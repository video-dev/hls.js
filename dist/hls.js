(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.Hls = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      } else {
        // At least give some kind of context to the user
        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
        err.context = er;
        throw err;
      }
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    args = Array.prototype.slice.call(arguments, 1);
    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else if (listeners) {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.prototype.listenerCount = function(type) {
  if (this._events) {
    var evlistener = this._events[type];

    if (isFunction(evlistener))
      return 1;
    else if (evlistener)
      return evlistener.length;
  }
  return 0;
};

EventEmitter.listenerCount = function(emitter, type) {
  return emitter.listenerCount(type);
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],2:[function(require,module,exports){
var bundleFn = arguments[3];
var sources = arguments[4];
var cache = arguments[5];

var stringify = JSON.stringify;

module.exports = function (fn, options) {
    var wkey;
    var cacheKeys = Object.keys(cache);

    for (var i = 0, l = cacheKeys.length; i < l; i++) {
        var key = cacheKeys[i];
        var exp = cache[key].exports;
        // Using babel as a transpiler to use esmodule, the export will always
        // be an object with the default export as a property of it. To ensure
        // the existing api and babel esmodule exports are both supported we
        // check for both
        if (exp === fn || exp && exp.default === fn) {
            wkey = key;
            break;
        }
    }

    if (!wkey) {
        wkey = Math.floor(Math.pow(16, 8) * Math.random()).toString(16);
        var wcache = {};
        for (var i = 0, l = cacheKeys.length; i < l; i++) {
            var key = cacheKeys[i];
            wcache[key] = key;
        }
        sources[wkey] = [
            Function(['require','module','exports'], '(' + fn + ')(self)'),
            wcache
        ];
    }
    var skey = Math.floor(Math.pow(16, 8) * Math.random()).toString(16);

    var scache = {}; scache[wkey] = wkey;
    sources[skey] = [
        Function(['require'], (
            // try to call default if defined to also support babel esmodule
            // exports
            'var f = require(' + stringify(wkey) + ');' +
            '(f.default ? f.default : f)(self);'
        )),
        scache
    ];

    var workerSources = {};
    resolveSources(skey);

    function resolveSources(key) {
        workerSources[key] = true;

        for (var depPath in sources[key][1]) {
            var depKey = sources[key][1][depPath];
            if (!workerSources[depKey]) {
                resolveSources(depKey);
            }
        }
    }

    var src = '(' + bundleFn + ')({'
        + Object.keys(workerSources).map(function (key) {
            return stringify(key) + ':['
                + sources[key][0]
                + ',' + stringify(sources[key][1]) + ']'
            ;
        }).join(',')
        + '},{},[' + stringify(skey) + '])'
    ;

    var URL = window.URL || window.webkitURL || window.mozURL || window.msURL;

    var blob = new Blob([src], { type: 'text/javascript' });
    if (options && options.bare) { return blob; }
    var workerUrl = URL.createObjectURL(blob);
    var worker = new Worker(workerUrl);
    worker.objectURL = workerUrl;
    return worker;
};

},{}],3:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _eventHandler = require('../event-handler');

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _bufferHelper = require('../helper/buffer-helper');

var _bufferHelper2 = _interopRequireDefault(_bufferHelper);

var _errors = require('../errors');

var _logger = require('../utils/logger');

var _ewmaBandwidthEstimator = require('./ewma-bandwidth-estimator');

var _ewmaBandwidthEstimator2 = _interopRequireDefault(_ewmaBandwidthEstimator);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * simple ABR Controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *  - compute next level based on last fragment bw heuristics
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *  - implement an abandon rules triggered if we have less than 2 frag buffered and if computed bw shows that we risk buffer stalling
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

var AbrController = function (_EventHandler) {
  _inherits(AbrController, _EventHandler);

  function AbrController(hls) {
    _classCallCheck(this, AbrController);

    var _this = _possibleConstructorReturn(this, (AbrController.__proto__ || Object.getPrototypeOf(AbrController)).call(this, hls, _events2.default.FRAG_LOADING, _events2.default.FRAG_LOADED, _events2.default.ERROR));

    _this.lastLoadedFragLevel = 0;
    _this._autoLevelCapping = -1;
    _this._nextAutoLevel = -1;
    _this.hls = hls;
    _this.onCheck = _this.abandonRulesCheck.bind(_this);
    return _this;
  }

  _createClass(AbrController, [{
    key: 'destroy',
    value: function destroy() {
      this.clearTimer();
      _eventHandler2.default.prototype.destroy.call(this);
    }
  }, {
    key: 'onFragLoading',
    value: function onFragLoading(data) {
      var frag = data.frag;
      if (frag.type === 'main') {
        if (!this.timer) {
          this.timer = setInterval(this.onCheck, 100);
        }
        // lazy init of bw Estimator, rationale is that we use different params for Live/VoD
        // so we need to wait for stream manifest / playlist type to instantiate it.
        if (!this.bwEstimator) {
          var hls = this.hls,
              level = data.frag.level,
              isLive = hls.levels[level].details.live,
              config = hls.config,
              ewmaFast = void 0,
              ewmaSlow = void 0;

          if (isLive) {
            ewmaFast = config.abrEwmaFastLive;
            ewmaSlow = config.abrEwmaSlowLive;
          } else {
            ewmaFast = config.abrEwmaFastVoD;
            ewmaSlow = config.abrEwmaSlowVoD;
          }
          this.bwEstimator = new _ewmaBandwidthEstimator2.default(hls, ewmaSlow, ewmaFast, config.abrEwmaDefaultEstimate);
        }
        this.fragCurrent = frag;
      }
    }
  }, {
    key: 'abandonRulesCheck',
    value: function abandonRulesCheck() {
      /*
        monitor fragment retrieval time...
        we compute expected time of arrival of the complete fragment.
        we compare it to expected time of buffer starvation
      */
      var hls = this.hls,
          v = hls.media,
          frag = this.fragCurrent,
          loader = frag.loader;

      // if loader has been destroyed or loading has been aborted, stop timer and return
      if (!loader || loader.stats && loader.stats.aborted) {
        _logger.logger.warn('frag loader destroy or aborted, disarm abandonRulesCheck');
        this.clearTimer();
        return;
      }
      var stats = loader.stats;
      /* only monitor frag retrieval time if
      (video not paused OR first fragment being loaded(ready state === HAVE_NOTHING = 0)) AND autoswitching enabled AND not lowest level (=> means that we have several levels) */
      if (v && (!v.paused && v.playbackRate !== 0 || !v.readyState) && frag.autoLevel && frag.level) {
        var requestDelay = performance.now() - stats.trequest,
            playbackRate = Math.abs(v.playbackRate);
        // monitor fragment load progress after half of expected fragment duration,to stabilize bitrate
        if (requestDelay > 500 * frag.duration / playbackRate) {
          var levels = hls.levels,
              loadRate = Math.max(1, stats.bw ? stats.bw / 8 : stats.loaded * 1000 / requestDelay),
              // byte/s; at least 1 byte/s to avoid division by zero
          // compute expected fragment length using frag duration and level bitrate. also ensure that expected len is gte than already loaded size
          expectedLen = stats.total ? stats.total : Math.max(stats.loaded, Math.round(frag.duration * levels[frag.level].bitrate / 8)),
              pos = v.currentTime,
              fragLoadedDelay = (expectedLen - stats.loaded) / loadRate,
              bufferStarvationDelay = (_bufferHelper2.default.bufferInfo(v, pos, hls.config.maxBufferHole).end - pos) / playbackRate;
          // consider emergency switch down only if we have less than 2 frag buffered AND
          // time to finish loading current fragment is bigger than buffer starvation delay
          // ie if we risk buffer starvation if bw does not increase quickly
          if (bufferStarvationDelay < 2 * frag.duration / playbackRate && fragLoadedDelay > bufferStarvationDelay) {
            var fragLevelNextLoadedDelay = void 0,
                nextLoadLevel = void 0;
            // lets iterate through lower level and try to find the biggest one that could avoid rebuffering
            // we start from current level - 1 and we step down , until we find a matching level
            for (nextLoadLevel = frag.level - 1; nextLoadLevel >= 0; nextLoadLevel--) {
              // compute time to load next fragment at lower level
              // 0.8 : consider only 80% of current bw to be conservative
              // 8 = bits per byte (bps/Bps)
              fragLevelNextLoadedDelay = frag.duration * levels[nextLoadLevel].bitrate / (8 * 0.8 * loadRate);
              _logger.logger.log('fragLoadedDelay/bufferStarvationDelay/fragLevelNextLoadedDelay[' + nextLoadLevel + '] :' + fragLoadedDelay.toFixed(1) + '/' + bufferStarvationDelay.toFixed(1) + '/' + fragLevelNextLoadedDelay.toFixed(1));
              if (fragLevelNextLoadedDelay < bufferStarvationDelay) {
                // we found a lower level that be rebuffering free with current estimated bw !
                break;
              }
            }
            // only emergency switch down if it takes less time to load new fragment at lowest level instead
            // of finishing loading current one ...
            if (fragLevelNextLoadedDelay < fragLoadedDelay) {
              // ensure nextLoadLevel is not negative
              nextLoadLevel = Math.max(0, nextLoadLevel);
              // force next load level in auto mode
              hls.nextLoadLevel = nextLoadLevel;
              // update bw estimate for this fragment before cancelling load (this will help reducing the bw)
              this.bwEstimator.sample(requestDelay, stats.loaded);
              // abort fragment loading ...
              _logger.logger.warn('loading too slow, abort fragment loading and switch to level ' + nextLoadLevel);
              //abort fragment loading
              frag.loader.abort();
              this.clearTimer();
              hls.trigger(_events2.default.FRAG_LOAD_EMERGENCY_ABORTED, { frag: frag, stats: stats });
            }
          }
        }
      }
    }
  }, {
    key: 'onFragLoaded',
    value: function onFragLoaded(data) {
      var frag = data.frag;
      if (frag.type === 'main') {
        var stats = data.stats;
        // only update stats on first frag loading
        // if same frag is loaded multiple times, it might be in browser cache, and loaded quickly
        // and leading to wrong bw estimation
        if (stats.aborted === undefined && frag.loadCounter === 1) {
          var fragLoadingDurationMs = stats.tload - stats.trequest;
          this.bwEstimator.sample(fragLoadingDurationMs, stats.loaded);
          // if fragment has been loaded to perform a bitrate test, (hls.startLevel = -1), store bitrate test delay duration
          if (frag.bitrateTest) {
            this.bitrateTestDelay = fragLoadingDurationMs / 1000;
          } else {
            this.bitrateTestDelay = 0;
          }
        }

        // stop monitoring bw once frag loaded
        this.clearTimer();
        // store level id after successful fragment load
        this.lastLoadedFragLevel = frag.level;
        // reset forced auto level value so that next level will be selected
        this._nextAutoLevel = -1;
      }
    }
  }, {
    key: 'onError',
    value: function onError(data) {
      // stop timer in case of frag loading error
      switch (data.details) {
        case _errors.ErrorDetails.FRAG_LOAD_ERROR:
        case _errors.ErrorDetails.FRAG_LOAD_TIMEOUT:
          this.clearTimer();
          break;
        default:
          break;
      }
    }
  }, {
    key: 'clearTimer',
    value: function clearTimer() {
      if (this.timer) {
        clearInterval(this.timer);
        this.timer = null;
      }
    }

    /** Return the capping/max level value that could be used by automatic level selection algorithm **/

  }, {
    key: 'findBestLevel',
    value: function findBestLevel(currentLevel, currentFragDuration, currentBw, maxAutoLevel, maxFetchDuration, bwFactor, bwUpFactor, levels) {
      for (var i = maxAutoLevel; i >= 0; i--) {
        var levelInfo = levels[i],
            levelDetails = levelInfo.details,
            avgDuration = levelDetails ? levelDetails.totalduration / levelDetails.fragments.length : currentFragDuration,
            adjustedbw = void 0;
        // follow algorithm captured from stagefright :
        // https://android.googlesource.com/platform/frameworks/av/+/master/media/libstagefright/httplive/LiveSession.cpp
        // Pick the highest bandwidth stream below or equal to estimated bandwidth.
        // consider only 80% of the available bandwidth, but if we are switching up,
        // be even more conservative (70%) to avoid overestimating and immediately
        // switching back.
        if (i <= currentLevel) {
          adjustedbw = bwFactor * currentBw;
        } else {
          adjustedbw = bwUpFactor * currentBw;
        }
        var bitrate = levels[i].bitrate,
            fetchDuration = bitrate * avgDuration / adjustedbw;

        _logger.logger.trace('level/adjustedbw/bitrate/avgDuration/maxFetchDuration/fetchDuration: ' + i + '/' + Math.round(adjustedbw) + '/' + bitrate + '/' + avgDuration + '/' + maxFetchDuration + '/' + fetchDuration);
        // if adjusted bw is greater than level bitrate AND
        if (adjustedbw > bitrate && (
        // fragment fetchDuration unknown or fragment fetchDuration less than max allowed fetch duration, then this level matches
        !fetchDuration || fetchDuration < maxFetchDuration)) {
          // as we are looping from highest to lowest, this will return the best achievable quality level
          return i;
        }
      }
      // not enough time budget even with quality level 0 ... rebuffering might happen
      return -1;
    }
  }, {
    key: 'autoLevelCapping',
    get: function get() {
      return this._autoLevelCapping;
    }

    /** set the capping/max level value that could be used by automatic level selection algorithm **/
    ,
    set: function set(newLevel) {
      this._autoLevelCapping = newLevel;
    }
  }, {
    key: 'nextAutoLevel',
    get: function get() {
      var nextAutoLevel = this._nextAutoLevel,
          bwEstimator = this.bwEstimator;
      // in case next auto level has been forced, and bw not available or not reliable
      if (nextAutoLevel !== -1 && (!bwEstimator || !bwEstimator.canEstimate())) {
        // cap next auto level by max auto level
        return Math.min(nextAutoLevel, this.maxAutoLevel);
      }
      // compute next level using ABR logic
      var nextABRAutoLevel = this.nextABRAutoLevel;
      if (nextAutoLevel !== -1) {
        // nextAutoLevel is defined, use it to cap ABR computed quality level
        nextABRAutoLevel = Math.min(nextAutoLevel, nextABRAutoLevel);
      }
      return nextABRAutoLevel;
    },
    set: function set(nextLevel) {
      this._nextAutoLevel = nextLevel;
    }
  }, {
    key: 'maxAutoLevel',
    get: function get() {
      var levels = this.hls.levels,
          autoLevelCapping = this._autoLevelCapping,
          maxAutoLevel;
      if (autoLevelCapping === -1 && levels && levels.length) {
        maxAutoLevel = levels.length - 1;
      } else {
        maxAutoLevel = autoLevelCapping;
      }
      return maxAutoLevel;
    }
  }, {
    key: 'nextABRAutoLevel',
    get: function get() {
      var hls = this.hls,
          maxAutoLevel = this.maxAutoLevel,
          levels = hls.levels,
          config = hls.config;
      var v = hls.media,
          currentLevel = this.lastLoadedFragLevel,
          currentFragDuration = this.fragCurrent ? this.fragCurrent.duration : 0,
          pos = v ? v.currentTime : 0,

      // playbackRate is the absolute value of the playback rate; if v.playbackRate is 0, we use 1 to load as
      // if we're playing back at the normal rate.
      playbackRate = v && v.playbackRate !== 0 ? Math.abs(v.playbackRate) : 1.0,
          avgbw = this.bwEstimator ? this.bwEstimator.getEstimate() : config.abrEwmaDefaultEstimate,

      // bufferStarvationDelay is the wall-clock time left until the playback buffer is exhausted.
      bufferStarvationDelay = (_bufferHelper2.default.bufferInfo(v, pos, config.maxBufferHole).end - pos) / playbackRate;

      // First, look to see if we can find a level matching with our avg bandwidth AND that could also guarantee no rebuffering at all
      var bestLevel = this.findBestLevel(currentLevel, currentFragDuration, avgbw, maxAutoLevel, bufferStarvationDelay, config.abrBandWidthFactor, config.abrBandWidthUpFactor, levels);
      if (bestLevel >= 0) {
        return bestLevel;
      } else {
        _logger.logger.trace('rebuffering expected to happen, lets try to find a quality level minimizing the rebuffering');
        // not possible to get rid of rebuffering ... let's try to find level that will guarantee less than maxStarvationDelay of rebuffering
        // if no matching level found, logic will return 0
        var maxStarvationDelay = config.maxStarvationDelay;
        if (bufferStarvationDelay === 0) {
          // in case buffer is empty, let's check if previous fragment was loaded to perform a bitrate test
          var bitrateTestDelay = this.bitrateTestDelay;
          if (bitrateTestDelay) {
            // if it is the case, then we need to decrease this bitrate test duration from our maxStarvationDelay.
            // rationale is that we need to account for this bitrate test duration
            maxStarvationDelay -= bitrateTestDelay;
            _logger.logger.trace('bitrate test took ' + Math.round(1000 * bitrateTestDelay) + 'ms, set first fragment max fetchDuration to ' + Math.round(1000 * maxStarvationDelay) + ' ms');
          }
        }
        bestLevel = this.findBestLevel(currentLevel, currentFragDuration, avgbw, maxAutoLevel, bufferStarvationDelay + maxStarvationDelay, config.abrBandWidthFactor, config.abrBandWidthUpFactor, levels);
        return Math.max(bestLevel, 0);
      }
    }
  }]);

  return AbrController;
}(_eventHandler2.default);

exports.default = AbrController;

},{"../errors":25,"../event-handler":26,"../events":27,"../helper/buffer-helper":29,"../utils/logger":44,"./ewma-bandwidth-estimator":8}],4:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _binarySearch = require('../utils/binary-search');

var _binarySearch2 = _interopRequireDefault(_binarySearch);

var _bufferHelper = require('../helper/buffer-helper');

var _bufferHelper2 = _interopRequireDefault(_bufferHelper);

var _demuxer = require('../demux/demuxer');

var _demuxer2 = _interopRequireDefault(_demuxer);

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _eventHandler = require('../event-handler');

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _levelHelper = require('../helper/level-helper');

var _levelHelper2 = _interopRequireDefault(_levelHelper);

var _timeRanges = require('../utils/timeRanges');

var _timeRanges2 = _interopRequireDefault(_timeRanges);

var _errors = require('../errors');

var _logger = require('../utils/logger');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Audio Stream Controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

var State = {
  STOPPED: 'STOPPED',
  STARTING: 'STARTING',
  IDLE: 'IDLE',
  PAUSED: 'PAUSED',
  KEY_LOADING: 'KEY_LOADING',
  FRAG_LOADING: 'FRAG_LOADING',
  FRAG_LOADING_WAITING_RETRY: 'FRAG_LOADING_WAITING_RETRY',
  WAITING_TRACK: 'WAITING_TRACK',
  PARSING: 'PARSING',
  PARSED: 'PARSED',
  ENDED: 'ENDED',
  ERROR: 'ERROR'
};

var AudioStreamController = function (_EventHandler) {
  _inherits(AudioStreamController, _EventHandler);

  function AudioStreamController(hls) {
    _classCallCheck(this, AudioStreamController);

    var _this = _possibleConstructorReturn(this, (AudioStreamController.__proto__ || Object.getPrototypeOf(AudioStreamController)).call(this, hls, _events2.default.MEDIA_ATTACHED, _events2.default.MEDIA_DETACHING, _events2.default.AUDIO_TRACKS_UPDATED, _events2.default.AUDIO_TRACK_SWITCH, _events2.default.AUDIO_TRACK_LOADED, _events2.default.KEY_LOADED, _events2.default.FRAG_LOADED, _events2.default.FRAG_PARSING_INIT_SEGMENT, _events2.default.FRAG_PARSING_DATA, _events2.default.FRAG_PARSED, _events2.default.ERROR, _events2.default.BUFFER_CREATED, _events2.default.BUFFER_APPENDED, _events2.default.BUFFER_FLUSHED));

    _this.config = hls.config;
    _this.audioCodecSwap = false;
    _this.ticks = 0;
    _this.ontick = _this.tick.bind(_this);
    return _this;
  }

  _createClass(AudioStreamController, [{
    key: 'destroy',
    value: function destroy() {
      this.stopLoad();
      if (this.timer) {
        clearInterval(this.timer);
        this.timer = null;
      }
      _eventHandler2.default.prototype.destroy.call(this);
      this.state = State.STOPPED;
    }
  }, {
    key: 'startLoad',
    value: function startLoad(startPosition) {
      if (this.tracks) {
        var media = this.media,
            lastCurrentTime = this.lastCurrentTime;
        this.stopLoad();
        if (!this.timer) {
          this.timer = setInterval(this.ontick, 100);
        }
        this.fragLoadError = 0;
        if (media && lastCurrentTime) {
          _logger.logger.log('configure startPosition @' + lastCurrentTime);
          this.state = State.IDLE;
        } else {
          this.lastCurrentTime = this.startPosition ? this.startPosition : startPosition;
          this.state = State.STARTING;
        }
        this.nextLoadPosition = this.startPosition = this.lastCurrentTime;
        this.tick();
      } else {
        this.startPosition = startPosition;
        this.state = State.STOPPED;
      }
    }
  }, {
    key: 'stopLoad',
    value: function stopLoad() {
      var frag = this.fragCurrent;
      if (frag) {
        if (frag.loader) {
          frag.loader.abort();
        }
        this.fragCurrent = null;
      }
      this.fragPrevious = null;
      if (this.demuxer) {
        this.demuxer.destroy();
        this.demuxer = null;
      }
      this.state = State.STOPPED;
    }
  }, {
    key: 'tick',
    value: function tick() {
      this.ticks++;
      if (this.ticks === 1) {
        this.doTick();
        if (this.ticks > 1) {
          setTimeout(this.tick, 1);
        }
        this.ticks = 0;
      }
    }
  }, {
    key: 'doTick',
    value: function doTick() {
      var pos,
          track,
          trackDetails,
          hls = this.hls,
          config = hls.config;
      //logger.log('audioStream:' + this.state);
      switch (this.state) {
        case State.ERROR:
        //don't do anything in error state to avoid breaking further ...
        case State.PAUSED:
          //don't do anything in paused state either ...
          break;
        case State.STARTING:
          this.state = State.WAITING_TRACK;
          this.loadedmetadata = false;
          break;
        case State.IDLE:
          // if video not attached AND
          // start fragment already requested OR start frag prefetch disable
          // exit loop
          // => if media not attached but start frag prefetch is enabled and start frag not requested yet, we will not exit loop
          if (!this.media && (this.startFragRequested || !config.startFragPrefetch)) {
            break;
          }
          // determine next candidate fragment to be loaded, based on current position and
          //  end of buffer position
          // if we have not yet loaded any fragment, start loading from start position
          if (this.loadedmetadata) {
            pos = this.media.currentTime;
          } else {
            pos = this.nextLoadPosition;
          }
          var media = this.mediaBuffer ? this.mediaBuffer : this.media;
          var bufferInfo = _bufferHelper2.default.bufferInfo(media, pos, config.maxBufferHole),
              bufferLen = bufferInfo.len,
              bufferEnd = bufferInfo.end,
              fragPrevious = this.fragPrevious,
              maxBufLen = config.maxMaxBufferLength;

          // if buffer length is less than maxBufLen try to load a new fragment
          if (bufferLen < maxBufLen && this.trackId < this.tracks.length) {
            trackDetails = this.tracks[this.trackId].details;
            // if track info not retrieved yet, switch state and wait for track retrieval
            if (typeof trackDetails === 'undefined') {
              this.state = State.WAITING_TRACK;
              break;
            }

            // we just got done loading the final fragment, check if we need to finalize media stream
            if (!trackDetails.live && fragPrevious && fragPrevious.sn === trackDetails.endSN) {
              // if we are not seeking or if we are seeking but everything (almost) til the end is buffered, let's signal eos
              // we don't compare exactly media.duration === bufferInfo.end as there could be some subtle media duration difference when switching
              // between different renditions. using half frag duration should help cope with these cases.
              if (!this.media.seeking || this.media.duration - bufferEnd < fragPrevious.duration / 2) {
                // Finalize the media stream
                this.hls.trigger(_events2.default.BUFFER_EOS, { type: 'audio' });
                this.state = State.ENDED;
                break;
              }
            }

            // find fragment index, contiguous with end of buffer position
            var fragments = trackDetails.fragments,
                fragLen = fragments.length,
                start = fragments[0].start,
                end = fragments[fragLen - 1].start + fragments[fragLen - 1].duration,
                frag = void 0;

            // if bufferEnd before start of playlist, load first fragment
            if (bufferEnd < start) {
              frag = fragments[0];
            } else {
              (function () {
                var foundFrag = void 0;
                var maxFragLookUpTolerance = config.maxFragLookUpTolerance;
                if (bufferEnd < end) {
                  if (bufferEnd > end - maxFragLookUpTolerance) {
                    maxFragLookUpTolerance = 0;
                  }
                  foundFrag = _binarySearch2.default.search(fragments, function (candidate) {
                    // offset should be within fragment boundary - config.maxFragLookUpTolerance
                    // this is to cope with situations like
                    // bufferEnd = 9.991
                    // frag[Ã˜] : [0,10]
                    // frag[1] : [10,20]
                    // bufferEnd is within frag[0] range ... although what we are expecting is to return frag[1] here
                    //              frag start               frag start+duration
                    //                  |-----------------------------|
                    //              <--->                         <--->
                    //  ...--------><-----------------------------><---------....
                    // previous frag         matching fragment         next frag
                    //  return -1             return 0                 return 1
                    //logger.log(`level/sn/start/end/bufEnd:${level}/${candidate.sn}/${candidate.start}/${(candidate.start+candidate.duration)}/${bufferEnd}`);
                    if (candidate.start + candidate.duration - maxFragLookUpTolerance <= bufferEnd) {
                      return 1;
                    } else if (candidate.start - maxFragLookUpTolerance > bufferEnd) {
                      return -1;
                    }
                    return 0;
                  });
                } else {
                  // reach end of playlist
                  foundFrag = fragments[fragLen - 1];
                }
                if (foundFrag) {
                  frag = foundFrag;
                  start = foundFrag.start;
                  //logger.log('find SN matching with pos:' +  bufferEnd + ':' + frag.sn);
                  if (fragPrevious && frag.level === fragPrevious.level && frag.sn === fragPrevious.sn) {
                    if (frag.sn < trackDetails.endSN) {
                      frag = fragments[frag.sn + 1 - trackDetails.startSN];
                      _logger.logger.log('SN just loaded, load next one: ' + frag.sn);
                    } else {
                      frag = null;
                    }
                  }
                }
              })();
            }
            if (frag) {
              //logger.log('      loading frag ' + i +',pos/bufEnd:' + pos.toFixed(3) + '/' + bufferEnd.toFixed(3));
              if (frag.decryptdata.uri != null && frag.decryptdata.key == null) {
                _logger.logger.log('Loading key for ' + frag.sn + ' of [' + trackDetails.startSN + ' ,' + trackDetails.endSN + '],track ' + this.trackId);
                this.state = State.KEY_LOADING;
                hls.trigger(_events2.default.KEY_LOADING, { frag: frag });
              } else {
                _logger.logger.log('Loading ' + frag.sn + ' of [' + trackDetails.startSN + ' ,' + trackDetails.endSN + '],track ' + this.trackId + ', currentTime:' + pos + ',bufferEnd:' + bufferEnd.toFixed(3));
                // ensure that we are not reloading the same fragments in loop ...
                if (this.fragLoadIdx !== undefined) {
                  this.fragLoadIdx++;
                } else {
                  this.fragLoadIdx = 0;
                }
                if (frag.loadCounter) {
                  frag.loadCounter++;
                  var maxThreshold = config.fragLoadingLoopThreshold;
                  // if this frag has already been loaded 3 times, and if it has been reloaded recently
                  if (frag.loadCounter > maxThreshold && Math.abs(this.fragLoadIdx - frag.loadIdx) < maxThreshold) {
                    hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.FRAG_LOOP_LOADING_ERROR, fatal: false, frag: frag });
                    return;
                  }
                } else {
                  frag.loadCounter = 1;
                }
                frag.loadIdx = this.fragLoadIdx;
                this.fragCurrent = frag;
                this.startFragRequested = true;
                hls.trigger(_events2.default.FRAG_LOADING, { frag: frag });
                this.state = State.FRAG_LOADING;
              }
            }
          }
          break;
        case State.WAITING_TRACK:
          track = this.tracks[this.trackId];
          // check if playlist is already loaded
          if (track && track.details) {
            this.state = State.IDLE;
          }
          break;
        case State.FRAG_LOADING_WAITING_RETRY:
          var now = performance.now();
          var retryDate = this.retryDate;
          media = this.media;
          var isSeeking = media && media.seeking;
          // if current time is gt than retryDate, or if media seeking let's switch to IDLE state to retry loading
          if (!retryDate || now >= retryDate || isSeeking) {
            _logger.logger.log('audioStreamController: retryDate reached, switch back to IDLE state');
            this.state = State.IDLE;
          }
          break;
        case State.STOPPED:
        case State.FRAG_LOADING:
        case State.PARSING:
        case State.PARSED:
        case State.ENDED:
          break;
        default:
          break;
      }
    }
  }, {
    key: 'onMediaAttached',
    value: function onMediaAttached(data) {
      var media = this.media = this.mediaBuffer = data.media;
      this.onvseeking = this.onMediaSeeking.bind(this);
      this.onvended = this.onMediaEnded.bind(this);
      media.addEventListener('seeking', this.onvseeking);
      media.addEventListener('ended', this.onvended);
      var config = this.config;
      if (this.tracks && config.autoStartLoad) {
        this.startLoad(config.startPosition);
      }
    }
  }, {
    key: 'onMediaDetaching',
    value: function onMediaDetaching() {
      var media = this.media;
      if (media && media.ended) {
        _logger.logger.log('MSE detaching and video ended, reset startPosition');
        this.startPosition = this.lastCurrentTime = 0;
      }

      // reset fragment loading counter on MSE detaching to avoid reporting FRAG_LOOP_LOADING_ERROR after error recovery
      var tracks = this.tracks;
      if (tracks) {
        // reset fragment load counter
        tracks.forEach(function (track) {
          if (track.details) {
            track.details.fragments.forEach(function (fragment) {
              fragment.loadCounter = undefined;
            });
          }
        });
      }
      // remove video listeners
      if (media) {
        media.removeEventListener('seeking', this.onvseeking);
        media.removeEventListener('ended', this.onvended);
        this.onvseeking = this.onvseeked = this.onvended = null;
      }
      this.media = null;
      this.loadedmetadata = false;
      this.stopLoad();
    }
  }, {
    key: 'onMediaSeeking',
    value: function onMediaSeeking() {
      if (this.state === State.ENDED) {
        // switch to IDLE state to check for potential new fragment
        this.state = State.IDLE;
      }
      if (this.media) {
        this.lastCurrentTime = this.media.currentTime;
      }
      // avoid reporting fragment loop loading error in case user is seeking several times on same position
      if (this.fragLoadIdx !== undefined) {
        this.fragLoadIdx += 2 * this.config.fragLoadingLoopThreshold;
      }
      // tick to speed up processing
      this.tick();
    }
  }, {
    key: 'onMediaEnded',
    value: function onMediaEnded() {
      // reset startPosition and lastCurrentTime to restart playback @ stream beginning
      this.startPosition = this.lastCurrentTime = 0;
    }
  }, {
    key: 'onAudioTracksUpdated',
    value: function onAudioTracksUpdated(data) {
      _logger.logger.log('audio tracks updated');
      this.tracks = data.audioTracks;
    }
  }, {
    key: 'onAudioTrackSwitch',
    value: function onAudioTrackSwitch(data) {
      // if any URL found on new audio track, it is an alternate audio track
      var altAudio = !!data.url;
      this.trackId = data.id;
      this.state = State.IDLE;

      this.fragCurrent = null;
      this.state = State.PAUSED;
      // destroy useless demuxer when switching audio to main
      if (!altAudio) {
        if (this.demuxer) {
          this.demuxer.destroy();
          this.demuxer = null;
        }
      } else {
        // switching to audio track, start timer if not already started
        if (!this.timer) {
          this.timer = setInterval(this.ontick, 100);
        }
      }
      // flush audio source buffer
      this.hls.trigger(_events2.default.BUFFER_FLUSHING, { startOffset: 0, endOffset: Number.POSITIVE_INFINITY, type: 'audio' });
      this.tick();
    }
  }, {
    key: 'onAudioTrackLoaded',
    value: function onAudioTrackLoaded(data) {
      var details = data.details,
          trackId = data.id,
          track = this.tracks[trackId],
          duration = details.totalduration;

      _logger.logger.log('track ' + trackId + ' loaded [' + details.startSN + ',' + details.endSN + '],duration:' + duration);
      details.PTSKnown = false;
      track.details = details;

      // compute start position
      if (!this.startFragRequested) {
        // compute start position if set to -1. use it straight away if value is defined
        if (this.startPosition === -1) {
          // first, check if start time offset has been set in playlist, if yes, use this value
          var startTimeOffset = details.startTimeOffset;
          if (!isNaN(startTimeOffset)) {
            _logger.logger.log('start time offset found in playlist, adjust startPosition to ' + startTimeOffset);
            this.startPosition = startTimeOffset;
          } else {
            this.startPosition = 0;
          }
        }
        this.nextLoadPosition = this.startPosition;
      }
      // only switch batck to IDLE state if we were waiting for track to start downloading a new fragment
      if (this.state === State.WAITING_TRACK) {
        this.state = State.IDLE;
      }
      //trigger handler right now
      this.tick();
    }
  }, {
    key: 'onKeyLoaded',
    value: function onKeyLoaded() {
      if (this.state === State.KEY_LOADING) {
        this.state = State.IDLE;
        this.tick();
      }
    }
  }, {
    key: 'onFragLoaded',
    value: function onFragLoaded(data) {
      var fragCurrent = this.fragCurrent;
      if (this.state === State.FRAG_LOADING && fragCurrent && data.frag.type === 'audio' && data.frag.level === fragCurrent.level && data.frag.sn === fragCurrent.sn) {
        this.state = State.PARSING;
        // transmux the MPEG-TS data to ISO-BMFF segments
        this.stats = data.stats;
        var track = this.tracks[this.trackId],
            details = track.details,
            duration = details.totalduration,
            start = fragCurrent.start,
            trackId = fragCurrent.level,
            sn = fragCurrent.sn,
            audioCodec = this.config.defaultAudioCodec || track.audioCodec;
        this.pendingAppending = 0;
        if (!this.demuxer) {
          this.demuxer = new _demuxer2.default(this.hls, 'audio');
        }
        _logger.logger.log('Demuxing ' + sn + ' of [' + details.startSN + ' ,' + details.endSN + '],track ' + trackId);
        // time Offset is accurate if level PTS is known, or if playlist is not sliding (not live)
        var accurateTimeOffset = details.PTSKnown || !details.live;
        this.demuxer.push(data.payload, audioCodec, null, start, fragCurrent.cc, trackId, sn, duration, fragCurrent.decryptdata, accurateTimeOffset);
      }
      this.fragLoadError = 0;
    }
  }, {
    key: 'onFragParsingInitSegment',
    value: function onFragParsingInitSegment(data) {
      var fragCurrent = this.fragCurrent;
      if (fragCurrent && data.id === 'audio' && data.sn === fragCurrent.sn && data.level === fragCurrent.level && this.state === State.PARSING) {
        var tracks = data.tracks,
            track = void 0;

        // include levelCodec in audio and video tracks
        track = tracks.audio;
        if (track) {
          track.levelCodec = 'mp4a.40.2';
          track.id = data.id;
          this.hls.trigger(_events2.default.BUFFER_CODECS, tracks);
          _logger.logger.log('audio track:audio,container:' + track.container + ',codecs[level/parsed]=[' + track.levelCodec + '/' + track.codec + ']');
          var initSegment = track.initSegment;
          if (initSegment) {
            this.pendingAppending++;
            this.hls.trigger(_events2.default.BUFFER_APPENDING, { type: 'audio', data: initSegment, parent: 'audio', content: 'initSegment' });
          }
          //trigger handler right now
          this.tick();
        }
      }
    }
  }, {
    key: 'onFragParsingData',
    value: function onFragParsingData(data) {
      var _this2 = this;

      var fragCurrent = this.fragCurrent;
      if (fragCurrent && data.id === 'audio' && data.sn === fragCurrent.sn && data.level === fragCurrent.level && this.state === State.PARSING) {
        var track = this.tracks[this.trackId],
            frag = this.fragCurrent;

        _logger.logger.log('parsed ' + data.type + ',PTS:[' + data.startPTS.toFixed(3) + ',' + data.endPTS.toFixed(3) + '],DTS:[' + data.startDTS.toFixed(3) + '/' + data.endDTS.toFixed(3) + '],nb:' + data.nb);
        _levelHelper2.default.updateFragPTSDTS(track.details, frag.sn, data.startPTS, data.endPTS);

        [data.data1, data.data2].forEach(function (buffer) {
          if (buffer) {
            _this2.pendingAppending++;
            _this2.hls.trigger(_events2.default.BUFFER_APPENDING, { type: data.type, data: buffer, parent: 'audio', content: 'data' });
          }
        });
        this.nextLoadPosition = data.endPTS;
        //trigger handler right now
        this.tick();
      }
    }
  }, {
    key: 'onFragParsed',
    value: function onFragParsed(data) {
      var fragCurrent = this.fragCurrent;
      if (fragCurrent && data.id === 'audio' && data.sn === fragCurrent.sn && data.level === fragCurrent.level && this.state === State.PARSING) {
        this.stats.tparsed = performance.now();
        this.state = State.PARSED;
        this._checkAppendedParsed();
      }
    }
  }, {
    key: 'onBufferCreated',
    value: function onBufferCreated(data) {
      var audioTrack = data.tracks.audio;
      if (audioTrack) {
        this.mediaBuffer = audioTrack.buffer;
        this.loadedmetadata = true;
      }
    }
  }, {
    key: 'onBufferAppended',
    value: function onBufferAppended(data) {
      if (data.parent === 'audio') {
        switch (this.state) {
          case State.PARSING:
          case State.PARSED:
            this.pendingAppending--;
            this._checkAppendedParsed();
            break;
          default:
            break;
        }
      }
    }
  }, {
    key: '_checkAppendedParsed',
    value: function _checkAppendedParsed() {
      //trigger handler right now
      if (this.state === State.PARSED && this.pendingAppending === 0) {
        var frag = this.fragCurrent,
            stats = this.stats;
        if (frag) {
          this.fragPrevious = frag;
          stats.tbuffered = performance.now();
          this.hls.trigger(_events2.default.FRAG_BUFFERED, { stats: stats, frag: frag, id: 'audio' });
          var media = this.mediaBuffer ? this.mediaBuffer : this.media;
          _logger.logger.log('audio buffered : ' + _timeRanges2.default.toString(media.buffered));
          this.state = State.IDLE;
        }
        this.tick();
      }
    }
  }, {
    key: 'onError',
    value: function onError(data) {
      var frag = data.frag;
      // don't handle frag error not related to audio fragment
      if (frag && frag.type !== 'audio') {
        return;
      }
      switch (data.details) {
        case _errors.ErrorDetails.FRAG_LOAD_ERROR:
        case _errors.ErrorDetails.FRAG_LOAD_TIMEOUT:
          if (!data.fatal) {
            var loadError = this.fragLoadError;
            if (loadError) {
              loadError++;
            } else {
              loadError = 1;
            }
            var config = this.config;
            if (loadError <= config.fragLoadingMaxRetry) {
              this.fragLoadError = loadError;
              // reset load counter to avoid frag loop loading error
              frag.loadCounter = 0;
              // exponential backoff capped to config.fragLoadingMaxRetryTimeout
              var delay = Math.min(Math.pow(2, loadError - 1) * config.fragLoadingRetryDelay, config.fragLoadingMaxRetryTimeout);
              _logger.logger.warn('audioStreamController: frag loading failed, retry in ' + delay + ' ms');
              this.retryDate = performance.now() + delay;
              // retry loading state
              this.state = State.FRAG_LOADING_WAITING_RETRY;
            } else {
              _logger.logger.error('audioStreamController: ' + data.details + ' reaches max retry, redispatch as fatal ...');
              // redispatch same error but with fatal set to true
              data.fatal = true;
              this.hls.trigger(_events2.default.ERROR, data);
              this.state = State.ERROR;
            }
          }
          break;
        case _errors.ErrorDetails.FRAG_LOOP_LOADING_ERROR:
        case _errors.ErrorDetails.AUDIO_TRACK_LOAD_ERROR:
        case _errors.ErrorDetails.AUDIO_TRACK_LOAD_TIMEOUT:
        case _errors.ErrorDetails.KEY_LOAD_ERROR:
        case _errors.ErrorDetails.KEY_LOAD_TIMEOUT:
          //  when in ERROR state, don't switch back to IDLE state in case a non-fatal error is received
          if (this.state !== State.ERROR) {
            // if fatal error, stop processing, otherwise move to IDLE to retry loading
            this.state = data.fatal ? State.ERROR : State.IDLE;
            _logger.logger.warn('audioStreamController: ' + data.details + ' while loading frag,switch to ' + this.state + ' state ...');
          }
          break;
        default:
          break;
      }
    }
  }, {
    key: 'onBufferFlushed',
    value: function onBufferFlushed() {
      // increase fragment load Index to avoid frag loop loading error after buffer flush
      this.fragLoadIdx += 2 * this.config.fragLoadingLoopThreshold;
      // move to IDLE once flush complete. this should trigger new fragment loading
      this.state = State.IDLE;
      // reset reference to frag
      this.fragPrevious = null;
      this.tick();
    }
  }]);

  return AudioStreamController;
}(_eventHandler2.default);

exports.default = AudioStreamController;

},{"../demux/demuxer":21,"../errors":25,"../event-handler":26,"../events":27,"../helper/buffer-helper":29,"../helper/level-helper":30,"../utils/binary-search":40,"../utils/logger":44,"../utils/timeRanges":46}],5:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _eventHandler = require('../event-handler');

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _logger = require('../utils/logger');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * audio track controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

var AudioTrackController = function (_EventHandler) {
  _inherits(AudioTrackController, _EventHandler);

  function AudioTrackController(hls) {
    _classCallCheck(this, AudioTrackController);

    return _possibleConstructorReturn(this, (AudioTrackController.__proto__ || Object.getPrototypeOf(AudioTrackController)).call(this, hls, _events2.default.MANIFEST_LOADING, _events2.default.MANIFEST_LOADED, _events2.default.AUDIO_TRACK_LOADED));
  }

  _createClass(AudioTrackController, [{
    key: 'destroy',
    value: function destroy() {
      _eventHandler2.default.prototype.destroy.call(this);
    }
  }, {
    key: 'onManifestLoading',
    value: function onManifestLoading() {
      // reset audio tracks on manifest loading
      this.tracks = [];
      this.trackId = -1;
    }
  }, {
    key: 'onManifestLoaded',
    value: function onManifestLoaded(data) {
      var _this2 = this;

      var tracks = data.audioTracks || [];
      var defaultFound = false;
      this.tracks = tracks;
      this.hls.trigger(_events2.default.AUDIO_TRACKS_UPDATED, { audioTracks: tracks });
      // loop through available audio tracks and autoselect default if needed
      var id = 0;
      tracks.forEach(function (track) {
        if (track.default) {
          _this2.audioTrack = id;
          defaultFound = true;
          return;
        }
        id++;
      });
      if (defaultFound === false && tracks.length) {
        _logger.logger.log('no default audio track defined, use first audio track as default');
        this.audioTrack = 0;
      }
    }
  }, {
    key: 'onAudioTrackLoaded',
    value: function onAudioTrackLoaded(data) {
      if (data.id < this.tracks.length) {
        _logger.logger.log('audioTrack ' + data.id + ' loaded');
        this.tracks[data.id].details = data.details;
        // check if current playlist is a live playlist
        if (data.details.live && !this.timer) {
          // if live playlist we will have to reload it periodically
          // set reload period to playlist target duration
          this.timer = setInterval(this.ontick, 1000 * data.details.targetduration);
        }
        if (!data.details.live && this.timer) {
          // playlist is not live and timer is armed : stopping it
          clearInterval(this.timer);
          this.timer = null;
        }
      }
    }

    /** get alternate audio tracks list from playlist **/

  }, {
    key: 'setAudioTrackInternal',
    value: function setAudioTrackInternal(newId) {
      // check if level idx is valid
      if (newId >= 0 && newId < this.tracks.length) {
        // stopping live reloading timer if any
        if (this.timer) {
          clearInterval(this.timer);
          this.timer = null;
        }
        this.trackId = newId;
        _logger.logger.log('switching to audioTrack ' + newId);
        var audioTrack = this.tracks[newId],
            type = audioTrack.type,
            url = audioTrack.url;
        this.hls.trigger(_events2.default.AUDIO_TRACK_SWITCH, { id: newId, type: type, url: url });
        // check if we need to load playlist for this audio Track
        var details = audioTrack.details;
        if (url && (details === undefined || details.live === true)) {
          // track not retrieved yet, or live playlist we need to (re)load it
          _logger.logger.log('(re)loading playlist for audioTrack ' + newId);
          this.hls.trigger(_events2.default.AUDIO_TRACK_LOADING, { url: url, id: newId });
        }
      }
    }
  }, {
    key: 'audioTracks',
    get: function get() {
      return this.tracks;
    }

    /** get index of the selected audio track (index in audio track lists) **/

  }, {
    key: 'audioTrack',
    get: function get() {
      return this.trackId;
    }

    /** select an audio track, based on its index in audio track lists**/
    ,
    set: function set(audioTrackId) {
      if (this.trackId !== audioTrackId || this.tracks[audioTrackId].details === undefined) {
        this.setAudioTrackInternal(audioTrackId);
      }
    }
  }]);

  return AudioTrackController;
}(_eventHandler2.default);

exports.default = AudioTrackController;

},{"../event-handler":26,"../events":27,"../utils/logger":44}],6:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _eventHandler = require('../event-handler');

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _logger = require('../utils/logger');

var _errors = require('../errors');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Buffer Controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

var BufferController = function (_EventHandler) {
  _inherits(BufferController, _EventHandler);

  function BufferController(hls) {
    _classCallCheck(this, BufferController);

    // the value that we have set mediasource.duration to
    // (the actual duration may be tweaked slighly by the browser)
    var _this = _possibleConstructorReturn(this, (BufferController.__proto__ || Object.getPrototypeOf(BufferController)).call(this, hls, _events2.default.MEDIA_ATTACHING, _events2.default.MEDIA_DETACHING, _events2.default.MANIFEST_PARSED, _events2.default.BUFFER_RESET, _events2.default.BUFFER_APPENDING, _events2.default.BUFFER_CODECS, _events2.default.BUFFER_EOS, _events2.default.BUFFER_FLUSHING, _events2.default.LEVEL_UPDATED));

    _this._msDuration = null;
    // the value that we want to set mediaSource.duration to
    _this._levelDuration = null;

    // Source Buffer listeners
    _this.onsbue = _this.onSBUpdateEnd.bind(_this);
    _this.onsbe = _this.onSBUpdateError.bind(_this);
    _this.pendingTracks = {};
    return _this;
  }

  _createClass(BufferController, [{
    key: 'destroy',
    value: function destroy() {
      _eventHandler2.default.prototype.destroy.call(this);
    }
  }, {
    key: 'onManifestParsed',
    value: function onManifestParsed(data) {
      var audioExpected = data.audio,
          videoExpected = data.video,
          sourceBufferNb = 0;
      if (audioExpected || videoExpected) {
        sourceBufferNb = (audioExpected ? 1 : 0) + (videoExpected ? 1 : 0);
        _logger.logger.log(sourceBufferNb + ' sourceBuffer(s) expected');
      }
      this.sourceBufferNb = sourceBufferNb;
    }
  }, {
    key: 'onMediaAttaching',
    value: function onMediaAttaching(data) {
      var media = this.media = data.media;
      if (media) {
        // setup the media source
        var ms = this.mediaSource = new MediaSource();
        //Media Source listeners
        this.onmso = this.onMediaSourceOpen.bind(this);
        this.onmse = this.onMediaSourceEnded.bind(this);
        this.onmsc = this.onMediaSourceClose.bind(this);
        ms.addEventListener('sourceopen', this.onmso);
        ms.addEventListener('sourceended', this.onmse);
        ms.addEventListener('sourceclose', this.onmsc);
        // link video and media Source
        media.src = URL.createObjectURL(ms);
      }
    }
  }, {
    key: 'onMediaDetaching',
    value: function onMediaDetaching() {
      _logger.logger.log('media source detaching');
      var ms = this.mediaSource;
      if (ms) {
        if (ms.readyState === 'open') {
          try {
            // endOfStream could trigger exception if any sourcebuffer is in updating state
            // we don't really care about checking sourcebuffer state here,
            // as we are anyway detaching the MediaSource
            // let's just avoid this exception to propagate
            ms.endOfStream();
          } catch (err) {
            _logger.logger.warn('onMediaDetaching:' + err.message + ' while calling endOfStream');
          }
        }
        ms.removeEventListener('sourceopen', this.onmso);
        ms.removeEventListener('sourceended', this.onmse);
        ms.removeEventListener('sourceclose', this.onmsc);

        // Detach properly the MediaSource from the HTMLMediaElement as
        // suggested in https://github.com/w3c/media-source/issues/53.
        if (this.media) {
          this.media.removeAttribute('src');
          this.media.load();
        }

        this.mediaSource = null;
        this.media = null;
        this.pendingTracks = {};
        this.sourceBuffer = {};
        this.flushRange = [];
        this.segments = [];
        this.appended = 0;
      }
      this.onmso = this.onmse = this.onmsc = null;
      this.hls.trigger(_events2.default.MEDIA_DETACHED);
    }
  }, {
    key: 'onMediaSourceOpen',
    value: function onMediaSourceOpen() {
      _logger.logger.log('media source opened');
      this.hls.trigger(_events2.default.MEDIA_ATTACHED, { media: this.media });
      var mediaSource = this.mediaSource;
      if (mediaSource) {
        // once received, don't listen anymore to sourceopen event
        mediaSource.removeEventListener('sourceopen', this.onmso);
      }
      this.checkPendingTracks();
    }
  }, {
    key: 'checkPendingTracks',
    value: function checkPendingTracks() {
      // if any buffer codecs pending, check if we have enough to create sourceBuffers
      var pendingTracks = this.pendingTracks,
          pendingTracksNb = Object.keys(pendingTracks).length;
      // if any pending tracks and (if nb of pending tracks matching expected nb or if unknoown expected nb)
      if (pendingTracksNb && (this.sourceBufferNb === pendingTracksNb || this.sourceBufferNb === 0)) {
        // ok, let's create them now !
        this.createSourceBuffers(pendingTracks);
        this.pendingTracks = {};
        // append any pending segments now !
        this.doAppending();
      }
    }
  }, {
    key: 'onMediaSourceClose',
    value: function onMediaSourceClose() {
      _logger.logger.log('media source closed');
    }
  }, {
    key: 'onMediaSourceEnded',
    value: function onMediaSourceEnded() {
      _logger.logger.log('media source ended');
    }
  }, {
    key: 'onSBUpdateEnd',
    value: function onSBUpdateEnd() {

      if (this._needsFlush) {
        this.doFlush();
      }

      if (this._needsEos) {
        this.checkEos();
      }
      this.appending = false;
      this.hls.trigger(_events2.default.BUFFER_APPENDED, { parent: this.parent });

      // don't append in flushing mode
      if (!this._needsFlush) {
        this.doAppending();
      }

      this.updateMediaElementDuration();
    }
  }, {
    key: 'onSBUpdateError',
    value: function onSBUpdateError(event) {
      _logger.logger.error('sourceBuffer error:' + event);
      // according to http://www.w3.org/TR/media-source/#sourcebuffer-append-error
      // this error might not always be fatal (it is fatal if decode error is set, in that case
      // it will be followed by a mediaElement error ...)
      this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.BUFFER_APPENDING_ERROR, fatal: false });
      // we don't need to do more than that, as accordin to the spec, updateend will be fired just after
    }
  }, {
    key: 'onBufferReset',
    value: function onBufferReset() {
      var sourceBuffer = this.sourceBuffer;
      for (var type in sourceBuffer) {
        var sb = sourceBuffer[type];
        try {
          this.mediaSource.removeSourceBuffer(sb);
          sb.removeEventListener('updateend', this.onsbue);
          sb.removeEventListener('error', this.onsbe);
        } catch (err) {}
      }
      this.sourceBuffer = {};
      this.flushRange = [];
      this.segments = [];
      this.appended = 0;
    }
  }, {
    key: 'onBufferCodecs',
    value: function onBufferCodecs(tracks) {
      // if source buffer(s) not created yet, appended buffer tracks in this.pendingTracks
      // if sourcebuffers already created, do nothing ...
      if (Object.keys(this.sourceBuffer).length === 0) {
        for (var trackName in tracks) {
          this.pendingTracks[trackName] = tracks[trackName];
        }
        var mediaSource = this.mediaSource;
        if (mediaSource && mediaSource.readyState === 'open') {
          // try to create sourcebuffers if mediasource opened
          this.checkPendingTracks();
        }
      }
    }
  }, {
    key: 'createSourceBuffers',
    value: function createSourceBuffers(tracks) {
      var sourceBuffer = this.sourceBuffer,
          mediaSource = this.mediaSource;

      for (var trackName in tracks) {
        if (!sourceBuffer[trackName]) {
          var track = tracks[trackName];
          // use levelCodec as first priority
          var codec = track.levelCodec || track.codec;
          var mimeType = track.container + ';codecs=' + codec;
          _logger.logger.log('creating sourceBuffer with mimeType:' + mimeType);
          try {
            var sb = sourceBuffer[trackName] = mediaSource.addSourceBuffer(mimeType);
            sb.addEventListener('updateend', this.onsbue);
            sb.addEventListener('error', this.onsbe);
            track.buffer = sb;
          } catch (err) {
            _logger.logger.error('error while trying to add sourceBuffer:' + err.message);
            this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.BUFFER_ADD_CODEC_ERROR, fatal: false, err: err, mimeType: mimeType });
          }
        }
      }
      this.hls.trigger(_events2.default.BUFFER_CREATED, { tracks: tracks });
    }
  }, {
    key: 'onBufferAppending',
    value: function onBufferAppending(data) {
      if (!this._needsFlush) {
        if (!this.segments) {
          this.segments = [data];
        } else {
          this.segments.push(data);
        }
        this.doAppending();
      }
    }
  }, {
    key: 'onBufferAppendFail',
    value: function onBufferAppendFail(data) {
      _logger.logger.error('sourceBuffer error:' + data.event);
      // according to http://www.w3.org/TR/media-source/#sourcebuffer-append-error
      // this error might not always be fatal (it is fatal if decode error is set, in that case
      // it will be followed by a mediaElement error ...)
      this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.BUFFER_APPENDING_ERROR, fatal: false, frag: this.fragCurrent });
    }

    // on BUFFER_EOS mark matching sourcebuffer(s) as ended and trigger checkEos()

  }, {
    key: 'onBufferEos',
    value: function onBufferEos(data) {
      var sb = this.sourceBuffer;
      var dataType = data.type;
      for (var type in sb) {
        if (!dataType || type === dataType) {
          if (!sb[type].ended) {
            sb[type].ended = true;
            _logger.logger.log(type + ' sourceBuffer now EOS');
          }
        }
      }
      this.checkEos();
    }

    // if all source buffers are marked as ended, signal endOfStream() to MediaSource.

  }, {
    key: 'checkEos',
    value: function checkEos() {
      var sb = this.sourceBuffer,
          mediaSource = this.mediaSource;
      if (!mediaSource || mediaSource.readyState !== 'open') {
        this._needsEos = false;
        return;
      }
      for (var type in sb) {
        if (!sb[type].ended) {
          return;
        }
        if (sb[type].updating) {
          this._needsEos = true;
          return;
        }
      }
      _logger.logger.log('all media data available, signal endOfStream() to MediaSource and stop loading fragment');
      //Notify the media element that it now has all of the media data
      mediaSource.endOfStream();
      this._needsEos = false;
    }
  }, {
    key: 'onBufferFlushing',
    value: function onBufferFlushing(data) {
      this.flushRange.push({ start: data.startOffset, end: data.endOffset, type: data.type });
      // attempt flush immediatly
      this.flushBufferCounter = 0;
      this.doFlush();
    }
  }, {
    key: 'onLevelUpdated',
    value: function onLevelUpdated(event) {
      var details = event.details;
      if (details.fragments.length === 0) {
        return;
      }
      this._levelDuration = details.totalduration + details.fragments[0].start;
      this.updateMediaElementDuration();
    }

    // https://github.com/dailymotion/hls.js/issues/355

  }, {
    key: 'updateMediaElementDuration',
    value: function updateMediaElementDuration() {
      if (this._levelDuration === null) {
        return;
      }
      var media = this.media,
          mediaSource = this.mediaSource,
          sourceBuffer = this.sourceBuffer;
      if (!media || !mediaSource || !sourceBuffer || media.readyState === 0 || mediaSource.readyState !== 'open') {
        return;
      }
      for (var type in sourceBuffer) {
        if (sourceBuffer[type].updating) {
          // can't set duration whilst a buffer is updating
          return;
        }
      }
      if (this._msDuration === null) {
        // initialise to the value that the media source is reporting
        this._msDuration = mediaSource.duration;
      }
      // this._levelDuration was the last value we set.
      // not using mediaSource.duration as the browser may tweak this value
      // only update mediasource duration if its value increase, this is to avoid
      // flushing already buffered portion when switching between quality level, as they
      if (this._levelDuration > this._msDuration) {
        _logger.logger.log('Updating mediasource duration to ' + this._levelDuration);
        mediaSource.duration = this._levelDuration;
        this._msDuration = this._levelDuration;
      }
    }
  }, {
    key: 'doFlush',
    value: function doFlush() {
      // loop through all buffer ranges to flush
      while (this.flushRange.length) {
        var range = this.flushRange[0];
        // flushBuffer will abort any buffer append in progress and flush Audio/Video Buffer
        if (this.flushBuffer(range.start, range.end, range.type)) {
          // range flushed, remove from flush array
          this.flushRange.shift();
          this.flushBufferCounter = 0;
        } else {
          this._needsFlush = true;
          // avoid looping, wait for SB update end to retrigger a flush
          return;
        }
      }
      if (this.flushRange.length === 0) {
        // everything flushed
        this._needsFlush = false;

        // let's recompute this.appended, which is used to avoid flush looping
        var appended = 0;
        var sourceBuffer = this.sourceBuffer;
        for (var type in sourceBuffer) {
          appended += sourceBuffer[type].buffered.length;
        }
        this.appended = appended;
        this.hls.trigger(_events2.default.BUFFER_FLUSHED);
      }
    }
  }, {
    key: 'doAppending',
    value: function doAppending() {
      var hls = this.hls,
          sourceBuffer = this.sourceBuffer,
          segments = this.segments;
      if (Object.keys(sourceBuffer).length) {
        if (this.media.error) {
          this.segments = [];
          _logger.logger.error('trying to append although a media error occured, flush segment and abort');
          return;
        }
        if (this.appending) {
          //logger.log(`sb appending in progress`);
          return;
        }
        if (segments && segments.length) {
          var segment = segments.shift();
          try {
            var type = segment.type;
            if (sourceBuffer[type]) {
              // reset sourceBuffer ended flag before appending segment
              sourceBuffer[type].ended = false;
              //logger.log(`appending ${segment.content} ${segment.type} SB, size:${segment.data.length}, ${segment.parent}`);
              this.parent = segment.parent;
              sourceBuffer[type].appendBuffer(segment.data);
              this.appendError = 0;
              this.appended++;
              this.appending = true;
            } else {
              // in case we don't have any source buffer matching with this segment type,
              // it means that Mediasource fails to create sourcebuffer
              // discard this segment, and trigger update end
              this.onSBUpdateEnd();
            }
          } catch (err) {
            // in case any error occured while appending, put back segment in segments table
            _logger.logger.error('error while trying to append buffer:' + err.message);
            segments.unshift(segment);
            var event = { type: _errors.ErrorTypes.MEDIA_ERROR };
            if (err.code !== 22) {
              if (this.appendError) {
                this.appendError++;
              } else {
                this.appendError = 1;
              }
              event.details = _errors.ErrorDetails.BUFFER_APPEND_ERROR;
              event.frag = this.fragCurrent;
              /* with UHD content, we could get loop of quota exceeded error until
                browser is able to evict some data from sourcebuffer. retrying help recovering this
              */
              if (this.appendError > hls.config.appendErrorMaxRetry) {
                _logger.logger.log('fail ' + hls.config.appendErrorMaxRetry + ' times to append segment in sourceBuffer');
                segments = [];
                event.fatal = true;
                hls.trigger(_events2.default.ERROR, event);
                return;
              } else {
                event.fatal = false;
                hls.trigger(_events2.default.ERROR, event);
              }
            } else {
              // QuotaExceededError: http://www.w3.org/TR/html5/infrastructure.html#quotaexceedederror
              // let's stop appending any segments, and report BUFFER_FULL_ERROR error
              this.segments = [];
              event.details = _errors.ErrorDetails.BUFFER_FULL_ERROR;
              hls.trigger(_events2.default.ERROR, event);
              return;
            }
          }
        }
      }
    }

    /*
      flush specified buffered range,
      return true once range has been flushed.
      as sourceBuffer.remove() is asynchronous, flushBuffer will be retriggered on sourceBuffer update end
    */

  }, {
    key: 'flushBuffer',
    value: function flushBuffer(startOffset, endOffset, typeIn) {
      var sb,
          i,
          bufStart,
          bufEnd,
          flushStart,
          flushEnd,
          sourceBuffer = this.sourceBuffer;
      if (Object.keys(sourceBuffer).length) {
        _logger.logger.log('flushBuffer,pos/start/end: ' + this.media.currentTime + '/' + startOffset + '/' + endOffset);
        // safeguard to avoid infinite looping : don't try to flush more than the nb of appended segments
        if (this.flushBufferCounter < this.appended) {
          for (var type in sourceBuffer) {
            // check if sourcebuffer type is defined (typeIn): if yes, let's only flush this one
            // if no, let's flush all sourcebuffers
            if (typeIn && type !== typeIn) {
              continue;
            }
            sb = sourceBuffer[type];
            // we are going to flush buffer, mark source buffer as 'not ended'
            sb.ended = false;
            if (!sb.updating) {
              for (i = 0; i < sb.buffered.length; i++) {
                bufStart = sb.buffered.start(i);
                bufEnd = sb.buffered.end(i);
                // workaround firefox not able to properly flush multiple buffered range.
                if (navigator.userAgent.toLowerCase().indexOf('firefox') !== -1 && endOffset === Number.POSITIVE_INFINITY) {
                  flushStart = startOffset;
                  flushEnd = endOffset;
                } else {
                  flushStart = Math.max(bufStart, startOffset);
                  flushEnd = Math.min(bufEnd, endOffset);
                }
                /* sometimes sourcebuffer.remove() does not flush
                   the exact expected time range.
                   to avoid rounding issues/infinite loop,
                   only flush buffer range of length greater than 500ms.
                */
                if (Math.min(flushEnd, bufEnd) - flushStart > 0.5) {
                  this.flushBufferCounter++;
                  _logger.logger.log('flush ' + type + ' [' + flushStart + ',' + flushEnd + '], of [' + bufStart + ',' + bufEnd + '], pos:' + this.media.currentTime);
                  sb.remove(flushStart, flushEnd);
                  return false;
                }
              }
            } else {
              //logger.log('abort ' + type + ' append in progress');
              // this will abort any appending in progress
              //sb.abort();
              _logger.logger.warn('cannot flush, sb updating in progress');
              return false;
            }
          }
        } else {
          _logger.logger.warn('abort flushing too many retries');
        }
        _logger.logger.log('buffer flushed');
      }
      // everything flushed !
      return true;
    }
  }]);

  return BufferController;
}(_eventHandler2.default);

exports.default = BufferController;

},{"../errors":25,"../event-handler":26,"../events":27,"../utils/logger":44}],7:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _eventHandler = require('../event-handler');

var _eventHandler2 = _interopRequireDefault(_eventHandler);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * cap stream level to media size dimension controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

var CapLevelController = function (_EventHandler) {
  _inherits(CapLevelController, _EventHandler);

  function CapLevelController(hls) {
    _classCallCheck(this, CapLevelController);

    return _possibleConstructorReturn(this, (CapLevelController.__proto__ || Object.getPrototypeOf(CapLevelController)).call(this, hls, _events2.default.FPS_DROP_LEVEL_CAPPING, _events2.default.MEDIA_ATTACHING, _events2.default.MANIFEST_PARSED));
  }

  _createClass(CapLevelController, [{
    key: 'destroy',
    value: function destroy() {
      if (this.hls.config.capLevelToPlayerSize) {
        this.media = this.restrictedLevels = null;
        this.autoLevelCapping = Number.POSITIVE_INFINITY;
        if (this.timer) {
          this.timer = clearInterval(this.timer);
        }
      }
    }
  }, {
    key: 'onFpsDropLevelCapping',
    value: function onFpsDropLevelCapping(data) {
      if (!this.restrictedLevels) {
        this.restrictedLevels = [];
      }
      if (!this.isLevelRestricted(data.droppedLevel)) {
        this.restrictedLevels.push(data.droppedLevel);
      }
    }
  }, {
    key: 'onMediaAttaching',
    value: function onMediaAttaching(data) {
      this.media = data.media instanceof HTMLVideoElement ? data.media : null;
    }
  }, {
    key: 'onManifestParsed',
    value: function onManifestParsed(data) {
      if (this.hls.config.capLevelToPlayerSize) {
        this.autoLevelCapping = Number.POSITIVE_INFINITY;
        this.levels = data.levels;
        this.hls.firstLevel = this.getMaxLevel(data.firstLevel);
        clearInterval(this.timer);
        this.timer = setInterval(this.detectPlayerSize.bind(this), 1000);
        this.detectPlayerSize();
      }
    }
  }, {
    key: 'detectPlayerSize',
    value: function detectPlayerSize() {
      if (this.media) {
        var levelsLength = this.levels ? this.levels.length : 0;
        if (levelsLength) {
          this.hls.autoLevelCapping = this.getMaxLevel(levelsLength - 1);
          if (this.hls.autoLevelCapping > this.autoLevelCapping) {
            // if auto level capping has a higher value for the previous one, flush the buffer using nextLevelSwitch
            // usually happen when the user go to the fullscreen mode.
            this.hls.streamController.nextLevelSwitch();
          }
          this.autoLevelCapping = this.hls.autoLevelCapping;
        }
      }
    }

    /*
    * returns level should be the one with the dimensions equal or greater than the media (player) dimensions (so the video will be downscaled)
    */

  }, {
    key: 'getMaxLevel',
    value: function getMaxLevel(capLevelIndex) {
      var result = 0,
          i = void 0,
          level = void 0,
          mWidth = this.mediaWidth,
          mHeight = this.mediaHeight,
          lWidth = 0,
          lHeight = 0;

      for (i = 0; i <= capLevelIndex; i++) {
        level = this.levels[i];
        if (this.isLevelRestricted(i)) {
          break;
        }
        result = i;
        lWidth = level.width;
        lHeight = level.height;
        if (mWidth <= lWidth || mHeight <= lHeight) {
          break;
        }
      }
      return result;
    }
  }, {
    key: 'isLevelRestricted',
    value: function isLevelRestricted(level) {
      return this.restrictedLevels && this.restrictedLevels.indexOf(level) !== -1 ? true : false;
    }
  }, {
    key: 'contentScaleFactor',
    get: function get() {
      var pixelRatio = 1;
      try {
        pixelRatio = window.devicePixelRatio;
      } catch (e) {}
      return pixelRatio;
    }
  }, {
    key: 'mediaWidth',
    get: function get() {
      var width = void 0;
      if (this.media) {
        width = this.media.width || this.media.clientWidth || this.media.offsetWidth;
        width *= this.contentScaleFactor;
      }
      return width;
    }
  }, {
    key: 'mediaHeight',
    get: function get() {
      var height = void 0;
      if (this.media) {
        height = this.media.height || this.media.clientHeight || this.media.offsetHeight;
        height *= this.contentScaleFactor;
      }
      return height;
    }
  }]);

  return CapLevelController;
}(_eventHandler2.default);

exports.default = CapLevelController;

},{"../event-handler":26,"../events":27}],8:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * EWMA Bandwidth Estimator
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *  - heavily inspired from shaka-player
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Tracks bandwidth samples and estimates available bandwidth.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Based on the minimum of two exponentially-weighted moving averages with
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * different half-lives.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */

var _ewma = require('../utils/ewma');

var _ewma2 = _interopRequireDefault(_ewma);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var EwmaBandWidthEstimator = function () {
  function EwmaBandWidthEstimator(hls, slow, fast, defaultEstimate) {
    _classCallCheck(this, EwmaBandWidthEstimator);

    this.hls = hls;
    this.defaultEstimate_ = defaultEstimate;
    this.minWeight_ = 0.001;
    this.minDelayMs_ = 50;
    this.slow_ = new _ewma2.default(slow);
    this.fast_ = new _ewma2.default(fast);
  }

  _createClass(EwmaBandWidthEstimator, [{
    key: 'sample',
    value: function sample(durationMs, numBytes) {
      durationMs = Math.max(durationMs, this.minDelayMs_);
      var bandwidth = 8000 * numBytes / durationMs,

      //console.log('instant bw:'+ Math.round(bandwidth));
      // we weight sample using loading duration....
      weight = durationMs / 1000;
      this.fast_.sample(weight, bandwidth);
      this.slow_.sample(weight, bandwidth);
    }
  }, {
    key: 'canEstimate',
    value: function canEstimate() {
      var fast = this.fast_;
      return fast && fast.getTotalWeight() >= this.minWeight_;
    }
  }, {
    key: 'getEstimate',
    value: function getEstimate() {
      if (this.canEstimate()) {
        //console.log('slow estimate:'+ Math.round(this.slow_.getEstimate()));
        //console.log('fast estimate:'+ Math.round(this.fast_.getEstimate()));
        // Take the minimum of these two estimates.  This should have the effect of
        // adapting down quickly, but up more slowly.
        return Math.min(this.fast_.getEstimate(), this.slow_.getEstimate());
      } else {
        return this.defaultEstimate_;
      }
    }
  }, {
    key: 'destroy',
    value: function destroy() {}
  }]);

  return EwmaBandWidthEstimator;
}();

exports.default = EwmaBandWidthEstimator;

},{"../utils/ewma":43}],9:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _eventHandler = require('../event-handler');

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _logger = require('../utils/logger');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * FPS Controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

var FPSController = function (_EventHandler) {
  _inherits(FPSController, _EventHandler);

  function FPSController(hls) {
    _classCallCheck(this, FPSController);

    return _possibleConstructorReturn(this, (FPSController.__proto__ || Object.getPrototypeOf(FPSController)).call(this, hls, _events2.default.MEDIA_ATTACHING));
  }

  _createClass(FPSController, [{
    key: 'destroy',
    value: function destroy() {
      if (this.timer) {
        clearInterval(this.timer);
      }
      this.isVideoPlaybackQualityAvailable = false;
    }
  }, {
    key: 'onMediaAttaching',
    value: function onMediaAttaching(data) {
      if (this.hls.config.capLevelOnFPSDrop) {
        this.video = data.media instanceof HTMLVideoElement ? data.media : null;
        if (typeof this.video.getVideoPlaybackQuality === 'function') {
          this.isVideoPlaybackQualityAvailable = true;
        }
        clearInterval(this.timer);
        this.timer = setInterval(this.checkFPSInterval.bind(this), this.hls.config.fpsDroppedMonitoringPeriod);
      }
    }
  }, {
    key: 'checkFPS',
    value: function checkFPS(video, decodedFrames, droppedFrames) {
      var currentTime = performance.now();
      if (decodedFrames) {
        if (this.lastTime) {
          var currentPeriod = currentTime - this.lastTime,
              currentDropped = droppedFrames - this.lastDroppedFrames,
              currentDecoded = decodedFrames - this.lastDecodedFrames,
              droppedFPS = 1000 * currentDropped / currentPeriod;
          this.hls.trigger(_events2.default.FPS_DROP, { currentDropped: currentDropped, currentDecoded: currentDecoded, totalDroppedFrames: droppedFrames });
          if (droppedFPS > 0) {
            //logger.log('checkFPS : droppedFPS/decodedFPS:' + droppedFPS/(1000 * currentDecoded / currentPeriod));
            if (currentDropped > this.hls.config.fpsDroppedMonitoringThreshold * currentDecoded) {
              var currentLevel = this.hls.currentLevel;
              _logger.logger.warn('drop FPS ratio greater than max allowed value for currentLevel: ' + currentLevel);
              if (currentLevel > 0 && (this.hls.autoLevelCapping === -1 || this.hls.autoLevelCapping >= currentLevel)) {
                currentLevel = currentLevel - 1;
                this.hls.trigger(_events2.default.FPS_DROP_LEVEL_CAPPING, { level: currentLevel, droppedLevel: this.hls.currentLevel });
                this.hls.autoLevelCapping = currentLevel;
                this.hls.streamController.nextLevelSwitch();
              }
            }
          }
        }
        this.lastTime = currentTime;
        this.lastDroppedFrames = droppedFrames;
        this.lastDecodedFrames = decodedFrames;
      }
    }
  }, {
    key: 'checkFPSInterval',
    value: function checkFPSInterval() {
      if (this.video) {
        if (this.isVideoPlaybackQualityAvailable) {
          var videoPlaybackQuality = this.video.getVideoPlaybackQuality();
          this.checkFPS(this.video, videoPlaybackQuality.totalVideoFrames, videoPlaybackQuality.droppedVideoFrames);
        } else {
          this.checkFPS(this.video, this.video.webkitDecodedFrameCount, this.video.webkitDroppedFrameCount);
        }
      }
    }
  }]);

  return FPSController;
}(_eventHandler2.default);

exports.default = FPSController;

},{"../event-handler":26,"../events":27,"../utils/logger":44}],10:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _eventHandler = require('../event-handler');

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _logger = require('../utils/logger');

var _errors = require('../errors');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Level Controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

var LevelController = function (_EventHandler) {
  _inherits(LevelController, _EventHandler);

  function LevelController(hls) {
    _classCallCheck(this, LevelController);

    var _this = _possibleConstructorReturn(this, (LevelController.__proto__ || Object.getPrototypeOf(LevelController)).call(this, hls, _events2.default.MANIFEST_LOADED, _events2.default.LEVEL_LOADED, _events2.default.ERROR));

    _this.ontick = _this.tick.bind(_this);
    _this._manualLevel = _this._autoLevelCapping = -1;
    return _this;
  }

  _createClass(LevelController, [{
    key: 'destroy',
    value: function destroy() {
      if (this.timer) {
        clearTimeout(this.timer);
        this.timer = null;
      }
      this._manualLevel = -1;
    }
  }, {
    key: 'startLoad',
    value: function startLoad() {
      this.canload = true;
      // speed up live playlist refresh if timer exists
      if (this.timer) {
        this.tick();
      }
    }
  }, {
    key: 'stopLoad',
    value: function stopLoad() {
      this.canload = false;
    }
  }, {
    key: 'onManifestLoaded',
    value: function onManifestLoaded(data) {
      var levels0 = [],
          levels = [],
          bitrateStart,
          i,
          bitrateSet = {},
          videoCodecFound = false,
          audioCodecFound = false,
          hls = this.hls;

      // regroup redundant level together
      data.levels.forEach(function (level) {
        if (level.videoCodec) {
          videoCodecFound = true;
        }
        if (level.audioCodec || level.attrs && level.attrs.AUDIO) {
          audioCodecFound = true;
        }
        var redundantLevelId = bitrateSet[level.bitrate];
        if (redundantLevelId === undefined) {
          bitrateSet[level.bitrate] = levels0.length;
          level.url = [level.url];
          level.urlId = 0;
          levels0.push(level);
        } else {
          levels0[redundantLevelId].url.push(level.url);
        }
      });

      // remove audio-only level if we also have levels with audio+video codecs signalled
      if (videoCodecFound && audioCodecFound) {
        levels0.forEach(function (level) {
          if (level.videoCodec) {
            levels.push(level);
          }
        });
      } else {
        levels = levels0;
      }

      // only keep level with supported audio/video codecs
      levels = levels.filter(function (level) {
        var checkSupportedAudio = function checkSupportedAudio(codec) {
          return MediaSource.isTypeSupported('audio/mp4;codecs=' + codec);
        };
        var checkSupportedVideo = function checkSupportedVideo(codec) {
          return MediaSource.isTypeSupported('video/mp4;codecs=' + codec);
        };
        var audioCodec = level.audioCodec,
            videoCodec = level.videoCodec;

        return (!audioCodec || checkSupportedAudio(audioCodec)) && (!videoCodec || checkSupportedVideo(videoCodec));
      });

      if (levels.length) {
        // start bitrate is the first bitrate of the manifest
        bitrateStart = levels[0].bitrate;
        // sort level on bitrate
        levels.sort(function (a, b) {
          return a.bitrate - b.bitrate;
        });
        this._levels = levels;
        // find index of first level in sorted levels
        for (i = 0; i < levels.length; i++) {
          if (levels[i].bitrate === bitrateStart) {
            this._firstLevel = i;
            _logger.logger.log('manifest loaded,' + levels.length + ' level(s) found, first bitrate:' + bitrateStart);
            break;
          }
        }
        hls.trigger(_events2.default.MANIFEST_PARSED, { levels: this._levels, firstLevel: this._firstLevel, stats: data.stats, audio: audioCodecFound, video: videoCodecFound });
      } else {
        hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.MANIFEST_INCOMPATIBLE_CODECS_ERROR, fatal: true, url: hls.url, reason: 'no level with compatible codecs found in manifest' });
      }
      return;
    }
  }, {
    key: 'setLevelInternal',
    value: function setLevelInternal(newLevel) {
      var levels = this._levels;
      // check if level idx is valid
      if (newLevel >= 0 && newLevel < levels.length) {
        // stopping live reloading timer if any
        if (this.timer) {
          clearTimeout(this.timer);
          this.timer = null;
        }
        this._level = newLevel;
        _logger.logger.log('switching to level ' + newLevel);
        this.hls.trigger(_events2.default.LEVEL_SWITCH, { level: newLevel });
        var level = levels[newLevel],
            levelDetails = level.details;
        // check if we need to load playlist for this level. don't reload live playlist more than once per second
        if (!levelDetails || levelDetails.live === true && performance.now() - levelDetails.tload > 1000) {
          // level not retrieved yet, or live playlist we need to (re)load it
          _logger.logger.log('(re)loading playlist for level ' + newLevel);
          var urlId = level.urlId;
          this.hls.trigger(_events2.default.LEVEL_LOADING, { url: level.url[urlId], level: newLevel, id: urlId });
        }
      } else {
        // invalid level id given, trigger error
        this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.OTHER_ERROR, details: _errors.ErrorDetails.LEVEL_SWITCH_ERROR, level: newLevel, fatal: false, reason: 'invalid level idx' });
      }
    }
  }, {
    key: 'onError',
    value: function onError(data) {
      if (data.fatal) {
        return;
      }

      var details = data.details,
          hls = this.hls,
          levelId = void 0,
          level = void 0,
          levelError = false;
      // try to recover not fatal errors
      switch (details) {
        case _errors.ErrorDetails.FRAG_LOAD_ERROR:
        case _errors.ErrorDetails.FRAG_LOAD_TIMEOUT:
        case _errors.ErrorDetails.FRAG_LOOP_LOADING_ERROR:
        case _errors.ErrorDetails.KEY_LOAD_ERROR:
        case _errors.ErrorDetails.KEY_LOAD_TIMEOUT:
          levelId = data.frag.level;
          break;
        case _errors.ErrorDetails.LEVEL_LOAD_ERROR:
        case _errors.ErrorDetails.LEVEL_LOAD_TIMEOUT:
          levelId = data.context.level;
          levelError = true;
          break;
        default:
          break;
      }
      /* try to switch to a redundant stream if any available.
       * if no redundant stream available, emergency switch down (if in auto mode and current level not 0)
       * otherwise, we cannot recover this network error ...
       */
      if (levelId !== undefined) {
        level = this._levels[levelId];
        if (level.urlId < level.url.length - 1) {
          level.urlId++;
          level.details = undefined;
          _logger.logger.warn('level controller,' + details + ' for level ' + levelId + ': switching to redundant stream id ' + level.urlId);
        } else {
          // we could try to recover if in auto mode and current level not lowest level (0)
          var recoverable = this._manualLevel === -1 && levelId;
          if (recoverable) {
            _logger.logger.warn('level controller,' + details + ': emergency switch-down for next fragment');
            hls.abrController.nextAutoLevel = 0;
          } else if (level && level.details && level.details.live) {
            _logger.logger.warn('level controller,' + details + ' on live stream, discard');
            if (levelError) {
              // reset this._level so that another call to set level() will retrigger a frag load
              this._level = undefined;
            }
            // fragment errors are all handled  by streamController
          } else if (details !== _errors.ErrorDetails.FRAG_LOAD_ERROR && details !== _errors.ErrorDetails.FRAG_LOAD_TIMEOUT && details !== _errors.ErrorDetails.FRAG_LOOP_LOADING_ERROR) {
            _logger.logger.error('cannot recover ' + details + ' error');
            this._level = undefined;
            // stopping live reloading timer if any
            if (this.timer) {
              clearTimeout(this.timer);
              this.timer = null;
            }
            // redispatch same error but with fatal set to true
            data.fatal = true;
            hls.trigger(_events2.default.ERROR, data);
          }
        }
      }
    }
  }, {
    key: 'onLevelLoaded',
    value: function onLevelLoaded(data) {
      // only process level loaded events matching with expected level
      if (data.level === this._level) {
        var newDetails = data.details;
        // if current playlist is a live playlist, arm a timer to reload it
        if (newDetails.live) {
          var reloadInterval = 1000 * (newDetails.averagetargetduration ? newDetails.averagetargetduration : newDetails.targetduration),
              curLevel = this._levels[data.level],
              curDetails = curLevel.details;
          if (curDetails && newDetails.endSN === curDetails.endSN) {
            // follow HLS Spec, If the client reloads a Playlist file and finds that it has not
            // changed then it MUST wait for a period of one-half the target
            // duration before retrying.
            reloadInterval /= 2;
            _logger.logger.log('same live playlist, reload twice faster');
          }
          // decrement reloadInterval with level loading delay
          reloadInterval -= performance.now() - data.stats.trequest;
          // in any case, don't reload more than every second
          reloadInterval = Math.max(1000, Math.round(reloadInterval));
          _logger.logger.log('live playlist, reload in ' + reloadInterval + ' ms');
          this.timer = setTimeout(this.ontick, reloadInterval);
        } else {
          this.timer = null;
        }
      }
    }
  }, {
    key: 'tick',
    value: function tick() {
      var levelId = this._level;
      if (levelId !== undefined && this.canload) {
        var level = this._levels[levelId],
            urlId = level.urlId;
        this.hls.trigger(_events2.default.LEVEL_LOADING, { url: level.url[urlId], level: levelId, id: urlId });
      }
    }
  }, {
    key: 'levels',
    get: function get() {
      return this._levels;
    }
  }, {
    key: 'level',
    get: function get() {
      return this._level;
    },
    set: function set(newLevel) {
      var levels = this._levels;
      if (levels && levels.length > newLevel) {
        if (this._level !== newLevel || levels[newLevel].details === undefined) {
          this.setLevelInternal(newLevel);
        }
      }
    }
  }, {
    key: 'manualLevel',
    get: function get() {
      return this._manualLevel;
    },
    set: function set(newLevel) {
      this._manualLevel = newLevel;
      if (this._startLevel === undefined) {
        this._startLevel = newLevel;
      }
      if (newLevel !== -1) {
        this.level = newLevel;
      }
    }
  }, {
    key: 'firstLevel',
    get: function get() {
      return this._firstLevel;
    },
    set: function set(newLevel) {
      this._firstLevel = newLevel;
    }
  }, {
    key: 'startLevel',
    get: function get() {
      // hls.startLevel takes precedence over config.startLevel
      // if none of these values are defined, fallback on this._firstLevel (first quality level appearing in variant manifest)
      if (this._startLevel === undefined) {
        var configStartLevel = this.hls.config.startLevel;
        if (configStartLevel !== undefined) {
          return configStartLevel;
        } else {
          return this._firstLevel;
        }
      } else {
        return this._startLevel;
      }
    },
    set: function set(newLevel) {
      this._startLevel = newLevel;
    }
  }, {
    key: 'nextLoadLevel',
    get: function get() {
      if (this._manualLevel !== -1) {
        return this._manualLevel;
      } else {
        return this.hls.abrController.nextAutoLevel;
      }
    },
    set: function set(nextLevel) {
      this.level = nextLevel;
      if (this._manualLevel === -1) {
        this.hls.abrController.nextAutoLevel = nextLevel;
      }
    }
  }]);

  return LevelController;
}(_eventHandler2.default);

exports.default = LevelController;

},{"../errors":25,"../event-handler":26,"../events":27,"../utils/logger":44}],11:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _binarySearch = require('../utils/binary-search');

var _binarySearch2 = _interopRequireDefault(_binarySearch);

var _bufferHelper = require('../helper/buffer-helper');

var _bufferHelper2 = _interopRequireDefault(_bufferHelper);

var _demuxer = require('../demux/demuxer');

var _demuxer2 = _interopRequireDefault(_demuxer);

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _eventHandler = require('../event-handler');

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _levelHelper = require('../helper/level-helper');

var _levelHelper2 = _interopRequireDefault(_levelHelper);

var _timeRanges = require('../utils/timeRanges');

var _timeRanges2 = _interopRequireDefault(_timeRanges);

var _errors = require('../errors');

var _logger = require('../utils/logger');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Stream Controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

var State = {
  STOPPED: 'STOPPED',
  STARTING: 'STARTING',
  IDLE: 'IDLE',
  PAUSED: 'PAUSED',
  KEY_LOADING: 'KEY_LOADING',
  FRAG_LOADING: 'FRAG_LOADING',
  FRAG_LOADING_WAITING_RETRY: 'FRAG_LOADING_WAITING_RETRY',
  WAITING_LEVEL: 'WAITING_LEVEL',
  PARSING: 'PARSING',
  PARSED: 'PARSED',
  ENDED: 'ENDED',
  ERROR: 'ERROR'
};

var StreamController = function (_EventHandler) {
  _inherits(StreamController, _EventHandler);

  function StreamController(hls) {
    _classCallCheck(this, StreamController);

    var _this = _possibleConstructorReturn(this, (StreamController.__proto__ || Object.getPrototypeOf(StreamController)).call(this, hls, _events2.default.MEDIA_ATTACHED, _events2.default.MEDIA_DETACHING, _events2.default.MANIFEST_LOADING, _events2.default.MANIFEST_PARSED, _events2.default.LEVEL_LOADED, _events2.default.KEY_LOADED, _events2.default.FRAG_LOADED, _events2.default.FRAG_LOAD_EMERGENCY_ABORTED, _events2.default.FRAG_PARSING_INIT_SEGMENT, _events2.default.FRAG_PARSING_DATA, _events2.default.FRAG_PARSED, _events2.default.ERROR, _events2.default.AUDIO_TRACK_SWITCH, _events2.default.BUFFER_CREATED, _events2.default.BUFFER_APPENDED, _events2.default.BUFFER_FLUSHED));

    _this.config = hls.config;
    _this.audioCodecSwap = false;
    _this.ticks = 0;
    _this.ontick = _this.tick.bind(_this);
    return _this;
  }

  _createClass(StreamController, [{
    key: 'destroy',
    value: function destroy() {
      this.stopLoad();
      if (this.timer) {
        clearInterval(this.timer);
        this.timer = null;
      }
      _eventHandler2.default.prototype.destroy.call(this);
      this.state = State.STOPPED;
    }
  }, {
    key: 'startLoad',
    value: function startLoad(startPosition) {
      if (this.levels) {
        var media = this.media,
            lastCurrentTime = this.lastCurrentTime;
        this.stopLoad();
        this.demuxer = new _demuxer2.default(this.hls, 'main');
        if (!this.timer) {
          this.timer = setInterval(this.ontick, 100);
        }
        this.level = -1;
        this.fragLoadError = 0;
        if (media && lastCurrentTime > 0) {
          _logger.logger.log('configure startPosition @' + lastCurrentTime);
          if (!this.lastPaused) {
            _logger.logger.log('resuming video');
            media.play();
          }
        } else {
          this.lastCurrentTime = this.startPosition ? this.startPosition : startPosition;
        }
        this.state = this.startFragRequested ? State.IDLE : State.STARTING;
        this.nextLoadPosition = this.startPosition = this.lastCurrentTime;
        this.tick();
      } else {
        _logger.logger.warn('cannot start loading as manifest not parsed yet');
        this.state = State.STOPPED;
      }
    }
  }, {
    key: 'stopLoad',
    value: function stopLoad() {
      var frag = this.fragCurrent;
      if (frag) {
        if (frag.loader) {
          frag.loader.abort();
        }
        this.fragCurrent = null;
      }
      this.fragPrevious = null;
      if (this.demuxer) {
        this.demuxer.destroy();
        this.demuxer = null;
      }
      this.state = State.STOPPED;
    }
  }, {
    key: 'tick',
    value: function tick() {
      this.ticks++;
      if (this.ticks === 1) {
        this.doTick();
        if (this.ticks > 1) {
          setTimeout(this.tick, 1);
        }
        this.ticks = 0;
      }
    }
  }, {
    key: 'doTick',
    value: function doTick() {
      switch (this.state) {
        case State.STARTING:
          var hls = this.hls;
          // determine load level
          var startLevel = hls.startLevel;
          if (startLevel === -1) {
            // -1 : guess start Level by doing a bitrate test by loading first fragment of lowest quality level
            startLevel = 0;
            this.fragBitrateTest = true;
          }
          // set new level to playlist loader : this will trigger start level load
          // hls.nextLoadLevel remains until it is set to a new value or until a new frag is successfully loaded
          this.level = hls.nextLoadLevel = startLevel;
          this.state = State.WAITING_LEVEL;
          this.loadedmetadata = false;
          break;
        case State.IDLE:
          // when this returns false there was an error and we shall return immediatly
          // from current tick
          if (!this._doTickIdle()) {
            return;
          }
          break;
        case State.WAITING_LEVEL:
          var level = this.levels[this.level];
          // check if playlist is already loaded
          if (level && level.details) {
            this.state = State.IDLE;
          }
          break;
        case State.FRAG_LOADING_WAITING_RETRY:
          var now = performance.now();
          var retryDate = this.retryDate;
          // if current time is gt than retryDate, or if media seeking let's switch to IDLE state to retry loading
          if (!retryDate || now >= retryDate || this.media && this.media.seeking) {
            _logger.logger.log('mediaController: retryDate reached, switch back to IDLE state');
            this.state = State.IDLE;
          }
          break;
        case State.ERROR:
        case State.PAUSED:
        case State.STOPPED:
        case State.FRAG_LOADING:
        case State.PARSING:
        case State.PARSED:
        case State.ENDED:
          break;
        default:
          break;
      }
      // check buffer
      this._checkBuffer();
      // check/update current fragment
      this._checkFragmentChanged();
    }

    // Ironically the "idle" state is the on we do the most logic in it seems ....
    // NOTE: Maybe we could rather schedule a check for buffer length after half of the currently
    //       played segment, or on pause/play/seek instead of naively checking every 100ms?

  }, {
    key: '_doTickIdle',
    value: function _doTickIdle() {
      var hls = this.hls,
          config = hls.config,
          media = this.media;

      // if video not attached AND
      // start fragment already requested OR start frag prefetch disable
      // exit loop
      // => if media not attached but start frag prefetch is enabled and start frag not requested yet, we will not exit loop
      if (!media && (this.startFragRequested || !config.startFragPrefetch)) {
        return true;
      }

      // if we have not yet loaded any fragment, start loading from start position
      var pos = void 0;
      if (this.loadedmetadata) {
        pos = media.currentTime;
      } else {
        pos = this.nextLoadPosition;
      }
      // determine next load level
      var level = hls.nextLoadLevel;

      // compute max Buffer Length that we could get from this load level, based on level bitrate. don't buffer more than 60 MB and more than 30s
      var maxBufLen = void 0;
      if (this.levels[level].hasOwnProperty('bitrate')) {
        maxBufLen = Math.max(8 * config.maxBufferSize / this.levels[level].bitrate, config.maxBufferLength);
      } else {
        maxBufLen = config.maxBufferLength;
      }
      maxBufLen = Math.min(maxBufLen, config.maxMaxBufferLength);

      // determine next candidate fragment to be loaded, based on current position and end of buffer position
      // ensure up to `config.maxMaxBufferLength` of buffer upfront

      var bufferInfo = _bufferHelper2.default.bufferInfo(this.mediaBuffer ? this.mediaBuffer : media, pos, config.maxBufferHole),
          bufferLen = bufferInfo.len;
      // Stay idle if we are still with buffer margins
      if (bufferLen >= maxBufLen) {
        return true;
      }

      // if buffer length is less than maxBufLen try to load a new fragment ...
      _logger.logger.trace('buffer length of ' + bufferLen.toFixed(3) + ' is below max of ' + maxBufLen.toFixed(3) + '. checking for more payload ...');

      // set next load level : this will trigger a playlist load if needed
      hls.nextLoadLevel = level;
      this.level = level;

      var levelDetails = this.levels[level].details;
      // if level info not retrieved yet, switch state and wait for level retrieval
      // if live playlist, ensure that new playlist has been refreshed to avoid loading/try to load
      // a useless and outdated fragment (that might even introduce load error if it is already out of the live playlist)
      if (typeof levelDetails === 'undefined' || levelDetails.live && this.levelLastLoaded !== level) {
        this.state = State.WAITING_LEVEL;
        return true;
      }

      // we just got done loading the final fragment, check if we need to finalize media stream
      var fragPrevious = this.fragPrevious;
      if (!levelDetails.live && fragPrevious && fragPrevious.sn === levelDetails.endSN) {
        // if (we are not seeking AND current position is buffered) OR (if we are seeking but everything (almost) til the end is buffered), let's signal eos
        // we don't compare exactly media.duration === bufferInfo.end as there could be some subtle media duration difference when switching
        // between different renditions. using half frag duration should help cope with these cases.
        if (!media.seeking && bufferInfo.len || media.duration - bufferInfo.end <= fragPrevious.duration / 2) {
          // Finalize the media stream
          var data = {};
          if (this.altAudio) {
            data.type = 'video';
          }
          this.hls.trigger(_events2.default.BUFFER_EOS, data);
          this.state = State.ENDED;
          return true;
        }
      }

      // if we have the levelDetails for the selected variant, lets continue enrichen our stream (load keys/fragments or trigger EOS, etc..)
      return this._fetchPayloadOrEos({ pos: pos, bufferInfo: bufferInfo, levelDetails: levelDetails });
    }
  }, {
    key: '_fetchPayloadOrEos',
    value: function _fetchPayloadOrEos(_ref) {
      var pos = _ref.pos;
      var bufferInfo = _ref.bufferInfo;
      var levelDetails = _ref.levelDetails;

      var fragPrevious = this.fragPrevious,
          level = this.level,
          fragments = levelDetails.fragments,
          fragLen = fragments.length;

      // empty playlist
      if (fragLen === 0) {
        return false;
      }

      // find fragment index, contiguous with end of buffer position
      var start = fragments[0].start,
          end = fragments[fragLen - 1].start + fragments[fragLen - 1].duration,
          bufferEnd = bufferInfo.end,
          frag = void 0;

      // in case of live playlist we need to ensure that requested position is not located before playlist start
      if (levelDetails.live) {
        frag = this._ensureFragmentAtLivePoint({ levelDetails: levelDetails, bufferEnd: bufferEnd, start: start, end: end, fragPrevious: fragPrevious, fragments: fragments, fragLen: fragLen });
        // if it explicitely returns null don't load any fragment and exit function now
        if (frag === null) {
          return false;
        }
      } else {
        // VoD playlist: if bufferEnd before start of playlist, load first fragment
        if (bufferEnd < start) {
          frag = fragments[0];
        }
      }
      if (!frag) {
        frag = this._findFragment({ start: start, fragPrevious: fragPrevious, fragLen: fragLen, fragments: fragments, bufferEnd: bufferEnd, end: end, levelDetails: levelDetails });
      }
      if (frag) {
        return this._loadFragmentOrKey({ frag: frag, level: level, levelDetails: levelDetails, pos: pos, bufferEnd: bufferEnd });
      }
      return true;
    }
  }, {
    key: '_ensureFragmentAtLivePoint',
    value: function _ensureFragmentAtLivePoint(_ref2) {
      var levelDetails = _ref2.levelDetails;
      var bufferEnd = _ref2.bufferEnd;
      var start = _ref2.start;
      var end = _ref2.end;
      var fragPrevious = _ref2.fragPrevious;
      var fragments = _ref2.fragments;
      var fragLen = _ref2.fragLen;

      var config = this.hls.config,
          media = this.media;

      var frag = void 0;

      // check if requested position is within seekable boundaries :
      //logger.log(`start/pos/bufEnd/seeking:${start.toFixed(3)}/${pos.toFixed(3)}/${bufferEnd.toFixed(3)}/${this.media.seeking}`);
      var maxLatency = config.liveMaxLatencyDuration !== undefined ? config.liveMaxLatencyDuration : config.liveMaxLatencyDurationCount * levelDetails.targetduration;

      if (bufferEnd < Math.max(start, end - maxLatency)) {
        var liveSyncPosition = this.liveSyncPosition = this.computeLivePosition(start, levelDetails);
        _logger.logger.log('buffer end: ' + bufferEnd + ' is located too far from the end of live sliding playlist, reset currentTime to : ' + liveSyncPosition.toFixed(3));
        bufferEnd = liveSyncPosition;
        if (media && media.readyState && media.duration > liveSyncPosition) {
          media.currentTime = liveSyncPosition;
        }
      }

      // if end of buffer greater than live edge, don't load any fragment
      // this could happen if live playlist intermittently slides in the past.
      // level 1 loaded [182580161,182580167]
      // level 1 loaded [182580162,182580169]
      // Loading 182580168 of [182580162 ,182580169],level 1 ..
      // Loading 182580169 of [182580162 ,182580169],level 1 ..
      // level 1 loaded [182580162,182580168] <============= here we should have bufferEnd > end. in that case break to avoid reloading 182580168
      // level 1 loaded [182580164,182580171]
      //
      // don't return null in case media not loaded yet (readystate === 0)
      if (levelDetails.PTSKnown && bufferEnd > end && media && media.readyState) {
        return null;
      }

      if (this.startFragRequested && !levelDetails.PTSKnown) {
        /* we are switching level on live playlist, but we don't have any PTS info for that quality level ...
           try to load frag matching with next SN.
           even if SN are not synchronized between playlists, loading this frag will help us
           compute playlist sliding and find the right one after in case it was not the right consecutive one */
        if (fragPrevious) {
          var targetSN = fragPrevious.sn + 1;
          if (targetSN >= levelDetails.startSN && targetSN <= levelDetails.endSN) {
            frag = fragments[targetSN - levelDetails.startSN];
            _logger.logger.log('live playlist, switching playlist, load frag with next SN: ' + frag.sn);
          }
        }
        if (!frag) {
          /* we have no idea about which fragment should be loaded.
             so let's load mid fragment. it will help computing playlist sliding and find the right one
          */
          frag = fragments[Math.min(fragLen - 1, Math.round(fragLen / 2))];
          _logger.logger.log('live playlist, switching playlist, unknown, load middle frag : ' + frag.sn);
        }
      }
      return frag;
    }
  }, {
    key: '_findFragment',
    value: function _findFragment(_ref3) {
      var start = _ref3.start;
      var fragPrevious = _ref3.fragPrevious;
      var fragLen = _ref3.fragLen;
      var fragments = _ref3.fragments;
      var bufferEnd = _ref3.bufferEnd;
      var end = _ref3.end;
      var levelDetails = _ref3.levelDetails;

      var config = this.hls.config;

      var frag = void 0,
          foundFrag = void 0,
          maxFragLookUpTolerance = config.maxFragLookUpTolerance;

      if (bufferEnd < end) {
        if (bufferEnd > end - maxFragLookUpTolerance) {
          maxFragLookUpTolerance = 0;
        }
        foundFrag = _binarySearch2.default.search(fragments, function (candidate) {
          // offset should be within fragment boundary - config.maxFragLookUpTolerance
          // this is to cope with situations like
          // bufferEnd = 9.991
          // frag[Ã˜] : [0,10]
          // frag[1] : [10,20]
          // bufferEnd is within frag[0] range ... although what we are expecting is to return frag[1] here
          //              frag start               frag start+duration
          //                  |-----------------------------|
          //              <--->                         <--->
          //  ...--------><-----------------------------><---------....
          // previous frag         matching fragment         next frag
          //  return -1             return 0                 return 1
          //logger.log(`level/sn/start/end/bufEnd:${level}/${candidate.sn}/${candidate.start}/${(candidate.start+candidate.duration)}/${bufferEnd}`);
          if (candidate.start + candidate.duration - maxFragLookUpTolerance <= bufferEnd) {
            return 1;
          } // if maxFragLookUpTolerance will have negative value then don't return -1 for first element
          else if (candidate.start - maxFragLookUpTolerance > bufferEnd && candidate.start) {
              return -1;
            }
          return 0;
        });
      } else {
        // reach end of playlist
        foundFrag = fragments[fragLen - 1];
      }
      if (foundFrag) {
        frag = foundFrag;
        start = foundFrag.start;
        //logger.log('find SN matching with pos:' +  bufferEnd + ':' + frag.sn);
        if (fragPrevious && frag.level === fragPrevious.level && frag.sn === fragPrevious.sn) {
          if (frag.sn < levelDetails.endSN) {
            var deltaPTS = fragPrevious.deltaPTS,
                curSNIdx = frag.sn - levelDetails.startSN;
            // if there is a significant delta between audio and video, larger than max allowed hole,
            // and if previous remuxed fragment did not start with a keyframe. (fragPrevious.dropped)
            // let's try to load previous fragment again to get last keyframe
            // then we will reload again current fragment (that way we should be able to fill the buffer hole ...)
            if (deltaPTS && deltaPTS > config.maxBufferHole && fragPrevious.dropped && curSNIdx) {
              frag = fragments[curSNIdx - 1];
              _logger.logger.warn('SN just loaded, with large PTS gap between audio and video, maybe frag is not starting with a keyframe ? load previous one to try to overcome this');
              // decrement previous frag load counter to avoid frag loop loading error when next fragment will get reloaded
              fragPrevious.loadCounter--;
            } else {
              frag = fragments[curSNIdx + 1];
              _logger.logger.log('SN just loaded, load next one: ' + frag.sn);
            }
          } else {
            frag = null;
          }
        }
      }
      return frag;
    }
  }, {
    key: '_loadFragmentOrKey',
    value: function _loadFragmentOrKey(_ref4) {
      var frag = _ref4.frag;
      var level = _ref4.level;
      var levelDetails = _ref4.levelDetails;
      var pos = _ref4.pos;
      var bufferEnd = _ref4.bufferEnd;

      var hls = this.hls,
          config = hls.config;

      //logger.log('loading frag ' + i +',pos/bufEnd:' + pos.toFixed(3) + '/' + bufferEnd.toFixed(3));
      if (frag.decryptdata.uri != null && frag.decryptdata.key == null) {
        _logger.logger.log('Loading key for ' + frag.sn + ' of [' + levelDetails.startSN + ' ,' + levelDetails.endSN + '],level ' + level);
        this.state = State.KEY_LOADING;
        hls.trigger(_events2.default.KEY_LOADING, { frag: frag });
      } else {
        _logger.logger.log('Loading ' + frag.sn + ' of [' + levelDetails.startSN + ' ,' + levelDetails.endSN + '],level ' + level + ', currentTime:' + pos + ',bufferEnd:' + bufferEnd.toFixed(3));
        // ensure that we are not reloading the same fragments in loop ...
        if (this.fragLoadIdx !== undefined) {
          this.fragLoadIdx++;
        } else {
          this.fragLoadIdx = 0;
        }
        if (frag.loadCounter) {
          frag.loadCounter++;
          var maxThreshold = config.fragLoadingLoopThreshold;
          // if this frag has already been loaded 3 times, and if it has been reloaded recently
          if (frag.loadCounter > maxThreshold && Math.abs(this.fragLoadIdx - frag.loadIdx) < maxThreshold) {
            hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.FRAG_LOOP_LOADING_ERROR, fatal: false, frag: frag });
            return false;
          }
        } else {
          frag.loadCounter = 1;
        }
        frag.loadIdx = this.fragLoadIdx;
        this.fragCurrent = frag;
        this.startFragRequested = true;
        frag.autoLevel = hls.autoLevelEnabled;
        frag.bitrateTest = this.fragBitrateTest;
        hls.trigger(_events2.default.FRAG_LOADING, { frag: frag });
        this.state = State.FRAG_LOADING;
        return true;
      }
    }
  }, {
    key: 'getBufferRange',
    value: function getBufferRange(position) {
      var i,
          range,
          bufferRange = this.bufferRange;
      if (bufferRange) {
        for (i = bufferRange.length - 1; i >= 0; i--) {
          range = bufferRange[i];
          if (position >= range.start && position <= range.end) {
            return range;
          }
        }
      }
      return null;
    }
  }, {
    key: 'followingBufferRange',
    value: function followingBufferRange(range) {
      if (range) {
        // try to get range of next fragment (500ms after this range)
        return this.getBufferRange(range.end + 0.5);
      }
      return null;
    }
  }, {
    key: 'isBuffered',
    value: function isBuffered(position) {
      var media = this.media;
      if (media) {
        var buffered = media.buffered;
        for (var i = 0; i < buffered.length; i++) {
          if (position >= buffered.start(i) && position <= buffered.end(i)) {
            return true;
          }
        }
      }
      return false;
    }
  }, {
    key: '_checkFragmentChanged',
    value: function _checkFragmentChanged() {
      var rangeCurrent,
          currentTime,
          video = this.media;
      if (video && video.readyState && video.seeking === false) {
        currentTime = video.currentTime;
        /* if video element is in seeked state, currentTime can only increase.
          (assuming that playback rate is positive ...)
          As sometimes currentTime jumps back to zero after a
          media decode error, check this, to avoid seeking back to
          wrong position after a media decode error
        */
        if (currentTime > video.playbackRate * this.lastCurrentTime) {
          this.lastCurrentTime = currentTime;
        }
        if (this.isBuffered(currentTime)) {
          rangeCurrent = this.getBufferRange(currentTime);
        } else if (this.isBuffered(currentTime + 0.1)) {
          /* ensure that FRAG_CHANGED event is triggered at startup,
            when first video frame is displayed and playback is paused.
            add a tolerance of 100ms, in case current position is not buffered,
            check if current pos+100ms is buffered and use that buffer range
            for FRAG_CHANGED event reporting */
          rangeCurrent = this.getBufferRange(currentTime + 0.1);
        }
        if (rangeCurrent) {
          var fragPlaying = rangeCurrent.frag;
          if (fragPlaying !== this.fragPlaying) {
            this.fragPlaying = fragPlaying;
            this.hls.trigger(_events2.default.FRAG_CHANGED, { frag: fragPlaying });
          }
        }
      }
    }

    /*
      on immediate level switch :
       - pause playback if playing
       - cancel any pending load request
       - and trigger a buffer flush
    */

  }, {
    key: 'immediateLevelSwitch',
    value: function immediateLevelSwitch() {
      _logger.logger.log('immediateLevelSwitch');
      if (!this.immediateSwitch) {
        this.immediateSwitch = true;
        var media = this.media,
            previouslyPaused = void 0;
        if (media) {
          previouslyPaused = media.paused;
          media.pause();
        } else {
          // don't restart playback after instant level switch in case media not attached
          previouslyPaused = true;
        }
        this.previouslyPaused = previouslyPaused;
      }
      var fragCurrent = this.fragCurrent;
      if (fragCurrent && fragCurrent.loader) {
        fragCurrent.loader.abort();
      }
      this.fragCurrent = null;
      this.state = State.PAUSED;
      // flush everything
      this.hls.trigger(_events2.default.BUFFER_FLUSHING, { startOffset: 0, endOffset: Number.POSITIVE_INFINITY });
    }

    /*
       on immediate level switch end, after new fragment has been buffered :
        - nudge video decoder by slightly adjusting video currentTime (if currentTime buffered)
        - resume the playback if needed
    */

  }, {
    key: 'immediateLevelSwitchEnd',
    value: function immediateLevelSwitchEnd() {
      var media = this.media;
      if (media && media.buffered.length) {
        this.immediateSwitch = false;
        if (this.isBuffered(media.currentTime)) {
          // only nudge if currentTime is buffered
          media.currentTime -= 0.0001;
        }
        if (!this.previouslyPaused) {
          media.play();
        }
      }
    }
  }, {
    key: 'nextLevelSwitch',
    value: function nextLevelSwitch() {
      /* try to switch ASAP without breaking video playback :
         in order to ensure smooth but quick level switching,
        we need to find the next flushable buffer range
        we should take into account new segment fetch time
      */
      var media = this.media;
      // ensure that media is defined and that metadata are available (to retrieve currentTime)
      if (media && media.readyState) {
        var fetchdelay = void 0,
            currentRange = void 0,
            nextRange = void 0;
        // increase fragment load Index to avoid frag loop loading error after buffer flush
        this.fragLoadIdx += 2 * this.config.fragLoadingLoopThreshold;
        currentRange = this.getBufferRange(media.currentTime);
        if (currentRange && currentRange.start > 1) {
          // flush buffer preceding current fragment (flush until current fragment start offset)
          // minus 1s to avoid video freezing, that could happen if we flush keyframe of current video ...
          this.state = State.PAUSED;
          this.hls.trigger(_events2.default.BUFFER_FLUSHING, { startOffset: 0, endOffset: currentRange.start - 1 });
        }
        if (!media.paused) {
          // add a safety delay of 1s
          var nextLevelId = this.hls.nextLoadLevel,
              nextLevel = this.levels[nextLevelId],
              fragLastKbps = this.fragLastKbps;
          if (fragLastKbps && this.fragCurrent) {
            fetchdelay = this.fragCurrent.duration * nextLevel.bitrate / (1000 * fragLastKbps) + 1;
          } else {
            fetchdelay = 0;
          }
        } else {
          fetchdelay = 0;
        }
        //logger.log('fetchdelay:'+fetchdelay);
        // find buffer range that will be reached once new fragment will be fetched
        nextRange = this.getBufferRange(media.currentTime + fetchdelay);
        if (nextRange) {
          // we can flush buffer range following this one without stalling playback
          nextRange = this.followingBufferRange(nextRange);
          if (nextRange) {
            // if we are here, we can also cancel any loading/demuxing in progress, as they are useless
            var fragCurrent = this.fragCurrent;
            if (fragCurrent && fragCurrent.loader) {
              fragCurrent.loader.abort();
            }
            this.fragCurrent = null;
            // flush position is the start position of this new buffer
            this.state = State.PAUSED;
            this.hls.trigger(_events2.default.BUFFER_FLUSHING, { startOffset: nextRange.start, endOffset: Number.POSITIVE_INFINITY });
          }
        }
      }
    }
  }, {
    key: 'onMediaAttached',
    value: function onMediaAttached(data) {
      var media = this.media = this.mediaBuffer = data.media;
      this.onvseeking = this.onMediaSeeking.bind(this);
      this.onvseeked = this.onMediaSeeked.bind(this);
      this.onvended = this.onMediaEnded.bind(this);
      media.addEventListener('seeking', this.onvseeking);
      media.addEventListener('seeked', this.onvseeked);
      media.addEventListener('ended', this.onvended);
      var config = this.config;
      if (this.levels && config.autoStartLoad) {
        this.hls.startLoad(config.startPosition);
      }
    }
  }, {
    key: 'onMediaDetaching',
    value: function onMediaDetaching() {
      var media = this.media;
      if (media && media.ended) {
        _logger.logger.log('MSE detaching and video ended, reset startPosition');
        this.startPosition = this.lastCurrentTime = 0;
      }

      // reset fragment loading counter on MSE detaching to avoid reporting FRAG_LOOP_LOADING_ERROR after error recovery
      var levels = this.levels;
      if (levels) {
        // reset fragment load counter
        levels.forEach(function (level) {
          if (level.details) {
            level.details.fragments.forEach(function (fragment) {
              fragment.loadCounter = undefined;
            });
          }
        });
      }
      // remove video listeners
      if (media) {
        media.removeEventListener('seeking', this.onvseeking);
        media.removeEventListener('seeked', this.onvseeked);
        media.removeEventListener('ended', this.onvended);
        this.onvseeking = this.onvseeked = this.onvended = null;
      }
      this.media = null;
      this.loadedmetadata = false;
      this.stopLoad();
    }
  }, {
    key: 'onMediaSeeking',
    value: function onMediaSeeking() {
      var media = this.media,
          currentTime = media ? media.currentTime : undefined;
      _logger.logger.log('media seeking to ' + currentTime);
      if (this.state === State.FRAG_LOADING) {
        var bufferInfo = _bufferHelper2.default.bufferInfo(media, currentTime, this.config.maxBufferHole),
            fragCurrent = this.fragCurrent;
        // check if we are seeking to a unbuffered area AND if frag loading is in progress
        if (bufferInfo.len === 0 && fragCurrent) {
          var tolerance = this.config.maxFragLookUpTolerance,
              fragStartOffset = fragCurrent.start - tolerance,
              fragEndOffset = fragCurrent.start + fragCurrent.duration + tolerance;
          // check if we seek position will be out of currently loaded frag range : if out cancel frag load, if in, don't do anything
          if (currentTime < fragStartOffset || currentTime > fragEndOffset) {
            if (fragCurrent.loader) {
              _logger.logger.log('seeking outside of buffer while fragment load in progress, cancel fragment load');
              fragCurrent.loader.abort();
            }
            this.fragCurrent = null;
            this.fragPrevious = null;
            // switch to IDLE state to load new fragment
            this.state = State.IDLE;
          } else {
            _logger.logger.log('seeking outside of buffer but within currently loaded fragment range');
          }
        }
      } else if (this.state === State.ENDED) {
        // switch to IDLE state to check for potential new fragment
        this.state = State.IDLE;
      }
      if (media) {
        this.lastCurrentTime = currentTime;
      }
      // avoid reporting fragment loop loading error in case user is seeking several times on same position
      if (this.state !== State.FRAG_LOADING && this.fragLoadIdx !== undefined) {
        this.fragLoadIdx += 2 * this.config.fragLoadingLoopThreshold;
      }
      // tick to speed up processing
      this.tick();
    }
  }, {
    key: 'onMediaSeeked',
    value: function onMediaSeeked() {
      _logger.logger.log('media seeked to ' + this.media.currentTime);
      // tick to speed up FRAGMENT_PLAYING triggering
      this.tick();
    }
  }, {
    key: 'onMediaEnded',
    value: function onMediaEnded() {
      _logger.logger.log('media ended');
      // reset startPosition and lastCurrentTime to restart playback @ stream beginning
      this.startPosition = this.lastCurrentTime = 0;
    }
  }, {
    key: 'onManifestLoading',
    value: function onManifestLoading() {
      // reset buffer on manifest loading
      _logger.logger.log('trigger BUFFER_RESET');
      this.hls.trigger(_events2.default.BUFFER_RESET);
      this.bufferRange = [];
      this.stalled = false;
      this.startPosition = this.lastCurrentTime = 0;
    }
  }, {
    key: 'onManifestParsed',
    value: function onManifestParsed(data) {
      var aac = false,
          heaac = false,
          codec;
      data.levels.forEach(function (level) {
        // detect if we have different kind of audio codecs used amongst playlists
        codec = level.audioCodec;
        if (codec) {
          if (codec.indexOf('mp4a.40.2') !== -1) {
            aac = true;
          }
          if (codec.indexOf('mp4a.40.5') !== -1) {
            heaac = true;
          }
        }
      });
      this.audioCodecSwitch = aac && heaac;
      if (this.audioCodecSwitch) {
        _logger.logger.log('both AAC/HE-AAC audio found in levels; declaring level codec as HE-AAC');
      }
      this.levels = data.levels;
      this.startLevelLoaded = false;
      this.startFragRequested = false;
      var config = this.config;
      if (config.autoStartLoad) {
        this.hls.startLoad(config.startPosition);
      }
    }
  }, {
    key: 'onLevelLoaded',
    value: function onLevelLoaded(data) {
      var newDetails = data.details,
          newLevelId = data.level,
          curLevel = this.levels[newLevelId],
          duration = newDetails.totalduration,
          sliding = 0;

      _logger.logger.log('level ' + newLevelId + ' loaded [' + newDetails.startSN + ',' + newDetails.endSN + '],duration:' + duration);
      this.levelLastLoaded = newLevelId;

      if (newDetails.live) {
        var curDetails = curLevel.details;
        if (curDetails && newDetails.fragments.length > 0) {
          // we already have details for that level, merge them
          _levelHelper2.default.mergeDetails(curDetails, newDetails);
          sliding = newDetails.fragments[0].start;
          this.liveSyncPosition = this.computeLivePosition(sliding, curDetails);
          if (newDetails.PTSKnown) {
            _logger.logger.log('live playlist sliding:' + sliding.toFixed(3));
          } else {
            _logger.logger.log('live playlist - outdated PTS, unknown sliding');
          }
        } else {
          newDetails.PTSKnown = false;
          _logger.logger.log('live playlist - first load, unknown sliding');
        }
      } else {
        newDetails.PTSKnown = false;
      }
      // override level info
      curLevel.details = newDetails;
      this.hls.trigger(_events2.default.LEVEL_UPDATED, { details: newDetails, level: newLevelId });

      if (this.startFragRequested === false) {
        // compute start position if set to -1. use it straight away if value is defined
        if (this.startPosition === -1 || this.lastCurrentTime === -1) {
          // first, check if start time offset has been set in playlist, if yes, use this value
          var startTimeOffset = newDetails.startTimeOffset;
          if (!isNaN(startTimeOffset)) {
            if (startTimeOffset < 0) {
              _logger.logger.log('negative start time offset ' + startTimeOffset + ', count from end of last fragment');
              startTimeOffset = sliding + duration + startTimeOffset;
            }
            _logger.logger.log('start time offset found in playlist, adjust startPosition to ' + startTimeOffset);
            this.startPosition = startTimeOffset;
          } else {
            // if live playlist, set start position to be fragment N-this.config.liveSyncDurationCount (usually 3)
            if (newDetails.live) {
              this.startPosition = this.computeLivePosition(sliding, newDetails);
              _logger.logger.log('configure startPosition to ' + this.startPosition);
            } else {
              this.startPosition = 0;
            }
          }
        }
        this.nextLoadPosition = this.startPosition;
      }
      // only switch batck to IDLE state if we were waiting for level to start downloading a new fragment
      if (this.state === State.WAITING_LEVEL) {
        this.state = State.IDLE;
      }
      //trigger handler right now
      this.tick();
    }
  }, {
    key: 'onKeyLoaded',
    value: function onKeyLoaded() {
      if (this.state === State.KEY_LOADING) {
        this.state = State.IDLE;
        this.tick();
      }
    }
  }, {
    key: 'onFragLoaded',
    value: function onFragLoaded(data) {
      var fragCurrent = this.fragCurrent,
          fragLoaded = data.frag;
      if (this.state === State.FRAG_LOADING && fragCurrent && fragLoaded.type === 'main' && fragLoaded.level === fragCurrent.level && fragLoaded.sn === fragCurrent.sn) {
        var stats = data.stats;
        _logger.logger.log('Loaded  ' + fragCurrent.sn + ' of level ' + fragCurrent.level);
        // reset frag bitrate test in any case after frag loaded event
        this.fragBitrateTest = false;
        // if this frag was loaded to perform a bitrate test AND if hls.nextLoadLevel is greater than 0
        // then this means that we should be able to load a fragment at a higher quality level
        if (fragLoaded.bitrateTest === true && this.hls.nextLoadLevel) {
          // switch back to IDLE state ... we just loaded a fragment to determine adequate start bitrate and initialize autoswitch algo
          this.state = State.IDLE;
          this.startFragRequested = false;
          stats.tparsed = stats.tbuffered = performance.now();
          this.hls.trigger(_events2.default.FRAG_BUFFERED, { stats: stats, frag: fragCurrent, id: 'main' });
          this.tick();
        } else {
          this.state = State.PARSING;
          // transmux the MPEG-TS data to ISO-BMFF segments
          this.stats = stats;
          var currentLevel = this.levels[this.level],
              details = currentLevel.details,
              duration = details.totalduration,
              start = fragCurrent.startDTS !== undefined ? fragCurrent.startDTS : fragCurrent.start,
              level = fragCurrent.level,
              sn = fragCurrent.sn,
              audioCodec = this.config.defaultAudioCodec || currentLevel.audioCodec;
          if (this.audioCodecSwap) {
            _logger.logger.log('swapping playlist audio codec');
            if (audioCodec === undefined) {
              audioCodec = this.lastAudioCodec;
            }
            if (audioCodec) {
              if (audioCodec.indexOf('mp4a.40.5') !== -1) {
                audioCodec = 'mp4a.40.2';
              } else {
                audioCodec = 'mp4a.40.5';
              }
            }
          }
          this.pendingAppending = 0;
          _logger.logger.log('Demuxing ' + sn + ' of [' + details.startSN + ' ,' + details.endSN + '],level ' + level + ', cc ' + fragCurrent.cc);
          var demuxer = this.demuxer;
          if (!demuxer) {
            demuxer = this.demuxer = new _demuxer2.default(this.hls, 'main');
          }
          // time Offset is accurate if level PTS is known, or if playlist is not sliding (not live)
          var accurateTimeOffset = details.PTSKnown || !details.live;
          demuxer.push(data.payload, audioCodec, currentLevel.videoCodec, start, fragCurrent.cc, level, sn, duration, fragCurrent.decryptdata, accurateTimeOffset);
        }
      }
      this.fragLoadError = 0;
    }
  }, {
    key: 'onFragParsingInitSegment',
    value: function onFragParsingInitSegment(data) {
      var fragCurrent = this.fragCurrent;
      if (fragCurrent && data.id === 'main' && data.sn === fragCurrent.sn && data.level === fragCurrent.level && this.state === State.PARSING) {
        var tracks = data.tracks,
            trackName,
            track;

        // if audio track is expected to come from audio stream controller, discard any coming from main
        if (tracks.audio && this.altAudio) {
          delete tracks.audio;
        }
        // include levelCodec in audio and video tracks
        track = tracks.audio;
        if (track) {
          var audioCodec = this.levels[this.level].audioCodec,
              ua = navigator.userAgent.toLowerCase();
          if (audioCodec && this.audioCodecSwap) {
            _logger.logger.log('swapping playlist audio codec');
            if (audioCodec.indexOf('mp4a.40.5') !== -1) {
              audioCodec = 'mp4a.40.2';
            } else {
              audioCodec = 'mp4a.40.5';
            }
          }
          // in case AAC and HE-AAC audio codecs are signalled in manifest
          // force HE-AAC , as it seems that most browsers prefers that way,
          // except for mono streams OR on FF
          // these conditions might need to be reviewed ...
          if (this.audioCodecSwitch) {
            // don't force HE-AAC if mono stream
            if (track.metadata.channelCount !== 1 &&
            // don't force HE-AAC if firefox
            ua.indexOf('firefox') === -1) {
              audioCodec = 'mp4a.40.5';
            }
          }
          // HE-AAC is broken on Android, always signal audio codec as AAC even if variant manifest states otherwise
          if (ua.indexOf('android') !== -1) {
            audioCodec = 'mp4a.40.2';
            _logger.logger.log('Android: force audio codec to' + audioCodec);
          }
          track.levelCodec = audioCodec;
          track.id = data.id;
        }
        track = tracks.video;
        if (track) {
          track.levelCodec = this.levels[this.level].videoCodec;
          track.id = data.id;
        }

        // if remuxer specify that a unique track needs to generated,
        // let's merge all tracks together
        if (data.unique) {
          var mergedTrack = {
            codec: '',
            levelCodec: ''
          };
          for (trackName in data.tracks) {
            track = tracks[trackName];
            mergedTrack.container = track.container;
            if (mergedTrack.codec) {
              mergedTrack.codec += ',';
              mergedTrack.levelCodec += ',';
            }
            if (track.codec) {
              mergedTrack.codec += track.codec;
            }
            if (track.levelCodec) {
              mergedTrack.levelCodec += track.levelCodec;
            }
          }
          tracks = { audiovideo: mergedTrack };
        }
        this.hls.trigger(_events2.default.BUFFER_CODECS, tracks);
        // loop through tracks that are going to be provided to bufferController
        for (trackName in tracks) {
          track = tracks[trackName];
          _logger.logger.log('main track:' + trackName + ',container:' + track.container + ',codecs[level/parsed]=[' + track.levelCodec + '/' + track.codec + ']');
          var initSegment = track.initSegment;
          if (initSegment) {
            this.pendingAppending++;
            this.hls.trigger(_events2.default.BUFFER_APPENDING, { type: trackName, data: initSegment, parent: 'main', content: 'initSegment' });
          }
        }
        //trigger handler right now
        this.tick();
      }
    }
  }, {
    key: 'onFragParsingData',
    value: function onFragParsingData(data) {
      var _this2 = this;

      var fragCurrent = this.fragCurrent;
      if (fragCurrent && data.id === 'main' && data.sn === fragCurrent.sn && data.level === fragCurrent.level && (data.type !== 'audio' || this.audioTrackType !== 'AUDIO') && // filter out main audio if audio track is loaded through audio stream controller
      this.state === State.PARSING) {
        var level = this.levels[this.level],
            frag = this.fragCurrent;

        _logger.logger.log('parsed ' + data.type + ',PTS:[' + data.startPTS.toFixed(3) + ',' + data.endPTS.toFixed(3) + '],DTS:[' + data.startDTS.toFixed(3) + '/' + data.endDTS.toFixed(3) + '],nb:' + data.nb + ',dropped:' + (data.dropped || 0));

        var drift = _levelHelper2.default.updateFragPTSDTS(level.details, frag.sn, data.startPTS, data.endPTS, data.startDTS, data.endDTS),
            hls = this.hls;
        hls.trigger(_events2.default.LEVEL_PTS_UPDATED, { details: level.details, level: this.level, drift: drift });

        // has remuxer dropped video frames located before first keyframe ?
        if (data.type === 'video') {
          frag.dropped = data.dropped;
        }

        [data.data1, data.data2].forEach(function (buffer) {
          if (buffer) {
            _this2.pendingAppending++;
            hls.trigger(_events2.default.BUFFER_APPENDING, { type: data.type, data: buffer, parent: 'main', content: 'data' });
          }
        });

        this.nextLoadPosition = data.endPTS;
        this.bufferRange.push({ type: data.type, start: data.startPTS, end: data.endPTS, frag: frag });

        //trigger handler right now
        this.tick();
      }
    }
  }, {
    key: 'onFragParsed',
    value: function onFragParsed(data) {
      var fragCurrent = this.fragCurrent;
      if (fragCurrent && data.id === 'main' && data.sn === fragCurrent.sn && data.level === fragCurrent.level && this.state === State.PARSING) {
        this.stats.tparsed = performance.now();
        this.state = State.PARSED;
        this._checkAppendedParsed();
      }
    }
  }, {
    key: 'onAudioTrackSwitch',
    value: function onAudioTrackSwitch(data) {
      // if any URL found on new audio track, it is an alternate audio track
      var altAudio = !!data.url;
      // if we switch on main audio, ensure that main fragment scheduling is synced with media.buffered
      if (!altAudio) {
        if (this.mediaBuffer !== this.media) {
          _logger.logger.log('switching on main audio, use media.buffered to schedule main fragment loading');
          this.mediaBuffer = this.media;
          var fragCurrent = this.fragCurrent;
          // we need to refill audio buffer from main: cancel any frag loading to speed up audio switch
          if (fragCurrent.loader) {
            _logger.logger.log('switching to main audio track, cancel main fragment load');
            fragCurrent.loader.abort();
          }
          this.fragCurrent = null;
          this.fragPrevious = null;
          // destroy demuxer to force init segment generation (following audio switch)
          if (this.demuxer) {
            this.demuxer.destroy();
            this.demuxer = null;
          }
          // switch to IDLE state to load new fragment
          this.state = State.IDLE;
        }
      } else {
        // if we switch on alternate audio, ensure that main fragment scheduling is synced with video sourcebuffer buffered
        if (this.videoBuffer && this.mediaBuffer !== this.videoBuffer) {
          _logger.logger.log('switching on alternate audio, use video.buffered to schedule main fragment loading');
          this.mediaBuffer = this.videoBuffer;
        }
      }
      this.altAudio = altAudio;
    }
  }, {
    key: 'onBufferCreated',
    value: function onBufferCreated(data) {
      var tracks = data.tracks,
          mediaTrack = void 0,
          name = void 0,
          alternate = false;
      for (var type in tracks) {
        var track = tracks[type];
        if (track.id === 'main') {
          name = type;
          mediaTrack = track;
          // keep video source buffer reference
          if (type === 'video') {
            this.videoBuffer = tracks[type].buffer;
          }
        } else {
          alternate = true;
        }
      }
      if (alternate && mediaTrack) {
        _logger.logger.log('alternate track found, use ' + name + '.buffered to schedule main fragment loading');
        this.mediaBuffer = mediaTrack.buffer;
      } else {
        this.mediaBuffer = this.media;
      }
    }
  }, {
    key: 'onBufferAppended',
    value: function onBufferAppended(data) {
      if (data.parent === 'main') {
        switch (this.state) {
          case State.PARSING:
          case State.PARSED:
            this.pendingAppending--;
            this._checkAppendedParsed();
            break;
          default:
            break;
        }
      }
    }
  }, {
    key: '_checkAppendedParsed',
    value: function _checkAppendedParsed() {
      //trigger handler right now
      if (this.state === State.PARSED && this.pendingAppending === 0) {
        var frag = this.fragCurrent,
            stats = this.stats;
        if (frag) {
          this.fragPrevious = frag;
          stats.tbuffered = performance.now();
          // we should get rid of this.fragLastKbps
          this.fragLastKbps = Math.round(8 * stats.total / (stats.tbuffered - stats.tfirst));
          this.hls.trigger(_events2.default.FRAG_BUFFERED, { stats: stats, frag: frag, id: 'main' });
          var media = this.mediaBuffer ? this.mediaBuffer : this.media;
          _logger.logger.log('main buffered : ' + _timeRanges2.default.toString(media.buffered));
          this.state = State.IDLE;
        }
        this.tick();
      }
    }
  }, {
    key: 'onError',
    value: function onError(data) {
      var frag = data.frag || this.fragCurrent;
      // don't handle frag error not related to main fragment
      if (frag && frag.type !== 'main') {
        return;
      }
      var media = this.media,

      // 0.4 : tolerance needed as some browsers stalls playback before reaching buffered end
      mediaBuffered = media && this.isBuffered(media.currentTime) && this.isBuffered(media.currentTime + 0.4);
      switch (data.details) {
        case _errors.ErrorDetails.FRAG_LOAD_ERROR:
        case _errors.ErrorDetails.FRAG_LOAD_TIMEOUT:
          if (!data.fatal) {
            var loadError = this.fragLoadError;
            if (loadError) {
              loadError++;
            } else {
              loadError = 1;
            }
            var config = this.config;
            // keep retrying / don't raise fatal network error if current position is buffered
            if (loadError <= config.fragLoadingMaxRetry || mediaBuffered) {
              this.fragLoadError = loadError;
              // reset load counter to avoid frag loop loading error
              frag.loadCounter = 0;
              // exponential backoff capped to config.fragLoadingMaxRetryTimeout
              var delay = Math.min(Math.pow(2, loadError - 1) * config.fragLoadingRetryDelay, config.fragLoadingMaxRetryTimeout);
              _logger.logger.warn('mediaController: frag loading failed, retry in ' + delay + ' ms');
              this.retryDate = performance.now() + delay;
              // retry loading state
              this.state = State.FRAG_LOADING_WAITING_RETRY;
            } else {
              _logger.logger.error('mediaController: ' + data.details + ' reaches max retry, redispatch as fatal ...');
              // redispatch same error but with fatal set to true
              data.fatal = true;
              this.hls.trigger(_events2.default.ERROR, data);
              this.state = State.ERROR;
            }
          }
          break;
        case _errors.ErrorDetails.FRAG_LOOP_LOADING_ERROR:
          if (!data.fatal) {
            // if buffer is not empty
            if (mediaBuffered) {
              // try to reduce max buffer length : rationale is that we could get
              // frag loop loading error because of buffer eviction
              this._reduceMaxMaxBufferLength(frag.duration);
              this.state = State.IDLE;
            } else {
              // buffer empty. report as fatal if in manual mode or if lowest level.
              // level controller takes care of emergency switch down logic
              if (!frag.autoLevel || frag.level === 0) {
                // redispatch same error but with fatal set to true
                data.fatal = true;
                this.hls.trigger(_events2.default.ERROR, data);
                this.state = State.ERROR;
              }
            }
          }
          break;
        case _errors.ErrorDetails.LEVEL_LOAD_ERROR:
        case _errors.ErrorDetails.LEVEL_LOAD_TIMEOUT:
        case _errors.ErrorDetails.KEY_LOAD_ERROR:
        case _errors.ErrorDetails.KEY_LOAD_TIMEOUT:
          //  when in ERROR state, don't switch back to IDLE state in case a non-fatal error is received
          if (this.state !== State.ERROR) {
            // if fatal error, stop processing, otherwise move to IDLE to retry loading
            this.state = data.fatal ? State.ERROR : State.IDLE;
            _logger.logger.warn('mediaController: ' + data.details + ' while loading frag,switch to ' + this.state + ' state ...');
          }
          break;
        case _errors.ErrorDetails.BUFFER_FULL_ERROR:
          // if in appending state
          if (this.state === State.PARSING || this.state === State.PARSED) {
            // reduce max buf len if current position is buffered
            if (mediaBuffered) {
              this._reduceMaxMaxBufferLength(frag.duration);
              this.state = State.IDLE;
            } else {
              // current position is not buffered, but browser is still complaining about buffer full error
              // this happens on IE/Edge, refer to https://github.com/dailymotion/hls.js/pull/708
              // in that case flush the whole buffer to recover
              _logger.logger.warn('buffer full error also media.currentTime is not buffered, flush everything');
              this.fragCurrent = null;
              this.state = State.PAUSED;
              // flush everything
              this.hls.trigger(_events2.default.BUFFER_FLUSHING, { startOffset: 0, endOffset: Number.POSITIVE_INFINITY });
            }
          }
          break;
        default:
          break;
      }
    }
  }, {
    key: '_reduceMaxMaxBufferLength',
    value: function _reduceMaxMaxBufferLength(minLength) {
      var config = this.config;
      if (config.maxMaxBufferLength >= minLength) {
        // reduce max buffer length as it might be too high. we do this to avoid loop flushing ...
        config.maxMaxBufferLength /= 2;
        _logger.logger.warn('reduce max buffer length to ' + config.maxMaxBufferLength + 's and switch to IDLE state');
        // increase fragment load Index to avoid frag loop loading error after buffer flush
        this.fragLoadIdx += 2 * config.fragLoadingLoopThreshold;
      }
    }
  }, {
    key: '_checkBuffer',
    value: function _checkBuffer() {
      var media = this.media;
      // if ready state different from HAVE_NOTHING (numeric value 0), we are allowed to seek
      if (media && media.readyState) {
        var currentTime = media.currentTime,
            buffered = media.buffered;
        // adjust currentTime to start position on loaded metadata
        if (!this.loadedmetadata && buffered.length) {
          this.loadedmetadata = true;
          // only adjust currentTime if different from startPosition or if startPosition not buffered
          // at that stage, there should be only one buffered range, as we reach that code after first fragment has been buffered
          var startPosition = this.startPosition,
              startPositionBuffered = this.isBuffered(startPosition);
          // if currentTime not matching with expected startPosition or startPosition not buffered
          if (currentTime !== startPosition || !startPositionBuffered) {
            _logger.logger.log('target start position:' + startPosition);
            // if startPosition not buffered, let's seek to buffered.start(0)
            if (!startPositionBuffered) {
              startPosition = buffered.start(0);
              _logger.logger.log('target start position not buffered, seek to buffered.start(0) ' + startPosition);
            }
            _logger.logger.log('adjust currentTime from ' + currentTime + ' to ' + startPosition);
            media.currentTime = startPosition;
          }
        } else if (this.immediateSwitch) {
          this.immediateLevelSwitchEnd();
        } else {
          var bufferInfo = _bufferHelper2.default.bufferInfo(media, currentTime, 0),
              expectedPlaying = !(media.paused || // not playing when media is paused
          media.ended || // not playing when media is ended
          media.buffered.length === 0),
              // not playing if nothing buffered
          jumpThreshold = 0.4,
              // tolerance needed as some browsers stalls playback before reaching buffered range end
          playheadMoving = currentTime > media.playbackRate * this.lastCurrentTime;

          if (this.stalled && playheadMoving) {
            this.stalled = false;
            _logger.logger.log('playback not stuck anymore @' + currentTime);
          }
          // check buffer upfront
          // if less than jumpThreshold second is buffered, let's check in more details
          if (expectedPlaying && bufferInfo.len <= jumpThreshold) {
            if (playheadMoving) {
              // playhead moving
              jumpThreshold = 0;
              this.seekHoleNudgeDuration = 0;
            } else {
              // playhead not moving AND media expected to play
              if (!this.stalled) {
                this.seekHoleNudgeDuration = 0;
                _logger.logger.log('playback seems stuck @' + currentTime);
                this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.BUFFER_STALLED_ERROR, fatal: false });
                this.stalled = true;
              } else {
                this.seekHoleNudgeDuration += this.config.seekHoleNudgeDuration;
              }
            }
            // if we are below threshold, try to jump to start of next buffer range if close
            if (bufferInfo.len <= jumpThreshold) {
              // no buffer available @ currentTime, check if next buffer is close (within a config.maxSeekHole second range)
              var nextBufferStart = bufferInfo.nextStart,
                  delta = nextBufferStart - currentTime;
              if (nextBufferStart && delta < this.config.maxSeekHole && delta > 0) {
                // next buffer is close ! adjust currentTime to nextBufferStart
                // this will ensure effective video decoding
                _logger.logger.log('adjust currentTime from ' + media.currentTime + ' to next buffered @ ' + nextBufferStart + ' + nudge ' + this.seekHoleNudgeDuration);
                var hole = nextBufferStart + this.seekHoleNudgeDuration - media.currentTime;
                media.currentTime = nextBufferStart + this.seekHoleNudgeDuration;
                this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.BUFFER_SEEK_OVER_HOLE, fatal: false, hole: hole });
              }
            }
          }
        }
      }
    }
  }, {
    key: 'onFragLoadEmergencyAborted',
    value: function onFragLoadEmergencyAborted() {
      this.state = State.IDLE;
      // if loadedmetadata is not set, it means that we are emergency switch down on first frag
      // in that case, reset startFragRequested flag
      if (!this.loadedmetadata) {
        this.startFragRequested = false;
      }
      this.tick();
    }
  }, {
    key: 'onBufferFlushed',
    value: function onBufferFlushed() {
      /* after successful buffer flushing, rebuild buffer Range array
        loop through existing buffer range and check if
        corresponding range is still buffered. only push to new array already buffered range
      */
      var newRange = [],
          range,
          i;
      for (i = 0; i < this.bufferRange.length; i++) {
        range = this.bufferRange[i];
        if (this.isBuffered((range.start + range.end) / 2)) {
          newRange.push(range);
        }
      }
      this.bufferRange = newRange;

      // increase fragment load Index to avoid frag loop loading error after buffer flush
      this.fragLoadIdx += 2 * this.config.fragLoadingLoopThreshold;
      // move to IDLE once flush complete. this should trigger new fragment loading
      this.state = State.IDLE;
      // reset reference to frag
      this.fragPrevious = null;
    }
  }, {
    key: 'swapAudioCodec',
    value: function swapAudioCodec() {
      this.audioCodecSwap = !this.audioCodecSwap;
    }
  }, {
    key: 'computeLivePosition',
    value: function computeLivePosition(sliding, levelDetails) {
      var targetLatency = this.config.liveSyncDuration !== undefined ? this.config.liveSyncDuration : this.config.liveSyncDurationCount * levelDetails.targetduration;
      return sliding + Math.max(0, levelDetails.totalduration - targetLatency);
    }
  }, {
    key: 'state',
    set: function set(nextState) {
      if (this.state !== nextState) {
        var previousState = this.state;
        this._state = nextState;
        _logger.logger.log('engine state transition from ' + previousState + ' to ' + nextState);
        this.hls.trigger(_events2.default.STREAM_STATE_TRANSITION, { previousState: previousState, nextState: nextState });
      }
    },
    get: function get() {
      return this._state;
    }
  }, {
    key: 'currentLevel',
    get: function get() {
      if (this.media) {
        var range = this.getBufferRange(this.media.currentTime);
        if (range) {
          return range.frag.level;
        }
      }
      return -1;
    }
  }, {
    key: 'nextBufferRange',
    get: function get() {
      if (this.media) {
        // first get end range of current fragment
        return this.followingBufferRange(this.getBufferRange(this.media.currentTime));
      } else {
        return null;
      }
    }
  }, {
    key: 'nextLevel',
    get: function get() {
      var range = this.nextBufferRange;
      if (range) {
        return range.frag.level;
      } else {
        return -1;
      }
    }
  }, {
    key: 'liveSyncPosition',
    get: function get() {
      return this._liveSyncPosition;
    },
    set: function set(value) {
      this._liveSyncPosition = value;
    }
  }]);

  return StreamController;
}(_eventHandler2.default);

exports.default = StreamController;

},{"../demux/demuxer":21,"../errors":25,"../event-handler":26,"../events":27,"../helper/buffer-helper":29,"../helper/level-helper":30,"../utils/binary-search":40,"../utils/logger":44,"../utils/timeRanges":46}],12:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _eventHandler = require('../event-handler');

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _cea608Parser = require('../utils/cea-608-parser');

var _cea608Parser2 = _interopRequireDefault(_cea608Parser);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Timeline Controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

var TimelineController = function (_EventHandler) {
  _inherits(TimelineController, _EventHandler);

  function TimelineController(hls) {
    _classCallCheck(this, TimelineController);

    var _this = _possibleConstructorReturn(this, (TimelineController.__proto__ || Object.getPrototypeOf(TimelineController)).call(this, hls, _events2.default.MEDIA_ATTACHING, _events2.default.MEDIA_DETACHING, _events2.default.FRAG_PARSING_USERDATA, _events2.default.MANIFEST_LOADING, _events2.default.FRAG_LOADED, _events2.default.LEVEL_SWITCH));

    _this.hls = hls;
    _this.config = hls.config;
    _this.enabled = true;
    _this.Cues = hls.config.cueHandler;

    if (_this.config.enableCEA708Captions) {
      var self = _this;

      var channel1 = {
        'newCue': function newCue(startTime, endTime, screen) {
          if (!self.textTrack1) {
            //Enable reuse of existing text track.
            var existingTrack1 = self.getExistingTrack('1');
            if (!existingTrack1) {
              self.textTrack1 = self.createTextTrack('captions', 'English', 'en');
              self.textTrack1.textTrack1 = true;
            } else {
              self.textTrack1 = existingTrack1;
              self.clearCurrentCues(self.textTrack1);

              var e = new window.Event('addtrack');
              e.track = self.textTrack1;
              self.media.dispatchEvent(e);
            }
          }

          self.Cues.newCue(self.textTrack1, startTime, endTime, screen);
        }
      };

      var channel2 = {
        'newCue': function newCue(startTime, endTime, screen) {
          if (!self.textTrack2) {
            //Enable reuse of existing text track.
            var existingTrack2 = self.getExistingTrack('2');
            if (!existingTrack2) {
              self.textTrack2 = self.createTextTrack('captions', 'Spanish', 'es');
              self.textTrack2.textTrack2 = true;
            } else {
              self.textTrack2 = existingTrack2;
              self.clearCurrentCues(self.textTrack2);

              var e = new window.Event('addtrack');
              e.track = self.textTrack2;
              self.media.dispatchEvent(e);
            }
          }

          self.Cues.newCue(self.textTrack2, startTime, endTime, screen);
        }
      };

      _this.cea608Parser = new _cea608Parser2.default(0, channel1, channel2);
    }
    return _this;
  }

  _createClass(TimelineController, [{
    key: 'clearCurrentCues',
    value: function clearCurrentCues(track) {
      if (track && track.cues) {
        while (track.cues.length > 0) {
          track.removeCue(track.cues[0]);
        }
      }
    }
  }, {
    key: 'getExistingTrack',
    value: function getExistingTrack(channelNumber) {
      var media = this.media;
      if (media) {
        for (var i = 0; i < media.textTracks.length; i++) {
          var textTrack = media.textTracks[i];
          var propName = 'textTrack' + channelNumber;
          if (textTrack[propName] === true) {
            return textTrack;
          }
        }
      }
      return null;
    }
  }, {
    key: 'createTextTrack',
    value: function createTextTrack(kind, label, lang) {
      if (this.media) {
        return this.media.addTextTrack(kind, label, lang);
      }
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      _eventHandler2.default.prototype.destroy.call(this);
    }
  }, {
    key: 'onMediaAttaching',
    value: function onMediaAttaching(data) {
      this.media = data.media;
    }
  }, {
    key: 'onMediaDetaching',
    value: function onMediaDetaching() {}
  }, {
    key: 'onManifestLoading',
    value: function onManifestLoading() {
      this.lastPts = Number.NEGATIVE_INFINITY;
    }
  }, {
    key: 'onLevelSwitch',
    value: function onLevelSwitch() {
      if (this.hls.currentLevel.closedCaptions === 'NONE') {
        this.enabled = false;
      } else {
        this.enabled = true;
      }
    }
  }, {
    key: 'onFragLoaded',
    value: function onFragLoaded(data) {
      if (data.frag.type === 'main') {
        var pts = data.frag.start; //Number.POSITIVE_INFINITY;
        // if this is a frag for a previously loaded timerange, remove all captions
        // TODO: consider just removing captions for the timerange
        if (pts <= this.lastPts) {
          this.clearCurrentCues(this.textTrack1);
          this.clearCurrentCues(this.textTrack2);
        }
        this.lastPts = pts;
      }
    }
  }, {
    key: 'onFragParsingUserdata',
    value: function onFragParsingUserdata(data) {
      // push all of the CEA-708 messages into the interpreter
      // immediately. It will create the proper timestamps based on our PTS value
      if (this.enabled) {
        for (var i = 0; i < data.samples.length; i++) {
          var ccdatas = this.extractCea608Data(data.samples[i].bytes);
          this.cea608Parser.addData(data.samples[i].pts, ccdatas);
        }
      }
    }
  }, {
    key: 'extractCea608Data',
    value: function extractCea608Data(byteArray) {
      var count = byteArray[0] & 31;
      var position = 2;
      var tmpByte, ccbyte1, ccbyte2, ccValid, ccType;
      var actualCCBytes = [];

      for (var j = 0; j < count; j++) {
        tmpByte = byteArray[position++];
        ccbyte1 = 0x7F & byteArray[position++];
        ccbyte2 = 0x7F & byteArray[position++];
        ccValid = (4 & tmpByte) === 0 ? false : true;
        ccType = 3 & tmpByte;

        if (ccbyte1 === 0 && ccbyte2 === 0) {
          continue;
        }

        if (ccValid) {
          if (ccType === 0) // || ccType === 1
            {
              actualCCBytes.push(ccbyte1);
              actualCCBytes.push(ccbyte2);
            }
        }
      }
      return actualCCBytes;
    }
  }]);

  return TimelineController;
}(_eventHandler2.default);

exports.default = TimelineController;

},{"../event-handler":26,"../events":27,"../utils/cea-608-parser":41}],13:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var AESCrypto = function () {
  function AESCrypto(iv) {
    _classCallCheck(this, AESCrypto);

    this.aesIV = iv;
  }

  _createClass(AESCrypto, [{
    key: 'decrypt',
    value: function decrypt(data, key) {
      return window.crypto.subtle.decrypt({ name: 'AES-CBC', iv: this.aesIV }, key, data);
    }
  }]);

  return AESCrypto;
}();

exports.default = AESCrypto;

},{}],14:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var AESDecryptor = function () {
  function AESDecryptor(keyBuffer) {
    _classCallCheck(this, AESDecryptor);

    // convert keyBuffer to Uint32Array
    var key = this.uint8ArrayToUint32Array_(keyBuffer);
    var keySize = this.keySize = key.length;

    if (keySize !== 4 && keySize !== 6 && keySize !== 8) {
      throw new Error('Invalid aes key size=' + keySize);
    }

    var nRounds = keySize + 6;
    this.ksRows = (nRounds + 1) * 4;
    this.keyWords = key;
    this.subMix = [];
    this.invSubMix = [];
    this.initTable();
    this.expandKey();
  }

  _createClass(AESDecryptor, [{
    key: 'uint8ArrayToUint32Array_',
    value: function uint8ArrayToUint32Array_(arrayBuffer) {
      var view = new DataView(arrayBuffer);
      var newArray = new Uint32Array(4);
      for (var i = 0; i < newArray.length; i++) {
        newArray[i] = view.getUint32(i * 4);
      }
      return newArray;
    }
  }, {
    key: 'initTable',
    value: function initTable() {
      var sBox = this.sBox = new Uint32Array(256);
      var invSBox = this.invSBox = new Uint32Array(256);
      var subMix0 = this.subMix[0] = new Uint32Array(256);
      var subMix1 = this.subMix[1] = new Uint32Array(256);
      var subMix2 = this.subMix[2] = new Uint32Array(256);
      var subMix3 = this.subMix[3] = new Uint32Array(256);
      var invSubMix0 = this.invSubMix[0] = new Uint32Array(256);
      var invSubMix1 = this.invSubMix[1] = new Uint32Array(256);
      var invSubMix2 = this.invSubMix[2] = new Uint32Array(256);
      var invSubMix3 = this.invSubMix[3] = new Uint32Array(256);
      this.rcon = [0x0, 0x1, 0x2, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];

      var d = new Uint32Array(256);
      var x = 0;
      var xi = 0;
      var i = 0;
      for (i = 0; i < 256; i++) {
        if (i < 128) {
          d[i] = i << 1;
        } else {
          d[i] = i << 1 ^ 0x11b;
        }
      }

      for (i = 0; i < 256; i++) {
        var sx = xi ^ xi << 1 ^ xi << 2 ^ xi << 3 ^ xi << 4;
        sx = sx >>> 8 ^ sx & 0xff ^ 0x63;
        sBox[x] = sx;
        invSBox[sx] = x;

        // Compute multiplication
        var x2 = d[x];
        var x4 = d[x2];
        var x8 = d[x4];

        // Compute sub/invSub bytes, mix columns tables
        var t = d[sx] * 0x101 ^ sx * 0x1010100;
        subMix0[x] = t << 24 | t >>> 8;
        subMix1[x] = t << 16 | t >>> 16;
        subMix2[x] = t << 8 | t >>> 24;
        subMix3[x] = t;

        // Compute inv sub bytes, inv mix columns tables
        t = x8 * 0x1010101 ^ x4 * 0x10001 ^ x2 * 0x101 ^ x * 0x1010100;
        invSubMix0[sx] = t << 24 | t >>> 8;
        invSubMix1[sx] = t << 16 | t >>> 16;
        invSubMix2[sx] = t << 8 | t >>> 24;
        invSubMix3[sx] = t;

        // Compute next counter
        if (!x) {
          x = xi = 1;
        } else {
          x = x2 ^ d[d[d[x8 ^ x2]]];
          xi ^= d[d[xi]];
        }
      }
    }
  }, {
    key: 'expandKey',
    value: function expandKey() {
      var keySchedule = this.keySchedule = new Uint32Array(this.ksRows).fill(0);
      var rcon = this.rcon;
      var invKeySchedule = this.invKeySchedule = new Uint32Array(this.ksRows).fill(0);
      var keySize = this.keySize;
      var keyWords = this.keyWords;
      var ksRows = this.ksRows;
      var sbox = this.sBox;
      var invSubMix0 = this.invSubMix[0];
      var invSubMix1 = this.invSubMix[1];
      var invSubMix2 = this.invSubMix[2];
      var invSubMix3 = this.invSubMix[3];
      var prev;
      var t;

      for (var ksRow = 0; ksRow < ksRows; ksRow++) {
        if (ksRow < keySize) {
          prev = keySchedule[ksRow] = keyWords[ksRow];
          continue;
        }
        t = prev;

        if (ksRow % keySize === 0) {
          // Rot word
          t = t << 8 | t >>> 24;

          // Sub word
          t = sbox[t >>> 24] << 24 | sbox[t >>> 16 & 0xff] << 16 | sbox[t >>> 8 & 0xff] << 8 | sbox[t & 0xff];

          // Mix Rcon
          t ^= rcon[ksRow / keySize | 0] << 24;
        } else if (keySize > 6 && ksRow % keySize === 4) {
          // Sub word
          t = sbox[t >>> 24] << 24 | sbox[t >>> 16 & 0xff] << 16 | sbox[t >>> 8 & 0xff] << 8 | sbox[t & 0xff];
        }

        keySchedule[ksRow] = prev = (keySchedule[ksRow - keySize] ^ t) >>> 0;
      }

      for (var invKsRow = 0; invKsRow < ksRows; invKsRow++) {
        ksRow = ksRows - invKsRow;
        if (invKsRow & 3) {
          t = keySchedule[ksRow];
        } else {
          t = keySchedule[ksRow - 4];
        }

        if (invKsRow < 4 || ksRow <= 4) {
          invKeySchedule[invKsRow] = t;
        } else {
          invKeySchedule[invKsRow] = invSubMix0[sbox[t >>> 24]] ^ invSubMix1[sbox[t >>> 16 & 0xff]] ^ invSubMix2[sbox[t >>> 8 & 0xff]] ^ invSubMix3[sbox[t & 0xff]];
        }

        invKeySchedule[invKsRow] = invKeySchedule[invKsRow] >>> 0;
      }
    }
  }, {
    key: 'decrypt',
    value: function decrypt(inputData, offset, aesIV) {
      var invKeySched = this.invKeySchedule;
      var invKey0 = invKeySched[0];
      var invKey1 = invKeySched[1];
      var invKey2 = invKeySched[2];
      var invKey3 = invKeySched[3];
      var nRounds = this.keySize + 6;
      var invSubMix0 = this.invSubMix[0];
      var invSubMix1 = this.invSubMix[1];
      var invSubMix2 = this.invSubMix[2];
      var invSubMix3 = this.invSubMix[3];
      var invSBOX = this.invSBox;
      var output = new Uint8Array(inputData.byteLength);

      // parse iv to Uint32Array
      var iv = this.uint8ArrayToUint32Array_(aesIV);

      var mixing0 = iv[0];
      var mixing1 = iv[1];
      var mixing2 = iv[2];
      var mixing3 = iv[3];

      var input = new DataView(inputData);

      while (offset < inputData.byteLength) {
        var w0 = input.getUint32(offset);
        var w1 = input.getUint32(offset + 4);
        var w2 = input.getUint32(offset + 8);
        var w3 = input.getUint32(offset + 12);

        var s = new Uint32Array(4);
        var t = new Uint32Array(4);
        var r = new Uint32Array(4);

        s[0] = w0 ^ invKey0;
        s[1] = w3 ^ invKey1;
        s[2] = w2 ^ invKey2;
        s[3] = w1 ^ invKey3;

        var ksRow = 4;
        var i;
        for (i = 1; i < nRounds; i++) {
          t[0] = invSubMix0[s[0] >>> 24] ^ invSubMix1[s[1] >>> 16 & 0xff] ^ invSubMix2[s[2] >>> 8 & 0xff] ^ invSubMix3[s[3] & 0xff] ^ invKeySched[ksRow++];
          t[1] = invSubMix0[s[1] >>> 24] ^ invSubMix1[s[2] >>> 16 & 0xff] ^ invSubMix2[s[3] >>> 8 & 0xff] ^ invSubMix3[s[0] & 0xff] ^ invKeySched[ksRow++];
          t[2] = invSubMix0[s[2] >>> 24] ^ invSubMix1[s[3] >>> 16 & 0xff] ^ invSubMix2[s[0] >>> 8 & 0xff] ^ invSubMix3[s[1] & 0xff] ^ invKeySched[ksRow++];
          t[3] = invSubMix0[s[3] >>> 24] ^ invSubMix1[s[0] >>> 16 & 0xff] ^ invSubMix2[s[1] >>> 8 & 0xff] ^ invSubMix3[s[2] & 0xff] ^ invKeySched[ksRow++];
          // Update state
          s[0] = t[0];
          s[1] = t[1];
          s[2] = t[2];
          s[3] = t[3];
        }
        // Shift rows, sub bytes, add round key
        t[0] = (invSBOX[s[0] >>> 24] << 24 | invSBOX[s[1] >>> 16 & 0xff] << 16 | invSBOX[s[2] >>> 8 & 0xff] << 8 | invSBOX[s[3] & 0xff]) ^ invKeySched[ksRow++];
        t[1] = (invSBOX[s[1] >>> 24] << 24 | invSBOX[s[2] >>> 16 & 0xff] << 16 | invSBOX[s[3] >>> 8 & 0xff] << 8 | invSBOX[s[0] & 0xff]) ^ invKeySched[ksRow++];
        t[2] = (invSBOX[s[2] >>> 24] << 24 | invSBOX[s[3] >>> 16 & 0xff] << 16 | invSBOX[s[0] >>> 8 & 0xff] << 8 | invSBOX[s[1] & 0xff]) ^ invKeySched[ksRow++];
        t[3] = (invSBOX[s[3] >>> 24] << 24 | invSBOX[s[0] >>> 16 & 0xff] << 16 | invSBOX[s[1] >>> 8 & 0xff] << 8 | invSBOX[s[2] & 0xff]) ^ invKeySched[ksRow];

        r[3] = t[0] ^ mixing0;
        r[2] = t[3] ^ mixing1;
        r[1] = t[2] ^ mixing2;
        r[0] = t[1] ^ mixing3;

        // convert result to uint8Array and write to output
        var rView = new DataView(r.buffer);
        for (i = 0; i < 16; i++) {
          output[i + offset] = rView.getUint8(15 - i);
        }

        // reset iv to last 4 unsigned int
        mixing0 = w0;
        mixing1 = w1;
        mixing2 = w2;
        mixing3 = w3;

        offset += 16;
      }

      return this.unpad_(output).buffer;
    }
  }, {
    key: 'unpad_',
    value: function unpad_(data) {
      // Remove the padding at the end of output.
      // The padding occurs because each decryption happens in 16 bytes, but the encrypted data is not modulus of 16
      var len = data.length;
      var bytesOfPadding = data[len - 1];

      // Uncomment to log info about padding
      //for (var i = bytesOfPadding; i > 0; --i) {
      //    var v = data[--len];
      //
      //    if (bytesOfPadding !== v) {
      //        console.warn('Invalid padding error: Expected ' + bytesOfPadding, ', but received ' + v);
      //    }
      //}

      return data.subarray(0, data.length - bytesOfPadding);
    }
  }]);

  return AESDecryptor;
}();

exports.default = AESDecryptor;

},{}],15:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _aesCrypto = require('./aes-crypto');

var _aesCrypto2 = _interopRequireDefault(_aesCrypto);

var _fastAesKey = require('./fast-aes-key');

var _fastAesKey2 = _interopRequireDefault(_fastAesKey);

var _aesDecryptor = require('./aes-decryptor');

var _aesDecryptor2 = _interopRequireDefault(_aesDecryptor);

var _errors = require('../errors');

var _logger = require('../utils/logger');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Decrypter = function () {
  function Decrypter(hls) {
    _classCallCheck(this, Decrypter);

    this.hls = hls;
    try {
      var browserCrypto = window ? window.crypto : crypto;
      this.subtle = browserCrypto.subtle || browserCrypto.webkitSubtle;
    } catch (e) {}

    this.disableWebCrypto = !this.supportsWebCrypto();
  }

  _createClass(Decrypter, [{
    key: 'supportsWebCrypto',
    value: function supportsWebCrypto() {
      return this.subtle && window.location.protocol === 'https:';
    }
  }, {
    key: 'decrypt',
    value: function decrypt(data, key, iv, callback) {
      var _this = this;

      if (this.disableWebCrypto && this.hls.config.enableSoftwareAES) {
        _logger.logger.log('decrypting by JavaScript Implementation');

        var decryptor = new _aesDecryptor2.default(key);
        callback(decryptor.decrypt(data, 0, iv));
      } else {
        _logger.logger.log('decrypting by WebCrypto API');

        if (this.key !== key) {
          this.key = key;
          this.fastAesKey = new _fastAesKey2.default(key);
        }

        this.fastAesKey.expandKey().then(function (aesKey) {
          // decrypt using web crypto
          var crypto = new _aesCrypto2.default(iv);
          crypto.decrypt(data, aesKey).then(function (result) {
            callback(result);
          });
        }).catch(function (err) {
          _this.onWebCryptoError(err, data, key, iv, callback);
        });
      }
    }
  }, {
    key: 'onWebCryptoError',
    value: function onWebCryptoError(err, data, key, iv, callback) {
      if (this.hls.config.enableSoftwareAES) {
        _logger.logger.log('disabling to use WebCrypto API');
        this.disableWebCrypto = true;
        this.decrypt(data, key, iv, callback);
      } else {
        _logger.logger.error('decrypting error : ' + err.message);
        this.hls.trigger(Event.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.FRAG_DECRYPT_ERROR, fatal: true, reason: err.message });
      }
    }
  }, {
    key: 'destroy',
    value: function destroy() {}
  }]);

  return Decrypter;
}();

exports.default = Decrypter;

},{"../errors":25,"../utils/logger":44,"./aes-crypto":13,"./aes-decryptor":14,"./fast-aes-key":16}],16:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var FastAESKey = function () {
  function FastAESKey(key) {
    _classCallCheck(this, FastAESKey);

    this.key = key;
  }

  _createClass(FastAESKey, [{
    key: 'expandKey',
    value: function expandKey() {
      return window.crypto.subtle.importKey('raw', this.key, { name: 'AES-CBC' }, false, ['encrypt', 'decrypt']);
    }
  }]);

  return FastAESKey;
}();

exports.default = FastAESKey;

},{}],17:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * AAC demuxer
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */


var _adts = require('./adts');

var _adts2 = _interopRequireDefault(_adts);

var _logger = require('../utils/logger');

var _id = require('../demux/id3');

var _id2 = _interopRequireDefault(_id);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var AACDemuxer = function () {
  function AACDemuxer(observer, id, remuxerClass, config) {
    _classCallCheck(this, AACDemuxer);

    this.observer = observer;
    this.id = id;
    this.remuxerClass = remuxerClass;
    this.config = config;
    this.remuxer = new this.remuxerClass(observer, id, config);
    this.insertDiscontinuity();
  }

  _createClass(AACDemuxer, [{
    key: 'insertDiscontinuity',
    value: function insertDiscontinuity() {
      this._aacTrack = { container: 'audio/adts', type: 'audio', id: -1, sequenceNumber: 0, samples: [], len: 0 };
    }
  }, {
    key: 'push',


    // feed incoming data to the front of the parsing pipeline
    value: function push(data, audioCodec, videoCodec, timeOffset, cc, level, sn, duration, accurateTimeOffset) {
      var track,
          id3 = new _id2.default(data),
          pts = 90 * id3.timeStamp,
          config,
          frameLength,
          frameDuration,
          frameIndex,
          offset,
          headerLength,
          stamp,
          len,
          aacSample;

      var contiguous = false;
      if (cc !== this.lastCC) {
        _logger.logger.log(this.id + ' discontinuity detected');
        this.lastCC = cc;
        this.insertDiscontinuity();
        this.remuxer.switchLevel();
        this.remuxer.insertDiscontinuity();
      } else if (level !== this.lastLevel) {
        _logger.logger.log('audio track switch detected');
        this.lastLevel = level;
        this.remuxer.switchLevel();
        this.insertDiscontinuity();
      } else if (sn === this.lastSN + 1) {
        contiguous = true;
      }
      track = this._aacTrack;
      this.lastSN = sn;
      this.lastLevel = level;

      // look for ADTS header (0xFFFx)
      for (offset = id3.length, len = data.length; offset < len - 1; offset++) {
        if (data[offset] === 0xff && (data[offset + 1] & 0xf0) === 0xf0) {
          break;
        }
      }

      if (!track.audiosamplerate) {
        config = _adts2.default.getAudioConfig(this.observer, data, offset, audioCodec);
        track.config = config.config;
        track.audiosamplerate = config.samplerate;
        track.channelCount = config.channelCount;
        track.codec = config.codec;
        track.duration = duration;
        _logger.logger.log('parsed codec:' + track.codec + ',rate:' + config.samplerate + ',nb channel:' + config.channelCount);
      }
      frameIndex = 0;
      frameDuration = 1024 * 90000 / track.audiosamplerate;
      while (offset + 5 < len) {
        // The protection skip bit tells us if we have 2 bytes of CRC data at the end of the ADTS header
        headerLength = !!(data[offset + 1] & 0x01) ? 7 : 9;
        // retrieve frame size
        frameLength = (data[offset + 3] & 0x03) << 11 | data[offset + 4] << 3 | (data[offset + 5] & 0xE0) >>> 5;
        frameLength -= headerLength;
        //stamp = pes.pts;

        if (frameLength > 0 && offset + headerLength + frameLength <= len) {
          stamp = pts + frameIndex * frameDuration;
          //logger.log(`AAC frame, offset/length/total/pts:${offset+headerLength}/${frameLength}/${data.byteLength}/${(stamp/90).toFixed(0)}`);
          aacSample = { unit: data.subarray(offset + headerLength, offset + headerLength + frameLength), pts: stamp, dts: stamp };
          track.samples.push(aacSample);
          track.len += frameLength;
          offset += frameLength + headerLength;
          frameIndex++;
          // look for ADTS header (0xFFFx)
          for (; offset < len - 1; offset++) {
            if (data[offset] === 0xff && (data[offset + 1] & 0xf0) === 0xf0) {
              break;
            }
          }
        } else {
          break;
        }
      }
      this.remuxer.remux(level, sn, this._aacTrack, { samples: [] }, { samples: [{ pts: pts, dts: pts, unit: id3.payload }] }, { samples: [] }, timeOffset, contiguous, accurateTimeOffset);
    }
  }, {
    key: 'destroy',
    value: function destroy() {}
  }], [{
    key: 'probe',
    value: function probe(data) {
      // check if data contains ID3 timestamp and ADTS sync worc
      var id3 = new _id2.default(data),
          offset,
          len;
      if (id3.hasTimeStamp) {
        // look for ADTS header (0xFFFx)
        for (offset = id3.length, len = data.length; offset < len - 1; offset++) {
          if (data[offset] === 0xff && (data[offset + 1] & 0xf0) === 0xf0) {
            //logger.log('ADTS sync word found !');
            return true;
          }
        }
      }
      return false;
    }
  }]);

  return AACDemuxer;
}();

exports.default = AACDemuxer;

},{"../demux/id3":23,"../utils/logger":44,"./adts":18}],18:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *  ADTS parser helper
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */


var _logger = require('../utils/logger');

var _errors = require('../errors');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ADTS = function () {
  function ADTS() {
    _classCallCheck(this, ADTS);
  }

  _createClass(ADTS, null, [{
    key: 'getAudioConfig',
    value: function getAudioConfig(observer, data, offset, audioCodec) {
      var adtsObjectType,
          // :int
      adtsSampleingIndex,
          // :int
      adtsExtensionSampleingIndex,
          // :int
      adtsChanelConfig,
          // :int
      config,
          userAgent = navigator.userAgent.toLowerCase(),
          adtsSampleingRates = [96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050, 16000, 12000, 11025, 8000, 7350];
      // byte 2
      adtsObjectType = ((data[offset + 2] & 0xC0) >>> 6) + 1;
      adtsSampleingIndex = (data[offset + 2] & 0x3C) >>> 2;
      if (adtsSampleingIndex > adtsSampleingRates.length - 1) {
        observer.trigger(Event.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.FRAG_PARSING_ERROR, fatal: true, reason: 'invalid ADTS sampling index:' + adtsSampleingIndex });
        return;
      }
      adtsChanelConfig = (data[offset + 2] & 0x01) << 2;
      // byte 3
      adtsChanelConfig |= (data[offset + 3] & 0xC0) >>> 6;
      _logger.logger.log('manifest codec:' + audioCodec + ',ADTS data:type:' + adtsObjectType + ',sampleingIndex:' + adtsSampleingIndex + '[' + adtsSampleingRates[adtsSampleingIndex] + 'Hz],channelConfig:' + adtsChanelConfig);
      // firefox/Opera: freq less than 24kHz = AAC SBR (HE-AAC)
      if (/firefox|OPR/i.test(userAgent)) {
        if (adtsSampleingIndex >= 6) {
          adtsObjectType = 5;
          config = new Array(4);
          // HE-AAC uses SBR (Spectral Band Replication) , high frequencies are constructed from low frequencies
          // there is a factor 2 between frame sample rate and output sample rate
          // multiply frequency by 2 (see table below, equivalent to substract 3)
          adtsExtensionSampleingIndex = adtsSampleingIndex - 3;
        } else {
          adtsObjectType = 2;
          config = new Array(2);
          adtsExtensionSampleingIndex = adtsSampleingIndex;
        }
        // Android : always use AAC
      } else if (userAgent.indexOf('android') !== -1) {
        adtsObjectType = 2;
        config = new Array(2);
        adtsExtensionSampleingIndex = adtsSampleingIndex;
      } else {
        /*  for other browsers (Chrome/Vivaldi ...)
            always force audio type to be HE-AAC SBR, as some browsers do not support audio codec switch properly (like Chrome ...)
        */
        adtsObjectType = 5;
        config = new Array(4);
        // if (manifest codec is HE-AAC or HE-AACv2) OR (manifest codec not specified AND frequency less than 24kHz)
        if (audioCodec && (audioCodec.indexOf('mp4a.40.29') !== -1 || audioCodec.indexOf('mp4a.40.5') !== -1) || !audioCodec && adtsSampleingIndex >= 6) {
          // HE-AAC uses SBR (Spectral Band Replication) , high frequencies are constructed from low frequencies
          // there is a factor 2 between frame sample rate and output sample rate
          // multiply frequency by 2 (see table below, equivalent to substract 3)
          adtsExtensionSampleingIndex = adtsSampleingIndex - 3;
        } else {
          // if (manifest codec is AAC) AND (frequency less than 24kHz AND nb channel is 1) OR (manifest codec not specified and mono audio)
          // Chrome fails to play back with low frequency AAC LC mono when initialized with HE-AAC.  This is not a problem with stereo.
          if (audioCodec && audioCodec.indexOf('mp4a.40.2') !== -1 && adtsSampleingIndex >= 6 && adtsChanelConfig === 1 || !audioCodec && adtsChanelConfig === 1) {
            adtsObjectType = 2;
            config = new Array(2);
          }
          adtsExtensionSampleingIndex = adtsSampleingIndex;
        }
      }
      /* refer to http://wiki.multimedia.cx/index.php?title=MPEG-4_Audio#Audio_Specific_Config
          ISO 14496-3 (AAC).pdf - Table 1.13 â€” Syntax of AudioSpecificConfig()
        Audio Profile / Audio Object Type
        0: Null
        1: AAC Main
        2: AAC LC (Low Complexity)
        3: AAC SSR (Scalable Sample Rate)
        4: AAC LTP (Long Term Prediction)
        5: SBR (Spectral Band Replication)
        6: AAC Scalable
       sampling freq
        0: 96000 Hz
        1: 88200 Hz
        2: 64000 Hz
        3: 48000 Hz
        4: 44100 Hz
        5: 32000 Hz
        6: 24000 Hz
        7: 22050 Hz
        8: 16000 Hz
        9: 12000 Hz
        10: 11025 Hz
        11: 8000 Hz
        12: 7350 Hz
        13: Reserved
        14: Reserved
        15: frequency is written explictly
        Channel Configurations
        These are the channel configurations:
        0: Defined in AOT Specifc Config
        1: 1 channel: front-center
        2: 2 channels: front-left, front-right
      */
      // audioObjectType = profile => profile, the MPEG-4 Audio Object Type minus 1
      config[0] = adtsObjectType << 3;
      // samplingFrequencyIndex
      config[0] |= (adtsSampleingIndex & 0x0E) >> 1;
      config[1] |= (adtsSampleingIndex & 0x01) << 7;
      // channelConfiguration
      config[1] |= adtsChanelConfig << 3;
      if (adtsObjectType === 5) {
        // adtsExtensionSampleingIndex
        config[1] |= (adtsExtensionSampleingIndex & 0x0E) >> 1;
        config[2] = (adtsExtensionSampleingIndex & 0x01) << 7;
        // adtsObjectType (force to 2, chrome is checking that object type is less than 5 ???
        //    https://chromium.googlesource.com/chromium/src.git/+/master/media/formats/mp4/aac.cc
        config[2] |= 2 << 2;
        config[3] = 0;
      }
      return { config: config, samplerate: adtsSampleingRates[adtsSampleingIndex], channelCount: adtsChanelConfig, codec: 'mp4a.40.' + adtsObjectType };
    }
  }]);

  return ADTS;
}();

exports.default = ADTS;

},{"../errors":25,"../utils/logger":44}],19:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*  inline demuxer.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *   probe fragments and instantiate appropriate demuxer depending on content type (TSDemuxer, AACDemuxer, ...)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _errors = require('../errors');

var _aacdemuxer = require('../demux/aacdemuxer');

var _aacdemuxer2 = _interopRequireDefault(_aacdemuxer);

var _tsdemuxer = require('../demux/tsdemuxer');

var _tsdemuxer2 = _interopRequireDefault(_tsdemuxer);

var _mp4Remuxer = require('../remux/mp4-remuxer');

var _mp4Remuxer2 = _interopRequireDefault(_mp4Remuxer);

var _passthroughRemuxer = require('../remux/passthrough-remuxer');

var _passthroughRemuxer2 = _interopRequireDefault(_passthroughRemuxer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var DemuxerInline = function () {
  function DemuxerInline(hls, id, typeSupported) {
    var config = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

    _classCallCheck(this, DemuxerInline);

    this.hls = hls;
    this.id = id;
    this.config = this.hls.config || config;
    this.typeSupported = typeSupported;
  }

  _createClass(DemuxerInline, [{
    key: 'destroy',
    value: function destroy() {
      var demuxer = this.demuxer;
      if (demuxer) {
        demuxer.destroy();
      }
    }
  }, {
    key: 'push',
    value: function push(data, audioCodec, videoCodec, timeOffset, cc, level, sn, duration, accurateTimeOffset) {
      var demuxer = this.demuxer;
      if (!demuxer) {
        var hls = this.hls,
            id = this.id;
        // probe for content type
        if (_tsdemuxer2.default.probe(data)) {
          if (this.typeSupported.mp2t === true) {
            demuxer = new _tsdemuxer2.default(hls, id, _passthroughRemuxer2.default, this.config);
          } else {
            demuxer = new _tsdemuxer2.default(hls, id, _mp4Remuxer2.default, this.config);
          }
        } else if (_aacdemuxer2.default.probe(data)) {
          demuxer = new _aacdemuxer2.default(hls, id, _mp4Remuxer2.default, this.config);
        } else {
          hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, id: id, details: _errors.ErrorDetails.FRAG_PARSING_ERROR, fatal: true, reason: 'no demux matching with content found' });
          return;
        }
        this.demuxer = demuxer;
      }
      demuxer.push(data, audioCodec, videoCodec, timeOffset, cc, level, sn, duration, accurateTimeOffset);
    }
  }]);

  return DemuxerInline;
}();

exports.default = DemuxerInline;

},{"../demux/aacdemuxer":17,"../demux/tsdemuxer":24,"../errors":25,"../events":27,"../remux/mp4-remuxer":37,"../remux/passthrough-remuxer":38}],20:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _demuxerInline = require('../demux/demuxer-inline');

var _demuxerInline2 = _interopRequireDefault(_demuxerInline);

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _logger = require('../utils/logger');

var _events3 = require('events');

var _events4 = _interopRequireDefault(_events3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* demuxer web worker.
 *  - listen to worker message, and trigger DemuxerInline upon reception of Fragments.
 *  - provides MP4 Boxes back to main thread using [transferable objects](https://developers.google.com/web/updates/2011/12/Transferable-Objects-Lightning-Fast) in order to minimize message passing overhead.
 */

var DemuxerWorker = function DemuxerWorker(self) {
  // observer setup
  var observer = new _events4.default();
  observer.trigger = function trigger(event) {
    for (var _len = arguments.length, data = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      data[_key - 1] = arguments[_key];
    }

    observer.emit.apply(observer, [event, event].concat(data));
  };

  observer.off = function off(event) {
    for (var _len2 = arguments.length, data = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      data[_key2 - 1] = arguments[_key2];
    }

    observer.removeListener.apply(observer, [event].concat(data));
  };
  self.addEventListener('message', function (ev) {
    var data = ev.data;
    //console.log('demuxer cmd:' + data.cmd);
    switch (data.cmd) {
      case 'init':
        var config = JSON.parse(data.config);
        self.demuxer = new _demuxerInline2.default(observer, data.id, data.typeSupported, config);
        try {
          (0, _logger.enableLogs)(config.debug);
        } catch (err) {
          console.warn('demuxerWorker: unable to enable logs');
        }
        break;
      case 'demux':
        self.demuxer.push(new Uint8Array(data.data), data.audioCodec, data.videoCodec, data.timeOffset, data.cc, data.level, data.sn, data.duration, data.accurateTimeOffset);
        break;
      default:
        break;
    }
  });

  var forwardMessage = function forwardMessage(ev, data) {
    self.postMessage({ event: ev, data: data });
  };

  // forward events to main thread
  observer.on(_events2.default.FRAG_PARSING_INIT_SEGMENT, forwardMessage);
  observer.on(_events2.default.FRAG_PARSED, forwardMessage);
  observer.on(_events2.default.ERROR, forwardMessage);
  observer.on(_events2.default.FRAG_PARSING_METADATA, forwardMessage);
  observer.on(_events2.default.FRAG_PARSING_USERDATA, forwardMessage);

  // special case for FRAG_PARSING_DATA: pass data1/data2 as transferable object (no copy)
  observer.on(_events2.default.FRAG_PARSING_DATA, function (ev, data) {
    var data1 = data.data1.buffer,
        data2 = data.data2.buffer;
    // remove data1 and data2 reference from data to avoid copying them ...
    delete data.data1;
    delete data.data2;
    self.postMessage({ event: ev, data: data, data1: data1, data2: data2 }, [data1, data2]);
  });
};

exports.default = DemuxerWorker;

},{"../demux/demuxer-inline":19,"../events":27,"../utils/logger":44,"events":1}],21:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _demuxerInline = require('../demux/demuxer-inline');

var _demuxerInline2 = _interopRequireDefault(_demuxerInline);

var _demuxerWorker = require('../demux/demuxer-worker');

var _demuxerWorker2 = _interopRequireDefault(_demuxerWorker);

var _logger = require('../utils/logger');

var _decrypter = require('../crypt/decrypter');

var _decrypter2 = _interopRequireDefault(_decrypter);

var _errors = require('../errors');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Demuxer = function () {
  function Demuxer(hls, id) {
    _classCallCheck(this, Demuxer);

    this.hls = hls;
    this.id = id;
    var typeSupported = {
      mp4: MediaSource.isTypeSupported('video/mp4'),
      mp2t: hls.config.enableMP2TPassThrough && MediaSource.isTypeSupported('video/mp2t')
    };
    if (hls.config.enableWorker && typeof Worker !== 'undefined') {
      _logger.logger.log('demuxing in webworker');
      try {
        var work = require('webworkify');
        var w = this.w = work(_demuxerWorker2.default);
        this.onwmsg = this.onWorkerMessage.bind(this);
        w.addEventListener('message', this.onwmsg);
        w.onerror = function (event) {
          hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.OTHER_ERROR, details: _errors.ErrorDetails.INTERNAL_EXCEPTION, fatal: true, event: 'demuxerWorker', err: { message: event.message + ' (' + event.filename + ':' + event.lineno + ')' } });
        };
        w.postMessage({ cmd: 'init', typeSupported: typeSupported, id: id, config: JSON.stringify(hls.config) });
      } catch (err) {
        _logger.logger.error('error while initializing DemuxerWorker, fallback on DemuxerInline');
        this.demuxer = new _demuxerInline2.default(hls, id, typeSupported);
      }
    } else {
      this.demuxer = new _demuxerInline2.default(hls, id, typeSupported);
    }
    this.demuxInitialized = true;
  }

  _createClass(Demuxer, [{
    key: 'destroy',
    value: function destroy() {
      var w = this.w;
      if (w) {
        w.removeEventListener('message', this.onwmsg);
        w.terminate();
        this.w = null;
      } else {
        var demuxer = this.demuxer;
        if (demuxer) {
          demuxer.destroy();
          this.demuxer = null;
        }
      }
      var decrypter = this.decrypter;
      if (decrypter) {
        decrypter.destroy();
        this.decrypter = null;
      }
    }
  }, {
    key: 'pushDecrypted',
    value: function pushDecrypted(data, audioCodec, videoCodec, timeOffset, cc, level, sn, duration, accurateTimeOffset) {
      var w = this.w;
      if (w) {
        // post fragment payload as transferable objects (no copy)
        w.postMessage({ cmd: 'demux', data: data, audioCodec: audioCodec, videoCodec: videoCodec, timeOffset: timeOffset, cc: cc, level: level, sn: sn, duration: duration, accurateTimeOffset: accurateTimeOffset }, [data]);
      } else {
        var demuxer = this.demuxer;
        if (demuxer) {
          demuxer.push(new Uint8Array(data), audioCodec, videoCodec, timeOffset, cc, level, sn, duration, accurateTimeOffset);
        }
      }
    }
  }, {
    key: 'push',
    value: function push(data, audioCodec, videoCodec, timeOffset, cc, level, sn, duration, decryptdata, accurateTimeOffset) {
      if (data.byteLength > 0 && decryptdata != null && decryptdata.key != null && decryptdata.method === 'AES-128') {
        if (this.decrypter == null) {
          this.decrypter = new _decrypter2.default(this.hls);
        }

        var localthis = this;
        this.decrypter.decrypt(data, decryptdata.key.buffer, decryptdata.iv.buffer, function (decryptedData) {
          localthis.pushDecrypted(decryptedData, audioCodec, videoCodec, timeOffset, cc, level, sn, duration, accurateTimeOffset);
        });
      } else {
        this.pushDecrypted(data, audioCodec, videoCodec, timeOffset, cc, level, sn, duration, accurateTimeOffset);
      }
    }
  }, {
    key: 'onWorkerMessage',
    value: function onWorkerMessage(ev) {
      var data = ev.data,
          hls = this.hls;
      //console.log('onWorkerMessage:' + data.event);
      switch (data.event) {
        // special case for FRAG_PARSING_DATA: data1 and data2 are transferable objects
        case _events2.default.FRAG_PARSING_DATA:
          data.data.data1 = new Uint8Array(data.data1);
          data.data.data2 = new Uint8Array(data.data2);
        /* falls through */
        default:
          hls.trigger(data.event, data.data);
          break;
      }
    }
  }]);

  return Demuxer;
}();

exports.default = Demuxer;

},{"../crypt/decrypter":15,"../demux/demuxer-inline":19,"../demux/demuxer-worker":20,"../errors":25,"../events":27,"../utils/logger":44,"webworkify":2}],22:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Parser for exponential Golomb codes, a variable-bitwidth number encoding scheme used by h264.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */

var _logger = require('../utils/logger');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ExpGolomb = function () {
  function ExpGolomb(data) {
    _classCallCheck(this, ExpGolomb);

    this.data = data;
    // the number of bytes left to examine in this.data
    this.bytesAvailable = this.data.byteLength;
    // the current word being examined
    this.word = 0; // :uint
    // the number of bits left to examine in the current word
    this.bitsAvailable = 0; // :uint
  }

  // ():void


  _createClass(ExpGolomb, [{
    key: 'loadWord',
    value: function loadWord() {
      var position = this.data.byteLength - this.bytesAvailable,
          workingBytes = new Uint8Array(4),
          availableBytes = Math.min(4, this.bytesAvailable);
      if (availableBytes === 0) {
        throw new Error('no bytes available');
      }
      workingBytes.set(this.data.subarray(position, position + availableBytes));
      this.word = new DataView(workingBytes.buffer).getUint32(0);
      // track the amount of this.data that has been processed
      this.bitsAvailable = availableBytes * 8;
      this.bytesAvailable -= availableBytes;
    }

    // (count:int):void

  }, {
    key: 'skipBits',
    value: function skipBits(count) {
      var skipBytes; // :int
      if (this.bitsAvailable > count) {
        this.word <<= count;
        this.bitsAvailable -= count;
      } else {
        count -= this.bitsAvailable;
        skipBytes = count >> 3;
        count -= skipBytes >> 3;
        this.bytesAvailable -= skipBytes;
        this.loadWord();
        this.word <<= count;
        this.bitsAvailable -= count;
      }
    }

    // (size:int):uint

  }, {
    key: 'readBits',
    value: function readBits(size) {
      var bits = Math.min(this.bitsAvailable, size),
          // :uint
      valu = this.word >>> 32 - bits; // :uint
      if (size > 32) {
        _logger.logger.error('Cannot read more than 32 bits at a time');
      }
      this.bitsAvailable -= bits;
      if (this.bitsAvailable > 0) {
        this.word <<= bits;
      } else if (this.bytesAvailable > 0) {
        this.loadWord();
      }
      bits = size - bits;
      if (bits > 0 && this.bitsAvailable) {
        return valu << bits | this.readBits(bits);
      } else {
        return valu;
      }
    }

    // ():uint

  }, {
    key: 'skipLZ',
    value: function skipLZ() {
      var leadingZeroCount; // :uint
      for (leadingZeroCount = 0; leadingZeroCount < this.bitsAvailable; ++leadingZeroCount) {
        if (0 !== (this.word & 0x80000000 >>> leadingZeroCount)) {
          // the first bit of working word is 1
          this.word <<= leadingZeroCount;
          this.bitsAvailable -= leadingZeroCount;
          return leadingZeroCount;
        }
      }
      // we exhausted word and still have not found a 1
      this.loadWord();
      return leadingZeroCount + this.skipLZ();
    }

    // ():void

  }, {
    key: 'skipUEG',
    value: function skipUEG() {
      this.skipBits(1 + this.skipLZ());
    }

    // ():void

  }, {
    key: 'skipEG',
    value: function skipEG() {
      this.skipBits(1 + this.skipLZ());
    }

    // ():uint

  }, {
    key: 'readUEG',
    value: function readUEG() {
      var clz = this.skipLZ(); // :uint
      return this.readBits(clz + 1) - 1;
    }

    // ():int

  }, {
    key: 'readEG',
    value: function readEG() {
      var valu = this.readUEG(); // :int
      if (0x01 & valu) {
        // the number is odd if the low order bit is set
        return 1 + valu >>> 1; // add 1 to make it even, and divide by 2
      } else {
        return -1 * (valu >>> 1); // divide by two then make it negative
      }
    }

    // Some convenience functions
    // :Boolean

  }, {
    key: 'readBoolean',
    value: function readBoolean() {
      return 1 === this.readBits(1);
    }

    // ():int

  }, {
    key: 'readUByte',
    value: function readUByte() {
      return this.readBits(8);
    }

    // ():int

  }, {
    key: 'readUShort',
    value: function readUShort() {
      return this.readBits(16);
    }
    // ():int

  }, {
    key: 'readUInt',
    value: function readUInt() {
      return this.readBits(32);
    }

    /**
     * Advance the ExpGolomb decoder past a scaling list. The scaling
     * list is optionally transmitted as part of a sequence parameter
     * set and is not relevant to transmuxing.
     * @param count {number} the number of entries in this scaling list
     * @see Recommendation ITU-T H.264, Section 7.3.2.1.1.1
     */

  }, {
    key: 'skipScalingList',
    value: function skipScalingList(count) {
      var lastScale = 8,
          nextScale = 8,
          j,
          deltaScale;
      for (j = 0; j < count; j++) {
        if (nextScale !== 0) {
          deltaScale = this.readEG();
          nextScale = (lastScale + deltaScale + 256) % 256;
        }
        lastScale = nextScale === 0 ? lastScale : nextScale;
      }
    }

    /**
     * Read a sequence parameter set and return some interesting video
     * properties. A sequence parameter set is the H264 metadata that
     * describes the properties of upcoming video frames.
     * @param data {Uint8Array} the bytes of a sequence parameter set
     * @return {object} an object with configuration parsed from the
     * sequence parameter set, including the dimensions of the
     * associated video frames.
     */

  }, {
    key: 'readSPS',
    value: function readSPS() {
      var frameCropLeftOffset = 0,
          frameCropRightOffset = 0,
          frameCropTopOffset = 0,
          frameCropBottomOffset = 0,
          sarScale = 1,
          profileIdc,
          profileCompat,
          levelIdc,
          numRefFramesInPicOrderCntCycle,
          picWidthInMbsMinus1,
          picHeightInMapUnitsMinus1,
          frameMbsOnlyFlag,
          scalingListCount,
          i;
      this.readUByte();
      profileIdc = this.readUByte(); // profile_idc
      profileCompat = this.readBits(5); // constraint_set[0-4]_flag, u(5)
      this.skipBits(3); // reserved_zero_3bits u(3),
      levelIdc = this.readUByte(); //level_idc u(8)
      this.skipUEG(); // seq_parameter_set_id
      // some profiles have more optional data we don't need
      if (profileIdc === 100 || profileIdc === 110 || profileIdc === 122 || profileIdc === 244 || profileIdc === 44 || profileIdc === 83 || profileIdc === 86 || profileIdc === 118 || profileIdc === 128) {
        var chromaFormatIdc = this.readUEG();
        if (chromaFormatIdc === 3) {
          this.skipBits(1); // separate_colour_plane_flag
        }
        this.skipUEG(); // bit_depth_luma_minus8
        this.skipUEG(); // bit_depth_chroma_minus8
        this.skipBits(1); // qpprime_y_zero_transform_bypass_flag
        if (this.readBoolean()) {
          // seq_scaling_matrix_present_flag
          scalingListCount = chromaFormatIdc !== 3 ? 8 : 12;
          for (i = 0; i < scalingListCount; i++) {
            if (this.readBoolean()) {
              // seq_scaling_list_present_flag[ i ]
              if (i < 6) {
                this.skipScalingList(16);
              } else {
                this.skipScalingList(64);
              }
            }
          }
        }
      }
      this.skipUEG(); // log2_max_frame_num_minus4
      var picOrderCntType = this.readUEG();
      if (picOrderCntType === 0) {
        this.readUEG(); //log2_max_pic_order_cnt_lsb_minus4
      } else if (picOrderCntType === 1) {
        this.skipBits(1); // delta_pic_order_always_zero_flag
        this.skipEG(); // offset_for_non_ref_pic
        this.skipEG(); // offset_for_top_to_bottom_field
        numRefFramesInPicOrderCntCycle = this.readUEG();
        for (i = 0; i < numRefFramesInPicOrderCntCycle; i++) {
          this.skipEG(); // offset_for_ref_frame[ i ]
        }
      }
      this.skipUEG(); // max_num_ref_frames
      this.skipBits(1); // gaps_in_frame_num_value_allowed_flag
      picWidthInMbsMinus1 = this.readUEG();
      picHeightInMapUnitsMinus1 = this.readUEG();
      frameMbsOnlyFlag = this.readBits(1);
      if (frameMbsOnlyFlag === 0) {
        this.skipBits(1); // mb_adaptive_frame_field_flag
      }
      this.skipBits(1); // direct_8x8_inference_flag
      if (this.readBoolean()) {
        // frame_cropping_flag
        frameCropLeftOffset = this.readUEG();
        frameCropRightOffset = this.readUEG();
        frameCropTopOffset = this.readUEG();
        frameCropBottomOffset = this.readUEG();
      }
      if (this.readBoolean()) {
        // vui_parameters_present_flag
        if (this.readBoolean()) {
          // aspect_ratio_info_present_flag
          var sarRatio = void 0;
          var aspectRatioIdc = this.readUByte();
          switch (aspectRatioIdc) {
            case 1:
              sarRatio = [1, 1];break;
            case 2:
              sarRatio = [12, 11];break;
            case 3:
              sarRatio = [10, 11];break;
            case 4:
              sarRatio = [16, 11];break;
            case 5:
              sarRatio = [40, 33];break;
            case 6:
              sarRatio = [24, 11];break;
            case 7:
              sarRatio = [20, 11];break;
            case 8:
              sarRatio = [32, 11];break;
            case 9:
              sarRatio = [80, 33];break;
            case 10:
              sarRatio = [18, 11];break;
            case 11:
              sarRatio = [15, 11];break;
            case 12:
              sarRatio = [64, 33];break;
            case 13:
              sarRatio = [160, 99];break;
            case 14:
              sarRatio = [4, 3];break;
            case 15:
              sarRatio = [3, 2];break;
            case 16:
              sarRatio = [2, 1];break;
            case 255:
              {
                sarRatio = [this.readUByte() << 8 | this.readUByte(), this.readUByte() << 8 | this.readUByte()];
                break;
              }
          }
          if (sarRatio) {
            sarScale = sarRatio[0] / sarRatio[1];
          }
        }
      }
      return {
        width: Math.ceil(((picWidthInMbsMinus1 + 1) * 16 - frameCropLeftOffset * 2 - frameCropRightOffset * 2) * sarScale),
        height: (2 - frameMbsOnlyFlag) * (picHeightInMapUnitsMinus1 + 1) * 16 - (frameMbsOnlyFlag ? 2 : 4) * (frameCropTopOffset + frameCropBottomOffset)
      };
    }
  }, {
    key: 'readSliceType',
    value: function readSliceType() {
      // skip NALu type
      this.readUByte();
      // discard first_mb_in_slice
      this.readUEG();
      // return slice_type
      return this.readUEG();
    }
  }]);

  return ExpGolomb;
}();

exports.default = ExpGolomb;

},{"../utils/logger":44}],23:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * ID3 parser
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */


var _logger = require('../utils/logger');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

//import Hex from '../utils/hex';

var ID3 = function () {
  function ID3(data) {
    _classCallCheck(this, ID3);

    this._hasTimeStamp = false;
    var offset = 0,
        byte1,
        byte2,
        byte3,
        byte4,
        tagSize,
        endPos,
        header,
        len;
    do {
      header = this.readUTF(data, offset, 3);
      offset += 3;
      // first check for ID3 header
      if (header === 'ID3') {
        // skip 24 bits
        offset += 3;
        // retrieve tag(s) length
        byte1 = data[offset++] & 0x7f;
        byte2 = data[offset++] & 0x7f;
        byte3 = data[offset++] & 0x7f;
        byte4 = data[offset++] & 0x7f;
        tagSize = (byte1 << 21) + (byte2 << 14) + (byte3 << 7) + byte4;
        endPos = offset + tagSize;
        //logger.log(`ID3 tag found, size/end: ${tagSize}/${endPos}`);

        // read ID3 tags
        this._parseID3Frames(data, offset, endPos);
        offset = endPos;
      } else if (header === '3DI') {
        // http://id3.org/id3v2.4.0-structure chapter 3.4.   ID3v2 footer
        offset += 7;
        _logger.logger.log('3DI footer found, end: ' + offset);
      } else {
        offset -= 3;
        len = offset;
        if (len) {
          //logger.log(`ID3 len: ${len}`);
          if (!this.hasTimeStamp) {
            _logger.logger.warn('ID3 tag found, but no timestamp');
          }
          this._length = len;
          this._payload = data.subarray(0, len);
        }
        return;
      }
    } while (true);
  }

  _createClass(ID3, [{
    key: 'readUTF',
    value: function readUTF(data, start, len) {

      var result = '',
          offset = start,
          end = start + len;
      do {
        result += String.fromCharCode(data[offset++]);
      } while (offset < end);
      return result;
    }
  }, {
    key: '_parseID3Frames',
    value: function _parseID3Frames(data, offset, endPos) {
      var tagId, tagLen, tagStart, tagFlags, timestamp;
      while (offset + 8 <= endPos) {
        tagId = this.readUTF(data, offset, 4);
        offset += 4;

        tagLen = data[offset++] << 24 + data[offset++] << 16 + data[offset++] << 8 + data[offset++];

        tagFlags = data[offset++] << 8 + data[offset++];

        tagStart = offset;
        //logger.log("ID3 tag id:" + tagId);
        switch (tagId) {
          case 'PRIV':
            //logger.log('parse frame:' + Hex.hexDump(data.subarray(offset,endPos)));
            // owner should be "com.apple.streaming.transportStreamTimestamp"
            if (this.readUTF(data, offset, 44) === 'com.apple.streaming.transportStreamTimestamp') {
              offset += 44;
              // smelling even better ! we found the right descriptor
              // skip null character (string end) + 3 first bytes
              offset += 4;

              // timestamp is 33 bit expressed as a big-endian eight-octet number, with the upper 31 bits set to zero.
              var pts33Bit = data[offset++] & 0x1;
              this._hasTimeStamp = true;

              timestamp = ((data[offset++] << 23) + (data[offset++] << 15) + (data[offset++] << 7) + data[offset++]) / 45;

              if (pts33Bit) {
                timestamp += 47721858.84; // 2^32 / 90
              }
              timestamp = Math.round(timestamp);
              _logger.logger.trace('ID3 timestamp found: ' + timestamp);
              this._timeStamp = timestamp;
            }
            break;
          default:
            break;
        }
      }
    }
  }, {
    key: 'hasTimeStamp',
    get: function get() {
      return this._hasTimeStamp;
    }
  }, {
    key: 'timeStamp',
    get: function get() {
      return this._timeStamp;
    }
  }, {
    key: 'length',
    get: function get() {
      return this._length;
    }
  }, {
    key: 'payload',
    get: function get() {
      return this._payload;
    }
  }]);

  return ID3;
}();

exports.default = ID3;

},{"../utils/logger":44}],24:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * highly optimized TS demuxer:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * parse PAT, PMT
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * extract PES packet from audio and video PIDs
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * extract AVC/H264 NAL units and AAC/ADTS samples from PES packet
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * trigger the remuxer upon parsing completion
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * it also tries to workaround as best as it can audio codec switch (HE-AAC to AAC and vice versa), without having to restart the MediaSource.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * it also controls the remuxing process :
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * upon discontinuity or level switch detection, it will also notifies the remuxer so that it can reset its state.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */

// import Hex from '../utils/hex';


var _adts = require('./adts');

var _adts2 = _interopRequireDefault(_adts);

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _expGolomb = require('./exp-golomb');

var _expGolomb2 = _interopRequireDefault(_expGolomb);

var _logger = require('../utils/logger');

var _errors = require('../errors');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var TSDemuxer = function () {
  function TSDemuxer(observer, id, remuxerClass, config) {
    _classCallCheck(this, TSDemuxer);

    this.observer = observer;
    this.id = id;
    this.remuxerClass = remuxerClass;
    this.config = config;
    this.lastCC = 0;
    this.remuxer = new this.remuxerClass(observer, id, config);
  }

  _createClass(TSDemuxer, [{
    key: 'switchLevel',
    value: function switchLevel() {
      this.pmtParsed = false;
      this._pmtId = -1;
      this._avcTrack = { container: 'video/mp2t', type: 'video', id: -1, sequenceNumber: 0, samples: [], len: 0, dropped: 0 };
      this._aacTrack = { container: 'video/mp2t', type: 'audio', id: -1, sequenceNumber: 0, samples: [], len: 0 };
      this._id3Track = { type: 'id3', id: -1, sequenceNumber: 0, samples: [], len: 0 };
      this._txtTrack = { type: 'text', id: -1, sequenceNumber: 0, samples: [], len: 0 };
      // flush any partial content
      this.aacOverFlow = null;
      this.aacLastPTS = null;
      this.avcSample = null;
      this.remuxer.switchLevel();
    }
  }, {
    key: 'insertDiscontinuity',
    value: function insertDiscontinuity() {
      this.switchLevel();
      this.remuxer.insertDiscontinuity();
    }

    // feed incoming data to the front of the parsing pipeline

  }, {
    key: 'push',
    value: function push(data, audioCodec, videoCodec, timeOffset, cc, level, sn, duration, accurateTimeOffset) {
      var start,
          len = data.length,
          stt,
          pid,
          atf,
          offset,
          pes,
          codecsOnly = this.remuxer.passthrough,
          unknownPIDs = false;

      this.audioCodec = audioCodec;
      this.videoCodec = videoCodec;
      this._duration = duration;
      this.contiguous = false;
      this.accurateTimeOffset = accurateTimeOffset;
      if (cc !== this.lastCC) {
        _logger.logger.log('discontinuity detected');
        this.insertDiscontinuity();
        this.lastCC = cc;
      }
      if (level !== this.lastLevel) {
        _logger.logger.log('level switch detected');
        this.switchLevel();
        this.lastLevel = level;
      } else if (sn === this.lastSN + 1) {
        this.contiguous = true;
      }
      this.lastSN = sn;

      var pmtParsed = this.pmtParsed,
          avcTrack = this._avcTrack,
          aacTrack = this._aacTrack,
          id3Track = this._id3Track,
          avcId = avcTrack.id,
          aacId = aacTrack.id,
          id3Id = id3Track.id,
          pmtId = this._pmtId,
          avcData = avcTrack.pesData,
          aacData = aacTrack.pesData,
          id3Data = id3Track.pesData,
          parsePAT = this._parsePAT,
          parsePMT = this._parsePMT,
          parsePES = this._parsePES,
          parseAVCPES = this._parseAVCPES.bind(this),
          parseAACPES = this._parseAACPES.bind(this),
          parseID3PES = this._parseID3PES.bind(this);

      // don't parse last TS packet if incomplete
      len -= len % 188;
      // loop through TS packets
      for (start = 0; start < len; start += 188) {
        if (data[start] === 0x47) {
          stt = !!(data[start + 1] & 0x40);
          // pid is a 13-bit field starting at the last bit of TS[1]
          pid = ((data[start + 1] & 0x1f) << 8) + data[start + 2];
          atf = (data[start + 3] & 0x30) >> 4;
          // if an adaption field is present, its length is specified by the fifth byte of the TS packet header.
          if (atf > 1) {
            offset = start + 5 + data[start + 4];
            // continue if there is only adaptation field
            if (offset === start + 188) {
              continue;
            }
          } else {
            offset = start + 4;
          }
          switch (pid) {
            case avcId:
              if (stt) {
                if (avcData && (pes = parsePES(avcData))) {
                  parseAVCPES(pes, false);
                  if (codecsOnly) {
                    // if we have video codec info AND
                    // if audio PID is undefined OR if we have audio codec info,
                    // we have all codec info !
                    if (avcTrack.codec && (aacId === -1 || aacTrack.codec)) {
                      this.remux(level, sn, data, timeOffset);
                      return;
                    }
                  }
                }
                avcData = { data: [], size: 0 };
              }
              if (avcData) {
                avcData.data.push(data.subarray(offset, start + 188));
                avcData.size += start + 188 - offset;
              }
              break;
            case aacId:
              if (stt) {
                if (aacData && (pes = parsePES(aacData))) {
                  parseAACPES(pes);
                  if (codecsOnly) {
                    // here we now that we have audio codec info
                    // if video PID is undefined OR if we have video codec info,
                    // we have all codec infos !
                    if (aacTrack.codec && (avcId === -1 || avcTrack.codec)) {
                      this.remux(level, sn, data, timeOffset);
                      return;
                    }
                  }
                }
                aacData = { data: [], size: 0 };
              }
              if (aacData) {
                aacData.data.push(data.subarray(offset, start + 188));
                aacData.size += start + 188 - offset;
              }
              break;
            case id3Id:
              if (stt) {
                if (id3Data && (pes = parsePES(id3Data))) {
                  parseID3PES(pes);
                }
                id3Data = { data: [], size: 0 };
              }
              if (id3Data) {
                id3Data.data.push(data.subarray(offset, start + 188));
                id3Data.size += start + 188 - offset;
              }
              break;
            case 0:
              if (stt) {
                offset += data[offset] + 1;
              }
              pmtId = this._pmtId = parsePAT(data, offset);
              break;
            case pmtId:
              if (stt) {
                offset += data[offset] + 1;
              }
              var parsedPIDs = parsePMT(data, offset);
              avcId = avcTrack.id = parsedPIDs.avc;
              aacId = aacTrack.id = parsedPIDs.aac;
              id3Id = id3Track.id = parsedPIDs.id3;
              if (unknownPIDs && !pmtParsed) {
                _logger.logger.log('reparse from beginning');
                unknownPIDs = false;
                // we set it to -188, the += 188 in the for loop will reset start to 0
                start = -188;
              }
              pmtParsed = this.pmtParsed = true;
              break;
            case 17:
            case 0x1fff:
              break;
            default:
              unknownPIDs = true;
              break;
          }
        } else {
          this.observer.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, id: this.id, details: _errors.ErrorDetails.FRAG_PARSING_ERROR, fatal: false, reason: 'TS packet did not start with 0x47' });
        }
      }
      // try to parse last PES packets
      if (avcData && (pes = parsePES(avcData))) {
        parseAVCPES(pes, true);
        avcTrack.pesData = null;
      } else {
        // either avcData null or PES truncated, keep it for next frag parsing
        avcTrack.pesData = avcData;
      }

      if (aacData && (pes = parsePES(aacData))) {
        parseAACPES(pes);
        aacTrack.pesData = null;
      } else {
        if (aacData && aacData.size) {
          _logger.logger.log('last AAC PES packet truncated,might overlap between fragments');
        }
        // either aacData null or PES truncated, keep it for next frag parsing
        aacTrack.pesData = aacData;
      }

      if (id3Data && (pes = parsePES(id3Data))) {
        parseID3PES(pes);
        id3Track.pesData = null;
      } else {
        // either id3Data null or PES truncated, keep it for next frag parsing
        id3Track.pesData = id3Data;
      }
      this.remux(level, sn, null, timeOffset);
    }
  }, {
    key: 'remux',
    value: function remux(level, sn, data, timeOffset) {
      var avcTrack = this._avcTrack,
          samples = avcTrack.samples;

      // compute total/avc sample length and nb of NAL units
      var trackData = samples.reduce(function (prevSampleData, curSample) {
        var sampleData = curSample.units.units.reduce(function (prevUnitData, curUnit) {
          return {
            len: prevUnitData.len + curUnit.data.length,
            nbNalu: prevUnitData.nbNalu + 1
          };
        }, { len: 0, nbNalu: 0 });
        curSample.length = sampleData.len;
        return {
          len: prevSampleData.len + sampleData.len,
          nbNalu: prevSampleData.nbNalu + sampleData.nbNalu
        };
      }, { len: 0, nbNalu: 0 });
      avcTrack.len = trackData.len;
      avcTrack.nbNalu = trackData.nbNalu;
      this.remuxer.remux(level, sn, this._aacTrack, this._avcTrack, this._id3Track, this._txtTrack, timeOffset, this.contiguous, this.accurateTimeOffset, data);
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      this.switchLevel();
      this._initPTS = this._initDTS = undefined;
      this._duration = 0;
    }
  }, {
    key: '_parsePAT',
    value: function _parsePAT(data, offset) {
      // skip the PSI header and parse the first PMT entry
      return (data[offset + 10] & 0x1F) << 8 | data[offset + 11];
      //logger.log('PMT PID:'  + this._pmtId);
    }
  }, {
    key: '_parsePMT',
    value: function _parsePMT(data, offset) {
      var sectionLength,
          tableEnd,
          programInfoLength,
          pid,
          result = { aac: -1, avc: -1, id3: -1 };
      sectionLength = (data[offset + 1] & 0x0f) << 8 | data[offset + 2];
      tableEnd = offset + 3 + sectionLength - 4;
      // to determine where the table is, we have to figure out how
      // long the program info descriptors are
      programInfoLength = (data[offset + 10] & 0x0f) << 8 | data[offset + 11];
      // advance the offset to the first entry in the mapping table
      offset += 12 + programInfoLength;
      while (offset < tableEnd) {
        pid = (data[offset + 1] & 0x1F) << 8 | data[offset + 2];
        switch (data[offset]) {
          // ISO/IEC 13818-7 ADTS AAC (MPEG-2 lower bit-rate audio)
          case 0x0f:
            //logger.log('AAC PID:'  + pid);
            if (result.aac === -1) {
              result.aac = pid;
            }
            break;
          // Packetized metadata (ID3)
          case 0x15:
            //logger.log('ID3 PID:'  + pid);
            if (result.id3 === -1) {
              result.id3 = pid;
            }
            break;
          // ITU-T Rec. H.264 and ISO/IEC 14496-10 (lower bit-rate video)
          case 0x1b:
            //logger.log('AVC PID:'  + pid);
            if (result.avc === -1) {
              result.avc = pid;
            }
            break;
          case 0x24:
            _logger.logger.warn('HEVC stream type found, not supported for now');
            break;
          default:
            _logger.logger.log('unkown stream type:' + data[offset]);
            break;
        }
        // move to the next table entry
        // skip past the elementary stream descriptors, if present
        offset += ((data[offset + 3] & 0x0F) << 8 | data[offset + 4]) + 5;
      }
      return result;
    }
  }, {
    key: '_parsePES',
    value: function _parsePES(stream) {
      var i = 0,
          frag,
          pesFlags,
          pesPrefix,
          pesLen,
          pesHdrLen,
          pesData,
          pesPts,
          pesDts,
          payloadStartOffset,
          data = stream.data;
      // safety check
      if (!stream || stream.size === 0) {
        return null;
      }

      // we might need up to 19 bytes to read PES header
      // if first chunk of data is less than 19 bytes, let's merge it with following ones until we get 19 bytes
      // usually only one merge is needed (and this is rare ...)
      while (data[0].length < 19 && data.length > 1) {
        var newData = new Uint8Array(data[0].length + data[1].length);
        newData.set(data[0]);
        newData.set(data[1], data[0].length);
        data[0] = newData;
        data.splice(1, 1);
      }
      //retrieve PTS/DTS from first fragment
      frag = data[0];
      pesPrefix = (frag[0] << 16) + (frag[1] << 8) + frag[2];
      if (pesPrefix === 1) {
        pesLen = (frag[4] << 8) + frag[5];
        // if PES len is not zero and not matching with total len, stop parsing. PES might be truncated
        // minus 6 : PES header size
        if (pesLen && pesLen !== stream.size - 6) {
          return null;
        }
        pesFlags = frag[7];
        if (pesFlags & 0xC0) {
          /* PES header described here : http://dvd.sourceforge.net/dvdinfo/pes-hdr.html
              as PTS / DTS is 33 bit we cannot use bitwise operator in JS,
              as Bitwise operators treat their operands as a sequence of 32 bits */
          pesPts = (frag[9] & 0x0E) * 536870912 + // 1 << 29
          (frag[10] & 0xFF) * 4194304 + // 1 << 22
          (frag[11] & 0xFE) * 16384 + // 1 << 14
          (frag[12] & 0xFF) * 128 + // 1 << 7
          (frag[13] & 0xFE) / 2;
          // check if greater than 2^32 -1
          if (pesPts > 4294967295) {
            // decrement 2^33
            pesPts -= 8589934592;
          }
          if (pesFlags & 0x40) {
            pesDts = (frag[14] & 0x0E) * 536870912 + // 1 << 29
            (frag[15] & 0xFF) * 4194304 + // 1 << 22
            (frag[16] & 0xFE) * 16384 + // 1 << 14
            (frag[17] & 0xFF) * 128 + // 1 << 7
            (frag[18] & 0xFE) / 2;
            // check if greater than 2^32 -1
            if (pesDts > 4294967295) {
              // decrement 2^33
              pesDts -= 8589934592;
            }
          } else {
            pesDts = pesPts;
          }
        }
        pesHdrLen = frag[8];
        // 9 bytes : 6 bytes for PES header + 3 bytes for PES extension
        payloadStartOffset = pesHdrLen + 9;

        stream.size -= payloadStartOffset;
        //reassemble PES packet
        pesData = new Uint8Array(stream.size);
        while (data.length) {
          frag = data.shift();
          var len = frag.byteLength;
          if (payloadStartOffset) {
            if (payloadStartOffset > len) {
              // trim full frag if PES header bigger than frag
              payloadStartOffset -= len;
              continue;
            } else {
              // trim partial frag if PES header smaller than frag
              frag = frag.subarray(payloadStartOffset);
              len -= payloadStartOffset;
              payloadStartOffset = 0;
            }
          }
          pesData.set(frag, i);
          i += len;
        }
        if (pesLen) {
          // payload size : remove PES header + PES extension
          pesLen -= pesHdrLen + 3;
        }
        return { data: pesData, pts: pesPts, dts: pesDts, len: pesLen };
      } else {
        return null;
      }
    }
  }, {
    key: 'pushAccesUnit',
    value: function pushAccesUnit(avcSample, avcTrack) {
      if (avcSample.units.units.length) {
        // only push AVC sample if starting with a keyframe is not mandatory OR
        //    if keyframe already found in this fragment OR
        //       keyframe found in last fragment (track.sps) AND
        //          samples already appended (we already found a keyframe in this fragment) OR fragment is contiguous
        if (!this.config.forceKeyFrameOnDiscontinuity || avcSample.key === true || avcTrack.sps && (avcTrack.samples.length || this.contiguous)) {
          avcTrack.samples.push(avcSample);
        } else {
          // dropped samples, track it
          avcTrack.dropped++;
        }
      }
      if (avcSample.debug.length) {
        _logger.logger.log(avcSample.pts + '/' + avcSample.dts + ':' + avcSample.debug + ',' + avcSample.units.length);
      }
    }
  }, {
    key: '_parseAVCPES',
    value: function _parseAVCPES(pes, last) {
      var _this = this;

      //logger.log('parse new PES');
      var track = this._avcTrack,
          units = this._parseAVCNALu(pes.data),
          debug = false,
          expGolombDecoder,
          avcSample = this.avcSample,
          push,
          i;
      //free pes.data to save up some memory
      pes.data = null;

      units.forEach(function (unit) {
        switch (unit.type) {
          //NDR
          case 1:
            push = true;
            if (debug && avcSample) {
              avcSample.debug += 'NDR ';
            }
            break;
          //IDR
          case 5:
            push = true;
            // handle PES not starting with AUD
            if (!avcSample) {
              avcSample = _this.avcSample = _this._createAVCSample(true, pes.pts, pes.dts, '');
            }
            if (debug) {
              avcSample.debug += 'IDR ';
            }
            avcSample.key = true;
            break;
          //SEI
          case 6:
            push = true;
            if (debug && avcSample) {
              avcSample.debug += 'SEI ';
            }
            expGolombDecoder = new _expGolomb2.default(_this.discardEPB(unit.data));

            // skip frameType
            expGolombDecoder.readUByte();

            var payloadType = 0;
            var payloadSize = 0;
            var endOfCaptions = false;
            var b = 0;

            while (!endOfCaptions && expGolombDecoder.bytesAvailable > 1) {
              payloadType = 0;
              do {
                b = expGolombDecoder.readUByte();
                payloadType += b;
              } while (b === 0xFF);

              // Parse payload size.
              payloadSize = 0;
              do {
                b = expGolombDecoder.readUByte();
                payloadSize += b;
              } while (b === 0xFF);

              // TODO: there can be more than one payload in an SEI packet...
              // TODO: need to read type and size in a while loop to get them all
              if (payloadType === 4 && expGolombDecoder.bytesAvailable !== 0) {

                endOfCaptions = true;

                var countryCode = expGolombDecoder.readUByte();

                if (countryCode === 181) {
                  var providerCode = expGolombDecoder.readUShort();

                  if (providerCode === 49) {
                    var userStructure = expGolombDecoder.readUInt();

                    if (userStructure === 0x47413934) {
                      var userDataType = expGolombDecoder.readUByte();

                      // Raw CEA-608 bytes wrapped in CEA-708 packet
                      if (userDataType === 3) {
                        var firstByte = expGolombDecoder.readUByte();
                        var secondByte = expGolombDecoder.readUByte();

                        var totalCCs = 31 & firstByte;
                        var byteArray = [firstByte, secondByte];

                        for (i = 0; i < totalCCs; i++) {
                          // 3 bytes per CC
                          byteArray.push(expGolombDecoder.readUByte());
                          byteArray.push(expGolombDecoder.readUByte());
                          byteArray.push(expGolombDecoder.readUByte());
                        }

                        _this._insertSampleInOrder(_this._txtTrack.samples, { type: 3, pts: pes.pts, bytes: byteArray });
                      }
                    }
                  }
                }
              } else if (payloadSize < expGolombDecoder.bytesAvailable) {
                for (i = 0; i < payloadSize; i++) {
                  expGolombDecoder.readUByte();
                }
              }
            }
            break;
          //SPS
          case 7:
            push = true;
            if (debug && avcSample) {
              avcSample.debug += 'SPS ';
            }
            if (!track.sps) {
              expGolombDecoder = new _expGolomb2.default(unit.data);
              var config = expGolombDecoder.readSPS();
              track.width = config.width;
              track.height = config.height;
              track.sps = [unit.data];
              track.duration = _this._duration;
              var codecarray = unit.data.subarray(1, 4);
              var codecstring = 'avc1.';
              for (i = 0; i < 3; i++) {
                var h = codecarray[i].toString(16);
                if (h.length < 2) {
                  h = '0' + h;
                }
                codecstring += h;
              }
              track.codec = codecstring;
            }
            break;
          //PPS
          case 8:
            push = true;
            if (debug && avcSample) {
              avcSample.debug += 'PPS ';
            }
            if (!track.pps) {
              track.pps = [unit.data];
            }
            break;
          // AUD
          case 9:
            push = false;
            if (avcSample) {
              _this.pushAccesUnit(avcSample, track);
            }
            avcSample = _this.avcSample = _this._createAVCSample(false, pes.pts, pes.dts, debug ? 'AUD ' : '');
            break;
          // Filler Data
          case 12:
            push = false;
            break;
          default:
            push = false;
            if (avcSample) {
              avcSample.debug += 'unknown NAL ' + unit.type + ' ';
            }
            break;
        }
        if (avcSample && push) {
          var _units = avcSample.units;
          _units.units.push(unit);
        }
      });
      // if last PES packet, push samples
      if (last && avcSample) {
        this.pushAccesUnit(avcSample, track);
        this.avcSample = null;
      }
    }
  }, {
    key: '_createAVCSample',
    value: function _createAVCSample(key, pts, dts, debug) {
      return { key: key, pts: pts, dts: dts, units: { units: [], length: 0 }, debug: debug };
    }
  }, {
    key: '_insertSampleInOrder',
    value: function _insertSampleInOrder(arr, data) {
      var len = arr.length;
      if (len > 0) {
        if (data.pts >= arr[len - 1].pts) {
          arr.push(data);
        } else {
          for (var pos = len - 1; pos >= 0; pos--) {
            if (data.pts < arr[pos].pts) {
              arr.splice(pos, 0, data);
              break;
            }
          }
        }
      } else {
        arr.push(data);
      }
    }
  }, {
    key: '_getLastNalUnit',
    value: function _getLastNalUnit() {
      var avcSample = this.avcSample,
          lastUnit = void 0;
      // try to fallback to previous sample if current one is empty
      if (!avcSample || avcSample.units.units.length === 0) {
        var track = this._avcTrack,
            samples = track.samples;
        avcSample = samples[samples.length - 1];
      }
      if (avcSample) {
        var units = avcSample.units.units;
        lastUnit = units[units.length - 1];
      }
      return lastUnit;
    }
  }, {
    key: '_parseAVCNALu',
    value: function _parseAVCNALu(array) {
      var i = 0,
          len = array.byteLength,
          value,
          overflow,
          track = this._avcTrack,
          state = track.naluState || 0,
          lastState = state;
      var units = [],
          unit,
          unitType,
          lastUnitStart = -1,
          lastUnitType;
      //logger.log('PES:' + Hex.hexDump(array));
      while (i < len) {
        value = array[i++];
        // finding 3 or 4-byte start codes (00 00 01 OR 00 00 00 01)
        switch (state) {
          case 0:
            if (value === 0) {
              state = 1;
            }
            break;
          case 1:
            if (value === 0) {
              state = 2;
            } else {
              state = 0;
            }
            break;
          case 2:
          case 3:
            if (value === 0) {
              state = 3;
            } else if (value === 1) {
              if (lastUnitStart >= 0) {
                unit = { data: array.subarray(lastUnitStart, i - state - 1), type: lastUnitType };
                //logger.log('pushing NALU, type/size:' + unit.type + '/' + unit.data.byteLength);
                units.push(unit);
              } else {
                // lastUnitStart is undefined => this is the first start code found in this PES packet
                // first check if start code delimiter is overlapping between 2 PES packets,
                // ie it started in last packet (lastState not zero)
                // and ended at the beginning of this PES packet (i <= 4 - lastState)
                var lastUnit = this._getLastNalUnit();
                if (lastUnit) {
                  if (lastState && i <= 4 - lastState) {
                    // start delimiter overlapping between PES packets
                    // strip start delimiter bytes from the end of last NAL unit
                    // check if lastUnit had a state different from zero
                    if (lastUnit.state) {
                      // strip last bytes
                      lastUnit.data = lastUnit.data.subarray(0, lastUnit.data.byteLength - lastState);
                    }
                  }
                  // If NAL units are not starting right at the beginning of the PES packet, push preceding data into previous NAL unit.
                  overflow = i - state - 1;
                  if (overflow > 0) {
                    //logger.log('first NALU found with overflow:' + overflow);
                    var tmp = new Uint8Array(lastUnit.data.byteLength + overflow);
                    tmp.set(lastUnit.data, 0);
                    tmp.set(array.subarray(0, overflow), lastUnit.data.byteLength);
                    lastUnit.data = tmp;
                  }
                }
              }
              // check if we can read unit type
              if (i < len) {
                unitType = array[i] & 0x1f;
                //logger.log('find NALU @ offset:' + i + ',type:' + unitType);
                lastUnitStart = i;
                lastUnitType = unitType;
                state = 0;
              } else {
                // not enough byte to read unit type. let's read it on next PES parsing
                state = -1;
              }
            } else {
              state = 0;
            }
            break;
          case -1:
            // special use case where we found 3 or 4-byte start codes exactly at the end of previous PES packet
            lastUnitStart = 0;
            // NALu type is value read from offset 0
            lastUnitType = value & 0x1f;
            state = 0;
            break;
          default:
            break;
        }
      }
      if (lastUnitStart >= 0 && state >= 0) {
        unit = { data: array.subarray(lastUnitStart, len), type: lastUnitType, state: state };
        units.push(unit);
        //logger.log('pushing NALU, type/size/state:' + unit.type + '/' + unit.data.byteLength + '/' + state);
      }
      // no NALu found
      if (units.length === 0) {
        // append pes.data to previous NAL unit
        var _lastUnit = this._getLastNalUnit();
        if (_lastUnit) {
          var _tmp = new Uint8Array(_lastUnit.data.byteLength + array.byteLength);
          _tmp.set(_lastUnit.data, 0);
          _tmp.set(array, _lastUnit.data.byteLength);
          _lastUnit.data = _tmp;
        }
      }
      track.naluState = state;
      return units;
    }

    /**
     * remove Emulation Prevention bytes from a RBSP
     */

  }, {
    key: 'discardEPB',
    value: function discardEPB(data) {
      var length = data.byteLength,
          EPBPositions = [],
          i = 1,
          newLength,
          newData;

      // Find all `Emulation Prevention Bytes`
      while (i < length - 2) {
        if (data[i] === 0 && data[i + 1] === 0 && data[i + 2] === 0x03) {
          EPBPositions.push(i + 2);
          i += 2;
        } else {
          i++;
        }
      }

      // If no Emulation Prevention Bytes were found just return the original
      // array
      if (EPBPositions.length === 0) {
        return data;
      }

      // Create a new array to hold the NAL unit data
      newLength = length - EPBPositions.length;
      newData = new Uint8Array(newLength);
      var sourceIndex = 0;

      for (i = 0; i < newLength; sourceIndex++, i++) {
        if (sourceIndex === EPBPositions[0]) {
          // Skip this byte
          sourceIndex++;
          // Remove this position index
          EPBPositions.shift();
        }
        newData[i] = data[sourceIndex];
      }
      return newData;
    }
  }, {
    key: '_parseAACPES',
    value: function _parseAACPES(pes) {
      var track = this._aacTrack,
          data = pes.data,
          pts = pes.pts,
          startOffset = 0,
          aacOverFlow = this.aacOverFlow,
          aacLastPTS = this.aacLastPTS,
          config,
          frameLength,
          frameDuration,
          frameIndex,
          offset,
          headerLength,
          stamp,
          len,
          aacSample;
      if (aacOverFlow) {
        var tmp = new Uint8Array(aacOverFlow.byteLength + data.byteLength);
        tmp.set(aacOverFlow, 0);
        tmp.set(data, aacOverFlow.byteLength);
        //logger.log(`AAC: append overflowing ${aacOverFlow.byteLength} bytes to beginning of new PES`);
        data = tmp;
      }
      // look for ADTS header (0xFFFx)
      for (offset = startOffset, len = data.length; offset < len - 1; offset++) {
        if (data[offset] === 0xff && (data[offset + 1] & 0xf0) === 0xf0) {
          break;
        }
      }
      // if ADTS header does not start straight from the beginning of the PES payload, raise an error
      if (offset) {
        var reason, fatal;
        if (offset < len - 1) {
          reason = 'AAC PES did not start with ADTS header,offset:' + offset;
          fatal = false;
        } else {
          reason = 'no ADTS header found in AAC PES';
          fatal = true;
        }
        _logger.logger.warn('parsing error:' + reason);
        this.observer.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, id: this.id, details: _errors.ErrorDetails.FRAG_PARSING_ERROR, fatal: fatal, reason: reason });
        if (fatal) {
          return;
        }
      }
      if (!track.audiosamplerate) {
        config = _adts2.default.getAudioConfig(this.observer, data, offset, this.audioCodec);
        track.config = config.config;
        track.audiosamplerate = config.samplerate;
        track.channelCount = config.channelCount;
        track.codec = config.codec;
        track.duration = this._duration;
        _logger.logger.log('parsed codec:' + track.codec + ',rate:' + config.samplerate + ',nb channel:' + config.channelCount);
      }
      frameIndex = 0;
      frameDuration = 1024 * 90000 / track.audiosamplerate;

      // if last AAC frame is overflowing, we should ensure timestamps are contiguous:
      // first sample PTS should be equal to last sample PTS + frameDuration
      if (aacOverFlow && aacLastPTS) {
        var newPTS = aacLastPTS + frameDuration;
        if (Math.abs(newPTS - pts) > 1) {
          _logger.logger.log('AAC: align PTS for overlapping frames by ' + Math.round((newPTS - pts) / 90));
          pts = newPTS;
        }
      }

      while (offset + 5 < len) {
        // The protection skip bit tells us if we have 2 bytes of CRC data at the end of the ADTS header
        headerLength = !!(data[offset + 1] & 0x01) ? 7 : 9;
        // retrieve frame size
        frameLength = (data[offset + 3] & 0x03) << 11 | data[offset + 4] << 3 | (data[offset + 5] & 0xE0) >>> 5;
        frameLength -= headerLength;
        //stamp = pes.pts;

        if (frameLength > 0 && offset + headerLength + frameLength <= len) {
          stamp = pts + frameIndex * frameDuration;
          //logger.log(`AAC frame, offset/length/total/pts:${offset+headerLength}/${frameLength}/${data.byteLength}/${(stamp/90).toFixed(0)}`);
          aacSample = { unit: data.subarray(offset + headerLength, offset + headerLength + frameLength), pts: stamp, dts: stamp };
          track.samples.push(aacSample);
          track.len += frameLength;
          offset += frameLength + headerLength;
          frameIndex++;
          // look for ADTS header (0xFFFx)
          for (; offset < len - 1; offset++) {
            if (data[offset] === 0xff && (data[offset + 1] & 0xf0) === 0xf0) {
              break;
            }
          }
        } else {
          break;
        }
      }
      if (offset < len) {
        aacOverFlow = data.subarray(offset, len);
        //logger.log(`AAC: overflow detected:${len-offset}`);
      } else {
        aacOverFlow = null;
      }
      this.aacOverFlow = aacOverFlow;
      this.aacLastPTS = stamp;
    }
  }, {
    key: '_parseID3PES',
    value: function _parseID3PES(pes) {
      this._id3Track.samples.push(pes);
    }
  }], [{
    key: 'probe',
    value: function probe(data) {
      // a TS fragment should contain at least 3 TS packets, a PAT, a PMT, and one PID, each starting with 0x47
      if (data.length >= 3 * 188 && data[0] === 0x47 && data[188] === 0x47 && data[2 * 188] === 0x47) {
        return true;
      } else {
        return false;
      }
    }
  }]);

  return TSDemuxer;
}();

exports.default = TSDemuxer;

},{"../errors":25,"../events":27,"../utils/logger":44,"./adts":18,"./exp-golomb":22}],25:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
var ErrorTypes = exports.ErrorTypes = {
  // Identifier for a network error (loading error / timeout ...)
  NETWORK_ERROR: 'networkError',
  // Identifier for a media Error (video/parsing/mediasource error)
  MEDIA_ERROR: 'mediaError',
  // Identifier for all other errors
  OTHER_ERROR: 'otherError'
};

var ErrorDetails = exports.ErrorDetails = {
  // Identifier for a manifest load error - data: { url : faulty URL, response : { code: error code, text: error text }}
  MANIFEST_LOAD_ERROR: 'manifestLoadError',
  // Identifier for a manifest load timeout - data: { url : faulty URL, response : { code: error code, text: error text }}
  MANIFEST_LOAD_TIMEOUT: 'manifestLoadTimeOut',
  // Identifier for a manifest parsing error - data: { url : faulty URL, reason : error reason}
  MANIFEST_PARSING_ERROR: 'manifestParsingError',
  // Identifier for a manifest with only incompatible codecs error - data: { url : faulty URL, reason : error reason}
  MANIFEST_INCOMPATIBLE_CODECS_ERROR: 'manifestIncompatibleCodecsError',
  // Identifier for a level load error - data: { url : faulty URL, response : { code: error code, text: error text }}
  LEVEL_LOAD_ERROR: 'levelLoadError',
  // Identifier for a level load timeout - data: { url : faulty URL, response : { code: error code, text: error text }}
  LEVEL_LOAD_TIMEOUT: 'levelLoadTimeOut',
  // Identifier for a level switch error - data: { level : faulty level Id, event : error description}
  LEVEL_SWITCH_ERROR: 'levelSwitchError',
  // Identifier for an audio track load error - data: { url : faulty URL, response : { code: error code, text: error text }}
  AUDIO_TRACK_LOAD_ERROR: 'audioTrackLoadError',
  // Identifier for an audio track load timeout - data: { url : faulty URL, response : { code: error code, text: error text }}
  AUDIO_TRACK_LOAD_TIMEOUT: 'audioTrackLoadTimeOut',
  // Identifier for fragment load error - data: { frag : fragment object, response : { code: error code, text: error text }}
  FRAG_LOAD_ERROR: 'fragLoadError',
  // Identifier for fragment loop loading error - data: { frag : fragment object}
  FRAG_LOOP_LOADING_ERROR: 'fragLoopLoadingError',
  // Identifier for fragment load timeout error - data: { frag : fragment object}
  FRAG_LOAD_TIMEOUT: 'fragLoadTimeOut',
  // Identifier for a fragment decryption error event - data: parsing error description
  FRAG_DECRYPT_ERROR: 'fragDecryptError',
  // Identifier for a fragment parsing error event - data: parsing error description
  FRAG_PARSING_ERROR: 'fragParsingError',
  // Identifier for decrypt key load error - data: { frag : fragment object, response : { code: error code, text: error text }}
  KEY_LOAD_ERROR: 'keyLoadError',
  // Identifier for decrypt key load timeout error - data: { frag : fragment object}
  KEY_LOAD_TIMEOUT: 'keyLoadTimeOut',
  // Triggered when an exception occurs while adding a sourceBuffer to MediaSource - data : {  err : exception , mimeType : mimeType }
  BUFFER_ADD_CODEC_ERROR: 'bufferAddCodecError',
  // Identifier for a buffer append error - data: append error description
  BUFFER_APPEND_ERROR: 'bufferAppendError',
  // Identifier for a buffer appending error event - data: appending error description
  BUFFER_APPENDING_ERROR: 'bufferAppendingError',
  // Identifier for a buffer stalled error event
  BUFFER_STALLED_ERROR: 'bufferStalledError',
  // Identifier for a buffer full event
  BUFFER_FULL_ERROR: 'bufferFullError',
  // Identifier for a buffer seek over hole event
  BUFFER_SEEK_OVER_HOLE: 'bufferSeekOverHole',
  // Identifier for an internal exception happening inside hls.js while handling an event
  INTERNAL_EXCEPTION: 'internalException'
};

},{}],26:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     * All objects in the event handling chain should inherit from this class
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */

var _logger = require('./utils/logger');

var _errors = require('./errors');

var _events = require('./events');

var _events2 = _interopRequireDefault(_events);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var EventHandler = function () {
  function EventHandler(hls) {
    _classCallCheck(this, EventHandler);

    this.hls = hls;
    this.onEvent = this.onEvent.bind(this);

    for (var _len = arguments.length, events = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      events[_key - 1] = arguments[_key];
    }

    this.handledEvents = events;
    this.useGenericHandler = true;

    this.registerListeners();
  }

  _createClass(EventHandler, [{
    key: 'destroy',
    value: function destroy() {
      this.unregisterListeners();
    }
  }, {
    key: 'isEventHandler',
    value: function isEventHandler() {
      return _typeof(this.handledEvents) === 'object' && this.handledEvents.length && typeof this.onEvent === 'function';
    }
  }, {
    key: 'registerListeners',
    value: function registerListeners() {
      if (this.isEventHandler()) {
        this.handledEvents.forEach(function (event) {
          if (event === 'hlsEventGeneric') {
            throw new Error('Forbidden event name: ' + event);
          }
          this.hls.on(event, this.onEvent);
        }.bind(this));
      }
    }
  }, {
    key: 'unregisterListeners',
    value: function unregisterListeners() {
      if (this.isEventHandler()) {
        this.handledEvents.forEach(function (event) {
          this.hls.off(event, this.onEvent);
        }.bind(this));
      }
    }

    /**
     * arguments: event (string), data (any)
     */

  }, {
    key: 'onEvent',
    value: function onEvent(event, data) {
      this.onEventGeneric(event, data);
    }
  }, {
    key: 'onEventGeneric',
    value: function onEventGeneric(event, data) {
      var eventToFunction = function eventToFunction(event, data) {
        var funcName = 'on' + event.replace('hls', '');
        if (typeof this[funcName] !== 'function') {
          throw new Error('Event ' + event + ' has no generic handler in this ' + this.constructor.name + ' class (tried ' + funcName + ')');
        }
        return this[funcName].bind(this, data);
      };
      try {
        eventToFunction.call(this, event, data).call();
      } catch (err) {
        _logger.logger.error('internal error happened while processing ' + event + ':' + err.message);
        this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.OTHER_ERROR, details: _errors.ErrorDetails.INTERNAL_EXCEPTION, fatal: false, event: event, err: err });
      }
    }
  }]);

  return EventHandler;
}();

exports.default = EventHandler;

},{"./errors":25,"./events":27,"./utils/logger":44}],27:[function(require,module,exports){
'use strict';

module.exports = {
  // fired before MediaSource is attaching to media element - data: { media }
  MEDIA_ATTACHING: 'hlsMediaAttaching',
  // fired when MediaSource has been succesfully attached to media element - data: { }
  MEDIA_ATTACHED: 'hlsMediaAttached',
  // fired before detaching MediaSource from media element - data: { }
  MEDIA_DETACHING: 'hlsMediaDetaching',
  // fired when MediaSource has been detached from media element - data: { }
  MEDIA_DETACHED: 'hlsMediaDetached',
  // fired when we buffer is going to be resetted
  BUFFER_RESET: 'hlsBufferReset',
  // fired when we know about the codecs that we need buffers for to push into - data: {tracks : { container, codec, levelCodec, initSegment, metadata }}
  BUFFER_CODECS: 'hlsBufferCodecs',
  // fired when sourcebuffers have been created data: { tracks : tracks}
  BUFFER_CREATED: 'hlsBufferCreated',
  // fired when we append a segment to the buffer - data: { segment: segment object }
  BUFFER_APPENDING: 'hlsBufferAppending',
  // fired when we are done with appending a media segment to the buffer data : { parent : segment parent that triggered BUFFER_APPENDING }
  BUFFER_APPENDED: 'hlsBufferAppended',
  // fired when the stream is finished and we want to notify the media buffer that there will be no more data
  BUFFER_EOS: 'hlsBufferEos',
  // fired when the media buffer should be flushed - data {startOffset, endOffset}
  BUFFER_FLUSHING: 'hlsBufferFlushing',
  // fired when the media has been flushed
  BUFFER_FLUSHED: 'hlsBufferFlushed',
  // fired to signal that a manifest loading starts - data: { url : manifestURL}
  MANIFEST_LOADING: 'hlsManifestLoading',
  // fired after manifest has been loaded - data: { levels : [available quality levels] , audioTracks : [ available audio tracks], url : manifestURL, stats : { trequest, tfirst, tload, mtime}}
  MANIFEST_LOADED: 'hlsManifestLoaded',
  // fired after manifest has been parsed - data: { levels : [available quality levels] , firstLevel : index of first quality level appearing in Manifest}
  MANIFEST_PARSED: 'hlsManifestParsed',
  // fired when a level playlist loading starts - data: { url : level URL  level : id of level being loaded}
  LEVEL_LOADING: 'hlsLevelLoading',
  // fired when a level playlist loading finishes - data: { details : levelDetails object, level : id of loaded level, stats : { trequest, tfirst, tload, mtime} }
  LEVEL_LOADED: 'hlsLevelLoaded',
  // fired when a level's details have been updated based on previous details, after it has been loaded. - data: { details : levelDetails object, level : id of updated level }
  LEVEL_UPDATED: 'hlsLevelUpdated',
  // fired when a level's PTS information has been updated after parsing a fragment - data: { details : levelDetails object, level : id of updated level, drift: PTS drift observed when parsing last fragment }
  LEVEL_PTS_UPDATED: 'hlsLevelPtsUpdated',
  // fired when a level switch is requested - data: { level : id of new level }
  LEVEL_SWITCH: 'hlsLevelSwitch',
  // fired to notify that audio track lists has been updated data: { audioTracks : audioTracks}
  AUDIO_TRACKS_UPDATED: 'hlsAudioTracksUpdated',
  // fired when an audio track switch occurs - data: {  id : audio track id}
  AUDIO_TRACK_SWITCH: 'hlsAudioTrackSwitch',
  // fired when an audio track loading starts - data: { url : audio track URL  id : audio track id}
  AUDIO_TRACK_LOADING: 'hlsAudioTrackLoading',
  // fired when an audio track loading  finishes - data: { details : levelDetails object, id : audio track id, stats : { trequest, tfirst, tload, mtime} }
  AUDIO_TRACK_LOADED: 'hlsAudioTrackLoaded',
  // fired when a fragment loading starts - data: { frag : fragment object}
  FRAG_LOADING: 'hlsFragLoading',
  // fired when a fragment loading is progressing - data: { frag : fragment object, { trequest, tfirst, loaded}}
  FRAG_LOAD_PROGRESS: 'hlsFragLoadProgress',
  // Identifier for fragment load aborting for emergency switch down - data: {frag : fragment object}
  FRAG_LOAD_EMERGENCY_ABORTED: 'hlsFragLoadEmergencyAborted',
  // fired when a fragment loading is completed - data: { frag : fragment object, payload : fragment payload, stats : { trequest, tfirst, tload, length}}
  FRAG_LOADED: 'hlsFragLoaded',
  // fired when Init Segment has been extracted from fragment - data: { id : demuxer id, level : levelId, sn : sequence number, moov : moov MP4 box, codecs : codecs found while parsing fragment}
  FRAG_PARSING_INIT_SEGMENT: 'hlsFragParsingInitSegment',
  // fired when parsing sei text is completed - data: { id : demuxer id, , level : levelId, sn : sequence number, samples : [ sei samples pes ] }
  FRAG_PARSING_USERDATA: 'hlsFragParsingUserdata',
  // fired when parsing id3 is completed - data: { id : demuxer id, , level : levelId, sn : sequence number, samples : [ id3 samples pes ] }
  FRAG_PARSING_METADATA: 'hlsFragParsingMetadata',
  // fired when data have been extracted from fragment - data: { id : demuxer id, level : levelId, sn : sequence number, data1 : moof MP4 box or TS fragments, data2 : mdat MP4 box or null}
  FRAG_PARSING_DATA: 'hlsFragParsingData',
  // fired when fragment parsing is completed - data: { id : demuxer id; level : levelId, sn : sequence number, }
  FRAG_PARSED: 'hlsFragParsed',
  // fired when fragment remuxed MP4 boxes have all been appended into SourceBuffer - data: { id : demuxer id,frag : fragment object, stats : { trequest, tfirst, tload, tparsed, tbuffered, length} }
  FRAG_BUFFERED: 'hlsFragBuffered',
  // fired when fragment matching with current media position is changing - data : { id : demuxer id, frag : fragment object }
  FRAG_CHANGED: 'hlsFragChanged',
  // Identifier for a FPS drop event - data: {curentDropped, currentDecoded, totalDroppedFrames}
  FPS_DROP: 'hlsFpsDrop',
  //triggered when FPS drop triggers auto level capping - data: {level, droppedlevel}
  FPS_DROP_LEVEL_CAPPING: 'hlsFpsDropLevelCapping',
  // Identifier for an error event - data: { type : error type, details : error details, fatal : if true, hls.js cannot/will not try to recover, if false, hls.js will try to recover,other error specific data}
  ERROR: 'hlsError',
  // fired when hls.js instance starts destroying. Different from MEDIA_DETACHED as one could want to detach and reattach a media to the instance of hls.js to handle mid-rolls for example
  DESTROYING: 'hlsDestroying',
  // fired when a decrypt key loading starts - data: { frag : fragment object}
  KEY_LOADING: 'hlsKeyLoading',
  // fired when a decrypt key loading is completed - data: { frag : fragment object, payload : key payload, stats : { trequest, tfirst, tload, length}}
  KEY_LOADED: 'hlsKeyLoaded',
  // fired upon stream controller state transitions - data: {previousState, nextState}
  STREAM_STATE_TRANSITION: 'hlsStreamStateTransition'
};

},{}],28:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 *  AAC helper
 */

var AAC = function () {
  function AAC() {
    _classCallCheck(this, AAC);
  }

  _createClass(AAC, null, [{
    key: "getSilentFrame",
    value: function getSilentFrame(channelCount) {
      if (channelCount === 1) {
        return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x23, 0x80]);
      } else if (channelCount === 2) {
        return new Uint8Array([0x21, 0x00, 0x49, 0x90, 0x02, 0x19, 0x00, 0x23, 0x80]);
      } else if (channelCount === 3) {
        return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x8e]);
      } else if (channelCount === 4) {
        return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x80, 0x2c, 0x80, 0x08, 0x02, 0x38]);
      } else if (channelCount === 5) {
        return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x82, 0x30, 0x04, 0x99, 0x00, 0x21, 0x90, 0x02, 0x38]);
      } else if (channelCount === 6) {
        return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x82, 0x30, 0x04, 0x99, 0x00, 0x21, 0x90, 0x02, 0x00, 0xb2, 0x00, 0x20, 0x08, 0xe0]);
      }
      return null;
    }
  }]);

  return AAC;
}();

exports.default = AAC;

},{}],29:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Buffer Helper class, providing methods dealing buffer length retrieval
*/

var BufferHelper = function () {
  function BufferHelper() {
    _classCallCheck(this, BufferHelper);
  }

  _createClass(BufferHelper, null, [{
    key: "bufferInfo",
    value: function bufferInfo(media, pos, maxHoleDuration) {
      if (media) {
        var vbuffered = media.buffered,
            buffered = [],
            i;
        for (i = 0; i < vbuffered.length; i++) {
          buffered.push({ start: vbuffered.start(i), end: vbuffered.end(i) });
        }
        return this.bufferedInfo(buffered, pos, maxHoleDuration);
      } else {
        return { len: 0, start: 0, end: 0, nextStart: undefined };
      }
    }
  }, {
    key: "bufferedInfo",
    value: function bufferedInfo(buffered, pos, maxHoleDuration) {
      var buffered2 = [],

      // bufferStart and bufferEnd are buffer boundaries around current video position
      bufferLen,
          bufferStart,
          bufferEnd,
          bufferStartNext,
          i;
      // sort on buffer.start/smaller end (IE does not always return sorted buffered range)
      buffered.sort(function (a, b) {
        var diff = a.start - b.start;
        if (diff) {
          return diff;
        } else {
          return b.end - a.end;
        }
      });
      // there might be some small holes between buffer time range
      // consider that holes smaller than maxHoleDuration are irrelevant and build another
      // buffer time range representations that discards those holes
      for (i = 0; i < buffered.length; i++) {
        var buf2len = buffered2.length;
        if (buf2len) {
          var buf2end = buffered2[buf2len - 1].end;
          // if small hole (value between 0 or maxHoleDuration ) or overlapping (negative)
          if (buffered[i].start - buf2end < maxHoleDuration) {
            // merge overlapping time ranges
            // update lastRange.end only if smaller than item.end
            // e.g.  [ 1, 15] with  [ 2,8] => [ 1,15] (no need to modify lastRange.end)
            // whereas [ 1, 8] with  [ 2,15] => [ 1,15] ( lastRange should switch from [1,8] to [1,15])
            if (buffered[i].end > buf2end) {
              buffered2[buf2len - 1].end = buffered[i].end;
            }
          } else {
            // big hole
            buffered2.push(buffered[i]);
          }
        } else {
          // first value
          buffered2.push(buffered[i]);
        }
      }
      for (i = 0, bufferLen = 0, bufferStart = bufferEnd = pos; i < buffered2.length; i++) {
        var start = buffered2[i].start,
            end = buffered2[i].end;
        //logger.log('buf start/end:' + buffered.start(i) + '/' + buffered.end(i));
        if (pos + maxHoleDuration >= start && pos < end) {
          // play position is inside this buffer TimeRange, retrieve end of buffer position and buffer length
          bufferStart = start;
          bufferEnd = end;
          bufferLen = bufferEnd - pos;
        } else if (pos + maxHoleDuration < start) {
          bufferStartNext = start;
          break;
        }
      }
      return { len: bufferLen, start: bufferStart, end: bufferEnd, nextStart: bufferStartNext };
    }
  }]);

  return BufferHelper;
}();

exports.default = BufferHelper;

},{}],30:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Level Helper class, providing methods dealing with playlist sliding and drift
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */

var _logger = require('../utils/logger');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var LevelHelper = function () {
  function LevelHelper() {
    _classCallCheck(this, LevelHelper);
  }

  _createClass(LevelHelper, null, [{
    key: 'mergeDetails',
    value: function mergeDetails(oldDetails, newDetails) {
      var start = Math.max(oldDetails.startSN, newDetails.startSN) - newDetails.startSN,
          end = Math.min(oldDetails.endSN, newDetails.endSN) - newDetails.startSN,
          delta = newDetails.startSN - oldDetails.startSN,
          oldfragments = oldDetails.fragments,
          newfragments = newDetails.fragments,
          ccOffset = 0,
          PTSFrag;

      // check if old/new playlists have fragments in common
      if (end < start) {
        newDetails.PTSKnown = false;
        return;
      }
      // loop through overlapping SN and update startPTS , cc, and duration if any found
      for (var i = start; i <= end; i++) {
        var oldFrag = oldfragments[delta + i],
            newFrag = newfragments[i];
        if (newFrag && oldFrag) {
          ccOffset = oldFrag.cc - newFrag.cc;
          if (!isNaN(oldFrag.startPTS)) {
            newFrag.start = newFrag.startPTS = oldFrag.startPTS;
            newFrag.endPTS = oldFrag.endPTS;
            newFrag.duration = oldFrag.duration;
            PTSFrag = newFrag;
          }
        }
      }

      if (ccOffset) {
        _logger.logger.log('discontinuity sliding from playlist, take drift into account');
        for (i = 0; i < newfragments.length; i++) {
          newfragments[i].cc += ccOffset;
        }
      }

      // if at least one fragment contains PTS info, recompute PTS information for all fragments
      if (PTSFrag) {
        LevelHelper.updateFragPTSDTS(newDetails, PTSFrag.sn, PTSFrag.startPTS, PTSFrag.endPTS, PTSFrag.startDTS, PTSFrag.endDTS);
      } else {
        // ensure that delta is within oldfragments range
        // also adjust sliding in case delta is 0 (we could have old=[50-60] and new=old=[50-61])
        // in that case we also need to adjust start offset of all fragments
        if (delta >= 0 && delta < oldfragments.length) {
          // adjust start by sliding offset
          var sliding = oldfragments[delta].start;
          for (i = 0; i < newfragments.length; i++) {
            newfragments[i].start += sliding;
          }
        }
      }
      // if we are here, it means we have fragments overlapping between
      // old and new level. reliable PTS info is thus relying on old level
      newDetails.PTSKnown = oldDetails.PTSKnown;
      return;
    }
  }, {
    key: 'updateFragPTSDTS',
    value: function updateFragPTSDTS(details, sn, startPTS, endPTS, startDTS, endDTS) {
      var fragIdx, fragments, frag, i;
      // exit if sn out of range
      if (sn < details.startSN || sn > details.endSN) {
        return 0;
      }
      fragIdx = sn - details.startSN;
      fragments = details.fragments;
      frag = fragments[fragIdx];
      if (!isNaN(frag.startPTS)) {
        // delta PTS between audio and video
        var deltaPTS = Math.abs(frag.startPTS - startPTS);
        if (isNaN(frag.deltaPTS)) {
          frag.deltaPTS = deltaPTS;
        } else {
          frag.deltaPTS = Math.max(deltaPTS, frag.deltaPTS);
        }
        startPTS = Math.min(startPTS, frag.startPTS);
        endPTS = Math.max(endPTS, frag.endPTS);
        startDTS = Math.min(startDTS, frag.startDTS);
        endDTS = Math.max(endDTS, frag.endDTS);
      }

      var drift = startPTS - frag.start;

      frag.start = frag.startPTS = startPTS;
      frag.endPTS = endPTS;
      frag.startDTS = startDTS;
      frag.endDTS = endDTS;
      frag.duration = endPTS - startPTS;
      // adjust fragment PTS/duration from seqnum-1 to frag 0
      for (i = fragIdx; i > 0; i--) {
        LevelHelper.updatePTS(fragments, i, i - 1);
      }

      // adjust fragment PTS/duration from seqnum to last frag
      for (i = fragIdx; i < fragments.length - 1; i++) {
        LevelHelper.updatePTS(fragments, i, i + 1);
      }
      details.PTSKnown = true;
      //logger.log(`                                            frag start/end:${startPTS.toFixed(3)}/${endPTS.toFixed(3)}`);

      return drift;
    }
  }, {
    key: 'updatePTS',
    value: function updatePTS(fragments, fromIdx, toIdx) {
      var fragFrom = fragments[fromIdx],
          fragTo = fragments[toIdx],
          fragToPTS = fragTo.startPTS;
      // if we know startPTS[toIdx]
      if (!isNaN(fragToPTS)) {
        // update fragment duration.
        // it helps to fix drifts between playlist reported duration and fragment real duration
        if (toIdx > fromIdx) {
          fragFrom.duration = fragToPTS - fragFrom.start;
          if (fragFrom.duration < 0) {
            _logger.logger.warn('negative duration computed for frag ' + fragFrom.sn + ',level ' + fragFrom.level + ', there should be some duration drift between playlist and fragment!');
          }
        } else {
          fragTo.duration = fragFrom.start - fragToPTS;
          if (fragTo.duration < 0) {
            _logger.logger.warn('negative duration computed for frag ' + fragTo.sn + ',level ' + fragTo.level + ', there should be some duration drift between playlist and fragment!');
          }
        }
      } else {
        // we dont know startPTS[toIdx]
        if (toIdx > fromIdx) {
          fragTo.start = fragFrom.start + fragFrom.duration;
        } else {
          fragTo.start = fragFrom.start - fragTo.duration;
        }
      }
    }
  }]);

  return LevelHelper;
}();

exports.default = LevelHelper;

},{"../utils/logger":44}],31:[function(require,module,exports){
/**
 * HLS interface
 */
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
//import FetchLoader from './utils/fetch-loader';


var _events = require('./events');

var _events2 = _interopRequireDefault(_events);

var _errors = require('./errors');

var _playlistLoader = require('./loader/playlist-loader');

var _playlistLoader2 = _interopRequireDefault(_playlistLoader);

var _fragmentLoader = require('./loader/fragment-loader');

var _fragmentLoader2 = _interopRequireDefault(_fragmentLoader);

var _abrController = require('./controller/abr-controller');

var _abrController2 = _interopRequireDefault(_abrController);

var _bufferController = require('./controller/buffer-controller');

var _bufferController2 = _interopRequireDefault(_bufferController);

var _capLevelController = require('./controller/cap-level-controller');

var _capLevelController2 = _interopRequireDefault(_capLevelController);

var _audioStreamController = require('./controller/audio-stream-controller');

var _audioStreamController2 = _interopRequireDefault(_audioStreamController);

var _streamController = require('./controller/stream-controller');

var _streamController2 = _interopRequireDefault(_streamController);

var _levelController = require('./controller/level-controller');

var _levelController2 = _interopRequireDefault(_levelController);

var _timelineController = require('./controller/timeline-controller');

var _timelineController2 = _interopRequireDefault(_timelineController);

var _fpsController = require('./controller/fps-controller');

var _fpsController2 = _interopRequireDefault(_fpsController);

var _audioTrackController = require('./controller/audio-track-controller');

var _audioTrackController2 = _interopRequireDefault(_audioTrackController);

var _logger = require('./utils/logger');

var _xhrLoader = require('./utils/xhr-loader');

var _xhrLoader2 = _interopRequireDefault(_xhrLoader);

var _events3 = require('events');

var _events4 = _interopRequireDefault(_events3);

var _keyLoader = require('./loader/key-loader');

var _keyLoader2 = _interopRequireDefault(_keyLoader);

var _cues = require('./utils/cues');

var _cues2 = _interopRequireDefault(_cues);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Hls = function () {
  _createClass(Hls, null, [{
    key: 'isSupported',
    value: function isSupported() {
      return window.MediaSource && typeof window.MediaSource.isTypeSupported === 'function' && window.MediaSource.isTypeSupported('video/mp4; codecs="avc1.42E01E,mp4a.40.2"');
    }
  }, {
    key: 'version',
    get: function get() {
      // replaced with browserify-versionify transform
      return '__VERSION__';
    }
  }, {
    key: 'Events',
    get: function get() {
      return _events2.default;
    }
  }, {
    key: 'ErrorTypes',
    get: function get() {
      return _errors.ErrorTypes;
    }
  }, {
    key: 'ErrorDetails',
    get: function get() {
      return _errors.ErrorDetails;
    }
  }, {
    key: 'DefaultConfig',
    get: function get() {
      if (!Hls.defaultConfig) {
        Hls.defaultConfig = {
          autoStartLoad: true,
          startPosition: -1,
          defaultAudioCodec: undefined,
          debug: false,
          capLevelOnFPSDrop: false,
          capLevelToPlayerSize: false,
          maxBufferLength: 30,
          maxBufferSize: 60 * 1000 * 1000,
          maxBufferHole: 0.5,
          maxSeekHole: 2,
          seekHoleNudgeDuration: 0.01,
          stalledInBufferedNudgeThreshold: 10,
          maxFragLookUpTolerance: 0.2,
          liveSyncDurationCount: 3,
          liveMaxLatencyDurationCount: Infinity,
          liveSyncDuration: undefined,
          liveMaxLatencyDuration: undefined,
          maxMaxBufferLength: 600,
          enableWorker: true,
          enableSoftwareAES: true,
          manifestLoadingTimeOut: 10000,
          manifestLoadingMaxRetry: 1,
          manifestLoadingRetryDelay: 1000,
          manifestLoadingMaxRetryTimeout: 64000,
          startLevel: undefined,
          levelLoadingTimeOut: 10000,
          levelLoadingMaxRetry: 4,
          levelLoadingRetryDelay: 1000,
          levelLoadingMaxRetryTimeout: 64000,
          fragLoadingTimeOut: 20000,
          fragLoadingMaxRetry: 6,
          fragLoadingRetryDelay: 1000,
          fragLoadingMaxRetryTimeout: 64000,
          fragLoadingLoopThreshold: 3,
          startFragPrefetch: false,
          fpsDroppedMonitoringPeriod: 5000,
          fpsDroppedMonitoringThreshold: 0.2,
          appendErrorMaxRetry: 3,
          loader: _xhrLoader2.default,
          //loader: FetchLoader,
          fLoader: undefined,
          pLoader: undefined,
          xhrSetup: undefined,
          fetchSetup: undefined,
          abrController: _abrController2.default,
          bufferController: _bufferController2.default,
          capLevelController: _capLevelController2.default,
          fpsController: _fpsController2.default,
          streamController: _streamController2.default,
          audioStreamController: _audioStreamController2.default,
          timelineController: _timelineController2.default,
          cueHandler: _cues2.default,
          enableCEA708Captions: true,
          enableMP2TPassThrough: false,
          stretchShortVideoTrack: false,
          forceKeyFrameOnDiscontinuity: true,
          abrEwmaFastLive: 5,
          abrEwmaSlowLive: 9,
          abrEwmaFastVoD: 4,
          abrEwmaSlowVoD: 15,
          abrEwmaDefaultEstimate: 5e5, // 500 kbps
          abrBandWidthFactor: 0.8,
          abrBandWidthUpFactor: 0.7,
          maxStarvationDelay: 4
        };
      }
      return Hls.defaultConfig;
    },
    set: function set(defaultConfig) {
      Hls.defaultConfig = defaultConfig;
    }
  }]);

  function Hls() {
    var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, Hls);

    var defaultConfig = Hls.DefaultConfig;

    if ((config.liveSyncDurationCount || config.liveMaxLatencyDurationCount) && (config.liveSyncDuration || config.liveMaxLatencyDuration)) {
      throw new Error('Illegal hls.js config: don\'t mix up liveSyncDurationCount/liveMaxLatencyDurationCount and liveSyncDuration/liveMaxLatencyDuration');
    }

    for (var prop in defaultConfig) {
      if (prop in config) {
        continue;
      }
      config[prop] = defaultConfig[prop];
    }

    if (config.liveMaxLatencyDurationCount !== undefined && config.liveMaxLatencyDurationCount <= config.liveSyncDurationCount) {
      throw new Error('Illegal hls.js config: "liveMaxLatencyDurationCount" must be gt "liveSyncDurationCount"');
    }

    if (config.liveMaxLatencyDuration !== undefined && (config.liveMaxLatencyDuration <= config.liveSyncDuration || config.liveSyncDuration === undefined)) {
      throw new Error('Illegal hls.js config: "liveMaxLatencyDuration" must be gt "liveSyncDuration"');
    }

    (0, _logger.enableLogs)(config.debug);
    this.config = config;
    // observer setup
    var observer = this.observer = new _events4.default();
    observer.trigger = function trigger(event) {
      for (var _len = arguments.length, data = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        data[_key - 1] = arguments[_key];
      }

      observer.emit.apply(observer, [event, event].concat(data));
    };

    observer.off = function off(event) {
      for (var _len2 = arguments.length, data = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        data[_key2 - 1] = arguments[_key2];
      }

      observer.removeListener.apply(observer, [event].concat(data));
    };
    this.on = observer.on.bind(observer);
    this.off = observer.off.bind(observer);
    this.trigger = observer.trigger.bind(observer);
    this.playlistLoader = new _playlistLoader2.default(this);
    this.fragmentLoader = new _fragmentLoader2.default(this);
    this.levelController = new _levelController2.default(this);
    this.abrController = new config.abrController(this);
    this.bufferController = new config.bufferController(this);
    this.capLevelController = new config.capLevelController(this);
    this.fpsController = new config.fpsController(this);
    this.streamController = new config.streamController(this);
    this.audioStreamController = new config.audioStreamController(this);
    this.timelineController = new config.timelineController(this);
    this.audioTrackController = new _audioTrackController2.default(this);
    this.keyLoader = new _keyLoader2.default(this);
  }

  _createClass(Hls, [{
    key: 'destroy',
    value: function destroy() {
      _logger.logger.log('destroy');
      this.trigger(_events2.default.DESTROYING);
      this.detachMedia();
      this.playlistLoader.destroy();
      this.fragmentLoader.destroy();
      this.levelController.destroy();
      this.abrController.destroy();
      this.bufferController.destroy();
      this.capLevelController.destroy();
      this.fpsController.destroy();
      this.streamController.destroy();
      this.audioStreamController.destroy();
      this.timelineController.destroy();
      this.audioTrackController.destroy();
      this.keyLoader.destroy();
      this.url = null;
      this.observer.removeAllListeners();
    }
  }, {
    key: 'attachMedia',
    value: function attachMedia(media) {
      _logger.logger.log('attachMedia');
      this.media = media;
      this.trigger(_events2.default.MEDIA_ATTACHING, { media: media });
    }
  }, {
    key: 'detachMedia',
    value: function detachMedia() {
      _logger.logger.log('detachMedia');
      this.trigger(_events2.default.MEDIA_DETACHING);
      this.media = null;
    }
  }, {
    key: 'loadSource',
    value: function loadSource(url) {
      _logger.logger.log('loadSource:' + url);
      this.url = url;
      // when attaching to a source URL, trigger a playlist load
      this.trigger(_events2.default.MANIFEST_LOADING, { url: url });
    }
  }, {
    key: 'startLoad',
    value: function startLoad() {
      var startPosition = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : -1;

      _logger.logger.log('startLoad');
      this.levelController.startLoad();
      this.streamController.startLoad(startPosition);
      this.audioStreamController.startLoad(startPosition);
    }
  }, {
    key: 'stopLoad',
    value: function stopLoad() {
      _logger.logger.log('stopLoad');
      this.levelController.stopLoad();
      this.streamController.stopLoad();
      this.audioStreamController.stopLoad();
    }
  }, {
    key: 'swapAudioCodec',
    value: function swapAudioCodec() {
      _logger.logger.log('swapAudioCodec');
      this.streamController.swapAudioCodec();
    }
  }, {
    key: 'recoverMediaError',
    value: function recoverMediaError() {
      _logger.logger.log('recoverMediaError');
      var media = this.media;
      this.detachMedia();
      this.attachMedia(media);
    }

    /** Return all quality levels **/

  }, {
    key: 'levels',
    get: function get() {
      return this.levelController.levels;
    }

    /** Return current playback quality level **/

  }, {
    key: 'currentLevel',
    get: function get() {
      return this.streamController.currentLevel;
    }

    /* set quality level immediately (-1 for automatic level selection) */
    ,
    set: function set(newLevel) {
      _logger.logger.log('set currentLevel:' + newLevel);
      this.loadLevel = newLevel;
      this.streamController.immediateLevelSwitch();
    }

    /** Return next playback quality level (quality level of next fragment) **/

  }, {
    key: 'nextLevel',
    get: function get() {
      return this.streamController.nextLevel;
    }

    /* set quality level for next fragment (-1 for automatic level selection) */
    ,
    set: function set(newLevel) {
      _logger.logger.log('set nextLevel:' + newLevel);
      this.levelController.manualLevel = newLevel;
      this.streamController.nextLevelSwitch();
    }

    /** Return the quality level of current/last loaded fragment **/

  }, {
    key: 'loadLevel',
    get: function get() {
      return this.levelController.level;
    }

    /* set quality level for current/next loaded fragment (-1 for automatic level selection) */
    ,
    set: function set(newLevel) {
      _logger.logger.log('set loadLevel:' + newLevel);
      this.levelController.manualLevel = newLevel;
    }

    /** Return the quality level of next loaded fragment **/

  }, {
    key: 'nextLoadLevel',
    get: function get() {
      return this.levelController.nextLoadLevel;
    }

    /** set quality level of next loaded fragment **/
    ,
    set: function set(level) {
      this.levelController.nextLoadLevel = level;
    }

    /** Return first level (index of first level referenced in manifest)
    **/

  }, {
    key: 'firstLevel',
    get: function get() {
      return this.levelController.firstLevel;
    }

    /** set first level (index of first level referenced in manifest)
    **/
    ,
    set: function set(newLevel) {
      _logger.logger.log('set firstLevel:' + newLevel);
      this.levelController.firstLevel = newLevel;
    }

    /** Return start level (level of first fragment that will be played back)
        if not overrided by user, first level appearing in manifest will be used as start level
        if -1 : automatic start level selection, playback will start from level matching download bandwidth (determined from download of first segment)
    **/

  }, {
    key: 'startLevel',
    get: function get() {
      return this.levelController.startLevel;
    }

    /** set  start level (level of first fragment that will be played back)
        if not overrided by user, first level appearing in manifest will be used as start level
        if -1 : automatic start level selection, playback will start from level matching download bandwidth (determined from download of first segment)
    **/
    ,
    set: function set(newLevel) {
      _logger.logger.log('set startLevel:' + newLevel);
      this.levelController.startLevel = newLevel;
    }

    /** Return the capping/max level value that could be used by automatic level selection algorithm **/

  }, {
    key: 'autoLevelCapping',
    get: function get() {
      return this.abrController.autoLevelCapping;
    }

    /** set the capping/max level value that could be used by automatic level selection algorithm **/
    ,
    set: function set(newLevel) {
      _logger.logger.log('set autoLevelCapping:' + newLevel);
      this.abrController.autoLevelCapping = newLevel;
    }

    /* check if we are in automatic level selection mode */

  }, {
    key: 'autoLevelEnabled',
    get: function get() {
      return this.levelController.manualLevel === -1;
    }

    /* return manual level */

  }, {
    key: 'manualLevel',
    get: function get() {
      return this.levelController.manualLevel;
    }

    /** get alternate audio tracks list from playlist **/

  }, {
    key: 'audioTracks',
    get: function get() {
      return this.audioTrackController.audioTracks;
    }

    /** get index of the selected audio track (index in audio track lists) **/

  }, {
    key: 'audioTrack',
    get: function get() {
      return this.audioTrackController.audioTrack;
    }

    /** select an audio track, based on its index in audio track lists**/
    ,
    set: function set(audioTrackId) {
      this.audioTrackController.audioTrack = audioTrackId;
    }
  }, {
    key: 'liveSyncPosition',
    get: function get() {
      return this.streamController.liveSyncPosition;
    }
  }]);

  return Hls;
}();

exports.default = Hls;

},{"./controller/abr-controller":3,"./controller/audio-stream-controller":4,"./controller/audio-track-controller":5,"./controller/buffer-controller":6,"./controller/cap-level-controller":7,"./controller/fps-controller":9,"./controller/level-controller":10,"./controller/stream-controller":11,"./controller/timeline-controller":12,"./errors":25,"./events":27,"./loader/fragment-loader":33,"./loader/key-loader":34,"./loader/playlist-loader":35,"./utils/cues":42,"./utils/logger":44,"./utils/xhr-loader":48,"events":1}],32:[function(require,module,exports){
'use strict';

// This is mostly for support of the es6 module export
// syntax with the babel compiler, it looks like it doesnt support
// function exports like we are used to in node/commonjs
module.exports = require('./hls.js').default;

},{"./hls.js":31}],33:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _eventHandler = require('../event-handler');

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _errors = require('../errors');

var _logger = require('../utils/logger');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Fragment Loader
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

var FragmentLoader = function (_EventHandler) {
  _inherits(FragmentLoader, _EventHandler);

  function FragmentLoader(hls) {
    _classCallCheck(this, FragmentLoader);

    var _this = _possibleConstructorReturn(this, (FragmentLoader.__proto__ || Object.getPrototypeOf(FragmentLoader)).call(this, hls, _events2.default.FRAG_LOADING));

    _this.loaders = {};
    return _this;
  }

  _createClass(FragmentLoader, [{
    key: 'destroy',
    value: function destroy() {
      for (var loaderName in this.loaders) {
        var loader = this.loaders[loaderName];
        if (loader) {
          loader.destroy();
        }
      }
      this.loaders = {};
      _eventHandler2.default.prototype.destroy.call(this);
    }
  }, {
    key: 'onFragLoading',
    value: function onFragLoading(data) {
      var frag = data.frag,
          type = frag.type,
          loader = this.loaders[type],
          config = this.hls.config;

      frag.loaded = 0;
      if (loader) {
        _logger.logger.warn('abort previous fragment loader for type:' + type);
        loader.abort();
      }
      loader = this.loaders[type] = frag.loader = typeof config.fLoader !== 'undefined' ? new config.fLoader(config) : new config.loader(config);

      var loaderContext = void 0,
          loaderConfig = void 0,
          loaderCallbacks = void 0;
      loaderContext = { url: frag.url, frag: frag, responseType: 'arraybuffer', progressData: false };
      var start = frag.byteRangeStartOffset,
          end = frag.byteRangeEndOffset;
      if (!isNaN(start) && !isNaN(end)) {
        loaderContext.rangeStart = start;
        loaderContext.rangeEnd = end;
      }
      loaderConfig = { timeout: config.fragLoadingTimeOut, maxRetry: 0, retryDelay: 0, maxRetryDelay: config.fragLoadingMaxRetryTimeout };
      loaderCallbacks = { onSuccess: this.loadsuccess.bind(this), onError: this.loaderror.bind(this), onTimeout: this.loadtimeout.bind(this), onProgress: this.loadprogress.bind(this) };
      loader.load(loaderContext, loaderConfig, loaderCallbacks);
    }
  }, {
    key: 'loadsuccess',
    value: function loadsuccess(response, stats, context) {
      var payload = response.data,
          frag = context.frag;
      // detach fragment loader on load success
      frag.loader = undefined;
      this.loaders[frag.type] = undefined;
      this.hls.trigger(_events2.default.FRAG_LOADED, { payload: payload, frag: frag, stats: stats });
    }
  }, {
    key: 'loaderror',
    value: function loaderror(response, context) {
      var loader = context.loader;
      if (loader) {
        loader.abort();
      }
      this.loaders[context.type] = undefined;
      this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.NETWORK_ERROR, details: _errors.ErrorDetails.FRAG_LOAD_ERROR, fatal: false, frag: context.frag, response: response });
    }
  }, {
    key: 'loadtimeout',
    value: function loadtimeout(stats, context) {
      var loader = context.loader;
      if (loader) {
        loader.abort();
      }
      this.loaders[context.type] = undefined;
      this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.NETWORK_ERROR, details: _errors.ErrorDetails.FRAG_LOAD_TIMEOUT, fatal: false, frag: context.frag });
    }

    // data will be used for progressive parsing

  }, {
    key: 'loadprogress',
    value: function loadprogress(stats, context, data) {
      // jshint ignore:line
      var frag = context.frag;
      frag.loaded = stats.loaded;
      this.hls.trigger(_events2.default.FRAG_LOAD_PROGRESS, { frag: frag, stats: stats });
    }
  }]);

  return FragmentLoader;
}(_eventHandler2.default);

exports.default = FragmentLoader;

},{"../errors":25,"../event-handler":26,"../events":27,"../utils/logger":44}],34:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _eventHandler = require('../event-handler');

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _errors = require('../errors');

var _logger = require('../utils/logger');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Decrypt key Loader
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

var KeyLoader = function (_EventHandler) {
  _inherits(KeyLoader, _EventHandler);

  function KeyLoader(hls) {
    _classCallCheck(this, KeyLoader);

    var _this = _possibleConstructorReturn(this, (KeyLoader.__proto__ || Object.getPrototypeOf(KeyLoader)).call(this, hls, _events2.default.KEY_LOADING));

    _this.loaders = {};
    _this.decryptkey = null;
    _this.decrypturl = null;
    return _this;
  }

  _createClass(KeyLoader, [{
    key: 'destroy',
    value: function destroy() {
      for (var loaderName in this.loaders) {
        var loader = this.loaders[loaderName];
        if (loader) {
          loader.destroy();
        }
      }
      this.loaders = {};
      _eventHandler2.default.prototype.destroy.call(this);
    }
  }, {
    key: 'onKeyLoading',
    value: function onKeyLoading(data) {
      var frag = data.frag,
          type = frag.type,
          loader = this.loaders[type],
          decryptdata = frag.decryptdata,
          uri = decryptdata.uri;
      // if uri is different from previous one or if decrypt key not retrieved yet
      if (uri !== this.decrypturl || this.decryptkey === null) {
        var config = this.hls.config;

        if (loader) {
          _logger.logger.warn('abort previous fragment loader for type:' + type);
          loader.abort();
        }
        frag.loader = this.loaders[type] = new config.loader(config);
        this.decrypturl = uri;
        this.decryptkey = null;

        var loaderContext = void 0,
            loaderConfig = void 0,
            loaderCallbacks = void 0;
        loaderContext = { url: uri, frag: frag, responseType: 'arraybuffer' };
        loaderConfig = { timeout: config.fragLoadingTimeOut, maxRetry: config.fragLoadingMaxRetry, retryDelay: config.fragLoadingRetryDelay, maxRetryDelay: config.fragLoadingMaxRetryTimeout };
        loaderCallbacks = { onSuccess: this.loadsuccess.bind(this), onError: this.loaderror.bind(this), onTimeout: this.loadtimeout.bind(this) };
        frag.loader.load(loaderContext, loaderConfig, loaderCallbacks);
      } else if (this.decryptkey) {
        // we already loaded this key, return it
        decryptdata.key = this.decryptkey;
        this.hls.trigger(_events2.default.KEY_LOADED, { frag: frag });
      }
    }
  }, {
    key: 'loadsuccess',
    value: function loadsuccess(response, stats, context) {
      var frag = context.frag;
      this.decryptkey = frag.decryptdata.key = new Uint8Array(response.data);
      // detach fragment loader on load success
      frag.loader = undefined;
      this.loaders[context.type] = undefined;
      this.hls.trigger(_events2.default.KEY_LOADED, { frag: frag });
    }
  }, {
    key: 'loaderror',
    value: function loaderror(response, context) {
      var frag = context.frag,
          loader = frag.loader;
      if (loader) {
        loader.abort();
      }
      this.loaders[context.type] = undefined;
      this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.NETWORK_ERROR, details: _errors.ErrorDetails.KEY_LOAD_ERROR, fatal: false, frag: frag, response: response });
    }
  }, {
    key: 'loadtimeout',
    value: function loadtimeout(stats, context) {
      var frag = context.frag,
          loader = frag.loader;
      if (loader) {
        loader.abort();
      }
      this.loaders[context.type] = undefined;
      this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.NETWORK_ERROR, details: _errors.ErrorDetails.KEY_LOAD_TIMEOUT, fatal: false, frag: frag });
    }
  }]);

  return KeyLoader;
}(_eventHandler2.default);

exports.default = KeyLoader;

},{"../errors":25,"../event-handler":26,"../events":27,"../utils/logger":44}],35:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _eventHandler = require('../event-handler');

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _errors = require('../errors');

var _url = require('../utils/url');

var _url2 = _interopRequireDefault(_url);

var _attrList = require('../utils/attr-list');

var _attrList2 = _interopRequireDefault(_attrList);

var _logger = require('../utils/logger');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Playlist Loader
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

var PlaylistLoader = function (_EventHandler) {
  _inherits(PlaylistLoader, _EventHandler);

  function PlaylistLoader(hls) {
    _classCallCheck(this, PlaylistLoader);

    var _this = _possibleConstructorReturn(this, (PlaylistLoader.__proto__ || Object.getPrototypeOf(PlaylistLoader)).call(this, hls, _events2.default.MANIFEST_LOADING, _events2.default.LEVEL_LOADING, _events2.default.AUDIO_TRACK_LOADING));

    _this.loaders = {};
    return _this;
  }

  _createClass(PlaylistLoader, [{
    key: 'destroy',
    value: function destroy() {
      for (var loaderName in this.loaders) {
        var loader = this.loaders[loaderName];
        if (loader) {
          loader.destroy();
        }
      }
      this.loaders = {};
      _eventHandler2.default.prototype.destroy.call(this);
    }
  }, {
    key: 'onManifestLoading',
    value: function onManifestLoading(data) {
      this.load(data.url, { type: 'manifest' });
    }
  }, {
    key: 'onLevelLoading',
    value: function onLevelLoading(data) {
      this.load(data.url, { type: 'level', level: data.level, id: data.id });
    }
  }, {
    key: 'onAudioTrackLoading',
    value: function onAudioTrackLoading(data) {
      this.load(data.url, { type: 'audioTrack', id: data.id });
    }
  }, {
    key: 'load',
    value: function load(url, context) {
      var config = this.hls.config,
          retry,
          timeout,
          retryDelay,
          maxRetryDelay;
      if (context.type === 'manifest') {
        retry = config.manifestLoadingMaxRetry;
        timeout = config.manifestLoadingTimeOut;
        retryDelay = config.manifestLoadingRetryDelay;
        maxRetryDelay = config.manifestLoadingMaxRetryTimeOut;
      } else {
        retry = config.levelLoadingMaxRetry;
        timeout = config.levelLoadingTimeOut;
        retryDelay = config.levelLoadingRetryDelay;
        maxRetryDelay = config.levelLoadingMaxRetryTimeOut;
      }
      var loader = this.loaders[context.type];
      if (loader) {
        var loaderContext = loader.context;
        if (loaderContext && loaderContext.url === url) {
          _logger.logger.warn('playlist request ongoing');
          return;
        } else {
          _logger.logger.warn('abort previous loader for type:' + context.type);
          loader.abort();
        }
      }
      loader = this.loaders[context.type] = context.loader = typeof config.pLoader !== 'undefined' ? new config.pLoader(config) : new config.loader(config);
      context.url = url;
      context.responseType = '';

      var loaderConfig = void 0,
          loaderCallbacks = void 0;
      loaderConfig = { timeout: timeout, maxRetry: retry, retryDelay: retryDelay, maxRetryDelay: maxRetryDelay };
      loaderCallbacks = { onSuccess: this.loadsuccess.bind(this), onError: this.loaderror.bind(this), onTimeout: this.loadtimeout.bind(this) };
      loader.load(context, loaderConfig, loaderCallbacks);
    }
  }, {
    key: 'resolve',
    value: function resolve(url, baseUrl) {
      return _url2.default.buildAbsoluteURL(baseUrl, url);
    }
  }, {
    key: 'parseMasterPlaylist',
    value: function parseMasterPlaylist(string, baseurl) {
      var levels = [],
          result = void 0;

      // https://regex101.com is your friend
      var re = /#EXT-X-STREAM-INF:([^\n\r]*)[\r\n]+([^\r\n]+)/g;
      while ((result = re.exec(string)) != null) {
        var level = {};

        var attrs = level.attrs = new _attrList2.default(result[1]);
        level.url = this.resolve(result[2], baseurl);

        var resolution = attrs.decimalResolution('RESOLUTION');
        if (resolution) {
          level.width = resolution.width;
          level.height = resolution.height;
        }
        level.bitrate = attrs.decimalInteger('AVERAGE-BANDWIDTH') || attrs.decimalInteger('BANDWIDTH');
        level.name = attrs.NAME;

        var codecs = attrs.CODECS;
        if (codecs) {
          codecs = codecs.split(',');
          for (var i = 0; i < codecs.length; i++) {
            var codec = codecs[i];
            if (codec.indexOf('avc1') !== -1) {
              level.videoCodec = this.avc1toavcoti(codec);
            } else {
              level.audioCodec = codec;
            }
          }
        }

        levels.push(level);
      }
      return levels;
    }
  }, {
    key: 'parseMasterPlaylistMedia',
    value: function parseMasterPlaylistMedia(string, baseurl, type) {
      var result = void 0,
          medias = [];

      // https://regex101.com is your friend
      var re = /#EXT-X-MEDIA:(.*)/g;
      while ((result = re.exec(string)) != null) {
        var media = {};
        var attrs = new _attrList2.default(result[1]);
        if (attrs.TYPE === type) {
          media.groupId = attrs['GROUP-ID'];
          media.name = attrs.NAME;
          media.type = type;
          media.default = attrs.DEFAULT === 'YES';
          media.autoselect = attrs.AUTOSELECT === 'YES';
          media.forced = attrs.FORCED === 'YES';
          if (attrs.URI) {
            media.url = this.resolve(attrs.URI, baseurl);
          }
          media.lang = attrs.LANGUAGE;
          if (!media.name) {
            media.name = media.lang;
          }
          medias.push(media);
        }
      }
      return medias;
    }
    /**
     * Utility method for parseLevelPlaylist to create an initialization vector for a given segment
     * @returns {Uint8Array}
     */

  }, {
    key: 'createInitializationVector',
    value: function createInitializationVector(segmentNumber) {
      var uint8View = new Uint8Array(16);

      for (var i = 12; i < 16; i++) {
        uint8View[i] = segmentNumber >> 8 * (15 - i) & 0xff;
      }

      return uint8View;
    }

    /**
     * Utility method for parseLevelPlaylist to get a fragment's decryption data from the currently parsed encryption key data
     * @param levelkey - a playlist's encryption info
     * @param segmentNumber - the fragment's segment number
     * @returns {*} - an object to be applied as a fragment's decryptdata
     */

  }, {
    key: 'fragmentDecryptdataFromLevelkey',
    value: function fragmentDecryptdataFromLevelkey(levelkey, segmentNumber) {
      var decryptdata = levelkey;

      if (levelkey && levelkey.method && levelkey.uri && !levelkey.iv) {
        decryptdata = this.cloneObj(levelkey);
        decryptdata.iv = this.createInitializationVector(segmentNumber);
      }

      return decryptdata;
    }
  }, {
    key: 'avc1toavcoti',
    value: function avc1toavcoti(codec) {
      var result,
          avcdata = codec.split('.');
      if (avcdata.length > 2) {
        result = avcdata.shift() + '.';
        result += parseInt(avcdata.shift()).toString(16);
        result += ('000' + parseInt(avcdata.shift()).toString(16)).substr(-4);
      } else {
        result = codec;
      }
      return result;
    }
  }, {
    key: 'cloneObj',
    value: function cloneObj(obj) {
      return JSON.parse(JSON.stringify(obj));
    }
  }, {
    key: 'parseLevelPlaylist',
    value: function parseLevelPlaylist(string, baseurl, id, type) {
      var currentSN = 0,
          fragdecryptdata,
          totalduration = 0,
          level = { type: null, version: null, url: baseurl, fragments: [], live: true, startSN: 0 },
          levelkey = { method: null, key: null, iv: null, uri: null },
          cc = 0,
          programDateTime = null,
          frag = null,
          result,
          regexp,
          duration = null,
          title = null,
          byteRangeEndOffset = null,
          byteRangeStartOffset = null,
          tagList = [];

      regexp = /(?:(?:#(EXTM3U))|(?:#EXT-X-(PLAYLIST-TYPE):(.+))|(?:#EXT-X-(MEDIA-SEQUENCE):(\d+))|(?:#EXT-X-(TARGETDURATION):(\d+))|(?:#EXT-X-(KEY):(.+))|(?:#EXT-X-(START):(.+))|(?:#EXT(INF):(\d+(?:\.\d+)?)(?:,(.*))?)|(?:(?!#)()(\S.+))|(?:#EXT-X-(BYTERANGE):(\d+(?:@\d+(?:\.\d+)?)?)|(?:#EXT-X-(ENDLIST))|(?:#EXT-X-(DIS)CONTINUITY))|(?:#EXT-X-(PROGRAM-DATE-TIME):(.+))|(?:#EXT-X-(VERSION):(\d+))|(?:(#)(.*):(.*))|(?:(#)(.*)))(?:.*)\r?\n?/g;
      while ((result = regexp.exec(string)) !== null) {
        result.shift();
        result = result.filter(function (n) {
          return n !== undefined;
        });
        switch (result[0]) {
          case 'PLAYLIST-TYPE':
            level.type = result[1].toUpperCase();
            break;
          case 'MEDIA-SEQUENCE':
            currentSN = level.startSN = parseInt(result[1]);
            break;
          case 'TARGETDURATION':
            level.targetduration = parseFloat(result[1]);
            break;
          case 'VERSION':
            level.version = parseInt(result[1]);
            break;
          case 'EXTM3U':
            break;
          case 'ENDLIST':
            level.live = false;
            break;
          case 'DIS':
            cc++;
            tagList.push(result);
            break;
          case 'BYTERANGE':
            var params = result[1].split('@');
            if (params.length === 1) {
              byteRangeStartOffset = byteRangeEndOffset;
            } else {
              byteRangeStartOffset = parseInt(params[1]);
            }
            byteRangeEndOffset = parseInt(params[0]) + byteRangeStartOffset;
            break;
          case 'INF':
            duration = parseFloat(result[1]);
            title = result[2] ? result[2] : null;
            tagList.push(result);
            break;
          case '':
            // url
            if (!isNaN(duration)) {
              var sn = currentSN++;
              fragdecryptdata = this.fragmentDecryptdataFromLevelkey(levelkey, sn);
              var url = result[1] ? this.resolve(result[1], baseurl) : null;
              frag = { url: url,
                type: type,
                duration: duration,
                title: title,
                start: totalduration,
                sn: sn,
                level: id,
                cc: cc,
                decryptdata: fragdecryptdata,
                programDateTime: programDateTime,
                tagList: tagList };
              // only include byte range options if used/needed
              if (byteRangeStartOffset !== null) {
                frag.byteRangeStartOffset = byteRangeStartOffset;
                frag.byteRangeEndOffset = byteRangeEndOffset;
              }
              level.fragments.push(frag);
              totalduration += duration;
              duration = null;
              title = null;
              byteRangeStartOffset = null;
              programDateTime = null;
              tagList = [];
            }
            break;
          case 'KEY':
            // https://tools.ietf.org/html/draft-pantos-http-live-streaming-08#section-3.4.4
            var decryptparams = result[1];
            var keyAttrs = new _attrList2.default(decryptparams);
            var decryptmethod = keyAttrs.enumeratedString('METHOD'),
                decrypturi = keyAttrs.URI,
                decryptiv = keyAttrs.hexadecimalInteger('IV');
            if (decryptmethod) {
              levelkey = { method: null, key: null, iv: null, uri: null };
              if (decrypturi && decryptmethod === 'AES-128') {
                levelkey.method = decryptmethod;
                // URI to get the key
                levelkey.uri = this.resolve(decrypturi, baseurl);
                levelkey.key = null;
                // Initialization Vector (IV)
                levelkey.iv = decryptiv;
              }
            }
            break;
          case 'START':
            var startParams = result[1];
            var startAttrs = new _attrList2.default(startParams);
            var startTimeOffset = startAttrs.decimalFloatingPoint('TIME-OFFSET');
            //TIME-OFFSET can be 0
            if (!isNaN(startTimeOffset)) {
              level.startTimeOffset = startTimeOffset;
            }
            break;
          case 'PROGRAM-DATE-TIME':
            programDateTime = new Date(Date.parse(result[1]));
            tagList.push(result);
            break;
          case '#':
            result.shift();
            tagList.push(result);
            break;
          default:
            _logger.logger.warn('line parsed but not handled: ' + result);
            break;
        }
      }
      //logger.log('found ' + level.fragments.length + ' fragments');
      if (frag && !frag.url) {
        level.fragments.pop();
        totalduration -= frag.duration;
      }
      level.totalduration = totalduration;
      level.averagetargetduration = totalduration / level.fragments.length;
      level.endSN = currentSN - 1;
      return level;
    }
  }, {
    key: 'loadsuccess',
    value: function loadsuccess(response, stats, context) {
      var string = response.data,
          url = response.url,
          type = context.type,
          id = context.id,
          level = context.level,
          hls = this.hls;

      this.loaders[type] = undefined;
      // responseURL not supported on some browsers (it is used to detect URL redirection)
      // data-uri mode also not supported (but no need to detect redirection)
      if (url === undefined || url.indexOf('data:') === 0) {
        // fallback to initial URL
        url = context.url;
      }
      stats.tload = performance.now();
      //stats.mtime = new Date(target.getResponseHeader('Last-Modified'));
      if (string.indexOf('#EXTM3U') === 0) {
        if (string.indexOf('#EXTINF:') > 0) {
          var isLevel = type !== 'audioTrack',
              levelDetails = this.parseLevelPlaylist(string, url, (isLevel ? level : id) || 0, isLevel ? 'main' : 'audio');
          levelDetails.tload = stats.tload;
          if (type === 'manifest') {
            // first request, stream manifest (no master playlist), fire manifest loaded event with level details
            hls.trigger(_events2.default.MANIFEST_LOADED, { levels: [{ url: url, details: levelDetails }], url: url, stats: stats });
          }
          stats.tparsed = performance.now();
          if (isLevel) {
            hls.trigger(_events2.default.LEVEL_LOADED, { details: levelDetails, level: level || 0, id: id || 0, stats: stats });
          } else {
            hls.trigger(_events2.default.AUDIO_TRACK_LOADED, { details: levelDetails, id: id, stats: stats });
          }
        } else {
          var levels = this.parseMasterPlaylist(string, url);
          // multi level playlist, parse level info
          if (levels.length) {
            var audiotracks = this.parseMasterPlaylistMedia(string, url, 'AUDIO');
            if (audiotracks.length) {
              // check if we have found an audio track embedded in main playlist (audio track without URI attribute)
              var embeddedAudioFound = false;
              audiotracks.forEach(function (audioTrack) {
                if (!audioTrack.url) {
                  embeddedAudioFound = true;
                }
              });
              // if no embedded audio track defined, but audio codec signaled in quality level, we need to signal this main audio track
              // this could happen with playlists with alt audio rendition in which quality levels (main) contains both audio+video. but with mixed audio track not signaled
              if (embeddedAudioFound === false && levels[0].audioCodec && !levels[0].attrs.AUDIO) {
                _logger.logger.log('audio codec signaled in quality level, but no embedded audio track signaled, create one');
                audiotracks.unshift({ type: 'main', name: 'main' });
              }
            }
            hls.trigger(_events2.default.MANIFEST_LOADED, { levels: levels, audioTracks: audiotracks, url: url, stats: stats });
          } else {
            hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.NETWORK_ERROR, details: _errors.ErrorDetails.MANIFEST_PARSING_ERROR, fatal: true, url: url, reason: 'no level found in manifest' });
          }
        }
      } else {
        hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.NETWORK_ERROR, details: _errors.ErrorDetails.MANIFEST_PARSING_ERROR, fatal: true, url: url, reason: 'no EXTM3U delimiter' });
      }
    }
  }, {
    key: 'loaderror',
    value: function loaderror(response, context) {
      var details,
          fatal,
          loader = context.loader;
      switch (context.type) {
        case 'manifest':
          details = _errors.ErrorDetails.MANIFEST_LOAD_ERROR;
          fatal = true;
          break;
        case 'level':
          details = _errors.ErrorDetails.LEVEL_LOAD_ERROR;
          fatal = false;
          break;
        case 'audioTrack':
          details = _errors.ErrorDetails.AUDIO_TRACK_LOAD_ERROR;
          fatal = false;
          break;
      }
      if (loader) {
        loader.abort();
        this.loaders[context.type] = undefined;
      }
      this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.NETWORK_ERROR, details: details, fatal: fatal, url: loader.url, loader: loader, response: response, context: context });
    }
  }, {
    key: 'loadtimeout',
    value: function loadtimeout(stats, context) {
      var details,
          fatal,
          loader = context.loader;
      switch (context.type) {
        case 'manifest':
          details = _errors.ErrorDetails.MANIFEST_LOAD_TIMEOUT;
          fatal = true;
          break;
        case 'level':
          details = _errors.ErrorDetails.LEVEL_LOAD_TIMEOUT;
          fatal = false;
          break;
        case 'audioTrack':
          details = _errors.ErrorDetails.AUDIO_TRACK_LOAD_TIMEOUT;
          fatal = false;
          break;
      }
      if (loader) {
        loader.abort();
        this.loaders[context.type] = undefined;
      }
      this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.NETWORK_ERROR, details: details, fatal: fatal, url: loader.url, loader: loader, context: context });
    }
  }]);

  return PlaylistLoader;
}(_eventHandler2.default);

exports.default = PlaylistLoader;

},{"../errors":25,"../event-handler":26,"../events":27,"../utils/attr-list":39,"../utils/logger":44,"../utils/url":47}],36:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Generate MP4 Box
*/

//import Hex from '../utils/hex';
var MP4 = function () {
  function MP4() {
    _classCallCheck(this, MP4);
  }

  _createClass(MP4, null, [{
    key: 'init',
    value: function init() {
      MP4.types = {
        avc1: [], // codingname
        avcC: [],
        btrt: [],
        dinf: [],
        dref: [],
        esds: [],
        ftyp: [],
        hdlr: [],
        mdat: [],
        mdhd: [],
        mdia: [],
        mfhd: [],
        minf: [],
        moof: [],
        moov: [],
        mp4a: [],
        mvex: [],
        mvhd: [],
        sdtp: [],
        stbl: [],
        stco: [],
        stsc: [],
        stsd: [],
        stsz: [],
        stts: [],
        tfdt: [],
        tfhd: [],
        traf: [],
        trak: [],
        trun: [],
        trex: [],
        tkhd: [],
        vmhd: [],
        smhd: []
      };

      var i;
      for (i in MP4.types) {
        if (MP4.types.hasOwnProperty(i)) {
          MP4.types[i] = [i.charCodeAt(0), i.charCodeAt(1), i.charCodeAt(2), i.charCodeAt(3)];
        }
      }

      var videoHdlr = new Uint8Array([0x00, // version 0
      0x00, 0x00, 0x00, // flags
      0x00, 0x00, 0x00, 0x00, // pre_defined
      0x76, 0x69, 0x64, 0x65, // handler_type: 'vide'
      0x00, 0x00, 0x00, 0x00, // reserved
      0x00, 0x00, 0x00, 0x00, // reserved
      0x00, 0x00, 0x00, 0x00, // reserved
      0x56, 0x69, 0x64, 0x65, 0x6f, 0x48, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'VideoHandler'
      ]);

      var audioHdlr = new Uint8Array([0x00, // version 0
      0x00, 0x00, 0x00, // flags
      0x00, 0x00, 0x00, 0x00, // pre_defined
      0x73, 0x6f, 0x75, 0x6e, // handler_type: 'soun'
      0x00, 0x00, 0x00, 0x00, // reserved
      0x00, 0x00, 0x00, 0x00, // reserved
      0x00, 0x00, 0x00, 0x00, // reserved
      0x53, 0x6f, 0x75, 0x6e, 0x64, 0x48, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'SoundHandler'
      ]);

      MP4.HDLR_TYPES = {
        'video': videoHdlr,
        'audio': audioHdlr
      };

      var dref = new Uint8Array([0x00, // version 0
      0x00, 0x00, 0x00, // flags
      0x00, 0x00, 0x00, 0x01, // entry_count
      0x00, 0x00, 0x00, 0x0c, // entry_size
      0x75, 0x72, 0x6c, 0x20, // 'url' type
      0x00, // version 0
      0x00, 0x00, 0x01 // entry_flags
      ]);

      var stco = new Uint8Array([0x00, // version
      0x00, 0x00, 0x00, // flags
      0x00, 0x00, 0x00, 0x00 // entry_count
      ]);

      MP4.STTS = MP4.STSC = MP4.STCO = stco;

      MP4.STSZ = new Uint8Array([0x00, // version
      0x00, 0x00, 0x00, // flags
      0x00, 0x00, 0x00, 0x00, // sample_size
      0x00, 0x00, 0x00, 0x00]);
      MP4.VMHD = new Uint8Array([0x00, // version
      0x00, 0x00, 0x01, // flags
      0x00, 0x00, // graphicsmode
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00 // opcolor
      ]);
      MP4.SMHD = new Uint8Array([0x00, // version
      0x00, 0x00, 0x00, // flags
      0x00, 0x00, // balance
      0x00, 0x00 // reserved
      ]);

      MP4.STSD = new Uint8Array([0x00, // version 0
      0x00, 0x00, 0x00, // flags
      0x00, 0x00, 0x00, 0x01]); // entry_count

      var majorBrand = new Uint8Array([105, 115, 111, 109]); // isom
      var avc1Brand = new Uint8Array([97, 118, 99, 49]); // avc1
      var minorVersion = new Uint8Array([0, 0, 0, 1]);

      MP4.FTYP = MP4.box(MP4.types.ftyp, majorBrand, minorVersion, majorBrand, avc1Brand);
      MP4.DINF = MP4.box(MP4.types.dinf, MP4.box(MP4.types.dref, dref));
    }
  }, {
    key: 'box',
    value: function box(type) {
      var payload = Array.prototype.slice.call(arguments, 1),
          size = 8,
          i = payload.length,
          len = i,
          result;
      // calculate the total size we need to allocate
      while (i--) {
        size += payload[i].byteLength;
      }
      result = new Uint8Array(size);
      result[0] = size >> 24 & 0xff;
      result[1] = size >> 16 & 0xff;
      result[2] = size >> 8 & 0xff;
      result[3] = size & 0xff;
      result.set(type, 4);
      // copy the payload into the result
      for (i = 0, size = 8; i < len; i++) {
        // copy payload[i] array @ offset size
        result.set(payload[i], size);
        size += payload[i].byteLength;
      }
      return result;
    }
  }, {
    key: 'hdlr',
    value: function hdlr(type) {
      return MP4.box(MP4.types.hdlr, MP4.HDLR_TYPES[type]);
    }
  }, {
    key: 'mdat',
    value: function mdat(data) {
      return MP4.box(MP4.types.mdat, data);
    }
  }, {
    key: 'mdhd',
    value: function mdhd(timescale, duration) {
      duration *= timescale;
      return MP4.box(MP4.types.mdhd, new Uint8Array([0x00, // version 0
      0x00, 0x00, 0x00, // flags
      0x00, 0x00, 0x00, 0x02, // creation_time
      0x00, 0x00, 0x00, 0x03, // modification_time
      timescale >> 24 & 0xFF, timescale >> 16 & 0xFF, timescale >> 8 & 0xFF, timescale & 0xFF, // timescale
      duration >> 24, duration >> 16 & 0xFF, duration >> 8 & 0xFF, duration & 0xFF, // duration
      0x55, 0xc4, // 'und' language (undetermined)
      0x00, 0x00]));
    }
  }, {
    key: 'mdia',
    value: function mdia(track) {
      return MP4.box(MP4.types.mdia, MP4.mdhd(track.timescale, track.duration), MP4.hdlr(track.type), MP4.minf(track));
    }
  }, {
    key: 'mfhd',
    value: function mfhd(sequenceNumber) {
      return MP4.box(MP4.types.mfhd, new Uint8Array([0x00, 0x00, 0x00, 0x00, // flags
      sequenceNumber >> 24, sequenceNumber >> 16 & 0xFF, sequenceNumber >> 8 & 0xFF, sequenceNumber & 0xFF]));
    }
  }, {
    key: 'minf',
    value: function minf(track) {
      if (track.type === 'audio') {
        return MP4.box(MP4.types.minf, MP4.box(MP4.types.smhd, MP4.SMHD), MP4.DINF, MP4.stbl(track));
      } else {
        return MP4.box(MP4.types.minf, MP4.box(MP4.types.vmhd, MP4.VMHD), MP4.DINF, MP4.stbl(track));
      }
    }
  }, {
    key: 'moof',
    value: function moof(sn, baseMediaDecodeTime, track) {
      return MP4.box(MP4.types.moof, MP4.mfhd(sn), MP4.traf(track, baseMediaDecodeTime));
    }
    /**
     * @param tracks... (optional) {array} the tracks associated with this movie
     */

  }, {
    key: 'moov',
    value: function moov(tracks) {
      var i = tracks.length,
          boxes = [];

      while (i--) {
        boxes[i] = MP4.trak(tracks[i]);
      }

      return MP4.box.apply(null, [MP4.types.moov, MP4.mvhd(tracks[0].timescale, tracks[0].duration)].concat(boxes).concat(MP4.mvex(tracks)));
    }
  }, {
    key: 'mvex',
    value: function mvex(tracks) {
      var i = tracks.length,
          boxes = [];

      while (i--) {
        boxes[i] = MP4.trex(tracks[i]);
      }
      return MP4.box.apply(null, [MP4.types.mvex].concat(boxes));
    }
  }, {
    key: 'mvhd',
    value: function mvhd(timescale, duration) {
      duration *= timescale;
      var bytes = new Uint8Array([0x00, // version 0
      0x00, 0x00, 0x00, // flags
      0x00, 0x00, 0x00, 0x01, // creation_time
      0x00, 0x00, 0x00, 0x02, // modification_time
      timescale >> 24 & 0xFF, timescale >> 16 & 0xFF, timescale >> 8 & 0xFF, timescale & 0xFF, // timescale
      duration >> 24 & 0xFF, duration >> 16 & 0xFF, duration >> 8 & 0xFF, duration & 0xFF, // duration
      0x00, 0x01, 0x00, 0x00, // 1.0 rate
      0x01, 0x00, // 1.0 volume
      0x00, 0x00, // reserved
      0x00, 0x00, 0x00, 0x00, // reserved
      0x00, 0x00, 0x00, 0x00, // reserved
      0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, // transformation: unity matrix
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // pre_defined
      0xff, 0xff, 0xff, 0xff // next_track_ID
      ]);
      return MP4.box(MP4.types.mvhd, bytes);
    }
  }, {
    key: 'sdtp',
    value: function sdtp(track) {
      var samples = track.samples || [],
          bytes = new Uint8Array(4 + samples.length),
          flags,
          i;
      // leave the full box header (4 bytes) all zero
      // write the sample table
      for (i = 0; i < samples.length; i++) {
        flags = samples[i].flags;
        bytes[i + 4] = flags.dependsOn << 4 | flags.isDependedOn << 2 | flags.hasRedundancy;
      }

      return MP4.box(MP4.types.sdtp, bytes);
    }
  }, {
    key: 'stbl',
    value: function stbl(track) {
      return MP4.box(MP4.types.stbl, MP4.stsd(track), MP4.box(MP4.types.stts, MP4.STTS), MP4.box(MP4.types.stsc, MP4.STSC), MP4.box(MP4.types.stsz, MP4.STSZ), MP4.box(MP4.types.stco, MP4.STCO));
    }
  }, {
    key: 'avc1',
    value: function avc1(track) {
      var sps = [],
          pps = [],
          i,
          data,
          len;
      // assemble the SPSs

      for (i = 0; i < track.sps.length; i++) {
        data = track.sps[i];
        len = data.byteLength;
        sps.push(len >>> 8 & 0xFF);
        sps.push(len & 0xFF);
        sps = sps.concat(Array.prototype.slice.call(data)); // SPS
      }

      // assemble the PPSs
      for (i = 0; i < track.pps.length; i++) {
        data = track.pps[i];
        len = data.byteLength;
        pps.push(len >>> 8 & 0xFF);
        pps.push(len & 0xFF);
        pps = pps.concat(Array.prototype.slice.call(data));
      }

      var avcc = MP4.box(MP4.types.avcC, new Uint8Array([0x01, // version
      sps[3], // profile
      sps[4], // profile compat
      sps[5], // level
      0xfc | 3, // lengthSizeMinusOne, hard-coded to 4 bytes
      0xE0 | track.sps.length // 3bit reserved (111) + numOfSequenceParameterSets
      ].concat(sps).concat([track.pps.length // numOfPictureParameterSets
      ]).concat(pps))),
          // "PPS"
      width = track.width,
          height = track.height;
      //console.log('avcc:' + Hex.hexDump(avcc));
      return MP4.box(MP4.types.avc1, new Uint8Array([0x00, 0x00, 0x00, // reserved
      0x00, 0x00, 0x00, // reserved
      0x00, 0x01, // data_reference_index
      0x00, 0x00, // pre_defined
      0x00, 0x00, // reserved
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // pre_defined
      width >> 8 & 0xFF, width & 0xff, // width
      height >> 8 & 0xFF, height & 0xff, // height
      0x00, 0x48, 0x00, 0x00, // horizresolution
      0x00, 0x48, 0x00, 0x00, // vertresolution
      0x00, 0x00, 0x00, 0x00, // reserved
      0x00, 0x01, // frame_count
      0x12, 0x64, 0x61, 0x69, 0x6C, //dailymotion/hls.js
      0x79, 0x6D, 0x6F, 0x74, 0x69, 0x6F, 0x6E, 0x2F, 0x68, 0x6C, 0x73, 0x2E, 0x6A, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // compressorname
      0x00, 0x18, // depth = 24
      0x11, 0x11]), // pre_defined = -1
      avcc, MP4.box(MP4.types.btrt, new Uint8Array([0x00, 0x1c, 0x9c, 0x80, // bufferSizeDB
      0x00, 0x2d, 0xc6, 0xc0, // maxBitrate
      0x00, 0x2d, 0xc6, 0xc0])) // avgBitrate
      );
    }
  }, {
    key: 'esds',
    value: function esds(track) {
      var configlen = track.config.length;
      return new Uint8Array([0x00, // version 0
      0x00, 0x00, 0x00, // flags

      0x03, // descriptor_type
      0x17 + configlen, // length
      0x00, 0x01, //es_id
      0x00, // stream_priority

      0x04, // descriptor_type
      0x0f + configlen, // length
      0x40, //codec : mpeg4_audio
      0x15, // stream_type
      0x00, 0x00, 0x00, // buffer_size
      0x00, 0x00, 0x00, 0x00, // maxBitrate
      0x00, 0x00, 0x00, 0x00, // avgBitrate

      0x05 // descriptor_type
      ].concat([configlen]).concat(track.config).concat([0x06, 0x01, 0x02])); // GASpecificConfig)); // length + audio config descriptor
    }
  }, {
    key: 'mp4a',
    value: function mp4a(track) {
      var audiosamplerate = track.audiosamplerate;
      return MP4.box(MP4.types.mp4a, new Uint8Array([0x00, 0x00, 0x00, // reserved
      0x00, 0x00, 0x00, // reserved
      0x00, 0x01, // data_reference_index
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // reserved
      0x00, track.channelCount, // channelcount
      0x00, 0x10, // sampleSize:16bits
      0x00, 0x00, 0x00, 0x00, // reserved2
      audiosamplerate >> 8 & 0xFF, audiosamplerate & 0xff, //
      0x00, 0x00]), MP4.box(MP4.types.esds, MP4.esds(track)));
    }
  }, {
    key: 'stsd',
    value: function stsd(track) {
      if (track.type === 'audio') {
        return MP4.box(MP4.types.stsd, MP4.STSD, MP4.mp4a(track));
      } else {
        return MP4.box(MP4.types.stsd, MP4.STSD, MP4.avc1(track));
      }
    }
  }, {
    key: 'tkhd',
    value: function tkhd(track) {
      var id = track.id,
          duration = track.duration * track.timescale,
          width = track.width,
          height = track.height;
      return MP4.box(MP4.types.tkhd, new Uint8Array([0x00, // version 0
      0x00, 0x00, 0x07, // flags
      0x00, 0x00, 0x00, 0x00, // creation_time
      0x00, 0x00, 0x00, 0x00, // modification_time
      id >> 24 & 0xFF, id >> 16 & 0xFF, id >> 8 & 0xFF, id & 0xFF, // track_ID
      0x00, 0x00, 0x00, 0x00, // reserved
      duration >> 24, duration >> 16 & 0xFF, duration >> 8 & 0xFF, duration & 0xFF, // duration
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // reserved
      0x00, 0x00, // layer
      0x00, 0x00, // alternate_group
      0x00, 0x00, // non-audio track volume
      0x00, 0x00, // reserved
      0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, // transformation: unity matrix
      width >> 8 & 0xFF, width & 0xFF, 0x00, 0x00, // width
      height >> 8 & 0xFF, height & 0xFF, 0x00, 0x00 // height
      ]));
    }
  }, {
    key: 'traf',
    value: function traf(track, baseMediaDecodeTime) {
      var sampleDependencyTable = MP4.sdtp(track),
          id = track.id;
      return MP4.box(MP4.types.traf, MP4.box(MP4.types.tfhd, new Uint8Array([0x00, // version 0
      0x00, 0x00, 0x00, // flags
      id >> 24, id >> 16 & 0XFF, id >> 8 & 0XFF, id & 0xFF])), MP4.box(MP4.types.tfdt, new Uint8Array([0x00, // version 0
      0x00, 0x00, 0x00, // flags
      baseMediaDecodeTime >> 24, baseMediaDecodeTime >> 16 & 0XFF, baseMediaDecodeTime >> 8 & 0XFF, baseMediaDecodeTime & 0xFF])), MP4.trun(track, sampleDependencyTable.length + 16 + // tfhd
      16 + // tfdt
      8 + // traf header
      16 + // mfhd
      8 + // moof header
      8), // mdat header
      sampleDependencyTable);
    }

    /**
     * Generate a track box.
     * @param track {object} a track definition
     * @return {Uint8Array} the track box
     */

  }, {
    key: 'trak',
    value: function trak(track) {
      track.duration = track.duration || 0xffffffff;
      return MP4.box(MP4.types.trak, MP4.tkhd(track), MP4.mdia(track));
    }
  }, {
    key: 'trex',
    value: function trex(track) {
      var id = track.id;
      return MP4.box(MP4.types.trex, new Uint8Array([0x00, // version 0
      0x00, 0x00, 0x00, // flags
      id >> 24, id >> 16 & 0XFF, id >> 8 & 0XFF, id & 0xFF, // track_ID
      0x00, 0x00, 0x00, 0x01, // default_sample_description_index
      0x00, 0x00, 0x00, 0x00, // default_sample_duration
      0x00, 0x00, 0x00, 0x00, // default_sample_size
      0x00, 0x01, 0x00, 0x01 // default_sample_flags
      ]));
    }
  }, {
    key: 'trun',
    value: function trun(track, offset) {
      var samples = track.samples || [],
          len = samples.length,
          arraylen = 12 + 16 * len,
          array = new Uint8Array(arraylen),
          i,
          sample,
          duration,
          size,
          flags,
          cts;
      offset += 8 + arraylen;
      array.set([0x00, // version 0
      0x00, 0x0f, 0x01, // flags
      len >>> 24 & 0xFF, len >>> 16 & 0xFF, len >>> 8 & 0xFF, len & 0xFF, // sample_count
      offset >>> 24 & 0xFF, offset >>> 16 & 0xFF, offset >>> 8 & 0xFF, offset & 0xFF // data_offset
      ], 0);
      for (i = 0; i < len; i++) {
        sample = samples[i];
        duration = sample.duration;
        size = sample.size;
        flags = sample.flags;
        cts = sample.cts;
        array.set([duration >>> 24 & 0xFF, duration >>> 16 & 0xFF, duration >>> 8 & 0xFF, duration & 0xFF, // sample_duration
        size >>> 24 & 0xFF, size >>> 16 & 0xFF, size >>> 8 & 0xFF, size & 0xFF, // sample_size
        flags.isLeading << 2 | flags.dependsOn, flags.isDependedOn << 6 | flags.hasRedundancy << 4 | flags.paddingValue << 1 | flags.isNonSync, flags.degradPrio & 0xF0 << 8, flags.degradPrio & 0x0F, // sample_flags
        cts >>> 24 & 0xFF, cts >>> 16 & 0xFF, cts >>> 8 & 0xFF, cts & 0xFF // sample_composition_time_offset
        ], 12 + 16 * i);
      }
      return MP4.box(MP4.types.trun, array);
    }
  }, {
    key: 'initSegment',
    value: function initSegment(tracks) {
      if (!MP4.types) {
        MP4.init();
      }
      var movie = MP4.moov(tracks),
          result;
      result = new Uint8Array(MP4.FTYP.byteLength + movie.byteLength);
      result.set(MP4.FTYP);
      result.set(movie, MP4.FTYP.byteLength);
      return result;
    }
  }]);

  return MP4;
}();

exports.default = MP4;

},{}],37:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * fMP4 remuxer
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */

var _aac = require('../helper/aac');

var _aac2 = _interopRequireDefault(_aac);

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _logger = require('../utils/logger');

var _mp4Generator = require('../remux/mp4-generator');

var _mp4Generator2 = _interopRequireDefault(_mp4Generator);

var _errors = require('../errors');

require('../utils/polyfill');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var MP4Remuxer = function () {
  function MP4Remuxer(observer, id, config) {
    _classCallCheck(this, MP4Remuxer);

    this.observer = observer;
    this.id = id;
    this.config = config;
    this.ISGenerated = false;
    this.PES2MP4SCALEFACTOR = 4;
    this.PES_TIMESCALE = 90000;
    this.MP4_TIMESCALE = this.PES_TIMESCALE / this.PES2MP4SCALEFACTOR;
  }

  _createClass(MP4Remuxer, [{
    key: 'destroy',
    value: function destroy() {}
  }, {
    key: 'insertDiscontinuity',
    value: function insertDiscontinuity() {
      this._initPTS = this._initDTS = undefined;
    }
  }, {
    key: 'switchLevel',
    value: function switchLevel() {
      this.ISGenerated = false;
    }
  }, {
    key: 'remux',
    value: function remux(level, sn, audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset) {
      this.level = level;
      this.sn = sn;
      // generate Init Segment if needed
      if (!this.ISGenerated) {
        this.generateIS(audioTrack, videoTrack, timeOffset);
      }

      if (this.ISGenerated) {
        // Purposefully remuxing audio before video, so that remuxVideo can use nextAacPts, which is
        // calculated in remuxAudio.
        //logger.log('nb AAC samples:' + audioTrack.samples.length);
        if (audioTrack.samples.length) {
          var audioData = this.remuxAudio(audioTrack, timeOffset, contiguous, accurateTimeOffset);
          //logger.log('nb AVC samples:' + videoTrack.samples.length);
          if (videoTrack.samples.length) {
            var audioTrackLength = void 0;
            if (audioData) {
              audioTrackLength = audioData.endPTS - audioData.startPTS;
            }
            this.remuxVideo(videoTrack, timeOffset, contiguous, audioTrackLength);
          }
        } else {
          var videoData = void 0;
          //logger.log('nb AVC samples:' + videoTrack.samples.length);
          if (videoTrack.samples.length) {
            videoData = this.remuxVideo(videoTrack, timeOffset, contiguous);
          }
          if (videoData && audioTrack.codec) {
            this.remuxEmptyAudio(audioTrack, timeOffset, contiguous, videoData);
          }
        }
      }
      //logger.log('nb ID3 samples:' + audioTrack.samples.length);
      if (id3Track.samples.length) {
        this.remuxID3(id3Track, timeOffset);
      }
      //logger.log('nb ID3 samples:' + audioTrack.samples.length);
      if (textTrack.samples.length) {
        this.remuxText(textTrack, timeOffset);
      }
      //notify end of parsing
      this.observer.trigger(_events2.default.FRAG_PARSED, { id: this.id, level: this.level, sn: this.sn });
    }
  }, {
    key: 'generateIS',
    value: function generateIS(audioTrack, videoTrack, timeOffset) {
      var observer = this.observer,
          audioSamples = audioTrack.samples,
          videoSamples = videoTrack.samples,
          pesTimeScale = this.PES_TIMESCALE,
          tracks = {},
          data = { id: this.id, level: this.level, sn: this.sn, tracks: tracks, unique: false },
          computePTSDTS = this._initPTS === undefined,
          initPTS,
          initDTS;

      if (computePTSDTS) {
        initPTS = initDTS = Infinity;
      }
      if (audioTrack.config && audioSamples.length) {
        audioTrack.timescale = audioTrack.audiosamplerate;
        // MP4 duration (track duration in seconds multiplied by timescale) is coded on 32 bits
        // we know that each AAC sample contains 1024 frames....
        // in order to avoid overflowing the 32 bit counter for large duration, we use smaller timescale (timescale/gcd)
        // we just need to ensure that AAC sample duration will still be an integer (will be 1024/gcd)
        if (audioTrack.timescale * audioTrack.duration > Math.pow(2, 32)) {
          (function () {
            var greatestCommonDivisor = function greatestCommonDivisor(a, b) {
              if (!b) {
                return a;
              }
              return greatestCommonDivisor(b, a % b);
            };
            audioTrack.timescale = audioTrack.audiosamplerate / greatestCommonDivisor(audioTrack.audiosamplerate, 1024);
          })();
        }
        _logger.logger.log('audio mp4 timescale :' + audioTrack.timescale);
        tracks.audio = {
          container: 'audio/mp4',
          codec: audioTrack.codec,
          initSegment: _mp4Generator2.default.initSegment([audioTrack]),
          metadata: {
            channelCount: audioTrack.channelCount
          }
        };
        if (computePTSDTS) {
          // remember first PTS of this demuxing context. for audio, PTS = DTS
          initPTS = initDTS = audioSamples[0].pts - pesTimeScale * timeOffset;
        }
      }

      if (videoTrack.sps && videoTrack.pps && videoSamples.length) {
        videoTrack.timescale = this.MP4_TIMESCALE;
        tracks.video = {
          container: 'video/mp4',
          codec: videoTrack.codec,
          initSegment: _mp4Generator2.default.initSegment([videoTrack]),
          metadata: {
            width: videoTrack.width,
            height: videoTrack.height
          }
        };
        if (computePTSDTS) {
          initPTS = Math.min(initPTS, videoSamples[0].pts - pesTimeScale * timeOffset);
          initDTS = Math.min(initDTS, videoSamples[0].dts - pesTimeScale * timeOffset);
        }
      }

      if (Object.keys(tracks).length) {
        observer.trigger(_events2.default.FRAG_PARSING_INIT_SEGMENT, data);
        this.ISGenerated = true;
        if (computePTSDTS) {
          this._initPTS = initPTS;
          this._initDTS = initDTS;
        }
      } else {
        observer.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, id: this.id, details: _errors.ErrorDetails.FRAG_PARSING_ERROR, fatal: false, reason: 'no audio/video samples found' });
      }
    }
  }, {
    key: 'remuxVideo',
    value: function remuxVideo(track, timeOffset, contiguous, audioTrackLength) {
      var offset = 8,
          pesTimeScale = this.PES_TIMESCALE,
          pes2mp4ScaleFactor = this.PES2MP4SCALEFACTOR,
          mp4SampleDuration,
          mdat,
          moof,
          firstPTS,
          firstDTS,
          nextDTS,
          lastPTS,
          lastDTS,
          inputSamples = track.samples,
          outputSamples = [];

      // for (let i = 0; i < track.samples.length; i++) {
      //   let avcSample = track.samples[i];
      //   let units = avcSample.units.units;
      //   let unitsString = '';
      //   for (let j = 0; j < units.length ; j++) {
      //     unitsString += units[j].type + ',';
      //     if (units[j].data.length < 500) {
      //       unitsString += Hex.hexDump(units[j].data);
      //     }
      //   }
      //   logger.log(avcSample.pts + '/' + avcSample.dts + ',' + unitsString + avcSample.units.length);
      // }

      // handle broken streams with PTS < DTS, tolerance up 200ms (18000 in 90kHz timescale)
      var PTSDTSshift = inputSamples.reduce(function (prev, curr) {
        return Math.max(Math.min(prev, curr.pts - curr.dts), -18000);
      }, 0);
      if (PTSDTSshift < 0) {
        _logger.logger.warn('PTS < DTS detected in video samples, shifting DTS by ' + Math.round(PTSDTSshift / 90) + ' ms to overcome this issue');
        for (var i = 0; i < inputSamples.length; i++) {
          inputSamples[i].dts += PTSDTSshift;
        }
      }

      // PTS is coded on 33bits, and can loop from -2^32 to 2^32
      // PTSNormalize will make PTS/DTS value monotonic, we use last known DTS value as reference value
      var nextAvcDts = void 0;
      // contiguous fragments are consecutive fragments from same quality level (same level, new SN = old SN + 1)
      if (contiguous) {
        // if parsed fragment is contiguous with last one, let's use last DTS value as reference
        nextAvcDts = this.nextAvcDts;
      } else {
        // if not contiguous, let's use target timeOffset
        nextAvcDts = timeOffset * pesTimeScale;
      }

      // compute first DTS and last DTS, normalize them against reference value
      var sample = inputSamples[0];
      firstDTS = Math.max(this._PTSNormalize(sample.dts - this._initDTS, nextAvcDts), 0);
      firstPTS = Math.max(this._PTSNormalize(sample.pts - this._initDTS, nextAvcDts), 0);

      // check timestamp continuity accross consecutive fragments (this is to remove inter-fragment gap/hole)
      var delta = Math.round((firstDTS - nextAvcDts) / 90);
      // if fragment are contiguous, detect hole/overlapping between fragments
      if (contiguous) {
        if (delta) {
          if (delta > 1) {
            _logger.logger.log('AVC:' + delta + ' ms hole between fragments detected,filling it');
          } else if (delta < -1) {
            _logger.logger.log('AVC:' + -delta + ' ms overlapping between fragments detected');
          }
          // remove hole/gap : set DTS to next expected DTS
          firstDTS = nextAvcDts;
          inputSamples[0].dts = firstDTS + this._initDTS;
          // offset PTS as well, ensure that PTS is smaller or equal than new DTS
          firstPTS = Math.max(firstPTS - delta, nextAvcDts);
          inputSamples[0].pts = firstPTS + this._initDTS;
          _logger.logger.log('Video/PTS/DTS adjusted: ' + Math.round(firstPTS / 90) + '/' + Math.round(firstDTS / 90) + ',delta:' + delta + ' ms');
        }
      }
      nextDTS = firstDTS;

      // compute lastPTS/lastDTS
      sample = inputSamples[inputSamples.length - 1];
      lastDTS = Math.max(this._PTSNormalize(sample.dts - this._initDTS, nextAvcDts), 0);
      lastPTS = Math.max(this._PTSNormalize(sample.pts - this._initDTS, nextAvcDts), 0);
      lastPTS = Math.max(lastPTS, lastDTS);

      var vendor = navigator.vendor,
          userAgent = navigator.userAgent,
          isSafari = vendor && vendor.indexOf('Apple') > -1 && userAgent && !userAgent.match('CriOS');

      // on Safari let's signal the same sample duration for all samples
      // sample duration (as expected by trun MP4 boxes), should be the delta between sample DTS
      // set this constant duration as being the avg delta between consecutive DTS.
      if (isSafari) {
        mp4SampleDuration = Math.round((lastDTS - firstDTS) / (pes2mp4ScaleFactor * (inputSamples.length - 1)));
      }

      // normalize all PTS/DTS now ...
      for (var _i = 0; _i < inputSamples.length; _i++) {
        var _sample = inputSamples[_i];
        if (isSafari) {
          // sample DTS is computed using a constant decoding offset (mp4SampleDuration) between samples
          _sample.dts = firstDTS + _i * pes2mp4ScaleFactor * mp4SampleDuration;
        } else {
          // ensure sample monotonic DTS
          _sample.dts = Math.max(this._PTSNormalize(_sample.dts - this._initDTS, nextAvcDts), firstDTS);
          // ensure dts is a multiple of scale factor to avoid rounding issues
          _sample.dts = Math.round(_sample.dts / pes2mp4ScaleFactor) * pes2mp4ScaleFactor;
        }
        // we normalize PTS against nextAvcDts, we also substract initDTS (some streams don't start @ PTS O)
        // and we ensure that computed value is greater or equal than sample DTS
        _sample.pts = Math.max(this._PTSNormalize(_sample.pts - this._initDTS, nextAvcDts), _sample.dts);
        // ensure pts is a multiple of scale factor to avoid rounding issues
        _sample.pts = Math.round(_sample.pts / pes2mp4ScaleFactor) * pes2mp4ScaleFactor;
      }

      /* concatenate the video data and construct the mdat in place
        (need 8 more bytes to fill length and mpdat type) */
      mdat = new Uint8Array(track.len + 4 * track.nbNalu + 8);
      var view = new DataView(mdat.buffer);
      view.setUint32(0, mdat.byteLength);
      mdat.set(_mp4Generator2.default.types.mdat, 4);

      for (var _i2 = 0; _i2 < inputSamples.length; _i2++) {
        var avcSample = inputSamples[_i2],
            mp4SampleLength = 0,
            compositionTimeOffset = void 0;
        // convert NALU bitstream to MP4 format (prepend NALU with size field)
        while (avcSample.units.units.length) {
          var unit = avcSample.units.units.shift();
          view.setUint32(offset, unit.data.byteLength);
          offset += 4;
          mdat.set(unit.data, offset);
          offset += unit.data.byteLength;
          mp4SampleLength += 4 + unit.data.byteLength;
        }

        if (!isSafari) {
          // expected sample duration is the Decoding Timestamp diff of consecutive samples
          if (_i2 < inputSamples.length - 1) {
            mp4SampleDuration = inputSamples[_i2 + 1].dts - avcSample.dts;
          } else {
            var config = this.config,
                lastFrameDuration = avcSample.dts - inputSamples[_i2 > 0 ? _i2 - 1 : _i2].dts;
            if (config.stretchShortVideoTrack) {
              // In some cases, a segment's audio track duration may exceed the video track duration.
              // Since we've already remuxed audio, and we know how long the audio track is, we look to
              // see if the delta to the next segment is longer than the minimum of maxBufferHole and
              // maxSeekHole. If so, playback would potentially get stuck, so we artificially inflate
              // the duration of the last frame to minimize any potential gap between segments.
              var maxBufferHole = config.maxBufferHole,
                  maxSeekHole = config.maxSeekHole,
                  gapTolerance = Math.floor(Math.min(maxBufferHole, maxSeekHole) * pesTimeScale),
                  deltaToFrameEnd = (audioTrackLength ? firstPTS + audioTrackLength * pesTimeScale : this.nextAacPts) - avcSample.pts;
              if (deltaToFrameEnd > gapTolerance) {
                // We subtract lastFrameDuration from deltaToFrameEnd to try to prevent any video
                // frame overlap. maxBufferHole/maxSeekHole should be >> lastFrameDuration anyway.
                mp4SampleDuration = deltaToFrameEnd - lastFrameDuration;
                if (mp4SampleDuration < 0) {
                  mp4SampleDuration = lastFrameDuration;
                }
                _logger.logger.log('It is approximately ' + deltaToFrameEnd / 90 + ' ms to the next segment; using duration ' + mp4SampleDuration / 90 + ' ms for the last video frame.');
              } else {
                mp4SampleDuration = lastFrameDuration;
              }
            } else {
              mp4SampleDuration = lastFrameDuration;
            }
          }
          mp4SampleDuration /= pes2mp4ScaleFactor;
          compositionTimeOffset = Math.round((avcSample.pts - avcSample.dts) / pes2mp4ScaleFactor);
        } else {
          compositionTimeOffset = Math.max(0, mp4SampleDuration * Math.round((avcSample.pts - avcSample.dts) / (pes2mp4ScaleFactor * mp4SampleDuration)));
        }

        //console.log('PTS/DTS/initDTS/normPTS/normDTS/relative PTS : ${avcSample.pts}/${avcSample.dts}/${this._initDTS}/${ptsnorm}/${dtsnorm}/${(avcSample.pts/4294967296).toFixed(3)}');
        outputSamples.push({
          size: mp4SampleLength,
          // constant duration
          duration: mp4SampleDuration,
          cts: compositionTimeOffset,
          flags: {
            isLeading: 0,
            isDependedOn: 0,
            hasRedundancy: 0,
            degradPrio: 0,
            dependsOn: avcSample.key ? 2 : 1,
            isNonSync: avcSample.key ? 0 : 1
          }
        });
      }
      // next AVC sample DTS should be equal to last sample DTS + last sample duration (in PES timescale)
      this.nextAvcDts = lastDTS + mp4SampleDuration * pes2mp4ScaleFactor;
      var dropped = track.dropped;
      track.len = 0;
      track.nbNalu = 0;
      track.dropped = 0;
      if (outputSamples.length && navigator.userAgent.toLowerCase().indexOf('chrome') > -1) {
        var flags = outputSamples[0].flags;
        // chrome workaround, mark first sample as being a Random Access Point to avoid sourcebuffer append issue
        // https://code.google.com/p/chromium/issues/detail?id=229412
        flags.dependsOn = 2;
        flags.isNonSync = 0;
      }
      track.samples = outputSamples;
      moof = _mp4Generator2.default.moof(track.sequenceNumber++, firstDTS / pes2mp4ScaleFactor, track);
      track.samples = [];

      var data = {
        id: this.id,
        level: this.level,
        sn: this.sn,
        data1: moof,
        data2: mdat,
        startPTS: firstPTS / pesTimeScale,
        endPTS: (lastPTS + pes2mp4ScaleFactor * mp4SampleDuration) / pesTimeScale,
        startDTS: firstDTS / pesTimeScale,
        endDTS: this.nextAvcDts / pesTimeScale,
        type: 'video',
        nb: outputSamples.length,
        dropped: dropped
      };
      this.observer.trigger(_events2.default.FRAG_PARSING_DATA, data);
      return data;
    }
  }, {
    key: 'remuxAudio',
    value: function remuxAudio(track, timeOffset, contiguous, accurateTimeOffset) {
      var pesTimeScale = this.PES_TIMESCALE,
          mp4timeScale = track.timescale,
          pes2mp4ScaleFactor = pesTimeScale / mp4timeScale,
          expectedSampleDuration = track.timescale * 1024 / track.audiosamplerate;
      var view,
          offset = 8,
          aacSample,
          mp4Sample,
          unit,
          mdat,
          moof,
          firstPTS,
          firstDTS,
          lastDTS,
          pts,
          dts,
          ptsnorm,
          dtsnorm,
          samples = [],
          samples0 = [],
          fillFrame,
          newStamp;

      track.samples.sort(function (a, b) {
        return a.pts - b.pts;
      });
      samples0 = track.samples;

      // for audio samples, also consider consecutive fragments as being contiguous (even if a level switch occurs),
      // for sake of clarity:
      // consecutive fragments are frags with less than 100ms gaps between new time offset and next expected PTS
      // contiguous fragments are consecutive fragments from same quality level (same level, new SN = old SN + 1)
      // this helps ensuring audio continuity
      // and this also avoids audio glitches/cut when switching quality, or reporting wrong duration on first audio frame

      contiguous |= samples0.length && this.nextAacPts && Math.abs(timeOffset - this.nextAacPts / pesTimeScale) < 0.1;

      var nextAacPts = contiguous ? this.nextAacPts : timeOffset * pesTimeScale;

      // If the audio track is missing samples, the frames seem to get "left-shifted" within the
      // resulting mp4 segment, causing sync issues and leaving gaps at the end of the audio segment.
      // In an effort to prevent this from happening, we inject frames here where there are gaps.
      // When possible, we inject a silent frame; when that's not possible, we duplicate the last
      // frame.
      var pesFrameDuration = expectedSampleDuration * pes2mp4ScaleFactor;
      var nextPtsNorm = nextAacPts;

      // only inject/drop audio frames in case time offset is accurate
      if (accurateTimeOffset) {
        for (var i = 0; i < samples0.length;) {
          // First, let's see how far off this frame is from where we expect it to be
          var sample = samples0[i],
              ptsNorm = this._PTSNormalize(sample.pts - this._initDTS, nextAacPts),
              delta = ptsNorm - nextPtsNorm;

          // If we're overlapping by more than a duration, drop this sample
          if (delta <= -pesFrameDuration) {
            _logger.logger.warn('Dropping 1 audio frame @ ' + Math.round(nextPtsNorm / 90) / 1000 + 's due to ' + Math.round(Math.abs(delta / 90)) + ' ms overlap.');
            samples0.splice(i, 1);
            track.len -= sample.unit.length;
            // Don't touch nextPtsNorm or i
          }
          // Otherwise, if we're more than a frame away from where we should be, insert missing frames
          else if (delta >= pesFrameDuration) {
              var missing = Math.round(delta / pesFrameDuration);
              _logger.logger.warn('Injecting ' + missing + ' audio frame @ ' + Math.round(nextPtsNorm / 90) / 1000 + 's due to ' + Math.round(delta / 90) + ' ms gap.');
              for (var j = 0; j < missing; j++) {
                newStamp = nextPtsNorm + this._initDTS;
                newStamp = Math.max(newStamp, this._initDTS);
                fillFrame = _aac2.default.getSilentFrame(track.channelCount);
                if (!fillFrame) {
                  _logger.logger.log('Unable to get silent frame for given audio codec; duplicating last frame instead.');
                  fillFrame = sample.unit.slice(0);
                }
                samples0.splice(i, 0, { unit: fillFrame, pts: newStamp, dts: newStamp });
                track.len += fillFrame.length;
                nextPtsNorm += pesFrameDuration;
                i += 1;
              }

              // Adjust sample to next expected pts
              sample.pts = sample.dts = nextPtsNorm + this._initDTS;
              nextPtsNorm += pesFrameDuration;
              i += 1;
            }
            // Otherwise, we're within half a frame duration, so just adjust pts
            else {
                if (Math.abs(delta) > 0.1 * pesFrameDuration) {
                  //logger.log(`Invalid frame delta ${Math.round(ptsNorm - nextPtsNorm + pesFrameDuration)} at PTS ${Math.round(ptsNorm / 90)} (should be ${Math.round(pesFrameDuration)}).`);
                }
                nextPtsNorm += pesFrameDuration;
                if (i === 0) {
                  sample.pts = sample.dts = this._initDTS + nextAacPts;
                } else {
                  sample.pts = sample.dts = samples0[i - 1].pts + pesFrameDuration;
                }
                i += 1;
              }
        }
      }

      while (samples0.length) {
        aacSample = samples0.shift();
        unit = aacSample.unit;
        pts = aacSample.pts - this._initDTS;
        dts = aacSample.dts - this._initDTS;
        //logger.log(`Audio/PTS:${Math.round(pts/90)}`);
        // if not first sample
        if (lastDTS !== undefined) {
          ptsnorm = this._PTSNormalize(pts, lastDTS);
          dtsnorm = this._PTSNormalize(dts, lastDTS);
          mp4Sample.duration = Math.round((dtsnorm - lastDTS) / pes2mp4ScaleFactor);
        } else {
          ptsnorm = this._PTSNormalize(pts, nextAacPts);
          dtsnorm = this._PTSNormalize(dts, nextAacPts);
          var _delta = Math.round(1000 * (ptsnorm - nextAacPts) / pesTimeScale),
              numMissingFrames = 0;
          // if fragment are contiguous, detect hole/overlapping between fragments
          // contiguous fragments are consecutive fragments from same quality level (same level, new SN = old SN + 1)
          if (contiguous) {
            // log delta
            if (_delta) {
              if (_delta > 0) {
                numMissingFrames = Math.round((ptsnorm - nextAacPts) / pesFrameDuration);
                _logger.logger.log(_delta + ' ms hole between AAC samples detected,filling it');
                if (numMissingFrames > 0) {
                  fillFrame = _aac2.default.getSilentFrame(track.channelCount);
                  if (!fillFrame) {
                    fillFrame = unit.slice(0);
                  }
                  track.len += numMissingFrames * fillFrame.length;
                }
                // if we have frame overlap, overlapping for more than half a frame duraion
              } else if (_delta < -12) {
                // drop overlapping audio frames... browser will deal with it
                _logger.logger.log(-_delta + ' ms overlapping between AAC samples detected, drop frame');
                track.len -= unit.byteLength;
                continue;
              }
              // set PTS/DTS to expected PTS/DTS
              ptsnorm = dtsnorm = nextAacPts;
            }
          }
          // remember first PTS of our aacSamples, ensure value is positive
          firstPTS = Math.max(0, ptsnorm);
          firstDTS = Math.max(0, dtsnorm);
          if (track.len > 0) {
            /* concatenate the audio data and construct the mdat in place
              (need 8 more bytes to fill length and mdat type) */
            mdat = new Uint8Array(track.len + 8);
            view = new DataView(mdat.buffer);
            view.setUint32(0, mdat.byteLength);
            mdat.set(_mp4Generator2.default.types.mdat, 4);
          } else {
            // no audio samples
            return;
          }
          for (var _i3 = 0; _i3 < numMissingFrames; _i3++) {
            newStamp = ptsnorm - (numMissingFrames - _i3) * pesFrameDuration;
            fillFrame = _aac2.default.getSilentFrame(track.channelCount);
            if (!fillFrame) {
              _logger.logger.log('Unable to get silent frame for given audio codec; duplicating this frame instead.');
              fillFrame = unit.slice(0);
            }
            mdat.set(fillFrame, offset);
            offset += fillFrame.byteLength;
            mp4Sample = {
              size: fillFrame.byteLength,
              cts: 0,
              duration: 1024,
              flags: {
                isLeading: 0,
                isDependedOn: 0,
                hasRedundancy: 0,
                degradPrio: 0,
                dependsOn: 1
              }
            };
            samples.push(mp4Sample);
          }
        }
        mdat.set(unit, offset);
        offset += unit.byteLength;
        //console.log('PTS/DTS/initDTS/normPTS/normDTS/relative PTS : ${aacSample.pts}/${aacSample.dts}/${this._initDTS}/${ptsnorm}/${dtsnorm}/${(aacSample.pts/4294967296).toFixed(3)}');
        mp4Sample = {
          size: unit.byteLength,
          cts: 0,
          duration: 0,
          flags: {
            isLeading: 0,
            isDependedOn: 0,
            hasRedundancy: 0,
            degradPrio: 0,
            dependsOn: 1
          }
        };
        samples.push(mp4Sample);
        lastDTS = dtsnorm;
      }
      var lastSampleDuration = 0;
      var nbSamples = samples.length;
      //set last sample duration as being identical to previous sample
      if (nbSamples >= 2) {
        lastSampleDuration = samples[nbSamples - 2].duration;
        mp4Sample.duration = lastSampleDuration;
      }
      if (nbSamples) {
        // next aac sample PTS should be equal to last sample PTS + duration
        this.nextAacPts = ptsnorm + pes2mp4ScaleFactor * lastSampleDuration;
        //logger.log('Audio/PTS/PTSend:' + aacSample.pts.toFixed(0) + '/' + this.nextAacDts.toFixed(0));
        track.len = 0;
        track.samples = samples;
        moof = _mp4Generator2.default.moof(track.sequenceNumber++, firstDTS / pes2mp4ScaleFactor, track);
        track.samples = [];
        var audioData = {
          id: this.id,
          level: this.level,
          sn: this.sn,
          data1: moof,
          data2: mdat,
          startPTS: firstPTS / pesTimeScale,
          endPTS: this.nextAacPts / pesTimeScale,
          startDTS: firstDTS / pesTimeScale,
          endDTS: (dtsnorm + pes2mp4ScaleFactor * lastSampleDuration) / pesTimeScale,
          type: 'audio',
          nb: nbSamples
        };
        this.observer.trigger(_events2.default.FRAG_PARSING_DATA, audioData);
        return audioData;
      }
      return null;
    }
  }, {
    key: 'remuxEmptyAudio',
    value: function remuxEmptyAudio(track, timeOffset, contiguous, videoData) {
      var pesTimeScale = this.PES_TIMESCALE,
          mp4timeScale = track.timescale ? track.timescale : track.audiosamplerate,
          pes2mp4ScaleFactor = pesTimeScale / mp4timeScale,


      // sync with video's timestamp
      startDTS = videoData.startDTS * pesTimeScale + this._initDTS,
          endDTS = videoData.endDTS * pesTimeScale + this._initDTS,


      // one sample's duration value
      sampleDuration = 1024,
          frameDuration = pes2mp4ScaleFactor * sampleDuration,


      // samples count of this segment's duration
      nbSamples = Math.ceil((endDTS - startDTS) / frameDuration),


      // silent frame
      silentFrame = _aac2.default.getSilentFrame(track.channelCount);

      // Can't remux if we can't generate a silent frame...
      if (!silentFrame) {
        _logger.logger.trace('Unable to remuxEmptyAudio since we were unable to get a silent frame for given audio codec!');
        return;
      }

      var samples = [];
      for (var i = 0; i < nbSamples; i++) {
        var stamp = startDTS + i * frameDuration;
        samples.push({ unit: silentFrame.slice(0), pts: stamp, dts: stamp });
        track.len += silentFrame.length;
      }
      track.samples = samples;

      this.remuxAudio(track, timeOffset, contiguous);
    }
  }, {
    key: 'remuxID3',
    value: function remuxID3(track, timeOffset) {
      var length = track.samples.length,
          sample;
      // consume samples
      if (length) {
        for (var index = 0; index < length; index++) {
          sample = track.samples[index];
          // setting id3 pts, dts to relative time
          // using this._initPTS and this._initDTS to calculate relative time
          sample.pts = (sample.pts - this._initPTS) / this.PES_TIMESCALE;
          sample.dts = (sample.dts - this._initDTS) / this.PES_TIMESCALE;
        }
        this.observer.trigger(_events2.default.FRAG_PARSING_METADATA, {
          id: this.id,
          level: this.level,
          sn: this.sn,
          samples: track.samples
        });
      }

      track.samples = [];
      timeOffset = timeOffset;
    }
  }, {
    key: 'remuxText',
    value: function remuxText(track, timeOffset) {
      track.samples.sort(function (a, b) {
        return a.pts - b.pts;
      });

      var length = track.samples.length,
          sample;
      // consume samples
      if (length) {
        for (var index = 0; index < length; index++) {
          sample = track.samples[index];
          // setting text pts, dts to relative time
          // using this._initPTS and this._initDTS to calculate relative time
          sample.pts = (sample.pts - this._initPTS) / this.PES_TIMESCALE;
        }
        this.observer.trigger(_events2.default.FRAG_PARSING_USERDATA, {
          id: this.id,
          level: this.level,
          sn: this.sn,
          samples: track.samples
        });
      }

      track.samples = [];
      timeOffset = timeOffset;
    }
  }, {
    key: '_PTSNormalize',
    value: function _PTSNormalize(value, reference) {
      var offset;
      if (reference === undefined) {
        return value;
      }
      if (reference < value) {
        // - 2^33
        offset = -8589934592;
      } else {
        // + 2^33
        offset = 8589934592;
      }
      /* PTS is 33bit (from 0 to 2^33 -1)
        if diff between value and reference is bigger than half of the amplitude (2^32) then it means that
        PTS looping occured. fill the gap */
      while (Math.abs(value - reference) > 4294967296) {
        value += offset;
      }
      return value;
    }
  }, {
    key: 'passthrough',
    get: function get() {
      return false;
    }
  }]);

  return MP4Remuxer;
}();

exports.default = MP4Remuxer;

},{"../errors":25,"../events":27,"../helper/aac":28,"../remux/mp4-generator":36,"../utils/logger":44,"../utils/polyfill":45}],38:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * passthrough remuxer
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */


var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var PassThroughRemuxer = function () {
  function PassThroughRemuxer(observer, id) {
    _classCallCheck(this, PassThroughRemuxer);

    this.observer = observer;
    this.id = id;
    this.ISGenerated = false;
  }

  _createClass(PassThroughRemuxer, [{
    key: 'destroy',
    value: function destroy() {}
  }, {
    key: 'insertDiscontinuity',
    value: function insertDiscontinuity() {}
  }, {
    key: 'switchLevel',
    value: function switchLevel() {
      this.ISGenerated = false;
    }
  }, {
    key: 'remux',
    value: function remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, rawData) {
      var observer = this.observer;
      // generate Init Segment if needed
      if (!this.ISGenerated) {
        var tracks = {},
            data = { id: this.id, tracks: tracks, unique: true },
            track = videoTrack,
            codec = track.codec;

        if (codec) {
          data.tracks.video = {
            container: track.container,
            codec: codec,
            metadata: {
              width: track.width,
              height: track.height
            }
          };
        }

        track = audioTrack;
        codec = track.codec;
        if (codec) {
          data.tracks.audio = {
            container: track.container,
            codec: codec,
            metadata: {
              channelCount: track.channelCount
            }
          };
        }
        this.ISGenerated = true;
        observer.trigger(_events2.default.FRAG_PARSING_INIT_SEGMENT, data);
      }
      observer.trigger(_events2.default.FRAG_PARSING_DATA, {
        id: this.id,
        data1: rawData,
        startPTS: timeOffset,
        startDTS: timeOffset,
        type: 'audiovideo',
        nb: 1,
        dropped: 0
      });
    }
  }, {
    key: 'passthrough',
    get: function get() {
      return true;
    }
  }]);

  return PassThroughRemuxer;
}();

exports.default = PassThroughRemuxer;

},{"../events":27}],39:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// adapted from https://github.com/kanongil/node-m3u8parse/blob/master/attrlist.js
var AttrList = function () {
  function AttrList(attrs) {
    _classCallCheck(this, AttrList);

    if (typeof attrs === 'string') {
      attrs = AttrList.parseAttrList(attrs);
    }
    for (var attr in attrs) {
      if (attrs.hasOwnProperty(attr)) {
        this[attr] = attrs[attr];
      }
    }
  }

  _createClass(AttrList, [{
    key: 'decimalInteger',
    value: function decimalInteger(attrName) {
      var intValue = parseInt(this[attrName], 10);
      if (intValue > Number.MAX_SAFE_INTEGER) {
        return Infinity;
      }
      return intValue;
    }
  }, {
    key: 'hexadecimalInteger',
    value: function hexadecimalInteger(attrName) {
      if (this[attrName]) {
        var stringValue = (this[attrName] || '0x').slice(2);
        stringValue = (stringValue.length & 1 ? '0' : '') + stringValue;

        var value = new Uint8Array(stringValue.length / 2);
        for (var i = 0; i < stringValue.length / 2; i++) {
          value[i] = parseInt(stringValue.slice(i * 2, i * 2 + 2), 16);
        }
        return value;
      } else {
        return null;
      }
    }
  }, {
    key: 'hexadecimalIntegerAsNumber',
    value: function hexadecimalIntegerAsNumber(attrName) {
      var intValue = parseInt(this[attrName], 16);
      if (intValue > Number.MAX_SAFE_INTEGER) {
        return Infinity;
      }
      return intValue;
    }
  }, {
    key: 'decimalFloatingPoint',
    value: function decimalFloatingPoint(attrName) {
      return parseFloat(this[attrName]);
    }
  }, {
    key: 'enumeratedString',
    value: function enumeratedString(attrName) {
      return this[attrName];
    }
  }, {
    key: 'decimalResolution',
    value: function decimalResolution(attrName) {
      var res = /^(\d+)x(\d+)$/.exec(this[attrName]);
      if (res === null) {
        return undefined;
      }
      return {
        width: parseInt(res[1], 10),
        height: parseInt(res[2], 10)
      };
    }
  }], [{
    key: 'parseAttrList',
    value: function parseAttrList(input) {
      var re = /\s*(.+?)\s*=((?:\".*?\")|.*?)(?:,|$)/g;
      var match,
          attrs = {};
      while ((match = re.exec(input)) !== null) {
        var value = match[2],
            quote = '"';

        if (value.indexOf(quote) === 0 && value.lastIndexOf(quote) === value.length - 1) {
          value = value.slice(1, -1);
        }
        attrs[match[1]] = value;
      }
      return attrs;
    }
  }]);

  return AttrList;
}();

exports.default = AttrList;

},{}],40:[function(require,module,exports){
"use strict";

var BinarySearch = {
    /**
     * Searches for an item in an array which matches a certain condition.
     * This requires the condition to only match one item in the array,
     * and for the array to be ordered.
     *
     * @param {Array} list The array to search.
     * @param {Function} comparisonFunction
     *      Called and provided a candidate item as the first argument.
     *      Should return:
     *          > -1 if the item should be located at a lower index than the provided item.
     *          > 1 if the item should be located at a higher index than the provided item.
     *          > 0 if the item is the item you're looking for.
     *
     * @return {*} The object if it is found or null otherwise.
     */
    search: function search(list, comparisonFunction) {
        var minIndex = 0;
        var maxIndex = list.length - 1;
        var currentIndex = null;
        var currentElement = null;

        while (minIndex <= maxIndex) {
            currentIndex = (minIndex + maxIndex) / 2 | 0;
            currentElement = list[currentIndex];

            var comparisonResult = comparisonFunction(currentElement);
            if (comparisonResult > 0) {
                minIndex = currentIndex + 1;
            } else if (comparisonResult < 0) {
                maxIndex = currentIndex - 1;
            } else {
                return currentElement;
            }
        }

        return null;
    }
};

module.exports = BinarySearch;

},{}],41:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 *
 * This code was ported from the dash.js project at:
 *   https://github.com/Dash-Industry-Forum/dash.js/blob/development/externals/cea608-parser.js
 *   https://github.com/Dash-Industry-Forum/dash.js/commit/8269b26a761e0853bb21d78780ed945144ecdd4d#diff-71bc295a2d6b6b7093a1d3290d53a4b2
 *
 * The original copyright appears below:
 *
 * The copyright in this software is being made available under the BSD License,
 * included below. This software may be subject to other third party and contributor
 * rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2015-2016, DASH Industry Forum.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *  1. Redistributions of source code must retain the above copyright notice, this
 *  list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *  this list of conditions and the following disclaimer in the documentation and/or
 *  other materials provided with the distribution.
 *  2. Neither the name of Dash Industry Forum nor the names of its
 *  contributors may be used to endorse or promote products derived from this software
 *  without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY
 *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 *  POSSIBILITY OF SUCH DAMAGE.
 */
/**
 *  Exceptions from regular ASCII. CodePoints are mapped to UTF-16 codes
 */

var specialCea608CharsCodes = {
    0x2a: 0xe1, // lowercase a, acute accent
    0x5c: 0xe9, // lowercase e, acute accent
    0x5e: 0xed, // lowercase i, acute accent
    0x5f: 0xf3, // lowercase o, acute accent
    0x60: 0xfa, // lowercase u, acute accent
    0x7b: 0xe7, // lowercase c with cedilla
    0x7c: 0xf7, // division symbol
    0x7d: 0xd1, // uppercase N tilde
    0x7e: 0xf1, // lowercase n tilde
    0x7f: 0x2588, // Full block
    // THIS BLOCK INCLUDES THE 16 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS
    // THAT COME FROM HI BYTE=0x11 AND LOW BETWEEN 0x30 AND 0x3F
    // THIS MEANS THAT \x50 MUST BE ADDED TO THE VALUES
    0x80: 0xae, // Registered symbol (R)
    0x81: 0xb0, // degree sign
    0x82: 0xbd, // 1/2 symbol
    0x83: 0xbf, // Inverted (open) question mark
    0x84: 0x2122, // Trademark symbol (TM)
    0x85: 0xa2, // Cents symbol
    0x86: 0xa3, // Pounds sterling
    0x87: 0x266a, // Music 8'th note
    0x88: 0xe0, // lowercase a, grave accent
    0x89: 0x20, // transparent space (regular)
    0x8a: 0xe8, // lowercase e, grave accent
    0x8b: 0xe2, // lowercase a, circumflex accent
    0x8c: 0xea, // lowercase e, circumflex accent
    0x8d: 0xee, // lowercase i, circumflex accent
    0x8e: 0xf4, // lowercase o, circumflex accent
    0x8f: 0xfb, // lowercase u, circumflex accent
    // THIS BLOCK INCLUDES THE 32 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS
    // THAT COME FROM HI BYTE=0x12 AND LOW BETWEEN 0x20 AND 0x3F
    0x90: 0xc1, // capital letter A with acute
    0x91: 0xc9, // capital letter E with acute
    0x92: 0xd3, // capital letter O with acute
    0x93: 0xda, // capital letter U with acute
    0x94: 0xdc, // capital letter U with diaresis
    0x95: 0xfc, // lowercase letter U with diaeresis
    0x96: 0x2018, // opening single quote
    0x97: 0xa1, // inverted exclamation mark
    0x98: 0x2a, // asterisk
    0x99: 0x2019, // closing single quote
    0x9a: 0x2501, // box drawings heavy horizontal
    0x9b: 0xa9, // copyright sign
    0x9c: 0x2120, // Service mark
    0x9d: 0x2022, // (round) bullet
    0x9e: 0x201c, // Left double quotation mark
    0x9f: 0x201d, // Right double quotation mark
    0xa0: 0xc0, // uppercase A, grave accent
    0xa1: 0xc2, // uppercase A, circumflex
    0xa2: 0xc7, // uppercase C with cedilla
    0xa3: 0xc8, // uppercase E, grave accent
    0xa4: 0xca, // uppercase E, circumflex
    0xa5: 0xcb, // capital letter E with diaresis
    0xa6: 0xeb, // lowercase letter e with diaresis
    0xa7: 0xce, // uppercase I, circumflex
    0xa8: 0xcf, // uppercase I, with diaresis
    0xa9: 0xef, // lowercase i, with diaresis
    0xaa: 0xd4, // uppercase O, circumflex
    0xab: 0xd9, // uppercase U, grave accent
    0xac: 0xf9, // lowercase u, grave accent
    0xad: 0xdb, // uppercase U, circumflex
    0xae: 0xab, // left-pointing double angle quotation mark
    0xaf: 0xbb, // right-pointing double angle quotation mark
    // THIS BLOCK INCLUDES THE 32 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS
    // THAT COME FROM HI BYTE=0x13 AND LOW BETWEEN 0x20 AND 0x3F
    0xb0: 0xc3, // Uppercase A, tilde
    0xb1: 0xe3, // Lowercase a, tilde
    0xb2: 0xcd, // Uppercase I, acute accent
    0xb3: 0xcc, // Uppercase I, grave accent
    0xb4: 0xec, // Lowercase i, grave accent
    0xb5: 0xd2, // Uppercase O, grave accent
    0xb6: 0xf2, // Lowercase o, grave accent
    0xb7: 0xd5, // Uppercase O, tilde
    0xb8: 0xf5, // Lowercase o, tilde
    0xb9: 0x7b, // Open curly brace
    0xba: 0x7d, // Closing curly brace
    0xbb: 0x5c, // Backslash
    0xbc: 0x5e, // Caret
    0xbd: 0x5f, // Underscore
    0xbe: 0x7c, // Pipe (vertical line)
    0xbf: 0x223c, // Tilde operator
    0xc0: 0xc4, // Uppercase A, umlaut
    0xc1: 0xe4, // Lowercase A, umlaut
    0xc2: 0xd6, // Uppercase O, umlaut
    0xc3: 0xf6, // Lowercase o, umlaut
    0xc4: 0xdf, // Esszett (sharp S)
    0xc5: 0xa5, // Yen symbol
    0xc6: 0xa4, // Generic currency sign
    0xc7: 0x2503, // Box drawings heavy vertical
    0xc8: 0xc5, // Uppercase A, ring
    0xc9: 0xe5, // Lowercase A, ring
    0xca: 0xd8, // Uppercase O, stroke
    0xcb: 0xf8, // Lowercase o, strok
    0xcc: 0x250f, // Box drawings heavy down and right
    0xcd: 0x2513, // Box drawings heavy down and left
    0xce: 0x2517, // Box drawings heavy up and right
    0xcf: 0x251b // Box drawings heavy up and left
};

/**
 * Utils
 */
var getCharForByte = function getCharForByte(byte) {
    var charCode = byte;
    if (specialCea608CharsCodes.hasOwnProperty(byte)) {
        charCode = specialCea608CharsCodes[byte];
    }
    return String.fromCharCode(charCode);
};

var NR_ROWS = 15,
    NR_COLS = 32;
// Tables to look up row from PAC data
var rowsLowCh1 = { 0x11: 1, 0x12: 3, 0x15: 5, 0x16: 7, 0x17: 9, 0x10: 11, 0x13: 12, 0x14: 14 };
var rowsHighCh1 = { 0x11: 2, 0x12: 4, 0x15: 6, 0x16: 8, 0x17: 10, 0x13: 13, 0x14: 15 };
var rowsLowCh2 = { 0x19: 1, 0x1A: 3, 0x1D: 5, 0x1E: 7, 0x1F: 9, 0x18: 11, 0x1B: 12, 0x1C: 14 };
var rowsHighCh2 = { 0x19: 2, 0x1A: 4, 0x1D: 6, 0x1E: 8, 0x1F: 10, 0x1B: 13, 0x1C: 15 };

var backgroundColors = ['white', 'green', 'blue', 'cyan', 'red', 'yellow', 'magenta', 'black', 'transparent'];

/**
 * Simple logger class to be able to write with time-stamps and filter on level.
 */
var logger = {
    verboseFilter: { 'DATA': 3, 'DEBUG': 3, 'INFO': 2, 'WARNING': 2, 'TEXT': 1, 'ERROR': 0 },
    time: null,
    verboseLevel: 0, // Only write errors
    setTime: function setTime(newTime) {
        this.time = newTime;
    },
    log: function log(severity, msg) {
        var minLevel = this.verboseFilter[severity];
        if (this.verboseLevel >= minLevel) {
            console.log(this.time + ' [' + severity + '] ' + msg);
        }
    }
};

var numArrayToHexArray = function numArrayToHexArray(numArray) {
    var hexArray = [];
    for (var j = 0; j < numArray.length; j++) {
        hexArray.push(numArray[j].toString(16));
    }
    return hexArray;
};

var PenState = function () {
    function PenState(foreground, underline, italics, background, flash) {
        _classCallCheck(this, PenState);

        this.foreground = foreground || 'white';
        this.underline = underline || false;
        this.italics = italics || false;
        this.background = background || 'black';
        this.flash = flash || false;
    }

    _createClass(PenState, [{
        key: 'reset',
        value: function reset() {
            this.foreground = 'white';
            this.underline = false;
            this.italics = false;
            this.background = 'black';
            this.flash = false;
        }
    }, {
        key: 'setStyles',
        value: function setStyles(styles) {
            var attribs = ['foreground', 'underline', 'italics', 'background', 'flash'];
            for (var i = 0; i < attribs.length; i++) {
                var style = attribs[i];
                if (styles.hasOwnProperty(style)) {
                    this[style] = styles[style];
                }
            }
        }
    }, {
        key: 'isDefault',
        value: function isDefault() {
            return this.foreground === 'white' && !this.underline && !this.italics && this.background === 'black' && !this.flash;
        }
    }, {
        key: 'equals',
        value: function equals(other) {
            return this.foreground === other.foreground && this.underline === other.underline && this.italics === other.italics && this.background === other.background && this.flash === other.flash;
        }
    }, {
        key: 'copy',
        value: function copy(newPenState) {
            this.foreground = newPenState.foreground;
            this.underline = newPenState.underline;
            this.italics = newPenState.italics;
            this.background = newPenState.background;
            this.flash = newPenState.flash;
        }
    }, {
        key: 'toString',
        value: function toString() {
            return 'color=' + this.foreground + ', underline=' + this.underline + ', italics=' + this.italics + ', background=' + this.background + ', flash=' + this.flash;
        }
    }]);

    return PenState;
}();

/**
 * Unicode character with styling and background.
 * @constructor
 */


var StyledUnicodeChar = function () {
    function StyledUnicodeChar(uchar, foreground, underline, italics, background, flash) {
        _classCallCheck(this, StyledUnicodeChar);

        this.uchar = uchar || ' '; // unicode character
        this.penState = new PenState(foreground, underline, italics, background, flash);
    }

    _createClass(StyledUnicodeChar, [{
        key: 'reset',
        value: function reset() {
            this.uchar = ' ';
            this.penState.reset();
        }
    }, {
        key: 'setChar',
        value: function setChar(uchar, newPenState) {
            this.uchar = uchar;
            this.penState.copy(newPenState);
        }
    }, {
        key: 'setPenState',
        value: function setPenState(newPenState) {
            this.penState.copy(newPenState);
        }
    }, {
        key: 'equals',
        value: function equals(other) {
            return this.uchar === other.uchar && this.penState.equals(other.penState);
        }
    }, {
        key: 'copy',
        value: function copy(newChar) {
            this.uchar = newChar.uchar;
            this.penState.copy(newChar.penState);
        }
    }, {
        key: 'isEmpty',
        value: function isEmpty() {
            return this.uchar === ' ' && this.penState.isDefault();
        }
    }]);

    return StyledUnicodeChar;
}();

/**
 * CEA-608 row consisting of NR_COLS instances of StyledUnicodeChar.
 * @constructor
 */


var Row = function () {
    function Row() {
        _classCallCheck(this, Row);

        this.chars = [];
        for (var i = 0; i < NR_COLS; i++) {
            this.chars.push(new StyledUnicodeChar());
        }
        this.pos = 0;
        this.currPenState = new PenState();
    }

    _createClass(Row, [{
        key: 'equals',
        value: function equals(other) {
            var equal = true;
            for (var i = 0; i < NR_COLS; i++) {
                if (!this.chars[i].equals(other.chars[i])) {
                    equal = false;
                    break;
                }
            }
            return equal;
        }
    }, {
        key: 'copy',
        value: function copy(other) {
            for (var i = 0; i < NR_COLS; i++) {
                this.chars[i].copy(other.chars[i]);
            }
        }
    }, {
        key: 'isEmpty',
        value: function isEmpty() {
            var empty = true;
            for (var i = 0; i < NR_COLS; i++) {
                if (!this.chars[i].isEmpty()) {
                    empty = false;
                    break;
                }
            }
            return empty;
        }

        /**
         *  Set the cursor to a valid column.
         */

    }, {
        key: 'setCursor',
        value: function setCursor(absPos) {
            if (this.pos !== absPos) {
                this.pos = absPos;
            }
            if (this.pos < 0) {
                logger.log('ERROR', 'Negative cursor position ' + this.pos);
                this.pos = 0;
            } else if (this.pos > NR_COLS) {
                logger.log('ERROR', 'Too large cursor position ' + this.pos);
                this.pos = NR_COLS;
            }
        }

        /**
         * Move the cursor relative to current position.
         */

    }, {
        key: 'moveCursor',
        value: function moveCursor(relPos) {
            var newPos = this.pos + relPos;
            if (relPos > 1) {
                for (var i = this.pos + 1; i < newPos + 1; i++) {
                    this.chars[i].setPenState(this.currPenState);
                }
            }
            this.setCursor(newPos);
        }

        /**
         * Backspace, move one step back and clear character.
         */

    }, {
        key: 'backSpace',
        value: function backSpace() {
            this.moveCursor(-1);
            this.chars[this.pos].setChar(' ', this.currPenState);
        }
    }, {
        key: 'insertChar',
        value: function insertChar(byte) {
            if (byte >= 0x90) {
                //Extended char
                this.backSpace();
            }
            var char = getCharForByte(byte);
            if (this.pos >= NR_COLS) {
                logger.log('ERROR', 'Cannot insert ' + byte.toString(16) + ' (' + char + ') at position ' + this.pos + '. Skipping it!');
                return;
            }
            this.chars[this.pos].setChar(char, this.currPenState);
            this.moveCursor(1);
        }
    }, {
        key: 'clearFromPos',
        value: function clearFromPos(startPos) {
            var i;
            for (i = startPos; i < NR_COLS; i++) {
                this.chars[i].reset();
            }
        }
    }, {
        key: 'clear',
        value: function clear() {
            this.clearFromPos(0);
            this.pos = 0;
            this.currPenState.reset();
        }
    }, {
        key: 'clearToEndOfRow',
        value: function clearToEndOfRow() {
            this.clearFromPos(this.pos);
        }
    }, {
        key: 'getTextString',
        value: function getTextString() {
            var chars = [];
            var empty = true;
            for (var i = 0; i < NR_COLS; i++) {
                var char = this.chars[i].uchar;
                if (char !== ' ') {
                    empty = false;
                }
                chars.push(char);
            }
            if (empty) {
                return '';
            } else {
                return chars.join('');
            }
        }
    }, {
        key: 'setPenStyles',
        value: function setPenStyles(styles) {
            this.currPenState.setStyles(styles);
            var currChar = this.chars[this.pos];
            currChar.setPenState(this.currPenState);
        }
    }]);

    return Row;
}();

/**
 * Keep a CEA-608 screen of 32x15 styled characters
 * @constructor
*/


var CaptionScreen = function () {
    function CaptionScreen() {
        _classCallCheck(this, CaptionScreen);

        this.rows = [];
        for (var i = 0; i < NR_ROWS; i++) {
            this.rows.push(new Row()); // Note that we use zero-based numbering (0-14)
        }
        this.currRow = NR_ROWS - 1;
        this.nrRollUpRows = null;
        this.reset();
    }

    _createClass(CaptionScreen, [{
        key: 'reset',
        value: function reset() {
            for (var i = 0; i < NR_ROWS; i++) {
                this.rows[i].clear();
            }
            this.currRow = NR_ROWS - 1;
        }
    }, {
        key: 'equals',
        value: function equals(other) {
            var equal = true;
            for (var i = 0; i < NR_ROWS; i++) {
                if (!this.rows[i].equals(other.rows[i])) {
                    equal = false;
                    break;
                }
            }
            return equal;
        }
    }, {
        key: 'copy',
        value: function copy(other) {
            for (var i = 0; i < NR_ROWS; i++) {
                this.rows[i].copy(other.rows[i]);
            }
        }
    }, {
        key: 'isEmpty',
        value: function isEmpty() {
            var empty = true;
            for (var i = 0; i < NR_ROWS; i++) {
                if (!this.rows[i].isEmpty()) {
                    empty = false;
                    break;
                }
            }
            return empty;
        }
    }, {
        key: 'backSpace',
        value: function backSpace() {
            var row = this.rows[this.currRow];
            row.backSpace();
        }
    }, {
        key: 'clearToEndOfRow',
        value: function clearToEndOfRow() {
            var row = this.rows[this.currRow];
            row.clearToEndOfRow();
        }

        /**
         * Insert a character (without styling) in the current row.
         */

    }, {
        key: 'insertChar',
        value: function insertChar(char) {
            var row = this.rows[this.currRow];
            row.insertChar(char);
        }
    }, {
        key: 'setPen',
        value: function setPen(styles) {
            var row = this.rows[this.currRow];
            row.setPenStyles(styles);
        }
    }, {
        key: 'moveCursor',
        value: function moveCursor(relPos) {
            var row = this.rows[this.currRow];
            row.moveCursor(relPos);
        }
    }, {
        key: 'setCursor',
        value: function setCursor(absPos) {
            logger.log('INFO', 'setCursor: ' + absPos);
            var row = this.rows[this.currRow];
            row.setCursor(absPos);
        }
    }, {
        key: 'setPAC',
        value: function setPAC(pacData) {
            logger.log('INFO', 'pacData = ' + JSON.stringify(pacData));
            var newRow = pacData.row - 1;
            if (this.nrRollUpRows && newRow < this.nrRollUpRows - 1) {
                newRow = this.nrRollUpRows - 1;
            }
            this.currRow = newRow;
            var row = this.rows[this.currRow];
            if (pacData.indent !== null) {
                var indent = pacData.indent;
                var prevPos = Math.max(indent - 1, 0);
                row.setCursor(pacData.indent);
                pacData.color = row.chars[prevPos].penState.foreground;
            }
            var styles = { foreground: pacData.color, underline: pacData.underline, italics: pacData.italics, background: 'black', flash: false };
            this.setPen(styles);
        }

        /**
         * Set background/extra foreground, but first do back_space, and then insert space (backwards compatibility).
         */

    }, {
        key: 'setBkgData',
        value: function setBkgData(bkgData) {

            logger.log('INFO', 'bkgData = ' + JSON.stringify(bkgData));
            this.backSpace();
            this.setPen(bkgData);
            this.insertChar(0x20); //Space
        }
    }, {
        key: 'setRollUpRows',
        value: function setRollUpRows(nrRows) {
            this.nrRollUpRows = nrRows;
        }
    }, {
        key: 'rollUp',
        value: function rollUp() {
            if (this.nrRollUpRows === null) {
                logger.log('DEBUG', 'roll_up but nrRollUpRows not set yet');
                return; //Not properly setup
            }
            logger.log('TEXT', this.getDisplayText());
            var topRowIndex = this.currRow + 1 - this.nrRollUpRows;
            var topRow = this.rows.splice(topRowIndex, 1)[0];
            topRow.clear();
            this.rows.splice(this.currRow, 0, topRow);
            logger.log('INFO', 'Rolling up');
            //logger.log('TEXT', this.get_display_text())
        }

        /**
         * Get all non-empty rows with as unicode text.
         */

    }, {
        key: 'getDisplayText',
        value: function getDisplayText(asOneRow) {
            asOneRow = asOneRow || false;
            var displayText = [];
            var text = '';
            var rowNr = -1;
            for (var i = 0; i < NR_ROWS; i++) {
                var rowText = this.rows[i].getTextString();
                if (rowText) {
                    rowNr = i + 1;
                    if (asOneRow) {
                        displayText.push('Row ' + rowNr + ': \'' + rowText + '\'');
                    } else {
                        displayText.push(rowText.trim());
                    }
                }
            }
            if (displayText.length > 0) {
                if (asOneRow) {
                    text = '[' + displayText.join(' | ') + ']';
                } else {
                    text = displayText.join('\n');
                }
            }
            return text;
        }
    }, {
        key: 'getTextAndFormat',
        value: function getTextAndFormat() {
            return this.rows;
        }
    }]);

    return CaptionScreen;
}();

//var modes = ['MODE_ROLL-UP', 'MODE_POP-ON', 'MODE_PAINT-ON', 'MODE_TEXT'];

var Cea608Channel = function () {
    function Cea608Channel(channelNumber, outputFilter) {
        _classCallCheck(this, Cea608Channel);

        this.chNr = channelNumber;
        this.outputFilter = outputFilter;
        this.mode = null;
        this.verbose = 0;
        this.displayedMemory = new CaptionScreen();
        this.nonDisplayedMemory = new CaptionScreen();
        this.lastOutputScreen = new CaptionScreen();
        this.currRollUpRow = this.displayedMemory.rows[NR_ROWS - 1];
        this.writeScreen = this.displayedMemory;
        this.mode = null;
        this.cueStartTime = null; // Keeps track of where a cue started.
    }

    _createClass(Cea608Channel, [{
        key: 'reset',
        value: function reset() {
            this.mode = null;
            this.displayedMemory.reset();
            this.nonDisplayedMemory.reset();
            this.lastOutputScreen.reset();
            this.currRollUpRow = this.displayedMemory.rows[NR_ROWS - 1];
            this.writeScreen = this.displayedMemory;
            this.mode = null;
            this.cueStartTime = null;
            this.lastCueEndTime = null;
        }
    }, {
        key: 'getHandler',
        value: function getHandler() {
            return this.outputFilter;
        }
    }, {
        key: 'setHandler',
        value: function setHandler(newHandler) {
            this.outputFilter = newHandler;
        }
    }, {
        key: 'setPAC',
        value: function setPAC(pacData) {
            this.writeScreen.setPAC(pacData);
        }
    }, {
        key: 'setBkgData',
        value: function setBkgData(bkgData) {
            this.writeScreen.setBkgData(bkgData);
        }
    }, {
        key: 'setMode',
        value: function setMode(newMode) {
            if (newMode === this.mode) {
                return;
            }
            this.mode = newMode;
            logger.log('INFO', 'MODE=' + newMode);
            if (this.mode === 'MODE_POP-ON') {
                this.writeScreen = this.nonDisplayedMemory;
            } else {
                this.writeScreen = this.displayedMemory;
                this.writeScreen.reset();
            }
            if (this.mode !== 'MODE_ROLL-UP') {
                this.displayedMemory.nrRollUpRows = null;
                this.nonDisplayedMemory.nrRollUpRows = null;
            }
            this.mode = newMode;
        }
    }, {
        key: 'insertChars',
        value: function insertChars(chars) {
            for (var i = 0; i < chars.length; i++) {
                this.writeScreen.insertChar(chars[i]);
            }
            var screen = this.writeScreen === this.displayedMemory ? 'DISP' : 'NON_DISP';
            logger.log('INFO', screen + ': ' + this.writeScreen.getDisplayText(true));
            if (this.mode === 'MODE_PAINT-ON' || this.mode === 'MODE_ROLL-UP') {
                logger.log('TEXT', 'DISPLAYED: ' + this.displayedMemory.getDisplayText(true));
                this.outputDataUpdate();
            }
        }
    }, {
        key: 'ccRCL',
        value: function ccRCL() {
            // Resume Caption Loading (switch mode to Pop On)
            logger.log('INFO', 'RCL - Resume Caption Loading');
            this.setMode('MODE_POP-ON');
        }
    }, {
        key: 'ccBS',
        value: function ccBS() {
            // BackSpace
            logger.log('INFO', 'BS - BackSpace');
            if (this.mode === 'MODE_TEXT') {
                return;
            }
            this.writeScreen.backSpace();
            if (this.writeScreen === this.displayedMemory) {
                this.outputDataUpdate();
            }
        }
    }, {
        key: 'ccAOF',
        value: function ccAOF() {
            // Reserved (formerly Alarm Off)
            return;
        }
    }, {
        key: 'ccAON',
        value: function ccAON() {
            // Reserved (formerly Alarm On)
            return;
        }
    }, {
        key: 'ccDER',
        value: function ccDER() {
            // Delete to End of Row
            logger.log('INFO', 'DER- Delete to End of Row');
            this.writeScreen.clearToEndOfRow();
            this.outputDataUpdate();
        }
    }, {
        key: 'ccRU',
        value: function ccRU(nrRows) {
            //Roll-Up Captions-2,3,or 4 Rows
            logger.log('INFO', 'RU(' + nrRows + ') - Roll Up');
            this.writeScreen = this.displayedMemory;
            this.setMode('MODE_ROLL-UP');
            this.writeScreen.setRollUpRows(nrRows);
        }
    }, {
        key: 'ccFON',
        value: function ccFON() {
            //Flash On
            logger.log('INFO', 'FON - Flash On');
            this.writeScreen.setPen({ flash: true });
        }
    }, {
        key: 'ccRDC',
        value: function ccRDC() {
            // Resume Direct Captioning (switch mode to PaintOn)
            logger.log('INFO', 'RDC - Resume Direct Captioning');
            this.setMode('MODE_PAINT-ON');
        }
    }, {
        key: 'ccTR',
        value: function ccTR() {
            // Text Restart in text mode (not supported, however)
            logger.log('INFO', 'TR');
            this.setMode('MODE_TEXT');
        }
    }, {
        key: 'ccRTD',
        value: function ccRTD() {
            // Resume Text Display in Text mode (not supported, however)
            logger.log('INFO', 'RTD');
            this.setMode('MODE_TEXT');
        }
    }, {
        key: 'ccEDM',
        value: function ccEDM() {
            // Erase Displayed Memory
            logger.log('INFO', 'EDM - Erase Displayed Memory');
            this.displayedMemory.reset();
            this.outputDataUpdate();
        }
    }, {
        key: 'ccCR',
        value: function ccCR() {
            // Carriage Return
            logger.log('CR - Carriage Return');
            this.writeScreen.rollUp();
            this.outputDataUpdate();
        }
    }, {
        key: 'ccENM',
        value: function ccENM() {
            //Erase Non-Displayed Memory
            logger.log('INFO', 'ENM - Erase Non-displayed Memory');
            this.nonDisplayedMemory.reset();
        }
    }, {
        key: 'ccEOC',
        value: function ccEOC() {
            //End of Caption (Flip Memories)
            logger.log('INFO', 'EOC - End Of Caption');
            if (this.mode === 'MODE_POP-ON') {
                var tmp = this.displayedMemory;
                this.displayedMemory = this.nonDisplayedMemory;
                this.nonDisplayedMemory = tmp;
                this.writeScreen = this.nonDisplayedMemory;
                logger.log('TEXT', 'DISP: ' + this.displayedMemory.getDisplayText());
            }
            this.outputDataUpdate();
        }
    }, {
        key: 'ccTO',
        value: function ccTO(nrCols) {
            // Tab Offset 1,2, or 3 columns
            logger.log('INFO', 'TO(' + nrCols + ') - Tab Offset');
            this.writeScreen.moveCursor(nrCols);
        }
    }, {
        key: 'ccMIDROW',
        value: function ccMIDROW(secondByte) {
            // Parse MIDROW command
            var styles = { flash: false };
            styles.underline = secondByte % 2 === 1;
            styles.italics = secondByte >= 0x2e;
            if (!styles.italics) {
                var colorIndex = Math.floor(secondByte / 2) - 0x10;
                var colors = ['white', 'green', 'blue', 'cyan', 'red', 'yellow', 'magenta'];
                styles.foreground = colors[colorIndex];
            } else {
                styles.foreground = 'white';
            }
            logger.log('INFO', 'MIDROW: ' + JSON.stringify(styles));
            this.writeScreen.setPen(styles);
        }
    }, {
        key: 'outputDataUpdate',
        value: function outputDataUpdate() {
            var t = logger.time;
            if (t === null) {
                return;
            }
            if (this.outputFilter) {
                if (this.outputFilter.updateData) {
                    this.outputFilter.updateData(t, this.displayedMemory);
                }
                if (this.cueStartTime === null && !this.displayedMemory.isEmpty()) {
                    // Start of a new cue
                    this.cueStartTime = t;
                } else {
                    if (!this.displayedMemory.equals(this.lastOutputScreen)) {
                        if (this.outputFilter.newCue) {
                            this.outputFilter.newCue(this.cueStartTime, t, this.lastOutputScreen);
                        }
                        this.cueStartTime = this.displayedMemory.isEmpty() ? null : t;
                    }
                }
                this.lastOutputScreen.copy(this.displayedMemory);
            }
        }
    }, {
        key: 'cueSplitAtTime',
        value: function cueSplitAtTime(t) {
            if (this.outputFilter) {
                if (!this.displayedMemory.isEmpty()) {
                    if (this.outputFilter.newCue) {
                        this.outputFilter.newCue(this.cueStartTime, t, this.displayedMemory);
                    }
                    this.cueStartTime = t;
                }
            }
        }
    }]);

    return Cea608Channel;
}();

var Cea608Parser = function () {
    function Cea608Parser(field, out1, out2) {
        _classCallCheck(this, Cea608Parser);

        this.field = field || 1;
        this.outputs = [out1, out2];
        this.channels = [new Cea608Channel(1, out1), new Cea608Channel(2, out2)];
        this.currChNr = -1; // Will be 1 or 2
        this.lastCmdA = null; // First byte of last command
        this.lastCmdB = null; // Second byte of last command
        this.bufferedData = [];
        this.startTime = null;
        this.lastTime = null;
        this.dataCounters = { 'padding': 0, 'char': 0, 'cmd': 0, 'other': 0 };
    }

    _createClass(Cea608Parser, [{
        key: 'getHandler',
        value: function getHandler(index) {
            return this.channels[index].getHandler();
        }
    }, {
        key: 'setHandler',
        value: function setHandler(index, newHandler) {
            this.channels[index].setHandler(newHandler);
        }

        /**
         * Add data for time t in forms of list of bytes (unsigned ints). The bytes are treated as pairs.
         */

    }, {
        key: 'addData',
        value: function addData(t, byteList) {
            var cmdFound,
                a,
                b,
                charsFound = false;

            this.lastTime = t;
            logger.setTime(t);

            for (var i = 0; i < byteList.length; i += 2) {
                a = byteList[i] & 0x7f;
                b = byteList[i + 1] & 0x7f;
                if (a === 0 && b === 0) {
                    this.dataCounters.padding += 2;
                    continue;
                } else {
                    logger.log('DATA', '[' + numArrayToHexArray([byteList[i], byteList[i + 1]]) + '] -> (' + numArrayToHexArray([a, b]) + ')');
                }
                cmdFound = this.parseCmd(a, b);
                if (!cmdFound) {
                    cmdFound = this.parseMidrow(a, b);
                }
                if (!cmdFound) {
                    cmdFound = this.parsePAC(a, b);
                }
                if (!cmdFound) {
                    cmdFound = this.parseBackgroundAttributes(a, b);
                }
                if (!cmdFound) {
                    charsFound = this.parseChars(a, b);
                    if (charsFound) {
                        if (this.currChNr && this.currChNr >= 0) {
                            var channel = this.channels[this.currChNr - 1];
                            channel.insertChars(charsFound);
                        } else {
                            logger.log('WARNING', 'No channel found yet. TEXT-MODE?');
                        }
                    }
                }
                if (cmdFound) {
                    this.dataCounters.cmd += 2;
                } else if (charsFound) {
                    this.dataCounters.char += 2;
                } else {
                    this.dataCounters.other += 2;
                    logger.log('WARNING', 'Couldn\'t parse cleaned data ' + numArrayToHexArray([a, b]) + ' orig: ' + numArrayToHexArray([byteList[i], byteList[i + 1]]));
                }
            }
        }

        /**
         * Parse Command.
         * @returns {Boolean} Tells if a command was found
         */

    }, {
        key: 'parseCmd',
        value: function parseCmd(a, b) {
            var chNr = null;

            var cond1 = (a === 0x14 || a === 0x1C) && 0x20 <= b && b <= 0x2F;
            var cond2 = (a === 0x17 || a === 0x1F) && 0x21 <= b && b <= 0x23;
            if (!(cond1 || cond2)) {
                return false;
            }

            if (a === this.lastCmdA && b === this.lastCmdB) {
                this.lastCmdA = null;
                this.lastCmdB = null; // Repeated commands are dropped (once)
                logger.log('DEBUG', 'Repeated command (' + numArrayToHexArray([a, b]) + ') is dropped');
                return true;
            }

            if (a === 0x14 || a === 0x17) {
                chNr = 1;
            } else {
                chNr = 2; // (a === 0x1C || a=== 0x1f)
            }

            var channel = this.channels[chNr - 1];

            if (a === 0x14 || a === 0x1C) {
                if (b === 0x20) {
                    channel.ccRCL();
                } else if (b === 0x21) {
                    channel.ccBS();
                } else if (b === 0x22) {
                    channel.ccAOF();
                } else if (b === 0x23) {
                    channel.ccAON();
                } else if (b === 0x24) {
                    channel.ccDER();
                } else if (b === 0x25) {
                    channel.ccRU(2);
                } else if (b === 0x26) {
                    channel.ccRU(3);
                } else if (b === 0x27) {
                    channel.ccRU(4);
                } else if (b === 0x28) {
                    channel.ccFON();
                } else if (b === 0x29) {
                    channel.ccRDC();
                } else if (b === 0x2A) {
                    channel.ccTR();
                } else if (b === 0x2B) {
                    channel.ccRTD();
                } else if (b === 0x2C) {
                    channel.ccEDM();
                } else if (b === 0x2D) {
                    channel.ccCR();
                } else if (b === 0x2E) {
                    channel.ccENM();
                } else if (b === 0x2F) {
                    channel.ccEOC();
                }
            } else {
                //a == 0x17 || a == 0x1F
                channel.ccTO(b - 0x20);
            }
            this.lastCmdA = a;
            this.lastCmdB = b;
            this.currChNr = chNr;
            return true;
        }

        /**
         * Parse midrow styling command
         * @returns {Boolean}
         */

    }, {
        key: 'parseMidrow',
        value: function parseMidrow(a, b) {
            var chNr = null;

            if ((a === 0x11 || a === 0x19) && 0x20 <= b && b <= 0x2f) {
                if (a === 0x11) {
                    chNr = 1;
                } else {
                    chNr = 2;
                }
                if (chNr !== this.currChNr) {
                    logger.log('ERROR', 'Mismatch channel in midrow parsing');
                    return false;
                }
                var channel = this.channels[chNr - 1];
                channel.ccMIDROW(b);
                logger.log('DEBUG', 'MIDROW (' + numArrayToHexArray([a, b]) + ')');
                return true;
            }
            return false;
        }
        /**
         * Parse Preable Access Codes (Table 53).
         * @returns {Boolean} Tells if PAC found
         */

    }, {
        key: 'parsePAC',
        value: function parsePAC(a, b) {

            var chNr = null;
            var row = null;

            var case1 = (0x11 <= a && a <= 0x17 || 0x19 <= a && a <= 0x1F) && 0x40 <= b && b <= 0x7F;
            var case2 = (a === 0x10 || a === 0x18) && 0x40 <= b && b <= 0x5F;
            if (!(case1 || case2)) {
                return false;
            }

            if (a === this.lastCmdA && b === this.lastCmdB) {
                this.lastCmdA = null;
                this.lastCmdB = null;
                return true; // Repeated commands are dropped (once)
            }

            chNr = a <= 0x17 ? 1 : 2;

            if (0x40 <= b && b <= 0x5F) {
                row = chNr === 1 ? rowsLowCh1[a] : rowsLowCh2[a];
            } else {
                // 0x60 <= b <= 0x7F
                row = chNr === 1 ? rowsHighCh1[a] : rowsHighCh2[a];
            }
            var pacData = this.interpretPAC(row, b);
            var channel = this.channels[chNr - 1];
            channel.setPAC(pacData);
            this.lastCmdA = a;
            this.lastCmdB = b;
            this.currChNr = chNr;
            return true;
        }

        /**
         * Interpret the second byte of the pac, and return the information.
         * @returns {Object} pacData with style parameters.
         */

    }, {
        key: 'interpretPAC',
        value: function interpretPAC(row, byte) {
            var pacIndex = byte;
            var pacData = { color: null, italics: false, indent: null, underline: false, row: row };

            if (byte > 0x5F) {
                pacIndex = byte - 0x60;
            } else {
                pacIndex = byte - 0x40;
            }
            pacData.underline = (pacIndex & 1) === 1;
            if (pacIndex <= 0xd) {
                pacData.color = ['white', 'green', 'blue', 'cyan', 'red', 'yellow', 'magenta', 'white'][Math.floor(pacIndex / 2)];
            } else if (pacIndex <= 0xf) {
                pacData.italics = true;
                pacData.color = 'white';
            } else {
                pacData.indent = Math.floor((pacIndex - 0x10) / 2) * 4;
            }
            return pacData; // Note that row has zero offset. The spec uses 1.
        }

        /**
         * Parse characters.
         * @returns An array with 1 to 2 codes corresponding to chars, if found. null otherwise.
         */

    }, {
        key: 'parseChars',
        value: function parseChars(a, b) {

            var channelNr = null,
                charCodes = null,
                charCode1 = null;

            if (a >= 0x19) {
                channelNr = 2;
                charCode1 = a - 8;
            } else {
                channelNr = 1;
                charCode1 = a;
            }
            if (0x11 <= charCode1 && charCode1 <= 0x13) {
                // Special character
                var oneCode = b;
                if (charCode1 === 0x11) {
                    oneCode = b + 0x50;
                } else if (charCode1 === 0x12) {
                    oneCode = b + 0x70;
                } else {
                    oneCode = b + 0x90;
                }
                logger.log('INFO', 'Special char \'' + getCharForByte(oneCode) + '\' in channel ' + channelNr);
                charCodes = [oneCode];
            } else if (0x20 <= a && a <= 0x7f) {
                charCodes = b === 0 ? [a] : [a, b];
            }
            if (charCodes) {
                var hexCodes = numArrayToHexArray(charCodes);
                logger.log('DEBUG', 'Char codes =  ' + hexCodes.join(','));
                this.lastCmdA = null;
                this.lastCmdB = null;
            }
            return charCodes;
        }

        /**
        * Parse extended background attributes as well as new foreground color black.
        * @returns{Boolean} Tells if background attributes are found
        */

    }, {
        key: 'parseBackgroundAttributes',
        value: function parseBackgroundAttributes(a, b) {
            var bkgData, index, chNr, channel;

            var case1 = (a === 0x10 || a === 0x18) && 0x20 <= b && b <= 0x2f;
            var case2 = (a === 0x17 || a === 0x1f) && 0x2d <= b && b <= 0x2f;
            if (!(case1 || case2)) {
                return false;
            }
            bkgData = {};
            if (a === 0x10 || a === 0x18) {
                index = Math.floor((b - 0x20) / 2);
                bkgData.background = backgroundColors[index];
                if (b % 2 === 1) {
                    bkgData.background = bkgData.background + '_semi';
                }
            } else if (b === 0x2d) {
                bkgData.background = 'transparent';
            } else {
                bkgData.foreground = 'black';
                if (b === 0x2f) {
                    bkgData.underline = true;
                }
            }
            chNr = a < 0x18 ? 1 : 2;
            channel = this.channels[chNr - 1];
            channel.setBkgData(bkgData);
            this.lastCmdA = null;
            this.lastCmdB = null;
            return true;
        }

        /**
         * Reset state of parser and its channels.
         */

    }, {
        key: 'reset',
        value: function reset() {
            for (var i = 0; i < this.channels.length; i++) {
                if (this.channels[i]) {
                    this.channels[i].reset();
                }
            }
            this.lastCmdA = null;
            this.lastCmdB = null;
        }

        /**
         * Trigger the generation of a cue, and the start of a new one if displayScreens are not empty.
         */

    }, {
        key: 'cueSplitAtTime',
        value: function cueSplitAtTime(t) {
            for (var i = 0; i < this.channels.length; i++) {
                if (this.channels[i]) {
                    this.channels[i].cueSplitAtTime(t);
                }
            }
        }
    }]);

    return Cea608Parser;
}();

exports.default = Cea608Parser;

},{}],42:[function(require,module,exports){
'use strict';

var Cues = {

  newCue: function newCue(track, startTime, endTime, captionScreen) {
    var row;
    var cue;
    var indenting;
    var indent;
    var text;
    var VTTCue = window.VTTCue || window.TextTrackCue;

    for (var r = 0; r < captionScreen.rows.length; r++) {
      row = captionScreen.rows[r];
      indenting = true;
      indent = 0;
      text = '';

      if (!row.isEmpty()) {
        for (var c = 0; c < row.chars.length; c++) {
          if (row.chars[c].uchar.match(/\s/) && indenting) {
            indent++;
          } else {
            text += row.chars[c].uchar;
            indenting = false;
          }
        }
        cue = new VTTCue(startTime, endTime, text.trim());

        if (indent >= 16) {
          indent--;
        } else {
          indent++;
        }

        // VTTCue.line get's flakey when using controls, so let's now include line 13&14
        // also, drop line 1 since it's to close to the top
        if (navigator.userAgent.match(/Firefox\//)) {
          cue.line = r + 1;
        } else {
          cue.line = r > 7 ? r - 2 : r + 1;
        }
        cue.align = 'left';
        cue.position = 100 * (indent / 32) + (navigator.userAgent.match(/Firefox\//) ? 50 : 0);
        track.addCue(cue);
      }
    }
  }

};

module.exports = Cues;

},{}],43:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/*
 * compute an Exponential Weighted moving average
 * - https://en.wikipedia.org/wiki/Moving_average#Exponential_moving_average
 *  - heavily inspired from shaka-player
 */

var EWMA = function () {

  //  About half of the estimated value will be from the last |halfLife| samples by weight.
  function EWMA(halfLife) {
    _classCallCheck(this, EWMA);

    // Larger values of alpha expire historical data more slowly.
    this.alpha_ = halfLife ? Math.exp(Math.log(0.5) / halfLife) : 0;
    this.estimate_ = 0;
    this.totalWeight_ = 0;
  }

  _createClass(EWMA, [{
    key: "sample",
    value: function sample(weight, value) {
      var adjAlpha = Math.pow(this.alpha_, weight);
      this.estimate_ = value * (1 - adjAlpha) + adjAlpha * this.estimate_;
      this.totalWeight_ += weight;
    }
  }, {
    key: "getTotalWeight",
    value: function getTotalWeight() {
      return this.totalWeight_;
    }
  }, {
    key: "getEstimate",
    value: function getEstimate() {
      if (this.alpha_) {
        var zeroFactor = 1 - Math.pow(this.alpha_, this.totalWeight_);
        return this.estimate_ / zeroFactor;
      } else {
        return this.estimate_;
      }
    }
  }]);

  return EWMA;
}();

exports.default = EWMA;

},{}],44:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function noop() {}

var fakeLogger = {
  trace: noop,
  debug: noop,
  log: noop,
  warn: noop,
  info: noop,
  error: noop
};

var exportedLogger = fakeLogger;

/*globals self: false */

//let lastCallTime;
// function formatMsgWithTimeInfo(type, msg) {
//   const now = Date.now();
//   const diff = lastCallTime ? '+' + (now - lastCallTime) : '0';
//   lastCallTime = now;
//   msg = (new Date(now)).toISOString() + ' | [' +  type + '] > ' + msg + ' ( ' + diff + ' ms )';
//   return msg;
// }

function formatMsg(type, msg) {
  msg = '[' + type + '] > ' + msg;
  return msg;
}

function consolePrintFn(type) {
  var func = self.console[type];
  if (func) {
    return function () {
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      if (args[0]) {
        args[0] = formatMsg(type, args[0]);
      }
      func.apply(self.console, args);
    };
  }
  return noop;
}

function exportLoggerFunctions(debugConfig) {
  for (var _len2 = arguments.length, functions = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    functions[_key2 - 1] = arguments[_key2];
  }

  functions.forEach(function (type) {
    exportedLogger[type] = debugConfig[type] ? debugConfig[type].bind(debugConfig) : consolePrintFn(type);
  });
}

var enableLogs = exports.enableLogs = function enableLogs(debugConfig) {
  if (debugConfig === true || (typeof debugConfig === 'undefined' ? 'undefined' : _typeof(debugConfig)) === 'object') {
    exportLoggerFunctions(debugConfig,
    // Remove out from list here to hard-disable a log-level
    //'trace',
    'debug', 'log', 'info', 'warn', 'error');
    // Some browsers don't allow to use bind on console object anyway
    // fallback to default if needed
    try {
      exportedLogger.log();
    } catch (e) {
      exportedLogger = fakeLogger;
    }
  } else {
    exportedLogger = fakeLogger;
  }
};

var logger = exports.logger = exportedLogger;

},{}],45:[function(require,module,exports){
'use strict';

if (typeof ArrayBuffer !== 'undefined' && !ArrayBuffer.prototype.slice) {
  ArrayBuffer.prototype.slice = function (start, end) {
    var that = new Uint8Array(this);
    if (end === undefined) {
      end = that.length;
    }
    var result = new ArrayBuffer(end - start);
    var resultArray = new Uint8Array(result);
    for (var i = 0; i < resultArray.length; i++) {
      resultArray[i] = that[i + start];
    }
    return result;
  };
}

},{}],46:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 *  TimeRanges to string helper
 */

var TimeRanges = function () {
  function TimeRanges() {
    _classCallCheck(this, TimeRanges);
  }

  _createClass(TimeRanges, null, [{
    key: 'toString',
    value: function toString(r) {
      var log = '',
          len = r.length;
      for (var i = 0; i < len; i++) {
        log += '[' + r.start(i) + ',' + r.end(i) + ']';
      }
      return log;
    }
  }]);

  return TimeRanges;
}();

exports.default = TimeRanges;

},{}],47:[function(require,module,exports){
'use strict';

var URLHelper = {
  // build an absolute URL from a relative one using the provided baseURL
  // if relativeURL is an absolute URL it will be returned as is.
  buildAbsoluteURL: function buildAbsoluteURL(baseURL, relativeURL) {
    // remove any remaining space and CRLF
    relativeURL = relativeURL.trim();
    if (/^[a-z]+:/i.test(relativeURL)) {
      // complete url, not relative
      return relativeURL;
    }

    var relativeURLQuery = null;
    var relativeURLHash = null;

    var relativeURLHashSplit = /^([^#]*)(.*)$/.exec(relativeURL);
    if (relativeURLHashSplit) {
      relativeURLHash = relativeURLHashSplit[2];
      relativeURL = relativeURLHashSplit[1];
    }
    var relativeURLQuerySplit = /^([^\?]*)(.*)$/.exec(relativeURL);
    if (relativeURLQuerySplit) {
      relativeURLQuery = relativeURLQuerySplit[2];
      relativeURL = relativeURLQuerySplit[1];
    }

    var baseURLHashSplit = /^([^#]*)(.*)$/.exec(baseURL);
    if (baseURLHashSplit) {
      baseURL = baseURLHashSplit[1];
    }
    var baseURLQuerySplit = /^([^\?]*)(.*)$/.exec(baseURL);
    if (baseURLQuerySplit) {
      baseURL = baseURLQuerySplit[1];
    }

    var baseURLDomainSplit = /^(([a-z]+:)?\/\/[a-z0-9\.\-_~]+(:[0-9]+)?)?(\/.*)$/i.exec(baseURL);
    if (!baseURLDomainSplit) {
      throw new Error('Error trying to parse base URL.');
    }

    // e.g. 'http:', 'https:', ''
    var baseURLProtocol = baseURLDomainSplit[2] || '';
    // e.g. 'http://example.com', '//example.com', ''
    var baseURLProtocolDomain = baseURLDomainSplit[1] || '';
    // e.g. '/a/b/c/playlist.m3u8'
    var baseURLPath = baseURLDomainSplit[4];

    var builtURL = null;
    if (/^\/\//.test(relativeURL)) {
      // relative url starts wth '//' so copy protocol (which may be '' if baseUrl didn't provide one)
      builtURL = baseURLProtocol + '//' + URLHelper.buildAbsolutePath('', relativeURL.substring(2));
    } else if (/^\//.test(relativeURL)) {
      // relative url starts with '/' so start from root of domain
      builtURL = baseURLProtocolDomain + '/' + URLHelper.buildAbsolutePath('', relativeURL.substring(1));
    } else {
      builtURL = URLHelper.buildAbsolutePath(baseURLProtocolDomain + baseURLPath, relativeURL);
    }

    // put the query and hash parts back
    if (relativeURLQuery) {
      builtURL += relativeURLQuery;
    }
    if (relativeURLHash) {
      builtURL += relativeURLHash;
    }
    return builtURL;
  },

  // build an absolute path using the provided basePath
  // adapted from https://developer.mozilla.org/en-US/docs/Web/API/document/cookie#Using_relative_URLs_in_the_path_parameter
  // this does not handle the case where relativePath is "/" or "//". These cases should be handled outside this.
  buildAbsolutePath: function buildAbsolutePath(basePath, relativePath) {
    var sRelPath = relativePath;
    var nUpLn,
        sDir = '',
        sPath = basePath.replace(/[^\/]*$/, sRelPath.replace(/(\/|^)(?:\.?\/+)+/g, '$1'));
    for (var nEnd, nStart = 0; nEnd = sPath.indexOf('/../', nStart), nEnd > -1; nStart = nEnd + nUpLn) {
      nUpLn = /^\/(?:\.\.\/)*/.exec(sPath.slice(nEnd))[0].length;
      sDir = (sDir + sPath.substring(nStart, nEnd)).replace(new RegExp('(?:\\\/+[^\\\/]*){0,' + (nUpLn - 1) / 3 + '}$'), '/');
    }
    return sDir + sPath.substr(nStart);
  }
};

module.exports = URLHelper;

},{}],48:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * XHR based logger
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */

var _logger = require('../utils/logger');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var XhrLoader = function () {
  function XhrLoader(config) {
    _classCallCheck(this, XhrLoader);

    if (config && config.xhrSetup) {
      this.xhrSetup = config.xhrSetup;
    }
  }

  _createClass(XhrLoader, [{
    key: 'destroy',
    value: function destroy() {
      this.abort();
      this.loader = null;
    }
  }, {
    key: 'abort',
    value: function abort() {
      var loader = this.loader;
      if (loader && loader.readyState !== 4) {
        this.stats.aborted = true;
        loader.abort();
      }

      window.clearTimeout(this.requestTimeout);
      this.requestTimeout = null;
      window.clearTimeout(this.retryTimeout);
      this.retryTimeout = null;
    }
  }, {
    key: 'load',
    value: function load(context, config, callbacks) {
      this.context = context;
      this.config = config;
      this.callbacks = callbacks;
      this.stats = { trequest: performance.now(), retry: 0 };
      this.retryDelay = config.retryDelay;
      this.loadInternal();
    }
  }, {
    key: 'loadInternal',
    value: function loadInternal() {
      var xhr,
          context = this.context;

      if (typeof XDomainRequest !== 'undefined') {
        xhr = this.loader = new XDomainRequest();
      } else {
        xhr = this.loader = new XMLHttpRequest();
      }

      xhr.onreadystatechange = this.readystatechange.bind(this);
      xhr.onprogress = this.loadprogress.bind(this);

      xhr.open('GET', context.url, true);

      if (context.rangeEnd) {
        xhr.setRequestHeader('Range', 'bytes=' + context.rangeStart + '-' + (context.rangeEnd - 1));
      }
      xhr.responseType = context.responseType;
      var stats = this.stats;
      stats.tfirst = 0;
      stats.loaded = 0;
      if (this.xhrSetup) {
        this.xhrSetup(xhr, context.url);
      }
      // setup timeout before we perform request
      this.requestTimeout = window.setTimeout(this.loadtimeout.bind(this), this.config.timeout);
      xhr.send();
    }
  }, {
    key: 'readystatechange',
    value: function readystatechange(event) {
      var xhr = event.currentTarget,
          readyState = xhr.readyState,
          stats = this.stats,
          context = this.context,
          config = this.config;

      // don't proceed if xhr has been aborted
      if (stats.aborted) {
        return;
      }

      // in any case clear the current xhrs timeout
      window.clearTimeout(this.requestTimeout);

      // HEADERS_RECEIVED
      if (readyState >= 2) {
        if (stats.tfirst === 0) {
          stats.tfirst = Math.max(performance.now(), stats.trequest);
          // reset timeout to total timeout duration minus the time it took to receive headers
          this.requestTimeout = window.setTimeout(this.loadtimeout.bind(this), config.timeout - (stats.tfirst - stats.trequest));
        }
        if (readyState === 4) {
          var status = xhr.status;
          // http status between 200 to 299 are all successful
          if (status >= 200 && status < 300) {
            stats.tload = Math.max(stats.tfirst, performance.now());
            var data = void 0,
                len = void 0;
            if (context.responseType === 'arraybuffer') {
              data = xhr.response;
              len = data.byteLength;
            } else {
              data = xhr.responseText;
              len = data.length;
            }
            stats.loaded = stats.total = len;
            var response = { url: xhr.responseURL, data: data };
            this.callbacks.onSuccess(response, stats, context);
          } else {
            // if max nb of retries reached or if http status between 400 and 499 (such error cannot be recovered, retrying is useless), return error
            if (stats.retry >= config.maxRetry || status >= 400 && status < 499) {
              _logger.logger.error(status + ' while loading ' + context.url);
              this.callbacks.onError({ code: status, text: xhr.statusText }, context);
            } else {
              // retry
              _logger.logger.warn(status + ' while loading ' + context.url + ', retrying in ' + this.retryDelay + '...');
              // aborts and resets internal state
              this.destroy();
              // schedule retry
              this.retryTimeout = window.setTimeout(this.loadInternal.bind(this), this.retryDelay);
              // set exponential backoff
              this.retryDelay = Math.min(2 * this.retryDelay, config.maxRetryDelay);
              stats.retry++;
            }
          }
        }
      }
    }
  }, {
    key: 'loadtimeout',
    value: function loadtimeout() {
      _logger.logger.warn('timeout while loading ' + this.context.url);
      this.callbacks.onTimeout(this.stats, this.context);
    }
  }, {
    key: 'loadprogress',
    value: function loadprogress(event) {
      var stats = this.stats;
      stats.loaded = event.loaded;
      if (event.lengthComputable) {
        stats.total = event.total;
      }
      var onProgress = this.callbacks.onProgress;
      if (onProgress) {
        // last args is to provide on progress data
        onProgress(stats, this.context, null);
      }
    }
  }]);

  return XhrLoader;
}();

exports.default = XhrLoader;

},{"../utils/logger":44}]},{},[32])(32)
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvZXZlbnRzL2V2ZW50cy5qcyIsIm5vZGVfbW9kdWxlcy93ZWJ3b3JraWZ5L2luZGV4LmpzIiwic3JjL2NvbnRyb2xsZXIvYWJyLWNvbnRyb2xsZXIuanMiLCJzcmMvY29udHJvbGxlci9hdWRpby1zdHJlYW0tY29udHJvbGxlci5qcyIsInNyYy9jb250cm9sbGVyL2F1ZGlvLXRyYWNrLWNvbnRyb2xsZXIuanMiLCJzcmMvY29udHJvbGxlci9idWZmZXItY29udHJvbGxlci5qcyIsInNyYy9jb250cm9sbGVyL2NhcC1sZXZlbC1jb250cm9sbGVyLmpzIiwic3JjL2NvbnRyb2xsZXIvZXdtYS1iYW5kd2lkdGgtZXN0aW1hdG9yLmpzIiwic3JjL2NvbnRyb2xsZXIvZnBzLWNvbnRyb2xsZXIuanMiLCJzcmMvY29udHJvbGxlci9sZXZlbC1jb250cm9sbGVyLmpzIiwic3JjL2NvbnRyb2xsZXIvc3RyZWFtLWNvbnRyb2xsZXIuanMiLCJzcmMvY29udHJvbGxlci90aW1lbGluZS1jb250cm9sbGVyLmpzIiwic3JjL2NyeXB0L2Flcy1jcnlwdG8uanMiLCJzcmMvY3J5cHQvYWVzLWRlY3J5cHRvci5qcyIsInNyYy9jcnlwdC9kZWNyeXB0ZXIuanMiLCJzcmMvY3J5cHQvZmFzdC1hZXMta2V5LmpzIiwic3JjL2RlbXV4L2FhY2RlbXV4ZXIuanMiLCJzcmMvZGVtdXgvYWR0cy5qcyIsInNyYy9kZW11eC9kZW11eGVyLWlubGluZS5qcyIsInNyYy9kZW11eC9kZW11eGVyLXdvcmtlci5qcyIsInNyYy9kZW11eC9kZW11eGVyLmpzIiwic3JjL2RlbXV4L2V4cC1nb2xvbWIuanMiLCJzcmMvZGVtdXgvaWQzLmpzIiwic3JjL2RlbXV4L3RzZGVtdXhlci5qcyIsInNyYy9lcnJvcnMuanMiLCJzcmMvZXZlbnQtaGFuZGxlci5qcyIsInNyYy9ldmVudHMuanMiLCJzcmMvaGVscGVyL2FhYy5qcyIsInNyYy9oZWxwZXIvYnVmZmVyLWhlbHBlci5qcyIsInNyYy9oZWxwZXIvbGV2ZWwtaGVscGVyLmpzIiwic3JjL2hscy5qcyIsInNyYy9pbmRleC5qcyIsInNyYy9sb2FkZXIvZnJhZ21lbnQtbG9hZGVyLmpzIiwic3JjL2xvYWRlci9rZXktbG9hZGVyLmpzIiwic3JjL2xvYWRlci9wbGF5bGlzdC1sb2FkZXIuanMiLCJzcmMvcmVtdXgvbXA0LWdlbmVyYXRvci5qcyIsInNyYy9yZW11eC9tcDQtcmVtdXhlci5qcyIsInNyYy9yZW11eC9wYXNzdGhyb3VnaC1yZW11eGVyLmpzIiwic3JjL3V0aWxzL2F0dHItbGlzdC5qcyIsInNyYy91dGlscy9iaW5hcnktc2VhcmNoLmpzIiwic3JjL3V0aWxzL2NlYS02MDgtcGFyc2VyLmpzIiwic3JjL3V0aWxzL2N1ZXMuanMiLCJzcmMvdXRpbHMvZXdtYS5qcyIsInNyYy91dGlscy9sb2dnZXIuanMiLCJzcmMvdXRpbHMvcG9seWZpbGwuanMiLCJzcmMvdXRpbHMvdGltZVJhbmdlcy5qcyIsInNyYy91dGlscy91cmwuanMiLCJzcmMvdXRpbHMveGhyLWxvYWRlci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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OUIsRUFBcUMsS0FBSyxPQUExQztBQUNEOzs7aUNBRVksSyxFQUFPO0FBQ2xCLFVBQUksUUFBUSxLQUFLLEtBQWpCO0FBQ0EsWUFBTSxNQUFOLEdBQWUsTUFBTSxNQUFyQjtBQUNBLFVBQUksTUFBTSxnQkFBVixFQUE0QjtBQUMxQixjQUFNLEtBQU4sR0FBYyxNQUFNLEtBQXBCO0FBQ0Q7QUFDRCxVQUFJLGFBQWEsS0FBSyxTQUFMLENBQWUsVUFBaEM7QUFDQSxVQUFJLFVBQUosRUFBZ0I7QUFDZDtBQUNBLG1CQUFXLEtBQVgsRUFBa0IsS0FBSyxPQUF2QixFQUFnQyxJQUFoQztBQUNEO0FBQ0Y7Ozs7OztrQkFHWSxTIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIHRoaXMuX2V2ZW50cyA9IHRoaXMuX2V2ZW50cyB8fCB7fTtcbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gdGhpcy5fbWF4TGlzdGVuZXJzIHx8IHVuZGVmaW5lZDtcbn1cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjEwLnhcbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cyA9IHVuZGVmaW5lZDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX21heExpc3RlbmVycyA9IHVuZGVmaW5lZDtcblxuLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhbiAxMCBsaXN0ZW5lcnMgYXJlXG4vLyBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxuRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcblxuLy8gT2J2aW91c2x5IG5vdCBhbGwgRW1pdHRlcnMgc2hvdWxkIGJlIGxpbWl0ZWQgdG8gMTAuIFRoaXMgZnVuY3Rpb24gYWxsb3dzXG4vLyB0aGF0IHRvIGJlIGluY3JlYXNlZC4gU2V0IHRvIHplcm8gZm9yIHVubGltaXRlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24obikge1xuICBpZiAoIWlzTnVtYmVyKG4pIHx8IG4gPCAwIHx8IGlzTmFOKG4pKVxuICAgIHRocm93IFR5cGVFcnJvcignbiBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJyk7XG4gIHRoaXMuX21heExpc3RlbmVycyA9IG47XG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIgZXIsIGhhbmRsZXIsIGxlbiwgYXJncywgaSwgbGlzdGVuZXJzO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuXG4gIC8vIElmIHRoZXJlIGlzIG5vICdlcnJvcicgZXZlbnQgbGlzdGVuZXIgdGhlbiB0aHJvdy5cbiAgaWYgKHR5cGUgPT09ICdlcnJvcicpIHtcbiAgICBpZiAoIXRoaXMuX2V2ZW50cy5lcnJvciB8fFxuICAgICAgICAoaXNPYmplY3QodGhpcy5fZXZlbnRzLmVycm9yKSAmJiAhdGhpcy5fZXZlbnRzLmVycm9yLmxlbmd0aCkpIHtcbiAgICAgIGVyID0gYXJndW1lbnRzWzFdO1xuICAgICAgaWYgKGVyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBBdCBsZWFzdCBnaXZlIHNvbWUga2luZCBvZiBjb250ZXh0IHRvIHRoZSB1c2VyXG4gICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ1VuY2F1Z2h0LCB1bnNwZWNpZmllZCBcImVycm9yXCIgZXZlbnQuICgnICsgZXIgKyAnKScpO1xuICAgICAgICBlcnIuY29udGV4dCA9IGVyO1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaGFuZGxlciA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICBpZiAoaXNVbmRlZmluZWQoaGFuZGxlcikpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIGlmIChpc0Z1bmN0aW9uKGhhbmRsZXIpKSB7XG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAvLyBmYXN0IGNhc2VzXG4gICAgICBjYXNlIDE6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBzbG93ZXJcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICBoYW5kbGVyLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc09iamVjdChoYW5kbGVyKSkge1xuICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgIGxpc3RlbmVycyA9IGhhbmRsZXIuc2xpY2UoKTtcbiAgICBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKylcbiAgICAgIGxpc3RlbmVyc1tpXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBtO1xuXG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcblxuICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09PSBcIm5ld0xpc3RlbmVyXCIhIEJlZm9yZVxuICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcIm5ld0xpc3RlbmVyXCIuXG4gIGlmICh0aGlzLl9ldmVudHMubmV3TGlzdGVuZXIpXG4gICAgdGhpcy5lbWl0KCduZXdMaXN0ZW5lcicsIHR5cGUsXG4gICAgICAgICAgICAgIGlzRnVuY3Rpb24obGlzdGVuZXIubGlzdGVuZXIpID9cbiAgICAgICAgICAgICAgbGlzdGVuZXIubGlzdGVuZXIgOiBsaXN0ZW5lcik7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XG4gIGVsc2UgaWYgKGlzT2JqZWN0KHRoaXMuX2V2ZW50c1t0eXBlXSkpXG4gICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5wdXNoKGxpc3RlbmVyKTtcbiAgZWxzZVxuICAgIC8vIEFkZGluZyB0aGUgc2Vjb25kIGVsZW1lbnQsIG5lZWQgdG8gY2hhbmdlIHRvIGFycmF5LlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IFt0aGlzLl9ldmVudHNbdHlwZV0sIGxpc3RlbmVyXTtcblxuICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xuICBpZiAoaXNPYmplY3QodGhpcy5fZXZlbnRzW3R5cGVdKSAmJiAhdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCkge1xuICAgIGlmICghaXNVbmRlZmluZWQodGhpcy5fbWF4TGlzdGVuZXJzKSkge1xuICAgICAgbSA9IHRoaXMuX21heExpc3RlbmVycztcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzO1xuICAgIH1cblxuICAgIGlmIChtICYmIG0gPiAwICYmIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGggPiBtKSB7XG4gICAgICB0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkID0gdHJ1ZTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJyhub2RlKSB3YXJuaW5nOiBwb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5ICcgK1xuICAgICAgICAgICAgICAgICAgICAnbGVhayBkZXRlY3RlZC4gJWQgbGlzdGVuZXJzIGFkZGVkLiAnICtcbiAgICAgICAgICAgICAgICAgICAgJ1VzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvIGluY3JlYXNlIGxpbWl0LicsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGgpO1xuICAgICAgaWYgKHR5cGVvZiBjb25zb2xlLnRyYWNlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIG5vdCBzdXBwb3J0ZWQgaW4gSUUgMTBcbiAgICAgICAgY29uc29sZS50cmFjZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICB2YXIgZmlyZWQgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBnKCkge1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgZyk7XG5cbiAgICBpZiAoIWZpcmVkKSB7XG4gICAgICBmaXJlZCA9IHRydWU7XG4gICAgICBsaXN0ZW5lci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfVxuXG4gIGcubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgdGhpcy5vbih0eXBlLCBnKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIGVtaXRzIGEgJ3JlbW92ZUxpc3RlbmVyJyBldmVudCBpZmYgdGhlIGxpc3RlbmVyIHdhcyByZW1vdmVkXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIGxpc3QsIHBvc2l0aW9uLCBsZW5ndGgsIGk7XG5cbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgbGlzdCA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgbGVuZ3RoID0gbGlzdC5sZW5ndGg7XG4gIHBvc2l0aW9uID0gLTE7XG5cbiAgaWYgKGxpc3QgPT09IGxpc3RlbmVyIHx8XG4gICAgICAoaXNGdW5jdGlvbihsaXN0Lmxpc3RlbmVyKSAmJiBsaXN0Lmxpc3RlbmVyID09PSBsaXN0ZW5lcikpIHtcbiAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIGlmICh0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIpO1xuXG4gIH0gZWxzZSBpZiAoaXNPYmplY3QobGlzdCkpIHtcbiAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSA+IDA7KSB7XG4gICAgICBpZiAobGlzdFtpXSA9PT0gbGlzdGVuZXIgfHxcbiAgICAgICAgICAobGlzdFtpXS5saXN0ZW5lciAmJiBsaXN0W2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikpIHtcbiAgICAgICAgcG9zaXRpb24gPSBpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocG9zaXRpb24gPCAwKVxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICBpZiAobGlzdC5sZW5ndGggPT09IDEpIHtcbiAgICAgIGxpc3QubGVuZ3RoID0gMDtcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpc3Quc3BsaWNlKHBvc2l0aW9uLCAxKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3RlbmVyKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciBrZXksIGxpc3RlbmVycztcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICByZXR1cm4gdGhpcztcblxuICAvLyBub3QgbGlzdGVuaW5nIGZvciByZW1vdmVMaXN0ZW5lciwgbm8gbmVlZCB0byBlbWl0XG4gIGlmICghdGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApXG4gICAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICBlbHNlIGlmICh0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gZW1pdCByZW1vdmVMaXN0ZW5lciBmb3IgYWxsIGxpc3RlbmVycyBvbiBhbGwgZXZlbnRzXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgZm9yIChrZXkgaW4gdGhpcy5fZXZlbnRzKSB7XG4gICAgICBpZiAoa2V5ID09PSAncmVtb3ZlTGlzdGVuZXInKSBjb250aW51ZTtcbiAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGtleSk7XG4gICAgfVxuICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdyZW1vdmVMaXN0ZW5lcicpO1xuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChpc0Z1bmN0aW9uKGxpc3RlbmVycykpIHtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVycyk7XG4gIH0gZWxzZSBpZiAobGlzdGVuZXJzKSB7XG4gICAgLy8gTElGTyBvcmRlclxuICAgIHdoaWxlIChsaXN0ZW5lcnMubGVuZ3RoKVxuICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbbGlzdGVuZXJzLmxlbmd0aCAtIDFdKTtcbiAgfVxuICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciByZXQ7XG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0ID0gW107XG4gIGVsc2UgaWYgKGlzRnVuY3Rpb24odGhpcy5fZXZlbnRzW3R5cGVdKSlcbiAgICByZXQgPSBbdGhpcy5fZXZlbnRzW3R5cGVdXTtcbiAgZWxzZVxuICAgIHJldCA9IHRoaXMuX2V2ZW50c1t0eXBlXS5zbGljZSgpO1xuICByZXR1cm4gcmV0O1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24odHlwZSkge1xuICBpZiAodGhpcy5fZXZlbnRzKSB7XG4gICAgdmFyIGV2bGlzdGVuZXIgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgICBpZiAoaXNGdW5jdGlvbihldmxpc3RlbmVyKSlcbiAgICAgIHJldHVybiAxO1xuICAgIGVsc2UgaWYgKGV2bGlzdGVuZXIpXG4gICAgICByZXR1cm4gZXZsaXN0ZW5lci5sZW5ndGg7XG4gIH1cbiAgcmV0dXJuIDA7XG59O1xuXG5FdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHtcbiAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJDb3VudCh0eXBlKTtcbn07XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbiIsInZhciBidW5kbGVGbiA9IGFyZ3VtZW50c1szXTtcbnZhciBzb3VyY2VzID0gYXJndW1lbnRzWzRdO1xudmFyIGNhY2hlID0gYXJndW1lbnRzWzVdO1xuXG52YXIgc3RyaW5naWZ5ID0gSlNPTi5zdHJpbmdpZnk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGZuLCBvcHRpb25zKSB7XG4gICAgdmFyIHdrZXk7XG4gICAgdmFyIGNhY2hlS2V5cyA9IE9iamVjdC5rZXlzKGNhY2hlKTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2FjaGVLZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIga2V5ID0gY2FjaGVLZXlzW2ldO1xuICAgICAgICB2YXIgZXhwID0gY2FjaGVba2V5XS5leHBvcnRzO1xuICAgICAgICAvLyBVc2luZyBiYWJlbCBhcyBhIHRyYW5zcGlsZXIgdG8gdXNlIGVzbW9kdWxlLCB0aGUgZXhwb3J0IHdpbGwgYWx3YXlzXG4gICAgICAgIC8vIGJlIGFuIG9iamVjdCB3aXRoIHRoZSBkZWZhdWx0IGV4cG9ydCBhcyBhIHByb3BlcnR5IG9mIGl0LiBUbyBlbnN1cmVcbiAgICAgICAgLy8gdGhlIGV4aXN0aW5nIGFwaSBhbmQgYmFiZWwgZXNtb2R1bGUgZXhwb3J0cyBhcmUgYm90aCBzdXBwb3J0ZWQgd2VcbiAgICAgICAgLy8gY2hlY2sgZm9yIGJvdGhcbiAgICAgICAgaWYgKGV4cCA9PT0gZm4gfHwgZXhwICYmIGV4cC5kZWZhdWx0ID09PSBmbikge1xuICAgICAgICAgICAgd2tleSA9IGtleTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCF3a2V5KSB7XG4gICAgICAgIHdrZXkgPSBNYXRoLmZsb29yKE1hdGgucG93KDE2LCA4KSAqIE1hdGgucmFuZG9tKCkpLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgdmFyIHdjYWNoZSA9IHt9O1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNhY2hlS2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBjYWNoZUtleXNbaV07XG4gICAgICAgICAgICB3Y2FjaGVba2V5XSA9IGtleTtcbiAgICAgICAgfVxuICAgICAgICBzb3VyY2VzW3drZXldID0gW1xuICAgICAgICAgICAgRnVuY3Rpb24oWydyZXF1aXJlJywnbW9kdWxlJywnZXhwb3J0cyddLCAnKCcgKyBmbiArICcpKHNlbGYpJyksXG4gICAgICAgICAgICB3Y2FjaGVcbiAgICAgICAgXTtcbiAgICB9XG4gICAgdmFyIHNrZXkgPSBNYXRoLmZsb29yKE1hdGgucG93KDE2LCA4KSAqIE1hdGgucmFuZG9tKCkpLnRvU3RyaW5nKDE2KTtcblxuICAgIHZhciBzY2FjaGUgPSB7fTsgc2NhY2hlW3drZXldID0gd2tleTtcbiAgICBzb3VyY2VzW3NrZXldID0gW1xuICAgICAgICBGdW5jdGlvbihbJ3JlcXVpcmUnXSwgKFxuICAgICAgICAgICAgLy8gdHJ5IHRvIGNhbGwgZGVmYXVsdCBpZiBkZWZpbmVkIHRvIGFsc28gc3VwcG9ydCBiYWJlbCBlc21vZHVsZVxuICAgICAgICAgICAgLy8gZXhwb3J0c1xuICAgICAgICAgICAgJ3ZhciBmID0gcmVxdWlyZSgnICsgc3RyaW5naWZ5KHdrZXkpICsgJyk7JyArXG4gICAgICAgICAgICAnKGYuZGVmYXVsdCA/IGYuZGVmYXVsdCA6IGYpKHNlbGYpOydcbiAgICAgICAgKSksXG4gICAgICAgIHNjYWNoZVxuICAgIF07XG5cbiAgICB2YXIgd29ya2VyU291cmNlcyA9IHt9O1xuICAgIHJlc29sdmVTb3VyY2VzKHNrZXkpO1xuXG4gICAgZnVuY3Rpb24gcmVzb2x2ZVNvdXJjZXMoa2V5KSB7XG4gICAgICAgIHdvcmtlclNvdXJjZXNba2V5XSA9IHRydWU7XG5cbiAgICAgICAgZm9yICh2YXIgZGVwUGF0aCBpbiBzb3VyY2VzW2tleV1bMV0pIHtcbiAgICAgICAgICAgIHZhciBkZXBLZXkgPSBzb3VyY2VzW2tleV1bMV1bZGVwUGF0aF07XG4gICAgICAgICAgICBpZiAoIXdvcmtlclNvdXJjZXNbZGVwS2V5XSkge1xuICAgICAgICAgICAgICAgIHJlc29sdmVTb3VyY2VzKGRlcEtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgc3JjID0gJygnICsgYnVuZGxlRm4gKyAnKSh7J1xuICAgICAgICArIE9iamVjdC5rZXlzKHdvcmtlclNvdXJjZXMpLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gc3RyaW5naWZ5KGtleSkgKyAnOlsnXG4gICAgICAgICAgICAgICAgKyBzb3VyY2VzW2tleV1bMF1cbiAgICAgICAgICAgICAgICArICcsJyArIHN0cmluZ2lmeShzb3VyY2VzW2tleV1bMV0pICsgJ10nXG4gICAgICAgICAgICA7XG4gICAgICAgIH0pLmpvaW4oJywnKVxuICAgICAgICArICd9LHt9LFsnICsgc3RyaW5naWZ5KHNrZXkpICsgJ10pJ1xuICAgIDtcblxuICAgIHZhciBVUkwgPSB3aW5kb3cuVVJMIHx8IHdpbmRvdy53ZWJraXRVUkwgfHwgd2luZG93Lm1velVSTCB8fCB3aW5kb3cubXNVUkw7XG5cbiAgICB2YXIgYmxvYiA9IG5ldyBCbG9iKFtzcmNdLCB7IHR5cGU6ICd0ZXh0L2phdmFzY3JpcHQnIH0pO1xuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuYmFyZSkgeyByZXR1cm4gYmxvYjsgfVxuICAgIHZhciB3b3JrZXJVcmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuICAgIHZhciB3b3JrZXIgPSBuZXcgV29ya2VyKHdvcmtlclVybCk7XG4gICAgd29ya2VyLm9iamVjdFVSTCA9IHdvcmtlclVybDtcbiAgICByZXR1cm4gd29ya2VyO1xufTtcbiIsIi8qXG4gKiBzaW1wbGUgQUJSIENvbnRyb2xsZXJcbiAqICAtIGNvbXB1dGUgbmV4dCBsZXZlbCBiYXNlZCBvbiBsYXN0IGZyYWdtZW50IGJ3IGhldXJpc3RpY3NcbiAqICAtIGltcGxlbWVudCBhbiBhYmFuZG9uIHJ1bGVzIHRyaWdnZXJlZCBpZiB3ZSBoYXZlIGxlc3MgdGhhbiAyIGZyYWcgYnVmZmVyZWQgYW5kIGlmIGNvbXB1dGVkIGJ3IHNob3dzIHRoYXQgd2UgcmlzayBidWZmZXIgc3RhbGxpbmdcbiAqL1xuXG5pbXBvcnQgRXZlbnQgZnJvbSAnLi4vZXZlbnRzJztcbmltcG9ydCBFdmVudEhhbmRsZXIgZnJvbSAnLi4vZXZlbnQtaGFuZGxlcic7XG5pbXBvcnQgQnVmZmVySGVscGVyIGZyb20gJy4uL2hlbHBlci9idWZmZXItaGVscGVyJztcbmltcG9ydCB7RXJyb3JEZXRhaWxzfSBmcm9tICcuLi9lcnJvcnMnO1xuaW1wb3J0IHtsb2dnZXJ9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XG5pbXBvcnQgRXdtYUJhbmRXaWR0aEVzdGltYXRvciBmcm9tICcuL2V3bWEtYmFuZHdpZHRoLWVzdGltYXRvcic7XG5cbmNsYXNzIEFickNvbnRyb2xsZXIgZXh0ZW5kcyBFdmVudEhhbmRsZXIge1xuXG4gIGNvbnN0cnVjdG9yKGhscykge1xuICAgIHN1cGVyKGhscywgRXZlbnQuRlJBR19MT0FESU5HLFxuICAgICAgICAgICAgICAgRXZlbnQuRlJBR19MT0FERUQsXG4gICAgICAgICAgICAgICBFdmVudC5FUlJPUik7XG4gICAgdGhpcy5sYXN0TG9hZGVkRnJhZ0xldmVsID0gMDtcbiAgICB0aGlzLl9hdXRvTGV2ZWxDYXBwaW5nID0gLTE7XG4gICAgdGhpcy5fbmV4dEF1dG9MZXZlbCA9IC0xO1xuICAgIHRoaXMuaGxzID0gaGxzO1xuICAgIHRoaXMub25DaGVjayA9IHRoaXMuYWJhbmRvblJ1bGVzQ2hlY2suYmluZCh0aGlzKTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5jbGVhclRpbWVyKCk7XG4gICAgRXZlbnRIYW5kbGVyLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XG4gIH1cblxuICBvbkZyYWdMb2FkaW5nKGRhdGEpIHtcbiAgICBsZXQgZnJhZyA9IGRhdGEuZnJhZztcbiAgICBpZiAoZnJhZy50eXBlID09PSAnbWFpbicpIHtcbiAgICAgIGlmICghdGhpcy50aW1lcikge1xuICAgICAgICB0aGlzLnRpbWVyID0gc2V0SW50ZXJ2YWwodGhpcy5vbkNoZWNrLCAxMDApO1xuICAgICAgfVxuICAgICAgLy8gbGF6eSBpbml0IG9mIGJ3IEVzdGltYXRvciwgcmF0aW9uYWxlIGlzIHRoYXQgd2UgdXNlIGRpZmZlcmVudCBwYXJhbXMgZm9yIExpdmUvVm9EXG4gICAgICAvLyBzbyB3ZSBuZWVkIHRvIHdhaXQgZm9yIHN0cmVhbSBtYW5pZmVzdCAvIHBsYXlsaXN0IHR5cGUgdG8gaW5zdGFudGlhdGUgaXQuXG4gICAgICBpZiAoIXRoaXMuYndFc3RpbWF0b3IpIHtcbiAgICAgICAgbGV0IGhscyA9IHRoaXMuaGxzLFxuICAgICAgICAgICAgbGV2ZWwgPSBkYXRhLmZyYWcubGV2ZWwsXG4gICAgICAgICAgICBpc0xpdmUgPSBobHMubGV2ZWxzW2xldmVsXS5kZXRhaWxzLmxpdmUsXG4gICAgICAgICAgICBjb25maWcgPSBobHMuY29uZmlnLFxuICAgICAgICAgICAgZXdtYUZhc3QsIGV3bWFTbG93O1xuXG4gICAgICAgIGlmIChpc0xpdmUpIHtcbiAgICAgICAgICBld21hRmFzdCA9IGNvbmZpZy5hYnJFd21hRmFzdExpdmU7XG4gICAgICAgICAgZXdtYVNsb3cgPSBjb25maWcuYWJyRXdtYVNsb3dMaXZlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGV3bWFGYXN0ID0gY29uZmlnLmFickV3bWFGYXN0Vm9EO1xuICAgICAgICAgIGV3bWFTbG93ID0gY29uZmlnLmFickV3bWFTbG93Vm9EO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYndFc3RpbWF0b3IgPSBuZXcgRXdtYUJhbmRXaWR0aEVzdGltYXRvcihobHMsZXdtYVNsb3csZXdtYUZhc3QsY29uZmlnLmFickV3bWFEZWZhdWx0RXN0aW1hdGUpO1xuICAgICAgfVxuICAgICAgdGhpcy5mcmFnQ3VycmVudCA9IGZyYWc7XG4gICAgfVxuICB9XG5cbiAgYWJhbmRvblJ1bGVzQ2hlY2soKSB7XG4gICAgLypcbiAgICAgIG1vbml0b3IgZnJhZ21lbnQgcmV0cmlldmFsIHRpbWUuLi5cbiAgICAgIHdlIGNvbXB1dGUgZXhwZWN0ZWQgdGltZSBvZiBhcnJpdmFsIG9mIHRoZSBjb21wbGV0ZSBmcmFnbWVudC5cbiAgICAgIHdlIGNvbXBhcmUgaXQgdG8gZXhwZWN0ZWQgdGltZSBvZiBidWZmZXIgc3RhcnZhdGlvblxuICAgICovXG4gICAgbGV0IGhscyA9IHRoaXMuaGxzLCB2ID0gaGxzLm1lZGlhLGZyYWcgPSB0aGlzLmZyYWdDdXJyZW50LCBsb2FkZXIgPSBmcmFnLmxvYWRlcjtcblxuICAgIC8vIGlmIGxvYWRlciBoYXMgYmVlbiBkZXN0cm95ZWQgb3IgbG9hZGluZyBoYXMgYmVlbiBhYm9ydGVkLCBzdG9wIHRpbWVyIGFuZCByZXR1cm5cbiAgICBpZighbG9hZGVyIHx8ICggbG9hZGVyLnN0YXRzICYmIGxvYWRlci5zdGF0cy5hYm9ydGVkKSkge1xuICAgICAgbG9nZ2VyLndhcm4oYGZyYWcgbG9hZGVyIGRlc3Ryb3kgb3IgYWJvcnRlZCwgZGlzYXJtIGFiYW5kb25SdWxlc0NoZWNrYCk7XG4gICAgICB0aGlzLmNsZWFyVGltZXIoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IHN0YXRzID0gbG9hZGVyLnN0YXRzO1xuICAgIC8qIG9ubHkgbW9uaXRvciBmcmFnIHJldHJpZXZhbCB0aW1lIGlmXG4gICAgKHZpZGVvIG5vdCBwYXVzZWQgT1IgZmlyc3QgZnJhZ21lbnQgYmVpbmcgbG9hZGVkKHJlYWR5IHN0YXRlID09PSBIQVZFX05PVEhJTkcgPSAwKSkgQU5EIGF1dG9zd2l0Y2hpbmcgZW5hYmxlZCBBTkQgbm90IGxvd2VzdCBsZXZlbCAoPT4gbWVhbnMgdGhhdCB3ZSBoYXZlIHNldmVyYWwgbGV2ZWxzKSAqL1xuICAgIGlmICh2ICYmICgoIXYucGF1c2VkICYmICh2LnBsYXliYWNrUmF0ZSAhPT0gMCkpIHx8ICF2LnJlYWR5U3RhdGUpICYmIGZyYWcuYXV0b0xldmVsICYmIGZyYWcubGV2ZWwpIHtcbiAgICAgIGxldCByZXF1ZXN0RGVsYXkgPSBwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXRzLnRyZXF1ZXN0LFxuICAgICAgICAgIHBsYXliYWNrUmF0ZSA9IE1hdGguYWJzKHYucGxheWJhY2tSYXRlKTtcbiAgICAgIC8vIG1vbml0b3IgZnJhZ21lbnQgbG9hZCBwcm9ncmVzcyBhZnRlciBoYWxmIG9mIGV4cGVjdGVkIGZyYWdtZW50IGR1cmF0aW9uLHRvIHN0YWJpbGl6ZSBiaXRyYXRlXG4gICAgICBpZiAocmVxdWVzdERlbGF5ID4gKDUwMCAqIGZyYWcuZHVyYXRpb24gLyBwbGF5YmFja1JhdGUpKSB7XG4gICAgICAgIGxldCBsZXZlbHMgPSBobHMubGV2ZWxzLFxuICAgICAgICAgICAgbG9hZFJhdGUgPSBNYXRoLm1heCgxLCBzdGF0cy5idyA/IHN0YXRzLmJ3IC8gOCA6IHN0YXRzLmxvYWRlZCAqIDEwMDAgLyByZXF1ZXN0RGVsYXkpLCAvLyBieXRlL3M7IGF0IGxlYXN0IDEgYnl0ZS9zIHRvIGF2b2lkIGRpdmlzaW9uIGJ5IHplcm9cbiAgICAgICAgICAgIC8vIGNvbXB1dGUgZXhwZWN0ZWQgZnJhZ21lbnQgbGVuZ3RoIHVzaW5nIGZyYWcgZHVyYXRpb24gYW5kIGxldmVsIGJpdHJhdGUuIGFsc28gZW5zdXJlIHRoYXQgZXhwZWN0ZWQgbGVuIGlzIGd0ZSB0aGFuIGFscmVhZHkgbG9hZGVkIHNpemVcbiAgICAgICAgICAgIGV4cGVjdGVkTGVuID0gc3RhdHMudG90YWwgPyBzdGF0cy50b3RhbCA6IE1hdGgubWF4KHN0YXRzLmxvYWRlZCwgTWF0aC5yb3VuZChmcmFnLmR1cmF0aW9uICogbGV2ZWxzW2ZyYWcubGV2ZWxdLmJpdHJhdGUgLyA4KSksXG4gICAgICAgICAgICBwb3MgPSB2LmN1cnJlbnRUaW1lLFxuICAgICAgICAgICAgZnJhZ0xvYWRlZERlbGF5ID0gKGV4cGVjdGVkTGVuIC0gc3RhdHMubG9hZGVkKSAvIGxvYWRSYXRlLFxuICAgICAgICAgICAgYnVmZmVyU3RhcnZhdGlvbkRlbGF5ID0gKEJ1ZmZlckhlbHBlci5idWZmZXJJbmZvKHYscG9zLGhscy5jb25maWcubWF4QnVmZmVySG9sZSkuZW5kIC0gcG9zKSAvIHBsYXliYWNrUmF0ZTtcbiAgICAgICAgLy8gY29uc2lkZXIgZW1lcmdlbmN5IHN3aXRjaCBkb3duIG9ubHkgaWYgd2UgaGF2ZSBsZXNzIHRoYW4gMiBmcmFnIGJ1ZmZlcmVkIEFORFxuICAgICAgICAvLyB0aW1lIHRvIGZpbmlzaCBsb2FkaW5nIGN1cnJlbnQgZnJhZ21lbnQgaXMgYmlnZ2VyIHRoYW4gYnVmZmVyIHN0YXJ2YXRpb24gZGVsYXlcbiAgICAgICAgLy8gaWUgaWYgd2UgcmlzayBidWZmZXIgc3RhcnZhdGlvbiBpZiBidyBkb2VzIG5vdCBpbmNyZWFzZSBxdWlja2x5XG4gICAgICAgIGlmICgoYnVmZmVyU3RhcnZhdGlvbkRlbGF5IDwgKDIgKiBmcmFnLmR1cmF0aW9uIC8gcGxheWJhY2tSYXRlKSkgJiYgKGZyYWdMb2FkZWREZWxheSA+IGJ1ZmZlclN0YXJ2YXRpb25EZWxheSkpIHtcbiAgICAgICAgICBsZXQgZnJhZ0xldmVsTmV4dExvYWRlZERlbGF5LCBuZXh0TG9hZExldmVsO1xuICAgICAgICAgIC8vIGxldHMgaXRlcmF0ZSB0aHJvdWdoIGxvd2VyIGxldmVsIGFuZCB0cnkgdG8gZmluZCB0aGUgYmlnZ2VzdCBvbmUgdGhhdCBjb3VsZCBhdm9pZCByZWJ1ZmZlcmluZ1xuICAgICAgICAgIC8vIHdlIHN0YXJ0IGZyb20gY3VycmVudCBsZXZlbCAtIDEgYW5kIHdlIHN0ZXAgZG93biAsIHVudGlsIHdlIGZpbmQgYSBtYXRjaGluZyBsZXZlbFxuICAgICAgICAgIGZvciAobmV4dExvYWRMZXZlbCA9IGZyYWcubGV2ZWwgLSAxIDsgbmV4dExvYWRMZXZlbCA+PTAgOyBuZXh0TG9hZExldmVsLS0pIHtcbiAgICAgICAgICAgIC8vIGNvbXB1dGUgdGltZSB0byBsb2FkIG5leHQgZnJhZ21lbnQgYXQgbG93ZXIgbGV2ZWxcbiAgICAgICAgICAgIC8vIDAuOCA6IGNvbnNpZGVyIG9ubHkgODAlIG9mIGN1cnJlbnQgYncgdG8gYmUgY29uc2VydmF0aXZlXG4gICAgICAgICAgICAvLyA4ID0gYml0cyBwZXIgYnl0ZSAoYnBzL0JwcylcbiAgICAgICAgICAgIGZyYWdMZXZlbE5leHRMb2FkZWREZWxheSA9IGZyYWcuZHVyYXRpb24gKiBsZXZlbHNbbmV4dExvYWRMZXZlbF0uYml0cmF0ZSAvICg4ICogMC44ICogbG9hZFJhdGUpO1xuICAgICAgICAgICAgbG9nZ2VyLmxvZyhgZnJhZ0xvYWRlZERlbGF5L2J1ZmZlclN0YXJ2YXRpb25EZWxheS9mcmFnTGV2ZWxOZXh0TG9hZGVkRGVsYXlbJHtuZXh0TG9hZExldmVsfV0gOiR7ZnJhZ0xvYWRlZERlbGF5LnRvRml4ZWQoMSl9LyR7YnVmZmVyU3RhcnZhdGlvbkRlbGF5LnRvRml4ZWQoMSl9LyR7ZnJhZ0xldmVsTmV4dExvYWRlZERlbGF5LnRvRml4ZWQoMSl9YCk7XG4gICAgICAgICAgICBpZiAoZnJhZ0xldmVsTmV4dExvYWRlZERlbGF5IDwgYnVmZmVyU3RhcnZhdGlvbkRlbGF5KSB7XG4gICAgICAgICAgICAgIC8vIHdlIGZvdW5kIGEgbG93ZXIgbGV2ZWwgdGhhdCBiZSByZWJ1ZmZlcmluZyBmcmVlIHdpdGggY3VycmVudCBlc3RpbWF0ZWQgYncgIVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gb25seSBlbWVyZ2VuY3kgc3dpdGNoIGRvd24gaWYgaXQgdGFrZXMgbGVzcyB0aW1lIHRvIGxvYWQgbmV3IGZyYWdtZW50IGF0IGxvd2VzdCBsZXZlbCBpbnN0ZWFkXG4gICAgICAgICAgLy8gb2YgZmluaXNoaW5nIGxvYWRpbmcgY3VycmVudCBvbmUgLi4uXG4gICAgICAgICAgaWYgKGZyYWdMZXZlbE5leHRMb2FkZWREZWxheSA8IGZyYWdMb2FkZWREZWxheSkge1xuICAgICAgICAgICAgLy8gZW5zdXJlIG5leHRMb2FkTGV2ZWwgaXMgbm90IG5lZ2F0aXZlXG4gICAgICAgICAgICBuZXh0TG9hZExldmVsID0gTWF0aC5tYXgoMCxuZXh0TG9hZExldmVsKTtcbiAgICAgICAgICAgIC8vIGZvcmNlIG5leHQgbG9hZCBsZXZlbCBpbiBhdXRvIG1vZGVcbiAgICAgICAgICAgIGhscy5uZXh0TG9hZExldmVsID0gbmV4dExvYWRMZXZlbDtcbiAgICAgICAgICAgIC8vIHVwZGF0ZSBidyBlc3RpbWF0ZSBmb3IgdGhpcyBmcmFnbWVudCBiZWZvcmUgY2FuY2VsbGluZyBsb2FkICh0aGlzIHdpbGwgaGVscCByZWR1Y2luZyB0aGUgYncpXG4gICAgICAgICAgICB0aGlzLmJ3RXN0aW1hdG9yLnNhbXBsZShyZXF1ZXN0RGVsYXksc3RhdHMubG9hZGVkKTtcbiAgICAgICAgICAgIC8vIGFib3J0IGZyYWdtZW50IGxvYWRpbmcgLi4uXG4gICAgICAgICAgICBsb2dnZXIud2FybihgbG9hZGluZyB0b28gc2xvdywgYWJvcnQgZnJhZ21lbnQgbG9hZGluZyBhbmQgc3dpdGNoIHRvIGxldmVsICR7bmV4dExvYWRMZXZlbH1gKTtcbiAgICAgICAgICAgIC8vYWJvcnQgZnJhZ21lbnQgbG9hZGluZ1xuICAgICAgICAgICAgZnJhZy5sb2FkZXIuYWJvcnQoKTtcbiAgICAgICAgICAgIHRoaXMuY2xlYXJUaW1lcigpO1xuICAgICAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnQuRlJBR19MT0FEX0VNRVJHRU5DWV9BQk9SVEVELCB7ZnJhZzogZnJhZywgc3RhdHM6IHN0YXRzIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIG9uRnJhZ0xvYWRlZChkYXRhKSB7XG4gICAgbGV0IGZyYWcgPSBkYXRhLmZyYWc7XG4gICAgaWYgKGZyYWcudHlwZSA9PT0gJ21haW4nKSB7XG4gICAgICBsZXQgc3RhdHMgPSBkYXRhLnN0YXRzO1xuICAgICAgLy8gb25seSB1cGRhdGUgc3RhdHMgb24gZmlyc3QgZnJhZyBsb2FkaW5nXG4gICAgICAvLyBpZiBzYW1lIGZyYWcgaXMgbG9hZGVkIG11bHRpcGxlIHRpbWVzLCBpdCBtaWdodCBiZSBpbiBicm93c2VyIGNhY2hlLCBhbmQgbG9hZGVkIHF1aWNrbHlcbiAgICAgIC8vIGFuZCBsZWFkaW5nIHRvIHdyb25nIGJ3IGVzdGltYXRpb25cbiAgICAgIGlmIChzdGF0cy5hYm9ydGVkID09PSB1bmRlZmluZWQgJiYgZnJhZy5sb2FkQ291bnRlciA9PT0gMSkge1xuICAgICAgICBsZXQgZnJhZ0xvYWRpbmdEdXJhdGlvbk1zID0gc3RhdHMudGxvYWQgLSBzdGF0cy50cmVxdWVzdDtcbiAgICAgICAgdGhpcy5id0VzdGltYXRvci5zYW1wbGUoZnJhZ0xvYWRpbmdEdXJhdGlvbk1zLHN0YXRzLmxvYWRlZCk7XG4gICAgICAgIC8vIGlmIGZyYWdtZW50IGhhcyBiZWVuIGxvYWRlZCB0byBwZXJmb3JtIGEgYml0cmF0ZSB0ZXN0LCAoaGxzLnN0YXJ0TGV2ZWwgPSAtMSksIHN0b3JlIGJpdHJhdGUgdGVzdCBkZWxheSBkdXJhdGlvblxuICAgICAgICBpZiAoZnJhZy5iaXRyYXRlVGVzdCkge1xuICAgICAgICAgIHRoaXMuYml0cmF0ZVRlc3REZWxheSA9IGZyYWdMb2FkaW5nRHVyYXRpb25Ncy8xMDAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuYml0cmF0ZVRlc3REZWxheSA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gc3RvcCBtb25pdG9yaW5nIGJ3IG9uY2UgZnJhZyBsb2FkZWRcbiAgICAgIHRoaXMuY2xlYXJUaW1lcigpO1xuICAgICAgLy8gc3RvcmUgbGV2ZWwgaWQgYWZ0ZXIgc3VjY2Vzc2Z1bCBmcmFnbWVudCBsb2FkXG4gICAgICB0aGlzLmxhc3RMb2FkZWRGcmFnTGV2ZWwgPSBmcmFnLmxldmVsO1xuICAgICAgLy8gcmVzZXQgZm9yY2VkIGF1dG8gbGV2ZWwgdmFsdWUgc28gdGhhdCBuZXh0IGxldmVsIHdpbGwgYmUgc2VsZWN0ZWRcbiAgICAgIHRoaXMuX25leHRBdXRvTGV2ZWwgPSAtMTtcbiAgICB9XG4gIH1cblxuICBvbkVycm9yKGRhdGEpIHtcbiAgICAvLyBzdG9wIHRpbWVyIGluIGNhc2Ugb2YgZnJhZyBsb2FkaW5nIGVycm9yXG4gICAgc3dpdGNoKGRhdGEuZGV0YWlscykge1xuICAgICAgY2FzZSBFcnJvckRldGFpbHMuRlJBR19MT0FEX0VSUk9SOlxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuRlJBR19MT0FEX1RJTUVPVVQ6XG4gICAgICAgIHRoaXMuY2xlYXJUaW1lcigpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gY2xlYXJUaW1lcigpIHtcbiAgICBpZiAodGhpcy50aW1lcikge1xuICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLnRpbWVyKTtcbiAgICAgIHRoaXMudGltZXIgPSBudWxsO1xuICAgIH1cbiB9XG5cbiAgLyoqIFJldHVybiB0aGUgY2FwcGluZy9tYXggbGV2ZWwgdmFsdWUgdGhhdCBjb3VsZCBiZSB1c2VkIGJ5IGF1dG9tYXRpYyBsZXZlbCBzZWxlY3Rpb24gYWxnb3JpdGhtICoqL1xuICBnZXQgYXV0b0xldmVsQ2FwcGluZygpIHtcbiAgICByZXR1cm4gdGhpcy5fYXV0b0xldmVsQ2FwcGluZztcbiAgfVxuXG4gIC8qKiBzZXQgdGhlIGNhcHBpbmcvbWF4IGxldmVsIHZhbHVlIHRoYXQgY291bGQgYmUgdXNlZCBieSBhdXRvbWF0aWMgbGV2ZWwgc2VsZWN0aW9uIGFsZ29yaXRobSAqKi9cbiAgc2V0IGF1dG9MZXZlbENhcHBpbmcobmV3TGV2ZWwpIHtcbiAgICB0aGlzLl9hdXRvTGV2ZWxDYXBwaW5nID0gbmV3TGV2ZWw7XG4gIH1cblxuICBnZXQgbmV4dEF1dG9MZXZlbCgpIHtcbiAgICBsZXQgbmV4dEF1dG9MZXZlbCA9IHRoaXMuX25leHRBdXRvTGV2ZWwsIGJ3RXN0aW1hdG9yID0gdGhpcy5id0VzdGltYXRvcjtcbiAgICAvLyBpbiBjYXNlIG5leHQgYXV0byBsZXZlbCBoYXMgYmVlbiBmb3JjZWQsIGFuZCBidyBub3QgYXZhaWxhYmxlIG9yIG5vdCByZWxpYWJsZVxuICAgIGlmIChuZXh0QXV0b0xldmVsICE9PSAtMSAmJiAoIWJ3RXN0aW1hdG9yIHx8ICFid0VzdGltYXRvci5jYW5Fc3RpbWF0ZSgpKSkge1xuICAgICAgLy8gY2FwIG5leHQgYXV0byBsZXZlbCBieSBtYXggYXV0byBsZXZlbFxuICAgICAgcmV0dXJuIE1hdGgubWluKG5leHRBdXRvTGV2ZWwsdGhpcy5tYXhBdXRvTGV2ZWwpO1xuICAgIH1cbiAgICAvLyBjb21wdXRlIG5leHQgbGV2ZWwgdXNpbmcgQUJSIGxvZ2ljXG4gICAgbGV0IG5leHRBQlJBdXRvTGV2ZWwgPSB0aGlzLm5leHRBQlJBdXRvTGV2ZWw7XG4gICAgaWYgKG5leHRBdXRvTGV2ZWwgIT09IC0xKSB7XG4gICAgICAvLyBuZXh0QXV0b0xldmVsIGlzIGRlZmluZWQsIHVzZSBpdCB0byBjYXAgQUJSIGNvbXB1dGVkIHF1YWxpdHkgbGV2ZWxcbiAgICAgIG5leHRBQlJBdXRvTGV2ZWwgPSBNYXRoLm1pbihuZXh0QXV0b0xldmVsLG5leHRBQlJBdXRvTGV2ZWwpO1xuICAgIH1cbiAgICByZXR1cm4gbmV4dEFCUkF1dG9MZXZlbDtcbiAgfVxuXG4gIGdldCBtYXhBdXRvTGV2ZWwoKSB7XG4gICAgdmFyIGxldmVscyA9IHRoaXMuaGxzLmxldmVscyxhdXRvTGV2ZWxDYXBwaW5nID0gdGhpcy5fYXV0b0xldmVsQ2FwcGluZywgbWF4QXV0b0xldmVsO1xuICAgIGlmIChhdXRvTGV2ZWxDYXBwaW5nPT09IC0xICYmIGxldmVscyAmJiBsZXZlbHMubGVuZ3RoKSB7XG4gICAgICBtYXhBdXRvTGV2ZWwgPSBsZXZlbHMubGVuZ3RoIC0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWF4QXV0b0xldmVsID0gYXV0b0xldmVsQ2FwcGluZztcbiAgICB9XG4gICAgcmV0dXJuIG1heEF1dG9MZXZlbDtcbiAgfVxuXG4gIGdldCBuZXh0QUJSQXV0b0xldmVsKCkge1xuICAgIHZhciBobHMgPSB0aGlzLmhscywgbWF4QXV0b0xldmVsID0gdGhpcy5tYXhBdXRvTGV2ZWwsIGxldmVscyA9IGhscy5sZXZlbHMsIGNvbmZpZyA9IGhscy5jb25maWc7XG4gICAgY29uc3QgdiA9IGhscy5tZWRpYSxcbiAgICAgICAgICBjdXJyZW50TGV2ZWwgPSB0aGlzLmxhc3RMb2FkZWRGcmFnTGV2ZWwsXG4gICAgICAgICAgY3VycmVudEZyYWdEdXJhdGlvbiA9IHRoaXMuZnJhZ0N1cnJlbnQgPyB0aGlzLmZyYWdDdXJyZW50LmR1cmF0aW9uIDogMCxcbiAgICAgICAgICBwb3MgPSAodiA/IHYuY3VycmVudFRpbWUgOiAwKSxcbiAgICAgICAgICAvLyBwbGF5YmFja1JhdGUgaXMgdGhlIGFic29sdXRlIHZhbHVlIG9mIHRoZSBwbGF5YmFjayByYXRlOyBpZiB2LnBsYXliYWNrUmF0ZSBpcyAwLCB3ZSB1c2UgMSB0byBsb2FkIGFzXG4gICAgICAgICAgLy8gaWYgd2UncmUgcGxheWluZyBiYWNrIGF0IHRoZSBub3JtYWwgcmF0ZS5cbiAgICAgICAgICBwbGF5YmFja1JhdGUgPSAoKHYgJiYgKHYucGxheWJhY2tSYXRlICE9PSAwKSkgPyBNYXRoLmFicyh2LnBsYXliYWNrUmF0ZSkgOiAxLjApLFxuICAgICAgICAgIGF2Z2J3ID0gdGhpcy5id0VzdGltYXRvciA/IHRoaXMuYndFc3RpbWF0b3IuZ2V0RXN0aW1hdGUoKSA6IGNvbmZpZy5hYnJFd21hRGVmYXVsdEVzdGltYXRlLFxuICAgICAgICAgIC8vIGJ1ZmZlclN0YXJ2YXRpb25EZWxheSBpcyB0aGUgd2FsbC1jbG9jayB0aW1lIGxlZnQgdW50aWwgdGhlIHBsYXliYWNrIGJ1ZmZlciBpcyBleGhhdXN0ZWQuXG4gICAgICAgICAgYnVmZmVyU3RhcnZhdGlvbkRlbGF5ID0gKEJ1ZmZlckhlbHBlci5idWZmZXJJbmZvKHYsIHBvcywgY29uZmlnLm1heEJ1ZmZlckhvbGUpLmVuZCAtIHBvcykgLyBwbGF5YmFja1JhdGU7XG5cbiAgICAvLyBGaXJzdCwgbG9vayB0byBzZWUgaWYgd2UgY2FuIGZpbmQgYSBsZXZlbCBtYXRjaGluZyB3aXRoIG91ciBhdmcgYmFuZHdpZHRoIEFORCB0aGF0IGNvdWxkIGFsc28gZ3VhcmFudGVlIG5vIHJlYnVmZmVyaW5nIGF0IGFsbFxuICAgIGxldCBiZXN0TGV2ZWwgPSB0aGlzLmZpbmRCZXN0TGV2ZWwoY3VycmVudExldmVsLGN1cnJlbnRGcmFnRHVyYXRpb24sYXZnYncsbWF4QXV0b0xldmVsLGJ1ZmZlclN0YXJ2YXRpb25EZWxheSxjb25maWcuYWJyQmFuZFdpZHRoRmFjdG9yLGNvbmZpZy5hYnJCYW5kV2lkdGhVcEZhY3RvcixsZXZlbHMpO1xuICAgIGlmIChiZXN0TGV2ZWwgPj0gMCkge1xuICAgICAgcmV0dXJuIGJlc3RMZXZlbDtcbiAgICB9IGVsc2Uge1xuICAgICAgbG9nZ2VyLnRyYWNlKCdyZWJ1ZmZlcmluZyBleHBlY3RlZCB0byBoYXBwZW4sIGxldHMgdHJ5IHRvIGZpbmQgYSBxdWFsaXR5IGxldmVsIG1pbmltaXppbmcgdGhlIHJlYnVmZmVyaW5nJyk7XG4gICAgICAvLyBub3QgcG9zc2libGUgdG8gZ2V0IHJpZCBvZiByZWJ1ZmZlcmluZyAuLi4gbGV0J3MgdHJ5IHRvIGZpbmQgbGV2ZWwgdGhhdCB3aWxsIGd1YXJhbnRlZSBsZXNzIHRoYW4gbWF4U3RhcnZhdGlvbkRlbGF5IG9mIHJlYnVmZmVyaW5nXG4gICAgICAvLyBpZiBubyBtYXRjaGluZyBsZXZlbCBmb3VuZCwgbG9naWMgd2lsbCByZXR1cm4gMFxuICAgICAgbGV0IG1heFN0YXJ2YXRpb25EZWxheSA9IGNvbmZpZy5tYXhTdGFydmF0aW9uRGVsYXk7XG4gICAgICBpZiAoYnVmZmVyU3RhcnZhdGlvbkRlbGF5ID09PSAwKSB7XG4gICAgICAgIC8vIGluIGNhc2UgYnVmZmVyIGlzIGVtcHR5LCBsZXQncyBjaGVjayBpZiBwcmV2aW91cyBmcmFnbWVudCB3YXMgbG9hZGVkIHRvIHBlcmZvcm0gYSBiaXRyYXRlIHRlc3RcbiAgICAgICAgbGV0IGJpdHJhdGVUZXN0RGVsYXkgPSB0aGlzLmJpdHJhdGVUZXN0RGVsYXk7XG4gICAgICAgIGlmIChiaXRyYXRlVGVzdERlbGF5KSB7XG4gICAgICAgICAgLy8gaWYgaXQgaXMgdGhlIGNhc2UsIHRoZW4gd2UgbmVlZCB0byBkZWNyZWFzZSB0aGlzIGJpdHJhdGUgdGVzdCBkdXJhdGlvbiBmcm9tIG91ciBtYXhTdGFydmF0aW9uRGVsYXkuXG4gICAgICAgICAgLy8gcmF0aW9uYWxlIGlzIHRoYXQgd2UgbmVlZCB0byBhY2NvdW50IGZvciB0aGlzIGJpdHJhdGUgdGVzdCBkdXJhdGlvblxuICAgICAgICAgIG1heFN0YXJ2YXRpb25EZWxheSAtPSBiaXRyYXRlVGVzdERlbGF5O1xuICAgICAgICAgIGxvZ2dlci50cmFjZShgYml0cmF0ZSB0ZXN0IHRvb2sgJHtNYXRoLnJvdW5kKDEwMDAqYml0cmF0ZVRlc3REZWxheSl9bXMsIHNldCBmaXJzdCBmcmFnbWVudCBtYXggZmV0Y2hEdXJhdGlvbiB0byAke01hdGgucm91bmQoMTAwMCptYXhTdGFydmF0aW9uRGVsYXkpfSBtc2ApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBiZXN0TGV2ZWwgPSB0aGlzLmZpbmRCZXN0TGV2ZWwoY3VycmVudExldmVsLGN1cnJlbnRGcmFnRHVyYXRpb24sYXZnYncsbWF4QXV0b0xldmVsLGJ1ZmZlclN0YXJ2YXRpb25EZWxheSttYXhTdGFydmF0aW9uRGVsYXksY29uZmlnLmFickJhbmRXaWR0aEZhY3Rvcixjb25maWcuYWJyQmFuZFdpZHRoVXBGYWN0b3IsbGV2ZWxzKTtcbiAgICAgIHJldHVybiBNYXRoLm1heChiZXN0TGV2ZWwsMCk7XG4gICAgfVxuICB9XG5cbiAgZmluZEJlc3RMZXZlbChjdXJyZW50TGV2ZWwsY3VycmVudEZyYWdEdXJhdGlvbixjdXJyZW50QncsbWF4QXV0b0xldmVsLG1heEZldGNoRHVyYXRpb24sYndGYWN0b3IsYndVcEZhY3RvcixsZXZlbHMpIHtcbiAgICBmb3IgKGxldCBpID0gbWF4QXV0b0xldmVsOyBpID49IDA7IGktLSkge1xuICAgICAgbGV0IGxldmVsSW5mbyA9IGxldmVsc1tpXSxcbiAgICAgICAgICBsZXZlbERldGFpbHMgPSBsZXZlbEluZm8uZGV0YWlscyxcbiAgICAgICAgICBhdmdEdXJhdGlvbiA9IGxldmVsRGV0YWlscyA/IGxldmVsRGV0YWlscy50b3RhbGR1cmF0aW9uL2xldmVsRGV0YWlscy5mcmFnbWVudHMubGVuZ3RoIDogY3VycmVudEZyYWdEdXJhdGlvbixcbiAgICAgICAgICBhZGp1c3RlZGJ3O1xuICAgIC8vIGZvbGxvdyBhbGdvcml0aG0gY2FwdHVyZWQgZnJvbSBzdGFnZWZyaWdodCA6XG4gICAgLy8gaHR0cHM6Ly9hbmRyb2lkLmdvb2dsZXNvdXJjZS5jb20vcGxhdGZvcm0vZnJhbWV3b3Jrcy9hdi8rL21hc3Rlci9tZWRpYS9saWJzdGFnZWZyaWdodC9odHRwbGl2ZS9MaXZlU2Vzc2lvbi5jcHBcbiAgICAvLyBQaWNrIHRoZSBoaWdoZXN0IGJhbmR3aWR0aCBzdHJlYW0gYmVsb3cgb3IgZXF1YWwgdG8gZXN0aW1hdGVkIGJhbmR3aWR0aC5cbiAgICAvLyBjb25zaWRlciBvbmx5IDgwJSBvZiB0aGUgYXZhaWxhYmxlIGJhbmR3aWR0aCwgYnV0IGlmIHdlIGFyZSBzd2l0Y2hpbmcgdXAsXG4gICAgLy8gYmUgZXZlbiBtb3JlIGNvbnNlcnZhdGl2ZSAoNzAlKSB0byBhdm9pZCBvdmVyZXN0aW1hdGluZyBhbmQgaW1tZWRpYXRlbHlcbiAgICAvLyBzd2l0Y2hpbmcgYmFjay5cbiAgICAgIGlmIChpIDw9IGN1cnJlbnRMZXZlbCkge1xuICAgICAgICBhZGp1c3RlZGJ3ID0gYndGYWN0b3IgKiBjdXJyZW50Qnc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhZGp1c3RlZGJ3ID0gYndVcEZhY3RvciAqIGN1cnJlbnRCdztcbiAgICAgIH1cbiAgICAgIGNvbnN0IGJpdHJhdGUgPSBsZXZlbHNbaV0uYml0cmF0ZSxcbiAgICAgICAgICAgIGZldGNoRHVyYXRpb24gPSBiaXRyYXRlICogYXZnRHVyYXRpb24gLyBhZGp1c3RlZGJ3O1xuXG4gICAgbG9nZ2VyLnRyYWNlKGBsZXZlbC9hZGp1c3RlZGJ3L2JpdHJhdGUvYXZnRHVyYXRpb24vbWF4RmV0Y2hEdXJhdGlvbi9mZXRjaER1cmF0aW9uOiAke2l9LyR7TWF0aC5yb3VuZChhZGp1c3RlZGJ3KX0vJHtiaXRyYXRlfS8ke2F2Z0R1cmF0aW9ufS8ke21heEZldGNoRHVyYXRpb259LyR7ZmV0Y2hEdXJhdGlvbn1gKTtcbiAgICAgIC8vIGlmIGFkanVzdGVkIGJ3IGlzIGdyZWF0ZXIgdGhhbiBsZXZlbCBiaXRyYXRlIEFORFxuICAgICAgaWYgKGFkanVzdGVkYncgPiBiaXRyYXRlICYmXG4gICAgICAvLyBmcmFnbWVudCBmZXRjaER1cmF0aW9uIHVua25vd24gb3IgZnJhZ21lbnQgZmV0Y2hEdXJhdGlvbiBsZXNzIHRoYW4gbWF4IGFsbG93ZWQgZmV0Y2ggZHVyYXRpb24sIHRoZW4gdGhpcyBsZXZlbCBtYXRjaGVzXG4gICAgICAgICghZmV0Y2hEdXJhdGlvbiB8fMKgZmV0Y2hEdXJhdGlvbiA8IG1heEZldGNoRHVyYXRpb24pICkge1xuICAgICAgICAvLyBhcyB3ZSBhcmUgbG9vcGluZyBmcm9tIGhpZ2hlc3QgdG8gbG93ZXN0LCB0aGlzIHdpbGwgcmV0dXJuIHRoZSBiZXN0IGFjaGlldmFibGUgcXVhbGl0eSBsZXZlbFxuICAgICAgICByZXR1cm4gaTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gbm90IGVub3VnaCB0aW1lIGJ1ZGdldCBldmVuIHdpdGggcXVhbGl0eSBsZXZlbCAwIC4uLiByZWJ1ZmZlcmluZyBtaWdodCBoYXBwZW5cbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICBzZXQgbmV4dEF1dG9MZXZlbChuZXh0TGV2ZWwpIHtcbiAgICB0aGlzLl9uZXh0QXV0b0xldmVsID0gbmV4dExldmVsO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEFickNvbnRyb2xsZXI7XG5cbiIsIi8qXG4gKiBBdWRpbyBTdHJlYW0gQ29udHJvbGxlclxuKi9cblxuaW1wb3J0IEJpbmFyeVNlYXJjaCBmcm9tICcuLi91dGlscy9iaW5hcnktc2VhcmNoJztcbmltcG9ydCBCdWZmZXJIZWxwZXIgZnJvbSAnLi4vaGVscGVyL2J1ZmZlci1oZWxwZXInO1xuaW1wb3J0IERlbXV4ZXIgZnJvbSAnLi4vZGVtdXgvZGVtdXhlcic7XG5pbXBvcnQgRXZlbnQgZnJvbSAnLi4vZXZlbnRzJztcbmltcG9ydCBFdmVudEhhbmRsZXIgZnJvbSAnLi4vZXZlbnQtaGFuZGxlcic7XG5pbXBvcnQgTGV2ZWxIZWxwZXIgZnJvbSAnLi4vaGVscGVyL2xldmVsLWhlbHBlcic7XG5pbXBvcnQgVGltZVJhbmdlcyBmcm9tICcuLi91dGlscy90aW1lUmFuZ2VzJztcbmltcG9ydCB7RXJyb3JUeXBlcywgRXJyb3JEZXRhaWxzfSBmcm9tICcuLi9lcnJvcnMnO1xuaW1wb3J0IHtsb2dnZXJ9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XG5cbmNvbnN0IFN0YXRlID0ge1xuICBTVE9QUEVEIDogJ1NUT1BQRUQnLFxuICBTVEFSVElORyA6ICdTVEFSVElORycsXG4gIElETEUgOiAnSURMRScsXG4gIFBBVVNFRCA6ICdQQVVTRUQnLFxuICBLRVlfTE9BRElORyA6ICdLRVlfTE9BRElORycsXG4gIEZSQUdfTE9BRElORyA6ICdGUkFHX0xPQURJTkcnLFxuICBGUkFHX0xPQURJTkdfV0FJVElOR19SRVRSWSA6ICdGUkFHX0xPQURJTkdfV0FJVElOR19SRVRSWScsXG4gIFdBSVRJTkdfVFJBQ0sgOiAnV0FJVElOR19UUkFDSycsXG4gIFBBUlNJTkcgOiAnUEFSU0lORycsXG4gIFBBUlNFRCA6ICdQQVJTRUQnLFxuICBFTkRFRCA6ICdFTkRFRCcsXG4gIEVSUk9SIDogJ0VSUk9SJ1xufTtcblxuY2xhc3MgQXVkaW9TdHJlYW1Db250cm9sbGVyIGV4dGVuZHMgRXZlbnRIYW5kbGVyIHtcblxuICBjb25zdHJ1Y3RvcihobHMpIHtcbiAgICBzdXBlcihobHMsXG4gICAgICBFdmVudC5NRURJQV9BVFRBQ0hFRCxcbiAgICAgIEV2ZW50Lk1FRElBX0RFVEFDSElORyxcbiAgICAgIEV2ZW50LkFVRElPX1RSQUNLU19VUERBVEVELFxuICAgICAgRXZlbnQuQVVESU9fVFJBQ0tfU1dJVENILFxuICAgICAgRXZlbnQuQVVESU9fVFJBQ0tfTE9BREVELFxuICAgICAgRXZlbnQuS0VZX0xPQURFRCxcbiAgICAgIEV2ZW50LkZSQUdfTE9BREVELFxuICAgICAgRXZlbnQuRlJBR19QQVJTSU5HX0lOSVRfU0VHTUVOVCxcbiAgICAgIEV2ZW50LkZSQUdfUEFSU0lOR19EQVRBLFxuICAgICAgRXZlbnQuRlJBR19QQVJTRUQsXG4gICAgICBFdmVudC5FUlJPUixcbiAgICAgIEV2ZW50LkJVRkZFUl9DUkVBVEVELFxuICAgICAgRXZlbnQuQlVGRkVSX0FQUEVOREVELFxuICAgICAgRXZlbnQuQlVGRkVSX0ZMVVNIRUQpO1xuXG4gICAgdGhpcy5jb25maWcgPSBobHMuY29uZmlnO1xuICAgIHRoaXMuYXVkaW9Db2RlY1N3YXAgPSBmYWxzZTtcbiAgICB0aGlzLnRpY2tzID0gMDtcbiAgICB0aGlzLm9udGljayA9IHRoaXMudGljay5iaW5kKHRoaXMpO1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnN0b3BMb2FkKCk7XG4gICAgaWYgKHRoaXMudGltZXIpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy50aW1lcik7XG4gICAgICB0aGlzLnRpbWVyID0gbnVsbDtcbiAgICB9XG4gICAgRXZlbnRIYW5kbGVyLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XG4gICAgdGhpcy5zdGF0ZSA9IFN0YXRlLlNUT1BQRUQ7XG4gIH1cblxuICBzdGFydExvYWQoc3RhcnRQb3NpdGlvbikge1xuICAgIGlmICh0aGlzLnRyYWNrcykge1xuICAgICAgdmFyIG1lZGlhID0gdGhpcy5tZWRpYSwgbGFzdEN1cnJlbnRUaW1lID0gdGhpcy5sYXN0Q3VycmVudFRpbWU7XG4gICAgICB0aGlzLnN0b3BMb2FkKCk7XG4gICAgICBpZiAoIXRoaXMudGltZXIpIHtcbiAgICAgICAgdGhpcy50aW1lciA9IHNldEludGVydmFsKHRoaXMub250aWNrLCAxMDApO1xuICAgICAgfVxuICAgICAgdGhpcy5mcmFnTG9hZEVycm9yID0gMDtcbiAgICAgIGlmIChtZWRpYSAmJiBsYXN0Q3VycmVudFRpbWUpIHtcbiAgICAgICAgbG9nZ2VyLmxvZyhgY29uZmlndXJlIHN0YXJ0UG9zaXRpb24gQCR7bGFzdEN1cnJlbnRUaW1lfWApO1xuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubGFzdEN1cnJlbnRUaW1lID0gdGhpcy5zdGFydFBvc2l0aW9uID8gdGhpcy5zdGFydFBvc2l0aW9uIDogc3RhcnRQb3NpdGlvbjtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLlNUQVJUSU5HO1xuICAgICAgfVxuICAgICAgdGhpcy5uZXh0TG9hZFBvc2l0aW9uID0gdGhpcy5zdGFydFBvc2l0aW9uID0gdGhpcy5sYXN0Q3VycmVudFRpbWU7XG4gICAgICB0aGlzLnRpY2soKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zdGFydFBvc2l0aW9uID0gc3RhcnRQb3NpdGlvbjtcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5TVE9QUEVEO1xuICAgIH1cbiAgfVxuXG4gIHN0b3BMb2FkKCkge1xuICAgIHZhciBmcmFnID0gdGhpcy5mcmFnQ3VycmVudDtcbiAgICBpZiAoZnJhZykge1xuICAgICAgaWYgKGZyYWcubG9hZGVyKSB7XG4gICAgICAgIGZyYWcubG9hZGVyLmFib3J0KCk7XG4gICAgICB9XG4gICAgICB0aGlzLmZyYWdDdXJyZW50ID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5mcmFnUHJldmlvdXMgPSBudWxsO1xuICAgIGlmICh0aGlzLmRlbXV4ZXIpIHtcbiAgICAgIHRoaXMuZGVtdXhlci5kZXN0cm95KCk7XG4gICAgICB0aGlzLmRlbXV4ZXIgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLnN0YXRlID0gU3RhdGUuU1RPUFBFRDtcbiAgfVxuXG4gIHRpY2soKSB7XG4gICAgdGhpcy50aWNrcysrO1xuICAgIGlmICh0aGlzLnRpY2tzID09PSAxKSB7XG4gICAgICB0aGlzLmRvVGljaygpO1xuICAgICAgaWYgKHRoaXMudGlja3MgPiAxKSB7XG4gICAgICAgIHNldFRpbWVvdXQodGhpcy50aWNrLCAxKTtcbiAgICAgIH1cbiAgICAgIHRoaXMudGlja3MgPSAwO1xuICAgIH1cbiAgfVxuXG4gIGRvVGljaygpIHtcbiAgICB2YXIgcG9zLCB0cmFjaywgdHJhY2tEZXRhaWxzLCBobHMgPSB0aGlzLmhscywgY29uZmlnID0gaGxzLmNvbmZpZztcbiAgICAvL2xvZ2dlci5sb2coJ2F1ZGlvU3RyZWFtOicgKyB0aGlzLnN0YXRlKTtcbiAgICBzd2l0Y2godGhpcy5zdGF0ZSkge1xuICAgICAgY2FzZSBTdGF0ZS5FUlJPUjpcbiAgICAgICAgLy9kb24ndCBkbyBhbnl0aGluZyBpbiBlcnJvciBzdGF0ZSB0byBhdm9pZCBicmVha2luZyBmdXJ0aGVyIC4uLlxuICAgICAgY2FzZSBTdGF0ZS5QQVVTRUQ6XG4gICAgICAgIC8vZG9uJ3QgZG8gYW55dGhpbmcgaW4gcGF1c2VkIHN0YXRlIGVpdGhlciAuLi5cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFN0YXRlLlNUQVJUSU5HOlxuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuV0FJVElOR19UUkFDSztcbiAgICAgICAgdGhpcy5sb2FkZWRtZXRhZGF0YSA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgU3RhdGUuSURMRTpcbiAgICAgICAgLy8gaWYgdmlkZW8gbm90IGF0dGFjaGVkIEFORFxuICAgICAgICAvLyBzdGFydCBmcmFnbWVudCBhbHJlYWR5IHJlcXVlc3RlZCBPUiBzdGFydCBmcmFnIHByZWZldGNoIGRpc2FibGVcbiAgICAgICAgLy8gZXhpdCBsb29wXG4gICAgICAgIC8vID0+IGlmIG1lZGlhIG5vdCBhdHRhY2hlZCBidXQgc3RhcnQgZnJhZyBwcmVmZXRjaCBpcyBlbmFibGVkIGFuZCBzdGFydCBmcmFnIG5vdCByZXF1ZXN0ZWQgeWV0LCB3ZSB3aWxsIG5vdCBleGl0IGxvb3BcbiAgICAgICAgaWYgKCF0aGlzLm1lZGlhICYmXG4gICAgICAgICAgKHRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkIHx8ICFjb25maWcuc3RhcnRGcmFnUHJlZmV0Y2gpKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZGV0ZXJtaW5lIG5leHQgY2FuZGlkYXRlIGZyYWdtZW50IHRvIGJlIGxvYWRlZCwgYmFzZWQgb24gY3VycmVudCBwb3NpdGlvbiBhbmRcbiAgICAgICAgLy8gIGVuZCBvZiBidWZmZXIgcG9zaXRpb25cbiAgICAgICAgLy8gaWYgd2UgaGF2ZSBub3QgeWV0IGxvYWRlZCBhbnkgZnJhZ21lbnQsIHN0YXJ0IGxvYWRpbmcgZnJvbSBzdGFydCBwb3NpdGlvblxuICAgICAgICBpZiAodGhpcy5sb2FkZWRtZXRhZGF0YSkge1xuICAgICAgICAgIHBvcyA9IHRoaXMubWVkaWEuY3VycmVudFRpbWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcG9zID0gdGhpcy5uZXh0TG9hZFBvc2l0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGxldCBtZWRpYSA9IHRoaXMubWVkaWFCdWZmZXIgPyB0aGlzLm1lZGlhQnVmZmVyIDogdGhpcy5tZWRpYTtcbiAgICAgICAgdmFyIGJ1ZmZlckluZm8gPSBCdWZmZXJIZWxwZXIuYnVmZmVySW5mbyhtZWRpYSxwb3MsY29uZmlnLm1heEJ1ZmZlckhvbGUpLFxuICAgICAgICAgICAgYnVmZmVyTGVuID0gYnVmZmVySW5mby5sZW4sXG4gICAgICAgICAgICBidWZmZXJFbmQgPSBidWZmZXJJbmZvLmVuZCxcbiAgICAgICAgICAgIGZyYWdQcmV2aW91cyA9IHRoaXMuZnJhZ1ByZXZpb3VzLFxuICAgICAgICAgICAgbWF4QnVmTGVuID0gY29uZmlnLm1heE1heEJ1ZmZlckxlbmd0aDtcblxuICAgICAgICAvLyBpZiBidWZmZXIgbGVuZ3RoIGlzIGxlc3MgdGhhbiBtYXhCdWZMZW4gdHJ5IHRvIGxvYWQgYSBuZXcgZnJhZ21lbnRcbiAgICAgICAgaWYgKGJ1ZmZlckxlbiA8IG1heEJ1ZkxlbiAmJiB0aGlzLnRyYWNrSWQgPCB0aGlzLnRyYWNrcy5sZW5ndGgpIHtcbiAgICAgICAgICB0cmFja0RldGFpbHMgPSB0aGlzLnRyYWNrc1t0aGlzLnRyYWNrSWRdLmRldGFpbHM7XG4gICAgICAgICAgLy8gaWYgdHJhY2sgaW5mbyBub3QgcmV0cmlldmVkIHlldCwgc3dpdGNoIHN0YXRlIGFuZCB3YWl0IGZvciB0cmFjayByZXRyaWV2YWxcbiAgICAgICAgICBpZiAodHlwZW9mIHRyYWNrRGV0YWlscyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5XQUlUSU5HX1RSQUNLO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIC8vIHdlIGp1c3QgZ290IGRvbmUgbG9hZGluZyB0aGUgZmluYWwgZnJhZ21lbnQsIGNoZWNrIGlmIHdlIG5lZWQgdG8gZmluYWxpemUgbWVkaWEgc3RyZWFtXG4gICAgICAgIGlmICghdHJhY2tEZXRhaWxzLmxpdmUgJiYgZnJhZ1ByZXZpb3VzICYmIGZyYWdQcmV2aW91cy5zbiA9PT0gdHJhY2tEZXRhaWxzLmVuZFNOKSB7XG4gICAgICAgICAgICAvLyBpZiB3ZSBhcmUgbm90IHNlZWtpbmcgb3IgaWYgd2UgYXJlIHNlZWtpbmcgYnV0IGV2ZXJ5dGhpbmcgKGFsbW9zdCkgdGlsIHRoZSBlbmQgaXMgYnVmZmVyZWQsIGxldCdzIHNpZ25hbCBlb3NcbiAgICAgICAgICAgIC8vIHdlIGRvbid0IGNvbXBhcmUgZXhhY3RseSBtZWRpYS5kdXJhdGlvbiA9PT0gYnVmZmVySW5mby5lbmQgYXMgdGhlcmUgY291bGQgYmUgc29tZSBzdWJ0bGUgbWVkaWEgZHVyYXRpb24gZGlmZmVyZW5jZSB3aGVuIHN3aXRjaGluZ1xuICAgICAgICAgICAgLy8gYmV0d2VlbiBkaWZmZXJlbnQgcmVuZGl0aW9ucy4gdXNpbmcgaGFsZiBmcmFnIGR1cmF0aW9uIHNob3VsZCBoZWxwIGNvcGUgd2l0aCB0aGVzZSBjYXNlcy5cbiAgICAgICAgICAgIGlmICghdGhpcy5tZWRpYS5zZWVraW5nIHx8ICh0aGlzLm1lZGlhLmR1cmF0aW9uLWJ1ZmZlckVuZCkgPCBmcmFnUHJldmlvdXMuZHVyYXRpb24vMikge1xuICAgICAgICAgICAgLy8gRmluYWxpemUgdGhlIG1lZGlhIHN0cmVhbVxuICAgICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5CVUZGRVJfRU9TLHsgdHlwZSA6ICdhdWRpbyd9KTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5FTkRFRDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgICAgLy8gZmluZCBmcmFnbWVudCBpbmRleCwgY29udGlndW91cyB3aXRoIGVuZCBvZiBidWZmZXIgcG9zaXRpb25cbiAgICAgICAgICBsZXQgZnJhZ21lbnRzID0gdHJhY2tEZXRhaWxzLmZyYWdtZW50cyxcbiAgICAgICAgICAgICAgZnJhZ0xlbiA9IGZyYWdtZW50cy5sZW5ndGgsXG4gICAgICAgICAgICAgIHN0YXJ0ID0gZnJhZ21lbnRzWzBdLnN0YXJ0LFxuICAgICAgICAgICAgICBlbmQgPSBmcmFnbWVudHNbZnJhZ0xlbi0xXS5zdGFydCArIGZyYWdtZW50c1tmcmFnTGVuLTFdLmR1cmF0aW9uLFxuICAgICAgICAgICAgICBmcmFnO1xuXG4gICAgICAgICAgLy8gaWYgYnVmZmVyRW5kIGJlZm9yZSBzdGFydCBvZiBwbGF5bGlzdCwgbG9hZCBmaXJzdCBmcmFnbWVudFxuICAgICAgICAgIGlmIChidWZmZXJFbmQgPCBzdGFydCkge1xuICAgICAgICAgICAgZnJhZyA9IGZyYWdtZW50c1swXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IGZvdW5kRnJhZztcbiAgICAgICAgICAgIGxldCBtYXhGcmFnTG9va1VwVG9sZXJhbmNlID0gY29uZmlnLm1heEZyYWdMb29rVXBUb2xlcmFuY2U7XG4gICAgICAgICAgICBpZiAoYnVmZmVyRW5kIDwgZW5kKSB7XG4gICAgICAgICAgICAgIGlmIChidWZmZXJFbmQgPiBlbmQgLSBtYXhGcmFnTG9va1VwVG9sZXJhbmNlKSB7XG4gICAgICAgICAgICAgICAgbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSA9IDA7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZm91bmRGcmFnID0gQmluYXJ5U2VhcmNoLnNlYXJjaChmcmFnbWVudHMsIChjYW5kaWRhdGUpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBvZmZzZXQgc2hvdWxkIGJlIHdpdGhpbiBmcmFnbWVudCBib3VuZGFyeSAtIGNvbmZpZy5tYXhGcmFnTG9va1VwVG9sZXJhbmNlXG4gICAgICAgICAgICAgICAgLy8gdGhpcyBpcyB0byBjb3BlIHdpdGggc2l0dWF0aW9ucyBsaWtlXG4gICAgICAgICAgICAgICAgLy8gYnVmZmVyRW5kID0gOS45OTFcbiAgICAgICAgICAgICAgICAvLyBmcmFnW8OYXSA6IFswLDEwXVxuICAgICAgICAgICAgICAgIC8vIGZyYWdbMV0gOiBbMTAsMjBdXG4gICAgICAgICAgICAgICAgLy8gYnVmZmVyRW5kIGlzIHdpdGhpbiBmcmFnWzBdIHJhbmdlIC4uLiBhbHRob3VnaCB3aGF0IHdlIGFyZSBleHBlY3RpbmcgaXMgdG8gcmV0dXJuIGZyYWdbMV0gaGVyZVxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgZnJhZyBzdGFydCAgICAgICAgICAgICAgIGZyYWcgc3RhcnQrZHVyYXRpb25cbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgICB8LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18XG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICA8LS0tPiAgICAgICAgICAgICAgICAgICAgICAgICA8LS0tPlxuICAgICAgICAgICAgICAgICAgICAvLyAgLi4uLS0tLS0tLS0+PC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tPjwtLS0tLS0tLS0uLi4uXG4gICAgICAgICAgICAgICAgICAgIC8vIHByZXZpb3VzIGZyYWcgICAgICAgICBtYXRjaGluZyBmcmFnbWVudCAgICAgICAgIG5leHQgZnJhZ1xuICAgICAgICAgICAgICAgICAgICAvLyAgcmV0dXJuIC0xICAgICAgICAgICAgIHJldHVybiAwICAgICAgICAgICAgICAgICByZXR1cm4gMVxuICAgICAgICAgICAgICAgIC8vbG9nZ2VyLmxvZyhgbGV2ZWwvc24vc3RhcnQvZW5kL2J1ZkVuZDoke2xldmVsfS8ke2NhbmRpZGF0ZS5zbn0vJHtjYW5kaWRhdGUuc3RhcnR9LyR7KGNhbmRpZGF0ZS5zdGFydCtjYW5kaWRhdGUuZHVyYXRpb24pfS8ke2J1ZmZlckVuZH1gKTtcbiAgICAgICAgICAgICAgICBpZiAoKGNhbmRpZGF0ZS5zdGFydCArIGNhbmRpZGF0ZS5kdXJhdGlvbiAtIG1heEZyYWdMb29rVXBUb2xlcmFuY2UpIDw9IGJ1ZmZlckVuZCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNhbmRpZGF0ZS5zdGFydCAtIG1heEZyYWdMb29rVXBUb2xlcmFuY2UgPiBidWZmZXJFbmQpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gcmVhY2ggZW5kIG9mIHBsYXlsaXN0XG4gICAgICAgICAgICAgIGZvdW5kRnJhZyA9IGZyYWdtZW50c1tmcmFnTGVuLTFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZvdW5kRnJhZykge1xuICAgICAgICAgICAgICBmcmFnID0gZm91bmRGcmFnO1xuICAgICAgICAgICAgICBzdGFydCA9IGZvdW5kRnJhZy5zdGFydDtcbiAgICAgICAgICAgICAgLy9sb2dnZXIubG9nKCdmaW5kIFNOIG1hdGNoaW5nIHdpdGggcG9zOicgKyAgYnVmZmVyRW5kICsgJzonICsgZnJhZy5zbik7XG4gICAgICAgICAgICAgIGlmIChmcmFnUHJldmlvdXMgJiYgZnJhZy5sZXZlbCA9PT0gZnJhZ1ByZXZpb3VzLmxldmVsICYmIGZyYWcuc24gPT09IGZyYWdQcmV2aW91cy5zbikge1xuICAgICAgICAgICAgICAgIGlmIChmcmFnLnNuIDwgdHJhY2tEZXRhaWxzLmVuZFNOKSB7XG4gICAgICAgICAgICAgICAgICBmcmFnID0gZnJhZ21lbnRzW2ZyYWcuc24gKyAxIC0gdHJhY2tEZXRhaWxzLnN0YXJ0U05dO1xuICAgICAgICAgICAgICAgICAgbG9nZ2VyLmxvZyhgU04ganVzdCBsb2FkZWQsIGxvYWQgbmV4dCBvbmU6ICR7ZnJhZy5zbn1gKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgZnJhZyA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmKGZyYWcpIHtcbiAgICAgICAgICAgIC8vbG9nZ2VyLmxvZygnICAgICAgbG9hZGluZyBmcmFnICcgKyBpICsnLHBvcy9idWZFbmQ6JyArIHBvcy50b0ZpeGVkKDMpICsgJy8nICsgYnVmZmVyRW5kLnRvRml4ZWQoMykpO1xuICAgICAgICAgICAgaWYgKChmcmFnLmRlY3J5cHRkYXRhLnVyaSAhPSBudWxsKSAmJiAoZnJhZy5kZWNyeXB0ZGF0YS5rZXkgPT0gbnVsbCkpIHtcbiAgICAgICAgICAgICAgbG9nZ2VyLmxvZyhgTG9hZGluZyBrZXkgZm9yICR7ZnJhZy5zbn0gb2YgWyR7dHJhY2tEZXRhaWxzLnN0YXJ0U059ICwke3RyYWNrRGV0YWlscy5lbmRTTn1dLHRyYWNrICR7dGhpcy50cmFja0lkfWApO1xuICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuS0VZX0xPQURJTkc7XG4gICAgICAgICAgICAgIGhscy50cmlnZ2VyKEV2ZW50LktFWV9MT0FESU5HLCB7ZnJhZzogZnJhZ30pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbG9nZ2VyLmxvZyhgTG9hZGluZyAke2ZyYWcuc259IG9mIFske3RyYWNrRGV0YWlscy5zdGFydFNOfSAsJHt0cmFja0RldGFpbHMuZW5kU059XSx0cmFjayAke3RoaXMudHJhY2tJZH0sIGN1cnJlbnRUaW1lOiR7cG9zfSxidWZmZXJFbmQ6JHtidWZmZXJFbmQudG9GaXhlZCgzKX1gKTtcbiAgICAgICAgICAgICAgLy8gZW5zdXJlIHRoYXQgd2UgYXJlIG5vdCByZWxvYWRpbmcgdGhlIHNhbWUgZnJhZ21lbnRzIGluIGxvb3AgLi4uXG4gICAgICAgICAgICAgIGlmICh0aGlzLmZyYWdMb2FkSWR4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZyYWdMb2FkSWR4Kys7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mcmFnTG9hZElkeCA9IDA7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGZyYWcubG9hZENvdW50ZXIpIHtcbiAgICAgICAgICAgICAgICBmcmFnLmxvYWRDb3VudGVyKys7XG4gICAgICAgICAgICAgICAgbGV0IG1heFRocmVzaG9sZCA9IGNvbmZpZy5mcmFnTG9hZGluZ0xvb3BUaHJlc2hvbGQ7XG4gICAgICAgICAgICAgICAgLy8gaWYgdGhpcyBmcmFnIGhhcyBhbHJlYWR5IGJlZW4gbG9hZGVkIDMgdGltZXMsIGFuZCBpZiBpdCBoYXMgYmVlbiByZWxvYWRlZCByZWNlbnRseVxuICAgICAgICAgICAgICAgIGlmIChmcmFnLmxvYWRDb3VudGVyID4gbWF4VGhyZXNob2xkICYmIChNYXRoLmFicyh0aGlzLmZyYWdMb2FkSWR4IC0gZnJhZy5sb2FkSWR4KSA8IG1heFRocmVzaG9sZCkpIHtcbiAgICAgICAgICAgICAgICAgIGhscy50cmlnZ2VyKEV2ZW50LkVSUk9SLCB7dHlwZTogRXJyb3JUeXBlcy5NRURJQV9FUlJPUiwgZGV0YWlsczogRXJyb3JEZXRhaWxzLkZSQUdfTE9PUF9MT0FESU5HX0VSUk9SLCBmYXRhbDogZmFsc2UsIGZyYWc6IGZyYWd9KTtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZnJhZy5sb2FkQ291bnRlciA9IDE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZnJhZy5sb2FkSWR4ID0gdGhpcy5mcmFnTG9hZElkeDtcbiAgICAgICAgICAgICAgdGhpcy5mcmFnQ3VycmVudCA9IGZyYWc7XG4gICAgICAgICAgICAgIHRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnQuRlJBR19MT0FESU5HLCB7ZnJhZzogZnJhZ30pO1xuICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuRlJBR19MT0FESU5HO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgU3RhdGUuV0FJVElOR19UUkFDSzpcbiAgICAgICAgdHJhY2sgPSB0aGlzLnRyYWNrc1t0aGlzLnRyYWNrSWRdO1xuICAgICAgICAvLyBjaGVjayBpZiBwbGF5bGlzdCBpcyBhbHJlYWR5IGxvYWRlZFxuICAgICAgICBpZiAodHJhY2sgJiYgdHJhY2suZGV0YWlscykge1xuICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBTdGF0ZS5GUkFHX0xPQURJTkdfV0FJVElOR19SRVRSWTpcbiAgICAgICAgdmFyIG5vdyA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICB2YXIgcmV0cnlEYXRlID0gdGhpcy5yZXRyeURhdGU7XG4gICAgICAgIG1lZGlhID0gdGhpcy5tZWRpYTtcbiAgICAgICAgdmFyIGlzU2Vla2luZyA9IG1lZGlhICYmIG1lZGlhLnNlZWtpbmc7XG4gICAgICAgIC8vIGlmIGN1cnJlbnQgdGltZSBpcyBndCB0aGFuIHJldHJ5RGF0ZSwgb3IgaWYgbWVkaWEgc2Vla2luZyBsZXQncyBzd2l0Y2ggdG8gSURMRSBzdGF0ZSB0byByZXRyeSBsb2FkaW5nXG4gICAgICAgIGlmKCFyZXRyeURhdGUgfHwgKG5vdyA+PSByZXRyeURhdGUpIHx8IGlzU2Vla2luZykge1xuICAgICAgICAgIGxvZ2dlci5sb2coYGF1ZGlvU3RyZWFtQ29udHJvbGxlcjogcmV0cnlEYXRlIHJlYWNoZWQsIHN3aXRjaCBiYWNrIHRvIElETEUgc3RhdGVgKTtcbiAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgU3RhdGUuU1RPUFBFRDpcbiAgICAgIGNhc2UgU3RhdGUuRlJBR19MT0FESU5HOlxuICAgICAgY2FzZSBTdGF0ZS5QQVJTSU5HOlxuICAgICAgY2FzZSBTdGF0ZS5QQVJTRUQ6XG4gICAgICBjYXNlIFN0YXRlLkVOREVEOlxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIG9uTWVkaWFBdHRhY2hlZChkYXRhKSB7XG4gICAgdmFyIG1lZGlhID0gdGhpcy5tZWRpYSA9IHRoaXMubWVkaWFCdWZmZXIgPSBkYXRhLm1lZGlhO1xuICAgIHRoaXMub252c2Vla2luZyA9IHRoaXMub25NZWRpYVNlZWtpbmcuYmluZCh0aGlzKTtcbiAgICB0aGlzLm9udmVuZGVkID0gdGhpcy5vbk1lZGlhRW5kZWQuYmluZCh0aGlzKTtcbiAgICBtZWRpYS5hZGRFdmVudExpc3RlbmVyKCdzZWVraW5nJywgdGhpcy5vbnZzZWVraW5nKTtcbiAgICBtZWRpYS5hZGRFdmVudExpc3RlbmVyKCdlbmRlZCcsIHRoaXMub252ZW5kZWQpO1xuICAgIGxldCBjb25maWcgPSB0aGlzLmNvbmZpZztcbiAgICBpZih0aGlzLnRyYWNrcyAmJiBjb25maWcuYXV0b1N0YXJ0TG9hZCkge1xuICAgICAgdGhpcy5zdGFydExvYWQoY29uZmlnLnN0YXJ0UG9zaXRpb24pO1xuICAgIH1cbiAgfVxuXG4gIG9uTWVkaWFEZXRhY2hpbmcoKSB7XG4gICAgdmFyIG1lZGlhID0gdGhpcy5tZWRpYTtcbiAgICBpZiAobWVkaWEgJiYgbWVkaWEuZW5kZWQpIHtcbiAgICAgIGxvZ2dlci5sb2coJ01TRSBkZXRhY2hpbmcgYW5kIHZpZGVvIGVuZGVkLCByZXNldCBzdGFydFBvc2l0aW9uJyk7XG4gICAgICB0aGlzLnN0YXJ0UG9zaXRpb24gPSB0aGlzLmxhc3RDdXJyZW50VGltZSA9IDA7XG4gICAgfVxuXG4gICAgLy8gcmVzZXQgZnJhZ21lbnQgbG9hZGluZyBjb3VudGVyIG9uIE1TRSBkZXRhY2hpbmcgdG8gYXZvaWQgcmVwb3J0aW5nIEZSQUdfTE9PUF9MT0FESU5HX0VSUk9SIGFmdGVyIGVycm9yIHJlY292ZXJ5XG4gICAgdmFyIHRyYWNrcyA9IHRoaXMudHJhY2tzO1xuICAgIGlmICh0cmFja3MpIHtcbiAgICAgIC8vIHJlc2V0IGZyYWdtZW50IGxvYWQgY291bnRlclxuICAgICAgICB0cmFja3MuZm9yRWFjaCh0cmFjayA9PiB7XG4gICAgICAgICAgaWYodHJhY2suZGV0YWlscykge1xuICAgICAgICAgICAgdHJhY2suZGV0YWlscy5mcmFnbWVudHMuZm9yRWFjaChmcmFnbWVudCA9PiB7XG4gICAgICAgICAgICAgIGZyYWdtZW50LmxvYWRDb3VudGVyID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIC8vIHJlbW92ZSB2aWRlbyBsaXN0ZW5lcnNcbiAgICBpZiAobWVkaWEpIHtcbiAgICAgIG1lZGlhLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3NlZWtpbmcnLCB0aGlzLm9udnNlZWtpbmcpO1xuICAgICAgbWVkaWEucmVtb3ZlRXZlbnRMaXN0ZW5lcignZW5kZWQnLCB0aGlzLm9udmVuZGVkKTtcbiAgICAgIHRoaXMub252c2Vla2luZyA9IHRoaXMub252c2Vla2VkICA9IHRoaXMub252ZW5kZWQgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLm1lZGlhID0gbnVsbDtcbiAgICB0aGlzLmxvYWRlZG1ldGFkYXRhID0gZmFsc2U7XG4gICAgdGhpcy5zdG9wTG9hZCgpO1xuICB9XG5cbiAgb25NZWRpYVNlZWtpbmcoKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLkVOREVEKSB7XG4gICAgICAgIC8vIHN3aXRjaCB0byBJRExFIHN0YXRlIHRvIGNoZWNrIGZvciBwb3RlbnRpYWwgbmV3IGZyYWdtZW50XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgIH1cbiAgICBpZiAodGhpcy5tZWRpYSkge1xuICAgICAgdGhpcy5sYXN0Q3VycmVudFRpbWUgPSB0aGlzLm1lZGlhLmN1cnJlbnRUaW1lO1xuICAgIH1cbiAgICAvLyBhdm9pZCByZXBvcnRpbmcgZnJhZ21lbnQgbG9vcCBsb2FkaW5nIGVycm9yIGluIGNhc2UgdXNlciBpcyBzZWVraW5nIHNldmVyYWwgdGltZXMgb24gc2FtZSBwb3NpdGlvblxuICAgIGlmICh0aGlzLmZyYWdMb2FkSWR4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuZnJhZ0xvYWRJZHggKz0gMiAqIHRoaXMuY29uZmlnLmZyYWdMb2FkaW5nTG9vcFRocmVzaG9sZDtcbiAgICB9XG4gICAgLy8gdGljayB0byBzcGVlZCB1cCBwcm9jZXNzaW5nXG4gICAgdGhpcy50aWNrKCk7XG4gIH1cblxuICBvbk1lZGlhRW5kZWQoKSB7XG4gICAgLy8gcmVzZXQgc3RhcnRQb3NpdGlvbiBhbmQgbGFzdEN1cnJlbnRUaW1lIHRvIHJlc3RhcnQgcGxheWJhY2sgQCBzdHJlYW0gYmVnaW5uaW5nXG4gICAgdGhpcy5zdGFydFBvc2l0aW9uID0gdGhpcy5sYXN0Q3VycmVudFRpbWUgPSAwO1xuICB9XG5cblxuICBvbkF1ZGlvVHJhY2tzVXBkYXRlZChkYXRhKSB7XG4gICAgbG9nZ2VyLmxvZygnYXVkaW8gdHJhY2tzIHVwZGF0ZWQnKTtcbiAgICB0aGlzLnRyYWNrcyA9IGRhdGEuYXVkaW9UcmFja3M7XG4gIH1cblxuICBvbkF1ZGlvVHJhY2tTd2l0Y2goZGF0YSkge1xuICAgIC8vIGlmIGFueSBVUkwgZm91bmQgb24gbmV3IGF1ZGlvIHRyYWNrLCBpdCBpcyBhbiBhbHRlcm5hdGUgYXVkaW8gdHJhY2tcbiAgICB2YXIgYWx0QXVkaW8gPSAhIWRhdGEudXJsO1xuICAgIHRoaXMudHJhY2tJZCA9IGRhdGEuaWQ7XG4gICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG5cbiAgICB0aGlzLmZyYWdDdXJyZW50ID0gbnVsbDtcbiAgICB0aGlzLnN0YXRlID0gU3RhdGUuUEFVU0VEO1xuICAgIC8vIGRlc3Ryb3kgdXNlbGVzcyBkZW11eGVyIHdoZW4gc3dpdGNoaW5nIGF1ZGlvIHRvIG1haW5cbiAgICBpZiAoIWFsdEF1ZGlvKSB7XG4gICAgICBpZiAodGhpcy5kZW11eGVyKSB7XG4gICAgICAgIHRoaXMuZGVtdXhlci5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuZGVtdXhlciA9IG51bGw7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHN3aXRjaGluZyB0byBhdWRpbyB0cmFjaywgc3RhcnQgdGltZXIgaWYgbm90IGFscmVhZHkgc3RhcnRlZFxuICAgICAgaWYgKCF0aGlzLnRpbWVyKSB7XG4gICAgICAgIHRoaXMudGltZXIgPSBzZXRJbnRlcnZhbCh0aGlzLm9udGljaywgMTAwKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gZmx1c2ggYXVkaW8gc291cmNlIGJ1ZmZlclxuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuQlVGRkVSX0ZMVVNISU5HLCB7c3RhcnRPZmZzZXQ6IDAsIGVuZE9mZnNldDogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLCB0eXBlIDogJ2F1ZGlvJ30pO1xuICAgIHRoaXMudGljaygpO1xuICB9XG5cbiAgb25BdWRpb1RyYWNrTG9hZGVkKGRhdGEpIHtcbiAgICB2YXIgZGV0YWlscyA9IGRhdGEuZGV0YWlscyxcbiAgICAgICAgdHJhY2tJZCA9IGRhdGEuaWQsXG4gICAgICAgIHRyYWNrID0gdGhpcy50cmFja3NbdHJhY2tJZF0sXG4gICAgICAgIGR1cmF0aW9uID0gZGV0YWlscy50b3RhbGR1cmF0aW9uO1xuXG4gICAgbG9nZ2VyLmxvZyhgdHJhY2sgJHt0cmFja0lkfSBsb2FkZWQgWyR7ZGV0YWlscy5zdGFydFNOfSwke2RldGFpbHMuZW5kU059XSxkdXJhdGlvbjoke2R1cmF0aW9ufWApO1xuICAgIGRldGFpbHMuUFRTS25vd24gPSBmYWxzZTtcbiAgICB0cmFjay5kZXRhaWxzID0gZGV0YWlscztcblxuICAgIC8vIGNvbXB1dGUgc3RhcnQgcG9zaXRpb25cbiAgICBpZiAoIXRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkKSB7XG4gICAgLy8gY29tcHV0ZSBzdGFydCBwb3NpdGlvbiBpZiBzZXQgdG8gLTEuIHVzZSBpdCBzdHJhaWdodCBhd2F5IGlmIHZhbHVlIGlzIGRlZmluZWRcbiAgICAgIGlmICh0aGlzLnN0YXJ0UG9zaXRpb24gPT09IC0xKSB7XG4gICAgICAgIC8vIGZpcnN0LCBjaGVjayBpZiBzdGFydCB0aW1lIG9mZnNldCBoYXMgYmVlbiBzZXQgaW4gcGxheWxpc3QsIGlmIHllcywgdXNlIHRoaXMgdmFsdWVcbiAgICAgICAgbGV0IHN0YXJ0VGltZU9mZnNldCA9IGRldGFpbHMuc3RhcnRUaW1lT2Zmc2V0O1xuICAgICAgICBpZighaXNOYU4oc3RhcnRUaW1lT2Zmc2V0KSkge1xuICAgICAgICAgIGxvZ2dlci5sb2coYHN0YXJ0IHRpbWUgb2Zmc2V0IGZvdW5kIGluIHBsYXlsaXN0LCBhZGp1c3Qgc3RhcnRQb3NpdGlvbiB0byAke3N0YXJ0VGltZU9mZnNldH1gKTtcbiAgICAgICAgICB0aGlzLnN0YXJ0UG9zaXRpb24gPSBzdGFydFRpbWVPZmZzZXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5zdGFydFBvc2l0aW9uID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5uZXh0TG9hZFBvc2l0aW9uID0gdGhpcy5zdGFydFBvc2l0aW9uO1xuICAgIH1cbiAgICAvLyBvbmx5IHN3aXRjaCBiYXRjayB0byBJRExFIHN0YXRlIGlmIHdlIHdlcmUgd2FpdGluZyBmb3IgdHJhY2sgdG8gc3RhcnQgZG93bmxvYWRpbmcgYSBuZXcgZnJhZ21lbnRcbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuV0FJVElOR19UUkFDSykge1xuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgfVxuICAgIC8vdHJpZ2dlciBoYW5kbGVyIHJpZ2h0IG5vd1xuICAgIHRoaXMudGljaygpO1xuICB9XG5cbiAgb25LZXlMb2FkZWQoKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLktFWV9MT0FESU5HKSB7XG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgIHRoaXMudGljaygpO1xuICAgIH1cbiAgfVxuXG4gIG9uRnJhZ0xvYWRlZChkYXRhKSB7XG4gICAgdmFyIGZyYWdDdXJyZW50ID0gdGhpcy5mcmFnQ3VycmVudDtcbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuRlJBR19MT0FESU5HICYmXG4gICAgICAgIGZyYWdDdXJyZW50ICYmXG4gICAgICAgIGRhdGEuZnJhZy50eXBlID09PSAnYXVkaW8nICYmXG4gICAgICAgIGRhdGEuZnJhZy5sZXZlbCA9PT0gZnJhZ0N1cnJlbnQubGV2ZWwgJiZcbiAgICAgICAgZGF0YS5mcmFnLnNuID09PSBmcmFnQ3VycmVudC5zbikge1xuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuUEFSU0lORztcbiAgICAgICAgLy8gdHJhbnNtdXggdGhlIE1QRUctVFMgZGF0YSB0byBJU08tQk1GRiBzZWdtZW50c1xuICAgICAgICB0aGlzLnN0YXRzID0gZGF0YS5zdGF0cztcbiAgICAgICAgdmFyIHRyYWNrID0gdGhpcy50cmFja3NbdGhpcy50cmFja0lkXSxcbiAgICAgICAgICAgIGRldGFpbHMgPSB0cmFjay5kZXRhaWxzLFxuICAgICAgICAgICAgZHVyYXRpb24gPSBkZXRhaWxzLnRvdGFsZHVyYXRpb24sXG4gICAgICAgICAgICBzdGFydCA9IGZyYWdDdXJyZW50LnN0YXJ0LFxuICAgICAgICAgICAgdHJhY2tJZCA9IGZyYWdDdXJyZW50LmxldmVsLFxuICAgICAgICAgICAgc24gPSBmcmFnQ3VycmVudC5zbixcbiAgICAgICAgICAgIGF1ZGlvQ29kZWMgPSB0aGlzLmNvbmZpZy5kZWZhdWx0QXVkaW9Db2RlYyB8fCB0cmFjay5hdWRpb0NvZGVjO1xuICAgICAgICB0aGlzLnBlbmRpbmdBcHBlbmRpbmcgPSAwO1xuICAgICAgICBpZighdGhpcy5kZW11eGVyKSB7XG4gICAgICAgICAgdGhpcy5kZW11eGVyID0gbmV3IERlbXV4ZXIodGhpcy5obHMsJ2F1ZGlvJyk7XG4gICAgICAgIH1cbiAgICAgICAgbG9nZ2VyLmxvZyhgRGVtdXhpbmcgJHtzbn0gb2YgWyR7ZGV0YWlscy5zdGFydFNOfSAsJHtkZXRhaWxzLmVuZFNOfV0sdHJhY2sgJHt0cmFja0lkfWApO1xuICAgICAgICAvLyB0aW1lIE9mZnNldCBpcyBhY2N1cmF0ZSBpZiBsZXZlbCBQVFMgaXMga25vd24sIG9yIGlmIHBsYXlsaXN0IGlzIG5vdCBzbGlkaW5nIChub3QgbGl2ZSlcbiAgICAgICAgbGV0IGFjY3VyYXRlVGltZU9mZnNldCA9IGRldGFpbHMuUFRTS25vd24gfHwgIWRldGFpbHMubGl2ZTtcbiAgICAgICAgdGhpcy5kZW11eGVyLnB1c2goZGF0YS5wYXlsb2FkLCBhdWRpb0NvZGVjLCBudWxsLCBzdGFydCwgZnJhZ0N1cnJlbnQuY2MsIHRyYWNrSWQsIHNuLCBkdXJhdGlvbiwgZnJhZ0N1cnJlbnQuZGVjcnlwdGRhdGEsYWNjdXJhdGVUaW1lT2Zmc2V0KTtcbiAgICB9XG4gICAgdGhpcy5mcmFnTG9hZEVycm9yID0gMDtcbiAgfVxuXG4gIG9uRnJhZ1BhcnNpbmdJbml0U2VnbWVudChkYXRhKSB7XG4gICAgbGV0IGZyYWdDdXJyZW50ID0gdGhpcy5mcmFnQ3VycmVudDtcbiAgICBpZiAoZnJhZ0N1cnJlbnQgJiZcbiAgICAgICAgZGF0YS5pZCA9PT0gJ2F1ZGlvJyAmJlxuICAgICAgICBkYXRhLnNuID09PSBmcmFnQ3VycmVudC5zbiAmJlxuICAgICAgICBkYXRhLmxldmVsID09PSBmcmFnQ3VycmVudC5sZXZlbCAmJlxuICAgICAgICB0aGlzLnN0YXRlID09PSBTdGF0ZS5QQVJTSU5HKSB7XG4gICAgICBsZXQgdHJhY2tzID0gZGF0YS50cmFja3MsIHRyYWNrO1xuXG4gICAgICAvLyBpbmNsdWRlIGxldmVsQ29kZWMgaW4gYXVkaW8gYW5kIHZpZGVvIHRyYWNrc1xuICAgICAgdHJhY2sgPSB0cmFja3MuYXVkaW87XG4gICAgICBpZih0cmFjaykge1xuICAgICAgICB0cmFjay5sZXZlbENvZGVjID0gJ21wNGEuNDAuMic7XG4gICAgICAgIHRyYWNrLmlkID0gZGF0YS5pZDtcbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5CVUZGRVJfQ09ERUNTLHRyYWNrcyk7XG4gICAgICAgIGxvZ2dlci5sb2coYGF1ZGlvIHRyYWNrOmF1ZGlvLGNvbnRhaW5lcjoke3RyYWNrLmNvbnRhaW5lcn0sY29kZWNzW2xldmVsL3BhcnNlZF09WyR7dHJhY2subGV2ZWxDb2RlY30vJHt0cmFjay5jb2RlY31dYCk7XG4gICAgICAgIGxldCBpbml0U2VnbWVudCA9IHRyYWNrLmluaXRTZWdtZW50O1xuICAgICAgICBpZiAoaW5pdFNlZ21lbnQpIHtcbiAgICAgICAgICB0aGlzLnBlbmRpbmdBcHBlbmRpbmcrKztcbiAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkJVRkZFUl9BUFBFTkRJTkcsIHt0eXBlOiAnYXVkaW8nLCBkYXRhOiBpbml0U2VnbWVudCwgcGFyZW50IDogJ2F1ZGlvJyxjb250ZW50IDogJ2luaXRTZWdtZW50J30pO1xuICAgICAgICB9XG4gICAgICAgIC8vdHJpZ2dlciBoYW5kbGVyIHJpZ2h0IG5vd1xuICAgICAgICB0aGlzLnRpY2soKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBvbkZyYWdQYXJzaW5nRGF0YShkYXRhKSB7XG4gICAgbGV0IGZyYWdDdXJyZW50ID0gdGhpcy5mcmFnQ3VycmVudDtcbiAgICBpZiAoZnJhZ0N1cnJlbnQgJiZcbiAgICAgICAgZGF0YS5pZCA9PT0gJ2F1ZGlvJyAmJlxuICAgICAgICBkYXRhLnNuID09PSBmcmFnQ3VycmVudC5zbiAmJlxuICAgICAgICBkYXRhLmxldmVsID09PSBmcmFnQ3VycmVudC5sZXZlbCAmJlxuICAgICAgICB0aGlzLnN0YXRlID09PSBTdGF0ZS5QQVJTSU5HKSB7XG4gICAgICB2YXIgdHJhY2sgPSB0aGlzLnRyYWNrc1t0aGlzLnRyYWNrSWRdLFxuICAgICAgICAgIGZyYWcgPSB0aGlzLmZyYWdDdXJyZW50O1xuXG4gICAgICBsb2dnZXIubG9nKGBwYXJzZWQgJHtkYXRhLnR5cGV9LFBUUzpbJHtkYXRhLnN0YXJ0UFRTLnRvRml4ZWQoMyl9LCR7ZGF0YS5lbmRQVFMudG9GaXhlZCgzKX1dLERUUzpbJHtkYXRhLnN0YXJ0RFRTLnRvRml4ZWQoMyl9LyR7ZGF0YS5lbmREVFMudG9GaXhlZCgzKX1dLG5iOiR7ZGF0YS5uYn1gKTtcbiAgICAgIExldmVsSGVscGVyLnVwZGF0ZUZyYWdQVFNEVFModHJhY2suZGV0YWlscyxmcmFnLnNuLGRhdGEuc3RhcnRQVFMsZGF0YS5lbmRQVFMpO1xuXG4gICAgICBbZGF0YS5kYXRhMSwgZGF0YS5kYXRhMl0uZm9yRWFjaChidWZmZXIgPT4ge1xuICAgICAgICBpZiAoYnVmZmVyKSB7XG4gICAgICAgICAgdGhpcy5wZW5kaW5nQXBwZW5kaW5nKys7XG4gICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5CVUZGRVJfQVBQRU5ESU5HLCB7dHlwZTogZGF0YS50eXBlLCBkYXRhOiBidWZmZXIsIHBhcmVudCA6ICdhdWRpbycsY29udGVudCA6ICdkYXRhJ30pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRoaXMubmV4dExvYWRQb3NpdGlvbiA9IGRhdGEuZW5kUFRTO1xuICAgICAgLy90cmlnZ2VyIGhhbmRsZXIgcmlnaHQgbm93XG4gICAgICB0aGlzLnRpY2soKTtcbiAgICB9XG4gIH1cblxuICBvbkZyYWdQYXJzZWQoZGF0YSkge1xuICAgIGxldCBmcmFnQ3VycmVudCA9IHRoaXMuZnJhZ0N1cnJlbnQ7XG4gICAgaWYgKGZyYWdDdXJyZW50ICYmXG4gICAgICAgIGRhdGEuaWQgPT09ICdhdWRpbycgJiZcbiAgICAgICAgZGF0YS5zbiA9PT0gZnJhZ0N1cnJlbnQuc24gJiZcbiAgICAgICAgZGF0YS5sZXZlbCA9PT0gZnJhZ0N1cnJlbnQubGV2ZWwgJiZcbiAgICAgICAgdGhpcy5zdGF0ZSA9PT0gU3RhdGUuUEFSU0lORykge1xuICAgICAgdGhpcy5zdGF0cy50cGFyc2VkID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuUEFSU0VEO1xuICAgICAgdGhpcy5fY2hlY2tBcHBlbmRlZFBhcnNlZCgpO1xuICAgIH1cbiAgfVxuXG5cbiAgb25CdWZmZXJDcmVhdGVkKGRhdGEpIHtcbiAgICBsZXQgYXVkaW9UcmFjayA9IGRhdGEudHJhY2tzLmF1ZGlvO1xuICAgIGlmIChhdWRpb1RyYWNrKSB7XG4gICAgICB0aGlzLm1lZGlhQnVmZmVyID0gYXVkaW9UcmFjay5idWZmZXI7XG4gICAgICB0aGlzLmxvYWRlZG1ldGFkYXRhID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBvbkJ1ZmZlckFwcGVuZGVkKGRhdGEpIHtcbiAgICBpZiAoZGF0YS5wYXJlbnQgPT09ICdhdWRpbycpIHtcbiAgICAgIHN3aXRjaCAodGhpcy5zdGF0ZSkge1xuICAgICAgICBjYXNlIFN0YXRlLlBBUlNJTkc6XG4gICAgICAgIGNhc2UgU3RhdGUuUEFSU0VEOlxuICAgICAgICAgIHRoaXMucGVuZGluZ0FwcGVuZGluZy0tO1xuICAgICAgICAgIHRoaXMuX2NoZWNrQXBwZW5kZWRQYXJzZWQoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBfY2hlY2tBcHBlbmRlZFBhcnNlZCgpIHtcbiAgICAvL3RyaWdnZXIgaGFuZGxlciByaWdodCBub3dcbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuUEFSU0VEICYmIHRoaXMucGVuZGluZ0FwcGVuZGluZyA9PT0gMCkgIHtcbiAgICAgIHZhciBmcmFnID0gdGhpcy5mcmFnQ3VycmVudCwgc3RhdHMgPSB0aGlzLnN0YXRzO1xuICAgICAgaWYgKGZyYWcpIHtcbiAgICAgICAgdGhpcy5mcmFnUHJldmlvdXMgPSBmcmFnO1xuICAgICAgICBzdGF0cy50YnVmZmVyZWQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5GUkFHX0JVRkZFUkVELCB7c3RhdHM6IHN0YXRzLCBmcmFnOiBmcmFnLCBpZCA6ICdhdWRpbyd9KTtcbiAgICAgICAgbGV0IG1lZGlhID0gdGhpcy5tZWRpYUJ1ZmZlciA/IHRoaXMubWVkaWFCdWZmZXIgOiB0aGlzLm1lZGlhO1xuICAgICAgICBsb2dnZXIubG9nKGBhdWRpbyBidWZmZXJlZCA6ICR7VGltZVJhbmdlcy50b1N0cmluZyhtZWRpYS5idWZmZXJlZCl9YCk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgfVxuICAgICAgdGhpcy50aWNrKCk7XG4gICAgfVxuICB9XG5cbiAgb25FcnJvcihkYXRhKSB7XG4gICAgbGV0IGZyYWcgPSBkYXRhLmZyYWc7XG4gICAgLy8gZG9uJ3QgaGFuZGxlIGZyYWcgZXJyb3Igbm90IHJlbGF0ZWQgdG8gYXVkaW8gZnJhZ21lbnRcbiAgICBpZiAoZnJhZyAmJiBmcmFnLnR5cGUgIT09ICdhdWRpbycpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3dpdGNoKGRhdGEuZGV0YWlscykge1xuICAgICAgY2FzZSBFcnJvckRldGFpbHMuRlJBR19MT0FEX0VSUk9SOlxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuRlJBR19MT0FEX1RJTUVPVVQ6XG4gICAgICAgIGlmKCFkYXRhLmZhdGFsKSB7XG4gICAgICAgICAgdmFyIGxvYWRFcnJvciA9IHRoaXMuZnJhZ0xvYWRFcnJvcjtcbiAgICAgICAgICBpZihsb2FkRXJyb3IpIHtcbiAgICAgICAgICAgIGxvYWRFcnJvcisrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsb2FkRXJyb3I9MTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGV0IGNvbmZpZyA9IHRoaXMuY29uZmlnO1xuICAgICAgICAgIGlmIChsb2FkRXJyb3IgPD0gY29uZmlnLmZyYWdMb2FkaW5nTWF4UmV0cnkpIHtcbiAgICAgICAgICAgIHRoaXMuZnJhZ0xvYWRFcnJvciA9IGxvYWRFcnJvcjtcbiAgICAgICAgICAgIC8vIHJlc2V0IGxvYWQgY291bnRlciB0byBhdm9pZCBmcmFnIGxvb3AgbG9hZGluZyBlcnJvclxuICAgICAgICAgICAgZnJhZy5sb2FkQ291bnRlciA9IDA7XG4gICAgICAgICAgICAvLyBleHBvbmVudGlhbCBiYWNrb2ZmIGNhcHBlZCB0byBjb25maWcuZnJhZ0xvYWRpbmdNYXhSZXRyeVRpbWVvdXRcbiAgICAgICAgICAgIHZhciBkZWxheSA9IE1hdGgubWluKE1hdGgucG93KDIsbG9hZEVycm9yLTEpKmNvbmZpZy5mcmFnTG9hZGluZ1JldHJ5RGVsYXksY29uZmlnLmZyYWdMb2FkaW5nTWF4UmV0cnlUaW1lb3V0KTtcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKGBhdWRpb1N0cmVhbUNvbnRyb2xsZXI6IGZyYWcgbG9hZGluZyBmYWlsZWQsIHJldHJ5IGluICR7ZGVsYXl9IG1zYCk7XG4gICAgICAgICAgICB0aGlzLnJldHJ5RGF0ZSA9IHBlcmZvcm1hbmNlLm5vdygpICsgZGVsYXk7XG4gICAgICAgICAgICAvLyByZXRyeSBsb2FkaW5nIHN0YXRlXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuRlJBR19MT0FESU5HX1dBSVRJTkdfUkVUUlk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcihgYXVkaW9TdHJlYW1Db250cm9sbGVyOiAke2RhdGEuZGV0YWlsc30gcmVhY2hlcyBtYXggcmV0cnksIHJlZGlzcGF0Y2ggYXMgZmF0YWwgLi4uYCk7XG4gICAgICAgICAgICAvLyByZWRpc3BhdGNoIHNhbWUgZXJyb3IgYnV0IHdpdGggZmF0YWwgc2V0IHRvIHRydWVcbiAgICAgICAgICAgIGRhdGEuZmF0YWwgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5FUlJPUiwgZGF0YSk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuRVJST1I7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBFcnJvckRldGFpbHMuRlJBR19MT09QX0xPQURJTkdfRVJST1I6XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5BVURJT19UUkFDS19MT0FEX0VSUk9SOlxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuQVVESU9fVFJBQ0tfTE9BRF9USU1FT1VUOlxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuS0VZX0xPQURfRVJST1I6XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5LRVlfTE9BRF9USU1FT1VUOlxuICAgICAgICAvLyAgd2hlbiBpbiBFUlJPUiBzdGF0ZSwgZG9uJ3Qgc3dpdGNoIGJhY2sgdG8gSURMRSBzdGF0ZSBpbiBjYXNlIGEgbm9uLWZhdGFsIGVycm9yIGlzIHJlY2VpdmVkXG4gICAgICAgIGlmKHRoaXMuc3RhdGUgIT09IFN0YXRlLkVSUk9SKSB7XG4gICAgICAgICAgICAvLyBpZiBmYXRhbCBlcnJvciwgc3RvcCBwcm9jZXNzaW5nLCBvdGhlcndpc2UgbW92ZSB0byBJRExFIHRvIHJldHJ5IGxvYWRpbmdcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBkYXRhLmZhdGFsID8gU3RhdGUuRVJST1IgOiBTdGF0ZS5JRExFO1xuICAgICAgICAgICAgbG9nZ2VyLndhcm4oYGF1ZGlvU3RyZWFtQ29udHJvbGxlcjogJHtkYXRhLmRldGFpbHN9IHdoaWxlIGxvYWRpbmcgZnJhZyxzd2l0Y2ggdG8gJHt0aGlzLnN0YXRlfSBzdGF0ZSAuLi5gKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIG9uQnVmZmVyRmx1c2hlZCgpIHtcbiAgICAvLyBpbmNyZWFzZSBmcmFnbWVudCBsb2FkIEluZGV4IHRvIGF2b2lkIGZyYWcgbG9vcCBsb2FkaW5nIGVycm9yIGFmdGVyIGJ1ZmZlciBmbHVzaFxuICAgIHRoaXMuZnJhZ0xvYWRJZHggKz0gMiAqIHRoaXMuY29uZmlnLmZyYWdMb2FkaW5nTG9vcFRocmVzaG9sZDtcbiAgICAvLyBtb3ZlIHRvIElETEUgb25jZSBmbHVzaCBjb21wbGV0ZS4gdGhpcyBzaG91bGQgdHJpZ2dlciBuZXcgZnJhZ21lbnQgbG9hZGluZ1xuICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgIC8vIHJlc2V0IHJlZmVyZW5jZSB0byBmcmFnXG4gICAgdGhpcy5mcmFnUHJldmlvdXMgPSBudWxsO1xuICAgIHRoaXMudGljaygpO1xuICB9XG59XG5leHBvcnQgZGVmYXVsdCBBdWRpb1N0cmVhbUNvbnRyb2xsZXI7XG5cbiIsIi8qXG4gKiBhdWRpbyB0cmFjayBjb250cm9sbGVyXG4qL1xuXG5pbXBvcnQgRXZlbnQgZnJvbSAnLi4vZXZlbnRzJztcbmltcG9ydCBFdmVudEhhbmRsZXIgZnJvbSAnLi4vZXZlbnQtaGFuZGxlcic7XG5pbXBvcnQge2xvZ2dlcn0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcblxuY2xhc3MgQXVkaW9UcmFja0NvbnRyb2xsZXIgZXh0ZW5kcyBFdmVudEhhbmRsZXIge1xuXG4gIGNvbnN0cnVjdG9yKGhscykge1xuICAgIHN1cGVyKGhscywgRXZlbnQuTUFOSUZFU1RfTE9BRElORyxcbiAgICAgICAgICAgICAgIEV2ZW50Lk1BTklGRVNUX0xPQURFRCxcbiAgICAgICAgICAgICAgIEV2ZW50LkFVRElPX1RSQUNLX0xPQURFRCk7XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIEV2ZW50SGFuZGxlci5wcm90b3R5cGUuZGVzdHJveS5jYWxsKHRoaXMpO1xuICB9XG5cbiAgb25NYW5pZmVzdExvYWRpbmcoKSB7XG4gICAgLy8gcmVzZXQgYXVkaW8gdHJhY2tzIG9uIG1hbmlmZXN0IGxvYWRpbmdcbiAgICB0aGlzLnRyYWNrcyA9IFtdO1xuICAgIHRoaXMudHJhY2tJZCA9IC0xO1xuICB9XG5cbiAgb25NYW5pZmVzdExvYWRlZChkYXRhKSB7XG4gICAgbGV0IHRyYWNrcyA9IGRhdGEuYXVkaW9UcmFja3MgfHwgW107XG4gICAgbGV0IGRlZmF1bHRGb3VuZCA9IGZhbHNlO1xuICAgIHRoaXMudHJhY2tzID0gdHJhY2tzO1xuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuQVVESU9fVFJBQ0tTX1VQREFURUQsIHthdWRpb1RyYWNrcyA6IHRyYWNrc30pO1xuICAgIC8vIGxvb3AgdGhyb3VnaCBhdmFpbGFibGUgYXVkaW8gdHJhY2tzIGFuZCBhdXRvc2VsZWN0IGRlZmF1bHQgaWYgbmVlZGVkXG4gICAgbGV0IGlkID0gMDtcbiAgICB0cmFja3MuZm9yRWFjaCh0cmFjayA9PiB7XG4gICAgICBpZih0cmFjay5kZWZhdWx0KSB7XG4gICAgICAgIHRoaXMuYXVkaW9UcmFjayA9IGlkO1xuICAgICAgICBkZWZhdWx0Rm91bmQgPSB0cnVlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZCsrO1xuICAgIH0pO1xuICAgIGlmIChkZWZhdWx0Rm91bmQgPT09IGZhbHNlICYmIHRyYWNrcy5sZW5ndGgpIHtcbiAgICAgIGxvZ2dlci5sb2coJ25vIGRlZmF1bHQgYXVkaW8gdHJhY2sgZGVmaW5lZCwgdXNlIGZpcnN0IGF1ZGlvIHRyYWNrIGFzIGRlZmF1bHQnKTtcbiAgICAgIHRoaXMuYXVkaW9UcmFjayA9IDA7XG4gICAgfVxuICB9XG5cbiAgb25BdWRpb1RyYWNrTG9hZGVkKGRhdGEpIHtcbiAgICBpZiAoZGF0YS5pZCA8IHRoaXMudHJhY2tzLmxlbmd0aCkge1xuICAgICAgbG9nZ2VyLmxvZyhgYXVkaW9UcmFjayAke2RhdGEuaWR9IGxvYWRlZGApO1xuICAgICAgdGhpcy50cmFja3NbZGF0YS5pZF0uZGV0YWlscyA9IGRhdGEuZGV0YWlscztcbiAgICAgIC8vIGNoZWNrIGlmIGN1cnJlbnQgcGxheWxpc3QgaXMgYSBsaXZlIHBsYXlsaXN0XG4gICAgICBpZiAoZGF0YS5kZXRhaWxzLmxpdmUgJiYgIXRoaXMudGltZXIpIHtcbiAgICAgICAgLy8gaWYgbGl2ZSBwbGF5bGlzdCB3ZSB3aWxsIGhhdmUgdG8gcmVsb2FkIGl0IHBlcmlvZGljYWxseVxuICAgICAgICAvLyBzZXQgcmVsb2FkIHBlcmlvZCB0byBwbGF5bGlzdCB0YXJnZXQgZHVyYXRpb25cbiAgICAgICAgdGhpcy50aW1lciA9IHNldEludGVydmFsKHRoaXMub250aWNrLCAxMDAwICogZGF0YS5kZXRhaWxzLnRhcmdldGR1cmF0aW9uKTtcbiAgICAgIH1cbiAgICAgIGlmICghZGF0YS5kZXRhaWxzLmxpdmUgJiYgdGhpcy50aW1lcikge1xuICAgICAgICAvLyBwbGF5bGlzdCBpcyBub3QgbGl2ZSBhbmQgdGltZXIgaXMgYXJtZWQgOiBzdG9wcGluZyBpdFxuICAgICAgICBjbGVhckludGVydmFsKHRoaXMudGltZXIpO1xuICAgICAgICB0aGlzLnRpbWVyID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKiogZ2V0IGFsdGVybmF0ZSBhdWRpbyB0cmFja3MgbGlzdCBmcm9tIHBsYXlsaXN0ICoqL1xuICBnZXQgYXVkaW9UcmFja3MoKSB7XG4gICAgcmV0dXJuIHRoaXMudHJhY2tzO1xuICB9XG5cbiAgLyoqIGdldCBpbmRleCBvZiB0aGUgc2VsZWN0ZWQgYXVkaW8gdHJhY2sgKGluZGV4IGluIGF1ZGlvIHRyYWNrIGxpc3RzKSAqKi9cbiAgZ2V0IGF1ZGlvVHJhY2soKSB7XG4gICByZXR1cm4gdGhpcy50cmFja0lkO1xuICB9XG5cbiAgLyoqIHNlbGVjdCBhbiBhdWRpbyB0cmFjaywgYmFzZWQgb24gaXRzIGluZGV4IGluIGF1ZGlvIHRyYWNrIGxpc3RzKiovXG4gIHNldCBhdWRpb1RyYWNrKGF1ZGlvVHJhY2tJZCkge1xuICAgIGlmICh0aGlzLnRyYWNrSWQgIT09IGF1ZGlvVHJhY2tJZCB8fCB0aGlzLnRyYWNrc1thdWRpb1RyYWNrSWRdLmRldGFpbHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5zZXRBdWRpb1RyYWNrSW50ZXJuYWwoYXVkaW9UcmFja0lkKTtcbiAgICB9XG4gIH1cblxuIHNldEF1ZGlvVHJhY2tJbnRlcm5hbChuZXdJZCkge1xuICAgIC8vIGNoZWNrIGlmIGxldmVsIGlkeCBpcyB2YWxpZFxuICAgIGlmIChuZXdJZCA+PSAwICYmIG5ld0lkIDwgdGhpcy50cmFja3MubGVuZ3RoKSB7XG4gICAgICAvLyBzdG9wcGluZyBsaXZlIHJlbG9hZGluZyB0aW1lciBpZiBhbnlcbiAgICAgIGlmICh0aGlzLnRpbWVyKSB7XG4gICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLnRpbWVyKTtcbiAgICAgICB0aGlzLnRpbWVyID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHRoaXMudHJhY2tJZCA9IG5ld0lkO1xuICAgICAgbG9nZ2VyLmxvZyhgc3dpdGNoaW5nIHRvIGF1ZGlvVHJhY2sgJHtuZXdJZH1gKTtcbiAgICAgIGxldCBhdWRpb1RyYWNrID0gdGhpcy50cmFja3NbbmV3SWRdLCB0eXBlID0gYXVkaW9UcmFjay50eXBlLHVybCA9IGF1ZGlvVHJhY2sudXJsO1xuICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5BVURJT19UUkFDS19TV0lUQ0gsIHtpZDogbmV3SWQsIHR5cGUgOiB0eXBlLCB1cmwgOiB1cmx9KTtcbiAgICAgICAvLyBjaGVjayBpZiB3ZSBuZWVkIHRvIGxvYWQgcGxheWxpc3QgZm9yIHRoaXMgYXVkaW8gVHJhY2tcbiAgICAgICBsZXQgZGV0YWlscyA9IGF1ZGlvVHJhY2suZGV0YWlscztcbiAgICAgIGlmICh1cmwgJiYgKGRldGFpbHMgPT09IHVuZGVmaW5lZCB8fCBkZXRhaWxzLmxpdmUgPT09IHRydWUpKSB7XG4gICAgICAgIC8vIHRyYWNrIG5vdCByZXRyaWV2ZWQgeWV0LCBvciBsaXZlIHBsYXlsaXN0IHdlIG5lZWQgdG8gKHJlKWxvYWQgaXRcbiAgICAgICAgbG9nZ2VyLmxvZyhgKHJlKWxvYWRpbmcgcGxheWxpc3QgZm9yIGF1ZGlvVHJhY2sgJHtuZXdJZH1gKTtcbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5BVURJT19UUkFDS19MT0FESU5HLCB7dXJsOiB1cmwsIGlkOiBuZXdJZH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBBdWRpb1RyYWNrQ29udHJvbGxlcjtcbiIsIi8qXG4gKiBCdWZmZXIgQ29udHJvbGxlclxuKi9cblxuaW1wb3J0IEV2ZW50IGZyb20gJy4uL2V2ZW50cyc7XG5pbXBvcnQgRXZlbnRIYW5kbGVyIGZyb20gJy4uL2V2ZW50LWhhbmRsZXInO1xuaW1wb3J0IHtsb2dnZXJ9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XG5pbXBvcnQge0Vycm9yVHlwZXMsIEVycm9yRGV0YWlsc30gZnJvbSAnLi4vZXJyb3JzJztcblxuXG5jbGFzcyBCdWZmZXJDb250cm9sbGVyIGV4dGVuZHMgRXZlbnRIYW5kbGVyIHtcblxuICBjb25zdHJ1Y3RvcihobHMpIHtcbiAgICBzdXBlcihobHMsXG4gICAgICBFdmVudC5NRURJQV9BVFRBQ0hJTkcsXG4gICAgICBFdmVudC5NRURJQV9ERVRBQ0hJTkcsXG4gICAgICBFdmVudC5NQU5JRkVTVF9QQVJTRUQsXG4gICAgICBFdmVudC5CVUZGRVJfUkVTRVQsXG4gICAgICBFdmVudC5CVUZGRVJfQVBQRU5ESU5HLFxuICAgICAgRXZlbnQuQlVGRkVSX0NPREVDUyxcbiAgICAgIEV2ZW50LkJVRkZFUl9FT1MsXG4gICAgICBFdmVudC5CVUZGRVJfRkxVU0hJTkcsXG4gICAgICBFdmVudC5MRVZFTF9VUERBVEVEKTtcblxuICAgIC8vIHRoZSB2YWx1ZSB0aGF0IHdlIGhhdmUgc2V0IG1lZGlhc291cmNlLmR1cmF0aW9uIHRvXG4gICAgLy8gKHRoZSBhY3R1YWwgZHVyYXRpb24gbWF5IGJlIHR3ZWFrZWQgc2xpZ2hseSBieSB0aGUgYnJvd3NlcilcbiAgICB0aGlzLl9tc0R1cmF0aW9uID0gbnVsbDtcbiAgICAvLyB0aGUgdmFsdWUgdGhhdCB3ZSB3YW50IHRvIHNldCBtZWRpYVNvdXJjZS5kdXJhdGlvbiB0b1xuICAgIHRoaXMuX2xldmVsRHVyYXRpb24gPSBudWxsO1xuXG4gICAgLy8gU291cmNlIEJ1ZmZlciBsaXN0ZW5lcnNcbiAgICB0aGlzLm9uc2J1ZSA9IHRoaXMub25TQlVwZGF0ZUVuZC5iaW5kKHRoaXMpO1xuICAgIHRoaXMub25zYmUgID0gdGhpcy5vblNCVXBkYXRlRXJyb3IuYmluZCh0aGlzKTtcbiAgICB0aGlzLnBlbmRpbmdUcmFja3MgPSB7fTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgRXZlbnRIYW5kbGVyLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XG4gIH1cblxuICBvbk1hbmlmZXN0UGFyc2VkKGRhdGEpIHtcbiAgICBsZXQgYXVkaW9FeHBlY3RlZCA9IGRhdGEuYXVkaW8sXG4gICAgICAgIHZpZGVvRXhwZWN0ZWQgPSBkYXRhLnZpZGVvLFxuICAgICAgICBzb3VyY2VCdWZmZXJOYiA9IDA7XG4gICAgaWYgKGF1ZGlvRXhwZWN0ZWQgfHwgdmlkZW9FeHBlY3RlZCkge1xuICAgICAgc291cmNlQnVmZmVyTmIgPSAoYXVkaW9FeHBlY3RlZCA/IDEgOiAwKSArICh2aWRlb0V4cGVjdGVkID8gMSA6IDApO1xuICAgICAgbG9nZ2VyLmxvZyhgJHtzb3VyY2VCdWZmZXJOYn0gc291cmNlQnVmZmVyKHMpIGV4cGVjdGVkYCk7XG4gICAgfVxuICAgIHRoaXMuc291cmNlQnVmZmVyTmIgPSBzb3VyY2VCdWZmZXJOYjtcbiAgfVxuXG4gIG9uTWVkaWFBdHRhY2hpbmcoZGF0YSkge1xuICAgIGxldCBtZWRpYSA9IHRoaXMubWVkaWEgPSBkYXRhLm1lZGlhO1xuICAgIGlmIChtZWRpYSkge1xuICAgICAgLy8gc2V0dXAgdGhlIG1lZGlhIHNvdXJjZVxuICAgICAgdmFyIG1zID0gdGhpcy5tZWRpYVNvdXJjZSA9IG5ldyBNZWRpYVNvdXJjZSgpO1xuICAgICAgLy9NZWRpYSBTb3VyY2UgbGlzdGVuZXJzXG4gICAgICB0aGlzLm9ubXNvID0gdGhpcy5vbk1lZGlhU291cmNlT3Blbi5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5vbm1zZSA9IHRoaXMub25NZWRpYVNvdXJjZUVuZGVkLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLm9ubXNjID0gdGhpcy5vbk1lZGlhU291cmNlQ2xvc2UuYmluZCh0aGlzKTtcbiAgICAgIG1zLmFkZEV2ZW50TGlzdGVuZXIoJ3NvdXJjZW9wZW4nLCB0aGlzLm9ubXNvKTtcbiAgICAgIG1zLmFkZEV2ZW50TGlzdGVuZXIoJ3NvdXJjZWVuZGVkJywgdGhpcy5vbm1zZSk7XG4gICAgICBtcy5hZGRFdmVudExpc3RlbmVyKCdzb3VyY2VjbG9zZScsIHRoaXMub25tc2MpO1xuICAgICAgLy8gbGluayB2aWRlbyBhbmQgbWVkaWEgU291cmNlXG4gICAgICBtZWRpYS5zcmMgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKG1zKTtcbiAgICB9XG4gIH1cblxuICBvbk1lZGlhRGV0YWNoaW5nKCkge1xuICAgIGxvZ2dlci5sb2coJ21lZGlhIHNvdXJjZSBkZXRhY2hpbmcnKTtcbiAgICB2YXIgbXMgPSB0aGlzLm1lZGlhU291cmNlO1xuICAgIGlmIChtcykge1xuICAgICAgaWYgKG1zLnJlYWR5U3RhdGUgPT09ICdvcGVuJykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIGVuZE9mU3RyZWFtIGNvdWxkIHRyaWdnZXIgZXhjZXB0aW9uIGlmIGFueSBzb3VyY2VidWZmZXIgaXMgaW4gdXBkYXRpbmcgc3RhdGVcbiAgICAgICAgICAvLyB3ZSBkb24ndCByZWFsbHkgY2FyZSBhYm91dCBjaGVja2luZyBzb3VyY2VidWZmZXIgc3RhdGUgaGVyZSxcbiAgICAgICAgICAvLyBhcyB3ZSBhcmUgYW55d2F5IGRldGFjaGluZyB0aGUgTWVkaWFTb3VyY2VcbiAgICAgICAgICAvLyBsZXQncyBqdXN0IGF2b2lkIHRoaXMgZXhjZXB0aW9uIHRvIHByb3BhZ2F0ZVxuICAgICAgICAgIG1zLmVuZE9mU3RyZWFtKCk7XG4gICAgICAgIH0gY2F0Y2goZXJyKSB7XG4gICAgICAgICAgbG9nZ2VyLndhcm4oYG9uTWVkaWFEZXRhY2hpbmc6JHtlcnIubWVzc2FnZX0gd2hpbGUgY2FsbGluZyBlbmRPZlN0cmVhbWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBtcy5yZW1vdmVFdmVudExpc3RlbmVyKCdzb3VyY2VvcGVuJywgdGhpcy5vbm1zbyk7XG4gICAgICBtcy5yZW1vdmVFdmVudExpc3RlbmVyKCdzb3VyY2VlbmRlZCcsIHRoaXMub25tc2UpO1xuICAgICAgbXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignc291cmNlY2xvc2UnLCB0aGlzLm9ubXNjKTtcblxuICAgICAgLy8gRGV0YWNoIHByb3Blcmx5IHRoZSBNZWRpYVNvdXJjZSBmcm9tIHRoZSBIVE1MTWVkaWFFbGVtZW50IGFzXG4gICAgICAvLyBzdWdnZXN0ZWQgaW4gaHR0cHM6Ly9naXRodWIuY29tL3czYy9tZWRpYS1zb3VyY2UvaXNzdWVzLzUzLlxuICAgICAgaWYgKHRoaXMubWVkaWEpIHtcbiAgICAgICAgdGhpcy5tZWRpYS5yZW1vdmVBdHRyaWJ1dGUoJ3NyYycpO1xuICAgICAgICB0aGlzLm1lZGlhLmxvYWQoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5tZWRpYVNvdXJjZSA9IG51bGw7XG4gICAgICB0aGlzLm1lZGlhID0gbnVsbDtcbiAgICAgIHRoaXMucGVuZGluZ1RyYWNrcyA9IHt9O1xuICAgICAgdGhpcy5zb3VyY2VCdWZmZXIgPSB7fTtcbiAgICAgIHRoaXMuZmx1c2hSYW5nZSA9IFtdO1xuICAgICAgdGhpcy5zZWdtZW50cyA9IFtdO1xuICAgICAgdGhpcy5hcHBlbmRlZCA9IDA7XG4gICAgfVxuICAgIHRoaXMub25tc28gPSB0aGlzLm9ubXNlID0gdGhpcy5vbm1zYyA9IG51bGw7XG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5NRURJQV9ERVRBQ0hFRCk7XG4gIH1cblxuICBvbk1lZGlhU291cmNlT3BlbigpIHtcbiAgICBsb2dnZXIubG9nKCdtZWRpYSBzb3VyY2Ugb3BlbmVkJyk7XG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5NRURJQV9BVFRBQ0hFRCwgeyBtZWRpYSA6IHRoaXMubWVkaWEgfSk7XG4gICAgbGV0IG1lZGlhU291cmNlID0gdGhpcy5tZWRpYVNvdXJjZTtcbiAgICBpZiAobWVkaWFTb3VyY2UpIHtcbiAgICAgIC8vIG9uY2UgcmVjZWl2ZWQsIGRvbid0IGxpc3RlbiBhbnltb3JlIHRvIHNvdXJjZW9wZW4gZXZlbnRcbiAgICAgIG1lZGlhU291cmNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3NvdXJjZW9wZW4nLCB0aGlzLm9ubXNvKTtcbiAgICB9XG4gICAgdGhpcy5jaGVja1BlbmRpbmdUcmFja3MoKTtcbiAgfVxuXG4gIGNoZWNrUGVuZGluZ1RyYWNrcygpIHtcbiAgICAvLyBpZiBhbnkgYnVmZmVyIGNvZGVjcyBwZW5kaW5nLCBjaGVjayBpZiB3ZSBoYXZlIGVub3VnaCB0byBjcmVhdGUgc291cmNlQnVmZmVyc1xuICAgIGxldCBwZW5kaW5nVHJhY2tzID0gdGhpcy5wZW5kaW5nVHJhY2tzLFxuICAgICAgICBwZW5kaW5nVHJhY2tzTmIgPSBPYmplY3Qua2V5cyhwZW5kaW5nVHJhY2tzKS5sZW5ndGg7XG4gICAgLy8gaWYgYW55IHBlbmRpbmcgdHJhY2tzIGFuZCAoaWYgbmIgb2YgcGVuZGluZyB0cmFja3MgbWF0Y2hpbmcgZXhwZWN0ZWQgbmIgb3IgaWYgdW5rbm9vd24gZXhwZWN0ZWQgbmIpXG4gICAgaWYgKHBlbmRpbmdUcmFja3NOYiAmJiAoXG4gICAgICAgIHRoaXMuc291cmNlQnVmZmVyTmIgPT09IHBlbmRpbmdUcmFja3NOYiB8fFxuICAgICAgICB0aGlzLnNvdXJjZUJ1ZmZlck5iID09PSAwKSkge1xuICAgICAgLy8gb2ssIGxldCdzIGNyZWF0ZSB0aGVtIG5vdyAhXG4gICAgICB0aGlzLmNyZWF0ZVNvdXJjZUJ1ZmZlcnMocGVuZGluZ1RyYWNrcyk7XG4gICAgICB0aGlzLnBlbmRpbmdUcmFja3MgPSB7fTtcbiAgICAgIC8vIGFwcGVuZCBhbnkgcGVuZGluZyBzZWdtZW50cyBub3cgIVxuICAgICAgdGhpcy5kb0FwcGVuZGluZygpO1xuICAgIH1cbiAgfVxuXG4gIG9uTWVkaWFTb3VyY2VDbG9zZSgpIHtcbiAgICBsb2dnZXIubG9nKCdtZWRpYSBzb3VyY2UgY2xvc2VkJyk7XG4gIH1cblxuICBvbk1lZGlhU291cmNlRW5kZWQoKSB7XG4gICAgbG9nZ2VyLmxvZygnbWVkaWEgc291cmNlIGVuZGVkJyk7XG4gIH1cblxuXG4gIG9uU0JVcGRhdGVFbmQoKSB7XG5cbiAgICBpZiAodGhpcy5fbmVlZHNGbHVzaCkge1xuICAgICAgdGhpcy5kb0ZsdXNoKCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX25lZWRzRW9zKSB7XG4gICAgICB0aGlzLmNoZWNrRW9zKCk7XG4gICAgfVxuICAgIHRoaXMuYXBwZW5kaW5nID0gZmFsc2U7XG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5CVUZGRVJfQVBQRU5ERUQsIHsgcGFyZW50IDogdGhpcy5wYXJlbnR9KTtcblxuICAgIC8vIGRvbid0IGFwcGVuZCBpbiBmbHVzaGluZyBtb2RlXG4gICAgaWYgKCF0aGlzLl9uZWVkc0ZsdXNoKSB7XG4gICAgICB0aGlzLmRvQXBwZW5kaW5nKCk7XG4gICAgfVxuXG4gICAgdGhpcy51cGRhdGVNZWRpYUVsZW1lbnREdXJhdGlvbigpO1xuICB9XG5cbiAgb25TQlVwZGF0ZUVycm9yKGV2ZW50KSB7XG4gICAgbG9nZ2VyLmVycm9yKGBzb3VyY2VCdWZmZXIgZXJyb3I6JHtldmVudH1gKTtcbiAgICAvLyBhY2NvcmRpbmcgdG8gaHR0cDovL3d3dy53My5vcmcvVFIvbWVkaWEtc291cmNlLyNzb3VyY2VidWZmZXItYXBwZW5kLWVycm9yXG4gICAgLy8gdGhpcyBlcnJvciBtaWdodCBub3QgYWx3YXlzIGJlIGZhdGFsIChpdCBpcyBmYXRhbCBpZiBkZWNvZGUgZXJyb3IgaXMgc2V0LCBpbiB0aGF0IGNhc2VcbiAgICAvLyBpdCB3aWxsIGJlIGZvbGxvd2VkIGJ5IGEgbWVkaWFFbGVtZW50IGVycm9yIC4uLilcbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkVSUk9SLCB7dHlwZTogRXJyb3JUeXBlcy5NRURJQV9FUlJPUiwgZGV0YWlsczogRXJyb3JEZXRhaWxzLkJVRkZFUl9BUFBFTkRJTkdfRVJST1IsIGZhdGFsOiBmYWxzZX0pO1xuICAgIC8vIHdlIGRvbid0IG5lZWQgdG8gZG8gbW9yZSB0aGFuIHRoYXQsIGFzIGFjY29yZGluIHRvIHRoZSBzcGVjLCB1cGRhdGVlbmQgd2lsbCBiZSBmaXJlZCBqdXN0IGFmdGVyXG4gIH1cblxuICBvbkJ1ZmZlclJlc2V0KCkge1xuICAgIHZhciBzb3VyY2VCdWZmZXIgPSB0aGlzLnNvdXJjZUJ1ZmZlcjtcbiAgICBmb3IodmFyIHR5cGUgaW4gc291cmNlQnVmZmVyKSB7XG4gICAgICB2YXIgc2IgPSBzb3VyY2VCdWZmZXJbdHlwZV07XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLm1lZGlhU291cmNlLnJlbW92ZVNvdXJjZUJ1ZmZlcihzYik7XG4gICAgICAgIHNiLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3VwZGF0ZWVuZCcsIHRoaXMub25zYnVlKTtcbiAgICAgICAgc2IucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCB0aGlzLm9uc2JlKTtcbiAgICAgIH0gY2F0Y2goZXJyKSB7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuc291cmNlQnVmZmVyID0ge307XG4gICAgdGhpcy5mbHVzaFJhbmdlID0gW107XG4gICAgdGhpcy5zZWdtZW50cyA9IFtdO1xuICAgIHRoaXMuYXBwZW5kZWQgPSAwO1xuICB9XG5cbiAgb25CdWZmZXJDb2RlY3ModHJhY2tzKSB7XG4gICAgLy8gaWYgc291cmNlIGJ1ZmZlcihzKSBub3QgY3JlYXRlZCB5ZXQsIGFwcGVuZGVkIGJ1ZmZlciB0cmFja3MgaW4gdGhpcy5wZW5kaW5nVHJhY2tzXG4gICAgLy8gaWYgc291cmNlYnVmZmVycyBhbHJlYWR5IGNyZWF0ZWQsIGRvIG5vdGhpbmcgLi4uXG4gICAgaWYgKE9iamVjdC5rZXlzKHRoaXMuc291cmNlQnVmZmVyKS5sZW5ndGggPT09IDApIHtcbiAgICAgIGZvciAodmFyIHRyYWNrTmFtZSBpbiB0cmFja3MpIHsgdGhpcy5wZW5kaW5nVHJhY2tzW3RyYWNrTmFtZV0gPSB0cmFja3NbdHJhY2tOYW1lXTsgfVxuICAgICAgbGV0IG1lZGlhU291cmNlID0gdGhpcy5tZWRpYVNvdXJjZTtcbiAgICAgIGlmIChtZWRpYVNvdXJjZSAmJiBtZWRpYVNvdXJjZS5yZWFkeVN0YXRlID09PSAnb3BlbicpIHtcbiAgICAgICAgLy8gdHJ5IHRvIGNyZWF0ZSBzb3VyY2VidWZmZXJzIGlmIG1lZGlhc291cmNlIG9wZW5lZFxuICAgICAgICB0aGlzLmNoZWNrUGVuZGluZ1RyYWNrcygpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG5cbiAgY3JlYXRlU291cmNlQnVmZmVycyh0cmFja3MpIHtcbiAgICB2YXIgc291cmNlQnVmZmVyID0gdGhpcy5zb3VyY2VCdWZmZXIsbWVkaWFTb3VyY2UgPSB0aGlzLm1lZGlhU291cmNlO1xuXG4gICAgZm9yIChsZXQgdHJhY2tOYW1lIGluIHRyYWNrcykge1xuICAgICAgaWYoIXNvdXJjZUJ1ZmZlclt0cmFja05hbWVdKSB7XG4gICAgICAgIGxldCB0cmFjayA9IHRyYWNrc1t0cmFja05hbWVdO1xuICAgICAgICAvLyB1c2UgbGV2ZWxDb2RlYyBhcyBmaXJzdCBwcmlvcml0eVxuICAgICAgICBsZXQgY29kZWMgPSB0cmFjay5sZXZlbENvZGVjIHx8IHRyYWNrLmNvZGVjO1xuICAgICAgICBsZXQgbWltZVR5cGUgPSBgJHt0cmFjay5jb250YWluZXJ9O2NvZGVjcz0ke2NvZGVjfWA7XG4gICAgICAgIGxvZ2dlci5sb2coYGNyZWF0aW5nIHNvdXJjZUJ1ZmZlciB3aXRoIG1pbWVUeXBlOiR7bWltZVR5cGV9YCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgbGV0IHNiID0gc291cmNlQnVmZmVyW3RyYWNrTmFtZV0gPSBtZWRpYVNvdXJjZS5hZGRTb3VyY2VCdWZmZXIobWltZVR5cGUpO1xuICAgICAgICAgIHNiLmFkZEV2ZW50TGlzdGVuZXIoJ3VwZGF0ZWVuZCcsIHRoaXMub25zYnVlKTtcbiAgICAgICAgICBzYi5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIHRoaXMub25zYmUpO1xuICAgICAgICAgIHRyYWNrLmJ1ZmZlciA9IHNiO1xuICAgICAgICB9IGNhdGNoKGVycikge1xuICAgICAgICAgIGxvZ2dlci5lcnJvcihgZXJyb3Igd2hpbGUgdHJ5aW5nIHRvIGFkZCBzb3VyY2VCdWZmZXI6JHtlcnIubWVzc2FnZX1gKTtcbiAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkVSUk9SLCB7dHlwZTogRXJyb3JUeXBlcy5NRURJQV9FUlJPUiwgZGV0YWlsczogRXJyb3JEZXRhaWxzLkJVRkZFUl9BRERfQ09ERUNfRVJST1IsIGZhdGFsOiBmYWxzZSwgZXJyOiBlcnIsIG1pbWVUeXBlIDogbWltZVR5cGV9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkJVRkZFUl9DUkVBVEVELCB7IHRyYWNrcyA6IHRyYWNrcyB9ICk7XG4gIH1cblxuICBvbkJ1ZmZlckFwcGVuZGluZyhkYXRhKSB7XG4gICAgaWYgKCF0aGlzLl9uZWVkc0ZsdXNoKSB7XG4gICAgICBpZiAoIXRoaXMuc2VnbWVudHMpIHtcbiAgICAgICAgdGhpcy5zZWdtZW50cyA9IFsgZGF0YSBdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zZWdtZW50cy5wdXNoKGRhdGEpO1xuICAgICAgfVxuICAgICAgdGhpcy5kb0FwcGVuZGluZygpO1xuICAgIH1cbiAgfVxuXG4gIG9uQnVmZmVyQXBwZW5kRmFpbChkYXRhKSB7XG4gICAgbG9nZ2VyLmVycm9yKGBzb3VyY2VCdWZmZXIgZXJyb3I6JHtkYXRhLmV2ZW50fWApO1xuICAgIC8vIGFjY29yZGluZyB0byBodHRwOi8vd3d3LnczLm9yZy9UUi9tZWRpYS1zb3VyY2UvI3NvdXJjZWJ1ZmZlci1hcHBlbmQtZXJyb3JcbiAgICAvLyB0aGlzIGVycm9yIG1pZ2h0IG5vdCBhbHdheXMgYmUgZmF0YWwgKGl0IGlzIGZhdGFsIGlmIGRlY29kZSBlcnJvciBpcyBzZXQsIGluIHRoYXQgY2FzZVxuICAgIC8vIGl0IHdpbGwgYmUgZm9sbG93ZWQgYnkgYSBtZWRpYUVsZW1lbnQgZXJyb3IgLi4uKVxuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuRVJST1IsIHt0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLCBkZXRhaWxzOiBFcnJvckRldGFpbHMuQlVGRkVSX0FQUEVORElOR19FUlJPUiwgZmF0YWw6IGZhbHNlLCBmcmFnOiB0aGlzLmZyYWdDdXJyZW50fSk7XG4gIH1cblxuICAvLyBvbiBCVUZGRVJfRU9TIG1hcmsgbWF0Y2hpbmcgc291cmNlYnVmZmVyKHMpIGFzIGVuZGVkIGFuZCB0cmlnZ2VyIGNoZWNrRW9zKClcbiAgb25CdWZmZXJFb3MoZGF0YSkge1xuICAgIHZhciBzYiA9IHRoaXMuc291cmNlQnVmZmVyO1xuICAgIGxldCBkYXRhVHlwZSA9IGRhdGEudHlwZTtcbiAgICBmb3IobGV0IHR5cGUgaW4gc2IpIHtcbiAgICAgIGlmICghZGF0YVR5cGUgfHwgdHlwZSA9PT0gZGF0YVR5cGUpIHtcbiAgICAgICAgaWYgKCFzYlt0eXBlXS5lbmRlZCkge1xuICAgICAgICAgIHNiW3R5cGVdLmVuZGVkID0gdHJ1ZTtcbiAgICAgICAgICBsb2dnZXIubG9nKGAke3R5cGV9IHNvdXJjZUJ1ZmZlciBub3cgRU9TYCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5jaGVja0VvcygpO1xuICB9XG5cbiAvLyBpZiBhbGwgc291cmNlIGJ1ZmZlcnMgYXJlIG1hcmtlZCBhcyBlbmRlZCwgc2lnbmFsIGVuZE9mU3RyZWFtKCkgdG8gTWVkaWFTb3VyY2UuXG4gY2hlY2tFb3MoKSB7XG4gICAgdmFyIHNiID0gdGhpcy5zb3VyY2VCdWZmZXIsIG1lZGlhU291cmNlID0gdGhpcy5tZWRpYVNvdXJjZTtcbiAgICBpZiAoIW1lZGlhU291cmNlIHx8IG1lZGlhU291cmNlLnJlYWR5U3RhdGUgIT09ICdvcGVuJykge1xuICAgICAgdGhpcy5fbmVlZHNFb3MgPSBmYWxzZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yKGxldCB0eXBlIGluIHNiKSB7XG4gICAgICBpZiAoIXNiW3R5cGVdLmVuZGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmKHNiW3R5cGVdLnVwZGF0aW5nKSB7XG4gICAgICAgIHRoaXMuX25lZWRzRW9zID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBsb2dnZXIubG9nKCdhbGwgbWVkaWEgZGF0YSBhdmFpbGFibGUsIHNpZ25hbCBlbmRPZlN0cmVhbSgpIHRvIE1lZGlhU291cmNlIGFuZCBzdG9wIGxvYWRpbmcgZnJhZ21lbnQnKTtcbiAgICAvL05vdGlmeSB0aGUgbWVkaWEgZWxlbWVudCB0aGF0IGl0IG5vdyBoYXMgYWxsIG9mIHRoZSBtZWRpYSBkYXRhXG4gICAgbWVkaWFTb3VyY2UuZW5kT2ZTdHJlYW0oKTtcbiAgICB0aGlzLl9uZWVkc0VvcyA9IGZhbHNlO1xuIH1cblxuXG4gIG9uQnVmZmVyRmx1c2hpbmcoZGF0YSkge1xuICAgIHRoaXMuZmx1c2hSYW5nZS5wdXNoKHtzdGFydDogZGF0YS5zdGFydE9mZnNldCwgZW5kOiBkYXRhLmVuZE9mZnNldCwgdHlwZSA6IGRhdGEudHlwZX0pO1xuICAgIC8vIGF0dGVtcHQgZmx1c2ggaW1tZWRpYXRseVxuICAgIHRoaXMuZmx1c2hCdWZmZXJDb3VudGVyID0gMDtcbiAgICB0aGlzLmRvRmx1c2goKTtcbiAgfVxuXG4gIG9uTGV2ZWxVcGRhdGVkKGV2ZW50KSB7XG4gICAgbGV0IGRldGFpbHMgPSBldmVudC5kZXRhaWxzO1xuICAgIGlmIChkZXRhaWxzLmZyYWdtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fbGV2ZWxEdXJhdGlvbiA9IGRldGFpbHMudG90YWxkdXJhdGlvbiArIGRldGFpbHMuZnJhZ21lbnRzWzBdLnN0YXJ0O1xuICAgIHRoaXMudXBkYXRlTWVkaWFFbGVtZW50RHVyYXRpb24oKTtcbiAgfVxuXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9kYWlseW1vdGlvbi9obHMuanMvaXNzdWVzLzM1NVxuICB1cGRhdGVNZWRpYUVsZW1lbnREdXJhdGlvbigpIHtcbiAgICBpZiAodGhpcy5fbGV2ZWxEdXJhdGlvbiA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgbWVkaWEgPSB0aGlzLm1lZGlhLFxuICAgICAgICBtZWRpYVNvdXJjZSA9IHRoaXMubWVkaWFTb3VyY2UsXG4gICAgICAgIHNvdXJjZUJ1ZmZlciA9IHRoaXMuc291cmNlQnVmZmVyO1xuICAgIGlmICghbWVkaWEgfHwgIW1lZGlhU291cmNlIHx8ICFzb3VyY2VCdWZmZXIgfHwgbWVkaWEucmVhZHlTdGF0ZSA9PT0gMCB8fCBtZWRpYVNvdXJjZS5yZWFkeVN0YXRlICE9PSAnb3BlbicpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChsZXQgdHlwZSBpbiBzb3VyY2VCdWZmZXIpIHtcbiAgICAgIGlmIChzb3VyY2VCdWZmZXJbdHlwZV0udXBkYXRpbmcpIHtcbiAgICAgICAgLy8gY2FuJ3Qgc2V0IGR1cmF0aW9uIHdoaWxzdCBhIGJ1ZmZlciBpcyB1cGRhdGluZ1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLl9tc0R1cmF0aW9uID09PSBudWxsKSB7XG4gICAgICAvLyBpbml0aWFsaXNlIHRvIHRoZSB2YWx1ZSB0aGF0IHRoZSBtZWRpYSBzb3VyY2UgaXMgcmVwb3J0aW5nXG4gICAgICB0aGlzLl9tc0R1cmF0aW9uID0gbWVkaWFTb3VyY2UuZHVyYXRpb247XG4gICAgfVxuICAgIC8vIHRoaXMuX2xldmVsRHVyYXRpb24gd2FzIHRoZSBsYXN0IHZhbHVlIHdlIHNldC5cbiAgICAvLyBub3QgdXNpbmcgbWVkaWFTb3VyY2UuZHVyYXRpb24gYXMgdGhlIGJyb3dzZXIgbWF5IHR3ZWFrIHRoaXMgdmFsdWVcbiAgICAvLyBvbmx5IHVwZGF0ZSBtZWRpYXNvdXJjZSBkdXJhdGlvbiBpZiBpdHMgdmFsdWUgaW5jcmVhc2UsIHRoaXMgaXMgdG8gYXZvaWRcbiAgICAvLyBmbHVzaGluZyBhbHJlYWR5IGJ1ZmZlcmVkIHBvcnRpb24gd2hlbiBzd2l0Y2hpbmcgYmV0d2VlbiBxdWFsaXR5IGxldmVsLCBhcyB0aGV5XG4gICAgaWYgKHRoaXMuX2xldmVsRHVyYXRpb24gPiB0aGlzLl9tc0R1cmF0aW9uKSB7XG4gICAgICBsb2dnZXIubG9nKGBVcGRhdGluZyBtZWRpYXNvdXJjZSBkdXJhdGlvbiB0byAke3RoaXMuX2xldmVsRHVyYXRpb259YCk7XG4gICAgICBtZWRpYVNvdXJjZS5kdXJhdGlvbiA9IHRoaXMuX2xldmVsRHVyYXRpb247XG4gICAgICB0aGlzLl9tc0R1cmF0aW9uID0gdGhpcy5fbGV2ZWxEdXJhdGlvbjtcbiAgICB9XG4gIH1cblxuICBkb0ZsdXNoKCkge1xuICAgIC8vIGxvb3AgdGhyb3VnaCBhbGwgYnVmZmVyIHJhbmdlcyB0byBmbHVzaFxuICAgIHdoaWxlKHRoaXMuZmx1c2hSYW5nZS5sZW5ndGgpIHtcbiAgICAgIHZhciByYW5nZSA9IHRoaXMuZmx1c2hSYW5nZVswXTtcbiAgICAgIC8vIGZsdXNoQnVmZmVyIHdpbGwgYWJvcnQgYW55IGJ1ZmZlciBhcHBlbmQgaW4gcHJvZ3Jlc3MgYW5kIGZsdXNoIEF1ZGlvL1ZpZGVvIEJ1ZmZlclxuICAgICAgaWYgKHRoaXMuZmx1c2hCdWZmZXIocmFuZ2Uuc3RhcnQsIHJhbmdlLmVuZCwgcmFuZ2UudHlwZSkpIHtcbiAgICAgICAgLy8gcmFuZ2UgZmx1c2hlZCwgcmVtb3ZlIGZyb20gZmx1c2ggYXJyYXlcbiAgICAgICAgdGhpcy5mbHVzaFJhbmdlLnNoaWZ0KCk7XG4gICAgICAgIHRoaXMuZmx1c2hCdWZmZXJDb3VudGVyID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX25lZWRzRmx1c2ggPSB0cnVlO1xuICAgICAgICAvLyBhdm9pZCBsb29waW5nLCB3YWl0IGZvciBTQiB1cGRhdGUgZW5kIHRvIHJldHJpZ2dlciBhIGZsdXNoXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMuZmx1c2hSYW5nZS5sZW5ndGggPT09IDApIHtcbiAgICAgIC8vIGV2ZXJ5dGhpbmcgZmx1c2hlZFxuICAgICAgdGhpcy5fbmVlZHNGbHVzaCA9IGZhbHNlO1xuXG4gICAgICAvLyBsZXQncyByZWNvbXB1dGUgdGhpcy5hcHBlbmRlZCwgd2hpY2ggaXMgdXNlZCB0byBhdm9pZCBmbHVzaCBsb29waW5nXG4gICAgICB2YXIgYXBwZW5kZWQgPSAwO1xuICAgICAgdmFyIHNvdXJjZUJ1ZmZlciA9IHRoaXMuc291cmNlQnVmZmVyO1xuICAgICAgZm9yICh2YXIgdHlwZSBpbiBzb3VyY2VCdWZmZXIpIHtcbiAgICAgICAgYXBwZW5kZWQgKz0gc291cmNlQnVmZmVyW3R5cGVdLmJ1ZmZlcmVkLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHRoaXMuYXBwZW5kZWQgPSBhcHBlbmRlZDtcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuQlVGRkVSX0ZMVVNIRUQpO1xuICAgIH1cbiAgfVxuXG4gIGRvQXBwZW5kaW5nKCkge1xuICAgIHZhciBobHMgPSB0aGlzLmhscywgc291cmNlQnVmZmVyID0gdGhpcy5zb3VyY2VCdWZmZXIsIHNlZ21lbnRzID0gdGhpcy5zZWdtZW50cztcbiAgICBpZiAoT2JqZWN0LmtleXMoc291cmNlQnVmZmVyKS5sZW5ndGgpIHtcbiAgICAgIGlmICh0aGlzLm1lZGlhLmVycm9yKSB7XG4gICAgICAgIHRoaXMuc2VnbWVudHMgPSBbXTtcbiAgICAgICAgbG9nZ2VyLmVycm9yKCd0cnlpbmcgdG8gYXBwZW5kIGFsdGhvdWdoIGEgbWVkaWEgZXJyb3Igb2NjdXJlZCwgZmx1c2ggc2VnbWVudCBhbmQgYWJvcnQnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuYXBwZW5kaW5nKSB7XG4gICAgICAgIC8vbG9nZ2VyLmxvZyhgc2IgYXBwZW5kaW5nIGluIHByb2dyZXNzYCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChzZWdtZW50cyAmJiBzZWdtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIHNlZ21lbnQgPSBzZWdtZW50cy5zaGlmdCgpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGxldCB0eXBlID0gc2VnbWVudC50eXBlO1xuICAgICAgICAgIGlmKHNvdXJjZUJ1ZmZlclt0eXBlXSkge1xuICAgICAgICAgICAgLy8gcmVzZXQgc291cmNlQnVmZmVyIGVuZGVkIGZsYWcgYmVmb3JlIGFwcGVuZGluZyBzZWdtZW50XG4gICAgICAgICAgICBzb3VyY2VCdWZmZXJbdHlwZV0uZW5kZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIC8vbG9nZ2VyLmxvZyhgYXBwZW5kaW5nICR7c2VnbWVudC5jb250ZW50fSAke3NlZ21lbnQudHlwZX0gU0IsIHNpemU6JHtzZWdtZW50LmRhdGEubGVuZ3RofSwgJHtzZWdtZW50LnBhcmVudH1gKTtcbiAgICAgICAgICAgIHRoaXMucGFyZW50ID0gc2VnbWVudC5wYXJlbnQ7XG4gICAgICAgICAgICBzb3VyY2VCdWZmZXJbdHlwZV0uYXBwZW5kQnVmZmVyKHNlZ21lbnQuZGF0YSk7XG4gICAgICAgICAgICB0aGlzLmFwcGVuZEVycm9yID0gMDtcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kZWQrKztcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kaW5nID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gaW4gY2FzZSB3ZSBkb24ndCBoYXZlIGFueSBzb3VyY2UgYnVmZmVyIG1hdGNoaW5nIHdpdGggdGhpcyBzZWdtZW50IHR5cGUsXG4gICAgICAgICAgICAvLyBpdCBtZWFucyB0aGF0IE1lZGlhc291cmNlIGZhaWxzIHRvIGNyZWF0ZSBzb3VyY2VidWZmZXJcbiAgICAgICAgICAgIC8vIGRpc2NhcmQgdGhpcyBzZWdtZW50LCBhbmQgdHJpZ2dlciB1cGRhdGUgZW5kXG4gICAgICAgICAgICB0aGlzLm9uU0JVcGRhdGVFbmQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2goZXJyKSB7XG4gICAgICAgICAgLy8gaW4gY2FzZSBhbnkgZXJyb3Igb2NjdXJlZCB3aGlsZSBhcHBlbmRpbmcsIHB1dCBiYWNrIHNlZ21lbnQgaW4gc2VnbWVudHMgdGFibGVcbiAgICAgICAgICBsb2dnZXIuZXJyb3IoYGVycm9yIHdoaWxlIHRyeWluZyB0byBhcHBlbmQgYnVmZmVyOiR7ZXJyLm1lc3NhZ2V9YCk7XG4gICAgICAgICAgc2VnbWVudHMudW5zaGlmdChzZWdtZW50KTtcbiAgICAgICAgICB2YXIgZXZlbnQgPSB7dHlwZTogRXJyb3JUeXBlcy5NRURJQV9FUlJPUn07XG4gICAgICAgICAgaWYoZXJyLmNvZGUgIT09IDIyKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5hcHBlbmRFcnJvcikge1xuICAgICAgICAgICAgICB0aGlzLmFwcGVuZEVycm9yKys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLmFwcGVuZEVycm9yID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV2ZW50LmRldGFpbHMgPSBFcnJvckRldGFpbHMuQlVGRkVSX0FQUEVORF9FUlJPUjtcbiAgICAgICAgICAgIGV2ZW50LmZyYWcgPSB0aGlzLmZyYWdDdXJyZW50O1xuICAgICAgICAgICAgLyogd2l0aCBVSEQgY29udGVudCwgd2UgY291bGQgZ2V0IGxvb3Agb2YgcXVvdGEgZXhjZWVkZWQgZXJyb3IgdW50aWxcbiAgICAgICAgICAgICAgYnJvd3NlciBpcyBhYmxlIHRvIGV2aWN0IHNvbWUgZGF0YSBmcm9tIHNvdXJjZWJ1ZmZlci4gcmV0cnlpbmcgaGVscCByZWNvdmVyaW5nIHRoaXNcbiAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAodGhpcy5hcHBlbmRFcnJvciA+IGhscy5jb25maWcuYXBwZW5kRXJyb3JNYXhSZXRyeSkge1xuICAgICAgICAgICAgICBsb2dnZXIubG9nKGBmYWlsICR7aGxzLmNvbmZpZy5hcHBlbmRFcnJvck1heFJldHJ5fSB0aW1lcyB0byBhcHBlbmQgc2VnbWVudCBpbiBzb3VyY2VCdWZmZXJgKTtcbiAgICAgICAgICAgICAgc2VnbWVudHMgPSBbXTtcbiAgICAgICAgICAgICAgZXZlbnQuZmF0YWwgPSB0cnVlO1xuICAgICAgICAgICAgICBobHMudHJpZ2dlcihFdmVudC5FUlJPUiwgZXZlbnQpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBldmVudC5mYXRhbCA9IGZhbHNlO1xuICAgICAgICAgICAgICBobHMudHJpZ2dlcihFdmVudC5FUlJPUiwgZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBRdW90YUV4Y2VlZGVkRXJyb3I6IGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1L2luZnJhc3RydWN0dXJlLmh0bWwjcXVvdGFleGNlZWRlZGVycm9yXG4gICAgICAgICAgICAvLyBsZXQncyBzdG9wIGFwcGVuZGluZyBhbnkgc2VnbWVudHMsIGFuZCByZXBvcnQgQlVGRkVSX0ZVTExfRVJST1IgZXJyb3JcbiAgICAgICAgICAgIHRoaXMuc2VnbWVudHMgPSBbXTtcbiAgICAgICAgICAgIGV2ZW50LmRldGFpbHMgPSBFcnJvckRldGFpbHMuQlVGRkVSX0ZVTExfRVJST1I7XG4gICAgICAgICAgICBobHMudHJpZ2dlcihFdmVudC5FUlJPUixldmVudCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLypcbiAgICBmbHVzaCBzcGVjaWZpZWQgYnVmZmVyZWQgcmFuZ2UsXG4gICAgcmV0dXJuIHRydWUgb25jZSByYW5nZSBoYXMgYmVlbiBmbHVzaGVkLlxuICAgIGFzIHNvdXJjZUJ1ZmZlci5yZW1vdmUoKSBpcyBhc3luY2hyb25vdXMsIGZsdXNoQnVmZmVyIHdpbGwgYmUgcmV0cmlnZ2VyZWQgb24gc291cmNlQnVmZmVyIHVwZGF0ZSBlbmRcbiAgKi9cbiAgZmx1c2hCdWZmZXIoc3RhcnRPZmZzZXQsIGVuZE9mZnNldCwgdHlwZUluKSB7XG4gICAgdmFyIHNiLCBpLCBidWZTdGFydCwgYnVmRW5kLCBmbHVzaFN0YXJ0LCBmbHVzaEVuZCwgc291cmNlQnVmZmVyID0gdGhpcy5zb3VyY2VCdWZmZXI7XG4gICAgaWYgKE9iamVjdC5rZXlzKHNvdXJjZUJ1ZmZlcikubGVuZ3RoKSB7XG4gICAgICBsb2dnZXIubG9nKCdmbHVzaEJ1ZmZlcixwb3Mvc3RhcnQvZW5kOiAnICsgdGhpcy5tZWRpYS5jdXJyZW50VGltZSArICcvJyArIHN0YXJ0T2Zmc2V0ICsgJy8nICsgZW5kT2Zmc2V0KTtcbiAgICAgIC8vIHNhZmVndWFyZCB0byBhdm9pZCBpbmZpbml0ZSBsb29waW5nIDogZG9uJ3QgdHJ5IHRvIGZsdXNoIG1vcmUgdGhhbiB0aGUgbmIgb2YgYXBwZW5kZWQgc2VnbWVudHNcbiAgICAgIGlmICh0aGlzLmZsdXNoQnVmZmVyQ291bnRlciA8IHRoaXMuYXBwZW5kZWQpIHtcbiAgICAgICAgZm9yICh2YXIgdHlwZSBpbiBzb3VyY2VCdWZmZXIpIHtcbiAgICAgICAgICAvLyBjaGVjayBpZiBzb3VyY2VidWZmZXIgdHlwZSBpcyBkZWZpbmVkICh0eXBlSW4pOiBpZiB5ZXMsIGxldCdzIG9ubHkgZmx1c2ggdGhpcyBvbmVcbiAgICAgICAgICAvLyBpZiBubywgbGV0J3MgZmx1c2ggYWxsIHNvdXJjZWJ1ZmZlcnNcbiAgICAgICAgICBpZiAodHlwZUluICYmIHR5cGUgIT09IHR5cGVJbikge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNiID0gc291cmNlQnVmZmVyW3R5cGVdO1xuICAgICAgICAgIC8vIHdlIGFyZSBnb2luZyB0byBmbHVzaCBidWZmZXIsIG1hcmsgc291cmNlIGJ1ZmZlciBhcyAnbm90IGVuZGVkJ1xuICAgICAgICAgIHNiLmVuZGVkID0gZmFsc2U7XG4gICAgICAgICAgaWYgKCFzYi51cGRhdGluZykge1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHNiLmJ1ZmZlcmVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIGJ1ZlN0YXJ0ID0gc2IuYnVmZmVyZWQuc3RhcnQoaSk7XG4gICAgICAgICAgICAgIGJ1ZkVuZCA9IHNiLmJ1ZmZlcmVkLmVuZChpKTtcbiAgICAgICAgICAgICAgLy8gd29ya2Fyb3VuZCBmaXJlZm94IG5vdCBhYmxlIHRvIHByb3Blcmx5IGZsdXNoIG11bHRpcGxlIGJ1ZmZlcmVkIHJhbmdlLlxuICAgICAgICAgICAgICBpZiAobmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ2ZpcmVmb3gnKSAhPT0gLTEgJiYgZW5kT2Zmc2V0ID09PSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpIHtcbiAgICAgICAgICAgICAgICBmbHVzaFN0YXJ0ID0gc3RhcnRPZmZzZXQ7XG4gICAgICAgICAgICAgICAgZmx1c2hFbmQgPSBlbmRPZmZzZXQ7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZmx1c2hTdGFydCA9IE1hdGgubWF4KGJ1ZlN0YXJ0LCBzdGFydE9mZnNldCk7XG4gICAgICAgICAgICAgICAgZmx1c2hFbmQgPSBNYXRoLm1pbihidWZFbmQsIGVuZE9mZnNldCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLyogc29tZXRpbWVzIHNvdXJjZWJ1ZmZlci5yZW1vdmUoKSBkb2VzIG5vdCBmbHVzaFxuICAgICAgICAgICAgICAgICB0aGUgZXhhY3QgZXhwZWN0ZWQgdGltZSByYW5nZS5cbiAgICAgICAgICAgICAgICAgdG8gYXZvaWQgcm91bmRpbmcgaXNzdWVzL2luZmluaXRlIGxvb3AsXG4gICAgICAgICAgICAgICAgIG9ubHkgZmx1c2ggYnVmZmVyIHJhbmdlIG9mIGxlbmd0aCBncmVhdGVyIHRoYW4gNTAwbXMuXG4gICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgIGlmIChNYXRoLm1pbihmbHVzaEVuZCxidWZFbmQpIC0gZmx1c2hTdGFydCA+IDAuNSApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZsdXNoQnVmZmVyQ291bnRlcisrO1xuICAgICAgICAgICAgICAgIGxvZ2dlci5sb2coYGZsdXNoICR7dHlwZX0gWyR7Zmx1c2hTdGFydH0sJHtmbHVzaEVuZH1dLCBvZiBbJHtidWZTdGFydH0sJHtidWZFbmR9XSwgcG9zOiR7dGhpcy5tZWRpYS5jdXJyZW50VGltZX1gKTtcbiAgICAgICAgICAgICAgICBzYi5yZW1vdmUoZmx1c2hTdGFydCwgZmx1c2hFbmQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvL2xvZ2dlci5sb2coJ2Fib3J0ICcgKyB0eXBlICsgJyBhcHBlbmQgaW4gcHJvZ3Jlc3MnKTtcbiAgICAgICAgICAgIC8vIHRoaXMgd2lsbCBhYm9ydCBhbnkgYXBwZW5kaW5nIGluIHByb2dyZXNzXG4gICAgICAgICAgICAvL3NiLmFib3J0KCk7XG4gICAgICAgICAgICBsb2dnZXIud2FybignY2Fubm90IGZsdXNoLCBzYiB1cGRhdGluZyBpbiBwcm9ncmVzcycpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbG9nZ2VyLndhcm4oJ2Fib3J0IGZsdXNoaW5nIHRvbyBtYW55IHJldHJpZXMnKTtcbiAgICAgIH1cbiAgICAgIGxvZ2dlci5sb2coJ2J1ZmZlciBmbHVzaGVkJyk7XG4gICAgfVxuICAgIC8vIGV2ZXJ5dGhpbmcgZmx1c2hlZCAhXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQnVmZmVyQ29udHJvbGxlcjtcbiIsIi8qXG4gKiBjYXAgc3RyZWFtIGxldmVsIHRvIG1lZGlhIHNpemUgZGltZW5zaW9uIGNvbnRyb2xsZXJcbiovXG5cbmltcG9ydCBFdmVudCBmcm9tICcuLi9ldmVudHMnO1xuaW1wb3J0IEV2ZW50SGFuZGxlciBmcm9tICcuLi9ldmVudC1oYW5kbGVyJztcblxuY2xhc3MgQ2FwTGV2ZWxDb250cm9sbGVyIGV4dGVuZHMgRXZlbnRIYW5kbGVyIHtcblx0Y29uc3RydWN0b3IoaGxzKSB7XG4gICAgc3VwZXIoaGxzLFxuICAgICAgRXZlbnQuRlBTX0RST1BfTEVWRUxfQ0FQUElORyxcbiAgICAgIEV2ZW50Lk1FRElBX0FUVEFDSElORyxcbiAgICAgIEV2ZW50Lk1BTklGRVNUX1BBUlNFRCk7ICAgXG5cdH1cblx0XG5cdGRlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMuaGxzLmNvbmZpZy5jYXBMZXZlbFRvUGxheWVyU2l6ZSkge1xuICAgICAgdGhpcy5tZWRpYSA9IHRoaXMucmVzdHJpY3RlZExldmVscyA9IG51bGw7XG4gICAgICB0aGlzLmF1dG9MZXZlbENhcHBpbmcgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgICBpZiAodGhpcy50aW1lcikge1xuICAgICAgICB0aGlzLnRpbWVyID0gY2xlYXJJbnRlcnZhbCh0aGlzLnRpbWVyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblx0XG4gIG9uRnBzRHJvcExldmVsQ2FwcGluZyhkYXRhKSB7XG4gICAgaWYgKCF0aGlzLnJlc3RyaWN0ZWRMZXZlbHMpIHtcbiAgICAgIHRoaXMucmVzdHJpY3RlZExldmVscyA9IFtdO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuaXNMZXZlbFJlc3RyaWN0ZWQoZGF0YS5kcm9wcGVkTGV2ZWwpKSB7XG4gICAgICB0aGlzLnJlc3RyaWN0ZWRMZXZlbHMucHVzaChkYXRhLmRyb3BwZWRMZXZlbCk7XG4gICAgfVxuICB9XG4gIFxuXHRvbk1lZGlhQXR0YWNoaW5nKGRhdGEpIHtcbiAgICB0aGlzLm1lZGlhID0gZGF0YS5tZWRpYSBpbnN0YW5jZW9mIEhUTUxWaWRlb0VsZW1lbnQgPyBkYXRhLm1lZGlhIDogbnVsbDsgIFxuICB9XG5cbiAgb25NYW5pZmVzdFBhcnNlZChkYXRhKSB7XG4gICAgaWYgKHRoaXMuaGxzLmNvbmZpZy5jYXBMZXZlbFRvUGxheWVyU2l6ZSkge1xuICAgICAgdGhpcy5hdXRvTGV2ZWxDYXBwaW5nID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgICAgdGhpcy5sZXZlbHMgPSBkYXRhLmxldmVscztcbiAgICAgIHRoaXMuaGxzLmZpcnN0TGV2ZWwgPSB0aGlzLmdldE1heExldmVsKGRhdGEuZmlyc3RMZXZlbCk7XG4gICAgICBjbGVhckludGVydmFsKHRoaXMudGltZXIpO1xuICAgICAgdGhpcy50aW1lciA9IHNldEludGVydmFsKHRoaXMuZGV0ZWN0UGxheWVyU2l6ZS5iaW5kKHRoaXMpLCAxMDAwKTtcbiAgICAgIHRoaXMuZGV0ZWN0UGxheWVyU2l6ZSgpO1xuICAgIH1cbiAgfVxuICBcbiAgZGV0ZWN0UGxheWVyU2l6ZSgpIHtcbiAgICBpZiAodGhpcy5tZWRpYSkge1xuICAgICAgbGV0IGxldmVsc0xlbmd0aCA9IHRoaXMubGV2ZWxzID8gdGhpcy5sZXZlbHMubGVuZ3RoIDogMDtcbiAgICAgIGlmIChsZXZlbHNMZW5ndGgpIHtcbiAgICAgICAgdGhpcy5obHMuYXV0b0xldmVsQ2FwcGluZyA9IHRoaXMuZ2V0TWF4TGV2ZWwobGV2ZWxzTGVuZ3RoIC0gMSk7XG4gICAgICAgIGlmICh0aGlzLmhscy5hdXRvTGV2ZWxDYXBwaW5nID4gdGhpcy5hdXRvTGV2ZWxDYXBwaW5nKSB7XG4gICAgICAgICAgLy8gaWYgYXV0byBsZXZlbCBjYXBwaW5nIGhhcyBhIGhpZ2hlciB2YWx1ZSBmb3IgdGhlIHByZXZpb3VzIG9uZSwgZmx1c2ggdGhlIGJ1ZmZlciB1c2luZyBuZXh0TGV2ZWxTd2l0Y2hcbiAgICAgICAgICAvLyB1c3VhbGx5IGhhcHBlbiB3aGVuIHRoZSB1c2VyIGdvIHRvIHRoZSBmdWxsc2NyZWVuIG1vZGUuXG4gICAgICAgICAgdGhpcy5obHMuc3RyZWFtQ29udHJvbGxlci5uZXh0TGV2ZWxTd2l0Y2goKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmF1dG9MZXZlbENhcHBpbmcgPSB0aGlzLmhscy5hdXRvTGV2ZWxDYXBwaW5nOyAgICAgICAgXG4gICAgICB9ICBcbiAgICB9XG4gIH1cbiAgXG4gIC8qXG4gICogcmV0dXJucyBsZXZlbCBzaG91bGQgYmUgdGhlIG9uZSB3aXRoIHRoZSBkaW1lbnNpb25zIGVxdWFsIG9yIGdyZWF0ZXIgdGhhbiB0aGUgbWVkaWEgKHBsYXllcikgZGltZW5zaW9ucyAoc28gdGhlIHZpZGVvIHdpbGwgYmUgZG93bnNjYWxlZClcbiAgKi9cbiAgZ2V0TWF4TGV2ZWwoY2FwTGV2ZWxJbmRleCkge1xuICAgIGxldCByZXN1bHQgPSAwLFxuICAgICAgICBpLFxuICAgICAgICBsZXZlbCxcbiAgICAgICAgbVdpZHRoID0gdGhpcy5tZWRpYVdpZHRoLFxuICAgICAgICBtSGVpZ2h0ID0gdGhpcy5tZWRpYUhlaWdodCxcbiAgICAgICAgbFdpZHRoID0gMCxcbiAgICAgICAgbEhlaWdodCA9IDA7XG4gICAgICAgIFxuICAgIGZvciAoaSA9IDA7IGkgPD0gY2FwTGV2ZWxJbmRleDsgaSsrKSB7XG4gICAgICBsZXZlbCA9IHRoaXMubGV2ZWxzW2ldO1xuICAgICAgaWYgKHRoaXMuaXNMZXZlbFJlc3RyaWN0ZWQoaSkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICByZXN1bHQgPSBpO1xuICAgICAgbFdpZHRoID0gbGV2ZWwud2lkdGg7XG4gICAgICBsSGVpZ2h0ID0gbGV2ZWwuaGVpZ2h0O1xuICAgICAgaWYgKG1XaWR0aCA8PSBsV2lkdGggfHwgbUhlaWdodCA8PSBsSGVpZ2h0KSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gIFxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgXG4gIGlzTGV2ZWxSZXN0cmljdGVkKGxldmVsKSB7XG4gICAgcmV0dXJuICh0aGlzLnJlc3RyaWN0ZWRMZXZlbHMgJiYgdGhpcy5yZXN0cmljdGVkTGV2ZWxzLmluZGV4T2YobGV2ZWwpICE9PSAtMSkgPyB0cnVlIDogZmFsc2U7XG4gIH1cbiAgXG4gIGdldCBjb250ZW50U2NhbGVGYWN0b3IoKSB7XG4gICAgbGV0IHBpeGVsUmF0aW8gPSAxO1xuICAgIHRyeSB7XG4gICAgICBwaXhlbFJhdGlvID0gIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvO1xuICAgIH0gY2F0Y2goZSkge31cbiAgICByZXR1cm4gcGl4ZWxSYXRpbztcbiAgfVxuICBcbiAgZ2V0IG1lZGlhV2lkdGgoKSB7XG4gICAgbGV0IHdpZHRoO1xuICAgIGlmICh0aGlzLm1lZGlhKSB7XG4gICAgICB3aWR0aCA9IHRoaXMubWVkaWEud2lkdGggfHwgdGhpcy5tZWRpYS5jbGllbnRXaWR0aCB8fCB0aGlzLm1lZGlhLm9mZnNldFdpZHRoO1xuICAgICAgd2lkdGggKj0gdGhpcy5jb250ZW50U2NhbGVGYWN0b3I7XG4gICAgfVxuICAgIHJldHVybiB3aWR0aDtcbiAgfVxuICBcbiAgZ2V0IG1lZGlhSGVpZ2h0KCkge1xuICAgIGxldCBoZWlnaHQ7XG4gICAgaWYgKHRoaXMubWVkaWEpIHtcbiAgICAgIGhlaWdodCA9IHRoaXMubWVkaWEuaGVpZ2h0IHx8IHRoaXMubWVkaWEuY2xpZW50SGVpZ2h0IHx8IHRoaXMubWVkaWEub2Zmc2V0SGVpZ2h0O1xuICAgICAgaGVpZ2h0ICo9IHRoaXMuY29udGVudFNjYWxlRmFjdG9yOyBcbiAgICB9XG4gICAgcmV0dXJuIGhlaWdodDtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDYXBMZXZlbENvbnRyb2xsZXI7IiwiLypcbiAqIEVXTUEgQmFuZHdpZHRoIEVzdGltYXRvclxuICogIC0gaGVhdmlseSBpbnNwaXJlZCBmcm9tIHNoYWthLXBsYXllclxuICogVHJhY2tzIGJhbmR3aWR0aCBzYW1wbGVzIGFuZCBlc3RpbWF0ZXMgYXZhaWxhYmxlIGJhbmR3aWR0aC5cbiAqIEJhc2VkIG9uIHRoZSBtaW5pbXVtIG9mIHR3byBleHBvbmVudGlhbGx5LXdlaWdodGVkIG1vdmluZyBhdmVyYWdlcyB3aXRoXG4gKiBkaWZmZXJlbnQgaGFsZi1saXZlcy5cbiAqL1xuXG5pbXBvcnQgRVdNQSBmcm9tICcuLi91dGlscy9ld21hJztcblxuXG5jbGFzcyBFd21hQmFuZFdpZHRoRXN0aW1hdG9yIHtcblxuICBjb25zdHJ1Y3RvcihobHMsc2xvdyxmYXN0LGRlZmF1bHRFc3RpbWF0ZSkge1xuICAgIHRoaXMuaGxzID0gaGxzO1xuICAgIHRoaXMuZGVmYXVsdEVzdGltYXRlXyA9IGRlZmF1bHRFc3RpbWF0ZTtcbiAgICB0aGlzLm1pbldlaWdodF8gPSAwLjAwMTtcbiAgICB0aGlzLm1pbkRlbGF5TXNfID0gNTA7XG4gICAgdGhpcy5zbG93XyA9IG5ldyBFV01BKHNsb3cpO1xuICAgIHRoaXMuZmFzdF8gPSBuZXcgRVdNQShmYXN0KTtcbiAgfVxuXG4gIHNhbXBsZShkdXJhdGlvbk1zLG51bUJ5dGVzKSB7XG4gICAgZHVyYXRpb25NcyA9IE1hdGgubWF4KGR1cmF0aW9uTXMsIHRoaXMubWluRGVsYXlNc18pO1xuICAgIHZhciBiYW5kd2lkdGggPSA4MDAwKiBudW1CeXRlcyAvIGR1cmF0aW9uTXMsXG4gICAgLy9jb25zb2xlLmxvZygnaW5zdGFudCBidzonKyBNYXRoLnJvdW5kKGJhbmR3aWR0aCkpO1xuICAgIC8vIHdlIHdlaWdodCBzYW1wbGUgdXNpbmcgbG9hZGluZyBkdXJhdGlvbi4uLi5cbiAgICAgICAgd2VpZ2h0ID0gZHVyYXRpb25NcyAvIDEwMDA7XG4gICAgdGhpcy5mYXN0Xy5zYW1wbGUod2VpZ2h0LGJhbmR3aWR0aCk7XG4gICAgdGhpcy5zbG93Xy5zYW1wbGUod2VpZ2h0LGJhbmR3aWR0aCk7XG4gIH1cblxuICBjYW5Fc3RpbWF0ZSgpIHtcbiAgICBsZXQgZmFzdCA9IHRoaXMuZmFzdF87XG4gICAgcmV0dXJuIChmYXN0ICYmIGZhc3QuZ2V0VG90YWxXZWlnaHQoKSA+PSB0aGlzLm1pbldlaWdodF8pO1xuICB9XG5cblxuICBnZXRFc3RpbWF0ZSgpIHtcbiAgICBpZiAodGhpcy5jYW5Fc3RpbWF0ZSgpKSB7XG4gICAgICAvL2NvbnNvbGUubG9nKCdzbG93IGVzdGltYXRlOicrIE1hdGgucm91bmQodGhpcy5zbG93Xy5nZXRFc3RpbWF0ZSgpKSk7XG4gICAgICAvL2NvbnNvbGUubG9nKCdmYXN0IGVzdGltYXRlOicrIE1hdGgucm91bmQodGhpcy5mYXN0Xy5nZXRFc3RpbWF0ZSgpKSk7XG4gICAgICAvLyBUYWtlIHRoZSBtaW5pbXVtIG9mIHRoZXNlIHR3byBlc3RpbWF0ZXMuICBUaGlzIHNob3VsZCBoYXZlIHRoZSBlZmZlY3Qgb2ZcbiAgICAgIC8vIGFkYXB0aW5nIGRvd24gcXVpY2tseSwgYnV0IHVwIG1vcmUgc2xvd2x5LlxuICAgICAgcmV0dXJuIE1hdGgubWluKHRoaXMuZmFzdF8uZ2V0RXN0aW1hdGUoKSx0aGlzLnNsb3dfLmdldEVzdGltYXRlKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5kZWZhdWx0RXN0aW1hdGVfO1xuICAgIH1cbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gIH1cbn1cbmV4cG9ydCBkZWZhdWx0IEV3bWFCYW5kV2lkdGhFc3RpbWF0b3I7XG5cbiIsIi8qXG4gKiBGUFMgQ29udHJvbGxlclxuKi9cblxuaW1wb3J0IEV2ZW50IGZyb20gJy4uL2V2ZW50cyc7XG5pbXBvcnQgRXZlbnRIYW5kbGVyIGZyb20gJy4uL2V2ZW50LWhhbmRsZXInO1xuaW1wb3J0IHtsb2dnZXJ9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XG5cbmNsYXNzIEZQU0NvbnRyb2xsZXIgZXh0ZW5kcyBFdmVudEhhbmRsZXJ7XG5cbiAgY29uc3RydWN0b3IoaGxzKSB7XG4gICAgc3VwZXIoaGxzLCBFdmVudC5NRURJQV9BVFRBQ0hJTkcpO1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICBpZiAodGhpcy50aW1lcikge1xuICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLnRpbWVyKTtcbiAgICB9XG4gICAgdGhpcy5pc1ZpZGVvUGxheWJhY2tRdWFsaXR5QXZhaWxhYmxlID0gZmFsc2U7XG4gIH1cbiAgXG4gIG9uTWVkaWFBdHRhY2hpbmcoZGF0YSkge1xuICAgIGlmICh0aGlzLmhscy5jb25maWcuY2FwTGV2ZWxPbkZQU0Ryb3ApIHtcbiAgICAgIHRoaXMudmlkZW8gPSBkYXRhLm1lZGlhIGluc3RhbmNlb2YgSFRNTFZpZGVvRWxlbWVudCA/IGRhdGEubWVkaWEgOiBudWxsO1xuICAgICAgaWYgKHR5cGVvZiB0aGlzLnZpZGVvLmdldFZpZGVvUGxheWJhY2tRdWFsaXR5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMuaXNWaWRlb1BsYXliYWNrUXVhbGl0eUF2YWlsYWJsZSA9IHRydWU7XG4gICAgICB9XG4gICAgICBjbGVhckludGVydmFsKHRoaXMudGltZXIpO1xuICAgICAgdGhpcy50aW1lciA9IHNldEludGVydmFsKHRoaXMuY2hlY2tGUFNJbnRlcnZhbC5iaW5kKHRoaXMpLCB0aGlzLmhscy5jb25maWcuZnBzRHJvcHBlZE1vbml0b3JpbmdQZXJpb2QpO1xuICAgIH0gXG4gIH1cbiAgXG4gIGNoZWNrRlBTKHZpZGVvLCBkZWNvZGVkRnJhbWVzLCBkcm9wcGVkRnJhbWVzKSB7XG4gICAgbGV0IGN1cnJlbnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgaWYgKGRlY29kZWRGcmFtZXMpIHtcbiAgICAgIGlmICh0aGlzLmxhc3RUaW1lKSB7XG4gICAgICAgIGxldCBjdXJyZW50UGVyaW9kID0gY3VycmVudFRpbWUgLSB0aGlzLmxhc3RUaW1lLFxuICAgICAgICAgICAgY3VycmVudERyb3BwZWQgPSBkcm9wcGVkRnJhbWVzIC0gdGhpcy5sYXN0RHJvcHBlZEZyYW1lcyxcbiAgICAgICAgICAgIGN1cnJlbnREZWNvZGVkID0gZGVjb2RlZEZyYW1lcyAtIHRoaXMubGFzdERlY29kZWRGcmFtZXMsXG4gICAgICAgICAgICBkcm9wcGVkRlBTID0gMTAwMCAqIGN1cnJlbnREcm9wcGVkIC8gY3VycmVudFBlcmlvZDtcbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5GUFNfRFJPUCwge2N1cnJlbnREcm9wcGVkOiBjdXJyZW50RHJvcHBlZCwgY3VycmVudERlY29kZWQ6IGN1cnJlbnREZWNvZGVkLCB0b3RhbERyb3BwZWRGcmFtZXM6IGRyb3BwZWRGcmFtZXN9KTtcbiAgICAgICAgaWYgKGRyb3BwZWRGUFMgPiAwKSB7XG4gICAgICAgICAgLy9sb2dnZXIubG9nKCdjaGVja0ZQUyA6IGRyb3BwZWRGUFMvZGVjb2RlZEZQUzonICsgZHJvcHBlZEZQUy8oMTAwMCAqIGN1cnJlbnREZWNvZGVkIC8gY3VycmVudFBlcmlvZCkpO1xuICAgICAgICAgIGlmIChjdXJyZW50RHJvcHBlZCA+IHRoaXMuaGxzLmNvbmZpZy5mcHNEcm9wcGVkTW9uaXRvcmluZ1RocmVzaG9sZCAqIGN1cnJlbnREZWNvZGVkKSB7XG4gICAgICAgICAgICBsZXQgY3VycmVudExldmVsID0gdGhpcy5obHMuY3VycmVudExldmVsO1xuICAgICAgICAgICAgbG9nZ2VyLndhcm4oJ2Ryb3AgRlBTIHJhdGlvIGdyZWF0ZXIgdGhhbiBtYXggYWxsb3dlZCB2YWx1ZSBmb3IgY3VycmVudExldmVsOiAnICsgY3VycmVudExldmVsKTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50TGV2ZWwgPiAwICYmICh0aGlzLmhscy5hdXRvTGV2ZWxDYXBwaW5nID09PSAtMSB8fCB0aGlzLmhscy5hdXRvTGV2ZWxDYXBwaW5nID49IGN1cnJlbnRMZXZlbCkpIHtcbiAgICAgICAgICAgICAgY3VycmVudExldmVsID0gY3VycmVudExldmVsIC0gMTtcbiAgICAgICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5GUFNfRFJPUF9MRVZFTF9DQVBQSU5HLCB7bGV2ZWw6IGN1cnJlbnRMZXZlbCwgZHJvcHBlZExldmVsOiB0aGlzLmhscy5jdXJyZW50TGV2ZWx9KTtcbiAgICAgICAgICAgICAgdGhpcy5obHMuYXV0b0xldmVsQ2FwcGluZyA9IGN1cnJlbnRMZXZlbDtcbiAgICAgICAgICAgICAgdGhpcy5obHMuc3RyZWFtQ29udHJvbGxlci5uZXh0TGV2ZWxTd2l0Y2goKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMubGFzdFRpbWUgPSBjdXJyZW50VGltZTtcbiAgICAgIHRoaXMubGFzdERyb3BwZWRGcmFtZXMgPSBkcm9wcGVkRnJhbWVzO1xuICAgICAgdGhpcy5sYXN0RGVjb2RlZEZyYW1lcyA9IGRlY29kZWRGcmFtZXM7XG4gICAgfVxuICB9XG4gIFxuICBjaGVja0ZQU0ludGVydmFsKCkge1xuICAgIGlmICh0aGlzLnZpZGVvKSB7XG4gICAgICBpZiAodGhpcy5pc1ZpZGVvUGxheWJhY2tRdWFsaXR5QXZhaWxhYmxlKSB7XG4gICAgICAgIGxldCB2aWRlb1BsYXliYWNrUXVhbGl0eSA9IHRoaXMudmlkZW8uZ2V0VmlkZW9QbGF5YmFja1F1YWxpdHkoKTtcbiAgICAgICAgdGhpcy5jaGVja0ZQUyh0aGlzLnZpZGVvLCB2aWRlb1BsYXliYWNrUXVhbGl0eS50b3RhbFZpZGVvRnJhbWVzLCB2aWRlb1BsYXliYWNrUXVhbGl0eS5kcm9wcGVkVmlkZW9GcmFtZXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jaGVja0ZQUyh0aGlzLnZpZGVvLCB0aGlzLnZpZGVvLndlYmtpdERlY29kZWRGcmFtZUNvdW50LCB0aGlzLnZpZGVvLndlYmtpdERyb3BwZWRGcmFtZUNvdW50KTsgIFxuICAgICAgfVxuICAgIH1cbiAgfSBcbn1cblxuZXhwb3J0IGRlZmF1bHQgRlBTQ29udHJvbGxlcjtcblxuIiwiLypcbiAqIExldmVsIENvbnRyb2xsZXJcbiovXG5cbmltcG9ydCBFdmVudCBmcm9tICcuLi9ldmVudHMnO1xuaW1wb3J0IEV2ZW50SGFuZGxlciBmcm9tICcuLi9ldmVudC1oYW5kbGVyJztcbmltcG9ydCB7bG9nZ2VyfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xuaW1wb3J0IHtFcnJvclR5cGVzLCBFcnJvckRldGFpbHN9IGZyb20gJy4uL2Vycm9ycyc7XG5cbmNsYXNzIExldmVsQ29udHJvbGxlciBleHRlbmRzIEV2ZW50SGFuZGxlciB7XG5cbiAgY29uc3RydWN0b3IoaGxzKSB7XG4gICAgc3VwZXIoaGxzLFxuICAgICAgRXZlbnQuTUFOSUZFU1RfTE9BREVELFxuICAgICAgRXZlbnQuTEVWRUxfTE9BREVELFxuICAgICAgRXZlbnQuRVJST1IpO1xuICAgIHRoaXMub250aWNrID0gdGhpcy50aWNrLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fbWFudWFsTGV2ZWwgPSB0aGlzLl9hdXRvTGV2ZWxDYXBwaW5nID0gLTE7XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIGlmICh0aGlzLnRpbWVyKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lcik7XG4gICAgICB0aGlzLnRpbWVyID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5fbWFudWFsTGV2ZWwgPSAtMTtcbiAgfVxuXG4gIHN0YXJ0TG9hZCgpIHtcbiAgICB0aGlzLmNhbmxvYWQgPSB0cnVlO1xuICAgIC8vIHNwZWVkIHVwIGxpdmUgcGxheWxpc3QgcmVmcmVzaCBpZiB0aW1lciBleGlzdHNcbiAgICBpZiAodGhpcy50aW1lcikge1xuICAgICAgdGhpcy50aWNrKCk7XG4gICAgfVxuICB9XG5cbiAgc3RvcExvYWQoKSB7XG4gICAgdGhpcy5jYW5sb2FkID0gZmFsc2U7XG4gIH1cblxuICBvbk1hbmlmZXN0TG9hZGVkKGRhdGEpIHtcbiAgICB2YXIgbGV2ZWxzMCA9IFtdLCBsZXZlbHMgPSBbXSwgYml0cmF0ZVN0YXJ0LCBpLCBiaXRyYXRlU2V0ID0ge30sIHZpZGVvQ29kZWNGb3VuZCA9IGZhbHNlLCBhdWRpb0NvZGVjRm91bmQgPSBmYWxzZSwgaGxzID0gdGhpcy5obHM7XG5cbiAgICAvLyByZWdyb3VwIHJlZHVuZGFudCBsZXZlbCB0b2dldGhlclxuICAgIGRhdGEubGV2ZWxzLmZvckVhY2gobGV2ZWwgPT4ge1xuICAgICAgaWYobGV2ZWwudmlkZW9Db2RlYykge1xuICAgICAgICB2aWRlb0NvZGVjRm91bmQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYobGV2ZWwuYXVkaW9Db2RlYyB8fCAobGV2ZWwuYXR0cnMgJiYgbGV2ZWwuYXR0cnMuQVVESU8pKSB7XG4gICAgICAgIGF1ZGlvQ29kZWNGb3VuZCA9IHRydWU7XG4gICAgICB9XG4gICAgICB2YXIgcmVkdW5kYW50TGV2ZWxJZCA9IGJpdHJhdGVTZXRbbGV2ZWwuYml0cmF0ZV07XG4gICAgICBpZiAocmVkdW5kYW50TGV2ZWxJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGJpdHJhdGVTZXRbbGV2ZWwuYml0cmF0ZV0gPSBsZXZlbHMwLmxlbmd0aDtcbiAgICAgICAgbGV2ZWwudXJsID0gW2xldmVsLnVybF07XG4gICAgICAgIGxldmVsLnVybElkID0gMDtcbiAgICAgICAgbGV2ZWxzMC5wdXNoKGxldmVsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldmVsczBbcmVkdW5kYW50TGV2ZWxJZF0udXJsLnB1c2gobGV2ZWwudXJsKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIHJlbW92ZSBhdWRpby1vbmx5IGxldmVsIGlmIHdlIGFsc28gaGF2ZSBsZXZlbHMgd2l0aCBhdWRpbyt2aWRlbyBjb2RlY3Mgc2lnbmFsbGVkXG4gICAgaWYodmlkZW9Db2RlY0ZvdW5kICYmIGF1ZGlvQ29kZWNGb3VuZCkge1xuICAgICAgbGV2ZWxzMC5mb3JFYWNoKGxldmVsID0+IHtcbiAgICAgICAgaWYobGV2ZWwudmlkZW9Db2RlYykge1xuICAgICAgICAgIGxldmVscy5wdXNoKGxldmVsKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldmVscyA9IGxldmVsczA7XG4gICAgfVxuXG4gICAgLy8gb25seSBrZWVwIGxldmVsIHdpdGggc3VwcG9ydGVkIGF1ZGlvL3ZpZGVvIGNvZGVjc1xuICAgIGxldmVscyA9IGxldmVscy5maWx0ZXIoZnVuY3Rpb24obGV2ZWwpIHtcbiAgICAgIHZhciBjaGVja1N1cHBvcnRlZEF1ZGlvID0gZnVuY3Rpb24oY29kZWMpIHsgcmV0dXJuIE1lZGlhU291cmNlLmlzVHlwZVN1cHBvcnRlZChgYXVkaW8vbXA0O2NvZGVjcz0ke2NvZGVjfWApO307XG4gICAgICB2YXIgY2hlY2tTdXBwb3J0ZWRWaWRlbyA9IGZ1bmN0aW9uKGNvZGVjKSB7IHJldHVybiBNZWRpYVNvdXJjZS5pc1R5cGVTdXBwb3J0ZWQoYHZpZGVvL21wNDtjb2RlY3M9JHtjb2RlY31gKTt9O1xuICAgICAgdmFyIGF1ZGlvQ29kZWMgPSBsZXZlbC5hdWRpb0NvZGVjLCB2aWRlb0NvZGVjID0gbGV2ZWwudmlkZW9Db2RlYztcblxuICAgICAgcmV0dXJuICghYXVkaW9Db2RlYyB8fCBjaGVja1N1cHBvcnRlZEF1ZGlvKGF1ZGlvQ29kZWMpKSAmJlxuICAgICAgICAgICAgICghdmlkZW9Db2RlYyB8fCBjaGVja1N1cHBvcnRlZFZpZGVvKHZpZGVvQ29kZWMpKTtcbiAgICB9KTtcblxuICAgIGlmKGxldmVscy5sZW5ndGgpIHtcbiAgICAgIC8vIHN0YXJ0IGJpdHJhdGUgaXMgdGhlIGZpcnN0IGJpdHJhdGUgb2YgdGhlIG1hbmlmZXN0XG4gICAgICBiaXRyYXRlU3RhcnQgPSBsZXZlbHNbMF0uYml0cmF0ZTtcbiAgICAgIC8vIHNvcnQgbGV2ZWwgb24gYml0cmF0ZVxuICAgICAgbGV2ZWxzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEuYml0cmF0ZSAtIGIuYml0cmF0ZTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5fbGV2ZWxzID0gbGV2ZWxzO1xuICAgICAgLy8gZmluZCBpbmRleCBvZiBmaXJzdCBsZXZlbCBpbiBzb3J0ZWQgbGV2ZWxzXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGV2ZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChsZXZlbHNbaV0uYml0cmF0ZSA9PT0gYml0cmF0ZVN0YXJ0KSB7XG4gICAgICAgICAgdGhpcy5fZmlyc3RMZXZlbCA9IGk7XG4gICAgICAgICAgbG9nZ2VyLmxvZyhgbWFuaWZlc3QgbG9hZGVkLCR7bGV2ZWxzLmxlbmd0aH0gbGV2ZWwocykgZm91bmQsIGZpcnN0IGJpdHJhdGU6JHtiaXRyYXRlU3RhcnR9YCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGhscy50cmlnZ2VyKEV2ZW50Lk1BTklGRVNUX1BBUlNFRCwge2xldmVsczogdGhpcy5fbGV2ZWxzLCBmaXJzdExldmVsOiB0aGlzLl9maXJzdExldmVsLCBzdGF0czogZGF0YS5zdGF0cywgYXVkaW8gOiBhdWRpb0NvZGVjRm91bmQsIHZpZGVvIDogdmlkZW9Db2RlY0ZvdW5kfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhscy50cmlnZ2VyKEV2ZW50LkVSUk9SLCB7dHlwZTogRXJyb3JUeXBlcy5NRURJQV9FUlJPUiwgZGV0YWlsczogRXJyb3JEZXRhaWxzLk1BTklGRVNUX0lOQ09NUEFUSUJMRV9DT0RFQ1NfRVJST1IsIGZhdGFsOiB0cnVlLCB1cmw6IGhscy51cmwsIHJlYXNvbjogJ25vIGxldmVsIHdpdGggY29tcGF0aWJsZSBjb2RlY3MgZm91bmQgaW4gbWFuaWZlc3QnfSk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuXG4gIGdldCBsZXZlbHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xldmVscztcbiAgfVxuXG4gIGdldCBsZXZlbCgpIHtcbiAgICByZXR1cm4gdGhpcy5fbGV2ZWw7XG4gIH1cblxuICBzZXQgbGV2ZWwobmV3TGV2ZWwpIHtcbiAgICBsZXQgbGV2ZWxzID0gdGhpcy5fbGV2ZWxzO1xuICAgIGlmIChsZXZlbHMgJiYgbGV2ZWxzLmxlbmd0aCA+IG5ld0xldmVsKSB7XG4gICAgICBpZiAodGhpcy5fbGV2ZWwgIT09IG5ld0xldmVsIHx8IGxldmVsc1tuZXdMZXZlbF0uZGV0YWlscyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuc2V0TGV2ZWxJbnRlcm5hbChuZXdMZXZlbCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiBzZXRMZXZlbEludGVybmFsKG5ld0xldmVsKSB7XG4gICAgbGV0IGxldmVscyA9IHRoaXMuX2xldmVscztcbiAgICAvLyBjaGVjayBpZiBsZXZlbCBpZHggaXMgdmFsaWRcbiAgICBpZiAobmV3TGV2ZWwgPj0gMCAmJiBuZXdMZXZlbCA8IGxldmVscy5sZW5ndGgpIHtcbiAgICAgIC8vIHN0b3BwaW5nIGxpdmUgcmVsb2FkaW5nIHRpbWVyIGlmIGFueVxuICAgICAgaWYgKHRoaXMudGltZXIpIHtcbiAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lcik7XG4gICAgICAgdGhpcy50aW1lciA9IG51bGw7XG4gICAgICB9XG4gICAgICB0aGlzLl9sZXZlbCA9IG5ld0xldmVsO1xuICAgICAgbG9nZ2VyLmxvZyhgc3dpdGNoaW5nIHRvIGxldmVsICR7bmV3TGV2ZWx9YCk7XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkxFVkVMX1NXSVRDSCwge2xldmVsOiBuZXdMZXZlbH0pO1xuICAgICAgdmFyIGxldmVsID0gbGV2ZWxzW25ld0xldmVsXSwgbGV2ZWxEZXRhaWxzID0gbGV2ZWwuZGV0YWlscztcbiAgICAgICAvLyBjaGVjayBpZiB3ZSBuZWVkIHRvIGxvYWQgcGxheWxpc3QgZm9yIHRoaXMgbGV2ZWwuIGRvbid0IHJlbG9hZCBsaXZlIHBsYXlsaXN0IG1vcmUgdGhhbiBvbmNlIHBlciBzZWNvbmRcbiAgICAgIGlmICghbGV2ZWxEZXRhaWxzIHx8XG4gICAgICAgICAgKGxldmVsRGV0YWlscy5saXZlID09PSB0cnVlICYmIChwZXJmb3JtYW5jZS5ub3coKSAtIGxldmVsRGV0YWlscy50bG9hZCA+IDEwMDApICkpIHtcbiAgICAgICAgLy8gbGV2ZWwgbm90IHJldHJpZXZlZCB5ZXQsIG9yIGxpdmUgcGxheWxpc3Qgd2UgbmVlZCB0byAocmUpbG9hZCBpdFxuICAgICAgICBsb2dnZXIubG9nKGAocmUpbG9hZGluZyBwbGF5bGlzdCBmb3IgbGV2ZWwgJHtuZXdMZXZlbH1gKTtcbiAgICAgICAgdmFyIHVybElkID0gbGV2ZWwudXJsSWQ7XG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuTEVWRUxfTE9BRElORywge3VybDogbGV2ZWwudXJsW3VybElkXSwgbGV2ZWw6IG5ld0xldmVsLCBpZDogdXJsSWR9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaW52YWxpZCBsZXZlbCBpZCBnaXZlbiwgdHJpZ2dlciBlcnJvclxuICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5FUlJPUiwge3R5cGUgOiBFcnJvclR5cGVzLk9USEVSX0VSUk9SLCBkZXRhaWxzOiBFcnJvckRldGFpbHMuTEVWRUxfU1dJVENIX0VSUk9SLCBsZXZlbDogbmV3TGV2ZWwsIGZhdGFsOiBmYWxzZSwgcmVhc29uOiAnaW52YWxpZCBsZXZlbCBpZHgnfSk7XG4gICAgfVxuIH1cblxuICBnZXQgbWFudWFsTGV2ZWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuX21hbnVhbExldmVsO1xuICB9XG5cbiAgc2V0IG1hbnVhbExldmVsKG5ld0xldmVsKSB7XG4gICAgdGhpcy5fbWFudWFsTGV2ZWwgPSBuZXdMZXZlbDtcbiAgICBpZiAodGhpcy5fc3RhcnRMZXZlbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLl9zdGFydExldmVsID0gbmV3TGV2ZWw7XG4gICAgfVxuICAgIGlmIChuZXdMZXZlbCAhPT0gLTEpIHtcbiAgICAgIHRoaXMubGV2ZWwgPSBuZXdMZXZlbDtcbiAgICB9XG4gIH1cblxuICBnZXQgZmlyc3RMZXZlbCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZmlyc3RMZXZlbDtcbiAgfVxuXG4gIHNldCBmaXJzdExldmVsKG5ld0xldmVsKSB7XG4gICAgdGhpcy5fZmlyc3RMZXZlbCA9IG5ld0xldmVsO1xuICB9XG5cbiAgZ2V0IHN0YXJ0TGV2ZWwoKSB7XG4gICAgLy8gaGxzLnN0YXJ0TGV2ZWwgdGFrZXMgcHJlY2VkZW5jZSBvdmVyIGNvbmZpZy5zdGFydExldmVsXG4gICAgLy8gaWYgbm9uZSBvZiB0aGVzZSB2YWx1ZXMgYXJlIGRlZmluZWQsIGZhbGxiYWNrIG9uIHRoaXMuX2ZpcnN0TGV2ZWwgKGZpcnN0IHF1YWxpdHkgbGV2ZWwgYXBwZWFyaW5nIGluIHZhcmlhbnQgbWFuaWZlc3QpXG4gICAgaWYgKHRoaXMuX3N0YXJ0TGV2ZWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgbGV0IGNvbmZpZ1N0YXJ0TGV2ZWwgPSB0aGlzLmhscy5jb25maWcuc3RhcnRMZXZlbDtcbiAgICAgIGlmIChjb25maWdTdGFydExldmVsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGNvbmZpZ1N0YXJ0TGV2ZWw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5fZmlyc3RMZXZlbDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuX3N0YXJ0TGV2ZWw7XG4gICAgfVxuICB9XG5cbiAgc2V0IHN0YXJ0TGV2ZWwobmV3TGV2ZWwpIHtcbiAgICB0aGlzLl9zdGFydExldmVsID0gbmV3TGV2ZWw7XG4gIH1cblxuICBvbkVycm9yKGRhdGEpIHtcbiAgICBpZihkYXRhLmZhdGFsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IGRldGFpbHMgPSBkYXRhLmRldGFpbHMsIGhscyA9IHRoaXMuaGxzLCBsZXZlbElkLCBsZXZlbCwgbGV2ZWxFcnJvciA9IGZhbHNlO1xuICAgIC8vIHRyeSB0byByZWNvdmVyIG5vdCBmYXRhbCBlcnJvcnNcbiAgICBzd2l0Y2goZGV0YWlscykge1xuICAgICAgY2FzZSBFcnJvckRldGFpbHMuRlJBR19MT0FEX0VSUk9SOlxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuRlJBR19MT0FEX1RJTUVPVVQ6XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5GUkFHX0xPT1BfTE9BRElOR19FUlJPUjpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLktFWV9MT0FEX0VSUk9SOlxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuS0VZX0xPQURfVElNRU9VVDpcbiAgICAgICAgIGxldmVsSWQgPSBkYXRhLmZyYWcubGV2ZWw7XG4gICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkxFVkVMX0xPQURfRVJST1I6XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5MRVZFTF9MT0FEX1RJTUVPVVQ6XG4gICAgICAgIGxldmVsSWQgPSBkYXRhLmNvbnRleHQubGV2ZWw7XG4gICAgICAgIGxldmVsRXJyb3IgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICAvKiB0cnkgdG8gc3dpdGNoIHRvIGEgcmVkdW5kYW50IHN0cmVhbSBpZiBhbnkgYXZhaWxhYmxlLlxuICAgICAqIGlmIG5vIHJlZHVuZGFudCBzdHJlYW0gYXZhaWxhYmxlLCBlbWVyZ2VuY3kgc3dpdGNoIGRvd24gKGlmIGluIGF1dG8gbW9kZSBhbmQgY3VycmVudCBsZXZlbCBub3QgMClcbiAgICAgKiBvdGhlcndpc2UsIHdlIGNhbm5vdCByZWNvdmVyIHRoaXMgbmV0d29yayBlcnJvciAuLi5cbiAgICAgKi9cbiAgICBpZiAobGV2ZWxJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBsZXZlbCA9IHRoaXMuX2xldmVsc1tsZXZlbElkXTtcbiAgICAgIGlmIChsZXZlbC51cmxJZCA8IChsZXZlbC51cmwubGVuZ3RoIC0gMSkpIHtcbiAgICAgICAgbGV2ZWwudXJsSWQrKztcbiAgICAgICAgbGV2ZWwuZGV0YWlscyA9IHVuZGVmaW5lZDtcbiAgICAgICAgbG9nZ2VyLndhcm4oYGxldmVsIGNvbnRyb2xsZXIsJHtkZXRhaWxzfSBmb3IgbGV2ZWwgJHtsZXZlbElkfTogc3dpdGNoaW5nIHRvIHJlZHVuZGFudCBzdHJlYW0gaWQgJHtsZXZlbC51cmxJZH1gKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHdlIGNvdWxkIHRyeSB0byByZWNvdmVyIGlmIGluIGF1dG8gbW9kZSBhbmQgY3VycmVudCBsZXZlbCBub3QgbG93ZXN0IGxldmVsICgwKVxuICAgICAgICBsZXQgcmVjb3ZlcmFibGUgPSAoKHRoaXMuX21hbnVhbExldmVsID09PSAtMSkgJiYgbGV2ZWxJZCk7XG4gICAgICAgIGlmIChyZWNvdmVyYWJsZSkge1xuICAgICAgICAgIGxvZ2dlci53YXJuKGBsZXZlbCBjb250cm9sbGVyLCR7ZGV0YWlsc306IGVtZXJnZW5jeSBzd2l0Y2gtZG93biBmb3IgbmV4dCBmcmFnbWVudGApO1xuICAgICAgICAgIGhscy5hYnJDb250cm9sbGVyLm5leHRBdXRvTGV2ZWwgPSAwO1xuICAgICAgICB9IGVsc2UgaWYobGV2ZWwgJiYgbGV2ZWwuZGV0YWlscyAmJiBsZXZlbC5kZXRhaWxzLmxpdmUpIHtcbiAgICAgICAgICBsb2dnZXIud2FybihgbGV2ZWwgY29udHJvbGxlciwke2RldGFpbHN9IG9uIGxpdmUgc3RyZWFtLCBkaXNjYXJkYCk7XG4gICAgICAgICAgaWYgKGxldmVsRXJyb3IpIHtcbiAgICAgICAgICAgIC8vIHJlc2V0IHRoaXMuX2xldmVsIHNvIHRoYXQgYW5vdGhlciBjYWxsIHRvIHNldCBsZXZlbCgpIHdpbGwgcmV0cmlnZ2VyIGEgZnJhZyBsb2FkXG4gICAgICAgICAgICB0aGlzLl9sZXZlbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgIC8vIGZyYWdtZW50IGVycm9ycyBhcmUgYWxsIGhhbmRsZWQgIGJ5IHN0cmVhbUNvbnRyb2xsZXJcbiAgICAgICAgfSBlbHNlIGlmIChkZXRhaWxzICE9PSBFcnJvckRldGFpbHMuRlJBR19MT0FEX0VSUk9SICYmXG4gICAgICAgICAgICAgICAgICAgZGV0YWlscyAhPT0gRXJyb3JEZXRhaWxzLkZSQUdfTE9BRF9USU1FT1VUICYmXG4gICAgICAgICAgICAgICAgICAgZGV0YWlscyAhPT0gRXJyb3JEZXRhaWxzLkZSQUdfTE9PUF9MT0FESU5HX0VSUk9SKSB7XG4gICAgICAgICAgbG9nZ2VyLmVycm9yKGBjYW5ub3QgcmVjb3ZlciAke2RldGFpbHN9IGVycm9yYCk7XG4gICAgICAgICAgdGhpcy5fbGV2ZWwgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgLy8gc3RvcHBpbmcgbGl2ZSByZWxvYWRpbmcgdGltZXIgaWYgYW55XG4gICAgICAgICAgaWYgKHRoaXMudGltZXIpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVyKTtcbiAgICAgICAgICAgIHRoaXMudGltZXIgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyByZWRpc3BhdGNoIHNhbWUgZXJyb3IgYnV0IHdpdGggZmF0YWwgc2V0IHRvIHRydWVcbiAgICAgICAgICBkYXRhLmZhdGFsID0gdHJ1ZTtcbiAgICAgICAgICBobHMudHJpZ2dlcihFdmVudC5FUlJPUiwgZGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBvbkxldmVsTG9hZGVkKGRhdGEpIHtcbiAgICAgLy8gb25seSBwcm9jZXNzIGxldmVsIGxvYWRlZCBldmVudHMgbWF0Y2hpbmcgd2l0aCBleHBlY3RlZCBsZXZlbFxuICAgICBpZiAoZGF0YS5sZXZlbCA9PT0gdGhpcy5fbGV2ZWwpIHtcbiAgICAgIGxldCBuZXdEZXRhaWxzID0gZGF0YS5kZXRhaWxzO1xuICAgICAgLy8gaWYgY3VycmVudCBwbGF5bGlzdCBpcyBhIGxpdmUgcGxheWxpc3QsIGFybSBhIHRpbWVyIHRvIHJlbG9hZCBpdFxuICAgICAgaWYgKG5ld0RldGFpbHMubGl2ZSkge1xuICAgICAgICBsZXQgcmVsb2FkSW50ZXJ2YWwgPSAxMDAwKiggbmV3RGV0YWlscy5hdmVyYWdldGFyZ2V0ZHVyYXRpb24gPyBuZXdEZXRhaWxzLmF2ZXJhZ2V0YXJnZXRkdXJhdGlvbiA6IG5ld0RldGFpbHMudGFyZ2V0ZHVyYXRpb24pLFxuICAgICAgICAgICAgY3VyTGV2ZWwgPSB0aGlzLl9sZXZlbHNbZGF0YS5sZXZlbF0sXG4gICAgICAgICAgICBjdXJEZXRhaWxzID0gY3VyTGV2ZWwuZGV0YWlscztcbiAgICAgICAgaWYgKGN1ckRldGFpbHMgJiYgbmV3RGV0YWlscy5lbmRTTiA9PT0gY3VyRGV0YWlscy5lbmRTTikge1xuICAgICAgICAgIC8vIGZvbGxvdyBITFMgU3BlYywgSWYgdGhlIGNsaWVudCByZWxvYWRzIGEgUGxheWxpc3QgZmlsZSBhbmQgZmluZHMgdGhhdCBpdCBoYXMgbm90XG4gICAgICAgICAgLy8gY2hhbmdlZCB0aGVuIGl0IE1VU1Qgd2FpdCBmb3IgYSBwZXJpb2Qgb2Ygb25lLWhhbGYgdGhlIHRhcmdldFxuICAgICAgICAgIC8vIGR1cmF0aW9uIGJlZm9yZSByZXRyeWluZy5cbiAgICAgICAgICByZWxvYWRJbnRlcnZhbCAvPTI7XG4gICAgICAgICAgbG9nZ2VyLmxvZyhgc2FtZSBsaXZlIHBsYXlsaXN0LCByZWxvYWQgdHdpY2UgZmFzdGVyYCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZGVjcmVtZW50IHJlbG9hZEludGVydmFsIHdpdGggbGV2ZWwgbG9hZGluZyBkZWxheVxuICAgICAgICByZWxvYWRJbnRlcnZhbCAtPSBwZXJmb3JtYW5jZS5ub3coKSAtIGRhdGEuc3RhdHMudHJlcXVlc3Q7XG4gICAgICAgIC8vIGluIGFueSBjYXNlLCBkb24ndCByZWxvYWQgbW9yZSB0aGFuIGV2ZXJ5IHNlY29uZFxuICAgICAgICByZWxvYWRJbnRlcnZhbCA9IE1hdGgubWF4KDEwMDAsTWF0aC5yb3VuZChyZWxvYWRJbnRlcnZhbCkpO1xuICAgICAgICBsb2dnZXIubG9nKGBsaXZlIHBsYXlsaXN0LCByZWxvYWQgaW4gJHtyZWxvYWRJbnRlcnZhbH0gbXNgKTtcbiAgICAgICAgdGhpcy50aW1lciA9IHNldFRpbWVvdXQodGhpcy5vbnRpY2sscmVsb2FkSW50ZXJ2YWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy50aW1lciA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdGljaygpIHtcbiAgICB2YXIgbGV2ZWxJZCA9IHRoaXMuX2xldmVsO1xuICAgIGlmIChsZXZlbElkICE9PSB1bmRlZmluZWQgJiYgdGhpcy5jYW5sb2FkKSB7XG4gICAgICB2YXIgbGV2ZWwgPSB0aGlzLl9sZXZlbHNbbGV2ZWxJZF0sIHVybElkID0gbGV2ZWwudXJsSWQ7XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkxFVkVMX0xPQURJTkcsIHt1cmw6IGxldmVsLnVybFt1cmxJZF0sIGxldmVsOiBsZXZlbElkLCBpZDogdXJsSWR9KTtcbiAgICB9XG4gIH1cblxuICBnZXQgbmV4dExvYWRMZXZlbCgpIHtcbiAgICBpZiAodGhpcy5fbWFudWFsTGV2ZWwgIT09IC0xKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbWFudWFsTGV2ZWw7XG4gICAgfSBlbHNlIHtcbiAgICAgcmV0dXJuIHRoaXMuaGxzLmFickNvbnRyb2xsZXIubmV4dEF1dG9MZXZlbDtcbiAgICB9XG4gIH1cblxuICBzZXQgbmV4dExvYWRMZXZlbChuZXh0TGV2ZWwpIHtcbiAgICB0aGlzLmxldmVsID0gbmV4dExldmVsO1xuICAgIGlmICh0aGlzLl9tYW51YWxMZXZlbCA9PT0gLTEpIHtcbiAgICAgIHRoaXMuaGxzLmFickNvbnRyb2xsZXIubmV4dEF1dG9MZXZlbCA9IG5leHRMZXZlbDtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTGV2ZWxDb250cm9sbGVyO1xuXG4iLCIvKlxuICogU3RyZWFtIENvbnRyb2xsZXJcbiovXG5cbmltcG9ydCBCaW5hcnlTZWFyY2ggZnJvbSAnLi4vdXRpbHMvYmluYXJ5LXNlYXJjaCc7XG5pbXBvcnQgQnVmZmVySGVscGVyIGZyb20gJy4uL2hlbHBlci9idWZmZXItaGVscGVyJztcbmltcG9ydCBEZW11eGVyIGZyb20gJy4uL2RlbXV4L2RlbXV4ZXInO1xuaW1wb3J0IEV2ZW50IGZyb20gJy4uL2V2ZW50cyc7XG5pbXBvcnQgRXZlbnRIYW5kbGVyIGZyb20gJy4uL2V2ZW50LWhhbmRsZXInO1xuaW1wb3J0IExldmVsSGVscGVyIGZyb20gJy4uL2hlbHBlci9sZXZlbC1oZWxwZXInO1xuaW1wb3J0IFRpbWVSYW5nZXMgZnJvbSAnLi4vdXRpbHMvdGltZVJhbmdlcyc7XG5pbXBvcnQge0Vycm9yVHlwZXMsIEVycm9yRGV0YWlsc30gZnJvbSAnLi4vZXJyb3JzJztcbmltcG9ydCB7bG9nZ2VyfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xuXG5jb25zdCBTdGF0ZSA9IHtcbiAgU1RPUFBFRCA6ICdTVE9QUEVEJyxcbiAgU1RBUlRJTkcgOiAnU1RBUlRJTkcnLFxuICBJRExFIDogJ0lETEUnLFxuICBQQVVTRUQgOiAnUEFVU0VEJyxcbiAgS0VZX0xPQURJTkcgOiAnS0VZX0xPQURJTkcnLFxuICBGUkFHX0xPQURJTkcgOiAnRlJBR19MT0FESU5HJyxcbiAgRlJBR19MT0FESU5HX1dBSVRJTkdfUkVUUlkgOiAnRlJBR19MT0FESU5HX1dBSVRJTkdfUkVUUlknLFxuICBXQUlUSU5HX0xFVkVMIDogJ1dBSVRJTkdfTEVWRUwnLFxuICBQQVJTSU5HIDogJ1BBUlNJTkcnLFxuICBQQVJTRUQgOiAnUEFSU0VEJyxcbiAgRU5ERUQgOiAnRU5ERUQnLFxuICBFUlJPUiA6ICdFUlJPUidcbn07XG5cbmNsYXNzIFN0cmVhbUNvbnRyb2xsZXIgZXh0ZW5kcyBFdmVudEhhbmRsZXIge1xuXG4gIGNvbnN0cnVjdG9yKGhscykge1xuICAgIHN1cGVyKGhscyxcbiAgICAgIEV2ZW50Lk1FRElBX0FUVEFDSEVELFxuICAgICAgRXZlbnQuTUVESUFfREVUQUNISU5HLFxuICAgICAgRXZlbnQuTUFOSUZFU1RfTE9BRElORyxcbiAgICAgIEV2ZW50Lk1BTklGRVNUX1BBUlNFRCxcbiAgICAgIEV2ZW50LkxFVkVMX0xPQURFRCxcbiAgICAgIEV2ZW50LktFWV9MT0FERUQsXG4gICAgICBFdmVudC5GUkFHX0xPQURFRCxcbiAgICAgIEV2ZW50LkZSQUdfTE9BRF9FTUVSR0VOQ1lfQUJPUlRFRCxcbiAgICAgIEV2ZW50LkZSQUdfUEFSU0lOR19JTklUX1NFR01FTlQsXG4gICAgICBFdmVudC5GUkFHX1BBUlNJTkdfREFUQSxcbiAgICAgIEV2ZW50LkZSQUdfUEFSU0VELFxuICAgICAgRXZlbnQuRVJST1IsXG4gICAgICBFdmVudC5BVURJT19UUkFDS19TV0lUQ0gsXG4gICAgICBFdmVudC5CVUZGRVJfQ1JFQVRFRCxcbiAgICAgIEV2ZW50LkJVRkZFUl9BUFBFTkRFRCxcbiAgICAgIEV2ZW50LkJVRkZFUl9GTFVTSEVEKTtcblxuICAgIHRoaXMuY29uZmlnID0gaGxzLmNvbmZpZztcbiAgICB0aGlzLmF1ZGlvQ29kZWNTd2FwID0gZmFsc2U7XG4gICAgdGhpcy50aWNrcyA9IDA7XG4gICAgdGhpcy5vbnRpY2sgPSB0aGlzLnRpY2suYmluZCh0aGlzKTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5zdG9wTG9hZCgpO1xuICAgIGlmICh0aGlzLnRpbWVyKSB7XG4gICAgICBjbGVhckludGVydmFsKHRoaXMudGltZXIpO1xuICAgICAgdGhpcy50aW1lciA9IG51bGw7XG4gICAgfVxuICAgIEV2ZW50SGFuZGxlci5wcm90b3R5cGUuZGVzdHJveS5jYWxsKHRoaXMpO1xuICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5TVE9QUEVEO1xuICB9XG5cbiAgc3RhcnRMb2FkKHN0YXJ0UG9zaXRpb24pIHtcbiAgICBpZiAodGhpcy5sZXZlbHMpIHtcbiAgICAgIHZhciBtZWRpYSA9IHRoaXMubWVkaWEsIGxhc3RDdXJyZW50VGltZSA9IHRoaXMubGFzdEN1cnJlbnRUaW1lO1xuICAgICAgdGhpcy5zdG9wTG9hZCgpO1xuICAgICAgdGhpcy5kZW11eGVyID0gbmV3IERlbXV4ZXIodGhpcy5obHMsJ21haW4nKTtcbiAgICAgIGlmICghdGhpcy50aW1lcikge1xuICAgICAgICB0aGlzLnRpbWVyID0gc2V0SW50ZXJ2YWwodGhpcy5vbnRpY2ssIDEwMCk7XG4gICAgICB9XG4gICAgICB0aGlzLmxldmVsID0gLTE7XG4gICAgICB0aGlzLmZyYWdMb2FkRXJyb3IgPSAwO1xuICAgICAgaWYgKG1lZGlhICYmIGxhc3RDdXJyZW50VGltZSA+IDApIHtcbiAgICAgICAgbG9nZ2VyLmxvZyhgY29uZmlndXJlIHN0YXJ0UG9zaXRpb24gQCR7bGFzdEN1cnJlbnRUaW1lfWApO1xuICAgICAgICBpZiAoIXRoaXMubGFzdFBhdXNlZCkge1xuICAgICAgICAgIGxvZ2dlci5sb2coJ3Jlc3VtaW5nIHZpZGVvJyk7XG4gICAgICAgICAgbWVkaWEucGxheSgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmxhc3RDdXJyZW50VGltZSA9IHRoaXMuc3RhcnRQb3NpdGlvbiA/IHRoaXMuc3RhcnRQb3NpdGlvbiA6IHN0YXJ0UG9zaXRpb247XG4gICAgICB9XG4gICAgICB0aGlzLnN0YXRlID0gdGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgPyBTdGF0ZS5JRExFIDogU3RhdGUuU1RBUlRJTkc7XG4gICAgICB0aGlzLm5leHRMb2FkUG9zaXRpb24gPSB0aGlzLnN0YXJ0UG9zaXRpb24gPSB0aGlzLmxhc3RDdXJyZW50VGltZTtcbiAgICAgIHRoaXMudGljaygpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb2dnZXIud2FybignY2Fubm90IHN0YXJ0IGxvYWRpbmcgYXMgbWFuaWZlc3Qgbm90IHBhcnNlZCB5ZXQnKTtcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5TVE9QUEVEO1xuICAgIH1cbiAgfVxuXG4gIHN0b3BMb2FkKCkge1xuICAgIHZhciBmcmFnID0gdGhpcy5mcmFnQ3VycmVudDtcbiAgICBpZiAoZnJhZykge1xuICAgICAgaWYgKGZyYWcubG9hZGVyKSB7XG4gICAgICAgIGZyYWcubG9hZGVyLmFib3J0KCk7XG4gICAgICB9XG4gICAgICB0aGlzLmZyYWdDdXJyZW50ID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5mcmFnUHJldmlvdXMgPSBudWxsO1xuICAgIGlmICh0aGlzLmRlbXV4ZXIpIHtcbiAgICAgIHRoaXMuZGVtdXhlci5kZXN0cm95KCk7XG4gICAgICB0aGlzLmRlbXV4ZXIgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLnN0YXRlID0gU3RhdGUuU1RPUFBFRDtcbiAgfVxuXG4gIHRpY2soKSB7XG4gICAgdGhpcy50aWNrcysrO1xuICAgIGlmICh0aGlzLnRpY2tzID09PSAxKSB7XG4gICAgICB0aGlzLmRvVGljaygpO1xuICAgICAgaWYgKHRoaXMudGlja3MgPiAxKSB7XG4gICAgICAgIHNldFRpbWVvdXQodGhpcy50aWNrLCAxKTtcbiAgICAgIH1cbiAgICAgIHRoaXMudGlja3MgPSAwO1xuICAgIH1cbiAgfVxuXG4gIGRvVGljaygpIHtcbiAgICBzd2l0Y2godGhpcy5zdGF0ZSkge1xuICAgICAgY2FzZSBTdGF0ZS5TVEFSVElORzpcbiAgICAgICAgdmFyIGhscyA9IHRoaXMuaGxzO1xuICAgICAgICAvLyBkZXRlcm1pbmUgbG9hZCBsZXZlbFxuICAgICAgICBsZXQgc3RhcnRMZXZlbCA9IGhscy5zdGFydExldmVsO1xuICAgICAgICBpZiAoc3RhcnRMZXZlbCA9PT0gLTEpIHtcbiAgICAgICAgICAvLyAtMSA6IGd1ZXNzIHN0YXJ0IExldmVsIGJ5IGRvaW5nIGEgYml0cmF0ZSB0ZXN0IGJ5IGxvYWRpbmcgZmlyc3QgZnJhZ21lbnQgb2YgbG93ZXN0IHF1YWxpdHkgbGV2ZWxcbiAgICAgICAgICBzdGFydExldmVsID0gMDtcbiAgICAgICAgICB0aGlzLmZyYWdCaXRyYXRlVGVzdCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2V0IG5ldyBsZXZlbCB0byBwbGF5bGlzdCBsb2FkZXIgOiB0aGlzIHdpbGwgdHJpZ2dlciBzdGFydCBsZXZlbCBsb2FkXG4gICAgICAgIC8vIGhscy5uZXh0TG9hZExldmVsIHJlbWFpbnMgdW50aWwgaXQgaXMgc2V0IHRvIGEgbmV3IHZhbHVlIG9yIHVudGlsIGEgbmV3IGZyYWcgaXMgc3VjY2Vzc2Z1bGx5IGxvYWRlZFxuICAgICAgICB0aGlzLmxldmVsID0gaGxzLm5leHRMb2FkTGV2ZWwgPSBzdGFydExldmVsO1xuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuV0FJVElOR19MRVZFTDtcbiAgICAgICAgdGhpcy5sb2FkZWRtZXRhZGF0YSA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgU3RhdGUuSURMRTpcbiAgICAgICAgLy8gd2hlbiB0aGlzIHJldHVybnMgZmFsc2UgdGhlcmUgd2FzIGFuIGVycm9yIGFuZCB3ZSBzaGFsbCByZXR1cm4gaW1tZWRpYXRseVxuICAgICAgICAvLyBmcm9tIGN1cnJlbnQgdGlja1xuICAgICAgICBpZiAoIXRoaXMuX2RvVGlja0lkbGUoKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgU3RhdGUuV0FJVElOR19MRVZFTDpcbiAgICAgICAgdmFyIGxldmVsID0gdGhpcy5sZXZlbHNbdGhpcy5sZXZlbF07XG4gICAgICAgIC8vIGNoZWNrIGlmIHBsYXlsaXN0IGlzIGFscmVhZHkgbG9hZGVkXG4gICAgICAgIGlmIChsZXZlbCAmJiBsZXZlbC5kZXRhaWxzKSB7XG4gICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFN0YXRlLkZSQUdfTE9BRElOR19XQUlUSU5HX1JFVFJZOlxuICAgICAgICB2YXIgbm93ID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIHZhciByZXRyeURhdGUgPSB0aGlzLnJldHJ5RGF0ZTtcbiAgICAgICAgLy8gaWYgY3VycmVudCB0aW1lIGlzIGd0IHRoYW4gcmV0cnlEYXRlLCBvciBpZiBtZWRpYSBzZWVraW5nIGxldCdzIHN3aXRjaCB0byBJRExFIHN0YXRlIHRvIHJldHJ5IGxvYWRpbmdcbiAgICAgICAgaWYoIXJldHJ5RGF0ZSB8fCAobm93ID49IHJldHJ5RGF0ZSkgfHwgKHRoaXMubWVkaWEgJiYgdGhpcy5tZWRpYS5zZWVraW5nKSkge1xuICAgICAgICAgIGxvZ2dlci5sb2coYG1lZGlhQ29udHJvbGxlcjogcmV0cnlEYXRlIHJlYWNoZWQsIHN3aXRjaCBiYWNrIHRvIElETEUgc3RhdGVgKTtcbiAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgU3RhdGUuRVJST1I6XG4gICAgICBjYXNlIFN0YXRlLlBBVVNFRDpcbiAgICAgIGNhc2UgU3RhdGUuU1RPUFBFRDpcbiAgICAgIGNhc2UgU3RhdGUuRlJBR19MT0FESU5HOlxuICAgICAgY2FzZSBTdGF0ZS5QQVJTSU5HOlxuICAgICAgY2FzZSBTdGF0ZS5QQVJTRUQ6XG4gICAgICBjYXNlIFN0YXRlLkVOREVEOlxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICAvLyBjaGVjayBidWZmZXJcbiAgICB0aGlzLl9jaGVja0J1ZmZlcigpO1xuICAgIC8vIGNoZWNrL3VwZGF0ZSBjdXJyZW50IGZyYWdtZW50XG4gICAgdGhpcy5fY2hlY2tGcmFnbWVudENoYW5nZWQoKTtcbiAgfVxuXG4gIC8vIElyb25pY2FsbHkgdGhlIFwiaWRsZVwiIHN0YXRlIGlzIHRoZSBvbiB3ZSBkbyB0aGUgbW9zdCBsb2dpYyBpbiBpdCBzZWVtcyAuLi4uXG4gIC8vIE5PVEU6IE1heWJlIHdlIGNvdWxkIHJhdGhlciBzY2hlZHVsZSBhIGNoZWNrIGZvciBidWZmZXIgbGVuZ3RoIGFmdGVyIGhhbGYgb2YgdGhlIGN1cnJlbnRseVxuICAvLyAgICAgICBwbGF5ZWQgc2VnbWVudCwgb3Igb24gcGF1c2UvcGxheS9zZWVrIGluc3RlYWQgb2YgbmFpdmVseSBjaGVja2luZyBldmVyeSAxMDBtcz9cbiAgX2RvVGlja0lkbGUoKSB7XG4gICAgY29uc3QgaGxzID0gdGhpcy5obHMsXG4gICAgICAgICAgY29uZmlnID0gaGxzLmNvbmZpZyxcbiAgICAgICAgICBtZWRpYSA9IHRoaXMubWVkaWE7XG5cbiAgICAvLyBpZiB2aWRlbyBub3QgYXR0YWNoZWQgQU5EXG4gICAgLy8gc3RhcnQgZnJhZ21lbnQgYWxyZWFkeSByZXF1ZXN0ZWQgT1Igc3RhcnQgZnJhZyBwcmVmZXRjaCBkaXNhYmxlXG4gICAgLy8gZXhpdCBsb29wXG4gICAgLy8gPT4gaWYgbWVkaWEgbm90IGF0dGFjaGVkIGJ1dCBzdGFydCBmcmFnIHByZWZldGNoIGlzIGVuYWJsZWQgYW5kIHN0YXJ0IGZyYWcgbm90IHJlcXVlc3RlZCB5ZXQsIHdlIHdpbGwgbm90IGV4aXQgbG9vcFxuICAgIGlmICghbWVkaWEgJiZcbiAgICAgICh0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCB8fCAhY29uZmlnLnN0YXJ0RnJhZ1ByZWZldGNoKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gaWYgd2UgaGF2ZSBub3QgeWV0IGxvYWRlZCBhbnkgZnJhZ21lbnQsIHN0YXJ0IGxvYWRpbmcgZnJvbSBzdGFydCBwb3NpdGlvblxuICAgIGxldCBwb3M7XG4gICAgaWYgKHRoaXMubG9hZGVkbWV0YWRhdGEpIHtcbiAgICAgIHBvcyA9IG1lZGlhLmN1cnJlbnRUaW1lO1xuICAgIH0gZWxzZSB7XG4gICAgICBwb3MgPSB0aGlzLm5leHRMb2FkUG9zaXRpb247XG4gICAgfVxuICAgIC8vIGRldGVybWluZSBuZXh0IGxvYWQgbGV2ZWxcbiAgICBsZXQgbGV2ZWwgPSBobHMubmV4dExvYWRMZXZlbDtcblxuICAgIC8vIGNvbXB1dGUgbWF4IEJ1ZmZlciBMZW5ndGggdGhhdCB3ZSBjb3VsZCBnZXQgZnJvbSB0aGlzIGxvYWQgbGV2ZWwsIGJhc2VkIG9uIGxldmVsIGJpdHJhdGUuIGRvbid0IGJ1ZmZlciBtb3JlIHRoYW4gNjAgTUIgYW5kIG1vcmUgdGhhbiAzMHNcbiAgICBsZXQgbWF4QnVmTGVuO1xuICAgIGlmICgodGhpcy5sZXZlbHNbbGV2ZWxdKS5oYXNPd25Qcm9wZXJ0eSgnYml0cmF0ZScpKSB7XG4gICAgICBtYXhCdWZMZW4gPSBNYXRoLm1heCg4ICogY29uZmlnLm1heEJ1ZmZlclNpemUgLyB0aGlzLmxldmVsc1tsZXZlbF0uYml0cmF0ZSwgY29uZmlnLm1heEJ1ZmZlckxlbmd0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1heEJ1ZkxlbiA9IGNvbmZpZy5tYXhCdWZmZXJMZW5ndGg7XG4gICAgfVxuICAgIG1heEJ1ZkxlbiA9IE1hdGgubWluKG1heEJ1ZkxlbiwgY29uZmlnLm1heE1heEJ1ZmZlckxlbmd0aCk7XG5cbiAgICAvLyBkZXRlcm1pbmUgbmV4dCBjYW5kaWRhdGUgZnJhZ21lbnQgdG8gYmUgbG9hZGVkLCBiYXNlZCBvbiBjdXJyZW50IHBvc2l0aW9uIGFuZCBlbmQgb2YgYnVmZmVyIHBvc2l0aW9uXG4gICAgLy8gZW5zdXJlIHVwIHRvIGBjb25maWcubWF4TWF4QnVmZmVyTGVuZ3RoYCBvZiBidWZmZXIgdXBmcm9udFxuXG4gICAgY29uc3QgYnVmZmVySW5mbyA9IEJ1ZmZlckhlbHBlci5idWZmZXJJbmZvKHRoaXMubWVkaWFCdWZmZXIgPyB0aGlzLm1lZGlhQnVmZmVyIDogbWVkaWEsIHBvcywgY29uZmlnLm1heEJ1ZmZlckhvbGUpLFxuICAgICAgICAgIGJ1ZmZlckxlbiA9IGJ1ZmZlckluZm8ubGVuO1xuICAgIC8vIFN0YXkgaWRsZSBpZiB3ZSBhcmUgc3RpbGwgd2l0aCBidWZmZXIgbWFyZ2luc1xuICAgIGlmIChidWZmZXJMZW4gPj0gbWF4QnVmTGVuKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBpZiBidWZmZXIgbGVuZ3RoIGlzIGxlc3MgdGhhbiBtYXhCdWZMZW4gdHJ5IHRvIGxvYWQgYSBuZXcgZnJhZ21lbnQgLi4uXG4gICAgbG9nZ2VyLnRyYWNlKGBidWZmZXIgbGVuZ3RoIG9mICR7YnVmZmVyTGVuLnRvRml4ZWQoMyl9IGlzIGJlbG93IG1heCBvZiAke21heEJ1Zkxlbi50b0ZpeGVkKDMpfS4gY2hlY2tpbmcgZm9yIG1vcmUgcGF5bG9hZCAuLi5gKTtcblxuICAgIC8vIHNldCBuZXh0IGxvYWQgbGV2ZWwgOiB0aGlzIHdpbGwgdHJpZ2dlciBhIHBsYXlsaXN0IGxvYWQgaWYgbmVlZGVkXG4gICAgaGxzLm5leHRMb2FkTGV2ZWwgPSBsZXZlbDtcbiAgICB0aGlzLmxldmVsID0gbGV2ZWw7XG5cbiAgICBjb25zdCBsZXZlbERldGFpbHMgPSB0aGlzLmxldmVsc1tsZXZlbF0uZGV0YWlscztcbiAgICAvLyBpZiBsZXZlbCBpbmZvIG5vdCByZXRyaWV2ZWQgeWV0LCBzd2l0Y2ggc3RhdGUgYW5kIHdhaXQgZm9yIGxldmVsIHJldHJpZXZhbFxuICAgIC8vIGlmIGxpdmUgcGxheWxpc3QsIGVuc3VyZSB0aGF0IG5ldyBwbGF5bGlzdCBoYXMgYmVlbiByZWZyZXNoZWQgdG8gYXZvaWQgbG9hZGluZy90cnkgdG8gbG9hZFxuICAgIC8vIGEgdXNlbGVzcyBhbmQgb3V0ZGF0ZWQgZnJhZ21lbnQgKHRoYXQgbWlnaHQgZXZlbiBpbnRyb2R1Y2UgbG9hZCBlcnJvciBpZiBpdCBpcyBhbHJlYWR5IG91dCBvZiB0aGUgbGl2ZSBwbGF5bGlzdClcbiAgICBpZiAodHlwZW9mIGxldmVsRGV0YWlscyA9PT0gJ3VuZGVmaW5lZCcgfHwgbGV2ZWxEZXRhaWxzLmxpdmUgJiYgdGhpcy5sZXZlbExhc3RMb2FkZWQgIT09IGxldmVsKSB7XG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuV0FJVElOR19MRVZFTDtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIHdlIGp1c3QgZ290IGRvbmUgbG9hZGluZyB0aGUgZmluYWwgZnJhZ21lbnQsIGNoZWNrIGlmIHdlIG5lZWQgdG8gZmluYWxpemUgbWVkaWEgc3RyZWFtXG4gICAgbGV0IGZyYWdQcmV2aW91cyA9IHRoaXMuZnJhZ1ByZXZpb3VzO1xuICAgIGlmICghbGV2ZWxEZXRhaWxzLmxpdmUgJiYgZnJhZ1ByZXZpb3VzICYmIGZyYWdQcmV2aW91cy5zbiA9PT0gbGV2ZWxEZXRhaWxzLmVuZFNOKSB7XG4gICAgICAgIC8vIGlmICh3ZSBhcmUgbm90IHNlZWtpbmcgQU5EIGN1cnJlbnQgcG9zaXRpb24gaXMgYnVmZmVyZWQpIE9SIChpZiB3ZSBhcmUgc2Vla2luZyBidXQgZXZlcnl0aGluZyAoYWxtb3N0KSB0aWwgdGhlIGVuZCBpcyBidWZmZXJlZCksIGxldCdzIHNpZ25hbCBlb3NcbiAgICAgICAgLy8gd2UgZG9uJ3QgY29tcGFyZSBleGFjdGx5IG1lZGlhLmR1cmF0aW9uID09PSBidWZmZXJJbmZvLmVuZCBhcyB0aGVyZSBjb3VsZCBiZSBzb21lIHN1YnRsZSBtZWRpYSBkdXJhdGlvbiBkaWZmZXJlbmNlIHdoZW4gc3dpdGNoaW5nXG4gICAgICAgIC8vIGJldHdlZW4gZGlmZmVyZW50IHJlbmRpdGlvbnMuIHVzaW5nIGhhbGYgZnJhZyBkdXJhdGlvbiBzaG91bGQgaGVscCBjb3BlIHdpdGggdGhlc2UgY2FzZXMuXG4gICAgICAgIGlmICgoIW1lZGlhLnNlZWtpbmcgJiYgYnVmZmVySW5mby5sZW4pIHx8IChtZWRpYS5kdXJhdGlvbi1idWZmZXJJbmZvLmVuZCkgPD0gZnJhZ1ByZXZpb3VzLmR1cmF0aW9uLzIpIHtcbiAgICAgICAgLy8gRmluYWxpemUgdGhlIG1lZGlhIHN0cmVhbVxuICAgICAgICBsZXQgZGF0YSA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hbHRBdWRpbykge1xuICAgICAgICAgIGRhdGEudHlwZSA9ICd2aWRlbyc7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5CVUZGRVJfRU9TLGRhdGEpO1xuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuRU5ERUQ7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGlmIHdlIGhhdmUgdGhlIGxldmVsRGV0YWlscyBmb3IgdGhlIHNlbGVjdGVkIHZhcmlhbnQsIGxldHMgY29udGludWUgZW5yaWNoZW4gb3VyIHN0cmVhbSAobG9hZCBrZXlzL2ZyYWdtZW50cyBvciB0cmlnZ2VyIEVPUywgZXRjLi4pXG4gICAgcmV0dXJuIHRoaXMuX2ZldGNoUGF5bG9hZE9yRW9zKHtwb3MsIGJ1ZmZlckluZm8sIGxldmVsRGV0YWlsc30pO1xuICB9XG5cbiAgX2ZldGNoUGF5bG9hZE9yRW9zKHtwb3MsIGJ1ZmZlckluZm8sIGxldmVsRGV0YWlsc30pIHtcbiAgICBjb25zdCBmcmFnUHJldmlvdXMgPSB0aGlzLmZyYWdQcmV2aW91cyxcbiAgICAgICAgICBsZXZlbCA9IHRoaXMubGV2ZWwsXG4gICAgICAgICAgZnJhZ21lbnRzID0gbGV2ZWxEZXRhaWxzLmZyYWdtZW50cyxcbiAgICAgICAgICBmcmFnTGVuID0gZnJhZ21lbnRzLmxlbmd0aDtcblxuICAgIC8vIGVtcHR5IHBsYXlsaXN0XG4gICAgaWYgKGZyYWdMZW4gPT09IDApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBmaW5kIGZyYWdtZW50IGluZGV4LCBjb250aWd1b3VzIHdpdGggZW5kIG9mIGJ1ZmZlciBwb3NpdGlvblxuICAgIGxldCBzdGFydCA9IGZyYWdtZW50c1swXS5zdGFydCxcbiAgICAgICAgZW5kID0gZnJhZ21lbnRzW2ZyYWdMZW4tMV0uc3RhcnQgKyBmcmFnbWVudHNbZnJhZ0xlbi0xXS5kdXJhdGlvbixcbiAgICAgICAgYnVmZmVyRW5kID0gYnVmZmVySW5mby5lbmQsXG4gICAgICAgIGZyYWc7XG5cbiAgICAgIC8vIGluIGNhc2Ugb2YgbGl2ZSBwbGF5bGlzdCB3ZSBuZWVkIHRvIGVuc3VyZSB0aGF0IHJlcXVlc3RlZCBwb3NpdGlvbiBpcyBub3QgbG9jYXRlZCBiZWZvcmUgcGxheWxpc3Qgc3RhcnRcbiAgICBpZiAobGV2ZWxEZXRhaWxzLmxpdmUpIHtcbiAgICAgIGZyYWcgPSB0aGlzLl9lbnN1cmVGcmFnbWVudEF0TGl2ZVBvaW50KHtsZXZlbERldGFpbHMsIGJ1ZmZlckVuZCwgc3RhcnQsIGVuZCwgZnJhZ1ByZXZpb3VzLCBmcmFnbWVudHMsIGZyYWdMZW59KTtcbiAgICAgIC8vIGlmIGl0IGV4cGxpY2l0ZWx5IHJldHVybnMgbnVsbCBkb24ndCBsb2FkIGFueSBmcmFnbWVudCBhbmQgZXhpdCBmdW5jdGlvbiBub3dcbiAgICAgIGlmIChmcmFnID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBWb0QgcGxheWxpc3Q6IGlmIGJ1ZmZlckVuZCBiZWZvcmUgc3RhcnQgb2YgcGxheWxpc3QsIGxvYWQgZmlyc3QgZnJhZ21lbnRcbiAgICAgIGlmIChidWZmZXJFbmQgPCBzdGFydCkge1xuICAgICAgICBmcmFnID0gZnJhZ21lbnRzWzBdO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWZyYWcpIHtcbiAgICAgIGZyYWcgPSB0aGlzLl9maW5kRnJhZ21lbnQoe3N0YXJ0LCBmcmFnUHJldmlvdXMsIGZyYWdMZW4sIGZyYWdtZW50cywgYnVmZmVyRW5kLCBlbmQsIGxldmVsRGV0YWlsc30pO1xuICAgIH1cbiAgICBpZihmcmFnKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbG9hZEZyYWdtZW50T3JLZXkoe2ZyYWcsIGxldmVsLCBsZXZlbERldGFpbHMsIHBvcywgYnVmZmVyRW5kfSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgX2Vuc3VyZUZyYWdtZW50QXRMaXZlUG9pbnQoe2xldmVsRGV0YWlscywgYnVmZmVyRW5kLCBzdGFydCwgZW5kLCBmcmFnUHJldmlvdXMsIGZyYWdtZW50cywgZnJhZ0xlbn0pIHtcbiAgICBjb25zdCBjb25maWcgPSB0aGlzLmhscy5jb25maWcsIG1lZGlhID0gdGhpcy5tZWRpYTtcblxuICAgIGxldCBmcmFnO1xuXG4gICAgLy8gY2hlY2sgaWYgcmVxdWVzdGVkIHBvc2l0aW9uIGlzIHdpdGhpbiBzZWVrYWJsZSBib3VuZGFyaWVzIDpcbiAgICAvL2xvZ2dlci5sb2coYHN0YXJ0L3Bvcy9idWZFbmQvc2Vla2luZzoke3N0YXJ0LnRvRml4ZWQoMyl9LyR7cG9zLnRvRml4ZWQoMyl9LyR7YnVmZmVyRW5kLnRvRml4ZWQoMyl9LyR7dGhpcy5tZWRpYS5zZWVraW5nfWApO1xuICAgIGxldCBtYXhMYXRlbmN5ID0gY29uZmlnLmxpdmVNYXhMYXRlbmN5RHVyYXRpb24gIT09IHVuZGVmaW5lZCA/IGNvbmZpZy5saXZlTWF4TGF0ZW5jeUR1cmF0aW9uIDogY29uZmlnLmxpdmVNYXhMYXRlbmN5RHVyYXRpb25Db3VudCpsZXZlbERldGFpbHMudGFyZ2V0ZHVyYXRpb247XG5cbiAgICBpZiAoYnVmZmVyRW5kIDwgTWF0aC5tYXgoc3RhcnQsIGVuZCAtIG1heExhdGVuY3kpKSB7XG4gICAgICAgIGxldCBsaXZlU3luY1Bvc2l0aW9uID0gdGhpcy5saXZlU3luY1Bvc2l0aW9uID0gdGhpcy5jb21wdXRlTGl2ZVBvc2l0aW9uKHN0YXJ0LCBsZXZlbERldGFpbHMpO1xuICAgICAgICBsb2dnZXIubG9nKGBidWZmZXIgZW5kOiAke2J1ZmZlckVuZH0gaXMgbG9jYXRlZCB0b28gZmFyIGZyb20gdGhlIGVuZCBvZiBsaXZlIHNsaWRpbmcgcGxheWxpc3QsIHJlc2V0IGN1cnJlbnRUaW1lIHRvIDogJHtsaXZlU3luY1Bvc2l0aW9uLnRvRml4ZWQoMyl9YCk7XG4gICAgICAgIGJ1ZmZlckVuZCA9IGxpdmVTeW5jUG9zaXRpb247XG4gICAgICAgIGlmIChtZWRpYSAmJiBtZWRpYS5yZWFkeVN0YXRlICYmIG1lZGlhLmR1cmF0aW9uID4gbGl2ZVN5bmNQb3NpdGlvbikge1xuICAgICAgICAgIG1lZGlhLmN1cnJlbnRUaW1lID0gbGl2ZVN5bmNQb3NpdGlvbjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGlmIGVuZCBvZiBidWZmZXIgZ3JlYXRlciB0aGFuIGxpdmUgZWRnZSwgZG9uJ3QgbG9hZCBhbnkgZnJhZ21lbnRcbiAgICAvLyB0aGlzIGNvdWxkIGhhcHBlbiBpZiBsaXZlIHBsYXlsaXN0IGludGVybWl0dGVudGx5IHNsaWRlcyBpbiB0aGUgcGFzdC5cbiAgICAvLyBsZXZlbCAxIGxvYWRlZCBbMTgyNTgwMTYxLDE4MjU4MDE2N11cbiAgICAvLyBsZXZlbCAxIGxvYWRlZCBbMTgyNTgwMTYyLDE4MjU4MDE2OV1cbiAgICAvLyBMb2FkaW5nIDE4MjU4MDE2OCBvZiBbMTgyNTgwMTYyICwxODI1ODAxNjldLGxldmVsIDEgLi5cbiAgICAvLyBMb2FkaW5nIDE4MjU4MDE2OSBvZiBbMTgyNTgwMTYyICwxODI1ODAxNjldLGxldmVsIDEgLi5cbiAgICAvLyBsZXZlbCAxIGxvYWRlZCBbMTgyNTgwMTYyLDE4MjU4MDE2OF0gPD09PT09PT09PT09PT0gaGVyZSB3ZSBzaG91bGQgaGF2ZSBidWZmZXJFbmQgPiBlbmQuIGluIHRoYXQgY2FzZSBicmVhayB0byBhdm9pZCByZWxvYWRpbmcgMTgyNTgwMTY4XG4gICAgLy8gbGV2ZWwgMSBsb2FkZWQgWzE4MjU4MDE2NCwxODI1ODAxNzFdXG4gICAgLy9cbiAgICAvLyBkb24ndCByZXR1cm4gbnVsbCBpbiBjYXNlIG1lZGlhIG5vdCBsb2FkZWQgeWV0IChyZWFkeXN0YXRlID09PSAwKVxuICAgIGlmIChsZXZlbERldGFpbHMuUFRTS25vd24gJiYgYnVmZmVyRW5kID4gZW5kICYmIG1lZGlhICYmIG1lZGlhLnJlYWR5U3RhdGUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCAmJiAhbGV2ZWxEZXRhaWxzLlBUU0tub3duKSB7XG4gICAgICAvKiB3ZSBhcmUgc3dpdGNoaW5nIGxldmVsIG9uIGxpdmUgcGxheWxpc3QsIGJ1dCB3ZSBkb24ndCBoYXZlIGFueSBQVFMgaW5mbyBmb3IgdGhhdCBxdWFsaXR5IGxldmVsIC4uLlxuICAgICAgICAgdHJ5IHRvIGxvYWQgZnJhZyBtYXRjaGluZyB3aXRoIG5leHQgU04uXG4gICAgICAgICBldmVuIGlmIFNOIGFyZSBub3Qgc3luY2hyb25pemVkIGJldHdlZW4gcGxheWxpc3RzLCBsb2FkaW5nIHRoaXMgZnJhZyB3aWxsIGhlbHAgdXNcbiAgICAgICAgIGNvbXB1dGUgcGxheWxpc3Qgc2xpZGluZyBhbmQgZmluZCB0aGUgcmlnaHQgb25lIGFmdGVyIGluIGNhc2UgaXQgd2FzIG5vdCB0aGUgcmlnaHQgY29uc2VjdXRpdmUgb25lICovXG4gICAgICBpZiAoZnJhZ1ByZXZpb3VzKSB7XG4gICAgICAgIHZhciB0YXJnZXRTTiA9IGZyYWdQcmV2aW91cy5zbiArIDE7XG4gICAgICAgIGlmICh0YXJnZXRTTiA+PSBsZXZlbERldGFpbHMuc3RhcnRTTiAmJiB0YXJnZXRTTiA8PSBsZXZlbERldGFpbHMuZW5kU04pIHtcbiAgICAgICAgICBmcmFnID0gZnJhZ21lbnRzW3RhcmdldFNOIC0gbGV2ZWxEZXRhaWxzLnN0YXJ0U05dO1xuICAgICAgICAgIGxvZ2dlci5sb2coYGxpdmUgcGxheWxpc3QsIHN3aXRjaGluZyBwbGF5bGlzdCwgbG9hZCBmcmFnIHdpdGggbmV4dCBTTjogJHtmcmFnLnNufWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWZyYWcpIHtcbiAgICAgICAgLyogd2UgaGF2ZSBubyBpZGVhIGFib3V0IHdoaWNoIGZyYWdtZW50IHNob3VsZCBiZSBsb2FkZWQuXG4gICAgICAgICAgIHNvIGxldCdzIGxvYWQgbWlkIGZyYWdtZW50LiBpdCB3aWxsIGhlbHAgY29tcHV0aW5nIHBsYXlsaXN0IHNsaWRpbmcgYW5kIGZpbmQgdGhlIHJpZ2h0IG9uZVxuICAgICAgICAqL1xuICAgICAgICBmcmFnID0gZnJhZ21lbnRzW01hdGgubWluKGZyYWdMZW4gLSAxLCBNYXRoLnJvdW5kKGZyYWdMZW4gLyAyKSldO1xuICAgICAgICBsb2dnZXIubG9nKGBsaXZlIHBsYXlsaXN0LCBzd2l0Y2hpbmcgcGxheWxpc3QsIHVua25vd24sIGxvYWQgbWlkZGxlIGZyYWcgOiAke2ZyYWcuc259YCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmcmFnO1xuICB9XG5cbiAgX2ZpbmRGcmFnbWVudCh7c3RhcnQsIGZyYWdQcmV2aW91cywgZnJhZ0xlbiwgZnJhZ21lbnRzLCBidWZmZXJFbmQsIGVuZCwgbGV2ZWxEZXRhaWxzfSkge1xuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuaGxzLmNvbmZpZztcblxuICAgIGxldCBmcmFnLFxuICAgICAgICBmb3VuZEZyYWcsXG4gICAgICAgIG1heEZyYWdMb29rVXBUb2xlcmFuY2UgPSBjb25maWcubWF4RnJhZ0xvb2tVcFRvbGVyYW5jZTtcblxuICAgIGlmIChidWZmZXJFbmQgPCBlbmQpIHtcbiAgICAgIGlmIChidWZmZXJFbmQgPiBlbmQgLSBtYXhGcmFnTG9va1VwVG9sZXJhbmNlKSB7XG4gICAgICAgIG1heEZyYWdMb29rVXBUb2xlcmFuY2UgPSAwO1xuICAgICAgfVxuICAgICAgZm91bmRGcmFnID0gQmluYXJ5U2VhcmNoLnNlYXJjaChmcmFnbWVudHMsIChjYW5kaWRhdGUpID0+IHtcbiAgICAgICAgLy8gb2Zmc2V0IHNob3VsZCBiZSB3aXRoaW4gZnJhZ21lbnQgYm91bmRhcnkgLSBjb25maWcubWF4RnJhZ0xvb2tVcFRvbGVyYW5jZVxuICAgICAgICAvLyB0aGlzIGlzIHRvIGNvcGUgd2l0aCBzaXR1YXRpb25zIGxpa2VcbiAgICAgICAgLy8gYnVmZmVyRW5kID0gOS45OTFcbiAgICAgICAgLy8gZnJhZ1vDmF0gOiBbMCwxMF1cbiAgICAgICAgLy8gZnJhZ1sxXSA6IFsxMCwyMF1cbiAgICAgICAgLy8gYnVmZmVyRW5kIGlzIHdpdGhpbiBmcmFnWzBdIHJhbmdlIC4uLiBhbHRob3VnaCB3aGF0IHdlIGFyZSBleHBlY3RpbmcgaXMgdG8gcmV0dXJuIGZyYWdbMV0gaGVyZVxuICAgICAgICAgICAgLy8gICAgICAgICAgICAgIGZyYWcgc3RhcnQgICAgICAgICAgICAgICBmcmFnIHN0YXJ0K2R1cmF0aW9uXG4gICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgIHwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXxcbiAgICAgICAgICAgIC8vICAgICAgICAgICAgICA8LS0tPiAgICAgICAgICAgICAgICAgICAgICAgICA8LS0tPlxuICAgICAgICAgICAgLy8gIC4uLi0tLS0tLS0tPjwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLT48LS0tLS0tLS0tLi4uLlxuICAgICAgICAgICAgLy8gcHJldmlvdXMgZnJhZyAgICAgICAgIG1hdGNoaW5nIGZyYWdtZW50ICAgICAgICAgbmV4dCBmcmFnXG4gICAgICAgICAgICAvLyAgcmV0dXJuIC0xICAgICAgICAgICAgIHJldHVybiAwICAgICAgICAgICAgICAgICByZXR1cm4gMVxuICAgICAgICAvL2xvZ2dlci5sb2coYGxldmVsL3NuL3N0YXJ0L2VuZC9idWZFbmQ6JHtsZXZlbH0vJHtjYW5kaWRhdGUuc259LyR7Y2FuZGlkYXRlLnN0YXJ0fS8keyhjYW5kaWRhdGUuc3RhcnQrY2FuZGlkYXRlLmR1cmF0aW9uKX0vJHtidWZmZXJFbmR9YCk7XG4gICAgICAgIGlmICgoY2FuZGlkYXRlLnN0YXJ0ICsgY2FuZGlkYXRlLmR1cmF0aW9uIC0gbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSkgPD0gYnVmZmVyRW5kKSB7XG4gICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH0vLyBpZiBtYXhGcmFnTG9va1VwVG9sZXJhbmNlIHdpbGwgaGF2ZSBuZWdhdGl2ZSB2YWx1ZSB0aGVuIGRvbid0IHJldHVybiAtMSBmb3IgZmlyc3QgZWxlbWVudFxuICAgICAgICBlbHNlIGlmIChjYW5kaWRhdGUuc3RhcnQgLSBtYXhGcmFnTG9va1VwVG9sZXJhbmNlID4gYnVmZmVyRW5kICYmIGNhbmRpZGF0ZS5zdGFydCkge1xuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyByZWFjaCBlbmQgb2YgcGxheWxpc3RcbiAgICAgIGZvdW5kRnJhZyA9IGZyYWdtZW50c1tmcmFnTGVuLTFdO1xuICAgIH1cbiAgICBpZiAoZm91bmRGcmFnKSB7XG4gICAgICBmcmFnID0gZm91bmRGcmFnO1xuICAgICAgc3RhcnQgPSBmb3VuZEZyYWcuc3RhcnQ7XG4gICAgICAvL2xvZ2dlci5sb2coJ2ZpbmQgU04gbWF0Y2hpbmcgd2l0aCBwb3M6JyArICBidWZmZXJFbmQgKyAnOicgKyBmcmFnLnNuKTtcbiAgICAgIGlmIChmcmFnUHJldmlvdXMgJiYgZnJhZy5sZXZlbCA9PT0gZnJhZ1ByZXZpb3VzLmxldmVsICYmIGZyYWcuc24gPT09IGZyYWdQcmV2aW91cy5zbikge1xuICAgICAgICBpZiAoZnJhZy5zbiA8IGxldmVsRGV0YWlscy5lbmRTTikge1xuICAgICAgICAgIGxldCBkZWx0YVBUUyA9IGZyYWdQcmV2aW91cy5kZWx0YVBUUyxcbiAgICAgICAgICBjdXJTTklkeCA9IGZyYWcuc24gLSBsZXZlbERldGFpbHMuc3RhcnRTTjtcbiAgICAgICAgICAvLyBpZiB0aGVyZSBpcyBhIHNpZ25pZmljYW50IGRlbHRhIGJldHdlZW4gYXVkaW8gYW5kIHZpZGVvLCBsYXJnZXIgdGhhbiBtYXggYWxsb3dlZCBob2xlLFxuICAgICAgICAgIC8vIGFuZCBpZiBwcmV2aW91cyByZW11eGVkIGZyYWdtZW50IGRpZCBub3Qgc3RhcnQgd2l0aCBhIGtleWZyYW1lLiAoZnJhZ1ByZXZpb3VzLmRyb3BwZWQpXG4gICAgICAgICAgLy8gbGV0J3MgdHJ5IHRvIGxvYWQgcHJldmlvdXMgZnJhZ21lbnQgYWdhaW4gdG8gZ2V0IGxhc3Qga2V5ZnJhbWVcbiAgICAgICAgICAvLyB0aGVuIHdlIHdpbGwgcmVsb2FkIGFnYWluIGN1cnJlbnQgZnJhZ21lbnQgKHRoYXQgd2F5IHdlIHNob3VsZCBiZSBhYmxlIHRvIGZpbGwgdGhlIGJ1ZmZlciBob2xlIC4uLilcbiAgICAgICAgICBpZiAoZGVsdGFQVFMgJiYgZGVsdGFQVFMgPiBjb25maWcubWF4QnVmZmVySG9sZSAmJiBmcmFnUHJldmlvdXMuZHJvcHBlZCAmJiBjdXJTTklkeCkge1xuICAgICAgICAgICAgZnJhZyA9IGZyYWdtZW50c1tjdXJTTklkeC0xXTtcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKGBTTiBqdXN0IGxvYWRlZCwgd2l0aCBsYXJnZSBQVFMgZ2FwIGJldHdlZW4gYXVkaW8gYW5kIHZpZGVvLCBtYXliZSBmcmFnIGlzIG5vdCBzdGFydGluZyB3aXRoIGEga2V5ZnJhbWUgPyBsb2FkIHByZXZpb3VzIG9uZSB0byB0cnkgdG8gb3ZlcmNvbWUgdGhpc2ApO1xuICAgICAgICAgICAgLy8gZGVjcmVtZW50IHByZXZpb3VzIGZyYWcgbG9hZCBjb3VudGVyIHRvIGF2b2lkIGZyYWcgbG9vcCBsb2FkaW5nIGVycm9yIHdoZW4gbmV4dCBmcmFnbWVudCB3aWxsIGdldCByZWxvYWRlZFxuICAgICAgICAgICAgZnJhZ1ByZXZpb3VzLmxvYWRDb3VudGVyLS07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZyYWcgPSBmcmFnbWVudHNbY3VyU05JZHgrMV07XG4gICAgICAgICAgICBsb2dnZXIubG9nKGBTTiBqdXN0IGxvYWRlZCwgbG9hZCBuZXh0IG9uZTogJHtmcmFnLnNufWApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmcmFnID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZnJhZztcbiAgfVxuXG4gIF9sb2FkRnJhZ21lbnRPcktleSh7ZnJhZywgbGV2ZWwsIGxldmVsRGV0YWlscywgcG9zLCBidWZmZXJFbmR9KSB7XG4gICAgY29uc3QgaGxzID0gdGhpcy5obHMsXG4gICAgICAgICAgY29uZmlnID0gaGxzLmNvbmZpZztcblxuICAgIC8vbG9nZ2VyLmxvZygnbG9hZGluZyBmcmFnICcgKyBpICsnLHBvcy9idWZFbmQ6JyArIHBvcy50b0ZpeGVkKDMpICsgJy8nICsgYnVmZmVyRW5kLnRvRml4ZWQoMykpO1xuICAgIGlmICgoZnJhZy5kZWNyeXB0ZGF0YS51cmkgIT0gbnVsbCkgJiYgKGZyYWcuZGVjcnlwdGRhdGEua2V5ID09IG51bGwpKSB7XG4gICAgICBsb2dnZXIubG9nKGBMb2FkaW5nIGtleSBmb3IgJHtmcmFnLnNufSBvZiBbJHtsZXZlbERldGFpbHMuc3RhcnRTTn0gLCR7bGV2ZWxEZXRhaWxzLmVuZFNOfV0sbGV2ZWwgJHtsZXZlbH1gKTtcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5LRVlfTE9BRElORztcbiAgICAgIGhscy50cmlnZ2VyKEV2ZW50LktFWV9MT0FESU5HLCB7ZnJhZzogZnJhZ30pO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb2dnZXIubG9nKGBMb2FkaW5nICR7ZnJhZy5zbn0gb2YgWyR7bGV2ZWxEZXRhaWxzLnN0YXJ0U059ICwke2xldmVsRGV0YWlscy5lbmRTTn1dLGxldmVsICR7bGV2ZWx9LCBjdXJyZW50VGltZToke3Bvc30sYnVmZmVyRW5kOiR7YnVmZmVyRW5kLnRvRml4ZWQoMyl9YCk7XG4gICAgICAvLyBlbnN1cmUgdGhhdCB3ZSBhcmUgbm90IHJlbG9hZGluZyB0aGUgc2FtZSBmcmFnbWVudHMgaW4gbG9vcCAuLi5cbiAgICAgIGlmICh0aGlzLmZyYWdMb2FkSWR4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5mcmFnTG9hZElkeCsrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5mcmFnTG9hZElkeCA9IDA7XG4gICAgICB9XG4gICAgICBpZiAoZnJhZy5sb2FkQ291bnRlcikge1xuICAgICAgICBmcmFnLmxvYWRDb3VudGVyKys7XG4gICAgICAgIGxldCBtYXhUaHJlc2hvbGQgPSBjb25maWcuZnJhZ0xvYWRpbmdMb29wVGhyZXNob2xkO1xuICAgICAgICAvLyBpZiB0aGlzIGZyYWcgaGFzIGFscmVhZHkgYmVlbiBsb2FkZWQgMyB0aW1lcywgYW5kIGlmIGl0IGhhcyBiZWVuIHJlbG9hZGVkIHJlY2VudGx5XG4gICAgICAgIGlmIChmcmFnLmxvYWRDb3VudGVyID4gbWF4VGhyZXNob2xkICYmIChNYXRoLmFicyh0aGlzLmZyYWdMb2FkSWR4IC0gZnJhZy5sb2FkSWR4KSA8IG1heFRocmVzaG9sZCkpIHtcbiAgICAgICAgICBobHMudHJpZ2dlcihFdmVudC5FUlJPUiwge3R5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsIGRldGFpbHM6IEVycm9yRGV0YWlscy5GUkFHX0xPT1BfTE9BRElOR19FUlJPUiwgZmF0YWw6IGZhbHNlLCBmcmFnOiBmcmFnfSk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmcmFnLmxvYWRDb3VudGVyID0gMTtcbiAgICAgIH1cbiAgICAgIGZyYWcubG9hZElkeCA9IHRoaXMuZnJhZ0xvYWRJZHg7XG4gICAgICB0aGlzLmZyYWdDdXJyZW50ID0gZnJhZztcbiAgICAgIHRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkID0gdHJ1ZTtcbiAgICAgIGZyYWcuYXV0b0xldmVsID0gaGxzLmF1dG9MZXZlbEVuYWJsZWQ7XG4gICAgICBmcmFnLmJpdHJhdGVUZXN0ID0gdGhpcy5mcmFnQml0cmF0ZVRlc3Q7XG4gICAgICBobHMudHJpZ2dlcihFdmVudC5GUkFHX0xPQURJTkcsIHtmcmFnOiBmcmFnfSk7XG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuRlJBR19MT0FESU5HO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgc2V0IHN0YXRlKG5leHRTdGF0ZSkge1xuICAgIGlmICh0aGlzLnN0YXRlICE9PSBuZXh0U3RhdGUpIHtcbiAgICAgIGNvbnN0IHByZXZpb3VzU3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgICAgdGhpcy5fc3RhdGUgPSBuZXh0U3RhdGU7XG4gICAgICBsb2dnZXIubG9nKGBlbmdpbmUgc3RhdGUgdHJhbnNpdGlvbiBmcm9tICR7cHJldmlvdXNTdGF0ZX0gdG8gJHtuZXh0U3RhdGV9YCk7XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LlNUUkVBTV9TVEFURV9UUkFOU0lUSU9OLCB7cHJldmlvdXNTdGF0ZSwgbmV4dFN0YXRlfSk7XG4gICAgfVxuICB9XG5cbiAgZ2V0IHN0YXRlKCkge1xuICAgIHJldHVybiB0aGlzLl9zdGF0ZTtcbiAgfVxuXG4gIGdldEJ1ZmZlclJhbmdlKHBvc2l0aW9uKSB7XG4gICAgdmFyIGksIHJhbmdlLFxuICAgICAgICBidWZmZXJSYW5nZSA9IHRoaXMuYnVmZmVyUmFuZ2U7XG4gICAgaWYgKGJ1ZmZlclJhbmdlKSB7XG4gICAgICBmb3IgKGkgPSBidWZmZXJSYW5nZS5sZW5ndGggLSAxOyBpID49MDsgaS0tKSB7XG4gICAgICAgIHJhbmdlID0gYnVmZmVyUmFuZ2VbaV07XG4gICAgICAgIGlmIChwb3NpdGlvbiA+PSByYW5nZS5zdGFydCAmJiBwb3NpdGlvbiA8PSByYW5nZS5lbmQpIHtcbiAgICAgICAgICByZXR1cm4gcmFuZ2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBnZXQgY3VycmVudExldmVsKCkge1xuICAgIGlmICh0aGlzLm1lZGlhKSB7XG4gICAgICB2YXIgcmFuZ2UgPSB0aGlzLmdldEJ1ZmZlclJhbmdlKHRoaXMubWVkaWEuY3VycmVudFRpbWUpO1xuICAgICAgaWYgKHJhbmdlKSB7XG4gICAgICAgIHJldHVybiByYW5nZS5mcmFnLmxldmVsO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICBnZXQgbmV4dEJ1ZmZlclJhbmdlKCkge1xuICAgIGlmICh0aGlzLm1lZGlhKSB7XG4gICAgICAvLyBmaXJzdCBnZXQgZW5kIHJhbmdlIG9mIGN1cnJlbnQgZnJhZ21lbnRcbiAgICAgIHJldHVybiB0aGlzLmZvbGxvd2luZ0J1ZmZlclJhbmdlKHRoaXMuZ2V0QnVmZmVyUmFuZ2UodGhpcy5tZWRpYS5jdXJyZW50VGltZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICBmb2xsb3dpbmdCdWZmZXJSYW5nZShyYW5nZSkge1xuICAgIGlmIChyYW5nZSkge1xuICAgICAgLy8gdHJ5IHRvIGdldCByYW5nZSBvZiBuZXh0IGZyYWdtZW50ICg1MDBtcyBhZnRlciB0aGlzIHJhbmdlKVxuICAgICAgcmV0dXJuIHRoaXMuZ2V0QnVmZmVyUmFuZ2UocmFuZ2UuZW5kICsgMC41KTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBnZXQgbmV4dExldmVsKCkge1xuICAgIHZhciByYW5nZSA9IHRoaXMubmV4dEJ1ZmZlclJhbmdlO1xuICAgIGlmIChyYW5nZSkge1xuICAgICAgcmV0dXJuIHJhbmdlLmZyYWcubGV2ZWw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gIH1cblxuICBpc0J1ZmZlcmVkKHBvc2l0aW9uKSB7XG4gICAgbGV0IG1lZGlhID0gdGhpcy5tZWRpYTtcbiAgICBpZiAobWVkaWEpIHtcbiAgICAgIGxldCBidWZmZXJlZCA9IG1lZGlhLmJ1ZmZlcmVkO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBidWZmZXJlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAocG9zaXRpb24gPj0gYnVmZmVyZWQuc3RhcnQoaSkgJiYgcG9zaXRpb24gPD0gYnVmZmVyZWQuZW5kKGkpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgX2NoZWNrRnJhZ21lbnRDaGFuZ2VkKCkge1xuICAgIHZhciByYW5nZUN1cnJlbnQsIGN1cnJlbnRUaW1lLCB2aWRlbyA9IHRoaXMubWVkaWE7XG4gICAgaWYgKHZpZGVvICYmIHZpZGVvLnJlYWR5U3RhdGUgJiYgdmlkZW8uc2Vla2luZyA9PT0gZmFsc2UpIHtcbiAgICAgIGN1cnJlbnRUaW1lID0gdmlkZW8uY3VycmVudFRpbWU7XG4gICAgICAvKiBpZiB2aWRlbyBlbGVtZW50IGlzIGluIHNlZWtlZCBzdGF0ZSwgY3VycmVudFRpbWUgY2FuIG9ubHkgaW5jcmVhc2UuXG4gICAgICAgIChhc3N1bWluZyB0aGF0IHBsYXliYWNrIHJhdGUgaXMgcG9zaXRpdmUgLi4uKVxuICAgICAgICBBcyBzb21ldGltZXMgY3VycmVudFRpbWUganVtcHMgYmFjayB0byB6ZXJvIGFmdGVyIGFcbiAgICAgICAgbWVkaWEgZGVjb2RlIGVycm9yLCBjaGVjayB0aGlzLCB0byBhdm9pZCBzZWVraW5nIGJhY2sgdG9cbiAgICAgICAgd3JvbmcgcG9zaXRpb24gYWZ0ZXIgYSBtZWRpYSBkZWNvZGUgZXJyb3JcbiAgICAgICovXG4gICAgICBpZihjdXJyZW50VGltZSA+IHZpZGVvLnBsYXliYWNrUmF0ZSp0aGlzLmxhc3RDdXJyZW50VGltZSkge1xuICAgICAgICB0aGlzLmxhc3RDdXJyZW50VGltZSA9IGN1cnJlbnRUaW1lO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuaXNCdWZmZXJlZChjdXJyZW50VGltZSkpIHtcbiAgICAgICAgcmFuZ2VDdXJyZW50ID0gdGhpcy5nZXRCdWZmZXJSYW5nZShjdXJyZW50VGltZSk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuaXNCdWZmZXJlZChjdXJyZW50VGltZSArIDAuMSkpIHtcbiAgICAgICAgLyogZW5zdXJlIHRoYXQgRlJBR19DSEFOR0VEIGV2ZW50IGlzIHRyaWdnZXJlZCBhdCBzdGFydHVwLFxuICAgICAgICAgIHdoZW4gZmlyc3QgdmlkZW8gZnJhbWUgaXMgZGlzcGxheWVkIGFuZCBwbGF5YmFjayBpcyBwYXVzZWQuXG4gICAgICAgICAgYWRkIGEgdG9sZXJhbmNlIG9mIDEwMG1zLCBpbiBjYXNlIGN1cnJlbnQgcG9zaXRpb24gaXMgbm90IGJ1ZmZlcmVkLFxuICAgICAgICAgIGNoZWNrIGlmIGN1cnJlbnQgcG9zKzEwMG1zIGlzIGJ1ZmZlcmVkIGFuZCB1c2UgdGhhdCBidWZmZXIgcmFuZ2VcbiAgICAgICAgICBmb3IgRlJBR19DSEFOR0VEIGV2ZW50IHJlcG9ydGluZyAqL1xuICAgICAgICByYW5nZUN1cnJlbnQgPSB0aGlzLmdldEJ1ZmZlclJhbmdlKGN1cnJlbnRUaW1lICsgMC4xKTtcbiAgICAgIH1cbiAgICAgIGlmIChyYW5nZUN1cnJlbnQpIHtcbiAgICAgICAgdmFyIGZyYWdQbGF5aW5nID0gcmFuZ2VDdXJyZW50LmZyYWc7XG4gICAgICAgIGlmIChmcmFnUGxheWluZyAhPT0gdGhpcy5mcmFnUGxheWluZykge1xuICAgICAgICAgIHRoaXMuZnJhZ1BsYXlpbmcgPSBmcmFnUGxheWluZztcbiAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkZSQUdfQ0hBTkdFRCwge2ZyYWc6IGZyYWdQbGF5aW5nfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKlxuICAgIG9uIGltbWVkaWF0ZSBsZXZlbCBzd2l0Y2ggOlxuICAgICAtIHBhdXNlIHBsYXliYWNrIGlmIHBsYXlpbmdcbiAgICAgLSBjYW5jZWwgYW55IHBlbmRpbmcgbG9hZCByZXF1ZXN0XG4gICAgIC0gYW5kIHRyaWdnZXIgYSBidWZmZXIgZmx1c2hcbiAgKi9cbiAgaW1tZWRpYXRlTGV2ZWxTd2l0Y2goKSB7XG4gICAgbG9nZ2VyLmxvZygnaW1tZWRpYXRlTGV2ZWxTd2l0Y2gnKTtcbiAgICBpZiAoIXRoaXMuaW1tZWRpYXRlU3dpdGNoKSB7XG4gICAgICB0aGlzLmltbWVkaWF0ZVN3aXRjaCA9IHRydWU7XG4gICAgICBsZXQgbWVkaWEgPSB0aGlzLm1lZGlhLCBwcmV2aW91c2x5UGF1c2VkO1xuICAgICAgaWYgKG1lZGlhKSB7XG4gICAgICAgIHByZXZpb3VzbHlQYXVzZWQgPSBtZWRpYS5wYXVzZWQ7XG4gICAgICAgIG1lZGlhLnBhdXNlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBkb24ndCByZXN0YXJ0IHBsYXliYWNrIGFmdGVyIGluc3RhbnQgbGV2ZWwgc3dpdGNoIGluIGNhc2UgbWVkaWEgbm90IGF0dGFjaGVkXG4gICAgICAgIHByZXZpb3VzbHlQYXVzZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgdGhpcy5wcmV2aW91c2x5UGF1c2VkID0gcHJldmlvdXNseVBhdXNlZDtcbiAgICB9XG4gICAgdmFyIGZyYWdDdXJyZW50ID0gdGhpcy5mcmFnQ3VycmVudDtcbiAgICBpZiAoZnJhZ0N1cnJlbnQgJiYgZnJhZ0N1cnJlbnQubG9hZGVyKSB7XG4gICAgICBmcmFnQ3VycmVudC5sb2FkZXIuYWJvcnQoKTtcbiAgICB9XG4gICAgdGhpcy5mcmFnQ3VycmVudCA9IG51bGw7XG4gICAgdGhpcy5zdGF0ZSA9IFN0YXRlLlBBVVNFRDtcbiAgICAvLyBmbHVzaCBldmVyeXRoaW5nXG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5CVUZGRVJfRkxVU0hJTkcsIHtzdGFydE9mZnNldDogMCwgZW5kT2Zmc2V0OiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFl9KTtcbiAgfVxuXG4gIC8qXG4gICAgIG9uIGltbWVkaWF0ZSBsZXZlbCBzd2l0Y2ggZW5kLCBhZnRlciBuZXcgZnJhZ21lbnQgaGFzIGJlZW4gYnVmZmVyZWQgOlxuICAgICAgLSBudWRnZSB2aWRlbyBkZWNvZGVyIGJ5IHNsaWdodGx5IGFkanVzdGluZyB2aWRlbyBjdXJyZW50VGltZSAoaWYgY3VycmVudFRpbWUgYnVmZmVyZWQpXG4gICAgICAtIHJlc3VtZSB0aGUgcGxheWJhY2sgaWYgbmVlZGVkXG4gICovXG4gIGltbWVkaWF0ZUxldmVsU3dpdGNoRW5kKCkge1xuICAgIGxldCBtZWRpYSA9IHRoaXMubWVkaWE7XG4gICAgaWYgKG1lZGlhICYmIG1lZGlhLmJ1ZmZlcmVkLmxlbmd0aCkge1xuICAgICAgdGhpcy5pbW1lZGlhdGVTd2l0Y2ggPSBmYWxzZTtcbiAgICAgIGlmKHRoaXMuaXNCdWZmZXJlZChtZWRpYS5jdXJyZW50VGltZSkpIHtcbiAgICAgICAgLy8gb25seSBudWRnZSBpZiBjdXJyZW50VGltZSBpcyBidWZmZXJlZFxuICAgICAgICBtZWRpYS5jdXJyZW50VGltZSAtPSAwLjAwMDE7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMucHJldmlvdXNseVBhdXNlZCkge1xuICAgICAgICBtZWRpYS5wbGF5KCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgbmV4dExldmVsU3dpdGNoKCkge1xuICAgIC8qIHRyeSB0byBzd2l0Y2ggQVNBUCB3aXRob3V0IGJyZWFraW5nIHZpZGVvIHBsYXliYWNrIDpcbiAgICAgICBpbiBvcmRlciB0byBlbnN1cmUgc21vb3RoIGJ1dCBxdWljayBsZXZlbCBzd2l0Y2hpbmcsXG4gICAgICB3ZSBuZWVkIHRvIGZpbmQgdGhlIG5leHQgZmx1c2hhYmxlIGJ1ZmZlciByYW5nZVxuICAgICAgd2Ugc2hvdWxkIHRha2UgaW50byBhY2NvdW50IG5ldyBzZWdtZW50IGZldGNoIHRpbWVcbiAgICAqL1xuICAgIGxldCBtZWRpYSA9IHRoaXMubWVkaWE7XG4gICAgLy8gZW5zdXJlIHRoYXQgbWVkaWEgaXMgZGVmaW5lZCBhbmQgdGhhdCBtZXRhZGF0YSBhcmUgYXZhaWxhYmxlICh0byByZXRyaWV2ZSBjdXJyZW50VGltZSlcbiAgICBpZiAobWVkaWEgJiYgbWVkaWEucmVhZHlTdGF0ZSkge1xuICAgICAgbGV0IGZldGNoZGVsYXksIGN1cnJlbnRSYW5nZSwgbmV4dFJhbmdlO1xuICAgICAgLy8gaW5jcmVhc2UgZnJhZ21lbnQgbG9hZCBJbmRleCB0byBhdm9pZCBmcmFnIGxvb3AgbG9hZGluZyBlcnJvciBhZnRlciBidWZmZXIgZmx1c2hcbiAgICAgIHRoaXMuZnJhZ0xvYWRJZHggKz0gMiAqIHRoaXMuY29uZmlnLmZyYWdMb2FkaW5nTG9vcFRocmVzaG9sZDtcbiAgICAgIGN1cnJlbnRSYW5nZSA9IHRoaXMuZ2V0QnVmZmVyUmFuZ2UobWVkaWEuY3VycmVudFRpbWUpO1xuICAgICAgaWYgKGN1cnJlbnRSYW5nZSAmJiBjdXJyZW50UmFuZ2Uuc3RhcnQgPiAxKSB7XG4gICAgICAvLyBmbHVzaCBidWZmZXIgcHJlY2VkaW5nIGN1cnJlbnQgZnJhZ21lbnQgKGZsdXNoIHVudGlsIGN1cnJlbnQgZnJhZ21lbnQgc3RhcnQgb2Zmc2V0KVxuICAgICAgLy8gbWludXMgMXMgdG8gYXZvaWQgdmlkZW8gZnJlZXppbmcsIHRoYXQgY291bGQgaGFwcGVuIGlmIHdlIGZsdXNoIGtleWZyYW1lIG9mIGN1cnJlbnQgdmlkZW8gLi4uXG4gICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5QQVVTRUQ7XG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuQlVGRkVSX0ZMVVNISU5HLCB7c3RhcnRPZmZzZXQ6IDAsIGVuZE9mZnNldDogY3VycmVudFJhbmdlLnN0YXJ0IC0gMX0pO1xuICAgICAgfVxuICAgICAgaWYgKCFtZWRpYS5wYXVzZWQpIHtcbiAgICAgICAgLy8gYWRkIGEgc2FmZXR5IGRlbGF5IG9mIDFzXG4gICAgICAgIHZhciBuZXh0TGV2ZWxJZCA9IHRoaXMuaGxzLm5leHRMb2FkTGV2ZWwsbmV4dExldmVsID0gdGhpcy5sZXZlbHNbbmV4dExldmVsSWRdLCBmcmFnTGFzdEticHMgPSB0aGlzLmZyYWdMYXN0S2JwcztcbiAgICAgICAgaWYgKGZyYWdMYXN0S2JwcyAmJiB0aGlzLmZyYWdDdXJyZW50KSB7XG4gICAgICAgICAgZmV0Y2hkZWxheSA9IHRoaXMuZnJhZ0N1cnJlbnQuZHVyYXRpb24gKiBuZXh0TGV2ZWwuYml0cmF0ZSAvICgxMDAwICogZnJhZ0xhc3RLYnBzKSArIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZmV0Y2hkZWxheSA9IDA7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZldGNoZGVsYXkgPSAwO1xuICAgICAgfVxuICAgICAgLy9sb2dnZXIubG9nKCdmZXRjaGRlbGF5OicrZmV0Y2hkZWxheSk7XG4gICAgICAvLyBmaW5kIGJ1ZmZlciByYW5nZSB0aGF0IHdpbGwgYmUgcmVhY2hlZCBvbmNlIG5ldyBmcmFnbWVudCB3aWxsIGJlIGZldGNoZWRcbiAgICAgIG5leHRSYW5nZSA9IHRoaXMuZ2V0QnVmZmVyUmFuZ2UobWVkaWEuY3VycmVudFRpbWUgKyBmZXRjaGRlbGF5KTtcbiAgICAgIGlmIChuZXh0UmFuZ2UpIHtcbiAgICAgICAgLy8gd2UgY2FuIGZsdXNoIGJ1ZmZlciByYW5nZSBmb2xsb3dpbmcgdGhpcyBvbmUgd2l0aG91dCBzdGFsbGluZyBwbGF5YmFja1xuICAgICAgICBuZXh0UmFuZ2UgPSB0aGlzLmZvbGxvd2luZ0J1ZmZlclJhbmdlKG5leHRSYW5nZSk7XG4gICAgICAgIGlmIChuZXh0UmFuZ2UpIHtcbiAgICAgICAgICAvLyBpZiB3ZSBhcmUgaGVyZSwgd2UgY2FuIGFsc28gY2FuY2VsIGFueSBsb2FkaW5nL2RlbXV4aW5nIGluIHByb2dyZXNzLCBhcyB0aGV5IGFyZSB1c2VsZXNzXG4gICAgICAgICAgdmFyIGZyYWdDdXJyZW50ID0gdGhpcy5mcmFnQ3VycmVudDtcbiAgICAgICAgICBpZiAoZnJhZ0N1cnJlbnQgJiYgZnJhZ0N1cnJlbnQubG9hZGVyKSB7XG4gICAgICAgICAgICBmcmFnQ3VycmVudC5sb2FkZXIuYWJvcnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5mcmFnQ3VycmVudCA9IG51bGw7XG4gICAgICAgICAgLy8gZmx1c2ggcG9zaXRpb24gaXMgdGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoaXMgbmV3IGJ1ZmZlclxuICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5QQVVTRUQ7XG4gICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5CVUZGRVJfRkxVU0hJTkcsIHtzdGFydE9mZnNldDogbmV4dFJhbmdlLnN0YXJ0LCBlbmRPZmZzZXQ6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWX0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgb25NZWRpYUF0dGFjaGVkKGRhdGEpIHtcbiAgICB2YXIgbWVkaWEgPSB0aGlzLm1lZGlhID0gdGhpcy5tZWRpYUJ1ZmZlciA9IGRhdGEubWVkaWE7XG4gICAgdGhpcy5vbnZzZWVraW5nID0gdGhpcy5vbk1lZGlhU2Vla2luZy5iaW5kKHRoaXMpO1xuICAgIHRoaXMub252c2Vla2VkID0gdGhpcy5vbk1lZGlhU2Vla2VkLmJpbmQodGhpcyk7XG4gICAgdGhpcy5vbnZlbmRlZCA9IHRoaXMub25NZWRpYUVuZGVkLmJpbmQodGhpcyk7XG4gICAgbWVkaWEuYWRkRXZlbnRMaXN0ZW5lcignc2Vla2luZycsIHRoaXMub252c2Vla2luZyk7XG4gICAgbWVkaWEuYWRkRXZlbnRMaXN0ZW5lcignc2Vla2VkJywgdGhpcy5vbnZzZWVrZWQpO1xuICAgIG1lZGlhLmFkZEV2ZW50TGlzdGVuZXIoJ2VuZGVkJywgdGhpcy5vbnZlbmRlZCk7XG4gICAgbGV0IGNvbmZpZyA9IHRoaXMuY29uZmlnO1xuICAgIGlmKHRoaXMubGV2ZWxzICYmIGNvbmZpZy5hdXRvU3RhcnRMb2FkKSB7XG4gICAgICB0aGlzLmhscy5zdGFydExvYWQoY29uZmlnLnN0YXJ0UG9zaXRpb24pO1xuICAgIH1cbiAgfVxuXG4gIG9uTWVkaWFEZXRhY2hpbmcoKSB7XG4gICAgdmFyIG1lZGlhID0gdGhpcy5tZWRpYTtcbiAgICBpZiAobWVkaWEgJiYgbWVkaWEuZW5kZWQpIHtcbiAgICAgIGxvZ2dlci5sb2coJ01TRSBkZXRhY2hpbmcgYW5kIHZpZGVvIGVuZGVkLCByZXNldCBzdGFydFBvc2l0aW9uJyk7XG4gICAgICB0aGlzLnN0YXJ0UG9zaXRpb24gPSB0aGlzLmxhc3RDdXJyZW50VGltZSA9IDA7XG4gICAgfVxuXG4gICAgLy8gcmVzZXQgZnJhZ21lbnQgbG9hZGluZyBjb3VudGVyIG9uIE1TRSBkZXRhY2hpbmcgdG8gYXZvaWQgcmVwb3J0aW5nIEZSQUdfTE9PUF9MT0FESU5HX0VSUk9SIGFmdGVyIGVycm9yIHJlY292ZXJ5XG4gICAgdmFyIGxldmVscyA9IHRoaXMubGV2ZWxzO1xuICAgIGlmIChsZXZlbHMpIHtcbiAgICAgIC8vIHJlc2V0IGZyYWdtZW50IGxvYWQgY291bnRlclxuICAgICAgICBsZXZlbHMuZm9yRWFjaChsZXZlbCA9PiB7XG4gICAgICAgICAgaWYobGV2ZWwuZGV0YWlscykge1xuICAgICAgICAgICAgbGV2ZWwuZGV0YWlscy5mcmFnbWVudHMuZm9yRWFjaChmcmFnbWVudCA9PiB7XG4gICAgICAgICAgICAgIGZyYWdtZW50LmxvYWRDb3VudGVyID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIC8vIHJlbW92ZSB2aWRlbyBsaXN0ZW5lcnNcbiAgICBpZiAobWVkaWEpIHtcbiAgICAgIG1lZGlhLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3NlZWtpbmcnLCB0aGlzLm9udnNlZWtpbmcpO1xuICAgICAgbWVkaWEucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Vla2VkJywgdGhpcy5vbnZzZWVrZWQpO1xuICAgICAgbWVkaWEucmVtb3ZlRXZlbnRMaXN0ZW5lcignZW5kZWQnLCB0aGlzLm9udmVuZGVkKTtcbiAgICAgIHRoaXMub252c2Vla2luZyA9IHRoaXMub252c2Vla2VkICA9IHRoaXMub252ZW5kZWQgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLm1lZGlhID0gbnVsbDtcbiAgICB0aGlzLmxvYWRlZG1ldGFkYXRhID0gZmFsc2U7XG4gICAgdGhpcy5zdG9wTG9hZCgpO1xuICB9XG5cbiAgb25NZWRpYVNlZWtpbmcoKSB7XG4gICAgbGV0IG1lZGlhID0gdGhpcy5tZWRpYSwgY3VycmVudFRpbWUgPSBtZWRpYSA/IG1lZGlhLmN1cnJlbnRUaW1lIDogdW5kZWZpbmVkO1xuICAgIGxvZ2dlci5sb2coJ21lZGlhIHNlZWtpbmcgdG8gJyArIGN1cnJlbnRUaW1lKTtcbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuRlJBR19MT0FESU5HKSB7XG4gICAgICBsZXQgYnVmZmVySW5mbyA9IEJ1ZmZlckhlbHBlci5idWZmZXJJbmZvKG1lZGlhLGN1cnJlbnRUaW1lLHRoaXMuY29uZmlnLm1heEJ1ZmZlckhvbGUpLFxuICAgICAgICAgIGZyYWdDdXJyZW50ID0gdGhpcy5mcmFnQ3VycmVudDtcbiAgICAgIC8vIGNoZWNrIGlmIHdlIGFyZSBzZWVraW5nIHRvIGEgdW5idWZmZXJlZCBhcmVhIEFORCBpZiBmcmFnIGxvYWRpbmcgaXMgaW4gcHJvZ3Jlc3NcbiAgICAgIGlmIChidWZmZXJJbmZvLmxlbiA9PT0gMCAmJiBmcmFnQ3VycmVudCkge1xuICAgICAgICBsZXQgdG9sZXJhbmNlID0gdGhpcy5jb25maWcubWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSxcbiAgICAgICAgICAgIGZyYWdTdGFydE9mZnNldCA9IGZyYWdDdXJyZW50LnN0YXJ0IC0gdG9sZXJhbmNlLFxuICAgICAgICAgICAgZnJhZ0VuZE9mZnNldCA9IGZyYWdDdXJyZW50LnN0YXJ0ICsgZnJhZ0N1cnJlbnQuZHVyYXRpb24gKyB0b2xlcmFuY2U7XG4gICAgICAgIC8vIGNoZWNrIGlmIHdlIHNlZWsgcG9zaXRpb24gd2lsbCBiZSBvdXQgb2YgY3VycmVudGx5IGxvYWRlZCBmcmFnIHJhbmdlIDogaWYgb3V0IGNhbmNlbCBmcmFnIGxvYWQsIGlmIGluLCBkb24ndCBkbyBhbnl0aGluZ1xuICAgICAgICBpZiAoY3VycmVudFRpbWUgPCBmcmFnU3RhcnRPZmZzZXQgfHwgY3VycmVudFRpbWUgPiBmcmFnRW5kT2Zmc2V0KSB7XG4gICAgICAgICAgaWYgKGZyYWdDdXJyZW50LmxvYWRlcikge1xuICAgICAgICAgICAgbG9nZ2VyLmxvZygnc2Vla2luZyBvdXRzaWRlIG9mIGJ1ZmZlciB3aGlsZSBmcmFnbWVudCBsb2FkIGluIHByb2dyZXNzLCBjYW5jZWwgZnJhZ21lbnQgbG9hZCcpO1xuICAgICAgICAgICAgZnJhZ0N1cnJlbnQubG9hZGVyLmFib3J0KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuZnJhZ0N1cnJlbnQgPSBudWxsO1xuICAgICAgICAgIHRoaXMuZnJhZ1ByZXZpb3VzID0gbnVsbDtcbiAgICAgICAgICAvLyBzd2l0Y2ggdG8gSURMRSBzdGF0ZSB0byBsb2FkIG5ldyBmcmFnbWVudFxuICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxvZ2dlci5sb2coJ3NlZWtpbmcgb3V0c2lkZSBvZiBidWZmZXIgYnV0IHdpdGhpbiBjdXJyZW50bHkgbG9hZGVkIGZyYWdtZW50IHJhbmdlJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLkVOREVEKSB7XG4gICAgICAgIC8vIHN3aXRjaCB0byBJRExFIHN0YXRlIHRvIGNoZWNrIGZvciBwb3RlbnRpYWwgbmV3IGZyYWdtZW50XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgIH1cbiAgICBpZiAobWVkaWEpIHtcbiAgICAgIHRoaXMubGFzdEN1cnJlbnRUaW1lID0gY3VycmVudFRpbWU7XG4gICAgfVxuICAgIC8vIGF2b2lkIHJlcG9ydGluZyBmcmFnbWVudCBsb29wIGxvYWRpbmcgZXJyb3IgaW4gY2FzZSB1c2VyIGlzIHNlZWtpbmcgc2V2ZXJhbCB0aW1lcyBvbiBzYW1lIHBvc2l0aW9uXG4gICAgaWYgKHRoaXMuc3RhdGUgIT09IFN0YXRlLkZSQUdfTE9BRElORyAmJiB0aGlzLmZyYWdMb2FkSWR4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuZnJhZ0xvYWRJZHggKz0gMiAqIHRoaXMuY29uZmlnLmZyYWdMb2FkaW5nTG9vcFRocmVzaG9sZDtcbiAgICB9XG4gICAgLy8gdGljayB0byBzcGVlZCB1cCBwcm9jZXNzaW5nXG4gICAgdGhpcy50aWNrKCk7XG4gIH1cblxuICBvbk1lZGlhU2Vla2VkKCkge1xuICAgIGxvZ2dlci5sb2coJ21lZGlhIHNlZWtlZCB0byAnICsgdGhpcy5tZWRpYS5jdXJyZW50VGltZSk7XG4gICAgLy8gdGljayB0byBzcGVlZCB1cCBGUkFHTUVOVF9QTEFZSU5HIHRyaWdnZXJpbmdcbiAgICB0aGlzLnRpY2soKTtcbiAgfVxuXG4gIG9uTWVkaWFFbmRlZCgpIHtcbiAgICBsb2dnZXIubG9nKCdtZWRpYSBlbmRlZCcpO1xuICAgIC8vIHJlc2V0IHN0YXJ0UG9zaXRpb24gYW5kIGxhc3RDdXJyZW50VGltZSB0byByZXN0YXJ0IHBsYXliYWNrIEAgc3RyZWFtIGJlZ2lubmluZ1xuICAgIHRoaXMuc3RhcnRQb3NpdGlvbiA9IHRoaXMubGFzdEN1cnJlbnRUaW1lID0gMDtcbiAgfVxuXG5cbiAgb25NYW5pZmVzdExvYWRpbmcoKSB7XG4gICAgLy8gcmVzZXQgYnVmZmVyIG9uIG1hbmlmZXN0IGxvYWRpbmdcbiAgICBsb2dnZXIubG9nKCd0cmlnZ2VyIEJVRkZFUl9SRVNFVCcpO1xuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuQlVGRkVSX1JFU0VUKTtcbiAgICB0aGlzLmJ1ZmZlclJhbmdlID0gW107XG4gICAgdGhpcy5zdGFsbGVkID0gZmFsc2U7XG4gICAgdGhpcy5zdGFydFBvc2l0aW9uID0gdGhpcy5sYXN0Q3VycmVudFRpbWUgPSAwO1xuICB9XG5cbiAgb25NYW5pZmVzdFBhcnNlZChkYXRhKSB7XG4gICAgdmFyIGFhYyA9IGZhbHNlLCBoZWFhYyA9IGZhbHNlLCBjb2RlYztcbiAgICBkYXRhLmxldmVscy5mb3JFYWNoKGxldmVsID0+IHtcbiAgICAgIC8vIGRldGVjdCBpZiB3ZSBoYXZlIGRpZmZlcmVudCBraW5kIG9mIGF1ZGlvIGNvZGVjcyB1c2VkIGFtb25nc3QgcGxheWxpc3RzXG4gICAgICBjb2RlYyA9IGxldmVsLmF1ZGlvQ29kZWM7XG4gICAgICBpZiAoY29kZWMpIHtcbiAgICAgICAgaWYgKGNvZGVjLmluZGV4T2YoJ21wNGEuNDAuMicpICE9PSAtMSkge1xuICAgICAgICAgIGFhYyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvZGVjLmluZGV4T2YoJ21wNGEuNDAuNScpICE9PSAtMSkge1xuICAgICAgICAgIGhlYWFjID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuYXVkaW9Db2RlY1N3aXRjaCA9IChhYWMgJiYgaGVhYWMpO1xuICAgIGlmICh0aGlzLmF1ZGlvQ29kZWNTd2l0Y2gpIHtcbiAgICAgIGxvZ2dlci5sb2coJ2JvdGggQUFDL0hFLUFBQyBhdWRpbyBmb3VuZCBpbiBsZXZlbHM7IGRlY2xhcmluZyBsZXZlbCBjb2RlYyBhcyBIRS1BQUMnKTtcbiAgICB9XG4gICAgdGhpcy5sZXZlbHMgPSBkYXRhLmxldmVscztcbiAgICB0aGlzLnN0YXJ0TGV2ZWxMb2FkZWQgPSBmYWxzZTtcbiAgICB0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCA9IGZhbHNlO1xuICAgIGxldCBjb25maWcgPSB0aGlzLmNvbmZpZztcbiAgICBpZiAoY29uZmlnLmF1dG9TdGFydExvYWQpIHtcbiAgICAgIHRoaXMuaGxzLnN0YXJ0TG9hZChjb25maWcuc3RhcnRQb3NpdGlvbik7XG4gICAgfVxuICB9XG5cbiAgb25MZXZlbExvYWRlZChkYXRhKSB7XG4gICAgdmFyIG5ld0RldGFpbHMgPSBkYXRhLmRldGFpbHMsXG4gICAgICAgIG5ld0xldmVsSWQgPSBkYXRhLmxldmVsLFxuICAgICAgICBjdXJMZXZlbCA9IHRoaXMubGV2ZWxzW25ld0xldmVsSWRdLFxuICAgICAgICBkdXJhdGlvbiA9IG5ld0RldGFpbHMudG90YWxkdXJhdGlvbixcbiAgICAgICAgc2xpZGluZyA9IDA7XG5cbiAgICBsb2dnZXIubG9nKGBsZXZlbCAke25ld0xldmVsSWR9IGxvYWRlZCBbJHtuZXdEZXRhaWxzLnN0YXJ0U059LCR7bmV3RGV0YWlscy5lbmRTTn1dLGR1cmF0aW9uOiR7ZHVyYXRpb259YCk7XG4gICAgdGhpcy5sZXZlbExhc3RMb2FkZWQgPSBuZXdMZXZlbElkO1xuXG4gICAgaWYgKG5ld0RldGFpbHMubGl2ZSkge1xuICAgICAgdmFyIGN1ckRldGFpbHMgPSBjdXJMZXZlbC5kZXRhaWxzO1xuICAgICAgaWYgKGN1ckRldGFpbHMgJiYgbmV3RGV0YWlscy5mcmFnbWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAvLyB3ZSBhbHJlYWR5IGhhdmUgZGV0YWlscyBmb3IgdGhhdCBsZXZlbCwgbWVyZ2UgdGhlbVxuICAgICAgICBMZXZlbEhlbHBlci5tZXJnZURldGFpbHMoY3VyRGV0YWlscyxuZXdEZXRhaWxzKTtcbiAgICAgICAgc2xpZGluZyA9IG5ld0RldGFpbHMuZnJhZ21lbnRzWzBdLnN0YXJ0O1xuICAgICAgICB0aGlzLmxpdmVTeW5jUG9zaXRpb24gPSB0aGlzLmNvbXB1dGVMaXZlUG9zaXRpb24oc2xpZGluZywgY3VyRGV0YWlscyk7XG4gICAgICAgIGlmIChuZXdEZXRhaWxzLlBUU0tub3duKSB7XG4gICAgICAgICAgbG9nZ2VyLmxvZyhgbGl2ZSBwbGF5bGlzdCBzbGlkaW5nOiR7c2xpZGluZy50b0ZpeGVkKDMpfWApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxvZ2dlci5sb2coJ2xpdmUgcGxheWxpc3QgLSBvdXRkYXRlZCBQVFMsIHVua25vd24gc2xpZGluZycpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXdEZXRhaWxzLlBUU0tub3duID0gZmFsc2U7XG4gICAgICAgIGxvZ2dlci5sb2coJ2xpdmUgcGxheWxpc3QgLSBmaXJzdCBsb2FkLCB1bmtub3duIHNsaWRpbmcnKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbmV3RGV0YWlscy5QVFNLbm93biA9IGZhbHNlO1xuICAgIH1cbiAgICAvLyBvdmVycmlkZSBsZXZlbCBpbmZvXG4gICAgY3VyTGV2ZWwuZGV0YWlscyA9IG5ld0RldGFpbHM7XG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5MRVZFTF9VUERBVEVELCB7IGRldGFpbHM6IG5ld0RldGFpbHMsIGxldmVsOiBuZXdMZXZlbElkIH0pO1xuXG4gICAgaWYgKHRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkID09PSBmYWxzZSkge1xuICAgIC8vIGNvbXB1dGUgc3RhcnQgcG9zaXRpb24gaWYgc2V0IHRvIC0xLiB1c2UgaXQgc3RyYWlnaHQgYXdheSBpZiB2YWx1ZSBpcyBkZWZpbmVkXG4gICAgICBpZiAodGhpcy5zdGFydFBvc2l0aW9uID09PSAtMSB8fMKgdGhpcy5sYXN0Q3VycmVudFRpbWUgPT09IC0xKSB7XG4gICAgICAgIC8vIGZpcnN0LCBjaGVjayBpZiBzdGFydCB0aW1lIG9mZnNldCBoYXMgYmVlbiBzZXQgaW4gcGxheWxpc3QsIGlmIHllcywgdXNlIHRoaXMgdmFsdWVcbiAgICAgICAgbGV0IHN0YXJ0VGltZU9mZnNldCA9IG5ld0RldGFpbHMuc3RhcnRUaW1lT2Zmc2V0O1xuICAgICAgICBpZighaXNOYU4oc3RhcnRUaW1lT2Zmc2V0KSkge1xuICAgICAgICAgIGlmIChzdGFydFRpbWVPZmZzZXQgPCAwKSB7XG4gICAgICAgICAgICBsb2dnZXIubG9nKGBuZWdhdGl2ZSBzdGFydCB0aW1lIG9mZnNldCAke3N0YXJ0VGltZU9mZnNldH0sIGNvdW50IGZyb20gZW5kIG9mIGxhc3QgZnJhZ21lbnRgKTtcbiAgICAgICAgICAgIHN0YXJ0VGltZU9mZnNldCA9IHNsaWRpbmcgKyBkdXJhdGlvbiArIHN0YXJ0VGltZU9mZnNldDtcbiAgICAgICAgICB9XG4gICAgICAgICAgbG9nZ2VyLmxvZyhgc3RhcnQgdGltZSBvZmZzZXQgZm91bmQgaW4gcGxheWxpc3QsIGFkanVzdCBzdGFydFBvc2l0aW9uIHRvICR7c3RhcnRUaW1lT2Zmc2V0fWApO1xuICAgICAgICAgIHRoaXMuc3RhcnRQb3NpdGlvbiA9IHN0YXJ0VGltZU9mZnNldDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBpZiBsaXZlIHBsYXlsaXN0LCBzZXQgc3RhcnQgcG9zaXRpb24gdG8gYmUgZnJhZ21lbnQgTi10aGlzLmNvbmZpZy5saXZlU3luY0R1cmF0aW9uQ291bnQgKHVzdWFsbHkgMylcbiAgICAgICAgICBpZiAobmV3RGV0YWlscy5saXZlKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0UG9zaXRpb24gPSB0aGlzLmNvbXB1dGVMaXZlUG9zaXRpb24oc2xpZGluZywgbmV3RGV0YWlscyk7XG4gICAgICAgICAgICBsb2dnZXIubG9nKGBjb25maWd1cmUgc3RhcnRQb3NpdGlvbiB0byAke3RoaXMuc3RhcnRQb3NpdGlvbn1gKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zdGFydFBvc2l0aW9uID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMubmV4dExvYWRQb3NpdGlvbiA9IHRoaXMuc3RhcnRQb3NpdGlvbjtcbiAgICB9XG4gICAgLy8gb25seSBzd2l0Y2ggYmF0Y2sgdG8gSURMRSBzdGF0ZSBpZiB3ZSB3ZXJlIHdhaXRpbmcgZm9yIGxldmVsIHRvIHN0YXJ0IGRvd25sb2FkaW5nIGEgbmV3IGZyYWdtZW50XG4gICAgaWYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLldBSVRJTkdfTEVWRUwpIHtcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgIH1cbiAgICAvL3RyaWdnZXIgaGFuZGxlciByaWdodCBub3dcbiAgICB0aGlzLnRpY2soKTtcbiAgfVxuXG4gIG9uS2V5TG9hZGVkKCkge1xuICAgIGlmICh0aGlzLnN0YXRlID09PSBTdGF0ZS5LRVlfTE9BRElORykge1xuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICB0aGlzLnRpY2soKTtcbiAgICB9XG4gIH1cblxuICBvbkZyYWdMb2FkZWQoZGF0YSkge1xuICAgIHZhciBmcmFnQ3VycmVudCA9IHRoaXMuZnJhZ0N1cnJlbnQsXG4gICAgICAgIGZyYWdMb2FkZWQgPSBkYXRhLmZyYWc7XG4gICAgaWYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLkZSQUdfTE9BRElORyAmJlxuICAgICAgICBmcmFnQ3VycmVudCAmJlxuICAgICAgICBmcmFnTG9hZGVkLnR5cGUgPT09ICdtYWluJyAmJlxuICAgICAgICBmcmFnTG9hZGVkLmxldmVsID09PSBmcmFnQ3VycmVudC5sZXZlbCAmJlxuICAgICAgICBmcmFnTG9hZGVkLnNuID09PSBmcmFnQ3VycmVudC5zbikge1xuICAgICAgbGV0IHN0YXRzID0gZGF0YS5zdGF0cztcbiAgICAgIGxvZ2dlci5sb2coYExvYWRlZCAgJHtmcmFnQ3VycmVudC5zbn0gb2YgbGV2ZWwgJHtmcmFnQ3VycmVudC5sZXZlbH1gKTtcbiAgICAgIC8vIHJlc2V0IGZyYWcgYml0cmF0ZSB0ZXN0IGluIGFueSBjYXNlIGFmdGVyIGZyYWcgbG9hZGVkIGV2ZW50XG4gICAgICB0aGlzLmZyYWdCaXRyYXRlVGVzdCA9IGZhbHNlO1xuICAgICAgLy8gaWYgdGhpcyBmcmFnIHdhcyBsb2FkZWQgdG8gcGVyZm9ybSBhIGJpdHJhdGUgdGVzdCBBTkQgaWYgaGxzLm5leHRMb2FkTGV2ZWwgaXMgZ3JlYXRlciB0aGFuIDBcbiAgICAgIC8vIHRoZW4gdGhpcyBtZWFucyB0aGF0IHdlIHNob3VsZCBiZSBhYmxlIHRvIGxvYWQgYSBmcmFnbWVudCBhdCBhIGhpZ2hlciBxdWFsaXR5IGxldmVsXG4gICAgICBpZiAoZnJhZ0xvYWRlZC5iaXRyYXRlVGVzdCA9PT0gdHJ1ZSAmJiB0aGlzLmhscy5uZXh0TG9hZExldmVsKSB7XG4gICAgICAgIC8vIHN3aXRjaCBiYWNrIHRvIElETEUgc3RhdGUgLi4uIHdlIGp1c3QgbG9hZGVkIGEgZnJhZ21lbnQgdG8gZGV0ZXJtaW5lIGFkZXF1YXRlIHN0YXJ0IGJpdHJhdGUgYW5kIGluaXRpYWxpemUgYXV0b3N3aXRjaCBhbGdvXG4gICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgICB0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCA9IGZhbHNlO1xuICAgICAgICBzdGF0cy50cGFyc2VkID0gc3RhdHMudGJ1ZmZlcmVkID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuRlJBR19CVUZGRVJFRCwge3N0YXRzOiBzdGF0cywgZnJhZzogZnJhZ0N1cnJlbnQsIGlkIDogJ21haW4nfSk7XG4gICAgICAgIHRoaXMudGljaygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLlBBUlNJTkc7XG4gICAgICAgIC8vIHRyYW5zbXV4IHRoZSBNUEVHLVRTIGRhdGEgdG8gSVNPLUJNRkYgc2VnbWVudHNcbiAgICAgICAgdGhpcy5zdGF0cyA9IHN0YXRzO1xuICAgICAgICB2YXIgY3VycmVudExldmVsID0gdGhpcy5sZXZlbHNbdGhpcy5sZXZlbF0sXG4gICAgICAgICAgICBkZXRhaWxzID0gY3VycmVudExldmVsLmRldGFpbHMsXG4gICAgICAgICAgICBkdXJhdGlvbiA9IGRldGFpbHMudG90YWxkdXJhdGlvbixcbiAgICAgICAgICAgIHN0YXJ0ID0gZnJhZ0N1cnJlbnQuc3RhcnREVFMgIT09IHVuZGVmaW5lZCA/IGZyYWdDdXJyZW50LnN0YXJ0RFRTICA6IGZyYWdDdXJyZW50LnN0YXJ0LFxuICAgICAgICAgICAgbGV2ZWwgPSBmcmFnQ3VycmVudC5sZXZlbCxcbiAgICAgICAgICAgIHNuID0gZnJhZ0N1cnJlbnQuc24sXG4gICAgICAgICAgICBhdWRpb0NvZGVjID0gdGhpcy5jb25maWcuZGVmYXVsdEF1ZGlvQ29kZWMgfHwgY3VycmVudExldmVsLmF1ZGlvQ29kZWM7XG4gICAgICAgIGlmKHRoaXMuYXVkaW9Db2RlY1N3YXApIHtcbiAgICAgICAgICBsb2dnZXIubG9nKCdzd2FwcGluZyBwbGF5bGlzdCBhdWRpbyBjb2RlYycpO1xuICAgICAgICAgIGlmKGF1ZGlvQ29kZWMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYXVkaW9Db2RlYyA9IHRoaXMubGFzdEF1ZGlvQ29kZWM7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmKGF1ZGlvQ29kZWMpIHtcbiAgICAgICAgICAgIGlmKGF1ZGlvQ29kZWMuaW5kZXhPZignbXA0YS40MC41JykgIT09LTEpIHtcbiAgICAgICAgICAgICAgYXVkaW9Db2RlYyA9ICdtcDRhLjQwLjInO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYXVkaW9Db2RlYyA9ICdtcDRhLjQwLjUnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBlbmRpbmdBcHBlbmRpbmcgPSAwO1xuICAgICAgICBsb2dnZXIubG9nKGBEZW11eGluZyAke3NufSBvZiBbJHtkZXRhaWxzLnN0YXJ0U059ICwke2RldGFpbHMuZW5kU059XSxsZXZlbCAke2xldmVsfSwgY2MgJHtmcmFnQ3VycmVudC5jY31gKTtcbiAgICAgICAgbGV0IGRlbXV4ZXIgPSB0aGlzLmRlbXV4ZXI7XG4gICAgICAgIGlmICghZGVtdXhlcikge1xuICAgICAgICAgIGRlbXV4ZXIgPSB0aGlzLmRlbXV4ZXIgPSBuZXcgRGVtdXhlcih0aGlzLmhscywnbWFpbicpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRpbWUgT2Zmc2V0IGlzIGFjY3VyYXRlIGlmIGxldmVsIFBUUyBpcyBrbm93biwgb3IgaWYgcGxheWxpc3QgaXMgbm90IHNsaWRpbmcgKG5vdCBsaXZlKVxuICAgICAgICBsZXQgYWNjdXJhdGVUaW1lT2Zmc2V0ID0gZGV0YWlscy5QVFNLbm93biB8fCAhZGV0YWlscy5saXZlO1xuICAgICAgICBkZW11eGVyLnB1c2goZGF0YS5wYXlsb2FkLCBhdWRpb0NvZGVjLCBjdXJyZW50TGV2ZWwudmlkZW9Db2RlYywgc3RhcnQsIGZyYWdDdXJyZW50LmNjLCBsZXZlbCwgc24sIGR1cmF0aW9uLCBmcmFnQ3VycmVudC5kZWNyeXB0ZGF0YSwgYWNjdXJhdGVUaW1lT2Zmc2V0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5mcmFnTG9hZEVycm9yID0gMDtcbiAgfVxuXG4gIG9uRnJhZ1BhcnNpbmdJbml0U2VnbWVudChkYXRhKSB7XG4gICAgbGV0IGZyYWdDdXJyZW50ID0gdGhpcy5mcmFnQ3VycmVudDtcbiAgICBpZiAoZnJhZ0N1cnJlbnQgJiZcbiAgICAgICAgZGF0YS5pZCA9PT0gJ21haW4nICYmXG4gICAgICAgIGRhdGEuc24gPT09IGZyYWdDdXJyZW50LnNuICYmXG4gICAgICAgIGRhdGEubGV2ZWwgPT09IGZyYWdDdXJyZW50LmxldmVsICYmXG4gICAgICAgIHRoaXMuc3RhdGUgPT09IFN0YXRlLlBBUlNJTkcpIHtcbiAgICAgIHZhciB0cmFja3MgPSBkYXRhLnRyYWNrcywgdHJhY2tOYW1lLCB0cmFjaztcblxuICAgICAgLy8gaWYgYXVkaW8gdHJhY2sgaXMgZXhwZWN0ZWQgdG8gY29tZSBmcm9tIGF1ZGlvIHN0cmVhbSBjb250cm9sbGVyLCBkaXNjYXJkIGFueSBjb21pbmcgZnJvbSBtYWluXG4gICAgICBpZiAodHJhY2tzLmF1ZGlvICYmIHRoaXMuYWx0QXVkaW8pIHtcbiAgICAgICAgZGVsZXRlIHRyYWNrcy5hdWRpbztcbiAgICAgIH1cbiAgICAgIC8vIGluY2x1ZGUgbGV2ZWxDb2RlYyBpbiBhdWRpbyBhbmQgdmlkZW8gdHJhY2tzXG4gICAgICB0cmFjayA9IHRyYWNrcy5hdWRpbztcbiAgICAgIGlmKHRyYWNrKSB7XG4gICAgICAgIHZhciBhdWRpb0NvZGVjID0gdGhpcy5sZXZlbHNbdGhpcy5sZXZlbF0uYXVkaW9Db2RlYyxcbiAgICAgICAgICAgIHVhID0gbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZihhdWRpb0NvZGVjICYmIHRoaXMuYXVkaW9Db2RlY1N3YXApIHtcbiAgICAgICAgICBsb2dnZXIubG9nKCdzd2FwcGluZyBwbGF5bGlzdCBhdWRpbyBjb2RlYycpO1xuICAgICAgICAgIGlmKGF1ZGlvQ29kZWMuaW5kZXhPZignbXA0YS40MC41JykgIT09LTEpIHtcbiAgICAgICAgICAgIGF1ZGlvQ29kZWMgPSAnbXA0YS40MC4yJztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXVkaW9Db2RlYyA9ICdtcDRhLjQwLjUnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBpbiBjYXNlIEFBQyBhbmQgSEUtQUFDIGF1ZGlvIGNvZGVjcyBhcmUgc2lnbmFsbGVkIGluIG1hbmlmZXN0XG4gICAgICAgIC8vIGZvcmNlIEhFLUFBQyAsIGFzIGl0IHNlZW1zIHRoYXQgbW9zdCBicm93c2VycyBwcmVmZXJzIHRoYXQgd2F5LFxuICAgICAgICAvLyBleGNlcHQgZm9yIG1vbm8gc3RyZWFtcyBPUiBvbiBGRlxuICAgICAgICAvLyB0aGVzZSBjb25kaXRpb25zIG1pZ2h0IG5lZWQgdG8gYmUgcmV2aWV3ZWQgLi4uXG4gICAgICAgIGlmICh0aGlzLmF1ZGlvQ29kZWNTd2l0Y2gpIHtcbiAgICAgICAgICAgIC8vIGRvbid0IGZvcmNlIEhFLUFBQyBpZiBtb25vIHN0cmVhbVxuICAgICAgICAgICBpZih0cmFjay5tZXRhZGF0YS5jaGFubmVsQ291bnQgIT09IDEgJiZcbiAgICAgICAgICAgIC8vIGRvbid0IGZvcmNlIEhFLUFBQyBpZiBmaXJlZm94XG4gICAgICAgICAgICB1YS5pbmRleE9mKCdmaXJlZm94JykgPT09IC0xKSB7XG4gICAgICAgICAgICAgIGF1ZGlvQ29kZWMgPSAnbXA0YS40MC41JztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSEUtQUFDIGlzIGJyb2tlbiBvbiBBbmRyb2lkLCBhbHdheXMgc2lnbmFsIGF1ZGlvIGNvZGVjIGFzIEFBQyBldmVuIGlmIHZhcmlhbnQgbWFuaWZlc3Qgc3RhdGVzIG90aGVyd2lzZVxuICAgICAgICBpZih1YS5pbmRleE9mKCdhbmRyb2lkJykgIT09IC0xKSB7XG4gICAgICAgICAgYXVkaW9Db2RlYyA9ICdtcDRhLjQwLjInO1xuICAgICAgICAgIGxvZ2dlci5sb2coYEFuZHJvaWQ6IGZvcmNlIGF1ZGlvIGNvZGVjIHRvYCArIGF1ZGlvQ29kZWMpO1xuICAgICAgICB9XG4gICAgICAgIHRyYWNrLmxldmVsQ29kZWMgPSBhdWRpb0NvZGVjO1xuICAgICAgICB0cmFjay5pZCA9IGRhdGEuaWQ7XG4gICAgICB9XG4gICAgICB0cmFjayA9IHRyYWNrcy52aWRlbztcbiAgICAgIGlmKHRyYWNrKSB7XG4gICAgICAgIHRyYWNrLmxldmVsQ29kZWMgPSB0aGlzLmxldmVsc1t0aGlzLmxldmVsXS52aWRlb0NvZGVjO1xuICAgICAgICB0cmFjay5pZCA9IGRhdGEuaWQ7XG4gICAgICB9XG5cbiAgICAgIC8vIGlmIHJlbXV4ZXIgc3BlY2lmeSB0aGF0IGEgdW5pcXVlIHRyYWNrIG5lZWRzIHRvIGdlbmVyYXRlZCxcbiAgICAgIC8vIGxldCdzIG1lcmdlIGFsbCB0cmFja3MgdG9nZXRoZXJcbiAgICAgIGlmIChkYXRhLnVuaXF1ZSkge1xuICAgICAgICB2YXIgbWVyZ2VkVHJhY2sgPSB7XG4gICAgICAgICAgICBjb2RlYyA6ICcnLFxuICAgICAgICAgICAgbGV2ZWxDb2RlYyA6ICcnXG4gICAgICAgICAgfTtcbiAgICAgICAgZm9yICh0cmFja05hbWUgaW4gZGF0YS50cmFja3MpIHtcbiAgICAgICAgICB0cmFjayA9IHRyYWNrc1t0cmFja05hbWVdO1xuICAgICAgICAgIG1lcmdlZFRyYWNrLmNvbnRhaW5lciA9IHRyYWNrLmNvbnRhaW5lcjtcbiAgICAgICAgICBpZiAobWVyZ2VkVHJhY2suY29kZWMpIHtcbiAgICAgICAgICAgIG1lcmdlZFRyYWNrLmNvZGVjICs9ICAnLCc7XG4gICAgICAgICAgICBtZXJnZWRUcmFjay5sZXZlbENvZGVjICs9ICAnLCc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmKHRyYWNrLmNvZGVjKSB7XG4gICAgICAgICAgICBtZXJnZWRUcmFjay5jb2RlYyArPSAgdHJhY2suY29kZWM7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0cmFjay5sZXZlbENvZGVjKSB7XG4gICAgICAgICAgICBtZXJnZWRUcmFjay5sZXZlbENvZGVjICs9ICB0cmFjay5sZXZlbENvZGVjO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0cmFja3MgPSB7IGF1ZGlvdmlkZW8gOiBtZXJnZWRUcmFjayB9O1xuICAgICAgfVxuICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5CVUZGRVJfQ09ERUNTLHRyYWNrcyk7XG4gICAgICAvLyBsb29wIHRocm91Z2ggdHJhY2tzIHRoYXQgYXJlIGdvaW5nIHRvIGJlIHByb3ZpZGVkIHRvIGJ1ZmZlckNvbnRyb2xsZXJcbiAgICAgIGZvciAodHJhY2tOYW1lIGluIHRyYWNrcykge1xuICAgICAgICB0cmFjayA9IHRyYWNrc1t0cmFja05hbWVdO1xuICAgICAgICBsb2dnZXIubG9nKGBtYWluIHRyYWNrOiR7dHJhY2tOYW1lfSxjb250YWluZXI6JHt0cmFjay5jb250YWluZXJ9LGNvZGVjc1tsZXZlbC9wYXJzZWRdPVske3RyYWNrLmxldmVsQ29kZWN9LyR7dHJhY2suY29kZWN9XWApO1xuICAgICAgICB2YXIgaW5pdFNlZ21lbnQgPSB0cmFjay5pbml0U2VnbWVudDtcbiAgICAgICAgaWYgKGluaXRTZWdtZW50KSB7XG4gICAgICAgICAgdGhpcy5wZW5kaW5nQXBwZW5kaW5nKys7XG4gICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5CVUZGRVJfQVBQRU5ESU5HLCB7dHlwZTogdHJhY2tOYW1lLCBkYXRhOiBpbml0U2VnbWVudCwgcGFyZW50IDogJ21haW4nLCBjb250ZW50IDogJ2luaXRTZWdtZW50J30pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvL3RyaWdnZXIgaGFuZGxlciByaWdodCBub3dcbiAgICAgIHRoaXMudGljaygpO1xuICAgIH1cbiAgfVxuXG4gIG9uRnJhZ1BhcnNpbmdEYXRhKGRhdGEpIHtcbiAgICBsZXQgZnJhZ0N1cnJlbnQgPSB0aGlzLmZyYWdDdXJyZW50O1xuICAgIGlmIChmcmFnQ3VycmVudCAmJlxuICAgICAgICBkYXRhLmlkID09PSAnbWFpbicgJiZcbiAgICAgICAgZGF0YS5zbiA9PT0gZnJhZ0N1cnJlbnQuc24gJiZcbiAgICAgICAgZGF0YS5sZXZlbCA9PT0gZnJhZ0N1cnJlbnQubGV2ZWwgJiZcbiAgICAgICAgKGRhdGEudHlwZSAhPT0gJ2F1ZGlvJyB8fCB0aGlzLmF1ZGlvVHJhY2tUeXBlICE9PSAnQVVESU8nKSAmJiAvLyBmaWx0ZXIgb3V0IG1haW4gYXVkaW8gaWYgYXVkaW8gdHJhY2sgaXMgbG9hZGVkIHRocm91Z2ggYXVkaW8gc3RyZWFtIGNvbnRyb2xsZXJcbiAgICAgICAgdGhpcy5zdGF0ZSA9PT0gU3RhdGUuUEFSU0lORykge1xuICAgICAgdmFyIGxldmVsID0gdGhpcy5sZXZlbHNbdGhpcy5sZXZlbF0sXG4gICAgICAgICAgZnJhZyA9IHRoaXMuZnJhZ0N1cnJlbnQ7XG5cbiAgICAgIGxvZ2dlci5sb2coYHBhcnNlZCAke2RhdGEudHlwZX0sUFRTOlske2RhdGEuc3RhcnRQVFMudG9GaXhlZCgzKX0sJHtkYXRhLmVuZFBUUy50b0ZpeGVkKDMpfV0sRFRTOlske2RhdGEuc3RhcnREVFMudG9GaXhlZCgzKX0vJHtkYXRhLmVuZERUUy50b0ZpeGVkKDMpfV0sbmI6JHtkYXRhLm5ifSxkcm9wcGVkOiR7ZGF0YS5kcm9wcGVkIHx8IDB9YCk7XG5cbiAgICAgIHZhciBkcmlmdCA9IExldmVsSGVscGVyLnVwZGF0ZUZyYWdQVFNEVFMobGV2ZWwuZGV0YWlscyxmcmFnLnNuLGRhdGEuc3RhcnRQVFMsZGF0YS5lbmRQVFMsZGF0YS5zdGFydERUUyxkYXRhLmVuZERUUyksXG4gICAgICAgICAgaGxzID0gdGhpcy5obHM7XG4gICAgICBobHMudHJpZ2dlcihFdmVudC5MRVZFTF9QVFNfVVBEQVRFRCwge2RldGFpbHM6IGxldmVsLmRldGFpbHMsIGxldmVsOiB0aGlzLmxldmVsLCBkcmlmdDogZHJpZnR9KTtcblxuICAgICAgLy8gaGFzIHJlbXV4ZXIgZHJvcHBlZCB2aWRlbyBmcmFtZXMgbG9jYXRlZCBiZWZvcmUgZmlyc3Qga2V5ZnJhbWUgP1xuICAgICAgaWYoZGF0YS50eXBlID09PSAndmlkZW8nKSB7XG4gICAgICAgIGZyYWcuZHJvcHBlZCA9IGRhdGEuZHJvcHBlZDtcbiAgICAgIH1cblxuICAgICAgW2RhdGEuZGF0YTEsIGRhdGEuZGF0YTJdLmZvckVhY2goYnVmZmVyID0+IHtcbiAgICAgICAgaWYgKGJ1ZmZlcikge1xuICAgICAgICAgIHRoaXMucGVuZGluZ0FwcGVuZGluZysrO1xuICAgICAgICAgIGhscy50cmlnZ2VyKEV2ZW50LkJVRkZFUl9BUFBFTkRJTkcsIHt0eXBlOiBkYXRhLnR5cGUsIGRhdGE6IGJ1ZmZlciwgcGFyZW50IDogJ21haW4nLGNvbnRlbnQgOiAnZGF0YSd9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHRoaXMubmV4dExvYWRQb3NpdGlvbiA9IGRhdGEuZW5kUFRTO1xuICAgICAgdGhpcy5idWZmZXJSYW5nZS5wdXNoKHt0eXBlOiBkYXRhLnR5cGUsIHN0YXJ0OiBkYXRhLnN0YXJ0UFRTLCBlbmQ6IGRhdGEuZW5kUFRTLCBmcmFnOiBmcmFnfSk7XG5cbiAgICAgIC8vdHJpZ2dlciBoYW5kbGVyIHJpZ2h0IG5vd1xuICAgICAgdGhpcy50aWNrKCk7XG4gICAgfVxuICB9XG5cbiAgb25GcmFnUGFyc2VkKGRhdGEpIHtcbiAgICBsZXQgZnJhZ0N1cnJlbnQgPSB0aGlzLmZyYWdDdXJyZW50O1xuICAgIGlmIChmcmFnQ3VycmVudCAmJlxuICAgICAgICBkYXRhLmlkID09PSAnbWFpbicgJiZcbiAgICAgICAgZGF0YS5zbiA9PT0gZnJhZ0N1cnJlbnQuc24gJiZcbiAgICAgICAgZGF0YS5sZXZlbCA9PT0gZnJhZ0N1cnJlbnQubGV2ZWwgJiZcbiAgICAgICAgdGhpcy5zdGF0ZSA9PT0gU3RhdGUuUEFSU0lORykge1xuICAgICAgdGhpcy5zdGF0cy50cGFyc2VkID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuUEFSU0VEO1xuICAgICAgdGhpcy5fY2hlY2tBcHBlbmRlZFBhcnNlZCgpO1xuICAgIH1cbiAgfVxuXG4gIG9uQXVkaW9UcmFja1N3aXRjaChkYXRhKSB7XG4gICAgLy8gaWYgYW55IFVSTCBmb3VuZCBvbiBuZXcgYXVkaW8gdHJhY2ssIGl0IGlzIGFuIGFsdGVybmF0ZSBhdWRpbyB0cmFja1xuICAgIHZhciBhbHRBdWRpbyA9ICEhZGF0YS51cmw7XG4gICAgLy8gaWYgd2Ugc3dpdGNoIG9uIG1haW4gYXVkaW8sIGVuc3VyZSB0aGF0IG1haW4gZnJhZ21lbnQgc2NoZWR1bGluZyBpcyBzeW5jZWQgd2l0aCBtZWRpYS5idWZmZXJlZFxuICAgIGlmICghYWx0QXVkaW8pIHtcbiAgICAgIGlmICh0aGlzLm1lZGlhQnVmZmVyICE9PSB0aGlzLm1lZGlhKSB7XG4gICAgICAgIGxvZ2dlci5sb2coYHN3aXRjaGluZyBvbiBtYWluIGF1ZGlvLCB1c2UgbWVkaWEuYnVmZmVyZWQgdG8gc2NoZWR1bGUgbWFpbiBmcmFnbWVudCBsb2FkaW5nYCk7XG4gICAgICAgIHRoaXMubWVkaWFCdWZmZXIgPSB0aGlzLm1lZGlhO1xuICAgICAgICBsZXQgZnJhZ0N1cnJlbnQgPSB0aGlzLmZyYWdDdXJyZW50O1xuICAgICAgICAvLyB3ZSBuZWVkIHRvIHJlZmlsbCBhdWRpbyBidWZmZXIgZnJvbSBtYWluOiBjYW5jZWwgYW55IGZyYWcgbG9hZGluZyB0byBzcGVlZCB1cCBhdWRpbyBzd2l0Y2hcbiAgICAgICAgaWYgKGZyYWdDdXJyZW50LmxvYWRlcikge1xuICAgICAgICAgIGxvZ2dlci5sb2coJ3N3aXRjaGluZyB0byBtYWluIGF1ZGlvIHRyYWNrLCBjYW5jZWwgbWFpbiBmcmFnbWVudCBsb2FkJyk7XG4gICAgICAgICAgZnJhZ0N1cnJlbnQubG9hZGVyLmFib3J0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5mcmFnQ3VycmVudCA9IG51bGw7XG4gICAgICAgIHRoaXMuZnJhZ1ByZXZpb3VzID0gbnVsbDtcbiAgICAgICAgLy8gZGVzdHJveSBkZW11eGVyIHRvIGZvcmNlIGluaXQgc2VnbWVudCBnZW5lcmF0aW9uIChmb2xsb3dpbmcgYXVkaW8gc3dpdGNoKVxuICAgICAgICBpZiAodGhpcy5kZW11eGVyKSB7XG4gICAgICAgICAgdGhpcy5kZW11eGVyLmRlc3Ryb3koKTtcbiAgICAgICAgICB0aGlzLmRlbXV4ZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIHN3aXRjaCB0byBJRExFIHN0YXRlIHRvIGxvYWQgbmV3IGZyYWdtZW50XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgLy8gaWYgd2Ugc3dpdGNoIG9uIGFsdGVybmF0ZSBhdWRpbywgZW5zdXJlIHRoYXQgbWFpbiBmcmFnbWVudCBzY2hlZHVsaW5nIGlzIHN5bmNlZCB3aXRoIHZpZGVvIHNvdXJjZWJ1ZmZlciBidWZmZXJlZFxuICAgICAgaWYgKHRoaXMudmlkZW9CdWZmZXIgJiYgdGhpcy5tZWRpYUJ1ZmZlciAhPT0gdGhpcy52aWRlb0J1ZmZlcikge1xuICAgICAgICBsb2dnZXIubG9nKGBzd2l0Y2hpbmcgb24gYWx0ZXJuYXRlIGF1ZGlvLCB1c2UgdmlkZW8uYnVmZmVyZWQgdG8gc2NoZWR1bGUgbWFpbiBmcmFnbWVudCBsb2FkaW5nYCk7XG4gICAgICAgIHRoaXMubWVkaWFCdWZmZXIgPSB0aGlzLnZpZGVvQnVmZmVyO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmFsdEF1ZGlvID0gYWx0QXVkaW87XG4gIH1cblxuXG4gIG9uQnVmZmVyQ3JlYXRlZChkYXRhKSB7XG4gICAgbGV0IHRyYWNrcyA9IGRhdGEudHJhY2tzLCBtZWRpYVRyYWNrLCBuYW1lLCBhbHRlcm5hdGUgPSBmYWxzZTtcbiAgICBmb3IodmFyIHR5cGUgaW4gdHJhY2tzKSB7XG4gICAgICBsZXQgdHJhY2sgPSB0cmFja3NbdHlwZV07XG4gICAgICBpZiAodHJhY2suaWQgPT09ICdtYWluJykge1xuICAgICAgICBuYW1lID0gdHlwZTtcbiAgICAgICAgbWVkaWFUcmFjayA9IHRyYWNrO1xuICAgICAgICAvLyBrZWVwIHZpZGVvIHNvdXJjZSBidWZmZXIgcmVmZXJlbmNlXG4gICAgICAgIGlmICh0eXBlID09PSAndmlkZW8nKSB7XG4gICAgICAgICAgdGhpcy52aWRlb0J1ZmZlciA9IHRyYWNrc1t0eXBlXS5idWZmZXI7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFsdGVybmF0ZSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChhbHRlcm5hdGUgJiYgbWVkaWFUcmFjaykge1xuICAgICAgbG9nZ2VyLmxvZyhgYWx0ZXJuYXRlIHRyYWNrIGZvdW5kLCB1c2UgJHtuYW1lfS5idWZmZXJlZCB0byBzY2hlZHVsZSBtYWluIGZyYWdtZW50IGxvYWRpbmdgKTtcbiAgICAgIHRoaXMubWVkaWFCdWZmZXIgPSBtZWRpYVRyYWNrLmJ1ZmZlcjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5tZWRpYUJ1ZmZlciA9IHRoaXMubWVkaWE7XG4gICAgfVxuICB9XG5cbiAgb25CdWZmZXJBcHBlbmRlZChkYXRhKSB7XG4gICAgaWYgKGRhdGEucGFyZW50ID09PSAnbWFpbicpIHtcbiAgICAgIHN3aXRjaCAodGhpcy5zdGF0ZSkge1xuICAgICAgICBjYXNlIFN0YXRlLlBBUlNJTkc6XG4gICAgICAgIGNhc2UgU3RhdGUuUEFSU0VEOlxuICAgICAgICAgIHRoaXMucGVuZGluZ0FwcGVuZGluZy0tO1xuICAgICAgICAgIHRoaXMuX2NoZWNrQXBwZW5kZWRQYXJzZWQoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBfY2hlY2tBcHBlbmRlZFBhcnNlZCgpIHtcbiAgICAvL3RyaWdnZXIgaGFuZGxlciByaWdodCBub3dcbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuUEFSU0VEICYmIHRoaXMucGVuZGluZ0FwcGVuZGluZyA9PT0gMCkgIHtcbiAgICAgIHZhciBmcmFnID0gdGhpcy5mcmFnQ3VycmVudCwgc3RhdHMgPSB0aGlzLnN0YXRzO1xuICAgICAgaWYgKGZyYWcpIHtcbiAgICAgICAgdGhpcy5mcmFnUHJldmlvdXMgPSBmcmFnO1xuICAgICAgICBzdGF0cy50YnVmZmVyZWQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgLy8gd2Ugc2hvdWxkIGdldCByaWQgb2YgdGhpcy5mcmFnTGFzdEticHNcbiAgICAgICAgdGhpcy5mcmFnTGFzdEticHMgPSBNYXRoLnJvdW5kKDggKiBzdGF0cy50b3RhbCAvIChzdGF0cy50YnVmZmVyZWQgLSBzdGF0cy50Zmlyc3QpKTtcbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5GUkFHX0JVRkZFUkVELCB7c3RhdHM6IHN0YXRzLCBmcmFnOiBmcmFnLCBpZCA6ICdtYWluJ30pO1xuICAgICAgICBsZXQgbWVkaWEgPSB0aGlzLm1lZGlhQnVmZmVyID8gdGhpcy5tZWRpYUJ1ZmZlciA6IHRoaXMubWVkaWE7XG4gICAgICAgIGxvZ2dlci5sb2coYG1haW4gYnVmZmVyZWQgOiAke1RpbWVSYW5nZXMudG9TdHJpbmcobWVkaWEuYnVmZmVyZWQpfWApO1xuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgIH1cbiAgICAgIHRoaXMudGljaygpO1xuICAgIH1cbiAgfVxuXG4gIG9uRXJyb3IoZGF0YSkge1xuICAgIGxldCBmcmFnID0gZGF0YS5mcmFnIHx8wqB0aGlzLmZyYWdDdXJyZW50O1xuICAgIC8vIGRvbid0IGhhbmRsZSBmcmFnIGVycm9yIG5vdCByZWxhdGVkIHRvIG1haW4gZnJhZ21lbnRcbiAgICBpZiAoZnJhZyAmJiBmcmFnLnR5cGUgIT09ICdtYWluJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgbWVkaWEgPSB0aGlzLm1lZGlhLFxuICAgICAgICAvLyAwLjQgOiB0b2xlcmFuY2UgbmVlZGVkIGFzIHNvbWUgYnJvd3NlcnMgc3RhbGxzIHBsYXliYWNrIGJlZm9yZSByZWFjaGluZyBidWZmZXJlZCBlbmRcbiAgICAgICAgbWVkaWFCdWZmZXJlZCA9IG1lZGlhICYmIHRoaXMuaXNCdWZmZXJlZChtZWRpYS5jdXJyZW50VGltZSkgJiYgdGhpcy5pc0J1ZmZlcmVkKG1lZGlhLmN1cnJlbnRUaW1lKzAuNCk7XG4gICAgc3dpdGNoKGRhdGEuZGV0YWlscykge1xuICAgICAgY2FzZSBFcnJvckRldGFpbHMuRlJBR19MT0FEX0VSUk9SOlxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuRlJBR19MT0FEX1RJTUVPVVQ6XG4gICAgICAgIGlmKCFkYXRhLmZhdGFsKSB7XG4gICAgICAgICAgdmFyIGxvYWRFcnJvciA9IHRoaXMuZnJhZ0xvYWRFcnJvcjtcbiAgICAgICAgICBpZihsb2FkRXJyb3IpIHtcbiAgICAgICAgICAgIGxvYWRFcnJvcisrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsb2FkRXJyb3I9MTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGV0IGNvbmZpZyA9IHRoaXMuY29uZmlnO1xuICAgICAgICAgIC8vIGtlZXAgcmV0cnlpbmcgLyBkb24ndCByYWlzZSBmYXRhbCBuZXR3b3JrIGVycm9yIGlmIGN1cnJlbnQgcG9zaXRpb24gaXMgYnVmZmVyZWRcbiAgICAgICAgICBpZiAobG9hZEVycm9yIDw9IGNvbmZpZy5mcmFnTG9hZGluZ01heFJldHJ5IHx8IG1lZGlhQnVmZmVyZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZnJhZ0xvYWRFcnJvciA9IGxvYWRFcnJvcjtcbiAgICAgICAgICAgIC8vIHJlc2V0IGxvYWQgY291bnRlciB0byBhdm9pZCBmcmFnIGxvb3AgbG9hZGluZyBlcnJvclxuICAgICAgICAgICAgZnJhZy5sb2FkQ291bnRlciA9IDA7XG4gICAgICAgICAgICAvLyBleHBvbmVudGlhbCBiYWNrb2ZmIGNhcHBlZCB0byBjb25maWcuZnJhZ0xvYWRpbmdNYXhSZXRyeVRpbWVvdXRcbiAgICAgICAgICAgIHZhciBkZWxheSA9IE1hdGgubWluKE1hdGgucG93KDIsbG9hZEVycm9yLTEpKmNvbmZpZy5mcmFnTG9hZGluZ1JldHJ5RGVsYXksY29uZmlnLmZyYWdMb2FkaW5nTWF4UmV0cnlUaW1lb3V0KTtcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKGBtZWRpYUNvbnRyb2xsZXI6IGZyYWcgbG9hZGluZyBmYWlsZWQsIHJldHJ5IGluICR7ZGVsYXl9IG1zYCk7XG4gICAgICAgICAgICB0aGlzLnJldHJ5RGF0ZSA9IHBlcmZvcm1hbmNlLm5vdygpICsgZGVsYXk7XG4gICAgICAgICAgICAvLyByZXRyeSBsb2FkaW5nIHN0YXRlXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuRlJBR19MT0FESU5HX1dBSVRJTkdfUkVUUlk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcihgbWVkaWFDb250cm9sbGVyOiAke2RhdGEuZGV0YWlsc30gcmVhY2hlcyBtYXggcmV0cnksIHJlZGlzcGF0Y2ggYXMgZmF0YWwgLi4uYCk7XG4gICAgICAgICAgICAvLyByZWRpc3BhdGNoIHNhbWUgZXJyb3IgYnV0IHdpdGggZmF0YWwgc2V0IHRvIHRydWVcbiAgICAgICAgICAgIGRhdGEuZmF0YWwgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5FUlJPUiwgZGF0YSk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuRVJST1I7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBFcnJvckRldGFpbHMuRlJBR19MT09QX0xPQURJTkdfRVJST1I6XG4gICAgICAgIGlmKCFkYXRhLmZhdGFsKSB7XG4gICAgICAgICAgLy8gaWYgYnVmZmVyIGlzIG5vdCBlbXB0eVxuICAgICAgICAgIGlmIChtZWRpYUJ1ZmZlcmVkKSB7XG4gICAgICAgICAgICAvLyB0cnkgdG8gcmVkdWNlIG1heCBidWZmZXIgbGVuZ3RoIDogcmF0aW9uYWxlIGlzIHRoYXQgd2UgY291bGQgZ2V0XG4gICAgICAgICAgICAvLyBmcmFnIGxvb3AgbG9hZGluZyBlcnJvciBiZWNhdXNlIG9mIGJ1ZmZlciBldmljdGlvblxuICAgICAgICAgICAgdGhpcy5fcmVkdWNlTWF4TWF4QnVmZmVyTGVuZ3RoKGZyYWcuZHVyYXRpb24pO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGJ1ZmZlciBlbXB0eS4gcmVwb3J0IGFzIGZhdGFsIGlmIGluIG1hbnVhbCBtb2RlIG9yIGlmIGxvd2VzdCBsZXZlbC5cbiAgICAgICAgICAgIC8vIGxldmVsIGNvbnRyb2xsZXIgdGFrZXMgY2FyZSBvZiBlbWVyZ2VuY3kgc3dpdGNoIGRvd24gbG9naWNcbiAgICAgICAgICAgIGlmICghZnJhZy5hdXRvTGV2ZWwgfHwgZnJhZy5sZXZlbCA9PT0gMCkge1xuICAgICAgICAgICAgICAvLyByZWRpc3BhdGNoIHNhbWUgZXJyb3IgYnV0IHdpdGggZmF0YWwgc2V0IHRvIHRydWVcbiAgICAgICAgICAgICAgZGF0YS5mYXRhbCA9IHRydWU7XG4gICAgICAgICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuRVJST1IsIGRhdGEpO1xuICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuRVJST1I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBFcnJvckRldGFpbHMuTEVWRUxfTE9BRF9FUlJPUjpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkxFVkVMX0xPQURfVElNRU9VVDpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLktFWV9MT0FEX0VSUk9SOlxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuS0VZX0xPQURfVElNRU9VVDpcbiAgICAgICAgLy8gIHdoZW4gaW4gRVJST1Igc3RhdGUsIGRvbid0IHN3aXRjaCBiYWNrIHRvIElETEUgc3RhdGUgaW4gY2FzZSBhIG5vbi1mYXRhbCBlcnJvciBpcyByZWNlaXZlZFxuICAgICAgICBpZih0aGlzLnN0YXRlICE9PSBTdGF0ZS5FUlJPUikge1xuICAgICAgICAgICAgLy8gaWYgZmF0YWwgZXJyb3IsIHN0b3AgcHJvY2Vzc2luZywgb3RoZXJ3aXNlIG1vdmUgdG8gSURMRSB0byByZXRyeSBsb2FkaW5nXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gZGF0YS5mYXRhbCA/IFN0YXRlLkVSUk9SIDogU3RhdGUuSURMRTtcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKGBtZWRpYUNvbnRyb2xsZXI6ICR7ZGF0YS5kZXRhaWxzfSB3aGlsZSBsb2FkaW5nIGZyYWcsc3dpdGNoIHRvICR7dGhpcy5zdGF0ZX0gc3RhdGUgLi4uYCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5CVUZGRVJfRlVMTF9FUlJPUjpcbiAgICAgICAgLy8gaWYgaW4gYXBwZW5kaW5nIHN0YXRlXG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09PSBTdGF0ZS5QQVJTSU5HIHx8wqB0aGlzLnN0YXRlID09PSBTdGF0ZS5QQVJTRUQpIHtcbiAgICAgICAgICAvLyByZWR1Y2UgbWF4IGJ1ZiBsZW4gaWYgY3VycmVudCBwb3NpdGlvbiBpcyBidWZmZXJlZFxuICAgICAgICAgIGlmIChtZWRpYUJ1ZmZlcmVkKSB7XG4gICAgICAgICAgICB0aGlzLl9yZWR1Y2VNYXhNYXhCdWZmZXJMZW5ndGgoZnJhZy5kdXJhdGlvbik7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gY3VycmVudCBwb3NpdGlvbiBpcyBub3QgYnVmZmVyZWQsIGJ1dCBicm93c2VyIGlzIHN0aWxsIGNvbXBsYWluaW5nIGFib3V0IGJ1ZmZlciBmdWxsIGVycm9yXG4gICAgICAgICAgICAvLyB0aGlzIGhhcHBlbnMgb24gSUUvRWRnZSwgcmVmZXIgdG8gaHR0cHM6Ly9naXRodWIuY29tL2RhaWx5bW90aW9uL2hscy5qcy9wdWxsLzcwOFxuICAgICAgICAgICAgLy8gaW4gdGhhdCBjYXNlIGZsdXNoIHRoZSB3aG9sZSBidWZmZXIgdG8gcmVjb3ZlclxuICAgICAgICAgICAgbG9nZ2VyLndhcm4oJ2J1ZmZlciBmdWxsIGVycm9yIGFsc28gbWVkaWEuY3VycmVudFRpbWUgaXMgbm90IGJ1ZmZlcmVkLCBmbHVzaCBldmVyeXRoaW5nJyk7XG4gICAgICAgICAgICB0aGlzLmZyYWdDdXJyZW50ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5QQVVTRUQ7XG4gICAgICAgICAgICAvLyBmbHVzaCBldmVyeXRoaW5nXG4gICAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkJVRkZFUl9GTFVTSElORywge3N0YXJ0T2Zmc2V0OiAwLCBlbmRPZmZzZXQ6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWX0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIF9yZWR1Y2VNYXhNYXhCdWZmZXJMZW5ndGgobWluTGVuZ3RoKSB7XG4gICAgbGV0IGNvbmZpZyA9IHRoaXMuY29uZmlnO1xuICAgIGlmIChjb25maWcubWF4TWF4QnVmZmVyTGVuZ3RoID49IG1pbkxlbmd0aCkge1xuICAgICAgLy8gcmVkdWNlIG1heCBidWZmZXIgbGVuZ3RoIGFzIGl0IG1pZ2h0IGJlIHRvbyBoaWdoLiB3ZSBkbyB0aGlzIHRvIGF2b2lkIGxvb3AgZmx1c2hpbmcgLi4uXG4gICAgICBjb25maWcubWF4TWF4QnVmZmVyTGVuZ3RoLz0yO1xuICAgICAgbG9nZ2VyLndhcm4oYHJlZHVjZSBtYXggYnVmZmVyIGxlbmd0aCB0byAke2NvbmZpZy5tYXhNYXhCdWZmZXJMZW5ndGh9cyBhbmQgc3dpdGNoIHRvIElETEUgc3RhdGVgKTtcbiAgICAgIC8vIGluY3JlYXNlIGZyYWdtZW50IGxvYWQgSW5kZXggdG8gYXZvaWQgZnJhZyBsb29wIGxvYWRpbmcgZXJyb3IgYWZ0ZXIgYnVmZmVyIGZsdXNoXG4gICAgICB0aGlzLmZyYWdMb2FkSWR4ICs9IDIgKiBjb25maWcuZnJhZ0xvYWRpbmdMb29wVGhyZXNob2xkO1xuICAgIH1cbiAgfVxuXG5fY2hlY2tCdWZmZXIoKSB7XG4gICAgdmFyIG1lZGlhID0gdGhpcy5tZWRpYTtcbiAgICAvLyBpZiByZWFkeSBzdGF0ZSBkaWZmZXJlbnQgZnJvbSBIQVZFX05PVEhJTkcgKG51bWVyaWMgdmFsdWUgMCksIHdlIGFyZSBhbGxvd2VkIHRvIHNlZWtcbiAgICBpZihtZWRpYSAmJiBtZWRpYS5yZWFkeVN0YXRlKSB7XG4gICAgICAgIGxldCBjdXJyZW50VGltZSA9IG1lZGlhLmN1cnJlbnRUaW1lLFxuICAgICAgICAgICAgIGJ1ZmZlcmVkID0gbWVkaWEuYnVmZmVyZWQ7XG4gICAgICAvLyBhZGp1c3QgY3VycmVudFRpbWUgdG8gc3RhcnQgcG9zaXRpb24gb24gbG9hZGVkIG1ldGFkYXRhXG4gICAgICBpZighdGhpcy5sb2FkZWRtZXRhZGF0YSAmJiBidWZmZXJlZC5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5sb2FkZWRtZXRhZGF0YSA9IHRydWU7XG4gICAgICAgIC8vIG9ubHkgYWRqdXN0IGN1cnJlbnRUaW1lIGlmIGRpZmZlcmVudCBmcm9tIHN0YXJ0UG9zaXRpb24gb3IgaWYgc3RhcnRQb3NpdGlvbiBub3QgYnVmZmVyZWRcbiAgICAgICAgLy8gYXQgdGhhdCBzdGFnZSwgdGhlcmUgc2hvdWxkIGJlIG9ubHkgb25lIGJ1ZmZlcmVkIHJhbmdlLCBhcyB3ZSByZWFjaCB0aGF0IGNvZGUgYWZ0ZXIgZmlyc3QgZnJhZ21lbnQgaGFzIGJlZW4gYnVmZmVyZWRcbiAgICAgICAgbGV0IHN0YXJ0UG9zaXRpb24gPSB0aGlzLnN0YXJ0UG9zaXRpb24sXG4gICAgICAgICAgICBzdGFydFBvc2l0aW9uQnVmZmVyZWQgPSB0aGlzLmlzQnVmZmVyZWQoc3RhcnRQb3NpdGlvbik7XG4gICAgICAgIC8vIGlmIGN1cnJlbnRUaW1lIG5vdCBtYXRjaGluZyB3aXRoIGV4cGVjdGVkIHN0YXJ0UG9zaXRpb24gb3Igc3RhcnRQb3NpdGlvbiBub3QgYnVmZmVyZWRcbiAgICAgICAgaWYgKGN1cnJlbnRUaW1lICE9PSBzdGFydFBvc2l0aW9uIHx8ICFzdGFydFBvc2l0aW9uQnVmZmVyZWQpIHtcbiAgICAgICAgICBsb2dnZXIubG9nKGB0YXJnZXQgc3RhcnQgcG9zaXRpb246JHtzdGFydFBvc2l0aW9ufWApO1xuICAgICAgICAgIC8vIGlmIHN0YXJ0UG9zaXRpb24gbm90IGJ1ZmZlcmVkLCBsZXQncyBzZWVrIHRvIGJ1ZmZlcmVkLnN0YXJ0KDApXG4gICAgICAgICAgaWYoIXN0YXJ0UG9zaXRpb25CdWZmZXJlZCkge1xuICAgICAgICAgICAgc3RhcnRQb3NpdGlvbiA9IGJ1ZmZlcmVkLnN0YXJ0KDApO1xuICAgICAgICAgICAgbG9nZ2VyLmxvZyhgdGFyZ2V0IHN0YXJ0IHBvc2l0aW9uIG5vdCBidWZmZXJlZCwgc2VlayB0byBidWZmZXJlZC5zdGFydCgwKSAke3N0YXJ0UG9zaXRpb259YCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxvZ2dlci5sb2coYGFkanVzdCBjdXJyZW50VGltZSBmcm9tICR7Y3VycmVudFRpbWV9IHRvICR7c3RhcnRQb3NpdGlvbn1gKTtcbiAgICAgICAgICBtZWRpYS5jdXJyZW50VGltZSA9IHN0YXJ0UG9zaXRpb247XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodGhpcy5pbW1lZGlhdGVTd2l0Y2gpIHtcbiAgICAgIHRoaXMuaW1tZWRpYXRlTGV2ZWxTd2l0Y2hFbmQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBidWZmZXJJbmZvID0gQnVmZmVySGVscGVyLmJ1ZmZlckluZm8obWVkaWEsY3VycmVudFRpbWUsMCksXG4gICAgICAgICAgICBleHBlY3RlZFBsYXlpbmcgPSAhKG1lZGlhLnBhdXNlZCB8fCAvLyBub3QgcGxheWluZyB3aGVuIG1lZGlhIGlzIHBhdXNlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZWRpYS5lbmRlZCAgfHwgLy8gbm90IHBsYXlpbmcgd2hlbiBtZWRpYSBpcyBlbmRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZWRpYS5idWZmZXJlZC5sZW5ndGggPT09IDApLCAvLyBub3QgcGxheWluZyBpZiBub3RoaW5nIGJ1ZmZlcmVkXG4gICAgICAgICAgICBqdW1wVGhyZXNob2xkID0gMC40LCAvLyB0b2xlcmFuY2UgbmVlZGVkIGFzIHNvbWUgYnJvd3NlcnMgc3RhbGxzIHBsYXliYWNrIGJlZm9yZSByZWFjaGluZyBidWZmZXJlZCByYW5nZSBlbmRcbiAgICAgICAgICAgIHBsYXloZWFkTW92aW5nID0gY3VycmVudFRpbWUgPiBtZWRpYS5wbGF5YmFja1JhdGUqdGhpcy5sYXN0Q3VycmVudFRpbWU7XG5cbiAgICAgICAgaWYgKHRoaXMuc3RhbGxlZCAmJiBwbGF5aGVhZE1vdmluZykge1xuICAgICAgICAgIHRoaXMuc3RhbGxlZCA9IGZhbHNlO1xuICAgICAgICAgIGxvZ2dlci5sb2coYHBsYXliYWNrIG5vdCBzdHVjayBhbnltb3JlIEAke2N1cnJlbnRUaW1lfWApO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNoZWNrIGJ1ZmZlciB1cGZyb250XG4gICAgICAgIC8vIGlmIGxlc3MgdGhhbiBqdW1wVGhyZXNob2xkIHNlY29uZCBpcyBidWZmZXJlZCwgbGV0J3MgY2hlY2sgaW4gbW9yZSBkZXRhaWxzXG4gICAgICAgIGlmKGV4cGVjdGVkUGxheWluZyAmJiBidWZmZXJJbmZvLmxlbiA8PSBqdW1wVGhyZXNob2xkKSB7XG4gICAgICAgICAgaWYocGxheWhlYWRNb3ZpbmcpIHtcbiAgICAgICAgICAgIC8vIHBsYXloZWFkIG1vdmluZ1xuICAgICAgICAgICAganVtcFRocmVzaG9sZCA9IDA7XG4gICAgICAgICAgICB0aGlzLnNlZWtIb2xlTnVkZ2VEdXJhdGlvbiA9IDA7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHBsYXloZWFkIG5vdCBtb3ZpbmcgQU5EIG1lZGlhIGV4cGVjdGVkIHRvIHBsYXlcbiAgICAgICAgICAgIGlmKCF0aGlzLnN0YWxsZWQpIHtcbiAgICAgICAgICAgICAgdGhpcy5zZWVrSG9sZU51ZGdlRHVyYXRpb24gPSAwO1xuICAgICAgICAgICAgICBsb2dnZXIubG9nKGBwbGF5YmFjayBzZWVtcyBzdHVjayBAJHtjdXJyZW50VGltZX1gKTtcbiAgICAgICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5FUlJPUiwge3R5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsIGRldGFpbHM6IEVycm9yRGV0YWlscy5CVUZGRVJfU1RBTExFRF9FUlJPUiwgZmF0YWw6IGZhbHNlfSk7XG4gICAgICAgICAgICAgIHRoaXMuc3RhbGxlZCA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLnNlZWtIb2xlTnVkZ2VEdXJhdGlvbiArPSB0aGlzLmNvbmZpZy5zZWVrSG9sZU51ZGdlRHVyYXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIGlmIHdlIGFyZSBiZWxvdyB0aHJlc2hvbGQsIHRyeSB0byBqdW1wIHRvIHN0YXJ0IG9mIG5leHQgYnVmZmVyIHJhbmdlIGlmIGNsb3NlXG4gICAgICAgICAgaWYoYnVmZmVySW5mby5sZW4gPD0ganVtcFRocmVzaG9sZCkge1xuICAgICAgICAgICAgLy8gbm8gYnVmZmVyIGF2YWlsYWJsZSBAIGN1cnJlbnRUaW1lLCBjaGVjayBpZiBuZXh0IGJ1ZmZlciBpcyBjbG9zZSAod2l0aGluIGEgY29uZmlnLm1heFNlZWtIb2xlIHNlY29uZCByYW5nZSlcbiAgICAgICAgICAgIHZhciBuZXh0QnVmZmVyU3RhcnQgPSBidWZmZXJJbmZvLm5leHRTdGFydCwgZGVsdGEgPSBuZXh0QnVmZmVyU3RhcnQtY3VycmVudFRpbWU7XG4gICAgICAgICAgICBpZihuZXh0QnVmZmVyU3RhcnQgJiZcbiAgICAgICAgICAgICAgIChkZWx0YSA8IHRoaXMuY29uZmlnLm1heFNlZWtIb2xlKSAmJlxuICAgICAgICAgICAgICAgKGRlbHRhID4gMCkpIHtcbiAgICAgICAgICAgICAgLy8gbmV4dCBidWZmZXIgaXMgY2xvc2UgISBhZGp1c3QgY3VycmVudFRpbWUgdG8gbmV4dEJ1ZmZlclN0YXJ0XG4gICAgICAgICAgICAgIC8vIHRoaXMgd2lsbCBlbnN1cmUgZWZmZWN0aXZlIHZpZGVvIGRlY29kaW5nXG4gICAgICAgICAgICAgIGxvZ2dlci5sb2coYGFkanVzdCBjdXJyZW50VGltZSBmcm9tICR7bWVkaWEuY3VycmVudFRpbWV9IHRvIG5leHQgYnVmZmVyZWQgQCAke25leHRCdWZmZXJTdGFydH0gKyBudWRnZSAke3RoaXMuc2Vla0hvbGVOdWRnZUR1cmF0aW9ufWApO1xuICAgICAgICAgICAgICBsZXQgaG9sZSA9IG5leHRCdWZmZXJTdGFydCArIHRoaXMuc2Vla0hvbGVOdWRnZUR1cmF0aW9uIC0gbWVkaWEuY3VycmVudFRpbWU7XG4gICAgICAgICAgICAgIG1lZGlhLmN1cnJlbnRUaW1lID0gbmV4dEJ1ZmZlclN0YXJ0ICsgdGhpcy5zZWVrSG9sZU51ZGdlRHVyYXRpb247XG4gICAgICAgICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuRVJST1IsIHt0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLCBkZXRhaWxzOiBFcnJvckRldGFpbHMuQlVGRkVSX1NFRUtfT1ZFUl9IT0xFLCBmYXRhbDogZmFsc2UsIGhvbGUgOiBob2xlfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgb25GcmFnTG9hZEVtZXJnZW5jeUFib3J0ZWQoKSB7XG4gICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgLy8gaWYgbG9hZGVkbWV0YWRhdGEgaXMgbm90IHNldCwgaXQgbWVhbnMgdGhhdCB3ZSBhcmUgZW1lcmdlbmN5IHN3aXRjaCBkb3duIG9uIGZpcnN0IGZyYWdcbiAgICAvLyBpbiB0aGF0IGNhc2UsIHJlc2V0IHN0YXJ0RnJhZ1JlcXVlc3RlZCBmbGFnXG4gICAgaWYoIXRoaXMubG9hZGVkbWV0YWRhdGEpIHtcbiAgICAgIHRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkID0gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMudGljaygpO1xuICB9XG5cbiAgb25CdWZmZXJGbHVzaGVkKCkge1xuICAgIC8qIGFmdGVyIHN1Y2Nlc3NmdWwgYnVmZmVyIGZsdXNoaW5nLCByZWJ1aWxkIGJ1ZmZlciBSYW5nZSBhcnJheVxuICAgICAgbG9vcCB0aHJvdWdoIGV4aXN0aW5nIGJ1ZmZlciByYW5nZSBhbmQgY2hlY2sgaWZcbiAgICAgIGNvcnJlc3BvbmRpbmcgcmFuZ2UgaXMgc3RpbGwgYnVmZmVyZWQuIG9ubHkgcHVzaCB0byBuZXcgYXJyYXkgYWxyZWFkeSBidWZmZXJlZCByYW5nZVxuICAgICovXG4gICAgdmFyIG5ld1JhbmdlID0gW10scmFuZ2UsaTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5idWZmZXJSYW5nZS5sZW5ndGg7IGkrKykge1xuICAgICAgcmFuZ2UgPSB0aGlzLmJ1ZmZlclJhbmdlW2ldO1xuICAgICAgaWYgKHRoaXMuaXNCdWZmZXJlZCgocmFuZ2Uuc3RhcnQgKyByYW5nZS5lbmQpIC8gMikpIHtcbiAgICAgICAgbmV3UmFuZ2UucHVzaChyYW5nZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuYnVmZmVyUmFuZ2UgPSBuZXdSYW5nZTtcblxuICAgIC8vIGluY3JlYXNlIGZyYWdtZW50IGxvYWQgSW5kZXggdG8gYXZvaWQgZnJhZyBsb29wIGxvYWRpbmcgZXJyb3IgYWZ0ZXIgYnVmZmVyIGZsdXNoXG4gICAgdGhpcy5mcmFnTG9hZElkeCArPSAyICogdGhpcy5jb25maWcuZnJhZ0xvYWRpbmdMb29wVGhyZXNob2xkO1xuICAgIC8vIG1vdmUgdG8gSURMRSBvbmNlIGZsdXNoIGNvbXBsZXRlLiB0aGlzIHNob3VsZCB0cmlnZ2VyIG5ldyBmcmFnbWVudCBsb2FkaW5nXG4gICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgLy8gcmVzZXQgcmVmZXJlbmNlIHRvIGZyYWdcbiAgICB0aGlzLmZyYWdQcmV2aW91cyA9IG51bGw7XG4gIH1cblxuICBzd2FwQXVkaW9Db2RlYygpIHtcbiAgICB0aGlzLmF1ZGlvQ29kZWNTd2FwID0gIXRoaXMuYXVkaW9Db2RlY1N3YXA7XG4gIH1cblxuICBjb21wdXRlTGl2ZVBvc2l0aW9uKHNsaWRpbmcsIGxldmVsRGV0YWlscykge1xuICAgIGxldCB0YXJnZXRMYXRlbmN5ID0gdGhpcy5jb25maWcubGl2ZVN5bmNEdXJhdGlvbiAhPT0gdW5kZWZpbmVkID8gdGhpcy5jb25maWcubGl2ZVN5bmNEdXJhdGlvbiA6IHRoaXMuY29uZmlnLmxpdmVTeW5jRHVyYXRpb25Db3VudCAqIGxldmVsRGV0YWlscy50YXJnZXRkdXJhdGlvbjtcbiAgICByZXR1cm4gc2xpZGluZyArIE1hdGgubWF4KDAsIGxldmVsRGV0YWlscy50b3RhbGR1cmF0aW9uIC0gdGFyZ2V0TGF0ZW5jeSk7XG4gIH1cblxuICBnZXQgbGl2ZVN5bmNQb3NpdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fbGl2ZVN5bmNQb3NpdGlvbjtcbiAgfVxuXG4gIHNldCBsaXZlU3luY1Bvc2l0aW9uKHZhbHVlKSB7XG4gICAgdGhpcy5fbGl2ZVN5bmNQb3NpdGlvbiA9IHZhbHVlO1xuICB9XG59XG5leHBvcnQgZGVmYXVsdCBTdHJlYW1Db250cm9sbGVyO1xuXG4iLCIvKlxuICogVGltZWxpbmUgQ29udHJvbGxlclxuKi9cblxuaW1wb3J0IEV2ZW50IGZyb20gJy4uL2V2ZW50cyc7XG5pbXBvcnQgRXZlbnRIYW5kbGVyIGZyb20gJy4uL2V2ZW50LWhhbmRsZXInO1xuaW1wb3J0IENlYTYwOFBhcnNlciBmcm9tICcuLi91dGlscy9jZWEtNjA4LXBhcnNlcic7XG5cbmNsYXNzIFRpbWVsaW5lQ29udHJvbGxlciBleHRlbmRzIEV2ZW50SGFuZGxlciB7XG5cbiAgY29uc3RydWN0b3IoaGxzKSB7XG4gICAgc3VwZXIoaGxzLCBFdmVudC5NRURJQV9BVFRBQ0hJTkcsXG4gICAgICAgICAgICAgICAgRXZlbnQuTUVESUFfREVUQUNISU5HLFxuICAgICAgICAgICAgICAgIEV2ZW50LkZSQUdfUEFSU0lOR19VU0VSREFUQSxcbiAgICAgICAgICAgICAgICBFdmVudC5NQU5JRkVTVF9MT0FESU5HLFxuICAgICAgICAgICAgICAgIEV2ZW50LkZSQUdfTE9BREVELFxuICAgICAgICAgICAgICAgIEV2ZW50LkxFVkVMX1NXSVRDSCk7XG5cbiAgICB0aGlzLmhscyA9IGhscztcbiAgICB0aGlzLmNvbmZpZyA9IGhscy5jb25maWc7XG4gICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcbiAgICB0aGlzLkN1ZXMgPSBobHMuY29uZmlnLmN1ZUhhbmRsZXI7XG5cbiAgICBpZiAodGhpcy5jb25maWcuZW5hYmxlQ0VBNzA4Q2FwdGlvbnMpXG4gICAge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICB2YXIgY2hhbm5lbDEgPVxuICAgICAge1xuICAgICAgICAnbmV3Q3VlJzogZnVuY3Rpb24oc3RhcnRUaW1lLCBlbmRUaW1lLCBzY3JlZW4pXG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoIXNlbGYudGV4dFRyYWNrMSlcbiAgICAgICAgICB7XG4gICAgICAgICAgICAvL0VuYWJsZSByZXVzZSBvZiBleGlzdGluZyB0ZXh0IHRyYWNrLlxuICAgICAgICAgICAgdmFyIGV4aXN0aW5nVHJhY2sxID0gc2VsZi5nZXRFeGlzdGluZ1RyYWNrKCcxJyk7XG4gICAgICAgICAgICBpZighZXhpc3RpbmdUcmFjazEpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHNlbGYudGV4dFRyYWNrMSA9IHNlbGYuY3JlYXRlVGV4dFRyYWNrKCdjYXB0aW9ucycsICdFbmdsaXNoJywgJ2VuJyk7XG4gICAgICAgICAgICAgIHNlbGYudGV4dFRyYWNrMS50ZXh0VHJhY2sxID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgc2VsZi50ZXh0VHJhY2sxID0gZXhpc3RpbmdUcmFjazE7XG4gICAgICAgICAgICAgIHNlbGYuY2xlYXJDdXJyZW50Q3VlcyhzZWxmLnRleHRUcmFjazEpO1xuXG4gICAgICAgICAgICAgIGxldCBlID0gbmV3IHdpbmRvdy5FdmVudCgnYWRkdHJhY2snKTtcbiAgICAgICAgICAgICAgZS50cmFjayA9IHNlbGYudGV4dFRyYWNrMTtcbiAgICAgICAgICAgICAgc2VsZi5tZWRpYS5kaXNwYXRjaEV2ZW50KGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHNlbGYuQ3Vlcy5uZXdDdWUoc2VsZi50ZXh0VHJhY2sxLCBzdGFydFRpbWUsIGVuZFRpbWUsIHNjcmVlbik7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHZhciBjaGFubmVsMiA9XG4gICAgICB7XG4gICAgICAgICduZXdDdWUnOiBmdW5jdGlvbihzdGFydFRpbWUsIGVuZFRpbWUsIHNjcmVlbilcbiAgICAgICAge1xuICAgICAgICAgIGlmICghc2VsZi50ZXh0VHJhY2syKVxuICAgICAgICAgIHtcbiAgICAgICAgICAgIC8vRW5hYmxlIHJldXNlIG9mIGV4aXN0aW5nIHRleHQgdHJhY2suXG4gICAgICAgICAgICB2YXIgZXhpc3RpbmdUcmFjazIgPSBzZWxmLmdldEV4aXN0aW5nVHJhY2soJzInKTtcbiAgICAgICAgICAgIGlmKCFleGlzdGluZ1RyYWNrMilcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgc2VsZi50ZXh0VHJhY2syID0gc2VsZi5jcmVhdGVUZXh0VHJhY2soJ2NhcHRpb25zJywgJ1NwYW5pc2gnLCAnZXMnKTtcbiAgICAgICAgICAgICAgc2VsZi50ZXh0VHJhY2syLnRleHRUcmFjazIgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBzZWxmLnRleHRUcmFjazIgPSBleGlzdGluZ1RyYWNrMjtcbiAgICAgICAgICAgICAgc2VsZi5jbGVhckN1cnJlbnRDdWVzKHNlbGYudGV4dFRyYWNrMik7XG5cbiAgICAgICAgICAgICAgbGV0IGUgPSBuZXcgd2luZG93LkV2ZW50KCdhZGR0cmFjaycpO1xuICAgICAgICAgICAgICBlLnRyYWNrID0gc2VsZi50ZXh0VHJhY2syO1xuICAgICAgICAgICAgICBzZWxmLm1lZGlhLmRpc3BhdGNoRXZlbnQoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc2VsZi5DdWVzLm5ld0N1ZShzZWxmLnRleHRUcmFjazIsIHN0YXJ0VGltZSwgZW5kVGltZSwgc2NyZWVuKTsgICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHRoaXMuY2VhNjA4UGFyc2VyID0gbmV3IENlYTYwOFBhcnNlcigwLCBjaGFubmVsMSwgY2hhbm5lbDIpO1xuICAgIH1cbiAgfVxuXG4gIGNsZWFyQ3VycmVudEN1ZXModHJhY2spXG4gIHtcbiAgICBpZiAodHJhY2sgJiYgdHJhY2suY3VlcylcbiAgICB7XG4gICAgICB3aGlsZSAodHJhY2suY3Vlcy5sZW5ndGggPiAwKVxuICAgICAge1xuICAgICAgICB0cmFjay5yZW1vdmVDdWUodHJhY2suY3Vlc1swXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZ2V0RXhpc3RpbmdUcmFjayhjaGFubmVsTnVtYmVyKVxuICB7XG4gICAgbGV0IG1lZGlhID0gdGhpcy5tZWRpYTtcbiAgICBpZiAobWVkaWEpXG4gICAge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtZWRpYS50ZXh0VHJhY2tzLmxlbmd0aDsgaSsrKVxuICAgICAge1xuICAgICAgICBsZXQgdGV4dFRyYWNrID0gbWVkaWEudGV4dFRyYWNrc1tpXTtcbiAgICAgICAgbGV0IHByb3BOYW1lID0gJ3RleHRUcmFjaycgKyBjaGFubmVsTnVtYmVyO1xuICAgICAgICBpZiAodGV4dFRyYWNrW3Byb3BOYW1lXSA9PT0gdHJ1ZSlcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiB0ZXh0VHJhY2s7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBjcmVhdGVUZXh0VHJhY2soa2luZCwgbGFiZWwsIGxhbmcpXG4gIHtcbiAgICBpZiAodGhpcy5tZWRpYSlcbiAgICB7XG4gICAgICByZXR1cm4gdGhpcy5tZWRpYS5hZGRUZXh0VHJhY2soa2luZCwgbGFiZWwsIGxhbmcpO1xuICAgIH1cbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgRXZlbnRIYW5kbGVyLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XG4gIH1cblxuICBvbk1lZGlhQXR0YWNoaW5nKGRhdGEpIHtcbiAgICB0aGlzLm1lZGlhID0gZGF0YS5tZWRpYTtcbiAgfVxuXG4gIG9uTWVkaWFEZXRhY2hpbmcoKSB7XG4gIH1cblxuICBvbk1hbmlmZXN0TG9hZGluZygpXG4gIHtcbiAgICB0aGlzLmxhc3RQdHMgPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7XG4gIH1cblxuICBvbkxldmVsU3dpdGNoKClcbiAge1xuICAgIGlmICh0aGlzLmhscy5jdXJyZW50TGV2ZWwuY2xvc2VkQ2FwdGlvbnMgPT09ICdOT05FJylcbiAgICB7XG4gICAgICB0aGlzLmVuYWJsZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgb25GcmFnTG9hZGVkKGRhdGEpXG4gIHtcbiAgICBpZiAoZGF0YS5mcmFnLnR5cGUgPT09ICdtYWluJykge1xuICAgICAgdmFyIHB0cyA9IGRhdGEuZnJhZy5zdGFydDsgLy9OdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgICAvLyBpZiB0aGlzIGlzIGEgZnJhZyBmb3IgYSBwcmV2aW91c2x5IGxvYWRlZCB0aW1lcmFuZ2UsIHJlbW92ZSBhbGwgY2FwdGlvbnNcbiAgICAgIC8vIFRPRE86IGNvbnNpZGVyIGp1c3QgcmVtb3ZpbmcgY2FwdGlvbnMgZm9yIHRoZSB0aW1lcmFuZ2VcbiAgICAgIGlmIChwdHMgPD0gdGhpcy5sYXN0UHRzKVxuICAgICAge1xuICAgICAgdGhpcy5jbGVhckN1cnJlbnRDdWVzKHRoaXMudGV4dFRyYWNrMSk7XG4gICAgICB0aGlzLmNsZWFyQ3VycmVudEN1ZXModGhpcy50ZXh0VHJhY2syKTtcbiAgICAgIH1cbiAgICAgIHRoaXMubGFzdFB0cyA9IHB0cztcbiAgICB9XG4gIH1cblxuICBvbkZyYWdQYXJzaW5nVXNlcmRhdGEoZGF0YSkge1xuICAgIC8vIHB1c2ggYWxsIG9mIHRoZSBDRUEtNzA4IG1lc3NhZ2VzIGludG8gdGhlIGludGVycHJldGVyXG4gICAgLy8gaW1tZWRpYXRlbHkuIEl0IHdpbGwgY3JlYXRlIHRoZSBwcm9wZXIgdGltZXN0YW1wcyBiYXNlZCBvbiBvdXIgUFRTIHZhbHVlXG4gICAgaWYgKHRoaXMuZW5hYmxlZClcbiAgICB7XG4gICAgICBmb3IgKHZhciBpPTA7IGk8ZGF0YS5zYW1wbGVzLmxlbmd0aDsgaSsrKVxuICAgICAge1xuICAgICAgICB2YXIgY2NkYXRhcyA9IHRoaXMuZXh0cmFjdENlYTYwOERhdGEoZGF0YS5zYW1wbGVzW2ldLmJ5dGVzKTtcbiAgICAgICAgdGhpcy5jZWE2MDhQYXJzZXIuYWRkRGF0YShkYXRhLnNhbXBsZXNbaV0ucHRzLCBjY2RhdGFzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBleHRyYWN0Q2VhNjA4RGF0YShieXRlQXJyYXkpXG4gIHtcbiAgICB2YXIgY291bnQgPSBieXRlQXJyYXlbMF0gJiAzMTtcbiAgICB2YXIgcG9zaXRpb24gPSAyO1xuICAgIHZhciB0bXBCeXRlLCBjY2J5dGUxLCBjY2J5dGUyLCBjY1ZhbGlkLCBjY1R5cGU7XG4gICAgdmFyIGFjdHVhbENDQnl0ZXMgPSBbXTtcblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgY291bnQ7IGorKykge1xuICAgICAgdG1wQnl0ZSA9IGJ5dGVBcnJheVtwb3NpdGlvbisrXTtcbiAgICAgIGNjYnl0ZTEgPSAweDdGICYgYnl0ZUFycmF5W3Bvc2l0aW9uKytdO1xuICAgICAgY2NieXRlMiA9IDB4N0YgJiBieXRlQXJyYXlbcG9zaXRpb24rK107XG4gICAgICBjY1ZhbGlkID0gKDQgJiB0bXBCeXRlKSA9PT0gMCA/IGZhbHNlIDogdHJ1ZTtcbiAgICAgIGNjVHlwZSA9IDMgJiB0bXBCeXRlO1xuXG4gICAgICBpZiAoY2NieXRlMSA9PT0gMCAmJiBjY2J5dGUyID09PSAwKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2NWYWxpZCkge1xuICAgICAgICBpZiAoY2NUeXBlID09PSAwKSAvLyB8fCBjY1R5cGUgPT09IDFcbiAgICAgICAge1xuICAgICAgICAgIGFjdHVhbENDQnl0ZXMucHVzaChjY2J5dGUxKTtcbiAgICAgICAgICBhY3R1YWxDQ0J5dGVzLnB1c2goY2NieXRlMik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFjdHVhbENDQnl0ZXM7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgVGltZWxpbmVDb250cm9sbGVyO1xuIiwiZXhwb3J0IGRlZmF1bHQgY2xhc3MgQUVTQ3J5cHRvIHtcbiAgY29uc3RydWN0b3IoaXYpIHtcbiAgICB0aGlzLmFlc0lWID0gaXY7XG4gIH1cblxuICBkZWNyeXB0KGRhdGEsIGtleSkge1xuICAgIHJldHVybiB3aW5kb3cuY3J5cHRvLnN1YnRsZS5kZWNyeXB0KHtuYW1lOiAnQUVTLUNCQycsIGl2OiB0aGlzLmFlc0lWfSwga2V5LCBkYXRhKTtcbiAgfVxufVxuIiwiY2xhc3MgQUVTRGVjcnlwdG9yIHtcbiAgY29uc3RydWN0b3Ioa2V5QnVmZmVyKSB7XG4gICAgLy8gY29udmVydCBrZXlCdWZmZXIgdG8gVWludDMyQXJyYXlcbiAgICB2YXIga2V5ID0gdGhpcy51aW50OEFycmF5VG9VaW50MzJBcnJheV8oa2V5QnVmZmVyKTtcbiAgICB2YXIga2V5U2l6ZSA9IHRoaXMua2V5U2l6ZSA9IGtleS5sZW5ndGg7XG5cbiAgICBpZiAoa2V5U2l6ZSAhPT0gNCAmJiBrZXlTaXplICE9PSA2ICYmIGtleVNpemUgIT09IDgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhZXMga2V5IHNpemU9JyArIGtleVNpemUpO1xuICAgIH1cblxuICAgIHZhciBuUm91bmRzID0ga2V5U2l6ZSArIDY7XG4gICAgdGhpcy5rc1Jvd3MgPSAoblJvdW5kcyArIDEpICogNDtcbiAgICB0aGlzLmtleVdvcmRzID0ga2V5O1xuICAgIHRoaXMuc3ViTWl4ID0gW107XG4gICAgdGhpcy5pbnZTdWJNaXggPSBbXTtcbiAgICB0aGlzLmluaXRUYWJsZSgpO1xuICAgIHRoaXMuZXhwYW5kS2V5KCk7XG4gIH1cblxuICB1aW50OEFycmF5VG9VaW50MzJBcnJheV8oYXJyYXlCdWZmZXIpIHtcbiAgICB2YXIgdmlldyA9IG5ldyBEYXRhVmlldyhhcnJheUJ1ZmZlcik7XG4gICAgdmFyIG5ld0FycmF5ID0gbmV3IFVpbnQzMkFycmF5KDQpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmV3QXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgIG5ld0FycmF5W2ldID0gdmlldy5nZXRVaW50MzIoaSAqIDQpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3QXJyYXk7XG4gIH1cblxuICBpbml0VGFibGUoKSB7XG4gICAgdmFyIHNCb3ggPSB0aGlzLnNCb3ggPSBuZXcgVWludDMyQXJyYXkoMjU2KTtcbiAgICB2YXIgaW52U0JveCA9IHRoaXMuaW52U0JveD0gbmV3IFVpbnQzMkFycmF5KDI1Nik7XG4gICAgdmFyIHN1Yk1peDAgPSB0aGlzLnN1Yk1peFswXSA9IG5ldyBVaW50MzJBcnJheSgyNTYpO1xuICAgIHZhciBzdWJNaXgxID0gdGhpcy5zdWJNaXhbMV0gPSBuZXcgVWludDMyQXJyYXkoMjU2KTtcbiAgICB2YXIgc3ViTWl4MiA9IHRoaXMuc3ViTWl4WzJdID0gbmV3IFVpbnQzMkFycmF5KDI1Nik7XG4gICAgdmFyIHN1Yk1peDMgPSB0aGlzLnN1Yk1peFszXSA9IG5ldyBVaW50MzJBcnJheSgyNTYpO1xuICAgIHZhciBpbnZTdWJNaXgwID0gdGhpcy5pbnZTdWJNaXhbMF0gPSBuZXcgVWludDMyQXJyYXkoMjU2KTtcbiAgICB2YXIgaW52U3ViTWl4MSA9IHRoaXMuaW52U3ViTWl4WzFdID0gbmV3IFVpbnQzMkFycmF5KDI1Nik7XG4gICAgdmFyIGludlN1Yk1peDIgPSB0aGlzLmludlN1Yk1peFsyXSA9IG5ldyBVaW50MzJBcnJheSgyNTYpO1xuICAgIHZhciBpbnZTdWJNaXgzID0gdGhpcy5pbnZTdWJNaXhbM10gPSBuZXcgVWludDMyQXJyYXkoMjU2KTtcbiAgICB0aGlzLnJjb24gPSBbMHgwLCAweDEsIDB4MiwgMHg0LCAweDgsIDB4MTAsIDB4MjAsIDB4NDAsIDB4ODAsIDB4MWIsIDB4MzZdO1xuXG4gICAgdmFyIGQgPSBuZXcgVWludDMyQXJyYXkoMjU2KTtcbiAgICB2YXIgeCA9IDA7XG4gICAgdmFyIHhpID0gMDtcbiAgICB2YXIgaSA9IDA7XG4gICAgZm9yIChpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG4gICAgICBpZiAoaSA8IDEyOCkge1xuICAgICAgICBkW2ldID0gaSA8PCAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZFtpXSA9IChpIDw8IDEpIF4gMHgxMWI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG4gICAgICB2YXIgc3ggPSB4aSBeICh4aSA8PCAxKSBeICh4aSA8PCAyKSBeICh4aSA8PCAzKSBeICh4aSA8PCA0KTtcbiAgICAgIHN4ID0gKHN4ID4+PiA4KSBeIChzeCAmIDB4ZmYpIF4gMHg2MztcbiAgICAgIHNCb3hbeF0gPSBzeDtcbiAgICAgIGludlNCb3hbc3hdID0geDtcblxuICAgICAgLy8gQ29tcHV0ZSBtdWx0aXBsaWNhdGlvblxuICAgICAgdmFyIHgyID0gZFt4XTtcbiAgICAgIHZhciB4NCA9IGRbeDJdO1xuICAgICAgdmFyIHg4ID0gZFt4NF07XG5cbiAgICAgIC8vIENvbXB1dGUgc3ViL2ludlN1YiBieXRlcywgbWl4IGNvbHVtbnMgdGFibGVzXG4gICAgICB2YXIgdCA9IChkW3N4XSAqIDB4MTAxKSBeIChzeCAqIDB4MTAxMDEwMCk7XG4gICAgICBzdWJNaXgwW3hdID0gKHQgPDwgMjQpIHwgKHQgPj4+IDgpO1xuICAgICAgc3ViTWl4MVt4XSA9ICh0IDw8IDE2KSB8ICh0ID4+PiAxNik7XG4gICAgICBzdWJNaXgyW3hdID0gKHQgPDwgOCkgfCAodCA+Pj4gMjQpO1xuICAgICAgc3ViTWl4M1t4XSA9IHQ7XG5cbiAgICAgIC8vIENvbXB1dGUgaW52IHN1YiBieXRlcywgaW52IG1peCBjb2x1bW5zIHRhYmxlc1xuICAgICAgdCA9ICh4OCAqIDB4MTAxMDEwMSkgXiAoeDQgKiAweDEwMDAxKSBeICh4MiAqIDB4MTAxKSBeICh4ICogMHgxMDEwMTAwKTtcbiAgICAgIGludlN1Yk1peDBbc3hdID0gKHQgPDwgMjQpIHwgKHQgPj4+IDgpO1xuICAgICAgaW52U3ViTWl4MVtzeF0gPSAodCA8PCAxNikgfCAodCA+Pj4gMTYpO1xuICAgICAgaW52U3ViTWl4MltzeF0gPSAodCA8PCA4KSB8ICh0ID4+PiAyNCk7XG4gICAgICBpbnZTdWJNaXgzW3N4XSA9IHQ7XG5cbiAgICAgIC8vIENvbXB1dGUgbmV4dCBjb3VudGVyXG4gICAgICBpZiAoIXgpIHtcbiAgICAgICAgeCA9IHhpID0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHggPSB4MiBeIGRbZFtkW3g4IF4geDJdXV07XG4gICAgICAgIHhpIF49IGRbZFt4aV1dO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGV4cGFuZEtleSgpIHtcbiAgICB2YXIga2V5U2NoZWR1bGUgPSB0aGlzLmtleVNjaGVkdWxlID0gbmV3IFVpbnQzMkFycmF5KHRoaXMua3NSb3dzKS5maWxsKDApO1xuICAgIHZhciByY29uID0gdGhpcy5yY29uO1xuICAgIHZhciBpbnZLZXlTY2hlZHVsZSA9IHRoaXMuaW52S2V5U2NoZWR1bGUgPSBuZXcgVWludDMyQXJyYXkodGhpcy5rc1Jvd3MpLmZpbGwoMCk7XG4gICAgdmFyIGtleVNpemUgPSB0aGlzLmtleVNpemU7XG4gICAgdmFyIGtleVdvcmRzID0gdGhpcy5rZXlXb3JkcztcbiAgICB2YXIga3NSb3dzID0gdGhpcy5rc1Jvd3M7XG4gICAgdmFyIHNib3ggPSB0aGlzLnNCb3g7XG4gICAgdmFyIGludlN1Yk1peDAgPSB0aGlzLmludlN1Yk1peFswXTtcbiAgICB2YXIgaW52U3ViTWl4MSA9IHRoaXMuaW52U3ViTWl4WzFdO1xuICAgIHZhciBpbnZTdWJNaXgyID0gdGhpcy5pbnZTdWJNaXhbMl07XG4gICAgdmFyIGludlN1Yk1peDMgPSB0aGlzLmludlN1Yk1peFszXTtcbiAgICB2YXIgcHJldjtcbiAgICB2YXIgdDtcblxuICAgIGZvciAodmFyIGtzUm93ID0gMDsga3NSb3cgPCBrc1Jvd3M7IGtzUm93KyspIHtcbiAgICAgIGlmIChrc1JvdyA8IGtleVNpemUpIHtcbiAgICAgICAgcHJldiA9IGtleVNjaGVkdWxlW2tzUm93XSA9IGtleVdvcmRzW2tzUm93XTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB0ID0gcHJldjtcblxuICAgICAgaWYgKGtzUm93ICUga2V5U2l6ZSA9PT0gMCkge1xuICAgICAgICAvLyBSb3Qgd29yZFxuICAgICAgICB0ID0gKHQgPDwgOCkgfCAodCA+Pj4gMjQpO1xuXG4gICAgICAgIC8vIFN1YiB3b3JkXG4gICAgICAgIHQgPSAoc2JveFt0ID4+PiAyNF0gPDwgMjQpIHwgKHNib3hbKHQgPj4+IDE2KSAmIDB4ZmZdIDw8IDE2KSB8IChzYm94Wyh0ID4+PiA4KSAmIDB4ZmZdIDw8IDgpIHwgc2JveFt0ICYgMHhmZl07XG5cbiAgICAgICAgLy8gTWl4IFJjb25cbiAgICAgICAgdCBePSByY29uWyhrc1JvdyAvIGtleVNpemUpIHwgMF0gPDwgMjQ7XG4gICAgICB9IGVsc2UgaWYgKGtleVNpemUgPiA2ICYmIGtzUm93ICUga2V5U2l6ZSA9PT0gNCkgIHtcbiAgICAgICAgLy8gU3ViIHdvcmRcbiAgICAgICAgdCA9IChzYm94W3QgPj4+IDI0XSA8PCAyNCkgfCAoc2JveFsodCA+Pj4gMTYpICYgMHhmZl0gPDwgMTYpIHwgKHNib3hbKHQgPj4+IDgpICYgMHhmZl0gPDwgOCkgfCBzYm94W3QgJiAweGZmXTtcbiAgICAgIH1cblxuICAgICAga2V5U2NoZWR1bGVba3NSb3ddID0gcHJldiA9IChrZXlTY2hlZHVsZVtrc1JvdyAtIGtleVNpemVdIF4gdCkgPj4+IDA7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaW52S3NSb3cgPSAwOyBpbnZLc1JvdyA8IGtzUm93czsgaW52S3NSb3crKykge1xuICAgICAga3NSb3cgPSBrc1Jvd3MgLSBpbnZLc1JvdztcbiAgICAgIGlmIChpbnZLc1JvdyAmIDMpIHtcbiAgICAgICAgdCA9IGtleVNjaGVkdWxlW2tzUm93XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHQgPSBrZXlTY2hlZHVsZVtrc1JvdyAtIDRdO1xuICAgICAgfVxuXG4gICAgICBpZiAoaW52S3NSb3cgPCA0IHx8IGtzUm93IDw9IDQpIHtcbiAgICAgICAgaW52S2V5U2NoZWR1bGVbaW52S3NSb3ddID0gdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGludktleVNjaGVkdWxlW2ludktzUm93XSA9IGludlN1Yk1peDBbc2JveFt0ID4+PiAyNF1dIF4gaW52U3ViTWl4MVtzYm94Wyh0ID4+PiAxNikgJiAweGZmXV0gXiBpbnZTdWJNaXgyW3Nib3hbKHQgPj4+IDgpICYgMHhmZl1dIF4gaW52U3ViTWl4M1tzYm94W3QgJiAweGZmXV07XG4gICAgICB9XG5cbiAgICAgIGludktleVNjaGVkdWxlW2ludktzUm93XSA9IGludktleVNjaGVkdWxlW2ludktzUm93XSA+Pj4gMDtcbiAgICB9XG4gIH1cblxuICBkZWNyeXB0KGlucHV0RGF0YSwgb2Zmc2V0LCBhZXNJVikge1xuICAgIHZhciBpbnZLZXlTY2hlZCA9IHRoaXMuaW52S2V5U2NoZWR1bGU7XG4gICAgdmFyIGludktleTAgPSBpbnZLZXlTY2hlZFswXTtcbiAgICB2YXIgaW52S2V5MSA9IGludktleVNjaGVkWzFdO1xuICAgIHZhciBpbnZLZXkyID0gaW52S2V5U2NoZWRbMl07XG4gICAgdmFyIGludktleTMgPSBpbnZLZXlTY2hlZFszXTtcbiAgICB2YXIgblJvdW5kcyA9IHRoaXMua2V5U2l6ZSArIDY7XG4gICAgdmFyIGludlN1Yk1peDAgPSB0aGlzLmludlN1Yk1peFswXTtcbiAgICB2YXIgaW52U3ViTWl4MSA9IHRoaXMuaW52U3ViTWl4WzFdO1xuICAgIHZhciBpbnZTdWJNaXgyID0gdGhpcy5pbnZTdWJNaXhbMl07XG4gICAgdmFyIGludlN1Yk1peDMgPSB0aGlzLmludlN1Yk1peFszXTtcbiAgICB2YXIgaW52U0JPWCA9IHRoaXMuaW52U0JveDtcbiAgICB2YXIgb3V0cHV0ID0gbmV3IFVpbnQ4QXJyYXkoaW5wdXREYXRhLmJ5dGVMZW5ndGgpO1xuXG4gICAgLy8gcGFyc2UgaXYgdG8gVWludDMyQXJyYXlcbiAgICB2YXIgaXYgPSB0aGlzLnVpbnQ4QXJyYXlUb1VpbnQzMkFycmF5XyhhZXNJVik7XG5cbiAgICB2YXIgbWl4aW5nMCA9IGl2WzBdO1xuICAgIHZhciBtaXhpbmcxID0gaXZbMV07XG4gICAgdmFyIG1peGluZzIgPSBpdlsyXTtcbiAgICB2YXIgbWl4aW5nMyA9IGl2WzNdO1xuXG4gICAgdmFyIGlucHV0ID0gbmV3IERhdGFWaWV3KGlucHV0RGF0YSk7XG5cbiAgICB3aGlsZSAob2Zmc2V0IDwgaW5wdXREYXRhLmJ5dGVMZW5ndGgpIHtcbiAgICAgIHZhciB3MCA9IGlucHV0LmdldFVpbnQzMihvZmZzZXQpO1xuICAgICAgdmFyIHcxID0gaW5wdXQuZ2V0VWludDMyKG9mZnNldCArIDQpO1xuICAgICAgdmFyIHcyID0gaW5wdXQuZ2V0VWludDMyKG9mZnNldCArIDgpO1xuICAgICAgdmFyIHczID0gaW5wdXQuZ2V0VWludDMyKG9mZnNldCArIDEyKTtcblxuICAgICAgdmFyIHMgPSBuZXcgVWludDMyQXJyYXkoNCk7XG4gICAgICB2YXIgdCA9IG5ldyBVaW50MzJBcnJheSg0KTtcbiAgICAgIHZhciByID0gbmV3IFVpbnQzMkFycmF5KDQpO1xuXG4gICAgICBzWzBdID0gdzAgXiBpbnZLZXkwO1xuICAgICAgc1sxXSA9IHczIF4gaW52S2V5MTtcbiAgICAgIHNbMl0gPSB3MiBeIGludktleTI7XG4gICAgICBzWzNdID0gdzEgXiBpbnZLZXkzO1xuXG4gICAgICB2YXIga3NSb3cgPSA0O1xuICAgICAgdmFyIGk7XG4gICAgICBmb3IgKGkgPSAxOyBpIDwgblJvdW5kczsgaSsrKSB7XG4gICAgICAgIHRbMF0gPSBpbnZTdWJNaXgwW3NbMF0gPj4+IDI0XSBeIGludlN1Yk1peDFbKHNbMV0gPj4+IDE2KSAmIDB4ZmZdIF4gaW52U3ViTWl4Mlsoc1syXSA+Pj4gOCkgJiAweGZmXSBeIGludlN1Yk1peDNbc1szXSAmIDB4ZmZdIF4gaW52S2V5U2NoZWRba3NSb3crK107XG4gICAgICAgIHRbMV0gPSBpbnZTdWJNaXgwW3NbMV0gPj4+IDI0XSBeIGludlN1Yk1peDFbKHNbMl0gPj4+IDE2KSAmIDB4ZmZdIF4gaW52U3ViTWl4Mlsoc1szXSA+Pj4gOCkgJiAweGZmXSBeIGludlN1Yk1peDNbc1swXSAmIDB4ZmZdIF4gaW52S2V5U2NoZWRba3NSb3crK107XG4gICAgICAgIHRbMl0gPSBpbnZTdWJNaXgwW3NbMl0gPj4+IDI0XSBeIGludlN1Yk1peDFbKHNbM10gPj4+IDE2KSAmIDB4ZmZdIF4gaW52U3ViTWl4Mlsoc1swXSA+Pj4gOCkgJiAweGZmXSBeIGludlN1Yk1peDNbc1sxXSAmIDB4ZmZdIF4gaW52S2V5U2NoZWRba3NSb3crK107XG4gICAgICAgIHRbM10gPSBpbnZTdWJNaXgwW3NbM10gPj4+IDI0XSBeIGludlN1Yk1peDFbKHNbMF0gPj4+IDE2KSAmIDB4ZmZdIF4gaW52U3ViTWl4Mlsoc1sxXSA+Pj4gOCkgJiAweGZmXSBeIGludlN1Yk1peDNbc1syXSAmIDB4ZmZdIF4gaW52S2V5U2NoZWRba3NSb3crK107XG4gICAgICAgIC8vIFVwZGF0ZSBzdGF0ZVxuICAgICAgICBzWzBdID0gdFswXTtcbiAgICAgICAgc1sxXSA9IHRbMV07XG4gICAgICAgIHNbMl0gPSB0WzJdO1xuICAgICAgICBzWzNdID0gdFszXTtcbiAgICAgIH1cbiAgICAgIC8vIFNoaWZ0IHJvd3MsIHN1YiBieXRlcywgYWRkIHJvdW5kIGtleVxuICAgICAgdFswXSA9ICgoaW52U0JPWFtzWzBdID4+PiAyNF0gPDwgMjQpIHwgKGludlNCT1hbKHNbMV0gPj4+IDE2KSAmIDB4ZmZdIDw8IDE2KSB8IChpbnZTQk9YWyhzWzJdID4+PiA4KSAmIDB4ZmZdIDw8IDgpIHwgaW52U0JPWFtzWzNdICYgMHhmZl0pIF4gaW52S2V5U2NoZWRba3NSb3crK107XG4gICAgICB0WzFdID0gKChpbnZTQk9YW3NbMV0gPj4+IDI0XSA8PCAyNCkgfCAoaW52U0JPWFsoc1syXSA+Pj4gMTYpICYgMHhmZl0gPDwgMTYpIHwgKGludlNCT1hbKHNbM10gPj4+IDgpICYgMHhmZl0gPDwgOCkgfCBpbnZTQk9YW3NbMF0gJiAweGZmXSkgXiBpbnZLZXlTY2hlZFtrc1JvdysrXTtcbiAgICAgIHRbMl0gPSAoKGludlNCT1hbc1syXSA+Pj4gMjRdIDw8IDI0KSB8IChpbnZTQk9YWyhzWzNdID4+PiAxNikgJiAweGZmXSA8PCAxNikgfCAoaW52U0JPWFsoc1swXSA+Pj4gOCkgJiAweGZmXSA8PCA4KSB8IGludlNCT1hbc1sxXSAmIDB4ZmZdKSBeIGludktleVNjaGVkW2tzUm93KytdO1xuICAgICAgdFszXSA9ICgoaW52U0JPWFtzWzNdID4+PiAyNF0gPDwgMjQpIHwgKGludlNCT1hbKHNbMF0gPj4+IDE2KSAmIDB4ZmZdIDw8IDE2KSB8IChpbnZTQk9YWyhzWzFdID4+PiA4KSAmIDB4ZmZdIDw8IDgpIHwgaW52U0JPWFtzWzJdICYgMHhmZl0pIF4gaW52S2V5U2NoZWRba3NSb3ddO1xuXG4gICAgICByWzNdID0gdFswXSBeIG1peGluZzA7XG4gICAgICByWzJdID0gdFszXSBeIG1peGluZzE7XG4gICAgICByWzFdID0gdFsyXSBeIG1peGluZzI7XG4gICAgICByWzBdID0gdFsxXSBeIG1peGluZzM7XG5cbiAgICAgIC8vIGNvbnZlcnQgcmVzdWx0IHRvIHVpbnQ4QXJyYXkgYW5kIHdyaXRlIHRvIG91dHB1dFxuICAgICAgdmFyIHJWaWV3ID0gbmV3IERhdGFWaWV3KHIuYnVmZmVyKTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG4gICAgICAgIG91dHB1dFtpICsgb2Zmc2V0XSA9IHJWaWV3LmdldFVpbnQ4KDE1IC0gaSk7XG4gICAgICB9XG5cbiAgICAgIC8vIHJlc2V0IGl2IHRvIGxhc3QgNCB1bnNpZ25lZCBpbnRcbiAgICAgIG1peGluZzAgPSB3MDtcbiAgICAgIG1peGluZzEgPSB3MTtcbiAgICAgIG1peGluZzIgPSB3MjtcbiAgICAgIG1peGluZzMgPSB3MztcblxuICAgICAgb2Zmc2V0ICs9IDE2O1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnVucGFkXyhvdXRwdXQpLmJ1ZmZlcjtcbiAgfVxuXG4gIHVucGFkXyhkYXRhKSB7XG4gICAgLy8gUmVtb3ZlIHRoZSBwYWRkaW5nIGF0IHRoZSBlbmQgb2Ygb3V0cHV0LlxuICAgIC8vIFRoZSBwYWRkaW5nIG9jY3VycyBiZWNhdXNlIGVhY2ggZGVjcnlwdGlvbiBoYXBwZW5zIGluIDE2IGJ5dGVzLCBidXQgdGhlIGVuY3J5cHRlZCBkYXRhIGlzIG5vdCBtb2R1bHVzIG9mIDE2XG4gICAgdmFyIGxlbiA9IGRhdGEubGVuZ3RoO1xuICAgIHZhciBieXRlc09mUGFkZGluZyA9IGRhdGFbbGVuIC0gMV07XG5cbiAgICAvLyBVbmNvbW1lbnQgdG8gbG9nIGluZm8gYWJvdXQgcGFkZGluZ1xuICAgIC8vZm9yICh2YXIgaSA9IGJ5dGVzT2ZQYWRkaW5nOyBpID4gMDsgLS1pKSB7XG4gICAgLy8gICAgdmFyIHYgPSBkYXRhWy0tbGVuXTtcbiAgICAvL1xuICAgIC8vICAgIGlmIChieXRlc09mUGFkZGluZyAhPT0gdikge1xuICAgIC8vICAgICAgICBjb25zb2xlLndhcm4oJ0ludmFsaWQgcGFkZGluZyBlcnJvcjogRXhwZWN0ZWQgJyArIGJ5dGVzT2ZQYWRkaW5nLCAnLCBidXQgcmVjZWl2ZWQgJyArIHYpO1xuICAgIC8vICAgIH1cbiAgICAvL31cblxuICAgIHJldHVybiBkYXRhLnN1YmFycmF5KDAsIGRhdGEubGVuZ3RoIC0gYnl0ZXNPZlBhZGRpbmcpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEFFU0RlY3J5cHRvcjtcbiIsImltcG9ydCBBRVNDcnlwdG8gZnJvbSAnLi9hZXMtY3J5cHRvJztcbmltcG9ydCBGYXN0QUVTS2V5IGZyb20gJy4vZmFzdC1hZXMta2V5JztcbmltcG9ydCBBRVNEZWNyeXB0b3IgZnJvbSAnLi9hZXMtZGVjcnlwdG9yJztcblxuaW1wb3J0IHtFcnJvclR5cGVzLCBFcnJvckRldGFpbHN9IGZyb20gJy4uL2Vycm9ycyc7XG5pbXBvcnQge2xvZ2dlcn0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcblxuY2xhc3MgRGVjcnlwdGVyIHtcbiAgY29uc3RydWN0b3IoaGxzKSB7XG4gICAgdGhpcy5obHMgPSBobHM7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGJyb3dzZXJDcnlwdG8gPSB3aW5kb3cgPyB3aW5kb3cuY3J5cHRvIDogY3J5cHRvO1xuICAgICAgdGhpcy5zdWJ0bGUgPSBicm93c2VyQ3J5cHRvLnN1YnRsZSB8fCBicm93c2VyQ3J5cHRvLndlYmtpdFN1YnRsZTtcbiAgICB9IGNhdGNoIChlKSB7fVxuXG4gICAgdGhpcy5kaXNhYmxlV2ViQ3J5cHRvID0gIXRoaXMuc3VwcG9ydHNXZWJDcnlwdG8oKTtcbiAgfVxuXG4gIHN1cHBvcnRzV2ViQ3J5cHRvKCkge1xuICAgIHJldHVybiB0aGlzLnN1YnRsZSAmJiB3aW5kb3cubG9jYXRpb24ucHJvdG9jb2wgPT09ICdodHRwczonO1xuICB9XG5cbiAgZGVjcnlwdChkYXRhLCBrZXksIGl2LCBjYWxsYmFjaykge1xuICAgIGlmICh0aGlzLmRpc2FibGVXZWJDcnlwdG8gJiYgdGhpcy5obHMuY29uZmlnLmVuYWJsZVNvZnR3YXJlQUVTKSB7XG4gICAgICBsb2dnZXIubG9nKCdkZWNyeXB0aW5nIGJ5IEphdmFTY3JpcHQgSW1wbGVtZW50YXRpb24nKTtcblxuICAgICAgdmFyIGRlY3J5cHRvciA9IG5ldyBBRVNEZWNyeXB0b3Ioa2V5KTtcbiAgICAgIGNhbGxiYWNrKGRlY3J5cHRvci5kZWNyeXB0KGRhdGEsIDAsIGl2KSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgbG9nZ2VyLmxvZygnZGVjcnlwdGluZyBieSBXZWJDcnlwdG8gQVBJJyk7XG5cbiAgICAgIGlmICh0aGlzLmtleSAhPT0ga2V5KSB7XG4gICAgICAgIHRoaXMua2V5ID0ga2V5O1xuICAgICAgICB0aGlzLmZhc3RBZXNLZXkgPSBuZXcgRmFzdEFFU0tleShrZXkpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmZhc3RBZXNLZXkuZXhwYW5kS2V5KCkuXG4gICAgICAgIHRoZW4oKGFlc0tleSkgPT4ge1xuICAgICAgICAgIC8vIGRlY3J5cHQgdXNpbmcgd2ViIGNyeXB0b1xuICAgICAgICAgIHZhciBjcnlwdG8gPSBuZXcgQUVTQ3J5cHRvKGl2KTtcbiAgICAgICAgICBjcnlwdG8uZGVjcnlwdChkYXRhLCBhZXNLZXkpLlxuICAgICAgICAgICAgdGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgIGNhbGxiYWNrKHJlc3VsdCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSkuXG4gICAgICAgIGNhdGNoICgoZXJyKSA9PiB7XG4gICAgICAgICAgdGhpcy5vbldlYkNyeXB0b0Vycm9yKGVyciwgZGF0YSwga2V5LCBpdiwgY2FsbGJhY2spO1xuICAgICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBvbldlYkNyeXB0b0Vycm9yKGVyciwgZGF0YSwga2V5LCBpdiwgY2FsbGJhY2spIHtcbiAgICBpZiAodGhpcy5obHMuY29uZmlnLmVuYWJsZVNvZnR3YXJlQUVTKSB7XG4gICAgICBsb2dnZXIubG9nKCdkaXNhYmxpbmcgdG8gdXNlIFdlYkNyeXB0byBBUEknKTtcbiAgICAgIHRoaXMuZGlzYWJsZVdlYkNyeXB0byA9IHRydWU7XG4gICAgICB0aGlzLmRlY3J5cHQoZGF0YSwga2V5LCBpdiwgY2FsbGJhY2spO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGxvZ2dlci5lcnJvcihgZGVjcnlwdGluZyBlcnJvciA6ICR7ZXJyLm1lc3NhZ2V9YCk7XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkVSUk9SLCB7dHlwZSA6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsIGRldGFpbHMgOiBFcnJvckRldGFpbHMuRlJBR19ERUNSWVBUX0VSUk9SLCBmYXRhbCA6IHRydWUsIHJlYXNvbiA6IGVyci5tZXNzYWdlfSk7XG4gICAgfVxuICB9XG5cbiAgZGVzdHJveSgpIHt9XG59XG5cbmV4cG9ydCBkZWZhdWx0IERlY3J5cHRlcjtcbiIsImNsYXNzIEZhc3RBRVNLZXkge1xuICBjb25zdHJ1Y3RvcihrZXkpIHtcbiAgICB0aGlzLmtleSA9IGtleTtcbiAgfVxuXG4gIGV4cGFuZEtleSgpIHtcbiAgICByZXR1cm4gd2luZG93LmNyeXB0by5zdWJ0bGUuaW1wb3J0S2V5KCdyYXcnLCB0aGlzLmtleSwge25hbWU6ICdBRVMtQ0JDJ30sIGZhbHNlLCBbJ2VuY3J5cHQnLCAnZGVjcnlwdCddKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBGYXN0QUVTS2V5O1xuIiwiLyoqXG4gKiBBQUMgZGVtdXhlclxuICovXG5pbXBvcnQgQURUUyBmcm9tICcuL2FkdHMnO1xuaW1wb3J0IHtsb2dnZXJ9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XG5pbXBvcnQgSUQzIGZyb20gJy4uL2RlbXV4L2lkMyc7XG5cbiBjbGFzcyBBQUNEZW11eGVyIHtcblxuICBjb25zdHJ1Y3RvcihvYnNlcnZlciwgaWQsIHJlbXV4ZXJDbGFzcywgY29uZmlnKSB7XG4gICAgdGhpcy5vYnNlcnZlciA9IG9ic2VydmVyO1xuICAgIHRoaXMuaWQgPSBpZDtcbiAgICB0aGlzLnJlbXV4ZXJDbGFzcyA9IHJlbXV4ZXJDbGFzcztcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICB0aGlzLnJlbXV4ZXIgPSBuZXcgdGhpcy5yZW11eGVyQ2xhc3Mob2JzZXJ2ZXIsaWQsIGNvbmZpZyk7XG4gICAgdGhpcy5pbnNlcnREaXNjb250aW51aXR5KCk7XG4gIH1cblxuICBpbnNlcnREaXNjb250aW51aXR5KCkge1xuICAgIHRoaXMuX2FhY1RyYWNrID0ge2NvbnRhaW5lciA6ICdhdWRpby9hZHRzJywgdHlwZTogJ2F1ZGlvJywgaWQgOi0xLCBzZXF1ZW5jZU51bWJlcjogMCwgc2FtcGxlcyA6IFtdLCBsZW4gOiAwfTtcbiAgfVxuXG4gIHN0YXRpYyBwcm9iZShkYXRhKSB7XG4gICAgLy8gY2hlY2sgaWYgZGF0YSBjb250YWlucyBJRDMgdGltZXN0YW1wIGFuZCBBRFRTIHN5bmMgd29yY1xuICAgIHZhciBpZDMgPSBuZXcgSUQzKGRhdGEpLCBvZmZzZXQsbGVuO1xuICAgIGlmKGlkMy5oYXNUaW1lU3RhbXApIHtcbiAgICAgIC8vIGxvb2sgZm9yIEFEVFMgaGVhZGVyICgweEZGRngpXG4gICAgICBmb3IgKG9mZnNldCA9IGlkMy5sZW5ndGgsIGxlbiA9IGRhdGEubGVuZ3RoOyBvZmZzZXQgPCBsZW4gLSAxOyBvZmZzZXQrKykge1xuICAgICAgICBpZiAoKGRhdGFbb2Zmc2V0XSA9PT0gMHhmZikgJiYgKGRhdGFbb2Zmc2V0KzFdICYgMHhmMCkgPT09IDB4ZjApIHtcbiAgICAgICAgICAvL2xvZ2dlci5sb2coJ0FEVFMgc3luYyB3b3JkIGZvdW5kICEnKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuXG4gIC8vIGZlZWQgaW5jb21pbmcgZGF0YSB0byB0aGUgZnJvbnQgb2YgdGhlIHBhcnNpbmcgcGlwZWxpbmVcbiAgcHVzaChkYXRhLCBhdWRpb0NvZGVjLCB2aWRlb0NvZGVjLCB0aW1lT2Zmc2V0LCBjYywgbGV2ZWwsIHNuLCBkdXJhdGlvbixhY2N1cmF0ZVRpbWVPZmZzZXQpIHtcbiAgICB2YXIgdHJhY2ssXG4gICAgICAgIGlkMyA9IG5ldyBJRDMoZGF0YSksXG4gICAgICAgIHB0cyA9IDkwKmlkMy50aW1lU3RhbXAsXG4gICAgICAgIGNvbmZpZywgZnJhbWVMZW5ndGgsIGZyYW1lRHVyYXRpb24sIGZyYW1lSW5kZXgsIG9mZnNldCwgaGVhZGVyTGVuZ3RoLCBzdGFtcCwgbGVuLCBhYWNTYW1wbGU7XG5cbiAgICBsZXQgY29udGlndW91cyA9IGZhbHNlO1xuICAgIGlmIChjYyAhPT0gdGhpcy5sYXN0Q0MpIHtcbiAgICAgIGxvZ2dlci5sb2coYCR7dGhpcy5pZH0gZGlzY29udGludWl0eSBkZXRlY3RlZGApO1xuICAgICAgdGhpcy5sYXN0Q0MgPSBjYztcbiAgICAgIHRoaXMuaW5zZXJ0RGlzY29udGludWl0eSgpO1xuICAgICAgdGhpcy5yZW11eGVyLnN3aXRjaExldmVsKCk7XG4gICAgICB0aGlzLnJlbXV4ZXIuaW5zZXJ0RGlzY29udGludWl0eSgpO1xuICAgIH0gZWxzZSBpZiAobGV2ZWwgIT09IHRoaXMubGFzdExldmVsKSB7XG4gICAgICBsb2dnZXIubG9nKCdhdWRpbyB0cmFjayBzd2l0Y2ggZGV0ZWN0ZWQnKTtcbiAgICAgIHRoaXMubGFzdExldmVsID0gbGV2ZWw7XG4gICAgICB0aGlzLnJlbXV4ZXIuc3dpdGNoTGV2ZWwoKTtcbiAgICAgIHRoaXMuaW5zZXJ0RGlzY29udGludWl0eSgpO1xuICAgIH0gZWxzZSBpZiAoc24gPT09ICh0aGlzLmxhc3RTTisxKSkge1xuICAgICAgY29udGlndW91cyA9IHRydWU7XG4gICAgfVxuICAgIHRyYWNrID0gdGhpcy5fYWFjVHJhY2s7XG4gICAgdGhpcy5sYXN0U04gPSBzbjtcbiAgICB0aGlzLmxhc3RMZXZlbCA9IGxldmVsO1xuXG4gICAgLy8gbG9vayBmb3IgQURUUyBoZWFkZXIgKDB4RkZGeClcbiAgICBmb3IgKG9mZnNldCA9IGlkMy5sZW5ndGgsIGxlbiA9IGRhdGEubGVuZ3RoOyBvZmZzZXQgPCBsZW4gLSAxOyBvZmZzZXQrKykge1xuICAgICAgaWYgKChkYXRhW29mZnNldF0gPT09IDB4ZmYpICYmIChkYXRhW29mZnNldCsxXSAmIDB4ZjApID09PSAweGYwKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghdHJhY2suYXVkaW9zYW1wbGVyYXRlKSB7XG4gICAgICBjb25maWcgPSBBRFRTLmdldEF1ZGlvQ29uZmlnKHRoaXMub2JzZXJ2ZXIsZGF0YSwgb2Zmc2V0LCBhdWRpb0NvZGVjKTtcbiAgICAgIHRyYWNrLmNvbmZpZyA9IGNvbmZpZy5jb25maWc7XG4gICAgICB0cmFjay5hdWRpb3NhbXBsZXJhdGUgPSBjb25maWcuc2FtcGxlcmF0ZTtcbiAgICAgIHRyYWNrLmNoYW5uZWxDb3VudCA9IGNvbmZpZy5jaGFubmVsQ291bnQ7XG4gICAgICB0cmFjay5jb2RlYyA9IGNvbmZpZy5jb2RlYztcbiAgICAgIHRyYWNrLmR1cmF0aW9uID0gZHVyYXRpb247XG4gICAgICBsb2dnZXIubG9nKGBwYXJzZWQgY29kZWM6JHt0cmFjay5jb2RlY30scmF0ZToke2NvbmZpZy5zYW1wbGVyYXRlfSxuYiBjaGFubmVsOiR7Y29uZmlnLmNoYW5uZWxDb3VudH1gKTtcbiAgICB9XG4gICAgZnJhbWVJbmRleCA9IDA7XG4gICAgZnJhbWVEdXJhdGlvbiA9IDEwMjQgKiA5MDAwMCAvIHRyYWNrLmF1ZGlvc2FtcGxlcmF0ZTtcbiAgICB3aGlsZSAoKG9mZnNldCArIDUpIDwgbGVuKSB7XG4gICAgICAvLyBUaGUgcHJvdGVjdGlvbiBza2lwIGJpdCB0ZWxscyB1cyBpZiB3ZSBoYXZlIDIgYnl0ZXMgb2YgQ1JDIGRhdGEgYXQgdGhlIGVuZCBvZiB0aGUgQURUUyBoZWFkZXJcbiAgICAgIGhlYWRlckxlbmd0aCA9ICghIShkYXRhW29mZnNldCArIDFdICYgMHgwMSkgPyA3IDogOSk7XG4gICAgICAvLyByZXRyaWV2ZSBmcmFtZSBzaXplXG4gICAgICBmcmFtZUxlbmd0aCA9ICgoZGF0YVtvZmZzZXQgKyAzXSAmIDB4MDMpIDw8IDExKSB8XG4gICAgICAgICAgICAgICAgICAgICAoZGF0YVtvZmZzZXQgKyA0XSA8PCAzKSB8XG4gICAgICAgICAgICAgICAgICAgICgoZGF0YVtvZmZzZXQgKyA1XSAmIDB4RTApID4+PiA1KTtcbiAgICAgIGZyYW1lTGVuZ3RoICAtPSBoZWFkZXJMZW5ndGg7XG4gICAgICAvL3N0YW1wID0gcGVzLnB0cztcblxuICAgICAgaWYgKChmcmFtZUxlbmd0aCA+IDApICYmICgob2Zmc2V0ICsgaGVhZGVyTGVuZ3RoICsgZnJhbWVMZW5ndGgpIDw9IGxlbikpIHtcbiAgICAgICAgc3RhbXAgPSBwdHMgKyBmcmFtZUluZGV4ICogZnJhbWVEdXJhdGlvbjtcbiAgICAgICAgLy9sb2dnZXIubG9nKGBBQUMgZnJhbWUsIG9mZnNldC9sZW5ndGgvdG90YWwvcHRzOiR7b2Zmc2V0K2hlYWRlckxlbmd0aH0vJHtmcmFtZUxlbmd0aH0vJHtkYXRhLmJ5dGVMZW5ndGh9LyR7KHN0YW1wLzkwKS50b0ZpeGVkKDApfWApO1xuICAgICAgICBhYWNTYW1wbGUgPSB7dW5pdDogZGF0YS5zdWJhcnJheShvZmZzZXQgKyBoZWFkZXJMZW5ndGgsIG9mZnNldCArIGhlYWRlckxlbmd0aCArIGZyYW1lTGVuZ3RoKSwgcHRzOiBzdGFtcCwgZHRzOiBzdGFtcH07XG4gICAgICAgIHRyYWNrLnNhbXBsZXMucHVzaChhYWNTYW1wbGUpO1xuICAgICAgICB0cmFjay5sZW4gKz0gZnJhbWVMZW5ndGg7XG4gICAgICAgIG9mZnNldCArPSBmcmFtZUxlbmd0aCArIGhlYWRlckxlbmd0aDtcbiAgICAgICAgZnJhbWVJbmRleCsrO1xuICAgICAgICAvLyBsb29rIGZvciBBRFRTIGhlYWRlciAoMHhGRkZ4KVxuICAgICAgICBmb3IgKCA7IG9mZnNldCA8IChsZW4gLSAxKTsgb2Zmc2V0KyspIHtcbiAgICAgICAgICBpZiAoKGRhdGFbb2Zmc2V0XSA9PT0gMHhmZikgJiYgKChkYXRhW29mZnNldCArIDFdICYgMHhmMCkgPT09IDB4ZjApKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnJlbXV4ZXIucmVtdXgobGV2ZWwsIHNuICwgdGhpcy5fYWFjVHJhY2sse3NhbXBsZXMgOiBbXX0sIHtzYW1wbGVzIDogWyB7IHB0czogcHRzLCBkdHMgOiBwdHMsIHVuaXQgOiBpZDMucGF5bG9hZH0gXX0sIHsgc2FtcGxlczogW10gfSwgdGltZU9mZnNldCwgY29udGlndW91cyxhY2N1cmF0ZVRpbWVPZmZzZXQpO1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgfVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IEFBQ0RlbXV4ZXI7XG4iLCIvKipcbiAqICBBRFRTIHBhcnNlciBoZWxwZXJcbiAqL1xuaW1wb3J0IHtsb2dnZXJ9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XG5pbXBvcnQge0Vycm9yVHlwZXMsIEVycm9yRGV0YWlsc30gZnJvbSAnLi4vZXJyb3JzJztcblxuIGNsYXNzIEFEVFMge1xuXG4gIHN0YXRpYyBnZXRBdWRpb0NvbmZpZyhvYnNlcnZlciwgZGF0YSwgb2Zmc2V0LCBhdWRpb0NvZGVjKSB7XG4gICAgdmFyIGFkdHNPYmplY3RUeXBlLCAvLyA6aW50XG4gICAgICAgIGFkdHNTYW1wbGVpbmdJbmRleCwgLy8gOmludFxuICAgICAgICBhZHRzRXh0ZW5zaW9uU2FtcGxlaW5nSW5kZXgsIC8vIDppbnRcbiAgICAgICAgYWR0c0NoYW5lbENvbmZpZywgLy8gOmludFxuICAgICAgICBjb25maWcsXG4gICAgICAgIHVzZXJBZ2VudCA9IG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgYWR0c1NhbXBsZWluZ1JhdGVzID0gW1xuICAgICAgICAgICAgOTYwMDAsIDg4MjAwLFxuICAgICAgICAgICAgNjQwMDAsIDQ4MDAwLFxuICAgICAgICAgICAgNDQxMDAsIDMyMDAwLFxuICAgICAgICAgICAgMjQwMDAsIDIyMDUwLFxuICAgICAgICAgICAgMTYwMDAsIDEyMDAwLFxuICAgICAgICAgICAgMTEwMjUsIDgwMDAsXG4gICAgICAgICAgICA3MzUwXTtcbiAgICAvLyBieXRlIDJcbiAgICBhZHRzT2JqZWN0VHlwZSA9ICgoZGF0YVtvZmZzZXQgKyAyXSAmIDB4QzApID4+PiA2KSArIDE7XG4gICAgYWR0c1NhbXBsZWluZ0luZGV4ID0gKChkYXRhW29mZnNldCArIDJdICYgMHgzQykgPj4+IDIpO1xuICAgIGlmKGFkdHNTYW1wbGVpbmdJbmRleCA+IGFkdHNTYW1wbGVpbmdSYXRlcy5sZW5ndGgtMSkge1xuICAgICAgb2JzZXJ2ZXIudHJpZ2dlcihFdmVudC5FUlJPUiwge3R5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsIGRldGFpbHM6IEVycm9yRGV0YWlscy5GUkFHX1BBUlNJTkdfRVJST1IsIGZhdGFsOiB0cnVlLCByZWFzb246IGBpbnZhbGlkIEFEVFMgc2FtcGxpbmcgaW5kZXg6JHthZHRzU2FtcGxlaW5nSW5kZXh9YH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBhZHRzQ2hhbmVsQ29uZmlnID0gKChkYXRhW29mZnNldCArIDJdICYgMHgwMSkgPDwgMik7XG4gICAgLy8gYnl0ZSAzXG4gICAgYWR0c0NoYW5lbENvbmZpZyB8PSAoKGRhdGFbb2Zmc2V0ICsgM10gJiAweEMwKSA+Pj4gNik7XG4gICAgbG9nZ2VyLmxvZyhgbWFuaWZlc3QgY29kZWM6JHthdWRpb0NvZGVjfSxBRFRTIGRhdGE6dHlwZToke2FkdHNPYmplY3RUeXBlfSxzYW1wbGVpbmdJbmRleDoke2FkdHNTYW1wbGVpbmdJbmRleH1bJHthZHRzU2FtcGxlaW5nUmF0ZXNbYWR0c1NhbXBsZWluZ0luZGV4XX1Iel0sY2hhbm5lbENvbmZpZzoke2FkdHNDaGFuZWxDb25maWd9YCk7XG4gICAgLy8gZmlyZWZveC9PcGVyYTogZnJlcSBsZXNzIHRoYW4gMjRrSHogPSBBQUMgU0JSIChIRS1BQUMpXG4gICAgaWYgKC9maXJlZm94fE9QUi9pLnRlc3QodXNlckFnZW50KSkge1xuICAgICAgaWYgKGFkdHNTYW1wbGVpbmdJbmRleCA+PSA2KSB7XG4gICAgICAgIGFkdHNPYmplY3RUeXBlID0gNTtcbiAgICAgICAgY29uZmlnID0gbmV3IEFycmF5KDQpO1xuICAgICAgICAvLyBIRS1BQUMgdXNlcyBTQlIgKFNwZWN0cmFsIEJhbmQgUmVwbGljYXRpb24pICwgaGlnaCBmcmVxdWVuY2llcyBhcmUgY29uc3RydWN0ZWQgZnJvbSBsb3cgZnJlcXVlbmNpZXNcbiAgICAgICAgLy8gdGhlcmUgaXMgYSBmYWN0b3IgMiBiZXR3ZWVuIGZyYW1lIHNhbXBsZSByYXRlIGFuZCBvdXRwdXQgc2FtcGxlIHJhdGVcbiAgICAgICAgLy8gbXVsdGlwbHkgZnJlcXVlbmN5IGJ5IDIgKHNlZSB0YWJsZSBiZWxvdywgZXF1aXZhbGVudCB0byBzdWJzdHJhY3QgMylcbiAgICAgICAgYWR0c0V4dGVuc2lvblNhbXBsZWluZ0luZGV4ID0gYWR0c1NhbXBsZWluZ0luZGV4IC0gMztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFkdHNPYmplY3RUeXBlID0gMjtcbiAgICAgICAgY29uZmlnID0gbmV3IEFycmF5KDIpO1xuICAgICAgICBhZHRzRXh0ZW5zaW9uU2FtcGxlaW5nSW5kZXggPSBhZHRzU2FtcGxlaW5nSW5kZXg7XG4gICAgICB9XG4gICAgICAvLyBBbmRyb2lkIDogYWx3YXlzIHVzZSBBQUNcbiAgICB9IGVsc2UgaWYgKHVzZXJBZ2VudC5pbmRleE9mKCdhbmRyb2lkJykgIT09IC0xKSB7XG4gICAgICBhZHRzT2JqZWN0VHlwZSA9IDI7XG4gICAgICBjb25maWcgPSBuZXcgQXJyYXkoMik7XG4gICAgICBhZHRzRXh0ZW5zaW9uU2FtcGxlaW5nSW5kZXggPSBhZHRzU2FtcGxlaW5nSW5kZXg7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qICBmb3Igb3RoZXIgYnJvd3NlcnMgKENocm9tZS9WaXZhbGRpIC4uLilcbiAgICAgICAgICBhbHdheXMgZm9yY2UgYXVkaW8gdHlwZSB0byBiZSBIRS1BQUMgU0JSLCBhcyBzb21lIGJyb3dzZXJzIGRvIG5vdCBzdXBwb3J0IGF1ZGlvIGNvZGVjIHN3aXRjaCBwcm9wZXJseSAobGlrZSBDaHJvbWUgLi4uKVxuICAgICAgKi9cbiAgICAgIGFkdHNPYmplY3RUeXBlID0gNTtcbiAgICAgIGNvbmZpZyA9IG5ldyBBcnJheSg0KTtcbiAgICAgIC8vIGlmIChtYW5pZmVzdCBjb2RlYyBpcyBIRS1BQUMgb3IgSEUtQUFDdjIpIE9SIChtYW5pZmVzdCBjb2RlYyBub3Qgc3BlY2lmaWVkIEFORCBmcmVxdWVuY3kgbGVzcyB0aGFuIDI0a0h6KVxuICAgICAgaWYgKChhdWRpb0NvZGVjICYmICgoYXVkaW9Db2RlYy5pbmRleE9mKCdtcDRhLjQwLjI5JykgIT09IC0xKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAoYXVkaW9Db2RlYy5pbmRleE9mKCdtcDRhLjQwLjUnKSAhPT0gLTEpKSkgfHxcbiAgICAgICAgICAoIWF1ZGlvQ29kZWMgJiYgYWR0c1NhbXBsZWluZ0luZGV4ID49IDYpKSB7XG4gICAgICAgIC8vIEhFLUFBQyB1c2VzIFNCUiAoU3BlY3RyYWwgQmFuZCBSZXBsaWNhdGlvbikgLCBoaWdoIGZyZXF1ZW5jaWVzIGFyZSBjb25zdHJ1Y3RlZCBmcm9tIGxvdyBmcmVxdWVuY2llc1xuICAgICAgICAvLyB0aGVyZSBpcyBhIGZhY3RvciAyIGJldHdlZW4gZnJhbWUgc2FtcGxlIHJhdGUgYW5kIG91dHB1dCBzYW1wbGUgcmF0ZVxuICAgICAgICAvLyBtdWx0aXBseSBmcmVxdWVuY3kgYnkgMiAoc2VlIHRhYmxlIGJlbG93LCBlcXVpdmFsZW50IHRvIHN1YnN0cmFjdCAzKVxuICAgICAgICBhZHRzRXh0ZW5zaW9uU2FtcGxlaW5nSW5kZXggPSBhZHRzU2FtcGxlaW5nSW5kZXggLSAzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gaWYgKG1hbmlmZXN0IGNvZGVjIGlzIEFBQykgQU5EIChmcmVxdWVuY3kgbGVzcyB0aGFuIDI0a0h6IEFORCBuYiBjaGFubmVsIGlzIDEpIE9SIChtYW5pZmVzdCBjb2RlYyBub3Qgc3BlY2lmaWVkIGFuZCBtb25vIGF1ZGlvKVxuICAgICAgICAvLyBDaHJvbWUgZmFpbHMgdG8gcGxheSBiYWNrIHdpdGggbG93IGZyZXF1ZW5jeSBBQUMgTEMgbW9ubyB3aGVuIGluaXRpYWxpemVkIHdpdGggSEUtQUFDLiAgVGhpcyBpcyBub3QgYSBwcm9ibGVtIHdpdGggc3RlcmVvLlxuICAgICAgICBpZiAoYXVkaW9Db2RlYyAmJiBhdWRpb0NvZGVjLmluZGV4T2YoJ21wNGEuNDAuMicpICE9PSAtMSAmJiAoYWR0c1NhbXBsZWluZ0luZGV4ID49IDYgJiYgYWR0c0NoYW5lbENvbmZpZyA9PT0gMSkgfHxcbiAgICAgICAgICAgICghYXVkaW9Db2RlYyAmJiBhZHRzQ2hhbmVsQ29uZmlnID09PSAxKSkge1xuICAgICAgICAgIGFkdHNPYmplY3RUeXBlID0gMjtcbiAgICAgICAgICBjb25maWcgPSBuZXcgQXJyYXkoMik7XG4gICAgICAgIH1cbiAgICAgICAgYWR0c0V4dGVuc2lvblNhbXBsZWluZ0luZGV4ID0gYWR0c1NhbXBsZWluZ0luZGV4O1xuICAgICAgfVxuICAgIH1cbiAgICAvKiByZWZlciB0byBodHRwOi8vd2lraS5tdWx0aW1lZGlhLmN4L2luZGV4LnBocD90aXRsZT1NUEVHLTRfQXVkaW8jQXVkaW9fU3BlY2lmaWNfQ29uZmlnXG4gICAgICAgIElTTyAxNDQ5Ni0zIChBQUMpLnBkZiAtIFRhYmxlIDEuMTMg4oCUIFN5bnRheCBvZiBBdWRpb1NwZWNpZmljQ29uZmlnKClcbiAgICAgIEF1ZGlvIFByb2ZpbGUgLyBBdWRpbyBPYmplY3QgVHlwZVxuICAgICAgMDogTnVsbFxuICAgICAgMTogQUFDIE1haW5cbiAgICAgIDI6IEFBQyBMQyAoTG93IENvbXBsZXhpdHkpXG4gICAgICAzOiBBQUMgU1NSIChTY2FsYWJsZSBTYW1wbGUgUmF0ZSlcbiAgICAgIDQ6IEFBQyBMVFAgKExvbmcgVGVybSBQcmVkaWN0aW9uKVxuICAgICAgNTogU0JSIChTcGVjdHJhbCBCYW5kIFJlcGxpY2F0aW9uKVxuICAgICAgNjogQUFDIFNjYWxhYmxlXG4gICAgIHNhbXBsaW5nIGZyZXFcbiAgICAgIDA6IDk2MDAwIEh6XG4gICAgICAxOiA4ODIwMCBIelxuICAgICAgMjogNjQwMDAgSHpcbiAgICAgIDM6IDQ4MDAwIEh6XG4gICAgICA0OiA0NDEwMCBIelxuICAgICAgNTogMzIwMDAgSHpcbiAgICAgIDY6IDI0MDAwIEh6XG4gICAgICA3OiAyMjA1MCBIelxuICAgICAgODogMTYwMDAgSHpcbiAgICAgIDk6IDEyMDAwIEh6XG4gICAgICAxMDogMTEwMjUgSHpcbiAgICAgIDExOiA4MDAwIEh6XG4gICAgICAxMjogNzM1MCBIelxuICAgICAgMTM6IFJlc2VydmVkXG4gICAgICAxNDogUmVzZXJ2ZWRcbiAgICAgIDE1OiBmcmVxdWVuY3kgaXMgd3JpdHRlbiBleHBsaWN0bHlcbiAgICAgIENoYW5uZWwgQ29uZmlndXJhdGlvbnNcbiAgICAgIFRoZXNlIGFyZSB0aGUgY2hhbm5lbCBjb25maWd1cmF0aW9uczpcbiAgICAgIDA6IERlZmluZWQgaW4gQU9UIFNwZWNpZmMgQ29uZmlnXG4gICAgICAxOiAxIGNoYW5uZWw6IGZyb250LWNlbnRlclxuICAgICAgMjogMiBjaGFubmVsczogZnJvbnQtbGVmdCwgZnJvbnQtcmlnaHRcbiAgICAqL1xuICAgIC8vIGF1ZGlvT2JqZWN0VHlwZSA9IHByb2ZpbGUgPT4gcHJvZmlsZSwgdGhlIE1QRUctNCBBdWRpbyBPYmplY3QgVHlwZSBtaW51cyAxXG4gICAgY29uZmlnWzBdID0gYWR0c09iamVjdFR5cGUgPDwgMztcbiAgICAvLyBzYW1wbGluZ0ZyZXF1ZW5jeUluZGV4XG4gICAgY29uZmlnWzBdIHw9IChhZHRzU2FtcGxlaW5nSW5kZXggJiAweDBFKSA+PiAxO1xuICAgIGNvbmZpZ1sxXSB8PSAoYWR0c1NhbXBsZWluZ0luZGV4ICYgMHgwMSkgPDwgNztcbiAgICAvLyBjaGFubmVsQ29uZmlndXJhdGlvblxuICAgIGNvbmZpZ1sxXSB8PSBhZHRzQ2hhbmVsQ29uZmlnIDw8IDM7XG4gICAgaWYgKGFkdHNPYmplY3RUeXBlID09PSA1KSB7XG4gICAgICAvLyBhZHRzRXh0ZW5zaW9uU2FtcGxlaW5nSW5kZXhcbiAgICAgIGNvbmZpZ1sxXSB8PSAoYWR0c0V4dGVuc2lvblNhbXBsZWluZ0luZGV4ICYgMHgwRSkgPj4gMTtcbiAgICAgIGNvbmZpZ1syXSA9IChhZHRzRXh0ZW5zaW9uU2FtcGxlaW5nSW5kZXggJiAweDAxKSA8PCA3O1xuICAgICAgLy8gYWR0c09iamVjdFR5cGUgKGZvcmNlIHRvIDIsIGNocm9tZSBpcyBjaGVja2luZyB0aGF0IG9iamVjdCB0eXBlIGlzIGxlc3MgdGhhbiA1ID8/P1xuICAgICAgLy8gICAgaHR0cHM6Ly9jaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYy5naXQvKy9tYXN0ZXIvbWVkaWEvZm9ybWF0cy9tcDQvYWFjLmNjXG4gICAgICBjb25maWdbMl0gfD0gMiA8PCAyO1xuICAgICAgY29uZmlnWzNdID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIHtjb25maWc6IGNvbmZpZywgc2FtcGxlcmF0ZTogYWR0c1NhbXBsZWluZ1JhdGVzW2FkdHNTYW1wbGVpbmdJbmRleF0sIGNoYW5uZWxDb3VudDogYWR0c0NoYW5lbENvbmZpZywgY29kZWM6ICgnbXA0YS40MC4nICsgYWR0c09iamVjdFR5cGUpfTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBBRFRTO1xuIiwiLyogIGlubGluZSBkZW11eGVyLlxuICogICBwcm9iZSBmcmFnbWVudHMgYW5kIGluc3RhbnRpYXRlIGFwcHJvcHJpYXRlIGRlbXV4ZXIgZGVwZW5kaW5nIG9uIGNvbnRlbnQgdHlwZSAoVFNEZW11eGVyLCBBQUNEZW11eGVyLCAuLi4pXG4gKi9cblxuaW1wb3J0IEV2ZW50IGZyb20gJy4uL2V2ZW50cyc7XG5pbXBvcnQge0Vycm9yVHlwZXMsIEVycm9yRGV0YWlsc30gZnJvbSAnLi4vZXJyb3JzJztcbmltcG9ydCBBQUNEZW11eGVyIGZyb20gJy4uL2RlbXV4L2FhY2RlbXV4ZXInO1xuaW1wb3J0IFRTRGVtdXhlciBmcm9tICcuLi9kZW11eC90c2RlbXV4ZXInO1xuaW1wb3J0IE1QNFJlbXV4ZXIgZnJvbSAnLi4vcmVtdXgvbXA0LXJlbXV4ZXInO1xuaW1wb3J0IFBhc3NUaHJvdWdoUmVtdXhlciBmcm9tICcuLi9yZW11eC9wYXNzdGhyb3VnaC1yZW11eGVyJztcblxuY2xhc3MgRGVtdXhlcklubGluZSB7XG5cbiAgY29uc3RydWN0b3IoaGxzLGlkLCB0eXBlU3VwcG9ydGVkLCBjb25maWc9bnVsbCkge1xuICAgIHRoaXMuaGxzID0gaGxzO1xuICAgIHRoaXMuaWQgPSBpZDtcbiAgICB0aGlzLmNvbmZpZyA9IHRoaXMuaGxzLmNvbmZpZyB8fCBjb25maWc7XG4gICAgdGhpcy50eXBlU3VwcG9ydGVkID0gdHlwZVN1cHBvcnRlZDtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgdmFyIGRlbXV4ZXIgPSB0aGlzLmRlbXV4ZXI7XG4gICAgaWYgKGRlbXV4ZXIpIHtcbiAgICAgIGRlbXV4ZXIuZGVzdHJveSgpO1xuICAgIH1cbiAgfVxuXG4gIHB1c2goZGF0YSwgYXVkaW9Db2RlYywgdmlkZW9Db2RlYywgdGltZU9mZnNldCwgY2MsIGxldmVsLCBzbiwgZHVyYXRpb24sYWNjdXJhdGVUaW1lT2Zmc2V0KSB7XG4gICAgdmFyIGRlbXV4ZXIgPSB0aGlzLmRlbXV4ZXI7XG4gICAgaWYgKCFkZW11eGVyKSB7XG4gICAgICBsZXQgaGxzID0gdGhpcy5obHMsXG4gICAgICAgICAgaWQgPSB0aGlzLmlkO1xuICAgICAgLy8gcHJvYmUgZm9yIGNvbnRlbnQgdHlwZVxuICAgICAgaWYgKFRTRGVtdXhlci5wcm9iZShkYXRhKSkge1xuICAgICAgICBpZiAodGhpcy50eXBlU3VwcG9ydGVkLm1wMnQgPT09IHRydWUpIHtcbiAgICAgICAgICBkZW11eGVyID0gbmV3IFRTRGVtdXhlcihobHMsIGlkLCBQYXNzVGhyb3VnaFJlbXV4ZXIsIHRoaXMuY29uZmlnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZW11eGVyID0gbmV3IFRTRGVtdXhlcihobHMsIGlkLCBNUDRSZW11eGVyLCB0aGlzLmNvbmZpZyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZihBQUNEZW11eGVyLnByb2JlKGRhdGEpKSB7XG4gICAgICAgIGRlbXV4ZXIgPSBuZXcgQUFDRGVtdXhlcihobHMsIGlkLCBNUDRSZW11eGVyLCB0aGlzLmNvbmZpZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBobHMudHJpZ2dlcihFdmVudC5FUlJPUiwge3R5cGUgOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLCBpZCA6IGlkLCBkZXRhaWxzOiBFcnJvckRldGFpbHMuRlJBR19QQVJTSU5HX0VSUk9SLCBmYXRhbDogdHJ1ZSwgcmVhc29uOiAnbm8gZGVtdXggbWF0Y2hpbmcgd2l0aCBjb250ZW50IGZvdW5kJ30pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmRlbXV4ZXIgPSBkZW11eGVyO1xuICAgIH1cbiAgICBkZW11eGVyLnB1c2goZGF0YSxhdWRpb0NvZGVjLHZpZGVvQ29kZWMsdGltZU9mZnNldCxjYyxsZXZlbCxzbixkdXJhdGlvbixhY2N1cmF0ZVRpbWVPZmZzZXQpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IERlbXV4ZXJJbmxpbmU7XG4iLCIvKiBkZW11eGVyIHdlYiB3b3JrZXIuXG4gKiAgLSBsaXN0ZW4gdG8gd29ya2VyIG1lc3NhZ2UsIGFuZCB0cmlnZ2VyIERlbXV4ZXJJbmxpbmUgdXBvbiByZWNlcHRpb24gb2YgRnJhZ21lbnRzLlxuICogIC0gcHJvdmlkZXMgTVA0IEJveGVzIGJhY2sgdG8gbWFpbiB0aHJlYWQgdXNpbmcgW3RyYW5zZmVyYWJsZSBvYmplY3RzXShodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS93ZWIvdXBkYXRlcy8yMDExLzEyL1RyYW5zZmVyYWJsZS1PYmplY3RzLUxpZ2h0bmluZy1GYXN0KSBpbiBvcmRlciB0byBtaW5pbWl6ZSBtZXNzYWdlIHBhc3Npbmcgb3ZlcmhlYWQuXG4gKi9cblxuIGltcG9ydCBEZW11eGVySW5saW5lIGZyb20gJy4uL2RlbXV4L2RlbXV4ZXItaW5saW5lJztcbiBpbXBvcnQgRXZlbnQgZnJvbSAnLi4vZXZlbnRzJztcbiBpbXBvcnQge2VuYWJsZUxvZ3N9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XG4gaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tICdldmVudHMnO1xuXG52YXIgRGVtdXhlcldvcmtlciA9IGZ1bmN0aW9uIChzZWxmKSB7XG4gIC8vIG9ic2VydmVyIHNldHVwXG4gIHZhciBvYnNlcnZlciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgb2JzZXJ2ZXIudHJpZ2dlciA9IGZ1bmN0aW9uIHRyaWdnZXIgKGV2ZW50LCAuLi5kYXRhKSB7XG4gICAgb2JzZXJ2ZXIuZW1pdChldmVudCwgZXZlbnQsIC4uLmRhdGEpO1xuICB9O1xuXG4gIG9ic2VydmVyLm9mZiA9IGZ1bmN0aW9uIG9mZiAoZXZlbnQsIC4uLmRhdGEpIHtcbiAgICBvYnNlcnZlci5yZW1vdmVMaXN0ZW5lcihldmVudCwgLi4uZGF0YSk7XG4gIH07XG4gIHNlbGYuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGZ1bmN0aW9uIChldikge1xuICAgIHZhciBkYXRhID0gZXYuZGF0YTtcbiAgICAvL2NvbnNvbGUubG9nKCdkZW11eGVyIGNtZDonICsgZGF0YS5jbWQpO1xuICAgIHN3aXRjaCAoZGF0YS5jbWQpIHtcbiAgICAgIGNhc2UgJ2luaXQnOlxuICAgICAgICBsZXQgY29uZmlnID0gSlNPTi5wYXJzZShkYXRhLmNvbmZpZyk7XG4gICAgICAgIHNlbGYuZGVtdXhlciA9IG5ldyBEZW11eGVySW5saW5lKG9ic2VydmVyLCBkYXRhLmlkLCBkYXRhLnR5cGVTdXBwb3J0ZWQsIGNvbmZpZyk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZW5hYmxlTG9ncyhjb25maWcuZGVidWcpO1xuICAgICAgICB9IGNhdGNoKGVycikge1xuICAgICAgICAgIGNvbnNvbGUud2FybignZGVtdXhlcldvcmtlcjogdW5hYmxlIHRvIGVuYWJsZSBsb2dzJyk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdkZW11eCc6XG4gICAgICAgIHNlbGYuZGVtdXhlci5wdXNoKG5ldyBVaW50OEFycmF5KGRhdGEuZGF0YSksIGRhdGEuYXVkaW9Db2RlYywgZGF0YS52aWRlb0NvZGVjLCBkYXRhLnRpbWVPZmZzZXQsIGRhdGEuY2MsIGRhdGEubGV2ZWwsIGRhdGEuc24sIGRhdGEuZHVyYXRpb24sZGF0YS5hY2N1cmF0ZVRpbWVPZmZzZXQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfSk7XG5cbiAgdmFyIGZvcndhcmRNZXNzYWdlID0gZnVuY3Rpb24oZXYsZGF0YSkge1xuICAgIHNlbGYucG9zdE1lc3NhZ2Uoe2V2ZW50OiBldiwgZGF0YTpkYXRhIH0pO1xuICB9O1xuXG4gIC8vIGZvcndhcmQgZXZlbnRzIHRvIG1haW4gdGhyZWFkXG4gIG9ic2VydmVyLm9uKEV2ZW50LkZSQUdfUEFSU0lOR19JTklUX1NFR01FTlQsIGZvcndhcmRNZXNzYWdlKTtcbiAgb2JzZXJ2ZXIub24oRXZlbnQuRlJBR19QQVJTRUQsIGZvcndhcmRNZXNzYWdlKTtcbiAgb2JzZXJ2ZXIub24oRXZlbnQuRVJST1IsIGZvcndhcmRNZXNzYWdlKTtcbiAgb2JzZXJ2ZXIub24oRXZlbnQuRlJBR19QQVJTSU5HX01FVEFEQVRBLCBmb3J3YXJkTWVzc2FnZSk7XG4gIG9ic2VydmVyLm9uKEV2ZW50LkZSQUdfUEFSU0lOR19VU0VSREFUQSwgZm9yd2FyZE1lc3NhZ2UpO1xuXG4gIC8vIHNwZWNpYWwgY2FzZSBmb3IgRlJBR19QQVJTSU5HX0RBVEE6IHBhc3MgZGF0YTEvZGF0YTIgYXMgdHJhbnNmZXJhYmxlIG9iamVjdCAobm8gY29weSlcbiAgb2JzZXJ2ZXIub24oRXZlbnQuRlJBR19QQVJTSU5HX0RBVEEsIGZ1bmN0aW9uKGV2LCBkYXRhKSB7XG4gICAgbGV0IGRhdGExID0gZGF0YS5kYXRhMS5idWZmZXIsIGRhdGEyID0gZGF0YS5kYXRhMi5idWZmZXI7XG4gICAgLy8gcmVtb3ZlIGRhdGExIGFuZCBkYXRhMiByZWZlcmVuY2UgZnJvbSBkYXRhIHRvIGF2b2lkIGNvcHlpbmcgdGhlbSAuLi5cbiAgICBkZWxldGUgZGF0YS5kYXRhMTtcbiAgICBkZWxldGUgZGF0YS5kYXRhMjtcbiAgICBzZWxmLnBvc3RNZXNzYWdlKHtldmVudDogZXYsIGRhdGE6ZGF0YSAsIGRhdGExIDogZGF0YTEsIGRhdGEyIDogZGF0YTJ9LFtkYXRhMSwgZGF0YTJdKTtcbiAgfSk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBEZW11eGVyV29ya2VyO1xuXG4iLCJpbXBvcnQgRXZlbnQgZnJvbSAnLi4vZXZlbnRzJztcbmltcG9ydCBEZW11eGVySW5saW5lIGZyb20gJy4uL2RlbXV4L2RlbXV4ZXItaW5saW5lJztcbmltcG9ydCBEZW11eGVyV29ya2VyIGZyb20gJy4uL2RlbXV4L2RlbXV4ZXItd29ya2VyJztcbmltcG9ydCB7bG9nZ2VyfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xuaW1wb3J0IERlY3J5cHRlciBmcm9tICcuLi9jcnlwdC9kZWNyeXB0ZXInO1xuaW1wb3J0IHtFcnJvclR5cGVzLCBFcnJvckRldGFpbHN9IGZyb20gJy4uL2Vycm9ycyc7XG5cbmNsYXNzIERlbXV4ZXIge1xuXG4gIGNvbnN0cnVjdG9yKGhscywgaWQpIHtcbiAgICB0aGlzLmhscyA9IGhscztcbiAgICB0aGlzLmlkID0gaWQ7XG4gICAgdmFyIHR5cGVTdXBwb3J0ZWQgPSB7XG4gICAgICBtcDQgOiBNZWRpYVNvdXJjZS5pc1R5cGVTdXBwb3J0ZWQoJ3ZpZGVvL21wNCcpLFxuICAgICAgbXAydCA6IGhscy5jb25maWcuZW5hYmxlTVAyVFBhc3NUaHJvdWdoICYmIE1lZGlhU291cmNlLmlzVHlwZVN1cHBvcnRlZCgndmlkZW8vbXAydCcpXG4gICAgfTtcbiAgICBpZiAoaGxzLmNvbmZpZy5lbmFibGVXb3JrZXIgJiYgKHR5cGVvZihXb3JrZXIpICE9PSAndW5kZWZpbmVkJykpIHtcbiAgICAgICAgbG9nZ2VyLmxvZygnZGVtdXhpbmcgaW4gd2Vid29ya2VyJyk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgbGV0IHdvcmsgPSByZXF1aXJlKCd3ZWJ3b3JraWZ5Jyk7XG4gICAgICAgICAgbGV0IHcgPSB0aGlzLncgPSB3b3JrKERlbXV4ZXJXb3JrZXIpO1xuICAgICAgICAgIHRoaXMub253bXNnID0gdGhpcy5vbldvcmtlck1lc3NhZ2UuYmluZCh0aGlzKTtcbiAgICAgICAgICB3LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCB0aGlzLm9ud21zZyk7XG4gICAgICAgICAgdy5vbmVycm9yID0gZnVuY3Rpb24oZXZlbnQpIHsgaGxzLnRyaWdnZXIoRXZlbnQuRVJST1IsIHt0eXBlOiBFcnJvclR5cGVzLk9USEVSX0VSUk9SLCBkZXRhaWxzOiBFcnJvckRldGFpbHMuSU5URVJOQUxfRVhDRVBUSU9OLCBmYXRhbDogdHJ1ZSwgZXZlbnQgOiAnZGVtdXhlcldvcmtlcicsIGVyciA6IHsgbWVzc2FnZSA6IGV2ZW50Lm1lc3NhZ2UgKyAnICgnICsgZXZlbnQuZmlsZW5hbWUgKyAnOicgKyBldmVudC5saW5lbm8gKyAnKScgfX0pO307XG4gICAgICAgICAgdy5wb3N0TWVzc2FnZSh7Y21kOiAnaW5pdCcsIHR5cGVTdXBwb3J0ZWQgOiB0eXBlU3VwcG9ydGVkLCBpZCA6IGlkLCBjb25maWc6IEpTT04uc3RyaW5naWZ5KGhscy5jb25maWcpfSk7XG4gICAgICAgIH0gY2F0Y2goZXJyKSB7XG4gICAgICAgICAgbG9nZ2VyLmVycm9yKCdlcnJvciB3aGlsZSBpbml0aWFsaXppbmcgRGVtdXhlcldvcmtlciwgZmFsbGJhY2sgb24gRGVtdXhlcklubGluZScpO1xuICAgICAgICAgIHRoaXMuZGVtdXhlciA9IG5ldyBEZW11eGVySW5saW5lKGhscyxpZCx0eXBlU3VwcG9ydGVkKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5kZW11eGVyID0gbmV3IERlbXV4ZXJJbmxpbmUoaGxzLGlkLHR5cGVTdXBwb3J0ZWQpO1xuICAgICAgfVxuICAgICAgdGhpcy5kZW11eEluaXRpYWxpemVkID0gdHJ1ZTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgbGV0IHcgPSB0aGlzLnc7XG4gICAgaWYgKHcpIHtcbiAgICAgIHcucmVtb3ZlRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIHRoaXMub253bXNnKTtcbiAgICAgIHcudGVybWluYXRlKCk7XG4gICAgICB0aGlzLncgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgZGVtdXhlciA9IHRoaXMuZGVtdXhlcjtcbiAgICAgIGlmIChkZW11eGVyKSB7XG4gICAgICAgIGRlbXV4ZXIuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLmRlbXV4ZXIgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgZGVjcnlwdGVyID0gdGhpcy5kZWNyeXB0ZXI7XG4gICAgaWYgKGRlY3J5cHRlcikge1xuICAgICAgZGVjcnlwdGVyLmRlc3Ryb3koKTtcbiAgICAgIHRoaXMuZGVjcnlwdGVyID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICBwdXNoRGVjcnlwdGVkKGRhdGEsIGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWMsIHRpbWVPZmZzZXQsIGNjLCBsZXZlbCwgc24sIGR1cmF0aW9uLGFjY3VyYXRlVGltZU9mZnNldCkge1xuICAgIGxldCB3ID0gdGhpcy53O1xuICAgIGlmICh3KSB7XG4gICAgICAvLyBwb3N0IGZyYWdtZW50IHBheWxvYWQgYXMgdHJhbnNmZXJhYmxlIG9iamVjdHMgKG5vIGNvcHkpXG4gICAgICB3LnBvc3RNZXNzYWdlKHtjbWQ6ICdkZW11eCcsIGRhdGE6IGRhdGEsIGF1ZGlvQ29kZWM6IGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWM6IHZpZGVvQ29kZWMsIHRpbWVPZmZzZXQ6IHRpbWVPZmZzZXQsIGNjOiBjYywgbGV2ZWw6IGxldmVsLCBzbiA6IHNuLCBkdXJhdGlvbjogZHVyYXRpb24sIGFjY3VyYXRlVGltZU9mZnNldCA6IGFjY3VyYXRlVGltZU9mZnNldH0sIFtkYXRhXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBkZW11eGVyID0gdGhpcy5kZW11eGVyO1xuICAgICAgaWYgKGRlbXV4ZXIpIHtcbiAgICAgICAgZGVtdXhlci5wdXNoKG5ldyBVaW50OEFycmF5KGRhdGEpLCBhdWRpb0NvZGVjLCB2aWRlb0NvZGVjLCB0aW1lT2Zmc2V0LCBjYywgbGV2ZWwsIHNuLCBkdXJhdGlvbixhY2N1cmF0ZVRpbWVPZmZzZXQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHB1c2goZGF0YSwgYXVkaW9Db2RlYywgdmlkZW9Db2RlYywgdGltZU9mZnNldCwgY2MsIGxldmVsLCBzbiwgZHVyYXRpb24sIGRlY3J5cHRkYXRhLGFjY3VyYXRlVGltZU9mZnNldCkge1xuICAgIGlmICgoZGF0YS5ieXRlTGVuZ3RoID4gMCkgJiYgKGRlY3J5cHRkYXRhICE9IG51bGwpICYmIChkZWNyeXB0ZGF0YS5rZXkgIT0gbnVsbCkgJiYgKGRlY3J5cHRkYXRhLm1ldGhvZCA9PT0gJ0FFUy0xMjgnKSkge1xuICAgICAgaWYgKHRoaXMuZGVjcnlwdGVyID09IG51bGwpIHtcbiAgICAgICAgdGhpcy5kZWNyeXB0ZXIgPSBuZXcgRGVjcnlwdGVyKHRoaXMuaGxzKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGxvY2FsdGhpcyA9IHRoaXM7XG4gICAgICB0aGlzLmRlY3J5cHRlci5kZWNyeXB0KGRhdGEsIGRlY3J5cHRkYXRhLmtleS5idWZmZXIsIGRlY3J5cHRkYXRhLml2LmJ1ZmZlciwgZnVuY3Rpb24oZGVjcnlwdGVkRGF0YSl7XG4gICAgICAgIGxvY2FsdGhpcy5wdXNoRGVjcnlwdGVkKGRlY3J5cHRlZERhdGEsIGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWMsIHRpbWVPZmZzZXQsIGNjLCBsZXZlbCwgc24sIGR1cmF0aW9uLGFjY3VyYXRlVGltZU9mZnNldCk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wdXNoRGVjcnlwdGVkKGRhdGEsIGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWMsIHRpbWVPZmZzZXQsIGNjLCBsZXZlbCwgc24sIGR1cmF0aW9uLGFjY3VyYXRlVGltZU9mZnNldCk7XG4gICAgfVxuICB9XG5cbiAgb25Xb3JrZXJNZXNzYWdlKGV2KSB7XG4gICAgbGV0IGRhdGEgPSBldi5kYXRhLFxuICAgICAgICBobHMgPSB0aGlzLmhscztcbiAgICAvL2NvbnNvbGUubG9nKCdvbldvcmtlck1lc3NhZ2U6JyArIGRhdGEuZXZlbnQpO1xuICAgIHN3aXRjaChkYXRhLmV2ZW50KSB7XG4gICAgICAvLyBzcGVjaWFsIGNhc2UgZm9yIEZSQUdfUEFSU0lOR19EQVRBOiBkYXRhMSBhbmQgZGF0YTIgYXJlIHRyYW5zZmVyYWJsZSBvYmplY3RzXG4gICAgICBjYXNlIEV2ZW50LkZSQUdfUEFSU0lOR19EQVRBOlxuICAgICAgICBkYXRhLmRhdGEuZGF0YTEgPSBuZXcgVWludDhBcnJheShkYXRhLmRhdGExKTtcbiAgICAgICAgZGF0YS5kYXRhLmRhdGEyID0gbmV3IFVpbnQ4QXJyYXkoZGF0YS5kYXRhMik7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGhscy50cmlnZ2VyKGRhdGEuZXZlbnQsIGRhdGEuZGF0YSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBEZW11eGVyO1xuXG4iLCIvKipcbiAqIFBhcnNlciBmb3IgZXhwb25lbnRpYWwgR29sb21iIGNvZGVzLCBhIHZhcmlhYmxlLWJpdHdpZHRoIG51bWJlciBlbmNvZGluZyBzY2hlbWUgdXNlZCBieSBoMjY0LlxuKi9cblxuaW1wb3J0IHtsb2dnZXJ9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XG5cbmNsYXNzIEV4cEdvbG9tYiB7XG5cbiAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgLy8gdGhlIG51bWJlciBvZiBieXRlcyBsZWZ0IHRvIGV4YW1pbmUgaW4gdGhpcy5kYXRhXG4gICAgdGhpcy5ieXRlc0F2YWlsYWJsZSA9IHRoaXMuZGF0YS5ieXRlTGVuZ3RoO1xuICAgIC8vIHRoZSBjdXJyZW50IHdvcmQgYmVpbmcgZXhhbWluZWRcbiAgICB0aGlzLndvcmQgPSAwOyAvLyA6dWludFxuICAgIC8vIHRoZSBudW1iZXIgb2YgYml0cyBsZWZ0IHRvIGV4YW1pbmUgaW4gdGhlIGN1cnJlbnQgd29yZFxuICAgIHRoaXMuYml0c0F2YWlsYWJsZSA9IDA7IC8vIDp1aW50XG4gIH1cblxuICAvLyAoKTp2b2lkXG4gIGxvYWRXb3JkKCkge1xuICAgIHZhclxuICAgICAgcG9zaXRpb24gPSB0aGlzLmRhdGEuYnl0ZUxlbmd0aCAtIHRoaXMuYnl0ZXNBdmFpbGFibGUsXG4gICAgICB3b3JraW5nQnl0ZXMgPSBuZXcgVWludDhBcnJheSg0KSxcbiAgICAgIGF2YWlsYWJsZUJ5dGVzID0gTWF0aC5taW4oNCwgdGhpcy5ieXRlc0F2YWlsYWJsZSk7XG4gICAgaWYgKGF2YWlsYWJsZUJ5dGVzID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vIGJ5dGVzIGF2YWlsYWJsZScpO1xuICAgIH1cbiAgICB3b3JraW5nQnl0ZXMuc2V0KHRoaXMuZGF0YS5zdWJhcnJheShwb3NpdGlvbiwgcG9zaXRpb24gKyBhdmFpbGFibGVCeXRlcykpO1xuICAgIHRoaXMud29yZCA9IG5ldyBEYXRhVmlldyh3b3JraW5nQnl0ZXMuYnVmZmVyKS5nZXRVaW50MzIoMCk7XG4gICAgLy8gdHJhY2sgdGhlIGFtb3VudCBvZiB0aGlzLmRhdGEgdGhhdCBoYXMgYmVlbiBwcm9jZXNzZWRcbiAgICB0aGlzLmJpdHNBdmFpbGFibGUgPSBhdmFpbGFibGVCeXRlcyAqIDg7XG4gICAgdGhpcy5ieXRlc0F2YWlsYWJsZSAtPSBhdmFpbGFibGVCeXRlcztcbiAgfVxuXG4gIC8vIChjb3VudDppbnQpOnZvaWRcbiAgc2tpcEJpdHMoY291bnQpIHtcbiAgICB2YXIgc2tpcEJ5dGVzOyAvLyA6aW50XG4gICAgaWYgKHRoaXMuYml0c0F2YWlsYWJsZSA+IGNvdW50KSB7XG4gICAgICB0aGlzLndvcmQgPDw9IGNvdW50O1xuICAgICAgdGhpcy5iaXRzQXZhaWxhYmxlIC09IGNvdW50O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb3VudCAtPSB0aGlzLmJpdHNBdmFpbGFibGU7XG4gICAgICBza2lwQnl0ZXMgPSBjb3VudCA+PiAzO1xuICAgICAgY291bnQgLT0gKHNraXBCeXRlcyA+PiAzKTtcbiAgICAgIHRoaXMuYnl0ZXNBdmFpbGFibGUgLT0gc2tpcEJ5dGVzO1xuICAgICAgdGhpcy5sb2FkV29yZCgpO1xuICAgICAgdGhpcy53b3JkIDw8PSBjb3VudDtcbiAgICAgIHRoaXMuYml0c0F2YWlsYWJsZSAtPSBjb3VudDtcbiAgICB9XG4gIH1cblxuICAvLyAoc2l6ZTppbnQpOnVpbnRcbiAgcmVhZEJpdHMoc2l6ZSkge1xuICAgIHZhclxuICAgICAgYml0cyA9IE1hdGgubWluKHRoaXMuYml0c0F2YWlsYWJsZSwgc2l6ZSksIC8vIDp1aW50XG4gICAgICB2YWx1ID0gdGhpcy53b3JkID4+PiAoMzIgLSBiaXRzKTsgLy8gOnVpbnRcbiAgICBpZiAoc2l6ZSA+IDMyKSB7XG4gICAgICBsb2dnZXIuZXJyb3IoJ0Nhbm5vdCByZWFkIG1vcmUgdGhhbiAzMiBiaXRzIGF0IGEgdGltZScpO1xuICAgIH1cbiAgICB0aGlzLmJpdHNBdmFpbGFibGUgLT0gYml0cztcbiAgICBpZiAodGhpcy5iaXRzQXZhaWxhYmxlID4gMCkge1xuICAgICAgdGhpcy53b3JkIDw8PSBiaXRzO1xuICAgIH0gZWxzZSBpZiAodGhpcy5ieXRlc0F2YWlsYWJsZSA+IDApIHtcbiAgICAgIHRoaXMubG9hZFdvcmQoKTtcbiAgICB9XG4gICAgYml0cyA9IHNpemUgLSBiaXRzO1xuICAgIGlmIChiaXRzID4gMCAmJiB0aGlzLmJpdHNBdmFpbGFibGUpIHtcbiAgICAgIHJldHVybiB2YWx1IDw8IGJpdHMgfCB0aGlzLnJlYWRCaXRzKGJpdHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdmFsdTtcbiAgICB9XG4gIH1cblxuICAvLyAoKTp1aW50XG4gIHNraXBMWigpIHtcbiAgICB2YXIgbGVhZGluZ1plcm9Db3VudDsgLy8gOnVpbnRcbiAgICBmb3IgKGxlYWRpbmdaZXJvQ291bnQgPSAwOyBsZWFkaW5nWmVyb0NvdW50IDwgdGhpcy5iaXRzQXZhaWxhYmxlOyArK2xlYWRpbmdaZXJvQ291bnQpIHtcbiAgICAgIGlmICgwICE9PSAodGhpcy53b3JkICYgKDB4ODAwMDAwMDAgPj4+IGxlYWRpbmdaZXJvQ291bnQpKSkge1xuICAgICAgICAvLyB0aGUgZmlyc3QgYml0IG9mIHdvcmtpbmcgd29yZCBpcyAxXG4gICAgICAgIHRoaXMud29yZCA8PD0gbGVhZGluZ1plcm9Db3VudDtcbiAgICAgICAgdGhpcy5iaXRzQXZhaWxhYmxlIC09IGxlYWRpbmdaZXJvQ291bnQ7XG4gICAgICAgIHJldHVybiBsZWFkaW5nWmVyb0NvdW50O1xuICAgICAgfVxuICAgIH1cbiAgICAvLyB3ZSBleGhhdXN0ZWQgd29yZCBhbmQgc3RpbGwgaGF2ZSBub3QgZm91bmQgYSAxXG4gICAgdGhpcy5sb2FkV29yZCgpO1xuICAgIHJldHVybiBsZWFkaW5nWmVyb0NvdW50ICsgdGhpcy5za2lwTFooKTtcbiAgfVxuXG4gIC8vICgpOnZvaWRcbiAgc2tpcFVFRygpIHtcbiAgICB0aGlzLnNraXBCaXRzKDEgKyB0aGlzLnNraXBMWigpKTtcbiAgfVxuXG4gIC8vICgpOnZvaWRcbiAgc2tpcEVHKCkge1xuICAgIHRoaXMuc2tpcEJpdHMoMSArIHRoaXMuc2tpcExaKCkpO1xuICB9XG5cbiAgLy8gKCk6dWludFxuICByZWFkVUVHKCkge1xuICAgIHZhciBjbHogPSB0aGlzLnNraXBMWigpOyAvLyA6dWludFxuICAgIHJldHVybiB0aGlzLnJlYWRCaXRzKGNseiArIDEpIC0gMTtcbiAgfVxuXG4gIC8vICgpOmludFxuICByZWFkRUcoKSB7XG4gICAgdmFyIHZhbHUgPSB0aGlzLnJlYWRVRUcoKTsgLy8gOmludFxuICAgIGlmICgweDAxICYgdmFsdSkge1xuICAgICAgLy8gdGhlIG51bWJlciBpcyBvZGQgaWYgdGhlIGxvdyBvcmRlciBiaXQgaXMgc2V0XG4gICAgICByZXR1cm4gKDEgKyB2YWx1KSA+Pj4gMTsgLy8gYWRkIDEgdG8gbWFrZSBpdCBldmVuLCBhbmQgZGl2aWRlIGJ5IDJcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIC0xICogKHZhbHUgPj4+IDEpOyAvLyBkaXZpZGUgYnkgdHdvIHRoZW4gbWFrZSBpdCBuZWdhdGl2ZVxuICAgIH1cbiAgfVxuXG4gIC8vIFNvbWUgY29udmVuaWVuY2UgZnVuY3Rpb25zXG4gIC8vIDpCb29sZWFuXG4gIHJlYWRCb29sZWFuKCkge1xuICAgIHJldHVybiAxID09PSB0aGlzLnJlYWRCaXRzKDEpO1xuICB9XG5cbiAgLy8gKCk6aW50XG4gIHJlYWRVQnl0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5yZWFkQml0cyg4KTtcbiAgfVxuXG4gIC8vICgpOmludFxuICByZWFkVVNob3J0KCkge1xuICAgIHJldHVybiB0aGlzLnJlYWRCaXRzKDE2KTtcbiAgfVxuICAgIC8vICgpOmludFxuICByZWFkVUludCgpIHtcbiAgICByZXR1cm4gdGhpcy5yZWFkQml0cygzMik7XG4gIH1cblxuICAvKipcbiAgICogQWR2YW5jZSB0aGUgRXhwR29sb21iIGRlY29kZXIgcGFzdCBhIHNjYWxpbmcgbGlzdC4gVGhlIHNjYWxpbmdcbiAgICogbGlzdCBpcyBvcHRpb25hbGx5IHRyYW5zbWl0dGVkIGFzIHBhcnQgb2YgYSBzZXF1ZW5jZSBwYXJhbWV0ZXJcbiAgICogc2V0IGFuZCBpcyBub3QgcmVsZXZhbnQgdG8gdHJhbnNtdXhpbmcuXG4gICAqIEBwYXJhbSBjb3VudCB7bnVtYmVyfSB0aGUgbnVtYmVyIG9mIGVudHJpZXMgaW4gdGhpcyBzY2FsaW5nIGxpc3RcbiAgICogQHNlZSBSZWNvbW1lbmRhdGlvbiBJVFUtVCBILjI2NCwgU2VjdGlvbiA3LjMuMi4xLjEuMVxuICAgKi9cbiAgc2tpcFNjYWxpbmdMaXN0KGNvdW50KSB7XG4gICAgdmFyXG4gICAgICBsYXN0U2NhbGUgPSA4LFxuICAgICAgbmV4dFNjYWxlID0gOCxcbiAgICAgIGosXG4gICAgICBkZWx0YVNjYWxlO1xuICAgIGZvciAoaiA9IDA7IGogPCBjb3VudDsgaisrKSB7XG4gICAgICBpZiAobmV4dFNjYWxlICE9PSAwKSB7XG4gICAgICAgIGRlbHRhU2NhbGUgPSB0aGlzLnJlYWRFRygpO1xuICAgICAgICBuZXh0U2NhbGUgPSAobGFzdFNjYWxlICsgZGVsdGFTY2FsZSArIDI1NikgJSAyNTY7XG4gICAgICB9XG4gICAgICBsYXN0U2NhbGUgPSAobmV4dFNjYWxlID09PSAwKSA/IGxhc3RTY2FsZSA6IG5leHRTY2FsZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVhZCBhIHNlcXVlbmNlIHBhcmFtZXRlciBzZXQgYW5kIHJldHVybiBzb21lIGludGVyZXN0aW5nIHZpZGVvXG4gICAqIHByb3BlcnRpZXMuIEEgc2VxdWVuY2UgcGFyYW1ldGVyIHNldCBpcyB0aGUgSDI2NCBtZXRhZGF0YSB0aGF0XG4gICAqIGRlc2NyaWJlcyB0aGUgcHJvcGVydGllcyBvZiB1cGNvbWluZyB2aWRlbyBmcmFtZXMuXG4gICAqIEBwYXJhbSBkYXRhIHtVaW50OEFycmF5fSB0aGUgYnl0ZXMgb2YgYSBzZXF1ZW5jZSBwYXJhbWV0ZXIgc2V0XG4gICAqIEByZXR1cm4ge29iamVjdH0gYW4gb2JqZWN0IHdpdGggY29uZmlndXJhdGlvbiBwYXJzZWQgZnJvbSB0aGVcbiAgICogc2VxdWVuY2UgcGFyYW1ldGVyIHNldCwgaW5jbHVkaW5nIHRoZSBkaW1lbnNpb25zIG9mIHRoZVxuICAgKiBhc3NvY2lhdGVkIHZpZGVvIGZyYW1lcy5cbiAgICovXG4gIHJlYWRTUFMoKSB7XG4gICAgdmFyXG4gICAgICBmcmFtZUNyb3BMZWZ0T2Zmc2V0ID0gMCxcbiAgICAgIGZyYW1lQ3JvcFJpZ2h0T2Zmc2V0ID0gMCxcbiAgICAgIGZyYW1lQ3JvcFRvcE9mZnNldCA9IDAsXG4gICAgICBmcmFtZUNyb3BCb3R0b21PZmZzZXQgPSAwLFxuICAgICAgc2FyU2NhbGUgPSAxLFxuICAgICAgcHJvZmlsZUlkYyxwcm9maWxlQ29tcGF0LGxldmVsSWRjLFxuICAgICAgbnVtUmVmRnJhbWVzSW5QaWNPcmRlckNudEN5Y2xlLCBwaWNXaWR0aEluTWJzTWludXMxLFxuICAgICAgcGljSGVpZ2h0SW5NYXBVbml0c01pbnVzMSxcbiAgICAgIGZyYW1lTWJzT25seUZsYWcsXG4gICAgICBzY2FsaW5nTGlzdENvdW50LFxuICAgICAgaTtcbiAgICB0aGlzLnJlYWRVQnl0ZSgpO1xuICAgIHByb2ZpbGVJZGMgPSB0aGlzLnJlYWRVQnl0ZSgpOyAvLyBwcm9maWxlX2lkY1xuICAgIHByb2ZpbGVDb21wYXQgPSB0aGlzLnJlYWRCaXRzKDUpOyAvLyBjb25zdHJhaW50X3NldFswLTRdX2ZsYWcsIHUoNSlcbiAgICB0aGlzLnNraXBCaXRzKDMpOyAvLyByZXNlcnZlZF96ZXJvXzNiaXRzIHUoMyksXG4gICAgbGV2ZWxJZGMgPSB0aGlzLnJlYWRVQnl0ZSgpOyAvL2xldmVsX2lkYyB1KDgpXG4gICAgdGhpcy5za2lwVUVHKCk7IC8vIHNlcV9wYXJhbWV0ZXJfc2V0X2lkXG4gICAgLy8gc29tZSBwcm9maWxlcyBoYXZlIG1vcmUgb3B0aW9uYWwgZGF0YSB3ZSBkb24ndCBuZWVkXG4gICAgaWYgKHByb2ZpbGVJZGMgPT09IDEwMCB8fFxuICAgICAgICBwcm9maWxlSWRjID09PSAxMTAgfHxcbiAgICAgICAgcHJvZmlsZUlkYyA9PT0gMTIyIHx8XG4gICAgICAgIHByb2ZpbGVJZGMgPT09IDI0NCB8fFxuICAgICAgICBwcm9maWxlSWRjID09PSA0NCAgfHxcbiAgICAgICAgcHJvZmlsZUlkYyA9PT0gODMgIHx8XG4gICAgICAgIHByb2ZpbGVJZGMgPT09IDg2ICB8fFxuICAgICAgICBwcm9maWxlSWRjID09PSAxMTggfHxcbiAgICAgICAgcHJvZmlsZUlkYyA9PT0gMTI4KSB7XG4gICAgICB2YXIgY2hyb21hRm9ybWF0SWRjID0gdGhpcy5yZWFkVUVHKCk7XG4gICAgICBpZiAoY2hyb21hRm9ybWF0SWRjID09PSAzKSB7XG4gICAgICAgIHRoaXMuc2tpcEJpdHMoMSk7IC8vIHNlcGFyYXRlX2NvbG91cl9wbGFuZV9mbGFnXG4gICAgICB9XG4gICAgICB0aGlzLnNraXBVRUcoKTsgLy8gYml0X2RlcHRoX2x1bWFfbWludXM4XG4gICAgICB0aGlzLnNraXBVRUcoKTsgLy8gYml0X2RlcHRoX2Nocm9tYV9taW51czhcbiAgICAgIHRoaXMuc2tpcEJpdHMoMSk7IC8vIHFwcHJpbWVfeV96ZXJvX3RyYW5zZm9ybV9ieXBhc3NfZmxhZ1xuICAgICAgaWYgKHRoaXMucmVhZEJvb2xlYW4oKSkgeyAvLyBzZXFfc2NhbGluZ19tYXRyaXhfcHJlc2VudF9mbGFnXG4gICAgICAgIHNjYWxpbmdMaXN0Q291bnQgPSAoY2hyb21hRm9ybWF0SWRjICE9PSAzKSA/IDggOiAxMjtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHNjYWxpbmdMaXN0Q291bnQ7IGkrKykge1xuICAgICAgICAgIGlmICh0aGlzLnJlYWRCb29sZWFuKCkpIHsgLy8gc2VxX3NjYWxpbmdfbGlzdF9wcmVzZW50X2ZsYWdbIGkgXVxuICAgICAgICAgICAgaWYgKGkgPCA2KSB7XG4gICAgICAgICAgICAgIHRoaXMuc2tpcFNjYWxpbmdMaXN0KDE2KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuc2tpcFNjYWxpbmdMaXN0KDY0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5za2lwVUVHKCk7IC8vIGxvZzJfbWF4X2ZyYW1lX251bV9taW51czRcbiAgICB2YXIgcGljT3JkZXJDbnRUeXBlID0gdGhpcy5yZWFkVUVHKCk7XG4gICAgaWYgKHBpY09yZGVyQ250VHlwZSA9PT0gMCkge1xuICAgICAgdGhpcy5yZWFkVUVHKCk7IC8vbG9nMl9tYXhfcGljX29yZGVyX2NudF9sc2JfbWludXM0XG4gICAgfSBlbHNlIGlmIChwaWNPcmRlckNudFR5cGUgPT09IDEpIHtcbiAgICAgIHRoaXMuc2tpcEJpdHMoMSk7IC8vIGRlbHRhX3BpY19vcmRlcl9hbHdheXNfemVyb19mbGFnXG4gICAgICB0aGlzLnNraXBFRygpOyAvLyBvZmZzZXRfZm9yX25vbl9yZWZfcGljXG4gICAgICB0aGlzLnNraXBFRygpOyAvLyBvZmZzZXRfZm9yX3RvcF90b19ib3R0b21fZmllbGRcbiAgICAgIG51bVJlZkZyYW1lc0luUGljT3JkZXJDbnRDeWNsZSA9IHRoaXMucmVhZFVFRygpO1xuICAgICAgZm9yKGkgPSAwOyBpIDwgbnVtUmVmRnJhbWVzSW5QaWNPcmRlckNudEN5Y2xlOyBpKyspIHtcbiAgICAgICAgdGhpcy5za2lwRUcoKTsgLy8gb2Zmc2V0X2Zvcl9yZWZfZnJhbWVbIGkgXVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnNraXBVRUcoKTsgLy8gbWF4X251bV9yZWZfZnJhbWVzXG4gICAgdGhpcy5za2lwQml0cygxKTsgLy8gZ2Fwc19pbl9mcmFtZV9udW1fdmFsdWVfYWxsb3dlZF9mbGFnXG4gICAgcGljV2lkdGhJbk1ic01pbnVzMSA9IHRoaXMucmVhZFVFRygpO1xuICAgIHBpY0hlaWdodEluTWFwVW5pdHNNaW51czEgPSB0aGlzLnJlYWRVRUcoKTtcbiAgICBmcmFtZU1ic09ubHlGbGFnID0gdGhpcy5yZWFkQml0cygxKTtcbiAgICBpZiAoZnJhbWVNYnNPbmx5RmxhZyA9PT0gMCkge1xuICAgICAgdGhpcy5za2lwQml0cygxKTsgLy8gbWJfYWRhcHRpdmVfZnJhbWVfZmllbGRfZmxhZ1xuICAgIH1cbiAgICB0aGlzLnNraXBCaXRzKDEpOyAvLyBkaXJlY3RfOHg4X2luZmVyZW5jZV9mbGFnXG4gICAgaWYgKHRoaXMucmVhZEJvb2xlYW4oKSkgeyAvLyBmcmFtZV9jcm9wcGluZ19mbGFnXG4gICAgICBmcmFtZUNyb3BMZWZ0T2Zmc2V0ID0gdGhpcy5yZWFkVUVHKCk7XG4gICAgICBmcmFtZUNyb3BSaWdodE9mZnNldCA9IHRoaXMucmVhZFVFRygpO1xuICAgICAgZnJhbWVDcm9wVG9wT2Zmc2V0ID0gdGhpcy5yZWFkVUVHKCk7XG4gICAgICBmcmFtZUNyb3BCb3R0b21PZmZzZXQgPSB0aGlzLnJlYWRVRUcoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMucmVhZEJvb2xlYW4oKSkge1xuICAgICAgLy8gdnVpX3BhcmFtZXRlcnNfcHJlc2VudF9mbGFnXG4gICAgICBpZiAodGhpcy5yZWFkQm9vbGVhbigpKSB7XG4gICAgICAgIC8vIGFzcGVjdF9yYXRpb19pbmZvX3ByZXNlbnRfZmxhZ1xuICAgICAgICBsZXQgc2FyUmF0aW87XG4gICAgICAgIGNvbnN0IGFzcGVjdFJhdGlvSWRjID0gdGhpcy5yZWFkVUJ5dGUoKTtcbiAgICAgICAgc3dpdGNoIChhc3BlY3RSYXRpb0lkYykge1xuICAgICAgICAgIGNhc2UgMTogc2FyUmF0aW8gPSBbMSwxXTsgYnJlYWs7XG4gICAgICAgICAgY2FzZSAyOiBzYXJSYXRpbyA9IFsxMiwxMV07IGJyZWFrO1xuICAgICAgICAgIGNhc2UgMzogc2FyUmF0aW8gPSBbMTAsMTFdOyBicmVhaztcbiAgICAgICAgICBjYXNlIDQ6IHNhclJhdGlvID0gWzE2LDExXTsgYnJlYWs7XG4gICAgICAgICAgY2FzZSA1OiBzYXJSYXRpbyA9IFs0MCwzM107IGJyZWFrO1xuICAgICAgICAgIGNhc2UgNjogc2FyUmF0aW8gPSBbMjQsMTFdOyBicmVhaztcbiAgICAgICAgICBjYXNlIDc6IHNhclJhdGlvID0gWzIwLDExXTsgYnJlYWs7XG4gICAgICAgICAgY2FzZSA4OiBzYXJSYXRpbyA9IFszMiwxMV07IGJyZWFrO1xuICAgICAgICAgIGNhc2UgOTogc2FyUmF0aW8gPSBbODAsMzNdOyBicmVhaztcbiAgICAgICAgICBjYXNlIDEwOiBzYXJSYXRpbyA9IFsxOCwxMV07IGJyZWFrO1xuICAgICAgICAgIGNhc2UgMTE6IHNhclJhdGlvID0gWzE1LDExXTsgYnJlYWs7XG4gICAgICAgICAgY2FzZSAxMjogc2FyUmF0aW8gPSBbNjQsMzNdOyBicmVhaztcbiAgICAgICAgICBjYXNlIDEzOiBzYXJSYXRpbyA9IFsxNjAsOTldOyBicmVhaztcbiAgICAgICAgICBjYXNlIDE0OiBzYXJSYXRpbyA9IFs0LDNdOyBicmVhaztcbiAgICAgICAgICBjYXNlIDE1OiBzYXJSYXRpbyA9IFszLDJdOyBicmVhaztcbiAgICAgICAgICBjYXNlIDE2OiBzYXJSYXRpbyA9IFsyLDFdOyBicmVhaztcbiAgICAgICAgICBjYXNlIDI1NToge1xuICAgICAgICAgICAgc2FyUmF0aW8gPSBbdGhpcy5yZWFkVUJ5dGUoKSA8PCA4IHwgdGhpcy5yZWFkVUJ5dGUoKSwgdGhpcy5yZWFkVUJ5dGUoKSA8PCA4IHwgdGhpcy5yZWFkVUJ5dGUoKV07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNhclJhdGlvKSB7XG4gICAgICAgICAgc2FyU2NhbGUgPSBzYXJSYXRpb1swXSAvIHNhclJhdGlvWzFdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB3aWR0aDogTWF0aC5jZWlsKCgoKHBpY1dpZHRoSW5NYnNNaW51czEgKyAxKSAqIDE2KSAtIGZyYW1lQ3JvcExlZnRPZmZzZXQgKiAyIC0gZnJhbWVDcm9wUmlnaHRPZmZzZXQgKiAyKSAqIHNhclNjYWxlKSxcbiAgICAgIGhlaWdodDogKCgyIC0gZnJhbWVNYnNPbmx5RmxhZykgKiAocGljSGVpZ2h0SW5NYXBVbml0c01pbnVzMSArIDEpICogMTYpIC0gKChmcmFtZU1ic09ubHlGbGFnPyAyIDogNCkgKiAoZnJhbWVDcm9wVG9wT2Zmc2V0ICsgZnJhbWVDcm9wQm90dG9tT2Zmc2V0KSlcbiAgICB9O1xuICB9XG5cbiAgcmVhZFNsaWNlVHlwZSgpIHtcbiAgICAvLyBza2lwIE5BTHUgdHlwZVxuICAgIHRoaXMucmVhZFVCeXRlKCk7XG4gICAgLy8gZGlzY2FyZCBmaXJzdF9tYl9pbl9zbGljZVxuICAgIHRoaXMucmVhZFVFRygpO1xuICAgIC8vIHJldHVybiBzbGljZV90eXBlXG4gICAgcmV0dXJuIHRoaXMucmVhZFVFRygpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEV4cEdvbG9tYjtcbiIsIi8qKlxuICogSUQzIHBhcnNlclxuICovXG5pbXBvcnQge2xvZ2dlcn0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcbi8vaW1wb3J0IEhleCBmcm9tICcuLi91dGlscy9oZXgnO1xuXG4gY2xhc3MgSUQzIHtcblxuICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgdGhpcy5faGFzVGltZVN0YW1wID0gZmFsc2U7XG4gICAgdmFyIG9mZnNldCA9IDAsIGJ5dGUxLGJ5dGUyLGJ5dGUzLGJ5dGU0LHRhZ1NpemUsZW5kUG9zLGhlYWRlcixsZW47XG4gICAgICBkbyB7XG4gICAgICAgIGhlYWRlciA9IHRoaXMucmVhZFVURihkYXRhLG9mZnNldCwzKTtcbiAgICAgICAgb2Zmc2V0Kz0zO1xuICAgICAgICAgIC8vIGZpcnN0IGNoZWNrIGZvciBJRDMgaGVhZGVyXG4gICAgICAgICAgaWYgKGhlYWRlciA9PT0gJ0lEMycpIHtcbiAgICAgICAgICAgICAgLy8gc2tpcCAyNCBiaXRzXG4gICAgICAgICAgICAgIG9mZnNldCArPSAzO1xuICAgICAgICAgICAgICAvLyByZXRyaWV2ZSB0YWcocykgbGVuZ3RoXG4gICAgICAgICAgICAgIGJ5dGUxID0gZGF0YVtvZmZzZXQrK10gJiAweDdmO1xuICAgICAgICAgICAgICBieXRlMiA9IGRhdGFbb2Zmc2V0KytdICYgMHg3ZjtcbiAgICAgICAgICAgICAgYnl0ZTMgPSBkYXRhW29mZnNldCsrXSAmIDB4N2Y7XG4gICAgICAgICAgICAgIGJ5dGU0ID0gZGF0YVtvZmZzZXQrK10gJiAweDdmO1xuICAgICAgICAgICAgICB0YWdTaXplID0gKGJ5dGUxIDw8IDIxKSArIChieXRlMiA8PCAxNCkgKyAoYnl0ZTMgPDwgNykgKyBieXRlNDtcbiAgICAgICAgICAgICAgZW5kUG9zID0gb2Zmc2V0ICsgdGFnU2l6ZTtcbiAgICAgICAgICAgICAgLy9sb2dnZXIubG9nKGBJRDMgdGFnIGZvdW5kLCBzaXplL2VuZDogJHt0YWdTaXplfS8ke2VuZFBvc31gKTtcblxuICAgICAgICAgICAgICAvLyByZWFkIElEMyB0YWdzXG4gICAgICAgICAgICAgIHRoaXMuX3BhcnNlSUQzRnJhbWVzKGRhdGEsIG9mZnNldCxlbmRQb3MpO1xuICAgICAgICAgICAgICBvZmZzZXQgPSBlbmRQb3M7XG4gICAgICAgICAgfSBlbHNlIGlmIChoZWFkZXIgPT09ICczREknKSB7XG4gICAgICAgICAgICAgIC8vIGh0dHA6Ly9pZDMub3JnL2lkM3YyLjQuMC1zdHJ1Y3R1cmUgY2hhcHRlciAzLjQuICAgSUQzdjIgZm9vdGVyXG4gICAgICAgICAgICAgIG9mZnNldCArPSA3O1xuICAgICAgICAgICAgICAgICAgbG9nZ2VyLmxvZyhgM0RJIGZvb3RlciBmb3VuZCwgZW5kOiAke29mZnNldH1gKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBvZmZzZXQgLT0gMztcbiAgICAgICAgICAgICAgbGVuID0gb2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgaWYgKGxlbikge1xuICAgICAgICAgICAgICAgICAgICAgIC8vbG9nZ2VyLmxvZyhgSUQzIGxlbjogJHtsZW59YCk7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmhhc1RpbWVTdGFtcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIud2FybignSUQzIHRhZyBmb3VuZCwgYnV0IG5vIHRpbWVzdGFtcCcpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9sZW5ndGggPSBsZW47XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGF5bG9hZCA9IGRhdGEuc3ViYXJyYXkoMCxsZW4pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgfSB3aGlsZSAodHJ1ZSk7XG4gIH1cblxuICByZWFkVVRGKGRhdGEsc3RhcnQsbGVuKSB7XG5cbiAgICB2YXIgcmVzdWx0ID0gJycsb2Zmc2V0ID0gc3RhcnQsIGVuZCA9IHN0YXJ0ICsgbGVuO1xuICAgIGRvIHtcbiAgICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGRhdGFbb2Zmc2V0KytdKTtcbiAgICB9IHdoaWxlKG9mZnNldCA8IGVuZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIF9wYXJzZUlEM0ZyYW1lcyhkYXRhLG9mZnNldCxlbmRQb3MpIHtcbiAgICB2YXIgdGFnSWQsdGFnTGVuLHRhZ1N0YXJ0LHRhZ0ZsYWdzLHRpbWVzdGFtcDtcbiAgICB3aGlsZShvZmZzZXQgKyA4IDw9IGVuZFBvcykge1xuICAgICAgdGFnSWQgPSB0aGlzLnJlYWRVVEYoZGF0YSxvZmZzZXQsNCk7XG4gICAgICBvZmZzZXQgKz00O1xuXG4gICAgICB0YWdMZW4gPSBkYXRhW29mZnNldCsrXSA8PCAyNCArXG4gICAgICAgICAgICAgICAgZGF0YVtvZmZzZXQrK10gPDwgMTYgK1xuICAgICAgICAgICAgICAgIGRhdGFbb2Zmc2V0KytdIDw8IDggK1xuICAgICAgICAgICAgICAgIGRhdGFbb2Zmc2V0KytdO1xuXG4gICAgICB0YWdGbGFncyA9IGRhdGFbb2Zmc2V0KytdIDw8IDggK1xuICAgICAgICAgICAgICAgICAgZGF0YVtvZmZzZXQrK107XG5cbiAgICAgIHRhZ1N0YXJ0ID0gb2Zmc2V0O1xuICAgICAgLy9sb2dnZXIubG9nKFwiSUQzIHRhZyBpZDpcIiArIHRhZ0lkKTtcbiAgICAgIHN3aXRjaCh0YWdJZCkge1xuICAgICAgICBjYXNlICdQUklWJzpcbiAgICAgICAgICAgIC8vbG9nZ2VyLmxvZygncGFyc2UgZnJhbWU6JyArIEhleC5oZXhEdW1wKGRhdGEuc3ViYXJyYXkob2Zmc2V0LGVuZFBvcykpKTtcbiAgICAgICAgICAgIC8vIG93bmVyIHNob3VsZCBiZSBcImNvbS5hcHBsZS5zdHJlYW1pbmcudHJhbnNwb3J0U3RyZWFtVGltZXN0YW1wXCJcbiAgICAgICAgICAgIGlmICh0aGlzLnJlYWRVVEYoZGF0YSxvZmZzZXQsNDQpID09PSAnY29tLmFwcGxlLnN0cmVhbWluZy50cmFuc3BvcnRTdHJlYW1UaW1lc3RhbXAnKSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0Kz00NDtcbiAgICAgICAgICAgICAgICAvLyBzbWVsbGluZyBldmVuIGJldHRlciAhIHdlIGZvdW5kIHRoZSByaWdodCBkZXNjcmlwdG9yXG4gICAgICAgICAgICAgICAgLy8gc2tpcCBudWxsIGNoYXJhY3RlciAoc3RyaW5nIGVuZCkgKyAzIGZpcnN0IGJ5dGVzXG4gICAgICAgICAgICAgICAgb2Zmc2V0Kz0gNDtcblxuICAgICAgICAgICAgICAgIC8vIHRpbWVzdGFtcCBpcyAzMyBiaXQgZXhwcmVzc2VkIGFzIGEgYmlnLWVuZGlhbiBlaWdodC1vY3RldCBudW1iZXIsIHdpdGggdGhlIHVwcGVyIDMxIGJpdHMgc2V0IHRvIHplcm8uXG4gICAgICAgICAgICAgICAgdmFyIHB0czMzQml0ICA9IGRhdGFbb2Zmc2V0KytdICYgMHgxO1xuICAgICAgICAgICAgICAgIHRoaXMuX2hhc1RpbWVTdGFtcCA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICB0aW1lc3RhbXAgPSAoKGRhdGFbb2Zmc2V0KytdIDw8IDIzKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIChkYXRhW29mZnNldCsrXSA8PCAxNSkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZGF0YVtvZmZzZXQrK10gPDwgIDcpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVtvZmZzZXQrK10pIC80NTtcblxuICAgICAgICAgICAgICAgIGlmIChwdHMzM0JpdCkge1xuICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXAgICArPSA0NzcyMTg1OC44NDsgLy8gMl4zMiAvIDkwXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRpbWVzdGFtcCA9IE1hdGgucm91bmQodGltZXN0YW1wKTtcbiAgICAgICAgICAgICAgICBsb2dnZXIudHJhY2UoYElEMyB0aW1lc3RhbXAgZm91bmQ6ICR7dGltZXN0YW1wfWApO1xuICAgICAgICAgICAgICAgIHRoaXMuX3RpbWVTdGFtcCA9IHRpbWVzdGFtcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZ2V0IGhhc1RpbWVTdGFtcCgpIHtcbiAgICByZXR1cm4gdGhpcy5faGFzVGltZVN0YW1wO1xuICB9XG5cbiAgZ2V0IHRpbWVTdGFtcCgpIHtcbiAgICByZXR1cm4gdGhpcy5fdGltZVN0YW1wO1xuICB9XG5cbiAgZ2V0IGxlbmd0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5fbGVuZ3RoO1xuICB9XG5cbiAgZ2V0IHBheWxvYWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BheWxvYWQ7XG4gIH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBJRDM7XG5cbiIsIi8qKlxuICogaGlnaGx5IG9wdGltaXplZCBUUyBkZW11eGVyOlxuICogcGFyc2UgUEFULCBQTVRcbiAqIGV4dHJhY3QgUEVTIHBhY2tldCBmcm9tIGF1ZGlvIGFuZCB2aWRlbyBQSURzXG4gKiBleHRyYWN0IEFWQy9IMjY0IE5BTCB1bml0cyBhbmQgQUFDL0FEVFMgc2FtcGxlcyBmcm9tIFBFUyBwYWNrZXRcbiAqIHRyaWdnZXIgdGhlIHJlbXV4ZXIgdXBvbiBwYXJzaW5nIGNvbXBsZXRpb25cbiAqIGl0IGFsc28gdHJpZXMgdG8gd29ya2Fyb3VuZCBhcyBiZXN0IGFzIGl0IGNhbiBhdWRpbyBjb2RlYyBzd2l0Y2ggKEhFLUFBQyB0byBBQUMgYW5kIHZpY2UgdmVyc2EpLCB3aXRob3V0IGhhdmluZyB0byByZXN0YXJ0IHRoZSBNZWRpYVNvdXJjZS5cbiAqIGl0IGFsc28gY29udHJvbHMgdGhlIHJlbXV4aW5nIHByb2Nlc3MgOlxuICogdXBvbiBkaXNjb250aW51aXR5IG9yIGxldmVsIHN3aXRjaCBkZXRlY3Rpb24sIGl0IHdpbGwgYWxzbyBub3RpZmllcyB0aGUgcmVtdXhlciBzbyB0aGF0IGl0IGNhbiByZXNldCBpdHMgc3RhdGUuXG4qL1xuXG4gaW1wb3J0IEFEVFMgZnJvbSAnLi9hZHRzJztcbiBpbXBvcnQgRXZlbnQgZnJvbSAnLi4vZXZlbnRzJztcbiBpbXBvcnQgRXhwR29sb21iIGZyb20gJy4vZXhwLWdvbG9tYic7XG4vLyBpbXBvcnQgSGV4IGZyb20gJy4uL3V0aWxzL2hleCc7XG4gaW1wb3J0IHtsb2dnZXJ9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XG4gaW1wb3J0IHtFcnJvclR5cGVzLCBFcnJvckRldGFpbHN9IGZyb20gJy4uL2Vycm9ycyc7XG5cbiBjbGFzcyBUU0RlbXV4ZXIge1xuXG4gIGNvbnN0cnVjdG9yKG9ic2VydmVyLCBpZCwgcmVtdXhlckNsYXNzLCBjb25maWcpIHtcbiAgICB0aGlzLm9ic2VydmVyID0gb2JzZXJ2ZXI7XG4gICAgdGhpcy5pZCA9IGlkO1xuICAgIHRoaXMucmVtdXhlckNsYXNzID0gcmVtdXhlckNsYXNzO1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgIHRoaXMubGFzdENDID0gMDtcbiAgICB0aGlzLnJlbXV4ZXIgPSBuZXcgdGhpcy5yZW11eGVyQ2xhc3Mob2JzZXJ2ZXIsIGlkLCBjb25maWcpO1xuICB9XG5cbiAgc3RhdGljIHByb2JlKGRhdGEpIHtcbiAgICAvLyBhIFRTIGZyYWdtZW50IHNob3VsZCBjb250YWluIGF0IGxlYXN0IDMgVFMgcGFja2V0cywgYSBQQVQsIGEgUE1ULCBhbmQgb25lIFBJRCwgZWFjaCBzdGFydGluZyB3aXRoIDB4NDdcbiAgICBpZiAoZGF0YS5sZW5ndGggPj0gMyoxODggJiYgZGF0YVswXSA9PT0gMHg0NyAmJiBkYXRhWzE4OF0gPT09IDB4NDcgJiYgZGF0YVsyKjE4OF0gPT09IDB4NDcpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgc3dpdGNoTGV2ZWwoKSB7XG4gICAgdGhpcy5wbXRQYXJzZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9wbXRJZCA9IC0xO1xuICAgIHRoaXMuX2F2Y1RyYWNrID0ge2NvbnRhaW5lciA6ICd2aWRlby9tcDJ0JywgdHlwZTogJ3ZpZGVvJywgaWQgOi0xLCBzZXF1ZW5jZU51bWJlcjogMCwgc2FtcGxlcyA6IFtdLCBsZW4gOiAwLCBkcm9wcGVkIDogMH07XG4gICAgdGhpcy5fYWFjVHJhY2sgPSB7Y29udGFpbmVyIDogJ3ZpZGVvL21wMnQnLCB0eXBlOiAnYXVkaW8nLCBpZCA6LTEsIHNlcXVlbmNlTnVtYmVyOiAwLCBzYW1wbGVzIDogW10sIGxlbiA6IDB9O1xuICAgIHRoaXMuX2lkM1RyYWNrID0ge3R5cGU6ICdpZDMnLCBpZCA6LTEsIHNlcXVlbmNlTnVtYmVyOiAwLCBzYW1wbGVzIDogW10sIGxlbiA6IDB9O1xuICAgIHRoaXMuX3R4dFRyYWNrID0ge3R5cGU6ICd0ZXh0JywgaWQ6IC0xLCBzZXF1ZW5jZU51bWJlcjogMCwgc2FtcGxlcyA6IFtdLCBsZW4gOiAwfTtcbiAgICAvLyBmbHVzaCBhbnkgcGFydGlhbCBjb250ZW50XG4gICAgdGhpcy5hYWNPdmVyRmxvdyA9IG51bGw7XG4gICAgdGhpcy5hYWNMYXN0UFRTID0gbnVsbDtcbiAgICB0aGlzLmF2Y1NhbXBsZSA9IG51bGw7XG4gICAgdGhpcy5yZW11eGVyLnN3aXRjaExldmVsKCk7XG4gIH1cblxuICBpbnNlcnREaXNjb250aW51aXR5KCkge1xuICAgIHRoaXMuc3dpdGNoTGV2ZWwoKTtcbiAgICB0aGlzLnJlbXV4ZXIuaW5zZXJ0RGlzY29udGludWl0eSgpO1xuICB9XG5cbiAgLy8gZmVlZCBpbmNvbWluZyBkYXRhIHRvIHRoZSBmcm9udCBvZiB0aGUgcGFyc2luZyBwaXBlbGluZVxuICBwdXNoKGRhdGEsIGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWMsIHRpbWVPZmZzZXQsIGNjLCBsZXZlbCwgc24sIGR1cmF0aW9uLGFjY3VyYXRlVGltZU9mZnNldCkge1xuICAgIHZhciBzdGFydCwgbGVuID0gZGF0YS5sZW5ndGgsIHN0dCwgcGlkLCBhdGYsIG9mZnNldCxwZXMsXG4gICAgICAgIGNvZGVjc09ubHkgPSB0aGlzLnJlbXV4ZXIucGFzc3Rocm91Z2gsXG4gICAgICAgIHVua25vd25QSURzID0gZmFsc2U7XG5cbiAgICB0aGlzLmF1ZGlvQ29kZWMgPSBhdWRpb0NvZGVjO1xuICAgIHRoaXMudmlkZW9Db2RlYyA9IHZpZGVvQ29kZWM7XG4gICAgdGhpcy5fZHVyYXRpb24gPSBkdXJhdGlvbjtcbiAgICB0aGlzLmNvbnRpZ3VvdXMgPSBmYWxzZTtcbiAgICB0aGlzLmFjY3VyYXRlVGltZU9mZnNldCA9IGFjY3VyYXRlVGltZU9mZnNldDtcbiAgICBpZiAoY2MgIT09IHRoaXMubGFzdENDKSB7XG4gICAgICBsb2dnZXIubG9nKCdkaXNjb250aW51aXR5IGRldGVjdGVkJyk7XG4gICAgICB0aGlzLmluc2VydERpc2NvbnRpbnVpdHkoKTtcbiAgICAgIHRoaXMubGFzdENDID0gY2M7XG4gICAgfVxuICAgIGlmIChsZXZlbCAhPT0gdGhpcy5sYXN0TGV2ZWwpIHtcbiAgICAgIGxvZ2dlci5sb2coJ2xldmVsIHN3aXRjaCBkZXRlY3RlZCcpO1xuICAgICAgdGhpcy5zd2l0Y2hMZXZlbCgpO1xuICAgICAgdGhpcy5sYXN0TGV2ZWwgPSBsZXZlbDtcbiAgICB9IGVsc2UgaWYgKHNuID09PSAodGhpcy5sYXN0U04rMSkpIHtcbiAgICAgIHRoaXMuY29udGlndW91cyA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMubGFzdFNOID0gc247XG5cbiAgICB2YXIgcG10UGFyc2VkID0gdGhpcy5wbXRQYXJzZWQsXG4gICAgICAgIGF2Y1RyYWNrID0gdGhpcy5fYXZjVHJhY2ssXG4gICAgICAgIGFhY1RyYWNrID0gdGhpcy5fYWFjVHJhY2ssXG4gICAgICAgIGlkM1RyYWNrID0gdGhpcy5faWQzVHJhY2ssXG4gICAgICAgIGF2Y0lkID0gYXZjVHJhY2suaWQsXG4gICAgICAgIGFhY0lkID0gYWFjVHJhY2suaWQsXG4gICAgICAgIGlkM0lkID0gaWQzVHJhY2suaWQsXG4gICAgICAgIHBtdElkID0gdGhpcy5fcG10SWQsXG4gICAgICAgIGF2Y0RhdGEgPSBhdmNUcmFjay5wZXNEYXRhLFxuICAgICAgICBhYWNEYXRhID0gYWFjVHJhY2sucGVzRGF0YSxcbiAgICAgICAgaWQzRGF0YSA9IGlkM1RyYWNrLnBlc0RhdGEsXG4gICAgICAgIHBhcnNlUEFUID0gdGhpcy5fcGFyc2VQQVQsXG4gICAgICAgIHBhcnNlUE1UID0gdGhpcy5fcGFyc2VQTVQsXG4gICAgICAgIHBhcnNlUEVTID0gdGhpcy5fcGFyc2VQRVMsXG4gICAgICAgIHBhcnNlQVZDUEVTID0gdGhpcy5fcGFyc2VBVkNQRVMuYmluZCh0aGlzKSxcbiAgICAgICAgcGFyc2VBQUNQRVMgPSB0aGlzLl9wYXJzZUFBQ1BFUy5iaW5kKHRoaXMpLFxuICAgICAgICBwYXJzZUlEM1BFUyAgPSB0aGlzLl9wYXJzZUlEM1BFUy5iaW5kKHRoaXMpO1xuXG4gICAgLy8gZG9uJ3QgcGFyc2UgbGFzdCBUUyBwYWNrZXQgaWYgaW5jb21wbGV0ZVxuICAgIGxlbiAtPSBsZW4gJSAxODg7XG4gICAgLy8gbG9vcCB0aHJvdWdoIFRTIHBhY2tldHNcbiAgICBmb3IgKHN0YXJ0ID0gMDsgc3RhcnQgPCBsZW47IHN0YXJ0ICs9IDE4OCkge1xuICAgICAgaWYgKGRhdGFbc3RhcnRdID09PSAweDQ3KSB7XG4gICAgICAgIHN0dCA9ICEhKGRhdGFbc3RhcnQgKyAxXSAmIDB4NDApO1xuICAgICAgICAvLyBwaWQgaXMgYSAxMy1iaXQgZmllbGQgc3RhcnRpbmcgYXQgdGhlIGxhc3QgYml0IG9mIFRTWzFdXG4gICAgICAgIHBpZCA9ICgoZGF0YVtzdGFydCArIDFdICYgMHgxZikgPDwgOCkgKyBkYXRhW3N0YXJ0ICsgMl07XG4gICAgICAgIGF0ZiA9IChkYXRhW3N0YXJ0ICsgM10gJiAweDMwKSA+PiA0O1xuICAgICAgICAvLyBpZiBhbiBhZGFwdGlvbiBmaWVsZCBpcyBwcmVzZW50LCBpdHMgbGVuZ3RoIGlzIHNwZWNpZmllZCBieSB0aGUgZmlmdGggYnl0ZSBvZiB0aGUgVFMgcGFja2V0IGhlYWRlci5cbiAgICAgICAgaWYgKGF0ZiA+IDEpIHtcbiAgICAgICAgICBvZmZzZXQgPSBzdGFydCArIDUgKyBkYXRhW3N0YXJ0ICsgNF07XG4gICAgICAgICAgLy8gY29udGludWUgaWYgdGhlcmUgaXMgb25seSBhZGFwdGF0aW9uIGZpZWxkXG4gICAgICAgICAgaWYgKG9mZnNldCA9PT0gKHN0YXJ0ICsgMTg4KSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9mZnNldCA9IHN0YXJ0ICsgNDtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2gocGlkKSB7XG4gICAgICAgICAgY2FzZSBhdmNJZDpcbiAgICAgICAgICAgIGlmIChzdHQpIHtcbiAgICAgICAgICAgICAgaWYgKGF2Y0RhdGEgJiYgKHBlcyA9IHBhcnNlUEVTKGF2Y0RhdGEpKSkge1xuICAgICAgICAgICAgICAgIHBhcnNlQVZDUEVTKHBlcyxmYWxzZSk7XG4gICAgICAgICAgICAgICAgaWYgKGNvZGVjc09ubHkpIHtcbiAgICAgICAgICAgICAgICAgIC8vIGlmIHdlIGhhdmUgdmlkZW8gY29kZWMgaW5mbyBBTkRcbiAgICAgICAgICAgICAgICAgIC8vIGlmIGF1ZGlvIFBJRCBpcyB1bmRlZmluZWQgT1IgaWYgd2UgaGF2ZSBhdWRpbyBjb2RlYyBpbmZvLFxuICAgICAgICAgICAgICAgICAgLy8gd2UgaGF2ZSBhbGwgY29kZWMgaW5mbyAhXG4gICAgICAgICAgICAgICAgICBpZiAoYXZjVHJhY2suY29kZWMgJiYgKGFhY0lkID09PSAtMSB8fCBhYWNUcmFjay5jb2RlYykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW11eChsZXZlbCxzbixkYXRhLHRpbWVPZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGF2Y0RhdGEgPSB7ZGF0YTogW10sIHNpemU6IDB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGF2Y0RhdGEpIHtcbiAgICAgICAgICAgICAgYXZjRGF0YS5kYXRhLnB1c2goZGF0YS5zdWJhcnJheShvZmZzZXQsIHN0YXJ0ICsgMTg4KSk7XG4gICAgICAgICAgICAgIGF2Y0RhdGEuc2l6ZSArPSBzdGFydCArIDE4OCAtIG9mZnNldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgYWFjSWQ6XG4gICAgICAgICAgICBpZiAoc3R0KSB7XG4gICAgICAgICAgICAgIGlmIChhYWNEYXRhICYmIChwZXMgPSBwYXJzZVBFUyhhYWNEYXRhKSkpIHtcbiAgICAgICAgICAgICAgICBwYXJzZUFBQ1BFUyhwZXMpO1xuICAgICAgICAgICAgICAgIGlmIChjb2RlY3NPbmx5KSB7XG4gICAgICAgICAgICAgICAgICAvLyBoZXJlIHdlIG5vdyB0aGF0IHdlIGhhdmUgYXVkaW8gY29kZWMgaW5mb1xuICAgICAgICAgICAgICAgICAgLy8gaWYgdmlkZW8gUElEIGlzIHVuZGVmaW5lZCBPUiBpZiB3ZSBoYXZlIHZpZGVvIGNvZGVjIGluZm8sXG4gICAgICAgICAgICAgICAgICAvLyB3ZSBoYXZlIGFsbCBjb2RlYyBpbmZvcyAhXG4gICAgICAgICAgICAgICAgICBpZiAoYWFjVHJhY2suY29kZWMgJiYgKGF2Y0lkID09PSAtMSB8fCBhdmNUcmFjay5jb2RlYykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW11eChsZXZlbCxzbixkYXRhLHRpbWVPZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGFhY0RhdGEgPSB7ZGF0YTogW10sIHNpemU6IDB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFhY0RhdGEpIHtcbiAgICAgICAgICAgICAgYWFjRGF0YS5kYXRhLnB1c2goZGF0YS5zdWJhcnJheShvZmZzZXQsIHN0YXJ0ICsgMTg4KSk7XG4gICAgICAgICAgICAgIGFhY0RhdGEuc2l6ZSArPSBzdGFydCArIDE4OCAtIG9mZnNldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgaWQzSWQ6XG4gICAgICAgICAgICBpZiAoc3R0KSB7XG4gICAgICAgICAgICAgIGlmIChpZDNEYXRhICYmIChwZXMgPSBwYXJzZVBFUyhpZDNEYXRhKSkpIHtcbiAgICAgICAgICAgICAgICBwYXJzZUlEM1BFUyhwZXMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlkM0RhdGEgPSB7ZGF0YTogW10sIHNpemU6IDB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlkM0RhdGEpIHtcbiAgICAgICAgICAgICAgaWQzRGF0YS5kYXRhLnB1c2goZGF0YS5zdWJhcnJheShvZmZzZXQsIHN0YXJ0ICsgMTg4KSk7XG4gICAgICAgICAgICAgIGlkM0RhdGEuc2l6ZSArPSBzdGFydCArIDE4OCAtIG9mZnNldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGlmIChzdHQpIHtcbiAgICAgICAgICAgICAgb2Zmc2V0ICs9IGRhdGFbb2Zmc2V0XSArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwbXRJZCA9IHRoaXMuX3BtdElkID0gcGFyc2VQQVQoZGF0YSwgb2Zmc2V0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgcG10SWQ6XG4gICAgICAgICAgICBpZiAoc3R0KSB7XG4gICAgICAgICAgICAgIG9mZnNldCArPSBkYXRhW29mZnNldF0gKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHBhcnNlZFBJRHMgPSBwYXJzZVBNVChkYXRhLCBvZmZzZXQpO1xuICAgICAgICAgICAgYXZjSWQgPSBhdmNUcmFjay5pZCA9IHBhcnNlZFBJRHMuYXZjO1xuICAgICAgICAgICAgYWFjSWQgPSBhYWNUcmFjay5pZCA9IHBhcnNlZFBJRHMuYWFjO1xuICAgICAgICAgICAgaWQzSWQgPSBpZDNUcmFjay5pZCA9IHBhcnNlZFBJRHMuaWQzO1xuICAgICAgICAgICAgaWYgKHVua25vd25QSURzICYmICFwbXRQYXJzZWQpIHtcbiAgICAgICAgICAgICAgbG9nZ2VyLmxvZygncmVwYXJzZSBmcm9tIGJlZ2lubmluZycpO1xuICAgICAgICAgICAgICB1bmtub3duUElEcyA9IGZhbHNlO1xuICAgICAgICAgICAgICAvLyB3ZSBzZXQgaXQgdG8gLTE4OCwgdGhlICs9IDE4OCBpbiB0aGUgZm9yIGxvb3Agd2lsbCByZXNldCBzdGFydCB0byAwXG4gICAgICAgICAgICAgIHN0YXJ0ID0gLTE4ODtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBtdFBhcnNlZCA9IHRoaXMucG10UGFyc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMTc6XG4gICAgICAgICAgY2FzZSAweDFmZmY6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdW5rbm93blBJRHMgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXIudHJpZ2dlcihFdmVudC5FUlJPUiwge3R5cGUgOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLCBpZCA6IHRoaXMuaWQsIGRldGFpbHM6IEVycm9yRGV0YWlscy5GUkFHX1BBUlNJTkdfRVJST1IsIGZhdGFsOiBmYWxzZSwgcmVhc29uOiAnVFMgcGFja2V0IGRpZCBub3Qgc3RhcnQgd2l0aCAweDQ3J30pO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyB0cnkgdG8gcGFyc2UgbGFzdCBQRVMgcGFja2V0c1xuICAgIGlmIChhdmNEYXRhICYmIChwZXMgPSBwYXJzZVBFUyhhdmNEYXRhKSkpIHtcbiAgICAgIHBhcnNlQVZDUEVTKHBlcyx0cnVlKTtcbiAgICAgIGF2Y1RyYWNrLnBlc0RhdGEgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBlaXRoZXIgYXZjRGF0YSBudWxsIG9yIFBFUyB0cnVuY2F0ZWQsIGtlZXAgaXQgZm9yIG5leHQgZnJhZyBwYXJzaW5nXG4gICAgICBhdmNUcmFjay5wZXNEYXRhID0gYXZjRGF0YTtcbiAgICB9XG5cbiAgICBpZiAoYWFjRGF0YSAmJiAocGVzID0gcGFyc2VQRVMoYWFjRGF0YSkpKSB7XG4gICAgICBwYXJzZUFBQ1BFUyhwZXMpO1xuICAgICAgYWFjVHJhY2sucGVzRGF0YSA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChhYWNEYXRhICYmIGFhY0RhdGEuc2l6ZSkge1xuICAgICAgICBsb2dnZXIubG9nKCdsYXN0IEFBQyBQRVMgcGFja2V0IHRydW5jYXRlZCxtaWdodCBvdmVybGFwIGJldHdlZW4gZnJhZ21lbnRzJyk7XG4gICAgICB9XG4gICAgIC8vIGVpdGhlciBhYWNEYXRhIG51bGwgb3IgUEVTIHRydW5jYXRlZCwga2VlcCBpdCBmb3IgbmV4dCBmcmFnIHBhcnNpbmdcbiAgICAgIGFhY1RyYWNrLnBlc0RhdGEgPSBhYWNEYXRhO1xuICAgIH1cblxuICAgIGlmIChpZDNEYXRhICYmIChwZXMgPSBwYXJzZVBFUyhpZDNEYXRhKSkpIHtcbiAgICAgIHBhcnNlSUQzUEVTKHBlcyk7XG4gICAgICBpZDNUcmFjay5wZXNEYXRhID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZWl0aGVyIGlkM0RhdGEgbnVsbCBvciBQRVMgdHJ1bmNhdGVkLCBrZWVwIGl0IGZvciBuZXh0IGZyYWcgcGFyc2luZ1xuICAgICAgaWQzVHJhY2sucGVzRGF0YSA9IGlkM0RhdGE7XG4gICAgfVxuICAgIHRoaXMucmVtdXgobGV2ZWwsc24sbnVsbCx0aW1lT2Zmc2V0KTtcbiAgfVxuXG4gIHJlbXV4KGxldmVsLCBzbiwgZGF0YSwgdGltZU9mZnNldCkge1xuICAgIGxldCBhdmNUcmFjayA9IHRoaXMuX2F2Y1RyYWNrLCBzYW1wbGVzID0gYXZjVHJhY2suc2FtcGxlcztcblxuICAgIC8vIGNvbXB1dGUgdG90YWwvYXZjIHNhbXBsZSBsZW5ndGggYW5kIG5iIG9mIE5BTCB1bml0c1xuICAgIGxldCB0cmFja0RhdGEgPSBzYW1wbGVzLnJlZHVjZShmdW5jdGlvbihwcmV2U2FtcGxlRGF0YSxjdXJTYW1wbGUpIHtcbiAgICAgIGxldCBzYW1wbGVEYXRhID0gY3VyU2FtcGxlLnVuaXRzLnVuaXRzLnJlZHVjZShmdW5jdGlvbihwcmV2VW5pdERhdGEsY3VyVW5pdCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGVuIDogcHJldlVuaXREYXRhLmxlbitjdXJVbml0LmRhdGEubGVuZ3RoLFxuICAgICAgICBuYk5hbHUgOiBwcmV2VW5pdERhdGEubmJOYWx1KzFcbiAgICAgICAgfTtcbiAgICAgIH0se2xlbiA6IDAsIG5iTmFsdSA6IDB9KTtcbiAgICAgIGN1clNhbXBsZS5sZW5ndGggPSBzYW1wbGVEYXRhLmxlbjtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxlbiA6IHByZXZTYW1wbGVEYXRhLmxlbitzYW1wbGVEYXRhLmxlbixcbiAgICAgICAgbmJOYWx1IDogcHJldlNhbXBsZURhdGEubmJOYWx1K3NhbXBsZURhdGEubmJOYWx1XG4gICAgfTt9LHtsZW4gOiAwLCBuYk5hbHUgOiAwfSk7XG4gICAgIGF2Y1RyYWNrLmxlbiA9IHRyYWNrRGF0YS5sZW47XG4gICAgIGF2Y1RyYWNrLm5iTmFsdSA9IHRyYWNrRGF0YS5uYk5hbHU7XG4gICAgdGhpcy5yZW11eGVyLnJlbXV4KGxldmVsLCBzbiwgdGhpcy5fYWFjVHJhY2ssIHRoaXMuX2F2Y1RyYWNrLCB0aGlzLl9pZDNUcmFjaywgdGhpcy5fdHh0VHJhY2ssIHRpbWVPZmZzZXQsIHRoaXMuY29udGlndW91cywgdGhpcy5hY2N1cmF0ZVRpbWVPZmZzZXQsIGRhdGEpO1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnN3aXRjaExldmVsKCk7XG4gICAgdGhpcy5faW5pdFBUUyA9IHRoaXMuX2luaXREVFMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fZHVyYXRpb24gPSAwO1xuICB9XG5cbiAgX3BhcnNlUEFUKGRhdGEsIG9mZnNldCkge1xuICAgIC8vIHNraXAgdGhlIFBTSSBoZWFkZXIgYW5kIHBhcnNlIHRoZSBmaXJzdCBQTVQgZW50cnlcbiAgICByZXR1cm4gKGRhdGFbb2Zmc2V0ICsgMTBdICYgMHgxRikgPDwgOCB8IGRhdGFbb2Zmc2V0ICsgMTFdO1xuICAgIC8vbG9nZ2VyLmxvZygnUE1UIFBJRDonICArIHRoaXMuX3BtdElkKTtcbiAgfVxuXG4gIF9wYXJzZVBNVChkYXRhLCBvZmZzZXQpIHtcbiAgICB2YXIgc2VjdGlvbkxlbmd0aCwgdGFibGVFbmQsIHByb2dyYW1JbmZvTGVuZ3RoLCBwaWQsIHJlc3VsdCA9IHsgYWFjIDogLTEsIGF2YyA6IC0xLCBpZDMgOiAtMX07XG4gICAgc2VjdGlvbkxlbmd0aCA9IChkYXRhW29mZnNldCArIDFdICYgMHgwZikgPDwgOCB8IGRhdGFbb2Zmc2V0ICsgMl07XG4gICAgdGFibGVFbmQgPSBvZmZzZXQgKyAzICsgc2VjdGlvbkxlbmd0aCAtIDQ7XG4gICAgLy8gdG8gZGV0ZXJtaW5lIHdoZXJlIHRoZSB0YWJsZSBpcywgd2UgaGF2ZSB0byBmaWd1cmUgb3V0IGhvd1xuICAgIC8vIGxvbmcgdGhlIHByb2dyYW0gaW5mbyBkZXNjcmlwdG9ycyBhcmVcbiAgICBwcm9ncmFtSW5mb0xlbmd0aCA9IChkYXRhW29mZnNldCArIDEwXSAmIDB4MGYpIDw8IDggfCBkYXRhW29mZnNldCArIDExXTtcbiAgICAvLyBhZHZhbmNlIHRoZSBvZmZzZXQgdG8gdGhlIGZpcnN0IGVudHJ5IGluIHRoZSBtYXBwaW5nIHRhYmxlXG4gICAgb2Zmc2V0ICs9IDEyICsgcHJvZ3JhbUluZm9MZW5ndGg7XG4gICAgd2hpbGUgKG9mZnNldCA8IHRhYmxlRW5kKSB7XG4gICAgICBwaWQgPSAoZGF0YVtvZmZzZXQgKyAxXSAmIDB4MUYpIDw8IDggfCBkYXRhW29mZnNldCArIDJdO1xuICAgICAgc3dpdGNoKGRhdGFbb2Zmc2V0XSkge1xuICAgICAgICAvLyBJU08vSUVDIDEzODE4LTcgQURUUyBBQUMgKE1QRUctMiBsb3dlciBiaXQtcmF0ZSBhdWRpbylcbiAgICAgICAgY2FzZSAweDBmOlxuICAgICAgICAgIC8vbG9nZ2VyLmxvZygnQUFDIFBJRDonICArIHBpZCk7XG4gICAgICAgICAgaWYgKHJlc3VsdC5hYWMgPT09IC0xKSB7XG4gICAgICAgICAgICByZXN1bHQuYWFjID0gcGlkO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gUGFja2V0aXplZCBtZXRhZGF0YSAoSUQzKVxuICAgICAgICBjYXNlIDB4MTU6XG4gICAgICAgICAgLy9sb2dnZXIubG9nKCdJRDMgUElEOicgICsgcGlkKTtcbiAgICAgICAgICBpZiAocmVzdWx0LmlkMyA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJlc3VsdC5pZDMgPSBwaWQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBJVFUtVCBSZWMuIEguMjY0IGFuZCBJU08vSUVDIDE0NDk2LTEwIChsb3dlciBiaXQtcmF0ZSB2aWRlbylcbiAgICAgICAgY2FzZSAweDFiOlxuICAgICAgICAgIC8vbG9nZ2VyLmxvZygnQVZDIFBJRDonICArIHBpZCk7XG4gICAgICAgICAgaWYgKHJlc3VsdC5hdmMgPT09IC0xKSB7XG4gICAgICAgICAgICByZXN1bHQuYXZjID0gcGlkO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAweDI0OlxuICAgICAgICAgIGxvZ2dlci53YXJuKCdIRVZDIHN0cmVhbSB0eXBlIGZvdW5kLCBub3Qgc3VwcG9ydGVkIGZvciBub3cnKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBsb2dnZXIubG9nKCd1bmtvd24gc3RyZWFtIHR5cGU6JyAgKyBkYXRhW29mZnNldF0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgLy8gbW92ZSB0byB0aGUgbmV4dCB0YWJsZSBlbnRyeVxuICAgICAgLy8gc2tpcCBwYXN0IHRoZSBlbGVtZW50YXJ5IHN0cmVhbSBkZXNjcmlwdG9ycywgaWYgcHJlc2VudFxuICAgICAgb2Zmc2V0ICs9ICgoZGF0YVtvZmZzZXQgKyAzXSAmIDB4MEYpIDw8IDggfCBkYXRhW29mZnNldCArIDRdKSArIDU7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBfcGFyc2VQRVMoc3RyZWFtKSB7XG4gICAgdmFyIGkgPSAwLCBmcmFnLCBwZXNGbGFncywgcGVzUHJlZml4LCBwZXNMZW4sIHBlc0hkckxlbiwgcGVzRGF0YSwgcGVzUHRzLCBwZXNEdHMsIHBheWxvYWRTdGFydE9mZnNldCwgZGF0YSA9IHN0cmVhbS5kYXRhO1xuICAgIC8vIHNhZmV0eSBjaGVja1xuICAgIGlmICghc3RyZWFtIHx8IHN0cmVhbS5zaXplID09PSAwKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyB3ZSBtaWdodCBuZWVkIHVwIHRvIDE5IGJ5dGVzIHRvIHJlYWQgUEVTIGhlYWRlclxuICAgIC8vIGlmIGZpcnN0IGNodW5rIG9mIGRhdGEgaXMgbGVzcyB0aGFuIDE5IGJ5dGVzLCBsZXQncyBtZXJnZSBpdCB3aXRoIGZvbGxvd2luZyBvbmVzIHVudGlsIHdlIGdldCAxOSBieXRlc1xuICAgIC8vIHVzdWFsbHkgb25seSBvbmUgbWVyZ2UgaXMgbmVlZGVkIChhbmQgdGhpcyBpcyByYXJlIC4uLilcbiAgICB3aGlsZShkYXRhWzBdLmxlbmd0aCA8IDE5ICYmIGRhdGEubGVuZ3RoID4gMSkge1xuICAgICAgbGV0IG5ld0RhdGEgPSBuZXcgVWludDhBcnJheShkYXRhWzBdLmxlbmd0aCArIGRhdGFbMV0ubGVuZ3RoKTtcbiAgICAgIG5ld0RhdGEuc2V0KGRhdGFbMF0pO1xuICAgICAgbmV3RGF0YS5zZXQoZGF0YVsxXSwgZGF0YVswXS5sZW5ndGgpO1xuICAgICAgZGF0YVswXSA9IG5ld0RhdGE7XG4gICAgICBkYXRhLnNwbGljZSgxLDEpO1xuICAgIH1cbiAgICAvL3JldHJpZXZlIFBUUy9EVFMgZnJvbSBmaXJzdCBmcmFnbWVudFxuICAgIGZyYWcgPSBkYXRhWzBdO1xuICAgIHBlc1ByZWZpeCA9IChmcmFnWzBdIDw8IDE2KSArIChmcmFnWzFdIDw8IDgpICsgZnJhZ1syXTtcbiAgICBpZiAocGVzUHJlZml4ID09PSAxKSB7XG4gICAgICBwZXNMZW4gPSAoZnJhZ1s0XSA8PCA4KSArIGZyYWdbNV07XG4gICAgICAvLyBpZiBQRVMgbGVuIGlzIG5vdCB6ZXJvIGFuZCBub3QgbWF0Y2hpbmcgd2l0aCB0b3RhbCBsZW4sIHN0b3AgcGFyc2luZy4gUEVTIG1pZ2h0IGJlIHRydW5jYXRlZFxuICAgICAgLy8gbWludXMgNiA6IFBFUyBoZWFkZXIgc2l6ZVxuICAgICAgaWYgKHBlc0xlbiAmJiBwZXNMZW4gIT09IHN0cmVhbS5zaXplIC0gNikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHBlc0ZsYWdzID0gZnJhZ1s3XTtcbiAgICAgIGlmIChwZXNGbGFncyAmIDB4QzApIHtcbiAgICAgICAgLyogUEVTIGhlYWRlciBkZXNjcmliZWQgaGVyZSA6IGh0dHA6Ly9kdmQuc291cmNlZm9yZ2UubmV0L2R2ZGluZm8vcGVzLWhkci5odG1sXG4gICAgICAgICAgICBhcyBQVFMgLyBEVFMgaXMgMzMgYml0IHdlIGNhbm5vdCB1c2UgYml0d2lzZSBvcGVyYXRvciBpbiBKUyxcbiAgICAgICAgICAgIGFzIEJpdHdpc2Ugb3BlcmF0b3JzIHRyZWF0IHRoZWlyIG9wZXJhbmRzIGFzIGEgc2VxdWVuY2Ugb2YgMzIgYml0cyAqL1xuICAgICAgICBwZXNQdHMgPSAoZnJhZ1s5XSAmIDB4MEUpICogNTM2ODcwOTEyICsvLyAxIDw8IDI5XG4gICAgICAgICAgKGZyYWdbMTBdICYgMHhGRikgKiA0MTk0MzA0ICsvLyAxIDw8IDIyXG4gICAgICAgICAgKGZyYWdbMTFdICYgMHhGRSkgKiAxNjM4NCArLy8gMSA8PCAxNFxuICAgICAgICAgIChmcmFnWzEyXSAmIDB4RkYpICogMTI4ICsvLyAxIDw8IDdcbiAgICAgICAgICAoZnJhZ1sxM10gJiAweEZFKSAvIDI7XG4gICAgICAgICAgLy8gY2hlY2sgaWYgZ3JlYXRlciB0aGFuIDJeMzIgLTFcbiAgICAgICAgICBpZiAocGVzUHRzID4gNDI5NDk2NzI5NSkge1xuICAgICAgICAgICAgLy8gZGVjcmVtZW50IDJeMzNcbiAgICAgICAgICAgIHBlc1B0cyAtPSA4NTg5OTM0NTkyO1xuICAgICAgICAgIH1cbiAgICAgICAgaWYgKHBlc0ZsYWdzICYgMHg0MCkge1xuICAgICAgICAgIHBlc0R0cyA9IChmcmFnWzE0XSAmIDB4MEUgKSAqIDUzNjg3MDkxMiArLy8gMSA8PCAyOVxuICAgICAgICAgICAgKGZyYWdbMTVdICYgMHhGRiApICogNDE5NDMwNCArLy8gMSA8PCAyMlxuICAgICAgICAgICAgKGZyYWdbMTZdICYgMHhGRSApICogMTYzODQgKy8vIDEgPDwgMTRcbiAgICAgICAgICAgIChmcmFnWzE3XSAmIDB4RkYgKSAqIDEyOCArLy8gMSA8PCA3XG4gICAgICAgICAgICAoZnJhZ1sxOF0gJiAweEZFICkgLyAyO1xuICAgICAgICAgIC8vIGNoZWNrIGlmIGdyZWF0ZXIgdGhhbiAyXjMyIC0xXG4gICAgICAgICAgaWYgKHBlc0R0cyA+IDQyOTQ5NjcyOTUpIHtcbiAgICAgICAgICAgIC8vIGRlY3JlbWVudCAyXjMzXG4gICAgICAgICAgICBwZXNEdHMgLT0gODU4OTkzNDU5MjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGVzRHRzID0gcGVzUHRzO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBwZXNIZHJMZW4gPSBmcmFnWzhdO1xuICAgICAgLy8gOSBieXRlcyA6IDYgYnl0ZXMgZm9yIFBFUyBoZWFkZXIgKyAzIGJ5dGVzIGZvciBQRVMgZXh0ZW5zaW9uXG4gICAgICBwYXlsb2FkU3RhcnRPZmZzZXQgPSBwZXNIZHJMZW4gKyA5O1xuXG4gICAgICBzdHJlYW0uc2l6ZSAtPSBwYXlsb2FkU3RhcnRPZmZzZXQ7XG4gICAgICAvL3JlYXNzZW1ibGUgUEVTIHBhY2tldFxuICAgICAgcGVzRGF0YSA9IG5ldyBVaW50OEFycmF5KHN0cmVhbS5zaXplKTtcbiAgICAgIHdoaWxlIChkYXRhLmxlbmd0aCkge1xuICAgICAgICBmcmFnID0gZGF0YS5zaGlmdCgpO1xuICAgICAgICB2YXIgbGVuID0gZnJhZy5ieXRlTGVuZ3RoO1xuICAgICAgICBpZiAocGF5bG9hZFN0YXJ0T2Zmc2V0KSB7XG4gICAgICAgICAgaWYgKHBheWxvYWRTdGFydE9mZnNldCA+IGxlbikge1xuICAgICAgICAgICAgLy8gdHJpbSBmdWxsIGZyYWcgaWYgUEVTIGhlYWRlciBiaWdnZXIgdGhhbiBmcmFnXG4gICAgICAgICAgICBwYXlsb2FkU3RhcnRPZmZzZXQtPWxlbjtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyB0cmltIHBhcnRpYWwgZnJhZyBpZiBQRVMgaGVhZGVyIHNtYWxsZXIgdGhhbiBmcmFnXG4gICAgICAgICAgICBmcmFnID0gZnJhZy5zdWJhcnJheShwYXlsb2FkU3RhcnRPZmZzZXQpO1xuICAgICAgICAgICAgbGVuLT1wYXlsb2FkU3RhcnRPZmZzZXQ7XG4gICAgICAgICAgICBwYXlsb2FkU3RhcnRPZmZzZXQgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwZXNEYXRhLnNldChmcmFnLCBpKTtcbiAgICAgICAgaSs9bGVuO1xuICAgICAgfVxuICAgICAgaWYgKHBlc0xlbikge1xuICAgICAgICAvLyBwYXlsb2FkIHNpemUgOiByZW1vdmUgUEVTIGhlYWRlciArIFBFUyBleHRlbnNpb25cbiAgICAgICAgcGVzTGVuIC09IHBlc0hkckxlbiszO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtkYXRhOiBwZXNEYXRhLCBwdHM6IHBlc1B0cywgZHRzOiBwZXNEdHMsIGxlbjogcGVzTGVufTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgcHVzaEFjY2VzVW5pdChhdmNTYW1wbGUsYXZjVHJhY2spIHtcbiAgICBpZiAoYXZjU2FtcGxlLnVuaXRzLnVuaXRzLmxlbmd0aCkge1xuICAgICAgLy8gb25seSBwdXNoIEFWQyBzYW1wbGUgaWYgc3RhcnRpbmcgd2l0aCBhIGtleWZyYW1lIGlzIG5vdCBtYW5kYXRvcnkgT1JcbiAgICAgIC8vICAgIGlmIGtleWZyYW1lIGFscmVhZHkgZm91bmQgaW4gdGhpcyBmcmFnbWVudCBPUlxuICAgICAgLy8gICAgICAga2V5ZnJhbWUgZm91bmQgaW4gbGFzdCBmcmFnbWVudCAodHJhY2suc3BzKSBBTkRcbiAgICAgIC8vICAgICAgICAgIHNhbXBsZXMgYWxyZWFkeSBhcHBlbmRlZCAod2UgYWxyZWFkeSBmb3VuZCBhIGtleWZyYW1lIGluIHRoaXMgZnJhZ21lbnQpIE9SIGZyYWdtZW50IGlzIGNvbnRpZ3VvdXNcbiAgICAgIGlmICghdGhpcy5jb25maWcuZm9yY2VLZXlGcmFtZU9uRGlzY29udGludWl0eSB8fFxuICAgICAgICAgIGF2Y1NhbXBsZS5rZXkgPT09IHRydWUgfHxcbiAgICAgICAgICAoYXZjVHJhY2suc3BzICYmIChhdmNUcmFjay5zYW1wbGVzLmxlbmd0aCB8fCB0aGlzLmNvbnRpZ3VvdXMpKSkge1xuICAgICAgICBhdmNUcmFjay5zYW1wbGVzLnB1c2goYXZjU2FtcGxlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGRyb3BwZWQgc2FtcGxlcywgdHJhY2sgaXRcbiAgICAgICAgYXZjVHJhY2suZHJvcHBlZCsrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZihhdmNTYW1wbGUuZGVidWcubGVuZ3RoKSB7XG4gICAgICBsb2dnZXIubG9nKGF2Y1NhbXBsZS5wdHMgKyAnLycgKyBhdmNTYW1wbGUuZHRzICsgJzonICsgYXZjU2FtcGxlLmRlYnVnICsgJywnICsgYXZjU2FtcGxlLnVuaXRzLmxlbmd0aCk7XG4gICAgfVxuICB9XG5cbiAgX3BhcnNlQVZDUEVTKHBlcyxsYXN0KSB7XG4gICAgLy9sb2dnZXIubG9nKCdwYXJzZSBuZXcgUEVTJyk7XG4gICAgdmFyIHRyYWNrID0gdGhpcy5fYXZjVHJhY2ssXG4gICAgICAgIHVuaXRzID0gdGhpcy5fcGFyc2VBVkNOQUx1KHBlcy5kYXRhKSxcbiAgICAgICAgZGVidWcgPSBmYWxzZSxcbiAgICAgICAgZXhwR29sb21iRGVjb2RlcixcbiAgICAgICAgYXZjU2FtcGxlID0gdGhpcy5hdmNTYW1wbGUsXG4gICAgICAgIHB1c2gsXG4gICAgICAgIGk7XG4gICAgLy9mcmVlIHBlcy5kYXRhIHRvIHNhdmUgdXAgc29tZSBtZW1vcnlcbiAgICBwZXMuZGF0YSA9IG51bGw7XG5cbiAgICB1bml0cy5mb3JFYWNoKHVuaXQgPT4ge1xuICAgICAgc3dpdGNoKHVuaXQudHlwZSkge1xuICAgICAgICAvL05EUlxuICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICBwdXNoID0gdHJ1ZTtcbiAgICAgICAgICAgaWYoZGVidWcgJiYgYXZjU2FtcGxlKSB7XG4gICAgICAgICAgICBhdmNTYW1wbGUuZGVidWcgKz0gJ05EUiAnO1xuICAgICAgICAgICB9XG4gICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvL0lEUlxuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgcHVzaCA9IHRydWU7XG4gICAgICAgICAgLy8gaGFuZGxlIFBFUyBub3Qgc3RhcnRpbmcgd2l0aCBBVURcbiAgICAgICAgICBpZiAoIWF2Y1NhbXBsZSkge1xuICAgICAgICAgICAgYXZjU2FtcGxlID0gdGhpcy5hdmNTYW1wbGUgPSB0aGlzLl9jcmVhdGVBVkNTYW1wbGUodHJ1ZSxwZXMucHRzLHBlcy5kdHMsJycpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZihkZWJ1Zykge1xuICAgICAgICAgICAgYXZjU2FtcGxlLmRlYnVnICs9ICdJRFIgJztcbiAgICAgICAgICB9XG4gICAgICAgICAgYXZjU2FtcGxlLmtleSA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vU0VJXG4gICAgICAgIGNhc2UgNjpcbiAgICAgICAgICBwdXNoID0gdHJ1ZTtcbiAgICAgICAgICBpZihkZWJ1ZyAmJiBhdmNTYW1wbGUpIHtcbiAgICAgICAgICAgIGF2Y1NhbXBsZS5kZWJ1ZyArPSAnU0VJICc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGV4cEdvbG9tYkRlY29kZXIgPSBuZXcgRXhwR29sb21iKHRoaXMuZGlzY2FyZEVQQih1bml0LmRhdGEpKTtcblxuICAgICAgICAgIC8vIHNraXAgZnJhbWVUeXBlXG4gICAgICAgICAgZXhwR29sb21iRGVjb2Rlci5yZWFkVUJ5dGUoKTtcblxuICAgICAgICAgIHZhciBwYXlsb2FkVHlwZSA9IDA7XG4gICAgICAgICAgdmFyIHBheWxvYWRTaXplID0gMDtcbiAgICAgICAgICB2YXIgZW5kT2ZDYXB0aW9ucyA9IGZhbHNlO1xuICAgICAgICAgIHZhciBiID0gMDtcblxuICAgICAgICAgIHdoaWxlICghZW5kT2ZDYXB0aW9ucyAmJiBleHBHb2xvbWJEZWNvZGVyLmJ5dGVzQXZhaWxhYmxlID4gMSkge1xuICAgICAgICAgICAgcGF5bG9hZFR5cGUgPSAwO1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIGIgPSBleHBHb2xvbWJEZWNvZGVyLnJlYWRVQnl0ZSgpO1xuICAgICAgICAgICAgICAgIHBheWxvYWRUeXBlICs9IGI7XG4gICAgICAgICAgICB9IHdoaWxlIChiID09PSAweEZGKTtcblxuICAgICAgICAgICAgLy8gUGFyc2UgcGF5bG9hZCBzaXplLlxuICAgICAgICAgICAgcGF5bG9hZFNpemUgPSAwO1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIGIgPSBleHBHb2xvbWJEZWNvZGVyLnJlYWRVQnl0ZSgpO1xuICAgICAgICAgICAgICAgIHBheWxvYWRTaXplICs9IGI7XG4gICAgICAgICAgICB9IHdoaWxlIChiID09PSAweEZGKTtcblxuICAgICAgICAgICAgLy8gVE9ETzogdGhlcmUgY2FuIGJlIG1vcmUgdGhhbiBvbmUgcGF5bG9hZCBpbiBhbiBTRUkgcGFja2V0Li4uXG4gICAgICAgICAgICAvLyBUT0RPOiBuZWVkIHRvIHJlYWQgdHlwZSBhbmQgc2l6ZSBpbiBhIHdoaWxlIGxvb3AgdG8gZ2V0IHRoZW0gYWxsXG4gICAgICAgICAgICBpZiAocGF5bG9hZFR5cGUgPT09IDQgJiYgZXhwR29sb21iRGVjb2Rlci5ieXRlc0F2YWlsYWJsZSAhPT0gMCkge1xuXG4gICAgICAgICAgICAgIGVuZE9mQ2FwdGlvbnMgPSB0cnVlO1xuXG4gICAgICAgICAgICAgIHZhciBjb3VudHJ5Q29kZSA9IGV4cEdvbG9tYkRlY29kZXIucmVhZFVCeXRlKCk7XG5cbiAgICAgICAgICAgICAgaWYgKGNvdW50cnlDb2RlID09PSAxODEpIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJvdmlkZXJDb2RlID0gZXhwR29sb21iRGVjb2Rlci5yZWFkVVNob3J0KCk7XG5cbiAgICAgICAgICAgICAgICBpZiAocHJvdmlkZXJDb2RlID09PSA0OSkge1xuICAgICAgICAgICAgICAgICAgdmFyIHVzZXJTdHJ1Y3R1cmUgPSBleHBHb2xvbWJEZWNvZGVyLnJlYWRVSW50KCk7XG5cbiAgICAgICAgICAgICAgICAgIGlmICh1c2VyU3RydWN0dXJlID09PSAweDQ3NDEzOTM0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB1c2VyRGF0YVR5cGUgPSBleHBHb2xvbWJEZWNvZGVyLnJlYWRVQnl0ZSgpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFJhdyBDRUEtNjA4IGJ5dGVzIHdyYXBwZWQgaW4gQ0VBLTcwOCBwYWNrZXRcbiAgICAgICAgICAgICAgICAgICAgaWYgKHVzZXJEYXRhVHlwZSA9PT0gMykge1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBmaXJzdEJ5dGUgPSBleHBHb2xvbWJEZWNvZGVyLnJlYWRVQnl0ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBzZWNvbmRCeXRlID0gZXhwR29sb21iRGVjb2Rlci5yZWFkVUJ5dGUoKTtcblxuICAgICAgICAgICAgICAgICAgICAgIHZhciB0b3RhbENDcyA9IDMxICYgZmlyc3RCeXRlO1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBieXRlQXJyYXkgPSBbZmlyc3RCeXRlLCBzZWNvbmRCeXRlXTtcblxuICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB0b3RhbENDczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAzIGJ5dGVzIHBlciBDQ1xuICAgICAgICAgICAgICAgICAgICAgICAgYnl0ZUFycmF5LnB1c2goZXhwR29sb21iRGVjb2Rlci5yZWFkVUJ5dGUoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBieXRlQXJyYXkucHVzaChleHBHb2xvbWJEZWNvZGVyLnJlYWRVQnl0ZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ5dGVBcnJheS5wdXNoKGV4cEdvbG9tYkRlY29kZXIucmVhZFVCeXRlKCkpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2luc2VydFNhbXBsZUluT3JkZXIodGhpcy5fdHh0VHJhY2suc2FtcGxlcywgeyB0eXBlOiAzLCBwdHM6IHBlcy5wdHMsIGJ5dGVzOiBieXRlQXJyYXkgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHBheWxvYWRTaXplIDwgZXhwR29sb21iRGVjb2Rlci5ieXRlc0F2YWlsYWJsZSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgZm9yIChpID0gMDsgaTxwYXlsb2FkU2l6ZTsgaSsrKVxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZXhwR29sb21iRGVjb2Rlci5yZWFkVUJ5dGUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgLy9TUFNcbiAgICAgICAgY2FzZSA3OlxuICAgICAgICAgIHB1c2ggPSB0cnVlO1xuICAgICAgICAgIGlmKGRlYnVnICYmIGF2Y1NhbXBsZSkge1xuICAgICAgICAgICAgYXZjU2FtcGxlLmRlYnVnICs9ICdTUFMgJztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYoIXRyYWNrLnNwcykge1xuICAgICAgICAgICAgZXhwR29sb21iRGVjb2RlciA9IG5ldyBFeHBHb2xvbWIodW5pdC5kYXRhKTtcbiAgICAgICAgICAgIHZhciBjb25maWcgPSBleHBHb2xvbWJEZWNvZGVyLnJlYWRTUFMoKTtcbiAgICAgICAgICAgIHRyYWNrLndpZHRoID0gY29uZmlnLndpZHRoO1xuICAgICAgICAgICAgdHJhY2suaGVpZ2h0ID0gY29uZmlnLmhlaWdodDtcbiAgICAgICAgICAgIHRyYWNrLnNwcyA9IFt1bml0LmRhdGFdO1xuICAgICAgICAgICAgdHJhY2suZHVyYXRpb24gPSB0aGlzLl9kdXJhdGlvbjtcbiAgICAgICAgICAgIHZhciBjb2RlY2FycmF5ID0gdW5pdC5kYXRhLnN1YmFycmF5KDEsIDQpO1xuICAgICAgICAgICAgdmFyIGNvZGVjc3RyaW5nID0gJ2F2YzEuJztcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFyIGggPSBjb2RlY2FycmF5W2ldLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgICAgICAgaWYgKGgubGVuZ3RoIDwgMikge1xuICAgICAgICAgICAgICAgIGggPSAnMCcgKyBoO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvZGVjc3RyaW5nICs9IGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmFjay5jb2RlYyA9IGNvZGVjc3RyaW5nO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgLy9QUFNcbiAgICAgICAgY2FzZSA4OlxuICAgICAgICAgIHB1c2ggPSB0cnVlO1xuICAgICAgICAgIGlmKGRlYnVnICYmIGF2Y1NhbXBsZSkge1xuICAgICAgICAgICAgYXZjU2FtcGxlLmRlYnVnICs9ICdQUFMgJztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCF0cmFjay5wcHMpIHtcbiAgICAgICAgICAgIHRyYWNrLnBwcyA9IFt1bml0LmRhdGFdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gQVVEXG4gICAgICAgIGNhc2UgOTpcbiAgICAgICAgICBwdXNoID0gZmFsc2U7XG4gICAgICAgICAgaWYgKGF2Y1NhbXBsZSkge1xuICAgICAgICAgICAgdGhpcy5wdXNoQWNjZXNVbml0KGF2Y1NhbXBsZSx0cmFjayk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGF2Y1NhbXBsZSA9IHRoaXMuYXZjU2FtcGxlID0gdGhpcy5fY3JlYXRlQVZDU2FtcGxlKGZhbHNlLHBlcy5wdHMscGVzLmR0cyxkZWJ1ZyA/ICdBVUQgJzogJycpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBGaWxsZXIgRGF0YVxuICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgIHB1c2ggPSBmYWxzZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBwdXNoID0gZmFsc2U7XG4gICAgICAgICAgaWYgKGF2Y1NhbXBsZSkge1xuICAgICAgICAgICAgYXZjU2FtcGxlLmRlYnVnICs9ICd1bmtub3duIE5BTCAnICsgdW5pdC50eXBlICsgJyAnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmKGF2Y1NhbXBsZSAmJiBwdXNoKSB7XG4gICAgICAgIGxldCB1bml0cyA9IGF2Y1NhbXBsZS51bml0cztcbiAgICAgICAgdW5pdHMudW5pdHMucHVzaCh1bml0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICAvLyBpZiBsYXN0IFBFUyBwYWNrZXQsIHB1c2ggc2FtcGxlc1xuICAgIGlmIChsYXN0ICYmIGF2Y1NhbXBsZSkge1xuICAgICAgdGhpcy5wdXNoQWNjZXNVbml0KGF2Y1NhbXBsZSx0cmFjayk7XG4gICAgICB0aGlzLmF2Y1NhbXBsZSA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgX2NyZWF0ZUFWQ1NhbXBsZShrZXkscHRzLGR0cyxkZWJ1Zykge1xuICAgIHJldHVybiB7IGtleSA6IGtleSwgcHRzIDogcHRzLCBkdHMgOiBkdHMsIHVuaXRzIDogeyB1bml0cyA6IFtdLCBsZW5ndGggOiAwfSwgZGVidWcgOiBkZWJ1Z307XG4gIH1cblxuICBfaW5zZXJ0U2FtcGxlSW5PcmRlcihhcnIsIGRhdGEpIHtcbiAgICB2YXIgbGVuID0gYXJyLmxlbmd0aDtcbiAgICBpZiAobGVuID4gMCkge1xuICAgICAgaWYgKGRhdGEucHRzID49IGFycltsZW4tMV0ucHRzKVxuICAgICAge1xuICAgICAgICBhcnIucHVzaChkYXRhKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBmb3IgKHZhciBwb3MgPSBsZW4gLSAxOyBwb3MgPj0gMDsgcG9zLS0pIHtcbiAgICAgICAgICBpZiAoZGF0YS5wdHMgPCBhcnJbcG9zXS5wdHMpIHtcbiAgICAgICAgICAgIGFyci5zcGxpY2UocG9zLCAwLCBkYXRhKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGFyci5wdXNoKGRhdGEpO1xuICAgIH1cbiAgfVxuXG4gIF9nZXRMYXN0TmFsVW5pdCgpIHtcbiAgICBsZXQgYXZjU2FtcGxlID0gdGhpcy5hdmNTYW1wbGUsIGxhc3RVbml0O1xuICAgIC8vIHRyeSB0byBmYWxsYmFjayB0byBwcmV2aW91cyBzYW1wbGUgaWYgY3VycmVudCBvbmUgaXMgZW1wdHlcbiAgICBpZiAoIWF2Y1NhbXBsZSB8fCBhdmNTYW1wbGUudW5pdHMudW5pdHMubGVuZ3RoID09PSAwKSB7XG4gICAgICBsZXQgdHJhY2sgPSB0aGlzLl9hdmNUcmFjaywgc2FtcGxlcyA9IHRyYWNrLnNhbXBsZXM7XG4gICAgICBhdmNTYW1wbGUgPSBzYW1wbGVzW3NhbXBsZXMubGVuZ3RoLTFdO1xuICAgIH1cbiAgICBpZiAoYXZjU2FtcGxlKSB7XG4gICAgICBsZXQgdW5pdHMgPSBhdmNTYW1wbGUudW5pdHMudW5pdHM7XG4gICAgICBsYXN0VW5pdCA9IHVuaXRzW3VuaXRzLmxlbmd0aCAtIDFdO1xuICAgIH1cbiAgICByZXR1cm4gbGFzdFVuaXQ7XG4gIH1cblxuICBfcGFyc2VBVkNOQUx1KGFycmF5KSB7XG4gICAgdmFyIGkgPSAwLCBsZW4gPSBhcnJheS5ieXRlTGVuZ3RoLCB2YWx1ZSwgb3ZlcmZsb3csIHRyYWNrID0gdGhpcy5fYXZjVHJhY2ssIHN0YXRlID0gdHJhY2submFsdVN0YXRlIHx8IDAsIGxhc3RTdGF0ZSA9IHN0YXRlO1xuICAgIHZhciB1bml0cyA9IFtdLCB1bml0LCB1bml0VHlwZSwgbGFzdFVuaXRTdGFydCA9IC0xLCBsYXN0VW5pdFR5cGU7XG4gICAgLy9sb2dnZXIubG9nKCdQRVM6JyArIEhleC5oZXhEdW1wKGFycmF5KSk7XG4gICAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICAgIHZhbHVlID0gYXJyYXlbaSsrXTtcbiAgICAgIC8vIGZpbmRpbmcgMyBvciA0LWJ5dGUgc3RhcnQgY29kZXMgKDAwIDAwIDAxIE9SIDAwIDAwIDAwIDAxKVxuICAgICAgc3dpdGNoIChzdGF0ZSkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgaWYgKHZhbHVlID09PSAwKSB7XG4gICAgICAgICAgICBzdGF0ZSA9IDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgaWYoIHZhbHVlID09PSAwKSB7XG4gICAgICAgICAgICBzdGF0ZSA9IDI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0YXRlID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIGlmKCB2YWx1ZSA9PT0gMCkge1xuICAgICAgICAgICAgc3RhdGUgPSAzO1xuICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT09IDEpIHtcbiAgICAgICAgICAgIGlmIChsYXN0VW5pdFN0YXJ0ID49MCkge1xuICAgICAgICAgICAgICB1bml0ID0ge2RhdGE6IGFycmF5LnN1YmFycmF5KGxhc3RVbml0U3RhcnQsIGkgLSBzdGF0ZSAtIDEpLCB0eXBlOiBsYXN0VW5pdFR5cGV9O1xuICAgICAgICAgICAgICAvL2xvZ2dlci5sb2coJ3B1c2hpbmcgTkFMVSwgdHlwZS9zaXplOicgKyB1bml0LnR5cGUgKyAnLycgKyB1bml0LmRhdGEuYnl0ZUxlbmd0aCk7XG4gICAgICAgICAgICAgIHVuaXRzLnB1c2godW5pdCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBsYXN0VW5pdFN0YXJ0IGlzIHVuZGVmaW5lZCA9PiB0aGlzIGlzIHRoZSBmaXJzdCBzdGFydCBjb2RlIGZvdW5kIGluIHRoaXMgUEVTIHBhY2tldFxuICAgICAgICAgICAgICAvLyBmaXJzdCBjaGVjayBpZiBzdGFydCBjb2RlIGRlbGltaXRlciBpcyBvdmVybGFwcGluZyBiZXR3ZWVuIDIgUEVTIHBhY2tldHMsXG4gICAgICAgICAgICAgIC8vIGllIGl0IHN0YXJ0ZWQgaW4gbGFzdCBwYWNrZXQgKGxhc3RTdGF0ZSBub3QgemVybylcbiAgICAgICAgICAgICAgLy8gYW5kIGVuZGVkIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhpcyBQRVMgcGFja2V0IChpIDw9IDQgLSBsYXN0U3RhdGUpXG4gICAgICAgICAgICAgIGxldCBsYXN0VW5pdCA9IHRoaXMuX2dldExhc3ROYWxVbml0KCk7XG4gICAgICAgICAgICAgIGlmIChsYXN0VW5pdCkge1xuICAgICAgICAgICAgICAgIGlmKGxhc3RTdGF0ZSAmJiAgKGkgPD0gNCAtIGxhc3RTdGF0ZSkpIHtcbiAgICAgICAgICAgICAgICAgIC8vIHN0YXJ0IGRlbGltaXRlciBvdmVybGFwcGluZyBiZXR3ZWVuIFBFUyBwYWNrZXRzXG4gICAgICAgICAgICAgICAgICAvLyBzdHJpcCBzdGFydCBkZWxpbWl0ZXIgYnl0ZXMgZnJvbSB0aGUgZW5kIG9mIGxhc3QgTkFMIHVuaXRcbiAgICAgICAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgbGFzdFVuaXQgaGFkIGEgc3RhdGUgZGlmZmVyZW50IGZyb20gemVyb1xuICAgICAgICAgICAgICAgICAgaWYgKGxhc3RVbml0LnN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHN0cmlwIGxhc3QgYnl0ZXNcbiAgICAgICAgICAgICAgICAgICAgbGFzdFVuaXQuZGF0YSA9IGxhc3RVbml0LmRhdGEuc3ViYXJyYXkoMCxsYXN0VW5pdC5kYXRhLmJ5dGVMZW5ndGggLSBsYXN0U3RhdGUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBJZiBOQUwgdW5pdHMgYXJlIG5vdCBzdGFydGluZyByaWdodCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBQRVMgcGFja2V0LCBwdXNoIHByZWNlZGluZyBkYXRhIGludG8gcHJldmlvdXMgTkFMIHVuaXQuXG4gICAgICAgICAgICAgICAgb3ZlcmZsb3cgID0gaSAtIHN0YXRlIC0gMTtcbiAgICAgICAgICAgICAgICBpZiAob3ZlcmZsb3cgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAvL2xvZ2dlci5sb2coJ2ZpcnN0IE5BTFUgZm91bmQgd2l0aCBvdmVyZmxvdzonICsgb3ZlcmZsb3cpO1xuICAgICAgICAgICAgICAgICAgbGV0IHRtcCA9IG5ldyBVaW50OEFycmF5KGxhc3RVbml0LmRhdGEuYnl0ZUxlbmd0aCArIG92ZXJmbG93KTtcbiAgICAgICAgICAgICAgICAgIHRtcC5zZXQobGFzdFVuaXQuZGF0YSwgMCk7XG4gICAgICAgICAgICAgICAgICB0bXAuc2V0KGFycmF5LnN1YmFycmF5KDAsIG92ZXJmbG93KSwgbGFzdFVuaXQuZGF0YS5ieXRlTGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgIGxhc3RVbml0LmRhdGEgPSB0bXA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjaGVjayBpZiB3ZSBjYW4gcmVhZCB1bml0IHR5cGVcbiAgICAgICAgICAgIGlmIChpIDwgbGVuKSB7XG4gICAgICAgICAgICAgIHVuaXRUeXBlID0gYXJyYXlbaV0gJiAweDFmO1xuICAgICAgICAgICAgICAvL2xvZ2dlci5sb2coJ2ZpbmQgTkFMVSBAIG9mZnNldDonICsgaSArICcsdHlwZTonICsgdW5pdFR5cGUpO1xuICAgICAgICAgICAgICBsYXN0VW5pdFN0YXJ0ID0gaTtcbiAgICAgICAgICAgICAgbGFzdFVuaXRUeXBlID0gdW5pdFR5cGU7XG4gICAgICAgICAgICAgIHN0YXRlID0gMDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIG5vdCBlbm91Z2ggYnl0ZSB0byByZWFkIHVuaXQgdHlwZS4gbGV0J3MgcmVhZCBpdCBvbiBuZXh0IFBFUyBwYXJzaW5nXG4gICAgICAgICAgICAgIHN0YXRlID0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0YXRlID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgLTE6XG4gICAgICAgIC8vIHNwZWNpYWwgdXNlIGNhc2Ugd2hlcmUgd2UgZm91bmQgMyBvciA0LWJ5dGUgc3RhcnQgY29kZXMgZXhhY3RseSBhdCB0aGUgZW5kIG9mIHByZXZpb3VzIFBFUyBwYWNrZXRcbiAgICAgICAgICBsYXN0VW5pdFN0YXJ0ID0gMDtcbiAgICAgICAgICAvLyBOQUx1IHR5cGUgaXMgdmFsdWUgcmVhZCBmcm9tIG9mZnNldCAwXG4gICAgICAgICAgbGFzdFVuaXRUeXBlID0gdmFsdWUgJiAweDFmO1xuICAgICAgICAgIHN0YXRlID0gMDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGxhc3RVbml0U3RhcnQgPj0wICYmIHN0YXRlID49MCkge1xuICAgICAgdW5pdCA9IHtkYXRhOiBhcnJheS5zdWJhcnJheShsYXN0VW5pdFN0YXJ0LCBsZW4pLCB0eXBlOiBsYXN0VW5pdFR5cGUsIHN0YXRlIDogc3RhdGV9O1xuICAgICAgdW5pdHMucHVzaCh1bml0KTtcbiAgICAgIC8vbG9nZ2VyLmxvZygncHVzaGluZyBOQUxVLCB0eXBlL3NpemUvc3RhdGU6JyArIHVuaXQudHlwZSArICcvJyArIHVuaXQuZGF0YS5ieXRlTGVuZ3RoICsgJy8nICsgc3RhdGUpO1xuICAgIH1cbiAgICAvLyBubyBOQUx1IGZvdW5kXG4gICAgaWYgKHVuaXRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgLy8gYXBwZW5kIHBlcy5kYXRhIHRvIHByZXZpb3VzIE5BTCB1bml0XG4gICAgICBsZXQgIGxhc3RVbml0ID0gdGhpcy5fZ2V0TGFzdE5hbFVuaXQoKTtcbiAgICAgIGlmIChsYXN0VW5pdCkge1xuICAgICAgICBsZXQgdG1wID0gbmV3IFVpbnQ4QXJyYXkobGFzdFVuaXQuZGF0YS5ieXRlTGVuZ3RoICsgYXJyYXkuYnl0ZUxlbmd0aCk7XG4gICAgICAgIHRtcC5zZXQobGFzdFVuaXQuZGF0YSwgMCk7XG4gICAgICAgIHRtcC5zZXQoYXJyYXksIGxhc3RVbml0LmRhdGEuYnl0ZUxlbmd0aCk7XG4gICAgICAgIGxhc3RVbml0LmRhdGEgPSB0bXA7XG4gICAgICB9XG4gICAgfVxuICAgIHRyYWNrLm5hbHVTdGF0ZSA9IHN0YXRlO1xuICAgIHJldHVybiB1bml0cztcbiAgfVxuXG4gIC8qKlxuICAgKiByZW1vdmUgRW11bGF0aW9uIFByZXZlbnRpb24gYnl0ZXMgZnJvbSBhIFJCU1BcbiAgICovXG4gIGRpc2NhcmRFUEIoZGF0YSkge1xuICAgIHZhciBsZW5ndGggPSBkYXRhLmJ5dGVMZW5ndGgsXG4gICAgICAgIEVQQlBvc2l0aW9ucyA9IFtdLFxuICAgICAgICBpID0gMSxcbiAgICAgICAgbmV3TGVuZ3RoLCBuZXdEYXRhO1xuXG4gICAgLy8gRmluZCBhbGwgYEVtdWxhdGlvbiBQcmV2ZW50aW9uIEJ5dGVzYFxuICAgIHdoaWxlIChpIDwgbGVuZ3RoIC0gMikge1xuICAgICAgaWYgKGRhdGFbaV0gPT09IDAgJiZcbiAgICAgICAgICBkYXRhW2kgKyAxXSA9PT0gMCAmJlxuICAgICAgICAgIGRhdGFbaSArIDJdID09PSAweDAzKSB7XG4gICAgICAgIEVQQlBvc2l0aW9ucy5wdXNoKGkgKyAyKTtcbiAgICAgICAgaSArPSAyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaSsrO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIG5vIEVtdWxhdGlvbiBQcmV2ZW50aW9uIEJ5dGVzIHdlcmUgZm91bmQganVzdCByZXR1cm4gdGhlIG9yaWdpbmFsXG4gICAgLy8gYXJyYXlcbiAgICBpZiAoRVBCUG9zaXRpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlIGEgbmV3IGFycmF5IHRvIGhvbGQgdGhlIE5BTCB1bml0IGRhdGFcbiAgICBuZXdMZW5ndGggPSBsZW5ndGggLSBFUEJQb3NpdGlvbnMubGVuZ3RoO1xuICAgIG5ld0RhdGEgPSBuZXcgVWludDhBcnJheShuZXdMZW5ndGgpO1xuICAgIHZhciBzb3VyY2VJbmRleCA9IDA7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbmV3TGVuZ3RoOyBzb3VyY2VJbmRleCsrLCBpKyspIHtcbiAgICAgIGlmIChzb3VyY2VJbmRleCA9PT0gRVBCUG9zaXRpb25zWzBdKSB7XG4gICAgICAgIC8vIFNraXAgdGhpcyBieXRlXG4gICAgICAgIHNvdXJjZUluZGV4Kys7XG4gICAgICAgIC8vIFJlbW92ZSB0aGlzIHBvc2l0aW9uIGluZGV4XG4gICAgICAgIEVQQlBvc2l0aW9ucy5zaGlmdCgpO1xuICAgICAgfVxuICAgICAgbmV3RGF0YVtpXSA9IGRhdGFbc291cmNlSW5kZXhdO1xuICAgIH1cbiAgICByZXR1cm4gbmV3RGF0YTtcbiAgfVxuXG4gIF9wYXJzZUFBQ1BFUyhwZXMpIHtcbiAgICB2YXIgdHJhY2sgPSB0aGlzLl9hYWNUcmFjayxcbiAgICAgICAgZGF0YSA9IHBlcy5kYXRhLFxuICAgICAgICBwdHMgPSBwZXMucHRzLFxuICAgICAgICBzdGFydE9mZnNldCA9IDAsXG4gICAgICAgIGFhY092ZXJGbG93ID0gdGhpcy5hYWNPdmVyRmxvdyxcbiAgICAgICAgYWFjTGFzdFBUUyA9IHRoaXMuYWFjTGFzdFBUUyxcbiAgICAgICAgY29uZmlnLCBmcmFtZUxlbmd0aCwgZnJhbWVEdXJhdGlvbiwgZnJhbWVJbmRleCwgb2Zmc2V0LCBoZWFkZXJMZW5ndGgsIHN0YW1wLCBsZW4sIGFhY1NhbXBsZTtcbiAgICBpZiAoYWFjT3ZlckZsb3cpIHtcbiAgICAgIHZhciB0bXAgPSBuZXcgVWludDhBcnJheShhYWNPdmVyRmxvdy5ieXRlTGVuZ3RoICsgZGF0YS5ieXRlTGVuZ3RoKTtcbiAgICAgIHRtcC5zZXQoYWFjT3ZlckZsb3csIDApO1xuICAgICAgdG1wLnNldChkYXRhLCBhYWNPdmVyRmxvdy5ieXRlTGVuZ3RoKTtcbiAgICAgIC8vbG9nZ2VyLmxvZyhgQUFDOiBhcHBlbmQgb3ZlcmZsb3dpbmcgJHthYWNPdmVyRmxvdy5ieXRlTGVuZ3RofSBieXRlcyB0byBiZWdpbm5pbmcgb2YgbmV3IFBFU2ApO1xuICAgICAgZGF0YSA9IHRtcDtcbiAgICB9XG4gICAgLy8gbG9vayBmb3IgQURUUyBoZWFkZXIgKDB4RkZGeClcbiAgICBmb3IgKG9mZnNldCA9IHN0YXJ0T2Zmc2V0LCBsZW4gPSBkYXRhLmxlbmd0aDsgb2Zmc2V0IDwgbGVuIC0gMTsgb2Zmc2V0KyspIHtcbiAgICAgIGlmICgoZGF0YVtvZmZzZXRdID09PSAweGZmKSAmJiAoZGF0YVtvZmZzZXQrMV0gJiAweGYwKSA9PT0gMHhmMCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gaWYgQURUUyBoZWFkZXIgZG9lcyBub3Qgc3RhcnQgc3RyYWlnaHQgZnJvbSB0aGUgYmVnaW5uaW5nIG9mIHRoZSBQRVMgcGF5bG9hZCwgcmFpc2UgYW4gZXJyb3JcbiAgICBpZiAob2Zmc2V0KSB7XG4gICAgICB2YXIgcmVhc29uLCBmYXRhbDtcbiAgICAgIGlmIChvZmZzZXQgPCBsZW4gLSAxKSB7XG4gICAgICAgIHJlYXNvbiA9IGBBQUMgUEVTIGRpZCBub3Qgc3RhcnQgd2l0aCBBRFRTIGhlYWRlcixvZmZzZXQ6JHtvZmZzZXR9YDtcbiAgICAgICAgZmF0YWwgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlYXNvbiA9ICdubyBBRFRTIGhlYWRlciBmb3VuZCBpbiBBQUMgUEVTJztcbiAgICAgICAgZmF0YWwgPSB0cnVlO1xuICAgICAgfVxuICAgICAgbG9nZ2VyLndhcm4oYHBhcnNpbmcgZXJyb3I6JHtyZWFzb259YCk7XG4gICAgICB0aGlzLm9ic2VydmVyLnRyaWdnZXIoRXZlbnQuRVJST1IsIHt0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLCBpZCA6IHRoaXMuaWQsIGRldGFpbHM6IEVycm9yRGV0YWlscy5GUkFHX1BBUlNJTkdfRVJST1IsIGZhdGFsOiBmYXRhbCwgcmVhc29uOiByZWFzb259KTtcbiAgICAgIGlmIChmYXRhbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghdHJhY2suYXVkaW9zYW1wbGVyYXRlKSB7XG4gICAgICBjb25maWcgPSBBRFRTLmdldEF1ZGlvQ29uZmlnKHRoaXMub2JzZXJ2ZXIsZGF0YSwgb2Zmc2V0LCB0aGlzLmF1ZGlvQ29kZWMpO1xuICAgICAgdHJhY2suY29uZmlnID0gY29uZmlnLmNvbmZpZztcbiAgICAgIHRyYWNrLmF1ZGlvc2FtcGxlcmF0ZSA9IGNvbmZpZy5zYW1wbGVyYXRlO1xuICAgICAgdHJhY2suY2hhbm5lbENvdW50ID0gY29uZmlnLmNoYW5uZWxDb3VudDtcbiAgICAgIHRyYWNrLmNvZGVjID0gY29uZmlnLmNvZGVjO1xuICAgICAgdHJhY2suZHVyYXRpb24gPSB0aGlzLl9kdXJhdGlvbjtcbiAgICAgIGxvZ2dlci5sb2coYHBhcnNlZCBjb2RlYzoke3RyYWNrLmNvZGVjfSxyYXRlOiR7Y29uZmlnLnNhbXBsZXJhdGV9LG5iIGNoYW5uZWw6JHtjb25maWcuY2hhbm5lbENvdW50fWApO1xuICAgIH1cbiAgICBmcmFtZUluZGV4ID0gMDtcbiAgICBmcmFtZUR1cmF0aW9uID0gMTAyNCAqIDkwMDAwIC8gdHJhY2suYXVkaW9zYW1wbGVyYXRlO1xuXG4gICAgLy8gaWYgbGFzdCBBQUMgZnJhbWUgaXMgb3ZlcmZsb3dpbmcsIHdlIHNob3VsZCBlbnN1cmUgdGltZXN0YW1wcyBhcmUgY29udGlndW91czpcbiAgICAvLyBmaXJzdCBzYW1wbGUgUFRTIHNob3VsZCBiZSBlcXVhbCB0byBsYXN0IHNhbXBsZSBQVFMgKyBmcmFtZUR1cmF0aW9uXG4gICAgaWYoYWFjT3ZlckZsb3cgJiYgYWFjTGFzdFBUUykge1xuICAgICAgdmFyIG5ld1BUUyA9IGFhY0xhc3RQVFMrZnJhbWVEdXJhdGlvbjtcbiAgICAgIGlmKE1hdGguYWJzKG5ld1BUUy1wdHMpID4gMSkge1xuICAgICAgICBsb2dnZXIubG9nKGBBQUM6IGFsaWduIFBUUyBmb3Igb3ZlcmxhcHBpbmcgZnJhbWVzIGJ5ICR7TWF0aC5yb3VuZCgobmV3UFRTLXB0cykvOTApfWApO1xuICAgICAgICBwdHM9bmV3UFRTO1xuICAgICAgfVxuICAgIH1cblxuICAgIHdoaWxlICgob2Zmc2V0ICsgNSkgPCBsZW4pIHtcbiAgICAgIC8vIFRoZSBwcm90ZWN0aW9uIHNraXAgYml0IHRlbGxzIHVzIGlmIHdlIGhhdmUgMiBieXRlcyBvZiBDUkMgZGF0YSBhdCB0aGUgZW5kIG9mIHRoZSBBRFRTIGhlYWRlclxuICAgICAgaGVhZGVyTGVuZ3RoID0gKCEhKGRhdGFbb2Zmc2V0ICsgMV0gJiAweDAxKSA/IDcgOiA5KTtcbiAgICAgIC8vIHJldHJpZXZlIGZyYW1lIHNpemVcbiAgICAgIGZyYW1lTGVuZ3RoID0gKChkYXRhW29mZnNldCArIDNdICYgMHgwMykgPDwgMTEpIHxcbiAgICAgICAgICAgICAgICAgICAgIChkYXRhW29mZnNldCArIDRdIDw8IDMpIHxcbiAgICAgICAgICAgICAgICAgICAgKChkYXRhW29mZnNldCArIDVdICYgMHhFMCkgPj4+IDUpO1xuICAgICAgZnJhbWVMZW5ndGggIC09IGhlYWRlckxlbmd0aDtcbiAgICAgIC8vc3RhbXAgPSBwZXMucHRzO1xuXG4gICAgICBpZiAoKGZyYW1lTGVuZ3RoID4gMCkgJiYgKChvZmZzZXQgKyBoZWFkZXJMZW5ndGggKyBmcmFtZUxlbmd0aCkgPD0gbGVuKSkge1xuICAgICAgICBzdGFtcCA9IHB0cyArIGZyYW1lSW5kZXggKiBmcmFtZUR1cmF0aW9uO1xuICAgICAgICAvL2xvZ2dlci5sb2coYEFBQyBmcmFtZSwgb2Zmc2V0L2xlbmd0aC90b3RhbC9wdHM6JHtvZmZzZXQraGVhZGVyTGVuZ3RofS8ke2ZyYW1lTGVuZ3RofS8ke2RhdGEuYnl0ZUxlbmd0aH0vJHsoc3RhbXAvOTApLnRvRml4ZWQoMCl9YCk7XG4gICAgICAgIGFhY1NhbXBsZSA9IHt1bml0OiBkYXRhLnN1YmFycmF5KG9mZnNldCArIGhlYWRlckxlbmd0aCwgb2Zmc2V0ICsgaGVhZGVyTGVuZ3RoICsgZnJhbWVMZW5ndGgpLCBwdHM6IHN0YW1wLCBkdHM6IHN0YW1wfTtcbiAgICAgICAgdHJhY2suc2FtcGxlcy5wdXNoKGFhY1NhbXBsZSk7XG4gICAgICAgIHRyYWNrLmxlbiArPSBmcmFtZUxlbmd0aDtcbiAgICAgICAgb2Zmc2V0ICs9IGZyYW1lTGVuZ3RoICsgaGVhZGVyTGVuZ3RoO1xuICAgICAgICBmcmFtZUluZGV4Kys7XG4gICAgICAgIC8vIGxvb2sgZm9yIEFEVFMgaGVhZGVyICgweEZGRngpXG4gICAgICAgIGZvciAoIDsgb2Zmc2V0IDwgKGxlbiAtIDEpOyBvZmZzZXQrKykge1xuICAgICAgICAgIGlmICgoZGF0YVtvZmZzZXRdID09PSAweGZmKSAmJiAoKGRhdGFbb2Zmc2V0ICsgMV0gJiAweGYwKSA9PT0gMHhmMCkpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvZmZzZXQgPCBsZW4pIHtcbiAgICAgIGFhY092ZXJGbG93ID0gZGF0YS5zdWJhcnJheShvZmZzZXQsIGxlbik7XG4gICAgICAvL2xvZ2dlci5sb2coYEFBQzogb3ZlcmZsb3cgZGV0ZWN0ZWQ6JHtsZW4tb2Zmc2V0fWApO1xuICAgIH0gZWxzZSB7XG4gICAgICBhYWNPdmVyRmxvdyA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMuYWFjT3ZlckZsb3cgPSBhYWNPdmVyRmxvdztcbiAgICB0aGlzLmFhY0xhc3RQVFMgPSBzdGFtcDtcbiAgfVxuXG4gIF9wYXJzZUlEM1BFUyhwZXMpIHtcbiAgICB0aGlzLl9pZDNUcmFjay5zYW1wbGVzLnB1c2gocGVzKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBUU0RlbXV4ZXI7XG4iLCJleHBvcnQgY29uc3QgRXJyb3JUeXBlcyA9IHtcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBuZXR3b3JrIGVycm9yIChsb2FkaW5nIGVycm9yIC8gdGltZW91dCAuLi4pXG4gIE5FVFdPUktfRVJST1I6ICduZXR3b3JrRXJyb3InLFxuICAvLyBJZGVudGlmaWVyIGZvciBhIG1lZGlhIEVycm9yICh2aWRlby9wYXJzaW5nL21lZGlhc291cmNlIGVycm9yKVxuICBNRURJQV9FUlJPUjogJ21lZGlhRXJyb3InLFxuICAvLyBJZGVudGlmaWVyIGZvciBhbGwgb3RoZXIgZXJyb3JzXG4gIE9USEVSX0VSUk9SOiAnb3RoZXJFcnJvcidcbn07XG5cbmV4cG9ydCBjb25zdCBFcnJvckRldGFpbHMgPSB7XG4gIC8vIElkZW50aWZpZXIgZm9yIGEgbWFuaWZlc3QgbG9hZCBlcnJvciAtIGRhdGE6IHsgdXJsIDogZmF1bHR5IFVSTCwgcmVzcG9uc2UgOiB7IGNvZGU6IGVycm9yIGNvZGUsIHRleHQ6IGVycm9yIHRleHQgfX1cbiAgTUFOSUZFU1RfTE9BRF9FUlJPUjogJ21hbmlmZXN0TG9hZEVycm9yJyxcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBtYW5pZmVzdCBsb2FkIHRpbWVvdXQgLSBkYXRhOiB7IHVybCA6IGZhdWx0eSBVUkwsIHJlc3BvbnNlIDogeyBjb2RlOiBlcnJvciBjb2RlLCB0ZXh0OiBlcnJvciB0ZXh0IH19XG4gIE1BTklGRVNUX0xPQURfVElNRU9VVDogJ21hbmlmZXN0TG9hZFRpbWVPdXQnLFxuICAvLyBJZGVudGlmaWVyIGZvciBhIG1hbmlmZXN0IHBhcnNpbmcgZXJyb3IgLSBkYXRhOiB7IHVybCA6IGZhdWx0eSBVUkwsIHJlYXNvbiA6IGVycm9yIHJlYXNvbn1cbiAgTUFOSUZFU1RfUEFSU0lOR19FUlJPUjogJ21hbmlmZXN0UGFyc2luZ0Vycm9yJyxcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBtYW5pZmVzdCB3aXRoIG9ubHkgaW5jb21wYXRpYmxlIGNvZGVjcyBlcnJvciAtIGRhdGE6IHsgdXJsIDogZmF1bHR5IFVSTCwgcmVhc29uIDogZXJyb3IgcmVhc29ufVxuICBNQU5JRkVTVF9JTkNPTVBBVElCTEVfQ09ERUNTX0VSUk9SOiAnbWFuaWZlc3RJbmNvbXBhdGlibGVDb2RlY3NFcnJvcicsXG4gIC8vIElkZW50aWZpZXIgZm9yIGEgbGV2ZWwgbG9hZCBlcnJvciAtIGRhdGE6IHsgdXJsIDogZmF1bHR5IFVSTCwgcmVzcG9uc2UgOiB7IGNvZGU6IGVycm9yIGNvZGUsIHRleHQ6IGVycm9yIHRleHQgfX1cbiAgTEVWRUxfTE9BRF9FUlJPUjogJ2xldmVsTG9hZEVycm9yJyxcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBsZXZlbCBsb2FkIHRpbWVvdXQgLSBkYXRhOiB7IHVybCA6IGZhdWx0eSBVUkwsIHJlc3BvbnNlIDogeyBjb2RlOiBlcnJvciBjb2RlLCB0ZXh0OiBlcnJvciB0ZXh0IH19XG4gIExFVkVMX0xPQURfVElNRU9VVDogJ2xldmVsTG9hZFRpbWVPdXQnLFxuICAvLyBJZGVudGlmaWVyIGZvciBhIGxldmVsIHN3aXRjaCBlcnJvciAtIGRhdGE6IHsgbGV2ZWwgOiBmYXVsdHkgbGV2ZWwgSWQsIGV2ZW50IDogZXJyb3IgZGVzY3JpcHRpb259XG4gIExFVkVMX1NXSVRDSF9FUlJPUjogJ2xldmVsU3dpdGNoRXJyb3InLFxuICAvLyBJZGVudGlmaWVyIGZvciBhbiBhdWRpbyB0cmFjayBsb2FkIGVycm9yIC0gZGF0YTogeyB1cmwgOiBmYXVsdHkgVVJMLCByZXNwb25zZSA6IHsgY29kZTogZXJyb3IgY29kZSwgdGV4dDogZXJyb3IgdGV4dCB9fVxuICBBVURJT19UUkFDS19MT0FEX0VSUk9SOiAnYXVkaW9UcmFja0xvYWRFcnJvcicsXG4gIC8vIElkZW50aWZpZXIgZm9yIGFuIGF1ZGlvIHRyYWNrIGxvYWQgdGltZW91dCAtIGRhdGE6IHsgdXJsIDogZmF1bHR5IFVSTCwgcmVzcG9uc2UgOiB7IGNvZGU6IGVycm9yIGNvZGUsIHRleHQ6IGVycm9yIHRleHQgfX1cbiAgQVVESU9fVFJBQ0tfTE9BRF9USU1FT1VUOiAnYXVkaW9UcmFja0xvYWRUaW1lT3V0JyxcbiAgLy8gSWRlbnRpZmllciBmb3IgZnJhZ21lbnQgbG9hZCBlcnJvciAtIGRhdGE6IHsgZnJhZyA6IGZyYWdtZW50IG9iamVjdCwgcmVzcG9uc2UgOiB7IGNvZGU6IGVycm9yIGNvZGUsIHRleHQ6IGVycm9yIHRleHQgfX1cbiAgRlJBR19MT0FEX0VSUk9SOiAnZnJhZ0xvYWRFcnJvcicsXG4gIC8vIElkZW50aWZpZXIgZm9yIGZyYWdtZW50IGxvb3AgbG9hZGluZyBlcnJvciAtIGRhdGE6IHsgZnJhZyA6IGZyYWdtZW50IG9iamVjdH1cbiAgRlJBR19MT09QX0xPQURJTkdfRVJST1I6ICdmcmFnTG9vcExvYWRpbmdFcnJvcicsXG4gIC8vIElkZW50aWZpZXIgZm9yIGZyYWdtZW50IGxvYWQgdGltZW91dCBlcnJvciAtIGRhdGE6IHsgZnJhZyA6IGZyYWdtZW50IG9iamVjdH1cbiAgRlJBR19MT0FEX1RJTUVPVVQ6ICdmcmFnTG9hZFRpbWVPdXQnLFxuICAvLyBJZGVudGlmaWVyIGZvciBhIGZyYWdtZW50IGRlY3J5cHRpb24gZXJyb3IgZXZlbnQgLSBkYXRhOiBwYXJzaW5nIGVycm9yIGRlc2NyaXB0aW9uXG4gIEZSQUdfREVDUllQVF9FUlJPUjogJ2ZyYWdEZWNyeXB0RXJyb3InLFxuICAvLyBJZGVudGlmaWVyIGZvciBhIGZyYWdtZW50IHBhcnNpbmcgZXJyb3IgZXZlbnQgLSBkYXRhOiBwYXJzaW5nIGVycm9yIGRlc2NyaXB0aW9uXG4gIEZSQUdfUEFSU0lOR19FUlJPUjogJ2ZyYWdQYXJzaW5nRXJyb3InLFxuICAvLyBJZGVudGlmaWVyIGZvciBkZWNyeXB0IGtleSBsb2FkIGVycm9yIC0gZGF0YTogeyBmcmFnIDogZnJhZ21lbnQgb2JqZWN0LCByZXNwb25zZSA6IHsgY29kZTogZXJyb3IgY29kZSwgdGV4dDogZXJyb3IgdGV4dCB9fVxuICBLRVlfTE9BRF9FUlJPUjogJ2tleUxvYWRFcnJvcicsXG4gIC8vIElkZW50aWZpZXIgZm9yIGRlY3J5cHQga2V5IGxvYWQgdGltZW91dCBlcnJvciAtIGRhdGE6IHsgZnJhZyA6IGZyYWdtZW50IG9iamVjdH1cbiAgS0VZX0xPQURfVElNRU9VVDogJ2tleUxvYWRUaW1lT3V0JyxcbiAgLy8gVHJpZ2dlcmVkIHdoZW4gYW4gZXhjZXB0aW9uIG9jY3VycyB3aGlsZSBhZGRpbmcgYSBzb3VyY2VCdWZmZXIgdG8gTWVkaWFTb3VyY2UgLSBkYXRhIDogeyAgZXJyIDogZXhjZXB0aW9uICwgbWltZVR5cGUgOiBtaW1lVHlwZSB9XG4gIEJVRkZFUl9BRERfQ09ERUNfRVJST1I6ICdidWZmZXJBZGRDb2RlY0Vycm9yJyxcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBidWZmZXIgYXBwZW5kIGVycm9yIC0gZGF0YTogYXBwZW5kIGVycm9yIGRlc2NyaXB0aW9uXG4gIEJVRkZFUl9BUFBFTkRfRVJST1I6ICdidWZmZXJBcHBlbmRFcnJvcicsXG4gIC8vIElkZW50aWZpZXIgZm9yIGEgYnVmZmVyIGFwcGVuZGluZyBlcnJvciBldmVudCAtIGRhdGE6IGFwcGVuZGluZyBlcnJvciBkZXNjcmlwdGlvblxuICBCVUZGRVJfQVBQRU5ESU5HX0VSUk9SOiAnYnVmZmVyQXBwZW5kaW5nRXJyb3InLFxuICAvLyBJZGVudGlmaWVyIGZvciBhIGJ1ZmZlciBzdGFsbGVkIGVycm9yIGV2ZW50XG4gIEJVRkZFUl9TVEFMTEVEX0VSUk9SOiAnYnVmZmVyU3RhbGxlZEVycm9yJyxcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBidWZmZXIgZnVsbCBldmVudFxuICBCVUZGRVJfRlVMTF9FUlJPUjogJ2J1ZmZlckZ1bGxFcnJvcicsXG4gIC8vIElkZW50aWZpZXIgZm9yIGEgYnVmZmVyIHNlZWsgb3ZlciBob2xlIGV2ZW50XG4gIEJVRkZFUl9TRUVLX09WRVJfSE9MRTogJ2J1ZmZlclNlZWtPdmVySG9sZScsXG4gIC8vIElkZW50aWZpZXIgZm9yIGFuIGludGVybmFsIGV4Y2VwdGlvbiBoYXBwZW5pbmcgaW5zaWRlIGhscy5qcyB3aGlsZSBoYW5kbGluZyBhbiBldmVudFxuICBJTlRFUk5BTF9FWENFUFRJT046ICdpbnRlcm5hbEV4Y2VwdGlvbidcbn07XG4iLCIvKlxuKlxuKiBBbGwgb2JqZWN0cyBpbiB0aGUgZXZlbnQgaGFuZGxpbmcgY2hhaW4gc2hvdWxkIGluaGVyaXQgZnJvbSB0aGlzIGNsYXNzXG4qXG4qL1xuXG5pbXBvcnQge2xvZ2dlcn0gZnJvbSAnLi91dGlscy9sb2dnZXInO1xuaW1wb3J0IHtFcnJvclR5cGVzLCBFcnJvckRldGFpbHN9IGZyb20gJy4vZXJyb3JzJztcbmltcG9ydCBFdmVudCBmcm9tICcuL2V2ZW50cyc7XG5cbmNsYXNzIEV2ZW50SGFuZGxlciB7XG5cbiAgY29uc3RydWN0b3IoaGxzLCAuLi5ldmVudHMpIHtcbiAgICB0aGlzLmhscyA9IGhscztcbiAgICB0aGlzLm9uRXZlbnQgPSB0aGlzLm9uRXZlbnQuYmluZCh0aGlzKTtcbiAgICB0aGlzLmhhbmRsZWRFdmVudHMgPSBldmVudHM7XG4gICAgdGhpcy51c2VHZW5lcmljSGFuZGxlciA9IHRydWU7XG5cbiAgICB0aGlzLnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIHRoaXMudW5yZWdpc3Rlckxpc3RlbmVycygpO1xuICB9XG5cbiAgaXNFdmVudEhhbmRsZXIoKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB0aGlzLmhhbmRsZWRFdmVudHMgPT09ICdvYmplY3QnICYmIHRoaXMuaGFuZGxlZEV2ZW50cy5sZW5ndGggJiYgdHlwZW9mIHRoaXMub25FdmVudCA9PT0gJ2Z1bmN0aW9uJztcbiAgfVxuXG4gIHJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIGlmICh0aGlzLmlzRXZlbnRIYW5kbGVyKCkpIHtcbiAgICAgIHRoaXMuaGFuZGxlZEV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudCA9PT0gJ2hsc0V2ZW50R2VuZXJpYycpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZvcmJpZGRlbiBldmVudCBuYW1lOiAnICsgZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaGxzLm9uKGV2ZW50LCB0aGlzLm9uRXZlbnQpO1xuICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICB9XG4gIH1cblxuICB1bnJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIGlmICh0aGlzLmlzRXZlbnRIYW5kbGVyKCkpIHtcbiAgICAgIHRoaXMuaGFuZGxlZEV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuaGxzLm9mZihldmVudCwgdGhpcy5vbkV2ZW50KTtcbiAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIGFyZ3VtZW50czogZXZlbnQgKHN0cmluZyksIGRhdGEgKGFueSlcbiAgICovXG4gIG9uRXZlbnQoZXZlbnQsIGRhdGEpIHtcbiAgICB0aGlzLm9uRXZlbnRHZW5lcmljKGV2ZW50LCBkYXRhKTtcbiAgfVxuXG4gIG9uRXZlbnRHZW5lcmljKGV2ZW50LCBkYXRhKSB7XG4gICAgdmFyIGV2ZW50VG9GdW5jdGlvbiA9IGZ1bmN0aW9uKGV2ZW50LCBkYXRhKSB7XG4gICAgICB2YXIgZnVuY05hbWUgPSAnb24nICsgZXZlbnQucmVwbGFjZSgnaGxzJywgJycpO1xuICAgICAgaWYgKHR5cGVvZiB0aGlzW2Z1bmNOYW1lXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV2ZW50ICR7ZXZlbnR9IGhhcyBubyBnZW5lcmljIGhhbmRsZXIgaW4gdGhpcyAke3RoaXMuY29uc3RydWN0b3IubmFtZX0gY2xhc3MgKHRyaWVkICR7ZnVuY05hbWV9KWApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXNbZnVuY05hbWVdLmJpbmQodGhpcywgZGF0YSk7XG4gICAgfTtcbiAgICB0cnkge1xuICAgICAgZXZlbnRUb0Z1bmN0aW9uLmNhbGwodGhpcywgZXZlbnQsIGRhdGEpLmNhbGwoKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGxvZ2dlci5lcnJvcihgaW50ZXJuYWwgZXJyb3IgaGFwcGVuZWQgd2hpbGUgcHJvY2Vzc2luZyAke2V2ZW50fToke2Vyci5tZXNzYWdlfWApO1xuICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5FUlJPUiwge3R5cGU6IEVycm9yVHlwZXMuT1RIRVJfRVJST1IsIGRldGFpbHM6IEVycm9yRGV0YWlscy5JTlRFUk5BTF9FWENFUFRJT04sIGZhdGFsOiBmYWxzZSwgZXZlbnQgOiBldmVudCwgZXJyIDogZXJyfSk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEV2ZW50SGFuZGxlcjtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAvLyBmaXJlZCBiZWZvcmUgTWVkaWFTb3VyY2UgaXMgYXR0YWNoaW5nIHRvIG1lZGlhIGVsZW1lbnQgLSBkYXRhOiB7IG1lZGlhIH1cbiAgTUVESUFfQVRUQUNISU5HOiAnaGxzTWVkaWFBdHRhY2hpbmcnLFxuICAvLyBmaXJlZCB3aGVuIE1lZGlhU291cmNlIGhhcyBiZWVuIHN1Y2Nlc2Z1bGx5IGF0dGFjaGVkIHRvIG1lZGlhIGVsZW1lbnQgLSBkYXRhOiB7IH1cbiAgTUVESUFfQVRUQUNIRUQ6ICdobHNNZWRpYUF0dGFjaGVkJyxcbiAgLy8gZmlyZWQgYmVmb3JlIGRldGFjaGluZyBNZWRpYVNvdXJjZSBmcm9tIG1lZGlhIGVsZW1lbnQgLSBkYXRhOiB7IH1cbiAgTUVESUFfREVUQUNISU5HOiAnaGxzTWVkaWFEZXRhY2hpbmcnLFxuICAvLyBmaXJlZCB3aGVuIE1lZGlhU291cmNlIGhhcyBiZWVuIGRldGFjaGVkIGZyb20gbWVkaWEgZWxlbWVudCAtIGRhdGE6IHsgfVxuICBNRURJQV9ERVRBQ0hFRDogJ2hsc01lZGlhRGV0YWNoZWQnLFxuICAvLyBmaXJlZCB3aGVuIHdlIGJ1ZmZlciBpcyBnb2luZyB0byBiZSByZXNldHRlZFxuICBCVUZGRVJfUkVTRVQ6ICdobHNCdWZmZXJSZXNldCcsXG4gIC8vIGZpcmVkIHdoZW4gd2Uga25vdyBhYm91dCB0aGUgY29kZWNzIHRoYXQgd2UgbmVlZCBidWZmZXJzIGZvciB0byBwdXNoIGludG8gLSBkYXRhOiB7dHJhY2tzIDogeyBjb250YWluZXIsIGNvZGVjLCBsZXZlbENvZGVjLCBpbml0U2VnbWVudCwgbWV0YWRhdGEgfX1cbiAgQlVGRkVSX0NPREVDUzogJ2hsc0J1ZmZlckNvZGVjcycsXG4gIC8vIGZpcmVkIHdoZW4gc291cmNlYnVmZmVycyBoYXZlIGJlZW4gY3JlYXRlZCBkYXRhOiB7IHRyYWNrcyA6IHRyYWNrc31cbiAgQlVGRkVSX0NSRUFURUQ6ICdobHNCdWZmZXJDcmVhdGVkJyxcbiAgLy8gZmlyZWQgd2hlbiB3ZSBhcHBlbmQgYSBzZWdtZW50IHRvIHRoZSBidWZmZXIgLSBkYXRhOiB7IHNlZ21lbnQ6IHNlZ21lbnQgb2JqZWN0IH1cbiAgQlVGRkVSX0FQUEVORElORzogJ2hsc0J1ZmZlckFwcGVuZGluZycsXG4gIC8vIGZpcmVkIHdoZW4gd2UgYXJlIGRvbmUgd2l0aCBhcHBlbmRpbmcgYSBtZWRpYSBzZWdtZW50IHRvIHRoZSBidWZmZXIgZGF0YSA6IHsgcGFyZW50IDogc2VnbWVudCBwYXJlbnQgdGhhdCB0cmlnZ2VyZWQgQlVGRkVSX0FQUEVORElORyB9XG4gIEJVRkZFUl9BUFBFTkRFRDogJ2hsc0J1ZmZlckFwcGVuZGVkJyxcbiAgLy8gZmlyZWQgd2hlbiB0aGUgc3RyZWFtIGlzIGZpbmlzaGVkIGFuZCB3ZSB3YW50IHRvIG5vdGlmeSB0aGUgbWVkaWEgYnVmZmVyIHRoYXQgdGhlcmUgd2lsbCBiZSBubyBtb3JlIGRhdGFcbiAgQlVGRkVSX0VPUzogJ2hsc0J1ZmZlckVvcycsXG4gIC8vIGZpcmVkIHdoZW4gdGhlIG1lZGlhIGJ1ZmZlciBzaG91bGQgYmUgZmx1c2hlZCAtIGRhdGEge3N0YXJ0T2Zmc2V0LCBlbmRPZmZzZXR9XG4gIEJVRkZFUl9GTFVTSElORzogJ2hsc0J1ZmZlckZsdXNoaW5nJyxcbiAgLy8gZmlyZWQgd2hlbiB0aGUgbWVkaWEgaGFzIGJlZW4gZmx1c2hlZFxuICBCVUZGRVJfRkxVU0hFRDogJ2hsc0J1ZmZlckZsdXNoZWQnLFxuICAvLyBmaXJlZCB0byBzaWduYWwgdGhhdCBhIG1hbmlmZXN0IGxvYWRpbmcgc3RhcnRzIC0gZGF0YTogeyB1cmwgOiBtYW5pZmVzdFVSTH1cbiAgTUFOSUZFU1RfTE9BRElORzogJ2hsc01hbmlmZXN0TG9hZGluZycsXG4gIC8vIGZpcmVkIGFmdGVyIG1hbmlmZXN0IGhhcyBiZWVuIGxvYWRlZCAtIGRhdGE6IHsgbGV2ZWxzIDogW2F2YWlsYWJsZSBxdWFsaXR5IGxldmVsc10gLCBhdWRpb1RyYWNrcyA6IFsgYXZhaWxhYmxlIGF1ZGlvIHRyYWNrc10sIHVybCA6IG1hbmlmZXN0VVJMLCBzdGF0cyA6IHsgdHJlcXVlc3QsIHRmaXJzdCwgdGxvYWQsIG10aW1lfX1cbiAgTUFOSUZFU1RfTE9BREVEOiAnaGxzTWFuaWZlc3RMb2FkZWQnLFxuICAvLyBmaXJlZCBhZnRlciBtYW5pZmVzdCBoYXMgYmVlbiBwYXJzZWQgLSBkYXRhOiB7IGxldmVscyA6IFthdmFpbGFibGUgcXVhbGl0eSBsZXZlbHNdICwgZmlyc3RMZXZlbCA6IGluZGV4IG9mIGZpcnN0IHF1YWxpdHkgbGV2ZWwgYXBwZWFyaW5nIGluIE1hbmlmZXN0fVxuICBNQU5JRkVTVF9QQVJTRUQ6ICdobHNNYW5pZmVzdFBhcnNlZCcsXG4gIC8vIGZpcmVkIHdoZW4gYSBsZXZlbCBwbGF5bGlzdCBsb2FkaW5nIHN0YXJ0cyAtIGRhdGE6IHsgdXJsIDogbGV2ZWwgVVJMICBsZXZlbCA6IGlkIG9mIGxldmVsIGJlaW5nIGxvYWRlZH1cbiAgTEVWRUxfTE9BRElORzogJ2hsc0xldmVsTG9hZGluZycsXG4gIC8vIGZpcmVkIHdoZW4gYSBsZXZlbCBwbGF5bGlzdCBsb2FkaW5nIGZpbmlzaGVzIC0gZGF0YTogeyBkZXRhaWxzIDogbGV2ZWxEZXRhaWxzIG9iamVjdCwgbGV2ZWwgOiBpZCBvZiBsb2FkZWQgbGV2ZWwsIHN0YXRzIDogeyB0cmVxdWVzdCwgdGZpcnN0LCB0bG9hZCwgbXRpbWV9IH1cbiAgTEVWRUxfTE9BREVEOiAnaGxzTGV2ZWxMb2FkZWQnLFxuICAvLyBmaXJlZCB3aGVuIGEgbGV2ZWwncyBkZXRhaWxzIGhhdmUgYmVlbiB1cGRhdGVkIGJhc2VkIG9uIHByZXZpb3VzIGRldGFpbHMsIGFmdGVyIGl0IGhhcyBiZWVuIGxvYWRlZC4gLSBkYXRhOiB7IGRldGFpbHMgOiBsZXZlbERldGFpbHMgb2JqZWN0LCBsZXZlbCA6IGlkIG9mIHVwZGF0ZWQgbGV2ZWwgfVxuICBMRVZFTF9VUERBVEVEOiAnaGxzTGV2ZWxVcGRhdGVkJyxcbiAgLy8gZmlyZWQgd2hlbiBhIGxldmVsJ3MgUFRTIGluZm9ybWF0aW9uIGhhcyBiZWVuIHVwZGF0ZWQgYWZ0ZXIgcGFyc2luZyBhIGZyYWdtZW50IC0gZGF0YTogeyBkZXRhaWxzIDogbGV2ZWxEZXRhaWxzIG9iamVjdCwgbGV2ZWwgOiBpZCBvZiB1cGRhdGVkIGxldmVsLCBkcmlmdDogUFRTIGRyaWZ0IG9ic2VydmVkIHdoZW4gcGFyc2luZyBsYXN0IGZyYWdtZW50IH1cbiAgTEVWRUxfUFRTX1VQREFURUQ6ICdobHNMZXZlbFB0c1VwZGF0ZWQnLFxuICAvLyBmaXJlZCB3aGVuIGEgbGV2ZWwgc3dpdGNoIGlzIHJlcXVlc3RlZCAtIGRhdGE6IHsgbGV2ZWwgOiBpZCBvZiBuZXcgbGV2ZWwgfVxuICBMRVZFTF9TV0lUQ0g6ICdobHNMZXZlbFN3aXRjaCcsXG4gIC8vIGZpcmVkIHRvIG5vdGlmeSB0aGF0IGF1ZGlvIHRyYWNrIGxpc3RzIGhhcyBiZWVuIHVwZGF0ZWQgZGF0YTogeyBhdWRpb1RyYWNrcyA6IGF1ZGlvVHJhY2tzfVxuICBBVURJT19UUkFDS1NfVVBEQVRFRDogJ2hsc0F1ZGlvVHJhY2tzVXBkYXRlZCcsXG4gIC8vIGZpcmVkIHdoZW4gYW4gYXVkaW8gdHJhY2sgc3dpdGNoIG9jY3VycyAtIGRhdGE6IHsgIGlkIDogYXVkaW8gdHJhY2sgaWR9XG4gIEFVRElPX1RSQUNLX1NXSVRDSDogJ2hsc0F1ZGlvVHJhY2tTd2l0Y2gnLFxuICAvLyBmaXJlZCB3aGVuIGFuIGF1ZGlvIHRyYWNrIGxvYWRpbmcgc3RhcnRzIC0gZGF0YTogeyB1cmwgOiBhdWRpbyB0cmFjayBVUkwgIGlkIDogYXVkaW8gdHJhY2sgaWR9XG4gIEFVRElPX1RSQUNLX0xPQURJTkc6ICdobHNBdWRpb1RyYWNrTG9hZGluZycsXG4gIC8vIGZpcmVkIHdoZW4gYW4gYXVkaW8gdHJhY2sgbG9hZGluZyAgZmluaXNoZXMgLSBkYXRhOiB7IGRldGFpbHMgOiBsZXZlbERldGFpbHMgb2JqZWN0LCBpZCA6IGF1ZGlvIHRyYWNrIGlkLCBzdGF0cyA6IHsgdHJlcXVlc3QsIHRmaXJzdCwgdGxvYWQsIG10aW1lfSB9XG4gIEFVRElPX1RSQUNLX0xPQURFRDogJ2hsc0F1ZGlvVHJhY2tMb2FkZWQnLFxuICAvLyBmaXJlZCB3aGVuIGEgZnJhZ21lbnQgbG9hZGluZyBzdGFydHMgLSBkYXRhOiB7IGZyYWcgOiBmcmFnbWVudCBvYmplY3R9XG4gIEZSQUdfTE9BRElORzogJ2hsc0ZyYWdMb2FkaW5nJyxcbiAgLy8gZmlyZWQgd2hlbiBhIGZyYWdtZW50IGxvYWRpbmcgaXMgcHJvZ3Jlc3NpbmcgLSBkYXRhOiB7IGZyYWcgOiBmcmFnbWVudCBvYmplY3QsIHsgdHJlcXVlc3QsIHRmaXJzdCwgbG9hZGVkfX1cbiAgRlJBR19MT0FEX1BST0dSRVNTOiAnaGxzRnJhZ0xvYWRQcm9ncmVzcycsXG4gIC8vIElkZW50aWZpZXIgZm9yIGZyYWdtZW50IGxvYWQgYWJvcnRpbmcgZm9yIGVtZXJnZW5jeSBzd2l0Y2ggZG93biAtIGRhdGE6IHtmcmFnIDogZnJhZ21lbnQgb2JqZWN0fVxuICBGUkFHX0xPQURfRU1FUkdFTkNZX0FCT1JURUQ6ICdobHNGcmFnTG9hZEVtZXJnZW5jeUFib3J0ZWQnLFxuICAvLyBmaXJlZCB3aGVuIGEgZnJhZ21lbnQgbG9hZGluZyBpcyBjb21wbGV0ZWQgLSBkYXRhOiB7IGZyYWcgOiBmcmFnbWVudCBvYmplY3QsIHBheWxvYWQgOiBmcmFnbWVudCBwYXlsb2FkLCBzdGF0cyA6IHsgdHJlcXVlc3QsIHRmaXJzdCwgdGxvYWQsIGxlbmd0aH19XG4gIEZSQUdfTE9BREVEOiAnaGxzRnJhZ0xvYWRlZCcsXG4gIC8vIGZpcmVkIHdoZW4gSW5pdCBTZWdtZW50IGhhcyBiZWVuIGV4dHJhY3RlZCBmcm9tIGZyYWdtZW50IC0gZGF0YTogeyBpZCA6IGRlbXV4ZXIgaWQsIGxldmVsIDogbGV2ZWxJZCwgc24gOiBzZXF1ZW5jZSBudW1iZXIsIG1vb3YgOiBtb292IE1QNCBib3gsIGNvZGVjcyA6IGNvZGVjcyBmb3VuZCB3aGlsZSBwYXJzaW5nIGZyYWdtZW50fVxuICBGUkFHX1BBUlNJTkdfSU5JVF9TRUdNRU5UOiAnaGxzRnJhZ1BhcnNpbmdJbml0U2VnbWVudCcsXG4gIC8vIGZpcmVkIHdoZW4gcGFyc2luZyBzZWkgdGV4dCBpcyBjb21wbGV0ZWQgLSBkYXRhOiB7IGlkIDogZGVtdXhlciBpZCwgLCBsZXZlbCA6IGxldmVsSWQsIHNuIDogc2VxdWVuY2UgbnVtYmVyLCBzYW1wbGVzIDogWyBzZWkgc2FtcGxlcyBwZXMgXSB9XG4gIEZSQUdfUEFSU0lOR19VU0VSREFUQTogJ2hsc0ZyYWdQYXJzaW5nVXNlcmRhdGEnLFxuICAvLyBmaXJlZCB3aGVuIHBhcnNpbmcgaWQzIGlzIGNvbXBsZXRlZCAtIGRhdGE6IHsgaWQgOiBkZW11eGVyIGlkLCAsIGxldmVsIDogbGV2ZWxJZCwgc24gOiBzZXF1ZW5jZSBudW1iZXIsIHNhbXBsZXMgOiBbIGlkMyBzYW1wbGVzIHBlcyBdIH1cbiAgRlJBR19QQVJTSU5HX01FVEFEQVRBOiAnaGxzRnJhZ1BhcnNpbmdNZXRhZGF0YScsXG4gIC8vIGZpcmVkIHdoZW4gZGF0YSBoYXZlIGJlZW4gZXh0cmFjdGVkIGZyb20gZnJhZ21lbnQgLSBkYXRhOiB7IGlkIDogZGVtdXhlciBpZCwgbGV2ZWwgOiBsZXZlbElkLCBzbiA6IHNlcXVlbmNlIG51bWJlciwgZGF0YTEgOiBtb29mIE1QNCBib3ggb3IgVFMgZnJhZ21lbnRzLCBkYXRhMiA6IG1kYXQgTVA0IGJveCBvciBudWxsfVxuICBGUkFHX1BBUlNJTkdfREFUQTogJ2hsc0ZyYWdQYXJzaW5nRGF0YScsXG4gIC8vIGZpcmVkIHdoZW4gZnJhZ21lbnQgcGFyc2luZyBpcyBjb21wbGV0ZWQgLSBkYXRhOiB7IGlkIDogZGVtdXhlciBpZDsgbGV2ZWwgOiBsZXZlbElkLCBzbiA6IHNlcXVlbmNlIG51bWJlciwgfVxuICBGUkFHX1BBUlNFRDogJ2hsc0ZyYWdQYXJzZWQnLFxuICAvLyBmaXJlZCB3aGVuIGZyYWdtZW50IHJlbXV4ZWQgTVA0IGJveGVzIGhhdmUgYWxsIGJlZW4gYXBwZW5kZWQgaW50byBTb3VyY2VCdWZmZXIgLSBkYXRhOiB7IGlkIDogZGVtdXhlciBpZCxmcmFnIDogZnJhZ21lbnQgb2JqZWN0LCBzdGF0cyA6IHsgdHJlcXVlc3QsIHRmaXJzdCwgdGxvYWQsIHRwYXJzZWQsIHRidWZmZXJlZCwgbGVuZ3RofSB9XG4gIEZSQUdfQlVGRkVSRUQ6ICdobHNGcmFnQnVmZmVyZWQnLFxuICAvLyBmaXJlZCB3aGVuIGZyYWdtZW50IG1hdGNoaW5nIHdpdGggY3VycmVudCBtZWRpYSBwb3NpdGlvbiBpcyBjaGFuZ2luZyAtIGRhdGEgOiB7IGlkIDogZGVtdXhlciBpZCwgZnJhZyA6IGZyYWdtZW50IG9iamVjdCB9XG4gIEZSQUdfQ0hBTkdFRDogJ2hsc0ZyYWdDaGFuZ2VkJyxcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBGUFMgZHJvcCBldmVudCAtIGRhdGE6IHtjdXJlbnREcm9wcGVkLCBjdXJyZW50RGVjb2RlZCwgdG90YWxEcm9wcGVkRnJhbWVzfVxuICBGUFNfRFJPUDogJ2hsc0Zwc0Ryb3AnLFxuICAvL3RyaWdnZXJlZCB3aGVuIEZQUyBkcm9wIHRyaWdnZXJzIGF1dG8gbGV2ZWwgY2FwcGluZyAtIGRhdGE6IHtsZXZlbCwgZHJvcHBlZGxldmVsfVxuICBGUFNfRFJPUF9MRVZFTF9DQVBQSU5HOiAnaGxzRnBzRHJvcExldmVsQ2FwcGluZycsXG4gIC8vIElkZW50aWZpZXIgZm9yIGFuIGVycm9yIGV2ZW50IC0gZGF0YTogeyB0eXBlIDogZXJyb3IgdHlwZSwgZGV0YWlscyA6IGVycm9yIGRldGFpbHMsIGZhdGFsIDogaWYgdHJ1ZSwgaGxzLmpzIGNhbm5vdC93aWxsIG5vdCB0cnkgdG8gcmVjb3ZlciwgaWYgZmFsc2UsIGhscy5qcyB3aWxsIHRyeSB0byByZWNvdmVyLG90aGVyIGVycm9yIHNwZWNpZmljIGRhdGF9XG4gIEVSUk9SOiAnaGxzRXJyb3InLFxuICAvLyBmaXJlZCB3aGVuIGhscy5qcyBpbnN0YW5jZSBzdGFydHMgZGVzdHJveWluZy4gRGlmZmVyZW50IGZyb20gTUVESUFfREVUQUNIRUQgYXMgb25lIGNvdWxkIHdhbnQgdG8gZGV0YWNoIGFuZCByZWF0dGFjaCBhIG1lZGlhIHRvIHRoZSBpbnN0YW5jZSBvZiBobHMuanMgdG8gaGFuZGxlIG1pZC1yb2xscyBmb3IgZXhhbXBsZVxuICBERVNUUk9ZSU5HOiAnaGxzRGVzdHJveWluZycsXG4gIC8vIGZpcmVkIHdoZW4gYSBkZWNyeXB0IGtleSBsb2FkaW5nIHN0YXJ0cyAtIGRhdGE6IHsgZnJhZyA6IGZyYWdtZW50IG9iamVjdH1cbiAgS0VZX0xPQURJTkc6ICdobHNLZXlMb2FkaW5nJyxcbiAgLy8gZmlyZWQgd2hlbiBhIGRlY3J5cHQga2V5IGxvYWRpbmcgaXMgY29tcGxldGVkIC0gZGF0YTogeyBmcmFnIDogZnJhZ21lbnQgb2JqZWN0LCBwYXlsb2FkIDoga2V5IHBheWxvYWQsIHN0YXRzIDogeyB0cmVxdWVzdCwgdGZpcnN0LCB0bG9hZCwgbGVuZ3RofX1cbiAgS0VZX0xPQURFRDogJ2hsc0tleUxvYWRlZCcsXG4gIC8vIGZpcmVkIHVwb24gc3RyZWFtIGNvbnRyb2xsZXIgc3RhdGUgdHJhbnNpdGlvbnMgLSBkYXRhOiB7cHJldmlvdXNTdGF0ZSwgbmV4dFN0YXRlfVxuICBTVFJFQU1fU1RBVEVfVFJBTlNJVElPTjogJ2hsc1N0cmVhbVN0YXRlVHJhbnNpdGlvbidcbn07XG4iLCIvKipcbiAqICBBQUMgaGVscGVyXG4gKi9cblxuY2xhc3MgQUFDIHtcbiAgc3RhdGljIGdldFNpbGVudEZyYW1lKGNoYW5uZWxDb3VudCkge1xuICAgIGlmIChjaGFubmVsQ291bnQgPT09IDEpIHtcbiAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShbMHgwMCwgMHhjOCwgMHgwMCwgMHg4MCwgMHgyMywgMHg4MF0pO1xuICAgIH0gZWxzZSBpZiAoY2hhbm5lbENvdW50ID09PSAyKSB7XG4gICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzB4MjEsIDB4MDAsIDB4NDksIDB4OTAsIDB4MDIsIDB4MTksIDB4MDAsIDB4MjMsIDB4ODBdKTtcbiAgICB9IGVsc2UgaWYgKGNoYW5uZWxDb3VudCA9PT0gMykge1xuICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFsweDAwLCAweGM4LCAweDAwLCAweDgwLCAweDIwLCAweDg0LCAweDAxLCAweDI2LCAweDQwLCAweDA4LCAweDY0LCAweDAwLCAweDhlXSk7XG4gICAgfSBlbHNlIGlmIChjaGFubmVsQ291bnQgPT09IDQpIHtcbiAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShbMHgwMCwgMHhjOCwgMHgwMCwgMHg4MCwgMHgyMCwgMHg4NCwgMHgwMSwgMHgyNiwgMHg0MCwgMHgwOCwgMHg2NCwgMHgwMCwgMHg4MCwgMHgyYywgMHg4MCwgMHgwOCwgMHgwMiwgMHgzOF0pO1xuICAgIH0gZWxzZSBpZiAoY2hhbm5lbENvdW50ID09PSA1KSB7XG4gICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzB4MDAsIDB4YzgsIDB4MDAsIDB4ODAsIDB4MjAsIDB4ODQsIDB4MDEsIDB4MjYsIDB4NDAsIDB4MDgsIDB4NjQsIDB4MDAsIDB4ODIsIDB4MzAsIDB4MDQsIDB4OTksIDB4MDAsIDB4MjEsIDB4OTAsIDB4MDIsIDB4MzhdKTtcbiAgICB9IGVsc2UgaWYgKGNoYW5uZWxDb3VudCA9PT0gNikge1xuICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFsweDAwLCAweGM4LCAweDAwLCAweDgwLCAweDIwLCAweDg0LCAweDAxLCAweDI2LCAweDQwLCAweDA4LCAweDY0LCAweDAwLCAweDgyLCAweDMwLCAweDA0LCAweDk5LCAweDAwLCAweDIxLCAweDkwLCAweDAyLCAweDAwLCAweGIyLCAweDAwLCAweDIwLCAweDA4LCAweGUwXSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEFBQztcbiIsIi8qKlxuICogQnVmZmVyIEhlbHBlciBjbGFzcywgcHJvdmlkaW5nIG1ldGhvZHMgZGVhbGluZyBidWZmZXIgbGVuZ3RoIHJldHJpZXZhbFxuKi9cblxuXG5jbGFzcyBCdWZmZXJIZWxwZXIge1xuXG4gIHN0YXRpYyBidWZmZXJJbmZvKG1lZGlhLCBwb3MsbWF4SG9sZUR1cmF0aW9uKSB7XG4gICAgaWYgKG1lZGlhKSB7XG4gICAgICB2YXIgdmJ1ZmZlcmVkID0gbWVkaWEuYnVmZmVyZWQsIGJ1ZmZlcmVkID0gW10saTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCB2YnVmZmVyZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYnVmZmVyZWQucHVzaCh7c3RhcnQ6IHZidWZmZXJlZC5zdGFydChpKSwgZW5kOiB2YnVmZmVyZWQuZW5kKGkpfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5idWZmZXJlZEluZm8oYnVmZmVyZWQscG9zLG1heEhvbGVEdXJhdGlvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB7bGVuOiAwLCBzdGFydDogMCwgZW5kOiAwLCBuZXh0U3RhcnQgOiB1bmRlZmluZWR9IDtcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgYnVmZmVyZWRJbmZvKGJ1ZmZlcmVkLHBvcyxtYXhIb2xlRHVyYXRpb24pIHtcbiAgICB2YXIgYnVmZmVyZWQyID0gW10sXG4gICAgICAgIC8vIGJ1ZmZlclN0YXJ0IGFuZCBidWZmZXJFbmQgYXJlIGJ1ZmZlciBib3VuZGFyaWVzIGFyb3VuZCBjdXJyZW50IHZpZGVvIHBvc2l0aW9uXG4gICAgICAgIGJ1ZmZlckxlbixidWZmZXJTdGFydCwgYnVmZmVyRW5kLGJ1ZmZlclN0YXJ0TmV4dCxpO1xuICAgIC8vIHNvcnQgb24gYnVmZmVyLnN0YXJ0L3NtYWxsZXIgZW5kIChJRSBkb2VzIG5vdCBhbHdheXMgcmV0dXJuIHNvcnRlZCBidWZmZXJlZCByYW5nZSlcbiAgICBidWZmZXJlZC5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICB2YXIgZGlmZiA9IGEuc3RhcnQgLSBiLnN0YXJ0O1xuICAgICAgaWYgKGRpZmYpIHtcbiAgICAgICAgcmV0dXJuIGRpZmY7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gYi5lbmQgLSBhLmVuZDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICAvLyB0aGVyZSBtaWdodCBiZSBzb21lIHNtYWxsIGhvbGVzIGJldHdlZW4gYnVmZmVyIHRpbWUgcmFuZ2VcbiAgICAvLyBjb25zaWRlciB0aGF0IGhvbGVzIHNtYWxsZXIgdGhhbiBtYXhIb2xlRHVyYXRpb24gYXJlIGlycmVsZXZhbnQgYW5kIGJ1aWxkIGFub3RoZXJcbiAgICAvLyBidWZmZXIgdGltZSByYW5nZSByZXByZXNlbnRhdGlvbnMgdGhhdCBkaXNjYXJkcyB0aG9zZSBob2xlc1xuICAgIGZvciAoaSA9IDA7IGkgPCBidWZmZXJlZC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGJ1ZjJsZW4gPSBidWZmZXJlZDIubGVuZ3RoO1xuICAgICAgaWYoYnVmMmxlbikge1xuICAgICAgICB2YXIgYnVmMmVuZCA9IGJ1ZmZlcmVkMltidWYybGVuIC0gMV0uZW5kO1xuICAgICAgICAvLyBpZiBzbWFsbCBob2xlICh2YWx1ZSBiZXR3ZWVuIDAgb3IgbWF4SG9sZUR1cmF0aW9uICkgb3Igb3ZlcmxhcHBpbmcgKG5lZ2F0aXZlKVxuICAgICAgICBpZigoYnVmZmVyZWRbaV0uc3RhcnQgLSBidWYyZW5kKSA8IG1heEhvbGVEdXJhdGlvbikge1xuICAgICAgICAgIC8vIG1lcmdlIG92ZXJsYXBwaW5nIHRpbWUgcmFuZ2VzXG4gICAgICAgICAgLy8gdXBkYXRlIGxhc3RSYW5nZS5lbmQgb25seSBpZiBzbWFsbGVyIHRoYW4gaXRlbS5lbmRcbiAgICAgICAgICAvLyBlLmcuICBbIDEsIDE1XSB3aXRoICBbIDIsOF0gPT4gWyAxLDE1XSAobm8gbmVlZCB0byBtb2RpZnkgbGFzdFJhbmdlLmVuZClcbiAgICAgICAgICAvLyB3aGVyZWFzIFsgMSwgOF0gd2l0aCAgWyAyLDE1XSA9PiBbIDEsMTVdICggbGFzdFJhbmdlIHNob3VsZCBzd2l0Y2ggZnJvbSBbMSw4XSB0byBbMSwxNV0pXG4gICAgICAgICAgaWYoYnVmZmVyZWRbaV0uZW5kID4gYnVmMmVuZCkge1xuICAgICAgICAgICAgYnVmZmVyZWQyW2J1ZjJsZW4gLSAxXS5lbmQgPSBidWZmZXJlZFtpXS5lbmQ7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGJpZyBob2xlXG4gICAgICAgICAgYnVmZmVyZWQyLnB1c2goYnVmZmVyZWRbaV0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBmaXJzdCB2YWx1ZVxuICAgICAgICBidWZmZXJlZDIucHVzaChidWZmZXJlZFtpXSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoaSA9IDAsIGJ1ZmZlckxlbiA9IDAsIGJ1ZmZlclN0YXJ0ID0gYnVmZmVyRW5kID0gcG9zOyBpIDwgYnVmZmVyZWQyLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc3RhcnQgPSAgYnVmZmVyZWQyW2ldLnN0YXJ0LFxuICAgICAgICAgIGVuZCA9IGJ1ZmZlcmVkMltpXS5lbmQ7XG4gICAgICAvL2xvZ2dlci5sb2coJ2J1ZiBzdGFydC9lbmQ6JyArIGJ1ZmZlcmVkLnN0YXJ0KGkpICsgJy8nICsgYnVmZmVyZWQuZW5kKGkpKTtcbiAgICAgIGlmICgocG9zICsgbWF4SG9sZUR1cmF0aW9uKSA+PSBzdGFydCAmJiBwb3MgPCBlbmQpIHtcbiAgICAgICAgLy8gcGxheSBwb3NpdGlvbiBpcyBpbnNpZGUgdGhpcyBidWZmZXIgVGltZVJhbmdlLCByZXRyaWV2ZSBlbmQgb2YgYnVmZmVyIHBvc2l0aW9uIGFuZCBidWZmZXIgbGVuZ3RoXG4gICAgICAgIGJ1ZmZlclN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgIGJ1ZmZlckVuZCA9IGVuZDtcbiAgICAgICAgYnVmZmVyTGVuID0gYnVmZmVyRW5kIC0gcG9zO1xuICAgICAgfSBlbHNlIGlmICgocG9zICsgbWF4SG9sZUR1cmF0aW9uKSA8IHN0YXJ0KSB7XG4gICAgICAgIGJ1ZmZlclN0YXJ0TmV4dCA9IHN0YXJ0O1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtsZW46IGJ1ZmZlckxlbiwgc3RhcnQ6IGJ1ZmZlclN0YXJ0LCBlbmQ6IGJ1ZmZlckVuZCwgbmV4dFN0YXJ0IDogYnVmZmVyU3RhcnROZXh0fTtcbiAgfVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IEJ1ZmZlckhlbHBlcjtcbiIsIi8qKlxuICogTGV2ZWwgSGVscGVyIGNsYXNzLCBwcm92aWRpbmcgbWV0aG9kcyBkZWFsaW5nIHdpdGggcGxheWxpc3Qgc2xpZGluZyBhbmQgZHJpZnRcbiovXG5cbmltcG9ydCB7bG9nZ2VyfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xuXG5jbGFzcyBMZXZlbEhlbHBlciB7XG5cbiAgc3RhdGljIG1lcmdlRGV0YWlscyhvbGREZXRhaWxzLG5ld0RldGFpbHMpIHtcbiAgICB2YXIgc3RhcnQgPSBNYXRoLm1heChvbGREZXRhaWxzLnN0YXJ0U04sbmV3RGV0YWlscy5zdGFydFNOKS1uZXdEZXRhaWxzLnN0YXJ0U04sXG4gICAgICAgIGVuZCA9IE1hdGgubWluKG9sZERldGFpbHMuZW5kU04sbmV3RGV0YWlscy5lbmRTTiktbmV3RGV0YWlscy5zdGFydFNOLFxuICAgICAgICBkZWx0YSA9IG5ld0RldGFpbHMuc3RhcnRTTiAtIG9sZERldGFpbHMuc3RhcnRTTixcbiAgICAgICAgb2xkZnJhZ21lbnRzID0gb2xkRGV0YWlscy5mcmFnbWVudHMsXG4gICAgICAgIG5ld2ZyYWdtZW50cyA9IG5ld0RldGFpbHMuZnJhZ21lbnRzLFxuICAgICAgICBjY09mZnNldCA9MCxcbiAgICAgICAgUFRTRnJhZztcblxuICAgIC8vIGNoZWNrIGlmIG9sZC9uZXcgcGxheWxpc3RzIGhhdmUgZnJhZ21lbnRzIGluIGNvbW1vblxuICAgIGlmICggZW5kIDwgc3RhcnQpIHtcbiAgICAgIG5ld0RldGFpbHMuUFRTS25vd24gPSBmYWxzZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gbG9vcCB0aHJvdWdoIG92ZXJsYXBwaW5nIFNOIGFuZCB1cGRhdGUgc3RhcnRQVFMgLCBjYywgYW5kIGR1cmF0aW9uIGlmIGFueSBmb3VuZFxuICAgIGZvcih2YXIgaSA9IHN0YXJ0IDsgaSA8PSBlbmQgOyBpKyspIHtcbiAgICAgIHZhciBvbGRGcmFnID0gb2xkZnJhZ21lbnRzW2RlbHRhK2ldLFxuICAgICAgICAgIG5ld0ZyYWcgPSBuZXdmcmFnbWVudHNbaV07XG4gICAgICBpZiAobmV3RnJhZyAmJiBvbGRGcmFnKSB7XG4gICAgICAgIGNjT2Zmc2V0ID0gb2xkRnJhZy5jYyAtIG5ld0ZyYWcuY2M7XG4gICAgICAgIGlmICghaXNOYU4ob2xkRnJhZy5zdGFydFBUUykpIHtcbiAgICAgICAgICBuZXdGcmFnLnN0YXJ0ID0gbmV3RnJhZy5zdGFydFBUUyA9IG9sZEZyYWcuc3RhcnRQVFM7XG4gICAgICAgICAgbmV3RnJhZy5lbmRQVFMgPSBvbGRGcmFnLmVuZFBUUztcbiAgICAgICAgICBuZXdGcmFnLmR1cmF0aW9uID0gb2xkRnJhZy5kdXJhdGlvbjtcbiAgICAgICAgICBQVFNGcmFnID0gbmV3RnJhZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmKGNjT2Zmc2V0KSB7XG4gICAgICBsb2dnZXIubG9nKGBkaXNjb250aW51aXR5IHNsaWRpbmcgZnJvbSBwbGF5bGlzdCwgdGFrZSBkcmlmdCBpbnRvIGFjY291bnRgKTtcbiAgICAgIGZvcihpID0gMCA7IGkgPCBuZXdmcmFnbWVudHMubGVuZ3RoIDsgaSsrKSB7XG4gICAgICAgIG5ld2ZyYWdtZW50c1tpXS5jYyArPSBjY09mZnNldDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBpZiBhdCBsZWFzdCBvbmUgZnJhZ21lbnQgY29udGFpbnMgUFRTIGluZm8sIHJlY29tcHV0ZSBQVFMgaW5mb3JtYXRpb24gZm9yIGFsbCBmcmFnbWVudHNcbiAgICBpZihQVFNGcmFnKSB7XG4gICAgICBMZXZlbEhlbHBlci51cGRhdGVGcmFnUFRTRFRTKG5ld0RldGFpbHMsUFRTRnJhZy5zbixQVFNGcmFnLnN0YXJ0UFRTLFBUU0ZyYWcuZW5kUFRTLFBUU0ZyYWcuc3RhcnREVFMsUFRTRnJhZy5lbmREVFMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBlbnN1cmUgdGhhdCBkZWx0YSBpcyB3aXRoaW4gb2xkZnJhZ21lbnRzIHJhbmdlXG4gICAgICAvLyBhbHNvIGFkanVzdCBzbGlkaW5nIGluIGNhc2UgZGVsdGEgaXMgMCAod2UgY291bGQgaGF2ZSBvbGQ9WzUwLTYwXSBhbmQgbmV3PW9sZD1bNTAtNjFdKVxuICAgICAgLy8gaW4gdGhhdCBjYXNlIHdlIGFsc28gbmVlZCB0byBhZGp1c3Qgc3RhcnQgb2Zmc2V0IG9mIGFsbCBmcmFnbWVudHNcbiAgICAgIGlmIChkZWx0YSA+PSAwICYmIGRlbHRhIDwgb2xkZnJhZ21lbnRzLmxlbmd0aCkge1xuICAgICAgICAvLyBhZGp1c3Qgc3RhcnQgYnkgc2xpZGluZyBvZmZzZXRcbiAgICAgICAgdmFyIHNsaWRpbmcgPSBvbGRmcmFnbWVudHNbZGVsdGFdLnN0YXJ0O1xuICAgICAgICBmb3IoaSA9IDAgOyBpIDwgbmV3ZnJhZ21lbnRzLmxlbmd0aCA7IGkrKykge1xuICAgICAgICAgIG5ld2ZyYWdtZW50c1tpXS5zdGFydCArPSBzbGlkaW5nO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGlmIHdlIGFyZSBoZXJlLCBpdCBtZWFucyB3ZSBoYXZlIGZyYWdtZW50cyBvdmVybGFwcGluZyBiZXR3ZWVuXG4gICAgLy8gb2xkIGFuZCBuZXcgbGV2ZWwuIHJlbGlhYmxlIFBUUyBpbmZvIGlzIHRodXMgcmVseWluZyBvbiBvbGQgbGV2ZWxcbiAgICBuZXdEZXRhaWxzLlBUU0tub3duID0gb2xkRGV0YWlscy5QVFNLbm93bjtcbiAgICByZXR1cm47XG4gIH1cblxuICBzdGF0aWMgdXBkYXRlRnJhZ1BUU0RUUyhkZXRhaWxzLHNuLHN0YXJ0UFRTLGVuZFBUUyxzdGFydERUUyxlbmREVFMpIHtcbiAgICB2YXIgZnJhZ0lkeCwgZnJhZ21lbnRzLCBmcmFnLCBpO1xuICAgIC8vIGV4aXQgaWYgc24gb3V0IG9mIHJhbmdlXG4gICAgaWYgKHNuIDwgZGV0YWlscy5zdGFydFNOIHx8IHNuID4gZGV0YWlscy5lbmRTTikge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGZyYWdJZHggPSBzbiAtIGRldGFpbHMuc3RhcnRTTjtcbiAgICBmcmFnbWVudHMgPSBkZXRhaWxzLmZyYWdtZW50cztcbiAgICBmcmFnID0gZnJhZ21lbnRzW2ZyYWdJZHhdO1xuICAgIGlmKCFpc05hTihmcmFnLnN0YXJ0UFRTKSkge1xuICAgICAgLy8gZGVsdGEgUFRTIGJldHdlZW4gYXVkaW8gYW5kIHZpZGVvXG4gICAgICBsZXQgZGVsdGFQVFMgPSBNYXRoLmFicyhmcmFnLnN0YXJ0UFRTLXN0YXJ0UFRTKTtcbiAgICAgIGlmIChpc05hTihmcmFnLmRlbHRhUFRTKSkge1xuICAgICAgICBmcmFnLmRlbHRhUFRTID0gZGVsdGFQVFM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmcmFnLmRlbHRhUFRTID0gTWF0aC5tYXgoZGVsdGFQVFMsZnJhZy5kZWx0YVBUUyk7XG4gICAgICB9XG4gICAgICBzdGFydFBUUyA9IE1hdGgubWluKHN0YXJ0UFRTLGZyYWcuc3RhcnRQVFMpO1xuICAgICAgZW5kUFRTID0gTWF0aC5tYXgoZW5kUFRTLCBmcmFnLmVuZFBUUyk7XG4gICAgICBzdGFydERUUyA9IE1hdGgubWluKHN0YXJ0RFRTLGZyYWcuc3RhcnREVFMpO1xuICAgICAgZW5kRFRTID0gTWF0aC5tYXgoZW5kRFRTLCBmcmFnLmVuZERUUyk7XG4gICAgfVxuXG4gICAgdmFyIGRyaWZ0ID0gc3RhcnRQVFMgLSBmcmFnLnN0YXJ0O1xuXG4gICAgZnJhZy5zdGFydCA9IGZyYWcuc3RhcnRQVFMgPSBzdGFydFBUUztcbiAgICBmcmFnLmVuZFBUUyA9IGVuZFBUUztcbiAgICBmcmFnLnN0YXJ0RFRTID0gc3RhcnREVFM7XG4gICAgZnJhZy5lbmREVFMgPSBlbmREVFM7XG4gICAgZnJhZy5kdXJhdGlvbiA9IGVuZFBUUyAtIHN0YXJ0UFRTO1xuICAgIC8vIGFkanVzdCBmcmFnbWVudCBQVFMvZHVyYXRpb24gZnJvbSBzZXFudW0tMSB0byBmcmFnIDBcbiAgICBmb3IoaSA9IGZyYWdJZHggOyBpID4gMCA7IGktLSkge1xuICAgICAgTGV2ZWxIZWxwZXIudXBkYXRlUFRTKGZyYWdtZW50cyxpLGktMSk7XG4gICAgfVxuXG4gICAgLy8gYWRqdXN0IGZyYWdtZW50IFBUUy9kdXJhdGlvbiBmcm9tIHNlcW51bSB0byBsYXN0IGZyYWdcbiAgICBmb3IoaSA9IGZyYWdJZHggOyBpIDwgZnJhZ21lbnRzLmxlbmd0aCAtIDEgOyBpKyspIHtcbiAgICAgIExldmVsSGVscGVyLnVwZGF0ZVBUUyhmcmFnbWVudHMsaSxpKzEpO1xuICAgIH1cbiAgICBkZXRhaWxzLlBUU0tub3duID0gdHJ1ZTtcbiAgICAvL2xvZ2dlci5sb2coYCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhZyBzdGFydC9lbmQ6JHtzdGFydFBUUy50b0ZpeGVkKDMpfS8ke2VuZFBUUy50b0ZpeGVkKDMpfWApO1xuXG4gICAgcmV0dXJuIGRyaWZ0O1xuICB9XG5cbiAgc3RhdGljIHVwZGF0ZVBUUyhmcmFnbWVudHMsZnJvbUlkeCwgdG9JZHgpIHtcbiAgICB2YXIgZnJhZ0Zyb20gPSBmcmFnbWVudHNbZnJvbUlkeF0sZnJhZ1RvID0gZnJhZ21lbnRzW3RvSWR4XSwgZnJhZ1RvUFRTID0gZnJhZ1RvLnN0YXJ0UFRTO1xuICAgIC8vIGlmIHdlIGtub3cgc3RhcnRQVFNbdG9JZHhdXG4gICAgaWYoIWlzTmFOKGZyYWdUb1BUUykpIHtcbiAgICAgIC8vIHVwZGF0ZSBmcmFnbWVudCBkdXJhdGlvbi5cbiAgICAgIC8vIGl0IGhlbHBzIHRvIGZpeCBkcmlmdHMgYmV0d2VlbiBwbGF5bGlzdCByZXBvcnRlZCBkdXJhdGlvbiBhbmQgZnJhZ21lbnQgcmVhbCBkdXJhdGlvblxuICAgICAgaWYgKHRvSWR4ID4gZnJvbUlkeCkge1xuICAgICAgICBmcmFnRnJvbS5kdXJhdGlvbiA9IGZyYWdUb1BUUy1mcmFnRnJvbS5zdGFydDtcbiAgICAgICAgaWYoZnJhZ0Zyb20uZHVyYXRpb24gPCAwKSB7XG4gICAgICAgICAgbG9nZ2VyLndhcm4oYG5lZ2F0aXZlIGR1cmF0aW9uIGNvbXB1dGVkIGZvciBmcmFnICR7ZnJhZ0Zyb20uc259LGxldmVsICR7ZnJhZ0Zyb20ubGV2ZWx9LCB0aGVyZSBzaG91bGQgYmUgc29tZSBkdXJhdGlvbiBkcmlmdCBiZXR3ZWVuIHBsYXlsaXN0IGFuZCBmcmFnbWVudCFgKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZnJhZ1RvLmR1cmF0aW9uID0gZnJhZ0Zyb20uc3RhcnQgLSBmcmFnVG9QVFM7XG4gICAgICAgIGlmKGZyYWdUby5kdXJhdGlvbiA8IDApIHtcbiAgICAgICAgICBsb2dnZXIud2FybihgbmVnYXRpdmUgZHVyYXRpb24gY29tcHV0ZWQgZm9yIGZyYWcgJHtmcmFnVG8uc259LGxldmVsICR7ZnJhZ1RvLmxldmVsfSwgdGhlcmUgc2hvdWxkIGJlIHNvbWUgZHVyYXRpb24gZHJpZnQgYmV0d2VlbiBwbGF5bGlzdCBhbmQgZnJhZ21lbnQhYCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gd2UgZG9udCBrbm93IHN0YXJ0UFRTW3RvSWR4XVxuICAgICAgaWYgKHRvSWR4ID4gZnJvbUlkeCkge1xuICAgICAgICBmcmFnVG8uc3RhcnQgPSBmcmFnRnJvbS5zdGFydCArIGZyYWdGcm9tLmR1cmF0aW9uO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZnJhZ1RvLnN0YXJ0ID0gZnJhZ0Zyb20uc3RhcnQgLSBmcmFnVG8uZHVyYXRpb247XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IExldmVsSGVscGVyO1xuIiwiLyoqXG4gKiBITFMgaW50ZXJmYWNlXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IEV2ZW50IGZyb20gJy4vZXZlbnRzJztcbmltcG9ydCB7RXJyb3JUeXBlcywgRXJyb3JEZXRhaWxzfSBmcm9tICcuL2Vycm9ycyc7XG5pbXBvcnQgUGxheWxpc3RMb2FkZXIgZnJvbSAnLi9sb2FkZXIvcGxheWxpc3QtbG9hZGVyJztcbmltcG9ydCBGcmFnbWVudExvYWRlciBmcm9tICcuL2xvYWRlci9mcmFnbWVudC1sb2FkZXInO1xuaW1wb3J0IEFickNvbnRyb2xsZXIgZnJvbSAgICAnLi9jb250cm9sbGVyL2Fici1jb250cm9sbGVyJztcbmltcG9ydCBCdWZmZXJDb250cm9sbGVyIGZyb20gICcuL2NvbnRyb2xsZXIvYnVmZmVyLWNvbnRyb2xsZXInO1xuaW1wb3J0IENhcExldmVsQ29udHJvbGxlciBmcm9tICAnLi9jb250cm9sbGVyL2NhcC1sZXZlbC1jb250cm9sbGVyJztcbmltcG9ydCBBdWRpb1N0cmVhbUNvbnRyb2xsZXIgZnJvbSAgJy4vY29udHJvbGxlci9hdWRpby1zdHJlYW0tY29udHJvbGxlcic7XG5pbXBvcnQgU3RyZWFtQ29udHJvbGxlciBmcm9tICAnLi9jb250cm9sbGVyL3N0cmVhbS1jb250cm9sbGVyJztcbmltcG9ydCBMZXZlbENvbnRyb2xsZXIgZnJvbSAgJy4vY29udHJvbGxlci9sZXZlbC1jb250cm9sbGVyJztcbmltcG9ydCBUaW1lbGluZUNvbnRyb2xsZXIgZnJvbSAnLi9jb250cm9sbGVyL3RpbWVsaW5lLWNvbnRyb2xsZXInO1xuaW1wb3J0IEZQU0NvbnRyb2xsZXIgZnJvbSAnLi9jb250cm9sbGVyL2Zwcy1jb250cm9sbGVyJztcbmltcG9ydCBBdWRpb1RyYWNrQ29udHJvbGxlciBmcm9tICcuL2NvbnRyb2xsZXIvYXVkaW8tdHJhY2stY29udHJvbGxlcic7XG5pbXBvcnQge2xvZ2dlciwgZW5hYmxlTG9nc30gZnJvbSAnLi91dGlscy9sb2dnZXInO1xuLy9pbXBvcnQgRmV0Y2hMb2FkZXIgZnJvbSAnLi91dGlscy9mZXRjaC1sb2FkZXInO1xuaW1wb3J0IFhockxvYWRlciBmcm9tICcuL3V0aWxzL3hoci1sb2FkZXInO1xuaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tICdldmVudHMnO1xuaW1wb3J0IEtleUxvYWRlciBmcm9tICcuL2xvYWRlci9rZXktbG9hZGVyJztcbmltcG9ydCBDdWVzIGZyb20gJy4vdXRpbHMvY3Vlcyc7XG5cbmNsYXNzIEhscyB7XG5cbiAgc3RhdGljIGdldCB2ZXJzaW9uKCkge1xuICAgIC8vIHJlcGxhY2VkIHdpdGggYnJvd3NlcmlmeS12ZXJzaW9uaWZ5IHRyYW5zZm9ybVxuICAgIHJldHVybiAnX19WRVJTSU9OX18nO1xuICB9XG5cbiAgc3RhdGljIGlzU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiAod2luZG93Lk1lZGlhU291cmNlICYmXG4gICAgICAgICAgICB0eXBlb2Ygd2luZG93Lk1lZGlhU291cmNlLmlzVHlwZVN1cHBvcnRlZCA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICAgICAgd2luZG93Lk1lZGlhU291cmNlLmlzVHlwZVN1cHBvcnRlZCgndmlkZW8vbXA0OyBjb2RlY3M9XCJhdmMxLjQyRTAxRSxtcDRhLjQwLjJcIicpKTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgRXZlbnRzKCkge1xuICAgIHJldHVybiBFdmVudDtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgRXJyb3JUeXBlcygpIHtcbiAgICByZXR1cm4gRXJyb3JUeXBlcztcbiAgfVxuXG4gIHN0YXRpYyBnZXQgRXJyb3JEZXRhaWxzKCkge1xuICAgIHJldHVybiBFcnJvckRldGFpbHM7XG4gIH1cblxuICBzdGF0aWMgZ2V0IERlZmF1bHRDb25maWcoKSB7XG4gICAgaWYoIUhscy5kZWZhdWx0Q29uZmlnKSB7XG4gICAgICAgSGxzLmRlZmF1bHRDb25maWcgPSB7XG4gICAgICAgICAgYXV0b1N0YXJ0TG9hZDogdHJ1ZSxcbiAgICAgICAgICBzdGFydFBvc2l0aW9uOiAtMSxcbiAgICAgICAgICBkZWZhdWx0QXVkaW9Db2RlYzogdW5kZWZpbmVkLFxuICAgICAgICAgIGRlYnVnOiBmYWxzZSxcbiAgICAgICAgICBjYXBMZXZlbE9uRlBTRHJvcDogZmFsc2UsXG4gICAgICAgICAgY2FwTGV2ZWxUb1BsYXllclNpemU6IGZhbHNlLFxuICAgICAgICAgIG1heEJ1ZmZlckxlbmd0aDogMzAsXG4gICAgICAgICAgbWF4QnVmZmVyU2l6ZTogNjAgKiAxMDAwICogMTAwMCxcbiAgICAgICAgICBtYXhCdWZmZXJIb2xlOiAwLjUsXG4gICAgICAgICAgbWF4U2Vla0hvbGU6IDIsXG4gICAgICAgICAgc2Vla0hvbGVOdWRnZUR1cmF0aW9uOiAwLjAxLFxuICAgICAgICAgIHN0YWxsZWRJbkJ1ZmZlcmVkTnVkZ2VUaHJlc2hvbGQ6IDEwLFxuICAgICAgICAgIG1heEZyYWdMb29rVXBUb2xlcmFuY2U6IDAuMixcbiAgICAgICAgICBsaXZlU3luY0R1cmF0aW9uQ291bnQ6MyxcbiAgICAgICAgICBsaXZlTWF4TGF0ZW5jeUR1cmF0aW9uQ291bnQ6IEluZmluaXR5LFxuICAgICAgICAgIGxpdmVTeW5jRHVyYXRpb246IHVuZGVmaW5lZCxcbiAgICAgICAgICBsaXZlTWF4TGF0ZW5jeUR1cmF0aW9uOiB1bmRlZmluZWQsXG4gICAgICAgICAgbWF4TWF4QnVmZmVyTGVuZ3RoOiA2MDAsXG4gICAgICAgICAgZW5hYmxlV29ya2VyOiB0cnVlLFxuICAgICAgICAgIGVuYWJsZVNvZnR3YXJlQUVTOiB0cnVlLFxuICAgICAgICAgIG1hbmlmZXN0TG9hZGluZ1RpbWVPdXQ6IDEwMDAwLFxuICAgICAgICAgIG1hbmlmZXN0TG9hZGluZ01heFJldHJ5OiAxLFxuICAgICAgICAgIG1hbmlmZXN0TG9hZGluZ1JldHJ5RGVsYXk6IDEwMDAsXG4gICAgICAgICAgbWFuaWZlc3RMb2FkaW5nTWF4UmV0cnlUaW1lb3V0OiA2NDAwMCxcbiAgICAgICAgICBzdGFydExldmVsOiB1bmRlZmluZWQsXG4gICAgICAgICAgbGV2ZWxMb2FkaW5nVGltZU91dDogMTAwMDAsXG4gICAgICAgICAgbGV2ZWxMb2FkaW5nTWF4UmV0cnk6IDQsXG4gICAgICAgICAgbGV2ZWxMb2FkaW5nUmV0cnlEZWxheTogMTAwMCxcbiAgICAgICAgICBsZXZlbExvYWRpbmdNYXhSZXRyeVRpbWVvdXQ6IDY0MDAwLFxuICAgICAgICAgIGZyYWdMb2FkaW5nVGltZU91dDogMjAwMDAsXG4gICAgICAgICAgZnJhZ0xvYWRpbmdNYXhSZXRyeTogNixcbiAgICAgICAgICBmcmFnTG9hZGluZ1JldHJ5RGVsYXk6IDEwMDAsXG4gICAgICAgICAgZnJhZ0xvYWRpbmdNYXhSZXRyeVRpbWVvdXQ6IDY0MDAwLFxuICAgICAgICAgIGZyYWdMb2FkaW5nTG9vcFRocmVzaG9sZDogMyxcbiAgICAgICAgICBzdGFydEZyYWdQcmVmZXRjaDogZmFsc2UsXG4gICAgICAgICAgZnBzRHJvcHBlZE1vbml0b3JpbmdQZXJpb2Q6IDUwMDAsXG4gICAgICAgICAgZnBzRHJvcHBlZE1vbml0b3JpbmdUaHJlc2hvbGQ6IDAuMixcbiAgICAgICAgICBhcHBlbmRFcnJvck1heFJldHJ5OiAzLFxuICAgICAgICAgIGxvYWRlcjogWGhyTG9hZGVyLFxuICAgICAgICAgIC8vbG9hZGVyOiBGZXRjaExvYWRlcixcbiAgICAgICAgICBmTG9hZGVyOiB1bmRlZmluZWQsXG4gICAgICAgICAgcExvYWRlcjogdW5kZWZpbmVkLFxuICAgICAgICAgIHhoclNldHVwOiB1bmRlZmluZWQsXG4gICAgICAgICAgZmV0Y2hTZXR1cDogdW5kZWZpbmVkLFxuICAgICAgICAgIGFickNvbnRyb2xsZXI6IEFickNvbnRyb2xsZXIsXG4gICAgICAgICAgYnVmZmVyQ29udHJvbGxlcjogQnVmZmVyQ29udHJvbGxlcixcbiAgICAgICAgICBjYXBMZXZlbENvbnRyb2xsZXI6IENhcExldmVsQ29udHJvbGxlcixcbiAgICAgICAgICBmcHNDb250cm9sbGVyOiBGUFNDb250cm9sbGVyLFxuICAgICAgICAgIHN0cmVhbUNvbnRyb2xsZXI6IFN0cmVhbUNvbnRyb2xsZXIsXG4gICAgICAgICAgYXVkaW9TdHJlYW1Db250cm9sbGVyOiBBdWRpb1N0cmVhbUNvbnRyb2xsZXIsXG4gICAgICAgICAgdGltZWxpbmVDb250cm9sbGVyOiBUaW1lbGluZUNvbnRyb2xsZXIsXG4gICAgICAgICAgY3VlSGFuZGxlcjogQ3VlcyxcbiAgICAgICAgICBlbmFibGVDRUE3MDhDYXB0aW9uczogdHJ1ZSxcbiAgICAgICAgICBlbmFibGVNUDJUUGFzc1Rocm91Z2g6IGZhbHNlLFxuICAgICAgICAgIHN0cmV0Y2hTaG9ydFZpZGVvVHJhY2s6IGZhbHNlLFxuICAgICAgICAgIGZvcmNlS2V5RnJhbWVPbkRpc2NvbnRpbnVpdHk6IHRydWUsXG4gICAgICAgICAgYWJyRXdtYUZhc3RMaXZlOiA1LFxuICAgICAgICAgIGFickV3bWFTbG93TGl2ZTogOSxcbiAgICAgICAgICBhYnJFd21hRmFzdFZvRDogNCxcbiAgICAgICAgICBhYnJFd21hU2xvd1ZvRDogMTUsXG4gICAgICAgICAgYWJyRXdtYURlZmF1bHRFc3RpbWF0ZTogNWU1LCAvLyA1MDAga2Jwc1xuICAgICAgICAgIGFickJhbmRXaWR0aEZhY3RvciA6IDAuOCxcbiAgICAgICAgICBhYnJCYW5kV2lkdGhVcEZhY3RvciA6IDAuNyxcbiAgICAgICAgICBtYXhTdGFydmF0aW9uRGVsYXkgOiA0XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBIbHMuZGVmYXVsdENvbmZpZztcbiAgfVxuXG4gIHN0YXRpYyBzZXQgRGVmYXVsdENvbmZpZyhkZWZhdWx0Q29uZmlnKSB7XG4gICAgSGxzLmRlZmF1bHRDb25maWcgPSBkZWZhdWx0Q29uZmlnO1xuICB9XG5cbiAgY29uc3RydWN0b3IoY29uZmlnID0ge30pIHtcbiAgICB2YXIgZGVmYXVsdENvbmZpZyA9IEhscy5EZWZhdWx0Q29uZmlnO1xuXG4gICAgaWYgKChjb25maWcubGl2ZVN5bmNEdXJhdGlvbkNvdW50IHx8IGNvbmZpZy5saXZlTWF4TGF0ZW5jeUR1cmF0aW9uQ291bnQpICYmIChjb25maWcubGl2ZVN5bmNEdXJhdGlvbiB8fCBjb25maWcubGl2ZU1heExhdGVuY3lEdXJhdGlvbikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSWxsZWdhbCBobHMuanMgY29uZmlnOiBkb25cXCd0IG1peCB1cCBsaXZlU3luY0R1cmF0aW9uQ291bnQvbGl2ZU1heExhdGVuY3lEdXJhdGlvbkNvdW50IGFuZCBsaXZlU3luY0R1cmF0aW9uL2xpdmVNYXhMYXRlbmN5RHVyYXRpb24nKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBwcm9wIGluIGRlZmF1bHRDb25maWcpIHtcbiAgICAgICAgaWYgKHByb3AgaW4gY29uZmlnKSB7IGNvbnRpbnVlOyB9XG4gICAgICAgIGNvbmZpZ1twcm9wXSA9IGRlZmF1bHRDb25maWdbcHJvcF07XG4gICAgfVxuXG4gICAgaWYgKGNvbmZpZy5saXZlTWF4TGF0ZW5jeUR1cmF0aW9uQ291bnQgIT09IHVuZGVmaW5lZCAmJiBjb25maWcubGl2ZU1heExhdGVuY3lEdXJhdGlvbkNvdW50IDw9IGNvbmZpZy5saXZlU3luY0R1cmF0aW9uQ291bnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSWxsZWdhbCBobHMuanMgY29uZmlnOiBcImxpdmVNYXhMYXRlbmN5RHVyYXRpb25Db3VudFwiIG11c3QgYmUgZ3QgXCJsaXZlU3luY0R1cmF0aW9uQ291bnRcIicpO1xuICAgIH1cblxuICAgIGlmIChjb25maWcubGl2ZU1heExhdGVuY3lEdXJhdGlvbiAhPT0gdW5kZWZpbmVkICYmIChjb25maWcubGl2ZU1heExhdGVuY3lEdXJhdGlvbiA8PSBjb25maWcubGl2ZVN5bmNEdXJhdGlvbiB8fCBjb25maWcubGl2ZVN5bmNEdXJhdGlvbiA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbGxlZ2FsIGhscy5qcyBjb25maWc6IFwibGl2ZU1heExhdGVuY3lEdXJhdGlvblwiIG11c3QgYmUgZ3QgXCJsaXZlU3luY0R1cmF0aW9uXCInKTtcbiAgICB9XG5cbiAgICBlbmFibGVMb2dzKGNvbmZpZy5kZWJ1Zyk7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgLy8gb2JzZXJ2ZXIgc2V0dXBcbiAgICB2YXIgb2JzZXJ2ZXIgPSB0aGlzLm9ic2VydmVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgIG9ic2VydmVyLnRyaWdnZXIgPSBmdW5jdGlvbiB0cmlnZ2VyIChldmVudCwgLi4uZGF0YSkge1xuICAgICAgb2JzZXJ2ZXIuZW1pdChldmVudCwgZXZlbnQsIC4uLmRhdGEpO1xuICAgIH07XG5cbiAgICBvYnNlcnZlci5vZmYgPSBmdW5jdGlvbiBvZmYgKGV2ZW50LCAuLi5kYXRhKSB7XG4gICAgICBvYnNlcnZlci5yZW1vdmVMaXN0ZW5lcihldmVudCwgLi4uZGF0YSk7XG4gICAgfTtcbiAgICB0aGlzLm9uID0gb2JzZXJ2ZXIub24uYmluZChvYnNlcnZlcik7XG4gICAgdGhpcy5vZmYgPSBvYnNlcnZlci5vZmYuYmluZChvYnNlcnZlcik7XG4gICAgdGhpcy50cmlnZ2VyID0gb2JzZXJ2ZXIudHJpZ2dlci5iaW5kKG9ic2VydmVyKTtcbiAgICB0aGlzLnBsYXlsaXN0TG9hZGVyID0gbmV3IFBsYXlsaXN0TG9hZGVyKHRoaXMpO1xuICAgIHRoaXMuZnJhZ21lbnRMb2FkZXIgPSBuZXcgRnJhZ21lbnRMb2FkZXIodGhpcyk7XG4gICAgdGhpcy5sZXZlbENvbnRyb2xsZXIgPSBuZXcgTGV2ZWxDb250cm9sbGVyKHRoaXMpO1xuICAgIHRoaXMuYWJyQ29udHJvbGxlciA9IG5ldyBjb25maWcuYWJyQ29udHJvbGxlcih0aGlzKTtcbiAgICB0aGlzLmJ1ZmZlckNvbnRyb2xsZXIgPSBuZXcgY29uZmlnLmJ1ZmZlckNvbnRyb2xsZXIodGhpcyk7XG4gICAgdGhpcy5jYXBMZXZlbENvbnRyb2xsZXIgPSBuZXcgY29uZmlnLmNhcExldmVsQ29udHJvbGxlcih0aGlzKTtcbiAgICB0aGlzLmZwc0NvbnRyb2xsZXIgPSBuZXcgY29uZmlnLmZwc0NvbnRyb2xsZXIodGhpcyk7XG4gICAgdGhpcy5zdHJlYW1Db250cm9sbGVyID0gbmV3IGNvbmZpZy5zdHJlYW1Db250cm9sbGVyKHRoaXMpO1xuICAgIHRoaXMuYXVkaW9TdHJlYW1Db250cm9sbGVyID0gbmV3IGNvbmZpZy5hdWRpb1N0cmVhbUNvbnRyb2xsZXIodGhpcyk7XG4gICAgdGhpcy50aW1lbGluZUNvbnRyb2xsZXIgPSBuZXcgY29uZmlnLnRpbWVsaW5lQ29udHJvbGxlcih0aGlzKTtcbiAgICB0aGlzLmF1ZGlvVHJhY2tDb250cm9sbGVyID0gbmV3IEF1ZGlvVHJhY2tDb250cm9sbGVyKHRoaXMpO1xuICAgIHRoaXMua2V5TG9hZGVyID0gbmV3IEtleUxvYWRlcih0aGlzKTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgbG9nZ2VyLmxvZygnZGVzdHJveScpO1xuICAgIHRoaXMudHJpZ2dlcihFdmVudC5ERVNUUk9ZSU5HKTtcbiAgICB0aGlzLmRldGFjaE1lZGlhKCk7XG4gICAgdGhpcy5wbGF5bGlzdExvYWRlci5kZXN0cm95KCk7XG4gICAgdGhpcy5mcmFnbWVudExvYWRlci5kZXN0cm95KCk7XG4gICAgdGhpcy5sZXZlbENvbnRyb2xsZXIuZGVzdHJveSgpO1xuICAgIHRoaXMuYWJyQ29udHJvbGxlci5kZXN0cm95KCk7XG4gICAgdGhpcy5idWZmZXJDb250cm9sbGVyLmRlc3Ryb3koKTtcbiAgICB0aGlzLmNhcExldmVsQ29udHJvbGxlci5kZXN0cm95KCk7XG4gICAgdGhpcy5mcHNDb250cm9sbGVyLmRlc3Ryb3koKTtcbiAgICB0aGlzLnN0cmVhbUNvbnRyb2xsZXIuZGVzdHJveSgpO1xuICAgIHRoaXMuYXVkaW9TdHJlYW1Db250cm9sbGVyLmRlc3Ryb3koKTtcbiAgICB0aGlzLnRpbWVsaW5lQ29udHJvbGxlci5kZXN0cm95KCk7XG4gICAgdGhpcy5hdWRpb1RyYWNrQ29udHJvbGxlci5kZXN0cm95KCk7XG4gICAgdGhpcy5rZXlMb2FkZXIuZGVzdHJveSgpO1xuICAgIHRoaXMudXJsID0gbnVsbDtcbiAgICB0aGlzLm9ic2VydmVyLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICB9XG5cbiAgYXR0YWNoTWVkaWEobWVkaWEpIHtcbiAgICBsb2dnZXIubG9nKCdhdHRhY2hNZWRpYScpO1xuICAgIHRoaXMubWVkaWEgPSBtZWRpYTtcbiAgICB0aGlzLnRyaWdnZXIoRXZlbnQuTUVESUFfQVRUQUNISU5HLCB7bWVkaWE6IG1lZGlhfSk7XG4gIH1cblxuICBkZXRhY2hNZWRpYSgpIHtcbiAgICBsb2dnZXIubG9nKCdkZXRhY2hNZWRpYScpO1xuICAgIHRoaXMudHJpZ2dlcihFdmVudC5NRURJQV9ERVRBQ0hJTkcpO1xuICAgIHRoaXMubWVkaWEgPSBudWxsO1xuICB9XG5cbiAgbG9hZFNvdXJjZSh1cmwpIHtcbiAgICBsb2dnZXIubG9nKGBsb2FkU291cmNlOiR7dXJsfWApO1xuICAgIHRoaXMudXJsID0gdXJsO1xuICAgIC8vIHdoZW4gYXR0YWNoaW5nIHRvIGEgc291cmNlIFVSTCwgdHJpZ2dlciBhIHBsYXlsaXN0IGxvYWRcbiAgICB0aGlzLnRyaWdnZXIoRXZlbnQuTUFOSUZFU1RfTE9BRElORywge3VybDogdXJsfSk7XG4gIH1cblxuICBzdGFydExvYWQoc3RhcnRQb3NpdGlvbj0tMSkge1xuICAgIGxvZ2dlci5sb2coJ3N0YXJ0TG9hZCcpO1xuICAgIHRoaXMubGV2ZWxDb250cm9sbGVyLnN0YXJ0TG9hZCgpO1xuICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlci5zdGFydExvYWQoc3RhcnRQb3NpdGlvbik7XG4gICAgdGhpcy5hdWRpb1N0cmVhbUNvbnRyb2xsZXIuc3RhcnRMb2FkKHN0YXJ0UG9zaXRpb24pO1xuICB9XG5cbiAgc3RvcExvYWQoKSB7XG4gICAgbG9nZ2VyLmxvZygnc3RvcExvYWQnKTtcbiAgICB0aGlzLmxldmVsQ29udHJvbGxlci5zdG9wTG9hZCgpO1xuICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlci5zdG9wTG9hZCgpO1xuICAgIHRoaXMuYXVkaW9TdHJlYW1Db250cm9sbGVyLnN0b3BMb2FkKCk7XG4gIH1cblxuICBzd2FwQXVkaW9Db2RlYygpIHtcbiAgICBsb2dnZXIubG9nKCdzd2FwQXVkaW9Db2RlYycpO1xuICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlci5zd2FwQXVkaW9Db2RlYygpO1xuICB9XG5cbiAgcmVjb3Zlck1lZGlhRXJyb3IoKSB7XG4gICAgbG9nZ2VyLmxvZygncmVjb3Zlck1lZGlhRXJyb3InKTtcbiAgICB2YXIgbWVkaWEgPSB0aGlzLm1lZGlhO1xuICAgIHRoaXMuZGV0YWNoTWVkaWEoKTtcbiAgICB0aGlzLmF0dGFjaE1lZGlhKG1lZGlhKTtcbiAgfVxuXG4gIC8qKiBSZXR1cm4gYWxsIHF1YWxpdHkgbGV2ZWxzICoqL1xuICBnZXQgbGV2ZWxzKCkge1xuICAgIHJldHVybiB0aGlzLmxldmVsQ29udHJvbGxlci5sZXZlbHM7XG4gIH1cblxuICAvKiogUmV0dXJuIGN1cnJlbnQgcGxheWJhY2sgcXVhbGl0eSBsZXZlbCAqKi9cbiAgZ2V0IGN1cnJlbnRMZXZlbCgpIHtcbiAgICByZXR1cm4gdGhpcy5zdHJlYW1Db250cm9sbGVyLmN1cnJlbnRMZXZlbDtcbiAgfVxuXG4gIC8qIHNldCBxdWFsaXR5IGxldmVsIGltbWVkaWF0ZWx5ICgtMSBmb3IgYXV0b21hdGljIGxldmVsIHNlbGVjdGlvbikgKi9cbiAgc2V0IGN1cnJlbnRMZXZlbChuZXdMZXZlbCkge1xuICAgIGxvZ2dlci5sb2coYHNldCBjdXJyZW50TGV2ZWw6JHtuZXdMZXZlbH1gKTtcbiAgICB0aGlzLmxvYWRMZXZlbCA9IG5ld0xldmVsO1xuICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlci5pbW1lZGlhdGVMZXZlbFN3aXRjaCgpO1xuICB9XG5cbiAgLyoqIFJldHVybiBuZXh0IHBsYXliYWNrIHF1YWxpdHkgbGV2ZWwgKHF1YWxpdHkgbGV2ZWwgb2YgbmV4dCBmcmFnbWVudCkgKiovXG4gIGdldCBuZXh0TGV2ZWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RyZWFtQ29udHJvbGxlci5uZXh0TGV2ZWw7XG4gIH1cblxuICAvKiBzZXQgcXVhbGl0eSBsZXZlbCBmb3IgbmV4dCBmcmFnbWVudCAoLTEgZm9yIGF1dG9tYXRpYyBsZXZlbCBzZWxlY3Rpb24pICovXG4gIHNldCBuZXh0TGV2ZWwobmV3TGV2ZWwpIHtcbiAgICBsb2dnZXIubG9nKGBzZXQgbmV4dExldmVsOiR7bmV3TGV2ZWx9YCk7XG4gICAgdGhpcy5sZXZlbENvbnRyb2xsZXIubWFudWFsTGV2ZWwgPSBuZXdMZXZlbDtcbiAgICB0aGlzLnN0cmVhbUNvbnRyb2xsZXIubmV4dExldmVsU3dpdGNoKCk7XG4gIH1cblxuICAvKiogUmV0dXJuIHRoZSBxdWFsaXR5IGxldmVsIG9mIGN1cnJlbnQvbGFzdCBsb2FkZWQgZnJhZ21lbnQgKiovXG4gIGdldCBsb2FkTGV2ZWwoKSB7XG4gICAgcmV0dXJuIHRoaXMubGV2ZWxDb250cm9sbGVyLmxldmVsO1xuICB9XG5cbiAgLyogc2V0IHF1YWxpdHkgbGV2ZWwgZm9yIGN1cnJlbnQvbmV4dCBsb2FkZWQgZnJhZ21lbnQgKC0xIGZvciBhdXRvbWF0aWMgbGV2ZWwgc2VsZWN0aW9uKSAqL1xuICBzZXQgbG9hZExldmVsKG5ld0xldmVsKSB7XG4gICAgbG9nZ2VyLmxvZyhgc2V0IGxvYWRMZXZlbDoke25ld0xldmVsfWApO1xuICAgIHRoaXMubGV2ZWxDb250cm9sbGVyLm1hbnVhbExldmVsID0gbmV3TGV2ZWw7XG4gIH1cblxuICAvKiogUmV0dXJuIHRoZSBxdWFsaXR5IGxldmVsIG9mIG5leHQgbG9hZGVkIGZyYWdtZW50ICoqL1xuICBnZXQgbmV4dExvYWRMZXZlbCgpIHtcbiAgICByZXR1cm4gdGhpcy5sZXZlbENvbnRyb2xsZXIubmV4dExvYWRMZXZlbDtcbiAgfVxuXG4gIC8qKiBzZXQgcXVhbGl0eSBsZXZlbCBvZiBuZXh0IGxvYWRlZCBmcmFnbWVudCAqKi9cbiAgc2V0IG5leHRMb2FkTGV2ZWwobGV2ZWwpIHtcbiAgICB0aGlzLmxldmVsQ29udHJvbGxlci5uZXh0TG9hZExldmVsID0gbGV2ZWw7XG4gIH1cblxuICAvKiogUmV0dXJuIGZpcnN0IGxldmVsIChpbmRleCBvZiBmaXJzdCBsZXZlbCByZWZlcmVuY2VkIGluIG1hbmlmZXN0KVxuICAqKi9cbiAgZ2V0IGZpcnN0TGV2ZWwoKSB7XG4gICAgcmV0dXJuIHRoaXMubGV2ZWxDb250cm9sbGVyLmZpcnN0TGV2ZWw7XG4gIH1cblxuICAvKiogc2V0IGZpcnN0IGxldmVsIChpbmRleCBvZiBmaXJzdCBsZXZlbCByZWZlcmVuY2VkIGluIG1hbmlmZXN0KVxuICAqKi9cbiAgc2V0IGZpcnN0TGV2ZWwobmV3TGV2ZWwpIHtcbiAgICBsb2dnZXIubG9nKGBzZXQgZmlyc3RMZXZlbDoke25ld0xldmVsfWApO1xuICAgIHRoaXMubGV2ZWxDb250cm9sbGVyLmZpcnN0TGV2ZWwgPSBuZXdMZXZlbDtcbiAgfVxuXG4gIC8qKiBSZXR1cm4gc3RhcnQgbGV2ZWwgKGxldmVsIG9mIGZpcnN0IGZyYWdtZW50IHRoYXQgd2lsbCBiZSBwbGF5ZWQgYmFjaylcbiAgICAgIGlmIG5vdCBvdmVycmlkZWQgYnkgdXNlciwgZmlyc3QgbGV2ZWwgYXBwZWFyaW5nIGluIG1hbmlmZXN0IHdpbGwgYmUgdXNlZCBhcyBzdGFydCBsZXZlbFxuICAgICAgaWYgLTEgOiBhdXRvbWF0aWMgc3RhcnQgbGV2ZWwgc2VsZWN0aW9uLCBwbGF5YmFjayB3aWxsIHN0YXJ0IGZyb20gbGV2ZWwgbWF0Y2hpbmcgZG93bmxvYWQgYmFuZHdpZHRoIChkZXRlcm1pbmVkIGZyb20gZG93bmxvYWQgb2YgZmlyc3Qgc2VnbWVudClcbiAgKiovXG4gIGdldCBzdGFydExldmVsKCkge1xuICAgIHJldHVybiB0aGlzLmxldmVsQ29udHJvbGxlci5zdGFydExldmVsO1xuICB9XG5cbiAgLyoqIHNldCAgc3RhcnQgbGV2ZWwgKGxldmVsIG9mIGZpcnN0IGZyYWdtZW50IHRoYXQgd2lsbCBiZSBwbGF5ZWQgYmFjaylcbiAgICAgIGlmIG5vdCBvdmVycmlkZWQgYnkgdXNlciwgZmlyc3QgbGV2ZWwgYXBwZWFyaW5nIGluIG1hbmlmZXN0IHdpbGwgYmUgdXNlZCBhcyBzdGFydCBsZXZlbFxuICAgICAgaWYgLTEgOiBhdXRvbWF0aWMgc3RhcnQgbGV2ZWwgc2VsZWN0aW9uLCBwbGF5YmFjayB3aWxsIHN0YXJ0IGZyb20gbGV2ZWwgbWF0Y2hpbmcgZG93bmxvYWQgYmFuZHdpZHRoIChkZXRlcm1pbmVkIGZyb20gZG93bmxvYWQgb2YgZmlyc3Qgc2VnbWVudClcbiAgKiovXG4gIHNldCBzdGFydExldmVsKG5ld0xldmVsKSB7XG4gICAgbG9nZ2VyLmxvZyhgc2V0IHN0YXJ0TGV2ZWw6JHtuZXdMZXZlbH1gKTtcbiAgICB0aGlzLmxldmVsQ29udHJvbGxlci5zdGFydExldmVsID0gbmV3TGV2ZWw7XG4gIH1cblxuICAvKiogUmV0dXJuIHRoZSBjYXBwaW5nL21heCBsZXZlbCB2YWx1ZSB0aGF0IGNvdWxkIGJlIHVzZWQgYnkgYXV0b21hdGljIGxldmVsIHNlbGVjdGlvbiBhbGdvcml0aG0gKiovXG4gIGdldCBhdXRvTGV2ZWxDYXBwaW5nKCkge1xuICAgIHJldHVybiB0aGlzLmFickNvbnRyb2xsZXIuYXV0b0xldmVsQ2FwcGluZztcbiAgfVxuXG4gIC8qKiBzZXQgdGhlIGNhcHBpbmcvbWF4IGxldmVsIHZhbHVlIHRoYXQgY291bGQgYmUgdXNlZCBieSBhdXRvbWF0aWMgbGV2ZWwgc2VsZWN0aW9uIGFsZ29yaXRobSAqKi9cbiAgc2V0IGF1dG9MZXZlbENhcHBpbmcobmV3TGV2ZWwpIHtcbiAgICBsb2dnZXIubG9nKGBzZXQgYXV0b0xldmVsQ2FwcGluZzoke25ld0xldmVsfWApO1xuICAgIHRoaXMuYWJyQ29udHJvbGxlci5hdXRvTGV2ZWxDYXBwaW5nID0gbmV3TGV2ZWw7XG4gIH1cblxuICAvKiBjaGVjayBpZiB3ZSBhcmUgaW4gYXV0b21hdGljIGxldmVsIHNlbGVjdGlvbiBtb2RlICovXG4gIGdldCBhdXRvTGV2ZWxFbmFibGVkKCkge1xuICAgIHJldHVybiAodGhpcy5sZXZlbENvbnRyb2xsZXIubWFudWFsTGV2ZWwgPT09IC0xKTtcbiAgfVxuXG4gIC8qIHJldHVybiBtYW51YWwgbGV2ZWwgKi9cbiAgZ2V0IG1hbnVhbExldmVsKCkge1xuICAgIHJldHVybiB0aGlzLmxldmVsQ29udHJvbGxlci5tYW51YWxMZXZlbDtcbiAgfVxuXG4gIC8qKiBnZXQgYWx0ZXJuYXRlIGF1ZGlvIHRyYWNrcyBsaXN0IGZyb20gcGxheWxpc3QgKiovXG4gIGdldCBhdWRpb1RyYWNrcygpIHtcbiAgICByZXR1cm4gdGhpcy5hdWRpb1RyYWNrQ29udHJvbGxlci5hdWRpb1RyYWNrcztcbiAgfVxuXG4gIC8qKiBnZXQgaW5kZXggb2YgdGhlIHNlbGVjdGVkIGF1ZGlvIHRyYWNrIChpbmRleCBpbiBhdWRpbyB0cmFjayBsaXN0cykgKiovXG4gIGdldCBhdWRpb1RyYWNrKCkge1xuICAgcmV0dXJuIHRoaXMuYXVkaW9UcmFja0NvbnRyb2xsZXIuYXVkaW9UcmFjaztcbiAgfVxuXG4gIC8qKiBzZWxlY3QgYW4gYXVkaW8gdHJhY2ssIGJhc2VkIG9uIGl0cyBpbmRleCBpbiBhdWRpbyB0cmFjayBsaXN0cyoqL1xuICBzZXQgYXVkaW9UcmFjayhhdWRpb1RyYWNrSWQpIHtcbiAgICB0aGlzLmF1ZGlvVHJhY2tDb250cm9sbGVyLmF1ZGlvVHJhY2sgPSBhdWRpb1RyYWNrSWQ7XG4gIH1cblxuICBnZXQgbGl2ZVN5bmNQb3NpdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnN0cmVhbUNvbnRyb2xsZXIubGl2ZVN5bmNQb3NpdGlvbjtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBIbHM7XG4iLCIvLyBUaGlzIGlzIG1vc3RseSBmb3Igc3VwcG9ydCBvZiB0aGUgZXM2IG1vZHVsZSBleHBvcnRcbi8vIHN5bnRheCB3aXRoIHRoZSBiYWJlbCBjb21waWxlciwgaXQgbG9va3MgbGlrZSBpdCBkb2VzbnQgc3VwcG9ydFxuLy8gZnVuY3Rpb24gZXhwb3J0cyBsaWtlIHdlIGFyZSB1c2VkIHRvIGluIG5vZGUvY29tbW9uanNcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9obHMuanMnKS5kZWZhdWx0O1xuIiwiLypcbiAqIEZyYWdtZW50IExvYWRlclxuKi9cblxuaW1wb3J0IEV2ZW50IGZyb20gJy4uL2V2ZW50cyc7XG5pbXBvcnQgRXZlbnRIYW5kbGVyIGZyb20gJy4uL2V2ZW50LWhhbmRsZXInO1xuaW1wb3J0IHtFcnJvclR5cGVzLCBFcnJvckRldGFpbHN9IGZyb20gJy4uL2Vycm9ycyc7XG5pbXBvcnQge2xvZ2dlcn0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcblxuY2xhc3MgRnJhZ21lbnRMb2FkZXIgZXh0ZW5kcyBFdmVudEhhbmRsZXIge1xuXG4gIGNvbnN0cnVjdG9yKGhscykge1xuICAgIHN1cGVyKGhscywgRXZlbnQuRlJBR19MT0FESU5HKTtcbiAgICB0aGlzLmxvYWRlcnMgPSB7fTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgZm9yIChsZXQgbG9hZGVyTmFtZSBpbiB0aGlzLmxvYWRlcnMpIHtcbiAgICAgIGxldCBsb2FkZXIgPSB0aGlzLmxvYWRlcnNbbG9hZGVyTmFtZV07XG4gICAgICBpZiAobG9hZGVyKSB7XG4gICAgICAgIGxvYWRlci5kZXN0cm95KCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMubG9hZGVycyA9IHt9O1xuICAgIEV2ZW50SGFuZGxlci5wcm90b3R5cGUuZGVzdHJveS5jYWxsKHRoaXMpO1xuICB9XG5cbiAgb25GcmFnTG9hZGluZyhkYXRhKSB7XG4gICAgbGV0IGZyYWcgPSBkYXRhLmZyYWcsXG4gICAgICAgIHR5cGUgPSBmcmFnLnR5cGUsXG4gICAgICAgIGxvYWRlciA9IHRoaXMubG9hZGVyc1t0eXBlXSxcbiAgICAgICAgY29uZmlnID0gdGhpcy5obHMuY29uZmlnO1xuXG4gICAgZnJhZy5sb2FkZWQgPSAwO1xuICAgIGlmIChsb2FkZXIpIHtcbiAgICAgIGxvZ2dlci53YXJuKGBhYm9ydCBwcmV2aW91cyBmcmFnbWVudCBsb2FkZXIgZm9yIHR5cGU6JHt0eXBlfWApO1xuICAgICAgbG9hZGVyLmFib3J0KCk7XG4gICAgfVxuICAgIGxvYWRlciAgPSB0aGlzLmxvYWRlcnNbdHlwZV0gPSBmcmFnLmxvYWRlciA9IHR5cGVvZihjb25maWcuZkxvYWRlcikgIT09ICd1bmRlZmluZWQnID8gbmV3IGNvbmZpZy5mTG9hZGVyKGNvbmZpZykgOiBuZXcgY29uZmlnLmxvYWRlcihjb25maWcpO1xuXG4gICAgbGV0IGxvYWRlckNvbnRleHQsIGxvYWRlckNvbmZpZywgbG9hZGVyQ2FsbGJhY2tzO1xuICAgIGxvYWRlckNvbnRleHQgPSB7IHVybCA6IGZyYWcudXJsLCBmcmFnIDogZnJhZywgcmVzcG9uc2VUeXBlIDogJ2FycmF5YnVmZmVyJywgcHJvZ3Jlc3NEYXRhIDogZmFsc2V9O1xuICAgIGxldCBzdGFydCA9IGZyYWcuYnl0ZVJhbmdlU3RhcnRPZmZzZXQsIGVuZCA9IGZyYWcuYnl0ZVJhbmdlRW5kT2Zmc2V0O1xuICAgIGlmICghaXNOYU4oc3RhcnQpICYmICFpc05hTihlbmQpKSB7XG4gICAgICBsb2FkZXJDb250ZXh0LnJhbmdlU3RhcnQgPSBzdGFydDtcbiAgICAgIGxvYWRlckNvbnRleHQucmFuZ2VFbmQgPSBlbmQ7XG4gICAgfVxuICAgIGxvYWRlckNvbmZpZyA9IHsgdGltZW91dCA6IGNvbmZpZy5mcmFnTG9hZGluZ1RpbWVPdXQsIG1heFJldHJ5IDogMCAsIHJldHJ5RGVsYXkgOiAwLCBtYXhSZXRyeURlbGF5IDogY29uZmlnLmZyYWdMb2FkaW5nTWF4UmV0cnlUaW1lb3V0fTtcbiAgICBsb2FkZXJDYWxsYmFja3MgPSB7IG9uU3VjY2VzcyA6IHRoaXMubG9hZHN1Y2Nlc3MuYmluZCh0aGlzKSwgb25FcnJvciA6dGhpcy5sb2FkZXJyb3IuYmluZCh0aGlzKSwgb25UaW1lb3V0IDogdGhpcy5sb2FkdGltZW91dC5iaW5kKHRoaXMpLCBvblByb2dyZXNzOiB0aGlzLmxvYWRwcm9ncmVzcy5iaW5kKHRoaXMpfTtcbiAgICBsb2FkZXIubG9hZChsb2FkZXJDb250ZXh0LGxvYWRlckNvbmZpZyxsb2FkZXJDYWxsYmFja3MpO1xuICB9XG5cbiAgbG9hZHN1Y2Nlc3MocmVzcG9uc2UsIHN0YXRzLCBjb250ZXh0KSB7XG4gICAgbGV0IHBheWxvYWQgPSByZXNwb25zZS5kYXRhLCBmcmFnID0gY29udGV4dC5mcmFnO1xuICAgIC8vIGRldGFjaCBmcmFnbWVudCBsb2FkZXIgb24gbG9hZCBzdWNjZXNzXG4gICAgZnJhZy5sb2FkZXIgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5sb2FkZXJzW2ZyYWcudHlwZV0gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5GUkFHX0xPQURFRCwge3BheWxvYWQ6IHBheWxvYWQsIGZyYWc6IGZyYWcsIHN0YXRzOiBzdGF0c30pO1xuICB9XG5cbiAgbG9hZGVycm9yKHJlc3BvbnNlLCBjb250ZXh0KSB7XG4gICAgbGV0IGxvYWRlciA9IGNvbnRleHQubG9hZGVyO1xuICAgIGlmIChsb2FkZXIpIHtcbiAgICAgIGxvYWRlci5hYm9ydCgpO1xuICAgIH1cbiAgICB0aGlzLmxvYWRlcnNbY29udGV4dC50eXBlXSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkVSUk9SLCB7dHlwZTogRXJyb3JUeXBlcy5ORVRXT1JLX0VSUk9SLCBkZXRhaWxzOiBFcnJvckRldGFpbHMuRlJBR19MT0FEX0VSUk9SLCBmYXRhbDogZmFsc2UsIGZyYWc6IGNvbnRleHQuZnJhZywgcmVzcG9uc2U6IHJlc3BvbnNlfSk7XG4gIH0gXG5cbiAgbG9hZHRpbWVvdXQoc3RhdHMsIGNvbnRleHQpIHtcbiAgICBsZXQgbG9hZGVyID0gY29udGV4dC5sb2FkZXI7XG4gICAgaWYgKGxvYWRlcikge1xuICAgICAgbG9hZGVyLmFib3J0KCk7XG4gICAgfVxuICAgIHRoaXMubG9hZGVyc1tjb250ZXh0LnR5cGVdID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuRVJST1IsIHt0eXBlOiBFcnJvclR5cGVzLk5FVFdPUktfRVJST1IsIGRldGFpbHM6IEVycm9yRGV0YWlscy5GUkFHX0xPQURfVElNRU9VVCwgZmF0YWw6IGZhbHNlLCBmcmFnOiBjb250ZXh0LmZyYWd9KTtcbiAgfVxuXG4gIC8vIGRhdGEgd2lsbCBiZSB1c2VkIGZvciBwcm9ncmVzc2l2ZSBwYXJzaW5nXG4gIGxvYWRwcm9ncmVzcyhzdGF0cywgY29udGV4dCwgZGF0YSkgeyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbiAgICBsZXQgZnJhZyA9IGNvbnRleHQuZnJhZztcbiAgICBmcmFnLmxvYWRlZCA9IHN0YXRzLmxvYWRlZDtcbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkZSQUdfTE9BRF9QUk9HUkVTUywge2ZyYWc6IGZyYWcsIHN0YXRzOiBzdGF0c30pO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEZyYWdtZW50TG9hZGVyO1xuIiwiLypcbiAqIERlY3J5cHQga2V5IExvYWRlclxuKi9cblxuaW1wb3J0IEV2ZW50IGZyb20gJy4uL2V2ZW50cyc7XG5pbXBvcnQgRXZlbnRIYW5kbGVyIGZyb20gJy4uL2V2ZW50LWhhbmRsZXInO1xuaW1wb3J0IHtFcnJvclR5cGVzLCBFcnJvckRldGFpbHN9IGZyb20gJy4uL2Vycm9ycyc7XG5pbXBvcnQge2xvZ2dlcn0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcblxuY2xhc3MgS2V5TG9hZGVyIGV4dGVuZHMgRXZlbnRIYW5kbGVyIHtcblxuICBjb25zdHJ1Y3RvcihobHMpIHtcbiAgICBzdXBlcihobHMsIEV2ZW50LktFWV9MT0FESU5HKTtcbiAgICB0aGlzLmxvYWRlcnMgPSB7fTtcbiAgICB0aGlzLmRlY3J5cHRrZXkgPSBudWxsO1xuICAgIHRoaXMuZGVjcnlwdHVybCA9IG51bGw7XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIGZvciAobGV0IGxvYWRlck5hbWUgaW4gdGhpcy5sb2FkZXJzKSB7XG4gICAgICBsZXQgbG9hZGVyID0gdGhpcy5sb2FkZXJzW2xvYWRlck5hbWVdO1xuICAgICAgaWYgKGxvYWRlcikge1xuICAgICAgICBsb2FkZXIuZGVzdHJveSgpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmxvYWRlcnMgPSB7fTtcbiAgICBFdmVudEhhbmRsZXIucHJvdG90eXBlLmRlc3Ryb3kuY2FsbCh0aGlzKTtcbiAgfVxuXG4gIG9uS2V5TG9hZGluZyhkYXRhKSB7XG4gICAgbGV0IGZyYWcgPSBkYXRhLmZyYWcsXG4gICAgICAgIHR5cGUgPSBmcmFnLnR5cGUsXG4gICAgICAgIGxvYWRlciA9IHRoaXMubG9hZGVyc1t0eXBlXSxcbiAgICAgICAgZGVjcnlwdGRhdGEgPSBmcmFnLmRlY3J5cHRkYXRhLFxuICAgICAgICB1cmkgPSBkZWNyeXB0ZGF0YS51cmk7XG4gICAgICAgIC8vIGlmIHVyaSBpcyBkaWZmZXJlbnQgZnJvbSBwcmV2aW91cyBvbmUgb3IgaWYgZGVjcnlwdCBrZXkgbm90IHJldHJpZXZlZCB5ZXRcbiAgICAgIGlmICh1cmkgIT09IHRoaXMuZGVjcnlwdHVybCB8fCB0aGlzLmRlY3J5cHRrZXkgPT09IG51bGwpIHtcbiAgICAgICAgbGV0IGNvbmZpZyA9IHRoaXMuaGxzLmNvbmZpZztcblxuICAgICAgICBpZiAobG9hZGVyKSB7XG4gICAgICAgICAgbG9nZ2VyLndhcm4oYGFib3J0IHByZXZpb3VzIGZyYWdtZW50IGxvYWRlciBmb3IgdHlwZToke3R5cGV9YCk7XG4gICAgICAgICAgbG9hZGVyLmFib3J0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZnJhZy5sb2FkZXIgPSB0aGlzLmxvYWRlcnNbdHlwZV0gPSBuZXcgY29uZmlnLmxvYWRlcihjb25maWcpO1xuICAgICAgICB0aGlzLmRlY3J5cHR1cmwgPSB1cmk7XG4gICAgICAgIHRoaXMuZGVjcnlwdGtleSA9IG51bGw7XG5cbiAgICAgICAgbGV0IGxvYWRlckNvbnRleHQsIGxvYWRlckNvbmZpZywgbG9hZGVyQ2FsbGJhY2tzO1xuICAgICAgICBsb2FkZXJDb250ZXh0ID0geyB1cmwgOiB1cmksIGZyYWcgOiBmcmFnLCByZXNwb25zZVR5cGUgOiAnYXJyYXlidWZmZXInfTtcbiAgICAgICAgbG9hZGVyQ29uZmlnID0geyB0aW1lb3V0IDogY29uZmlnLmZyYWdMb2FkaW5nVGltZU91dCwgbWF4UmV0cnkgOiBjb25maWcuZnJhZ0xvYWRpbmdNYXhSZXRyeSAsIHJldHJ5RGVsYXkgOiBjb25maWcuZnJhZ0xvYWRpbmdSZXRyeURlbGF5LCBtYXhSZXRyeURlbGF5IDogY29uZmlnLmZyYWdMb2FkaW5nTWF4UmV0cnlUaW1lb3V0fTtcbiAgICAgICAgbG9hZGVyQ2FsbGJhY2tzID0geyBvblN1Y2Nlc3MgOiB0aGlzLmxvYWRzdWNjZXNzLmJpbmQodGhpcyksIG9uRXJyb3IgOnRoaXMubG9hZGVycm9yLmJpbmQodGhpcyksIG9uVGltZW91dCA6IHRoaXMubG9hZHRpbWVvdXQuYmluZCh0aGlzKX07XG4gICAgICAgIGZyYWcubG9hZGVyLmxvYWQobG9hZGVyQ29udGV4dCxsb2FkZXJDb25maWcsbG9hZGVyQ2FsbGJhY2tzKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5kZWNyeXB0a2V5KSB7XG4gICAgICAgIC8vIHdlIGFscmVhZHkgbG9hZGVkIHRoaXMga2V5LCByZXR1cm4gaXRcbiAgICAgICAgZGVjcnlwdGRhdGEua2V5ID0gdGhpcy5kZWNyeXB0a2V5O1xuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LktFWV9MT0FERUQsIHtmcmFnOiBmcmFnfSk7XG4gICAgICB9XG4gIH1cblxuICBsb2Fkc3VjY2VzcyhyZXNwb25zZSwgc3RhdHMsIGNvbnRleHQpIHtcbiAgICBsZXQgZnJhZyA9IGNvbnRleHQuZnJhZztcbiAgICB0aGlzLmRlY3J5cHRrZXkgPSBmcmFnLmRlY3J5cHRkYXRhLmtleSA9IG5ldyBVaW50OEFycmF5KHJlc3BvbnNlLmRhdGEpO1xuICAgIC8vIGRldGFjaCBmcmFnbWVudCBsb2FkZXIgb24gbG9hZCBzdWNjZXNzXG4gICAgZnJhZy5sb2FkZXIgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5sb2FkZXJzW2NvbnRleHQudHlwZV0gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5LRVlfTE9BREVELCB7ZnJhZzogZnJhZ30pO1xuICB9XG5cbiAgbG9hZGVycm9yKHJlc3BvbnNlLCBjb250ZXh0KSB7XG4gICAgbGV0IGZyYWcgPSBjb250ZXh0LmZyYWcsXG4gICAgICAgIGxvYWRlciA9IGZyYWcubG9hZGVyO1xuICAgIGlmIChsb2FkZXIpIHtcbiAgICAgIGxvYWRlci5hYm9ydCgpO1xuICAgIH1cbiAgICB0aGlzLmxvYWRlcnNbY29udGV4dC50eXBlXSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkVSUk9SLCB7dHlwZTogRXJyb3JUeXBlcy5ORVRXT1JLX0VSUk9SLCBkZXRhaWxzOiBFcnJvckRldGFpbHMuS0VZX0xPQURfRVJST1IsIGZhdGFsOiBmYWxzZSwgZnJhZzogZnJhZywgcmVzcG9uc2U6IHJlc3BvbnNlfSk7XG4gIH1cblxuICBsb2FkdGltZW91dChzdGF0cywgY29udGV4dCkge1xuICAgIGxldCBmcmFnID0gY29udGV4dC5mcmFnLFxuICAgICAgICBsb2FkZXIgPSBmcmFnLmxvYWRlcjtcbiAgICBpZiAobG9hZGVyKSB7XG4gICAgICBsb2FkZXIuYWJvcnQoKTtcbiAgICB9XG4gICAgdGhpcy5sb2FkZXJzW2NvbnRleHQudHlwZV0gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5FUlJPUiwge3R5cGU6IEVycm9yVHlwZXMuTkVUV09SS19FUlJPUiwgZGV0YWlsczogRXJyb3JEZXRhaWxzLktFWV9MT0FEX1RJTUVPVVQsIGZhdGFsOiBmYWxzZSwgZnJhZzogZnJhZ30pO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEtleUxvYWRlcjtcbiIsIi8qKlxuICogUGxheWxpc3QgTG9hZGVyXG4qL1xuXG5pbXBvcnQgRXZlbnQgZnJvbSAnLi4vZXZlbnRzJztcbmltcG9ydCBFdmVudEhhbmRsZXIgZnJvbSAnLi4vZXZlbnQtaGFuZGxlcic7XG5pbXBvcnQge0Vycm9yVHlwZXMsIEVycm9yRGV0YWlsc30gZnJvbSAnLi4vZXJyb3JzJztcbmltcG9ydCBVUkxIZWxwZXIgZnJvbSAnLi4vdXRpbHMvdXJsJztcbmltcG9ydCBBdHRyTGlzdCBmcm9tICcuLi91dGlscy9hdHRyLWxpc3QnO1xuaW1wb3J0IHtsb2dnZXJ9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XG5cbmNsYXNzIFBsYXlsaXN0TG9hZGVyIGV4dGVuZHMgRXZlbnRIYW5kbGVyIHtcblxuICBjb25zdHJ1Y3RvcihobHMpIHtcbiAgICBzdXBlcihobHMsXG4gICAgICBFdmVudC5NQU5JRkVTVF9MT0FESU5HLFxuICAgICAgRXZlbnQuTEVWRUxfTE9BRElORyxcbiAgICAgIEV2ZW50LkFVRElPX1RSQUNLX0xPQURJTkcpO1xuICAgIHRoaXMubG9hZGVycyA9IHt9O1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICBmb3IgKGxldCBsb2FkZXJOYW1lIGluIHRoaXMubG9hZGVycykge1xuICAgICAgbGV0IGxvYWRlciA9IHRoaXMubG9hZGVyc1tsb2FkZXJOYW1lXTtcbiAgICAgIGlmIChsb2FkZXIpIHtcbiAgICAgICAgbG9hZGVyLmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5sb2FkZXJzID0ge307XG4gICAgRXZlbnRIYW5kbGVyLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XG4gIH1cblxuICBvbk1hbmlmZXN0TG9hZGluZyhkYXRhKSB7XG4gICAgdGhpcy5sb2FkKGRhdGEudXJsLCB7IHR5cGUgOiAnbWFuaWZlc3QnfSk7XG4gIH1cblxuICBvbkxldmVsTG9hZGluZyhkYXRhKSB7XG4gICAgdGhpcy5sb2FkKGRhdGEudXJsLCB7IHR5cGUgOiAnbGV2ZWwnLCBsZXZlbCA6IGRhdGEubGV2ZWwsIGlkIDogZGF0YS5pZH0pO1xuICB9XG5cbiAgb25BdWRpb1RyYWNrTG9hZGluZyhkYXRhKSB7XG4gICAgdGhpcy5sb2FkKGRhdGEudXJsLCB7IHR5cGUgOiAnYXVkaW9UcmFjaycsIGlkIDogZGF0YS5pZH0pO1xuICB9XG5cbiAgbG9hZCh1cmwsIGNvbnRleHQpIHtcbiAgICB2YXIgY29uZmlnID0gdGhpcy5obHMuY29uZmlnLFxuICAgICAgICByZXRyeSxcbiAgICAgICAgdGltZW91dCxcbiAgICAgICAgcmV0cnlEZWxheSxcbiAgICAgICAgbWF4UmV0cnlEZWxheTtcbiAgICBpZihjb250ZXh0LnR5cGUgPT09ICdtYW5pZmVzdCcpIHtcbiAgICAgIHJldHJ5ID0gY29uZmlnLm1hbmlmZXN0TG9hZGluZ01heFJldHJ5O1xuICAgICAgdGltZW91dCA9IGNvbmZpZy5tYW5pZmVzdExvYWRpbmdUaW1lT3V0O1xuICAgICAgcmV0cnlEZWxheSA9IGNvbmZpZy5tYW5pZmVzdExvYWRpbmdSZXRyeURlbGF5O1xuICAgICAgbWF4UmV0cnlEZWxheSA9IGNvbmZpZy5tYW5pZmVzdExvYWRpbmdNYXhSZXRyeVRpbWVPdXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHJ5ID0gY29uZmlnLmxldmVsTG9hZGluZ01heFJldHJ5O1xuICAgICAgdGltZW91dCA9IGNvbmZpZy5sZXZlbExvYWRpbmdUaW1lT3V0O1xuICAgICAgcmV0cnlEZWxheSA9IGNvbmZpZy5sZXZlbExvYWRpbmdSZXRyeURlbGF5O1xuICAgICAgbWF4UmV0cnlEZWxheSA9IGNvbmZpZy5sZXZlbExvYWRpbmdNYXhSZXRyeVRpbWVPdXQ7XG4gICAgfVxuICAgIGxldCBsb2FkZXIgPSB0aGlzLmxvYWRlcnNbY29udGV4dC50eXBlXTtcbiAgICBpZiAobG9hZGVyKSB7XG4gICAgICBsZXQgbG9hZGVyQ29udGV4dCA9IGxvYWRlci5jb250ZXh0O1xuICAgICAgaWYgKGxvYWRlckNvbnRleHQgJiYgbG9hZGVyQ29udGV4dC51cmwgPT09IHVybCkge1xuICAgICAgICBsb2dnZXIud2FybihgcGxheWxpc3QgcmVxdWVzdCBvbmdvaW5nYCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxvZ2dlci53YXJuKGBhYm9ydCBwcmV2aW91cyBsb2FkZXIgZm9yIHR5cGU6JHtjb250ZXh0LnR5cGV9YCk7XG4gICAgICAgIGxvYWRlci5hYm9ydCgpO1xuICAgICAgfVxuICAgIH1cbiAgICBsb2FkZXIgID0gdGhpcy5sb2FkZXJzW2NvbnRleHQudHlwZV0gPSBjb250ZXh0LmxvYWRlciA9IHR5cGVvZihjb25maWcucExvYWRlcikgIT09ICd1bmRlZmluZWQnID8gbmV3IGNvbmZpZy5wTG9hZGVyKGNvbmZpZykgOiBuZXcgY29uZmlnLmxvYWRlcihjb25maWcpO1xuICAgIGNvbnRleHQudXJsID0gdXJsO1xuICAgIGNvbnRleHQucmVzcG9uc2VUeXBlID0gJyc7XG5cbiAgICBsZXQgbG9hZGVyQ29uZmlnLCBsb2FkZXJDYWxsYmFja3M7XG4gICAgbG9hZGVyQ29uZmlnID0geyB0aW1lb3V0IDogdGltZW91dCwgbWF4UmV0cnkgOiByZXRyeSAsIHJldHJ5RGVsYXkgOiByZXRyeURlbGF5LCBtYXhSZXRyeURlbGF5IDogbWF4UmV0cnlEZWxheX07XG4gICAgbG9hZGVyQ2FsbGJhY2tzID0geyBvblN1Y2Nlc3MgOiB0aGlzLmxvYWRzdWNjZXNzLmJpbmQodGhpcyksIG9uRXJyb3IgOnRoaXMubG9hZGVycm9yLmJpbmQodGhpcyksIG9uVGltZW91dCA6IHRoaXMubG9hZHRpbWVvdXQuYmluZCh0aGlzKX07XG4gICAgbG9hZGVyLmxvYWQoY29udGV4dCxsb2FkZXJDb25maWcsbG9hZGVyQ2FsbGJhY2tzKTtcbiAgfVxuXG4gIHJlc29sdmUodXJsLCBiYXNlVXJsKSB7XG4gICAgcmV0dXJuIFVSTEhlbHBlci5idWlsZEFic29sdXRlVVJMKGJhc2VVcmwsIHVybCk7XG4gIH1cblxuICBwYXJzZU1hc3RlclBsYXlsaXN0KHN0cmluZywgYmFzZXVybCkge1xuICAgIGxldCBsZXZlbHMgPSBbXSwgcmVzdWx0O1xuXG4gICAgLy8gaHR0cHM6Ly9yZWdleDEwMS5jb20gaXMgeW91ciBmcmllbmRcbiAgICBjb25zdCByZSA9IC8jRVhULVgtU1RSRUFNLUlORjooW15cXG5cXHJdKilbXFxyXFxuXSsoW15cXHJcXG5dKykvZztcbiAgICB3aGlsZSAoKHJlc3VsdCA9IHJlLmV4ZWMoc3RyaW5nKSkgIT0gbnVsbCl7XG4gICAgICBjb25zdCBsZXZlbCA9IHt9O1xuXG4gICAgICB2YXIgYXR0cnMgPSBsZXZlbC5hdHRycyA9IG5ldyBBdHRyTGlzdChyZXN1bHRbMV0pO1xuICAgICAgbGV2ZWwudXJsID0gdGhpcy5yZXNvbHZlKHJlc3VsdFsyXSwgYmFzZXVybCk7XG5cbiAgICAgIHZhciByZXNvbHV0aW9uID0gYXR0cnMuZGVjaW1hbFJlc29sdXRpb24oJ1JFU09MVVRJT04nKTtcbiAgICAgIGlmKHJlc29sdXRpb24pIHtcbiAgICAgICAgbGV2ZWwud2lkdGggPSByZXNvbHV0aW9uLndpZHRoO1xuICAgICAgICBsZXZlbC5oZWlnaHQgPSByZXNvbHV0aW9uLmhlaWdodDtcbiAgICAgIH1cbiAgICAgIGxldmVsLmJpdHJhdGUgPSBhdHRycy5kZWNpbWFsSW50ZWdlcignQVZFUkFHRS1CQU5EV0lEVEgnKSB8fCBhdHRycy5kZWNpbWFsSW50ZWdlcignQkFORFdJRFRIJyk7XG4gICAgICBsZXZlbC5uYW1lID0gYXR0cnMuTkFNRTtcblxuICAgICAgdmFyIGNvZGVjcyA9IGF0dHJzLkNPREVDUztcbiAgICAgIGlmKGNvZGVjcykge1xuICAgICAgICBjb2RlY3MgPSBjb2RlY3Muc3BsaXQoJywnKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2RlY3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBjb2RlYyA9IGNvZGVjc1tpXTtcbiAgICAgICAgICBpZiAoY29kZWMuaW5kZXhPZignYXZjMScpICE9PSAtMSkge1xuICAgICAgICAgICAgbGV2ZWwudmlkZW9Db2RlYyA9IHRoaXMuYXZjMXRvYXZjb3RpKGNvZGVjKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV2ZWwuYXVkaW9Db2RlYyA9IGNvZGVjO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBsZXZlbHMucHVzaChsZXZlbCk7XG4gICAgfVxuICAgIHJldHVybiBsZXZlbHM7XG4gIH1cblxuICBwYXJzZU1hc3RlclBsYXlsaXN0TWVkaWEoc3RyaW5nLCBiYXNldXJsLCB0eXBlKSB7XG4gICAgbGV0IHJlc3VsdCwgbWVkaWFzID0gW107XG5cbiAgICAvLyBodHRwczovL3JlZ2V4MTAxLmNvbSBpcyB5b3VyIGZyaWVuZFxuICAgIGNvbnN0IHJlID0gLyNFWFQtWC1NRURJQTooLiopL2c7XG4gICAgd2hpbGUgKChyZXN1bHQgPSByZS5leGVjKHN0cmluZykpICE9IG51bGwpe1xuICAgICAgY29uc3QgbWVkaWEgPSB7fTtcbiAgICAgIHZhciBhdHRycyA9IG5ldyBBdHRyTGlzdChyZXN1bHRbMV0pO1xuICAgICAgaWYoYXR0cnMuVFlQRSA9PT0gdHlwZSkge1xuICAgICAgICBtZWRpYS5ncm91cElkID0gYXR0cnNbJ0dST1VQLUlEJ107XG4gICAgICAgIG1lZGlhLm5hbWUgPSBhdHRycy5OQU1FO1xuICAgICAgICBtZWRpYS50eXBlID0gdHlwZTtcbiAgICAgICAgbWVkaWEuZGVmYXVsdCA9IChhdHRycy5ERUZBVUxUID09PSAnWUVTJyk7XG4gICAgICAgIG1lZGlhLmF1dG9zZWxlY3QgPSAoYXR0cnMuQVVUT1NFTEVDVCA9PT0gJ1lFUycpO1xuICAgICAgICBtZWRpYS5mb3JjZWQgPSAoYXR0cnMuRk9SQ0VEID09PSAnWUVTJyk7XG4gICAgICAgIGlmIChhdHRycy5VUkkpIHtcbiAgICAgICAgICBtZWRpYS51cmwgPSB0aGlzLnJlc29sdmUoYXR0cnMuVVJJLCBiYXNldXJsKTtcbiAgICAgICAgfVxuICAgICAgICBtZWRpYS5sYW5nID0gYXR0cnMuTEFOR1VBR0U7XG4gICAgICAgIGlmKCFtZWRpYS5uYW1lKSB7XG4gICAgICAgICAgICBtZWRpYS5uYW1lID0gbWVkaWEubGFuZztcbiAgICAgICAgfVxuICAgICAgICBtZWRpYXMucHVzaChtZWRpYSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtZWRpYXM7XG4gIH1cbiAgLyoqXG4gICAqIFV0aWxpdHkgbWV0aG9kIGZvciBwYXJzZUxldmVsUGxheWxpc3QgdG8gY3JlYXRlIGFuIGluaXRpYWxpemF0aW9uIHZlY3RvciBmb3IgYSBnaXZlbiBzZWdtZW50XG4gICAqIEByZXR1cm5zIHtVaW50OEFycmF5fVxuICAgKi9cbiAgY3JlYXRlSW5pdGlhbGl6YXRpb25WZWN0b3IgKHNlZ21lbnROdW1iZXIpIHtcbiAgICB2YXIgdWludDhWaWV3ID0gbmV3IFVpbnQ4QXJyYXkoMTYpO1xuXG4gICAgZm9yICh2YXIgaSA9IDEyOyBpIDwgMTY7IGkrKykge1xuICAgICAgdWludDhWaWV3W2ldID0gKHNlZ21lbnROdW1iZXIgPj4gOCAqICgxNSAtIGkpKSAmIDB4ZmY7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVpbnQ4VmlldztcbiAgfVxuXG4gIC8qKlxuICAgKiBVdGlsaXR5IG1ldGhvZCBmb3IgcGFyc2VMZXZlbFBsYXlsaXN0IHRvIGdldCBhIGZyYWdtZW50J3MgZGVjcnlwdGlvbiBkYXRhIGZyb20gdGhlIGN1cnJlbnRseSBwYXJzZWQgZW5jcnlwdGlvbiBrZXkgZGF0YVxuICAgKiBAcGFyYW0gbGV2ZWxrZXkgLSBhIHBsYXlsaXN0J3MgZW5jcnlwdGlvbiBpbmZvXG4gICAqIEBwYXJhbSBzZWdtZW50TnVtYmVyIC0gdGhlIGZyYWdtZW50J3Mgc2VnbWVudCBudW1iZXJcbiAgICogQHJldHVybnMgeyp9IC0gYW4gb2JqZWN0IHRvIGJlIGFwcGxpZWQgYXMgYSBmcmFnbWVudCdzIGRlY3J5cHRkYXRhXG4gICAqL1xuICBmcmFnbWVudERlY3J5cHRkYXRhRnJvbUxldmVsa2V5IChsZXZlbGtleSwgc2VnbWVudE51bWJlcikge1xuICAgIHZhciBkZWNyeXB0ZGF0YSA9IGxldmVsa2V5O1xuXG4gICAgaWYgKGxldmVsa2V5ICYmIGxldmVsa2V5Lm1ldGhvZCAmJiBsZXZlbGtleS51cmkgJiYgIWxldmVsa2V5Lml2KSB7XG4gICAgICBkZWNyeXB0ZGF0YSA9IHRoaXMuY2xvbmVPYmoobGV2ZWxrZXkpO1xuICAgICAgZGVjcnlwdGRhdGEuaXYgPSB0aGlzLmNyZWF0ZUluaXRpYWxpemF0aW9uVmVjdG9yKHNlZ21lbnROdW1iZXIpO1xuICAgIH1cblxuICAgIHJldHVybiBkZWNyeXB0ZGF0YTtcbiAgfVxuXG4gIGF2YzF0b2F2Y290aShjb2RlYykge1xuICAgIHZhciByZXN1bHQsIGF2Y2RhdGEgPSBjb2RlYy5zcGxpdCgnLicpO1xuICAgIGlmIChhdmNkYXRhLmxlbmd0aCA+IDIpIHtcbiAgICAgIHJlc3VsdCA9IGF2Y2RhdGEuc2hpZnQoKSArICcuJztcbiAgICAgIHJlc3VsdCArPSBwYXJzZUludChhdmNkYXRhLnNoaWZ0KCkpLnRvU3RyaW5nKDE2KTtcbiAgICAgIHJlc3VsdCArPSAoJzAwMCcgKyBwYXJzZUludChhdmNkYXRhLnNoaWZ0KCkpLnRvU3RyaW5nKDE2KSkuc3Vic3RyKC00KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gY29kZWM7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBjbG9uZU9iaihvYmopIHtcbiAgICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShvYmopKTtcbiAgfVxuXG4gIHBhcnNlTGV2ZWxQbGF5bGlzdChzdHJpbmcsIGJhc2V1cmwsIGlkLCB0eXBlKSB7XG4gICAgdmFyIGN1cnJlbnRTTiA9IDAsXG4gICAgICAgIGZyYWdkZWNyeXB0ZGF0YSxcbiAgICAgICAgdG90YWxkdXJhdGlvbiA9IDAsXG4gICAgICAgIGxldmVsID0ge3R5cGU6IG51bGwsIHZlcnNpb246IG51bGwsIHVybDogYmFzZXVybCwgZnJhZ21lbnRzOiBbXSwgbGl2ZTogdHJ1ZSwgc3RhcnRTTjogMH0sXG4gICAgICAgIGxldmVsa2V5ID0ge21ldGhvZCA6IG51bGwsIGtleSA6IG51bGwsIGl2IDogbnVsbCwgdXJpIDogbnVsbH0sXG4gICAgICAgIGNjID0gMCxcbiAgICAgICAgcHJvZ3JhbURhdGVUaW1lID0gbnVsbCxcbiAgICAgICAgZnJhZyA9IG51bGwsXG4gICAgICAgIHJlc3VsdCxcbiAgICAgICAgcmVnZXhwLFxuICAgICAgICBkdXJhdGlvbiA9IG51bGwsXG4gICAgICAgIHRpdGxlID0gbnVsbCxcbiAgICAgICAgYnl0ZVJhbmdlRW5kT2Zmc2V0ID0gbnVsbCxcbiAgICAgICAgYnl0ZVJhbmdlU3RhcnRPZmZzZXQgPSBudWxsLFxuICAgICAgICB0YWdMaXN0ID0gW107XG5cbiAgICByZWdleHAgPSAvKD86KD86IyhFWFRNM1UpKXwoPzojRVhULVgtKFBMQVlMSVNULVRZUEUpOiguKykpfCg/OiNFWFQtWC0oTUVESUEtU0VRVUVOQ0UpOihcXGQrKSl8KD86I0VYVC1YLShUQVJHRVREVVJBVElPTik6KFxcZCspKXwoPzojRVhULVgtKEtFWSk6KC4rKSl8KD86I0VYVC1YLShTVEFSVCk6KC4rKSl8KD86I0VYVChJTkYpOihcXGQrKD86XFwuXFxkKyk/KSg/OiwoLiopKT8pfCg/Oig/ISMpKCkoXFxTLispKXwoPzojRVhULVgtKEJZVEVSQU5HRSk6KFxcZCsoPzpAXFxkKyg/OlxcLlxcZCspPyk/KXwoPzojRVhULVgtKEVORExJU1QpKXwoPzojRVhULVgtKERJUylDT05USU5VSVRZKSl8KD86I0VYVC1YLShQUk9HUkFNLURBVEUtVElNRSk6KC4rKSl8KD86I0VYVC1YLShWRVJTSU9OKTooXFxkKykpfCg/OigjKSguKik6KC4qKSl8KD86KCMpKC4qKSkpKD86LiopXFxyP1xcbj8vZztcbiAgICB3aGlsZSAoKHJlc3VsdCA9IHJlZ2V4cC5leGVjKHN0cmluZykpICE9PSBudWxsKSB7XG4gICAgICByZXN1bHQuc2hpZnQoKTtcbiAgICAgIHJlc3VsdCA9IHJlc3VsdC5maWx0ZXIoZnVuY3Rpb24obikgeyByZXR1cm4gKG4gIT09IHVuZGVmaW5lZCk7IH0pO1xuICAgICAgc3dpdGNoIChyZXN1bHRbMF0pIHtcbiAgICAgICAgY2FzZSAnUExBWUxJU1QtVFlQRSc6XG4gICAgICAgICAgbGV2ZWwudHlwZSA9IHJlc3VsdFsxXS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdNRURJQS1TRVFVRU5DRSc6XG4gICAgICAgICAgY3VycmVudFNOID0gbGV2ZWwuc3RhcnRTTiA9IHBhcnNlSW50KHJlc3VsdFsxXSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ1RBUkdFVERVUkFUSU9OJzpcbiAgICAgICAgICBsZXZlbC50YXJnZXRkdXJhdGlvbiA9IHBhcnNlRmxvYXQocmVzdWx0WzFdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnVkVSU0lPTic6XG4gICAgICAgICAgbGV2ZWwudmVyc2lvbiA9IHBhcnNlSW50KHJlc3VsdFsxXSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ0VYVE0zVSc6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ0VORExJU1QnOlxuICAgICAgICAgIGxldmVsLmxpdmUgPSBmYWxzZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnRElTJzpcbiAgICAgICAgICBjYysrO1xuICAgICAgICAgIHRhZ0xpc3QucHVzaChyZXN1bHQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdCWVRFUkFOR0UnOlxuICAgICAgICAgIHZhciBwYXJhbXMgPSByZXN1bHRbMV0uc3BsaXQoJ0AnKTtcbiAgICAgICAgICBpZiAocGFyYW1zLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgYnl0ZVJhbmdlU3RhcnRPZmZzZXQgPSBieXRlUmFuZ2VFbmRPZmZzZXQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJ5dGVSYW5nZVN0YXJ0T2Zmc2V0ID0gcGFyc2VJbnQocGFyYW1zWzFdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnl0ZVJhbmdlRW5kT2Zmc2V0ID0gcGFyc2VJbnQocGFyYW1zWzBdKSArIGJ5dGVSYW5nZVN0YXJ0T2Zmc2V0O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdJTkYnOlxuICAgICAgICAgIGR1cmF0aW9uID0gcGFyc2VGbG9hdChyZXN1bHRbMV0pO1xuICAgICAgICAgIHRpdGxlID0gcmVzdWx0WzJdID8gcmVzdWx0WzJdIDogbnVsbDtcbiAgICAgICAgICB0YWdMaXN0LnB1c2gocmVzdWx0KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnJzogLy8gdXJsXG4gICAgICAgICAgaWYgKCFpc05hTihkdXJhdGlvbikpIHtcbiAgICAgICAgICAgIHZhciBzbiA9IGN1cnJlbnRTTisrO1xuICAgICAgICAgICAgZnJhZ2RlY3J5cHRkYXRhID0gdGhpcy5mcmFnbWVudERlY3J5cHRkYXRhRnJvbUxldmVsa2V5KGxldmVsa2V5LCBzbik7XG4gICAgICAgICAgICB2YXIgdXJsID0gcmVzdWx0WzFdID8gdGhpcy5yZXNvbHZlKHJlc3VsdFsxXSwgYmFzZXVybCkgOiBudWxsO1xuICAgICAgICAgICAgZnJhZyA9IHt1cmw6IHVybCxcbiAgICAgICAgICAgICAgICAgICAgdHlwZSA6IHR5cGUsXG4gICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uOiBkdXJhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IHRpdGxlLFxuICAgICAgICAgICAgICAgICAgICBzdGFydDogdG90YWxkdXJhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgc246IHNuLFxuICAgICAgICAgICAgICAgICAgICBsZXZlbDogaWQsXG4gICAgICAgICAgICAgICAgICAgIGNjOiBjYyxcbiAgICAgICAgICAgICAgICAgICAgZGVjcnlwdGRhdGEgOiBmcmFnZGVjcnlwdGRhdGEsXG4gICAgICAgICAgICAgICAgICAgIHByb2dyYW1EYXRlVGltZTogcHJvZ3JhbURhdGVUaW1lLFxuICAgICAgICAgICAgICAgICAgICB0YWdMaXN0OiB0YWdMaXN0fTtcbiAgICAgICAgICAgIC8vIG9ubHkgaW5jbHVkZSBieXRlIHJhbmdlIG9wdGlvbnMgaWYgdXNlZC9uZWVkZWRcbiAgICAgICAgICAgIGlmKGJ5dGVSYW5nZVN0YXJ0T2Zmc2V0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIGZyYWcuYnl0ZVJhbmdlU3RhcnRPZmZzZXQgPSBieXRlUmFuZ2VTdGFydE9mZnNldDtcbiAgICAgICAgICAgICAgZnJhZy5ieXRlUmFuZ2VFbmRPZmZzZXQgPSBieXRlUmFuZ2VFbmRPZmZzZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXZlbC5mcmFnbWVudHMucHVzaChmcmFnKTtcbiAgICAgICAgICAgIHRvdGFsZHVyYXRpb24gKz0gZHVyYXRpb247XG4gICAgICAgICAgICBkdXJhdGlvbiA9IG51bGw7XG4gICAgICAgICAgICB0aXRsZSA9IG51bGw7XG4gICAgICAgICAgICBieXRlUmFuZ2VTdGFydE9mZnNldCA9IG51bGw7XG4gICAgICAgICAgICBwcm9ncmFtRGF0ZVRpbWUgPSBudWxsO1xuICAgICAgICAgICAgdGFnTGlzdCA9IFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnS0VZJzpcbiAgICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvZHJhZnQtcGFudG9zLWh0dHAtbGl2ZS1zdHJlYW1pbmctMDgjc2VjdGlvbi0zLjQuNFxuICAgICAgICAgIHZhciBkZWNyeXB0cGFyYW1zID0gcmVzdWx0WzFdO1xuICAgICAgICAgIHZhciBrZXlBdHRycyA9IG5ldyBBdHRyTGlzdChkZWNyeXB0cGFyYW1zKTtcbiAgICAgICAgICB2YXIgZGVjcnlwdG1ldGhvZCA9IGtleUF0dHJzLmVudW1lcmF0ZWRTdHJpbmcoJ01FVEhPRCcpLFxuICAgICAgICAgICAgICBkZWNyeXB0dXJpID0ga2V5QXR0cnMuVVJJLFxuICAgICAgICAgICAgICBkZWNyeXB0aXYgPSBrZXlBdHRycy5oZXhhZGVjaW1hbEludGVnZXIoJ0lWJyk7XG4gICAgICAgICAgaWYgKGRlY3J5cHRtZXRob2QpIHtcbiAgICAgICAgICAgIGxldmVsa2V5ID0geyBtZXRob2Q6IG51bGwsIGtleTogbnVsbCwgaXY6IG51bGwsIHVyaTogbnVsbCB9O1xuICAgICAgICAgICAgaWYgKChkZWNyeXB0dXJpKSAmJiAoZGVjcnlwdG1ldGhvZCA9PT0gJ0FFUy0xMjgnKSkge1xuICAgICAgICAgICAgICBsZXZlbGtleS5tZXRob2QgPSBkZWNyeXB0bWV0aG9kO1xuICAgICAgICAgICAgICAvLyBVUkkgdG8gZ2V0IHRoZSBrZXlcbiAgICAgICAgICAgICAgbGV2ZWxrZXkudXJpID0gdGhpcy5yZXNvbHZlKGRlY3J5cHR1cmksIGJhc2V1cmwpO1xuICAgICAgICAgICAgICBsZXZlbGtleS5rZXkgPSBudWxsO1xuICAgICAgICAgICAgICAvLyBJbml0aWFsaXphdGlvbiBWZWN0b3IgKElWKVxuICAgICAgICAgICAgICBsZXZlbGtleS5pdiA9IGRlY3J5cHRpdjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ1NUQVJUJzpcbiAgICAgICAgICBsZXQgc3RhcnRQYXJhbXMgPSByZXN1bHRbMV07XG4gICAgICAgICAgbGV0IHN0YXJ0QXR0cnMgPSBuZXcgQXR0ckxpc3Qoc3RhcnRQYXJhbXMpO1xuICAgICAgICAgIGxldCBzdGFydFRpbWVPZmZzZXQgPSBzdGFydEF0dHJzLmRlY2ltYWxGbG9hdGluZ1BvaW50KCdUSU1FLU9GRlNFVCcpO1xuICAgICAgICAgIC8vVElNRS1PRkZTRVQgY2FuIGJlIDBcbiAgICAgICAgICBpZiAoICFpc05hTihzdGFydFRpbWVPZmZzZXQpICkge1xuICAgICAgICAgICAgbGV2ZWwuc3RhcnRUaW1lT2Zmc2V0ID0gc3RhcnRUaW1lT2Zmc2V0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnUFJPR1JBTS1EQVRFLVRJTUUnOlxuICAgICAgICAgIHByb2dyYW1EYXRlVGltZSA9IG5ldyBEYXRlKERhdGUucGFyc2UocmVzdWx0WzFdKSk7XG4gICAgICAgICAgdGFnTGlzdC5wdXNoKHJlc3VsdCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJyMnOlxuICAgICAgICAgIHJlc3VsdC5zaGlmdCgpO1xuICAgICAgICAgIHRhZ0xpc3QucHVzaChyZXN1bHQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGxvZ2dlci53YXJuKGBsaW5lIHBhcnNlZCBidXQgbm90IGhhbmRsZWQ6ICR7cmVzdWx0fWApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICAvL2xvZ2dlci5sb2coJ2ZvdW5kICcgKyBsZXZlbC5mcmFnbWVudHMubGVuZ3RoICsgJyBmcmFnbWVudHMnKTtcbiAgICBpZihmcmFnICYmICFmcmFnLnVybCkge1xuICAgICAgbGV2ZWwuZnJhZ21lbnRzLnBvcCgpO1xuICAgICAgdG90YWxkdXJhdGlvbi09ZnJhZy5kdXJhdGlvbjtcbiAgICB9XG4gICAgbGV2ZWwudG90YWxkdXJhdGlvbiA9IHRvdGFsZHVyYXRpb247XG4gICAgbGV2ZWwuYXZlcmFnZXRhcmdldGR1cmF0aW9uID0gdG90YWxkdXJhdGlvbiAvIGxldmVsLmZyYWdtZW50cy5sZW5ndGg7XG4gICAgbGV2ZWwuZW5kU04gPSBjdXJyZW50U04gLSAxO1xuICAgIHJldHVybiBsZXZlbDtcbiAgfVxuXG4gIGxvYWRzdWNjZXNzKHJlc3BvbnNlLCBzdGF0cywgY29udGV4dCkge1xuICAgIHZhciBzdHJpbmcgPSByZXNwb25zZS5kYXRhLFxuICAgICAgICB1cmwgPSByZXNwb25zZS51cmwsXG4gICAgICAgIHR5cGUgPSBjb250ZXh0LnR5cGUsXG4gICAgICAgIGlkID0gY29udGV4dC5pZCxcbiAgICAgICAgbGV2ZWwgPSBjb250ZXh0LmxldmVsLFxuICAgICAgICBobHMgPSB0aGlzLmhscztcblxuICAgIHRoaXMubG9hZGVyc1t0eXBlXSA9IHVuZGVmaW5lZDtcbiAgICAvLyByZXNwb25zZVVSTCBub3Qgc3VwcG9ydGVkIG9uIHNvbWUgYnJvd3NlcnMgKGl0IGlzIHVzZWQgdG8gZGV0ZWN0IFVSTCByZWRpcmVjdGlvbilcbiAgICAvLyBkYXRhLXVyaSBtb2RlIGFsc28gbm90IHN1cHBvcnRlZCAoYnV0IG5vIG5lZWQgdG8gZGV0ZWN0IHJlZGlyZWN0aW9uKVxuICAgIGlmICh1cmwgPT09IHVuZGVmaW5lZCB8fCB1cmwuaW5kZXhPZignZGF0YTonKSA9PT0gMCkge1xuICAgICAgLy8gZmFsbGJhY2sgdG8gaW5pdGlhbCBVUkxcbiAgICAgIHVybCA9IGNvbnRleHQudXJsO1xuICAgIH1cbiAgICBzdGF0cy50bG9hZCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgIC8vc3RhdHMubXRpbWUgPSBuZXcgRGF0ZSh0YXJnZXQuZ2V0UmVzcG9uc2VIZWFkZXIoJ0xhc3QtTW9kaWZpZWQnKSk7XG4gICAgaWYgKHN0cmluZy5pbmRleE9mKCcjRVhUTTNVJykgPT09IDApIHtcbiAgICAgIGlmIChzdHJpbmcuaW5kZXhPZignI0VYVElORjonKSA+IDApIHtcbiAgICAgICAgbGV0IGlzTGV2ZWwgPSAodHlwZSAhPT0gJ2F1ZGlvVHJhY2snKSxcbiAgICAgICAgICAgIGxldmVsRGV0YWlscyA9IHRoaXMucGFyc2VMZXZlbFBsYXlsaXN0KHN0cmluZywgdXJsLCAoaXNMZXZlbCA/IGxldmVsIDogaWQpIHx8IDAsIGlzTGV2ZWwgPyAnbWFpbicgOiAnYXVkaW8nKTtcbiAgICAgICAgICAgIGxldmVsRGV0YWlscy50bG9hZCA9IHN0YXRzLnRsb2FkO1xuICAgICAgICBpZiAodHlwZSA9PT0gJ21hbmlmZXN0Jykge1xuICAgICAgICAvLyBmaXJzdCByZXF1ZXN0LCBzdHJlYW0gbWFuaWZlc3QgKG5vIG1hc3RlciBwbGF5bGlzdCksIGZpcmUgbWFuaWZlc3QgbG9hZGVkIGV2ZW50IHdpdGggbGV2ZWwgZGV0YWlsc1xuICAgICAgICAgIGhscy50cmlnZ2VyKEV2ZW50Lk1BTklGRVNUX0xPQURFRCwge2xldmVsczogW3t1cmw6IHVybCwgZGV0YWlscyA6IGxldmVsRGV0YWlsc31dLCB1cmw6IHVybCwgc3RhdHM6IHN0YXRzfSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdHMudHBhcnNlZCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICBpZiAoaXNMZXZlbCkge1xuICAgICAgICAgIGhscy50cmlnZ2VyKEV2ZW50LkxFVkVMX0xPQURFRCwge2RldGFpbHM6IGxldmVsRGV0YWlscywgbGV2ZWw6IGxldmVsIHx8IDAsIGlkOiBpZCB8fCAwLCBzdGF0czogc3RhdHN9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBobHMudHJpZ2dlcihFdmVudC5BVURJT19UUkFDS19MT0FERUQsIHtkZXRhaWxzOiBsZXZlbERldGFpbHMsIGlkOiBpZCwgc3RhdHM6IHN0YXRzfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBsZXZlbHMgPSB0aGlzLnBhcnNlTWFzdGVyUGxheWxpc3Qoc3RyaW5nLCB1cmwpO1xuICAgICAgICAvLyBtdWx0aSBsZXZlbCBwbGF5bGlzdCwgcGFyc2UgbGV2ZWwgaW5mb1xuICAgICAgICBpZiAobGV2ZWxzLmxlbmd0aCkge1xuICAgICAgICAgIGxldCBhdWRpb3RyYWNrcyA9IHRoaXMucGFyc2VNYXN0ZXJQbGF5bGlzdE1lZGlhKHN0cmluZywgdXJsLCAnQVVESU8nKTtcbiAgICAgICAgICBpZiAoYXVkaW90cmFja3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBjaGVjayBpZiB3ZSBoYXZlIGZvdW5kIGFuIGF1ZGlvIHRyYWNrIGVtYmVkZGVkIGluIG1haW4gcGxheWxpc3QgKGF1ZGlvIHRyYWNrIHdpdGhvdXQgVVJJIGF0dHJpYnV0ZSlcbiAgICAgICAgICAgIGxldCBlbWJlZGRlZEF1ZGlvRm91bmQgPSBmYWxzZTtcbiAgICAgICAgICAgIGF1ZGlvdHJhY2tzLmZvckVhY2goYXVkaW9UcmFjayA9PiB7XG4gICAgICAgICAgICAgIGlmKCFhdWRpb1RyYWNrLnVybCkge1xuICAgICAgICAgICAgICAgIGVtYmVkZGVkQXVkaW9Gb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gaWYgbm8gZW1iZWRkZWQgYXVkaW8gdHJhY2sgZGVmaW5lZCwgYnV0IGF1ZGlvIGNvZGVjIHNpZ25hbGVkIGluIHF1YWxpdHkgbGV2ZWwsIHdlIG5lZWQgdG8gc2lnbmFsIHRoaXMgbWFpbiBhdWRpbyB0cmFja1xuICAgICAgICAgICAgLy8gdGhpcyBjb3VsZCBoYXBwZW4gd2l0aCBwbGF5bGlzdHMgd2l0aCBhbHQgYXVkaW8gcmVuZGl0aW9uIGluIHdoaWNoIHF1YWxpdHkgbGV2ZWxzIChtYWluKSBjb250YWlucyBib3RoIGF1ZGlvK3ZpZGVvLiBidXQgd2l0aCBtaXhlZCBhdWRpbyB0cmFjayBub3Qgc2lnbmFsZWRcbiAgICAgICAgICAgIGlmIChlbWJlZGRlZEF1ZGlvRm91bmQgPT09IGZhbHNlICYmIGxldmVsc1swXS5hdWRpb0NvZGVjICYmICFsZXZlbHNbMF0uYXR0cnMuQVVESU8pIHtcbiAgICAgICAgICAgICAgbG9nZ2VyLmxvZygnYXVkaW8gY29kZWMgc2lnbmFsZWQgaW4gcXVhbGl0eSBsZXZlbCwgYnV0IG5vIGVtYmVkZGVkIGF1ZGlvIHRyYWNrIHNpZ25hbGVkLCBjcmVhdGUgb25lJyk7XG4gICAgICAgICAgICAgIGF1ZGlvdHJhY2tzLnVuc2hpZnQoeyB0eXBlIDogJ21haW4nLCBuYW1lIDogJ21haW4nfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGhscy50cmlnZ2VyKEV2ZW50Lk1BTklGRVNUX0xPQURFRCwge2xldmVsczogbGV2ZWxzLCBhdWRpb1RyYWNrcyA6IGF1ZGlvdHJhY2tzLCB1cmw6IHVybCwgc3RhdHM6IHN0YXRzfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnQuRVJST1IsIHt0eXBlOiBFcnJvclR5cGVzLk5FVFdPUktfRVJST1IsIGRldGFpbHM6IEVycm9yRGV0YWlscy5NQU5JRkVTVF9QQVJTSU5HX0VSUk9SLCBmYXRhbDogdHJ1ZSwgdXJsOiB1cmwsIHJlYXNvbjogJ25vIGxldmVsIGZvdW5kIGluIG1hbmlmZXN0J30pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGhscy50cmlnZ2VyKEV2ZW50LkVSUk9SLCB7dHlwZTogRXJyb3JUeXBlcy5ORVRXT1JLX0VSUk9SLCBkZXRhaWxzOiBFcnJvckRldGFpbHMuTUFOSUZFU1RfUEFSU0lOR19FUlJPUiwgZmF0YWw6IHRydWUsIHVybDogdXJsLCByZWFzb246ICdubyBFWFRNM1UgZGVsaW1pdGVyJ30pO1xuICAgIH1cbiAgfVxuXG4gIGxvYWRlcnJvcihyZXNwb25zZSwgY29udGV4dCkge1xuICAgIHZhciBkZXRhaWxzLCBmYXRhbCxsb2FkZXIgPSBjb250ZXh0LmxvYWRlcjtcbiAgICBzd2l0Y2goY29udGV4dC50eXBlKSB7XG4gICAgICBjYXNlICdtYW5pZmVzdCc6XG4gICAgICAgIGRldGFpbHMgPSBFcnJvckRldGFpbHMuTUFOSUZFU1RfTE9BRF9FUlJPUjtcbiAgICAgICAgZmF0YWwgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2xldmVsJzpcbiAgICAgICAgZGV0YWlscyA9IEVycm9yRGV0YWlscy5MRVZFTF9MT0FEX0VSUk9SO1xuICAgICAgICBmYXRhbCA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2F1ZGlvVHJhY2snOlxuICAgICAgICBkZXRhaWxzID0gRXJyb3JEZXRhaWxzLkFVRElPX1RSQUNLX0xPQURfRVJST1I7XG4gICAgICAgIGZhdGFsID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAobG9hZGVyKSB7XG4gICAgICBsb2FkZXIuYWJvcnQoKTtcbiAgICAgIHRoaXMubG9hZGVyc1tjb250ZXh0LnR5cGVdID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkVSUk9SLCB7dHlwZTogRXJyb3JUeXBlcy5ORVRXT1JLX0VSUk9SLCBkZXRhaWxzOiBkZXRhaWxzLCBmYXRhbDogZmF0YWwsIHVybDogbG9hZGVyLnVybCwgbG9hZGVyOiBsb2FkZXIsIHJlc3BvbnNlOiByZXNwb25zZSwgY29udGV4dCA6IGNvbnRleHR9KTtcbiAgfVxuXG4gIGxvYWR0aW1lb3V0KHN0YXRzLCBjb250ZXh0KSB7XG4gICAgdmFyIGRldGFpbHMsIGZhdGFsLCBsb2FkZXIgPSBjb250ZXh0LmxvYWRlcjtcbiAgICBzd2l0Y2goY29udGV4dC50eXBlKSB7XG4gICAgICBjYXNlICdtYW5pZmVzdCc6XG4gICAgICAgIGRldGFpbHMgPSBFcnJvckRldGFpbHMuTUFOSUZFU1RfTE9BRF9USU1FT1VUO1xuICAgICAgICBmYXRhbCA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbGV2ZWwnOlxuICAgICAgICBkZXRhaWxzID0gRXJyb3JEZXRhaWxzLkxFVkVMX0xPQURfVElNRU9VVDtcbiAgICAgICAgZmF0YWwgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdhdWRpb1RyYWNrJzpcbiAgICAgICAgZGV0YWlscyA9IEVycm9yRGV0YWlscy5BVURJT19UUkFDS19MT0FEX1RJTUVPVVQ7XG4gICAgICAgIGZhdGFsID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAobG9hZGVyKSB7XG4gICAgICBsb2FkZXIuYWJvcnQoKTtcbiAgICAgIHRoaXMubG9hZGVyc1tjb250ZXh0LnR5cGVdID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkVSUk9SLCB7dHlwZTogRXJyb3JUeXBlcy5ORVRXT1JLX0VSUk9SLCBkZXRhaWxzOiBkZXRhaWxzLCBmYXRhbDogZmF0YWwsIHVybDogbG9hZGVyLnVybCwgbG9hZGVyOiBsb2FkZXIsIGNvbnRleHQgOiBjb250ZXh0fSk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgUGxheWxpc3RMb2FkZXI7XG4iLCIvKipcbiAqIEdlbmVyYXRlIE1QNCBCb3hcbiovXG5cbi8vaW1wb3J0IEhleCBmcm9tICcuLi91dGlscy9oZXgnO1xuY2xhc3MgTVA0IHtcbiAgc3RhdGljIGluaXQoKSB7XG4gICAgTVA0LnR5cGVzID0ge1xuICAgICAgYXZjMTogW10sIC8vIGNvZGluZ25hbWVcbiAgICAgIGF2Y0M6IFtdLFxuICAgICAgYnRydDogW10sXG4gICAgICBkaW5mOiBbXSxcbiAgICAgIGRyZWY6IFtdLFxuICAgICAgZXNkczogW10sXG4gICAgICBmdHlwOiBbXSxcbiAgICAgIGhkbHI6IFtdLFxuICAgICAgbWRhdDogW10sXG4gICAgICBtZGhkOiBbXSxcbiAgICAgIG1kaWE6IFtdLFxuICAgICAgbWZoZDogW10sXG4gICAgICBtaW5mOiBbXSxcbiAgICAgIG1vb2Y6IFtdLFxuICAgICAgbW9vdjogW10sXG4gICAgICBtcDRhOiBbXSxcbiAgICAgIG12ZXg6IFtdLFxuICAgICAgbXZoZDogW10sXG4gICAgICBzZHRwOiBbXSxcbiAgICAgIHN0Ymw6IFtdLFxuICAgICAgc3RjbzogW10sXG4gICAgICBzdHNjOiBbXSxcbiAgICAgIHN0c2Q6IFtdLFxuICAgICAgc3RzejogW10sXG4gICAgICBzdHRzOiBbXSxcbiAgICAgIHRmZHQ6IFtdLFxuICAgICAgdGZoZDogW10sXG4gICAgICB0cmFmOiBbXSxcbiAgICAgIHRyYWs6IFtdLFxuICAgICAgdHJ1bjogW10sXG4gICAgICB0cmV4OiBbXSxcbiAgICAgIHRraGQ6IFtdLFxuICAgICAgdm1oZDogW10sXG4gICAgICBzbWhkOiBbXVxuICAgIH07XG5cbiAgICB2YXIgaTtcbiAgICBmb3IgKGkgaW4gTVA0LnR5cGVzKSB7XG4gICAgICBpZiAoTVA0LnR5cGVzLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgIE1QNC50eXBlc1tpXSA9IFtcbiAgICAgICAgICBpLmNoYXJDb2RlQXQoMCksXG4gICAgICAgICAgaS5jaGFyQ29kZUF0KDEpLFxuICAgICAgICAgIGkuY2hhckNvZGVBdCgyKSxcbiAgICAgICAgICBpLmNoYXJDb2RlQXQoMylcbiAgICAgICAgXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgdmlkZW9IZGxyID0gbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgMHgwMCwgLy8gdmVyc2lvbiAwXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAvLyBmbGFnc1xuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcHJlX2RlZmluZWRcbiAgICAgIDB4NzYsIDB4NjksIDB4NjQsIDB4NjUsIC8vIGhhbmRsZXJfdHlwZTogJ3ZpZGUnXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgICAweDU2LCAweDY5LCAweDY0LCAweDY1LFxuICAgICAgMHg2ZiwgMHg0OCwgMHg2MSwgMHg2ZSxcbiAgICAgIDB4NjQsIDB4NmMsIDB4NjUsIDB4NzIsIDB4MDAgLy8gbmFtZTogJ1ZpZGVvSGFuZGxlcidcbiAgICBdKTtcblxuICAgIHZhciBhdWRpb0hkbHIgPSBuZXcgVWludDhBcnJheShbXG4gICAgICAweDAwLCAvLyB2ZXJzaW9uIDBcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGZsYWdzXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyBwcmVfZGVmaW5lZFxuICAgICAgMHg3MywgMHg2ZiwgMHg3NSwgMHg2ZSwgLy8gaGFuZGxlcl90eXBlOiAnc291bidcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAgIDB4NTMsIDB4NmYsIDB4NzUsIDB4NmUsXG4gICAgICAweDY0LCAweDQ4LCAweDYxLCAweDZlLFxuICAgICAgMHg2NCwgMHg2YywgMHg2NSwgMHg3MiwgMHgwMCAvLyBuYW1lOiAnU291bmRIYW5kbGVyJ1xuICAgIF0pO1xuXG4gICAgTVA0LkhETFJfVFlQRVMgPSB7XG4gICAgICAndmlkZW8nOiB2aWRlb0hkbHIsXG4gICAgICAnYXVkaW8nOiBhdWRpb0hkbHJcbiAgICB9O1xuXG4gICAgdmFyIGRyZWYgPSBuZXcgVWludDhBcnJheShbXG4gICAgICAweDAwLCAvLyB2ZXJzaW9uIDBcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGZsYWdzXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAxLCAvLyBlbnRyeV9jb3VudFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwYywgLy8gZW50cnlfc2l6ZVxuICAgICAgMHg3NSwgMHg3MiwgMHg2YywgMHgyMCwgLy8gJ3VybCcgdHlwZVxuICAgICAgMHgwMCwgLy8gdmVyc2lvbiAwXG4gICAgICAweDAwLCAweDAwLCAweDAxIC8vIGVudHJ5X2ZsYWdzXG4gICAgXSk7XG5cbiAgICB2YXIgc3RjbyA9IG5ldyBVaW50OEFycmF5KFtcbiAgICAgIDB4MDAsIC8vIHZlcnNpb25cbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGZsYWdzXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwIC8vIGVudHJ5X2NvdW50XG4gICAgXSk7XG5cbiAgICBNUDQuU1RUUyA9IE1QNC5TVFNDID0gTVA0LlNUQ08gPSBzdGNvO1xuXG4gICAgTVA0LlNUU1ogPSBuZXcgVWludDhBcnJheShbXG4gICAgICAweDAwLCAvLyB2ZXJzaW9uXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAvLyBmbGFnc1xuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gc2FtcGxlX3NpemVcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHNhbXBsZV9jb3VudFxuICAgIF0pO1xuICAgIE1QNC5WTUhEID0gbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgMHgwMCwgLy8gdmVyc2lvblxuICAgICAgMHgwMCwgMHgwMCwgMHgwMSwgLy8gZmxhZ3NcbiAgICAgIDB4MDAsIDB4MDAsIC8vIGdyYXBoaWNzbW9kZVxuICAgICAgMHgwMCwgMHgwMCxcbiAgICAgIDB4MDAsIDB4MDAsXG4gICAgICAweDAwLCAweDAwIC8vIG9wY29sb3JcbiAgICBdKTtcbiAgICBNUDQuU01IRCA9IG5ldyBVaW50OEFycmF5KFtcbiAgICAgIDB4MDAsIC8vIHZlcnNpb25cbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGZsYWdzXG4gICAgICAweDAwLCAweDAwLCAvLyBiYWxhbmNlXG4gICAgICAweDAwLCAweDAwIC8vIHJlc2VydmVkXG4gICAgXSk7XG5cbiAgICBNUDQuU1RTRCA9IG5ldyBVaW50OEFycmF5KFtcbiAgICAgIDB4MDAsIC8vIHZlcnNpb24gMFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gZmxhZ3NcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDFdKTsvLyBlbnRyeV9jb3VudFxuXG4gICAgdmFyIG1ham9yQnJhbmQgPSBuZXcgVWludDhBcnJheShbMTA1LDExNSwxMTEsMTA5XSk7IC8vIGlzb21cbiAgICB2YXIgYXZjMUJyYW5kID0gbmV3IFVpbnQ4QXJyYXkoWzk3LDExOCw5OSw0OV0pOyAvLyBhdmMxXG4gICAgdmFyIG1pbm9yVmVyc2lvbiA9IG5ldyBVaW50OEFycmF5KFswLCAwLCAwLCAxXSk7XG5cbiAgICBNUDQuRlRZUCA9IE1QNC5ib3goTVA0LnR5cGVzLmZ0eXAsIG1ham9yQnJhbmQsIG1pbm9yVmVyc2lvbiwgbWFqb3JCcmFuZCwgYXZjMUJyYW5kKTtcbiAgICBNUDQuRElORiA9IE1QNC5ib3goTVA0LnR5cGVzLmRpbmYsIE1QNC5ib3goTVA0LnR5cGVzLmRyZWYsIGRyZWYpKTtcbiAgfVxuXG4gIHN0YXRpYyBib3godHlwZSkge1xuICB2YXJcbiAgICBwYXlsb2FkID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSxcbiAgICBzaXplID0gOCxcbiAgICBpID0gcGF5bG9hZC5sZW5ndGgsXG4gICAgbGVuID0gaSxcbiAgICByZXN1bHQ7XG4gICAgLy8gY2FsY3VsYXRlIHRoZSB0b3RhbCBzaXplIHdlIG5lZWQgdG8gYWxsb2NhdGVcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBzaXplICs9IHBheWxvYWRbaV0uYnl0ZUxlbmd0aDtcbiAgICB9XG4gICAgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoc2l6ZSk7XG4gICAgcmVzdWx0WzBdID0gKHNpemUgPj4gMjQpICYgMHhmZjtcbiAgICByZXN1bHRbMV0gPSAoc2l6ZSA+PiAxNikgJiAweGZmO1xuICAgIHJlc3VsdFsyXSA9IChzaXplID4+IDgpICYgMHhmZjtcbiAgICByZXN1bHRbM10gPSBzaXplICAmIDB4ZmY7XG4gICAgcmVzdWx0LnNldCh0eXBlLCA0KTtcbiAgICAvLyBjb3B5IHRoZSBwYXlsb2FkIGludG8gdGhlIHJlc3VsdFxuICAgIGZvciAoaSA9IDAsIHNpemUgPSA4OyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIC8vIGNvcHkgcGF5bG9hZFtpXSBhcnJheSBAIG9mZnNldCBzaXplXG4gICAgICByZXN1bHQuc2V0KHBheWxvYWRbaV0sIHNpemUpO1xuICAgICAgc2l6ZSArPSBwYXlsb2FkW2ldLmJ5dGVMZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBzdGF0aWMgaGRscih0eXBlKSB7XG4gICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLmhkbHIsIE1QNC5IRExSX1RZUEVTW3R5cGVdKTtcbiAgfVxuXG4gIHN0YXRpYyBtZGF0KGRhdGEpIHtcbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMubWRhdCwgZGF0YSk7XG4gIH1cblxuICBzdGF0aWMgbWRoZCh0aW1lc2NhbGUsIGR1cmF0aW9uKSB7XG4gICAgZHVyYXRpb24gKj0gdGltZXNjYWxlO1xuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5tZGhkLCBuZXcgVWludDhBcnJheShbXG4gICAgICAweDAwLCAvLyB2ZXJzaW9uIDBcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGZsYWdzXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAyLCAvLyBjcmVhdGlvbl90aW1lXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAzLCAvLyBtb2RpZmljYXRpb25fdGltZVxuICAgICAgKHRpbWVzY2FsZSA+PiAyNCkgJiAweEZGLFxuICAgICAgKHRpbWVzY2FsZSA+PiAxNikgJiAweEZGLFxuICAgICAgKHRpbWVzY2FsZSA+PiAgOCkgJiAweEZGLFxuICAgICAgdGltZXNjYWxlICYgMHhGRiwgLy8gdGltZXNjYWxlXG4gICAgICAoZHVyYXRpb24gPj4gMjQpLFxuICAgICAgKGR1cmF0aW9uID4+IDE2KSAmIDB4RkYsXG4gICAgICAoZHVyYXRpb24gPj4gIDgpICYgMHhGRixcbiAgICAgIGR1cmF0aW9uICYgMHhGRiwgLy8gZHVyYXRpb25cbiAgICAgIDB4NTUsIDB4YzQsIC8vICd1bmQnIGxhbmd1YWdlICh1bmRldGVybWluZWQpXG4gICAgICAweDAwLCAweDAwXG4gICAgXSkpO1xuICB9XG5cbiAgc3RhdGljIG1kaWEodHJhY2spIHtcbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMubWRpYSwgTVA0Lm1kaGQodHJhY2sudGltZXNjYWxlLCB0cmFjay5kdXJhdGlvbiksIE1QNC5oZGxyKHRyYWNrLnR5cGUpLCBNUDQubWluZih0cmFjaykpO1xuICB9XG5cbiAgc3RhdGljIG1maGQoc2VxdWVuY2VOdW1iZXIpIHtcbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMubWZoZCwgbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGZsYWdzXG4gICAgICAoc2VxdWVuY2VOdW1iZXIgPj4gMjQpLFxuICAgICAgKHNlcXVlbmNlTnVtYmVyID4+IDE2KSAmIDB4RkYsXG4gICAgICAoc2VxdWVuY2VOdW1iZXIgPj4gIDgpICYgMHhGRixcbiAgICAgIHNlcXVlbmNlTnVtYmVyICYgMHhGRiwgLy8gc2VxdWVuY2VfbnVtYmVyXG4gICAgXSkpO1xuICB9XG5cbiAgc3RhdGljIG1pbmYodHJhY2spIHtcbiAgICBpZiAodHJhY2sudHlwZSA9PT0gJ2F1ZGlvJykge1xuICAgICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLm1pbmYsIE1QNC5ib3goTVA0LnR5cGVzLnNtaGQsIE1QNC5TTUhEKSwgTVA0LkRJTkYsIE1QNC5zdGJsKHRyYWNrKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5taW5mLCBNUDQuYm94KE1QNC50eXBlcy52bWhkLCBNUDQuVk1IRCksIE1QNC5ESU5GLCBNUDQuc3RibCh0cmFjaykpO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBtb29mKHNuLCBiYXNlTWVkaWFEZWNvZGVUaW1lLCB0cmFjaykge1xuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5tb29mLCBNUDQubWZoZChzbiksIE1QNC50cmFmKHRyYWNrLGJhc2VNZWRpYURlY29kZVRpbWUpKTtcbiAgfVxuLyoqXG4gKiBAcGFyYW0gdHJhY2tzLi4uIChvcHRpb25hbCkge2FycmF5fSB0aGUgdHJhY2tzIGFzc29jaWF0ZWQgd2l0aCB0aGlzIG1vdmllXG4gKi9cbiAgc3RhdGljIG1vb3YodHJhY2tzKSB7XG4gICAgdmFyXG4gICAgICBpID0gdHJhY2tzLmxlbmd0aCxcbiAgICAgIGJveGVzID0gW107XG5cbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBib3hlc1tpXSA9IE1QNC50cmFrKHRyYWNrc1tpXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIE1QNC5ib3guYXBwbHkobnVsbCwgW01QNC50eXBlcy5tb292LCBNUDQubXZoZCh0cmFja3NbMF0udGltZXNjYWxlLCB0cmFja3NbMF0uZHVyYXRpb24pXS5jb25jYXQoYm94ZXMpLmNvbmNhdChNUDQubXZleCh0cmFja3MpKSk7XG4gIH1cblxuICBzdGF0aWMgbXZleCh0cmFja3MpIHtcbiAgICB2YXJcbiAgICAgIGkgPSB0cmFja3MubGVuZ3RoLFxuICAgICAgYm94ZXMgPSBbXTtcblxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGJveGVzW2ldID0gTVA0LnRyZXgodHJhY2tzW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIE1QNC5ib3guYXBwbHkobnVsbCwgW01QNC50eXBlcy5tdmV4XS5jb25jYXQoYm94ZXMpKTtcbiAgfVxuXG4gIHN0YXRpYyBtdmhkKHRpbWVzY2FsZSxkdXJhdGlvbikge1xuICAgIGR1cmF0aW9uKj10aW1lc2NhbGU7XG4gICAgdmFyXG4gICAgICBieXRlcyA9IG5ldyBVaW50OEFycmF5KFtcbiAgICAgICAgMHgwMCwgLy8gdmVyc2lvbiAwXG4gICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGZsYWdzXG4gICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDEsIC8vIGNyZWF0aW9uX3RpbWVcbiAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMiwgLy8gbW9kaWZpY2F0aW9uX3RpbWVcbiAgICAgICAgKHRpbWVzY2FsZSA+PiAyNCkgJiAweEZGLFxuICAgICAgICAodGltZXNjYWxlID4+IDE2KSAmIDB4RkYsXG4gICAgICAgICh0aW1lc2NhbGUgPj4gIDgpICYgMHhGRixcbiAgICAgICAgdGltZXNjYWxlICYgMHhGRiwgLy8gdGltZXNjYWxlXG4gICAgICAgIChkdXJhdGlvbiA+PiAyNCkgJiAweEZGLFxuICAgICAgICAoZHVyYXRpb24gPj4gMTYpICYgMHhGRixcbiAgICAgICAgKGR1cmF0aW9uID4+ICA4KSAmIDB4RkYsXG4gICAgICAgIGR1cmF0aW9uICYgMHhGRiwgLy8gZHVyYXRpb25cbiAgICAgICAgMHgwMCwgMHgwMSwgMHgwMCwgMHgwMCwgLy8gMS4wIHJhdGVcbiAgICAgICAgMHgwMSwgMHgwMCwgLy8gMS4wIHZvbHVtZVxuICAgICAgICAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxuICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxuICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxuICAgICAgICAweDAwLCAweDAxLCAweDAwLCAweDAwLFxuICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgICAweDAwLCAweDAxLCAweDAwLCAweDAwLFxuICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgICAweDQwLCAweDAwLCAweDAwLCAweDAwLCAvLyB0cmFuc2Zvcm1hdGlvbjogdW5pdHkgbWF0cml4XG4gICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHByZV9kZWZpbmVkXG4gICAgICAgIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYgLy8gbmV4dF90cmFja19JRFxuICAgICAgXSk7XG4gICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLm12aGQsIGJ5dGVzKTtcbiAgfVxuXG4gIHN0YXRpYyBzZHRwKHRyYWNrKSB7XG4gICAgdmFyXG4gICAgICBzYW1wbGVzID0gdHJhY2suc2FtcGxlcyB8fCBbXSxcbiAgICAgIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoNCArIHNhbXBsZXMubGVuZ3RoKSxcbiAgICAgIGZsYWdzLFxuICAgICAgaTtcbiAgICAvLyBsZWF2ZSB0aGUgZnVsbCBib3ggaGVhZGVyICg0IGJ5dGVzKSBhbGwgemVyb1xuICAgIC8vIHdyaXRlIHRoZSBzYW1wbGUgdGFibGVcbiAgICBmb3IgKGkgPSAwOyBpIDwgc2FtcGxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgZmxhZ3MgPSBzYW1wbGVzW2ldLmZsYWdzO1xuICAgICAgYnl0ZXNbaSArIDRdID0gKGZsYWdzLmRlcGVuZHNPbiA8PCA0KSB8XG4gICAgICAgIChmbGFncy5pc0RlcGVuZGVkT24gPDwgMikgfFxuICAgICAgICAoZmxhZ3MuaGFzUmVkdW5kYW5jeSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLnNkdHAsIGJ5dGVzKTtcbiAgfVxuXG4gIHN0YXRpYyBzdGJsKHRyYWNrKSB7XG4gICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLnN0YmwsIE1QNC5zdHNkKHRyYWNrKSwgTVA0LmJveChNUDQudHlwZXMuc3R0cywgTVA0LlNUVFMpLCBNUDQuYm94KE1QNC50eXBlcy5zdHNjLCBNUDQuU1RTQyksIE1QNC5ib3goTVA0LnR5cGVzLnN0c3osIE1QNC5TVFNaKSwgTVA0LmJveChNUDQudHlwZXMuc3RjbywgTVA0LlNUQ08pKTtcbiAgfVxuXG4gIHN0YXRpYyBhdmMxKHRyYWNrKSB7XG4gICAgdmFyIHNwcyA9IFtdLCBwcHMgPSBbXSwgaSwgZGF0YSwgbGVuO1xuICAgIC8vIGFzc2VtYmxlIHRoZSBTUFNzXG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgdHJhY2suc3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBkYXRhID0gdHJhY2suc3BzW2ldO1xuICAgICAgbGVuID0gZGF0YS5ieXRlTGVuZ3RoO1xuICAgICAgc3BzLnB1c2goKGxlbiA+Pj4gOCkgJiAweEZGKTtcbiAgICAgIHNwcy5wdXNoKChsZW4gJiAweEZGKSk7XG4gICAgICBzcHMgPSBzcHMuY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGRhdGEpKTsgLy8gU1BTXG4gICAgfVxuXG4gICAgLy8gYXNzZW1ibGUgdGhlIFBQU3NcbiAgICBmb3IgKGkgPSAwOyBpIDwgdHJhY2sucHBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBkYXRhID0gdHJhY2sucHBzW2ldO1xuICAgICAgbGVuID0gZGF0YS5ieXRlTGVuZ3RoO1xuICAgICAgcHBzLnB1c2goKGxlbiA+Pj4gOCkgJiAweEZGKTtcbiAgICAgIHBwcy5wdXNoKChsZW4gJiAweEZGKSk7XG4gICAgICBwcHMgPSBwcHMuY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGRhdGEpKTtcbiAgICB9XG5cbiAgICB2YXIgYXZjYyA9IE1QNC5ib3goTVA0LnR5cGVzLmF2Y0MsIG5ldyBVaW50OEFycmF5KFtcbiAgICAgICAgICAgIDB4MDEsICAgLy8gdmVyc2lvblxuICAgICAgICAgICAgc3BzWzNdLCAvLyBwcm9maWxlXG4gICAgICAgICAgICBzcHNbNF0sIC8vIHByb2ZpbGUgY29tcGF0XG4gICAgICAgICAgICBzcHNbNV0sIC8vIGxldmVsXG4gICAgICAgICAgICAweGZjIHwgMywgLy8gbGVuZ3RoU2l6ZU1pbnVzT25lLCBoYXJkLWNvZGVkIHRvIDQgYnl0ZXNcbiAgICAgICAgICAgIDB4RTAgfCB0cmFjay5zcHMubGVuZ3RoIC8vIDNiaXQgcmVzZXJ2ZWQgKDExMSkgKyBudW1PZlNlcXVlbmNlUGFyYW1ldGVyU2V0c1xuICAgICAgICAgIF0uY29uY2F0KHNwcykuY29uY2F0KFtcbiAgICAgICAgICAgIHRyYWNrLnBwcy5sZW5ndGggLy8gbnVtT2ZQaWN0dXJlUGFyYW1ldGVyU2V0c1xuICAgICAgICAgIF0pLmNvbmNhdChwcHMpKSksIC8vIFwiUFBTXCJcbiAgICAgICAgd2lkdGggPSB0cmFjay53aWR0aCxcbiAgICAgICAgaGVpZ2h0ID0gdHJhY2suaGVpZ2h0O1xuICAgIC8vY29uc29sZS5sb2coJ2F2Y2M6JyArIEhleC5oZXhEdW1wKGF2Y2MpKTtcbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMuYXZjMSwgbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgICAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxuICAgICAgICAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxuICAgICAgICAweDAwLCAweDAxLCAvLyBkYXRhX3JlZmVyZW5jZV9pbmRleFxuICAgICAgICAweDAwLCAweDAwLCAvLyBwcmVfZGVmaW5lZFxuICAgICAgICAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxuICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyBwcmVfZGVmaW5lZFxuICAgICAgICAod2lkdGggPj4gOCkgJiAweEZGLFxuICAgICAgICB3aWR0aCAmIDB4ZmYsIC8vIHdpZHRoXG4gICAgICAgIChoZWlnaHQgPj4gOCkgJiAweEZGLFxuICAgICAgICBoZWlnaHQgJiAweGZmLCAvLyBoZWlnaHRcbiAgICAgICAgMHgwMCwgMHg0OCwgMHgwMCwgMHgwMCwgLy8gaG9yaXpyZXNvbHV0aW9uXG4gICAgICAgIDB4MDAsIDB4NDgsIDB4MDAsIDB4MDAsIC8vIHZlcnRyZXNvbHV0aW9uXG4gICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgICAgIDB4MDAsIDB4MDEsIC8vIGZyYW1lX2NvdW50XG4gICAgICAgIDB4MTIsXG4gICAgICAgIDB4NjQsIDB4NjEsIDB4NjksIDB4NkMsIC8vZGFpbHltb3Rpb24vaGxzLmpzXG4gICAgICAgIDB4NzksIDB4NkQsIDB4NkYsIDB4NzQsXG4gICAgICAgIDB4NjksIDB4NkYsIDB4NkUsIDB4MkYsXG4gICAgICAgIDB4NjgsIDB4NkMsIDB4NzMsIDB4MkUsXG4gICAgICAgIDB4NkEsIDB4NzMsIDB4MDAsIDB4MDAsXG4gICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGNvbXByZXNzb3JuYW1lXG4gICAgICAgIDB4MDAsIDB4MTgsICAgLy8gZGVwdGggPSAyNFxuICAgICAgICAweDExLCAweDExXSksIC8vIHByZV9kZWZpbmVkID0gLTFcbiAgICAgICAgICBhdmNjLFxuICAgICAgICAgIE1QNC5ib3goTVA0LnR5cGVzLmJ0cnQsIG5ldyBVaW50OEFycmF5KFtcbiAgICAgICAgICAgIDB4MDAsIDB4MWMsIDB4OWMsIDB4ODAsIC8vIGJ1ZmZlclNpemVEQlxuICAgICAgICAgICAgMHgwMCwgMHgyZCwgMHhjNiwgMHhjMCwgLy8gbWF4Qml0cmF0ZVxuICAgICAgICAgICAgMHgwMCwgMHgyZCwgMHhjNiwgMHhjMF0pKSAvLyBhdmdCaXRyYXRlXG4gICAgICAgICAgKTtcbiAgfVxuXG4gIHN0YXRpYyBlc2RzKHRyYWNrKSB7XG4gICAgdmFyIGNvbmZpZ2xlbiA9IHRyYWNrLmNvbmZpZy5sZW5ndGg7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFtcbiAgICAgIDB4MDAsIC8vIHZlcnNpb24gMFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gZmxhZ3NcblxuICAgICAgMHgwMywgLy8gZGVzY3JpcHRvcl90eXBlXG4gICAgICAweDE3K2NvbmZpZ2xlbiwgLy8gbGVuZ3RoXG4gICAgICAweDAwLCAweDAxLCAvL2VzX2lkXG4gICAgICAweDAwLCAvLyBzdHJlYW1fcHJpb3JpdHlcblxuICAgICAgMHgwNCwgLy8gZGVzY3JpcHRvcl90eXBlXG4gICAgICAweDBmK2NvbmZpZ2xlbiwgLy8gbGVuZ3RoXG4gICAgICAweDQwLCAvL2NvZGVjIDogbXBlZzRfYXVkaW9cbiAgICAgIDB4MTUsIC8vIHN0cmVhbV90eXBlXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAvLyBidWZmZXJfc2l6ZVxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gbWF4Qml0cmF0ZVxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gYXZnQml0cmF0ZVxuXG4gICAgICAweDA1IC8vIGRlc2NyaXB0b3JfdHlwZVxuICAgICAgXS5jb25jYXQoW2NvbmZpZ2xlbl0pLmNvbmNhdCh0cmFjay5jb25maWcpLmNvbmNhdChbMHgwNiwgMHgwMSwgMHgwMl0pKTsgLy8gR0FTcGVjaWZpY0NvbmZpZykpOyAvLyBsZW5ndGggKyBhdWRpbyBjb25maWcgZGVzY3JpcHRvclxuICB9XG5cbiAgc3RhdGljIG1wNGEodHJhY2spIHtcbiAgICB2YXIgYXVkaW9zYW1wbGVyYXRlID0gdHJhY2suYXVkaW9zYW1wbGVyYXRlO1xuICAgICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLm1wNGEsIG5ldyBVaW50OEFycmF5KFtcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxuICAgICAgMHgwMCwgMHgwMSwgLy8gZGF0YV9yZWZlcmVuY2VfaW5kZXhcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxuICAgICAgMHgwMCwgdHJhY2suY2hhbm5lbENvdW50LCAvLyBjaGFubmVsY291bnRcbiAgICAgIDB4MDAsIDB4MTAsIC8vIHNhbXBsZVNpemU6MTZiaXRzXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZDJcbiAgICAgIChhdWRpb3NhbXBsZXJhdGUgPj4gOCkgJiAweEZGLFxuICAgICAgYXVkaW9zYW1wbGVyYXRlICYgMHhmZiwgLy9cbiAgICAgIDB4MDAsIDB4MDBdKSxcbiAgICAgIE1QNC5ib3goTVA0LnR5cGVzLmVzZHMsIE1QNC5lc2RzKHRyYWNrKSkpO1xuICB9XG5cbiAgc3RhdGljIHN0c2QodHJhY2spIHtcbiAgICBpZiAodHJhY2sudHlwZSA9PT0gJ2F1ZGlvJykge1xuICAgICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLnN0c2QsIE1QNC5TVFNELCBNUDQubXA0YSh0cmFjaykpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMuc3RzZCwgTVA0LlNUU0QsIE1QNC5hdmMxKHRyYWNrKSk7XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIHRraGQodHJhY2spIHtcbiAgICB2YXIgaWQgPSB0cmFjay5pZCxcbiAgICAgICAgZHVyYXRpb24gPSB0cmFjay5kdXJhdGlvbip0cmFjay50aW1lc2NhbGUsXG4gICAgICAgIHdpZHRoID0gdHJhY2sud2lkdGgsXG4gICAgICAgIGhlaWdodCA9IHRyYWNrLmhlaWdodDtcbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMudGtoZCwgbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgMHgwMCwgLy8gdmVyc2lvbiAwXG4gICAgICAweDAwLCAweDAwLCAweDA3LCAvLyBmbGFnc1xuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gY3JlYXRpb25fdGltZVxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gbW9kaWZpY2F0aW9uX3RpbWVcbiAgICAgIChpZCA+PiAyNCkgJiAweEZGLFxuICAgICAgKGlkID4+IDE2KSAmIDB4RkYsXG4gICAgICAoaWQgPj4gOCkgJiAweEZGLFxuICAgICAgaWQgJiAweEZGLCAvLyB0cmFja19JRFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAgIChkdXJhdGlvbiA+PiAyNCksXG4gICAgICAoZHVyYXRpb24gPj4gMTYpICYgMHhGRixcbiAgICAgIChkdXJhdGlvbiA+PiAgOCkgJiAweEZGLFxuICAgICAgZHVyYXRpb24gJiAweEZGLCAvLyBkdXJhdGlvblxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgICAweDAwLCAweDAwLCAvLyBsYXllclxuICAgICAgMHgwMCwgMHgwMCwgLy8gYWx0ZXJuYXRlX2dyb3VwXG4gICAgICAweDAwLCAweDAwLCAvLyBub24tYXVkaW8gdHJhY2sgdm9sdW1lXG4gICAgICAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxuICAgICAgMHgwMCwgMHgwMSwgMHgwMCwgMHgwMCxcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgIDB4MDAsIDB4MDEsIDB4MDAsIDB4MDAsXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAweDQwLCAweDAwLCAweDAwLCAweDAwLCAvLyB0cmFuc2Zvcm1hdGlvbjogdW5pdHkgbWF0cml4XG4gICAgICAod2lkdGggPj4gOCkgJiAweEZGLFxuICAgICAgd2lkdGggJiAweEZGLFxuICAgICAgMHgwMCwgMHgwMCwgLy8gd2lkdGhcbiAgICAgIChoZWlnaHQgPj4gOCkgJiAweEZGLFxuICAgICAgaGVpZ2h0ICYgMHhGRixcbiAgICAgIDB4MDAsIDB4MDAgLy8gaGVpZ2h0XG4gICAgXSkpO1xuICB9XG5cbiAgc3RhdGljIHRyYWYodHJhY2ssYmFzZU1lZGlhRGVjb2RlVGltZSkge1xuICAgIHZhciBzYW1wbGVEZXBlbmRlbmN5VGFibGUgPSBNUDQuc2R0cCh0cmFjayksXG4gICAgICAgIGlkID0gdHJhY2suaWQ7XG4gICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLnRyYWYsXG4gICAgICAgICAgICAgICBNUDQuYm94KE1QNC50eXBlcy50ZmhkLCBuZXcgVWludDhBcnJheShbXG4gICAgICAgICAgICAgICAgIDB4MDAsIC8vIHZlcnNpb24gMFxuICAgICAgICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLCAvLyBmbGFnc1xuICAgICAgICAgICAgICAgICAoaWQgPj4gMjQpLFxuICAgICAgICAgICAgICAgICAoaWQgPj4gMTYpICYgMFhGRixcbiAgICAgICAgICAgICAgICAgKGlkID4+IDgpICYgMFhGRixcbiAgICAgICAgICAgICAgICAgKGlkICYgMHhGRikgLy8gdHJhY2tfSURcbiAgICAgICAgICAgICAgIF0pKSxcbiAgICAgICAgICAgICAgIE1QNC5ib3goTVA0LnR5cGVzLnRmZHQsIG5ldyBVaW50OEFycmF5KFtcbiAgICAgICAgICAgICAgICAgMHgwMCwgLy8gdmVyc2lvbiAwXG4gICAgICAgICAgICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGZsYWdzXG4gICAgICAgICAgICAgICAgIChiYXNlTWVkaWFEZWNvZGVUaW1lID4+MjQpLFxuICAgICAgICAgICAgICAgICAoYmFzZU1lZGlhRGVjb2RlVGltZSA+PiAxNikgJiAwWEZGLFxuICAgICAgICAgICAgICAgICAoYmFzZU1lZGlhRGVjb2RlVGltZSA+PiA4KSAmIDBYRkYsXG4gICAgICAgICAgICAgICAgIChiYXNlTWVkaWFEZWNvZGVUaW1lICYgMHhGRikgLy8gYmFzZU1lZGlhRGVjb2RlVGltZVxuICAgICAgICAgICAgICAgXSkpLFxuICAgICAgICAgICAgICAgTVA0LnRydW4odHJhY2ssXG4gICAgICAgICAgICAgICAgICAgIHNhbXBsZURlcGVuZGVuY3lUYWJsZS5sZW5ndGggK1xuICAgICAgICAgICAgICAgICAgICAxNiArIC8vIHRmaGRcbiAgICAgICAgICAgICAgICAgICAgMTYgKyAvLyB0ZmR0XG4gICAgICAgICAgICAgICAgICAgIDggKyAgLy8gdHJhZiBoZWFkZXJcbiAgICAgICAgICAgICAgICAgICAgMTYgKyAvLyBtZmhkXG4gICAgICAgICAgICAgICAgICAgIDggKyAgLy8gbW9vZiBoZWFkZXJcbiAgICAgICAgICAgICAgICAgICAgOCksICAvLyBtZGF0IGhlYWRlclxuICAgICAgICAgICAgICAgc2FtcGxlRGVwZW5kZW5jeVRhYmxlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIHRyYWNrIGJveC5cbiAgICogQHBhcmFtIHRyYWNrIHtvYmplY3R9IGEgdHJhY2sgZGVmaW5pdGlvblxuICAgKiBAcmV0dXJuIHtVaW50OEFycmF5fSB0aGUgdHJhY2sgYm94XG4gICAqL1xuICBzdGF0aWMgdHJhayh0cmFjaykge1xuICAgIHRyYWNrLmR1cmF0aW9uID0gdHJhY2suZHVyYXRpb24gfHwgMHhmZmZmZmZmZjtcbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMudHJhaywgTVA0LnRraGQodHJhY2spLCBNUDQubWRpYSh0cmFjaykpO1xuICB9XG5cbiAgc3RhdGljIHRyZXgodHJhY2spIHtcbiAgICB2YXIgaWQgPSB0cmFjay5pZDtcbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMudHJleCwgbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgMHgwMCwgLy8gdmVyc2lvbiAwXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAvLyBmbGFnc1xuICAgICAoaWQgPj4gMjQpLFxuICAgICAoaWQgPj4gMTYpICYgMFhGRixcbiAgICAgKGlkID4+IDgpICYgMFhGRixcbiAgICAgKGlkICYgMHhGRiksIC8vIHRyYWNrX0lEXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAxLCAvLyBkZWZhdWx0X3NhbXBsZV9kZXNjcmlwdGlvbl9pbmRleFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gZGVmYXVsdF9zYW1wbGVfZHVyYXRpb25cbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGRlZmF1bHRfc2FtcGxlX3NpemVcbiAgICAgIDB4MDAsIDB4MDEsIDB4MDAsIDB4MDEgLy8gZGVmYXVsdF9zYW1wbGVfZmxhZ3NcbiAgICBdKSk7XG4gIH1cblxuICBzdGF0aWMgdHJ1bih0cmFjaywgb2Zmc2V0KSB7XG4gICAgdmFyIHNhbXBsZXM9IHRyYWNrLnNhbXBsZXMgfHwgW10sXG4gICAgICAgIGxlbiA9IHNhbXBsZXMubGVuZ3RoLFxuICAgICAgICBhcnJheWxlbiA9IDEyICsgKDE2ICogbGVuKSxcbiAgICAgICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheWxlbiksXG4gICAgICAgIGksc2FtcGxlLGR1cmF0aW9uLHNpemUsZmxhZ3MsY3RzO1xuICAgIG9mZnNldCArPSA4ICsgYXJyYXlsZW47XG4gICAgYXJyYXkuc2V0KFtcbiAgICAgIDB4MDAsIC8vIHZlcnNpb24gMFxuICAgICAgMHgwMCwgMHgwZiwgMHgwMSwgLy8gZmxhZ3NcbiAgICAgIChsZW4gPj4+IDI0KSAmIDB4RkYsXG4gICAgICAobGVuID4+PiAxNikgJiAweEZGLFxuICAgICAgKGxlbiA+Pj4gOCkgJiAweEZGLFxuICAgICAgbGVuICYgMHhGRiwgLy8gc2FtcGxlX2NvdW50XG4gICAgICAob2Zmc2V0ID4+PiAyNCkgJiAweEZGLFxuICAgICAgKG9mZnNldCA+Pj4gMTYpICYgMHhGRixcbiAgICAgIChvZmZzZXQgPj4+IDgpICYgMHhGRixcbiAgICAgIG9mZnNldCAmIDB4RkYgLy8gZGF0YV9vZmZzZXRcbiAgICBdLDApO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgc2FtcGxlID0gc2FtcGxlc1tpXTtcbiAgICAgIGR1cmF0aW9uID0gc2FtcGxlLmR1cmF0aW9uO1xuICAgICAgc2l6ZSA9IHNhbXBsZS5zaXplO1xuICAgICAgZmxhZ3MgPSBzYW1wbGUuZmxhZ3M7XG4gICAgICBjdHMgPSBzYW1wbGUuY3RzO1xuICAgICAgYXJyYXkuc2V0KFtcbiAgICAgICAgKGR1cmF0aW9uID4+PiAyNCkgJiAweEZGLFxuICAgICAgICAoZHVyYXRpb24gPj4+IDE2KSAmIDB4RkYsXG4gICAgICAgIChkdXJhdGlvbiA+Pj4gOCkgJiAweEZGLFxuICAgICAgICBkdXJhdGlvbiAmIDB4RkYsIC8vIHNhbXBsZV9kdXJhdGlvblxuICAgICAgICAoc2l6ZSA+Pj4gMjQpICYgMHhGRixcbiAgICAgICAgKHNpemUgPj4+IDE2KSAmIDB4RkYsXG4gICAgICAgIChzaXplID4+PiA4KSAmIDB4RkYsXG4gICAgICAgIHNpemUgJiAweEZGLCAvLyBzYW1wbGVfc2l6ZVxuICAgICAgICAoZmxhZ3MuaXNMZWFkaW5nIDw8IDIpIHwgZmxhZ3MuZGVwZW5kc09uLFxuICAgICAgICAoZmxhZ3MuaXNEZXBlbmRlZE9uIDw8IDYpIHxcbiAgICAgICAgICAoZmxhZ3MuaGFzUmVkdW5kYW5jeSA8PCA0KSB8XG4gICAgICAgICAgKGZsYWdzLnBhZGRpbmdWYWx1ZSA8PCAxKSB8XG4gICAgICAgICAgZmxhZ3MuaXNOb25TeW5jLFxuICAgICAgICBmbGFncy5kZWdyYWRQcmlvICYgMHhGMCA8PCA4LFxuICAgICAgICBmbGFncy5kZWdyYWRQcmlvICYgMHgwRiwgLy8gc2FtcGxlX2ZsYWdzXG4gICAgICAgIChjdHMgPj4+IDI0KSAmIDB4RkYsXG4gICAgICAgIChjdHMgPj4+IDE2KSAmIDB4RkYsXG4gICAgICAgIChjdHMgPj4+IDgpICYgMHhGRixcbiAgICAgICAgY3RzICYgMHhGRiAvLyBzYW1wbGVfY29tcG9zaXRpb25fdGltZV9vZmZzZXRcbiAgICAgIF0sMTIrMTYqaSk7XG4gICAgfVxuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy50cnVuLCBhcnJheSk7XG4gIH1cblxuICBzdGF0aWMgaW5pdFNlZ21lbnQodHJhY2tzKSB7XG4gICAgaWYgKCFNUDQudHlwZXMpIHtcbiAgICAgIE1QNC5pbml0KCk7XG4gICAgfVxuICAgIHZhciBtb3ZpZSA9IE1QNC5tb292KHRyYWNrcyksIHJlc3VsdDtcbiAgICByZXN1bHQgPSBuZXcgVWludDhBcnJheShNUDQuRlRZUC5ieXRlTGVuZ3RoICsgbW92aWUuYnl0ZUxlbmd0aCk7XG4gICAgcmVzdWx0LnNldChNUDQuRlRZUCk7XG4gICAgcmVzdWx0LnNldChtb3ZpZSwgTVA0LkZUWVAuYnl0ZUxlbmd0aCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBNUDQ7XG4iLCIvKipcbiAqIGZNUDQgcmVtdXhlclxuKi9cblxuXG5pbXBvcnQgQUFDIGZyb20gJy4uL2hlbHBlci9hYWMnO1xuaW1wb3J0IEV2ZW50IGZyb20gJy4uL2V2ZW50cyc7XG5pbXBvcnQge2xvZ2dlcn0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcbmltcG9ydCBNUDQgZnJvbSAnLi4vcmVtdXgvbXA0LWdlbmVyYXRvcic7XG5pbXBvcnQge0Vycm9yVHlwZXMsIEVycm9yRGV0YWlsc30gZnJvbSAnLi4vZXJyb3JzJztcbmltcG9ydCAnLi4vdXRpbHMvcG9seWZpbGwnO1xuXG5jbGFzcyBNUDRSZW11eGVyIHtcbiAgY29uc3RydWN0b3Iob2JzZXJ2ZXIsIGlkLCBjb25maWcpIHtcbiAgICB0aGlzLm9ic2VydmVyID0gb2JzZXJ2ZXI7XG4gICAgdGhpcy5pZCA9IGlkO1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgIHRoaXMuSVNHZW5lcmF0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLlBFUzJNUDRTQ0FMRUZBQ1RPUiA9IDQ7XG4gICAgdGhpcy5QRVNfVElNRVNDQUxFID0gOTAwMDA7XG4gICAgdGhpcy5NUDRfVElNRVNDQUxFID0gdGhpcy5QRVNfVElNRVNDQUxFIC8gdGhpcy5QRVMyTVA0U0NBTEVGQUNUT1I7XG4gIH1cblxuICBnZXQgcGFzc3Rocm91Z2goKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgfVxuXG4gIGluc2VydERpc2NvbnRpbnVpdHkoKSB7XG4gICAgdGhpcy5faW5pdFBUUyA9IHRoaXMuX2luaXREVFMgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBzd2l0Y2hMZXZlbCgpIHtcbiAgICB0aGlzLklTR2VuZXJhdGVkID0gZmFsc2U7XG4gIH1cblxuICByZW11eChsZXZlbCxzbixhdWRpb1RyYWNrLHZpZGVvVHJhY2ssaWQzVHJhY2ssdGV4dFRyYWNrLHRpbWVPZmZzZXQsIGNvbnRpZ3VvdXMsYWNjdXJhdGVUaW1lT2Zmc2V0KSB7XG4gICAgdGhpcy5sZXZlbCA9IGxldmVsO1xuICAgIHRoaXMuc24gPSBzbjtcbiAgICAvLyBnZW5lcmF0ZSBJbml0IFNlZ21lbnQgaWYgbmVlZGVkXG4gICAgaWYgKCF0aGlzLklTR2VuZXJhdGVkKSB7XG4gICAgICB0aGlzLmdlbmVyYXRlSVMoYXVkaW9UcmFjayx2aWRlb1RyYWNrLHRpbWVPZmZzZXQpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLklTR2VuZXJhdGVkKSB7XG4gICAgICAvLyBQdXJwb3NlZnVsbHkgcmVtdXhpbmcgYXVkaW8gYmVmb3JlIHZpZGVvLCBzbyB0aGF0IHJlbXV4VmlkZW8gY2FuIHVzZSBuZXh0QWFjUHRzLCB3aGljaCBpc1xuICAgICAgLy8gY2FsY3VsYXRlZCBpbiByZW11eEF1ZGlvLlxuICAgICAgLy9sb2dnZXIubG9nKCduYiBBQUMgc2FtcGxlczonICsgYXVkaW9UcmFjay5zYW1wbGVzLmxlbmd0aCk7XG4gICAgICBpZiAoYXVkaW9UcmFjay5zYW1wbGVzLmxlbmd0aCkge1xuICAgICAgICBsZXQgYXVkaW9EYXRhID0gdGhpcy5yZW11eEF1ZGlvKGF1ZGlvVHJhY2ssdGltZU9mZnNldCxjb250aWd1b3VzLGFjY3VyYXRlVGltZU9mZnNldCk7XG4gICAgICAgIC8vbG9nZ2VyLmxvZygnbmIgQVZDIHNhbXBsZXM6JyArIHZpZGVvVHJhY2suc2FtcGxlcy5sZW5ndGgpO1xuICAgICAgICBpZiAodmlkZW9UcmFjay5zYW1wbGVzLmxlbmd0aCkge1xuICAgICAgICAgIGxldCBhdWRpb1RyYWNrTGVuZ3RoO1xuICAgICAgICAgIGlmIChhdWRpb0RhdGEpIHtcbiAgICAgICAgICAgIGF1ZGlvVHJhY2tMZW5ndGggPSBhdWRpb0RhdGEuZW5kUFRTIC0gYXVkaW9EYXRhLnN0YXJ0UFRTO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnJlbXV4VmlkZW8odmlkZW9UcmFjayx0aW1lT2Zmc2V0LGNvbnRpZ3VvdXMsYXVkaW9UcmFja0xlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCB2aWRlb0RhdGE7XG4gICAgICAgIC8vbG9nZ2VyLmxvZygnbmIgQVZDIHNhbXBsZXM6JyArIHZpZGVvVHJhY2suc2FtcGxlcy5sZW5ndGgpO1xuICAgICAgICBpZiAodmlkZW9UcmFjay5zYW1wbGVzLmxlbmd0aCkge1xuICAgICAgICAgIHZpZGVvRGF0YSA9IHRoaXMucmVtdXhWaWRlbyh2aWRlb1RyYWNrLHRpbWVPZmZzZXQsY29udGlndW91cyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZpZGVvRGF0YSAmJiBhdWRpb1RyYWNrLmNvZGVjKSB7XG4gICAgICAgICAgdGhpcy5yZW11eEVtcHR5QXVkaW8oYXVkaW9UcmFjaywgdGltZU9mZnNldCwgY29udGlndW91cywgdmlkZW9EYXRhKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvL2xvZ2dlci5sb2coJ25iIElEMyBzYW1wbGVzOicgKyBhdWRpb1RyYWNrLnNhbXBsZXMubGVuZ3RoKTtcbiAgICBpZiAoaWQzVHJhY2suc2FtcGxlcy5sZW5ndGgpIHtcbiAgICAgIHRoaXMucmVtdXhJRDMoaWQzVHJhY2ssdGltZU9mZnNldCk7XG4gICAgfVxuICAgIC8vbG9nZ2VyLmxvZygnbmIgSUQzIHNhbXBsZXM6JyArIGF1ZGlvVHJhY2suc2FtcGxlcy5sZW5ndGgpO1xuICAgIGlmICh0ZXh0VHJhY2suc2FtcGxlcy5sZW5ndGgpIHtcbiAgICAgIHRoaXMucmVtdXhUZXh0KHRleHRUcmFjayx0aW1lT2Zmc2V0KTtcbiAgICB9XG4gICAgLy9ub3RpZnkgZW5kIG9mIHBhcnNpbmdcbiAgICB0aGlzLm9ic2VydmVyLnRyaWdnZXIoRXZlbnQuRlJBR19QQVJTRUQsIHsgaWQgOiB0aGlzLmlkICwgbGV2ZWwgOiB0aGlzLmxldmVsLCBzbiA6IHRoaXMuc259KTtcbiAgfVxuXG4gIGdlbmVyYXRlSVMoYXVkaW9UcmFjayx2aWRlb1RyYWNrLHRpbWVPZmZzZXQpIHtcbiAgICB2YXIgb2JzZXJ2ZXIgPSB0aGlzLm9ic2VydmVyLFxuICAgICAgICBhdWRpb1NhbXBsZXMgPSBhdWRpb1RyYWNrLnNhbXBsZXMsXG4gICAgICAgIHZpZGVvU2FtcGxlcyA9IHZpZGVvVHJhY2suc2FtcGxlcyxcbiAgICAgICAgcGVzVGltZVNjYWxlID0gdGhpcy5QRVNfVElNRVNDQUxFLFxuICAgICAgICB0cmFja3MgPSB7fSxcbiAgICAgICAgZGF0YSA9IHsgaWQgOiB0aGlzLmlkLCBsZXZlbCA6IHRoaXMubGV2ZWwsIHNuIDogdGhpcy5zbiwgdHJhY2tzIDogdHJhY2tzLCB1bmlxdWUgOiBmYWxzZSB9LFxuICAgICAgICBjb21wdXRlUFRTRFRTID0gKHRoaXMuX2luaXRQVFMgPT09IHVuZGVmaW5lZCksXG4gICAgICAgIGluaXRQVFMsIGluaXREVFM7XG5cbiAgICBpZiAoY29tcHV0ZVBUU0RUUykge1xuICAgICAgaW5pdFBUUyA9IGluaXREVFMgPSBJbmZpbml0eTtcbiAgICB9XG4gICAgaWYgKGF1ZGlvVHJhY2suY29uZmlnICYmIGF1ZGlvU2FtcGxlcy5sZW5ndGgpIHtcbiAgICAgIGF1ZGlvVHJhY2sudGltZXNjYWxlID0gYXVkaW9UcmFjay5hdWRpb3NhbXBsZXJhdGU7XG4gICAgICAvLyBNUDQgZHVyYXRpb24gKHRyYWNrIGR1cmF0aW9uIGluIHNlY29uZHMgbXVsdGlwbGllZCBieSB0aW1lc2NhbGUpIGlzIGNvZGVkIG9uIDMyIGJpdHNcbiAgICAgIC8vIHdlIGtub3cgdGhhdCBlYWNoIEFBQyBzYW1wbGUgY29udGFpbnMgMTAyNCBmcmFtZXMuLi4uXG4gICAgICAvLyBpbiBvcmRlciB0byBhdm9pZCBvdmVyZmxvd2luZyB0aGUgMzIgYml0IGNvdW50ZXIgZm9yIGxhcmdlIGR1cmF0aW9uLCB3ZSB1c2Ugc21hbGxlciB0aW1lc2NhbGUgKHRpbWVzY2FsZS9nY2QpXG4gICAgICAvLyB3ZSBqdXN0IG5lZWQgdG8gZW5zdXJlIHRoYXQgQUFDIHNhbXBsZSBkdXJhdGlvbiB3aWxsIHN0aWxsIGJlIGFuIGludGVnZXIgKHdpbGwgYmUgMTAyNC9nY2QpXG4gICAgICBpZiAoYXVkaW9UcmFjay50aW1lc2NhbGUgKiBhdWRpb1RyYWNrLmR1cmF0aW9uID4gTWF0aC5wb3coMiwgMzIpKSB7XG4gICAgICAgIGxldCBncmVhdGVzdENvbW1vbkRpdmlzb3IgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgICAgICBpZiAoICEgYikge1xuICAgICAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGdyZWF0ZXN0Q29tbW9uRGl2aXNvcihiLCBhICUgYik7XG4gICAgICAgIH07XG4gICAgICAgIGF1ZGlvVHJhY2sudGltZXNjYWxlID0gYXVkaW9UcmFjay5hdWRpb3NhbXBsZXJhdGUgLyBncmVhdGVzdENvbW1vbkRpdmlzb3IoYXVkaW9UcmFjay5hdWRpb3NhbXBsZXJhdGUsMTAyNCk7XG4gICAgICB9XG4gICAgICBsb2dnZXIubG9nICgnYXVkaW8gbXA0IHRpbWVzY2FsZSA6JysgYXVkaW9UcmFjay50aW1lc2NhbGUpO1xuICAgICAgdHJhY2tzLmF1ZGlvID0ge1xuICAgICAgICBjb250YWluZXIgOiAnYXVkaW8vbXA0JyxcbiAgICAgICAgY29kZWMgOiAgYXVkaW9UcmFjay5jb2RlYyxcbiAgICAgICAgaW5pdFNlZ21lbnQgOiBNUDQuaW5pdFNlZ21lbnQoW2F1ZGlvVHJhY2tdKSxcbiAgICAgICAgbWV0YWRhdGEgOiB7XG4gICAgICAgICAgY2hhbm5lbENvdW50IDogYXVkaW9UcmFjay5jaGFubmVsQ291bnRcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGlmIChjb21wdXRlUFRTRFRTKSB7XG4gICAgICAgIC8vIHJlbWVtYmVyIGZpcnN0IFBUUyBvZiB0aGlzIGRlbXV4aW5nIGNvbnRleHQuIGZvciBhdWRpbywgUFRTID0gRFRTXG4gICAgICAgIGluaXRQVFMgPSBpbml0RFRTID0gYXVkaW9TYW1wbGVzWzBdLnB0cyAtIHBlc1RpbWVTY2FsZSAqIHRpbWVPZmZzZXQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHZpZGVvVHJhY2suc3BzICYmIHZpZGVvVHJhY2sucHBzICYmIHZpZGVvU2FtcGxlcy5sZW5ndGgpIHtcbiAgICAgIHZpZGVvVHJhY2sudGltZXNjYWxlID0gdGhpcy5NUDRfVElNRVNDQUxFO1xuICAgICAgdHJhY2tzLnZpZGVvID0ge1xuICAgICAgICBjb250YWluZXIgOiAndmlkZW8vbXA0JyxcbiAgICAgICAgY29kZWMgOiAgdmlkZW9UcmFjay5jb2RlYyxcbiAgICAgICAgaW5pdFNlZ21lbnQgOiBNUDQuaW5pdFNlZ21lbnQoW3ZpZGVvVHJhY2tdKSxcbiAgICAgICAgbWV0YWRhdGEgOiB7XG4gICAgICAgICAgd2lkdGggOiB2aWRlb1RyYWNrLndpZHRoLFxuICAgICAgICAgIGhlaWdodCA6IHZpZGVvVHJhY2suaGVpZ2h0XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBpZiAoY29tcHV0ZVBUU0RUUykge1xuICAgICAgICBpbml0UFRTID0gTWF0aC5taW4oaW5pdFBUUyx2aWRlb1NhbXBsZXNbMF0ucHRzIC0gcGVzVGltZVNjYWxlICogdGltZU9mZnNldCk7XG4gICAgICAgIGluaXREVFMgPSBNYXRoLm1pbihpbml0RFRTLHZpZGVvU2FtcGxlc1swXS5kdHMgLSBwZXNUaW1lU2NhbGUgKiB0aW1lT2Zmc2V0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZihPYmplY3Qua2V5cyh0cmFja3MpLmxlbmd0aCkge1xuICAgICAgb2JzZXJ2ZXIudHJpZ2dlcihFdmVudC5GUkFHX1BBUlNJTkdfSU5JVF9TRUdNRU5ULGRhdGEpO1xuICAgICAgdGhpcy5JU0dlbmVyYXRlZCA9IHRydWU7XG4gICAgICBpZiAoY29tcHV0ZVBUU0RUUykge1xuICAgICAgICB0aGlzLl9pbml0UFRTID0gaW5pdFBUUztcbiAgICAgICAgdGhpcy5faW5pdERUUyA9IGluaXREVFM7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG9ic2VydmVyLnRyaWdnZXIoRXZlbnQuRVJST1IsIHt0eXBlIDogRXJyb3JUeXBlcy5NRURJQV9FUlJPUiwgaWQgOiB0aGlzLmlkLCBkZXRhaWxzOiBFcnJvckRldGFpbHMuRlJBR19QQVJTSU5HX0VSUk9SLCBmYXRhbDogZmFsc2UsIHJlYXNvbjogJ25vIGF1ZGlvL3ZpZGVvIHNhbXBsZXMgZm91bmQnfSk7XG4gICAgfVxuICB9XG5cbiAgcmVtdXhWaWRlbyh0cmFjaywgdGltZU9mZnNldCwgY29udGlndW91cywgYXVkaW9UcmFja0xlbmd0aCkge1xuICAgIHZhciBvZmZzZXQgPSA4LFxuICAgICAgICBwZXNUaW1lU2NhbGUgPSB0aGlzLlBFU19USU1FU0NBTEUsXG4gICAgICAgIHBlczJtcDRTY2FsZUZhY3RvciA9IHRoaXMuUEVTMk1QNFNDQUxFRkFDVE9SLFxuICAgICAgICBtcDRTYW1wbGVEdXJhdGlvbixcbiAgICAgICAgbWRhdCwgbW9vZixcbiAgICAgICAgZmlyc3RQVFMsIGZpcnN0RFRTLFxuICAgICAgICBuZXh0RFRTLFxuICAgICAgICBsYXN0UFRTLCBsYXN0RFRTLFxuICAgICAgICBpbnB1dFNhbXBsZXMgPSB0cmFjay5zYW1wbGVzLFxuICAgICAgICBvdXRwdXRTYW1wbGVzID0gW107XG5cbiAgLy8gZm9yIChsZXQgaSA9IDA7IGkgPCB0cmFjay5zYW1wbGVzLmxlbmd0aDsgaSsrKSB7XG4gIC8vICAgbGV0IGF2Y1NhbXBsZSA9IHRyYWNrLnNhbXBsZXNbaV07XG4gIC8vICAgbGV0IHVuaXRzID0gYXZjU2FtcGxlLnVuaXRzLnVuaXRzO1xuICAvLyAgIGxldCB1bml0c1N0cmluZyA9ICcnO1xuICAvLyAgIGZvciAobGV0IGogPSAwOyBqIDwgdW5pdHMubGVuZ3RoIDsgaisrKSB7XG4gIC8vICAgICB1bml0c1N0cmluZyArPSB1bml0c1tqXS50eXBlICsgJywnO1xuICAvLyAgICAgaWYgKHVuaXRzW2pdLmRhdGEubGVuZ3RoIDwgNTAwKSB7XG4gIC8vICAgICAgIHVuaXRzU3RyaW5nICs9IEhleC5oZXhEdW1wKHVuaXRzW2pdLmRhdGEpO1xuICAvLyAgICAgfVxuICAvLyAgIH1cbiAgLy8gICBsb2dnZXIubG9nKGF2Y1NhbXBsZS5wdHMgKyAnLycgKyBhdmNTYW1wbGUuZHRzICsgJywnICsgdW5pdHNTdHJpbmcgKyBhdmNTYW1wbGUudW5pdHMubGVuZ3RoKTtcbiAgLy8gfVxuXG4gICAgLy8gaGFuZGxlIGJyb2tlbiBzdHJlYW1zIHdpdGggUFRTIDwgRFRTLCB0b2xlcmFuY2UgdXAgMjAwbXMgKDE4MDAwIGluIDkwa0h6IHRpbWVzY2FsZSlcbiAgICBsZXQgUFRTRFRTc2hpZnQgPSBpbnB1dFNhbXBsZXMucmVkdWNlKCAocHJldiwgY3VycikgPT4gTWF0aC5tYXgoTWF0aC5taW4ocHJldixjdXJyLnB0cy1jdXJyLmR0cyksLTE4MDAwKSwwKTtcbiAgICBpZiAoUFRTRFRTc2hpZnQgPCAwKSB7XG4gICAgICBsb2dnZXIud2FybihgUFRTIDwgRFRTIGRldGVjdGVkIGluIHZpZGVvIHNhbXBsZXMsIHNoaWZ0aW5nIERUUyBieSAke01hdGgucm91bmQoUFRTRFRTc2hpZnQvOTApfSBtcyB0byBvdmVyY29tZSB0aGlzIGlzc3VlYCk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0U2FtcGxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpbnB1dFNhbXBsZXNbaV0uZHRzICs9IFBUU0RUU3NoaWZ0O1xuICAgICAgfVxuICAgIH1cblxuICAvLyBQVFMgaXMgY29kZWQgb24gMzNiaXRzLCBhbmQgY2FuIGxvb3AgZnJvbSAtMl4zMiB0byAyXjMyXG4gIC8vIFBUU05vcm1hbGl6ZSB3aWxsIG1ha2UgUFRTL0RUUyB2YWx1ZSBtb25vdG9uaWMsIHdlIHVzZSBsYXN0IGtub3duIERUUyB2YWx1ZSBhcyByZWZlcmVuY2UgdmFsdWVcbiAgIGxldCBuZXh0QXZjRHRzO1xuICAgLy8gY29udGlndW91cyBmcmFnbWVudHMgYXJlIGNvbnNlY3V0aXZlIGZyYWdtZW50cyBmcm9tIHNhbWUgcXVhbGl0eSBsZXZlbCAoc2FtZSBsZXZlbCwgbmV3IFNOID0gb2xkIFNOICsgMSlcbiAgICBpZiAoY29udGlndW91cykge1xuICAgICAgLy8gaWYgcGFyc2VkIGZyYWdtZW50IGlzIGNvbnRpZ3VvdXMgd2l0aCBsYXN0IG9uZSwgbGV0J3MgdXNlIGxhc3QgRFRTIHZhbHVlIGFzIHJlZmVyZW5jZVxuICAgICAgbmV4dEF2Y0R0cyA9IHRoaXMubmV4dEF2Y0R0cztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaWYgbm90IGNvbnRpZ3VvdXMsIGxldCdzIHVzZSB0YXJnZXQgdGltZU9mZnNldFxuICAgICAgbmV4dEF2Y0R0cyA9IHRpbWVPZmZzZXQqcGVzVGltZVNjYWxlO1xuICAgIH1cblxuICAgIC8vIGNvbXB1dGUgZmlyc3QgRFRTIGFuZCBsYXN0IERUUywgbm9ybWFsaXplIHRoZW0gYWdhaW5zdCByZWZlcmVuY2UgdmFsdWVcbiAgICBsZXQgc2FtcGxlID0gaW5wdXRTYW1wbGVzWzBdO1xuICAgIGZpcnN0RFRTID0gIE1hdGgubWF4KHRoaXMuX1BUU05vcm1hbGl6ZShzYW1wbGUuZHRzIC0gdGhpcy5faW5pdERUUyxuZXh0QXZjRHRzKSwwKTtcbiAgICBmaXJzdFBUUyA9ICBNYXRoLm1heCh0aGlzLl9QVFNOb3JtYWxpemUoc2FtcGxlLnB0cyAtIHRoaXMuX2luaXREVFMsbmV4dEF2Y0R0cyksMCk7XG5cbiAgICAvLyBjaGVjayB0aW1lc3RhbXAgY29udGludWl0eSBhY2Nyb3NzIGNvbnNlY3V0aXZlIGZyYWdtZW50cyAodGhpcyBpcyB0byByZW1vdmUgaW50ZXItZnJhZ21lbnQgZ2FwL2hvbGUpXG4gICAgbGV0IGRlbHRhID0gTWF0aC5yb3VuZCgoZmlyc3REVFMgLSBuZXh0QXZjRHRzKSAvIDkwKTtcbiAgICAvLyBpZiBmcmFnbWVudCBhcmUgY29udGlndW91cywgZGV0ZWN0IGhvbGUvb3ZlcmxhcHBpbmcgYmV0d2VlbiBmcmFnbWVudHNcbiAgICBpZiAoY29udGlndW91cykge1xuICAgICAgaWYgKGRlbHRhKSB7XG4gICAgICAgIGlmIChkZWx0YSA+IDEpIHtcbiAgICAgICAgICBsb2dnZXIubG9nKGBBVkM6JHtkZWx0YX0gbXMgaG9sZSBiZXR3ZWVuIGZyYWdtZW50cyBkZXRlY3RlZCxmaWxsaW5nIGl0YCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZGVsdGEgPCAtMSkge1xuICAgICAgICAgIGxvZ2dlci5sb2coYEFWQzokeygtZGVsdGEpfSBtcyBvdmVybGFwcGluZyBiZXR3ZWVuIGZyYWdtZW50cyBkZXRlY3RlZGApO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJlbW92ZSBob2xlL2dhcCA6IHNldCBEVFMgdG8gbmV4dCBleHBlY3RlZCBEVFNcbiAgICAgICAgZmlyc3REVFMgPSBuZXh0QXZjRHRzO1xuICAgICAgICBpbnB1dFNhbXBsZXNbMF0uZHRzID0gZmlyc3REVFMgKyB0aGlzLl9pbml0RFRTO1xuICAgICAgICAvLyBvZmZzZXQgUFRTIGFzIHdlbGwsIGVuc3VyZSB0aGF0IFBUUyBpcyBzbWFsbGVyIG9yIGVxdWFsIHRoYW4gbmV3IERUU1xuICAgICAgICBmaXJzdFBUUyA9IE1hdGgubWF4KGZpcnN0UFRTIC0gZGVsdGEsIG5leHRBdmNEdHMpO1xuICAgICAgICBpbnB1dFNhbXBsZXNbMF0ucHRzID0gZmlyc3RQVFMgKyB0aGlzLl9pbml0RFRTO1xuICAgICAgICBsb2dnZXIubG9nKGBWaWRlby9QVFMvRFRTIGFkanVzdGVkOiAke01hdGgucm91bmQoZmlyc3RQVFMvOTApfS8ke01hdGgucm91bmQoZmlyc3REVFMvOTApfSxkZWx0YToke2RlbHRhfSBtc2ApO1xuICAgICAgfVxuICAgIH1cbiAgICBuZXh0RFRTID0gZmlyc3REVFM7XG5cbiAgICAvLyBjb21wdXRlIGxhc3RQVFMvbGFzdERUU1xuICAgIHNhbXBsZSA9IGlucHV0U2FtcGxlc1tpbnB1dFNhbXBsZXMubGVuZ3RoLTFdO1xuICAgIGxhc3REVFMgPSBNYXRoLm1heCh0aGlzLl9QVFNOb3JtYWxpemUoc2FtcGxlLmR0cyAtIHRoaXMuX2luaXREVFMsbmV4dEF2Y0R0cykgLDApO1xuICAgIGxhc3RQVFMgPSBNYXRoLm1heCh0aGlzLl9QVFNOb3JtYWxpemUoc2FtcGxlLnB0cyAtIHRoaXMuX2luaXREVFMsbmV4dEF2Y0R0cykgLDApO1xuICAgIGxhc3RQVFMgPSBNYXRoLm1heChsYXN0UFRTLCBsYXN0RFRTKTtcblxuICAgIGxldCB2ZW5kb3IgPSBuYXZpZ2F0b3IudmVuZG9yLCB1c2VyQWdlbnQgPSBuYXZpZ2F0b3IudXNlckFnZW50LFxuICAgICAgICBpc1NhZmFyaSA9IHZlbmRvciAmJiB2ZW5kb3IuaW5kZXhPZignQXBwbGUnKSA+IC0xICYmIHVzZXJBZ2VudCAmJiAhdXNlckFnZW50Lm1hdGNoKCdDcmlPUycpO1xuXG4gICAgICAvLyBvbiBTYWZhcmkgbGV0J3Mgc2lnbmFsIHRoZSBzYW1lIHNhbXBsZSBkdXJhdGlvbiBmb3IgYWxsIHNhbXBsZXNcbiAgICAgIC8vIHNhbXBsZSBkdXJhdGlvbiAoYXMgZXhwZWN0ZWQgYnkgdHJ1biBNUDQgYm94ZXMpLCBzaG91bGQgYmUgdGhlIGRlbHRhIGJldHdlZW4gc2FtcGxlIERUU1xuICAgICAgLy8gc2V0IHRoaXMgY29uc3RhbnQgZHVyYXRpb24gYXMgYmVpbmcgdGhlIGF2ZyBkZWx0YSBiZXR3ZWVuIGNvbnNlY3V0aXZlIERUUy5cbiAgICBpZiAoaXNTYWZhcmkpIHtcbiAgICAgIG1wNFNhbXBsZUR1cmF0aW9uID0gTWF0aC5yb3VuZCgobGFzdERUUy1maXJzdERUUykvKHBlczJtcDRTY2FsZUZhY3RvciooaW5wdXRTYW1wbGVzLmxlbmd0aC0xKSkpO1xuICAgIH1cblxuICAgIC8vIG5vcm1hbGl6ZSBhbGwgUFRTL0RUUyBub3cgLi4uXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dFNhbXBsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCBzYW1wbGUgPSBpbnB1dFNhbXBsZXNbaV07XG4gICAgICBpZiAoaXNTYWZhcmkpIHtcbiAgICAgICAgLy8gc2FtcGxlIERUUyBpcyBjb21wdXRlZCB1c2luZyBhIGNvbnN0YW50IGRlY29kaW5nIG9mZnNldCAobXA0U2FtcGxlRHVyYXRpb24pIGJldHdlZW4gc2FtcGxlc1xuICAgICAgICBzYW1wbGUuZHRzID0gZmlyc3REVFMgKyBpKnBlczJtcDRTY2FsZUZhY3RvciptcDRTYW1wbGVEdXJhdGlvbjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGVuc3VyZSBzYW1wbGUgbW9ub3RvbmljIERUU1xuICAgICAgICBzYW1wbGUuZHRzID0gTWF0aC5tYXgodGhpcy5fUFRTTm9ybWFsaXplKHNhbXBsZS5kdHMgLSB0aGlzLl9pbml0RFRTLCBuZXh0QXZjRHRzKSxmaXJzdERUUyk7XG4gICAgICAgIC8vIGVuc3VyZSBkdHMgaXMgYSBtdWx0aXBsZSBvZiBzY2FsZSBmYWN0b3IgdG8gYXZvaWQgcm91bmRpbmcgaXNzdWVzXG4gICAgICAgIHNhbXBsZS5kdHMgPSBNYXRoLnJvdW5kKHNhbXBsZS5kdHMvcGVzMm1wNFNjYWxlRmFjdG9yKSpwZXMybXA0U2NhbGVGYWN0b3I7XG4gICAgICB9XG4gICAgICAvLyB3ZSBub3JtYWxpemUgUFRTIGFnYWluc3QgbmV4dEF2Y0R0cywgd2UgYWxzbyBzdWJzdHJhY3QgaW5pdERUUyAoc29tZSBzdHJlYW1zIGRvbid0IHN0YXJ0IEAgUFRTIE8pXG4gICAgICAvLyBhbmQgd2UgZW5zdXJlIHRoYXQgY29tcHV0ZWQgdmFsdWUgaXMgZ3JlYXRlciBvciBlcXVhbCB0aGFuIHNhbXBsZSBEVFNcbiAgICAgIHNhbXBsZS5wdHMgPSBNYXRoLm1heCh0aGlzLl9QVFNOb3JtYWxpemUoc2FtcGxlLnB0cyAtIHRoaXMuX2luaXREVFMsbmV4dEF2Y0R0cykgLCBzYW1wbGUuZHRzKTtcbiAgICAgIC8vIGVuc3VyZSBwdHMgaXMgYSBtdWx0aXBsZSBvZiBzY2FsZSBmYWN0b3IgdG8gYXZvaWQgcm91bmRpbmcgaXNzdWVzXG4gICAgICBzYW1wbGUucHRzID0gTWF0aC5yb3VuZChzYW1wbGUucHRzL3BlczJtcDRTY2FsZUZhY3RvcikqcGVzMm1wNFNjYWxlRmFjdG9yO1xuICAgIH1cblxuICAgIC8qIGNvbmNhdGVuYXRlIHRoZSB2aWRlbyBkYXRhIGFuZCBjb25zdHJ1Y3QgdGhlIG1kYXQgaW4gcGxhY2VcbiAgICAgIChuZWVkIDggbW9yZSBieXRlcyB0byBmaWxsIGxlbmd0aCBhbmQgbXBkYXQgdHlwZSkgKi9cbiAgICBtZGF0ID0gbmV3IFVpbnQ4QXJyYXkodHJhY2subGVuICsgKDQgKiB0cmFjay5uYk5hbHUpICsgOCk7XG4gICAgbGV0IHZpZXcgPSBuZXcgRGF0YVZpZXcobWRhdC5idWZmZXIpO1xuICAgIHZpZXcuc2V0VWludDMyKDAsIG1kYXQuYnl0ZUxlbmd0aCk7XG4gICAgbWRhdC5zZXQoTVA0LnR5cGVzLm1kYXQsIDQpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dFNhbXBsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCBhdmNTYW1wbGUgPSBpbnB1dFNhbXBsZXNbaV0sXG4gICAgICAgICAgbXA0U2FtcGxlTGVuZ3RoID0gMCxcbiAgICAgICAgICBjb21wb3NpdGlvblRpbWVPZmZzZXQ7XG4gICAgICAvLyBjb252ZXJ0IE5BTFUgYml0c3RyZWFtIHRvIE1QNCBmb3JtYXQgKHByZXBlbmQgTkFMVSB3aXRoIHNpemUgZmllbGQpXG4gICAgICB3aGlsZSAoYXZjU2FtcGxlLnVuaXRzLnVuaXRzLmxlbmd0aCkge1xuICAgICAgICBsZXQgdW5pdCA9IGF2Y1NhbXBsZS51bml0cy51bml0cy5zaGlmdCgpO1xuICAgICAgICB2aWV3LnNldFVpbnQzMihvZmZzZXQsIHVuaXQuZGF0YS5ieXRlTGVuZ3RoKTtcbiAgICAgICAgb2Zmc2V0ICs9IDQ7XG4gICAgICAgIG1kYXQuc2V0KHVuaXQuZGF0YSwgb2Zmc2V0KTtcbiAgICAgICAgb2Zmc2V0ICs9IHVuaXQuZGF0YS5ieXRlTGVuZ3RoO1xuICAgICAgICBtcDRTYW1wbGVMZW5ndGggKz0gNCArIHVuaXQuZGF0YS5ieXRlTGVuZ3RoO1xuICAgICAgfVxuXG4gICAgICBpZighaXNTYWZhcmkpIHtcbiAgICAgICAgLy8gZXhwZWN0ZWQgc2FtcGxlIGR1cmF0aW9uIGlzIHRoZSBEZWNvZGluZyBUaW1lc3RhbXAgZGlmZiBvZiBjb25zZWN1dGl2ZSBzYW1wbGVzXG4gICAgICAgIGlmIChpIDwgaW5wdXRTYW1wbGVzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICBtcDRTYW1wbGVEdXJhdGlvbiA9IGlucHV0U2FtcGxlc1tpKzFdLmR0cyAtIGF2Y1NhbXBsZS5kdHM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGV0IGNvbmZpZyA9IHRoaXMuY29uZmlnLFxuICAgICAgICAgICAgICBsYXN0RnJhbWVEdXJhdGlvbiA9IGF2Y1NhbXBsZS5kdHMgLSBpbnB1dFNhbXBsZXNbaSA+IDAgPyBpLTEgOiBpXS5kdHM7XG4gICAgICAgICAgaWYgKGNvbmZpZy5zdHJldGNoU2hvcnRWaWRlb1RyYWNrKSB7XG4gICAgICAgICAgICAvLyBJbiBzb21lIGNhc2VzLCBhIHNlZ21lbnQncyBhdWRpbyB0cmFjayBkdXJhdGlvbiBtYXkgZXhjZWVkIHRoZSB2aWRlbyB0cmFjayBkdXJhdGlvbi5cbiAgICAgICAgICAgIC8vIFNpbmNlIHdlJ3ZlIGFscmVhZHkgcmVtdXhlZCBhdWRpbywgYW5kIHdlIGtub3cgaG93IGxvbmcgdGhlIGF1ZGlvIHRyYWNrIGlzLCB3ZSBsb29rIHRvXG4gICAgICAgICAgICAvLyBzZWUgaWYgdGhlIGRlbHRhIHRvIHRoZSBuZXh0IHNlZ21lbnQgaXMgbG9uZ2VyIHRoYW4gdGhlIG1pbmltdW0gb2YgbWF4QnVmZmVySG9sZSBhbmRcbiAgICAgICAgICAgIC8vIG1heFNlZWtIb2xlLiBJZiBzbywgcGxheWJhY2sgd291bGQgcG90ZW50aWFsbHkgZ2V0IHN0dWNrLCBzbyB3ZSBhcnRpZmljaWFsbHkgaW5mbGF0ZVxuICAgICAgICAgICAgLy8gdGhlIGR1cmF0aW9uIG9mIHRoZSBsYXN0IGZyYW1lIHRvIG1pbmltaXplIGFueSBwb3RlbnRpYWwgZ2FwIGJldHdlZW4gc2VnbWVudHMuXG4gICAgICAgICAgICBsZXQgbWF4QnVmZmVySG9sZSA9IGNvbmZpZy5tYXhCdWZmZXJIb2xlLFxuICAgICAgICAgICAgICAgIG1heFNlZWtIb2xlID0gY29uZmlnLm1heFNlZWtIb2xlLFxuICAgICAgICAgICAgICAgIGdhcFRvbGVyYW5jZSA9IE1hdGguZmxvb3IoTWF0aC5taW4obWF4QnVmZmVySG9sZSwgbWF4U2Vla0hvbGUpICogcGVzVGltZVNjYWxlKSxcbiAgICAgICAgICAgICAgICBkZWx0YVRvRnJhbWVFbmQgPSAoYXVkaW9UcmFja0xlbmd0aCA/IGZpcnN0UFRTICsgYXVkaW9UcmFja0xlbmd0aCAqIHBlc1RpbWVTY2FsZSA6IHRoaXMubmV4dEFhY1B0cykgLSBhdmNTYW1wbGUucHRzO1xuICAgICAgICAgICAgaWYgKGRlbHRhVG9GcmFtZUVuZCA+IGdhcFRvbGVyYW5jZSkge1xuICAgICAgICAgICAgICAvLyBXZSBzdWJ0cmFjdCBsYXN0RnJhbWVEdXJhdGlvbiBmcm9tIGRlbHRhVG9GcmFtZUVuZCB0byB0cnkgdG8gcHJldmVudCBhbnkgdmlkZW9cbiAgICAgICAgICAgICAgLy8gZnJhbWUgb3ZlcmxhcC4gbWF4QnVmZmVySG9sZS9tYXhTZWVrSG9sZSBzaG91bGQgYmUgPj4gbGFzdEZyYW1lRHVyYXRpb24gYW55d2F5LlxuICAgICAgICAgICAgICBtcDRTYW1wbGVEdXJhdGlvbiA9IGRlbHRhVG9GcmFtZUVuZCAtIGxhc3RGcmFtZUR1cmF0aW9uO1xuICAgICAgICAgICAgICBpZiAobXA0U2FtcGxlRHVyYXRpb24gPCAwKSB7XG4gICAgICAgICAgICAgICAgbXA0U2FtcGxlRHVyYXRpb24gPSBsYXN0RnJhbWVEdXJhdGlvbjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBsb2dnZXIubG9nKGBJdCBpcyBhcHByb3hpbWF0ZWx5ICR7ZGVsdGFUb0ZyYW1lRW5kLzkwfSBtcyB0byB0aGUgbmV4dCBzZWdtZW50OyB1c2luZyBkdXJhdGlvbiAke21wNFNhbXBsZUR1cmF0aW9uLzkwfSBtcyBmb3IgdGhlIGxhc3QgdmlkZW8gZnJhbWUuYCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBtcDRTYW1wbGVEdXJhdGlvbiA9IGxhc3RGcmFtZUR1cmF0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtcDRTYW1wbGVEdXJhdGlvbiA9IGxhc3RGcmFtZUR1cmF0aW9uO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBtcDRTYW1wbGVEdXJhdGlvbiAvPSBwZXMybXA0U2NhbGVGYWN0b3I7XG4gICAgICAgIGNvbXBvc2l0aW9uVGltZU9mZnNldCA9IE1hdGgucm91bmQoKGF2Y1NhbXBsZS5wdHMgLSBhdmNTYW1wbGUuZHRzKSAvIHBlczJtcDRTY2FsZUZhY3Rvcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb21wb3NpdGlvblRpbWVPZmZzZXQgPSBNYXRoLm1heCgwLG1wNFNhbXBsZUR1cmF0aW9uKk1hdGgucm91bmQoKGF2Y1NhbXBsZS5wdHMgLSBhdmNTYW1wbGUuZHRzKS8ocGVzMm1wNFNjYWxlRmFjdG9yKm1wNFNhbXBsZUR1cmF0aW9uKSkpO1xuICAgICAgfVxuXG5cbiAgICAgIC8vY29uc29sZS5sb2coJ1BUUy9EVFMvaW5pdERUUy9ub3JtUFRTL25vcm1EVFMvcmVsYXRpdmUgUFRTIDogJHthdmNTYW1wbGUucHRzfS8ke2F2Y1NhbXBsZS5kdHN9LyR7dGhpcy5faW5pdERUU30vJHtwdHNub3JtfS8ke2R0c25vcm19LyR7KGF2Y1NhbXBsZS5wdHMvNDI5NDk2NzI5NikudG9GaXhlZCgzKX0nKTtcbiAgICAgIG91dHB1dFNhbXBsZXMucHVzaCh7XG4gICAgICAgIHNpemU6IG1wNFNhbXBsZUxlbmd0aCxcbiAgICAgICAgIC8vIGNvbnN0YW50IGR1cmF0aW9uXG4gICAgICAgIGR1cmF0aW9uOiBtcDRTYW1wbGVEdXJhdGlvbixcbiAgICAgICAgY3RzOiBjb21wb3NpdGlvblRpbWVPZmZzZXQsXG4gICAgICAgIGZsYWdzOiB7XG4gICAgICAgICAgaXNMZWFkaW5nOiAwLFxuICAgICAgICAgIGlzRGVwZW5kZWRPbjogMCxcbiAgICAgICAgICBoYXNSZWR1bmRhbmN5OiAwLFxuICAgICAgICAgIGRlZ3JhZFByaW86IDAsXG4gICAgICAgICAgZGVwZW5kc09uIDogYXZjU2FtcGxlLmtleSA/IDIgOiAxLFxuICAgICAgICAgIGlzTm9uU3luYyA6IGF2Y1NhbXBsZS5rZXkgPyAwIDogMVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgLy8gbmV4dCBBVkMgc2FtcGxlIERUUyBzaG91bGQgYmUgZXF1YWwgdG8gbGFzdCBzYW1wbGUgRFRTICsgbGFzdCBzYW1wbGUgZHVyYXRpb24gKGluIFBFUyB0aW1lc2NhbGUpXG4gICAgdGhpcy5uZXh0QXZjRHRzID0gbGFzdERUUyArIG1wNFNhbXBsZUR1cmF0aW9uKnBlczJtcDRTY2FsZUZhY3RvcjtcbiAgICBsZXQgZHJvcHBlZCA9IHRyYWNrLmRyb3BwZWQ7XG4gICAgdHJhY2subGVuID0gMDtcbiAgICB0cmFjay5uYk5hbHUgPSAwO1xuICAgIHRyYWNrLmRyb3BwZWQgPSAwO1xuICAgIGlmKG91dHB1dFNhbXBsZXMubGVuZ3RoICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5pbmRleE9mKCdjaHJvbWUnKSA+IC0xKSB7XG4gICAgICBsZXQgZmxhZ3MgPSBvdXRwdXRTYW1wbGVzWzBdLmZsYWdzO1xuICAgIC8vIGNocm9tZSB3b3JrYXJvdW5kLCBtYXJrIGZpcnN0IHNhbXBsZSBhcyBiZWluZyBhIFJhbmRvbSBBY2Nlc3MgUG9pbnQgdG8gYXZvaWQgc291cmNlYnVmZmVyIGFwcGVuZCBpc3N1ZVxuICAgIC8vIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0yMjk0MTJcbiAgICAgIGZsYWdzLmRlcGVuZHNPbiA9IDI7XG4gICAgICBmbGFncy5pc05vblN5bmMgPSAwO1xuICAgIH1cbiAgICB0cmFjay5zYW1wbGVzID0gb3V0cHV0U2FtcGxlcztcbiAgICBtb29mID0gTVA0Lm1vb2YodHJhY2suc2VxdWVuY2VOdW1iZXIrKywgZmlyc3REVFMgLyBwZXMybXA0U2NhbGVGYWN0b3IsIHRyYWNrKTtcbiAgICB0cmFjay5zYW1wbGVzID0gW107XG5cbiAgICBsZXQgZGF0YSA9IHtcbiAgICAgIGlkIDogdGhpcy5pZCxcbiAgICAgIGxldmVsIDogdGhpcy5sZXZlbCxcbiAgICAgIHNuIDogdGhpcy5zbixcbiAgICAgIGRhdGExOiBtb29mLFxuICAgICAgZGF0YTI6IG1kYXQsXG4gICAgICBzdGFydFBUUzogZmlyc3RQVFMgLyBwZXNUaW1lU2NhbGUsXG4gICAgICBlbmRQVFM6IChsYXN0UFRTICsgcGVzMm1wNFNjYWxlRmFjdG9yICogbXA0U2FtcGxlRHVyYXRpb24pIC8gcGVzVGltZVNjYWxlLFxuICAgICAgc3RhcnREVFM6IGZpcnN0RFRTIC8gcGVzVGltZVNjYWxlLFxuICAgICAgZW5kRFRTOiB0aGlzLm5leHRBdmNEdHMgLyBwZXNUaW1lU2NhbGUsXG4gICAgICB0eXBlOiAndmlkZW8nLFxuICAgICAgbmI6IG91dHB1dFNhbXBsZXMubGVuZ3RoLFxuICAgICAgZHJvcHBlZCA6IGRyb3BwZWRcbiAgICB9O1xuICAgIHRoaXMub2JzZXJ2ZXIudHJpZ2dlcihFdmVudC5GUkFHX1BBUlNJTkdfREFUQSwgZGF0YSk7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cblxuICByZW11eEF1ZGlvKHRyYWNrLCB0aW1lT2Zmc2V0LCBjb250aWd1b3VzLGFjY3VyYXRlVGltZU9mZnNldCkge1xuICAgIGxldCBwZXNUaW1lU2NhbGUgPSB0aGlzLlBFU19USU1FU0NBTEUsXG4gICAgICAgIG1wNHRpbWVTY2FsZSA9IHRyYWNrLnRpbWVzY2FsZSxcbiAgICAgICAgcGVzMm1wNFNjYWxlRmFjdG9yID0gcGVzVGltZVNjYWxlL21wNHRpbWVTY2FsZSxcbiAgICAgICAgZXhwZWN0ZWRTYW1wbGVEdXJhdGlvbiA9IHRyYWNrLnRpbWVzY2FsZSAqIDEwMjQgLyB0cmFjay5hdWRpb3NhbXBsZXJhdGU7XG4gICAgdmFyIHZpZXcsXG4gICAgICAgIG9mZnNldCA9IDgsXG4gICAgICAgIGFhY1NhbXBsZSwgbXA0U2FtcGxlLFxuICAgICAgICB1bml0LFxuICAgICAgICBtZGF0LCBtb29mLFxuICAgICAgICBmaXJzdFBUUywgZmlyc3REVFMsIGxhc3REVFMsXG4gICAgICAgIHB0cywgZHRzLCBwdHNub3JtLCBkdHNub3JtLFxuICAgICAgICBzYW1wbGVzID0gW10sXG4gICAgICAgIHNhbXBsZXMwID0gW10sXG4gICAgICAgIGZpbGxGcmFtZSwgbmV3U3RhbXA7XG5cbiAgICB0cmFjay5zYW1wbGVzLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgcmV0dXJuIChhLnB0cy1iLnB0cyk7XG4gICAgfSk7XG4gICAgc2FtcGxlczAgPSB0cmFjay5zYW1wbGVzO1xuXG4gICAgLy8gZm9yIGF1ZGlvIHNhbXBsZXMsIGFsc28gY29uc2lkZXIgY29uc2VjdXRpdmUgZnJhZ21lbnRzIGFzIGJlaW5nIGNvbnRpZ3VvdXMgKGV2ZW4gaWYgYSBsZXZlbCBzd2l0Y2ggb2NjdXJzKSxcbiAgICAvLyBmb3Igc2FrZSBvZiBjbGFyaXR5OlxuICAgIC8vIGNvbnNlY3V0aXZlIGZyYWdtZW50cyBhcmUgZnJhZ3Mgd2l0aCBsZXNzIHRoYW4gMTAwbXMgZ2FwcyBiZXR3ZWVuIG5ldyB0aW1lIG9mZnNldCBhbmQgbmV4dCBleHBlY3RlZCBQVFNcbiAgICAvLyBjb250aWd1b3VzIGZyYWdtZW50cyBhcmUgY29uc2VjdXRpdmUgZnJhZ21lbnRzIGZyb20gc2FtZSBxdWFsaXR5IGxldmVsIChzYW1lIGxldmVsLCBuZXcgU04gPSBvbGQgU04gKyAxKVxuICAgIC8vIHRoaXMgaGVscHMgZW5zdXJpbmcgYXVkaW8gY29udGludWl0eVxuICAgIC8vIGFuZCB0aGlzIGFsc28gYXZvaWRzIGF1ZGlvIGdsaXRjaGVzL2N1dCB3aGVuIHN3aXRjaGluZyBxdWFsaXR5LCBvciByZXBvcnRpbmcgd3JvbmcgZHVyYXRpb24gb24gZmlyc3QgYXVkaW8gZnJhbWVcblxuICAgIGNvbnRpZ3VvdXMgfD0gKHNhbXBsZXMwLmxlbmd0aCAmJiB0aGlzLm5leHRBYWNQdHMgJiYgTWF0aC5hYnModGltZU9mZnNldC10aGlzLm5leHRBYWNQdHMvcGVzVGltZVNjYWxlKSA8IDAuMSk7XG5cbiAgICBsZXQgbmV4dEFhY1B0cyA9IChjb250aWd1b3VzID8gdGhpcy5uZXh0QWFjUHRzIDogdGltZU9mZnNldCpwZXNUaW1lU2NhbGUpO1xuXG4gICAgLy8gSWYgdGhlIGF1ZGlvIHRyYWNrIGlzIG1pc3Npbmcgc2FtcGxlcywgdGhlIGZyYW1lcyBzZWVtIHRvIGdldCBcImxlZnQtc2hpZnRlZFwiIHdpdGhpbiB0aGVcbiAgICAvLyByZXN1bHRpbmcgbXA0IHNlZ21lbnQsIGNhdXNpbmcgc3luYyBpc3N1ZXMgYW5kIGxlYXZpbmcgZ2FwcyBhdCB0aGUgZW5kIG9mIHRoZSBhdWRpbyBzZWdtZW50LlxuICAgIC8vIEluIGFuIGVmZm9ydCB0byBwcmV2ZW50IHRoaXMgZnJvbSBoYXBwZW5pbmcsIHdlIGluamVjdCBmcmFtZXMgaGVyZSB3aGVyZSB0aGVyZSBhcmUgZ2Fwcy5cbiAgICAvLyBXaGVuIHBvc3NpYmxlLCB3ZSBpbmplY3QgYSBzaWxlbnQgZnJhbWU7IHdoZW4gdGhhdCdzIG5vdCBwb3NzaWJsZSwgd2UgZHVwbGljYXRlIHRoZSBsYXN0XG4gICAgLy8gZnJhbWUuXG4gICAgY29uc3QgcGVzRnJhbWVEdXJhdGlvbiA9IGV4cGVjdGVkU2FtcGxlRHVyYXRpb24gKiBwZXMybXA0U2NhbGVGYWN0b3I7XG4gICAgbGV0IG5leHRQdHNOb3JtID0gbmV4dEFhY1B0cztcblxuICAgIC8vIG9ubHkgaW5qZWN0L2Ryb3AgYXVkaW8gZnJhbWVzIGluIGNhc2UgdGltZSBvZmZzZXQgaXMgYWNjdXJhdGVcbiAgICBpZiAoYWNjdXJhdGVUaW1lT2Zmc2V0KSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNhbXBsZXMwLmxlbmd0aDsgKSB7XG4gICAgICAgIC8vIEZpcnN0LCBsZXQncyBzZWUgaG93IGZhciBvZmYgdGhpcyBmcmFtZSBpcyBmcm9tIHdoZXJlIHdlIGV4cGVjdCBpdCB0byBiZVxuICAgICAgICB2YXIgc2FtcGxlID0gc2FtcGxlczBbaV0sXG4gICAgICAgICAgICBwdHNOb3JtID0gdGhpcy5fUFRTTm9ybWFsaXplKHNhbXBsZS5wdHMgLSB0aGlzLl9pbml0RFRTLCBuZXh0QWFjUHRzKSxcbiAgICAgICAgICAgIGRlbHRhID0gcHRzTm9ybSAtIG5leHRQdHNOb3JtO1xuXG4gICAgICAgIC8vIElmIHdlJ3JlIG92ZXJsYXBwaW5nIGJ5IG1vcmUgdGhhbiBhIGR1cmF0aW9uLCBkcm9wIHRoaXMgc2FtcGxlXG4gICAgICAgIGlmIChkZWx0YSA8PSAtcGVzRnJhbWVEdXJhdGlvbikge1xuICAgICAgICAgIGxvZ2dlci53YXJuKGBEcm9wcGluZyAxIGF1ZGlvIGZyYW1lIEAgJHtNYXRoLnJvdW5kKG5leHRQdHNOb3JtLzkwKS8xMDAwfXMgZHVlIHRvICR7TWF0aC5yb3VuZChNYXRoLmFicyhkZWx0YSAvIDkwKSl9IG1zIG92ZXJsYXAuYCk7XG4gICAgICAgICAgc2FtcGxlczAuc3BsaWNlKGksIDEpO1xuICAgICAgICAgIHRyYWNrLmxlbiAtPSBzYW1wbGUudW5pdC5sZW5ndGg7XG4gICAgICAgICAgLy8gRG9uJ3QgdG91Y2ggbmV4dFB0c05vcm0gb3IgaVxuICAgICAgICB9XG4gICAgICAgIC8vIE90aGVyd2lzZSwgaWYgd2UncmUgbW9yZSB0aGFuIGEgZnJhbWUgYXdheSBmcm9tIHdoZXJlIHdlIHNob3VsZCBiZSwgaW5zZXJ0IG1pc3NpbmcgZnJhbWVzXG4gICAgICAgIGVsc2UgaWYgKGRlbHRhID49IHBlc0ZyYW1lRHVyYXRpb24pIHtcbiAgICAgICAgICB2YXIgbWlzc2luZyA9IE1hdGgucm91bmQoZGVsdGEgLyBwZXNGcmFtZUR1cmF0aW9uKTtcbiAgICAgICAgICBsb2dnZXIud2FybihgSW5qZWN0aW5nICR7bWlzc2luZ30gYXVkaW8gZnJhbWUgQCAke01hdGgucm91bmQobmV4dFB0c05vcm0vOTApLzEwMDB9cyBkdWUgdG8gJHtNYXRoLnJvdW5kKGRlbHRhIC8gOTApfSBtcyBnYXAuYCk7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtaXNzaW5nOyBqKyspIHtcbiAgICAgICAgICAgIG5ld1N0YW1wID0gbmV4dFB0c05vcm0gKyB0aGlzLl9pbml0RFRTO1xuICAgICAgICAgICAgbmV3U3RhbXAgPSBNYXRoLm1heChuZXdTdGFtcCwgdGhpcy5faW5pdERUUyk7XG4gICAgICAgICAgICBmaWxsRnJhbWUgPSBBQUMuZ2V0U2lsZW50RnJhbWUodHJhY2suY2hhbm5lbENvdW50KTtcbiAgICAgICAgICAgIGlmICghZmlsbEZyYW1lKSB7XG4gICAgICAgICAgICAgIGxvZ2dlci5sb2coJ1VuYWJsZSB0byBnZXQgc2lsZW50IGZyYW1lIGZvciBnaXZlbiBhdWRpbyBjb2RlYzsgZHVwbGljYXRpbmcgbGFzdCBmcmFtZSBpbnN0ZWFkLicpO1xuICAgICAgICAgICAgICBmaWxsRnJhbWUgPSBzYW1wbGUudW5pdC5zbGljZSgwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNhbXBsZXMwLnNwbGljZShpLCAwLCB7dW5pdDogZmlsbEZyYW1lLCBwdHM6IG5ld1N0YW1wLCBkdHM6IG5ld1N0YW1wfSk7XG4gICAgICAgICAgICB0cmFjay5sZW4gKz0gZmlsbEZyYW1lLmxlbmd0aDtcbiAgICAgICAgICAgIG5leHRQdHNOb3JtICs9IHBlc0ZyYW1lRHVyYXRpb247XG4gICAgICAgICAgICBpICs9IDE7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gQWRqdXN0IHNhbXBsZSB0byBuZXh0IGV4cGVjdGVkIHB0c1xuICAgICAgICAgIHNhbXBsZS5wdHMgPSBzYW1wbGUuZHRzID0gbmV4dFB0c05vcm0gKyB0aGlzLl9pbml0RFRTO1xuICAgICAgICAgIG5leHRQdHNOb3JtICs9IHBlc0ZyYW1lRHVyYXRpb247XG4gICAgICAgICAgaSArPSAxO1xuICAgICAgICB9XG4gICAgICAgIC8vIE90aGVyd2lzZSwgd2UncmUgd2l0aGluIGhhbGYgYSBmcmFtZSBkdXJhdGlvbiwgc28ganVzdCBhZGp1c3QgcHRzXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlmIChNYXRoLmFicyhkZWx0YSkgPiAoMC4xICogcGVzRnJhbWVEdXJhdGlvbikpIHtcbiAgICAgICAgICAgIC8vbG9nZ2VyLmxvZyhgSW52YWxpZCBmcmFtZSBkZWx0YSAke01hdGgucm91bmQocHRzTm9ybSAtIG5leHRQdHNOb3JtICsgcGVzRnJhbWVEdXJhdGlvbil9IGF0IFBUUyAke01hdGgucm91bmQocHRzTm9ybSAvIDkwKX0gKHNob3VsZCBiZSAke01hdGgucm91bmQocGVzRnJhbWVEdXJhdGlvbil9KS5gKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbmV4dFB0c05vcm0gKz0gcGVzRnJhbWVEdXJhdGlvbjtcbiAgICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgc2FtcGxlLnB0cyA9IHNhbXBsZS5kdHMgPSB0aGlzLl9pbml0RFRTICsgbmV4dEFhY1B0cztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2FtcGxlLnB0cyA9IHNhbXBsZS5kdHMgPSBzYW1wbGVzMFtpIC0gMV0ucHRzICsgcGVzRnJhbWVEdXJhdGlvbjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaSArPSAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG5cbiAgICB3aGlsZSAoc2FtcGxlczAubGVuZ3RoKSB7XG4gICAgICBhYWNTYW1wbGUgPSBzYW1wbGVzMC5zaGlmdCgpO1xuICAgICAgdW5pdCA9IGFhY1NhbXBsZS51bml0O1xuICAgICAgcHRzID0gYWFjU2FtcGxlLnB0cyAtIHRoaXMuX2luaXREVFM7XG4gICAgICBkdHMgPSBhYWNTYW1wbGUuZHRzIC0gdGhpcy5faW5pdERUUztcbiAgICAgIC8vbG9nZ2VyLmxvZyhgQXVkaW8vUFRTOiR7TWF0aC5yb3VuZChwdHMvOTApfWApO1xuICAgICAgLy8gaWYgbm90IGZpcnN0IHNhbXBsZVxuICAgICAgaWYgKGxhc3REVFMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwdHNub3JtID0gdGhpcy5fUFRTTm9ybWFsaXplKHB0cywgbGFzdERUUyk7XG4gICAgICAgIGR0c25vcm0gPSB0aGlzLl9QVFNOb3JtYWxpemUoZHRzLCBsYXN0RFRTKTtcbiAgICAgICAgbXA0U2FtcGxlLmR1cmF0aW9uID0gTWF0aC5yb3VuZCgoZHRzbm9ybSAtIGxhc3REVFMpIC8gcGVzMm1wNFNjYWxlRmFjdG9yKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHB0c25vcm0gPSB0aGlzLl9QVFNOb3JtYWxpemUocHRzLCBuZXh0QWFjUHRzKTtcbiAgICAgICAgZHRzbm9ybSA9IHRoaXMuX1BUU05vcm1hbGl6ZShkdHMsIG5leHRBYWNQdHMpO1xuICAgICAgICBsZXQgZGVsdGEgPSBNYXRoLnJvdW5kKDEwMDAgKiAocHRzbm9ybSAtIG5leHRBYWNQdHMpIC8gcGVzVGltZVNjYWxlKSxcbiAgICAgICAgICAgIG51bU1pc3NpbmdGcmFtZXMgPSAwO1xuICAgICAgICAvLyBpZiBmcmFnbWVudCBhcmUgY29udGlndW91cywgZGV0ZWN0IGhvbGUvb3ZlcmxhcHBpbmcgYmV0d2VlbiBmcmFnbWVudHNcbiAgICAgICAgLy8gY29udGlndW91cyBmcmFnbWVudHMgYXJlIGNvbnNlY3V0aXZlIGZyYWdtZW50cyBmcm9tIHNhbWUgcXVhbGl0eSBsZXZlbCAoc2FtZSBsZXZlbCwgbmV3IFNOID0gb2xkIFNOICsgMSlcbiAgICAgICAgaWYgKGNvbnRpZ3VvdXMpIHtcbiAgICAgICAgICAvLyBsb2cgZGVsdGFcbiAgICAgICAgICBpZiAoZGVsdGEpIHtcbiAgICAgICAgICAgIGlmIChkZWx0YSA+IDApIHtcbiAgICAgICAgICAgICAgbnVtTWlzc2luZ0ZyYW1lcyA9IE1hdGgucm91bmQoKHB0c25vcm0gLSBuZXh0QWFjUHRzKSAvIHBlc0ZyYW1lRHVyYXRpb24pO1xuICAgICAgICAgICAgICBsb2dnZXIubG9nKGAke2RlbHRhfSBtcyBob2xlIGJldHdlZW4gQUFDIHNhbXBsZXMgZGV0ZWN0ZWQsZmlsbGluZyBpdGApO1xuICAgICAgICAgICAgICBpZiAobnVtTWlzc2luZ0ZyYW1lcyA+IDApIHtcbiAgICAgICAgICAgICAgICBmaWxsRnJhbWUgPSBBQUMuZ2V0U2lsZW50RnJhbWUodHJhY2suY2hhbm5lbENvdW50KTtcbiAgICAgICAgICAgICAgICBpZiAoIWZpbGxGcmFtZSkge1xuICAgICAgICAgICAgICAgICAgZmlsbEZyYW1lID0gdW5pdC5zbGljZSgwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJhY2subGVuICs9IG51bU1pc3NpbmdGcmFtZXMgKiBmaWxsRnJhbWUubGVuZ3RoO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIGlmIHdlIGhhdmUgZnJhbWUgb3ZlcmxhcCwgb3ZlcmxhcHBpbmcgZm9yIG1vcmUgdGhhbiBoYWxmIGEgZnJhbWUgZHVyYWlvblxuICAgICAgICAgICAgfSBlbHNlIGlmIChkZWx0YSA8IC0xMikge1xuICAgICAgICAgICAgICAvLyBkcm9wIG92ZXJsYXBwaW5nIGF1ZGlvIGZyYW1lcy4uLiBicm93c2VyIHdpbGwgZGVhbCB3aXRoIGl0XG4gICAgICAgICAgICAgIGxvZ2dlci5sb2coYCR7KC1kZWx0YSl9IG1zIG92ZXJsYXBwaW5nIGJldHdlZW4gQUFDIHNhbXBsZXMgZGV0ZWN0ZWQsIGRyb3AgZnJhbWVgKTtcbiAgICAgICAgICAgICAgdHJhY2subGVuIC09IHVuaXQuYnl0ZUxlbmd0aDtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBzZXQgUFRTL0RUUyB0byBleHBlY3RlZCBQVFMvRFRTXG4gICAgICAgICAgICBwdHNub3JtID0gZHRzbm9ybSA9IG5leHRBYWNQdHM7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHJlbWVtYmVyIGZpcnN0IFBUUyBvZiBvdXIgYWFjU2FtcGxlcywgZW5zdXJlIHZhbHVlIGlzIHBvc2l0aXZlXG4gICAgICAgIGZpcnN0UFRTID0gTWF0aC5tYXgoMCwgcHRzbm9ybSk7XG4gICAgICAgIGZpcnN0RFRTID0gTWF0aC5tYXgoMCwgZHRzbm9ybSk7XG4gICAgICAgIGlmKHRyYWNrLmxlbiA+IDApIHtcbiAgICAgICAgICAvKiBjb25jYXRlbmF0ZSB0aGUgYXVkaW8gZGF0YSBhbmQgY29uc3RydWN0IHRoZSBtZGF0IGluIHBsYWNlXG4gICAgICAgICAgICAobmVlZCA4IG1vcmUgYnl0ZXMgdG8gZmlsbCBsZW5ndGggYW5kIG1kYXQgdHlwZSkgKi9cbiAgICAgICAgICBtZGF0ID0gbmV3IFVpbnQ4QXJyYXkodHJhY2subGVuICsgOCk7XG4gICAgICAgICAgdmlldyA9IG5ldyBEYXRhVmlldyhtZGF0LmJ1ZmZlcik7XG4gICAgICAgICAgdmlldy5zZXRVaW50MzIoMCwgbWRhdC5ieXRlTGVuZ3RoKTtcbiAgICAgICAgICBtZGF0LnNldChNUDQudHlwZXMubWRhdCwgNCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gbm8gYXVkaW8gc2FtcGxlc1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bU1pc3NpbmdGcmFtZXM7IGkrKykge1xuICAgICAgICAgIG5ld1N0YW1wID0gcHRzbm9ybSAtIChudW1NaXNzaW5nRnJhbWVzIC0gaSkgKiBwZXNGcmFtZUR1cmF0aW9uO1xuICAgICAgICAgIGZpbGxGcmFtZSA9IEFBQy5nZXRTaWxlbnRGcmFtZSh0cmFjay5jaGFubmVsQ291bnQpO1xuICAgICAgICAgIGlmICghZmlsbEZyYW1lKSB7XG4gICAgICAgICAgICBsb2dnZXIubG9nKCdVbmFibGUgdG8gZ2V0IHNpbGVudCBmcmFtZSBmb3IgZ2l2ZW4gYXVkaW8gY29kZWM7IGR1cGxpY2F0aW5nIHRoaXMgZnJhbWUgaW5zdGVhZC4nKTtcbiAgICAgICAgICAgIGZpbGxGcmFtZSA9IHVuaXQuc2xpY2UoMCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG1kYXQuc2V0KGZpbGxGcmFtZSwgb2Zmc2V0KTtcbiAgICAgICAgICBvZmZzZXQgKz0gZmlsbEZyYW1lLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgbXA0U2FtcGxlID0ge1xuICAgICAgICAgICAgc2l6ZTogZmlsbEZyYW1lLmJ5dGVMZW5ndGgsXG4gICAgICAgICAgICBjdHM6IDAsXG4gICAgICAgICAgICBkdXJhdGlvbjogMTAyNCxcbiAgICAgICAgICAgIGZsYWdzOiB7XG4gICAgICAgICAgICAgIGlzTGVhZGluZzogMCxcbiAgICAgICAgICAgICAgaXNEZXBlbmRlZE9uOiAwLFxuICAgICAgICAgICAgICBoYXNSZWR1bmRhbmN5OiAwLFxuICAgICAgICAgICAgICBkZWdyYWRQcmlvOiAwLFxuICAgICAgICAgICAgICBkZXBlbmRzT246IDEsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICBzYW1wbGVzLnB1c2gobXA0U2FtcGxlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbWRhdC5zZXQodW5pdCwgb2Zmc2V0KTtcbiAgICAgIG9mZnNldCArPSB1bml0LmJ5dGVMZW5ndGg7XG4gICAgICAvL2NvbnNvbGUubG9nKCdQVFMvRFRTL2luaXREVFMvbm9ybVBUUy9ub3JtRFRTL3JlbGF0aXZlIFBUUyA6ICR7YWFjU2FtcGxlLnB0c30vJHthYWNTYW1wbGUuZHRzfS8ke3RoaXMuX2luaXREVFN9LyR7cHRzbm9ybX0vJHtkdHNub3JtfS8keyhhYWNTYW1wbGUucHRzLzQyOTQ5NjcyOTYpLnRvRml4ZWQoMyl9Jyk7XG4gICAgICBtcDRTYW1wbGUgPSB7XG4gICAgICAgIHNpemU6IHVuaXQuYnl0ZUxlbmd0aCxcbiAgICAgICAgY3RzOiAwLFxuICAgICAgICBkdXJhdGlvbjogMCxcbiAgICAgICAgZmxhZ3M6IHtcbiAgICAgICAgICBpc0xlYWRpbmc6IDAsXG4gICAgICAgICAgaXNEZXBlbmRlZE9uOiAwLFxuICAgICAgICAgIGhhc1JlZHVuZGFuY3k6IDAsXG4gICAgICAgICAgZGVncmFkUHJpbzogMCxcbiAgICAgICAgICBkZXBlbmRzT246IDEsXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBzYW1wbGVzLnB1c2gobXA0U2FtcGxlKTtcbiAgICAgIGxhc3REVFMgPSBkdHNub3JtO1xuICAgIH1cbiAgICB2YXIgbGFzdFNhbXBsZUR1cmF0aW9uID0gMDtcbiAgICB2YXIgbmJTYW1wbGVzID0gc2FtcGxlcy5sZW5ndGg7XG4gICAgLy9zZXQgbGFzdCBzYW1wbGUgZHVyYXRpb24gYXMgYmVpbmcgaWRlbnRpY2FsIHRvIHByZXZpb3VzIHNhbXBsZVxuICAgIGlmIChuYlNhbXBsZXMgPj0gMikge1xuICAgICAgbGFzdFNhbXBsZUR1cmF0aW9uID0gc2FtcGxlc1tuYlNhbXBsZXMgLSAyXS5kdXJhdGlvbjtcbiAgICAgIG1wNFNhbXBsZS5kdXJhdGlvbiA9IGxhc3RTYW1wbGVEdXJhdGlvbjtcbiAgICB9XG4gICAgaWYgKG5iU2FtcGxlcykge1xuICAgICAgLy8gbmV4dCBhYWMgc2FtcGxlIFBUUyBzaG91bGQgYmUgZXF1YWwgdG8gbGFzdCBzYW1wbGUgUFRTICsgZHVyYXRpb25cbiAgICAgIHRoaXMubmV4dEFhY1B0cyA9IHB0c25vcm0gKyBwZXMybXA0U2NhbGVGYWN0b3IgKiBsYXN0U2FtcGxlRHVyYXRpb247XG4gICAgICAvL2xvZ2dlci5sb2coJ0F1ZGlvL1BUUy9QVFNlbmQ6JyArIGFhY1NhbXBsZS5wdHMudG9GaXhlZCgwKSArICcvJyArIHRoaXMubmV4dEFhY0R0cy50b0ZpeGVkKDApKTtcbiAgICAgIHRyYWNrLmxlbiA9IDA7XG4gICAgICB0cmFjay5zYW1wbGVzID0gc2FtcGxlcztcbiAgICAgIG1vb2YgPSBNUDQubW9vZih0cmFjay5zZXF1ZW5jZU51bWJlcisrLCBmaXJzdERUUyAvIHBlczJtcDRTY2FsZUZhY3RvciwgdHJhY2spO1xuICAgICAgdHJhY2suc2FtcGxlcyA9IFtdO1xuICAgICAgbGV0IGF1ZGlvRGF0YSA9IHtcbiAgICAgICAgaWQgOiB0aGlzLmlkLFxuICAgICAgICBsZXZlbCA6IHRoaXMubGV2ZWwsXG4gICAgICAgIHNuIDogdGhpcy5zbixcbiAgICAgICAgZGF0YTE6IG1vb2YsXG4gICAgICAgIGRhdGEyOiBtZGF0LFxuICAgICAgICBzdGFydFBUUzogZmlyc3RQVFMgLyBwZXNUaW1lU2NhbGUsXG4gICAgICAgIGVuZFBUUzogdGhpcy5uZXh0QWFjUHRzIC8gcGVzVGltZVNjYWxlLFxuICAgICAgICBzdGFydERUUzogZmlyc3REVFMgLyBwZXNUaW1lU2NhbGUsXG4gICAgICAgIGVuZERUUzogKGR0c25vcm0gKyBwZXMybXA0U2NhbGVGYWN0b3IgKiBsYXN0U2FtcGxlRHVyYXRpb24pIC8gcGVzVGltZVNjYWxlLFxuICAgICAgICB0eXBlOiAnYXVkaW8nLFxuICAgICAgICBuYjogbmJTYW1wbGVzXG4gICAgICB9O1xuICAgICAgdGhpcy5vYnNlcnZlci50cmlnZ2VyKEV2ZW50LkZSQUdfUEFSU0lOR19EQVRBLCBhdWRpb0RhdGEpO1xuICAgICAgcmV0dXJuIGF1ZGlvRGF0YTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZW11eEVtcHR5QXVkaW8odHJhY2ssIHRpbWVPZmZzZXQsIGNvbnRpZ3VvdXMsIHZpZGVvRGF0YSkge1xuICAgIGxldCBwZXNUaW1lU2NhbGUgPSB0aGlzLlBFU19USU1FU0NBTEUsXG4gICAgICAgIG1wNHRpbWVTY2FsZSA9IHRyYWNrLnRpbWVzY2FsZSA/IHRyYWNrLnRpbWVzY2FsZSA6IHRyYWNrLmF1ZGlvc2FtcGxlcmF0ZSxcbiAgICAgICAgcGVzMm1wNFNjYWxlRmFjdG9yID0gcGVzVGltZVNjYWxlL21wNHRpbWVTY2FsZSxcblxuICAgICAgICAvLyBzeW5jIHdpdGggdmlkZW8ncyB0aW1lc3RhbXBcbiAgICAgICAgc3RhcnREVFMgPSB2aWRlb0RhdGEuc3RhcnREVFMgKiBwZXNUaW1lU2NhbGUgKyB0aGlzLl9pbml0RFRTLFxuICAgICAgICBlbmREVFMgPSB2aWRlb0RhdGEuZW5kRFRTICogcGVzVGltZVNjYWxlICsgdGhpcy5faW5pdERUUyxcblxuICAgICAgICAvLyBvbmUgc2FtcGxlJ3MgZHVyYXRpb24gdmFsdWVcbiAgICAgICAgc2FtcGxlRHVyYXRpb24gPSAxMDI0LFxuICAgICAgICBmcmFtZUR1cmF0aW9uID0gcGVzMm1wNFNjYWxlRmFjdG9yICogc2FtcGxlRHVyYXRpb24sXG5cbiAgICAgICAgLy8gc2FtcGxlcyBjb3VudCBvZiB0aGlzIHNlZ21lbnQncyBkdXJhdGlvblxuICAgICAgICBuYlNhbXBsZXMgPSBNYXRoLmNlaWwoKGVuZERUUyAtIHN0YXJ0RFRTKSAvIGZyYW1lRHVyYXRpb24pLFxuXG4gICAgICAgIC8vIHNpbGVudCBmcmFtZVxuICAgICAgICBzaWxlbnRGcmFtZSA9IEFBQy5nZXRTaWxlbnRGcmFtZSh0cmFjay5jaGFubmVsQ291bnQpO1xuXG4gICAgLy8gQ2FuJ3QgcmVtdXggaWYgd2UgY2FuJ3QgZ2VuZXJhdGUgYSBzaWxlbnQgZnJhbWUuLi5cbiAgICBpZiAoIXNpbGVudEZyYW1lKSB7XG4gICAgICBsb2dnZXIudHJhY2UoJ1VuYWJsZSB0byByZW11eEVtcHR5QXVkaW8gc2luY2Ugd2Ugd2VyZSB1bmFibGUgdG8gZ2V0IGEgc2lsZW50IGZyYW1lIGZvciBnaXZlbiBhdWRpbyBjb2RlYyEnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgc2FtcGxlcyA9IFtdO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBuYlNhbXBsZXM7IGkrKykge1xuICAgICAgdmFyIHN0YW1wID0gc3RhcnREVFMgKyBpICogZnJhbWVEdXJhdGlvbjtcbiAgICAgIHNhbXBsZXMucHVzaCh7dW5pdDogc2lsZW50RnJhbWUuc2xpY2UoMCksIHB0czogc3RhbXAsIGR0czogc3RhbXB9KTtcbiAgICAgIHRyYWNrLmxlbiArPSBzaWxlbnRGcmFtZS5sZW5ndGg7XG4gICAgfVxuICAgIHRyYWNrLnNhbXBsZXMgPSBzYW1wbGVzO1xuXG4gICAgdGhpcy5yZW11eEF1ZGlvKHRyYWNrLCB0aW1lT2Zmc2V0LCBjb250aWd1b3VzKTtcbiAgfVxuXG4gIHJlbXV4SUQzKHRyYWNrLHRpbWVPZmZzZXQpIHtcbiAgICB2YXIgbGVuZ3RoID0gdHJhY2suc2FtcGxlcy5sZW5ndGgsIHNhbXBsZTtcbiAgICAvLyBjb25zdW1lIHNhbXBsZXNcbiAgICBpZihsZW5ndGgpIHtcbiAgICAgIGZvcih2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICBzYW1wbGUgPSB0cmFjay5zYW1wbGVzW2luZGV4XTtcbiAgICAgICAgLy8gc2V0dGluZyBpZDMgcHRzLCBkdHMgdG8gcmVsYXRpdmUgdGltZVxuICAgICAgICAvLyB1c2luZyB0aGlzLl9pbml0UFRTIGFuZCB0aGlzLl9pbml0RFRTIHRvIGNhbGN1bGF0ZSByZWxhdGl2ZSB0aW1lXG4gICAgICAgIHNhbXBsZS5wdHMgPSAoKHNhbXBsZS5wdHMgLSB0aGlzLl9pbml0UFRTKSAvIHRoaXMuUEVTX1RJTUVTQ0FMRSk7XG4gICAgICAgIHNhbXBsZS5kdHMgPSAoKHNhbXBsZS5kdHMgLSB0aGlzLl9pbml0RFRTKSAvIHRoaXMuUEVTX1RJTUVTQ0FMRSk7XG4gICAgICB9XG4gICAgICB0aGlzLm9ic2VydmVyLnRyaWdnZXIoRXZlbnQuRlJBR19QQVJTSU5HX01FVEFEQVRBLCB7XG4gICAgICAgIGlkIDogdGhpcy5pZCxcbiAgICAgICAgbGV2ZWwgOiB0aGlzLmxldmVsLFxuICAgICAgICBzbiA6IHRoaXMuc24sXG4gICAgICAgIHNhbXBsZXM6dHJhY2suc2FtcGxlc1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdHJhY2suc2FtcGxlcyA9IFtdO1xuICAgIHRpbWVPZmZzZXQgPSB0aW1lT2Zmc2V0O1xuICB9XG5cbiAgcmVtdXhUZXh0KHRyYWNrLHRpbWVPZmZzZXQpIHtcbiAgICB0cmFjay5zYW1wbGVzLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgcmV0dXJuIChhLnB0cy1iLnB0cyk7XG4gICAgfSk7XG5cbiAgICB2YXIgbGVuZ3RoID0gdHJhY2suc2FtcGxlcy5sZW5ndGgsIHNhbXBsZTtcbiAgICAvLyBjb25zdW1lIHNhbXBsZXNcbiAgICBpZihsZW5ndGgpIHtcbiAgICAgIGZvcih2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICBzYW1wbGUgPSB0cmFjay5zYW1wbGVzW2luZGV4XTtcbiAgICAgICAgLy8gc2V0dGluZyB0ZXh0IHB0cywgZHRzIHRvIHJlbGF0aXZlIHRpbWVcbiAgICAgICAgLy8gdXNpbmcgdGhpcy5faW5pdFBUUyBhbmQgdGhpcy5faW5pdERUUyB0byBjYWxjdWxhdGUgcmVsYXRpdmUgdGltZVxuICAgICAgICBzYW1wbGUucHRzID0gKChzYW1wbGUucHRzIC0gdGhpcy5faW5pdFBUUykgLyB0aGlzLlBFU19USU1FU0NBTEUpO1xuICAgICAgfVxuICAgICAgdGhpcy5vYnNlcnZlci50cmlnZ2VyKEV2ZW50LkZSQUdfUEFSU0lOR19VU0VSREFUQSwge1xuICAgICAgICBpZCA6IHRoaXMuaWQsXG4gICAgICAgIGxldmVsIDogdGhpcy5sZXZlbCxcbiAgICAgICAgc24gOiB0aGlzLnNuLFxuICAgICAgICBzYW1wbGVzOnRyYWNrLnNhbXBsZXNcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRyYWNrLnNhbXBsZXMgPSBbXTtcbiAgICB0aW1lT2Zmc2V0ID0gdGltZU9mZnNldDtcbiAgfVxuXG4gIF9QVFNOb3JtYWxpemUodmFsdWUsIHJlZmVyZW5jZSkge1xuICAgIHZhciBvZmZzZXQ7XG4gICAgaWYgKHJlZmVyZW5jZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGlmIChyZWZlcmVuY2UgPCB2YWx1ZSkge1xuICAgICAgLy8gLSAyXjMzXG4gICAgICBvZmZzZXQgPSAtODU4OTkzNDU5MjtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gKyAyXjMzXG4gICAgICBvZmZzZXQgPSA4NTg5OTM0NTkyO1xuICAgIH1cbiAgICAvKiBQVFMgaXMgMzNiaXQgKGZyb20gMCB0byAyXjMzIC0xKVxuICAgICAgaWYgZGlmZiBiZXR3ZWVuIHZhbHVlIGFuZCByZWZlcmVuY2UgaXMgYmlnZ2VyIHRoYW4gaGFsZiBvZiB0aGUgYW1wbGl0dWRlICgyXjMyKSB0aGVuIGl0IG1lYW5zIHRoYXRcbiAgICAgIFBUUyBsb29waW5nIG9jY3VyZWQuIGZpbGwgdGhlIGdhcCAqL1xuICAgIHdoaWxlIChNYXRoLmFicyh2YWx1ZSAtIHJlZmVyZW5jZSkgPiA0Mjk0OTY3Mjk2KSB7XG4gICAgICAgIHZhbHVlICs9IG9mZnNldDtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgTVA0UmVtdXhlcjtcbiIsIi8qKlxuICogcGFzc3Rocm91Z2ggcmVtdXhlclxuKi9cbmltcG9ydCBFdmVudCBmcm9tICcuLi9ldmVudHMnO1xuXG5jbGFzcyBQYXNzVGhyb3VnaFJlbXV4ZXIge1xuICBjb25zdHJ1Y3RvcihvYnNlcnZlcixpZCkge1xuICAgIHRoaXMub2JzZXJ2ZXIgPSBvYnNlcnZlcjtcbiAgICB0aGlzLmlkID0gaWQ7XG4gICAgdGhpcy5JU0dlbmVyYXRlZCA9IGZhbHNlO1xuICB9XG5cbiAgZ2V0IHBhc3N0aHJvdWdoKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgfVxuXG4gIGluc2VydERpc2NvbnRpbnVpdHkoKSB7XG4gIH1cblxuICBzd2l0Y2hMZXZlbCgpIHtcbiAgICB0aGlzLklTR2VuZXJhdGVkID0gZmFsc2U7XG4gIH1cblxuICByZW11eChhdWRpb1RyYWNrLHZpZGVvVHJhY2ssaWQzVHJhY2ssdGV4dFRyYWNrLHRpbWVPZmZzZXQscmF3RGF0YSkge1xuICAgIHZhciBvYnNlcnZlciA9IHRoaXMub2JzZXJ2ZXI7XG4gICAgLy8gZ2VuZXJhdGUgSW5pdCBTZWdtZW50IGlmIG5lZWRlZFxuICAgIGlmICghdGhpcy5JU0dlbmVyYXRlZCkge1xuICAgICAgdmFyIHRyYWNrcyA9IHt9LFxuICAgICAgICAgIGRhdGEgPSB7IGlkIDogdGhpcy5pZCwgdHJhY2tzIDogdHJhY2tzLCB1bmlxdWUgOiB0cnVlIH0sXG4gICAgICAgICAgdHJhY2sgPSB2aWRlb1RyYWNrLFxuICAgICAgICAgIGNvZGVjID0gdHJhY2suY29kZWM7XG5cbiAgICAgIGlmIChjb2RlYykge1xuICAgICAgICBkYXRhLnRyYWNrcy52aWRlbyA9IHtcbiAgICAgICAgICBjb250YWluZXIgOiB0cmFjay5jb250YWluZXIsXG4gICAgICAgICAgY29kZWMgOiAgY29kZWMsXG4gICAgICAgICAgbWV0YWRhdGEgOiB7XG4gICAgICAgICAgICB3aWR0aCA6IHRyYWNrLndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0IDogdHJhY2suaGVpZ2h0XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICB0cmFjayA9IGF1ZGlvVHJhY2s7XG4gICAgICBjb2RlYyA9IHRyYWNrLmNvZGVjO1xuICAgICAgaWYgKGNvZGVjKSB7XG4gICAgICAgIGRhdGEudHJhY2tzLmF1ZGlvID0ge1xuICAgICAgICAgIGNvbnRhaW5lciA6IHRyYWNrLmNvbnRhaW5lcixcbiAgICAgICAgICBjb2RlYyA6ICBjb2RlYyxcbiAgICAgICAgICBtZXRhZGF0YSA6IHtcbiAgICAgICAgICAgIGNoYW5uZWxDb3VudCA6IHRyYWNrLmNoYW5uZWxDb3VudFxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHRoaXMuSVNHZW5lcmF0ZWQgPSB0cnVlO1xuICAgICAgb2JzZXJ2ZXIudHJpZ2dlcihFdmVudC5GUkFHX1BBUlNJTkdfSU5JVF9TRUdNRU5ULGRhdGEpO1xuICAgIH1cbiAgICBvYnNlcnZlci50cmlnZ2VyKEV2ZW50LkZSQUdfUEFSU0lOR19EQVRBLCB7XG4gICAgICBpZCA6IHRoaXMuaWQsXG4gICAgICBkYXRhMTogcmF3RGF0YSxcbiAgICAgIHN0YXJ0UFRTOiB0aW1lT2Zmc2V0LFxuICAgICAgc3RhcnREVFM6IHRpbWVPZmZzZXQsXG4gICAgICB0eXBlOiAnYXVkaW92aWRlbycsXG4gICAgICBuYjogMSxcbiAgICAgIGRyb3BwZWQgOiAwXG4gICAgfSk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgUGFzc1Rocm91Z2hSZW11eGVyO1xuIiwiXG4vLyBhZGFwdGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2thbm9uZ2lsL25vZGUtbTN1OHBhcnNlL2Jsb2IvbWFzdGVyL2F0dHJsaXN0LmpzXG5jbGFzcyBBdHRyTGlzdCB7XG5cbiAgY29uc3RydWN0b3IoYXR0cnMpIHtcbiAgICBpZiAodHlwZW9mIGF0dHJzID09PSAnc3RyaW5nJykge1xuICAgICAgYXR0cnMgPSBBdHRyTGlzdC5wYXJzZUF0dHJMaXN0KGF0dHJzKTtcbiAgICB9XG4gICAgZm9yKHZhciBhdHRyIGluIGF0dHJzKXtcbiAgICAgIGlmKGF0dHJzLmhhc093blByb3BlcnR5KGF0dHIpKSB7XG4gICAgICAgIHRoaXNbYXR0cl0gPSBhdHRyc1thdHRyXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBkZWNpbWFsSW50ZWdlcihhdHRyTmFtZSkge1xuICAgIGNvbnN0IGludFZhbHVlID0gcGFyc2VJbnQodGhpc1thdHRyTmFtZV0sIDEwKTtcbiAgICBpZiAoaW50VmFsdWUgPiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUikge1xuICAgICAgcmV0dXJuIEluZmluaXR5O1xuICAgIH1cbiAgICByZXR1cm4gaW50VmFsdWU7XG4gIH1cblxuICBoZXhhZGVjaW1hbEludGVnZXIoYXR0ck5hbWUpIHtcbiAgICBpZih0aGlzW2F0dHJOYW1lXSkge1xuICAgICAgbGV0IHN0cmluZ1ZhbHVlID0gKHRoaXNbYXR0ck5hbWVdIHx8ICcweCcpLnNsaWNlKDIpO1xuICAgICAgc3RyaW5nVmFsdWUgPSAoKHN0cmluZ1ZhbHVlLmxlbmd0aCAmIDEpID8gJzAnIDogJycpICsgc3RyaW5nVmFsdWU7XG5cbiAgICAgIGNvbnN0IHZhbHVlID0gbmV3IFVpbnQ4QXJyYXkoc3RyaW5nVmFsdWUubGVuZ3RoIC8gMik7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0cmluZ1ZhbHVlLmxlbmd0aCAvIDI7IGkrKykge1xuICAgICAgICB2YWx1ZVtpXSA9IHBhcnNlSW50KHN0cmluZ1ZhbHVlLnNsaWNlKGkgKiAyLCBpICogMiArIDIpLCAxNik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIGhleGFkZWNpbWFsSW50ZWdlckFzTnVtYmVyKGF0dHJOYW1lKSB7XG4gICAgY29uc3QgaW50VmFsdWUgPSBwYXJzZUludCh0aGlzW2F0dHJOYW1lXSwgMTYpO1xuICAgIGlmIChpbnRWYWx1ZSA+IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKSB7XG4gICAgICByZXR1cm4gSW5maW5pdHk7XG4gICAgfVxuICAgIHJldHVybiBpbnRWYWx1ZTtcbiAgfVxuXG4gIGRlY2ltYWxGbG9hdGluZ1BvaW50KGF0dHJOYW1lKSB7XG4gICAgcmV0dXJuIHBhcnNlRmxvYXQodGhpc1thdHRyTmFtZV0pO1xuICB9XG5cbiAgZW51bWVyYXRlZFN0cmluZyhhdHRyTmFtZSkge1xuICAgIHJldHVybiB0aGlzW2F0dHJOYW1lXTtcbiAgfVxuXG4gIGRlY2ltYWxSZXNvbHV0aW9uKGF0dHJOYW1lKSB7XG4gICAgY29uc3QgcmVzID0gL14oXFxkKyl4KFxcZCspJC8uZXhlYyh0aGlzW2F0dHJOYW1lXSk7XG4gICAgaWYgKHJlcyA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHdpZHRoOiBwYXJzZUludChyZXNbMV0sIDEwKSxcbiAgICAgIGhlaWdodDogcGFyc2VJbnQocmVzWzJdLCAxMClcbiAgICB9O1xuICB9XG5cbiAgc3RhdGljIHBhcnNlQXR0ckxpc3QoaW5wdXQpIHtcbiAgICBjb25zdCByZSA9IC9cXHMqKC4rPylcXHMqPSgoPzpcXFwiLio/XFxcIil8Lio/KSg/Oix8JCkvZztcbiAgICB2YXIgbWF0Y2gsIGF0dHJzID0ge307XG4gICAgd2hpbGUgKChtYXRjaCA9IHJlLmV4ZWMoaW5wdXQpKSAhPT0gbnVsbCkge1xuICAgICAgdmFyIHZhbHVlID0gbWF0Y2hbMl0sIHF1b3RlID0gJ1wiJztcblxuICAgICAgaWYgKHZhbHVlLmluZGV4T2YocXVvdGUpID09PSAwICYmXG4gICAgICAgICAgdmFsdWUubGFzdEluZGV4T2YocXVvdGUpID09PSAodmFsdWUubGVuZ3RoLTEpKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUuc2xpY2UoMSwgLTEpO1xuICAgICAgfVxuICAgICAgYXR0cnNbbWF0Y2hbMV1dID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBhdHRycztcbiAgfVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IEF0dHJMaXN0O1xuIiwidmFyIEJpbmFyeVNlYXJjaCA9IHtcbiAgICAvKipcbiAgICAgKiBTZWFyY2hlcyBmb3IgYW4gaXRlbSBpbiBhbiBhcnJheSB3aGljaCBtYXRjaGVzIGEgY2VydGFpbiBjb25kaXRpb24uXG4gICAgICogVGhpcyByZXF1aXJlcyB0aGUgY29uZGl0aW9uIHRvIG9ubHkgbWF0Y2ggb25lIGl0ZW0gaW4gdGhlIGFycmF5LFxuICAgICAqIGFuZCBmb3IgdGhlIGFycmF5IHRvIGJlIG9yZGVyZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBhcnJheSB0byBzZWFyY2guXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY29tcGFyaXNvbkZ1bmN0aW9uXG4gICAgICogICAgICBDYWxsZWQgYW5kIHByb3ZpZGVkIGEgY2FuZGlkYXRlIGl0ZW0gYXMgdGhlIGZpcnN0IGFyZ3VtZW50LlxuICAgICAqICAgICAgU2hvdWxkIHJldHVybjpcbiAgICAgKiAgICAgICAgICA+IC0xIGlmIHRoZSBpdGVtIHNob3VsZCBiZSBsb2NhdGVkIGF0IGEgbG93ZXIgaW5kZXggdGhhbiB0aGUgcHJvdmlkZWQgaXRlbS5cbiAgICAgKiAgICAgICAgICA+IDEgaWYgdGhlIGl0ZW0gc2hvdWxkIGJlIGxvY2F0ZWQgYXQgYSBoaWdoZXIgaW5kZXggdGhhbiB0aGUgcHJvdmlkZWQgaXRlbS5cbiAgICAgKiAgICAgICAgICA+IDAgaWYgdGhlIGl0ZW0gaXMgdGhlIGl0ZW0geW91J3JlIGxvb2tpbmcgZm9yLlxuICAgICAqXG4gICAgICogQHJldHVybiB7Kn0gVGhlIG9iamVjdCBpZiBpdCBpcyBmb3VuZCBvciBudWxsIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBzZWFyY2g6IGZ1bmN0aW9uKGxpc3QsIGNvbXBhcmlzb25GdW5jdGlvbikge1xuICAgICAgICB2YXIgbWluSW5kZXggPSAwO1xuICAgICAgICB2YXIgbWF4SW5kZXggPSBsaXN0Lmxlbmd0aCAtIDE7XG4gICAgICAgIHZhciBjdXJyZW50SW5kZXggPSBudWxsO1xuICAgICAgICB2YXIgY3VycmVudEVsZW1lbnQgPSBudWxsO1xuICAgICBcbiAgICAgICAgd2hpbGUgKG1pbkluZGV4IDw9IG1heEluZGV4KSB7XG4gICAgICAgICAgICBjdXJyZW50SW5kZXggPSAobWluSW5kZXggKyBtYXhJbmRleCkgLyAyIHwgMDtcbiAgICAgICAgICAgIGN1cnJlbnRFbGVtZW50ID0gbGlzdFtjdXJyZW50SW5kZXhdO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB2YXIgY29tcGFyaXNvblJlc3VsdCA9IGNvbXBhcmlzb25GdW5jdGlvbihjdXJyZW50RWxlbWVudCk7XG4gICAgICAgICAgICBpZiAoY29tcGFyaXNvblJlc3VsdCA+IDApIHtcbiAgICAgICAgICAgICAgICBtaW5JbmRleCA9IGN1cnJlbnRJbmRleCArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjb21wYXJpc29uUmVzdWx0IDwgMCkge1xuICAgICAgICAgICAgICAgIG1heEluZGV4ID0gY3VycmVudEluZGV4IC0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBjdXJyZW50RWxlbWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICBcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBCaW5hcnlTZWFyY2g7XG4iLCIvKipcbiAqXG4gKiBUaGlzIGNvZGUgd2FzIHBvcnRlZCBmcm9tIHRoZSBkYXNoLmpzIHByb2plY3QgYXQ6XG4gKiAgIGh0dHBzOi8vZ2l0aHViLmNvbS9EYXNoLUluZHVzdHJ5LUZvcnVtL2Rhc2guanMvYmxvYi9kZXZlbG9wbWVudC9leHRlcm5hbHMvY2VhNjA4LXBhcnNlci5qc1xuICogICBodHRwczovL2dpdGh1Yi5jb20vRGFzaC1JbmR1c3RyeS1Gb3J1bS9kYXNoLmpzL2NvbW1pdC84MjY5YjI2YTc2MWUwODUzYmIyMWQ3ODc4MGVkOTQ1MTQ0ZWNkZDRkI2RpZmYtNzFiYzI5NWEyZDZiNmI3MDkzYTFkMzI5MGQ1M2E0YjJcbiAqXG4gKiBUaGUgb3JpZ2luYWwgY29weXJpZ2h0IGFwcGVhcnMgYmVsb3c6XG4gKlxuICogVGhlIGNvcHlyaWdodCBpbiB0aGlzIHNvZnR3YXJlIGlzIGJlaW5nIG1hZGUgYXZhaWxhYmxlIHVuZGVyIHRoZSBCU0QgTGljZW5zZSxcbiAqIGluY2x1ZGVkIGJlbG93LiBUaGlzIHNvZnR3YXJlIG1heSBiZSBzdWJqZWN0IHRvIG90aGVyIHRoaXJkIHBhcnR5IGFuZCBjb250cmlidXRvclxuICogcmlnaHRzLCBpbmNsdWRpbmcgcGF0ZW50IHJpZ2h0cywgYW5kIG5vIHN1Y2ggcmlnaHRzIGFyZSBncmFudGVkIHVuZGVyIHRoaXMgbGljZW5zZS5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUtMjAxNiwgREFTSCBJbmR1c3RyeSBGb3J1bS5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0IG1vZGlmaWNhdGlvbixcbiAqIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcbiAqICAxLiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsIHRoaXNcbiAqICBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAqICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcbiAqICB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vclxuICogIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG4gKiAgMi4gTmVpdGhlciB0aGUgbmFtZSBvZiBEYXNoIEluZHVzdHJ5IEZvcnVtIG5vciB0aGUgbmFtZXMgb2YgaXRzXG4gKiAgY29udHJpYnV0b3JzIG1heSBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb20gdGhpcyBzb2Z0d2FyZVxuICogIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuICpcbiAqICBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIEFTIElTIEFORCBBTllcbiAqICBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEXG4gKiAgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELlxuICogIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgSE9MREVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsXG4gKiAgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVFxuICogIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1JcbiAqICBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSxcbiAqICBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpXG4gKiAgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEVcbiAqICBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAqL1xuICAgIC8qKlxuICAgICAqICBFeGNlcHRpb25zIGZyb20gcmVndWxhciBBU0NJSS4gQ29kZVBvaW50cyBhcmUgbWFwcGVkIHRvIFVURi0xNiBjb2Rlc1xuICAgICAqL1xuXG52YXIgc3BlY2lhbENlYTYwOENoYXJzQ29kZXMgPSB7XG4gICAgMHgyYSA6IDB4ZTEsIC8vIGxvd2VyY2FzZSBhLCBhY3V0ZSBhY2NlbnRcbiAgICAweDVjIDogMHhlOSwgLy8gbG93ZXJjYXNlIGUsIGFjdXRlIGFjY2VudFxuICAgIDB4NWUgOiAweGVkLCAvLyBsb3dlcmNhc2UgaSwgYWN1dGUgYWNjZW50XG4gICAgMHg1ZiA6IDB4ZjMsIC8vIGxvd2VyY2FzZSBvLCBhY3V0ZSBhY2NlbnRcbiAgICAweDYwIDogMHhmYSwgLy8gbG93ZXJjYXNlIHUsIGFjdXRlIGFjY2VudFxuICAgIDB4N2IgOiAweGU3LCAvLyBsb3dlcmNhc2UgYyB3aXRoIGNlZGlsbGFcbiAgICAweDdjIDogMHhmNywgLy8gZGl2aXNpb24gc3ltYm9sXG4gICAgMHg3ZCA6IDB4ZDEsIC8vIHVwcGVyY2FzZSBOIHRpbGRlXG4gICAgMHg3ZSA6IDB4ZjEsIC8vIGxvd2VyY2FzZSBuIHRpbGRlXG4gICAgMHg3ZiA6IDB4MjU4OCwgLy8gRnVsbCBibG9ja1xuICAgIC8vIFRISVMgQkxPQ0sgSU5DTFVERVMgVEhFIDE2IEVYVEVOREVEIChUV08tQllURSkgTElORSAyMSBDSEFSQUNURVJTXG4gICAgLy8gVEhBVCBDT01FIEZST00gSEkgQllURT0weDExIEFORCBMT1cgQkVUV0VFTiAweDMwIEFORCAweDNGXG4gICAgLy8gVEhJUyBNRUFOUyBUSEFUIFxceDUwIE1VU1QgQkUgQURERUQgVE8gVEhFIFZBTFVFU1xuICAgIDB4ODAgOiAweGFlLCAvLyBSZWdpc3RlcmVkIHN5bWJvbCAoUilcbiAgICAweDgxIDogMHhiMCwgLy8gZGVncmVlIHNpZ25cbiAgICAweDgyIDogMHhiZCwgLy8gMS8yIHN5bWJvbFxuICAgIDB4ODMgOiAweGJmLCAvLyBJbnZlcnRlZCAob3BlbikgcXVlc3Rpb24gbWFya1xuICAgIDB4ODQgOiAweDIxMjIsIC8vIFRyYWRlbWFyayBzeW1ib2wgKFRNKVxuICAgIDB4ODUgOiAweGEyLCAvLyBDZW50cyBzeW1ib2xcbiAgICAweDg2IDogMHhhMywgLy8gUG91bmRzIHN0ZXJsaW5nXG4gICAgMHg4NyA6IDB4MjY2YSwgLy8gTXVzaWMgOCd0aCBub3RlXG4gICAgMHg4OCA6IDB4ZTAsIC8vIGxvd2VyY2FzZSBhLCBncmF2ZSBhY2NlbnRcbiAgICAweDg5IDogMHgyMCwgLy8gdHJhbnNwYXJlbnQgc3BhY2UgKHJlZ3VsYXIpXG4gICAgMHg4YSA6IDB4ZTgsIC8vIGxvd2VyY2FzZSBlLCBncmF2ZSBhY2NlbnRcbiAgICAweDhiIDogMHhlMiwgLy8gbG93ZXJjYXNlIGEsIGNpcmN1bWZsZXggYWNjZW50XG4gICAgMHg4YyA6IDB4ZWEsIC8vIGxvd2VyY2FzZSBlLCBjaXJjdW1mbGV4IGFjY2VudFxuICAgIDB4OGQgOiAweGVlLCAvLyBsb3dlcmNhc2UgaSwgY2lyY3VtZmxleCBhY2NlbnRcbiAgICAweDhlIDogMHhmNCwgLy8gbG93ZXJjYXNlIG8sIGNpcmN1bWZsZXggYWNjZW50XG4gICAgMHg4ZiA6IDB4ZmIsIC8vIGxvd2VyY2FzZSB1LCBjaXJjdW1mbGV4IGFjY2VudFxuICAgIC8vIFRISVMgQkxPQ0sgSU5DTFVERVMgVEhFIDMyIEVYVEVOREVEIChUV08tQllURSkgTElORSAyMSBDSEFSQUNURVJTXG4gICAgLy8gVEhBVCBDT01FIEZST00gSEkgQllURT0weDEyIEFORCBMT1cgQkVUV0VFTiAweDIwIEFORCAweDNGXG4gICAgMHg5MCA6IDB4YzEsIC8vIGNhcGl0YWwgbGV0dGVyIEEgd2l0aCBhY3V0ZVxuICAgIDB4OTEgOiAweGM5LCAvLyBjYXBpdGFsIGxldHRlciBFIHdpdGggYWN1dGVcbiAgICAweDkyIDogMHhkMywgLy8gY2FwaXRhbCBsZXR0ZXIgTyB3aXRoIGFjdXRlXG4gICAgMHg5MyA6IDB4ZGEsIC8vIGNhcGl0YWwgbGV0dGVyIFUgd2l0aCBhY3V0ZVxuICAgIDB4OTQgOiAweGRjLCAvLyBjYXBpdGFsIGxldHRlciBVIHdpdGggZGlhcmVzaXNcbiAgICAweDk1IDogMHhmYywgLy8gbG93ZXJjYXNlIGxldHRlciBVIHdpdGggZGlhZXJlc2lzXG4gICAgMHg5NiA6IDB4MjAxOCwgLy8gb3BlbmluZyBzaW5nbGUgcXVvdGVcbiAgICAweDk3IDogMHhhMSwgLy8gaW52ZXJ0ZWQgZXhjbGFtYXRpb24gbWFya1xuICAgIDB4OTggOiAweDJhLCAvLyBhc3Rlcmlza1xuICAgIDB4OTkgOiAweDIwMTksIC8vIGNsb3Npbmcgc2luZ2xlIHF1b3RlXG4gICAgMHg5YSA6IDB4MjUwMSwgLy8gYm94IGRyYXdpbmdzIGhlYXZ5IGhvcml6b250YWxcbiAgICAweDliIDogMHhhOSwgLy8gY29weXJpZ2h0IHNpZ25cbiAgICAweDljIDogMHgyMTIwLCAvLyBTZXJ2aWNlIG1hcmtcbiAgICAweDlkIDogMHgyMDIyLCAvLyAocm91bmQpIGJ1bGxldFxuICAgIDB4OWUgOiAweDIwMWMsIC8vIExlZnQgZG91YmxlIHF1b3RhdGlvbiBtYXJrXG4gICAgMHg5ZiA6IDB4MjAxZCwgLy8gUmlnaHQgZG91YmxlIHF1b3RhdGlvbiBtYXJrXG4gICAgMHhhMCA6IDB4YzAsIC8vIHVwcGVyY2FzZSBBLCBncmF2ZSBhY2NlbnRcbiAgICAweGExIDogMHhjMiwgLy8gdXBwZXJjYXNlIEEsIGNpcmN1bWZsZXhcbiAgICAweGEyIDogMHhjNywgLy8gdXBwZXJjYXNlIEMgd2l0aCBjZWRpbGxhXG4gICAgMHhhMyA6IDB4YzgsIC8vIHVwcGVyY2FzZSBFLCBncmF2ZSBhY2NlbnRcbiAgICAweGE0IDogMHhjYSwgLy8gdXBwZXJjYXNlIEUsIGNpcmN1bWZsZXhcbiAgICAweGE1IDogMHhjYiwgLy8gY2FwaXRhbCBsZXR0ZXIgRSB3aXRoIGRpYXJlc2lzXG4gICAgMHhhNiA6IDB4ZWIsIC8vIGxvd2VyY2FzZSBsZXR0ZXIgZSB3aXRoIGRpYXJlc2lzXG4gICAgMHhhNyA6IDB4Y2UsIC8vIHVwcGVyY2FzZSBJLCBjaXJjdW1mbGV4XG4gICAgMHhhOCA6IDB4Y2YsIC8vIHVwcGVyY2FzZSBJLCB3aXRoIGRpYXJlc2lzXG4gICAgMHhhOSA6IDB4ZWYsIC8vIGxvd2VyY2FzZSBpLCB3aXRoIGRpYXJlc2lzXG4gICAgMHhhYSA6IDB4ZDQsIC8vIHVwcGVyY2FzZSBPLCBjaXJjdW1mbGV4XG4gICAgMHhhYiA6IDB4ZDksIC8vIHVwcGVyY2FzZSBVLCBncmF2ZSBhY2NlbnRcbiAgICAweGFjIDogMHhmOSwgLy8gbG93ZXJjYXNlIHUsIGdyYXZlIGFjY2VudFxuICAgIDB4YWQgOiAweGRiLCAvLyB1cHBlcmNhc2UgVSwgY2lyY3VtZmxleFxuICAgIDB4YWUgOiAweGFiLCAvLyBsZWZ0LXBvaW50aW5nIGRvdWJsZSBhbmdsZSBxdW90YXRpb24gbWFya1xuICAgIDB4YWYgOiAweGJiLCAvLyByaWdodC1wb2ludGluZyBkb3VibGUgYW5nbGUgcXVvdGF0aW9uIG1hcmtcbiAgICAvLyBUSElTIEJMT0NLIElOQ0xVREVTIFRIRSAzMiBFWFRFTkRFRCAoVFdPLUJZVEUpIExJTkUgMjEgQ0hBUkFDVEVSU1xuICAgIC8vIFRIQVQgQ09NRSBGUk9NIEhJIEJZVEU9MHgxMyBBTkQgTE9XIEJFVFdFRU4gMHgyMCBBTkQgMHgzRlxuICAgIDB4YjAgOiAweGMzLCAvLyBVcHBlcmNhc2UgQSwgdGlsZGVcbiAgICAweGIxIDogMHhlMywgLy8gTG93ZXJjYXNlIGEsIHRpbGRlXG4gICAgMHhiMiA6IDB4Y2QsIC8vIFVwcGVyY2FzZSBJLCBhY3V0ZSBhY2NlbnRcbiAgICAweGIzIDogMHhjYywgLy8gVXBwZXJjYXNlIEksIGdyYXZlIGFjY2VudFxuICAgIDB4YjQgOiAweGVjLCAvLyBMb3dlcmNhc2UgaSwgZ3JhdmUgYWNjZW50XG4gICAgMHhiNSA6IDB4ZDIsIC8vIFVwcGVyY2FzZSBPLCBncmF2ZSBhY2NlbnRcbiAgICAweGI2IDogMHhmMiwgLy8gTG93ZXJjYXNlIG8sIGdyYXZlIGFjY2VudFxuICAgIDB4YjcgOiAweGQ1LCAvLyBVcHBlcmNhc2UgTywgdGlsZGVcbiAgICAweGI4IDogMHhmNSwgLy8gTG93ZXJjYXNlIG8sIHRpbGRlXG4gICAgMHhiOSA6IDB4N2IsIC8vIE9wZW4gY3VybHkgYnJhY2VcbiAgICAweGJhIDogMHg3ZCwgLy8gQ2xvc2luZyBjdXJseSBicmFjZVxuICAgIDB4YmIgOiAweDVjLCAvLyBCYWNrc2xhc2hcbiAgICAweGJjIDogMHg1ZSwgLy8gQ2FyZXRcbiAgICAweGJkIDogMHg1ZiwgLy8gVW5kZXJzY29yZVxuICAgIDB4YmUgOiAweDdjLCAvLyBQaXBlICh2ZXJ0aWNhbCBsaW5lKVxuICAgIDB4YmYgOiAweDIyM2MsIC8vIFRpbGRlIG9wZXJhdG9yXG4gICAgMHhjMCA6IDB4YzQsIC8vIFVwcGVyY2FzZSBBLCB1bWxhdXRcbiAgICAweGMxIDogMHhlNCwgLy8gTG93ZXJjYXNlIEEsIHVtbGF1dFxuICAgIDB4YzIgOiAweGQ2LCAvLyBVcHBlcmNhc2UgTywgdW1sYXV0XG4gICAgMHhjMyA6IDB4ZjYsIC8vIExvd2VyY2FzZSBvLCB1bWxhdXRcbiAgICAweGM0IDogMHhkZiwgLy8gRXNzemV0dCAoc2hhcnAgUylcbiAgICAweGM1IDogMHhhNSwgLy8gWWVuIHN5bWJvbFxuICAgIDB4YzYgOiAweGE0LCAvLyBHZW5lcmljIGN1cnJlbmN5IHNpZ25cbiAgICAweGM3IDogMHgyNTAzLCAvLyBCb3ggZHJhd2luZ3MgaGVhdnkgdmVydGljYWxcbiAgICAweGM4IDogMHhjNSwgLy8gVXBwZXJjYXNlIEEsIHJpbmdcbiAgICAweGM5IDogMHhlNSwgLy8gTG93ZXJjYXNlIEEsIHJpbmdcbiAgICAweGNhIDogMHhkOCwgLy8gVXBwZXJjYXNlIE8sIHN0cm9rZVxuICAgIDB4Y2IgOiAweGY4LCAvLyBMb3dlcmNhc2Ugbywgc3Ryb2tcbiAgICAweGNjIDogMHgyNTBmLCAvLyBCb3ggZHJhd2luZ3MgaGVhdnkgZG93biBhbmQgcmlnaHRcbiAgICAweGNkIDogMHgyNTEzLCAvLyBCb3ggZHJhd2luZ3MgaGVhdnkgZG93biBhbmQgbGVmdFxuICAgIDB4Y2UgOiAweDI1MTcsIC8vIEJveCBkcmF3aW5ncyBoZWF2eSB1cCBhbmQgcmlnaHRcbiAgICAweGNmIDogMHgyNTFiIC8vIEJveCBkcmF3aW5ncyBoZWF2eSB1cCBhbmQgbGVmdFxufTtcblxuLyoqXG4gKiBVdGlsc1xuICovXG52YXIgZ2V0Q2hhckZvckJ5dGUgPSBmdW5jdGlvbihieXRlKSB7XG4gICAgdmFyIGNoYXJDb2RlID0gYnl0ZTtcbiAgICBpZiAoc3BlY2lhbENlYTYwOENoYXJzQ29kZXMuaGFzT3duUHJvcGVydHkoYnl0ZSkpIHtcbiAgICAgICAgY2hhckNvZGUgPSBzcGVjaWFsQ2VhNjA4Q2hhcnNDb2Rlc1tieXRlXTtcbiAgICB9XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY2hhckNvZGUpO1xufTtcblxudmFyIE5SX1JPV1MgPSAxNSxcbiAgICBOUl9DT0xTID0gMzI7XG4vLyBUYWJsZXMgdG8gbG9vayB1cCByb3cgZnJvbSBQQUMgZGF0YVxudmFyIHJvd3NMb3dDaDEgPSB7MHgxMSA6IDEsIDB4MTIgOiAzLCAweDE1IDogNSwgMHgxNiA6IDcsIDB4MTcgOiA5LCAweDEwIDogMTEsIDB4MTMgOiAxMiwgMHgxNCA6IDE0fTtcbnZhciByb3dzSGlnaENoMSA9IHsweDExIDogMiwgMHgxMiA6IDQsIDB4MTUgOiA2LCAweDE2IDogOCwgMHgxNyA6IDEwLCAweDEzIDogMTMsIDB4MTQgOiAxNX07XG52YXIgcm93c0xvd0NoMiA9IHsweDE5IDogMSwgMHgxQSA6IDMsIDB4MUQgOiA1LCAweDFFIDogNywgMHgxRiA6IDksIDB4MTggOiAxMSwgMHgxQiA6IDEyLCAweDFDIDogMTR9O1xudmFyIHJvd3NIaWdoQ2gyID0gezB4MTkgOiAyLCAweDFBIDogNCwgMHgxRCA6IDYsIDB4MUUgOiA4LCAweDFGIDogMTAsIDB4MUIgOiAxMywgMHgxQyA6IDE1fTtcblxudmFyIGJhY2tncm91bmRDb2xvcnMgPSBbJ3doaXRlJywgJ2dyZWVuJywgJ2JsdWUnLCAnY3lhbicsICdyZWQnLCAneWVsbG93JywgJ21hZ2VudGEnLCAnYmxhY2snLCAndHJhbnNwYXJlbnQnXTtcblxuLyoqXG4gKiBTaW1wbGUgbG9nZ2VyIGNsYXNzIHRvIGJlIGFibGUgdG8gd3JpdGUgd2l0aCB0aW1lLXN0YW1wcyBhbmQgZmlsdGVyIG9uIGxldmVsLlxuICovXG52YXIgbG9nZ2VyID0ge1xuICAgIHZlcmJvc2VGaWx0ZXIgOiB7J0RBVEEnIDogMywgJ0RFQlVHJyA6IDMsICdJTkZPJyA6IDIsICdXQVJOSU5HJyA6IDIsICdURVhUJyA6IDEsICdFUlJPUicgOiAwfSxcbiAgICB0aW1lIDogbnVsbCxcbiAgICB2ZXJib3NlTGV2ZWwgOiAwLCAvLyBPbmx5IHdyaXRlIGVycm9yc1xuICAgIHNldFRpbWUgOiBmdW5jdGlvbihuZXdUaW1lKSB7XG4gICAgICAgIHRoaXMudGltZSA9IG5ld1RpbWU7XG4gICAgfSxcbiAgICBsb2cgOiBmdW5jdGlvbihzZXZlcml0eSwgbXNnKSB7XG4gICAgICAgIHZhciBtaW5MZXZlbCA9IHRoaXMudmVyYm9zZUZpbHRlcltzZXZlcml0eV07XG4gICAgICAgIGlmICh0aGlzLnZlcmJvc2VMZXZlbCA+PSBtaW5MZXZlbCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2codGhpcy50aW1lICsgJyBbJyArIHNldmVyaXR5ICsgJ10gJyArIG1zZyk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG52YXIgbnVtQXJyYXlUb0hleEFycmF5ID0gZnVuY3Rpb24obnVtQXJyYXkpIHtcbiAgICB2YXIgaGV4QXJyYXkgPSBbXTtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IG51bUFycmF5Lmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGhleEFycmF5LnB1c2gobnVtQXJyYXlbal0udG9TdHJpbmcoMTYpKTtcbiAgICB9XG4gICAgcmV0dXJuIGhleEFycmF5O1xufTtcblxuY2xhc3MgUGVuU3RhdGUge1xuXG4gICAgY29uc3RydWN0b3IoZm9yZWdyb3VuZCwgdW5kZXJsaW5lLCBpdGFsaWNzLCBiYWNrZ3JvdW5kLCBmbGFzaCkge1xuICAgICAgICB0aGlzLmZvcmVncm91bmQgPSBmb3JlZ3JvdW5kIHx8ICd3aGl0ZSc7XG4gICAgICAgIHRoaXMudW5kZXJsaW5lID0gdW5kZXJsaW5lIHx8IGZhbHNlO1xuICAgICAgICB0aGlzLml0YWxpY3MgPSBpdGFsaWNzIHx8IGZhbHNlO1xuICAgICAgICB0aGlzLmJhY2tncm91bmQgPSBiYWNrZ3JvdW5kIHx8ICdibGFjayc7XG4gICAgICAgIHRoaXMuZmxhc2ggPSBmbGFzaCB8fCBmYWxzZTtcbiAgICB9XG5cbiAgICByZXNldCgpIHtcbiAgICAgICAgdGhpcy5mb3JlZ3JvdW5kID0gJ3doaXRlJztcbiAgICAgICAgdGhpcy51bmRlcmxpbmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pdGFsaWNzID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYmFja2dyb3VuZCA9ICdibGFjayc7XG4gICAgICAgIHRoaXMuZmxhc2ggPSBmYWxzZTtcbiAgICB9XG5cbiAgICBzZXRTdHlsZXMoc3R5bGVzKSB7XG4gICAgICAgIHZhciBhdHRyaWJzID0gWydmb3JlZ3JvdW5kJywgJ3VuZGVybGluZScsICdpdGFsaWNzJywgJ2JhY2tncm91bmQnLCAnZmxhc2gnXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAgOyBpIDwgYXR0cmlicy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHN0eWxlID0gYXR0cmlic1tpXTtcbiAgICAgICAgICAgIGlmIChzdHlsZXMuaGFzT3duUHJvcGVydHkoc3R5bGUpKSB7XG4gICAgICAgICAgICAgICAgdGhpc1tzdHlsZV0gPSBzdHlsZXNbc3R5bGVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaXNEZWZhdWx0KCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuZm9yZWdyb3VuZCA9PT0gJ3doaXRlJyAmJiAhdGhpcy51bmRlcmxpbmUgJiYgIXRoaXMuaXRhbGljcyAmJlxuICAgICAgICAgICAgICAgIHRoaXMuYmFja2dyb3VuZCA9PT0gJ2JsYWNrJyAmJiAhdGhpcy5mbGFzaCk7XG4gICAgfVxuXG4gICAgZXF1YWxzKG90aGVyKSB7XG4gICAgICAgIHJldHVybiAoICh0aGlzLmZvcmVncm91bmQgPT09IG90aGVyLmZvcmVncm91bmQpICYmXG4gICAgICAgICAgICAgICAgICh0aGlzLnVuZGVybGluZSA9PT0gb3RoZXIudW5kZXJsaW5lKSAmJlxuICAgICAgICAgICAgICAgICAodGhpcy5pdGFsaWNzID09PSBvdGhlci5pdGFsaWNzKSAmJlxuICAgICAgICAgICAgICAgICAodGhpcy5iYWNrZ3JvdW5kID09PSBvdGhlci5iYWNrZ3JvdW5kKSAmJlxuICAgICAgICAgICAgICAgICAodGhpcy5mbGFzaCA9PT0gb3RoZXIuZmxhc2gpICk7XG4gICAgfVxuXG4gICAgY29weShuZXdQZW5TdGF0ZSkge1xuICAgICAgICB0aGlzLmZvcmVncm91bmQgPSBuZXdQZW5TdGF0ZS5mb3JlZ3JvdW5kO1xuICAgICAgICB0aGlzLnVuZGVybGluZSA9IG5ld1BlblN0YXRlLnVuZGVybGluZTtcbiAgICAgICAgdGhpcy5pdGFsaWNzID0gbmV3UGVuU3RhdGUuaXRhbGljcztcbiAgICAgICAgdGhpcy5iYWNrZ3JvdW5kID0gbmV3UGVuU3RhdGUuYmFja2dyb3VuZDtcbiAgICAgICAgdGhpcy5mbGFzaCA9IG5ld1BlblN0YXRlLmZsYXNoO1xuICAgIH1cblxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gKCdjb2xvcj0nICsgdGhpcy5mb3JlZ3JvdW5kICsgJywgdW5kZXJsaW5lPScgKyB0aGlzLnVuZGVybGluZSArICcsIGl0YWxpY3M9JyArIHRoaXMuaXRhbGljcyArXG4gICAgICAgICAgICAnLCBiYWNrZ3JvdW5kPScgKyB0aGlzLmJhY2tncm91bmQgKyAnLCBmbGFzaD0nICsgdGhpcy5mbGFzaCk7XG4gICAgfVxufVxuXG4vKipcbiAqIFVuaWNvZGUgY2hhcmFjdGVyIHdpdGggc3R5bGluZyBhbmQgYmFja2dyb3VuZC5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5jbGFzcyBTdHlsZWRVbmljb2RlQ2hhclxue1xuXG4gICAgY29uc3RydWN0b3IodWNoYXIsIGZvcmVncm91bmQsIHVuZGVybGluZSwgaXRhbGljcywgYmFja2dyb3VuZCwgZmxhc2gpIHtcbiAgICAgICAgdGhpcy51Y2hhciA9IHVjaGFyIHx8ICcgJzsgLy8gdW5pY29kZSBjaGFyYWN0ZXJcbiAgICAgICAgdGhpcy5wZW5TdGF0ZSA9IG5ldyBQZW5TdGF0ZShmb3JlZ3JvdW5kLCB1bmRlcmxpbmUsaXRhbGljcywgYmFja2dyb3VuZCwgZmxhc2gpO1xuICAgIH1cblxuICAgIHJlc2V0KCkge1xuICAgICAgICB0aGlzLnVjaGFyID0gJyAnO1xuICAgICAgICB0aGlzLnBlblN0YXRlLnJlc2V0KCk7XG4gICAgfVxuXG4gICAgc2V0Q2hhcih1Y2hhciwgbmV3UGVuU3RhdGUpIHtcbiAgICAgICAgdGhpcy51Y2hhciA9IHVjaGFyO1xuICAgICAgICB0aGlzLnBlblN0YXRlLmNvcHkobmV3UGVuU3RhdGUpO1xuICAgIH1cblxuICAgIHNldFBlblN0YXRlKG5ld1BlblN0YXRlKSB7XG4gICAgICAgIHRoaXMucGVuU3RhdGUuY29weShuZXdQZW5TdGF0ZSk7XG4gICAgfVxuXG4gICAgZXF1YWxzKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnVjaGFyID09PSBvdGhlci51Y2hhciAmJiB0aGlzLnBlblN0YXRlLmVxdWFscyhvdGhlci5wZW5TdGF0ZSk7XG4gICAgfVxuXG4gICAgY29weShuZXdDaGFyKSB7XG4gICAgICAgIHRoaXMudWNoYXIgPSBuZXdDaGFyLnVjaGFyO1xuICAgICAgICB0aGlzLnBlblN0YXRlLmNvcHkobmV3Q2hhci5wZW5TdGF0ZSk7XG4gICAgfVxuXG4gICAgaXNFbXB0eSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudWNoYXIgPT09ICcgJyAmJiB0aGlzLnBlblN0YXRlLmlzRGVmYXVsdCgpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBDRUEtNjA4IHJvdyBjb25zaXN0aW5nIG9mIE5SX0NPTFMgaW5zdGFuY2VzIG9mIFN0eWxlZFVuaWNvZGVDaGFyLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmNsYXNzIFJvdyB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuY2hhcnMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAgOyBpIDwgTlJfQ09MUyA7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5jaGFycy5wdXNoKG5ldyBTdHlsZWRVbmljb2RlQ2hhcigpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgIHRoaXMuY3VyclBlblN0YXRlID0gbmV3IFBlblN0YXRlKCk7XG4gICAgfVxuXG4gICAgZXF1YWxzKG90aGVyKSB7XG4gICAgICAgIHZhciBlcXVhbCA9IHRydWU7XG4gICAgICAgIGZvciAodmFyIGkgPSAwIDsgaSA8IE5SX0NPTFM7IGkgKyspIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5jaGFyc1tpXS5lcXVhbHMob3RoZXIuY2hhcnNbaV0pKSB7XG4gICAgICAgICAgICAgICAgZXF1YWwgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXF1YWw7XG4gICAgfVxuXG4gICAgY29weShvdGhlcikge1xuICAgICAgICBmb3IgKHZhciBpID0gMCA7IGkgPCBOUl9DT0xTOyBpICsrKSB7XG4gICAgICAgICAgICB0aGlzLmNoYXJzW2ldLmNvcHkob3RoZXIuY2hhcnNbaV0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaXNFbXB0eSgpIHtcbiAgICAgICAgdmFyIGVtcHR5ID0gdHJ1ZTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAgOyBpIDwgTlJfQ09MUzsgaSArKykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmNoYXJzW2ldLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgICAgIGVtcHR5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVtcHR5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqICBTZXQgdGhlIGN1cnNvciB0byBhIHZhbGlkIGNvbHVtbi5cbiAgICAgKi9cbiAgICBzZXRDdXJzb3IoYWJzUG9zKSB7XG4gICAgICAgIGlmICh0aGlzLnBvcyAhPT0gYWJzUG9zKSB7XG4gICAgICAgICAgICB0aGlzLnBvcyA9IGFic1BvcztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wb3MgPCAwKSB7XG4gICAgICAgICAgICBsb2dnZXIubG9nKCdFUlJPUicsICdOZWdhdGl2ZSBjdXJzb3IgcG9zaXRpb24gJyArIHRoaXMucG9zKTtcbiAgICAgICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnBvcyA+IE5SX0NPTFMpIHtcbiAgICAgICAgICAgIGxvZ2dlci5sb2coJ0VSUk9SJywgJ1RvbyBsYXJnZSBjdXJzb3IgcG9zaXRpb24gJyArIHRoaXMucG9zKTtcbiAgICAgICAgICAgIHRoaXMucG9zID0gTlJfQ09MUztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1vdmUgdGhlIGN1cnNvciByZWxhdGl2ZSB0byBjdXJyZW50IHBvc2l0aW9uLlxuICAgICAqL1xuICAgIG1vdmVDdXJzb3IocmVsUG9zKSB7XG4gICAgICAgIHZhciBuZXdQb3MgPSB0aGlzLnBvcyArIHJlbFBvcztcbiAgICAgICAgaWYgKHJlbFBvcyA+IDEpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSB0aGlzLnBvcysxOyBpIDwgbmV3UG9zKzEgOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNoYXJzW2ldLnNldFBlblN0YXRlKHRoaXMuY3VyclBlblN0YXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldEN1cnNvcihuZXdQb3MpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEJhY2tzcGFjZSwgbW92ZSBvbmUgc3RlcCBiYWNrIGFuZCBjbGVhciBjaGFyYWN0ZXIuXG4gICAgICovXG4gICAgYmFja1NwYWNlKCkge1xuICAgICAgICB0aGlzLm1vdmVDdXJzb3IoLTEpO1xuICAgICAgICB0aGlzLmNoYXJzW3RoaXMucG9zXS5zZXRDaGFyKCcgJywgdGhpcy5jdXJyUGVuU3RhdGUpO1xuICAgIH1cblxuICAgIGluc2VydENoYXIoYnl0ZSkge1xuICAgICAgICBpZiAoYnl0ZSA+PSAweDkwKSB7IC8vRXh0ZW5kZWQgY2hhclxuICAgICAgICAgICAgdGhpcy5iYWNrU3BhY2UoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2hhciA9IGdldENoYXJGb3JCeXRlKGJ5dGUpO1xuICAgICAgICBpZiAodGhpcy5wb3MgPj0gTlJfQ09MUykge1xuICAgICAgICAgICAgbG9nZ2VyLmxvZygnRVJST1InLCAnQ2Fubm90IGluc2VydCAnICsgYnl0ZS50b1N0cmluZygxNikgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJyAoJyArIGNoYXIgKyAnKSBhdCBwb3NpdGlvbiAnICsgdGhpcy5wb3MgKyAnLiBTa2lwcGluZyBpdCEnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNoYXJzW3RoaXMucG9zXS5zZXRDaGFyKGNoYXIsIHRoaXMuY3VyclBlblN0YXRlKTtcbiAgICAgICAgdGhpcy5tb3ZlQ3Vyc29yKDEpO1xuICAgIH1cblxuICAgIGNsZWFyRnJvbVBvcyhzdGFydFBvcykge1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgZm9yIChpID0gc3RhcnRQb3MgOyBpIDwgTlJfQ09MUyA7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5jaGFyc1tpXS5yZXNldCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY2xlYXIoKSB7XG4gICAgICAgIHRoaXMuY2xlYXJGcm9tUG9zKDApO1xuICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgIHRoaXMuY3VyclBlblN0YXRlLnJlc2V0KCk7XG4gICAgfVxuXG4gICAgY2xlYXJUb0VuZE9mUm93KCkge1xuICAgICAgICB0aGlzLmNsZWFyRnJvbVBvcyh0aGlzLnBvcyk7XG4gICAgfVxuXG4gICAgZ2V0VGV4dFN0cmluZygpIHtcbiAgICAgICAgdmFyIGNoYXJzID0gW107XG4gICAgICAgIHZhciBlbXB0eSA9IHRydWU7XG4gICAgICAgIGZvciAodmFyIGkgPSAwIDsgaSA8IE5SX0NPTFMgOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjaGFyID0gdGhpcy5jaGFyc1tpXS51Y2hhcjtcbiAgICAgICAgICAgIGlmIChjaGFyICE9PSAnICcpIHtcbiAgICAgICAgICAgICAgICBlbXB0eSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hhcnMucHVzaChjaGFyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW1wdHkpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBjaGFycy5qb2luKCcnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNldFBlblN0eWxlcyhzdHlsZXMpIHtcbiAgICAgICAgdGhpcy5jdXJyUGVuU3RhdGUuc2V0U3R5bGVzKHN0eWxlcyk7XG4gICAgICAgIHZhciBjdXJyQ2hhciA9IHRoaXMuY2hhcnNbdGhpcy5wb3NdO1xuICAgICAgICBjdXJyQ2hhci5zZXRQZW5TdGF0ZSh0aGlzLmN1cnJQZW5TdGF0ZSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEtlZXAgYSBDRUEtNjA4IHNjcmVlbiBvZiAzMngxNSBzdHlsZWQgY2hhcmFjdGVyc1xuICogQGNvbnN0cnVjdG9yXG4qL1xuY2xhc3MgQ2FwdGlvblNjcmVlbiB7XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5yb3dzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwIDsgaSA8ICBOUl9ST1dTOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMucm93cy5wdXNoKG5ldyBSb3coKSk7IC8vIE5vdGUgdGhhdCB3ZSB1c2UgemVyby1iYXNlZCBudW1iZXJpbmcgKDAtMTQpXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jdXJyUm93ID0gTlJfUk9XUyAtIDE7XG4gICAgICAgIHRoaXMubnJSb2xsVXBSb3dzID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgIH1cblxuICAgIHJlc2V0KCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMCA7IGkgPCBOUl9ST1dTIDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLnJvd3NbaV0uY2xlYXIoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmN1cnJSb3cgPSBOUl9ST1dTIC0gMTtcbiAgICB9XG5cbiAgICBlcXVhbHMob3RoZXIpIHtcbiAgICAgICAgdmFyIGVxdWFsID0gdHJ1ZTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAgOyBpIDwgTlJfUk9XUyA7IGkrKykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnJvd3NbaV0uZXF1YWxzKG90aGVyLnJvd3NbaV0pKSB7XG4gICAgICAgICAgICAgICAgZXF1YWwgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXF1YWw7XG4gICAgfVxuXG4gICAgY29weShvdGhlcikge1xuICAgICAgICBmb3IgKHZhciBpID0gMCA7IGkgPCBOUl9ST1dTIDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLnJvd3NbaV0uY29weShvdGhlci5yb3dzW2ldKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlzRW1wdHkoKSB7XG4gICAgICAgIHZhciBlbXB0eSA9IHRydWU7XG4gICAgICAgIGZvciAodmFyIGkgPSAwIDsgaSA8IE5SX1JPV1MgOyBpKyspIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5yb3dzW2ldLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgICAgIGVtcHR5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVtcHR5O1xuICAgIH1cblxuICAgIGJhY2tTcGFjZSgpIHtcbiAgICAgICAgdmFyIHJvdyA9IHRoaXMucm93c1t0aGlzLmN1cnJSb3ddO1xuICAgICAgICByb3cuYmFja1NwYWNlKCk7XG4gICAgfVxuXG4gICAgY2xlYXJUb0VuZE9mUm93KCkge1xuICAgICAgICB2YXIgcm93ID0gdGhpcy5yb3dzW3RoaXMuY3VyclJvd107XG4gICAgICAgIHJvdy5jbGVhclRvRW5kT2ZSb3coKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnNlcnQgYSBjaGFyYWN0ZXIgKHdpdGhvdXQgc3R5bGluZykgaW4gdGhlIGN1cnJlbnQgcm93LlxuICAgICAqL1xuICAgIGluc2VydENoYXIoY2hhcikge1xuICAgICAgICB2YXIgcm93ID0gdGhpcy5yb3dzW3RoaXMuY3VyclJvd107XG4gICAgICAgIHJvdy5pbnNlcnRDaGFyKGNoYXIpO1xuICAgIH1cblxuICAgIHNldFBlbihzdHlsZXMpIHtcbiAgICAgICAgdmFyIHJvdyA9IHRoaXMucm93c1t0aGlzLmN1cnJSb3ddO1xuICAgICAgICByb3cuc2V0UGVuU3R5bGVzKHN0eWxlcyk7XG4gICAgfVxuXG4gICAgbW92ZUN1cnNvcihyZWxQb3MpIHtcbiAgICAgICAgdmFyIHJvdyA9IHRoaXMucm93c1t0aGlzLmN1cnJSb3ddO1xuICAgICAgICByb3cubW92ZUN1cnNvcihyZWxQb3MpO1xuICAgIH1cblxuICAgIHNldEN1cnNvcihhYnNQb3MpIHtcbiAgICAgICAgbG9nZ2VyLmxvZygnSU5GTycsICdzZXRDdXJzb3I6ICcgKyBhYnNQb3MpO1xuICAgICAgICB2YXIgcm93ID0gdGhpcy5yb3dzW3RoaXMuY3VyclJvd107XG4gICAgICAgIHJvdy5zZXRDdXJzb3IoYWJzUG9zKTtcbiAgICB9XG5cbiAgICBzZXRQQUMocGFjRGF0YSkge1xuICAgICAgICBsb2dnZXIubG9nKCdJTkZPJywgJ3BhY0RhdGEgPSAnICsgSlNPTi5zdHJpbmdpZnkocGFjRGF0YSkpO1xuICAgICAgICB2YXIgbmV3Um93ID0gcGFjRGF0YS5yb3cgLSAxO1xuICAgICAgICBpZiAodGhpcy5uclJvbGxVcFJvd3MgICYmIG5ld1JvdyA8IHRoaXMubnJSb2xsVXBSb3dzIC0gMSkge1xuICAgICAgICAgICAgICAgIG5ld1JvdyA9IHRoaXMubnJSb2xsVXBSb3dzLTE7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jdXJyUm93ID0gbmV3Um93O1xuICAgICAgICB2YXIgcm93ID0gdGhpcy5yb3dzW3RoaXMuY3VyclJvd107XG4gICAgICAgIGlmIChwYWNEYXRhLmluZGVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIGluZGVudCA9IHBhY0RhdGEuaW5kZW50O1xuICAgICAgICAgICAgdmFyIHByZXZQb3MgPSBNYXRoLm1heChpbmRlbnQtMSwgMCk7XG4gICAgICAgICAgICByb3cuc2V0Q3Vyc29yKHBhY0RhdGEuaW5kZW50KTtcbiAgICAgICAgICAgIHBhY0RhdGEuY29sb3IgPSByb3cuY2hhcnNbcHJldlBvc10ucGVuU3RhdGUuZm9yZWdyb3VuZDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3R5bGVzID0ge2ZvcmVncm91bmQgOiBwYWNEYXRhLmNvbG9yLCB1bmRlcmxpbmUgOiBwYWNEYXRhLnVuZGVybGluZSwgaXRhbGljcyA6IHBhY0RhdGEuaXRhbGljcywgYmFja2dyb3VuZCA6ICdibGFjaycsIGZsYXNoIDogZmFsc2V9O1xuICAgICAgICB0aGlzLnNldFBlbihzdHlsZXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCBiYWNrZ3JvdW5kL2V4dHJhIGZvcmVncm91bmQsIGJ1dCBmaXJzdCBkbyBiYWNrX3NwYWNlLCBhbmQgdGhlbiBpbnNlcnQgc3BhY2UgKGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5KS5cbiAgICAgKi9cbiAgICBzZXRCa2dEYXRhKGJrZ0RhdGEpIHtcblxuICAgICAgICBsb2dnZXIubG9nKCdJTkZPJywgJ2JrZ0RhdGEgPSAnICsgSlNPTi5zdHJpbmdpZnkoYmtnRGF0YSkpO1xuICAgICAgICB0aGlzLmJhY2tTcGFjZSgpO1xuICAgICAgICB0aGlzLnNldFBlbihia2dEYXRhKTtcbiAgICAgICAgdGhpcy5pbnNlcnRDaGFyKDB4MjApOyAvL1NwYWNlXG4gICAgfVxuXG4gICAgc2V0Um9sbFVwUm93cyhuclJvd3MpIHtcbiAgICAgICAgdGhpcy5uclJvbGxVcFJvd3MgPSBuclJvd3M7XG4gICAgfVxuXG4gICAgcm9sbFVwKCkge1xuICAgICAgICBpZiAodGhpcy5uclJvbGxVcFJvd3MgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGxvZ2dlci5sb2coJ0RFQlVHJywgJ3JvbGxfdXAgYnV0IG5yUm9sbFVwUm93cyBub3Qgc2V0IHlldCcpO1xuICAgICAgICAgICAgcmV0dXJuOyAvL05vdCBwcm9wZXJseSBzZXR1cFxuICAgICAgICB9XG4gICAgICAgIGxvZ2dlci5sb2coJ1RFWFQnLCB0aGlzLmdldERpc3BsYXlUZXh0KCkpO1xuICAgICAgICB2YXIgdG9wUm93SW5kZXggPSB0aGlzLmN1cnJSb3cgKyAxIC0gdGhpcy5uclJvbGxVcFJvd3M7XG4gICAgICAgIHZhciB0b3BSb3cgPSB0aGlzLnJvd3Muc3BsaWNlKHRvcFJvd0luZGV4LCAxKVswXTtcbiAgICAgICAgdG9wUm93LmNsZWFyKCk7XG4gICAgICAgIHRoaXMucm93cy5zcGxpY2UodGhpcy5jdXJyUm93LCAwLCB0b3BSb3cpO1xuICAgICAgICBsb2dnZXIubG9nKCdJTkZPJywgJ1JvbGxpbmcgdXAnKTtcbiAgICAgICAgLy9sb2dnZXIubG9nKCdURVhUJywgdGhpcy5nZXRfZGlzcGxheV90ZXh0KCkpXG4gICAgfVxuXG4gICAvKipcbiAgICAqIEdldCBhbGwgbm9uLWVtcHR5IHJvd3Mgd2l0aCBhcyB1bmljb2RlIHRleHQuXG4gICAgKi9cbiAgICBnZXREaXNwbGF5VGV4dChhc09uZVJvdykge1xuICAgICAgICBhc09uZVJvdyA9IGFzT25lUm93IHx8IGZhbHNlO1xuICAgICAgICB2YXIgZGlzcGxheVRleHQgPSBbXTtcbiAgICAgICAgdmFyIHRleHQgPSAnJztcbiAgICAgICAgdmFyIHJvd05yID0gLTE7XG4gICAgICAgIGZvciAodmFyIGkgPSAwIDsgaSA8IE5SX1JPV1MgOyBpKyspIHtcbiAgICAgICAgICAgIHZhciByb3dUZXh0ID0gdGhpcy5yb3dzW2ldLmdldFRleHRTdHJpbmcoKTtcbiAgICAgICAgICAgIGlmIChyb3dUZXh0KSB7XG4gICAgICAgICAgICAgICAgcm93TnIgPSBpKzE7XG4gICAgICAgICAgICAgICAgaWYgKGFzT25lUm93KSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXlUZXh0LnB1c2goJ1JvdyAnICsgcm93TnIgKyAnOiBcXCcnICsgcm93VGV4dCArICdcXCcnKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5VGV4dC5wdXNoKHJvd1RleHQudHJpbSgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRpc3BsYXlUZXh0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGlmIChhc09uZVJvdykge1xuICAgICAgICAgICAgICAgIHRleHQgPSAnWycgKyBkaXNwbGF5VGV4dC5qb2luKCcgfCAnKSArICddJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGV4dCA9IGRpc3BsYXlUZXh0LmpvaW4oJ1xcbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cblxuICAgIGdldFRleHRBbmRGb3JtYXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvd3M7XG4gICAgfVxufVxuXG4vL3ZhciBtb2RlcyA9IFsnTU9ERV9ST0xMLVVQJywgJ01PREVfUE9QLU9OJywgJ01PREVfUEFJTlQtT04nLCAnTU9ERV9URVhUJ107XG5cbmNsYXNzIENlYTYwOENoYW5uZWxcbntcbiAgICBjb25zdHJ1Y3RvcihjaGFubmVsTnVtYmVyLCBvdXRwdXRGaWx0ZXIpIHtcblxuICAgICAgICB0aGlzLmNoTnIgPSBjaGFubmVsTnVtYmVyO1xuICAgICAgICB0aGlzLm91dHB1dEZpbHRlciA9IG91dHB1dEZpbHRlcjtcbiAgICAgICAgdGhpcy5tb2RlID0gbnVsbDtcbiAgICAgICAgdGhpcy52ZXJib3NlID0gMDtcbiAgICAgICAgdGhpcy5kaXNwbGF5ZWRNZW1vcnkgPSBuZXcgQ2FwdGlvblNjcmVlbigpO1xuICAgICAgICB0aGlzLm5vbkRpc3BsYXllZE1lbW9yeSA9IG5ldyBDYXB0aW9uU2NyZWVuKCk7XG4gICAgICAgIHRoaXMubGFzdE91dHB1dFNjcmVlbiA9IG5ldyBDYXB0aW9uU2NyZWVuKCk7XG4gICAgICAgIHRoaXMuY3VyclJvbGxVcFJvdyA9IHRoaXMuZGlzcGxheWVkTWVtb3J5LnJvd3NbTlJfUk9XUy0xXTtcbiAgICAgICAgdGhpcy53cml0ZVNjcmVlbiA9IHRoaXMuZGlzcGxheWVkTWVtb3J5O1xuICAgICAgICB0aGlzLm1vZGUgPSBudWxsO1xuICAgICAgICB0aGlzLmN1ZVN0YXJ0VGltZSA9IG51bGw7IC8vIEtlZXBzIHRyYWNrIG9mIHdoZXJlIGEgY3VlIHN0YXJ0ZWQuXG4gICAgfVxuXG4gICAgcmVzZXQoKSB7XG4gICAgICAgIHRoaXMubW9kZSA9IG51bGw7XG4gICAgICAgIHRoaXMuZGlzcGxheWVkTWVtb3J5LnJlc2V0KCk7XG4gICAgICAgIHRoaXMubm9uRGlzcGxheWVkTWVtb3J5LnJlc2V0KCk7XG4gICAgICAgIHRoaXMubGFzdE91dHB1dFNjcmVlbi5yZXNldCgpO1xuICAgICAgICB0aGlzLmN1cnJSb2xsVXBSb3cgPSB0aGlzLmRpc3BsYXllZE1lbW9yeS5yb3dzW05SX1JPV1MtMV07XG4gICAgICAgIHRoaXMud3JpdGVTY3JlZW4gPSB0aGlzLmRpc3BsYXllZE1lbW9yeTtcbiAgICAgICAgdGhpcy5tb2RlID0gbnVsbDtcbiAgICAgICAgdGhpcy5jdWVTdGFydFRpbWUgPSBudWxsO1xuICAgICAgICB0aGlzLmxhc3RDdWVFbmRUaW1lID0gbnVsbDtcbiAgICB9XG5cbiAgICBnZXRIYW5kbGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vdXRwdXRGaWx0ZXI7XG4gICAgfVxuXG4gICAgc2V0SGFuZGxlcihuZXdIYW5kbGVyKSB7XG4gICAgICAgIHRoaXMub3V0cHV0RmlsdGVyID0gbmV3SGFuZGxlcjtcbiAgICB9XG5cbiAgICBzZXRQQUMocGFjRGF0YSkge1xuICAgICAgICB0aGlzLndyaXRlU2NyZWVuLnNldFBBQyhwYWNEYXRhKTtcbiAgICB9XG5cbiAgICBzZXRCa2dEYXRhKGJrZ0RhdGEpIHtcbiAgICAgICAgdGhpcy53cml0ZVNjcmVlbi5zZXRCa2dEYXRhKGJrZ0RhdGEpO1xuICAgIH1cblxuICAgIHNldE1vZGUobmV3TW9kZSkge1xuICAgICAgICBpZiAobmV3TW9kZSA9PT0gdGhpcy5tb2RlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tb2RlID0gbmV3TW9kZTtcbiAgICAgICAgbG9nZ2VyLmxvZygnSU5GTycsICdNT0RFPScgKyBuZXdNb2RlKTtcbiAgICAgICAgaWYgKHRoaXMubW9kZSA9PT0gJ01PREVfUE9QLU9OJykge1xuICAgICAgICAgICAgdGhpcy53cml0ZVNjcmVlbiA9IHRoaXMubm9uRGlzcGxheWVkTWVtb3J5O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy53cml0ZVNjcmVlbiA9IHRoaXMuZGlzcGxheWVkTWVtb3J5O1xuICAgICAgICAgICAgdGhpcy53cml0ZVNjcmVlbi5yZXNldCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm1vZGUgIT09ICdNT0RFX1JPTEwtVVAnKSB7XG4gICAgICAgICAgICB0aGlzLmRpc3BsYXllZE1lbW9yeS5uclJvbGxVcFJvd3MgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5ub25EaXNwbGF5ZWRNZW1vcnkubnJSb2xsVXBSb3dzID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1vZGUgPSBuZXdNb2RlO1xuICAgIH1cblxuICAgIGluc2VydENoYXJzKGNoYXJzKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwIDsgaSA8IGNoYXJzLmxlbmd0aCA7IGkrKykge1xuICAgICAgICAgICAgdGhpcy53cml0ZVNjcmVlbi5pbnNlcnRDaGFyKGNoYXJzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2NyZWVuID0gdGhpcy53cml0ZVNjcmVlbiA9PT0gdGhpcy5kaXNwbGF5ZWRNZW1vcnkgPyAnRElTUCcgOiAnTk9OX0RJU1AnO1xuICAgICAgICBsb2dnZXIubG9nKCdJTkZPJywgc2NyZWVuICsgJzogJyArIHRoaXMud3JpdGVTY3JlZW4uZ2V0RGlzcGxheVRleHQodHJ1ZSkpO1xuICAgICAgICBpZiAodGhpcy5tb2RlID09PSAnTU9ERV9QQUlOVC1PTicgfHwgdGhpcy5tb2RlID09PSAnTU9ERV9ST0xMLVVQJykge1xuICAgICAgICAgICAgbG9nZ2VyLmxvZygnVEVYVCcsICdESVNQTEFZRUQ6ICcgKyB0aGlzLmRpc3BsYXllZE1lbW9yeS5nZXREaXNwbGF5VGV4dCh0cnVlKSk7XG4gICAgICAgICAgICB0aGlzLm91dHB1dERhdGFVcGRhdGUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNjUkNMKCkgeyAvLyBSZXN1bWUgQ2FwdGlvbiBMb2FkaW5nIChzd2l0Y2ggbW9kZSB0byBQb3AgT24pXG4gICAgICAgIGxvZ2dlci5sb2coJ0lORk8nLCAnUkNMIC0gUmVzdW1lIENhcHRpb24gTG9hZGluZycpO1xuICAgICAgICB0aGlzLnNldE1vZGUoJ01PREVfUE9QLU9OJyk7XG4gICAgfVxuXG4gICAgY2NCUygpIHsgLy8gQmFja1NwYWNlXG4gICAgICAgIGxvZ2dlci5sb2coJ0lORk8nLCAnQlMgLSBCYWNrU3BhY2UnKTtcbiAgICAgICAgaWYgKHRoaXMubW9kZSA9PT0gJ01PREVfVEVYVCcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLndyaXRlU2NyZWVuLmJhY2tTcGFjZSgpO1xuICAgICAgICBpZiAodGhpcy53cml0ZVNjcmVlbiA9PT0gdGhpcy5kaXNwbGF5ZWRNZW1vcnkpIHtcbiAgICAgICAgICAgIHRoaXMub3V0cHV0RGF0YVVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY2NBT0YoKSB7IC8vIFJlc2VydmVkIChmb3JtZXJseSBBbGFybSBPZmYpXG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjY0FPTigpIHsgLy8gUmVzZXJ2ZWQgKGZvcm1lcmx5IEFsYXJtIE9uKVxuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY2NERVIoKSB7IC8vIERlbGV0ZSB0byBFbmQgb2YgUm93XG4gICAgICAgIGxvZ2dlci5sb2coJ0lORk8nLCAnREVSLSBEZWxldGUgdG8gRW5kIG9mIFJvdycpO1xuICAgICAgICB0aGlzLndyaXRlU2NyZWVuLmNsZWFyVG9FbmRPZlJvdygpO1xuICAgICAgICB0aGlzLm91dHB1dERhdGFVcGRhdGUoKTtcbiAgICB9XG5cbiAgICBjY1JVKG5yUm93cykgeyAvL1JvbGwtVXAgQ2FwdGlvbnMtMiwzLG9yIDQgUm93c1xuICAgICAgICBsb2dnZXIubG9nKCdJTkZPJywgJ1JVKCcgKyBuclJvd3MgKycpIC0gUm9sbCBVcCcpO1xuICAgICAgICB0aGlzLndyaXRlU2NyZWVuID0gdGhpcy5kaXNwbGF5ZWRNZW1vcnk7XG4gICAgICAgIHRoaXMuc2V0TW9kZSgnTU9ERV9ST0xMLVVQJyk7XG4gICAgICAgIHRoaXMud3JpdGVTY3JlZW4uc2V0Um9sbFVwUm93cyhuclJvd3MpO1xuICAgIH1cblxuICAgIGNjRk9OKCkgeyAvL0ZsYXNoIE9uXG4gICAgICAgIGxvZ2dlci5sb2coJ0lORk8nLCAnRk9OIC0gRmxhc2ggT24nKTtcbiAgICAgICAgdGhpcy53cml0ZVNjcmVlbi5zZXRQZW4oe2ZsYXNoIDogdHJ1ZX0pO1xuICAgIH1cblxuICAgIGNjUkRDKCkgeyAvLyBSZXN1bWUgRGlyZWN0IENhcHRpb25pbmcgKHN3aXRjaCBtb2RlIHRvIFBhaW50T24pXG4gICAgICAgIGxvZ2dlci5sb2coJ0lORk8nLCAnUkRDIC0gUmVzdW1lIERpcmVjdCBDYXB0aW9uaW5nJyk7XG4gICAgICAgIHRoaXMuc2V0TW9kZSgnTU9ERV9QQUlOVC1PTicpO1xuICAgIH1cblxuICAgIGNjVFIoKSB7IC8vIFRleHQgUmVzdGFydCBpbiB0ZXh0IG1vZGUgKG5vdCBzdXBwb3J0ZWQsIGhvd2V2ZXIpXG4gICAgICAgIGxvZ2dlci5sb2coJ0lORk8nLCAnVFInKTtcbiAgICAgICAgdGhpcy5zZXRNb2RlKCdNT0RFX1RFWFQnKTtcbiAgICB9XG5cbiAgICBjY1JURCgpIHsgLy8gUmVzdW1lIFRleHQgRGlzcGxheSBpbiBUZXh0IG1vZGUgKG5vdCBzdXBwb3J0ZWQsIGhvd2V2ZXIpXG4gICAgICAgIGxvZ2dlci5sb2coJ0lORk8nLCAnUlREJyk7XG4gICAgICAgIHRoaXMuc2V0TW9kZSgnTU9ERV9URVhUJyk7XG4gICAgfVxuXG4gICAgY2NFRE0oKSB7IC8vIEVyYXNlIERpc3BsYXllZCBNZW1vcnlcbiAgICAgICAgbG9nZ2VyLmxvZygnSU5GTycsICdFRE0gLSBFcmFzZSBEaXNwbGF5ZWQgTWVtb3J5Jyk7XG4gICAgICAgIHRoaXMuZGlzcGxheWVkTWVtb3J5LnJlc2V0KCk7XG4gICAgICAgIHRoaXMub3V0cHV0RGF0YVVwZGF0ZSgpO1xuICAgIH1cblxuICAgIGNjQ1IoKSB7IC8vIENhcnJpYWdlIFJldHVyblxuICAgICAgICBsb2dnZXIubG9nKCdDUiAtIENhcnJpYWdlIFJldHVybicpO1xuICAgICAgICB0aGlzLndyaXRlU2NyZWVuLnJvbGxVcCgpO1xuICAgICAgICB0aGlzLm91dHB1dERhdGFVcGRhdGUoKTtcbiAgICB9XG5cbiAgICBjY0VOTSgpIHsgLy9FcmFzZSBOb24tRGlzcGxheWVkIE1lbW9yeVxuICAgICAgICBsb2dnZXIubG9nKCdJTkZPJywgJ0VOTSAtIEVyYXNlIE5vbi1kaXNwbGF5ZWQgTWVtb3J5Jyk7XG4gICAgICAgIHRoaXMubm9uRGlzcGxheWVkTWVtb3J5LnJlc2V0KCk7XG4gICAgfVxuXG4gICAgY2NFT0MoKSB7IC8vRW5kIG9mIENhcHRpb24gKEZsaXAgTWVtb3JpZXMpXG4gICAgICAgIGxvZ2dlci5sb2coJ0lORk8nLCAnRU9DIC0gRW5kIE9mIENhcHRpb24nKTtcbiAgICAgICAgaWYgKHRoaXMubW9kZSA9PT0gJ01PREVfUE9QLU9OJykge1xuICAgICAgICAgICAgdmFyIHRtcCA9IHRoaXMuZGlzcGxheWVkTWVtb3J5O1xuICAgICAgICAgICAgdGhpcy5kaXNwbGF5ZWRNZW1vcnkgPSB0aGlzLm5vbkRpc3BsYXllZE1lbW9yeTtcbiAgICAgICAgICAgIHRoaXMubm9uRGlzcGxheWVkTWVtb3J5ID0gdG1wO1xuICAgICAgICAgICAgdGhpcy53cml0ZVNjcmVlbiA9IHRoaXMubm9uRGlzcGxheWVkTWVtb3J5O1xuICAgICAgICAgICAgbG9nZ2VyLmxvZygnVEVYVCcsICdESVNQOiAnICsgdGhpcy5kaXNwbGF5ZWRNZW1vcnkuZ2V0RGlzcGxheVRleHQoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vdXRwdXREYXRhVXBkYXRlKCk7XG4gICAgfVxuXG4gICAgY2NUTyhuckNvbHMpIHsgLy8gVGFiIE9mZnNldCAxLDIsIG9yIDMgY29sdW1uc1xuICAgICAgICBsb2dnZXIubG9nKCdJTkZPJywgJ1RPKCcgKyBuckNvbHMgKyAnKSAtIFRhYiBPZmZzZXQnKTtcbiAgICAgICAgdGhpcy53cml0ZVNjcmVlbi5tb3ZlQ3Vyc29yKG5yQ29scyk7XG4gICAgfVxuXG4gICAgY2NNSURST1coc2Vjb25kQnl0ZSkgeyAvLyBQYXJzZSBNSURST1cgY29tbWFuZFxuICAgICAgICB2YXIgc3R5bGVzID0ge2ZsYXNoIDogZmFsc2V9O1xuICAgICAgICBzdHlsZXMudW5kZXJsaW5lID0gc2Vjb25kQnl0ZSAlIDIgPT09IDE7XG4gICAgICAgIHN0eWxlcy5pdGFsaWNzID0gc2Vjb25kQnl0ZSA+PSAweDJlO1xuICAgICAgICBpZiAoIXN0eWxlcy5pdGFsaWNzKSB7XG4gICAgICAgICAgICB2YXIgY29sb3JJbmRleCA9IE1hdGguZmxvb3Ioc2Vjb25kQnl0ZS8yKSAtIDB4MTA7XG4gICAgICAgICAgICB2YXIgY29sb3JzID0gWyd3aGl0ZScsICdncmVlbicsICdibHVlJywgJ2N5YW4nLCAncmVkJywgJ3llbGxvdycsICdtYWdlbnRhJ107XG4gICAgICAgICAgICBzdHlsZXMuZm9yZWdyb3VuZCA9IGNvbG9yc1tjb2xvckluZGV4XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0eWxlcy5mb3JlZ3JvdW5kID0gJ3doaXRlJztcbiAgICAgICAgfVxuICAgICAgICBsb2dnZXIubG9nKCdJTkZPJywgJ01JRFJPVzogJyArIEpTT04uc3RyaW5naWZ5KHN0eWxlcykpO1xuICAgICAgICB0aGlzLndyaXRlU2NyZWVuLnNldFBlbihzdHlsZXMpO1xuICAgIH1cblxuICAgIG91dHB1dERhdGFVcGRhdGUoKSB7XG4gICAgICAgIHZhciB0ID0gbG9nZ2VyLnRpbWU7XG4gICAgICAgIGlmICh0ID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3V0cHV0RmlsdGVyKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5vdXRwdXRGaWx0ZXIudXBkYXRlRGF0YSkge1xuICAgICAgICAgICAgICAgIHRoaXMub3V0cHV0RmlsdGVyLnVwZGF0ZURhdGEodCwgdGhpcy5kaXNwbGF5ZWRNZW1vcnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY3VlU3RhcnRUaW1lID09PSBudWxsICYmICF0aGlzLmRpc3BsYXllZE1lbW9yeS5pc0VtcHR5KCkpIHsgLy8gU3RhcnQgb2YgYSBuZXcgY3VlXG4gICAgICAgICAgICAgICAgdGhpcy5jdWVTdGFydFRpbWUgPSB0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuZGlzcGxheWVkTWVtb3J5LmVxdWFscyh0aGlzLmxhc3RPdXRwdXRTY3JlZW4pKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm91dHB1dEZpbHRlci5uZXdDdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3V0cHV0RmlsdGVyLm5ld0N1ZSh0aGlzLmN1ZVN0YXJ0VGltZSwgdCwgdGhpcy5sYXN0T3V0cHV0U2NyZWVuKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1ZVN0YXJ0VGltZSA9IHRoaXMuZGlzcGxheWVkTWVtb3J5LmlzRW1wdHkoKSA/IG51bGwgOiB0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubGFzdE91dHB1dFNjcmVlbi5jb3B5KHRoaXMuZGlzcGxheWVkTWVtb3J5KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGN1ZVNwbGl0QXRUaW1lKHQpIHtcbiAgICAgICAgaWYgKHRoaXMub3V0cHV0RmlsdGVyKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuZGlzcGxheWVkTWVtb3J5LmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm91dHB1dEZpbHRlci5uZXdDdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vdXRwdXRGaWx0ZXIubmV3Q3VlKHRoaXMuY3VlU3RhcnRUaW1lLCB0LCB0aGlzLmRpc3BsYXllZE1lbW9yeSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuY3VlU3RhcnRUaW1lID0gdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuY2xhc3MgQ2VhNjA4UGFyc2VyIHtcblxuICAgIGNvbnN0cnVjdG9yKGZpZWxkLCBvdXQxLCBvdXQyKSB7XG4gICAgICAgIHRoaXMuZmllbGQgPSBmaWVsZCB8fCAxO1xuICAgICAgICB0aGlzLm91dHB1dHMgPSBbb3V0MSwgb3V0Ml07XG4gICAgICAgIHRoaXMuY2hhbm5lbHMgPSBbbmV3IENlYTYwOENoYW5uZWwoMSwgb3V0MSksIG5ldyBDZWE2MDhDaGFubmVsKDIsIG91dDIpXTtcbiAgICAgICAgdGhpcy5jdXJyQ2hOciA9IC0xOyAvLyBXaWxsIGJlIDEgb3IgMlxuICAgICAgICB0aGlzLmxhc3RDbWRBID0gbnVsbDsgLy8gRmlyc3QgYnl0ZSBvZiBsYXN0IGNvbW1hbmRcbiAgICAgICAgdGhpcy5sYXN0Q21kQiA9IG51bGw7IC8vIFNlY29uZCBieXRlIG9mIGxhc3QgY29tbWFuZFxuICAgICAgICB0aGlzLmJ1ZmZlcmVkRGF0YSA9IFtdO1xuICAgICAgICB0aGlzLnN0YXJ0VGltZSA9IG51bGw7XG4gICAgICAgIHRoaXMubGFzdFRpbWUgPSBudWxsO1xuICAgICAgICB0aGlzLmRhdGFDb3VudGVycyA9IHsncGFkZGluZycgOiAwLCAnY2hhcicgOiAwLCAnY21kJyA6IDAsICdvdGhlcicgOiAwfTtcbiAgICB9XG5cbiAgICBnZXRIYW5kbGVyKGluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoYW5uZWxzW2luZGV4XS5nZXRIYW5kbGVyKCk7XG4gICAgfVxuXG4gICAgc2V0SGFuZGxlcihpbmRleCwgbmV3SGFuZGxlcikge1xuICAgICAgICB0aGlzLmNoYW5uZWxzW2luZGV4XS5zZXRIYW5kbGVyKG5ld0hhbmRsZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZCBkYXRhIGZvciB0aW1lIHQgaW4gZm9ybXMgb2YgbGlzdCBvZiBieXRlcyAodW5zaWduZWQgaW50cykuIFRoZSBieXRlcyBhcmUgdHJlYXRlZCBhcyBwYWlycy5cbiAgICAgKi9cbiAgICBhZGREYXRhKHQsIGJ5dGVMaXN0KSB7XG4gICAgICAgIHZhciBjbWRGb3VuZCwgYSwgYixcbiAgICAgICAgY2hhcnNGb3VuZCA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMubGFzdFRpbWUgPSB0O1xuICAgICAgICBsb2dnZXIuc2V0VGltZSh0KTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMCA7IGkgPCBieXRlTGlzdC5sZW5ndGggOyBpKz0yKSB7XG4gICAgICAgICAgICBhID0gYnl0ZUxpc3RbaV0gJiAweDdmO1xuICAgICAgICAgICAgYiA9IGJ5dGVMaXN0W2krMV0gJiAweDdmO1xuICAgICAgICAgICAgaWYgKGEgPT09IDAgJiYgYiA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGF0YUNvdW50ZXJzLnBhZGRpbmcgKz0gMjtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmxvZygnREFUQScsICdbJyArIG51bUFycmF5VG9IZXhBcnJheShbYnl0ZUxpc3RbaV0sIGJ5dGVMaXN0W2krMV1dKSArJ10gLT4gKCcgKyBudW1BcnJheVRvSGV4QXJyYXkoW2EsIGJdKSArICcpJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjbWRGb3VuZCA9IHRoaXMucGFyc2VDbWQoYSwgYik7XG4gICAgICAgICAgICBpZiAoIWNtZEZvdW5kKSB7XG4gICAgICAgICAgICAgICAgY21kRm91bmQgPSB0aGlzLnBhcnNlTWlkcm93KGEsIGIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFjbWRGb3VuZCkge1xuICAgICAgICAgICAgICAgIGNtZEZvdW5kID0gdGhpcy5wYXJzZVBBQyhhLCBiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghY21kRm91bmQpIHtcbiAgICAgICAgICAgICAgICBjbWRGb3VuZCA9IHRoaXMucGFyc2VCYWNrZ3JvdW5kQXR0cmlidXRlcyhhLCBiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghY21kRm91bmQpIHtcbiAgICAgICAgICAgICAgICBjaGFyc0ZvdW5kID0gdGhpcy5wYXJzZUNoYXJzKGEsIGIpO1xuICAgICAgICAgICAgICAgIGlmIChjaGFyc0ZvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmN1cnJDaE5yICYmIHRoaXMuY3VyckNoTnIgPj0wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2hhbm5lbCA9IHRoaXMuY2hhbm5lbHNbdGhpcy5jdXJyQ2hOci0xXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5uZWwuaW5zZXJ0Q2hhcnMoY2hhcnNGb3VuZCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIubG9nKCdXQVJOSU5HJywgJ05vIGNoYW5uZWwgZm91bmQgeWV0LiBURVhULU1PREU/Jyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY21kRm91bmQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGFDb3VudGVycy5jbWQgKz0gMjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2hhcnNGb3VuZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGF0YUNvdW50ZXJzLmNoYXIgKz0gMjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhQ291bnRlcnMub3RoZXIgKz0gMjtcbiAgICAgICAgICAgICAgICBsb2dnZXIubG9nKCdXQVJOSU5HJywgJ0NvdWxkblxcJ3QgcGFyc2UgY2xlYW5lZCBkYXRhICcgKyBudW1BcnJheVRvSGV4QXJyYXkoW2EsIGJdKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJyBvcmlnOiAnICsgbnVtQXJyYXlUb0hleEFycmF5KFtieXRlTGlzdFtpXSwgYnl0ZUxpc3RbaSsxXV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhcnNlIENvbW1hbmQuXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59IFRlbGxzIGlmIGEgY29tbWFuZCB3YXMgZm91bmRcbiAgICAgKi9cbiAgICBwYXJzZUNtZChhLCBiKSB7XG4gICAgICAgIHZhciBjaE5yID0gbnVsbDtcblxuICAgICAgICB2YXIgY29uZDEgPSAoYSA9PT0gMHgxNCB8fCBhID09PSAweDFDKSAmJiAoMHgyMCA8PSBiICYmIGIgPD0gMHgyRik7XG4gICAgICAgIHZhciBjb25kMiA9IChhID09PSAweDE3IHx8IGEgPT09IDB4MUYpICYmICgweDIxIDw9IGIgJiYgYiA8PSAweDIzKTtcbiAgICAgICAgaWYgKCEoY29uZDEgfHwgY29uZDIpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYSA9PT0gdGhpcy5sYXN0Q21kQSAmJiBiID09PSB0aGlzLmxhc3RDbWRCKSB7XG4gICAgICAgICAgICB0aGlzLmxhc3RDbWRBID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMubGFzdENtZEIgPSBudWxsOyAvLyBSZXBlYXRlZCBjb21tYW5kcyBhcmUgZHJvcHBlZCAob25jZSlcbiAgICAgICAgICAgIGxvZ2dlci5sb2coJ0RFQlVHJywgJ1JlcGVhdGVkIGNvbW1hbmQgKCcgKyBudW1BcnJheVRvSGV4QXJyYXkoW2EsIGJdKSArICcpIGlzIGRyb3BwZWQnKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGEgPT09IDB4MTQgfHwgYSA9PT0gMHgxNykge1xuICAgICAgICAgICAgY2hOciA9IDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjaE5yID0gMjsgLy8gKGEgPT09IDB4MUMgfHwgYT09PSAweDFmKVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNoYW5uZWwgPSB0aGlzLmNoYW5uZWxzW2NoTnIgLSAxXTtcblxuICAgICAgICBpZiAoYSA9PT0gMHgxNCB8fCBhID09PSAweDFDKSB7XG4gICAgICAgICAgICBpZiAoYiA9PT0gMHgyMCkge1xuICAgICAgICAgICAgICAgIGNoYW5uZWwuY2NSQ0woKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyMSkge1xuICAgICAgICAgICAgICAgIGNoYW5uZWwuY2NCUygpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChiID09PSAweDIyKSB7XG4gICAgICAgICAgICAgICAgY2hhbm5lbC5jY0FPRigpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChiID09PSAweDIzKSB7XG4gICAgICAgICAgICAgICAgY2hhbm5lbC5jY0FPTigpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChiID09PSAweDI0KSB7XG4gICAgICAgICAgICAgICAgY2hhbm5lbC5jY0RFUigpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChiID09PSAweDI1KSB7XG4gICAgICAgICAgICAgICAgY2hhbm5lbC5jY1JVKDIpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChiID09PSAweDI2KSB7XG4gICAgICAgICAgICAgICAgY2hhbm5lbC5jY1JVKDMpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChiID09PSAweDI3KSB7XG4gICAgICAgICAgICAgICAgY2hhbm5lbC5jY1JVKDQpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChiID09PSAweDI4KSB7XG4gICAgICAgICAgICAgICAgY2hhbm5lbC5jY0ZPTigpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChiID09PSAweDI5KSB7XG4gICAgICAgICAgICAgICAgY2hhbm5lbC5jY1JEQygpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChiID09PSAweDJBKSB7XG4gICAgICAgICAgICAgICAgY2hhbm5lbC5jY1RSKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGIgPT09IDB4MkIpIHtcbiAgICAgICAgICAgICAgICBjaGFubmVsLmNjUlREKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGIgPT09IDB4MkMpIHtcbiAgICAgICAgICAgICAgICBjaGFubmVsLmNjRURNKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGIgPT09IDB4MkQpIHtcbiAgICAgICAgICAgICAgICBjaGFubmVsLmNjQ1IoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyRSkge1xuICAgICAgICAgICAgICAgIGNoYW5uZWwuY2NFTk0oKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyRikge1xuICAgICAgICAgICAgICAgIGNoYW5uZWwuY2NFT0MoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHsgLy9hID09IDB4MTcgfHwgYSA9PSAweDFGXG4gICAgICAgICAgICBjaGFubmVsLmNjVE8oYiAtIDB4MjApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGFzdENtZEEgPSBhO1xuICAgICAgICB0aGlzLmxhc3RDbWRCID0gYjtcbiAgICAgICAgdGhpcy5jdXJyQ2hOciA9IGNoTnI7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhcnNlIG1pZHJvdyBzdHlsaW5nIGNvbW1hbmRcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBwYXJzZU1pZHJvdyhhLCBiKSB7XG4gICAgICAgIHZhciBjaE5yID0gbnVsbDtcblxuICAgICAgICBpZiAoICgoYSA9PT0gMHgxMSkgfHwgKGEgPT09IDB4MTkpKSAmJiAweDIwIDw9IGIgJiYgYiA8PSAweDJmKSB7XG4gICAgICAgICAgICBpZiAoYSA9PT0gMHgxMSkge1xuICAgICAgICAgICAgICAgIGNoTnIgPSAxO1xuICAgICAgICAgICAgfSBlbHNlICB7XG4gICAgICAgICAgICAgICAgY2hOciA9IDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2hOciAhPT0gdGhpcy5jdXJyQ2hOcikge1xuICAgICAgICAgICAgICAgIGxvZ2dlci5sb2coJ0VSUk9SJywgJ01pc21hdGNoIGNoYW5uZWwgaW4gbWlkcm93IHBhcnNpbmcnKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgY2hhbm5lbCA9IHRoaXMuY2hhbm5lbHNbY2hOci0xXTtcbiAgICAgICAgICAgIGNoYW5uZWwuY2NNSURST1coYik7XG4gICAgICAgICAgICBsb2dnZXIubG9nKCdERUJVRycsICdNSURST1cgKCcgKyBudW1BcnJheVRvSGV4QXJyYXkoW2EsIGJdKSArICcpJyk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhcnNlIFByZWFibGUgQWNjZXNzIENvZGVzIChUYWJsZSA1MykuXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59IFRlbGxzIGlmIFBBQyBmb3VuZFxuICAgICAqL1xuICAgIHBhcnNlUEFDKGEsIGIpIHtcblxuICAgICAgIHZhciBjaE5yID0gbnVsbDtcbiAgICAgICB2YXIgcm93ID0gbnVsbDtcblxuICAgICAgICB2YXIgY2FzZTEgPSAoKDB4MTEgPD0gYSAgJiYgYSA8PSAweDE3KSB8fCAoMHgxOSA8PSBhICYmIGEgPD0gMHgxRikpICYmICgweDQwIDw9IGIgJiYgYiA8PSAweDdGKTtcbiAgICAgICAgdmFyIGNhc2UyID0gKGEgPT09IDB4MTAgfHwgYSA9PT0gMHgxOCkgJiYgKDB4NDAgPD0gYiAmJiBiIDw9IDB4NUYpO1xuICAgICAgICBpZiAoISAoY2FzZTEgfHwgY2FzZTIpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYSA9PT0gdGhpcy5sYXN0Q21kQSAmJiBiID09PSB0aGlzLmxhc3RDbWRCKSB7XG4gICAgICAgICAgICB0aGlzLmxhc3RDbWRBID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMubGFzdENtZEIgPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7IC8vIFJlcGVhdGVkIGNvbW1hbmRzIGFyZSBkcm9wcGVkIChvbmNlKVxuICAgICAgICB9XG5cbiAgICAgICAgY2hOciA9IChhIDw9IDB4MTcpID8gMSA6IDI7XG5cbiAgICAgICAgaWYgKDB4NDAgPD0gYiAmJiBiIDw9IDB4NUYpIHtcbiAgICAgICAgICAgIHJvdyA9IChjaE5yID09PSAxKSA/IHJvd3NMb3dDaDFbYV0gOiByb3dzTG93Q2gyW2FdO1xuICAgICAgICB9IGVsc2UgeyAvLyAweDYwIDw9IGIgPD0gMHg3RlxuICAgICAgICAgICAgcm93ID0gKGNoTnIgPT09IDEpID8gcm93c0hpZ2hDaDFbYV0gOiByb3dzSGlnaENoMlthXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcGFjRGF0YSA9IHRoaXMuaW50ZXJwcmV0UEFDKHJvdywgYik7XG4gICAgICAgIHZhciBjaGFubmVsID0gdGhpcy5jaGFubmVsc1tjaE5yLTFdO1xuICAgICAgICBjaGFubmVsLnNldFBBQyhwYWNEYXRhKTtcbiAgICAgICAgdGhpcy5sYXN0Q21kQSA9IGE7XG4gICAgICAgIHRoaXMubGFzdENtZEIgPSBiO1xuICAgICAgICB0aGlzLmN1cnJDaE5yID0gY2hOcjtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW50ZXJwcmV0IHRoZSBzZWNvbmQgYnl0ZSBvZiB0aGUgcGFjLCBhbmQgcmV0dXJuIHRoZSBpbmZvcm1hdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBwYWNEYXRhIHdpdGggc3R5bGUgcGFyYW1ldGVycy5cbiAgICAgKi9cbiAgICBpbnRlcnByZXRQQUMocm93LCBieXRlKSB7XG4gICAgICAgIHZhciBwYWNJbmRleCA9IGJ5dGU7XG4gICAgICAgIHZhciBwYWNEYXRhID0ge2NvbG9yIDogbnVsbCwgaXRhbGljcyA6IGZhbHNlLCBpbmRlbnQgOiBudWxsLCB1bmRlcmxpbmUgOiBmYWxzZSwgcm93IDogcm93fTtcblxuICAgICAgICBpZiAoYnl0ZSA+IDB4NUYpIHtcbiAgICAgICAgICAgIHBhY0luZGV4ID0gYnl0ZSAtIDB4NjA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYWNJbmRleCA9IGJ5dGUgLSAweDQwO1xuICAgICAgICB9XG4gICAgICAgIHBhY0RhdGEudW5kZXJsaW5lID0gKHBhY0luZGV4ICYgMSkgPT09IDE7XG4gICAgICAgIGlmIChwYWNJbmRleCA8PSAweGQpIHtcbiAgICAgICAgICAgIHBhY0RhdGEuY29sb3IgPSBbJ3doaXRlJywgJ2dyZWVuJywgJ2JsdWUnLCAnY3lhbicsICdyZWQnLCAneWVsbG93JywgJ21hZ2VudGEnLCAnd2hpdGUnXVtNYXRoLmZsb29yKHBhY0luZGV4LzIpXTtcbiAgICAgICAgfSBlbHNlIGlmIChwYWNJbmRleCA8PSAweGYpIHtcbiAgICAgICAgICAgIHBhY0RhdGEuaXRhbGljcyA9IHRydWU7XG4gICAgICAgICAgICBwYWNEYXRhLmNvbG9yID0gJ3doaXRlJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhY0RhdGEuaW5kZW50ID0gKE1hdGguZmxvb3IoKHBhY0luZGV4LTB4MTApLzIpKSo0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYWNEYXRhOyAvLyBOb3RlIHRoYXQgcm93IGhhcyB6ZXJvIG9mZnNldC4gVGhlIHNwZWMgdXNlcyAxLlxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhcnNlIGNoYXJhY3RlcnMuXG4gICAgICogQHJldHVybnMgQW4gYXJyYXkgd2l0aCAxIHRvIDIgY29kZXMgY29ycmVzcG9uZGluZyB0byBjaGFycywgaWYgZm91bmQuIG51bGwgb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIHBhcnNlQ2hhcnMoYSwgYikge1xuXG4gICAgICAgdmFyICBjaGFubmVsTnIgPSBudWxsLFxuICAgICAgICAgICAgY2hhckNvZGVzID0gbnVsbCxcbiAgICAgICAgICAgIGNoYXJDb2RlMSA9IG51bGw7XG5cbiAgICAgICAgaWYgKGEgPj0gMHgxOSkge1xuICAgICAgICAgICAgY2hhbm5lbE5yID0gMjtcbiAgICAgICAgICAgIGNoYXJDb2RlMSA9IGEgLSA4O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2hhbm5lbE5yID0gMTtcbiAgICAgICAgICAgIGNoYXJDb2RlMSA9IGE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKDB4MTEgPD0gY2hhckNvZGUxICYmIGNoYXJDb2RlMSA8PSAweDEzKSB7XG4gICAgICAgICAgICAvLyBTcGVjaWFsIGNoYXJhY3RlclxuICAgICAgICAgICAgdmFyIG9uZUNvZGUgPSBiO1xuICAgICAgICAgICAgaWYgKGNoYXJDb2RlMSA9PT0gMHgxMSkge1xuICAgICAgICAgICAgICAgIG9uZUNvZGUgPSBiICsgMHg1MDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2hhckNvZGUxID09PSAweDEyKSB7XG4gICAgICAgICAgICAgICAgb25lQ29kZSA9IGIgKyAweDcwO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvbmVDb2RlID0gYiArIDB4OTA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2dnZXIubG9nKCdJTkZPJywgJ1NwZWNpYWwgY2hhciBcXCcnICsgZ2V0Q2hhckZvckJ5dGUob25lQ29kZSkgKyAnXFwnIGluIGNoYW5uZWwgJyArIGNoYW5uZWxOcik7XG4gICAgICAgICAgICBjaGFyQ29kZXMgPSBbb25lQ29kZV07XG4gICAgICAgIH0gZWxzZSBpZiAoMHgyMCA8PSBhICYmIGEgPD0gMHg3Zikge1xuICAgICAgICAgICAgY2hhckNvZGVzID0gKGIgPT09IDApID8gW2FdIDogW2EsIGJdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFyQ29kZXMpIHtcbiAgICAgICAgICAgIHZhciBoZXhDb2RlcyA9IG51bUFycmF5VG9IZXhBcnJheShjaGFyQ29kZXMpO1xuICAgICAgICAgICAgbG9nZ2VyLmxvZygnREVCVUcnLCAnQ2hhciBjb2RlcyA9ICAnICsgaGV4Q29kZXMuam9pbignLCcpKTtcbiAgICAgICAgICAgIHRoaXMubGFzdENtZEEgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5sYXN0Q21kQiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNoYXJDb2RlcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAqIFBhcnNlIGV4dGVuZGVkIGJhY2tncm91bmQgYXR0cmlidXRlcyBhcyB3ZWxsIGFzIG5ldyBmb3JlZ3JvdW5kIGNvbG9yIGJsYWNrLlxuICAgICogQHJldHVybnN7Qm9vbGVhbn0gVGVsbHMgaWYgYmFja2dyb3VuZCBhdHRyaWJ1dGVzIGFyZSBmb3VuZFxuICAgICovXG4gICAgcGFyc2VCYWNrZ3JvdW5kQXR0cmlidXRlcyhhLCBiKSB7XG4gICAgICAgdmFyICBia2dEYXRhLFxuICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICBjaE5yLFxuICAgICAgICAgICAgY2hhbm5lbDtcblxuICAgICAgICB2YXIgY2FzZTEgPSAoYSA9PT0gMHgxMCB8fCBhID09PSAweDE4KSAmJiAoMHgyMCA8PSBiICYmIGIgPD0gMHgyZik7XG4gICAgICAgIHZhciBjYXNlMiA9IChhID09PSAweDE3IHx8IGEgPT09IDB4MWYpICYmICgweDJkIDw9YiAmJiBiIDw9IDB4MmYpO1xuICAgICAgICBpZiAoIShjYXNlMSB8fCBjYXNlMikpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBia2dEYXRhID0ge307XG4gICAgICAgIGlmIChhICA9PT0gMHgxMCB8fCBhID09PSAweDE4KSB7XG4gICAgICAgICAgICBpbmRleCA9IE1hdGguZmxvb3IoKGItMHgyMCkvMik7XG4gICAgICAgICAgICBia2dEYXRhLmJhY2tncm91bmQgPSBiYWNrZ3JvdW5kQ29sb3JzW2luZGV4XTtcbiAgICAgICAgICAgIGlmIChiICUgMiA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGJrZ0RhdGEuYmFja2dyb3VuZCA9IGJrZ0RhdGEuYmFja2dyb3VuZCArICdfc2VtaSc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyZCkge1xuICAgICAgICAgICAgYmtnRGF0YS5iYWNrZ3JvdW5kID0gJ3RyYW5zcGFyZW50JztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJrZ0RhdGEuZm9yZWdyb3VuZCA9ICdibGFjayc7XG4gICAgICAgICAgICBpZiAoYiA9PT0gMHgyZikge1xuICAgICAgICAgICAgICAgIGJrZ0RhdGEudW5kZXJsaW5lID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjaE5yID0gKGEgPCAweDE4KSA/IDEgOiAyO1xuICAgICAgICBjaGFubmVsID0gdGhpcy5jaGFubmVsc1tjaE5yLTFdO1xuICAgICAgICBjaGFubmVsLnNldEJrZ0RhdGEoYmtnRGF0YSk7XG4gICAgICAgIHRoaXMubGFzdENtZEEgPSBudWxsO1xuICAgICAgICB0aGlzLmxhc3RDbWRCID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVzZXQgc3RhdGUgb2YgcGFyc2VyIGFuZCBpdHMgY2hhbm5lbHMuXG4gICAgICovXG4gICAgcmVzZXQoKSB7XG4gICAgICAgIGZvciAodmFyIGk9MCA7IGkgPCB0aGlzLmNoYW5uZWxzLmxlbmd0aCA7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuY2hhbm5lbHNbaV0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5uZWxzW2ldLnJlc2V0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sYXN0Q21kQSA9IG51bGw7XG4gICAgICAgIHRoaXMubGFzdENtZEIgPSBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXIgdGhlIGdlbmVyYXRpb24gb2YgYSBjdWUsIGFuZCB0aGUgc3RhcnQgb2YgYSBuZXcgb25lIGlmIGRpc3BsYXlTY3JlZW5zIGFyZSBub3QgZW1wdHkuXG4gICAgICovXG4gICAgY3VlU3BsaXRBdFRpbWUodCkge1xuICAgICAgICBmb3IgKHZhciBpPTAgOyBpIDwgdGhpcy5jaGFubmVscy5sZW5ndGggOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNoYW5uZWxzW2ldKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGFubmVsc1tpXS5jdWVTcGxpdEF0VGltZSh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ2VhNjA4UGFyc2VyO1xuIiwidmFyIEN1ZXMgPSB7XG5cbiAgbmV3Q3VlOiBmdW5jdGlvbih0cmFjaywgc3RhcnRUaW1lLCBlbmRUaW1lLCBjYXB0aW9uU2NyZWVuKSB7XG4gICAgdmFyIHJvdztcbiAgICB2YXIgY3VlO1xuICAgIHZhciBpbmRlbnRpbmc7XG4gICAgdmFyIGluZGVudDtcbiAgICB2YXIgdGV4dDtcbiAgICB2YXIgVlRUQ3VlID0gd2luZG93LlZUVEN1ZSB8fCB3aW5kb3cuVGV4dFRyYWNrQ3VlO1xuXG4gICAgZm9yICh2YXIgcj0wOyByPGNhcHRpb25TY3JlZW4ucm93cy5sZW5ndGg7IHIrKylcbiAgICB7XG4gICAgICByb3cgPSBjYXB0aW9uU2NyZWVuLnJvd3Nbcl07XG4gICAgICBpbmRlbnRpbmcgPSB0cnVlO1xuICAgICAgaW5kZW50ID0gMDtcbiAgICAgIHRleHQgPSAnJztcblxuICAgICAgaWYgKCFyb3cuaXNFbXB0eSgpKVxuICAgICAge1xuICAgICAgICBmb3IgKHZhciBjPTA7IGM8cm93LmNoYXJzLmxlbmd0aDsgYysrKVxuICAgICAgICB7XG4gICAgICAgICAgaWYgKHJvdy5jaGFyc1tjXS51Y2hhci5tYXRjaCgvXFxzLykgJiYgaW5kZW50aW5nKVxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGluZGVudCsrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlXG4gICAgICAgICAge1xuICAgICAgICAgICAgdGV4dCArPSByb3cuY2hhcnNbY10udWNoYXI7XG4gICAgICAgICAgICBpbmRlbnRpbmcgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY3VlID0gbmV3IFZUVEN1ZShzdGFydFRpbWUsIGVuZFRpbWUsIHRleHQudHJpbSgpKTtcblxuICAgICAgICBpZiAoaW5kZW50ID49IDE2KVxuICAgICAgICB7XG4gICAgICAgICAgaW5kZW50LS07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgaW5kZW50Kys7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBWVFRDdWUubGluZSBnZXQncyBmbGFrZXkgd2hlbiB1c2luZyBjb250cm9scywgc28gbGV0J3Mgbm93IGluY2x1ZGUgbGluZSAxMyYxNFxuICAgICAgICAvLyBhbHNvLCBkcm9wIGxpbmUgMSBzaW5jZSBpdCdzIHRvIGNsb3NlIHRvIHRoZSB0b3BcbiAgICAgICAgaWYgKG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL0ZpcmVmb3hcXC8vKSlcbiAgICAgICAge1xuICAgICAgICAgIGN1ZS5saW5lID0gciArIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgY3VlLmxpbmUgPSAociA+IDcgPyByIC0gMiA6IHIgKyAxKTtcbiAgICAgICAgfVxuICAgICAgICBjdWUuYWxpZ24gPSAnbGVmdCc7XG4gICAgICAgIGN1ZS5wb3NpdGlvbiA9IDEwMCAqIChpbmRlbnQgLyAzMikgKyAobmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvRmlyZWZveFxcLy8pID8gNTAgOiAwKTtcbiAgICAgICAgdHJhY2suYWRkQ3VlKGN1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ3VlcztcbiIsIi8qXG4gKiBjb21wdXRlIGFuIEV4cG9uZW50aWFsIFdlaWdodGVkIG1vdmluZyBhdmVyYWdlXG4gKiAtIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL01vdmluZ19hdmVyYWdlI0V4cG9uZW50aWFsX21vdmluZ19hdmVyYWdlXG4gKiAgLSBoZWF2aWx5IGluc3BpcmVkIGZyb20gc2hha2EtcGxheWVyXG4gKi9cblxuY2xhc3MgRVdNQSB7XG5cbiAvLyAgQWJvdXQgaGFsZiBvZiB0aGUgZXN0aW1hdGVkIHZhbHVlIHdpbGwgYmUgZnJvbSB0aGUgbGFzdCB8aGFsZkxpZmV8IHNhbXBsZXMgYnkgd2VpZ2h0LlxuICBjb25zdHJ1Y3RvcihoYWxmTGlmZSkge1xuICAgIC8vIExhcmdlciB2YWx1ZXMgb2YgYWxwaGEgZXhwaXJlIGhpc3RvcmljYWwgZGF0YSBtb3JlIHNsb3dseS5cbiAgICB0aGlzLmFscGhhXyA9IGhhbGZMaWZlID8gTWF0aC5leHAoTWF0aC5sb2coMC41KSAvIGhhbGZMaWZlKSA6IDA7XG4gICAgdGhpcy5lc3RpbWF0ZV8gPSAwO1xuICAgIHRoaXMudG90YWxXZWlnaHRfID0gMDtcbiAgfVxuXG4gIHNhbXBsZSh3ZWlnaHQsdmFsdWUpIHtcbiAgICB2YXIgYWRqQWxwaGEgPSBNYXRoLnBvdyh0aGlzLmFscGhhXywgd2VpZ2h0KTtcbiAgICB0aGlzLmVzdGltYXRlXyA9IHZhbHVlICogKDEgLSBhZGpBbHBoYSkgKyBhZGpBbHBoYSAqIHRoaXMuZXN0aW1hdGVfO1xuICAgIHRoaXMudG90YWxXZWlnaHRfICs9IHdlaWdodDtcbiAgfVxuXG4gIGdldFRvdGFsV2VpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLnRvdGFsV2VpZ2h0XztcbiAgfVxuXG4gIGdldEVzdGltYXRlKCkge1xuICAgIGlmICh0aGlzLmFscGhhXykge1xuICAgICAgdmFyIHplcm9GYWN0b3IgPSAxIC0gTWF0aC5wb3codGhpcy5hbHBoYV8sIHRoaXMudG90YWxXZWlnaHRfKTtcbiAgICAgIHJldHVybiB0aGlzLmVzdGltYXRlXyAvIHplcm9GYWN0b3I7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmVzdGltYXRlXztcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgRVdNQTtcbiIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbmNvbnN0IGZha2VMb2dnZXIgPSB7XG4gIHRyYWNlOiBub29wLFxuICBkZWJ1Zzogbm9vcCxcbiAgbG9nOiBub29wLFxuICB3YXJuOiBub29wLFxuICBpbmZvOiBub29wLFxuICBlcnJvcjogbm9vcFxufTtcblxubGV0IGV4cG9ydGVkTG9nZ2VyID0gZmFrZUxvZ2dlcjtcblxuLypnbG9iYWxzIHNlbGY6IGZhbHNlICovXG5cbi8vbGV0IGxhc3RDYWxsVGltZTtcbi8vIGZ1bmN0aW9uIGZvcm1hdE1zZ1dpdGhUaW1lSW5mbyh0eXBlLCBtc2cpIHtcbi8vICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbi8vICAgY29uc3QgZGlmZiA9IGxhc3RDYWxsVGltZSA/ICcrJyArIChub3cgLSBsYXN0Q2FsbFRpbWUpIDogJzAnO1xuLy8gICBsYXN0Q2FsbFRpbWUgPSBub3c7XG4vLyAgIG1zZyA9IChuZXcgRGF0ZShub3cpKS50b0lTT1N0cmluZygpICsgJyB8IFsnICsgIHR5cGUgKyAnXSA+ICcgKyBtc2cgKyAnICggJyArIGRpZmYgKyAnIG1zICknO1xuLy8gICByZXR1cm4gbXNnO1xuLy8gfVxuXG5mdW5jdGlvbiBmb3JtYXRNc2codHlwZSwgbXNnKSB7XG4gIG1zZyA9ICdbJyArICB0eXBlICsgJ10gPiAnICsgbXNnO1xuICByZXR1cm4gbXNnO1xufVxuXG5mdW5jdGlvbiBjb25zb2xlUHJpbnRGbih0eXBlKSB7XG4gIGNvbnN0IGZ1bmMgPSBzZWxmLmNvbnNvbGVbdHlwZV07XG4gIGlmIChmdW5jKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKC4uLmFyZ3MpIHtcbiAgICAgIGlmKGFyZ3NbMF0pIHtcbiAgICAgICAgYXJnc1swXSA9IGZvcm1hdE1zZyh0eXBlLCBhcmdzWzBdKTtcbiAgICAgIH1cbiAgICAgIGZ1bmMuYXBwbHkoc2VsZi5jb25zb2xlLCBhcmdzKTtcbiAgICB9O1xuICB9XG4gIHJldHVybiBub29wO1xufVxuXG5mdW5jdGlvbiBleHBvcnRMb2dnZXJGdW5jdGlvbnMoZGVidWdDb25maWcsIC4uLmZ1bmN0aW9ucykge1xuICBmdW5jdGlvbnMuZm9yRWFjaChmdW5jdGlvbih0eXBlKSB7XG4gICAgZXhwb3J0ZWRMb2dnZXJbdHlwZV0gPSBkZWJ1Z0NvbmZpZ1t0eXBlXSA/IGRlYnVnQ29uZmlnW3R5cGVdLmJpbmQoZGVidWdDb25maWcpIDogY29uc29sZVByaW50Rm4odHlwZSk7XG4gIH0pO1xufVxuXG5leHBvcnQgdmFyIGVuYWJsZUxvZ3MgPSBmdW5jdGlvbihkZWJ1Z0NvbmZpZykge1xuICBpZiAoZGVidWdDb25maWcgPT09IHRydWUgfHwgdHlwZW9mIGRlYnVnQ29uZmlnID09PSAnb2JqZWN0Jykge1xuICAgIGV4cG9ydExvZ2dlckZ1bmN0aW9ucyhkZWJ1Z0NvbmZpZyxcbiAgICAgIC8vIFJlbW92ZSBvdXQgZnJvbSBsaXN0IGhlcmUgdG8gaGFyZC1kaXNhYmxlIGEgbG9nLWxldmVsXG4gICAgICAvLyd0cmFjZScsXG4gICAgICAnZGVidWcnLFxuICAgICAgJ2xvZycsXG4gICAgICAnaW5mbycsXG4gICAgICAnd2FybicsXG4gICAgICAnZXJyb3InXG4gICAgKTtcbiAgICAvLyBTb21lIGJyb3dzZXJzIGRvbid0IGFsbG93IHRvIHVzZSBiaW5kIG9uIGNvbnNvbGUgb2JqZWN0IGFueXdheVxuICAgIC8vIGZhbGxiYWNrIHRvIGRlZmF1bHQgaWYgbmVlZGVkXG4gICAgdHJ5IHtcbiAgICAgZXhwb3J0ZWRMb2dnZXIubG9nKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZXhwb3J0ZWRMb2dnZXIgPSBmYWtlTG9nZ2VyO1xuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICBleHBvcnRlZExvZ2dlciA9IGZha2VMb2dnZXI7XG4gIH1cbn07XG5cbmV4cG9ydCB2YXIgbG9nZ2VyID0gZXhwb3J0ZWRMb2dnZXI7XG4iLCJpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiAhQXJyYXlCdWZmZXIucHJvdG90eXBlLnNsaWNlKSB7XG4gIEFycmF5QnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XG4gICAgdmFyIHRoYXQgPSBuZXcgVWludDhBcnJheSh0aGlzKTtcbiAgICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGVuZCA9IHRoYXQubGVuZ3RoO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gbmV3IEFycmF5QnVmZmVyKGVuZCAtIHN0YXJ0KTtcbiAgICB2YXIgcmVzdWx0QXJyYXkgPSBuZXcgVWludDhBcnJheShyZXN1bHQpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzdWx0QXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgIHJlc3VsdEFycmF5W2ldID0gdGhhdFtpICsgc3RhcnRdO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufVxuIiwiLyoqXG4gKiAgVGltZVJhbmdlcyB0byBzdHJpbmcgaGVscGVyXG4gKi9cblxuY2xhc3MgVGltZVJhbmdlcyB7XG4gIHN0YXRpYyB0b1N0cmluZyhyKSB7XG4gICAgdmFyIGxvZyA9ICcnLCBsZW4gPSByLmxlbmd0aDtcbiAgICBmb3IgKHZhciBpPTA7IGk8bGVuOyBpKyspIHtcbiAgICAgIGxvZyArPSAnWycgKyByLnN0YXJ0KGkpICsgJywnICsgci5lbmQoaSkgKyAnXSc7XG4gICAgfVxuICAgIHJldHVybiBsb2c7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgVGltZVJhbmdlcztcbiIsInZhciBVUkxIZWxwZXIgPSB7XG4gIC8vIGJ1aWxkIGFuIGFic29sdXRlIFVSTCBmcm9tIGEgcmVsYXRpdmUgb25lIHVzaW5nIHRoZSBwcm92aWRlZCBiYXNlVVJMXG4gIC8vIGlmIHJlbGF0aXZlVVJMIGlzIGFuIGFic29sdXRlIFVSTCBpdCB3aWxsIGJlIHJldHVybmVkIGFzIGlzLlxuICBidWlsZEFic29sdXRlVVJMOiBmdW5jdGlvbihiYXNlVVJMLCByZWxhdGl2ZVVSTCkge1xuICAgIC8vIHJlbW92ZSBhbnkgcmVtYWluaW5nIHNwYWNlIGFuZCBDUkxGXG4gICAgcmVsYXRpdmVVUkwgPSByZWxhdGl2ZVVSTC50cmltKCk7XG4gICAgaWYgKC9eW2Etel0rOi9pLnRlc3QocmVsYXRpdmVVUkwpKSB7XG4gICAgICAvLyBjb21wbGV0ZSB1cmwsIG5vdCByZWxhdGl2ZVxuICAgICAgcmV0dXJuIHJlbGF0aXZlVVJMO1xuICAgIH1cblxuICAgIHZhciByZWxhdGl2ZVVSTFF1ZXJ5ID0gbnVsbDtcbiAgICB2YXIgcmVsYXRpdmVVUkxIYXNoID0gbnVsbDtcblxuICAgIHZhciByZWxhdGl2ZVVSTEhhc2hTcGxpdCA9IC9eKFteI10qKSguKikkLy5leGVjKHJlbGF0aXZlVVJMKTtcbiAgICBpZiAocmVsYXRpdmVVUkxIYXNoU3BsaXQpIHtcbiAgICAgIHJlbGF0aXZlVVJMSGFzaCA9IHJlbGF0aXZlVVJMSGFzaFNwbGl0WzJdO1xuICAgICAgcmVsYXRpdmVVUkwgPSByZWxhdGl2ZVVSTEhhc2hTcGxpdFsxXTtcbiAgICB9XG4gICAgdmFyIHJlbGF0aXZlVVJMUXVlcnlTcGxpdCA9IC9eKFteXFw/XSopKC4qKSQvLmV4ZWMocmVsYXRpdmVVUkwpO1xuICAgIGlmIChyZWxhdGl2ZVVSTFF1ZXJ5U3BsaXQpIHtcbiAgICAgIHJlbGF0aXZlVVJMUXVlcnkgPSByZWxhdGl2ZVVSTFF1ZXJ5U3BsaXRbMl07XG4gICAgICByZWxhdGl2ZVVSTCA9IHJlbGF0aXZlVVJMUXVlcnlTcGxpdFsxXTtcbiAgICB9XG5cbiAgICB2YXIgYmFzZVVSTEhhc2hTcGxpdCA9IC9eKFteI10qKSguKikkLy5leGVjKGJhc2VVUkwpO1xuICAgIGlmIChiYXNlVVJMSGFzaFNwbGl0KSB7XG4gICAgICBiYXNlVVJMID0gYmFzZVVSTEhhc2hTcGxpdFsxXTtcbiAgICB9XG4gICAgdmFyIGJhc2VVUkxRdWVyeVNwbGl0ID0gL14oW15cXD9dKikoLiopJC8uZXhlYyhiYXNlVVJMKTtcbiAgICBpZiAoYmFzZVVSTFF1ZXJ5U3BsaXQpIHtcbiAgICAgIGJhc2VVUkwgPSBiYXNlVVJMUXVlcnlTcGxpdFsxXTtcbiAgICB9XG5cbiAgICB2YXIgYmFzZVVSTERvbWFpblNwbGl0ID0gL14oKFthLXpdKzopP1xcL1xcL1thLXowLTlcXC5cXC1ffl0rKDpbMC05XSspPyk/KFxcLy4qKSQvaS5leGVjKGJhc2VVUkwpO1xuICAgIGlmICghYmFzZVVSTERvbWFpblNwbGl0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Vycm9yIHRyeWluZyB0byBwYXJzZSBiYXNlIFVSTC4nKTtcbiAgICB9XG4gICAgXG4gICAgLy8gZS5nLiAnaHR0cDonLCAnaHR0cHM6JywgJydcbiAgICB2YXIgYmFzZVVSTFByb3RvY29sID0gYmFzZVVSTERvbWFpblNwbGl0WzJdIHx8ICcnO1xuICAgIC8vIGUuZy4gJ2h0dHA6Ly9leGFtcGxlLmNvbScsICcvL2V4YW1wbGUuY29tJywgJydcbiAgICB2YXIgYmFzZVVSTFByb3RvY29sRG9tYWluID0gYmFzZVVSTERvbWFpblNwbGl0WzFdIHx8ICcnO1xuICAgIC8vIGUuZy4gJy9hL2IvYy9wbGF5bGlzdC5tM3U4J1xuICAgIHZhciBiYXNlVVJMUGF0aCA9IGJhc2VVUkxEb21haW5TcGxpdFs0XTtcblxuICAgIHZhciBidWlsdFVSTCA9IG51bGw7XG4gICAgaWYgKC9eXFwvXFwvLy50ZXN0KHJlbGF0aXZlVVJMKSkge1xuICAgICAgLy8gcmVsYXRpdmUgdXJsIHN0YXJ0cyB3dGggJy8vJyBzbyBjb3B5IHByb3RvY29sICh3aGljaCBtYXkgYmUgJycgaWYgYmFzZVVybCBkaWRuJ3QgcHJvdmlkZSBvbmUpXG4gICAgICBidWlsdFVSTCA9IGJhc2VVUkxQcm90b2NvbCsnLy8nK1VSTEhlbHBlci5idWlsZEFic29sdXRlUGF0aCgnJywgcmVsYXRpdmVVUkwuc3Vic3RyaW5nKDIpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoL15cXC8vLnRlc3QocmVsYXRpdmVVUkwpKSB7XG4gICAgICAvLyByZWxhdGl2ZSB1cmwgc3RhcnRzIHdpdGggJy8nIHNvIHN0YXJ0IGZyb20gcm9vdCBvZiBkb21haW5cbiAgICAgIGJ1aWx0VVJMID0gYmFzZVVSTFByb3RvY29sRG9tYWluKycvJytVUkxIZWxwZXIuYnVpbGRBYnNvbHV0ZVBhdGgoJycsIHJlbGF0aXZlVVJMLnN1YnN0cmluZygxKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgYnVpbHRVUkwgPSBVUkxIZWxwZXIuYnVpbGRBYnNvbHV0ZVBhdGgoYmFzZVVSTFByb3RvY29sRG9tYWluK2Jhc2VVUkxQYXRoLCByZWxhdGl2ZVVSTCk7XG4gICAgfVxuXG4gICAgLy8gcHV0IHRoZSBxdWVyeSBhbmQgaGFzaCBwYXJ0cyBiYWNrXG4gICAgaWYgKHJlbGF0aXZlVVJMUXVlcnkpIHtcbiAgICAgIGJ1aWx0VVJMICs9IHJlbGF0aXZlVVJMUXVlcnk7XG4gICAgfVxuICAgIGlmIChyZWxhdGl2ZVVSTEhhc2gpIHtcbiAgICAgIGJ1aWx0VVJMICs9IHJlbGF0aXZlVVJMSGFzaDtcbiAgICB9XG4gICAgcmV0dXJuIGJ1aWx0VVJMO1xuICB9LFxuXG4gIC8vIGJ1aWxkIGFuIGFic29sdXRlIHBhdGggdXNpbmcgdGhlIHByb3ZpZGVkIGJhc2VQYXRoXG4gIC8vIGFkYXB0ZWQgZnJvbSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvZG9jdW1lbnQvY29va2llI1VzaW5nX3JlbGF0aXZlX1VSTHNfaW5fdGhlX3BhdGhfcGFyYW1ldGVyXG4gIC8vIHRoaXMgZG9lcyBub3QgaGFuZGxlIHRoZSBjYXNlIHdoZXJlIHJlbGF0aXZlUGF0aCBpcyBcIi9cIiBvciBcIi8vXCIuIFRoZXNlIGNhc2VzIHNob3VsZCBiZSBoYW5kbGVkIG91dHNpZGUgdGhpcy5cbiAgYnVpbGRBYnNvbHV0ZVBhdGg6IGZ1bmN0aW9uKGJhc2VQYXRoLCByZWxhdGl2ZVBhdGgpIHtcbiAgICB2YXIgc1JlbFBhdGggPSByZWxhdGl2ZVBhdGg7XG4gICAgdmFyIG5VcExuLCBzRGlyID0gJycsIHNQYXRoID0gYmFzZVBhdGgucmVwbGFjZSgvW15cXC9dKiQvLCBzUmVsUGF0aC5yZXBsYWNlKC8oXFwvfF4pKD86XFwuP1xcLyspKy9nLCAnJDEnKSk7XG4gICAgZm9yICh2YXIgbkVuZCwgblN0YXJ0ID0gMDsgbkVuZCA9IHNQYXRoLmluZGV4T2YoJy8uLi8nLCBuU3RhcnQpLCBuRW5kID4gLTE7IG5TdGFydCA9IG5FbmQgKyBuVXBMbikge1xuICAgICAgblVwTG4gPSAvXlxcLyg/OlxcLlxcLlxcLykqLy5leGVjKHNQYXRoLnNsaWNlKG5FbmQpKVswXS5sZW5ndGg7XG4gICAgICBzRGlyID0gKHNEaXIgKyBzUGF0aC5zdWJzdHJpbmcoblN0YXJ0LCBuRW5kKSkucmVwbGFjZShuZXcgUmVnRXhwKCcoPzpcXFxcXFwvK1teXFxcXFxcL10qKXswLCcgKyAoKG5VcExuIC0gMSkgLyAzKSArICd9JCcpLCAnLycpO1xuICAgIH1cbiAgICByZXR1cm4gc0RpciArIHNQYXRoLnN1YnN0cihuU3RhcnQpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFVSTEhlbHBlcjtcbiIsIi8qKlxuICogWEhSIGJhc2VkIGxvZ2dlclxuKi9cblxuaW1wb3J0IHtsb2dnZXJ9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XG5cbmNsYXNzIFhockxvYWRlciB7XG5cbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgaWYgKGNvbmZpZyAmJiBjb25maWcueGhyU2V0dXApIHtcbiAgICAgIHRoaXMueGhyU2V0dXAgPSBjb25maWcueGhyU2V0dXA7XG4gICAgfVxuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmFib3J0KCk7XG4gICAgdGhpcy5sb2FkZXIgPSBudWxsO1xuICB9XG5cbiAgYWJvcnQoKSB7XG4gICAgdmFyIGxvYWRlciA9IHRoaXMubG9hZGVyO1xuICAgIGlmIChsb2FkZXIgJiYgbG9hZGVyLnJlYWR5U3RhdGUgIT09IDQpIHtcbiAgICAgIHRoaXMuc3RhdHMuYWJvcnRlZCA9IHRydWU7XG4gICAgICBsb2FkZXIuYWJvcnQoKTtcbiAgICB9XG5cbiAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMucmVxdWVzdFRpbWVvdXQpO1xuICAgIHRoaXMucmVxdWVzdFRpbWVvdXQgPSBudWxsO1xuICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGhpcy5yZXRyeVRpbWVvdXQpO1xuICAgIHRoaXMucmV0cnlUaW1lb3V0ID0gbnVsbDtcbiAgfVxuXG4gIGxvYWQoY29udGV4dCwgY29uZmlnLCBjYWxsYmFja3MpIHtcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgIHRoaXMuY2FsbGJhY2tzID0gY2FsbGJhY2tzO1xuICAgIHRoaXMuc3RhdHMgPSB7dHJlcXVlc3Q6IHBlcmZvcm1hbmNlLm5vdygpLCByZXRyeTogMH07XG4gICAgdGhpcy5yZXRyeURlbGF5ID0gY29uZmlnLnJldHJ5RGVsYXk7XG4gICAgdGhpcy5sb2FkSW50ZXJuYWwoKTtcbiAgfVxuXG4gIGxvYWRJbnRlcm5hbCgpIHtcbiAgICB2YXIgeGhyLCBjb250ZXh0ID0gdGhpcy5jb250ZXh0O1xuXG4gICAgaWYgKHR5cGVvZiBYRG9tYWluUmVxdWVzdCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICB4aHIgPSB0aGlzLmxvYWRlciA9IG5ldyBYRG9tYWluUmVxdWVzdCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgeGhyID0gdGhpcy5sb2FkZXIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICB9XG5cbiAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gdGhpcy5yZWFkeXN0YXRlY2hhbmdlLmJpbmQodGhpcyk7XG4gICAgeGhyLm9ucHJvZ3Jlc3MgPSB0aGlzLmxvYWRwcm9ncmVzcy5iaW5kKHRoaXMpO1xuXG4gICAgeGhyLm9wZW4oJ0dFVCcsIGNvbnRleHQudXJsLCB0cnVlKTtcblxuICAgIGlmIChjb250ZXh0LnJhbmdlRW5kKSB7XG4gICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcignUmFuZ2UnLCdieXRlcz0nICsgY29udGV4dC5yYW5nZVN0YXJ0ICsgJy0nICsgKGNvbnRleHQucmFuZ2VFbmQtMSkpO1xuICAgIH1cbiAgICB4aHIucmVzcG9uc2VUeXBlID0gY29udGV4dC5yZXNwb25zZVR5cGU7XG4gICAgbGV0IHN0YXRzID0gdGhpcy5zdGF0cztcbiAgICBzdGF0cy50Zmlyc3QgPSAwO1xuICAgIHN0YXRzLmxvYWRlZCA9IDA7XG4gICAgaWYgKHRoaXMueGhyU2V0dXApIHtcbiAgICAgIHRoaXMueGhyU2V0dXAoeGhyLCBjb250ZXh0LnVybCk7XG4gICAgfVxuICAgIC8vIHNldHVwIHRpbWVvdXQgYmVmb3JlIHdlIHBlcmZvcm0gcmVxdWVzdFxuICAgIHRoaXMucmVxdWVzdFRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dCh0aGlzLmxvYWR0aW1lb3V0LmJpbmQodGhpcyksIHRoaXMuY29uZmlnLnRpbWVvdXQpO1xuICAgIHhoci5zZW5kKCk7XG4gIH1cblxuICByZWFkeXN0YXRlY2hhbmdlKGV2ZW50KSB7XG4gICAgdmFyIHhociA9IGV2ZW50LmN1cnJlbnRUYXJnZXQsXG4gICAgICAgIHJlYWR5U3RhdGUgPSB4aHIucmVhZHlTdGF0ZSxcbiAgICAgICAgc3RhdHMgPSB0aGlzLnN0YXRzLFxuICAgICAgICBjb250ZXh0ID0gdGhpcy5jb250ZXh0LFxuICAgICAgICBjb25maWcgPSB0aGlzLmNvbmZpZztcblxuICAgIC8vIGRvbid0IHByb2NlZWQgaWYgeGhyIGhhcyBiZWVuIGFib3J0ZWRcbiAgICBpZiAoc3RhdHMuYWJvcnRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGluIGFueSBjYXNlIGNsZWFyIHRoZSBjdXJyZW50IHhocnMgdGltZW91dFxuICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGhpcy5yZXF1ZXN0VGltZW91dCk7XG5cbiAgICAvLyBIRUFERVJTX1JFQ0VJVkVEXG4gICAgaWYgKHJlYWR5U3RhdGUgPj0yKSB7XG4gICAgICBpZiAoc3RhdHMudGZpcnN0ID09PSAwKSB7XG4gICAgICAgIHN0YXRzLnRmaXJzdCA9IE1hdGgubWF4KHBlcmZvcm1hbmNlLm5vdygpLCBzdGF0cy50cmVxdWVzdCk7XG4gICAgICAgIC8vIHJlc2V0IHRpbWVvdXQgdG8gdG90YWwgdGltZW91dCBkdXJhdGlvbiBtaW51cyB0aGUgdGltZSBpdCB0b29rIHRvIHJlY2VpdmUgaGVhZGVyc1xuICAgICAgICB0aGlzLnJlcXVlc3RUaW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQodGhpcy5sb2FkdGltZW91dC5iaW5kKHRoaXMpLCBjb25maWcudGltZW91dCAtIChzdGF0cy50Zmlyc3Qtc3RhdHMudHJlcXVlc3QpKTtcbiAgICAgIH1cbiAgICAgIGlmIChyZWFkeVN0YXRlID09PSA0KSB7XG4gICAgICAgIGxldCBzdGF0dXMgPSB4aHIuc3RhdHVzO1xuICAgICAgICAvLyBodHRwIHN0YXR1cyBiZXR3ZWVuIDIwMCB0byAyOTkgYXJlIGFsbCBzdWNjZXNzZnVsXG4gICAgICAgIGlmIChzdGF0dXMgPj0gMjAwICYmIHN0YXR1cyA8IDMwMCkgIHtcbiAgICAgICAgICBzdGF0cy50bG9hZCA9IE1hdGgubWF4KHN0YXRzLnRmaXJzdCxwZXJmb3JtYW5jZS5ub3coKSk7XG4gICAgICAgICAgbGV0IGRhdGEsbGVuO1xuICAgICAgICAgIGlmIChjb250ZXh0LnJlc3BvbnNlVHlwZSA9PT0gJ2FycmF5YnVmZmVyJykge1xuICAgICAgICAgICAgZGF0YSA9IHhoci5yZXNwb25zZTtcbiAgICAgICAgICAgIGxlbiA9IGRhdGEuYnl0ZUxlbmd0aDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGF0YSA9IHhoci5yZXNwb25zZVRleHQ7XG4gICAgICAgICAgICBsZW4gPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3RhdHMubG9hZGVkID0gc3RhdHMudG90YWwgPSBsZW47XG4gICAgICAgICAgbGV0IHJlc3BvbnNlID0geyB1cmwgOiB4aHIucmVzcG9uc2VVUkwsIGRhdGEgOiBkYXRhIH07XG4gICAgICAgICAgdGhpcy5jYWxsYmFja3Mub25TdWNjZXNzKHJlc3BvbnNlLCBzdGF0cywgY29udGV4dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBpZiBtYXggbmIgb2YgcmV0cmllcyByZWFjaGVkIG9yIGlmIGh0dHAgc3RhdHVzIGJldHdlZW4gNDAwIGFuZCA0OTkgKHN1Y2ggZXJyb3IgY2Fubm90IGJlIHJlY292ZXJlZCwgcmV0cnlpbmcgaXMgdXNlbGVzcyksIHJldHVybiBlcnJvclxuICAgICAgICAgIGlmIChzdGF0cy5yZXRyeSA+PSBjb25maWcubWF4UmV0cnkgfHwgKHN0YXR1cyA+PSA0MDAgJiYgc3RhdHVzIDwgNDk5KSkge1xuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGAke3N0YXR1c30gd2hpbGUgbG9hZGluZyAke2NvbnRleHQudXJsfWAgKTtcbiAgICAgICAgICAgIHRoaXMuY2FsbGJhY2tzLm9uRXJyb3IoeyBjb2RlIDogc3RhdHVzLCB0ZXh0IDogeGhyLnN0YXR1c1RleHR9LCBjb250ZXh0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gcmV0cnlcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKGAke3N0YXR1c30gd2hpbGUgbG9hZGluZyAke2NvbnRleHQudXJsfSwgcmV0cnlpbmcgaW4gJHt0aGlzLnJldHJ5RGVsYXl9Li4uYCk7XG4gICAgICAgICAgICAvLyBhYm9ydHMgYW5kIHJlc2V0cyBpbnRlcm5hbCBzdGF0ZVxuICAgICAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgICAgICAgICAvLyBzY2hlZHVsZSByZXRyeVxuICAgICAgICAgICAgdGhpcy5yZXRyeVRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dCh0aGlzLmxvYWRJbnRlcm5hbC5iaW5kKHRoaXMpLCB0aGlzLnJldHJ5RGVsYXkpO1xuICAgICAgICAgICAgLy8gc2V0IGV4cG9uZW50aWFsIGJhY2tvZmZcbiAgICAgICAgICAgIHRoaXMucmV0cnlEZWxheSA9IE1hdGgubWluKDIgKiB0aGlzLnJldHJ5RGVsYXksIGNvbmZpZy5tYXhSZXRyeURlbGF5KTtcbiAgICAgICAgICAgIHN0YXRzLnJldHJ5Kys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgbG9hZHRpbWVvdXQoKSB7XG4gICAgbG9nZ2VyLndhcm4oYHRpbWVvdXQgd2hpbGUgbG9hZGluZyAke3RoaXMuY29udGV4dC51cmx9YCApO1xuICAgIHRoaXMuY2FsbGJhY2tzLm9uVGltZW91dCh0aGlzLnN0YXRzLCB0aGlzLmNvbnRleHQpO1xuICB9XG5cbiAgbG9hZHByb2dyZXNzKGV2ZW50KSB7XG4gICAgdmFyIHN0YXRzID0gdGhpcy5zdGF0cztcbiAgICBzdGF0cy5sb2FkZWQgPSBldmVudC5sb2FkZWQ7XG4gICAgaWYgKGV2ZW50Lmxlbmd0aENvbXB1dGFibGUpIHtcbiAgICAgIHN0YXRzLnRvdGFsID0gZXZlbnQudG90YWw7XG4gICAgfVxuICAgIGxldCBvblByb2dyZXNzID0gdGhpcy5jYWxsYmFja3Mub25Qcm9ncmVzcztcbiAgICBpZiAob25Qcm9ncmVzcykge1xuICAgICAgLy8gbGFzdCBhcmdzIGlzIHRvIHByb3ZpZGUgb24gcHJvZ3Jlc3MgZGF0YVxuICAgICAgb25Qcm9ncmVzcyhzdGF0cywgdGhpcy5jb250ZXh0LCBudWxsKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgWGhyTG9hZGVyO1xuIl19
