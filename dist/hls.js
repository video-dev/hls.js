(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.Hls = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      } else {
        // At least give some kind of context to the user
        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
        err.context = er;
        throw err;
      }
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    args = Array.prototype.slice.call(arguments, 1);
    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else if (listeners) {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.prototype.listenerCount = function(type) {
  if (this._events) {
    var evlistener = this._events[type];

    if (isFunction(evlistener))
      return 1;
    else if (evlistener)
      return evlistener.length;
  }
  return 0;
};

EventEmitter.listenerCount = function(emitter, type) {
  return emitter.listenerCount(type);
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],2:[function(require,module,exports){
/* jshint ignore:start */
(function(root) { 
/* jshint ignore:end */
  var URLToolkit = {
    // build an absolute URL from a relative one using the provided baseURL
    // if relativeURL is an absolute URL it will be returned as is.
    buildAbsoluteURL: function(baseURL, relativeURL) {
      // remove any remaining space and CRLF
      relativeURL = relativeURL.trim();
      if (/^[a-z]+:/i.test(relativeURL)) {
        // complete url, not relative
        return relativeURL;
      }

      var relativeURLQuery = null;
      var relativeURLHash = null;

      var relativeURLHashSplit = /^([^#]*)(.*)$/.exec(relativeURL);
      if (relativeURLHashSplit) {
        relativeURLHash = relativeURLHashSplit[2];
        relativeURL = relativeURLHashSplit[1];
      }
      var relativeURLQuerySplit = /^([^\?]*)(.*)$/.exec(relativeURL);
      if (relativeURLQuerySplit) {
        relativeURLQuery = relativeURLQuerySplit[2];
        relativeURL = relativeURLQuerySplit[1];
      }

      var baseURLHashSplit = /^([^#]*)(.*)$/.exec(baseURL);
      if (baseURLHashSplit) {
        baseURL = baseURLHashSplit[1];
      }
      var baseURLQuerySplit = /^([^\?]*)(.*)$/.exec(baseURL);
      if (baseURLQuerySplit) {
        baseURL = baseURLQuerySplit[1];
      }

      var baseURLDomainSplit = /^(([a-z]+:)?\/\/[a-z0-9\.\-_~]+(:[0-9]+)?)?(\/.*)$/i.exec(baseURL);
      if (!baseURLDomainSplit) {
        throw new Error('Error trying to parse base URL.');
      }
      
      // e.g. 'http:', 'https:', ''
      var baseURLProtocol = baseURLDomainSplit[2] || '';
      // e.g. 'http://example.com', '//example.com', ''
      var baseURLProtocolDomain = baseURLDomainSplit[1] || '';
      // e.g. '/a/b/c/playlist.m3u8'
      var baseURLPath = baseURLDomainSplit[4];

      var builtURL = null;
      if (/^\/\//.test(relativeURL)) {
        // relative url starts wth '//' so copy protocol (which may be '' if baseUrl didn't provide one)
        builtURL = baseURLProtocol+'//'+URLToolkit.buildAbsolutePath('', relativeURL.substring(2));
      }
      else if (/^\//.test(relativeURL)) {
        // relative url starts with '/' so start from root of domain
        builtURL = baseURLProtocolDomain+'/'+URLToolkit.buildAbsolutePath('', relativeURL.substring(1));
      }
      else {
        builtURL = URLToolkit.buildAbsolutePath(baseURLProtocolDomain+baseURLPath, relativeURL);
      }

      // put the query and hash parts back
      if (relativeURLQuery) {
        builtURL += relativeURLQuery;
      }
      if (relativeURLHash) {
        builtURL += relativeURLHash;
      }
      return builtURL;
    },

    // build an absolute path using the provided basePath
    // adapted from https://developer.mozilla.org/en-US/docs/Web/API/document/cookie#Using_relative_URLs_in_the_path_parameter
    // this does not handle the case where relativePath is "/" or "//". These cases should be handled outside this.
    buildAbsolutePath: function(basePath, relativePath) {
      var sRelPath = relativePath;
      var nUpLn, sDir = '', sPath = basePath.replace(/[^\/]*$/, sRelPath.replace(/(\/|^)(?:\.?\/+)+/g, '$1'));
      for (var nEnd, nStart = 0; nEnd = sPath.indexOf('/../', nStart), nEnd > -1; nStart = nEnd + nUpLn) {
        nUpLn = /^\/(?:\.\.\/)*/.exec(sPath.slice(nEnd))[0].length;
        sDir = (sDir + sPath.substring(nStart, nEnd)).replace(new RegExp('(?:\\\/+[^\\\/]*){0,' + ((nUpLn - 1) / 3) + '}$'), '/');
      }
      return sDir + sPath.substr(nStart);
    }
  };

/* jshint ignore:start */
  if(typeof exports === 'object' && typeof module === 'object')
    module.exports = URLToolkit;
  else if(typeof define === 'function' && define.amd)
    define([], function() { return URLToolkit; });
  else if(typeof exports === 'object')
    exports["URLToolkit"] = URLToolkit;
  else
    root["URLToolkit"] = URLToolkit;
})(this);
/* jshint ignore:end */

},{}],3:[function(require,module,exports){
var bundleFn = arguments[3];
var sources = arguments[4];
var cache = arguments[5];

var stringify = JSON.stringify;

module.exports = function (fn, options) {
    var wkey;
    var cacheKeys = Object.keys(cache);

    for (var i = 0, l = cacheKeys.length; i < l; i++) {
        var key = cacheKeys[i];
        var exp = cache[key].exports;
        // Using babel as a transpiler to use esmodule, the export will always
        // be an object with the default export as a property of it. To ensure
        // the existing api and babel esmodule exports are both supported we
        // check for both
        if (exp === fn || exp && exp.default === fn) {
            wkey = key;
            break;
        }
    }

    if (!wkey) {
        wkey = Math.floor(Math.pow(16, 8) * Math.random()).toString(16);
        var wcache = {};
        for (var i = 0, l = cacheKeys.length; i < l; i++) {
            var key = cacheKeys[i];
            wcache[key] = key;
        }
        sources[wkey] = [
            Function(['require','module','exports'], '(' + fn + ')(self)'),
            wcache
        ];
    }
    var skey = Math.floor(Math.pow(16, 8) * Math.random()).toString(16);

    var scache = {}; scache[wkey] = wkey;
    sources[skey] = [
        Function(['require'], (
            // try to call default if defined to also support babel esmodule
            // exports
            'var f = require(' + stringify(wkey) + ');' +
            '(f.default ? f.default : f)(self);'
        )),
        scache
    ];

    var workerSources = {};
    resolveSources(skey);

    function resolveSources(key) {
        workerSources[key] = true;

        for (var depPath in sources[key][1]) {
            var depKey = sources[key][1][depPath];
            if (!workerSources[depKey]) {
                resolveSources(depKey);
            }
        }
    }

    var src = '(' + bundleFn + ')({'
        + Object.keys(workerSources).map(function (key) {
            return stringify(key) + ':['
                + sources[key][0]
                + ',' + stringify(sources[key][1]) + ']'
            ;
        }).join(',')
        + '},{},[' + stringify(skey) + '])'
    ;

    var URL = window.URL || window.webkitURL || window.mozURL || window.msURL;

    var blob = new Blob([src], { type: 'text/javascript' });
    if (options && options.bare) { return blob; }
    var workerUrl = URL.createObjectURL(blob);
    var worker = new Worker(workerUrl);
    worker.objectURL = workerUrl;
    return worker;
};

},{}],4:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _eventHandler = require('../event-handler');

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _bufferHelper = require('../helper/buffer-helper');

var _bufferHelper2 = _interopRequireDefault(_bufferHelper);

var _errors = require('../errors');

var _logger = require('../utils/logger');

var _ewmaBandwidthEstimator = require('./ewma-bandwidth-estimator');

var _ewmaBandwidthEstimator2 = _interopRequireDefault(_ewmaBandwidthEstimator);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * simple ABR Controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *  - compute next level based on last fragment bw heuristics
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *  - implement an abandon rules triggered if we have less than 2 frag buffered and if computed bw shows that we risk buffer stalling
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

var AbrController = function (_EventHandler) {
  _inherits(AbrController, _EventHandler);

  function AbrController(hls) {
    _classCallCheck(this, AbrController);

    var _this = _possibleConstructorReturn(this, (AbrController.__proto__ || Object.getPrototypeOf(AbrController)).call(this, hls, _events2.default.FRAG_LOADING, _events2.default.FRAG_LOADED, _events2.default.FRAG_BUFFERED, _events2.default.ERROR));

    _this.lastLoadedFragLevel = 0;
    _this._autoLevelCapping = -1;
    _this._nextAutoLevel = -1;
    _this.hls = hls;
    _this.onCheck = _this.abandonRulesCheck.bind(_this);
    return _this;
  }

  _createClass(AbrController, [{
    key: 'destroy',
    value: function destroy() {
      this.clearTimer();
      _eventHandler2.default.prototype.destroy.call(this);
    }
  }, {
    key: 'onFragLoading',
    value: function onFragLoading(data) {
      var frag = data.frag;
      if (frag.type === 'main') {
        if (!this.timer) {
          this.timer = setInterval(this.onCheck, 100);
        }
        // lazy init of bw Estimator, rationale is that we use different params for Live/VoD
        // so we need to wait for stream manifest / playlist type to instantiate it.
        if (!this.bwEstimator) {
          var hls = this.hls,
              level = data.frag.level,
              isLive = hls.levels[level].details.live,
              config = hls.config,
              ewmaFast = void 0,
              ewmaSlow = void 0;

          if (isLive) {
            ewmaFast = config.abrEwmaFastLive;
            ewmaSlow = config.abrEwmaSlowLive;
          } else {
            ewmaFast = config.abrEwmaFastVoD;
            ewmaSlow = config.abrEwmaSlowVoD;
          }
          this.bwEstimator = new _ewmaBandwidthEstimator2.default(hls, ewmaSlow, ewmaFast, config.abrEwmaDefaultEstimate);
        }
        this.fragCurrent = frag;
      }
    }
  }, {
    key: 'abandonRulesCheck',
    value: function abandonRulesCheck() {
      /*
        monitor fragment retrieval time...
        we compute expected time of arrival of the complete fragment.
        we compare it to expected time of buffer starvation
      */
      var hls = this.hls,
          v = hls.media,
          frag = this.fragCurrent,
          loader = frag.loader,
          minAutoLevel = this.minAutoLevel;

      // if loader has been destroyed or loading has been aborted, stop timer and return
      if (!loader || loader.stats && loader.stats.aborted) {
        _logger.logger.warn('frag loader destroy or aborted, disarm abandonRules');
        this.clearTimer();
        return;
      }
      var stats = loader.stats;
      /* only monitor frag retrieval time if
      (video not paused OR first fragment being loaded(ready state === HAVE_NOTHING = 0)) AND autoswitching enabled AND not lowest level (=> means that we have several levels) */
      if (v && (!v.paused && v.playbackRate !== 0 || !v.readyState) && frag.autoLevel && frag.level) {
        var requestDelay = performance.now() - stats.trequest,
            playbackRate = Math.abs(v.playbackRate);
        // monitor fragment load progress after half of expected fragment duration,to stabilize bitrate
        if (requestDelay > 500 * frag.duration / playbackRate) {
          var levels = hls.levels,
              loadRate = Math.max(1, stats.bw ? stats.bw / 8 : stats.loaded * 1000 / requestDelay),
              // byte/s; at least 1 byte/s to avoid division by zero
          // compute expected fragment length using frag duration and level bitrate. also ensure that expected len is gte than already loaded size
          expectedLen = stats.total ? stats.total : Math.max(stats.loaded, Math.round(frag.duration * levels[frag.level].bitrate / 8)),
              pos = v.currentTime,
              fragLoadedDelay = (expectedLen - stats.loaded) / loadRate,
              bufferStarvationDelay = (_bufferHelper2.default.bufferInfo(v, pos, hls.config.maxBufferHole).end - pos) / playbackRate;
          // consider emergency switch down only if we have less than 2 frag buffered AND
          // time to finish loading current fragment is bigger than buffer starvation delay
          // ie if we risk buffer starvation if bw does not increase quickly
          if (bufferStarvationDelay < 2 * frag.duration / playbackRate && fragLoadedDelay > bufferStarvationDelay) {
            var fragLevelNextLoadedDelay = void 0,
                nextLoadLevel = void 0;
            // lets iterate through lower level and try to find the biggest one that could avoid rebuffering
            // we start from current level - 1 and we step down , until we find a matching level
            for (nextLoadLevel = frag.level - 1; nextLoadLevel > minAutoLevel; nextLoadLevel--) {
              // compute time to load next fragment at lower level
              // 0.8 : consider only 80% of current bw to be conservative
              // 8 = bits per byte (bps/Bps)
              fragLevelNextLoadedDelay = frag.duration * levels[nextLoadLevel].bitrate / (8 * 0.8 * loadRate);
              if (fragLevelNextLoadedDelay < bufferStarvationDelay) {
                // we found a lower level that be rebuffering free with current estimated bw !
                break;
              }
            }
            // only emergency switch down if it takes less time to load new fragment at lowest level instead
            // of finishing loading current one ...
            if (fragLevelNextLoadedDelay < fragLoadedDelay) {
              _logger.logger.warn('loading too slow, abort fragment loading and switch to level ' + nextLoadLevel + ':fragLoadedDelay[' + nextLoadLevel + ']<fragLoadedDelay[' + (frag.level - 1) + '];bufferStarvationDelay:' + fragLevelNextLoadedDelay.toFixed(1) + '<' + fragLoadedDelay.toFixed(1) + ':' + bufferStarvationDelay.toFixed(1));
              // force next load level in auto mode
              hls.nextLoadLevel = nextLoadLevel;
              // update bw estimate for this fragment before cancelling load (this will help reducing the bw)
              this.bwEstimator.sample(requestDelay, stats.loaded);
              //abort fragment loading
              loader.abort();
              // stop abandon rules timer
              this.clearTimer();
              hls.trigger(_events2.default.FRAG_LOAD_EMERGENCY_ABORTED, { frag: frag, stats: stats });
            }
          }
        }
      }
    }
  }, {
    key: 'onFragLoaded',
    value: function onFragLoaded(data) {
      var frag = data.frag;
      if (frag.type === 'main') {
        // stop monitoring bw once frag loaded
        this.clearTimer();
        // store level id after successful fragment load
        this.lastLoadedFragLevel = frag.level;
        // reset forced auto level value so that next level will be selected
        this._nextAutoLevel = -1;
        // if fragment has been loaded to perform a bitrate test,
        if (data.frag.bitrateTest) {
          var stats = data.stats;
          stats.tparsed = stats.tbuffered = stats.tload;
          this.onFragBuffered(data);
        }
      }
    }
  }, {
    key: 'onFragBuffered',
    value: function onFragBuffered(data) {
      var stats = data.stats,
          frag = data.frag;
      // only update stats on first frag buffering
      // if same frag is loaded multiple times, it might be in browser cache, and loaded quickly
      // and leading to wrong bw estimation
      // on bitrate test, also only update stats once (if tload = tbuffered == on FRAG_LOADED)
      if (stats.aborted !== true && frag.loadCounter === 1 && frag.type === 'main' && (!frag.bitrateTest || stats.tload === stats.tbuffered)) {
        // use tparsed-trequest instead of tbuffered-trequest to compute fragLoadingProcessing; rationale is that  buffer appending only happens once media is attached
        // in case we use config.startFragPrefetch while media is not attached yet, fragment might be parsed while media not attached yet, but it will only be buffered on media attached
        // as a consequence it could happen really late in the process. meaning that appending duration might appears huge ... leading to underestimated throughput estimation
        var fragLoadingProcessingMs = stats.tparsed - stats.trequest;
        _logger.logger.log('latency/loading/parsing/append/kbps:' + Math.round(stats.tfirst - stats.trequest) + '/' + Math.round(stats.tload - stats.tfirst) + '/' + Math.round(stats.tparsed - stats.tload) + '/' + Math.round(stats.tbuffered - stats.tparsed) + '/' + Math.round(8 * stats.loaded / (stats.tbuffered - stats.trequest)));
        this.bwEstimator.sample(fragLoadingProcessingMs, stats.loaded);
        // if fragment has been loaded to perform a bitrate test, (hls.startLevel = -1), store bitrate test delay duration
        if (frag.bitrateTest) {
          this.bitrateTestDelay = fragLoadingProcessingMs / 1000;
        } else {
          this.bitrateTestDelay = 0;
        }
      }
    }
  }, {
    key: 'onError',
    value: function onError(data) {
      // stop timer in case of frag loading error
      switch (data.details) {
        case _errors.ErrorDetails.FRAG_LOAD_ERROR:
        case _errors.ErrorDetails.FRAG_LOAD_TIMEOUT:
          this.clearTimer();
          break;
        default:
          break;
      }
    }
  }, {
    key: 'clearTimer',
    value: function clearTimer() {
      if (this.timer) {
        clearInterval(this.timer);
        this.timer = null;
      }
    }

    /** Return the capping/max level value that could be used by automatic level selection algorithm **/

  }, {
    key: 'findBestLevel',
    value: function findBestLevel(currentLevel, currentFragDuration, currentBw, minAutoLevel, maxAutoLevel, maxFetchDuration, bwFactor, bwUpFactor, levels) {
      for (var i = maxAutoLevel; i >= minAutoLevel; i--) {
        var levelInfo = levels[i],
            levelDetails = levelInfo.details,
            avgDuration = levelDetails ? levelDetails.totalduration / levelDetails.fragments.length : currentFragDuration,
            live = levelDetails ? levelDetails.live : false,
            adjustedbw = void 0;
        // follow algorithm captured from stagefright :
        // https://android.googlesource.com/platform/frameworks/av/+/master/media/libstagefright/httplive/LiveSession.cpp
        // Pick the highest bandwidth stream below or equal to estimated bandwidth.
        // consider only 80% of the available bandwidth, but if we are switching up,
        // be even more conservative (70%) to avoid overestimating and immediately
        // switching back.
        if (i <= currentLevel) {
          adjustedbw = bwFactor * currentBw;
        } else {
          adjustedbw = bwUpFactor * currentBw;
        }
        var bitrate = levels[i].bitrate,
            fetchDuration = bitrate * avgDuration / adjustedbw;

        _logger.logger.trace('level/adjustedbw/bitrate/avgDuration/maxFetchDuration/fetchDuration: ' + i + '/' + Math.round(adjustedbw) + '/' + bitrate + '/' + avgDuration + '/' + maxFetchDuration + '/' + fetchDuration);
        // if adjusted bw is greater than level bitrate AND
        if (adjustedbw > bitrate && (
        // fragment fetchDuration unknown OR live stream OR fragment fetchDuration less than max allowed fetch duration, then this level matches
        // we don't account for max Fetch Duration for live streams, this is to avoid switching down when near the edge of live sliding window ...
        !fetchDuration || live || fetchDuration < maxFetchDuration)) {
          // as we are looping from highest to lowest, this will return the best achievable quality level

          return i;
        }
      }
      // not enough time budget even with quality level 0 ... rebuffering might happen
      return -1;
    }
  }, {
    key: 'autoLevelCapping',
    get: function get() {
      return this._autoLevelCapping;
    }

    /** set the capping/max level value that could be used by automatic level selection algorithm **/
    ,
    set: function set(newLevel) {
      this._autoLevelCapping = newLevel;
    }
  }, {
    key: 'nextAutoLevel',
    get: function get() {
      var nextAutoLevel = this._nextAutoLevel,
          bwEstimator = this.bwEstimator,
          hls = this.hls,
          levels = hls.levels,
          minAutoBitrate = hls.config.minAutoBitrate;
      // in case next auto level has been forced, and bw not available or not reliable
      if (nextAutoLevel !== -1 && (!bwEstimator || !bwEstimator.canEstimate())) {
        // cap next auto level by max auto level
        return Math.min(nextAutoLevel, this.maxAutoLevel);
      }
      // compute next level using ABR logic
      var nextABRAutoLevel = this.nextABRAutoLevel;
      if (nextAutoLevel !== -1) {
        // nextAutoLevel is defined, use it to cap ABR computed quality level
        nextABRAutoLevel = Math.min(nextAutoLevel, nextABRAutoLevel);
      }
      if (minAutoBitrate !== undefined) {
        while (levels[nextABRAutoLevel].bitrate < minAutoBitrate) {
          nextABRAutoLevel++;
        }
      }
      return nextABRAutoLevel;
    },
    set: function set(nextLevel) {
      this._nextAutoLevel = nextLevel;
    }
  }, {
    key: 'minAutoLevel',
    get: function get() {
      var hls = this.hls,
          levels = hls.levels,
          minAutoBitrate = hls.config.minAutoBitrate,
          len = levels ? levels.length : 0;
      for (var i = 0; i < len; i++) {
        if (levels[i].bitrate > minAutoBitrate) {
          return i;
        }
      }
      return 0;
    }
  }, {
    key: 'maxAutoLevel',
    get: function get() {
      var levels = this.hls.levels,
          autoLevelCapping = this._autoLevelCapping,
          maxAutoLevel;
      if (autoLevelCapping === -1 && levels && levels.length) {
        maxAutoLevel = levels.length - 1;
      } else {
        maxAutoLevel = autoLevelCapping;
      }
      return maxAutoLevel;
    }
  }, {
    key: 'nextABRAutoLevel',
    get: function get() {
      var hls = this.hls,
          maxAutoLevel = this.maxAutoLevel,
          levels = hls.levels,
          config = hls.config,
          minAutoLevel = this.minAutoLevel;
      var v = hls.media,
          currentLevel = this.lastLoadedFragLevel,
          currentFragDuration = this.fragCurrent ? this.fragCurrent.duration : 0,
          pos = v ? v.currentTime : 0,

      // playbackRate is the absolute value of the playback rate; if v.playbackRate is 0, we use 1 to load as
      // if we're playing back at the normal rate.
      playbackRate = v && v.playbackRate !== 0 ? Math.abs(v.playbackRate) : 1.0,
          avgbw = this.bwEstimator ? this.bwEstimator.getEstimate() : config.abrEwmaDefaultEstimate,

      // bufferStarvationDelay is the wall-clock time left until the playback buffer is exhausted.
      bufferStarvationDelay = (_bufferHelper2.default.bufferInfo(v, pos, config.maxBufferHole).end - pos) / playbackRate;

      // First, look to see if we can find a level matching with our avg bandwidth AND that could also guarantee no rebuffering at all
      var bestLevel = this.findBestLevel(currentLevel, currentFragDuration, avgbw, minAutoLevel, maxAutoLevel, bufferStarvationDelay, config.abrBandWidthFactor, config.abrBandWidthUpFactor, levels);
      if (bestLevel >= 0) {
        return bestLevel;
      } else {
        _logger.logger.trace('rebuffering expected to happen, lets try to find a quality level minimizing the rebuffering');
        // not possible to get rid of rebuffering ... let's try to find level that will guarantee less than maxStarvationDelay of rebuffering
        // if no matching level found, logic will return 0
        var maxStarvationDelay = config.maxStarvationDelay,
            bwFactor = config.abrBandWidthFactor,
            bwUpFactor = config.abrBandWidthUpFactor;
        if (bufferStarvationDelay === 0) {
          // in case buffer is empty, let's check if previous fragment was loaded to perform a bitrate test
          var bitrateTestDelay = this.bitrateTestDelay;
          if (bitrateTestDelay) {
            // if it is the case, then we need to adjust our max starvation delay using maxLoadingDelay config value
            // max video loading delay used in  automatic start level selection :
            // in that mode ABR controller will ensure that video loading time (ie the time to fetch the first fragment at lowest quality level +
            // the time to fetch the fragment at the appropriate quality level is less than ```maxLoadingDelay``` )
            maxStarvationDelay = config.maxLoadingDelay - bitrateTestDelay;
            _logger.logger.trace('bitrate test took ' + Math.round(1000 * bitrateTestDelay) + 'ms, set first fragment max fetchDuration to ' + Math.round(1000 * maxStarvationDelay) + ' ms');
            // don't use conservative factor on bitrate test
            bwFactor = bwUpFactor = 1;
          }
        }
        bestLevel = this.findBestLevel(currentLevel, currentFragDuration, avgbw, minAutoLevel, maxAutoLevel, bufferStarvationDelay + maxStarvationDelay, bwFactor, bwUpFactor, levels);
        return Math.max(bestLevel, 0);
      }
    }
  }]);

  return AbrController;
}(_eventHandler2.default);

exports.default = AbrController;

},{"../errors":28,"../event-handler":29,"../events":30,"../helper/buffer-helper":32,"../utils/logger":47,"./ewma-bandwidth-estimator":9}],5:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _binarySearch = require('../utils/binary-search');

var _binarySearch2 = _interopRequireDefault(_binarySearch);

var _bufferHelper = require('../helper/buffer-helper');

var _bufferHelper2 = _interopRequireDefault(_bufferHelper);

var _demuxer = require('../demux/demuxer');

var _demuxer2 = _interopRequireDefault(_demuxer);

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _eventHandler = require('../event-handler');

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _levelHelper = require('../helper/level-helper');

var _levelHelper2 = _interopRequireDefault(_levelHelper);

var _timeRanges = require('../utils/timeRanges');

var _timeRanges2 = _interopRequireDefault(_timeRanges);

var _errors = require('../errors');

var _logger = require('../utils/logger');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Audio Stream Controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

var State = {
  STOPPED: 'STOPPED',
  STARTING: 'STARTING',
  IDLE: 'IDLE',
  PAUSED: 'PAUSED',
  KEY_LOADING: 'KEY_LOADING',
  FRAG_LOADING: 'FRAG_LOADING',
  FRAG_LOADING_WAITING_RETRY: 'FRAG_LOADING_WAITING_RETRY',
  WAITING_TRACK: 'WAITING_TRACK',
  PARSING: 'PARSING',
  PARSED: 'PARSED',
  ENDED: 'ENDED',
  ERROR: 'ERROR',
  WAITING_INIT_PTS: 'WAITING_INIT_PTS'
};

var AudioStreamController = function (_EventHandler) {
  _inherits(AudioStreamController, _EventHandler);

  function AudioStreamController(hls) {
    _classCallCheck(this, AudioStreamController);

    var _this = _possibleConstructorReturn(this, (AudioStreamController.__proto__ || Object.getPrototypeOf(AudioStreamController)).call(this, hls, _events2.default.MEDIA_ATTACHED, _events2.default.MEDIA_DETACHING, _events2.default.AUDIO_TRACKS_UPDATED, _events2.default.AUDIO_TRACK_SWITCHING, _events2.default.AUDIO_TRACK_LOADED, _events2.default.KEY_LOADED, _events2.default.FRAG_LOADED, _events2.default.FRAG_PARSING_INIT_SEGMENT, _events2.default.FRAG_PARSING_DATA, _events2.default.FRAG_PARSED, _events2.default.ERROR, _events2.default.BUFFER_CREATED, _events2.default.BUFFER_APPENDED, _events2.default.BUFFER_FLUSHED, _events2.default.INIT_PTS_FOUND));

    _this.config = hls.config;
    _this.audioCodecSwap = false;
    _this.ticks = 0;
    _this.ontick = _this.tick.bind(_this);
    _this.initPTS = [];
    _this.waitingFragment = null;
    return _this;
  }

  _createClass(AudioStreamController, [{
    key: 'destroy',
    value: function destroy() {
      this.stopLoad();
      if (this.timer) {
        clearInterval(this.timer);
        this.timer = null;
      }
      _eventHandler2.default.prototype.destroy.call(this);
      this.state = State.STOPPED;
    }

    //Signal that video PTS was found

  }, {
    key: 'onInitPtsFound',
    value: function onInitPtsFound(data) {
      var demuxerId = data.id,
          cc = data.cc,
          initPTS = data.initPTS;
      if (demuxerId === 'main') {
        //Always update the new INIT PTS
        //Can change due level switch
        this.initPTS[cc] = initPTS;
        _logger.logger.log('InitPTS for cc:' + cc + ' found from video track:' + initPTS);

        //If we are waiting we need to demux/remux the waiting frag
        //With the new initPTS
        if (this.state === State.WAITING_INIT_PTS) {
          _logger.logger.log('sending pending audio frag to demuxer');
          this.state = State.FRAG_LOADING;
          //We have audio frag waiting or video pts
          //Let process it
          this.onFragLoaded(this.waitingFragment);
          //Lets clean the waiting frag
          this.waitingFragment = null;
        }
      }
    }
  }, {
    key: 'startLoad',
    value: function startLoad(startPosition) {
      if (this.tracks) {
        var lastCurrentTime = this.lastCurrentTime;
        this.stopLoad();
        if (!this.timer) {
          this.timer = setInterval(this.ontick, 100);
        }
        this.fragLoadError = 0;
        if (lastCurrentTime > 0 && startPosition === -1) {
          _logger.logger.log('audio:override startPosition with lastCurrentTime @' + lastCurrentTime.toFixed(3));
          this.state = State.IDLE;
        } else {
          this.lastCurrentTime = this.startPosition ? this.startPosition : startPosition;
          this.state = State.STARTING;
        }
        this.nextLoadPosition = this.startPosition = this.lastCurrentTime;
        this.tick();
      } else {
        this.startPosition = startPosition;
        this.state = State.STOPPED;
      }
    }
  }, {
    key: 'stopLoad',
    value: function stopLoad() {
      var frag = this.fragCurrent;
      if (frag) {
        if (frag.loader) {
          frag.loader.abort();
        }
        this.fragCurrent = null;
      }
      this.fragPrevious = null;
      if (this.demuxer) {
        this.demuxer.destroy();
        this.demuxer = null;
      }
      this.state = State.STOPPED;
    }
  }, {
    key: 'tick',
    value: function tick() {
      this.ticks++;
      if (this.ticks === 1) {
        this.doTick();
        if (this.ticks > 1) {
          setTimeout(this.tick, 1);
        }
        this.ticks = 0;
      }
    }
  }, {
    key: 'doTick',
    value: function doTick() {
      var _this2 = this;

      var pos,
          track,
          trackDetails,
          hls = this.hls,
          config = hls.config;
      //logger.log('audioStream:' + this.state);
      var now;
      var retryDate;
      var isSeeking;

      var _ret = function () {
        switch (_this2.state) {
          case State.ERROR:
          //don't do anything in error state to avoid breaking further ...
          case State.PAUSED:
            //don't do anything in paused state either ...
            break;
          case State.STARTING:
            _this2.state = State.WAITING_TRACK;
            _this2.loadedmetadata = false;
            break;
          case State.IDLE:
            // if video not attached AND
            // start fragment already requested OR start frag prefetch disable
            // exit loop
            // => if media not attached but start frag prefetch is enabled and start frag not requested yet, we will not exit loop
            if (!_this2.media && (_this2.startFragRequested || !config.startFragPrefetch)) {
              break;
            }
            // determine next candidate fragment to be loaded, based on current position and
            //  end of buffer position
            // if we have not yet loaded any fragment, start loading from start position
            if (_this2.loadedmetadata) {
              pos = _this2.media.currentTime;
            } else if (_this2.nextLoadPosition) {
              pos = _this2.nextLoadPosition;
            } else {
              pos = 0;
            }

            var media = _this2.mediaBuffer ? _this2.mediaBuffer : _this2.media,
                bufferInfo = _bufferHelper2.default.bufferInfo(media, pos, config.maxBufferHole),
                bufferLen = bufferInfo.len,
                bufferEnd = bufferInfo.end,
                fragPrevious = _this2.fragPrevious,
                maxBufLen = config.maxMaxBufferLength,
                audioSwitch = _this2.audioSwitch;

            // if buffer length is less than maxBufLen try to load a new fragment
            if (bufferLen < maxBufLen && _this2.trackId < _this2.tracks.length) {
              trackDetails = _this2.tracks[_this2.trackId].details;
              // if track info not retrieved yet, switch state and wait for track retrieval
              if (typeof trackDetails === 'undefined') {
                _this2.state = State.WAITING_TRACK;
                break;
              }

              // we just got done loading the final fragment, check if we need to finalize media stream
              if (!audioSwitch && !trackDetails.live && fragPrevious && fragPrevious.sn === trackDetails.endSN) {
                // if we are not seeking or if we are seeking but everything (almost) til the end is buffered, let's signal eos
                // we don't compare exactly media.duration === bufferInfo.end as there could be some subtle media duration difference when switching
                // between different renditions. using half frag duration should help cope with these cases.
                if (!_this2.media.seeking || _this2.media.duration - bufferEnd < fragPrevious.duration / 2) {
                  // Finalize the media stream
                  _this2.hls.trigger(_events2.default.BUFFER_EOS, { type: 'audio' });
                  _this2.state = State.ENDED;
                  break;
                }
              }

              // find fragment index, contiguous with end of buffer position
              var fragments = trackDetails.fragments,
                  fragLen = fragments.length,
                  start = fragments[0].start,
                  end = fragments[fragLen - 1].start + fragments[fragLen - 1].duration,
                  frag = void 0;

              // When switching audio track, reload audio as close as possible to currentTime
              if (audioSwitch) {
                if (trackDetails.live && !trackDetails.PTSKnown) {
                  _logger.logger.log('switching audiotrack, live stream, unknown PTS,load first fragment');
                  bufferEnd = 0;
                } else {
                  bufferEnd = pos;
                  // if currentTime (pos) is less than alt audio playlist start time, it means that alt audio is ahead of currentTime
                  if (trackDetails.PTSKnown && pos < start) {
                    // if everything is buffered from pos to start, let's seek to start
                    if (bufferInfo.end > start) {
                      _logger.logger.log('alt audio track ahead of main track, seek to start of alt audio track');
                      _this2.media.currentTime = start + 0.05;
                    } else {
                      return {
                        v: void 0
                      };
                    }
                  }
                }
              }

              // if bufferEnd before start of playlist, load first fragment
              if (bufferEnd < start) {
                frag = fragments[0];
              } else {
                (function () {
                  var foundFrag = void 0;
                  var maxFragLookUpTolerance = config.maxFragLookUpTolerance;
                  var fragNext = fragPrevious ? fragments.find(function (fragment) {
                    return fragment.sn === fragPrevious.sn + 1;
                  }) : undefined;
                  var fragmentWithinToleranceTest = function fragmentWithinToleranceTest(candidate) {
                    // offset should be within fragment boundary - config.maxFragLookUpTolerance
                    // this is to cope with situations like
                    // bufferEnd = 9.991
                    // frag[] : [0,10]
                    // frag[1] : [10,20]
                    // bufferEnd is within frag[0] range ... although what we are expecting is to return frag[1] here
                    //              frag start               frag start+duration
                    //                  |-----------------------------|
                    //              <--->                         <--->
                    //  ...--------><-----------------------------><---------....
                    // previous frag         matching fragment         next frag
                    //  return -1             return 0                 return 1
                    //logger.log(`level/sn/start/end/bufEnd:${level}/${candidate.sn}/${candidate.start}/${(candidate.start+candidate.duration)}/${bufferEnd}`);
                    // Set the lookup tolerance to be small enough to detect the current segment - ensures we don't skip over very small segments
                    var candidateLookupTolerance = Math.min(maxFragLookUpTolerance, candidate.duration);
                    if (candidate.start + candidate.duration - candidateLookupTolerance <= bufferEnd) {
                      return 1;
                    } // if maxFragLookUpTolerance will have negative value then don't return -1 for first element
                    else if (candidate.start - candidateLookupTolerance > bufferEnd && candidate.start) {
                        return -1;
                      }
                    return 0;
                  };

                  if (bufferEnd < end) {
                    if (bufferEnd > end - maxFragLookUpTolerance) {
                      maxFragLookUpTolerance = 0;
                    }
                    // Prefer the next fragment if it's within tolerance
                    if (fragNext && fragmentWithinToleranceTest(fragNext) !== 0) {
                      foundFrag = fragNext;
                    } else {
                      foundFrag = _binarySearch2.default.search(fragments, fragmentWithinToleranceTest);
                    }
                  } else {
                    // reach end of playlist
                    foundFrag = fragments[fragLen - 1];
                  }
                  if (foundFrag) {
                    frag = foundFrag;
                    start = foundFrag.start;
                    //logger.log('find SN matching with pos:' +  bufferEnd + ':' + frag.sn);
                    if (fragPrevious && frag.level === fragPrevious.level && frag.sn === fragPrevious.sn) {
                      if (frag.sn < trackDetails.endSN) {
                        frag = fragments[frag.sn + 1 - trackDetails.startSN];
                        _logger.logger.log('SN just loaded, load next one: ' + frag.sn);
                      } else {
                        frag = null;
                      }
                    }
                  }
                })();
              }
              if (frag) {
                //logger.log('      loading frag ' + i +',pos/bufEnd:' + pos.toFixed(3) + '/' + bufferEnd.toFixed(3));
                if (frag.decryptdata.uri != null && frag.decryptdata.key == null) {
                  _logger.logger.log('Loading key for ' + frag.sn + ' of [' + trackDetails.startSN + ' ,' + trackDetails.endSN + '],track ' + _this2.trackId);
                  _this2.state = State.KEY_LOADING;
                  hls.trigger(_events2.default.KEY_LOADING, { frag: frag });
                } else {
                  _logger.logger.log('Loading ' + frag.sn + ' of [' + trackDetails.startSN + ' ,' + trackDetails.endSN + '],track ' + _this2.trackId + ', currentTime:' + pos + ',bufferEnd:' + bufferEnd.toFixed(3));
                  // ensure that we are not reloading the same fragments in loop ...
                  if (_this2.fragLoadIdx !== undefined) {
                    _this2.fragLoadIdx++;
                  } else {
                    _this2.fragLoadIdx = 0;
                  }
                  if (frag.loadCounter) {
                    frag.loadCounter++;
                    var maxThreshold = config.fragLoadingLoopThreshold;
                    // if this frag has already been loaded 3 times, and if it has been reloaded recently
                    if (frag.loadCounter > maxThreshold && Math.abs(_this2.fragLoadIdx - frag.loadIdx) < maxThreshold) {
                      hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.FRAG_LOOP_LOADING_ERROR, fatal: false, frag: frag });
                      return {
                        v: void 0
                      };
                    }
                  } else {
                    frag.loadCounter = 1;
                  }
                  frag.loadIdx = _this2.fragLoadIdx;
                  _this2.fragCurrent = frag;
                  _this2.startFragRequested = true;
                  _this2.nextLoadPosition = frag.start + frag.duration;
                  hls.trigger(_events2.default.FRAG_LOADING, { frag: frag });
                  _this2.state = State.FRAG_LOADING;
                }
              }
            }
            break;
          case State.WAITING_TRACK:
            track = _this2.tracks[_this2.trackId];
            // check if playlist is already loaded
            if (track && track.details) {
              _this2.state = State.IDLE;
            }
            break;
          case State.FRAG_LOADING_WAITING_RETRY:
            now = performance.now();
            retryDate = _this2.retryDate;

            media = _this2.media;
            isSeeking = media && media.seeking;
            // if current time is gt than retryDate, or if media seeking let's switch to IDLE state to retry loading

            if (!retryDate || now >= retryDate || isSeeking) {
              _logger.logger.log('audioStreamController: retryDate reached, switch back to IDLE state');
              _this2.state = State.IDLE;
            }
            break;
          case State.WAITING_INIT_PTS:
          case State.STOPPED:
          case State.FRAG_LOADING:
          case State.PARSING:
          case State.PARSED:
          case State.ENDED:
            break;
          default:
            break;
        }
      }();

      if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object") return _ret.v;
    }
  }, {
    key: 'onMediaAttached',
    value: function onMediaAttached(data) {
      var media = this.media = this.mediaBuffer = data.media;
      this.onvseeking = this.onMediaSeeking.bind(this);
      this.onvended = this.onMediaEnded.bind(this);
      media.addEventListener('seeking', this.onvseeking);
      media.addEventListener('ended', this.onvended);
      var config = this.config;
      if (this.tracks && config.autoStartLoad) {
        this.startLoad(config.startPosition);
      }
    }
  }, {
    key: 'onMediaDetaching',
    value: function onMediaDetaching() {
      var media = this.media;
      if (media && media.ended) {
        _logger.logger.log('MSE detaching and video ended, reset startPosition');
        this.startPosition = this.lastCurrentTime = 0;
      }

      // reset fragment loading counter on MSE detaching to avoid reporting FRAG_LOOP_LOADING_ERROR after error recovery
      var tracks = this.tracks;
      if (tracks) {
        // reset fragment load counter
        tracks.forEach(function (track) {
          if (track.details) {
            track.details.fragments.forEach(function (fragment) {
              fragment.loadCounter = undefined;
            });
          }
        });
      }
      // remove video listeners
      if (media) {
        media.removeEventListener('seeking', this.onvseeking);
        media.removeEventListener('ended', this.onvended);
        this.onvseeking = this.onvseeked = this.onvended = null;
      }
      this.media = this.mediaBuffer = null;
      this.loadedmetadata = false;
      this.stopLoad();
    }
  }, {
    key: 'onMediaSeeking',
    value: function onMediaSeeking() {
      if (this.state === State.ENDED) {
        // switch to IDLE state to check for potential new fragment
        this.state = State.IDLE;
      }
      if (this.media) {
        this.lastCurrentTime = this.media.currentTime;
      }
      // avoid reporting fragment loop loading error in case user is seeking several times on same position
      if (this.fragLoadIdx !== undefined) {
        this.fragLoadIdx += 2 * this.config.fragLoadingLoopThreshold;
      }
      // tick to speed up processing
      this.tick();
    }
  }, {
    key: 'onMediaEnded',
    value: function onMediaEnded() {
      // reset startPosition and lastCurrentTime to restart playback @ stream beginning
      this.startPosition = this.lastCurrentTime = 0;
    }
  }, {
    key: 'onAudioTracksUpdated',
    value: function onAudioTracksUpdated(data) {
      _logger.logger.log('audio tracks updated');
      this.tracks = data.audioTracks;
    }
  }, {
    key: 'onAudioTrackSwitching',
    value: function onAudioTrackSwitching(data) {
      // if any URL found on new audio track, it is an alternate audio track
      var altAudio = !!data.url;
      this.trackId = data.id;
      this.state = State.IDLE;

      this.fragCurrent = null;
      this.state = State.PAUSED;
      this.waitingFragment = null;
      // destroy useless demuxer when switching audio to main
      if (!altAudio) {
        if (this.demuxer) {
          this.demuxer.destroy();
          this.demuxer = null;
        }
      } else {
        // switching to audio track, start timer if not already started
        if (!this.timer) {
          this.timer = setInterval(this.ontick, 100);
        }
      }

      //should we switch tracks ?
      if (altAudio) {
        this.audioSwitch = true;
        //main audio track are handled by stream-controller, just do something if switching to alt audio track
        this.state = State.IDLE;
        // increase fragment load Index to avoid frag loop loading error after buffer flush
        this.fragLoadIdx += 2 * this.config.fragLoadingLoopThreshold;
      }
      this.tick();
    }
  }, {
    key: 'onAudioTrackLoaded',
    value: function onAudioTrackLoaded(data) {
      var newDetails = data.details,
          trackId = data.id,
          track = this.tracks[trackId],
          duration = newDetails.totalduration,
          sliding = 0;

      _logger.logger.log('track ' + trackId + ' loaded [' + newDetails.startSN + ',' + newDetails.endSN + '],duration:' + duration);

      if (newDetails.live) {
        var curDetails = track.details;
        if (curDetails && newDetails.fragments.length > 0) {
          // we already have details for that level, merge them
          _levelHelper2.default.mergeDetails(curDetails, newDetails);
          sliding = newDetails.fragments[0].start;
          // TODO
          //this.liveSyncPosition = this.computeLivePosition(sliding, curDetails);
          if (newDetails.PTSKnown) {
            _logger.logger.log('live audio playlist sliding:' + sliding.toFixed(3));
          } else {
            _logger.logger.log('live audio playlist - outdated PTS, unknown sliding');
          }
        } else {
          newDetails.PTSKnown = false;
          _logger.logger.log('live audio playlist - first load, unknown sliding');
        }
      } else {
        newDetails.PTSKnown = false;
      }
      track.details = newDetails;

      // compute start position
      if (!this.startFragRequested) {
        // compute start position if set to -1. use it straight away if value is defined
        if (this.startPosition === -1) {
          // first, check if start time offset has been set in playlist, if yes, use this value
          var startTimeOffset = newDetails.startTimeOffset;
          if (!isNaN(startTimeOffset)) {
            _logger.logger.log('start time offset found in playlist, adjust startPosition to ' + startTimeOffset);
            this.startPosition = startTimeOffset;
          } else {
            this.startPosition = 0;
          }
        }
        this.nextLoadPosition = this.startPosition;
      }
      // only switch batck to IDLE state if we were waiting for track to start downloading a new fragment
      if (this.state === State.WAITING_TRACK) {
        this.state = State.IDLE;
      }
      //trigger handler right now
      this.tick();
    }
  }, {
    key: 'onKeyLoaded',
    value: function onKeyLoaded() {
      if (this.state === State.KEY_LOADING) {
        this.state = State.IDLE;
        this.tick();
      }
    }
  }, {
    key: 'onFragLoaded',
    value: function onFragLoaded(data) {
      var fragCurrent = this.fragCurrent;
      if (this.state === State.FRAG_LOADING && fragCurrent && data.frag.type === 'audio' && data.frag.level === fragCurrent.level && data.frag.sn === fragCurrent.sn) {
        this.state = State.PARSING;
        // transmux the MPEG-TS data to ISO-BMFF segments
        this.stats = data.stats;
        var track = this.tracks[this.trackId],
            details = track.details,
            duration = details.totalduration,
            start = fragCurrent.start,
            trackId = fragCurrent.level,
            sn = fragCurrent.sn,
            cc = fragCurrent.cc,
            audioCodec = this.config.defaultAudioCodec || track.audioCodec;
        this.appended = false;
        if (!this.demuxer) {
          this.demuxer = new _demuxer2.default(this.hls, 'audio');
        }
        //Check if we have video initPTS
        // If not we need to wait for it
        var initPTS = this.initPTS[cc];
        if (initPTS !== undefined) {
          this.pendingBuffering = -1;
          _logger.logger.log('Demuxing ' + sn + ' of [' + details.startSN + ' ,' + details.endSN + '],track ' + trackId);
          // time Offset is accurate if level PTS is known, or if playlist is not sliding (not live)
          var accurateTimeOffset = false; //details.PTSKnown || !details.live;
          this.demuxer.push(data.payload, audioCodec, null, start, cc, trackId, sn, duration, fragCurrent.decryptdata, accurateTimeOffset, initPTS);
        } else {
          _logger.logger.log('unknown video PTS for continuity counter ' + cc + ', waiting for video PTS before demuxing audio frag ' + sn + ' of [' + details.startSN + ' ,' + details.endSN + '],track ' + trackId);
          this.waitingFragment = data;
          this.state = State.WAITING_INIT_PTS;
        }
      }
      this.fragLoadError = 0;
    }
  }, {
    key: 'onFragParsingInitSegment',
    value: function onFragParsingInitSegment(data) {
      var fragCurrent = this.fragCurrent;
      if (fragCurrent && data.id === 'audio' && data.sn === fragCurrent.sn && data.level === fragCurrent.level && this.state === State.PARSING) {
        var tracks = data.tracks,
            track = void 0;

        // delete any video track found on audio demuxer
        if (tracks.video) {
          delete tracks.video;
        }

        // include levelCodec in audio and video tracks
        track = tracks.audio;
        if (track) {
          track.levelCodec = 'mp4a.40.2';
          track.id = data.id;
          this.hls.trigger(_events2.default.BUFFER_CODECS, tracks);
          _logger.logger.log('audio track:audio,container:' + track.container + ',codecs[level/parsed]=[' + track.levelCodec + '/' + track.codec + ']');
          var initSegment = track.initSegment;
          if (initSegment) {
            var appendObj = { type: 'audio', data: initSegment, parent: 'audio', content: 'initSegment' };
            if (this.audioSwitch) {
              this.pendingData = [appendObj];
            } else {
              this.appended = true;
              this.hls.trigger(_events2.default.BUFFER_APPENDING, appendObj);
            }
          }
          //trigger handler right now
          this.tick();
        }
      }
    }
  }, {
    key: 'onFragParsingData',
    value: function onFragParsingData(data) {
      var _this3 = this;

      var fragCurrent = this.fragCurrent;
      if (fragCurrent && data.id === 'audio' && data.type === 'audio' && data.sn === fragCurrent.sn && data.level === fragCurrent.level && this.state === State.PARSING) {
        (function () {
          var trackId = _this3.trackId,
              track = _this3.tracks[trackId],
              frag = _this3.fragCurrent,
              hls = _this3.hls;

          _logger.logger.log('parsed ' + data.type + ',PTS:[' + data.startPTS.toFixed(3) + ',' + data.endPTS.toFixed(3) + '],DTS:[' + data.startDTS.toFixed(3) + '/' + data.endDTS.toFixed(3) + '],nb:' + data.nb);
          _levelHelper2.default.updateFragPTSDTS(track.details, frag.sn, data.startPTS, data.endPTS);

          var audioSwitch = _this3.audioSwitch,
              media = _this3.media,
              appendOnBufferFlush = false;
          //Only flush audio from old audio tracks when PTS is known on new audio track
          if (audioSwitch && media) {
            if (media.readyState) {
              var currentTime = media.currentTime;
              _logger.logger.log('switching audio track : currentTime:' + currentTime);
              if (currentTime >= data.startPTS) {
                _logger.logger.log('switching audio track : flushing all audio');
                hls.trigger(_events2.default.BUFFER_FLUSHING, { startOffset: 0, endOffset: Number.POSITIVE_INFINITY, type: 'audio' });
                appendOnBufferFlush = true;
                //Lets announce that the initial audio track switch flush occur
                _this3.audioSwitch = false;
                hls.trigger(_events2.default.AUDIO_TRACK_SWITCHED, { id: trackId });
              }
            } else {
              //Lets announce that the initial audio track switch flush occur
              _this3.audioSwitch = false;
              hls.trigger(_events2.default.AUDIO_TRACK_SWITCHED, { id: trackId });
            }
          }

          var pendingData = _this3.pendingData;
          if (!_this3.audioSwitch) {
            [data.data1, data.data2].forEach(function (buffer) {
              if (buffer) {
                pendingData.push({ type: data.type, data: buffer, parent: 'audio', content: 'data' });
              }
            });
            if (!appendOnBufferFlush && pendingData.length) {
              pendingData.forEach(function (appendObj) {
                _this3.hls.trigger(_events2.default.BUFFER_APPENDING, appendObj);
              });
              _this3.pendingData = [];
              _this3.appended = true;
            }
          }
          //trigger handler right now
          _this3.tick();
        })();
      }
    }
  }, {
    key: 'onFragParsed',
    value: function onFragParsed(data) {
      var fragCurrent = this.fragCurrent;
      if (fragCurrent && data.id === 'audio' && data.sn === fragCurrent.sn && data.level === fragCurrent.level && this.state === State.PARSING) {
        this.stats.tparsed = performance.now();
        this.state = State.PARSED;
        this._checkAppendedParsed();
      }
    }
  }, {
    key: 'onBufferCreated',
    value: function onBufferCreated(data) {
      var audioTrack = data.tracks.audio;
      if (audioTrack) {
        this.mediaBuffer = audioTrack.buffer;
        this.loadedmetadata = true;
      }
    }
  }, {
    key: 'onBufferAppended',
    value: function onBufferAppended(data) {
      if (data.parent === 'audio') {
        var state = this.state;
        if (state === State.PARSING || state === State.PARSED) {
          this.pendingBuffering = data.pending;
          this._checkAppendedParsed();
        }
      }
    }
  }, {
    key: '_checkAppendedParsed',
    value: function _checkAppendedParsed() {
      //trigger handler right now
      if (this.state === State.PARSED && (!this.appended || this.pendingBuffering === 0)) {
        var frag = this.fragCurrent,
            stats = this.stats,
            hls = this.hls;
        if (frag) {
          this.fragPrevious = frag;
          stats.tbuffered = performance.now();
          hls.trigger(_events2.default.FRAG_BUFFERED, { stats: stats, frag: frag, id: 'audio' });
          var media = this.mediaBuffer ? this.mediaBuffer : this.media;
          _logger.logger.log('audio buffered : ' + _timeRanges2.default.toString(media.buffered));
          if (this.audioSwitch && this.appended) {
            this.audioSwitch = false;
            hls.trigger(_events2.default.AUDIO_TRACK_SWITCHED, { id: this.trackId });
          }
          this.state = State.IDLE;
        }
        this.tick();
      }
    }
  }, {
    key: 'onError',
    value: function onError(data) {
      var frag = data.frag;
      // don't handle frag error not related to audio fragment
      if (frag && frag.type !== 'audio') {
        return;
      }
      switch (data.details) {
        case _errors.ErrorDetails.FRAG_LOAD_ERROR:
        case _errors.ErrorDetails.FRAG_LOAD_TIMEOUT:
          if (!data.fatal) {
            var loadError = this.fragLoadError;
            if (loadError) {
              loadError++;
            } else {
              loadError = 1;
            }
            var config = this.config;
            if (loadError <= config.fragLoadingMaxRetry) {
              this.fragLoadError = loadError;
              // reset load counter to avoid frag loop loading error
              frag.loadCounter = 0;
              // exponential backoff capped to config.fragLoadingMaxRetryTimeout
              var delay = Math.min(Math.pow(2, loadError - 1) * config.fragLoadingRetryDelay, config.fragLoadingMaxRetryTimeout);
              _logger.logger.warn('audioStreamController: frag loading failed, retry in ' + delay + ' ms');
              this.retryDate = performance.now() + delay;
              // retry loading state
              this.state = State.FRAG_LOADING_WAITING_RETRY;
            } else {
              _logger.logger.error('audioStreamController: ' + data.details + ' reaches max retry, redispatch as fatal ...');
              // redispatch same error but with fatal set to true
              data.fatal = true;
              this.hls.trigger(_events2.default.ERROR, data);
              this.state = State.ERROR;
            }
          }
          break;
        case _errors.ErrorDetails.FRAG_LOOP_LOADING_ERROR:
        case _errors.ErrorDetails.AUDIO_TRACK_LOAD_ERROR:
        case _errors.ErrorDetails.AUDIO_TRACK_LOAD_TIMEOUT:
        case _errors.ErrorDetails.KEY_LOAD_ERROR:
        case _errors.ErrorDetails.KEY_LOAD_TIMEOUT:
          //  when in ERROR state, don't switch back to IDLE state in case a non-fatal error is received
          if (this.state !== State.ERROR) {
            // if fatal error, stop processing, otherwise move to IDLE to retry loading
            this.state = data.fatal ? State.ERROR : State.IDLE;
            _logger.logger.warn('audioStreamController: ' + data.details + ' while loading frag,switch to ' + this.state + ' state ...');
          }
          break;
        default:
          break;
      }
    }
  }, {
    key: 'onBufferFlushed',
    value: function onBufferFlushed() {
      var _this4 = this;

      var pendingData = this.pendingData;
      if (pendingData && pendingData.length) {
        _logger.logger.log('appending pending audio data on Buffer Flushed');
        pendingData.forEach(function (appendObj) {
          _this4.hls.trigger(_events2.default.BUFFER_APPENDING, appendObj);
        });
        this.appended = true;
        this.pendingData = [];
        this.state = State.PARSED;
      } else {
        // move to IDLE once flush complete. this should trigger new fragment loading
        this.state = State.IDLE;
        // reset reference to frag
        this.fragPrevious = null;
        this.tick();
      }
    }
  }]);

  return AudioStreamController;
}(_eventHandler2.default);

exports.default = AudioStreamController;

},{"../demux/demuxer":24,"../errors":28,"../event-handler":29,"../events":30,"../helper/buffer-helper":32,"../helper/level-helper":33,"../utils/binary-search":43,"../utils/logger":47,"../utils/timeRanges":48}],6:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _eventHandler = require('../event-handler');

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _logger = require('../utils/logger');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * audio track controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

var AudioTrackController = function (_EventHandler) {
  _inherits(AudioTrackController, _EventHandler);

  function AudioTrackController(hls) {
    _classCallCheck(this, AudioTrackController);

    var _this = _possibleConstructorReturn(this, (AudioTrackController.__proto__ || Object.getPrototypeOf(AudioTrackController)).call(this, hls, _events2.default.MANIFEST_LOADING, _events2.default.MANIFEST_LOADED, _events2.default.AUDIO_TRACK_LOADED));

    _this.ticks = 0;
    _this.ontick = _this.tick.bind(_this);
    return _this;
  }

  _createClass(AudioTrackController, [{
    key: 'destroy',
    value: function destroy() {
      _eventHandler2.default.prototype.destroy.call(this);
    }
  }, {
    key: 'tick',
    value: function tick() {
      this.ticks++;
      if (this.ticks === 1) {
        this.doTick();
        if (this.ticks > 1) {
          setTimeout(this.tick, 1);
        }
        this.ticks = 0;
      }
    }
  }, {
    key: 'doTick',
    value: function doTick() {
      this.updateTrack(this.trackId);
    }
  }, {
    key: 'onManifestLoading',
    value: function onManifestLoading() {
      // reset audio tracks on manifest loading
      this.tracks = [];
      this.trackId = -1;
    }
  }, {
    key: 'onManifestLoaded',
    value: function onManifestLoaded(data) {
      var _this2 = this;

      var tracks = data.audioTracks || [];
      var defaultFound = false;
      this.tracks = tracks;
      this.hls.trigger(_events2.default.AUDIO_TRACKS_UPDATED, { audioTracks: tracks });
      // loop through available audio tracks and autoselect default if needed
      var id = 0;
      tracks.forEach(function (track) {
        if (track.default) {
          _this2.audioTrack = id;
          defaultFound = true;
          return;
        }
        id++;
      });
      if (defaultFound === false && tracks.length) {
        _logger.logger.log('no default audio track defined, use first audio track as default');
        this.audioTrack = 0;
      }
    }
  }, {
    key: 'onAudioTrackLoaded',
    value: function onAudioTrackLoaded(data) {
      if (data.id < this.tracks.length) {
        _logger.logger.log('audioTrack ' + data.id + ' loaded');
        this.tracks[data.id].details = data.details;
        // check if current playlist is a live playlist
        if (data.details.live && !this.timer) {
          // if live playlist we will have to reload it periodically
          // set reload period to playlist target duration
          this.timer = setInterval(this.ontick, 1000 * data.details.targetduration);
        }
        if (!data.details.live && this.timer) {
          // playlist is not live and timer is armed : stopping it
          clearInterval(this.timer);
          this.timer = null;
        }
      }
    }

    /** get alternate audio tracks list from playlist **/

  }, {
    key: 'setAudioTrackInternal',
    value: function setAudioTrackInternal(newId) {
      // check if level idx is valid
      if (newId >= 0 && newId < this.tracks.length) {
        // stopping live reloading timer if any
        if (this.timer) {
          clearInterval(this.timer);
          this.timer = null;
        }
        this.trackId = newId;
        _logger.logger.log('switching to audioTrack ' + newId);
        var audioTrack = this.tracks[newId],
            hls = this.hls,
            type = audioTrack.type,
            url = audioTrack.url,
            eventObj = { id: newId, type: type, url: url };
        // keep AUDIO_TRACK_SWITCH for legacy reason
        hls.trigger(_events2.default.AUDIO_TRACK_SWITCH, eventObj);
        hls.trigger(_events2.default.AUDIO_TRACK_SWITCHING, eventObj);
        // check if we need to load playlist for this audio Track
        var details = audioTrack.details;
        if (url && (details === undefined || details.live === true)) {
          // track not retrieved yet, or live playlist we need to (re)load it
          _logger.logger.log('(re)loading playlist for audioTrack ' + newId);
          hls.trigger(_events2.default.AUDIO_TRACK_LOADING, { url: url, id: newId });
        }
      }
    }
  }, {
    key: 'updateTrack',
    value: function updateTrack(newId) {
      // check if level idx is valid
      if (newId >= 0 && newId < this.tracks.length) {
        // stopping live reloading timer if any
        if (this.timer) {
          clearInterval(this.timer);
          this.timer = null;
        }
        this.trackId = newId;
        _logger.logger.log('updating audioTrack ' + newId);
        var audioTrack = this.tracks[newId],
            url = audioTrack.url;
        // check if we need to load playlist for this audio Track
        var details = audioTrack.details;
        if (url && (details === undefined || details.live === true)) {
          // track not retrieved yet, or live playlist we need to (re)load it
          _logger.logger.log('(re)loading playlist for audioTrack ' + newId);
          this.hls.trigger(_events2.default.AUDIO_TRACK_LOADING, { url: url, id: newId });
        }
      }
    }
  }, {
    key: 'audioTracks',
    get: function get() {
      return this.tracks;
    }

    /** get index of the selected audio track (index in audio track lists) **/

  }, {
    key: 'audioTrack',
    get: function get() {
      return this.trackId;
    }

    /** select an audio track, based on its index in audio track lists**/
    ,
    set: function set(audioTrackId) {
      if (this.trackId !== audioTrackId || this.tracks[audioTrackId].details === undefined) {
        this.setAudioTrackInternal(audioTrackId);
      }
    }
  }]);

  return AudioTrackController;
}(_eventHandler2.default);

exports.default = AudioTrackController;

},{"../event-handler":29,"../events":30,"../utils/logger":47}],7:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _eventHandler = require('../event-handler');

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _logger = require('../utils/logger');

var _errors = require('../errors');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Buffer Controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

var BufferController = function (_EventHandler) {
  _inherits(BufferController, _EventHandler);

  function BufferController(hls) {
    _classCallCheck(this, BufferController);

    // the value that we have set mediasource.duration to
    // (the actual duration may be tweaked slighly by the browser)
    var _this = _possibleConstructorReturn(this, (BufferController.__proto__ || Object.getPrototypeOf(BufferController)).call(this, hls, _events2.default.MEDIA_ATTACHING, _events2.default.MEDIA_DETACHING, _events2.default.MANIFEST_PARSED, _events2.default.BUFFER_RESET, _events2.default.BUFFER_APPENDING, _events2.default.BUFFER_CODECS, _events2.default.BUFFER_EOS, _events2.default.BUFFER_FLUSHING, _events2.default.LEVEL_PTS_UPDATED, _events2.default.LEVEL_UPDATED));

    _this._msDuration = null;
    // the value that we want to set mediaSource.duration to
    _this._levelDuration = null;

    // Source Buffer listeners
    _this.onsbue = _this.onSBUpdateEnd.bind(_this);
    _this.onsbe = _this.onSBUpdateError.bind(_this);
    _this.pendingTracks = {};
    _this.tracks = {};
    return _this;
  }

  _createClass(BufferController, [{
    key: 'destroy',
    value: function destroy() {
      _eventHandler2.default.prototype.destroy.call(this);
    }
  }, {
    key: 'onLevelPtsUpdated',
    value: function onLevelPtsUpdated(data) {
      var type = data.type;
      var audioTrack = this.tracks.audio;

      // Adjusting `SourceBuffer.timestampOffset` (desired point in the timeline where the next frames should be appended)
      // in Chrome browser when we detect MPEG audio container and time delta between level PTS and `SourceBuffer.timestampOffset`
      // is greater than 100ms (this is enough to handle seek for VOD or level change for LIVE videos). At the time of change we issue
      // `SourceBuffer.abort()` and adjusting `SourceBuffer.timestampOffset` if `SourceBuffer.updating` is false or awaiting `updateend`
      // event if SB is in updating state.
      // More info here: https://github.com/dailymotion/hls.js/issues/332#issuecomment-257986486

      if (type === 'audio' && audioTrack && audioTrack.container === 'audio/mpeg') {
        // Chrome audio mp3 track
        var audioBuffer = this.sourceBuffer.audio;
        var delta = Math.abs(audioBuffer.timestampOffset - data.start);

        // adjust timestamp offset if time delta is greater than 100ms
        if (delta > 0.1) {
          var updating = audioBuffer.updating;

          try {
            audioBuffer.abort();
          } catch (err) {
            updating = true;
            _logger.logger.warn('can not abort audio buffer: ' + err);
          }

          if (!updating) {
            _logger.logger.warn('change mpeg audio timestamp offset from ' + audioBuffer.timestampOffset + ' to ' + data.start);
            audioBuffer.timestampOffset = data.start;
          } else {
            this.audioTimestampOffset = data.start;
          }
        }
      }
    }
  }, {
    key: 'onManifestParsed',
    value: function onManifestParsed(data) {
      var audioExpected = data.audio,
          videoExpected = data.video,
          sourceBufferNb = 0;
      // in case of alt audio 2 BUFFER_CODECS events will be triggered, one per stream controller
      // sourcebuffers will be created all at once when the expected nb of tracks will be reached
      // in case alt audio is not used, only one BUFFER_CODEC event will be fired from main stream controller
      // it will contain the expected nb of source buffers, no need to compute it
      if (data.altAudio && (audioExpected || videoExpected)) {
        sourceBufferNb = (audioExpected ? 1 : 0) + (videoExpected ? 1 : 0);
        _logger.logger.log(sourceBufferNb + ' sourceBuffer(s) expected');
      }
      this.sourceBufferNb = sourceBufferNb;
    }
  }, {
    key: 'onMediaAttaching',
    value: function onMediaAttaching(data) {
      var media = this.media = data.media;
      if (media) {
        // setup the media source
        var ms = this.mediaSource = new MediaSource();
        //Media Source listeners
        this.onmso = this.onMediaSourceOpen.bind(this);
        this.onmse = this.onMediaSourceEnded.bind(this);
        this.onmsc = this.onMediaSourceClose.bind(this);
        ms.addEventListener('sourceopen', this.onmso);
        ms.addEventListener('sourceended', this.onmse);
        ms.addEventListener('sourceclose', this.onmsc);
        // link video and media Source
        media.src = URL.createObjectURL(ms);
      }
    }
  }, {
    key: 'onMediaDetaching',
    value: function onMediaDetaching() {
      _logger.logger.log('media source detaching');
      var ms = this.mediaSource;
      if (ms) {
        if (ms.readyState === 'open') {
          try {
            // endOfStream could trigger exception if any sourcebuffer is in updating state
            // we don't really care about checking sourcebuffer state here,
            // as we are anyway detaching the MediaSource
            // let's just avoid this exception to propagate
            ms.endOfStream();
          } catch (err) {
            _logger.logger.warn('onMediaDetaching:' + err.message + ' while calling endOfStream');
          }
        }
        ms.removeEventListener('sourceopen', this.onmso);
        ms.removeEventListener('sourceended', this.onmse);
        ms.removeEventListener('sourceclose', this.onmsc);

        // Detach properly the MediaSource from the HTMLMediaElement as
        // suggested in https://github.com/w3c/media-source/issues/53.
        if (this.media) {
          URL.revokeObjectURL(this.media.src);
          this.media.removeAttribute('src');
          this.media.load();
        }

        this.mediaSource = null;
        this.media = null;
        this.pendingTracks = {};
        this.tracks = {};
        this.sourceBuffer = {};
        this.flushRange = [];
        this.segments = [];
        this.appended = 0;
      }
      this.onmso = this.onmse = this.onmsc = null;
      this.hls.trigger(_events2.default.MEDIA_DETACHED);
    }
  }, {
    key: 'onMediaSourceOpen',
    value: function onMediaSourceOpen() {
      _logger.logger.log('media source opened');
      this.hls.trigger(_events2.default.MEDIA_ATTACHED, { media: this.media });
      var mediaSource = this.mediaSource;
      if (mediaSource) {
        // once received, don't listen anymore to sourceopen event
        mediaSource.removeEventListener('sourceopen', this.onmso);
      }
      this.checkPendingTracks();
    }
  }, {
    key: 'checkPendingTracks',
    value: function checkPendingTracks() {
      // if any buffer codecs pending, check if we have enough to create sourceBuffers
      var pendingTracks = this.pendingTracks,
          pendingTracksNb = Object.keys(pendingTracks).length;
      // if any pending tracks and (if nb of pending tracks gt or equal than expected nb or if unknown expected nb)
      if (pendingTracksNb && (this.sourceBufferNb <= pendingTracksNb || this.sourceBufferNb === 0)) {
        // ok, let's create them now !
        this.createSourceBuffers(pendingTracks);
        this.pendingTracks = {};
        // append any pending segments now !
        this.doAppending();
      }
    }
  }, {
    key: 'onMediaSourceClose',
    value: function onMediaSourceClose() {
      _logger.logger.log('media source closed');
    }
  }, {
    key: 'onMediaSourceEnded',
    value: function onMediaSourceEnded() {
      _logger.logger.log('media source ended');
    }
  }, {
    key: 'onSBUpdateEnd',
    value: function onSBUpdateEnd() {
      // update timestampOffset
      if (this.audioTimestampOffset) {
        var audioBuffer = this.sourceBuffer.audio;
        _logger.logger.warn('change mpeg audio timestamp offset from ' + audioBuffer.timestampOffset + ' to ' + this.audioTimestampOffset);
        audioBuffer.timestampOffset = this.audioTimestampOffset;
        delete this.audioTimestampOffset;
      }

      if (this._needsFlush) {
        this.doFlush();
      }

      if (this._needsEos) {
        this.checkEos();
      }
      this.appending = false;
      var parent = this.parent;
      // count nb of pending segments waiting for appending on this sourcebuffer
      var pending = this.segments.reduce(function (counter, segment) {
        return segment.parent === parent ? counter + 1 : counter;
      }, 0);
      this.hls.trigger(_events2.default.BUFFER_APPENDED, { parent: parent, pending: pending });

      // don't append in flushing mode
      if (!this._needsFlush) {
        this.doAppending();
      }

      this.updateMediaElementDuration();
    }
  }, {
    key: 'onSBUpdateError',
    value: function onSBUpdateError(event) {
      _logger.logger.error('sourceBuffer error:' + event);
      // according to http://www.w3.org/TR/media-source/#sourcebuffer-append-error
      // this error might not always be fatal (it is fatal if decode error is set, in that case
      // it will be followed by a mediaElement error ...)
      this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.BUFFER_APPENDING_ERROR, fatal: false });
      // we don't need to do more than that, as accordin to the spec, updateend will be fired just after
    }
  }, {
    key: 'onBufferReset',
    value: function onBufferReset() {
      var sourceBuffer = this.sourceBuffer;
      for (var type in sourceBuffer) {
        var sb = sourceBuffer[type];
        try {
          this.mediaSource.removeSourceBuffer(sb);
          sb.removeEventListener('updateend', this.onsbue);
          sb.removeEventListener('error', this.onsbe);
        } catch (err) {}
      }
      this.sourceBuffer = {};
      this.flushRange = [];
      this.segments = [];
      this.appended = 0;
    }
  }, {
    key: 'onBufferCodecs',
    value: function onBufferCodecs(tracks) {
      // if source buffer(s) not created yet, appended buffer tracks in this.pendingTracks
      // if sourcebuffers already created, do nothing ...
      if (Object.keys(this.sourceBuffer).length === 0) {
        for (var trackName in tracks) {
          this.pendingTracks[trackName] = tracks[trackName];
        }
        var mediaSource = this.mediaSource;
        if (mediaSource && mediaSource.readyState === 'open') {
          // try to create sourcebuffers if mediasource opened
          this.checkPendingTracks();
        }
      }
    }
  }, {
    key: 'createSourceBuffers',
    value: function createSourceBuffers(tracks) {
      var sourceBuffer = this.sourceBuffer,
          mediaSource = this.mediaSource;

      for (var trackName in tracks) {
        if (!sourceBuffer[trackName]) {
          var track = tracks[trackName];
          // use levelCodec as first priority
          var codec = track.levelCodec || track.codec;
          var mimeType = track.container + ';codecs=' + codec;
          _logger.logger.log('creating sourceBuffer(' + mimeType + ')');
          try {
            var sb = sourceBuffer[trackName] = mediaSource.addSourceBuffer(mimeType);
            sb.addEventListener('updateend', this.onsbue);
            sb.addEventListener('error', this.onsbe);
            this.tracks[trackName] = { codec: codec, container: track.container };
            track.buffer = sb;
          } catch (err) {
            _logger.logger.error('error while trying to add sourceBuffer:' + err.message);
            this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.BUFFER_ADD_CODEC_ERROR, fatal: false, err: err, mimeType: mimeType });
          }
        }
      }
      this.hls.trigger(_events2.default.BUFFER_CREATED, { tracks: tracks });
    }
  }, {
    key: 'onBufferAppending',
    value: function onBufferAppending(data) {
      if (!this._needsFlush) {
        if (!this.segments) {
          this.segments = [data];
        } else {
          this.segments.push(data);
        }
        this.doAppending();
      }
    }
  }, {
    key: 'onBufferAppendFail',
    value: function onBufferAppendFail(data) {
      _logger.logger.error('sourceBuffer error:' + data.event);
      // according to http://www.w3.org/TR/media-source/#sourcebuffer-append-error
      // this error might not always be fatal (it is fatal if decode error is set, in that case
      // it will be followed by a mediaElement error ...)
      this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.BUFFER_APPENDING_ERROR, fatal: false, frag: this.fragCurrent });
    }

    // on BUFFER_EOS mark matching sourcebuffer(s) as ended and trigger checkEos()

  }, {
    key: 'onBufferEos',
    value: function onBufferEos(data) {
      var sb = this.sourceBuffer;
      var dataType = data.type;
      for (var type in sb) {
        if (!dataType || type === dataType) {
          if (!sb[type].ended) {
            sb[type].ended = true;
            _logger.logger.log(type + ' sourceBuffer now EOS');
          }
        }
      }
      this.checkEos();
    }

    // if all source buffers are marked as ended, signal endOfStream() to MediaSource.

  }, {
    key: 'checkEos',
    value: function checkEos() {
      var sb = this.sourceBuffer,
          mediaSource = this.mediaSource;
      if (!mediaSource || mediaSource.readyState !== 'open') {
        this._needsEos = false;
        return;
      }
      for (var type in sb) {
        var sbobj = sb[type];
        if (!sbobj.ended) {
          return;
        }
        if (sbobj.updating) {
          this._needsEos = true;
          return;
        }
      }
      _logger.logger.log('all media data available, signal endOfStream() to MediaSource and stop loading fragment');
      //Notify the media element that it now has all of the media data
      try {
        mediaSource.endOfStream();
      } catch (e) {
        _logger.logger.warn('exception while calling mediaSource.endOfStream()');
      }
      this._needsEos = false;
    }
  }, {
    key: 'onBufferFlushing',
    value: function onBufferFlushing(data) {
      this.flushRange.push({ start: data.startOffset, end: data.endOffset, type: data.type });
      // attempt flush immediatly
      this.flushBufferCounter = 0;
      this.doFlush();
    }
  }, {
    key: 'onLevelUpdated',
    value: function onLevelUpdated(event) {
      var details = event.details;
      if (details.fragments.length === 0) {
        return;
      }
      this._levelDuration = details.totalduration + details.fragments[0].start;
      this.updateMediaElementDuration();
    }

    // https://github.com/dailymotion/hls.js/issues/355

  }, {
    key: 'updateMediaElementDuration',
    value: function updateMediaElementDuration() {
      var media = this.media,
          mediaSource = this.mediaSource,
          sourceBuffer = this.sourceBuffer,
          levelDuration = this._levelDuration;
      if (levelDuration === null || !media || !mediaSource || !sourceBuffer || media.readyState === 0 || mediaSource.readyState !== 'open') {
        return;
      }
      for (var type in sourceBuffer) {
        if (sourceBuffer[type].updating) {
          // can't set duration whilst a buffer is updating
          return;
        }
      }
      if (this._msDuration === null) {
        // initialise to the value that the media source is reporting
        this._msDuration = mediaSource.duration;
      }
      // levelDuration was the last value we set.
      // not using mediaSource.duration as the browser may tweak this value
      // only update mediasource duration if its value increase, this is to avoid
      // flushing already buffered portion when switching between quality level
      if (levelDuration > this._msDuration && levelDuration > media.duration) {
        _logger.logger.log('Updating mediasource duration to ' + levelDuration.toFixed(3));
        this._msDuration = mediaSource.duration = levelDuration;
      }
    }
  }, {
    key: 'doFlush',
    value: function doFlush() {
      // loop through all buffer ranges to flush
      while (this.flushRange.length) {
        var range = this.flushRange[0];
        // flushBuffer will abort any buffer append in progress and flush Audio/Video Buffer
        if (this.flushBuffer(range.start, range.end, range.type)) {
          // range flushed, remove from flush array
          this.flushRange.shift();
          this.flushBufferCounter = 0;
        } else {
          this._needsFlush = true;
          // avoid looping, wait for SB update end to retrigger a flush
          return;
        }
      }
      if (this.flushRange.length === 0) {
        // everything flushed
        this._needsFlush = false;

        // let's recompute this.appended, which is used to avoid flush looping
        var appended = 0;
        var sourceBuffer = this.sourceBuffer;
        try {
          for (var type in sourceBuffer) {
            appended += sourceBuffer[type].buffered.length;
          }
        } catch (error) {
          // error could be thrown while accessing buffered, in case sourcebuffer has already been removed from MediaSource
          // this is harmess at this stage, catch this to avoid reporting an internal exception
          _logger.logger.error('error while accessing sourceBuffer.buffered');
        }
        this.appended = appended;
        this.hls.trigger(_events2.default.BUFFER_FLUSHED);
      }
    }
  }, {
    key: 'doAppending',
    value: function doAppending() {
      var hls = this.hls,
          sourceBuffer = this.sourceBuffer,
          segments = this.segments;
      if (Object.keys(sourceBuffer).length) {
        if (this.media.error) {
          this.segments = [];
          _logger.logger.error('trying to append although a media error occured, flush segment and abort');
          return;
        }
        if (this.appending) {
          //logger.log(`sb appending in progress`);
          return;
        }
        if (segments && segments.length) {
          var segment = segments.shift();
          try {
            var type = segment.type,
                sb = sourceBuffer[type];
            if (sb) {
              if (!sb.updating) {
                // reset sourceBuffer ended flag before appending segment
                sb.ended = false;
                //logger.log(`appending ${segment.content} ${type} SB, size:${segment.data.length}, ${segment.parent}`);
                this.parent = segment.parent;
                sb.appendBuffer(segment.data);
                this.appendError = 0;
                this.appended++;
                this.appending = true;
              } else {
                segments.unshift(segment);
              }
            } else {
              // in case we don't have any source buffer matching with this segment type,
              // it means that Mediasource fails to create sourcebuffer
              // discard this segment, and trigger update end
              this.onSBUpdateEnd();
            }
          } catch (err) {
            // in case any error occured while appending, put back segment in segments table
            _logger.logger.error('error while trying to append buffer:' + err.message);
            segments.unshift(segment);
            var event = { type: _errors.ErrorTypes.MEDIA_ERROR };
            if (err.code !== 22) {
              if (this.appendError) {
                this.appendError++;
              } else {
                this.appendError = 1;
              }
              event.details = _errors.ErrorDetails.BUFFER_APPEND_ERROR;
              event.frag = this.fragCurrent;
              /* with UHD content, we could get loop of quota exceeded error until
                browser is able to evict some data from sourcebuffer. retrying help recovering this
              */
              if (this.appendError > hls.config.appendErrorMaxRetry) {
                _logger.logger.log('fail ' + hls.config.appendErrorMaxRetry + ' times to append segment in sourceBuffer');
                segments = [];
                event.fatal = true;
                hls.trigger(_events2.default.ERROR, event);
                return;
              } else {
                event.fatal = false;
                hls.trigger(_events2.default.ERROR, event);
              }
            } else {
              // QuotaExceededError: http://www.w3.org/TR/html5/infrastructure.html#quotaexceedederror
              // let's stop appending any segments, and report BUFFER_FULL_ERROR error
              this.segments = [];
              event.details = _errors.ErrorDetails.BUFFER_FULL_ERROR;
              hls.trigger(_events2.default.ERROR, event);
              return;
            }
          }
        }
      }
    }

    /*
      flush specified buffered range,
      return true once range has been flushed.
      as sourceBuffer.remove() is asynchronous, flushBuffer will be retriggered on sourceBuffer update end
    */

  }, {
    key: 'flushBuffer',
    value: function flushBuffer(startOffset, endOffset, typeIn) {
      var sb,
          i,
          bufStart,
          bufEnd,
          flushStart,
          flushEnd,
          sourceBuffer = this.sourceBuffer;
      if (Object.keys(sourceBuffer).length) {
        _logger.logger.log('flushBuffer,pos/start/end: ' + this.media.currentTime + '/' + startOffset + '/' + endOffset);
        // safeguard to avoid infinite looping : don't try to flush more than the nb of appended segments
        if (this.flushBufferCounter < this.appended) {
          for (var type in sourceBuffer) {
            // check if sourcebuffer type is defined (typeIn): if yes, let's only flush this one
            // if no, let's flush all sourcebuffers
            if (typeIn && type !== typeIn) {
              continue;
            }
            sb = sourceBuffer[type];
            // we are going to flush buffer, mark source buffer as 'not ended'
            sb.ended = false;
            if (!sb.updating) {
              try {
                for (i = 0; i < sb.buffered.length; i++) {
                  bufStart = sb.buffered.start(i);
                  bufEnd = sb.buffered.end(i);
                  // workaround firefox not able to properly flush multiple buffered range.
                  if (navigator.userAgent.toLowerCase().indexOf('firefox') !== -1 && endOffset === Number.POSITIVE_INFINITY) {
                    flushStart = startOffset;
                    flushEnd = endOffset;
                  } else {
                    flushStart = Math.max(bufStart, startOffset);
                    flushEnd = Math.min(bufEnd, endOffset);
                  }
                  /* sometimes sourcebuffer.remove() does not flush
                     the exact expected time range.
                     to avoid rounding issues/infinite loop,
                     only flush buffer range of length greater than 500ms.
                  */
                  if (Math.min(flushEnd, bufEnd) - flushStart > 0.5) {
                    this.flushBufferCounter++;
                    _logger.logger.log('flush ' + type + ' [' + flushStart + ',' + flushEnd + '], of [' + bufStart + ',' + bufEnd + '], pos:' + this.media.currentTime);
                    sb.remove(flushStart, flushEnd);
                    return false;
                  }
                }
              } catch (e) {
                _logger.logger.warn('exception while accessing sourcebuffer, it might have been removed from MediaSource');
              }
            } else {
              //logger.log('abort ' + type + ' append in progress');
              // this will abort any appending in progress
              //sb.abort();
              _logger.logger.warn('cannot flush, sb updating in progress');
              return false;
            }
          }
        } else {
          _logger.logger.warn('abort flushing too many retries');
        }
        _logger.logger.log('buffer flushed');
      }
      // everything flushed !
      return true;
    }
  }]);

  return BufferController;
}(_eventHandler2.default);

exports.default = BufferController;

},{"../errors":28,"../event-handler":29,"../events":30,"../utils/logger":47}],8:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _eventHandler = require('../event-handler');

var _eventHandler2 = _interopRequireDefault(_eventHandler);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * cap stream level to media size dimension controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

var CapLevelController = function (_EventHandler) {
  _inherits(CapLevelController, _EventHandler);

  function CapLevelController(hls) {
    _classCallCheck(this, CapLevelController);

    return _possibleConstructorReturn(this, (CapLevelController.__proto__ || Object.getPrototypeOf(CapLevelController)).call(this, hls, _events2.default.FPS_DROP_LEVEL_CAPPING, _events2.default.MEDIA_ATTACHING, _events2.default.MANIFEST_PARSED));
  }

  _createClass(CapLevelController, [{
    key: 'destroy',
    value: function destroy() {
      if (this.hls.config.capLevelToPlayerSize) {
        this.media = this.restrictedLevels = null;
        this.autoLevelCapping = Number.POSITIVE_INFINITY;
        if (this.timer) {
          this.timer = clearInterval(this.timer);
        }
      }
    }
  }, {
    key: 'onFpsDropLevelCapping',
    value: function onFpsDropLevelCapping(data) {
      if (!this.restrictedLevels) {
        this.restrictedLevels = [];
      }
      if (!this.isLevelRestricted(data.droppedLevel)) {
        this.restrictedLevels.push(data.droppedLevel);
      }
    }
  }, {
    key: 'onMediaAttaching',
    value: function onMediaAttaching(data) {
      this.media = data.media instanceof HTMLVideoElement ? data.media : null;
    }
  }, {
    key: 'onManifestParsed',
    value: function onManifestParsed(data) {
      if (this.hls.config.capLevelToPlayerSize) {
        this.autoLevelCapping = Number.POSITIVE_INFINITY;
        this.levels = data.levels;
        this.hls.firstLevel = this.getMaxLevel(data.firstLevel);
        clearInterval(this.timer);
        this.timer = setInterval(this.detectPlayerSize.bind(this), 1000);
        this.detectPlayerSize();
      }
    }
  }, {
    key: 'detectPlayerSize',
    value: function detectPlayerSize() {
      if (this.media) {
        var levelsLength = this.levels ? this.levels.length : 0;
        if (levelsLength) {
          this.hls.autoLevelCapping = this.getMaxLevel(levelsLength - 1);
          if (this.hls.autoLevelCapping > this.autoLevelCapping) {
            // if auto level capping has a higher value for the previous one, flush the buffer using nextLevelSwitch
            // usually happen when the user go to the fullscreen mode.
            this.hls.streamController.nextLevelSwitch();
          }
          this.autoLevelCapping = this.hls.autoLevelCapping;
        }
      }
    }

    /*
    * returns level should be the one with the dimensions equal or greater than the media (player) dimensions (so the video will be downscaled)
    */

  }, {
    key: 'getMaxLevel',
    value: function getMaxLevel(capLevelIndex) {
      var result = 0,
          i = void 0,
          level = void 0,
          mWidth = this.mediaWidth,
          mHeight = this.mediaHeight,
          lWidth = 0,
          lHeight = 0;

      for (i = 0; i <= capLevelIndex; i++) {
        level = this.levels[i];
        if (this.isLevelRestricted(i)) {
          break;
        }
        result = i;
        lWidth = level.width;
        lHeight = level.height;
        if (mWidth <= lWidth || mHeight <= lHeight) {
          break;
        }
      }
      return result;
    }
  }, {
    key: 'isLevelRestricted',
    value: function isLevelRestricted(level) {
      return this.restrictedLevels && this.restrictedLevels.indexOf(level) !== -1 ? true : false;
    }
  }, {
    key: 'contentScaleFactor',
    get: function get() {
      var pixelRatio = 1;
      try {
        pixelRatio = window.devicePixelRatio;
      } catch (e) {}
      return pixelRatio;
    }
  }, {
    key: 'mediaWidth',
    get: function get() {
      var width = void 0;
      if (this.media) {
        width = this.media.width || this.media.clientWidth || this.media.offsetWidth;
        width *= this.contentScaleFactor;
      }
      return width;
    }
  }, {
    key: 'mediaHeight',
    get: function get() {
      var height = void 0;
      if (this.media) {
        height = this.media.height || this.media.clientHeight || this.media.offsetHeight;
        height *= this.contentScaleFactor;
      }
      return height;
    }
  }]);

  return CapLevelController;
}(_eventHandler2.default);

exports.default = CapLevelController;

},{"../event-handler":29,"../events":30}],9:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * EWMA Bandwidth Estimator
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *  - heavily inspired from shaka-player
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Tracks bandwidth samples and estimates available bandwidth.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Based on the minimum of two exponentially-weighted moving averages with
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * different half-lives.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */

var _ewma = require('../utils/ewma');

var _ewma2 = _interopRequireDefault(_ewma);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var EwmaBandWidthEstimator = function () {
  function EwmaBandWidthEstimator(hls, slow, fast, defaultEstimate) {
    _classCallCheck(this, EwmaBandWidthEstimator);

    this.hls = hls;
    this.defaultEstimate_ = defaultEstimate;
    this.minWeight_ = 0.001;
    this.minDelayMs_ = 50;
    this.slow_ = new _ewma2.default(slow);
    this.fast_ = new _ewma2.default(fast);
  }

  _createClass(EwmaBandWidthEstimator, [{
    key: 'sample',
    value: function sample(durationMs, numBytes) {
      durationMs = Math.max(durationMs, this.minDelayMs_);
      var bandwidth = 8000 * numBytes / durationMs,

      //console.log('instant bw:'+ Math.round(bandwidth));
      // we weight sample using loading duration....
      weight = durationMs / 1000;
      this.fast_.sample(weight, bandwidth);
      this.slow_.sample(weight, bandwidth);
    }
  }, {
    key: 'canEstimate',
    value: function canEstimate() {
      var fast = this.fast_;
      return fast && fast.getTotalWeight() >= this.minWeight_;
    }
  }, {
    key: 'getEstimate',
    value: function getEstimate() {
      if (this.canEstimate()) {
        //console.log('slow estimate:'+ Math.round(this.slow_.getEstimate()));
        //console.log('fast estimate:'+ Math.round(this.fast_.getEstimate()));
        // Take the minimum of these two estimates.  This should have the effect of
        // adapting down quickly, but up more slowly.
        return Math.min(this.fast_.getEstimate(), this.slow_.getEstimate());
      } else {
        return this.defaultEstimate_;
      }
    }
  }, {
    key: 'destroy',
    value: function destroy() {}
  }]);

  return EwmaBandWidthEstimator;
}();

exports.default = EwmaBandWidthEstimator;

},{"../utils/ewma":46}],10:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _eventHandler = require('../event-handler');

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _logger = require('../utils/logger');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * FPS Controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

var FPSController = function (_EventHandler) {
  _inherits(FPSController, _EventHandler);

  function FPSController(hls) {
    _classCallCheck(this, FPSController);

    return _possibleConstructorReturn(this, (FPSController.__proto__ || Object.getPrototypeOf(FPSController)).call(this, hls, _events2.default.MEDIA_ATTACHING));
  }

  _createClass(FPSController, [{
    key: 'destroy',
    value: function destroy() {
      if (this.timer) {
        clearInterval(this.timer);
      }
      this.isVideoPlaybackQualityAvailable = false;
    }
  }, {
    key: 'onMediaAttaching',
    value: function onMediaAttaching(data) {
      if (this.hls.config.capLevelOnFPSDrop) {
        this.video = data.media instanceof HTMLVideoElement ? data.media : null;
        if (typeof this.video.getVideoPlaybackQuality === 'function') {
          this.isVideoPlaybackQualityAvailable = true;
        }
        clearInterval(this.timer);
        this.timer = setInterval(this.checkFPSInterval.bind(this), this.hls.config.fpsDroppedMonitoringPeriod);
      }
    }
  }, {
    key: 'checkFPS',
    value: function checkFPS(video, decodedFrames, droppedFrames) {
      var currentTime = performance.now();
      if (decodedFrames) {
        if (this.lastTime) {
          var currentPeriod = currentTime - this.lastTime,
              currentDropped = droppedFrames - this.lastDroppedFrames,
              currentDecoded = decodedFrames - this.lastDecodedFrames,
              droppedFPS = 1000 * currentDropped / currentPeriod;
          this.hls.trigger(_events2.default.FPS_DROP, { currentDropped: currentDropped, currentDecoded: currentDecoded, totalDroppedFrames: droppedFrames });
          if (droppedFPS > 0) {
            //logger.log('checkFPS : droppedFPS/decodedFPS:' + droppedFPS/(1000 * currentDecoded / currentPeriod));
            if (currentDropped > this.hls.config.fpsDroppedMonitoringThreshold * currentDecoded) {
              var currentLevel = this.hls.currentLevel;
              _logger.logger.warn('drop FPS ratio greater than max allowed value for currentLevel: ' + currentLevel);
              if (currentLevel > 0 && (this.hls.autoLevelCapping === -1 || this.hls.autoLevelCapping >= currentLevel)) {
                currentLevel = currentLevel - 1;
                this.hls.trigger(_events2.default.FPS_DROP_LEVEL_CAPPING, { level: currentLevel, droppedLevel: this.hls.currentLevel });
                this.hls.autoLevelCapping = currentLevel;
                this.hls.streamController.nextLevelSwitch();
              }
            }
          }
        }
        this.lastTime = currentTime;
        this.lastDroppedFrames = droppedFrames;
        this.lastDecodedFrames = decodedFrames;
      }
    }
  }, {
    key: 'checkFPSInterval',
    value: function checkFPSInterval() {
      if (this.video) {
        if (this.isVideoPlaybackQualityAvailable) {
          var videoPlaybackQuality = this.video.getVideoPlaybackQuality();
          this.checkFPS(this.video, videoPlaybackQuality.totalVideoFrames, videoPlaybackQuality.droppedVideoFrames);
        } else {
          this.checkFPS(this.video, this.video.webkitDecodedFrameCount, this.video.webkitDroppedFrameCount);
        }
      }
    }
  }]);

  return FPSController;
}(_eventHandler2.default);

exports.default = FPSController;

},{"../event-handler":29,"../events":30,"../utils/logger":47}],11:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _eventHandler = require('../event-handler');

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _logger = require('../utils/logger');

var _errors = require('../errors');

var _bufferHelper = require('../helper/buffer-helper');

var _bufferHelper2 = _interopRequireDefault(_bufferHelper);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Level Controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

var LevelController = function (_EventHandler) {
  _inherits(LevelController, _EventHandler);

  function LevelController(hls) {
    _classCallCheck(this, LevelController);

    var _this = _possibleConstructorReturn(this, (LevelController.__proto__ || Object.getPrototypeOf(LevelController)).call(this, hls, _events2.default.MANIFEST_LOADED, _events2.default.LEVEL_LOADED, _events2.default.FRAG_LOADED, _events2.default.ERROR));

    _this.ontick = _this.tick.bind(_this);
    _this._manualLevel = _this._autoLevelCapping = -1;
    return _this;
  }

  _createClass(LevelController, [{
    key: 'destroy',
    value: function destroy() {
      if (this.timer) {
        clearTimeout(this.timer);
        this.timer = null;
      }
      this._manualLevel = -1;
    }
  }, {
    key: 'startLoad',
    value: function startLoad() {
      this.canload = true;
      var levels = this._levels;
      // clean up live level details to force reload them, and reset load errors
      if (levels) {
        levels.forEach(function (level) {
          level.loadError = 0;
          var levelDetails = level.details;
          if (levelDetails && levelDetails.live) {
            level.details = undefined;
          }
        });
      }
      // speed up live playlist refresh if timer exists
      if (this.timer) {
        this.tick();
      }
    }
  }, {
    key: 'stopLoad',
    value: function stopLoad() {
      this.canload = false;
    }
  }, {
    key: 'onManifestLoaded',
    value: function onManifestLoaded(data) {
      var levels0 = [],
          levels = [],
          bitrateStart,
          bitrateSet = {},
          videoCodecFound = false,
          audioCodecFound = false,
          hls = this.hls,
          brokenmp4inmp3 = /chrome|firefox/.test(navigator.userAgent.toLowerCase()),
          checkSupported = function checkSupported(type, codec) {
        return MediaSource.isTypeSupported(type + '/mp4;codecs=' + codec);
      };

      // regroup redundant level together
      data.levels.forEach(function (level) {
        if (level.videoCodec) {
          videoCodecFound = true;
        }
        // erase audio codec info if browser does not support mp4a.40.34. demuxer will autodetect codec and fallback to mpeg/audio
        if (brokenmp4inmp3 && level.audioCodec && level.audioCodec.indexOf('mp4a.40.34') !== -1) {
          level.audioCodec = undefined;
        }
        if (level.audioCodec || level.attrs && level.attrs.AUDIO) {
          audioCodecFound = true;
        }
        var redundantLevelId = bitrateSet[level.bitrate];
        if (redundantLevelId === undefined) {
          bitrateSet[level.bitrate] = levels0.length;
          level.url = [level.url];
          level.urlId = 0;
          levels0.push(level);
        } else {
          levels0[redundantLevelId].url.push(level.url);
        }
      });

      // remove audio-only level if we also have levels with audio+video codecs signalled
      if (videoCodecFound && audioCodecFound) {
        levels0.forEach(function (level) {
          if (level.videoCodec) {
            levels.push(level);
          }
        });
      } else {
        levels = levels0;
      }
      // only keep level with supported audio/video codecs
      levels = levels.filter(function (level) {
        var audioCodec = level.audioCodec,
            videoCodec = level.videoCodec;
        return (!audioCodec || checkSupported('audio', audioCodec)) && (!videoCodec || checkSupported('video', videoCodec));
      });

      if (levels.length) {
        // start bitrate is the first bitrate of the manifest
        bitrateStart = levels[0].bitrate;
        // sort level on bitrate
        levels.sort(function (a, b) {
          return a.bitrate - b.bitrate;
        });
        this._levels = levels;
        // find index of first level in sorted levels
        for (var i = 0; i < levels.length; i++) {
          if (levels[i].bitrate === bitrateStart) {
            this._firstLevel = i;
            _logger.logger.log('manifest loaded,' + levels.length + ' level(s) found, first bitrate:' + bitrateStart);
            break;
          }
        }
        hls.trigger(_events2.default.MANIFEST_PARSED, { levels: levels, firstLevel: this._firstLevel, stats: data.stats, audio: audioCodecFound, video: videoCodecFound, altAudio: data.audioTracks.length > 0 });
      } else {
        hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.MANIFEST_INCOMPATIBLE_CODECS_ERROR, fatal: true, url: hls.url, reason: 'no level with compatible codecs found in manifest' });
      }
      return;
    }
  }, {
    key: 'setLevelInternal',
    value: function setLevelInternal(newLevel) {
      var levels = this._levels;
      // check if level idx is valid
      if (newLevel >= 0 && newLevel < levels.length) {
        // stopping live reloading timer if any
        if (this.timer) {
          clearTimeout(this.timer);
          this.timer = null;
        }
        if (this._level !== newLevel) {
          _logger.logger.log('switching to level ' + newLevel);
          this._level = newLevel;
          this.hls.trigger(_events2.default.LEVEL_SWITCH, { level: newLevel });
        }
        var level = levels[newLevel],
            levelDetails = level.details;
        // check if we need to load playlist for this level
        if (!levelDetails || levelDetails.live === true) {
          // level not retrieved yet, or live playlist we need to (re)load it
          var urlId = level.urlId;
          this.hls.trigger(_events2.default.LEVEL_LOADING, { url: level.url[urlId], level: newLevel, id: urlId });
        }
      } else {
        // invalid level id given, trigger error
        this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.OTHER_ERROR, details: _errors.ErrorDetails.LEVEL_SWITCH_ERROR, level: newLevel, fatal: false, reason: 'invalid level idx' });
      }
    }
  }, {
    key: 'onError',
    value: function onError(data) {
      if (data.fatal) {
        return;
      }

      var details = data.details,
          hls = this.hls,
          levelId = void 0,
          level = void 0,
          levelError = false,
          abrController = hls.abrController,
          minAutoLevel = abrController.minAutoLevel;
      var removeLevel = false;
      // try to recover not fatal errors
      switch (details) {
        case _errors.ErrorDetails.FRAG_LOAD_ERROR:
        case _errors.ErrorDetails.FRAG_LOAD_TIMEOUT:
        case _errors.ErrorDetails.FRAG_LOOP_LOADING_ERROR:
        case _errors.ErrorDetails.KEY_LOAD_ERROR:
        case _errors.ErrorDetails.KEY_LOAD_TIMEOUT:
          levelId = data.frag.level;
          break;
        case _errors.ErrorDetails.LEVEL_LOAD_ERROR:
        case _errors.ErrorDetails.LEVEL_LOAD_TIMEOUT:
          levelId = data.context.level;
          levelError = true;
          break;
        case _errors.ErrorDetails.REMUX_ALLOC_ERROR:
          levelId = data.level;
          break;
        case _errors.ErrorDetails.MANIFEST_EMPTY_ERROR:
          levelId = data.context.level;
          levelError = true;
          removeLevel = true;
          break;
        default:
          break;
      }
      /* try to switch to a redundant stream if any available.
       * if no redundant stream available, emergency switch down (if in auto mode and current level not 0)
       * otherwise, we cannot recover this network error ...
       */
      if (levelId !== undefined) {
        level = this._levels[levelId];
        if (!level.loadError) {
          level.loadError = 1;
        } else {
          level.loadError++;
        }
        // if any redundant streams available and if we haven't try them all (level.loadError is reseted on successful frag/level load.
        // if level.loadError reaches nbRedundantLevel it means that we tried them all, no hope  => let's switch down
        var nbRedundantLevel = level.url.length;
        if (nbRedundantLevel > 1 && level.loadError < nbRedundantLevel) {
          level.urlId = (level.urlId + 1) % nbRedundantLevel;
          level.details = undefined;
          _logger.logger.warn('level controller,' + details + ' for level ' + levelId + ': switching to redundant stream id ' + level.urlId);
        } else {
          if (removeLevel) {
            _logger.logger.warn('Bad level encountered, removing & forcing to auto mode');
            this._levels = this.levels.filter(function (l, index) {
              return index !== levelId;
            });
            hls.currentLevel = -1;
            hls.trigger(_events2.default.LEVEL_REMOVED, { level: levelId });
          }
          // we could try to recover if in auto mode and current level not lowest level (0)
          var recoverable = this._manualLevel === -1 && levelId;
          if (recoverable) {
            _logger.logger.warn('level controller,' + details + ': switch-down for next fragment');
            abrController.nextAutoLevel = Math.max(minAutoLevel, levelId - 1);
          } else if (level && level.details && level.details.live) {
            _logger.logger.warn('level controller,' + details + ' on live stream, discard');
            if (levelError) {
              // reset this._level so that another call to set level() will retrigger a frag load
              this._level = undefined;
            }
            // other errors are handled by stream controller
          } else if (details === _errors.ErrorDetails.LEVEL_LOAD_ERROR || details === _errors.ErrorDetails.LEVEL_LOAD_TIMEOUT) {
            var media = hls.media,

            // 0.5 : tolerance needed as some browsers stalls playback before reaching buffered end
            mediaBuffered = media && _bufferHelper2.default.isBuffered(media, media.currentTime) && _bufferHelper2.default.isBuffered(media, media.currentTime + 0.5);
            if (mediaBuffered) {
              var retryDelay = hls.config.levelLoadingRetryDelay;
              _logger.logger.warn('level controller,' + details + ', but media buffered, retry in ' + retryDelay + 'ms');
              this.timer = setTimeout(this.ontick, retryDelay);
            } else {
              _logger.logger.error('cannot recover ' + details + ' error');
              this._level = undefined;
              // stopping live reloading timer if any
              if (this.timer) {
                clearTimeout(this.timer);
                this.timer = null;
              }
              // redispatch same error but with fatal set to true
              data.fatal = true;
              hls.trigger(_events2.default.ERROR, data);
            }
          }
        }
      }
    }

    // reset level load error counter on successful frag loaded

  }, {
    key: 'onFragLoaded',
    value: function onFragLoaded(data) {
      var fragLoaded = data.frag;
      if (fragLoaded && fragLoaded.type === 'main') {
        var level = this._levels[fragLoaded.level];
        if (level) {
          level.loadError = 0;
        }
      }
    }
  }, {
    key: 'onLevelLoaded',
    value: function onLevelLoaded(data) {
      var levelId = data.level;
      // only process level loaded events matching with expected level
      if (levelId === this._level) {
        var curLevel = this._levels[levelId];
        // reset level load error counter on successful level loaded
        curLevel.loadError = 0;
        var newDetails = data.details;
        // if current playlist is a live playlist, arm a timer to reload it
        if (newDetails.live) {
          var reloadInterval = 1000 * (newDetails.averagetargetduration ? newDetails.averagetargetduration : newDetails.targetduration),
              _curLevel = this._levels[data.level],
              curDetails = _curLevel.details;
          if (curDetails && newDetails.endSN === curDetails.endSN) {
            // follow HLS Spec, If the client reloads a Playlist file and finds that it has not
            // changed then it MUST wait for a period of one-half the target
            // duration before retrying.
            reloadInterval /= 2;
            _logger.logger.log('same live playlist, reload twice faster');
          }
          // decrement reloadInterval with level loading delay
          reloadInterval -= performance.now() - data.stats.trequest;
          // in any case, don't reload more than every second
          reloadInterval = Math.max(1000, Math.round(reloadInterval));
          _logger.logger.log('live playlist, reload in ' + reloadInterval + ' ms');
          this.timer = setTimeout(this.ontick, reloadInterval);
        } else {
          this.timer = null;
        }
      }
    }
  }, {
    key: 'tick',
    value: function tick() {
      var levelId = this._level;
      if (levelId !== undefined && this.canload) {
        var level = this._levels[levelId],
            urlId = level.urlId;
        this.hls.trigger(_events2.default.LEVEL_LOADING, { url: level.url[urlId], level: levelId, id: urlId });
      }
    }
  }, {
    key: 'levels',
    get: function get() {
      return this._levels;
    }
  }, {
    key: 'level',
    get: function get() {
      return this._level;
    },
    set: function set(newLevel) {
      var levels = this._levels;
      if (levels && levels.length > newLevel) {
        if (this._level !== newLevel || levels[newLevel].details === undefined) {
          this.setLevelInternal(newLevel);
        }
      }
    }
  }, {
    key: 'manualLevel',
    get: function get() {
      return this._manualLevel;
    },
    set: function set(newLevel) {
      this._manualLevel = newLevel;
      if (this._startLevel === undefined) {
        this._startLevel = newLevel;
      }
      if (newLevel !== -1) {
        this.level = newLevel;
      }
    }
  }, {
    key: 'firstLevel',
    get: function get() {
      return this._firstLevel;
    },
    set: function set(newLevel) {
      this._firstLevel = newLevel;
    }
  }, {
    key: 'startLevel',
    get: function get() {
      // hls.startLevel takes precedence over config.startLevel
      // if none of these values are defined, fallback on this._firstLevel (first quality level appearing in variant manifest)
      if (this._startLevel === undefined) {
        var configStartLevel = this.hls.config.startLevel;
        if (configStartLevel !== undefined) {
          return configStartLevel;
        } else {
          return this._firstLevel;
        }
      } else {
        return this._startLevel;
      }
    },
    set: function set(newLevel) {
      // if not in autostart level, ensure startLevel is greater than minAutoLevel
      if (newLevel !== -1) {
        newLevel = Math.max(newLevel, this.hls.abrController.minAutoLevel);
      }
      this._startLevel = newLevel;
    }
  }, {
    key: 'nextLoadLevel',
    get: function get() {
      if (this._manualLevel !== -1) {
        return this._manualLevel;
      } else {
        return this.hls.abrController.nextAutoLevel;
      }
    },
    set: function set(nextLevel) {
      this.level = nextLevel;
      if (this._manualLevel === -1) {
        this.hls.abrController.nextAutoLevel = nextLevel;
      }
    }
  }]);

  return LevelController;
}(_eventHandler2.default);

exports.default = LevelController;

},{"../errors":28,"../event-handler":29,"../events":30,"../helper/buffer-helper":32,"../utils/logger":47}],12:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _binarySearch = require('../utils/binary-search');

var _binarySearch2 = _interopRequireDefault(_binarySearch);

var _bufferHelper = require('../helper/buffer-helper');

var _bufferHelper2 = _interopRequireDefault(_bufferHelper);

var _demuxer = require('../demux/demuxer');

var _demuxer2 = _interopRequireDefault(_demuxer);

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _eventHandler = require('../event-handler');

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _levelHelper = require('../helper/level-helper');

var _levelHelper2 = _interopRequireDefault(_levelHelper);

var _timeRanges = require('../utils/timeRanges');

var _timeRanges2 = _interopRequireDefault(_timeRanges);

var _errors = require('../errors');

var _logger = require('../utils/logger');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Stream Controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

var State = {
  STOPPED: 'STOPPED',
  IDLE: 'IDLE',
  KEY_LOADING: 'KEY_LOADING',
  FRAG_LOADING: 'FRAG_LOADING',
  FRAG_LOADING_WAITING_RETRY: 'FRAG_LOADING_WAITING_RETRY',
  WAITING_LEVEL: 'WAITING_LEVEL',
  PARSING: 'PARSING',
  PARSED: 'PARSED',
  BUFFER_FLUSHING: 'BUFFER_FLUSHING',
  ENDED: 'ENDED',
  ERROR: 'ERROR'
};

var StreamController = function (_EventHandler) {
  _inherits(StreamController, _EventHandler);

  function StreamController(hls) {
    _classCallCheck(this, StreamController);

    var _this = _possibleConstructorReturn(this, (StreamController.__proto__ || Object.getPrototypeOf(StreamController)).call(this, hls, _events2.default.MEDIA_ATTACHED, _events2.default.MEDIA_DETACHING, _events2.default.MANIFEST_LOADING, _events2.default.MANIFEST_PARSED, _events2.default.LEVEL_LOADED, _events2.default.KEY_LOADED, _events2.default.FRAG_LOADED, _events2.default.FRAG_LOAD_EMERGENCY_ABORTED, _events2.default.FRAG_PARSING_INIT_SEGMENT, _events2.default.FRAG_PARSING_DATA, _events2.default.FRAG_PARSED, _events2.default.ERROR, _events2.default.AUDIO_TRACK_SWITCHING, _events2.default.AUDIO_TRACK_SWITCHED, _events2.default.BUFFER_CREATED, _events2.default.BUFFER_APPENDED, _events2.default.BUFFER_FLUSHED, _events2.default.LEVEL_REMOVED));

    _this.config = hls.config;
    _this.audioCodecSwap = false;
    _this.ticks = 0;
    _this.ontick = _this.tick.bind(_this);
    return _this;
  }

  _createClass(StreamController, [{
    key: 'destroy',
    value: function destroy() {
      this.stopLoad();
      if (this.timer) {
        clearInterval(this.timer);
        this.timer = null;
      }
      _eventHandler2.default.prototype.destroy.call(this);
      this.state = State.STOPPED;
    }
  }, {
    key: 'startLoad',
    value: function startLoad(startPosition) {
      if (this.levels) {
        var lastCurrentTime = this.lastCurrentTime,
            hls = this.hls;
        this.stopLoad();
        if (!this.timer) {
          this.timer = setInterval(this.ontick, 100);
        }
        this.level = -1;
        this.fragLoadError = 0;
        if (!this.startFragRequested) {
          // determine load level
          var startLevel = hls.startLevel;
          if (startLevel === -1) {
            // -1 : guess start Level by doing a bitrate test by loading first fragment of lowest quality level
            startLevel = 0;
            this.bitrateTest = true;
          }
          // set new level to playlist loader : this will trigger start level load
          // hls.nextLoadLevel remains until it is set to a new value or until a new frag is successfully loaded
          this.level = hls.nextLoadLevel = startLevel;
          this.loadedmetadata = false;
        }
        // if startPosition undefined but lastCurrentTime set, set startPosition to last currentTime
        if (lastCurrentTime > 0 && startPosition === -1) {
          _logger.logger.log('override startPosition with lastCurrentTime @' + lastCurrentTime.toFixed(3));
          startPosition = lastCurrentTime;
        }
        this.state = State.IDLE;
        this.nextLoadPosition = this.startPosition = this.lastCurrentTime = startPosition;
        this.tick();
      } else {
        _logger.logger.warn('cannot start loading as manifest not parsed yet');
        this.state = State.STOPPED;
      }
    }
  }, {
    key: 'stopLoad',
    value: function stopLoad() {
      var frag = this.fragCurrent;
      if (frag) {
        if (frag.loader) {
          frag.loader.abort();
        }
        this.fragCurrent = null;
      }
      this.fragPrevious = null;
      if (this.demuxer) {
        this.demuxer.destroy();
        this.demuxer = null;
      }
      this.state = State.STOPPED;
    }
  }, {
    key: 'tick',
    value: function tick() {
      this.ticks++;
      if (this.ticks === 1) {
        this.doTick();
        if (this.ticks > 1) {
          setTimeout(this.tick, 1);
        }
        this.ticks = 0;
      }
    }
  }, {
    key: 'doTick',
    value: function doTick() {
      switch (this.state) {
        case State.ERROR:
          //don't do anything in error state to avoid breaking further ...
          break;
        case State.BUFFER_FLUSHING:
          // in buffer flushing state, reset fragLoadError counter
          this.fragLoadError = 0;
          break;
        case State.IDLE:
          // when this returns false there was an error and we shall return immediatly
          // from current tick
          if (!this._doTickIdle()) {
            return;
          }
          break;
        case State.WAITING_LEVEL:
          var level = this.levels[this.level];
          // check if playlist is already loaded
          if (level && level.details) {
            this.state = State.IDLE;
          }
          break;
        case State.FRAG_LOADING_WAITING_RETRY:
          var now = performance.now();
          var retryDate = this.retryDate;
          // if current time is gt than retryDate, or if media seeking let's switch to IDLE state to retry loading
          if (!retryDate || now >= retryDate || this.media && this.media.seeking) {
            _logger.logger.log('mediaController: retryDate reached, switch back to IDLE state');
            this.state = State.IDLE;
          }
          break;
        case State.ERROR:
        case State.STOPPED:
        case State.FRAG_LOADING:
        case State.PARSING:
        case State.PARSED:
        case State.ENDED:
          break;
        default:
          break;
      }
      // check buffer
      this._checkBuffer();
      // check/update current fragment
      this._checkFragmentChanged();
    }

    // Ironically the "idle" state is the on we do the most logic in it seems ....
    // NOTE: Maybe we could rather schedule a check for buffer length after half of the currently
    //       played segment, or on pause/play/seek instead of naively checking every 100ms?

  }, {
    key: '_doTickIdle',
    value: function _doTickIdle() {
      var hls = this.hls,
          config = hls.config,
          media = this.media;

      // if video not attached AND
      // start fragment already requested OR start frag prefetch disable
      // exit loop
      // => if start level loaded and media not attached but start frag prefetch is enabled and start frag not requested yet, we will not exit loop
      if (this.levelLastLoaded !== undefined && !media && (this.startFragRequested || !config.startFragPrefetch)) {
        return true;
      }

      // if we have not yet loaded any fragment, start loading from start position
      var pos = 0;
      if (this.loadedmetadata) {
        pos = media.currentTime;
      } else if (this.nextLoadPosition) {
        pos = this.nextLoadPosition;
      }

      // determine next load level
      var level = hls.nextLoadLevel,
          levelInfo = this.levels[level],
          levelBitrate = levelInfo.bitrate,
          maxBufLen = void 0;

      // compute max Buffer Length that we could get from this load level, based on level bitrate. don't buffer more than 60 MB and more than 30s
      if (levelBitrate) {
        maxBufLen = Math.max(8 * config.maxBufferSize / levelBitrate, config.maxBufferLength);
      } else {
        maxBufLen = config.maxBufferLength;
      }
      maxBufLen = Math.min(maxBufLen, config.maxMaxBufferLength);

      // determine next candidate fragment to be loaded, based on current position and end of buffer position
      // ensure up to `config.maxMaxBufferLength` of buffer upfront

      var bufferInfo = _bufferHelper2.default.bufferInfo(this.mediaBuffer ? this.mediaBuffer : media, pos, config.maxBufferHole),
          bufferLen = bufferInfo.len;
      // Stay idle if we are still with buffer margins
      if (bufferLen >= maxBufLen) {
        return true;
      }

      // if buffer length is less than maxBufLen try to load a new fragment ...
      _logger.logger.trace('buffer length of ' + bufferLen.toFixed(3) + ' is below max of ' + maxBufLen.toFixed(3) + '. checking for more payload ...');

      // set next load level : this will trigger a playlist load if needed
      this.level = hls.nextLoadLevel = level;

      var levelDetails = levelInfo.details;
      // if level info not retrieved yet, switch state and wait for level retrieval
      // if live playlist, ensure that new playlist has been refreshed to avoid loading/try to load
      // a useless and outdated fragment (that might even introduce load error if it is already out of the live playlist)
      if (typeof levelDetails === 'undefined' || levelDetails.live && this.levelLastLoaded !== level) {
        this.state = State.WAITING_LEVEL;
        return true;
      }

      // we just got done loading the final fragment, check if we need to finalize media stream
      var fragPrevious = this.fragPrevious;
      if (!levelDetails.live && fragPrevious && fragPrevious.sn === levelDetails.endSN) {
        // if (we are not seeking AND current position is buffered) OR (if we are seeking but everything (almost) til the end is buffered), let's signal eos
        // we don't compare exactly media.duration === bufferInfo.end as there could be some subtle media duration difference when switching
        // between different renditions. using half frag duration should help cope with these cases.
        if (!media.seeking && bufferInfo.len || media.duration - bufferInfo.end <= fragPrevious.duration / 2) {
          // Finalize the media stream
          var data = {};
          if (this.altAudio) {
            data.type = 'video';
          }
          this.hls.trigger(_events2.default.BUFFER_EOS, data);
          this.state = State.ENDED;
          return true;
        }
      }

      // if we have the levelDetails for the selected variant, lets continue enrichen our stream (load keys/fragments or trigger EOS, etc..)
      return this._fetchPayloadOrEos({ pos: pos, bufferInfo: bufferInfo, levelDetails: levelDetails });
    }
  }, {
    key: '_fetchPayloadOrEos',
    value: function _fetchPayloadOrEos(_ref) {
      var pos = _ref.pos,
          bufferInfo = _ref.bufferInfo,
          levelDetails = _ref.levelDetails;

      var fragPrevious = this.fragPrevious,
          level = this.level,
          fragments = levelDetails.fragments,
          fragLen = fragments.length;

      // empty playlist
      if (fragLen === 0) {
        return false;
      }

      // find fragment index, contiguous with end of buffer position
      var start = fragments[0].start,
          end = fragments[fragLen - 1].start + fragments[fragLen - 1].duration,
          bufferEnd = bufferInfo.end,
          frag = void 0;

      // in case of live playlist we need to ensure that requested position is not located before playlist start
      if (levelDetails.live) {
        var initialLiveManifestSize = this.config.initialLiveManifestSize;
        if (fragLen < initialLiveManifestSize) {
          _logger.logger.warn('Can not start playback of a level, reason: not enough fragments ' + fragLen + ' < ' + initialLiveManifestSize);
          return false;
        }

        frag = this._ensureFragmentAtLivePoint({ levelDetails: levelDetails, bufferEnd: bufferEnd, start: start, end: end, fragPrevious: fragPrevious, fragments: fragments, fragLen: fragLen });
        // if it explicitely returns null don't load any fragment and exit function now
        if (frag === null) {
          return false;
        }
      } else {
        // VoD playlist: if bufferEnd before start of playlist, load first fragment
        if (bufferEnd < start) {
          frag = fragments[0];
        }
      }
      if (!frag) {
        frag = this._findFragment({ start: start, fragPrevious: fragPrevious, fragLen: fragLen, fragments: fragments, bufferEnd: bufferEnd, end: end, levelDetails: levelDetails });
      }
      if (frag) {
        return this._loadFragmentOrKey({ frag: frag, level: level, levelDetails: levelDetails, pos: pos, bufferEnd: bufferEnd });
      }
      return true;
    }
  }, {
    key: '_ensureFragmentAtLivePoint',
    value: function _ensureFragmentAtLivePoint(_ref2) {
      var levelDetails = _ref2.levelDetails,
          bufferEnd = _ref2.bufferEnd,
          start = _ref2.start,
          end = _ref2.end,
          fragPrevious = _ref2.fragPrevious,
          fragments = _ref2.fragments,
          fragLen = _ref2.fragLen;

      var config = this.hls.config,
          media = this.media;

      var frag = void 0;

      // check if requested position is within seekable boundaries :
      //logger.log(`start/pos/bufEnd/seeking:${start.toFixed(3)}/${pos.toFixed(3)}/${bufferEnd.toFixed(3)}/${this.media.seeking}`);
      var maxLatency = config.liveMaxLatencyDuration !== undefined ? config.liveMaxLatencyDuration : config.liveMaxLatencyDurationCount * levelDetails.targetduration;

      if (bufferEnd < Math.max(start, end - maxLatency)) {
        var liveSyncPosition = this.liveSyncPosition = this.computeLivePosition(start, levelDetails);
        _logger.logger.log('buffer end: ' + bufferEnd.toFixed(3) + ' is located too far from the end of live sliding playlist, reset currentTime to : ' + liveSyncPosition.toFixed(3));
        bufferEnd = liveSyncPosition;
        if (media && media.readyState && media.duration > liveSyncPosition) {
          media.currentTime = liveSyncPosition;
        }
      }

      // if end of buffer greater than live edge, don't load any fragment
      // this could happen if live playlist intermittently slides in the past.
      // level 1 loaded [182580161,182580167]
      // level 1 loaded [182580162,182580169]
      // Loading 182580168 of [182580162 ,182580169],level 1 ..
      // Loading 182580169 of [182580162 ,182580169],level 1 ..
      // level 1 loaded [182580162,182580168] <============= here we should have bufferEnd > end. in that case break to avoid reloading 182580168
      // level 1 loaded [182580164,182580171]
      //
      // don't return null in case media not loaded yet (readystate === 0)
      if (levelDetails.PTSKnown && bufferEnd > end && media && media.readyState) {
        return null;
      }

      if (this.startFragRequested && !levelDetails.PTSKnown) {
        /* we are switching level on live playlist, but we don't have any PTS info for that quality level ...
           try to load frag matching with next SN.
           even if SN are not synchronized between playlists, loading this frag will help us
           compute playlist sliding and find the right one after in case it was not the right consecutive one */
        if (fragPrevious) {
          var targetSN = fragPrevious.sn + 1;
          if (targetSN >= levelDetails.startSN && targetSN <= levelDetails.endSN) {
            frag = fragments[targetSN - levelDetails.startSN];
            _logger.logger.log('live playlist, switching playlist, load frag with next SN: ' + frag.sn);
          }
        }
        if (!frag) {
          /* we have no idea about which fragment should be loaded.
             so let's load mid fragment. it will help computing playlist sliding and find the right one
          */
          frag = fragments[Math.min(fragLen - 1, Math.round(fragLen / 2))];
          _logger.logger.log('live playlist, switching playlist, unknown, load middle frag : ' + frag.sn);
        }
      }
      return frag;
    }
  }, {
    key: '_findFragment',
    value: function _findFragment(_ref3) {
      var start = _ref3.start,
          fragPrevious = _ref3.fragPrevious,
          fragLen = _ref3.fragLen,
          fragments = _ref3.fragments,
          bufferEnd = _ref3.bufferEnd,
          end = _ref3.end,
          levelDetails = _ref3.levelDetails;

      var config = this.hls.config;
      var frag = void 0;
      var foundFrag = void 0;
      var maxFragLookUpTolerance = config.maxFragLookUpTolerance;
      var fragNext = fragPrevious ? fragments.find(function (fragment) {
        return fragment.sn === fragPrevious.sn + 1;
      }) : undefined;
      var fragmentWithinToleranceTest = function fragmentWithinToleranceTest(candidate) {
        // offset should be within fragment boundary - config.maxFragLookUpTolerance
        // this is to cope with situations like
        // bufferEnd = 9.991
        // frag[] : [0,10]
        // frag[1] : [10,20]
        // bufferEnd is within frag[0] range ... although what we are expecting is to return frag[1] here
        //              frag start               frag start+duration
        //                  |-----------------------------|
        //              <--->                         <--->
        //  ...--------><-----------------------------><---------....
        // previous frag         matching fragment         next frag
        //  return -1             return 0                 return 1
        //logger.log(`level/sn/start/end/bufEnd:${level}/${candidate.sn}/${candidate.start}/${(candidate.start+candidate.duration)}/${bufferEnd}`);
        // Set the lookup tolerance to be small enough to detect the current segment - ensures we don't skip over very small segments
        var candidateLookupTolerance = Math.min(maxFragLookUpTolerance, candidate.duration);
        if (candidate.start + candidate.duration - candidateLookupTolerance <= bufferEnd) {
          return 1;
        } // if maxFragLookUpTolerance will have negative value then don't return -1 for first element
        else if (candidate.start - candidateLookupTolerance > bufferEnd && candidate.start) {
            return -1;
          }
        return 0;
      };

      if (bufferEnd < end) {
        if (bufferEnd > end - maxFragLookUpTolerance) {
          maxFragLookUpTolerance = 0;
        }
        // Prefer the next fragment if it's within tolerance
        if (fragNext && !fragmentWithinToleranceTest(fragNext)) {
          foundFrag = fragNext;
        } else {
          foundFrag = _binarySearch2.default.search(fragments, fragmentWithinToleranceTest);
        }
      } else {
        // reach end of playlist
        foundFrag = fragments[fragLen - 1];
      }
      if (foundFrag) {
        frag = foundFrag;
        var curSNIdx = frag.sn - levelDetails.startSN;
        var sameLevel = fragPrevious && frag.level === fragPrevious.level;
        var prevFrag = fragments[curSNIdx - 1];
        var nextFrag = fragments[curSNIdx + 1];
        //logger.log('find SN matching with pos:' +  bufferEnd + ':' + frag.sn);
        if (sameLevel && frag.sn === fragPrevious.sn) {
          if (frag.sn < levelDetails.endSN) {
            var deltaPTS = fragPrevious.deltaPTS;
            // if there is a significant delta between audio and video, larger than max allowed hole,
            // and if previous remuxed fragment did not start with a keyframe. (fragPrevious.dropped)
            // let's try to load previous fragment again to get last keyframe
            // then we will reload again current fragment (that way we should be able to fill the buffer hole ...)
            if (deltaPTS && deltaPTS > config.maxBufferHole && fragPrevious.dropped && curSNIdx) {
              frag = prevFrag;
              _logger.logger.warn('SN just loaded, with large PTS gap between audio and video, maybe frag is not starting with a keyframe ? load previous one to try to overcome this');
              // decrement previous frag load counter to avoid frag loop loading error when next fragment will get reloaded
              fragPrevious.loadCounter--;
            } else {
              frag = nextFrag;
              _logger.logger.log('SN just loaded, load next one: ' + frag.sn);
            }
          } else {
            frag = null;
          }
        } else if (frag.dropped && !sameLevel) {
          // Only backtrack a max of 1 consecutive fragment to prevent sliding back too far when little or no frags start with keyframes
          if (nextFrag && nextFrag.backtracked) {
            _logger.logger.warn('Already backtracked from fragment ' + (curSNIdx + 1) + ', will not backtrack to fragment ' + curSNIdx + '. Loading fragment ' + (curSNIdx + 1));
            frag = nextFrag;
          } else {
            // If a fragment has dropped frames and it's in a different level/sequence, load the previous fragment to try and find the keyframe
            // Reset the dropped count now since it won't be reset until we parse the fragment again, which prevents infinite backtracking on the same segment
            _logger.logger.warn('Loaded fragment with dropped frames, backtracking 1 segment to find a keyframe');
            frag.dropped = 0;
            if (prevFrag && prevFrag.loadCounter) {
              prevFrag.loadCounter--;
              frag = prevFrag;
            } else {
              frag = null;
            }
          }
        }
      }
      return frag;
    }
  }, {
    key: '_loadFragmentOrKey',
    value: function _loadFragmentOrKey(_ref4) {
      var frag = _ref4.frag,
          level = _ref4.level,
          levelDetails = _ref4.levelDetails,
          pos = _ref4.pos,
          bufferEnd = _ref4.bufferEnd;

      var hls = this.hls,
          config = hls.config;

      //logger.log('loading frag ' + i +',pos/bufEnd:' + pos.toFixed(3) + '/' + bufferEnd.toFixed(3));
      if (frag.decryptdata.uri != null && frag.decryptdata.key == null) {
        _logger.logger.log('Loading key for ' + frag.sn + ' of [' + levelDetails.startSN + ' ,' + levelDetails.endSN + '],level ' + level);
        this.state = State.KEY_LOADING;
        hls.trigger(_events2.default.KEY_LOADING, { frag: frag });
      } else {
        _logger.logger.log('Loading ' + frag.sn + ' of [' + levelDetails.startSN + ' ,' + levelDetails.endSN + '],level ' + level + ', currentTime:' + pos.toFixed(3) + ',bufferEnd:' + bufferEnd.toFixed(3));
        // ensure that we are not reloading the same fragments in loop ...
        if (this.fragLoadIdx !== undefined) {
          this.fragLoadIdx++;
        } else {
          this.fragLoadIdx = 0;
        }
        if (frag.loadCounter) {
          frag.loadCounter++;
          var maxThreshold = config.fragLoadingLoopThreshold;
          // if this frag has already been loaded 3 times, and if it has been reloaded recently
          if (frag.loadCounter > maxThreshold && Math.abs(this.fragLoadIdx - frag.loadIdx) < maxThreshold) {
            hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.FRAG_LOOP_LOADING_ERROR, fatal: false, frag: frag });
            return false;
          }
        } else {
          frag.loadCounter = 1;
        }
        frag.loadIdx = this.fragLoadIdx;
        this.fragCurrent = frag;
        this.startFragRequested = true;
        this.nextLoadPosition = frag.start + frag.duration;
        frag.autoLevel = hls.autoLevelEnabled;
        frag.bitrateTest = this.bitrateTest;
        hls.trigger(_events2.default.FRAG_LOADING, { frag: frag });
        // lazy demuxer init, as this could take some time ... do it during frag loading
        if (!this.demuxer) {
          this.demuxer = new _demuxer2.default(hls, 'main');
        }
        this.state = State.FRAG_LOADING;
        return true;
      }
    }
  }, {
    key: 'getBufferRange',
    value: function getBufferRange(position) {
      var i,
          range,
          bufferRange = this.bufferRange;
      if (bufferRange) {
        for (i = bufferRange.length - 1; i >= 0; i--) {
          range = bufferRange[i];
          if (position >= range.start && position <= range.end) {
            return range;
          }
        }
      }
      return null;
    }
  }, {
    key: 'followingBufferRange',
    value: function followingBufferRange(range) {
      if (range) {
        // try to get range of next fragment (500ms after this range)
        return this.getBufferRange(range.end + 0.5);
      }
      return null;
    }
  }, {
    key: '_checkFragmentChanged',
    value: function _checkFragmentChanged() {
      var rangeCurrent,
          currentTime,
          video = this.media;
      if (video && video.readyState && video.seeking === false) {
        currentTime = video.currentTime;
        /* if video element is in seeked state, currentTime can only increase.
          (assuming that playback rate is positive ...)
          As sometimes currentTime jumps back to zero after a
          media decode error, check this, to avoid seeking back to
          wrong position after a media decode error
        */
        if (currentTime > video.playbackRate * this.lastCurrentTime) {
          this.lastCurrentTime = currentTime;
        }
        if (_bufferHelper2.default.isBuffered(video, currentTime)) {
          rangeCurrent = this.getBufferRange(currentTime);
        } else if (_bufferHelper2.default.isBuffered(video, currentTime + 0.1)) {
          /* ensure that FRAG_CHANGED event is triggered at startup,
            when first video frame is displayed and playback is paused.
            add a tolerance of 100ms, in case current position is not buffered,
            check if current pos+100ms is buffered and use that buffer range
            for FRAG_CHANGED event reporting */
          rangeCurrent = this.getBufferRange(currentTime + 0.1);
        }
        if (rangeCurrent) {
          var fragPlaying = rangeCurrent.frag;
          if (fragPlaying !== this.fragPlaying) {
            this.fragPlaying = fragPlaying;
            this.hls.trigger(_events2.default.FRAG_CHANGED, { frag: fragPlaying });
          }
        }
      }
    }

    /*
      on immediate level switch :
       - pause playback if playing
       - cancel any pending load request
       - and trigger a buffer flush
    */

  }, {
    key: 'immediateLevelSwitch',
    value: function immediateLevelSwitch() {
      _logger.logger.log('immediateLevelSwitch');
      if (!this.immediateSwitch) {
        this.immediateSwitch = true;
        var media = this.media,
            previouslyPaused = void 0;
        if (media) {
          previouslyPaused = media.paused;
          media.pause();
        } else {
          // don't restart playback after instant level switch in case media not attached
          previouslyPaused = true;
        }
        this.previouslyPaused = previouslyPaused;
      }
      var fragCurrent = this.fragCurrent;
      if (fragCurrent && fragCurrent.loader) {
        fragCurrent.loader.abort();
      }
      this.fragCurrent = null;
      // increase fragment load Index to avoid frag loop loading error after buffer flush
      this.fragLoadIdx += 2 * this.config.fragLoadingLoopThreshold;
      // flush everything
      this.flushMainBuffer(0, Number.POSITIVE_INFINITY);
    }

    /*
       on immediate level switch end, after new fragment has been buffered :
        - nudge video decoder by slightly adjusting video currentTime (if currentTime buffered)
        - resume the playback if needed
    */

  }, {
    key: 'immediateLevelSwitchEnd',
    value: function immediateLevelSwitchEnd() {
      var media = this.media;
      if (media && media.buffered.length) {
        this.immediateSwitch = false;
        if (_bufferHelper2.default.isBuffered(media, media.currentTime)) {
          // only nudge if currentTime is buffered
          media.currentTime -= 0.0001;
        }
        if (!this.previouslyPaused) {
          media.play();
        }
      }
    }
  }, {
    key: 'nextLevelSwitch',
    value: function nextLevelSwitch() {
      /* try to switch ASAP without breaking video playback :
         in order to ensure smooth but quick level switching,
        we need to find the next flushable buffer range
        we should take into account new segment fetch time
      */
      var media = this.media;
      // ensure that media is defined and that metadata are available (to retrieve currentTime)
      if (media && media.readyState) {
        var fetchdelay = void 0,
            currentRange = void 0,
            nextRange = void 0;
        // increase fragment load Index to avoid frag loop loading error after buffer flush
        this.fragLoadIdx += 2 * this.config.fragLoadingLoopThreshold;
        currentRange = this.getBufferRange(media.currentTime);
        if (currentRange && currentRange.start > 1) {
          // flush buffer preceding current fragment (flush until current fragment start offset)
          // minus 1s to avoid video freezing, that could happen if we flush keyframe of current video ...
          this.flushMainBuffer(0, currentRange.start - 1);
        }
        if (!media.paused) {
          // add a safety delay of 1s
          var nextLevelId = this.hls.nextLoadLevel,
              nextLevel = this.levels[nextLevelId],
              fragLastKbps = this.fragLastKbps;
          if (fragLastKbps && this.fragCurrent) {
            fetchdelay = this.fragCurrent.duration * nextLevel.bitrate / (1000 * fragLastKbps) + 1;
          } else {
            fetchdelay = 0;
          }
        } else {
          fetchdelay = 0;
        }
        //logger.log('fetchdelay:'+fetchdelay);
        // find buffer range that will be reached once new fragment will be fetched
        nextRange = this.getBufferRange(media.currentTime + fetchdelay);
        if (nextRange) {
          // we can flush buffer range following this one without stalling playback
          nextRange = this.followingBufferRange(nextRange);
          if (nextRange) {
            // if we are here, we can also cancel any loading/demuxing in progress, as they are useless
            var fragCurrent = this.fragCurrent;
            if (fragCurrent && fragCurrent.loader) {
              fragCurrent.loader.abort();
            }
            this.fragCurrent = null;
            // flush position is the start position of this new buffer
            this.flushMainBuffer(nextRange.start, Number.POSITIVE_INFINITY);
          }
        }
      }
    }
  }, {
    key: 'flushMainBuffer',
    value: function flushMainBuffer(startOffset, endOffset) {
      this.state = State.BUFFER_FLUSHING;
      var flushScope = { startOffset: startOffset, endOffset: endOffset };
      // if alternate audio tracks are used, only flush video, otherwise flush everything
      if (this.altAudio) {
        flushScope.type = 'video';
      }
      this.hls.trigger(_events2.default.BUFFER_FLUSHING, flushScope);
    }
  }, {
    key: 'onMediaAttached',
    value: function onMediaAttached(data) {
      var media = this.media = this.mediaBuffer = data.media;
      this.onvseeking = this.onMediaSeeking.bind(this);
      this.onvseeked = this.onMediaSeeked.bind(this);
      this.onvended = this.onMediaEnded.bind(this);
      media.addEventListener('seeking', this.onvseeking);
      media.addEventListener('seeked', this.onvseeked);
      media.addEventListener('ended', this.onvended);
      var config = this.config;
      if (this.levels && config.autoStartLoad) {
        this.hls.startLoad(config.startPosition);
      }
    }
  }, {
    key: 'onMediaDetaching',
    value: function onMediaDetaching() {
      var media = this.media;
      if (media && media.ended) {
        _logger.logger.log('MSE detaching and video ended, reset startPosition');
        this.startPosition = this.lastCurrentTime = 0;
      }

      // reset fragment loading counter on MSE detaching to avoid reporting FRAG_LOOP_LOADING_ERROR after error recovery
      var levels = this.levels;
      if (levels) {
        // reset fragment load counter
        levels.forEach(function (level) {
          if (level.details) {
            level.details.fragments.forEach(function (fragment) {
              fragment.loadCounter = undefined;
              fragment.backtracked = undefined;
            });
          }
        });
      }
      // remove video listeners
      if (media) {
        media.removeEventListener('seeking', this.onvseeking);
        media.removeEventListener('seeked', this.onvseeked);
        media.removeEventListener('ended', this.onvended);
        this.onvseeking = this.onvseeked = this.onvended = null;
      }
      this.media = this.mediaBuffer = null;
      this.loadedmetadata = false;
      this.stopLoad();
    }
  }, {
    key: 'onMediaSeeking',
    value: function onMediaSeeking() {
      var media = this.media,
          currentTime = media ? media.currentTime : undefined,
          config = this.config;
      _logger.logger.log('media seeking to ' + currentTime.toFixed(3));
      if (this.state === State.FRAG_LOADING) {
        var bufferInfo = _bufferHelper2.default.bufferInfo(media, currentTime, this.config.maxBufferHole),
            fragCurrent = this.fragCurrent;
        // check if we are seeking to a unbuffered area AND if frag loading is in progress
        if (bufferInfo.len === 0 && fragCurrent) {
          var tolerance = config.maxFragLookUpTolerance,
              fragStartOffset = fragCurrent.start - tolerance,
              fragEndOffset = fragCurrent.start + fragCurrent.duration + tolerance;
          // check if we seek position will be out of currently loaded frag range : if out cancel frag load, if in, don't do anything
          if (currentTime < fragStartOffset || currentTime > fragEndOffset) {
            if (fragCurrent.loader) {
              _logger.logger.log('seeking outside of buffer while fragment load in progress, cancel fragment load');
              fragCurrent.loader.abort();
            }
            this.fragCurrent = null;
            this.fragPrevious = null;
            // switch to IDLE state to load new fragment
            this.state = State.IDLE;
          } else {
            _logger.logger.log('seeking outside of buffer but within currently loaded fragment range');
          }
        }
      } else if (this.state === State.ENDED) {
        // switch to IDLE state to check for potential new fragment
        this.state = State.IDLE;
      }
      if (media) {
        this.lastCurrentTime = currentTime;
      }
      // avoid reporting fragment loop loading error in case user is seeking several times on same position
      if (this.state !== State.FRAG_LOADING && this.fragLoadIdx !== undefined) {
        this.fragLoadIdx += 2 * config.fragLoadingLoopThreshold;
      }
      // in case seeking occurs although no media buffered, adjust startPosition and nextLoadPosition to seek target
      if (!this.loadedmetadata) {
        this.nextLoadPosition = this.startPosition = currentTime;
      }
      // tick to speed up processing
      this.tick();
    }
  }, {
    key: 'onMediaSeeked',
    value: function onMediaSeeked() {
      _logger.logger.log('media seeked to ' + this.media.currentTime.toFixed(3));
      // tick to speed up FRAGMENT_PLAYING triggering
      this.tick();
    }
  }, {
    key: 'onMediaEnded',
    value: function onMediaEnded() {
      _logger.logger.log('media ended');
      // reset startPosition and lastCurrentTime to restart playback @ stream beginning
      this.startPosition = this.lastCurrentTime = 0;
    }
  }, {
    key: 'onManifestLoading',
    value: function onManifestLoading() {
      // reset buffer on manifest loading
      _logger.logger.log('trigger BUFFER_RESET');
      this.hls.trigger(_events2.default.BUFFER_RESET);
      this.bufferRange = [];
      this.stalled = false;
      this.startPosition = this.lastCurrentTime = 0;
    }
  }, {
    key: 'onManifestParsed',
    value: function onManifestParsed(data) {
      var aac = false,
          heaac = false,
          codec;
      data.levels.forEach(function (level) {
        // detect if we have different kind of audio codecs used amongst playlists
        codec = level.audioCodec;
        if (codec) {
          if (codec.indexOf('mp4a.40.2') !== -1) {
            aac = true;
          }
          if (codec.indexOf('mp4a.40.5') !== -1) {
            heaac = true;
          }
        }
      });
      this.audioCodecSwitch = aac && heaac;
      if (this.audioCodecSwitch) {
        _logger.logger.log('both AAC/HE-AAC audio found in levels; declaring level codec as HE-AAC');
      }
      this.levels = data.levels;
      this.startLevelLoaded = false;
      this.startFragRequested = false;
      var config = this.config;
      if (config.autoStartLoad) {
        this.hls.startLoad(config.startPosition);
      }
    }
  }, {
    key: 'onLevelLoaded',
    value: function onLevelLoaded(data) {
      var newDetails = data.details,
          newLevelId = data.level,
          curLevel = this.levels[newLevelId],
          duration = newDetails.totalduration,
          sliding = 0;

      _logger.logger.log('level ' + newLevelId + ' loaded [' + newDetails.startSN + ',' + newDetails.endSN + '],duration:' + duration);
      this.levelLastLoaded = newLevelId;

      if (newDetails.live) {
        var curDetails = curLevel.details;
        if (curDetails && newDetails.fragments.length > 0) {
          // we already have details for that level, merge them
          _levelHelper2.default.mergeDetails(curDetails, newDetails);
          sliding = newDetails.fragments[0].start;
          this.liveSyncPosition = this.computeLivePosition(sliding, curDetails);
          if (newDetails.PTSKnown) {
            _logger.logger.log('live playlist sliding:' + sliding.toFixed(3));
          } else {
            _logger.logger.log('live playlist - outdated PTS, unknown sliding');
          }
        } else {
          newDetails.PTSKnown = false;
          _logger.logger.log('live playlist - first load, unknown sliding');
        }
      } else {
        newDetails.PTSKnown = false;
      }
      // override level info
      curLevel.details = newDetails;
      this.hls.trigger(_events2.default.LEVEL_UPDATED, { details: newDetails, level: newLevelId });

      if (this.startFragRequested === false) {
        // compute start position if set to -1. use it straight away if value is defined
        if (this.startPosition === -1 || this.lastCurrentTime === -1) {
          // first, check if start time offset has been set in playlist, if yes, use this value
          var startTimeOffset = newDetails.startTimeOffset;
          if (!isNaN(startTimeOffset)) {
            if (startTimeOffset < 0) {
              _logger.logger.log('negative start time offset ' + startTimeOffset + ', count from end of last fragment');
              startTimeOffset = sliding + duration + startTimeOffset;
            }
            _logger.logger.log('start time offset found in playlist, adjust startPosition to ' + startTimeOffset);
            this.startPosition = startTimeOffset;
          } else {
            // if live playlist, set start position to be fragment N-this.config.liveSyncDurationCount (usually 3)
            if (newDetails.live) {
              this.startPosition = this.computeLivePosition(sliding, newDetails);
              _logger.logger.log('configure startPosition to ' + this.startPosition);
            } else {
              this.startPosition = 0;
            }
          }
          this.lastCurrentTime = this.startPosition;
        }
        this.nextLoadPosition = this.startPosition;
      }
      // only switch batck to IDLE state if we were waiting for level to start downloading a new fragment
      if (this.state === State.WAITING_LEVEL) {
        this.state = State.IDLE;
      }
      //trigger handler right now
      this.tick();
    }
  }, {
    key: 'onKeyLoaded',
    value: function onKeyLoaded() {
      if (this.state === State.KEY_LOADING) {
        this.state = State.IDLE;
        this.tick();
      }
    }
  }, {
    key: 'onFragLoaded',
    value: function onFragLoaded(data) {
      var fragCurrent = this.fragCurrent,
          fragLoaded = data.frag;
      if (this.state === State.FRAG_LOADING && fragCurrent && fragLoaded.type === 'main' && fragLoaded.level === fragCurrent.level && fragLoaded.sn === fragCurrent.sn) {
        var stats = data.stats,
            currentLevel = this.levels[fragCurrent.level],
            details = currentLevel.details;
        _logger.logger.log('Loaded  ' + fragCurrent.sn + ' of [' + details.startSN + ' ,' + details.endSN + '],level ' + fragCurrent.level);
        // reset frag bitrate test in any case after frag loaded event
        this.bitrateTest = false;
        // if this frag was loaded to perform a bitrate test AND if hls.nextLoadLevel is greater than 0
        // then this means that we should be able to load a fragment at a higher quality level
        if (fragLoaded.bitrateTest === true && this.hls.nextLoadLevel) {
          // switch back to IDLE state ... we just loaded a fragment to determine adequate start bitrate and initialize autoswitch algo
          this.state = State.IDLE;
          this.startFragRequested = false;
          stats.tparsed = stats.tbuffered = performance.now();
          this.hls.trigger(_events2.default.FRAG_BUFFERED, { stats: stats, frag: fragCurrent, id: 'main' });
          this.tick();
        } else {
          this.state = State.PARSING;
          // transmux the MPEG-TS data to ISO-BMFF segments
          this.stats = stats;
          var duration = details.totalduration,
              start = !isNaN(fragCurrent.startDTS) ? fragCurrent.startDTS : fragCurrent.start,
              level = fragCurrent.level,
              sn = fragCurrent.sn,
              audioCodec = this.config.defaultAudioCodec || currentLevel.audioCodec;
          if (this.audioCodecSwap) {
            _logger.logger.log('swapping playlist audio codec');
            if (audioCodec === undefined) {
              audioCodec = this.lastAudioCodec;
            }
            if (audioCodec) {
              if (audioCodec.indexOf('mp4a.40.5') !== -1) {
                audioCodec = 'mp4a.40.2';
              } else {
                audioCodec = 'mp4a.40.5';
              }
            }
          }
          this.pendingBuffering = -1;
          this.appended = false;
          _logger.logger.log('Parsing ' + sn + ' of [' + details.startSN + ' ,' + details.endSN + '],level ' + level + ', cc ' + fragCurrent.cc);
          var demuxer = this.demuxer;
          if (!demuxer) {
            demuxer = this.demuxer = new _demuxer2.default(this.hls, 'main');
          }
          // time Offset is accurate if level PTS is known, or if playlist is not sliding (not live) and if media is not seeking (this is to overcome potential timestamp drifts between playlists and fragments)
          var media = this.media;
          var mediaSeeking = media && media.seeking;
          var accurateTimeOffset = !mediaSeeking && (details.PTSKnown || !details.live);
          demuxer.push(data.payload, audioCodec, currentLevel.videoCodec, start, fragCurrent.cc, level, sn, duration, fragCurrent.decryptdata, accurateTimeOffset, null);
        }
      }
      this.fragLoadError = 0;
    }
  }, {
    key: 'onFragParsingInitSegment',
    value: function onFragParsingInitSegment(data) {
      var fragCurrent = this.fragCurrent;
      if (fragCurrent && data.id === 'main' && data.sn === fragCurrent.sn && data.level === fragCurrent.level && this.state === State.PARSING) {
        var tracks = data.tracks,
            trackName,
            track;

        // if audio track is expected to come from audio stream controller, discard any coming from main
        if (tracks.audio && this.altAudio) {
          delete tracks.audio;
        }
        // include levelCodec in audio and video tracks
        track = tracks.audio;
        if (track) {
          var audioCodec = this.levels[this.level].audioCodec,
              ua = navigator.userAgent.toLowerCase();
          if (audioCodec && this.audioCodecSwap) {
            _logger.logger.log('swapping playlist audio codec');
            if (audioCodec.indexOf('mp4a.40.5') !== -1) {
              audioCodec = 'mp4a.40.2';
            } else {
              audioCodec = 'mp4a.40.5';
            }
          }
          // in case AAC and HE-AAC audio codecs are signalled in manifest
          // force HE-AAC , as it seems that most browsers prefers that way,
          // except for mono streams OR on FF
          // these conditions might need to be reviewed ...
          if (this.audioCodecSwitch) {
            // don't force HE-AAC if mono stream
            if (track.metadata.channelCount !== 1 &&
            // don't force HE-AAC if firefox
            ua.indexOf('firefox') === -1) {
              audioCodec = 'mp4a.40.5';
            }
          }
          // HE-AAC is broken on Android, always signal audio codec as AAC even if variant manifest states otherwise
          if (ua.indexOf('android') !== -1 && track.container !== 'audio/mpeg') {
            // Exclude mpeg audio
            audioCodec = 'mp4a.40.2';
            _logger.logger.log('Android: force audio codec to ' + audioCodec);
          }
          track.levelCodec = audioCodec;
          track.id = data.id;
        }
        track = tracks.video;
        if (track) {
          track.levelCodec = this.levels[this.level].videoCodec;
          track.id = data.id;
        }

        // if remuxer specify that a unique track needs to generated,
        // let's merge all tracks together
        if (data.unique) {
          var mergedTrack = {
            codec: '',
            levelCodec: ''
          };
          for (trackName in data.tracks) {
            track = tracks[trackName];
            mergedTrack.container = track.container;
            if (mergedTrack.codec) {
              mergedTrack.codec += ',';
              mergedTrack.levelCodec += ',';
            }
            if (track.codec) {
              mergedTrack.codec += track.codec;
            }
            if (track.levelCodec) {
              mergedTrack.levelCodec += track.levelCodec;
            }
          }
          tracks = { audiovideo: mergedTrack };
        }
        this.hls.trigger(_events2.default.BUFFER_CODECS, tracks);
        // loop through tracks that are going to be provided to bufferController
        for (trackName in tracks) {
          track = tracks[trackName];
          _logger.logger.log('main track:' + trackName + ',container:' + track.container + ',codecs[level/parsed]=[' + track.levelCodec + '/' + track.codec + ']');
          var initSegment = track.initSegment;
          if (initSegment) {
            this.appended = true;
            this.hls.trigger(_events2.default.BUFFER_APPENDING, { type: trackName, data: initSegment, parent: 'main', content: 'initSegment' });
          }
        }
        //trigger handler right now
        this.tick();
      }
    }
  }, {
    key: 'onFragParsingData',
    value: function onFragParsingData(data) {
      var _this2 = this;

      var fragCurrent = this.fragCurrent;
      if (fragCurrent && data.id === 'main' && data.sn === fragCurrent.sn && data.level === fragCurrent.level && !(data.type === 'audio' && this.altAudio) && // filter out main audio if audio track is loaded through audio stream controller
      this.state === State.PARSING) {
        var level = this.levels[this.level],
            frag = this.fragCurrent;

        _logger.logger.log('Parsed ' + data.type + ',PTS:[' + data.startPTS.toFixed(3) + ',' + data.endPTS.toFixed(3) + '],DTS:[' + data.startDTS.toFixed(3) + '/' + data.endDTS.toFixed(3) + '],nb:' + data.nb + ',dropped:' + (data.dropped || 0));

        // Detect gaps in a fragment  and try to fix it by finding a keyframe in the previous fragment (see _findFragments)
        if (data.type === 'video') {
          frag.dropped = data.dropped;
          if (frag.dropped) {
            if (!frag.backtracked) {
              // Return back to the IDLE state without appending to buffer
              // Causes findFragments to backtrack a segment and find the keyframe
              // Audio fragments arriving before video sets the nextLoadPosition, causing _findFragments to skip the backtracked fragment
              frag.backtracked = true;
              this.nextLoadPosition = frag.startPTS;
              this.state = State.IDLE;
              this.tick();
              return;
            } else {
              _logger.logger.warn('Already backtracked on this fragment, appending with the gap');
            }
          } else {
            // Only reset the backtracked flag if we've loaded the frag without any dropped frames
            frag.backtracked = false;
          }
        }

        var drift = _levelHelper2.default.updateFragPTSDTS(level.details, frag.sn, data.startPTS, data.endPTS, data.startDTS, data.endDTS),
            hls = this.hls;
        hls.trigger(_events2.default.LEVEL_PTS_UPDATED, { details: level.details, level: this.level, drift: drift, type: data.type, start: data.startPTS, end: data.endPTS });

        // has remuxer dropped video frames located before first keyframe ?
        [data.data1, data.data2].forEach(function (buffer) {
          if (buffer) {
            _this2.appended = true;
            hls.trigger(_events2.default.BUFFER_APPENDING, { type: data.type, data: buffer, parent: 'main', content: 'data' });
          }
        });

        this.bufferRange.push({ type: data.type, start: data.startPTS, end: data.endPTS, frag: frag });

        //trigger handler right now
        this.tick();
      }
    }
  }, {
    key: 'onFragParsed',
    value: function onFragParsed(data) {
      var fragCurrent = this.fragCurrent;
      if (fragCurrent && data.id === 'main' && data.sn === fragCurrent.sn && data.level === fragCurrent.level && this.state === State.PARSING) {
        this.stats.tparsed = performance.now();
        this.state = State.PARSED;
        this._checkAppendedParsed();
      }
    }
  }, {
    key: 'onAudioTrackSwitching',
    value: function onAudioTrackSwitching(data) {
      // if any URL found on new audio track, it is an alternate audio track
      var altAudio = !!data.url,
          trackId = data.id;
      // if we switch on main audio, ensure that main fragment scheduling is synced with media.buffered
      // don't do anything if we switch to alt audio: audio stream controller is handling it.
      // we will just have to change buffer scheduling on audioTrackSwitched
      if (!altAudio) {
        if (this.mediaBuffer !== this.media) {
          _logger.logger.log('switching on main audio, use media.buffered to schedule main fragment loading');
          this.mediaBuffer = this.media;
          var fragCurrent = this.fragCurrent;
          // we need to refill audio buffer from main: cancel any frag loading to speed up audio switch
          if (fragCurrent.loader) {
            _logger.logger.log('switching to main audio track, cancel main fragment load');
            fragCurrent.loader.abort();
          }
          this.fragCurrent = null;
          this.fragPrevious = null;
          // destroy demuxer to force init segment generation (following audio switch)
          if (this.demuxer) {
            this.demuxer.destroy();
            this.demuxer = null;
          }
          // switch to IDLE state to load new fragment
          this.state = State.IDLE;
        }
        var hls = this.hls;
        // switching to main audio, flush all audio and trigger track switched
        hls.trigger(_events2.default.BUFFER_FLUSHING, { startOffset: 0, endOffset: Number.POSITIVE_INFINITY, type: 'audio' });
        hls.trigger(_events2.default.AUDIO_TRACK_SWITCHED, { id: trackId });
        this.altAudio = false;
      }
    }
  }, {
    key: 'onAudioTrackSwitched',
    value: function onAudioTrackSwitched(data) {
      var trackId = data.id,
          altAudio = !!this.hls.audioTracks[trackId].url;
      if (altAudio) {
        var videoBuffer = this.videoBuffer;
        // if we switched on alternate audio, ensure that main fragment scheduling is synced with video sourcebuffer buffered
        if (videoBuffer && this.mediaBuffer !== videoBuffer) {
          _logger.logger.log('switching on alternate audio, use video.buffered to schedule main fragment loading');
          this.mediaBuffer = videoBuffer;
        }
      }
      this.altAudio = altAudio;
      this.tick();
    }
  }, {
    key: 'onBufferCreated',
    value: function onBufferCreated(data) {
      var tracks = data.tracks,
          mediaTrack = void 0,
          name = void 0,
          alternate = false;
      for (var type in tracks) {
        var track = tracks[type];
        if (track.id === 'main') {
          name = type;
          mediaTrack = track;
          // keep video source buffer reference
          if (type === 'video') {
            this.videoBuffer = tracks[type].buffer;
          }
        } else {
          alternate = true;
        }
      }
      if (alternate && mediaTrack) {
        _logger.logger.log('alternate track found, use ' + name + '.buffered to schedule main fragment loading');
        this.mediaBuffer = mediaTrack.buffer;
      } else {
        this.mediaBuffer = this.media;
      }
    }
  }, {
    key: 'onBufferAppended',
    value: function onBufferAppended(data) {
      if (data.parent === 'main') {
        var state = this.state;
        if (state === State.PARSING || state === State.PARSED) {
          this.pendingBuffering = data.pending;
          this._checkAppendedParsed();
        }
      }
    }
  }, {
    key: '_checkAppendedParsed',
    value: function _checkAppendedParsed() {
      //trigger handler right now
      if (this.state === State.PARSED && (!this.appended || this.pendingBuffering === 0)) {
        var frag = this.fragCurrent,
            stats = this.stats;
        if (frag) {
          this.fragPrevious = frag;
          stats.tbuffered = performance.now();
          // we should get rid of this.fragLastKbps
          this.fragLastKbps = Math.round(8 * stats.total / (stats.tbuffered - stats.tfirst));
          this.hls.trigger(_events2.default.FRAG_BUFFERED, { stats: stats, frag: frag, id: 'main' });
          var media = this.mediaBuffer ? this.mediaBuffer : this.media;
          _logger.logger.log('main buffered : ' + _timeRanges2.default.toString(media.buffered));
          this.state = State.IDLE;
        }
        this.tick();
      }
    }
  }, {
    key: 'onError',
    value: function onError(data) {
      var frag = data.frag || this.fragCurrent;
      // don't handle frag error not related to main fragment
      if (frag && frag.type !== 'main') {
        return;
      }
      var media = this.media,

      // 0.5 : tolerance needed as some browsers stalls playback before reaching buffered end
      mediaBuffered = media && _bufferHelper2.default.isBuffered(media, media.currentTime) && _bufferHelper2.default.isBuffered(media, media.currentTime + 0.5);
      switch (data.details) {
        case _errors.ErrorDetails.FRAG_LOAD_ERROR:
        case _errors.ErrorDetails.FRAG_LOAD_TIMEOUT:
        case _errors.ErrorDetails.KEY_LOAD_ERROR:
        case _errors.ErrorDetails.KEY_LOAD_TIMEOUT:
          if (!data.fatal) {
            var loadError = this.fragLoadError;
            if (loadError) {
              loadError++;
            } else {
              loadError = 1;
            }
            var config = this.config;
            // keep retrying / don't raise fatal network error if current position is buffered or if in automode with current level not 0
            if (loadError <= config.fragLoadingMaxRetry || mediaBuffered || frag.autoLevel && frag.level) {
              this.fragLoadError = loadError;
              // reset load counter to avoid frag loop loading error
              frag.loadCounter = 0;
              // exponential backoff capped to config.fragLoadingMaxRetryTimeout
              var delay = Math.min(Math.pow(2, loadError - 1) * config.fragLoadingRetryDelay, config.fragLoadingMaxRetryTimeout);
              _logger.logger.warn('mediaController: frag loading failed, retry in ' + delay + ' ms');
              this.retryDate = performance.now() + delay;
              // retry loading state
              this.state = State.FRAG_LOADING_WAITING_RETRY;
            } else {
              _logger.logger.error('mediaController: ' + data.details + ' reaches max retry, redispatch as fatal ...');
              // redispatch same error but with fatal set to true
              data.fatal = true;
              this.hls.trigger(_events2.default.ERROR, data);
              this.state = State.ERROR;
            }
          }
          break;
        case _errors.ErrorDetails.FRAG_LOOP_LOADING_ERROR:
          if (!data.fatal) {
            // if buffer is not empty
            if (mediaBuffered) {
              // try to reduce max buffer length : rationale is that we could get
              // frag loop loading error because of buffer eviction
              this._reduceMaxBufferLength(frag.duration);
              this.state = State.IDLE;
            } else {
              // buffer empty. report as fatal if in manual mode or if lowest level.
              // level controller takes care of emergency switch down logic
              if (!frag.autoLevel || frag.level === 0) {
                // redispatch same error but with fatal set to true
                data.fatal = true;
                this.hls.trigger(_events2.default.ERROR, data);
                this.state = State.ERROR;
              }
            }
          }
          break;
        case _errors.ErrorDetails.LEVEL_LOAD_ERROR:
        case _errors.ErrorDetails.LEVEL_LOAD_TIMEOUT:
          if (this.state !== State.ERROR) {
            if (data.fatal) {
              // if fatal error, stop processing
              this.state = State.ERROR;
              _logger.logger.warn('streamController: ' + data.details + ',switch to ' + this.state + ' state ...');
            } else {
              // in cas of non fatal error while waiting level load to be completed, switch back to IDLE
              if (this.state === State.WAITING_LEVEL) {
                this.state = State.IDLE;
              }
            }
          }
          break;
        case _errors.ErrorDetails.BUFFER_FULL_ERROR:
          // if in appending state
          if (this.state === State.PARSING || this.state === State.PARSED) {
            // reduce max buf len if current position is buffered
            if (mediaBuffered) {
              this._reduceMaxBufferLength(frag.duration);
              this.state = State.IDLE;
            } else {
              // current position is not buffered, but browser is still complaining about buffer full error
              // this happens on IE/Edge, refer to https://github.com/dailymotion/hls.js/pull/708
              // in that case flush the whole buffer to recover
              _logger.logger.warn('buffer full error also media.currentTime is not buffered, flush everything');
              this.fragCurrent = null;
              // flush everything
              this.flushMainBuffer(0, Number.POSITIVE_INFINITY);
            }
          }
          break;
        default:
          break;
      }
    }
  }, {
    key: '_reduceMaxBufferLength',
    value: function _reduceMaxBufferLength(minLength) {
      var config = this.config;
      if (config.maxMaxBufferLength >= minLength) {
        // reduce max buffer length as it might be too high. we do this to avoid loop flushing ...
        config.maxMaxBufferLength /= 2;
        _logger.logger.warn('reduce max buffer length to ' + config.maxMaxBufferLength + 's and switch to IDLE state');
        // increase fragment load Index to avoid frag loop loading error after buffer flush
        this.fragLoadIdx += 2 * config.fragLoadingLoopThreshold;
      }
    }
  }, {
    key: '_checkBuffer',
    value: function _checkBuffer() {
      var media = this.media;
      // if ready state different from HAVE_NOTHING (numeric value 0), we are allowed to seek
      if (media && media.readyState) {
        var currentTime = media.currentTime,
            buffered = media.buffered;
        // adjust currentTime to start position on loaded metadata
        if (!this.loadedmetadata && buffered.length && !media.seeking) {
          this.loadedmetadata = true;
          // only adjust currentTime if different from startPosition or if startPosition not buffered
          // at that stage, there should be only one buffered range, as we reach that code after first fragment has been buffered
          var startPosition = this.startPosition,
              startPositionBuffered = _bufferHelper2.default.isBuffered(media, startPosition);
          // if currentTime not matching with expected startPosition or startPosition not buffered
          if (currentTime !== startPosition || !startPositionBuffered) {
            _logger.logger.log('target start position:' + startPosition);
            // if startPosition not buffered, let's seek to buffered.start(0)
            if (!startPositionBuffered) {
              startPosition = buffered.start(0);
              _logger.logger.log('target start position not buffered, seek to buffered.start(0) ' + startPosition);
            }
            _logger.logger.log('adjust currentTime from ' + currentTime + ' to ' + startPosition);
            media.currentTime = startPosition;
          }
        } else if (this.immediateSwitch) {
          this.immediateLevelSwitchEnd();
        } else {
          var bufferInfo = _bufferHelper2.default.bufferInfo(media, currentTime, 0),
              expectedPlaying = !(media.paused || // not playing when media is paused
          media.ended || // not playing when media is ended
          media.buffered.length === 0),
              // not playing if nothing buffered
          jumpThreshold = 0.5,
              // tolerance needed as some browsers stalls playback before reaching buffered range end
          playheadMoving = currentTime > media.playbackRate * this.lastCurrentTime,
              config = this.config;

          if (this.stalled && playheadMoving) {
            this.stalled = false;
            _logger.logger.log('playback not stuck anymore @' + currentTime);
          }
          // check buffer upfront
          // if less than jumpThreshold second is buffered, let's check in more details
          if (expectedPlaying && bufferInfo.len <= jumpThreshold) {
            if (playheadMoving) {
              // playhead moving
              jumpThreshold = 0;
              this.seekHoleNudgeDuration = 0;
            } else {
              // playhead not moving AND media expected to play
              if (!this.stalled) {
                this.seekHoleNudgeDuration = 0;
                _logger.logger.log('playback seems stuck @' + currentTime);
                this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.BUFFER_STALLED_ERROR, fatal: false });
                this.stalled = true;
              } else {
                this.seekHoleNudgeDuration += config.seekHoleNudgeDuration;
              }
            }
            // if we are below threshold, try to jump to start of next buffer range if close
            if (bufferInfo.len <= jumpThreshold) {
              // no buffer available @ currentTime, check if next buffer is close (within a config.maxSeekHole second range)
              var nextBufferStart = bufferInfo.nextStart,
                  delta = nextBufferStart - currentTime;
              if (nextBufferStart && delta < config.maxSeekHole && delta > 0) {
                // next buffer is close ! adjust currentTime to nextBufferStart
                // this will ensure effective video decoding
                _logger.logger.log('adjust currentTime from ' + media.currentTime + ' to next buffered @ ' + nextBufferStart + ' + nudge ' + this.seekHoleNudgeDuration);
                var hole = nextBufferStart + this.seekHoleNudgeDuration - media.currentTime;
                media.currentTime = nextBufferStart + this.seekHoleNudgeDuration;
                this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.BUFFER_SEEK_OVER_HOLE, fatal: false, hole: hole });
              }
            }
          }
        }
      }
    }
  }, {
    key: 'onFragLoadEmergencyAborted',
    value: function onFragLoadEmergencyAborted() {
      this.state = State.IDLE;
      // if loadedmetadata is not set, it means that we are emergency switch down on first frag
      // in that case, reset startFragRequested flag
      if (!this.loadedmetadata) {
        this.startFragRequested = false;
      }
      this.tick();
    }
  }, {
    key: 'onBufferFlushed',
    value: function onBufferFlushed() {
      /* after successful buffer flushing, rebuild buffer Range array
        loop through existing buffer range and check if
        corresponding range is still buffered. only push to new array already buffered range
        use mediaBuffered instead of media (so that we will check against video.buffered ranges in case of alt audio track)
      */
      var media = this.mediaBuffer ? this.mediaBuffer : this.media,
          bufferRange = this.bufferRange,
          newRange = [],
          range = void 0,
          i = void 0;
      for (i = 0; i < bufferRange.length; i++) {
        range = bufferRange[i];
        if (_bufferHelper2.default.isBuffered(media, (range.start + range.end) / 2)) {
          newRange.push(range);
        }
      }
      this.bufferRange = newRange;

      // increase fragment load Index to avoid frag loop loading error after buffer flush
      this.fragLoadIdx += 2 * this.config.fragLoadingLoopThreshold;
      // move to IDLE once flush complete. this should trigger new fragment loading
      this.state = State.IDLE;
      // reset reference to frag
      this.fragPrevious = null;
    }
  }, {
    key: 'onLevelRemoved',
    value: function onLevelRemoved(data) {
      this.levels = this.levels.filter(function (level, index) {
        return index !== data.level;
      });
    }
  }, {
    key: 'swapAudioCodec',
    value: function swapAudioCodec() {
      this.audioCodecSwap = !this.audioCodecSwap;
    }
  }, {
    key: 'computeLivePosition',
    value: function computeLivePosition(sliding, levelDetails) {
      var targetLatency = this.config.liveSyncDuration !== undefined ? this.config.liveSyncDuration : this.config.liveSyncDurationCount * levelDetails.targetduration;
      return sliding + Math.max(0, levelDetails.totalduration - targetLatency);
    }
  }, {
    key: 'state',
    set: function set(nextState) {
      if (this.state !== nextState) {
        var previousState = this.state;
        this._state = nextState;
        _logger.logger.log('engine state transition from ' + previousState + ' to ' + nextState);
        this.hls.trigger(_events2.default.STREAM_STATE_TRANSITION, { previousState: previousState, nextState: nextState });
      }
    },
    get: function get() {
      return this._state;
    }
  }, {
    key: 'currentLevel',
    get: function get() {
      var media = this.media;
      if (media) {
        var range = this.getBufferRange(media.currentTime);
        if (range) {
          return range.frag.level;
        }
      }
      return -1;
    }
  }, {
    key: 'nextBufferRange',
    get: function get() {
      var media = this.media;
      if (media) {
        // first get end range of current fragment
        return this.followingBufferRange(this.getBufferRange(media.currentTime));
      } else {
        return null;
      }
    }
  }, {
    key: 'nextLevel',
    get: function get() {
      var range = this.nextBufferRange;
      if (range) {
        return range.frag.level;
      } else {
        return -1;
      }
    }
  }, {
    key: 'liveSyncPosition',
    get: function get() {
      return this._liveSyncPosition;
    },
    set: function set(value) {
      this._liveSyncPosition = value;
    }
  }]);

  return StreamController;
}(_eventHandler2.default);

exports.default = StreamController;

},{"../demux/demuxer":24,"../errors":28,"../event-handler":29,"../events":30,"../helper/buffer-helper":32,"../helper/level-helper":33,"../utils/binary-search":43,"../utils/logger":47,"../utils/timeRanges":48}],13:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _eventHandler = require('../event-handler');

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _logger = require('../utils/logger');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Subtitle Stream Controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

var SubtitleStreamController = function (_EventHandler) {
  _inherits(SubtitleStreamController, _EventHandler);

  function SubtitleStreamController(hls) {
    _classCallCheck(this, SubtitleStreamController);

    var _this = _possibleConstructorReturn(this, (SubtitleStreamController.__proto__ || Object.getPrototypeOf(SubtitleStreamController)).call(this, hls, _events2.default.ERROR, _events2.default.SUBTITLE_TRACKS_UPDATED, _events2.default.SUBTITLE_TRACK_SWITCH, _events2.default.SUBTITLE_TRACK_LOADED, _events2.default.SUBTITLE_FRAG_PROCESSED));

    _this.config = hls.config;
    _this.vttFragSNsProcessed = {};
    _this.vttFragQueues = undefined;
    _this.currentlyProcessing = null;
    _this.currentTrackId = -1;
    return _this;
  }

  _createClass(SubtitleStreamController, [{
    key: 'destroy',
    value: function destroy() {
      _eventHandler2.default.prototype.destroy.call(this);
    }

    // Remove all queued items and create a new, empty queue for each track.

  }, {
    key: 'clearVttFragQueues',
    value: function clearVttFragQueues() {
      var _this2 = this;

      this.vttFragQueues = {};
      this.tracks.forEach(function (track) {
        _this2.vttFragQueues[track.id] = [];
      });
    }

    // If no frag is being processed and queue isn't empty, initiate processing of next frag in line.

  }, {
    key: 'nextFrag',
    value: function nextFrag() {
      if (this.currentlyProcessing === null && this.currentTrackId > -1 && this.vttFragQueues[this.currentTrackId].length) {
        var frag = this.currentlyProcessing = this.vttFragQueues[this.currentTrackId].shift();
        this.hls.trigger(_events2.default.FRAG_LOADING, { frag: frag });
      }
    }

    // When fragment has finished processing, add sn to list of completed if successful.

  }, {
    key: 'onSubtitleFragProcessed',
    value: function onSubtitleFragProcessed(data) {
      if (data.success) {
        this.vttFragSNsProcessed[data.frag.trackId].push(data.frag.sn);
      }
      this.currentlyProcessing = null;
      this.nextFrag();
    }

    // If something goes wrong, procede to next frag, if we were processing one.

  }, {
    key: 'onError',
    value: function onError(data) {
      var frag = data.frag;
      // don't handle frag error not related to subtitle fragment
      if (frag && frag.type !== 'subtitle') {
        return;
      }
      if (this.currentlyProcessing) {
        this.currentlyProcessing = null;
        this.nextFrag();
      }
    }

    // Got all new subtitle tracks.

  }, {
    key: 'onSubtitleTracksUpdated',
    value: function onSubtitleTracksUpdated(data) {
      var _this3 = this;

      _logger.logger.log('subtitle tracks updated');
      this.tracks = data.subtitleTracks;
      this.clearVttFragQueues();
      this.vttFragSNsProcessed = {};
      this.tracks.forEach(function (track) {
        _this3.vttFragSNsProcessed[track.id] = [];
      });
    }
  }, {
    key: 'onSubtitleTrackSwitch',
    value: function onSubtitleTrackSwitch(data) {
      this.currentTrackId = data.id;
      this.clearVttFragQueues();
    }

    // Got a new set of subtitle fragments.

  }, {
    key: 'onSubtitleTrackLoaded',
    value: function onSubtitleTrackLoaded(data) {
      var processedFragSNs = this.vttFragSNsProcessed[data.id],
          fragQueue = this.vttFragQueues[data.id],
          currentFragSN = !!this.currentlyProcessing ? this.currentlyProcessing.sn : -1;

      var alreadyProcessed = function alreadyProcessed(frag) {
        return processedFragSNs.indexOf(frag.sn) > -1;
      };

      var alreadyInQueue = function alreadyInQueue(frag) {
        return fragQueue.some(function (fragInQueue) {
          return fragInQueue.sn === frag.sn;
        });
      };

      // Add all fragments that haven't been, aren't currently being and aren't waiting to be processed, to queue.
      data.details.fragments.forEach(function (frag) {
        if (!(alreadyProcessed(frag) || frag.sn === currentFragSN || alreadyInQueue(frag))) {
          // Frags don't know their subtitle track ID, so let's just add that...
          frag.trackId = data.id;
          fragQueue.push(frag);
        }
      });

      this.nextFrag();
    }
  }]);

  return SubtitleStreamController;
}(_eventHandler2.default);

exports.default = SubtitleStreamController;

},{"../event-handler":29,"../events":30,"../utils/logger":47}],14:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _eventHandler = require('../event-handler');

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _logger = require('../utils/logger');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * audio track controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

var SubtitleTrackController = function (_EventHandler) {
  _inherits(SubtitleTrackController, _EventHandler);

  function SubtitleTrackController(hls) {
    _classCallCheck(this, SubtitleTrackController);

    var _this = _possibleConstructorReturn(this, (SubtitleTrackController.__proto__ || Object.getPrototypeOf(SubtitleTrackController)).call(this, hls, _events2.default.MEDIA_ATTACHED, _events2.default.MEDIA_DETACHING, _events2.default.MANIFEST_LOADING, _events2.default.MANIFEST_LOADED, _events2.default.SUBTITLE_TRACK_LOADED));

    _this.tracks = [];
    _this.trackId = -1;
    _this.media = undefined;
    return _this;
  }

  _createClass(SubtitleTrackController, [{
    key: 'destroy',
    value: function destroy() {
      _eventHandler2.default.prototype.destroy.call(this);
    }

    // Listen for subtitle track change, then extract the current track ID.

  }, {
    key: 'onMediaAttached',
    value: function onMediaAttached(data) {
      var _this2 = this;

      this.media = data.media;
      if (!this.media) {
        return;
      }

      this.media.textTracks.addEventListener('change', function () {
        // Media is undefined when switching streams via loadSource()
        if (!_this2.media) {
          return;
        }

        var trackId = -1;
        var tracks = _this2.media.textTracks;
        for (var id = 0; id < tracks.length; id++) {
          if (tracks[id].mode === 'showing') {
            trackId = id;
          }
        }
        // Setting current subtitleTrack will invoke code.
        _this2.subtitleTrack = trackId;
      });
    }
  }, {
    key: 'onMediaDetaching',
    value: function onMediaDetaching() {
      // TODO: Remove event listeners.
      this.media = undefined;
    }

    // Reset subtitle tracks on manifest loading

  }, {
    key: 'onManifestLoading',
    value: function onManifestLoading() {
      this.tracks = [];
      this.trackId = -1;
    }

    // Fired whenever a new manifest is loaded.

  }, {
    key: 'onManifestLoaded',
    value: function onManifestLoaded(data) {
      var _this3 = this;

      var tracks = data.subtitles || [];
      var defaultFound = false;
      this.tracks = tracks;
      this.trackId = -1;
      this.hls.trigger(_events2.default.SUBTITLE_TRACKS_UPDATED, { subtitleTracks: tracks });

      // loop through available subtitle tracks and autoselect default if needed
      // TODO: improve selection logic to handle forced, etc
      tracks.forEach(function (track) {
        if (track.default) {
          _this3.subtitleTrack = track.id;
          defaultFound = true;
        }
      });
    }

    // Trigger subtitle track playlist reload.

  }, {
    key: 'onTick',
    value: function onTick() {
      var trackId = this.trackId;
      var subtitleTrack = this.tracks[trackId];
      if (!subtitleTrack) {
        return;
      }

      var details = subtitleTrack.details;
      // check if we need to load playlist for this subtitle Track
      if (details === undefined || details.live === true) {
        // track not retrieved yet, or live playlist we need to (re)load it
        _logger.logger.log('(re)loading playlist for subtitle track ' + trackId);
        this.hls.trigger(_events2.default.SUBTITLE_TRACK_LOADING, { url: subtitleTrack.url, id: trackId });
      }
    }
  }, {
    key: 'onSubtitleTrackLoaded',
    value: function onSubtitleTrackLoaded(data) {
      var _this4 = this;

      if (data.id < this.tracks.length) {
        _logger.logger.log('subtitle track ' + data.id + ' loaded');
        this.tracks[data.id].details = data.details;
        // check if current playlist is a live playlist
        if (data.details.live && !this.timer) {
          // if live playlist we will have to reload it periodically
          // set reload period to playlist target duration
          this.timer = setInterval(function () {
            _this4.onTick();
          }, 1000 * data.details.targetduration, this);
        }
        if (!data.details.live && this.timer) {
          // playlist is not live and timer is armed : stopping it
          clearInterval(this.timer);
          this.timer = null;
        }
      }
    }

    /** get alternate subtitle tracks list from playlist **/

  }, {
    key: 'setSubtitleTrackInternal',
    value: function setSubtitleTrackInternal(newId) {
      // check if level idx is valid
      if (newId >= 0 && newId < this.tracks.length) {
        // stopping live reloading timer if any
        if (this.timer) {
          clearInterval(this.timer);
          this.timer = null;
        }
        this.trackId = newId;
        _logger.logger.log('switching to subtitle track ' + newId);
        var subtitleTrack = this.tracks[newId];
        this.hls.trigger(_events2.default.SUBTITLE_TRACK_SWITCH, { id: newId });
        // check if we need to load playlist for this subtitle Track
        var details = subtitleTrack.details;
        if (details === undefined || details.live === true) {
          // track not retrieved yet, or live playlist we need to (re)load it
          _logger.logger.log('(re)loading playlist for subtitle track ' + newId);
          this.hls.trigger(_events2.default.SUBTITLE_TRACK_LOADING, { url: subtitleTrack.url, id: newId });
        }
      }
    }
  }, {
    key: 'subtitleTracks',
    get: function get() {
      return this.tracks;
    }

    /** get index of the selected subtitle track (index in subtitle track lists) **/

  }, {
    key: 'subtitleTrack',
    get: function get() {
      return this.trackId;
    }

    /** select a subtitle track, based on its index in subtitle track lists**/
    ,
    set: function set(subtitleTrackId) {
      if (this.trackId !== subtitleTrackId) {
        // || this.tracks[subtitleTrackId].details === undefined) {
        this.setSubtitleTrackInternal(subtitleTrackId);
      }
    }
  }]);

  return SubtitleTrackController;
}(_eventHandler2.default);

exports.default = SubtitleTrackController;

},{"../event-handler":29,"../events":30,"../utils/logger":47}],15:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _eventHandler = require('../event-handler');

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _cea608Parser = require('../utils/cea-608-parser');

var _cea608Parser2 = _interopRequireDefault(_cea608Parser);

var _webvttParser = require('../utils/webvtt-parser');

var _webvttParser2 = _interopRequireDefault(_webvttParser);

var _logger = require('../utils/logger');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Timeline Controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

function clearCurrentCues(track) {
  if (track && track.cues) {
    while (track.cues.length > 0) {
      track.removeCue(track.cues[0]);
    }
  }
}

function reuseVttTextTrack(inUseTrack, manifestTrack) {
  return inUseTrack && inUseTrack.label === manifestTrack.name && !(inUseTrack.textTrack1 || inUseTrack.textTrack2);
}

function intersection(x1, x2, y1, y2) {
  return Math.min(x2, y2) - Math.max(x1, y1);
}

var TimelineController = function (_EventHandler) {
  _inherits(TimelineController, _EventHandler);

  function TimelineController(hls) {
    _classCallCheck(this, TimelineController);

    var _this = _possibleConstructorReturn(this, (TimelineController.__proto__ || Object.getPrototypeOf(TimelineController)).call(this, hls, _events2.default.MEDIA_ATTACHING, _events2.default.MEDIA_DETACHING, _events2.default.FRAG_PARSING_USERDATA, _events2.default.MANIFEST_LOADING, _events2.default.MANIFEST_LOADED, _events2.default.FRAG_LOADED, _events2.default.LEVEL_SWITCH, _events2.default.INIT_PTS_FOUND));

    _this.hls = hls;
    _this.config = hls.config;
    _this.enabled = true;
    _this.Cues = hls.config.cueHandler;
    _this.textTracks = [];
    _this.tracks = [];
    _this.unparsedVttFrags = [];
    _this.initPTS = undefined;
    _this.cueRanges = [];

    if (_this.config.enableCEA708Captions) {
      var self = _this;
      var sendAddTrackEvent = function sendAddTrackEvent(track, media) {
        var e = null;
        try {
          e = new window.Event('addtrack');
        } catch (err) {
          //for IE11
          e = document.createEvent('Event');
          e.initEvent('addtrack', false, false);
        }
        e.track = track;
        media.dispatchEvent(e);
      };

      var channel1 = {
        'newCue': function newCue(startTime, endTime, screen) {
          if (!self.textTrack1) {
            //Enable reuse of existing text track.
            var existingTrack1 = self.getExistingTrack('1');
            if (!existingTrack1) {
              self.textTrack1 = self.createTextTrack('captions', 'English', 'en');
              self.textTrack1.textTrack1 = true;
            } else {
              self.textTrack1 = existingTrack1;
              self.clearCurrentCues(self.textTrack1);
              sendAddTrackEvent(self.textTrack1, self.media);
            }
          }
          self.addCues('textTrack1', startTime, endTime, screen);
        }
      };

      var channel2 = {
        'newCue': function newCue(startTime, endTime, screen) {
          if (!self.textTrack2) {
            //Enable reuse of existing text track.
            var existingTrack2 = self.getExistingTrack('2');
            if (!existingTrack2) {
              self.textTrack2 = self.createTextTrack('captions', 'Spanish', 'es');
              self.textTrack2.textTrack2 = true;
            } else {
              self.textTrack2 = existingTrack2;

              sendAddTrackEvent(self.textTrack2, self.media);
            }
          }
          self.addCues('textTrack2', startTime, endTime, screen);
        }
      };

      _this.cea608Parser = new _cea608Parser2.default(0, channel1, channel2);
    }
    return _this;
  }

  _createClass(TimelineController, [{
    key: 'addCues',
    value: function addCues(channel, startTime, endTime, screen) {
      // skip cues which overlap more than 50% with previously parsed time ranges
      var ranges = this.cueRanges;
      var merged = false;
      for (var i = ranges.length; i--;) {
        var cueRange = ranges[i];
        var overlap = intersection(cueRange[0], cueRange[1], startTime, endTime);
        if (overlap >= 0) {
          cueRange[0] = Math.min(cueRange[0], startTime);
          cueRange[1] = Math.max(cueRange[1], endTime);
          merged = true;
          if (overlap / (endTime - startTime) > 0.5) {
            return;
          }
        }
      }
      if (!merged) {
        ranges.push([startTime, endTime]);
      }
      this.Cues.newCue(this[channel], startTime, endTime, screen);
    }

    // Triggered when an initial PTS is found; used for synchronisation of WebVTT.

  }, {
    key: 'onInitPtsFound',
    value: function onInitPtsFound(data) {
      var _this2 = this;

      if (typeof this.initPTS === 'undefined') {
        this.initPTS = data.initPTS;
      }

      // Due to asynchrony, initial PTS may arrive later than the first VTT fragments are loaded.
      // Parse any unparsed fragments upon receiving the initial PTS.
      if (this.unparsedVttFrags.length) {
        this.unparsedVttFrags.forEach(function (frag) {
          _this2.onFragLoaded(frag);
        });
        this.unparsedVttFrags = [];
      }
    }
  }, {
    key: 'getExistingTrack',
    value: function getExistingTrack(channelNumber) {
      var media = this.media;
      if (media) {
        for (var i = 0; i < media.textTracks.length; i++) {
          var textTrack = media.textTracks[i];
          var propName = 'textTrack' + channelNumber;
          if (textTrack[propName] === true) {
            return textTrack;
          }
        }
      }
      return null;
    }
  }, {
    key: 'createTextTrack',
    value: function createTextTrack(kind, label, lang) {
      if (this.media) {
        return this.media.addTextTrack(kind, label, lang);
      }
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      _eventHandler2.default.prototype.destroy.call(this);
    }
  }, {
    key: 'onMediaAttaching',
    value: function onMediaAttaching(data) {
      this.media = data.media;
    }
  }, {
    key: 'onMediaDetaching',
    value: function onMediaDetaching() {
      clearCurrentCues(this.textTrack1);
      clearCurrentCues(this.textTrack2);
    }
  }, {
    key: 'onManifestLoading',
    value: function onManifestLoading() {
      this.lastSn = -1; // Detect discontiguity in fragment parsing
      this.prevCC = -1;
      this.vttCCs = { ccOffset: 0, presentationOffset: 0 }; // Detect discontinuity in subtitle manifests
    }
  }, {
    key: 'onManifestLoaded',
    value: function onManifestLoaded(data) {
      var _this3 = this;

      this.textTracks = [];
      this.unparsedVttFrags = this.unparsedVttFrags || [];
      this.initPTS = undefined;
      this.cueRanges = [];

      if (this.config.enableWebVTT) {
        (function () {
          _this3.tracks = data.subtitles || [];
          var inUseTracks = _this3.media ? _this3.media.textTracks : [];

          _this3.tracks.forEach(function (track, index) {
            var textTrack = void 0;
            var inUseTrack = inUseTracks[index];
            // Reuse tracks with the same label, but do not reuse 608/708 tracks
            if (reuseVttTextTrack(inUseTrack, track)) {
              textTrack = inUseTrack;
            } else {
              textTrack = _this3.createTextTrack('subtitles', track.name, track.lang);
            }
            textTrack.mode = track.default ? 'showing' : 'hidden';
            _this3.textTracks.push(textTrack);
          });
        })();
      }
    }
  }, {
    key: 'onLevelSwitch',
    value: function onLevelSwitch() {
      this.enabled = this.hls.currentLevel.closedCaptions !== 'NONE';
    }
  }, {
    key: 'onFragLoaded',
    value: function onFragLoaded(data) {
      var _this4 = this;

      var frag = data.frag,
          payload = data.payload;
      if (frag.type === 'main') {
        var sn = frag.sn;
        // if this frag isn't contiguous, clear the parser so cues with bad start/end times aren't added to the textTrack
        if (sn !== this.lastSn + 1) {
          this.cea608Parser.reset();
        }
        this.lastSn = sn;
      }
      // If fragment is subtitle type, parse as WebVTT.
      else if (frag.type === 'subtitle') {
          if (payload.byteLength) {
            var _ret2 = function () {
              // We need an initial synchronisation PTS. Store fragments as long as none has arrived.
              if (typeof _this4.initPTS === 'undefined') {
                _this4.unparsedVttFrags.push(data);
                return {
                  v: void 0
                };
              }
              var vttCCs = _this4.vttCCs;
              if (!vttCCs[frag.cc]) {
                vttCCs[frag.cc] = { start: frag.start, prevCC: _this4.prevCC, new: true };
                _this4.prevCC = frag.cc;
              }
              var textTracks = _this4.textTracks,
                  hls = _this4.hls;

              // Parse the WebVTT file contents.
              _webvttParser2.default.parse(payload, _this4.initPTS, vttCCs, frag.cc, function (cues) {
                // Add cues and trigger event with success true.
                cues.forEach(function (cue) {
                  textTracks[frag.trackId].addCue(cue);
                });
                hls.trigger(_events2.default.SUBTITLE_FRAG_PROCESSED, { success: true, frag: frag });
              }, function (e) {
                // Something went wrong while parsing. Trigger event with success false.
                _logger.logger.log('Failed to parse VTT cue: ' + e);
                hls.trigger(_events2.default.SUBTITLE_FRAG_PROCESSED, { success: false, frag: frag });
              });
            }();

            if ((typeof _ret2 === 'undefined' ? 'undefined' : _typeof(_ret2)) === "object") return _ret2.v;
          } else {
            // In case there is no payload, finish unsuccessfully.
            this.hls.trigger(_events2.default.SUBTITLE_FRAG_PROCESSED, { success: false, frag: frag });
          }
        }
    }
  }, {
    key: 'onFragParsingUserdata',
    value: function onFragParsingUserdata(data) {
      // push all of the CEA-708 messages into the interpreter
      // immediately. It will create the proper timestamps based on our PTS value
      if (this.enabled && this.config.enableCEA708Captions) {
        for (var i = 0; i < data.samples.length; i++) {
          var ccdatas = this.extractCea608Data(data.samples[i].bytes);
          this.cea608Parser.addData(data.samples[i].pts, ccdatas);
        }
      }
    }
  }, {
    key: 'extractCea608Data',
    value: function extractCea608Data(byteArray) {
      var count = byteArray[0] & 31;
      var position = 2;
      var tmpByte, ccbyte1, ccbyte2, ccValid, ccType;
      var actualCCBytes = [];

      for (var j = 0; j < count; j++) {
        tmpByte = byteArray[position++];
        ccbyte1 = 0x7F & byteArray[position++];
        ccbyte2 = 0x7F & byteArray[position++];
        ccValid = (4 & tmpByte) !== 0;
        ccType = 3 & tmpByte;

        if (ccbyte1 === 0 && ccbyte2 === 0) {
          continue;
        }

        if (ccValid) {
          if (ccType === 0) // || ccType === 1
            {
              actualCCBytes.push(ccbyte1);
              actualCCBytes.push(ccbyte2);
            }
        }
      }
      return actualCCBytes;
    }
  }]);

  return TimelineController;
}(_eventHandler2.default);

exports.default = TimelineController;

},{"../event-handler":29,"../events":30,"../utils/cea-608-parser":44,"../utils/logger":47,"../utils/webvtt-parser":51}],16:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var AESCrypto = function () {
  function AESCrypto(subtle, iv) {
    _classCallCheck(this, AESCrypto);

    this.subtle = subtle;
    this.aesIV = iv;
  }

  _createClass(AESCrypto, [{
    key: 'decrypt',
    value: function decrypt(data, key) {
      return this.subtle.decrypt({ name: 'AES-CBC', iv: this.aesIV }, key, data);
    }
  }]);

  return AESCrypto;
}();

exports.default = AESCrypto;

},{}],17:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var AESDecryptor = function () {
  function AESDecryptor() {
    _classCallCheck(this, AESDecryptor);

    // Static after running initTable
    this.rcon = [0x0, 0x1, 0x2, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];

    this.subMix = [];
    this.subMix[0] = new Uint32Array(256);
    this.subMix[1] = new Uint32Array(256);
    this.subMix[2] = new Uint32Array(256);
    this.subMix[3] = new Uint32Array(256);

    this.invSubMix = [];
    this.invSubMix[0] = new Uint32Array(256);
    this.invSubMix[1] = new Uint32Array(256);
    this.invSubMix[2] = new Uint32Array(256);
    this.invSubMix[3] = new Uint32Array(256);

    this.sBox = new Uint32Array(256);
    this.invSBox = new Uint32Array(256);

    // Changes during runtime
    this.key = new Uint32Array(0);

    this.initTable();
  }

  // Using view.getUint32() also swaps the byte order.


  _createClass(AESDecryptor, [{
    key: 'uint8ArrayToUint32Array_',
    value: function uint8ArrayToUint32Array_(arrayBuffer) {
      var view = new DataView(arrayBuffer);
      var newArray = new Uint32Array(4);
      for (var i = 0; i < newArray.length; i++) {
        newArray[i] = view.getUint32(i * 4);
      }
      return newArray;
    }
  }, {
    key: 'initTable',
    value: function initTable() {
      var sBox = this.sBox;
      var invSBox = this.invSBox;
      var subMix0 = this.subMix[0];
      var subMix1 = this.subMix[1];
      var subMix2 = this.subMix[2];
      var subMix3 = this.subMix[3];
      var invSubMix0 = this.invSubMix[0];
      var invSubMix1 = this.invSubMix[1];
      var invSubMix2 = this.invSubMix[2];
      var invSubMix3 = this.invSubMix[3];

      var d = new Uint32Array(256);
      var x = 0;
      var xi = 0;
      var i = 0;
      for (i = 0; i < 256; i++) {
        if (i < 128) {
          d[i] = i << 1;
        } else {
          d[i] = i << 1 ^ 0x11b;
        }
      }

      for (i = 0; i < 256; i++) {
        var sx = xi ^ xi << 1 ^ xi << 2 ^ xi << 3 ^ xi << 4;
        sx = sx >>> 8 ^ sx & 0xff ^ 0x63;
        sBox[x] = sx;
        invSBox[sx] = x;

        // Compute multiplication
        var x2 = d[x];
        var x4 = d[x2];
        var x8 = d[x4];

        // Compute sub/invSub bytes, mix columns tables
        var t = d[sx] * 0x101 ^ sx * 0x1010100;
        subMix0[x] = t << 24 | t >>> 8;
        subMix1[x] = t << 16 | t >>> 16;
        subMix2[x] = t << 8 | t >>> 24;
        subMix3[x] = t;

        // Compute inv sub bytes, inv mix columns tables
        t = x8 * 0x1010101 ^ x4 * 0x10001 ^ x2 * 0x101 ^ x * 0x1010100;
        invSubMix0[sx] = t << 24 | t >>> 8;
        invSubMix1[sx] = t << 16 | t >>> 16;
        invSubMix2[sx] = t << 8 | t >>> 24;
        invSubMix3[sx] = t;

        // Compute next counter
        if (!x) {
          x = xi = 1;
        } else {
          x = x2 ^ d[d[d[x8 ^ x2]]];
          xi ^= d[d[xi]];
        }
      }
    }
  }, {
    key: 'expandKey',
    value: function expandKey(keyBuffer) {
      // convert keyBuffer to Uint32Array
      var key = this.uint8ArrayToUint32Array_(keyBuffer);
      var sameKey = true;
      var offset = 0;

      while (offset < key.length && sameKey) {
        sameKey = key[offset] === this.key[offset];
        offset++;
      }

      if (sameKey) {
        return;
      }

      this.key = key;
      var keySize = this.keySize = key.length;

      if (keySize !== 4 && keySize !== 6 && keySize !== 8) {
        throw new Error('Invalid aes key size=' + keySize);
      }

      var ksRows = this.ksRows = (keySize + 6 + 1) * 4;
      var ksRow = void 0;
      var invKsRow = void 0;

      var keySchedule = this.keySchedule = new Uint32Array(this.ksRows);
      var invKeySchedule = this.invKeySchedule = new Uint32Array(this.ksRows);
      var sbox = this.sBox;
      var rcon = this.rcon;

      var invSubMix0 = this.invSubMix[0];
      var invSubMix1 = this.invSubMix[1];
      var invSubMix2 = this.invSubMix[2];
      var invSubMix3 = this.invSubMix[3];

      var prev = void 0;
      var t = void 0;

      for (ksRow = 0; ksRow < ksRows; ksRow++) {
        if (ksRow < keySize) {
          prev = keySchedule[ksRow] = key[ksRow];
          continue;
        }
        t = prev;

        if (ksRow % keySize === 0) {
          // Rot word
          t = t << 8 | t >>> 24;

          // Sub word
          t = sbox[t >>> 24] << 24 | sbox[t >>> 16 & 0xff] << 16 | sbox[t >>> 8 & 0xff] << 8 | sbox[t & 0xff];

          // Mix Rcon
          t ^= rcon[ksRow / keySize | 0] << 24;
        } else if (keySize > 6 && ksRow % keySize === 4) {
          // Sub word
          t = sbox[t >>> 24] << 24 | sbox[t >>> 16 & 0xff] << 16 | sbox[t >>> 8 & 0xff] << 8 | sbox[t & 0xff];
        }

        keySchedule[ksRow] = prev = (keySchedule[ksRow - keySize] ^ t) >>> 0;
      }

      for (invKsRow = 0; invKsRow < ksRows; invKsRow++) {
        ksRow = ksRows - invKsRow;
        if (invKsRow & 3) {
          t = keySchedule[ksRow];
        } else {
          t = keySchedule[ksRow - 4];
        }

        if (invKsRow < 4 || ksRow <= 4) {
          invKeySchedule[invKsRow] = t;
        } else {
          invKeySchedule[invKsRow] = invSubMix0[sbox[t >>> 24]] ^ invSubMix1[sbox[t >>> 16 & 0xff]] ^ invSubMix2[sbox[t >>> 8 & 0xff]] ^ invSubMix3[sbox[t & 0xff]];
        }

        invKeySchedule[invKsRow] = invKeySchedule[invKsRow] >>> 0;
      }
    }

    // Adding this as a method greatly improves performance.

  }, {
    key: 'networkToHostOrderSwap',
    value: function networkToHostOrderSwap(word) {
      return word << 24 | (word & 0xff00) << 8 | (word & 0xff0000) >> 8 | word >>> 24;
    }
  }, {
    key: 'decrypt',
    value: function decrypt(inputArrayBuffer, offset, aesIV) {
      var nRounds = this.keySize + 6;
      var invKeySchedule = this.invKeySchedule;
      var invSBOX = this.invSBox;

      var invSubMix0 = this.invSubMix[0];
      var invSubMix1 = this.invSubMix[1];
      var invSubMix2 = this.invSubMix[2];
      var invSubMix3 = this.invSubMix[3];

      var initVector = this.uint8ArrayToUint32Array_(aesIV);
      var initVector0 = initVector[0];
      var initVector1 = initVector[1];
      var initVector2 = initVector[2];
      var initVector3 = initVector[3];

      var inputInt32 = new Int32Array(inputArrayBuffer);
      var outputInt32 = new Int32Array(inputInt32.length);

      var t0 = void 0,
          t1 = void 0,
          t2 = void 0,
          t3 = void 0;
      var s0 = void 0,
          s1 = void 0,
          s2 = void 0,
          s3 = void 0;
      var inputWords0 = void 0,
          inputWords1 = void 0,
          inputWords2 = void 0,
          inputWords3 = void 0;

      var ksRow, i;

      while (offset < inputInt32.length) {
        inputWords0 = this.networkToHostOrderSwap(inputInt32[offset]);
        inputWords1 = this.networkToHostOrderSwap(inputInt32[offset + 1]);
        inputWords2 = this.networkToHostOrderSwap(inputInt32[offset + 2]);
        inputWords3 = this.networkToHostOrderSwap(inputInt32[offset + 3]);

        s0 = inputWords0 ^ invKeySchedule[0];
        s1 = inputWords3 ^ invKeySchedule[1];
        s2 = inputWords2 ^ invKeySchedule[2];
        s3 = inputWords1 ^ invKeySchedule[3];

        ksRow = 4;

        // Iterate through the rounds of decryption
        for (i = 1; i < nRounds; i++) {
          t0 = invSubMix0[s0 >>> 24] ^ invSubMix1[s1 >> 16 & 0xff] ^ invSubMix2[s2 >> 8 & 0xff] ^ invSubMix3[s3 & 0xff] ^ invKeySchedule[ksRow];
          t1 = invSubMix0[s1 >>> 24] ^ invSubMix1[s2 >> 16 & 0xff] ^ invSubMix2[s3 >> 8 & 0xff] ^ invSubMix3[s0 & 0xff] ^ invKeySchedule[ksRow + 1];
          t2 = invSubMix0[s2 >>> 24] ^ invSubMix1[s3 >> 16 & 0xff] ^ invSubMix2[s0 >> 8 & 0xff] ^ invSubMix3[s1 & 0xff] ^ invKeySchedule[ksRow + 2];
          t3 = invSubMix0[s3 >>> 24] ^ invSubMix1[s0 >> 16 & 0xff] ^ invSubMix2[s1 >> 8 & 0xff] ^ invSubMix3[s2 & 0xff] ^ invKeySchedule[ksRow + 3];
          // Update state
          s0 = t0;
          s1 = t1;
          s2 = t2;
          s3 = t3;

          ksRow = ksRow + 4;
        }

        // Shift rows, sub bytes, add round key
        t0 = invSBOX[s0 >>> 24] << 24 ^ invSBOX[s1 >> 16 & 0xff] << 16 ^ invSBOX[s2 >> 8 & 0xff] << 8 ^ invSBOX[s3 & 0xff] ^ invKeySchedule[ksRow];
        t1 = invSBOX[s1 >>> 24] << 24 ^ invSBOX[s2 >> 16 & 0xff] << 16 ^ invSBOX[s3 >> 8 & 0xff] << 8 ^ invSBOX[s0 & 0xff] ^ invKeySchedule[ksRow + 1];
        t2 = invSBOX[s2 >>> 24] << 24 ^ invSBOX[s3 >> 16 & 0xff] << 16 ^ invSBOX[s0 >> 8 & 0xff] << 8 ^ invSBOX[s1 & 0xff] ^ invKeySchedule[ksRow + 2];
        t3 = invSBOX[s3 >>> 24] << 24 ^ invSBOX[s0 >> 16 & 0xff] << 16 ^ invSBOX[s1 >> 8 & 0xff] << 8 ^ invSBOX[s2 & 0xff] ^ invKeySchedule[ksRow + 3];
        ksRow = ksRow + 3;

        // Write
        outputInt32[offset] = this.networkToHostOrderSwap(t0 ^ initVector0);
        outputInt32[offset + 1] = this.networkToHostOrderSwap(t3 ^ initVector1);
        outputInt32[offset + 2] = this.networkToHostOrderSwap(t2 ^ initVector2);
        outputInt32[offset + 3] = this.networkToHostOrderSwap(t1 ^ initVector3);

        // reset initVector to last 4 unsigned int
        initVector0 = inputWords0;
        initVector1 = inputWords1;
        initVector2 = inputWords2;
        initVector3 = inputWords3;

        offset = offset + 4;
      }

      return outputInt32.buffer;
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      this.key = undefined;
      this.keySize = undefined;
      this.ksRows = undefined;

      this.sBox = undefined;
      this.invSBox = undefined;
      this.subMix = undefined;
      this.invSubMix = undefined;
      this.keySchedule = undefined;
      this.invKeySchedule = undefined;

      this.rcon = undefined;
    }
  }]);

  return AESDecryptor;
}();

exports.default = AESDecryptor;

},{}],18:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _aesCrypto = require('./aes-crypto');

var _aesCrypto2 = _interopRequireDefault(_aesCrypto);

var _fastAesKey = require('./fast-aes-key');

var _fastAesKey2 = _interopRequireDefault(_fastAesKey);

var _aesDecryptor = require('./aes-decryptor');

var _aesDecryptor2 = _interopRequireDefault(_aesDecryptor);

var _errors = require('../errors');

var _logger = require('../utils/logger');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Decrypter = function () {
  function Decrypter(hls) {
    _classCallCheck(this, Decrypter);

    this.hls = hls;
    try {
      var browserCrypto = window ? window.crypto : crypto;
      this.subtle = browserCrypto.subtle || browserCrypto.webkitSubtle;
    } catch (e) {}

    this.disableWebCrypto = !this.supportsWebCrypto();
  }

  _createClass(Decrypter, [{
    key: 'supportsWebCrypto',
    value: function supportsWebCrypto() {
      return this.subtle && window.location.protocol === 'https:';
    }
  }, {
    key: 'decrypt',
    value: function decrypt(data, key, iv, callback) {
      var _this = this;

      if (this.disableWebCrypto && this.hls.config.enableSoftwareAES) {
        _logger.logger.log('decrypting by JavaScript Implementation');
        if (!this.decryptor) {
          this.decryptor = new _aesDecryptor2.default();
        }
        this.decryptor.expandKey(key);
        callback(this.decryptor.decrypt(data, 0, iv));
      } else {
        (function () {
          _logger.logger.log('decrypting by WebCrypto API');
          var subtle = _this.subtle;
          if (_this.key !== key) {
            _this.key = key;
            _this.fastAesKey = new _fastAesKey2.default(subtle, key);
          }

          _this.fastAesKey.expandKey().then(function (aesKey) {
            // decrypt using web crypto
            var crypto = new _aesCrypto2.default(subtle, iv);
            crypto.decrypt(data, aesKey).then(function (result) {
              callback(result);
            });
          }).catch(function (err) {
            _this.onWebCryptoError(err, data, key, iv, callback);
          });
        })();
      }
    }
  }, {
    key: 'onWebCryptoError',
    value: function onWebCryptoError(err, data, key, iv, callback) {
      var hls = this.hls;
      if (hls.config.enableSoftwareAES) {
        _logger.logger.log('disabling to use WebCrypto API');
        this.disableWebCrypto = true;
        this.decrypt(data, key, iv, callback);
      } else {
        _logger.logger.error('decrypting error : ' + err.message);
        hls.trigger(Event.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.FRAG_DECRYPT_ERROR, fatal: true, reason: err.message });
      }
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      var decryptor = this.decryptor;
      if (decryptor) {
        decryptor.destroy();
        this.decryptor = undefined;
      }
    }
  }]);

  return Decrypter;
}();

exports.default = Decrypter;

},{"../errors":28,"../utils/logger":47,"./aes-crypto":16,"./aes-decryptor":17,"./fast-aes-key":19}],19:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var FastAESKey = function () {
  function FastAESKey(subtle, key) {
    _classCallCheck(this, FastAESKey);

    this.subtle = subtle;
    this.key = key;
  }

  _createClass(FastAESKey, [{
    key: 'expandKey',
    value: function expandKey() {
      return this.subtle.importKey('raw', this.key, { name: 'AES-CBC' }, false, ['encrypt', 'decrypt']);
    }
  }]);

  return FastAESKey;
}();

exports.default = FastAESKey;

},{}],20:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * AAC demuxer
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */


var _adts = require('./adts');

var _adts2 = _interopRequireDefault(_adts);

var _logger = require('../utils/logger');

var _id = require('../demux/id3');

var _id2 = _interopRequireDefault(_id);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var AACDemuxer = function () {
  function AACDemuxer(observer, id, remuxerClass, config, typeSupported) {
    _classCallCheck(this, AACDemuxer);

    this.observer = observer;
    this.id = id;
    this.remuxerClass = remuxerClass;
    this.config = config;
    this.remuxer = new this.remuxerClass(observer, id, config, typeSupported);
    // id === 'main' when the demuxer is used to play an audio only stream and requires AAC files placed back-to-back in the order they are received.
    // id === 'audio' when the demuxer is used for multitrack audio and requires the use of timestamps to sync audio with video.
    this.useTimeStamp = id === 'audio';
    this.insertDiscontinuity();
  }

  _createClass(AACDemuxer, [{
    key: 'insertDiscontinuity',
    value: function insertDiscontinuity() {
      this._aacTrack = { container: 'audio/adts', type: 'audio', id: -1, sequenceNumber: 0, isAAC: true, samples: [], len: 0 };
    }

    // Source for probe info - https://wiki.multimedia.cx/index.php?title=ADTS

  }, {
    key: 'push',


    // feed incoming data to the front of the parsing pipeline
    value: function push(data, audioCodec, videoCodec, timeOffset, cc, level, sn, duration, accurateTimeOffset, defaultInitPTS) {
      var track,
          id3 = new _id2.default(data),
          pts,
          config,
          frameLength,
          frameDuration,
          frameIndex,
          offset,
          headerLength,
          stamp,
          len,
          aacSample;

      // Use ID3 Timestamp if needed, as in v4 audio tracks.  Otherwise, concat AAC audio in the order it comes in.
      pts = this.useTimeStamp ? 90 * id3.timeStamp : timeOffset * 90000;

      var contiguous = false;
      if (cc !== this.lastCC) {
        _logger.logger.log(this.id + ' discontinuity detected');
        this.lastCC = cc;
        this.insertDiscontinuity();
        this.remuxer.switchLevel();
        this.remuxer.insertDiscontinuity();
      } else if (level !== this.lastLevel) {
        _logger.logger.log('audio track switch detected');
        this.lastLevel = level;
        this.remuxer.switchLevel();
        this.insertDiscontinuity();
      } else if (sn === this.lastSN + 1) {
        contiguous = true;
      }
      track = this._aacTrack;
      this.lastSN = sn;
      this.lastLevel = level;

      // Look for ADTS header | 1111 1111 | 1111 X00X | where X can be either 0 or 1
      for (offset = id3.length || 0, len = data.length; offset < len - 1; offset++) {
        if (data[offset] === 0xff && (data[offset + 1] & 0xf6) === 0xf0) {
          break;
        }
      }

      if (!track.audiosamplerate) {
        config = _adts2.default.getAudioConfig(this.observer, data, offset, audioCodec);
        track.config = config.config;
        track.audiosamplerate = config.samplerate;
        track.channelCount = config.channelCount;
        track.codec = config.codec;
        track.duration = duration;
        _logger.logger.log('parsed codec:' + track.codec + ',rate:' + config.samplerate + ',nb channel:' + config.channelCount);
      }
      frameIndex = 0;
      frameDuration = 1024 * 90000 / track.audiosamplerate;
      while (offset + 5 < len) {
        // The protection skip bit tells us if we have 2 bytes of CRC data at the end of the ADTS header
        headerLength = !!(data[offset + 1] & 0x01) ? 7 : 9;
        // retrieve frame size
        frameLength = (data[offset + 3] & 0x03) << 11 | data[offset + 4] << 3 | (data[offset + 5] & 0xE0) >>> 5;
        frameLength -= headerLength;
        //stamp = pes.pts;

        if (frameLength > 0 && offset + headerLength + frameLength <= len) {
          stamp = pts + frameIndex * frameDuration;
          //logger.log(`AAC frame, offset/length/total/pts:${offset+headerLength}/${frameLength}/${data.byteLength}/${(stamp/90).toFixed(0)}`);
          aacSample = { unit: data.subarray(offset + headerLength, offset + headerLength + frameLength), pts: stamp, dts: stamp };
          track.samples.push(aacSample);
          track.len += frameLength;
          offset += frameLength + headerLength;
          frameIndex++;
          // look for ADTS header (0xFFFx)
          for (; offset < len - 1; offset++) {
            if (data[offset] === 0xff && (data[offset + 1] & 0xf0) === 0xf0) {
              break;
            }
          }
        } else {
          break;
        }
      }
      var id3Track = id3.payload ? { samples: [{ pts: pts, dts: pts, unit: id3.payload }] } : { samples: [] };
      this.remuxer.remux(level, sn, cc, this._aacTrack, { samples: [] }, id3Track, { samples: [] }, timeOffset, contiguous, accurateTimeOffset, defaultInitPTS);
    }
  }, {
    key: 'destroy',
    value: function destroy() {}
  }], [{
    key: 'probe',
    value: function probe(data) {
      var id3 = new _id2.default(data),
          offset,
          len;
      for (offset = id3.length || 0, len = data.length; offset < len - 1; offset++) {
        // ADTS Header is | 1111 1111 | 1111 X00X | where X can be either 0 or 1
        if (data[offset] === 0xff && (data[offset + 1] & 0xf6) === 0xf0) {
          //logger.log('ADTS sync word found !');
          return true;
        }
      }
      return false;
    }
  }]);

  return AACDemuxer;
}();

exports.default = AACDemuxer;

},{"../demux/id3":26,"../utils/logger":47,"./adts":21}],21:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *  ADTS parser helper
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */


var _logger = require('../utils/logger');

var _errors = require('../errors');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ADTS = function () {
  function ADTS() {
    _classCallCheck(this, ADTS);
  }

  _createClass(ADTS, null, [{
    key: 'getAudioConfig',
    value: function getAudioConfig(observer, data, offset, audioCodec) {
      var adtsObjectType,
          // :int
      adtsSampleingIndex,
          // :int
      adtsExtensionSampleingIndex,
          // :int
      adtsChanelConfig,
          // :int
      config,
          userAgent = navigator.userAgent.toLowerCase(),
          adtsSampleingRates = [96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050, 16000, 12000, 11025, 8000, 7350];
      // byte 2
      adtsObjectType = ((data[offset + 2] & 0xC0) >>> 6) + 1;
      adtsSampleingIndex = (data[offset + 2] & 0x3C) >>> 2;
      if (adtsSampleingIndex > adtsSampleingRates.length - 1) {
        observer.trigger(Event.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.FRAG_PARSING_ERROR, fatal: true, reason: 'invalid ADTS sampling index:' + adtsSampleingIndex });
        return;
      }
      adtsChanelConfig = (data[offset + 2] & 0x01) << 2;
      // byte 3
      adtsChanelConfig |= (data[offset + 3] & 0xC0) >>> 6;
      _logger.logger.log('manifest codec:' + audioCodec + ',ADTS data:type:' + adtsObjectType + ',sampleingIndex:' + adtsSampleingIndex + '[' + adtsSampleingRates[adtsSampleingIndex] + 'Hz],channelConfig:' + adtsChanelConfig);
      // firefox/Opera: freq less than 24kHz = AAC SBR (HE-AAC)
      if (/firefox|OPR/i.test(userAgent)) {
        if (adtsSampleingIndex >= 6) {
          adtsObjectType = 5;
          config = new Array(4);
          // HE-AAC uses SBR (Spectral Band Replication) , high frequencies are constructed from low frequencies
          // there is a factor 2 between frame sample rate and output sample rate
          // multiply frequency by 2 (see table below, equivalent to substract 3)
          adtsExtensionSampleingIndex = adtsSampleingIndex - 3;
        } else {
          adtsObjectType = 2;
          config = new Array(2);
          adtsExtensionSampleingIndex = adtsSampleingIndex;
        }
        // Android : always use AAC
      } else if (userAgent.indexOf('android') !== -1) {
        adtsObjectType = 2;
        config = new Array(2);
        adtsExtensionSampleingIndex = adtsSampleingIndex;
      } else {
        /*  for other browsers (Chrome/Vivaldi ...)
            always force audio type to be HE-AAC SBR, as some browsers do not support audio codec switch properly (like Chrome ...)
        */
        adtsObjectType = 5;
        config = new Array(4);
        // if (manifest codec is HE-AAC or HE-AACv2) OR (manifest codec not specified AND frequency less than 24kHz)
        if (audioCodec && (audioCodec.indexOf('mp4a.40.29') !== -1 || audioCodec.indexOf('mp4a.40.5') !== -1) || !audioCodec && adtsSampleingIndex >= 6) {
          // HE-AAC uses SBR (Spectral Band Replication) , high frequencies are constructed from low frequencies
          // there is a factor 2 between frame sample rate and output sample rate
          // multiply frequency by 2 (see table below, equivalent to substract 3)
          adtsExtensionSampleingIndex = adtsSampleingIndex - 3;
        } else {
          // if (manifest codec is AAC) AND (frequency less than 24kHz AND nb channel is 1) OR (manifest codec not specified and mono audio)
          // Chrome fails to play back with low frequency AAC LC mono when initialized with HE-AAC.  This is not a problem with stereo.
          if (audioCodec && audioCodec.indexOf('mp4a.40.2') !== -1 && adtsSampleingIndex >= 6 && adtsChanelConfig === 1 || !audioCodec && adtsChanelConfig === 1) {
            adtsObjectType = 2;
            config = new Array(2);
          }
          adtsExtensionSampleingIndex = adtsSampleingIndex;
        }
      }
      /* refer to http://wiki.multimedia.cx/index.php?title=MPEG-4_Audio#Audio_Specific_Config
          ISO 14496-3 (AAC).pdf - Table 1.13  Syntax of AudioSpecificConfig()
        Audio Profile / Audio Object Type
        0: Null
        1: AAC Main
        2: AAC LC (Low Complexity)
        3: AAC SSR (Scalable Sample Rate)
        4: AAC LTP (Long Term Prediction)
        5: SBR (Spectral Band Replication)
        6: AAC Scalable
       sampling freq
        0: 96000 Hz
        1: 88200 Hz
        2: 64000 Hz
        3: 48000 Hz
        4: 44100 Hz
        5: 32000 Hz
        6: 24000 Hz
        7: 22050 Hz
        8: 16000 Hz
        9: 12000 Hz
        10: 11025 Hz
        11: 8000 Hz
        12: 7350 Hz
        13: Reserved
        14: Reserved
        15: frequency is written explictly
        Channel Configurations
        These are the channel configurations:
        0: Defined in AOT Specifc Config
        1: 1 channel: front-center
        2: 2 channels: front-left, front-right
      */
      // audioObjectType = profile => profile, the MPEG-4 Audio Object Type minus 1
      config[0] = adtsObjectType << 3;
      // samplingFrequencyIndex
      config[0] |= (adtsSampleingIndex & 0x0E) >> 1;
      config[1] |= (adtsSampleingIndex & 0x01) << 7;
      // channelConfiguration
      config[1] |= adtsChanelConfig << 3;
      if (adtsObjectType === 5) {
        // adtsExtensionSampleingIndex
        config[1] |= (adtsExtensionSampleingIndex & 0x0E) >> 1;
        config[2] = (adtsExtensionSampleingIndex & 0x01) << 7;
        // adtsObjectType (force to 2, chrome is checking that object type is less than 5 ???
        //    https://chromium.googlesource.com/chromium/src.git/+/master/media/formats/mp4/aac.cc
        config[2] |= 2 << 2;
        config[3] = 0;
      }
      return { config: config, samplerate: adtsSampleingRates[adtsSampleingIndex], channelCount: adtsChanelConfig, codec: 'mp4a.40.' + adtsObjectType };
    }
  }]);

  return ADTS;
}();

exports.default = ADTS;

},{"../errors":28,"../utils/logger":47}],22:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*  inline demuxer.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *   probe fragments and instantiate appropriate demuxer depending on content type (TSDemuxer, AACDemuxer, ...)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _errors = require('../errors');

var _aacdemuxer = require('../demux/aacdemuxer');

var _aacdemuxer2 = _interopRequireDefault(_aacdemuxer);

var _tsdemuxer = require('../demux/tsdemuxer');

var _tsdemuxer2 = _interopRequireDefault(_tsdemuxer);

var _mp4Remuxer = require('../remux/mp4-remuxer');

var _mp4Remuxer2 = _interopRequireDefault(_mp4Remuxer);

var _passthroughRemuxer = require('../remux/passthrough-remuxer');

var _passthroughRemuxer2 = _interopRequireDefault(_passthroughRemuxer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var DemuxerInline = function () {
  function DemuxerInline(hls, id, typeSupported) {
    var config = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

    _classCallCheck(this, DemuxerInline);

    this.hls = hls;
    this.id = id;
    this.config = this.hls.config || config;
    this.typeSupported = typeSupported;
  }

  _createClass(DemuxerInline, [{
    key: 'destroy',
    value: function destroy() {
      var demuxer = this.demuxer;
      if (demuxer) {
        demuxer.destroy();
      }
    }
  }, {
    key: 'push',
    value: function push(data, audioCodec, videoCodec, timeOffset, cc, level, sn, duration, accurateTimeOffset, defaultInitPTS) {
      var demuxer = this.demuxer;
      if (!demuxer ||
      // in case of continuity change, we might switch from content type (AAC container to TS container for example)
      // so let's check that current demuxer is still valid
      cc !== this.cc && !demuxer.probe(data)) {
        var hls = this.hls,
            id = this.id,
            config = this.config,
            typeSupported = this.typeSupported;
        // probe for content type
        if (_tsdemuxer2.default.probe(data)) {
          if (this.typeSupported.mp2t === true) {
            demuxer = new _tsdemuxer2.default(hls, id, _passthroughRemuxer2.default, config, typeSupported);
          } else {
            demuxer = new _tsdemuxer2.default(hls, id, _mp4Remuxer2.default, config, typeSupported);
          }
          demuxer.probe = _tsdemuxer2.default.probe;
        } else if (_aacdemuxer2.default.probe(data)) {
          demuxer = new _aacdemuxer2.default(hls, id, _mp4Remuxer2.default, config, typeSupported);
          demuxer.probe = _aacdemuxer2.default.probe;
        } else {
          hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, id: id, details: _errors.ErrorDetails.FRAG_PARSING_ERROR, fatal: true, reason: 'no demux matching with content found' });
          return;
        }
        this.demuxer = demuxer;
      }
      demuxer.push(data, audioCodec, videoCodec, timeOffset, cc, level, sn, duration, accurateTimeOffset, defaultInitPTS);
      this.cc = cc;
    }
  }]);

  return DemuxerInline;
}();

exports.default = DemuxerInline;

},{"../demux/aacdemuxer":20,"../demux/tsdemuxer":27,"../errors":28,"../events":30,"../remux/mp4-remuxer":40,"../remux/passthrough-remuxer":41}],23:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _demuxerInline = require('../demux/demuxer-inline');

var _demuxerInline2 = _interopRequireDefault(_demuxerInline);

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _logger = require('../utils/logger');

var _events3 = require('events');

var _events4 = _interopRequireDefault(_events3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* demuxer web worker.
 *  - listen to worker message, and trigger DemuxerInline upon reception of Fragments.
 *  - provides MP4 Boxes back to main thread using [transferable objects](https://developers.google.com/web/updates/2011/12/Transferable-Objects-Lightning-Fast) in order to minimize message passing overhead.
 */

var DemuxerWorker = function DemuxerWorker(self) {
  // observer setup
  var observer = new _events4.default();
  observer.trigger = function trigger(event) {
    for (var _len = arguments.length, data = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      data[_key - 1] = arguments[_key];
    }

    observer.emit.apply(observer, [event, event].concat(data));
  };

  observer.off = function off(event) {
    for (var _len2 = arguments.length, data = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      data[_key2 - 1] = arguments[_key2];
    }

    observer.removeListener.apply(observer, [event].concat(data));
  };

  var forwardMessage = function forwardMessage(ev, data) {
    self.postMessage({ event: ev, data: data });
  };

  self.addEventListener('message', function (ev) {
    var data = ev.data;
    //console.log('demuxer cmd:' + data.cmd);
    switch (data.cmd) {
      case 'init':
        var config = JSON.parse(data.config);
        self.demuxer = new _demuxerInline2.default(observer, data.id, data.typeSupported, config);
        try {
          (0, _logger.enableLogs)(config.debug === true);
        } catch (err) {
          console.warn('demuxerWorker: unable to enable logs');
        }
        // signal end of worker init
        forwardMessage('init', null);
        break;
      case 'demux':
        self.demuxer.push(new Uint8Array(data.data), data.audioCodec, data.videoCodec, data.timeOffset, data.cc, data.level, data.sn, data.duration, data.accurateTimeOffset, data.defaultInitPTS);
        break;
      default:
        break;
    }
  });

  // forward events to main thread
  observer.on(_events2.default.FRAG_PARSING_INIT_SEGMENT, forwardMessage);
  observer.on(_events2.default.FRAG_PARSED, forwardMessage);
  observer.on(_events2.default.ERROR, forwardMessage);
  observer.on(_events2.default.FRAG_PARSING_METADATA, forwardMessage);
  observer.on(_events2.default.FRAG_PARSING_USERDATA, forwardMessage);
  observer.on(_events2.default.INIT_PTS_FOUND, forwardMessage);

  // special case for FRAG_PARSING_DATA: pass data1/data2 as transferable object (no copy)
  observer.on(_events2.default.FRAG_PARSING_DATA, function (ev, data) {
    var data1 = data.data1.buffer,
        data2 = data.data2.buffer;
    // remove data1 and data2 reference from data to avoid copying them ...
    delete data.data1;
    delete data.data2;
    self.postMessage({ event: ev, data: data, data1: data1, data2: data2 }, [data1, data2]);
  });
};

exports.default = DemuxerWorker;

},{"../demux/demuxer-inline":22,"../events":30,"../utils/logger":47,"events":1}],24:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _demuxerInline = require('../demux/demuxer-inline');

var _demuxerInline2 = _interopRequireDefault(_demuxerInline);

var _demuxerWorker = require('../demux/demuxer-worker');

var _demuxerWorker2 = _interopRequireDefault(_demuxerWorker);

var _logger = require('../utils/logger');

var _decrypter = require('../crypt/decrypter');

var _decrypter2 = _interopRequireDefault(_decrypter);

var _errors = require('../errors');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Demuxer = function () {
  function Demuxer(hls, id) {
    _classCallCheck(this, Demuxer);

    this.hls = hls;
    this.id = id;
    var typeSupported = {
      mp4: MediaSource.isTypeSupported('video/mp4'),
      mp2t: hls.config.enableMP2TPassThrough && MediaSource.isTypeSupported('video/mp2t'),
      mpeg: MediaSource.isTypeSupported('audio/mpeg'),
      mp3: MediaSource.isTypeSupported('audio/mp4; codecs="mp3"')
    };
    if (hls.config.enableWorker && typeof Worker !== 'undefined') {
      _logger.logger.log('demuxing in webworker');
      var w = void 0;
      try {
        var work = require('webworkify');
        w = this.w = work(_demuxerWorker2.default);
        this.onwmsg = this.onWorkerMessage.bind(this);
        w.addEventListener('message', this.onwmsg);
        w.onerror = function (event) {
          hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.OTHER_ERROR, details: _errors.ErrorDetails.INTERNAL_EXCEPTION, fatal: true, event: 'demuxerWorker', err: { message: event.message + ' (' + event.filename + ':' + event.lineno + ')' } });
        };
        w.postMessage({ cmd: 'init', typeSupported: typeSupported, id: id, config: JSON.stringify(hls.config) });
      } catch (err) {
        _logger.logger.error('error while initializing DemuxerWorker, fallback on DemuxerInline');
        if (w) {
          // revoke the Object URL that was used to create demuxer worker, so as not to leak it
          URL.revokeObjectURL(w.objectURL);
        }
        this.demuxer = new _demuxerInline2.default(hls, id, typeSupported);
      }
    } else {
      this.demuxer = new _demuxerInline2.default(hls, id, typeSupported);
    }
    this.demuxInitialized = true;
  }

  _createClass(Demuxer, [{
    key: 'destroy',
    value: function destroy() {
      var w = this.w;
      if (w) {
        w.removeEventListener('message', this.onwmsg);
        w.terminate();
        this.w = null;
      } else {
        var demuxer = this.demuxer;
        if (demuxer) {
          demuxer.destroy();
          this.demuxer = null;
        }
      }
      var decrypter = this.decrypter;
      if (decrypter) {
        decrypter.destroy();
        this.decrypter = null;
      }
    }
  }, {
    key: 'pushDecrypted',
    value: function pushDecrypted(data, audioCodec, videoCodec, timeOffset, cc, level, sn, duration, accurateTimeOffset, defaultInitPTS) {
      var w = this.w;
      if (w) {
        // post fragment payload as transferable objects (no copy)
        w.postMessage({ cmd: 'demux', data: data, audioCodec: audioCodec, videoCodec: videoCodec, timeOffset: timeOffset, cc: cc, level: level, sn: sn, duration: duration, accurateTimeOffset: accurateTimeOffset, defaultInitPTS: defaultInitPTS }, [data]);
      } else {
        var demuxer = this.demuxer;
        if (demuxer) {
          demuxer.push(new Uint8Array(data), audioCodec, videoCodec, timeOffset, cc, level, sn, duration, accurateTimeOffset, defaultInitPTS);
        }
      }
    }
  }, {
    key: 'push',
    value: function push(data, audioCodec, videoCodec, timeOffset, cc, level, sn, duration, decryptdata, accurateTimeOffset, defaultInitPTS) {
      if (data.byteLength > 0 && decryptdata != null && decryptdata.key != null && decryptdata.method === 'AES-128') {
        if (this.decrypter == null) {
          this.decrypter = new _decrypter2.default(this.hls);
        }
        var localthis = this;
        var startTime = performance.now();
        this.decrypter.decrypt(data, decryptdata.key.buffer, decryptdata.iv.buffer, function (decryptedData) {
          localthis.hls.trigger(_events2.default.FRAG_DECRYPTED, { level: level, sn: sn, stats: { tstart: startTime, tdecrypt: performance.now() } });
          localthis.pushDecrypted(decryptedData, audioCodec, videoCodec, timeOffset, cc, level, sn, duration, accurateTimeOffset, defaultInitPTS);
        });
      } else {
        this.pushDecrypted(data, audioCodec, videoCodec, timeOffset, cc, level, sn, duration, accurateTimeOffset, defaultInitPTS);
      }
    }
  }, {
    key: 'onWorkerMessage',
    value: function onWorkerMessage(ev) {
      var data = ev.data,
          hls = this.hls;
      //console.log('onWorkerMessage:' + data.event);
      switch (data.event) {
        case 'init':
          // revoke the Object URL that was used to create demuxer worker, so as not to leak it
          URL.revokeObjectURL(this.w.objectURL);
          break;
        // special case for FRAG_PARSING_DATA: data1 and data2 are transferable objects
        case _events2.default.FRAG_PARSING_DATA:
          data.data.data1 = new Uint8Array(data.data1);
          data.data.data2 = new Uint8Array(data.data2);
        /* falls through */
        default:
          hls.trigger(data.event, data.data);
          break;
      }
    }
  }]);

  return Demuxer;
}();

exports.default = Demuxer;

},{"../crypt/decrypter":18,"../demux/demuxer-inline":22,"../demux/demuxer-worker":23,"../errors":28,"../events":30,"../utils/logger":47,"webworkify":3}],25:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Parser for exponential Golomb codes, a variable-bitwidth number encoding scheme used by h264.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */

var _logger = require('../utils/logger');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ExpGolomb = function () {
  function ExpGolomb(data) {
    _classCallCheck(this, ExpGolomb);

    this.data = data;
    // the number of bytes left to examine in this.data
    this.bytesAvailable = data.byteLength;
    // the current word being examined
    this.word = 0; // :uint
    // the number of bits left to examine in the current word
    this.bitsAvailable = 0; // :uint
  }

  // ():void


  _createClass(ExpGolomb, [{
    key: 'loadWord',
    value: function loadWord() {
      var data = this.data,
          bytesAvailable = this.bytesAvailable,
          position = data.byteLength - bytesAvailable,
          workingBytes = new Uint8Array(4),
          availableBytes = Math.min(4, bytesAvailable);
      if (availableBytes === 0) {
        throw new Error('no bytes available');
      }
      workingBytes.set(data.subarray(position, position + availableBytes));
      this.word = new DataView(workingBytes.buffer).getUint32(0);
      // track the amount of this.data that has been processed
      this.bitsAvailable = availableBytes * 8;
      this.bytesAvailable -= availableBytes;
    }

    // (count:int):void

  }, {
    key: 'skipBits',
    value: function skipBits(count) {
      var skipBytes; // :int
      if (this.bitsAvailable > count) {
        this.word <<= count;
        this.bitsAvailable -= count;
      } else {
        count -= this.bitsAvailable;
        skipBytes = count >> 3;
        count -= skipBytes >> 3;
        this.bytesAvailable -= skipBytes;
        this.loadWord();
        this.word <<= count;
        this.bitsAvailable -= count;
      }
    }

    // (size:int):uint

  }, {
    key: 'readBits',
    value: function readBits(size) {
      var bits = Math.min(this.bitsAvailable, size),
          // :uint
      valu = this.word >>> 32 - bits; // :uint
      if (size > 32) {
        _logger.logger.error('Cannot read more than 32 bits at a time');
      }
      this.bitsAvailable -= bits;
      if (this.bitsAvailable > 0) {
        this.word <<= bits;
      } else if (this.bytesAvailable > 0) {
        this.loadWord();
      }
      bits = size - bits;
      if (bits > 0 && this.bitsAvailable) {
        return valu << bits | this.readBits(bits);
      } else {
        return valu;
      }
    }

    // ():uint

  }, {
    key: 'skipLZ',
    value: function skipLZ() {
      var leadingZeroCount; // :uint
      for (leadingZeroCount = 0; leadingZeroCount < this.bitsAvailable; ++leadingZeroCount) {
        if (0 !== (this.word & 0x80000000 >>> leadingZeroCount)) {
          // the first bit of working word is 1
          this.word <<= leadingZeroCount;
          this.bitsAvailable -= leadingZeroCount;
          return leadingZeroCount;
        }
      }
      // we exhausted word and still have not found a 1
      this.loadWord();
      return leadingZeroCount + this.skipLZ();
    }

    // ():void

  }, {
    key: 'skipUEG',
    value: function skipUEG() {
      this.skipBits(1 + this.skipLZ());
    }

    // ():void

  }, {
    key: 'skipEG',
    value: function skipEG() {
      this.skipBits(1 + this.skipLZ());
    }

    // ():uint

  }, {
    key: 'readUEG',
    value: function readUEG() {
      var clz = this.skipLZ(); // :uint
      return this.readBits(clz + 1) - 1;
    }

    // ():int

  }, {
    key: 'readEG',
    value: function readEG() {
      var valu = this.readUEG(); // :int
      if (0x01 & valu) {
        // the number is odd if the low order bit is set
        return 1 + valu >>> 1; // add 1 to make it even, and divide by 2
      } else {
        return -1 * (valu >>> 1); // divide by two then make it negative
      }
    }

    // Some convenience functions
    // :Boolean

  }, {
    key: 'readBoolean',
    value: function readBoolean() {
      return 1 === this.readBits(1);
    }

    // ():int

  }, {
    key: 'readUByte',
    value: function readUByte() {
      return this.readBits(8);
    }

    // ():int

  }, {
    key: 'readUShort',
    value: function readUShort() {
      return this.readBits(16);
    }
    // ():int

  }, {
    key: 'readUInt',
    value: function readUInt() {
      return this.readBits(32);
    }

    /**
     * Advance the ExpGolomb decoder past a scaling list. The scaling
     * list is optionally transmitted as part of a sequence parameter
     * set and is not relevant to transmuxing.
     * @param count {number} the number of entries in this scaling list
     * @see Recommendation ITU-T H.264, Section 7.3.2.1.1.1
     */

  }, {
    key: 'skipScalingList',
    value: function skipScalingList(count) {
      var lastScale = 8,
          nextScale = 8,
          j,
          deltaScale;
      for (j = 0; j < count; j++) {
        if (nextScale !== 0) {
          deltaScale = this.readEG();
          nextScale = (lastScale + deltaScale + 256) % 256;
        }
        lastScale = nextScale === 0 ? lastScale : nextScale;
      }
    }

    /**
     * Read a sequence parameter set and return some interesting video
     * properties. A sequence parameter set is the H264 metadata that
     * describes the properties of upcoming video frames.
     * @param data {Uint8Array} the bytes of a sequence parameter set
     * @return {object} an object with configuration parsed from the
     * sequence parameter set, including the dimensions of the
     * associated video frames.
     */

  }, {
    key: 'readSPS',
    value: function readSPS() {
      var frameCropLeftOffset = 0,
          frameCropRightOffset = 0,
          frameCropTopOffset = 0,
          frameCropBottomOffset = 0,
          sarScale = 1,
          profileIdc,
          profileCompat,
          levelIdc,
          numRefFramesInPicOrderCntCycle,
          picWidthInMbsMinus1,
          picHeightInMapUnitsMinus1,
          frameMbsOnlyFlag,
          scalingListCount,
          i,
          readUByte = this.readUByte.bind(this),
          readBits = this.readBits.bind(this),
          readUEG = this.readUEG.bind(this),
          readBoolean = this.readBoolean.bind(this),
          skipBits = this.skipBits.bind(this),
          skipEG = this.skipEG.bind(this),
          skipUEG = this.skipUEG.bind(this),
          skipScalingList = this.skipScalingList.bind(this);

      readUByte();
      profileIdc = readUByte(); // profile_idc
      profileCompat = readBits(5); // constraint_set[0-4]_flag, u(5)
      skipBits(3); // reserved_zero_3bits u(3),
      levelIdc = readUByte(); //level_idc u(8)
      skipUEG(); // seq_parameter_set_id
      // some profiles have more optional data we don't need
      if (profileIdc === 100 || profileIdc === 110 || profileIdc === 122 || profileIdc === 244 || profileIdc === 44 || profileIdc === 83 || profileIdc === 86 || profileIdc === 118 || profileIdc === 128) {
        var chromaFormatIdc = readUEG();
        if (chromaFormatIdc === 3) {
          skipBits(1); // separate_colour_plane_flag
        }
        skipUEG(); // bit_depth_luma_minus8
        skipUEG(); // bit_depth_chroma_minus8
        skipBits(1); // qpprime_y_zero_transform_bypass_flag
        if (readBoolean()) {
          // seq_scaling_matrix_present_flag
          scalingListCount = chromaFormatIdc !== 3 ? 8 : 12;
          for (i = 0; i < scalingListCount; i++) {
            if (readBoolean()) {
              // seq_scaling_list_present_flag[ i ]
              if (i < 6) {
                skipScalingList(16);
              } else {
                skipScalingList(64);
              }
            }
          }
        }
      }
      skipUEG(); // log2_max_frame_num_minus4
      var picOrderCntType = readUEG();
      if (picOrderCntType === 0) {
        readUEG(); //log2_max_pic_order_cnt_lsb_minus4
      } else if (picOrderCntType === 1) {
        skipBits(1); // delta_pic_order_always_zero_flag
        skipEG(); // offset_for_non_ref_pic
        skipEG(); // offset_for_top_to_bottom_field
        numRefFramesInPicOrderCntCycle = readUEG();
        for (i = 0; i < numRefFramesInPicOrderCntCycle; i++) {
          skipEG(); // offset_for_ref_frame[ i ]
        }
      }
      skipUEG(); // max_num_ref_frames
      skipBits(1); // gaps_in_frame_num_value_allowed_flag
      picWidthInMbsMinus1 = readUEG();
      picHeightInMapUnitsMinus1 = readUEG();
      frameMbsOnlyFlag = readBits(1);
      if (frameMbsOnlyFlag === 0) {
        skipBits(1); // mb_adaptive_frame_field_flag
      }
      skipBits(1); // direct_8x8_inference_flag
      if (readBoolean()) {
        // frame_cropping_flag
        frameCropLeftOffset = readUEG();
        frameCropRightOffset = readUEG();
        frameCropTopOffset = readUEG();
        frameCropBottomOffset = readUEG();
      }
      if (readBoolean()) {
        // vui_parameters_present_flag
        if (readBoolean()) {
          // aspect_ratio_info_present_flag
          var sarRatio = void 0;
          var aspectRatioIdc = readUByte();
          switch (aspectRatioIdc) {
            case 1:
              sarRatio = [1, 1];break;
            case 2:
              sarRatio = [12, 11];break;
            case 3:
              sarRatio = [10, 11];break;
            case 4:
              sarRatio = [16, 11];break;
            case 5:
              sarRatio = [40, 33];break;
            case 6:
              sarRatio = [24, 11];break;
            case 7:
              sarRatio = [20, 11];break;
            case 8:
              sarRatio = [32, 11];break;
            case 9:
              sarRatio = [80, 33];break;
            case 10:
              sarRatio = [18, 11];break;
            case 11:
              sarRatio = [15, 11];break;
            case 12:
              sarRatio = [64, 33];break;
            case 13:
              sarRatio = [160, 99];break;
            case 14:
              sarRatio = [4, 3];break;
            case 15:
              sarRatio = [3, 2];break;
            case 16:
              sarRatio = [2, 1];break;
            case 255:
              {
                sarRatio = [readUByte() << 8 | readUByte(), readUByte() << 8 | readUByte()];
                break;
              }
          }
          if (sarRatio) {
            sarScale = sarRatio[0] / sarRatio[1];
          }
        }
      }
      return {
        width: Math.ceil(((picWidthInMbsMinus1 + 1) * 16 - frameCropLeftOffset * 2 - frameCropRightOffset * 2) * sarScale),
        height: (2 - frameMbsOnlyFlag) * (picHeightInMapUnitsMinus1 + 1) * 16 - (frameMbsOnlyFlag ? 2 : 4) * (frameCropTopOffset + frameCropBottomOffset)
      };
    }
  }, {
    key: 'readSliceType',
    value: function readSliceType() {
      // skip NALu type
      this.readUByte();
      // discard first_mb_in_slice
      this.readUEG();
      // return slice_type
      return this.readUEG();
    }
  }]);

  return ExpGolomb;
}();

exports.default = ExpGolomb;

},{"../utils/logger":47}],26:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * ID3 parser
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */


var _logger = require('../utils/logger');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

//import Hex from '../utils/hex';

var ID3 = function () {
  function ID3(data) {
    _classCallCheck(this, ID3);

    this._hasTimeStamp = false;
    var offset = 0,
        byte1,
        byte2,
        byte3,
        byte4,
        tagSize,
        endPos,
        header,
        len;
    do {
      header = this.readUTF(data, offset, 3);
      offset += 3;
      // first check for ID3 header
      if (header === 'ID3') {
        // skip 24 bits
        offset += 3;
        // retrieve tag(s) length
        byte1 = data[offset++] & 0x7f;
        byte2 = data[offset++] & 0x7f;
        byte3 = data[offset++] & 0x7f;
        byte4 = data[offset++] & 0x7f;
        tagSize = (byte1 << 21) + (byte2 << 14) + (byte3 << 7) + byte4;
        endPos = offset + tagSize;
        //logger.log(`ID3 tag found, size/end: ${tagSize}/${endPos}`);

        // read ID3 tags
        this._parseID3Frames(data, offset, endPos);
        offset = endPos;
      } else if (header === '3DI') {
        // http://id3.org/id3v2.4.0-structure chapter 3.4.   ID3v2 footer
        offset += 7;
        _logger.logger.log('3DI footer found, end: ' + offset);
      } else {
        offset -= 3;
        len = offset;
        if (len) {
          //logger.log(`ID3 len: ${len}`);
          if (!this.hasTimeStamp) {
            _logger.logger.warn('ID3 tag found, but no timestamp');
          }
          this._length = len;
          this._payload = data.subarray(0, len);
        }
        return;
      }
    } while (true);
  }

  _createClass(ID3, [{
    key: 'readUTF',
    value: function readUTF(data, start, len) {

      var result = '',
          offset = start,
          end = start + len;
      do {
        result += String.fromCharCode(data[offset++]);
      } while (offset < end);
      return result;
    }
  }, {
    key: '_parseID3Frames',
    value: function _parseID3Frames(data, offset, endPos) {
      var tagId, tagLen, tagStart, tagFlags, timestamp;
      while (offset + 8 <= endPos) {
        tagId = this.readUTF(data, offset, 4);
        offset += 4;

        tagLen = data[offset++] << 24 + data[offset++] << 16 + data[offset++] << 8 + data[offset++];

        tagFlags = data[offset++] << 8 + data[offset++];

        tagStart = offset;
        //logger.log("ID3 tag id:" + tagId);
        switch (tagId) {
          case 'PRIV':
            //logger.log('parse frame:' + Hex.hexDump(data.subarray(offset,endPos)));
            // owner should be "com.apple.streaming.transportStreamTimestamp"
            if (this.readUTF(data, offset, 44) === 'com.apple.streaming.transportStreamTimestamp') {
              offset += 44;
              // smelling even better ! we found the right descriptor
              // skip null character (string end) + 3 first bytes
              offset += 4;

              // timestamp is 33 bit expressed as a big-endian eight-octet number, with the upper 31 bits set to zero.
              var pts33Bit = data[offset++] & 0x1;
              this._hasTimeStamp = true;

              timestamp = ((data[offset++] << 23) + (data[offset++] << 15) + (data[offset++] << 7) + data[offset++]) / 45;

              if (pts33Bit) {
                timestamp += 47721858.84; // 2^32 / 90
              }
              timestamp = Math.round(timestamp);
              _logger.logger.trace('ID3 timestamp found: ' + timestamp);
              this._timeStamp = timestamp;
            }
            break;
          default:
            break;
        }
      }
    }
  }, {
    key: 'hasTimeStamp',
    get: function get() {
      return this._hasTimeStamp;
    }
  }, {
    key: 'timeStamp',
    get: function get() {
      return this._timeStamp;
    }
  }, {
    key: 'length',
    get: function get() {
      return this._length;
    }
  }, {
    key: 'payload',
    get: function get() {
      return this._payload;
    }
  }]);

  return ID3;
}();

exports.default = ID3;

},{"../utils/logger":47}],27:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * highly optimized TS demuxer:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * parse PAT, PMT
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * extract PES packet from audio and video PIDs
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * extract AVC/H264 NAL units and AAC/ADTS samples from PES packet
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * trigger the remuxer upon parsing completion
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * it also tries to workaround as best as it can audio codec switch (HE-AAC to AAC and vice versa), without having to restart the MediaSource.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * it also controls the remuxing process :
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * upon discontinuity or level switch detection, it will also notifies the remuxer so that it can reset its state.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */

// import Hex from '../utils/hex';


var _adts = require('./adts');

var _adts2 = _interopRequireDefault(_adts);

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _expGolomb = require('./exp-golomb');

var _expGolomb2 = _interopRequireDefault(_expGolomb);

var _logger = require('../utils/logger');

var _errors = require('../errors');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var TSDemuxer = function () {
  function TSDemuxer(observer, id, remuxerClass, config, typeSupported) {
    _classCallCheck(this, TSDemuxer);

    this.observer = observer;
    this.id = id;
    this.remuxerClass = remuxerClass;
    this.config = config;
    this.typeSupported = typeSupported;
    this.lastCC = 0;
    this.remuxer = new this.remuxerClass(observer, id, config, typeSupported);
  }

  _createClass(TSDemuxer, [{
    key: 'switchLevel',
    value: function switchLevel() {
      this.pmtParsed = false;
      this._pmtId = -1;
      this._avcTrack = { container: 'video/mp2t', type: 'video', id: -1, sequenceNumber: 0, samples: [], len: 0, dropped: 0 };
      this._audioTrack = { container: 'video/mp2t', type: 'audio', id: -1, sequenceNumber: 0, samples: [], len: 0, isAAC: true };
      this._id3Track = { type: 'id3', id: -1, sequenceNumber: 0, samples: [], len: 0 };
      this._txtTrack = { type: 'text', id: -1, sequenceNumber: 0, samples: [], len: 0 };
      // flush any partial content
      this.aacOverFlow = null;
      this.aacLastPTS = null;
      this.avcSample = null;
      this.remuxer.switchLevel();
    }
  }, {
    key: 'insertDiscontinuity',
    value: function insertDiscontinuity() {
      this.switchLevel();
      this.remuxer.insertDiscontinuity();
    }

    // feed incoming data to the front of the parsing pipeline

  }, {
    key: 'push',
    value: function push(data, audioCodec, videoCodec, timeOffset, cc, level, sn, duration, accurateTimeOffset, defaultInitPTS) {
      var start,
          len = data.length,
          stt,
          pid,
          atf,
          offset,
          pes,
          codecsOnly = this.remuxer.passthrough,
          unknownPIDs = false;

      this.audioCodec = audioCodec;
      this.videoCodec = videoCodec;
      this._duration = duration;
      this.contiguous = false;
      this.accurateTimeOffset = accurateTimeOffset;
      if (cc !== this.lastCC) {
        _logger.logger.log('discontinuity detected');
        this.insertDiscontinuity();
        this.lastCC = cc;
      }
      if (level !== this.lastLevel) {
        _logger.logger.log('level switch detected');
        this.switchLevel();
        this.lastLevel = level;
      } else if (sn === this.lastSN + 1) {
        this.contiguous = true;
      }
      this.lastSN = sn;

      var pmtParsed = this.pmtParsed,
          avcTrack = this._avcTrack,
          audioTrack = this._audioTrack,
          id3Track = this._id3Track,
          avcId = avcTrack.id,
          audioId = audioTrack.id,
          id3Id = id3Track.id,
          pmtId = this._pmtId,
          avcData = avcTrack.pesData,
          audioData = audioTrack.pesData,
          id3Data = id3Track.pesData,
          parsePAT = this._parsePAT,
          parsePMT = this._parsePMT,
          parsePES = this._parsePES,
          parseAVCPES = this._parseAVCPES.bind(this),
          parseAACPES = this._parseAACPES.bind(this),
          parseMPEGPES = this._parseMPEGPES.bind(this),
          parseID3PES = this._parseID3PES.bind(this);

      // don't parse last TS packet if incomplete
      len -= len % 188;
      // loop through TS packets
      for (start = 0; start < len; start += 188) {
        if (data[start] === 0x47) {
          stt = !!(data[start + 1] & 0x40);
          // pid is a 13-bit field starting at the last bit of TS[1]
          pid = ((data[start + 1] & 0x1f) << 8) + data[start + 2];
          atf = (data[start + 3] & 0x30) >> 4;
          // if an adaption field is present, its length is specified by the fifth byte of the TS packet header.
          if (atf > 1) {
            offset = start + 5 + data[start + 4];
            // continue if there is only adaptation field
            if (offset === start + 188) {
              continue;
            }
          } else {
            offset = start + 4;
          }
          switch (pid) {
            case avcId:
              if (stt) {
                if (avcData && (pes = parsePES(avcData))) {
                  parseAVCPES(pes, false);
                  if (codecsOnly) {
                    // if we have video codec info AND
                    // if audio PID is undefined OR if we have audio codec info,
                    // we have all codec info !
                    if (avcTrack.codec && (audioId === -1 || audioTrack.codec)) {
                      this.remux(level, sn, cc, data, timeOffset);
                      return;
                    }
                  }
                }
                avcData = { data: [], size: 0 };
              }
              if (avcData) {
                avcData.data.push(data.subarray(offset, start + 188));
                avcData.size += start + 188 - offset;
              }
              break;
            case audioId:
              if (stt) {
                if (audioData && (pes = parsePES(audioData))) {
                  if (audioTrack.isAAC) {
                    parseAACPES(pes);
                  } else {
                    parseMPEGPES(pes);
                  }
                  if (codecsOnly) {
                    // here we now that we have audio codec info
                    // if video PID is undefined OR if we have video codec info,
                    // we have all codec infos !
                    if (audioTrack.codec && (avcId === -1 || avcTrack.codec)) {
                      this.remux(level, sn, cc, data, timeOffset);
                      return;
                    }
                  }
                }
                audioData = { data: [], size: 0 };
              }
              if (audioData) {
                audioData.data.push(data.subarray(offset, start + 188));
                audioData.size += start + 188 - offset;
              }
              break;
            case id3Id:
              if (stt) {
                if (id3Data && (pes = parsePES(id3Data))) {
                  parseID3PES(pes);
                }
                id3Data = { data: [], size: 0 };
              }
              if (id3Data) {
                id3Data.data.push(data.subarray(offset, start + 188));
                id3Data.size += start + 188 - offset;
              }
              break;
            case 0:
              if (stt) {
                offset += data[offset] + 1;
              }
              pmtId = this._pmtId = parsePAT(data, offset);
              break;
            case pmtId:
              if (stt) {
                offset += data[offset] + 1;
              }
              var parsedPIDs = parsePMT(data, offset, this.typeSupported.mpeg === true || this.typeSupported.mp3 === true);

              // only update track id if track PID found while parsing PMT
              // this is to avoid resetting the PID to -1 in case
              // track PID transiently disappears from the stream
              // this could happen in case of transient missing audio samples for example
              avcId = parsedPIDs.avc;
              if (avcId > 0) {
                avcTrack.id = avcId;
              }
              audioId = parsedPIDs.audio;
              if (audioId > 0) {
                audioTrack.id = audioId;
                audioTrack.isAAC = parsedPIDs.isAAC;
              }
              id3Id = parsedPIDs.id3;
              if (id3Id > 0) {
                id3Track.id = id3Id;
              }
              if (unknownPIDs && !pmtParsed) {
                _logger.logger.log('reparse from beginning');
                unknownPIDs = false;
                // we set it to -188, the += 188 in the for loop will reset start to 0
                start = -188;
              }
              pmtParsed = this.pmtParsed = true;
              break;
            case 17:
            case 0x1fff:
              break;
            default:
              unknownPIDs = true;
              break;
          }
        } else {
          this.observer.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, id: this.id, details: _errors.ErrorDetails.FRAG_PARSING_ERROR, fatal: false, reason: 'TS packet did not start with 0x47' });
        }
      }
      // try to parse last PES packets
      if (avcData && (pes = parsePES(avcData))) {
        parseAVCPES(pes, true);
        avcTrack.pesData = null;
      } else {
        // either avcData null or PES truncated, keep it for next frag parsing
        avcTrack.pesData = avcData;
      }

      if (audioData && (pes = parsePES(audioData))) {
        if (audioTrack.isAAC) {
          parseAACPES(pes);
        } else {
          parseMPEGPES(pes);
        }
        audioTrack.pesData = null;
      } else {
        if (audioData && audioData.size) {
          _logger.logger.log('last AAC PES packet truncated,might overlap between fragments');
        }
        // either audioData null or PES truncated, keep it for next frag parsing
        audioTrack.pesData = audioData;
      }

      if (id3Data && (pes = parsePES(id3Data))) {
        parseID3PES(pes);
        id3Track.pesData = null;
      } else {
        // either id3Data null or PES truncated, keep it for next frag parsing
        id3Track.pesData = id3Data;
      }
      this.remux(level, sn, cc, null, timeOffset, defaultInitPTS);
    }
  }, {
    key: 'remux',
    value: function remux(level, sn, cc, data, timeOffset, defaultInitPTS) {
      var avcTrack = this._avcTrack,
          samples = avcTrack.samples,
          nbNalu = 0,
          naluLen = 0;

      // compute total/avc sample length and nb of NAL units
      for (var i = 0; i < samples.length; i++) {
        var sample = samples[i],
            units = sample.units.units,
            nbUnits = units.length,
            sampleLen = 0;
        for (var j = 0; j < nbUnits; j++) {
          sampleLen += units[j].data.length;
        }
        naluLen += sampleLen;
        nbNalu += nbUnits;
        sample.length = sampleLen;
      }
      avcTrack.len = naluLen;
      avcTrack.nbNalu = nbNalu;
      this.remuxer.remux(level, sn, cc, this._audioTrack, this._avcTrack, this._id3Track, this._txtTrack, timeOffset, this.contiguous, this.accurateTimeOffset, defaultInitPTS, data);
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      this.switchLevel();
      this._initPTS = this._initDTS = undefined;
      this._duration = 0;
    }
  }, {
    key: '_parsePAT',
    value: function _parsePAT(data, offset) {
      // skip the PSI header and parse the first PMT entry
      return (data[offset + 10] & 0x1F) << 8 | data[offset + 11];
      //logger.log('PMT PID:'  + this._pmtId);
    }
  }, {
    key: '_parsePMT',
    value: function _parsePMT(data, offset, mpegSupported) {
      var sectionLength,
          tableEnd,
          programInfoLength,
          pid,
          result = { audio: -1, avc: -1, id3: -1, isAAC: true };
      sectionLength = (data[offset + 1] & 0x0f) << 8 | data[offset + 2];
      tableEnd = offset + 3 + sectionLength - 4;
      // to determine where the table is, we have to figure out how
      // long the program info descriptors are
      programInfoLength = (data[offset + 10] & 0x0f) << 8 | data[offset + 11];
      // advance the offset to the first entry in the mapping table
      offset += 12 + programInfoLength;
      while (offset < tableEnd) {
        pid = (data[offset + 1] & 0x1F) << 8 | data[offset + 2];
        switch (data[offset]) {
          // ISO/IEC 13818-7 ADTS AAC (MPEG-2 lower bit-rate audio)
          case 0x0f:
            //logger.log('AAC PID:'  + pid);
            if (result.audio === -1) {
              result.audio = pid;
            }
            break;
          // Packetized metadata (ID3)
          case 0x15:
            //logger.log('ID3 PID:'  + pid);
            if (result.id3 === -1) {
              result.id3 = pid;
            }
            break;
          // ITU-T Rec. H.264 and ISO/IEC 14496-10 (lower bit-rate video)
          case 0x1b:
            //logger.log('AVC PID:'  + pid);
            if (result.avc === -1) {
              result.avc = pid;
            }
            break;
          // ISO/IEC 11172-3 (MPEG-1 audio)
          // or ISO/IEC 13818-3 (MPEG-2 halved sample rate audio)
          case 0x03:
          case 0x04:
            //logger.log('MPEG PID:'  + pid);
            if (!mpegSupported) {
              _logger.logger.log('MPEG audio found, not supported in this browser for now');
            } else if (result.audio === -1) {
              result.audio = pid;
              result.isAAC = false;
            }
            break;
          case 0x24:
            _logger.logger.warn('HEVC stream type found, not supported for now');
            break;
          default:
            _logger.logger.log('unkown stream type:' + data[offset]);
            break;
        }
        // move to the next table entry
        // skip past the elementary stream descriptors, if present
        offset += ((data[offset + 3] & 0x0F) << 8 | data[offset + 4]) + 5;
      }
      return result;
    }
  }, {
    key: '_parsePES',
    value: function _parsePES(stream) {
      var i = 0,
          frag,
          pesFlags,
          pesPrefix,
          pesLen,
          pesHdrLen,
          pesData,
          pesPts,
          pesDts,
          payloadStartOffset,
          data = stream.data;
      // safety check
      if (!stream || stream.size === 0) {
        return null;
      }

      // we might need up to 19 bytes to read PES header
      // if first chunk of data is less than 19 bytes, let's merge it with following ones until we get 19 bytes
      // usually only one merge is needed (and this is rare ...)
      while (data[0].length < 19 && data.length > 1) {
        var newData = new Uint8Array(data[0].length + data[1].length);
        newData.set(data[0]);
        newData.set(data[1], data[0].length);
        data[0] = newData;
        data.splice(1, 1);
      }
      //retrieve PTS/DTS from first fragment
      frag = data[0];
      pesPrefix = (frag[0] << 16) + (frag[1] << 8) + frag[2];
      if (pesPrefix === 1) {
        pesLen = (frag[4] << 8) + frag[5];
        // if PES parsed length is not zero and greater than total received length, stop parsing. PES might be truncated
        // minus 6 : PES header size
        if (pesLen && pesLen > stream.size - 6) {
          return null;
        }
        pesFlags = frag[7];
        if (pesFlags & 0xC0) {
          /* PES header described here : http://dvd.sourceforge.net/dvdinfo/pes-hdr.html
              as PTS / DTS is 33 bit we cannot use bitwise operator in JS,
              as Bitwise operators treat their operands as a sequence of 32 bits */
          pesPts = (frag[9] & 0x0E) * 536870912 + // 1 << 29
          (frag[10] & 0xFF) * 4194304 + // 1 << 22
          (frag[11] & 0xFE) * 16384 + // 1 << 14
          (frag[12] & 0xFF) * 128 + // 1 << 7
          (frag[13] & 0xFE) / 2;
          // check if greater than 2^32 -1
          if (pesPts > 4294967295) {
            // decrement 2^33
            pesPts -= 8589934592;
          }
          if (pesFlags & 0x40) {
            pesDts = (frag[14] & 0x0E) * 536870912 + // 1 << 29
            (frag[15] & 0xFF) * 4194304 + // 1 << 22
            (frag[16] & 0xFE) * 16384 + // 1 << 14
            (frag[17] & 0xFF) * 128 + // 1 << 7
            (frag[18] & 0xFE) / 2;
            // check if greater than 2^32 -1
            if (pesDts > 4294967295) {
              // decrement 2^33
              pesDts -= 8589934592;
            }
            if (pesPts - pesDts > 60 * 90000) {
              _logger.logger.warn(Math.round((pesPts - pesDts) / 90000) + 's delta between PTS and DTS, align them');
              pesPts = pesDts;
            }
          } else {
            pesDts = pesPts;
          }
        }
        pesHdrLen = frag[8];
        // 9 bytes : 6 bytes for PES header + 3 bytes for PES extension
        payloadStartOffset = pesHdrLen + 9;

        stream.size -= payloadStartOffset;
        //reassemble PES packet
        pesData = new Uint8Array(stream.size);
        for (var j = 0, dataLen = data.length; j < dataLen; j++) {
          frag = data[j];
          var len = frag.byteLength;
          if (payloadStartOffset) {
            if (payloadStartOffset > len) {
              // trim full frag if PES header bigger than frag
              payloadStartOffset -= len;
              continue;
            } else {
              // trim partial frag if PES header smaller than frag
              frag = frag.subarray(payloadStartOffset);
              len -= payloadStartOffset;
              payloadStartOffset = 0;
            }
          }
          pesData.set(frag, i);
          i += len;
        }
        if (pesLen) {
          // payload size : remove PES header + PES extension
          pesLen -= pesHdrLen + 3;
        }
        return { data: pesData, pts: pesPts, dts: pesDts, len: pesLen };
      } else {
        return null;
      }
    }
  }, {
    key: 'pushAccesUnit',
    value: function pushAccesUnit(avcSample, avcTrack) {
      if (avcSample.units.units.length && avcSample.frame) {
        // only push AVC sample if starting with a keyframe is not mandatory OR
        //    if keyframe already found in this fragment OR
        //       keyframe found in last fragment (track.sps) AND
        //          samples already appended (we already found a keyframe in this fragment) OR fragment is contiguous
        if (!this.config.forceKeyFrameOnDiscontinuity || avcSample.key === true || avcTrack.sps && (avcTrack.samples.length || this.contiguous)) {
          avcTrack.samples.push(avcSample);
        } else {
          // dropped samples, track it
          avcTrack.dropped++;
        }
      }
      if (avcSample.debug.length) {
        _logger.logger.log(avcSample.pts + '/' + avcSample.dts + ':' + avcSample.debug + ',' + avcSample.units.length);
      }
    }
  }, {
    key: '_parseAVCPES',
    value: function _parseAVCPES(pes, last) {
      var _this = this;

      //logger.log('parse new PES');
      var track = this._avcTrack,
          units = this._parseAVCNALu(pes.data),
          debug = false,
          expGolombDecoder,
          avcSample = this.avcSample,
          push,
          i;
      //free pes.data to save up some memory
      pes.data = null;

      units.forEach(function (unit) {
        switch (unit.type) {
          //NDR
          case 1:
            push = true;
            if (debug && avcSample) {
              avcSample.debug += 'NDR ';
            }
            avcSample.frame = true;
            // retrieve slice type by parsing beginning of NAL unit (follow H264 spec, slice_header definition) to detect keyframe embedded in NDR
            var data = unit.data;
            if (data.length > 1) {
              var sliceType = new _expGolomb2.default(data).readSliceType();
              // 2 : I slice, 4 : SI slice, 7 : I slice, 9: SI slice
              // SI slice : A slice that is coded using intra prediction only and using quantisation of the prediction samples.
              // An SI slice can be coded such that its decoded samples can be constructed identically to an SP slice.
              // I slice: A slice that is not an SI slice that is decoded using intra prediction only.
              //if (sliceType === 2 || sliceType === 7) {
              if (sliceType === 2 || sliceType === 4 || sliceType === 7 || sliceType === 9) {
                avcSample.key = true;
              }
            }
            break;
          //IDR
          case 5:
            push = true;
            // handle PES not starting with AUD
            if (!avcSample) {
              avcSample = _this.avcSample = _this._createAVCSample(true, pes.pts, pes.dts, '');
            }
            if (debug) {
              avcSample.debug += 'IDR ';
            }
            avcSample.key = true;
            avcSample.frame = true;
            break;
          //SEI
          case 6:
            push = true;
            if (debug && avcSample) {
              avcSample.debug += 'SEI ';
            }
            expGolombDecoder = new _expGolomb2.default(_this.discardEPB(unit.data));

            // skip frameType
            expGolombDecoder.readUByte();

            var payloadType = 0;
            var payloadSize = 0;
            var endOfCaptions = false;
            var b = 0;

            while (!endOfCaptions && expGolombDecoder.bytesAvailable > 1) {
              payloadType = 0;
              do {
                b = expGolombDecoder.readUByte();
                payloadType += b;
              } while (b === 0xFF);

              // Parse payload size.
              payloadSize = 0;
              do {
                b = expGolombDecoder.readUByte();
                payloadSize += b;
              } while (b === 0xFF);

              // TODO: there can be more than one payload in an SEI packet...
              // TODO: need to read type and size in a while loop to get them all
              if (payloadType === 4 && expGolombDecoder.bytesAvailable !== 0) {

                endOfCaptions = true;

                var countryCode = expGolombDecoder.readUByte();

                if (countryCode === 181) {
                  var providerCode = expGolombDecoder.readUShort();

                  if (providerCode === 49) {
                    var userStructure = expGolombDecoder.readUInt();

                    if (userStructure === 0x47413934) {
                      var userDataType = expGolombDecoder.readUByte();

                      // Raw CEA-608 bytes wrapped in CEA-708 packet
                      if (userDataType === 3) {
                        var firstByte = expGolombDecoder.readUByte();
                        var secondByte = expGolombDecoder.readUByte();

                        var totalCCs = 31 & firstByte;
                        var byteArray = [firstByte, secondByte];

                        for (i = 0; i < totalCCs; i++) {
                          // 3 bytes per CC
                          byteArray.push(expGolombDecoder.readUByte());
                          byteArray.push(expGolombDecoder.readUByte());
                          byteArray.push(expGolombDecoder.readUByte());
                        }

                        _this._insertSampleInOrder(_this._txtTrack.samples, { type: 3, pts: pes.pts, bytes: byteArray });
                      }
                    }
                  }
                }
              } else if (payloadSize < expGolombDecoder.bytesAvailable) {
                for (i = 0; i < payloadSize; i++) {
                  expGolombDecoder.readUByte();
                }
              }
            }
            break;
          //SPS
          case 7:
            push = true;
            if (debug && avcSample) {
              avcSample.debug += 'SPS ';
            }
            if (!track.sps) {
              expGolombDecoder = new _expGolomb2.default(unit.data);
              var config = expGolombDecoder.readSPS();
              track.width = config.width;
              track.height = config.height;
              track.sps = [unit.data];
              track.duration = _this._duration;
              var codecarray = unit.data.subarray(1, 4);
              var codecstring = 'avc1.';
              for (i = 0; i < 3; i++) {
                var h = codecarray[i].toString(16);
                if (h.length < 2) {
                  h = '0' + h;
                }
                codecstring += h;
              }
              track.codec = codecstring;
            }
            break;
          //PPS
          case 8:
            push = true;
            if (debug && avcSample) {
              avcSample.debug += 'PPS ';
            }
            if (!track.pps) {
              track.pps = [unit.data];
            }
            break;
          // AUD
          case 9:
            push = false;
            if (avcSample) {
              _this.pushAccesUnit(avcSample, track);
            }
            avcSample = _this.avcSample = _this._createAVCSample(false, pes.pts, pes.dts, debug ? 'AUD ' : '');
            break;
          // Filler Data
          case 12:
            push = false;
            break;
          default:
            push = false;
            if (avcSample) {
              avcSample.debug += 'unknown NAL ' + unit.type + ' ';
            }
            break;
        }
        if (avcSample && push) {
          var _units = avcSample.units;
          _units.units.push(unit);
        }
      });
      // if last PES packet, push samples
      if (last && avcSample) {
        this.pushAccesUnit(avcSample, track);
        this.avcSample = null;
      }
    }
  }, {
    key: '_createAVCSample',
    value: function _createAVCSample(key, pts, dts, debug) {
      return { key: key, pts: pts, dts: dts, units: { units: [], length: 0 }, debug: debug };
    }
  }, {
    key: '_insertSampleInOrder',
    value: function _insertSampleInOrder(arr, data) {
      var len = arr.length;
      if (len > 0) {
        if (data.pts >= arr[len - 1].pts) {
          arr.push(data);
        } else {
          for (var pos = len - 1; pos >= 0; pos--) {
            if (data.pts < arr[pos].pts) {
              arr.splice(pos, 0, data);
              break;
            }
          }
        }
      } else {
        arr.push(data);
      }
    }
  }, {
    key: '_getLastNalUnit',
    value: function _getLastNalUnit() {
      var avcSample = this.avcSample,
          lastUnit = void 0;
      // try to fallback to previous sample if current one is empty
      if (!avcSample || avcSample.units.units.length === 0) {
        var track = this._avcTrack,
            samples = track.samples;
        avcSample = samples[samples.length - 1];
      }
      if (avcSample) {
        var units = avcSample.units.units;
        lastUnit = units[units.length - 1];
      }
      return lastUnit;
    }
  }, {
    key: '_parseAVCNALu',
    value: function _parseAVCNALu(array) {
      var i = 0,
          len = array.byteLength,
          value,
          overflow,
          track = this._avcTrack,
          state = track.naluState || 0,
          lastState = state;
      var units = [],
          unit,
          unitType,
          lastUnitStart = -1,
          lastUnitType;
      //logger.log('PES:' + Hex.hexDump(array));

      if (state === -1) {
        // special use case where we found 3 or 4-byte start codes exactly at the end of previous PES packet
        lastUnitStart = 0;
        // NALu type is value read from offset 0
        lastUnitType = array[0] & 0x1f;
        state = 0;
        i = 1;
      }

      while (i < len) {
        value = array[i++];
        // optimization. state 0 and 1 are the predominant case. let's handle them outside of the switch/case
        if (!state) {
          state = value ? 0 : 1;
          continue;
        }
        if (state === 1) {
          state = value ? 0 : 2;
          continue;
        }
        // here we have state either equal to 2 or 3
        if (!value) {
          state = 3;
        } else if (value === 1) {
          if (lastUnitStart >= 0) {
            unit = { data: array.subarray(lastUnitStart, i - state - 1), type: lastUnitType };
            //logger.log('pushing NALU, type/size:' + unit.type + '/' + unit.data.byteLength);
            units.push(unit);
          } else {
            // lastUnitStart is undefined => this is the first start code found in this PES packet
            // first check if start code delimiter is overlapping between 2 PES packets,
            // ie it started in last packet (lastState not zero)
            // and ended at the beginning of this PES packet (i <= 4 - lastState)
            var lastUnit = this._getLastNalUnit();
            if (lastUnit) {
              if (lastState && i <= 4 - lastState) {
                // start delimiter overlapping between PES packets
                // strip start delimiter bytes from the end of last NAL unit
                // check if lastUnit had a state different from zero
                if (lastUnit.state) {
                  // strip last bytes
                  lastUnit.data = lastUnit.data.subarray(0, lastUnit.data.byteLength - lastState);
                }
              }
              // If NAL units are not starting right at the beginning of the PES packet, push preceding data into previous NAL unit.
              overflow = i - state - 1;
              if (overflow > 0) {
                //logger.log('first NALU found with overflow:' + overflow);
                var tmp = new Uint8Array(lastUnit.data.byteLength + overflow);
                tmp.set(lastUnit.data, 0);
                tmp.set(array.subarray(0, overflow), lastUnit.data.byteLength);
                lastUnit.data = tmp;
              }
            }
          }
          // check if we can read unit type
          if (i < len) {
            unitType = array[i] & 0x1f;
            //logger.log('find NALU @ offset:' + i + ',type:' + unitType);
            lastUnitStart = i;
            lastUnitType = unitType;
            state = 0;
          } else {
            // not enough byte to read unit type. let's read it on next PES parsing
            state = -1;
          }
        } else {
          state = 0;
        }
      }
      if (lastUnitStart >= 0 && state >= 0) {
        unit = { data: array.subarray(lastUnitStart, len), type: lastUnitType, state: state };
        units.push(unit);
        //logger.log('pushing NALU, type/size/state:' + unit.type + '/' + unit.data.byteLength + '/' + state);
      }
      // no NALu found
      if (units.length === 0) {
        // append pes.data to previous NAL unit
        var _lastUnit = this._getLastNalUnit();
        if (_lastUnit) {
          var _tmp = new Uint8Array(_lastUnit.data.byteLength + array.byteLength);
          _tmp.set(_lastUnit.data, 0);
          _tmp.set(array, _lastUnit.data.byteLength);
          _lastUnit.data = _tmp;
        }
      }
      track.naluState = state;
      return units;
    }

    /**
     * remove Emulation Prevention bytes from a RBSP
     */

  }, {
    key: 'discardEPB',
    value: function discardEPB(data) {
      var length = data.byteLength,
          EPBPositions = [],
          i = 1,
          newLength,
          newData;

      // Find all `Emulation Prevention Bytes`
      while (i < length - 2) {
        if (data[i] === 0 && data[i + 1] === 0 && data[i + 2] === 0x03) {
          EPBPositions.push(i + 2);
          i += 2;
        } else {
          i++;
        }
      }

      // If no Emulation Prevention Bytes were found just return the original
      // array
      if (EPBPositions.length === 0) {
        return data;
      }

      // Create a new array to hold the NAL unit data
      newLength = length - EPBPositions.length;
      newData = new Uint8Array(newLength);
      var sourceIndex = 0;

      for (i = 0; i < newLength; sourceIndex++, i++) {
        if (sourceIndex === EPBPositions[0]) {
          // Skip this byte
          sourceIndex++;
          // Remove this position index
          EPBPositions.shift();
        }
        newData[i] = data[sourceIndex];
      }
      return newData;
    }
  }, {
    key: '_parseAACPES',
    value: function _parseAACPES(pes) {
      var track = this._audioTrack,
          data = pes.data,
          pts = pes.pts,
          startOffset = 0,
          aacOverFlow = this.aacOverFlow,
          aacLastPTS = this.aacLastPTS,
          config,
          frameLength,
          frameDuration,
          frameIndex,
          offset,
          headerLength,
          stamp,
          len,
          aacSample;
      if (aacOverFlow) {
        var tmp = new Uint8Array(aacOverFlow.byteLength + data.byteLength);
        tmp.set(aacOverFlow, 0);
        tmp.set(data, aacOverFlow.byteLength);
        //logger.log(`AAC: append overflowing ${aacOverFlow.byteLength} bytes to beginning of new PES`);
        data = tmp;
      }
      // look for ADTS header (0xFFFx)
      for (offset = startOffset, len = data.length; offset < len - 1; offset++) {
        if (data[offset] === 0xff && (data[offset + 1] & 0xf0) === 0xf0) {
          break;
        }
      }
      // if ADTS header does not start straight from the beginning of the PES payload, raise an error
      if (offset) {
        var reason, fatal;
        if (offset < len - 1) {
          reason = 'AAC PES did not start with ADTS header,offset:' + offset;
          fatal = false;
        } else {
          reason = 'no ADTS header found in AAC PES';
          fatal = true;
        }
        _logger.logger.warn('parsing error:' + reason);
        this.observer.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, id: this.id, details: _errors.ErrorDetails.FRAG_PARSING_ERROR, fatal: fatal, reason: reason });
        if (fatal) {
          return;
        }
      }
      if (!track.audiosamplerate) {
        config = _adts2.default.getAudioConfig(this.observer, data, offset, this.audioCodec);
        track.config = config.config;
        track.audiosamplerate = config.samplerate;
        track.channelCount = config.channelCount;
        track.codec = config.codec;
        track.duration = this._duration;
        _logger.logger.log('parsed codec:' + track.codec + ',rate:' + config.samplerate + ',nb channel:' + config.channelCount);
      }
      frameIndex = 0;
      frameDuration = 1024 * 90000 / track.audiosamplerate;

      // if last AAC frame is overflowing, we should ensure timestamps are contiguous:
      // first sample PTS should be equal to last sample PTS + frameDuration
      if (aacOverFlow && aacLastPTS) {
        var newPTS = aacLastPTS + frameDuration;
        if (Math.abs(newPTS - pts) > 1) {
          _logger.logger.log('AAC: align PTS for overlapping frames by ' + Math.round((newPTS - pts) / 90));
          pts = newPTS;
        }
      }

      while (offset + 5 < len) {
        // The protection skip bit tells us if we have 2 bytes of CRC data at the end of the ADTS header
        headerLength = !!(data[offset + 1] & 0x01) ? 7 : 9;
        // retrieve frame size
        frameLength = (data[offset + 3] & 0x03) << 11 | data[offset + 4] << 3 | (data[offset + 5] & 0xE0) >>> 5;
        frameLength -= headerLength;
        //stamp = pes.pts;

        if (frameLength > 0 && offset + headerLength + frameLength <= len) {
          stamp = pts + frameIndex * frameDuration;
          //logger.log(`AAC frame, offset/length/total/pts:${offset+headerLength}/${frameLength}/${data.byteLength}/${(stamp/90).toFixed(0)}`);
          aacSample = { unit: data.subarray(offset + headerLength, offset + headerLength + frameLength), pts: stamp, dts: stamp };
          track.samples.push(aacSample);
          track.len += frameLength;
          offset += frameLength + headerLength;
          frameIndex++;
          // look for ADTS header (0xFFFx)
          for (; offset < len - 1; offset++) {
            if (data[offset] === 0xff && (data[offset + 1] & 0xf0) === 0xf0) {
              break;
            }
          }
        } else {
          break;
        }
      }
      if (offset < len) {
        aacOverFlow = data.subarray(offset, len);
        //logger.log(`AAC: overflow detected:${len-offset}`);
      } else {
        aacOverFlow = null;
      }
      this.aacOverFlow = aacOverFlow;
      this.aacLastPTS = stamp;
    }
  }, {
    key: '_parseMPEGPES',
    value: function _parseMPEGPES(pes) {
      var data = pes.data;
      var pts = pes.pts;
      var length = data.length;
      var frameIndex = 0;
      var offset = 0;
      var parsed;

      while (offset < length && (parsed = this._parseMpeg(data, offset, length, frameIndex++, pts)) > 0) {
        offset += parsed;
      }
    }
  }, {
    key: '_onMpegFrame',
    value: function _onMpegFrame(data, bitRate, sampleRate, channelCount, frameIndex, pts) {
      var frameDuration = 1152 / sampleRate * 1000;
      var stamp = pts + frameIndex * frameDuration;
      var track = this._audioTrack;

      track.config = [];
      track.channelCount = channelCount;
      track.audiosamplerate = sampleRate;
      track.duration = this._duration;
      track.samples.push({ unit: data, pts: stamp, dts: stamp });
      track.len += data.length;
    }
  }, {
    key: '_onMpegNoise',
    value: function _onMpegNoise(data) {
      _logger.logger.warn('mpeg audio has noise: ' + data.length + ' bytes');
    }
  }, {
    key: '_parseMpeg',
    value: function _parseMpeg(data, start, end, frameIndex, pts) {
      var BitratesMap = [32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448, 32, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 32, 48, 56, 64, 80, 96, 112, 128, 144, 160, 176, 192, 224, 256, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160];
      var SamplingRateMap = [44100, 48000, 32000, 22050, 24000, 16000, 11025, 12000, 8000];

      if (start + 2 > end) {
        return -1; // we need at least 2 bytes to detect sync pattern
      }
      if (data[start] === 0xFF || (data[start + 1] & 0xE0) === 0xE0) {
        // Using http://www.datavoyage.com/mpgscript/mpeghdr.htm as a reference
        if (start + 24 > end) {
          return -1;
        }
        var headerB = data[start + 1] >> 3 & 3;
        var headerC = data[start + 1] >> 1 & 3;
        var headerE = data[start + 2] >> 4 & 15;
        var headerF = data[start + 2] >> 2 & 3;
        var headerG = !!(data[start + 2] & 2);
        if (headerB !== 1 && headerE !== 0 && headerE !== 15 && headerF !== 3) {
          var columnInBitrates = headerB === 3 ? 3 - headerC : headerC === 3 ? 3 : 4;
          var bitRate = BitratesMap[columnInBitrates * 14 + headerE - 1] * 1000;
          var columnInSampleRates = headerB === 3 ? 0 : headerB === 2 ? 1 : 2;
          var sampleRate = SamplingRateMap[columnInSampleRates * 3 + headerF];
          var padding = headerG ? 1 : 0;
          var channelCount = data[start + 3] >> 6 === 3 ? 1 : 2; // If bits of channel mode are `11` then it is a single channel (Mono)
          var frameLength = headerC === 3 ? (headerB === 3 ? 12 : 6) * bitRate / sampleRate + padding << 2 : (headerB === 3 ? 144 : 72) * bitRate / sampleRate + padding | 0;
          if (start + frameLength > end) {
            return -1;
          }
          if (this._onMpegFrame) {
            this._onMpegFrame(data.subarray(start, start + frameLength), bitRate, sampleRate, channelCount, frameIndex, pts);
          }
          return frameLength;
        }
      }
      // noise or ID3, trying to skip
      var offset = start + 2;
      while (offset < end) {
        if (data[offset - 1] === 0xFF && (data[offset] & 0xE0) === 0xE0) {
          // sync pattern is found
          if (this._onMpegNoise) {
            this._onMpegNoise(data.subarray(start, offset - 1));
          }
          return offset - start - 1;
        }
        offset++;
      }
      return -1;
    }
  }, {
    key: '_parseID3PES',
    value: function _parseID3PES(pes) {
      this._id3Track.samples.push(pes);
    }
  }], [{
    key: 'probe',
    value: function probe(data) {
      // a TS fragment should contain at least 3 TS packets, a PAT, a PMT, and one PID, each starting with 0x47
      if (data.length >= 3 * 188 && data[0] === 0x47 && data[188] === 0x47 && data[2 * 188] === 0x47) {
        return true;
      } else {
        return false;
      }
    }
  }]);

  return TSDemuxer;
}();

exports.default = TSDemuxer;

},{"../errors":28,"../events":30,"../utils/logger":47,"./adts":21,"./exp-golomb":25}],28:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
var ErrorTypes = exports.ErrorTypes = {
  // Identifier for a network error (loading error / timeout ...)
  NETWORK_ERROR: 'networkError',
  // Identifier for a media Error (video/parsing/mediasource error)
  MEDIA_ERROR: 'mediaError',
  // Identifier for a mux Error (demuxing/remuxing)
  MUX_ERROR: 'muxError',
  // Identifier for all other errors
  OTHER_ERROR: 'otherError'
};

var ErrorDetails = exports.ErrorDetails = {
  // Identifier for a manifest load error - data: { url : faulty URL, response : { code: error code, text: error text }}
  MANIFEST_LOAD_ERROR: 'manifestLoadError',
  // Identifier for a manifest load timeout - data: { url : faulty URL, response : { code: error code, text: error text }}
  MANIFEST_LOAD_TIMEOUT: 'manifestLoadTimeOut',
  // Identifier for a manifest parsing error - data: { url : faulty URL, reason : error reason}
  MANIFEST_PARSING_ERROR: 'manifestParsingError',
  // Identifier for a manifest with only incompatible codecs error - data: { url : faulty URL, reason : error reason}
  MANIFEST_INCOMPATIBLE_CODECS_ERROR: 'manifestIncompatibleCodecsError',
  //
  MANIFEST_EMPTY_ERROR: 'manifestEmptyError',
  // Identifier for a level load error - data: { url : faulty URL, response : { code: error code, text: error text }}
  LEVEL_LOAD_ERROR: 'levelLoadError',
  // Identifier for a level load timeout - data: { url : faulty URL, response : { code: error code, text: error text }}
  LEVEL_LOAD_TIMEOUT: 'levelLoadTimeOut',
  // Identifier for a level switch error - data: { level : faulty level Id, event : error description}
  LEVEL_SWITCH_ERROR: 'levelSwitchError',
  // Identifier for an audio track load error - data: { url : faulty URL, response : { code: error code, text: error text }}
  AUDIO_TRACK_LOAD_ERROR: 'audioTrackLoadError',
  // Identifier for an audio track load timeout - data: { url : faulty URL, response : { code: error code, text: error text }}
  AUDIO_TRACK_LOAD_TIMEOUT: 'audioTrackLoadTimeOut',
  // Identifier for fragment load error - data: { frag : fragment object, response : { code: error code, text: error text }}
  FRAG_LOAD_ERROR: 'fragLoadError',
  // Identifier for fragment loop loading error - data: { frag : fragment object}
  FRAG_LOOP_LOADING_ERROR: 'fragLoopLoadingError',
  // Identifier for fragment load timeout error - data: { frag : fragment object}
  FRAG_LOAD_TIMEOUT: 'fragLoadTimeOut',
  // Identifier for a fragment decryption error event - data: parsing error description
  FRAG_DECRYPT_ERROR: 'fragDecryptError',
  // Identifier for a fragment parsing error event - data: { id : demuxer Id, reason : parsing error description }
  // will be renamed DEMUX_PARSING_ERROR and switched to MUX_ERROR in the next major release
  FRAG_PARSING_ERROR: 'fragParsingError',
  // Identifier for a remux alloc error event - data: { id : demuxer Id, bytes : nb of bytes on which allocation failed , reason : error text }
  REMUX_ALLOC_ERROR: 'remuxAllocError',
  // Identifier for decrypt key load error - data: { frag : fragment object, response : { code: error code, text: error text }}
  KEY_LOAD_ERROR: 'keyLoadError',
  // Identifier for decrypt key load timeout error - data: { frag : fragment object}
  KEY_LOAD_TIMEOUT: 'keyLoadTimeOut',
  // Triggered when an exception occurs while adding a sourceBuffer to MediaSource - data : {  err : exception , mimeType : mimeType }
  BUFFER_ADD_CODEC_ERROR: 'bufferAddCodecError',
  // Identifier for a buffer append error - data: append error description
  BUFFER_APPEND_ERROR: 'bufferAppendError',
  // Identifier for a buffer appending error event - data: appending error description
  BUFFER_APPENDING_ERROR: 'bufferAppendingError',
  // Identifier for a buffer stalled error event
  BUFFER_STALLED_ERROR: 'bufferStalledError',
  // Identifier for a buffer full event
  BUFFER_FULL_ERROR: 'bufferFullError',
  // Identifier for a buffer seek over hole event
  BUFFER_SEEK_OVER_HOLE: 'bufferSeekOverHole',
  // Identifier for an internal exception happening inside hls.js while handling an event
  INTERNAL_EXCEPTION: 'internalException',
  // Malformed WebVTT contents
  WEBVTT_EXCEPTION: 'webVTTException'
};

},{}],29:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     * All objects in the event handling chain should inherit from this class
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */

var _logger = require('./utils/logger');

var _errors = require('./errors');

var _events = require('./events');

var _events2 = _interopRequireDefault(_events);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var EventHandler = function () {
  function EventHandler(hls) {
    _classCallCheck(this, EventHandler);

    this.hls = hls;
    this.onEvent = this.onEvent.bind(this);

    for (var _len = arguments.length, events = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      events[_key - 1] = arguments[_key];
    }

    this.handledEvents = events;
    this.useGenericHandler = true;

    this.registerListeners();
  }

  _createClass(EventHandler, [{
    key: 'destroy',
    value: function destroy() {
      this.unregisterListeners();
    }
  }, {
    key: 'isEventHandler',
    value: function isEventHandler() {
      return _typeof(this.handledEvents) === 'object' && this.handledEvents.length && typeof this.onEvent === 'function';
    }
  }, {
    key: 'registerListeners',
    value: function registerListeners() {
      if (this.isEventHandler()) {
        this.handledEvents.forEach(function (event) {
          if (event === 'hlsEventGeneric') {
            throw new Error('Forbidden event name: ' + event);
          }
          this.hls.on(event, this.onEvent);
        }.bind(this));
      }
    }
  }, {
    key: 'unregisterListeners',
    value: function unregisterListeners() {
      if (this.isEventHandler()) {
        this.handledEvents.forEach(function (event) {
          this.hls.off(event, this.onEvent);
        }.bind(this));
      }
    }

    /**
     * arguments: event (string), data (any)
     */

  }, {
    key: 'onEvent',
    value: function onEvent(event, data) {
      this.onEventGeneric(event, data);
    }
  }, {
    key: 'onEventGeneric',
    value: function onEventGeneric(event, data) {
      var eventToFunction = function eventToFunction(event, data) {
        var funcName = 'on' + event.replace('hls', '');
        if (typeof this[funcName] !== 'function') {
          throw new Error('Event ' + event + ' has no generic handler in this ' + this.constructor.name + ' class (tried ' + funcName + ')');
        }
        return this[funcName].bind(this, data);
      };
      try {
        eventToFunction.call(this, event, data).call();
      } catch (err) {
        _logger.logger.error('internal error happened while processing ' + event + ':' + err.message);
        this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.OTHER_ERROR, details: _errors.ErrorDetails.INTERNAL_EXCEPTION, fatal: false, event: event, err: err });
      }
    }
  }]);

  return EventHandler;
}();

exports.default = EventHandler;

},{"./errors":28,"./events":30,"./utils/logger":47}],30:[function(require,module,exports){
'use strict';

module.exports = {
  // fired before MediaSource is attaching to media element - data: { media }
  MEDIA_ATTACHING: 'hlsMediaAttaching',
  // fired when MediaSource has been succesfully attached to media element - data: { }
  MEDIA_ATTACHED: 'hlsMediaAttached',
  // fired before detaching MediaSource from media element - data: { }
  MEDIA_DETACHING: 'hlsMediaDetaching',
  // fired when MediaSource has been detached from media element - data: { }
  MEDIA_DETACHED: 'hlsMediaDetached',
  // fired when we buffer is going to be resetted
  BUFFER_RESET: 'hlsBufferReset',
  // fired when we know about the codecs that we need buffers for to push into - data: {tracks : { container, codec, levelCodec, initSegment, metadata }}
  BUFFER_CODECS: 'hlsBufferCodecs',
  // fired when sourcebuffers have been created data: { tracks : tracks}
  BUFFER_CREATED: 'hlsBufferCreated',
  // fired when we append a segment to the buffer - data: { segment: segment object }
  BUFFER_APPENDING: 'hlsBufferAppending',
  // fired when we are done with appending a media segment to the buffer data : { parent : segment parent that triggered BUFFER_APPENDING , pending : nb of segments waiting for appending for this segment parent}
  BUFFER_APPENDED: 'hlsBufferAppended',
  // fired when the stream is finished and we want to notify the media buffer that there will be no more data
  BUFFER_EOS: 'hlsBufferEos',
  // fired when the media buffer should be flushed - data {startOffset, endOffset}
  BUFFER_FLUSHING: 'hlsBufferFlushing',
  // fired when the media has been flushed
  BUFFER_FLUSHED: 'hlsBufferFlushed',
  // fired to signal that a manifest loading starts - data: { url : manifestURL}
  MANIFEST_LOADING: 'hlsManifestLoading',
  // fired after manifest has been loaded - data: { levels : [available quality levels] , audioTracks : [ available audio tracks], url : manifestURL, stats : { trequest, tfirst, tload, mtime}}
  MANIFEST_LOADED: 'hlsManifestLoaded',
  // fired after manifest has been parsed - data: { levels : [available quality levels] , firstLevel : index of first quality level appearing in Manifest}
  MANIFEST_PARSED: 'hlsManifestParsed',
  // fired when a level playlist loading starts - data: { url : level URL  level : id of level being loaded}
  LEVEL_LOADING: 'hlsLevelLoading',
  // fired when a level playlist loading finishes - data: { details : levelDetails object, level : id of loaded level, stats : { trequest, tfirst, tload, mtime} }
  LEVEL_LOADED: 'hlsLevelLoaded',
  // fired when a level's details have been updated based on previous details, after it has been loaded. - data: { details : levelDetails object, level : id of updated level }
  LEVEL_UPDATED: 'hlsLevelUpdated',
  // fired when a level's PTS information has been updated after parsing a fragment - data: { details : levelDetails object, level : id of updated level, drift: PTS drift observed when parsing last fragment }
  LEVEL_PTS_UPDATED: 'hlsLevelPtsUpdated',
  // fired when a level switch is requested - data: { level : id of new level }
  LEVEL_SWITCH: 'hlsLevelSwitch',
  // fired to notify that audio track lists has been updated data: { audioTracks : audioTracks}
  LEVEL_REMOVED: 'hlsLevelRemoved',
  // fired when a level should no longer be used
  AUDIO_TRACKS_UPDATED: 'hlsAudioTracksUpdated',
  // fired when an audio track switch occurs - data: {  id : audio track id} // deprecated
  AUDIO_TRACK_SWITCH: 'hlsAudioTrackSwitch',
  // fired when an audio track switching is requested - data: {  id : audio track id}
  AUDIO_TRACK_SWITCHING: 'hlsAudioTrackSwitching',
  // fired when an audio track switch actually occurs - data: {  id : audio track id}
  AUDIO_TRACK_SWITCHED: 'hlsAudioTrackSwitched',
  // fired when an audio track loading starts - data: { url : audio track URL  id : audio track id}
  AUDIO_TRACK_LOADING: 'hlsAudioTrackLoading',
  // fired when an audio track loading  finishes - data: { details : levelDetails object, id : audio track id, stats : { trequest, tfirst, tload, mtime} }
  AUDIO_TRACK_LOADED: 'hlsAudioTrackLoaded',
  // fired to notify that subtitle track lists has been updated data: { subtitleTracks : subtitleTracks}
  SUBTITLE_TRACKS_UPDATED: 'hlsSubtitleTracksUpdated',
  // fired when an subtitle track switch occurs - data: {  id : subtitle track id}
  SUBTITLE_TRACK_SWITCH: 'hlsSubtitleTrackSwitch',
  // fired when an subtitle track loading starts - data: { url : subtitle track URL  id : subtitle track id}
  SUBTITLE_TRACK_LOADING: 'hlsSubtitleTrackLoading',
  // fired when an subtitle track loading  finishes - data: { details : levelDetails object, id : subtitle track id, stats : { trequest, tfirst, tload, mtime} }
  SUBTITLE_TRACK_LOADED: 'hlsSubtitleTrackLoaded',
  // fired when a subtitle fragment has been processed - data: { success : boolean, frag : the processed frag}
  SUBTITLE_FRAG_PROCESSED: 'hlsSubtitleFragProcessed',
  // fired when the first timestamp is found. Used for synchronising WebVTT subtitles.
  INIT_PTS_FOUND: 'hlsInitPtsFound',
  // fired when a fragment loading starts - data: { frag : fragment object}
  FRAG_LOADING: 'hlsFragLoading',
  // fired when a fragment loading is progressing - data: { frag : fragment object, { trequest, tfirst, loaded}}
  FRAG_LOAD_PROGRESS: 'hlsFragLoadProgress',
  // Identifier for fragment load aborting for emergency switch down - data: {frag : fragment object}
  FRAG_LOAD_EMERGENCY_ABORTED: 'hlsFragLoadEmergencyAborted',
  // fired when a fragment loading is completed - data: { frag : fragment object, payload : fragment payload, stats : { trequest, tfirst, tload, length}}
  FRAG_LOADED: 'hlsFragLoaded',
  // fired when a fragment has started decrypting - data: { level : levelId, sn : sequence number }
  FRAG_DECRYPT_STARTED: 'hlsFragDecryptStarted',
  // fired when a fragment has finished decrypting - data: { level : levelId, sn : sequence number }
  FRAG_DECRYPTED: 'hlsFragDecrypted',
  // fired when Init Segment has been extracted from fragment - data: { id : demuxer id, level : levelId, sn : sequence number, moov : moov MP4 box, codecs : codecs found while parsing fragment}
  FRAG_PARSING_INIT_SEGMENT: 'hlsFragParsingInitSegment',
  // fired when parsing sei text is completed - data: { id : demuxer id, , level : levelId, sn : sequence number, samples : [ sei samples pes ] }
  FRAG_PARSING_USERDATA: 'hlsFragParsingUserdata',
  // fired when parsing id3 is completed - data: { id : demuxer id, , level : levelId, sn : sequence number, samples : [ id3 samples pes ] }
  FRAG_PARSING_METADATA: 'hlsFragParsingMetadata',
  // fired when data have been extracted from fragment - data: { id : demuxer id, level : levelId, sn : sequence number, data1 : moof MP4 box or TS fragments, data2 : mdat MP4 box or null}
  FRAG_PARSING_DATA: 'hlsFragParsingData',
  // fired when fragment parsing is completed - data: { id : demuxer id; level : levelId, sn : sequence number, }
  FRAG_PARSED: 'hlsFragParsed',
  // fired when fragment remuxed MP4 boxes have all been appended into SourceBuffer - data: { id : demuxer id,frag : fragment object, stats : { trequest, tfirst, tload, tparsed, tbuffered, length} }
  FRAG_BUFFERED: 'hlsFragBuffered',
  // fired when fragment matching with current media position is changing - data : { id : demuxer id, frag : fragment object }
  FRAG_CHANGED: 'hlsFragChanged',
  // Identifier for a FPS drop event - data: {curentDropped, currentDecoded, totalDroppedFrames}
  FPS_DROP: 'hlsFpsDrop',
  //triggered when FPS drop triggers auto level capping - data: {level, droppedlevel}
  FPS_DROP_LEVEL_CAPPING: 'hlsFpsDropLevelCapping',
  // Identifier for an error event - data: { type : error type, details : error details, fatal : if true, hls.js cannot/will not try to recover, if false, hls.js will try to recover,other error specific data}
  ERROR: 'hlsError',
  // fired when hls.js instance starts destroying. Different from MEDIA_DETACHED as one could want to detach and reattach a media to the instance of hls.js to handle mid-rolls for example
  DESTROYING: 'hlsDestroying',
  // fired when a decrypt key loading starts - data: { frag : fragment object}
  KEY_LOADING: 'hlsKeyLoading',
  // fired when a decrypt key loading is completed - data: { frag : fragment object, payload : key payload, stats : { trequest, tfirst, tload, length}}
  KEY_LOADED: 'hlsKeyLoaded',
  // fired upon stream controller state transitions - data: {previousState, nextState}
  STREAM_STATE_TRANSITION: 'hlsStreamStateTransition'
};

},{}],31:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 *  AAC helper
 */

var AAC = function () {
  function AAC() {
    _classCallCheck(this, AAC);
  }

  _createClass(AAC, null, [{
    key: "getSilentFrame",
    value: function getSilentFrame(channelCount) {
      if (channelCount === 1) {
        return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x23, 0x80]);
      } else if (channelCount === 2) {
        return new Uint8Array([0x21, 0x00, 0x49, 0x90, 0x02, 0x19, 0x00, 0x23, 0x80]);
      } else if (channelCount === 3) {
        return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x8e]);
      } else if (channelCount === 4) {
        return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x80, 0x2c, 0x80, 0x08, 0x02, 0x38]);
      } else if (channelCount === 5) {
        return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x82, 0x30, 0x04, 0x99, 0x00, 0x21, 0x90, 0x02, 0x38]);
      } else if (channelCount === 6) {
        return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x82, 0x30, 0x04, 0x99, 0x00, 0x21, 0x90, 0x02, 0x00, 0xb2, 0x00, 0x20, 0x08, 0xe0]);
      }
      return null;
    }
  }]);

  return AAC;
}();

exports.default = AAC;

},{}],32:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Buffer Helper class, providing methods dealing buffer length retrieval
*/

var BufferHelper = function () {
  function BufferHelper() {
    _classCallCheck(this, BufferHelper);
  }

  _createClass(BufferHelper, null, [{
    key: "isBuffered",
    value: function isBuffered(media, position) {
      if (media) {
        var buffered = media.buffered;
        for (var i = 0; i < buffered.length; i++) {
          if (position >= buffered.start(i) && position <= buffered.end(i)) {
            return true;
          }
        }
      }
      return false;
    }
  }, {
    key: "bufferInfo",
    value: function bufferInfo(media, pos, maxHoleDuration) {
      if (media) {
        try {
          var vbuffered = media.buffered,
              buffered = [],
              i;
          for (i = 0; i < vbuffered.length; i++) {
            buffered.push({ start: vbuffered.start(i), end: vbuffered.end(i) });
          }
          return this.bufferedInfo(buffered, pos, maxHoleDuration);
        } catch (e) {
          return { len: 0, start: 0, end: 0, nextStart: undefined };
        }
      } else {
        return { len: 0, start: 0, end: 0, nextStart: undefined };
      }
    }
  }, {
    key: "bufferedInfo",
    value: function bufferedInfo(buffered, pos, maxHoleDuration) {
      var buffered2 = [],

      // bufferStart and bufferEnd are buffer boundaries around current video position
      bufferLen,
          bufferStart,
          bufferEnd,
          bufferStartNext,
          i;
      // sort on buffer.start/smaller end (IE does not always return sorted buffered range)
      buffered.sort(function (a, b) {
        var diff = a.start - b.start;
        if (diff) {
          return diff;
        } else {
          return b.end - a.end;
        }
      });
      // there might be some small holes between buffer time range
      // consider that holes smaller than maxHoleDuration are irrelevant and build another
      // buffer time range representations that discards those holes
      for (i = 0; i < buffered.length; i++) {
        var buf2len = buffered2.length;
        if (buf2len) {
          var buf2end = buffered2[buf2len - 1].end;
          // if small hole (value between 0 or maxHoleDuration ) or overlapping (negative)
          if (buffered[i].start - buf2end < maxHoleDuration) {
            // merge overlapping time ranges
            // update lastRange.end only if smaller than item.end
            // e.g.  [ 1, 15] with  [ 2,8] => [ 1,15] (no need to modify lastRange.end)
            // whereas [ 1, 8] with  [ 2,15] => [ 1,15] ( lastRange should switch from [1,8] to [1,15])
            if (buffered[i].end > buf2end) {
              buffered2[buf2len - 1].end = buffered[i].end;
            }
          } else {
            // big hole
            buffered2.push(buffered[i]);
          }
        } else {
          // first value
          buffered2.push(buffered[i]);
        }
      }
      for (i = 0, bufferLen = 0, bufferStart = bufferEnd = pos; i < buffered2.length; i++) {
        var start = buffered2[i].start,
            end = buffered2[i].end;
        //logger.log('buf start/end:' + buffered.start(i) + '/' + buffered.end(i));
        if (pos + maxHoleDuration >= start && pos < end) {
          // play position is inside this buffer TimeRange, retrieve end of buffer position and buffer length
          bufferStart = start;
          bufferEnd = end;
          bufferLen = bufferEnd - pos;
        } else if (pos + maxHoleDuration < start) {
          bufferStartNext = start;
          break;
        }
      }
      return { len: bufferLen, start: bufferStart || 0, end: bufferEnd || 0, nextStart: bufferStartNext };
    }
  }]);

  return BufferHelper;
}();

exports.default = BufferHelper;

},{}],33:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Level Helper class, providing methods dealing with playlist sliding and drift
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */

var _logger = require('../utils/logger');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var LevelHelper = function () {
  function LevelHelper() {
    _classCallCheck(this, LevelHelper);
  }

  _createClass(LevelHelper, null, [{
    key: 'mergeDetails',
    value: function mergeDetails(oldDetails, newDetails) {
      var start = Math.max(oldDetails.startSN, newDetails.startSN) - newDetails.startSN,
          end = Math.min(oldDetails.endSN, newDetails.endSN) - newDetails.startSN,
          delta = newDetails.startSN - oldDetails.startSN,
          oldfragments = oldDetails.fragments,
          newfragments = newDetails.fragments,
          ccOffset = 0,
          PTSFrag;

      // check if old/new playlists have fragments in common
      if (end < start) {
        newDetails.PTSKnown = false;
        return;
      }
      // loop through overlapping SN and update startPTS , cc, and duration if any found
      for (var i = start; i <= end; i++) {
        var oldFrag = oldfragments[delta + i],
            newFrag = newfragments[i];
        if (newFrag && oldFrag) {
          ccOffset = oldFrag.cc - newFrag.cc;
          if (!isNaN(oldFrag.startPTS)) {
            newFrag.start = newFrag.startPTS = oldFrag.startPTS;
            newFrag.endPTS = oldFrag.endPTS;
            newFrag.duration = oldFrag.duration;
            PTSFrag = newFrag;
          }
        }
      }

      if (ccOffset) {
        _logger.logger.log('discontinuity sliding from playlist, take drift into account');
        for (i = 0; i < newfragments.length; i++) {
          newfragments[i].cc += ccOffset;
        }
      }

      // if at least one fragment contains PTS info, recompute PTS information for all fragments
      if (PTSFrag) {
        LevelHelper.updateFragPTSDTS(newDetails, PTSFrag.sn, PTSFrag.startPTS, PTSFrag.endPTS, PTSFrag.startDTS, PTSFrag.endDTS);
      } else {
        // ensure that delta is within oldfragments range
        // also adjust sliding in case delta is 0 (we could have old=[50-60] and new=old=[50-61])
        // in that case we also need to adjust start offset of all fragments
        if (delta >= 0 && delta < oldfragments.length) {
          // adjust start by sliding offset
          var sliding = oldfragments[delta].start;
          for (i = 0; i < newfragments.length; i++) {
            newfragments[i].start += sliding;
          }
        }
      }
      // if we are here, it means we have fragments overlapping between
      // old and new level. reliable PTS info is thus relying on old level
      newDetails.PTSKnown = oldDetails.PTSKnown;
      return;
    }
  }, {
    key: 'updateFragPTSDTS',
    value: function updateFragPTSDTS(details, sn, startPTS, endPTS, startDTS, endDTS) {
      var fragIdx, fragments, frag, i;
      // exit if sn out of range
      if (!details || sn < details.startSN || sn > details.endSN) {
        return 0;
      }
      fragIdx = sn - details.startSN;
      fragments = details.fragments;
      frag = fragments[fragIdx];
      if (!isNaN(frag.startPTS)) {
        // delta PTS between audio and video
        var deltaPTS = Math.abs(frag.startPTS - startPTS);
        if (isNaN(frag.deltaPTS)) {
          frag.deltaPTS = deltaPTS;
        } else {
          frag.deltaPTS = Math.max(deltaPTS, frag.deltaPTS);
        }
        startPTS = Math.min(startPTS, frag.startPTS);
        endPTS = Math.max(endPTS, frag.endPTS);
        startDTS = Math.min(startDTS, frag.startDTS);
        endDTS = Math.max(endDTS, frag.endDTS);
      }

      var drift = startPTS - frag.start;

      frag.start = frag.startPTS = startPTS;
      frag.endPTS = endPTS;
      frag.startDTS = startDTS;
      frag.endDTS = endDTS;
      frag.duration = endPTS - startPTS;
      // adjust fragment PTS/duration from seqnum-1 to frag 0
      for (i = fragIdx; i > 0; i--) {
        LevelHelper.updatePTS(fragments, i, i - 1);
      }

      // adjust fragment PTS/duration from seqnum to last frag
      for (i = fragIdx; i < fragments.length - 1; i++) {
        LevelHelper.updatePTS(fragments, i, i + 1);
      }
      details.PTSKnown = true;
      //logger.log(`                                            frag start/end:${startPTS.toFixed(3)}/${endPTS.toFixed(3)}`);

      return drift;
    }
  }, {
    key: 'updatePTS',
    value: function updatePTS(fragments, fromIdx, toIdx) {
      var fragFrom = fragments[fromIdx],
          fragTo = fragments[toIdx],
          fragToPTS = fragTo.startPTS;
      // if we know startPTS[toIdx]
      if (!isNaN(fragToPTS)) {
        // update fragment duration.
        // it helps to fix drifts between playlist reported duration and fragment real duration
        if (toIdx > fromIdx) {
          fragFrom.duration = fragToPTS - fragFrom.start;
          if (fragFrom.duration < 0) {
            _logger.logger.warn('negative duration computed for frag ' + fragFrom.sn + ',level ' + fragFrom.level + ', there should be some duration drift between playlist and fragment!');
          }
        } else {
          fragTo.duration = fragFrom.start - fragToPTS;
          if (fragTo.duration < 0) {
            _logger.logger.warn('negative duration computed for frag ' + fragTo.sn + ',level ' + fragTo.level + ', there should be some duration drift between playlist and fragment!');
          }
        }
      } else {
        // we dont know startPTS[toIdx]
        if (toIdx > fromIdx) {
          fragTo.start = fragFrom.start + fragFrom.duration;
        } else {
          fragTo.start = fragFrom.start - fragTo.duration;
        }
      }
    }
  }]);

  return LevelHelper;
}();

exports.default = LevelHelper;

},{"../utils/logger":47}],34:[function(require,module,exports){
/**
 * HLS interface
 */
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
//import FetchLoader from './utils/fetch-loader';


var _events = require('./events');

var _events2 = _interopRequireDefault(_events);

var _errors = require('./errors');

var _playlistLoader = require('./loader/playlist-loader');

var _playlistLoader2 = _interopRequireDefault(_playlistLoader);

var _fragmentLoader = require('./loader/fragment-loader');

var _fragmentLoader2 = _interopRequireDefault(_fragmentLoader);

var _abrController = require('./controller/abr-controller');

var _abrController2 = _interopRequireDefault(_abrController);

var _bufferController = require('./controller/buffer-controller');

var _bufferController2 = _interopRequireDefault(_bufferController);

var _capLevelController = require('./controller/cap-level-controller');

var _capLevelController2 = _interopRequireDefault(_capLevelController);

var _audioStreamController = require('./controller/audio-stream-controller');

var _audioStreamController2 = _interopRequireDefault(_audioStreamController);

var _subtitleStreamController = require('./controller/subtitle-stream-controller');

var _subtitleStreamController2 = _interopRequireDefault(_subtitleStreamController);

var _streamController = require('./controller/stream-controller');

var _streamController2 = _interopRequireDefault(_streamController);

var _levelController = require('./controller/level-controller');

var _levelController2 = _interopRequireDefault(_levelController);

var _timelineController = require('./controller/timeline-controller');

var _timelineController2 = _interopRequireDefault(_timelineController);

var _fpsController = require('./controller/fps-controller');

var _fpsController2 = _interopRequireDefault(_fpsController);

var _audioTrackController = require('./controller/audio-track-controller');

var _audioTrackController2 = _interopRequireDefault(_audioTrackController);

var _subtitleTrackController = require('./controller/subtitle-track-controller');

var _subtitleTrackController2 = _interopRequireDefault(_subtitleTrackController);

var _logger = require('./utils/logger');

var _xhrLoader = require('./utils/xhr-loader');

var _xhrLoader2 = _interopRequireDefault(_xhrLoader);

var _events3 = require('events');

var _events4 = _interopRequireDefault(_events3);

var _keyLoader = require('./loader/key-loader');

var _keyLoader2 = _interopRequireDefault(_keyLoader);

var _cues = require('./utils/cues');

var _cues2 = _interopRequireDefault(_cues);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Hls = function () {
  _createClass(Hls, null, [{
    key: 'isSupported',
    value: function isSupported() {
      window.MediaSource = window.MediaSource || window.WebKitMediaSource;
      return window.MediaSource && typeof window.MediaSource.isTypeSupported === 'function' && window.MediaSource.isTypeSupported('video/mp4; codecs="avc1.42E01E,mp4a.40.2"');
    }
  }, {
    key: 'version',
    get: function get() {
      // replaced with browserify-versionify transform
      return '__VERSION__';
    }
  }, {
    key: 'Events',
    get: function get() {
      return _events2.default;
    }
  }, {
    key: 'ErrorTypes',
    get: function get() {
      return _errors.ErrorTypes;
    }
  }, {
    key: 'ErrorDetails',
    get: function get() {
      return _errors.ErrorDetails;
    }
  }, {
    key: 'DefaultConfig',
    get: function get() {
      if (!Hls.defaultConfig) {
        Hls.defaultConfig = {
          autoStartLoad: true,
          startPosition: -1,
          defaultAudioCodec: undefined,
          debug: false,
          capLevelOnFPSDrop: false,
          capLevelToPlayerSize: false,
          initialLiveManifestSize: 1,
          maxBufferLength: 30,
          maxBufferSize: 60 * 1000 * 1000,
          maxBufferHole: 0.5,
          maxSeekHole: 2,
          seekHoleNudgeDuration: 0.01,
          stalledInBufferedNudgeThreshold: 10,
          maxFragLookUpTolerance: 0.2,
          liveSyncDurationCount: 3,
          liveMaxLatencyDurationCount: Infinity,
          liveSyncDuration: undefined,
          liveMaxLatencyDuration: undefined,
          maxMaxBufferLength: 600,
          enableWorker: true,
          enableSoftwareAES: true,
          manifestLoadingTimeOut: 10000,
          manifestLoadingMaxRetry: 1,
          manifestLoadingRetryDelay: 1000,
          manifestLoadingMaxRetryTimeout: 64000,
          startLevel: undefined,
          levelLoadingTimeOut: 10000,
          levelLoadingMaxRetry: 4,
          levelLoadingRetryDelay: 1000,
          levelLoadingMaxRetryTimeout: 64000,
          fragLoadingTimeOut: 20000,
          fragLoadingMaxRetry: 6,
          fragLoadingRetryDelay: 1000,
          fragLoadingMaxRetryTimeout: 64000,
          fragLoadingLoopThreshold: 3,
          startFragPrefetch: false,
          fpsDroppedMonitoringPeriod: 5000,
          fpsDroppedMonitoringThreshold: 0.2,
          appendErrorMaxRetry: 3,
          loader: _xhrLoader2.default,
          //loader: FetchLoader,
          fLoader: undefined,
          pLoader: undefined,
          xhrSetup: undefined,
          fetchSetup: undefined,
          abrController: _abrController2.default,
          bufferController: _bufferController2.default,
          capLevelController: _capLevelController2.default,
          fpsController: _fpsController2.default,
          streamController: _streamController2.default,
          audioStreamController: _audioStreamController2.default,
          subtitleStreamController: _subtitleStreamController2.default,
          timelineController: _timelineController2.default,
          cueHandler: _cues2.default,
          enableCEA708Captions: true,
          enableWebVTT: true,
          enableMP2TPassThrough: false,
          stretchShortVideoTrack: false,
          forceKeyFrameOnDiscontinuity: true,
          abrEwmaFastLive: 3,
          abrEwmaSlowLive: 9,
          abrEwmaFastVoD: 3,
          abrEwmaSlowVoD: 9,
          abrEwmaDefaultEstimate: 5e5, // 500 kbps
          abrBandWidthFactor: 0.95,
          abrBandWidthUpFactor: 0.7,
          maxStarvationDelay: 4,
          maxLoadingDelay: 4,
          minAutoBitrate: 0
        };
      }
      return Hls.defaultConfig;
    },
    set: function set(defaultConfig) {
      Hls.defaultConfig = defaultConfig;
    }
  }]);

  function Hls() {
    var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, Hls);

    var defaultConfig = Hls.DefaultConfig;

    if ((config.liveSyncDurationCount || config.liveMaxLatencyDurationCount) && (config.liveSyncDuration || config.liveMaxLatencyDuration)) {
      throw new Error('Illegal hls.js config: don\'t mix up liveSyncDurationCount/liveMaxLatencyDurationCount and liveSyncDuration/liveMaxLatencyDuration');
    }

    for (var prop in defaultConfig) {
      if (prop in config) {
        continue;
      }
      config[prop] = defaultConfig[prop];
    }

    if (config.liveMaxLatencyDurationCount !== undefined && config.liveMaxLatencyDurationCount <= config.liveSyncDurationCount) {
      throw new Error('Illegal hls.js config: "liveMaxLatencyDurationCount" must be gt "liveSyncDurationCount"');
    }

    if (config.liveMaxLatencyDuration !== undefined && (config.liveMaxLatencyDuration <= config.liveSyncDuration || config.liveSyncDuration === undefined)) {
      throw new Error('Illegal hls.js config: "liveMaxLatencyDuration" must be gt "liveSyncDuration"');
    }

    (0, _logger.enableLogs)(config.debug);
    this.config = config;
    // observer setup
    var observer = this.observer = new _events4.default();
    observer.trigger = function trigger(event) {
      for (var _len = arguments.length, data = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        data[_key - 1] = arguments[_key];
      }

      observer.emit.apply(observer, [event, event].concat(data));
    };

    observer.off = function off(event) {
      for (var _len2 = arguments.length, data = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        data[_key2 - 1] = arguments[_key2];
      }

      observer.removeListener.apply(observer, [event].concat(data));
    };
    this.on = observer.on.bind(observer);
    this.off = observer.off.bind(observer);
    this.trigger = observer.trigger.bind(observer);
    this.playlistLoader = new _playlistLoader2.default(this);
    this.fragmentLoader = new _fragmentLoader2.default(this);
    this.levelController = new _levelController2.default(this);
    this.abrController = new config.abrController(this);
    this.bufferController = new config.bufferController(this);
    this.capLevelController = new config.capLevelController(this);
    this.fpsController = new config.fpsController(this);
    this.streamController = new config.streamController(this);
    this.audioStreamController = new config.audioStreamController(this);
    this.subtitleStreamController = new config.subtitleStreamController(this);
    this.timelineController = new config.timelineController(this);
    this.audioTrackController = new _audioTrackController2.default(this);
    this.subtitleTrackController = new _subtitleTrackController2.default(this);
    this.keyLoader = new _keyLoader2.default(this);
  }

  _createClass(Hls, [{
    key: 'destroy',
    value: function destroy() {
      _logger.logger.log('destroy');
      this.trigger(_events2.default.DESTROYING);
      this.detachMedia();
      this.playlistLoader.destroy();
      this.fragmentLoader.destroy();
      this.levelController.destroy();
      this.abrController.destroy();
      this.bufferController.destroy();
      this.capLevelController.destroy();
      this.fpsController.destroy();
      this.streamController.destroy();
      this.audioStreamController.destroy();
      this.subtitleStreamController.destroy();
      this.timelineController.destroy();
      this.audioTrackController.destroy();
      this.subtitleTrackController.destroy();
      this.keyLoader.destroy();
      this.url = null;
      this.observer.removeAllListeners();
    }
  }, {
    key: 'attachMedia',
    value: function attachMedia(media) {
      _logger.logger.log('attachMedia');
      this.media = media;
      this.trigger(_events2.default.MEDIA_ATTACHING, { media: media });
    }
  }, {
    key: 'detachMedia',
    value: function detachMedia() {
      _logger.logger.log('detachMedia');
      this.trigger(_events2.default.MEDIA_DETACHING);
      this.media = null;
    }
  }, {
    key: 'loadSource',
    value: function loadSource(url) {
      _logger.logger.log('loadSource:' + url);
      this.url = url;
      // when attaching to a source URL, trigger a playlist load
      this.trigger(_events2.default.MANIFEST_LOADING, { url: url });
    }
  }, {
    key: 'startLoad',
    value: function startLoad() {
      var startPosition = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : -1;

      _logger.logger.log('startLoad(' + startPosition + ')');
      this.levelController.startLoad();
      this.streamController.startLoad(startPosition);
      this.audioStreamController.startLoad(startPosition);
    }
  }, {
    key: 'stopLoad',
    value: function stopLoad() {
      _logger.logger.log('stopLoad');
      this.levelController.stopLoad();
      this.streamController.stopLoad();
      this.audioStreamController.stopLoad();
    }
  }, {
    key: 'swapAudioCodec',
    value: function swapAudioCodec() {
      _logger.logger.log('swapAudioCodec');
      this.streamController.swapAudioCodec();
    }
  }, {
    key: 'recoverMediaError',
    value: function recoverMediaError() {
      _logger.logger.log('recoverMediaError');
      var media = this.media;
      this.detachMedia();
      this.attachMedia(media);
    }
  }, {
    key: 'updateSize',
    value: function updateSize() {
      _logger.logger.log('updateSize');
      if (this.config.capLevelToPlayerSize) {
        this.capLevelController.detectPlayerSize();
      }
    }

    /** Return all quality levels **/

  }, {
    key: 'levels',
    get: function get() {
      return this.levelController.levels;
    }

    /** Return current playback quality level **/

  }, {
    key: 'currentLevel',
    get: function get() {
      return this.streamController.currentLevel;
    }

    /* set quality level immediately (-1 for automatic level selection) */
    ,
    set: function set(newLevel) {
      _logger.logger.log('set currentLevel:' + newLevel);
      this.loadLevel = newLevel;
      this.streamController.immediateLevelSwitch();
    }

    /** Return next playback quality level (quality level of next fragment) **/

  }, {
    key: 'nextLevel',
    get: function get() {
      return this.streamController.nextLevel;
    }

    /* set quality level for next fragment (-1 for automatic level selection) */
    ,
    set: function set(newLevel) {
      _logger.logger.log('set nextLevel:' + newLevel);
      this.levelController.manualLevel = newLevel;
      this.streamController.nextLevelSwitch();
    }

    /** Return the quality level of current/last loaded fragment **/

  }, {
    key: 'loadLevel',
    get: function get() {
      return this.levelController.level;
    }

    /* set quality level for current/next loaded fragment (-1 for automatic level selection) */
    ,
    set: function set(newLevel) {
      _logger.logger.log('set loadLevel:' + newLevel);
      this.levelController.manualLevel = newLevel;
    }

    /** Return the quality level of next loaded fragment **/

  }, {
    key: 'nextLoadLevel',
    get: function get() {
      return this.levelController.nextLoadLevel;
    }

    /** set quality level of next loaded fragment **/
    ,
    set: function set(level) {
      this.levelController.nextLoadLevel = level;
    }

    /** Return first level (index of first level referenced in manifest)
    **/

  }, {
    key: 'firstLevel',
    get: function get() {
      return Math.max(this.levelController.firstLevel, this.abrController.minAutoLevel);
    }

    /** set first level (index of first level referenced in manifest)
    **/
    ,
    set: function set(newLevel) {
      _logger.logger.log('set firstLevel:' + newLevel);
      this.levelController.firstLevel = newLevel;
    }

    /** Return start level (level of first fragment that will be played back)
        if not overrided by user, first level appearing in manifest will be used as start level
        if -1 : automatic start level selection, playback will start from level matching download bandwidth (determined from download of first segment)
    **/

  }, {
    key: 'startLevel',
    get: function get() {
      return this.levelController.startLevel;
    }

    /** set  start level (level of first fragment that will be played back)
        if not overrided by user, first level appearing in manifest will be used as start level
        if -1 : automatic start level selection, playback will start from level matching download bandwidth (determined from download of first segment)
    **/
    ,
    set: function set(newLevel) {
      _logger.logger.log('set startLevel:' + newLevel);
      this.levelController.startLevel = newLevel;
    }

    /** Return the capping/max level value that could be used by automatic level selection algorithm **/

  }, {
    key: 'autoLevelCapping',
    get: function get() {
      return this.abrController.autoLevelCapping;
    }

    /** set the capping/max level value that could be used by automatic level selection algorithm **/
    ,
    set: function set(newLevel) {
      _logger.logger.log('set autoLevelCapping:' + newLevel);
      this.abrController.autoLevelCapping = newLevel;
    }

    /* check if we are in automatic level selection mode */

  }, {
    key: 'autoLevelEnabled',
    get: function get() {
      return this.levelController.manualLevel === -1;
    }

    /* return manual level */

  }, {
    key: 'manualLevel',
    get: function get() {
      return this.levelController.manualLevel;
    }

    /** get alternate audio tracks list from playlist **/

  }, {
    key: 'audioTracks',
    get: function get() {
      return this.audioTrackController.audioTracks;
    }

    /** get index of the selected audio track (index in audio track lists) **/

  }, {
    key: 'audioTrack',
    get: function get() {
      return this.audioTrackController.audioTrack;
    }

    /** select an audio track, based on its index in audio track lists**/
    ,
    set: function set(audioTrackId) {
      this.audioTrackController.audioTrack = audioTrackId;
    }
  }, {
    key: 'liveSyncPosition',
    get: function get() {
      return this.streamController.liveSyncPosition;
    }

    /** get alternate subtitle tracks list from playlist **/

  }, {
    key: 'subtitleTracks',
    get: function get() {
      return this.subtitleTrackController.subtitleTracks;
    }

    /** get index of the selected subtitle track (index in subtitle track lists) **/

  }, {
    key: 'subtitleTrack',
    get: function get() {
      return this.subtitleTrackController.subtitleTrack;
    }

    /** select an subtitle track, based on its index in subtitle track lists**/
    ,
    set: function set(subtitleTrackId) {
      this.subtitleTrackController.subtitleTrack = subtitleTrackId;
    }
  }]);

  return Hls;
}();

exports.default = Hls;

},{"./controller/abr-controller":4,"./controller/audio-stream-controller":5,"./controller/audio-track-controller":6,"./controller/buffer-controller":7,"./controller/cap-level-controller":8,"./controller/fps-controller":10,"./controller/level-controller":11,"./controller/stream-controller":12,"./controller/subtitle-stream-controller":13,"./controller/subtitle-track-controller":14,"./controller/timeline-controller":15,"./errors":28,"./events":30,"./loader/fragment-loader":36,"./loader/key-loader":37,"./loader/playlist-loader":38,"./utils/cues":45,"./utils/logger":47,"./utils/xhr-loader":52,"events":1}],35:[function(require,module,exports){
'use strict';

// This is mostly for support of the es6 module export
// syntax with the babel compiler, it looks like it doesnt support
// function exports like we are used to in node/commonjs
module.exports = require('./hls.js').default;

},{"./hls.js":34}],36:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _eventHandler = require('../event-handler');

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _errors = require('../errors');

var _logger = require('../utils/logger');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Fragment Loader
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

var FragmentLoader = function (_EventHandler) {
  _inherits(FragmentLoader, _EventHandler);

  function FragmentLoader(hls) {
    _classCallCheck(this, FragmentLoader);

    var _this = _possibleConstructorReturn(this, (FragmentLoader.__proto__ || Object.getPrototypeOf(FragmentLoader)).call(this, hls, _events2.default.FRAG_LOADING));

    _this.loaders = {};
    return _this;
  }

  _createClass(FragmentLoader, [{
    key: 'destroy',
    value: function destroy() {
      var loaders = this.loaders;
      for (var loaderName in loaders) {
        var loader = loaders[loaderName];
        if (loader) {
          loader.destroy();
        }
      }
      this.loaders = {};
      _eventHandler2.default.prototype.destroy.call(this);
    }
  }, {
    key: 'onFragLoading',
    value: function onFragLoading(data) {
      var frag = data.frag,
          type = frag.type,
          loader = this.loaders[type],
          config = this.hls.config;

      frag.loaded = 0;
      if (loader) {
        _logger.logger.warn('abort previous fragment loader for type:' + type);
        loader.abort();
      }
      loader = this.loaders[type] = frag.loader = typeof config.fLoader !== 'undefined' ? new config.fLoader(config) : new config.loader(config);

      var loaderContext = void 0,
          loaderConfig = void 0,
          loaderCallbacks = void 0;
      loaderContext = { url: frag.url, frag: frag, responseType: 'arraybuffer', progressData: false };
      var start = frag.byteRangeStartOffset,
          end = frag.byteRangeEndOffset;
      if (!isNaN(start) && !isNaN(end)) {
        loaderContext.rangeStart = start;
        loaderContext.rangeEnd = end;
      }
      loaderConfig = { timeout: config.fragLoadingTimeOut, maxRetry: 0, retryDelay: 0, maxRetryDelay: config.fragLoadingMaxRetryTimeout };
      loaderCallbacks = { onSuccess: this.loadsuccess.bind(this), onError: this.loaderror.bind(this), onTimeout: this.loadtimeout.bind(this), onProgress: this.loadprogress.bind(this) };
      loader.load(loaderContext, loaderConfig, loaderCallbacks);
    }
  }, {
    key: 'loadsuccess',
    value: function loadsuccess(response, stats, context) {
      var payload = response.data,
          frag = context.frag;
      // detach fragment loader on load success
      frag.loader = undefined;
      this.loaders[frag.type] = undefined;
      this.hls.trigger(_events2.default.FRAG_LOADED, { payload: payload, frag: frag, stats: stats });
    }
  }, {
    key: 'loaderror',
    value: function loaderror(response, context) {
      var loader = context.loader;
      if (loader) {
        loader.abort();
      }
      this.loaders[context.type] = undefined;
      this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.NETWORK_ERROR, details: _errors.ErrorDetails.FRAG_LOAD_ERROR, fatal: false, frag: context.frag, response: response });
    }
  }, {
    key: 'loadtimeout',
    value: function loadtimeout(stats, context) {
      var loader = context.loader;
      if (loader) {
        loader.abort();
      }
      this.loaders[context.type] = undefined;
      this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.NETWORK_ERROR, details: _errors.ErrorDetails.FRAG_LOAD_TIMEOUT, fatal: false, frag: context.frag });
    }

    // data will be used for progressive parsing

  }, {
    key: 'loadprogress',
    value: function loadprogress(stats, context, data) {
      // jshint ignore:line
      var frag = context.frag;
      frag.loaded = stats.loaded;
      this.hls.trigger(_events2.default.FRAG_LOAD_PROGRESS, { frag: frag, stats: stats });
    }
  }]);

  return FragmentLoader;
}(_eventHandler2.default);

exports.default = FragmentLoader;

},{"../errors":28,"../event-handler":29,"../events":30,"../utils/logger":47}],37:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _eventHandler = require('../event-handler');

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _errors = require('../errors');

var _logger = require('../utils/logger');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Decrypt key Loader
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

var KeyLoader = function (_EventHandler) {
  _inherits(KeyLoader, _EventHandler);

  function KeyLoader(hls) {
    _classCallCheck(this, KeyLoader);

    var _this = _possibleConstructorReturn(this, (KeyLoader.__proto__ || Object.getPrototypeOf(KeyLoader)).call(this, hls, _events2.default.KEY_LOADING));

    _this.loaders = {};
    _this.decryptkey = null;
    _this.decrypturl = null;
    return _this;
  }

  _createClass(KeyLoader, [{
    key: 'destroy',
    value: function destroy() {
      for (var loaderName in this.loaders) {
        var loader = this.loaders[loaderName];
        if (loader) {
          loader.destroy();
        }
      }
      this.loaders = {};
      _eventHandler2.default.prototype.destroy.call(this);
    }
  }, {
    key: 'onKeyLoading',
    value: function onKeyLoading(data) {
      var frag = data.frag,
          type = frag.type,
          loader = this.loaders[type],
          decryptdata = frag.decryptdata,
          uri = decryptdata.uri;
      // if uri is different from previous one or if decrypt key not retrieved yet
      if (uri !== this.decrypturl || this.decryptkey === null) {
        var config = this.hls.config;

        if (loader) {
          _logger.logger.warn('abort previous key loader for type:' + type);
          loader.abort();
        }
        frag.loader = this.loaders[type] = new config.loader(config);
        this.decrypturl = uri;
        this.decryptkey = null;

        var loaderContext = void 0,
            loaderConfig = void 0,
            loaderCallbacks = void 0;
        loaderContext = { url: uri, frag: frag, responseType: 'arraybuffer' };
        loaderConfig = { timeout: config.fragLoadingTimeOut, maxRetry: config.fragLoadingMaxRetry, retryDelay: config.fragLoadingRetryDelay, maxRetryDelay: config.fragLoadingMaxRetryTimeout };
        loaderCallbacks = { onSuccess: this.loadsuccess.bind(this), onError: this.loaderror.bind(this), onTimeout: this.loadtimeout.bind(this) };
        frag.loader.load(loaderContext, loaderConfig, loaderCallbacks);
      } else if (this.decryptkey) {
        // we already loaded this key, return it
        decryptdata.key = this.decryptkey;
        this.hls.trigger(_events2.default.KEY_LOADED, { frag: frag });
      }
    }
  }, {
    key: 'loadsuccess',
    value: function loadsuccess(response, stats, context) {
      var frag = context.frag;
      this.decryptkey = frag.decryptdata.key = new Uint8Array(response.data);
      // detach fragment loader on load success
      frag.loader = undefined;
      this.loaders[frag.type] = undefined;
      this.hls.trigger(_events2.default.KEY_LOADED, { frag: frag });
    }
  }, {
    key: 'loaderror',
    value: function loaderror(response, context) {
      var frag = context.frag,
          loader = frag.loader;
      if (loader) {
        loader.abort();
      }
      this.loaders[context.type] = undefined;
      this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.NETWORK_ERROR, details: _errors.ErrorDetails.KEY_LOAD_ERROR, fatal: false, frag: frag, response: response });
    }
  }, {
    key: 'loadtimeout',
    value: function loadtimeout(stats, context) {
      var frag = context.frag,
          loader = frag.loader;
      if (loader) {
        loader.abort();
      }
      this.loaders[context.type] = undefined;
      this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.NETWORK_ERROR, details: _errors.ErrorDetails.KEY_LOAD_TIMEOUT, fatal: false, frag: frag });
    }
  }]);

  return KeyLoader;
}(_eventHandler2.default);

exports.default = KeyLoader;

},{"../errors":28,"../event-handler":29,"../events":30,"../utils/logger":47}],38:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Playlist Loader
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */

var _urlToolkit = require('url-toolkit');

var _urlToolkit2 = _interopRequireDefault(_urlToolkit);

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _eventHandler = require('../event-handler');

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _errors = require('../errors');

var _attrList = require('../utils/attr-list');

var _attrList2 = _interopRequireDefault(_attrList);

var _logger = require('../utils/logger');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// https://regex101.com is your friend
var MASTER_PLAYLIST_REGEX = /#EXT-X-STREAM-INF:([^\n\r]*)[\r\n]+([^\r\n]+)/g;
var MASTER_PLAYLIST_MEDIA_REGEX = /#EXT-X-MEDIA:(.*)/g;
var LEVEL_PLAYLIST_REGEX_FAST = /#EXTINF: *([^,]+),?(.*)|(?!#)(\S.+)|#EXT-X-BYTERANGE: *(.+)|#EXT-X-PROGRAM-DATE-TIME:(.+)|#.*/g;
var LEVEL_PLAYLIST_REGEX_SLOW = /(?:(?:#(EXTM3U))|(?:#EXT-X-(PLAYLIST-TYPE):(.+))|(?:#EXT-X-(MEDIA-SEQUENCE): *(\d+))|(?:#EXT-X-(TARGETDURATION): *(\d+))|(?:#EXT-X-(KEY):(.+))|(?:#EXT-X-(START):(.+))|(?:#EXT-X-(ENDLIST))|(?:#EXT-X-(DISCONTINUITY-SEQ)UENCE:(\d+))|(?:#EXT-X-(DIS)CONTINUITY))|(?:#EXT-X-(VERSION):(\d+))|(?:(#)(.*):(.*))|(?:(#)(.*))(?:.*)\r?\n?/;

var LevelKey = function () {
  function LevelKey() {
    _classCallCheck(this, LevelKey);

    this.method = null;
    this.key = null;
    this.iv = null;
    this._uri = null;
  }

  _createClass(LevelKey, [{
    key: 'uri',
    get: function get() {
      if (!this._uri && this.reluri) {
        this._uri = _urlToolkit2.default.buildAbsoluteURL(this.baseuri, this.reluri);
      }
      return this._uri;
    }
  }]);

  return LevelKey;
}();

var Fragment = function () {
  function Fragment() {
    _classCallCheck(this, Fragment);

    this._url = null;
    this._byteRange = null;
    this._decryptdata = null;
  }

  _createClass(Fragment, [{
    key: 'createInitializationVector',


    /**
     * Utility method for parseLevelPlaylist to create an initialization vector for a given segment
     * @returns {Uint8Array}
     */
    value: function createInitializationVector(segmentNumber) {
      var uint8View = new Uint8Array(16);

      for (var i = 12; i < 16; i++) {
        uint8View[i] = segmentNumber >> 8 * (15 - i) & 0xff;
      }

      return uint8View;
    }

    /**
     * Utility method for parseLevelPlaylist to get a fragment's decryption data from the currently parsed encryption key data
     * @param levelkey - a playlist's encryption info
     * @param segmentNumber - the fragment's segment number
     * @returns {*} - an object to be applied as a fragment's decryptdata
     */

  }, {
    key: 'fragmentDecryptdataFromLevelkey',
    value: function fragmentDecryptdataFromLevelkey(levelkey, segmentNumber) {
      var decryptdata = levelkey;

      if (levelkey && levelkey.method && levelkey.uri && !levelkey.iv) {
        decryptdata = Object.assign(new LevelKey(), this.cloneObj(levelkey));
        decryptdata.iv = this.createInitializationVector(segmentNumber);
      }

      return decryptdata;
    }
  }, {
    key: 'cloneObj',
    value: function cloneObj(obj) {
      return JSON.parse(JSON.stringify(obj));
    }
  }, {
    key: 'url',
    get: function get() {
      if (!this._url && this.relurl) {
        this._url = _urlToolkit2.default.buildAbsoluteURL(this.baseurl, this.relurl);
      }
      return this._url;
    },
    set: function set(value) {
      this._url = value;
    }
  }, {
    key: 'programDateTime',
    get: function get() {
      if (!this._programDateTime && this.rawProgramDateTime) {
        this._programDateTime = new Date(Date.parse(this.rawProgramDateTime));
      }
      return this._programDateTime;
    }
  }, {
    key: 'byteRange',
    get: function get() {
      if (!this._byteRange) {
        this._byteRange = [];
        if (this.rawByteRange) {
          var params = this.rawByteRange.split('@', 2);
          if (params.length === 1) {
            this._byteRange[0] = this.prevFrag ? this.prevFrag.byteRangeEndOffset : 0;
          } else {
            this._byteRange[0] = parseInt(params[1]);
          }
          this._byteRange[1] = parseInt(params[0]) + this._byteRange[0];
          this.prevFrag = null;
        }
      }
      return this._byteRange;
    }
  }, {
    key: 'byteRangeStartOffset',
    get: function get() {
      return this.byteRange[0];
    }
  }, {
    key: 'byteRangeEndOffset',
    get: function get() {
      return this.byteRange[1];
    }
  }, {
    key: 'decryptdata',
    get: function get() {
      if (!this._decryptdata) {
        this._decryptdata = this.fragmentDecryptdataFromLevelkey(this.levelkey, this.sn);
      }
      return this._decryptdata;
    }
  }]);

  return Fragment;
}();

var PlaylistLoader = function (_EventHandler) {
  _inherits(PlaylistLoader, _EventHandler);

  function PlaylistLoader(hls) {
    _classCallCheck(this, PlaylistLoader);

    var _this = _possibleConstructorReturn(this, (PlaylistLoader.__proto__ || Object.getPrototypeOf(PlaylistLoader)).call(this, hls, _events2.default.MANIFEST_LOADING, _events2.default.LEVEL_LOADING, _events2.default.AUDIO_TRACK_LOADING, _events2.default.SUBTITLE_TRACK_LOADING));

    _this.loaders = {};
    return _this;
  }

  _createClass(PlaylistLoader, [{
    key: 'destroy',
    value: function destroy() {
      for (var loaderName in this.loaders) {
        var loader = this.loaders[loaderName];
        if (loader) {
          loader.destroy();
        }
      }
      this.loaders = {};
      _eventHandler2.default.prototype.destroy.call(this);
    }
  }, {
    key: 'onManifestLoading',
    value: function onManifestLoading(data) {
      this.load(data.url, { type: 'manifest' });
    }
  }, {
    key: 'onLevelLoading',
    value: function onLevelLoading(data) {
      this.load(data.url, { type: 'level', level: data.level, id: data.id });
    }
  }, {
    key: 'onAudioTrackLoading',
    value: function onAudioTrackLoading(data) {
      this.load(data.url, { type: 'audioTrack', id: data.id });
    }
  }, {
    key: 'onSubtitleTrackLoading',
    value: function onSubtitleTrackLoading(data) {
      this.load(data.url, { type: 'subtitleTrack', id: data.id });
    }
  }, {
    key: 'load',
    value: function load(url, context) {
      var loader = this.loaders[context.type];
      if (loader) {
        var loaderContext = loader.context;
        if (loaderContext && loaderContext.url === url) {
          _logger.logger.trace('playlist request ongoing');
          return;
        } else {
          _logger.logger.warn('abort previous loader for type:' + context.type);
          loader.abort();
        }
      }
      var config = this.hls.config,
          retry = void 0,
          timeout = void 0,
          retryDelay = void 0,
          maxRetryDelay = void 0;
      if (context.type === 'manifest') {
        retry = config.manifestLoadingMaxRetry;
        timeout = config.manifestLoadingTimeOut;
        retryDelay = config.manifestLoadingRetryDelay;
        maxRetryDelay = config.manifestLoadingMaxRetryTimeout;
      } else {
        retry = config.levelLoadingMaxRetry;
        timeout = config.levelLoadingTimeOut;
        retryDelay = config.levelLoadingRetryDelay;
        maxRetryDelay = config.levelLoadingMaxRetryTimeout;
        _logger.logger.log('loading playlist for ' + context.type + ' ' + (context.level || context.id));
      }
      loader = this.loaders[context.type] = context.loader = typeof config.pLoader !== 'undefined' ? new config.pLoader(config) : new config.loader(config);
      context.url = url;
      context.responseType = '';

      var loaderConfig = void 0,
          loaderCallbacks = void 0;
      loaderConfig = { timeout: timeout, maxRetry: retry, retryDelay: retryDelay, maxRetryDelay: maxRetryDelay };
      loaderCallbacks = { onSuccess: this.loadsuccess.bind(this), onError: this.loaderror.bind(this), onTimeout: this.loadtimeout.bind(this) };
      loader.load(context, loaderConfig, loaderCallbacks);
    }
  }, {
    key: 'resolve',
    value: function resolve(url, baseUrl) {
      return _urlToolkit2.default.buildAbsoluteURL(baseUrl, url);
    }
  }, {
    key: 'parseMasterPlaylist',
    value: function parseMasterPlaylist(string, baseurl) {
      var levels = [],
          result = void 0;
      MASTER_PLAYLIST_REGEX.lastIndex = 0;
      while ((result = MASTER_PLAYLIST_REGEX.exec(string)) != null) {
        var level = {};

        var attrs = level.attrs = new _attrList2.default(result[1]);
        level.url = this.resolve(result[2], baseurl);

        var resolution = attrs.decimalResolution('RESOLUTION');
        if (resolution) {
          level.width = resolution.width;
          level.height = resolution.height;
        }
        level.bitrate = attrs.decimalInteger('AVERAGE-BANDWIDTH') || attrs.decimalInteger('BANDWIDTH');
        level.name = attrs.NAME;

        var codecs = attrs.CODECS;
        if (codecs) {
          codecs = codecs.split(/[ ,]+/);
          for (var i = 0; i < codecs.length; i++) {
            var codec = codecs[i];
            if (codec.indexOf('avc1') !== -1) {
              level.videoCodec = this.avc1toavcoti(codec);
            } else {
              level.audioCodec = codec;
            }
          }
        }

        levels.push(level);
      }
      return levels;
    }
  }, {
    key: 'parseMasterPlaylistMedia',
    value: function parseMasterPlaylistMedia(string, baseurl, type) {
      var result = void 0,
          medias = [],
          id = 0;
      MASTER_PLAYLIST_MEDIA_REGEX.lastIndex = 0;
      while ((result = MASTER_PLAYLIST_MEDIA_REGEX.exec(string)) != null) {
        var media = {};
        var attrs = new _attrList2.default(result[1]);
        if (attrs.TYPE === type) {
          media.groupId = attrs['GROUP-ID'];
          media.name = attrs.NAME;
          media.type = type;
          media.default = attrs.DEFAULT === 'YES';
          media.autoselect = attrs.AUTOSELECT === 'YES';
          media.forced = attrs.FORCED === 'YES';
          if (attrs.URI) {
            media.url = this.resolve(attrs.URI, baseurl);
          }
          media.lang = attrs.LANGUAGE;
          if (!media.name) {
            media.name = media.lang;
          }
          media.id = id++;
          medias.push(media);
        }
      }
      return medias;
    }
  }, {
    key: 'avc1toavcoti',
    value: function avc1toavcoti(codec) {
      var result,
          avcdata = codec.split('.');
      if (avcdata.length > 2) {
        result = avcdata.shift() + '.';
        result += parseInt(avcdata.shift()).toString(16);
        result += ('000' + parseInt(avcdata.shift()).toString(16)).substr(-4);
      } else {
        result = codec;
      }
      return result;
    }
  }, {
    key: 'parseLevelPlaylist',
    value: function parseLevelPlaylist(string, baseurl, id, type) {
      var currentSN = 0,
          totalduration = 0,
          level = { type: null, version: null, url: baseurl, fragments: [], live: true, startSN: 0 },
          levelkey = new LevelKey(),
          cc = 0,
          prevFrag = null,
          frag = new Fragment(),
          result,
          i;

      frag.tagList = [];

      LEVEL_PLAYLIST_REGEX_FAST.lastIndex = 0;

      while ((result = LEVEL_PLAYLIST_REGEX_FAST.exec(string)) !== null) {
        var duration = result[1];
        if (duration) {
          // INF
          frag.duration = parseFloat(duration);
          var title = result[2];
          frag.title = title ? title : null;
          frag.tagList.push(title ? ['INF', duration, title] : ['INF', duration]);
        } else if (result[3]) {
          // url
          if (!isNaN(frag.duration)) {
            var sn = currentSN++;
            frag.type = type;
            frag.prevFrag = prevFrag;
            frag.start = totalduration;
            frag.levelkey = levelkey;
            frag.sn = sn;
            frag.level = id;
            frag.cc = cc;
            frag.baseurl = baseurl;
            frag.relurl = result[3];

            level.fragments.push(frag);
            prevFrag = frag;
            totalduration += frag.duration;

            frag = new Fragment();
            frag.tagList = [];
          }
        } else if (result[4]) {
          // X-BYTERANGE
          frag.rawByteRange = result[4];
        } else if (result[5]) {
          // PROGRAM-DATE-TIME
          frag.rawProgramDateTime = result[5];
          frag.tagList.push(['PROGRAM-DATE-TIME', result[5]]);
        } else {
          result = result[0].match(LEVEL_PLAYLIST_REGEX_SLOW);
          for (i = 1; i < result.length; i++) {
            if (result[i] !== undefined) {
              break;
            }
          }

          var value1 = result[i + 1];
          var value2 = result[i + 2];

          switch (result[i]) {
            case '#':
              frag.tagList.push(value2 ? [value1, value2] : [value1]);
              break;
            case 'PLAYLIST-TYPE':
              level.type = value1.toUpperCase();
              break;
            case 'MEDIA-SEQUENCE':
              currentSN = level.startSN = parseInt(value1);
              break;
            case 'TARGETDURATION':
              level.targetduration = parseFloat(value1);
              break;
            case 'VERSION':
              level.version = parseInt(value1);
              break;
            case 'EXTM3U':
              break;
            case 'ENDLIST':
              level.live = false;
              break;
            case 'DIS':
              cc++;
              frag.tagList.push(['DIS']);
              break;
            case 'DISCONTINUITY-SEQ':
              cc = parseInt(value1);
              break;
            case 'KEY':
              // https://tools.ietf.org/html/draft-pantos-http-live-streaming-08#section-3.4.4
              var decryptparams = value1;
              var keyAttrs = new _attrList2.default(decryptparams);
              var decryptmethod = keyAttrs.enumeratedString('METHOD'),
                  decrypturi = keyAttrs.URI,
                  decryptiv = keyAttrs.hexadecimalInteger('IV');
              if (decryptmethod) {
                levelkey = new LevelKey();
                if (decrypturi && decryptmethod === 'AES-128') {
                  levelkey.method = decryptmethod;
                  // URI to get the key
                  levelkey.baseuri = baseurl;
                  levelkey.reluri = decrypturi;
                  levelkey.key = null;
                  // Initialization Vector (IV)
                  levelkey.iv = decryptiv;
                }
              }
              break;
            case 'START':
              var startParams = value1;
              var startAttrs = new _attrList2.default(startParams);
              var startTimeOffset = startAttrs.decimalFloatingPoint('TIME-OFFSET');
              //TIME-OFFSET can be 0
              if (!isNaN(startTimeOffset)) {
                level.startTimeOffset = startTimeOffset;
              }
              break;
            default:
              _logger.logger.warn('line parsed but not handled: ' + result);
              break;
          }
        }
      }
      frag = prevFrag;
      //logger.log('found ' + level.fragments.length + ' fragments');
      if (frag && !frag.relurl) {
        level.fragments.pop();
        totalduration -= frag.duration;
      }
      level.totalduration = totalduration;
      level.averagetargetduration = totalduration / level.fragments.length;
      level.endSN = currentSN - 1;
      return level;
    }
  }, {
    key: 'loadsuccess',
    value: function loadsuccess(response, stats, context) {
      var string = response.data,
          url = response.url,
          type = context.type,
          id = context.id,
          level = context.level,
          hls = this.hls;

      this.loaders[type] = undefined;
      // responseURL not supported on some browsers (it is used to detect URL redirection)
      // data-uri mode also not supported (but no need to detect redirection)
      if (url === undefined || url.indexOf('data:') === 0) {
        // fallback to initial URL
        url = context.url;
      }
      stats.tload = performance.now();
      //stats.mtime = new Date(target.getResponseHeader('Last-Modified'));
      if (string.indexOf('#EXTM3U') === 0) {
        if (string.indexOf('#EXTINF:') > 0) {
          var isLevel = type !== 'audioTrack' && type !== 'subtitleTrack',
              levelDetails = this.parseLevelPlaylist(string, url, level || id || 0, type === 'audioTrack' ? 'audio' : type === 'subtitleTrack' ? 'subtitle' : 'main');
          if (type === 'manifest') {
            // first request, stream manifest (no master playlist), fire manifest loaded event with level details
            hls.trigger(_events2.default.MANIFEST_LOADED, { levels: [{ url: url, details: levelDetails }], audioTracks: [], url: url, stats: stats });
          }
          stats.tparsed = performance.now();
          if (levelDetails.targetduration) {
            if (isLevel) {
              hls.trigger(_events2.default.LEVEL_LOADED, { details: levelDetails, level: level || 0, id: id || 0, stats: stats });
            } else {
              if (type === 'audioTrack') {
                hls.trigger(_events2.default.AUDIO_TRACK_LOADED, { details: levelDetails, id: id, stats: stats });
              } else if (type === 'subtitleTrack') {
                hls.trigger(_events2.default.SUBTITLE_TRACK_LOADED, { details: levelDetails, id: id, stats: stats });
              }
            }
          } else {
            hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.NETWORK_ERROR, details: _errors.ErrorDetails.MANIFEST_PARSING_ERROR, fatal: true, url: url, reason: 'invalid targetduration' });
          }
        } else {
          var levels = this.parseMasterPlaylist(string, url);
          // multi level playlist, parse level info
          if (levels.length) {
            var audioTracks = this.parseMasterPlaylistMedia(string, url, 'AUDIO');
            var subtitles = this.parseMasterPlaylistMedia(string, url, 'SUBTITLES');
            if (audioTracks.length) {
              // check if we have found an audio track embedded in main playlist (audio track without URI attribute)
              var embeddedAudioFound = false;
              audioTracks.forEach(function (audioTrack) {
                if (!audioTrack.url) {
                  embeddedAudioFound = true;
                }
              });
              // if no embedded audio track defined, but audio codec signaled in quality level, we need to signal this main audio track
              // this could happen with playlists with alt audio rendition in which quality levels (main) contains both audio+video. but with mixed audio track not signaled
              if (embeddedAudioFound === false && levels[0].audioCodec && !levels[0].attrs.AUDIO) {
                _logger.logger.log('audio codec signaled in quality level, but no embedded audio track signaled, create one');
                audioTracks.unshift({ type: 'main', name: 'main' });
              }
            }
            hls.trigger(_events2.default.MANIFEST_LOADED, { levels: levels, audioTracks: audioTracks, subtitles: subtitles, url: url, stats: stats });
          } else {
            hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.NETWORK_ERROR, details: _errors.ErrorDetails.MANIFEST_EMPTY_ERROR, fatal: false, url: url, reason: 'no level found in manifest', context: context });
          }
        }
      } else {
        hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.NETWORK_ERROR, details: _errors.ErrorDetails.MANIFEST_PARSING_ERROR, fatal: true, url: url, reason: 'no EXTM3U delimiter' });
      }
    }
  }, {
    key: 'loaderror',
    value: function loaderror(response, context) {
      var details,
          fatal,
          loader = context.loader;
      switch (context.type) {
        case 'manifest':
          details = _errors.ErrorDetails.MANIFEST_LOAD_ERROR;
          fatal = true;
          break;
        case 'level':
          details = _errors.ErrorDetails.LEVEL_LOAD_ERROR;
          fatal = false;
          break;
        case 'audioTrack':
          details = _errors.ErrorDetails.AUDIO_TRACK_LOAD_ERROR;
          fatal = false;
          break;
      }
      if (loader) {
        loader.abort();
        this.loaders[context.type] = undefined;
      }
      this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.NETWORK_ERROR, details: details, fatal: fatal, url: context.url, loader: loader, response: response, context: context });
    }
  }, {
    key: 'loadtimeout',
    value: function loadtimeout(stats, context) {
      var details,
          fatal,
          loader = context.loader;
      switch (context.type) {
        case 'manifest':
          details = _errors.ErrorDetails.MANIFEST_LOAD_TIMEOUT;
          fatal = true;
          break;
        case 'level':
          details = _errors.ErrorDetails.LEVEL_LOAD_TIMEOUT;
          fatal = false;
          break;
        case 'audioTrack':
          details = _errors.ErrorDetails.AUDIO_TRACK_LOAD_TIMEOUT;
          fatal = false;
          break;
      }
      if (loader) {
        loader.abort();
        this.loaders[context.type] = undefined;
      }
      this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.NETWORK_ERROR, details: details, fatal: fatal, url: context.url, loader: loader, context: context });
    }
  }]);

  return PlaylistLoader;
}(_eventHandler2.default);

exports.default = PlaylistLoader;

},{"../errors":28,"../event-handler":29,"../events":30,"../utils/attr-list":42,"../utils/logger":47,"url-toolkit":2}],39:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Generate MP4 Box
*/

//import Hex from '../utils/hex';
var MP4 = function () {
  function MP4() {
    _classCallCheck(this, MP4);
  }

  _createClass(MP4, null, [{
    key: 'init',
    value: function init() {
      MP4.types = {
        avc1: [], // codingname
        avcC: [],
        btrt: [],
        dinf: [],
        dref: [],
        esds: [],
        ftyp: [],
        hdlr: [],
        mdat: [],
        mdhd: [],
        mdia: [],
        mfhd: [],
        minf: [],
        moof: [],
        moov: [],
        mp4a: [],
        '.mp3': [],
        mvex: [],
        mvhd: [],
        sdtp: [],
        stbl: [],
        stco: [],
        stsc: [],
        stsd: [],
        stsz: [],
        stts: [],
        tfdt: [],
        tfhd: [],
        traf: [],
        trak: [],
        trun: [],
        trex: [],
        tkhd: [],
        vmhd: [],
        smhd: []
      };

      var i;
      for (i in MP4.types) {
        if (MP4.types.hasOwnProperty(i)) {
          MP4.types[i] = [i.charCodeAt(0), i.charCodeAt(1), i.charCodeAt(2), i.charCodeAt(3)];
        }
      }

      var videoHdlr = new Uint8Array([0x00, // version 0
      0x00, 0x00, 0x00, // flags
      0x00, 0x00, 0x00, 0x00, // pre_defined
      0x76, 0x69, 0x64, 0x65, // handler_type: 'vide'
      0x00, 0x00, 0x00, 0x00, // reserved
      0x00, 0x00, 0x00, 0x00, // reserved
      0x00, 0x00, 0x00, 0x00, // reserved
      0x56, 0x69, 0x64, 0x65, 0x6f, 0x48, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'VideoHandler'
      ]);

      var audioHdlr = new Uint8Array([0x00, // version 0
      0x00, 0x00, 0x00, // flags
      0x00, 0x00, 0x00, 0x00, // pre_defined
      0x73, 0x6f, 0x75, 0x6e, // handler_type: 'soun'
      0x00, 0x00, 0x00, 0x00, // reserved
      0x00, 0x00, 0x00, 0x00, // reserved
      0x00, 0x00, 0x00, 0x00, // reserved
      0x53, 0x6f, 0x75, 0x6e, 0x64, 0x48, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'SoundHandler'
      ]);

      MP4.HDLR_TYPES = {
        'video': videoHdlr,
        'audio': audioHdlr
      };

      var dref = new Uint8Array([0x00, // version 0
      0x00, 0x00, 0x00, // flags
      0x00, 0x00, 0x00, 0x01, // entry_count
      0x00, 0x00, 0x00, 0x0c, // entry_size
      0x75, 0x72, 0x6c, 0x20, // 'url' type
      0x00, // version 0
      0x00, 0x00, 0x01 // entry_flags
      ]);

      var stco = new Uint8Array([0x00, // version
      0x00, 0x00, 0x00, // flags
      0x00, 0x00, 0x00, 0x00 // entry_count
      ]);

      MP4.STTS = MP4.STSC = MP4.STCO = stco;

      MP4.STSZ = new Uint8Array([0x00, // version
      0x00, 0x00, 0x00, // flags
      0x00, 0x00, 0x00, 0x00, // sample_size
      0x00, 0x00, 0x00, 0x00]);
      MP4.VMHD = new Uint8Array([0x00, // version
      0x00, 0x00, 0x01, // flags
      0x00, 0x00, // graphicsmode
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00 // opcolor
      ]);
      MP4.SMHD = new Uint8Array([0x00, // version
      0x00, 0x00, 0x00, // flags
      0x00, 0x00, // balance
      0x00, 0x00 // reserved
      ]);

      MP4.STSD = new Uint8Array([0x00, // version 0
      0x00, 0x00, 0x00, // flags
      0x00, 0x00, 0x00, 0x01]); // entry_count

      var majorBrand = new Uint8Array([105, 115, 111, 109]); // isom
      var avc1Brand = new Uint8Array([97, 118, 99, 49]); // avc1
      var minorVersion = new Uint8Array([0, 0, 0, 1]);

      MP4.FTYP = MP4.box(MP4.types.ftyp, majorBrand, minorVersion, majorBrand, avc1Brand);
      MP4.DINF = MP4.box(MP4.types.dinf, MP4.box(MP4.types.dref, dref));
    }
  }, {
    key: 'box',
    value: function box(type) {
      var payload = Array.prototype.slice.call(arguments, 1),
          size = 8,
          i = payload.length,
          len = i,
          result;
      // calculate the total size we need to allocate
      while (i--) {
        size += payload[i].byteLength;
      }
      result = new Uint8Array(size);
      result[0] = size >> 24 & 0xff;
      result[1] = size >> 16 & 0xff;
      result[2] = size >> 8 & 0xff;
      result[3] = size & 0xff;
      result.set(type, 4);
      // copy the payload into the result
      for (i = 0, size = 8; i < len; i++) {
        // copy payload[i] array @ offset size
        result.set(payload[i], size);
        size += payload[i].byteLength;
      }
      return result;
    }
  }, {
    key: 'hdlr',
    value: function hdlr(type) {
      return MP4.box(MP4.types.hdlr, MP4.HDLR_TYPES[type]);
    }
  }, {
    key: 'mdat',
    value: function mdat(data) {
      return MP4.box(MP4.types.mdat, data);
    }
  }, {
    key: 'mdhd',
    value: function mdhd(timescale, duration) {
      duration *= timescale;
      return MP4.box(MP4.types.mdhd, new Uint8Array([0x00, // version 0
      0x00, 0x00, 0x00, // flags
      0x00, 0x00, 0x00, 0x02, // creation_time
      0x00, 0x00, 0x00, 0x03, // modification_time
      timescale >> 24 & 0xFF, timescale >> 16 & 0xFF, timescale >> 8 & 0xFF, timescale & 0xFF, // timescale
      duration >> 24, duration >> 16 & 0xFF, duration >> 8 & 0xFF, duration & 0xFF, // duration
      0x55, 0xc4, // 'und' language (undetermined)
      0x00, 0x00]));
    }
  }, {
    key: 'mdia',
    value: function mdia(track) {
      return MP4.box(MP4.types.mdia, MP4.mdhd(track.timescale, track.duration), MP4.hdlr(track.type), MP4.minf(track));
    }
  }, {
    key: 'mfhd',
    value: function mfhd(sequenceNumber) {
      return MP4.box(MP4.types.mfhd, new Uint8Array([0x00, 0x00, 0x00, 0x00, // flags
      sequenceNumber >> 24, sequenceNumber >> 16 & 0xFF, sequenceNumber >> 8 & 0xFF, sequenceNumber & 0xFF]));
    }
  }, {
    key: 'minf',
    value: function minf(track) {
      if (track.type === 'audio') {
        return MP4.box(MP4.types.minf, MP4.box(MP4.types.smhd, MP4.SMHD), MP4.DINF, MP4.stbl(track));
      } else {
        return MP4.box(MP4.types.minf, MP4.box(MP4.types.vmhd, MP4.VMHD), MP4.DINF, MP4.stbl(track));
      }
    }
  }, {
    key: 'moof',
    value: function moof(sn, baseMediaDecodeTime, track) {
      return MP4.box(MP4.types.moof, MP4.mfhd(sn), MP4.traf(track, baseMediaDecodeTime));
    }
    /**
     * @param tracks... (optional) {array} the tracks associated with this movie
     */

  }, {
    key: 'moov',
    value: function moov(tracks) {
      var i = tracks.length,
          boxes = [];

      while (i--) {
        boxes[i] = MP4.trak(tracks[i]);
      }

      return MP4.box.apply(null, [MP4.types.moov, MP4.mvhd(tracks[0].timescale, tracks[0].duration)].concat(boxes).concat(MP4.mvex(tracks)));
    }
  }, {
    key: 'mvex',
    value: function mvex(tracks) {
      var i = tracks.length,
          boxes = [];

      while (i--) {
        boxes[i] = MP4.trex(tracks[i]);
      }
      return MP4.box.apply(null, [MP4.types.mvex].concat(boxes));
    }
  }, {
    key: 'mvhd',
    value: function mvhd(timescale, duration) {
      duration *= timescale;
      var bytes = new Uint8Array([0x00, // version 0
      0x00, 0x00, 0x00, // flags
      0x00, 0x00, 0x00, 0x01, // creation_time
      0x00, 0x00, 0x00, 0x02, // modification_time
      timescale >> 24 & 0xFF, timescale >> 16 & 0xFF, timescale >> 8 & 0xFF, timescale & 0xFF, // timescale
      duration >> 24 & 0xFF, duration >> 16 & 0xFF, duration >> 8 & 0xFF, duration & 0xFF, // duration
      0x00, 0x01, 0x00, 0x00, // 1.0 rate
      0x01, 0x00, // 1.0 volume
      0x00, 0x00, // reserved
      0x00, 0x00, 0x00, 0x00, // reserved
      0x00, 0x00, 0x00, 0x00, // reserved
      0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, // transformation: unity matrix
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // pre_defined
      0xff, 0xff, 0xff, 0xff // next_track_ID
      ]);
      return MP4.box(MP4.types.mvhd, bytes);
    }
  }, {
    key: 'sdtp',
    value: function sdtp(track) {
      var samples = track.samples || [],
          bytes = new Uint8Array(4 + samples.length),
          flags,
          i;
      // leave the full box header (4 bytes) all zero
      // write the sample table
      for (i = 0; i < samples.length; i++) {
        flags = samples[i].flags;
        bytes[i + 4] = flags.dependsOn << 4 | flags.isDependedOn << 2 | flags.hasRedundancy;
      }

      return MP4.box(MP4.types.sdtp, bytes);
    }
  }, {
    key: 'stbl',
    value: function stbl(track) {
      return MP4.box(MP4.types.stbl, MP4.stsd(track), MP4.box(MP4.types.stts, MP4.STTS), MP4.box(MP4.types.stsc, MP4.STSC), MP4.box(MP4.types.stsz, MP4.STSZ), MP4.box(MP4.types.stco, MP4.STCO));
    }
  }, {
    key: 'avc1',
    value: function avc1(track) {
      var sps = [],
          pps = [],
          i,
          data,
          len;
      // assemble the SPSs

      for (i = 0; i < track.sps.length; i++) {
        data = track.sps[i];
        len = data.byteLength;
        sps.push(len >>> 8 & 0xFF);
        sps.push(len & 0xFF);
        sps = sps.concat(Array.prototype.slice.call(data)); // SPS
      }

      // assemble the PPSs
      for (i = 0; i < track.pps.length; i++) {
        data = track.pps[i];
        len = data.byteLength;
        pps.push(len >>> 8 & 0xFF);
        pps.push(len & 0xFF);
        pps = pps.concat(Array.prototype.slice.call(data));
      }

      var avcc = MP4.box(MP4.types.avcC, new Uint8Array([0x01, // version
      sps[3], // profile
      sps[4], // profile compat
      sps[5], // level
      0xfc | 3, // lengthSizeMinusOne, hard-coded to 4 bytes
      0xE0 | track.sps.length // 3bit reserved (111) + numOfSequenceParameterSets
      ].concat(sps).concat([track.pps.length // numOfPictureParameterSets
      ]).concat(pps))),
          // "PPS"
      width = track.width,
          height = track.height;
      //console.log('avcc:' + Hex.hexDump(avcc));
      return MP4.box(MP4.types.avc1, new Uint8Array([0x00, 0x00, 0x00, // reserved
      0x00, 0x00, 0x00, // reserved
      0x00, 0x01, // data_reference_index
      0x00, 0x00, // pre_defined
      0x00, 0x00, // reserved
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // pre_defined
      width >> 8 & 0xFF, width & 0xff, // width
      height >> 8 & 0xFF, height & 0xff, // height
      0x00, 0x48, 0x00, 0x00, // horizresolution
      0x00, 0x48, 0x00, 0x00, // vertresolution
      0x00, 0x00, 0x00, 0x00, // reserved
      0x00, 0x01, // frame_count
      0x12, 0x64, 0x61, 0x69, 0x6C, //dailymotion/hls.js
      0x79, 0x6D, 0x6F, 0x74, 0x69, 0x6F, 0x6E, 0x2F, 0x68, 0x6C, 0x73, 0x2E, 0x6A, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // compressorname
      0x00, 0x18, // depth = 24
      0x11, 0x11]), // pre_defined = -1
      avcc, MP4.box(MP4.types.btrt, new Uint8Array([0x00, 0x1c, 0x9c, 0x80, // bufferSizeDB
      0x00, 0x2d, 0xc6, 0xc0, // maxBitrate
      0x00, 0x2d, 0xc6, 0xc0])) // avgBitrate
      );
    }
  }, {
    key: 'esds',
    value: function esds(track) {
      var configlen = track.config.length;
      return new Uint8Array([0x00, // version 0
      0x00, 0x00, 0x00, // flags

      0x03, // descriptor_type
      0x17 + configlen, // length
      0x00, 0x01, //es_id
      0x00, // stream_priority

      0x04, // descriptor_type
      0x0f + configlen, // length
      0x40, //codec : mpeg4_audio
      0x15, // stream_type
      0x00, 0x00, 0x00, // buffer_size
      0x00, 0x00, 0x00, 0x00, // maxBitrate
      0x00, 0x00, 0x00, 0x00, // avgBitrate

      0x05 // descriptor_type
      ].concat([configlen]).concat(track.config).concat([0x06, 0x01, 0x02])); // GASpecificConfig)); // length + audio config descriptor
    }
  }, {
    key: 'mp4a',
    value: function mp4a(track) {
      var audiosamplerate = track.audiosamplerate;
      return MP4.box(MP4.types.mp4a, new Uint8Array([0x00, 0x00, 0x00, // reserved
      0x00, 0x00, 0x00, // reserved
      0x00, 0x01, // data_reference_index
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // reserved
      0x00, track.channelCount, // channelcount
      0x00, 0x10, // sampleSize:16bits
      0x00, 0x00, 0x00, 0x00, // reserved2
      audiosamplerate >> 8 & 0xFF, audiosamplerate & 0xff, //
      0x00, 0x00]), MP4.box(MP4.types.esds, MP4.esds(track)));
    }
  }, {
    key: 'mp3',
    value: function mp3(track) {
      var audiosamplerate = track.audiosamplerate;
      return MP4.box(MP4.types['.mp3'], new Uint8Array([0x00, 0x00, 0x00, // reserved
      0x00, 0x00, 0x00, // reserved
      0x00, 0x01, // data_reference_index
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // reserved
      0x00, track.channelCount, // channelcount
      0x00, 0x10, // sampleSize:16bits
      0x00, 0x00, 0x00, 0x00, // reserved2
      audiosamplerate >> 8 & 0xFF, audiosamplerate & 0xff, //
      0x00, 0x00]));
    }
  }, {
    key: 'stsd',
    value: function stsd(track) {
      if (track.type === 'audio') {
        if (!track.isAAC && track.codec === 'mp3') {
          return MP4.box(MP4.types.stsd, MP4.STSD, MP4.mp3(track));
        }
        return MP4.box(MP4.types.stsd, MP4.STSD, MP4.mp4a(track));
      } else {
        return MP4.box(MP4.types.stsd, MP4.STSD, MP4.avc1(track));
      }
    }
  }, {
    key: 'tkhd',
    value: function tkhd(track) {
      var id = track.id,
          duration = track.duration * track.timescale,
          width = track.width,
          height = track.height;
      return MP4.box(MP4.types.tkhd, new Uint8Array([0x00, // version 0
      0x00, 0x00, 0x07, // flags
      0x00, 0x00, 0x00, 0x00, // creation_time
      0x00, 0x00, 0x00, 0x00, // modification_time
      id >> 24 & 0xFF, id >> 16 & 0xFF, id >> 8 & 0xFF, id & 0xFF, // track_ID
      0x00, 0x00, 0x00, 0x00, // reserved
      duration >> 24, duration >> 16 & 0xFF, duration >> 8 & 0xFF, duration & 0xFF, // duration
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // reserved
      0x00, 0x00, // layer
      0x00, 0x00, // alternate_group
      0x00, 0x00, // non-audio track volume
      0x00, 0x00, // reserved
      0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, // transformation: unity matrix
      width >> 8 & 0xFF, width & 0xFF, 0x00, 0x00, // width
      height >> 8 & 0xFF, height & 0xFF, 0x00, 0x00 // height
      ]));
    }
  }, {
    key: 'traf',
    value: function traf(track, baseMediaDecodeTime) {
      var sampleDependencyTable = MP4.sdtp(track),
          id = track.id;
      return MP4.box(MP4.types.traf, MP4.box(MP4.types.tfhd, new Uint8Array([0x00, // version 0
      0x00, 0x00, 0x00, // flags
      id >> 24, id >> 16 & 0XFF, id >> 8 & 0XFF, id & 0xFF])), MP4.box(MP4.types.tfdt, new Uint8Array([0x00, // version 0
      0x00, 0x00, 0x00, // flags
      baseMediaDecodeTime >> 24, baseMediaDecodeTime >> 16 & 0XFF, baseMediaDecodeTime >> 8 & 0XFF, baseMediaDecodeTime & 0xFF])), MP4.trun(track, sampleDependencyTable.length + 16 + // tfhd
      16 + // tfdt
      8 + // traf header
      16 + // mfhd
      8 + // moof header
      8), // mdat header
      sampleDependencyTable);
    }

    /**
     * Generate a track box.
     * @param track {object} a track definition
     * @return {Uint8Array} the track box
     */

  }, {
    key: 'trak',
    value: function trak(track) {
      track.duration = track.duration || 0xffffffff;
      return MP4.box(MP4.types.trak, MP4.tkhd(track), MP4.mdia(track));
    }
  }, {
    key: 'trex',
    value: function trex(track) {
      var id = track.id;
      return MP4.box(MP4.types.trex, new Uint8Array([0x00, // version 0
      0x00, 0x00, 0x00, // flags
      id >> 24, id >> 16 & 0XFF, id >> 8 & 0XFF, id & 0xFF, // track_ID
      0x00, 0x00, 0x00, 0x01, // default_sample_description_index
      0x00, 0x00, 0x00, 0x00, // default_sample_duration
      0x00, 0x00, 0x00, 0x00, // default_sample_size
      0x00, 0x01, 0x00, 0x01 // default_sample_flags
      ]));
    }
  }, {
    key: 'trun',
    value: function trun(track, offset) {
      var samples = track.samples || [],
          len = samples.length,
          arraylen = 12 + 16 * len,
          array = new Uint8Array(arraylen),
          i,
          sample,
          duration,
          size,
          flags,
          cts;
      offset += 8 + arraylen;
      array.set([0x00, // version 0
      0x00, 0x0f, 0x01, // flags
      len >>> 24 & 0xFF, len >>> 16 & 0xFF, len >>> 8 & 0xFF, len & 0xFF, // sample_count
      offset >>> 24 & 0xFF, offset >>> 16 & 0xFF, offset >>> 8 & 0xFF, offset & 0xFF // data_offset
      ], 0);
      for (i = 0; i < len; i++) {
        sample = samples[i];
        duration = sample.duration;
        size = sample.size;
        flags = sample.flags;
        cts = sample.cts;
        array.set([duration >>> 24 & 0xFF, duration >>> 16 & 0xFF, duration >>> 8 & 0xFF, duration & 0xFF, // sample_duration
        size >>> 24 & 0xFF, size >>> 16 & 0xFF, size >>> 8 & 0xFF, size & 0xFF, // sample_size
        flags.isLeading << 2 | flags.dependsOn, flags.isDependedOn << 6 | flags.hasRedundancy << 4 | flags.paddingValue << 1 | flags.isNonSync, flags.degradPrio & 0xF0 << 8, flags.degradPrio & 0x0F, // sample_flags
        cts >>> 24 & 0xFF, cts >>> 16 & 0xFF, cts >>> 8 & 0xFF, cts & 0xFF // sample_composition_time_offset
        ], 12 + 16 * i);
      }
      return MP4.box(MP4.types.trun, array);
    }
  }, {
    key: 'initSegment',
    value: function initSegment(tracks) {
      if (!MP4.types) {
        MP4.init();
      }
      var movie = MP4.moov(tracks),
          result;
      result = new Uint8Array(MP4.FTYP.byteLength + movie.byteLength);
      result.set(MP4.FTYP);
      result.set(movie, MP4.FTYP.byteLength);
      return result;
    }
  }]);

  return MP4;
}();

exports.default = MP4;

},{}],40:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * fMP4 remuxer
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */

var _aac = require('../helper/aac');

var _aac2 = _interopRequireDefault(_aac);

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _logger = require('../utils/logger');

var _mp4Generator = require('../remux/mp4-generator');

var _mp4Generator2 = _interopRequireDefault(_mp4Generator);

var _errors = require('../errors');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var MP4Remuxer = function () {
  function MP4Remuxer(observer, id, config, typeSupported) {
    _classCallCheck(this, MP4Remuxer);

    this.observer = observer;
    this.id = id;
    this.config = config;
    this.typeSupported = typeSupported;
    this.ISGenerated = false;
    this.PES2MP4SCALEFACTOR = 4;
    this.PES_TIMESCALE = 90000;
    this.MP4_TIMESCALE = this.PES_TIMESCALE / this.PES2MP4SCALEFACTOR;
  }

  _createClass(MP4Remuxer, [{
    key: 'destroy',
    value: function destroy() {}
  }, {
    key: 'insertDiscontinuity',
    value: function insertDiscontinuity() {
      this._initPTS = this._initDTS = undefined;
    }
  }, {
    key: 'switchLevel',
    value: function switchLevel() {
      this.ISGenerated = false;
    }
  }, {
    key: 'remux',
    value: function remux(level, sn, cc, audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset, defaultInitPTS) {
      this.level = level;
      this.sn = sn;
      // generate Init Segment if needed
      if (!this.ISGenerated) {
        this.generateIS(audioTrack, videoTrack, timeOffset, cc);
      }

      if (defaultInitPTS !== null) {
        this._initPTS = this._initDTS = defaultInitPTS;
      }

      if (this.ISGenerated) {
        // Purposefully remuxing audio before video, so that remuxVideo can use nextAudioPts, which is
        // calculated in remuxAudio.
        //logger.log('nb AAC samples:' + audioTrack.samples.length);
        if (audioTrack.samples.length) {
          var audioData = this.remuxAudio(audioTrack, timeOffset, contiguous, accurateTimeOffset);
          //logger.log('nb AVC samples:' + videoTrack.samples.length);
          if (videoTrack.samples.length) {
            var audioTrackLength = void 0;
            if (audioData) {
              audioTrackLength = audioData.endPTS - audioData.startPTS;
            }
            this.remuxVideo(videoTrack, timeOffset, contiguous, audioTrackLength);
          }
        } else {
          var videoData = void 0;
          //logger.log('nb AVC samples:' + videoTrack.samples.length);
          if (videoTrack.samples.length) {
            videoData = this.remuxVideo(videoTrack, timeOffset, contiguous);
          }
          if (videoData && audioTrack.codec) {
            this.remuxEmptyAudio(audioTrack, timeOffset, contiguous, videoData);
          }
        }
      }
      //logger.log('nb ID3 samples:' + audioTrack.samples.length);
      if (id3Track.samples.length) {
        this.remuxID3(id3Track, timeOffset);
      }
      //logger.log('nb ID3 samples:' + audioTrack.samples.length);
      if (textTrack.samples.length) {
        this.remuxText(textTrack, timeOffset);
      }
      //notify end of parsing
      this.observer.trigger(_events2.default.FRAG_PARSED, { id: this.id, level: this.level, sn: this.sn });
    }
  }, {
    key: 'generateIS',
    value: function generateIS(audioTrack, videoTrack, timeOffset, cc) {
      var observer = this.observer,
          audioSamples = audioTrack.samples,
          videoSamples = videoTrack.samples,
          pesTimeScale = this.PES_TIMESCALE,
          typeSupported = this.typeSupported,
          container = 'audio/mp4',
          tracks = {},
          data = { id: this.id, level: this.level, sn: this.sn, tracks: tracks, unique: false },
          computePTSDTS = this._initPTS === undefined,
          initPTS,
          initDTS;

      if (computePTSDTS) {
        initPTS = initDTS = Infinity;
      }
      if (audioTrack.config && audioSamples.length) {
        audioTrack.timescale = audioTrack.audiosamplerate;
        // MP4 duration (track duration in seconds multiplied by timescale) is coded on 32 bits
        // we know that each AAC sample contains 1024 frames....
        // in order to avoid overflowing the 32 bit counter for large duration, we use smaller timescale (timescale/gcd)
        // we just need to ensure that AAC sample duration will still be an integer (will be 1024/gcd)
        if (audioTrack.timescale * audioTrack.duration > Math.pow(2, 32)) {
          (function () {
            var greatestCommonDivisor = function greatestCommonDivisor(a, b) {
              if (!b) {
                return a;
              }
              return greatestCommonDivisor(b, a % b);
            };
            audioTrack.timescale = audioTrack.audiosamplerate / greatestCommonDivisor(audioTrack.audiosamplerate, audioTrack.isAAC ? 1024 : 1152);
          })();
        }
        _logger.logger.log('audio mp4 timescale :' + audioTrack.timescale);
        if (!audioTrack.isAAC) {
          if (typeSupported.mpeg) {
            // Chrome and Safari
            container = 'audio/mpeg';
            audioTrack.codec = '';
          } else if (typeSupported.mp3) {
            // Firefox
            audioTrack.codec = 'mp3';
          }
        }
        tracks.audio = {
          container: container,
          codec: audioTrack.codec,
          initSegment: !audioTrack.isAAC && typeSupported.mpeg ? new Uint8Array() : _mp4Generator2.default.initSegment([audioTrack]),
          metadata: {
            channelCount: audioTrack.channelCount
          }
        };
        if (computePTSDTS) {
          // remember first PTS of this demuxing context. for audio, PTS = DTS
          initPTS = initDTS = audioSamples[0].pts - pesTimeScale * timeOffset;
        }
      }

      if (videoTrack.sps && videoTrack.pps && videoSamples.length) {
        videoTrack.timescale = this.MP4_TIMESCALE;
        tracks.video = {
          container: 'video/mp4',
          codec: videoTrack.codec,
          initSegment: _mp4Generator2.default.initSegment([videoTrack]),
          metadata: {
            width: videoTrack.width,
            height: videoTrack.height
          }
        };
        if (computePTSDTS) {
          initPTS = Math.min(initPTS, videoSamples[0].pts - pesTimeScale * timeOffset);
          initDTS = Math.min(initDTS, videoSamples[0].dts - pesTimeScale * timeOffset);
          this.observer.trigger(_events2.default.INIT_PTS_FOUND, { initPTS: initPTS });
          this.observer.trigger(_events2.default.INIT_PTS_FOUND, { id: this.id, initPTS: initPTS, cc: cc });
        }
      }

      if (Object.keys(tracks).length) {
        observer.trigger(_events2.default.FRAG_PARSING_INIT_SEGMENT, data);
        this.ISGenerated = true;
        if (computePTSDTS) {
          this._initPTS = initPTS;
          this._initDTS = initDTS;
        }
      } else {
        observer.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, id: this.id, details: _errors.ErrorDetails.FRAG_PARSING_ERROR, fatal: false, reason: 'no audio/video samples found' });
      }
    }
  }, {
    key: 'remuxVideo',
    value: function remuxVideo(track, timeOffset, contiguous, audioTrackLength) {
      var offset = 8,
          pesTimeScale = this.PES_TIMESCALE,
          pes2mp4ScaleFactor = this.PES2MP4SCALEFACTOR,
          mp4SampleDuration,
          mdat,
          moof,
          firstPTS,
          firstDTS,
          nextDTS,
          lastPTS,
          lastDTS,
          inputSamples = track.samples,
          outputSamples = [],
          nbSamples = inputSamples.length,
          ptsNormalize = this._PTSNormalize,
          initDTS = this._initDTS;

      // for (let i = 0; i < track.samples.length; i++) {
      //   let avcSample = track.samples[i];
      //   let units = avcSample.units.units;
      //   let unitsString = '';
      //   for (let j = 0; j < units.length ; j++) {
      //     unitsString += units[j].type + ',';
      //     if (units[j].data.length < 500) {
      //       unitsString += Hex.hexDump(units[j].data);
      //     }
      //   }
      //   logger.log(avcSample.pts + '/' + avcSample.dts + ',' + unitsString + avcSample.units.length);
      // }

      // sort video samples by DTS order
      inputSamples.sort(function (a, b) {
        return a.dts - b.dts;
      });

      // handle broken streams with PTS < DTS, tolerance up 200ms (18000 in 90kHz timescale)
      var PTSDTSshift = inputSamples.reduce(function (prev, curr) {
        return Math.max(Math.min(prev, curr.pts - curr.dts), -18000);
      }, 0);
      if (PTSDTSshift < 0) {
        _logger.logger.warn('PTS < DTS detected in video samples, shifting DTS by ' + Math.round(PTSDTSshift / 90) + ' ms to overcome this issue');
        for (var i = 0; i < inputSamples.length; i++) {
          inputSamples[i].dts += PTSDTSshift;
        }
      }

      // PTS is coded on 33bits, and can loop from -2^32 to 2^32
      // ptsNormalize will make PTS/DTS value monotonic, we use last known DTS value as reference value
      var nextAvcDts = void 0;
      // contiguous fragments are consecutive fragments from same quality level (same level, new SN = old SN + 1)
      if (contiguous) {
        // if parsed fragment is contiguous with last one, let's use last DTS value as reference
        nextAvcDts = this.nextAvcDts;
      } else {
        // if not contiguous, let's use target timeOffset
        nextAvcDts = timeOffset * pesTimeScale;
      }

      // compute first DTS and last DTS, normalize them against reference value
      var sample = inputSamples[0];
      firstDTS = Math.max(ptsNormalize(sample.dts - initDTS, nextAvcDts), 0);
      firstPTS = Math.max(ptsNormalize(sample.pts - initDTS, nextAvcDts), 0);

      // check timestamp continuity accross consecutive fragments (this is to remove inter-fragment gap/hole)
      var delta = Math.round((firstDTS - nextAvcDts) / 90);
      // if fragment are contiguous, detect hole/overlapping between fragments
      if (contiguous) {
        if (delta) {
          if (delta > 1) {
            _logger.logger.log('AVC:' + delta + ' ms hole between fragments detected,filling it');
          } else if (delta < -1) {
            _logger.logger.log('AVC:' + -delta + ' ms overlapping between fragments detected');
          }
          // remove hole/gap : set DTS to next expected DTS
          firstDTS = nextAvcDts;
          inputSamples[0].dts = firstDTS + initDTS;
          // offset PTS as well, ensure that PTS is smaller or equal than new DTS
          firstPTS = Math.max(firstPTS - delta, nextAvcDts);
          inputSamples[0].pts = firstPTS + initDTS;
          _logger.logger.log('Video/PTS/DTS adjusted: ' + Math.round(firstPTS / 90) + '/' + Math.round(firstDTS / 90) + ',delta:' + delta + ' ms');
        }
      }
      nextDTS = firstDTS;

      // compute lastPTS/lastDTS
      sample = inputSamples[inputSamples.length - 1];
      lastDTS = Math.max(ptsNormalize(sample.dts - initDTS, nextAvcDts), 0);
      lastPTS = Math.max(ptsNormalize(sample.pts - initDTS, nextAvcDts), 0);
      lastPTS = Math.max(lastPTS, lastDTS);

      var vendor = navigator.vendor,
          userAgent = navigator.userAgent,
          isSafari = vendor && vendor.indexOf('Apple') > -1 && userAgent && !userAgent.match('CriOS');

      // on Safari let's signal the same sample duration for all samples
      // sample duration (as expected by trun MP4 boxes), should be the delta between sample DTS
      // set this constant duration as being the avg delta between consecutive DTS.
      if (isSafari) {
        mp4SampleDuration = Math.round((lastDTS - firstDTS) / (pes2mp4ScaleFactor * (inputSamples.length - 1)));
      }

      // normalize all PTS/DTS now ...
      for (var _i = 0; _i < nbSamples; _i++) {
        var _sample = inputSamples[_i];
        if (isSafari) {
          // sample DTS is computed using a constant decoding offset (mp4SampleDuration) between samples
          _sample.dts = firstDTS + _i * pes2mp4ScaleFactor * mp4SampleDuration;
        } else {
          // ensure sample monotonic DTS
          _sample.dts = Math.max(ptsNormalize(_sample.dts - initDTS, nextAvcDts), firstDTS);
          // ensure dts is a multiple of scale factor to avoid rounding issues
          _sample.dts = Math.round(_sample.dts / pes2mp4ScaleFactor) * pes2mp4ScaleFactor;
        }
        // we normalize PTS against nextAvcDts, we also substract initDTS (some streams don't start @ PTS O)
        // and we ensure that computed value is greater or equal than sample DTS
        _sample.pts = Math.max(ptsNormalize(_sample.pts - initDTS, nextAvcDts), _sample.dts);
        // ensure pts is a multiple of scale factor to avoid rounding issues
        _sample.pts = Math.round(_sample.pts / pes2mp4ScaleFactor) * pes2mp4ScaleFactor;
      }

      /* concatenate the video data and construct the mdat in place
        (need 8 more bytes to fill length and mpdat type) */
      var mdatSize = track.len + 4 * track.nbNalu + 8;
      try {
        mdat = new Uint8Array(mdatSize);
      } catch (err) {
        this.observer.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MUX_ERROR, level: this.level, id: this.id, details: _errors.ErrorDetails.REMUX_ALLOC_ERROR, fatal: false, bytes: mdatSize, reason: 'fail allocating video mdat ' + mdatSize });
        return;
      }
      var view = new DataView(mdat.buffer);
      view.setUint32(0, mdatSize);
      mdat.set(_mp4Generator2.default.types.mdat, 4);

      for (var _i2 = 0; _i2 < nbSamples; _i2++) {
        var avcSample = inputSamples[_i2],
            avcSampleUnits = avcSample.units.units,
            mp4SampleLength = 0,
            compositionTimeOffset = void 0;
        // convert NALU bitstream to MP4 format (prepend NALU with size field)
        for (var j = 0, nbUnits = avcSampleUnits.length; j < nbUnits; j++) {
          var unit = avcSampleUnits[j],
              unitData = unit.data,
              unitDataLen = unit.data.byteLength;
          view.setUint32(offset, unitDataLen);
          offset += 4;
          mdat.set(unitData, offset);
          offset += unitDataLen;
          mp4SampleLength += 4 + unitDataLen;
        }

        if (!isSafari) {
          // expected sample duration is the Decoding Timestamp diff of consecutive samples
          if (_i2 < nbSamples - 1) {
            mp4SampleDuration = inputSamples[_i2 + 1].dts - avcSample.dts;
          } else {
            var config = this.config,
                lastFrameDuration = avcSample.dts - inputSamples[_i2 > 0 ? _i2 - 1 : _i2].dts;
            if (config.stretchShortVideoTrack) {
              // In some cases, a segment's audio track duration may exceed the video track duration.
              // Since we've already remuxed audio, and we know how long the audio track is, we look to
              // see if the delta to the next segment is longer than the minimum of maxBufferHole and
              // maxSeekHole. If so, playback would potentially get stuck, so we artificially inflate
              // the duration of the last frame to minimize any potential gap between segments.
              var maxBufferHole = config.maxBufferHole,
                  maxSeekHole = config.maxSeekHole,
                  gapTolerance = Math.floor(Math.min(maxBufferHole, maxSeekHole) * pesTimeScale),
                  deltaToFrameEnd = (audioTrackLength ? firstPTS + audioTrackLength * pesTimeScale : this.nextAudioPts) - avcSample.pts;
              if (deltaToFrameEnd > gapTolerance) {
                // We subtract lastFrameDuration from deltaToFrameEnd to try to prevent any video
                // frame overlap. maxBufferHole/maxSeekHole should be >> lastFrameDuration anyway.
                mp4SampleDuration = deltaToFrameEnd - lastFrameDuration;
                if (mp4SampleDuration < 0) {
                  mp4SampleDuration = lastFrameDuration;
                }
                _logger.logger.log('It is approximately ' + deltaToFrameEnd / 90 + ' ms to the next segment; using duration ' + mp4SampleDuration / 90 + ' ms for the last video frame.');
              } else {
                mp4SampleDuration = lastFrameDuration;
              }
            } else {
              mp4SampleDuration = lastFrameDuration;
            }
          }
          mp4SampleDuration /= pes2mp4ScaleFactor;
          compositionTimeOffset = Math.round((avcSample.pts - avcSample.dts) / pes2mp4ScaleFactor);
        } else {
          compositionTimeOffset = Math.max(0, mp4SampleDuration * Math.round((avcSample.pts - avcSample.dts) / (pes2mp4ScaleFactor * mp4SampleDuration)));
        }

        //console.log('PTS/DTS/initDTS/normPTS/normDTS/relative PTS : ${avcSample.pts}/${avcSample.dts}/${initDTS}/${ptsnorm}/${dtsnorm}/${(avcSample.pts/4294967296).toFixed(3)}');
        outputSamples.push({
          size: mp4SampleLength,
          // constant duration
          duration: mp4SampleDuration,
          cts: compositionTimeOffset,
          flags: {
            isLeading: 0,
            isDependedOn: 0,
            hasRedundancy: 0,
            degradPrio: 0,
            dependsOn: avcSample.key ? 2 : 1,
            isNonSync: avcSample.key ? 0 : 1
          }
        });
      }
      // next AVC sample DTS should be equal to last sample DTS + last sample duration (in PES timescale)
      this.nextAvcDts = lastDTS + mp4SampleDuration * pes2mp4ScaleFactor;
      var dropped = track.dropped;
      track.len = 0;
      track.nbNalu = 0;
      track.dropped = 0;
      if (outputSamples.length && navigator.userAgent.toLowerCase().indexOf('chrome') > -1) {
        var flags = outputSamples[0].flags;
        // chrome workaround, mark first sample as being a Random Access Point to avoid sourcebuffer append issue
        // https://code.google.com/p/chromium/issues/detail?id=229412
        flags.dependsOn = 2;
        flags.isNonSync = 0;
      }
      track.samples = outputSamples;
      moof = _mp4Generator2.default.moof(track.sequenceNumber++, firstDTS / pes2mp4ScaleFactor, track);
      track.samples = [];

      var data = {
        id: this.id,
        level: this.level,
        sn: this.sn,
        data1: moof,
        data2: mdat,
        startPTS: firstPTS / pesTimeScale,
        endPTS: (lastPTS + pes2mp4ScaleFactor * mp4SampleDuration) / pesTimeScale,
        startDTS: firstDTS / pesTimeScale,
        endDTS: this.nextAvcDts / pesTimeScale,
        type: 'video',
        nb: outputSamples.length,
        dropped: dropped
      };
      this.observer.trigger(_events2.default.FRAG_PARSING_DATA, data);
      return data;
    }
  }, {
    key: 'remuxAudio',
    value: function remuxAudio(track, timeOffset, contiguous, accurateTimeOffset) {
      var pesTimeScale = this.PES_TIMESCALE,
          mp4timeScale = track.timescale,
          pes2mp4ScaleFactor = pesTimeScale / mp4timeScale,
          expectedSampleDuration = track.timescale * (track.isAAC ? 1024 : 1152) / track.audiosamplerate,
          pesFrameDuration = expectedSampleDuration * pes2mp4ScaleFactor,
          ptsNormalize = this._PTSNormalize,
          initDTS = this._initDTS,
          rawMPEG = !track.isAAC && this.typeSupported.mpeg;

      var view,
          offset = rawMPEG ? 0 : 8,
          audioSample,
          mp4Sample,
          unit,
          mdat,
          moof,
          firstPTS,
          firstDTS,
          lastDTS,
          pts,
          dts,
          ptsnorm,
          dtsnorm,
          outputSamples = [],
          inputSamples = [],
          fillFrame,
          newStamp,
          nextAudioPts;

      track.samples.sort(function (a, b) {
        return a.pts - b.pts;
      });
      inputSamples = track.samples;

      // for audio samples, also consider consecutive fragments as being contiguous (even if a level switch occurs),
      // for sake of clarity:
      // consecutive fragments are frags with
      //  - less than 100ms gaps between new time offset and next expected PTS OR
      //  - less than 20 audio frames distance
      // contiguous fragments are consecutive fragments from same quality level (same level, new SN = old SN + 1)
      // this helps ensuring audio continuity
      // and this also avoids audio glitches/cut when switching quality, or reporting wrong duration on first audio frame

      nextAudioPts = this.nextAudioPts;
      contiguous |= inputSamples.length && nextAudioPts && (Math.abs(timeOffset - nextAudioPts / pesTimeScale) < 0.1 || Math.abs(inputSamples[0].pts - nextAudioPts - this._initDTS) < 20 * pesFrameDuration);

      if (!contiguous) {
        // if fragments are not contiguous, let's use timeOffset to compute next Audio PTS
        nextAudioPts = timeOffset * pesTimeScale;
      }
      // If the audio track is missing samples, the frames seem to get "left-shifted" within the
      // resulting mp4 segment, causing sync issues and leaving gaps at the end of the audio segment.
      // In an effort to prevent this from happening, we inject frames here where there are gaps.
      // When possible, we inject a silent frame; when that's not possible, we duplicate the last
      // frame.

      // only inject/drop audio frames in case time offset is accurate
      if (accurateTimeOffset && track.isAAC) {
        for (var i = 0, nextPtsNorm = nextAudioPts; i < inputSamples.length;) {
          // First, let's see how far off this frame is from where we expect it to be
          var sample = inputSamples[i],
              ptsNorm = ptsNormalize(sample.pts - initDTS, nextAudioPts),
              delta = ptsNorm - nextPtsNorm;

          // If we're overlapping by more than a duration, drop this sample
          if (delta <= -pesFrameDuration) {
            _logger.logger.warn('Dropping 1 audio frame @ ' + Math.round(nextPtsNorm / 90) / 1000 + 's due to ' + Math.round(Math.abs(delta / 90)) + ' ms overlap.');
            inputSamples.splice(i, 1);
            track.len -= sample.unit.length;
            // Don't touch nextPtsNorm or i
          }
          // Otherwise, if we're more than a frame away from where we should be, insert missing frames
          else if (delta >= pesFrameDuration) {
              var missing = Math.round(delta / pesFrameDuration);
              _logger.logger.warn('Injecting ' + missing + ' audio frame @ ' + Math.round(nextPtsNorm / 90) / 1000 + 's due to ' + Math.round(delta / 90) + ' ms gap.');
              for (var j = 0; j < missing; j++) {
                newStamp = nextPtsNorm + initDTS;
                newStamp = Math.max(newStamp, initDTS);
                fillFrame = _aac2.default.getSilentFrame(track.channelCount);
                if (!fillFrame) {
                  _logger.logger.log('Unable to get silent frame for given audio codec; duplicating last frame instead.');
                  fillFrame = sample.unit.subarray();
                }
                inputSamples.splice(i, 0, { unit: fillFrame, pts: newStamp, dts: newStamp });
                track.len += fillFrame.length;
                nextPtsNorm += pesFrameDuration;
                i += 1;
              }

              // Adjust sample to next expected pts
              sample.pts = sample.dts = nextPtsNorm + initDTS;
              nextPtsNorm += pesFrameDuration;
              i += 1;
            }
            // Otherwise, we're within half a frame duration, so just adjust pts
            else {
                if (Math.abs(delta) > 0.1 * pesFrameDuration) {
                  //logger.log(`Invalid frame delta ${Math.round(ptsNorm - nextPtsNorm + pesFrameDuration)} at PTS ${Math.round(ptsNorm / 90)} (should be ${Math.round(pesFrameDuration)}).`);
                }
                nextPtsNorm += pesFrameDuration;
                if (i === 0) {
                  sample.pts = sample.dts = initDTS + nextAudioPts;
                } else {
                  sample.pts = sample.dts = inputSamples[i - 1].pts + pesFrameDuration;
                }
                i += 1;
              }
        }
      }

      for (var _j = 0, _nbSamples = inputSamples.length; _j < _nbSamples; _j++) {
        audioSample = inputSamples[_j];
        unit = audioSample.unit;
        pts = audioSample.pts - initDTS;
        dts = audioSample.dts - initDTS;
        //logger.log(`Audio/PTS:${Math.round(pts/90)}`);
        // if not first sample
        if (lastDTS !== undefined) {
          ptsnorm = ptsNormalize(pts, lastDTS);
          dtsnorm = ptsNormalize(dts, lastDTS);
          mp4Sample.duration = Math.round((dtsnorm - lastDTS) / pes2mp4ScaleFactor);
        } else {
          ptsnorm = ptsNormalize(pts, nextAudioPts);
          dtsnorm = ptsNormalize(dts, nextAudioPts);
          var _delta = Math.round(1000 * (ptsnorm - nextAudioPts) / pesTimeScale),
              numMissingFrames = 0;
          // if fragment are contiguous, detect hole/overlapping between fragments
          // contiguous fragments are consecutive fragments from same quality level (same level, new SN = old SN + 1)
          if (contiguous && track.isAAC) {
            // log delta
            if (_delta) {
              if (_delta > 0) {
                numMissingFrames = Math.round((ptsnorm - nextAudioPts) / pesFrameDuration);
                _logger.logger.log(_delta + ' ms hole between AAC samples detected,filling it');
                if (numMissingFrames > 0) {
                  fillFrame = _aac2.default.getSilentFrame(track.channelCount);
                  if (!fillFrame) {
                    fillFrame = unit.subarray();
                  }
                  track.len += numMissingFrames * fillFrame.length;
                }
                // if we have frame overlap, overlapping for more than half a frame duraion
              } else if (_delta < -12) {
                // drop overlapping audio frames... browser will deal with it
                _logger.logger.log(-_delta + ' ms overlapping between AAC samples detected, drop frame');
                track.len -= unit.byteLength;
                continue;
              }
              // set PTS/DTS to expected PTS/DTS
              ptsnorm = dtsnorm = nextAudioPts;
            }
          }
          // remember first PTS of our audioSamples, ensure value is positive
          firstPTS = Math.max(0, ptsnorm);
          firstDTS = Math.max(0, dtsnorm);
          if (track.len > 0) {
            /* concatenate the audio data and construct the mdat in place
              (need 8 more bytes to fill length and mdat type) */

            var mdatSize = rawMPEG ? track.len : track.len + 8;
            try {
              mdat = new Uint8Array(mdatSize);
            } catch (err) {
              this.observer.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MUX_ERROR, level: this.level, id: this.id, details: _errors.ErrorDetails.REMUX_ALLOC_ERROR, fatal: false, bytes: mdatSize, reason: 'fail allocating audio mdat ' + mdatSize });
              return;
            }
            if (!rawMPEG) {
              view = new DataView(mdat.buffer);
              view.setUint32(0, mdatSize);
              mdat.set(_mp4Generator2.default.types.mdat, 4);
            }
          } else {
            // no audio samples
            return;
          }
          for (var _i3 = 0; _i3 < numMissingFrames; _i3++) {
            newStamp = ptsnorm - (numMissingFrames - _i3) * pesFrameDuration;
            fillFrame = _aac2.default.getSilentFrame(track.channelCount);
            if (!fillFrame) {
              _logger.logger.log('Unable to get silent frame for given audio codec; duplicating this frame instead.');
              fillFrame = unit.subarray();
            }
            mdat.set(fillFrame, offset);
            offset += fillFrame.byteLength;
            mp4Sample = {
              size: fillFrame.byteLength,
              cts: 0,
              duration: 1024,
              flags: {
                isLeading: 0,
                isDependedOn: 0,
                hasRedundancy: 0,
                degradPrio: 0,
                dependsOn: 1
              }
            };
            outputSamples.push(mp4Sample);
          }
        }
        mdat.set(unit, offset);
        var unitLen = unit.byteLength;
        offset += unitLen;
        //console.log('PTS/DTS/initDTS/normPTS/normDTS/relative PTS : ${audioSample.pts}/${audioSample.dts}/${initDTS}/${ptsnorm}/${dtsnorm}/${(audioSample.pts/4294967296).toFixed(3)}');
        mp4Sample = {
          size: unitLen,
          cts: 0,
          duration: 0,
          flags: {
            isLeading: 0,
            isDependedOn: 0,
            hasRedundancy: 0,
            degradPrio: 0,
            dependsOn: 1
          }
        };
        outputSamples.push(mp4Sample);
        lastDTS = dtsnorm;
      }
      var lastSampleDuration = 0;
      var nbSamples = outputSamples.length;
      //set last sample duration as being identical to previous sample
      if (nbSamples >= 2) {
        lastSampleDuration = outputSamples[nbSamples - 2].duration;
        mp4Sample.duration = lastSampleDuration;
      }
      if (nbSamples) {
        // next audio sample PTS should be equal to last sample PTS + duration
        this.nextAudioPts = ptsnorm + pes2mp4ScaleFactor * lastSampleDuration;
        //logger.log('Audio/PTS/PTSend:' + audioSample.pts.toFixed(0) + '/' + this.nextAacDts.toFixed(0));
        track.len = 0;
        track.samples = outputSamples;
        if (rawMPEG) {
          moof = new Uint8Array();
        } else {
          moof = _mp4Generator2.default.moof(track.sequenceNumber++, firstDTS / pes2mp4ScaleFactor, track);
        }
        track.samples = [];
        var audioData = {
          id: this.id,
          level: this.level,
          sn: this.sn,
          data1: moof,
          data2: mdat,
          startPTS: firstPTS / pesTimeScale,
          endPTS: this.nextAudioPts / pesTimeScale,
          startDTS: firstDTS / pesTimeScale,
          endDTS: (dtsnorm + pes2mp4ScaleFactor * lastSampleDuration) / pesTimeScale,
          type: 'audio',
          nb: nbSamples
        };
        this.observer.trigger(_events2.default.FRAG_PARSING_DATA, audioData);
        return audioData;
      }
      return null;
    }
  }, {
    key: 'remuxEmptyAudio',
    value: function remuxEmptyAudio(track, timeOffset, contiguous, videoData) {
      var pesTimeScale = this.PES_TIMESCALE,
          mp4timeScale = track.timescale ? track.timescale : track.audiosamplerate,
          pes2mp4ScaleFactor = pesTimeScale / mp4timeScale,
          nextAudioPts = this.nextAudioPts,


      // sync with video's timestamp
      startDTS = (nextAudioPts !== undefined ? nextAudioPts : videoData.startDTS * pesTimeScale) + this._initDTS,
          endDTS = videoData.endDTS * pesTimeScale + this._initDTS,

      // one sample's duration value
      sampleDuration = 1024,
          frameDuration = pes2mp4ScaleFactor * sampleDuration,


      // samples count of this segment's duration
      nbSamples = Math.ceil((endDTS - startDTS) / frameDuration),


      // silent frame
      silentFrame = _aac2.default.getSilentFrame(track.channelCount);

      _logger.logger.warn('remux empty Audio');
      // Can't remux if we can't generate a silent frame...
      if (!silentFrame) {
        _logger.logger.trace('Unable to remuxEmptyAudio since we were unable to get a silent frame for given audio codec!');
        return;
      }

      var samples = [];
      for (var i = 0; i < nbSamples; i++) {
        var stamp = startDTS + i * frameDuration;
        samples.push({ unit: silentFrame, pts: stamp, dts: stamp });
        track.len += silentFrame.length;
      }
      track.samples = samples;

      this.remuxAudio(track, timeOffset, contiguous);
    }
  }, {
    key: 'remuxID3',
    value: function remuxID3(track, timeOffset) {
      var length = track.samples.length,
          sample;
      // consume samples
      if (length) {
        for (var index = 0; index < length; index++) {
          sample = track.samples[index];
          // setting id3 pts, dts to relative time
          // using this._initPTS and this._initDTS to calculate relative time
          sample.pts = (sample.pts - this._initPTS) / this.PES_TIMESCALE;
          sample.dts = (sample.dts - this._initDTS) / this.PES_TIMESCALE;
        }
        this.observer.trigger(_events2.default.FRAG_PARSING_METADATA, {
          id: this.id,
          level: this.level,
          sn: this.sn,
          samples: track.samples
        });
      }

      track.samples = [];
      timeOffset = timeOffset;
    }
  }, {
    key: 'remuxText',
    value: function remuxText(track, timeOffset) {
      track.samples.sort(function (a, b) {
        return a.pts - b.pts;
      });

      var length = track.samples.length,
          sample;
      // consume samples
      if (length) {
        for (var index = 0; index < length; index++) {
          sample = track.samples[index];
          // setting text pts, dts to relative time
          // using this._initPTS and this._initDTS to calculate relative time
          sample.pts = (sample.pts - this._initPTS) / this.PES_TIMESCALE;
        }
        this.observer.trigger(_events2.default.FRAG_PARSING_USERDATA, {
          id: this.id,
          level: this.level,
          sn: this.sn,
          samples: track.samples
        });
      }

      track.samples = [];
      timeOffset = timeOffset;
    }
  }, {
    key: '_PTSNormalize',
    value: function _PTSNormalize(value, reference) {
      var offset;
      if (reference === undefined) {
        return value;
      }
      if (reference < value) {
        // - 2^33
        offset = -8589934592;
      } else {
        // + 2^33
        offset = 8589934592;
      }
      /* PTS is 33bit (from 0 to 2^33 -1)
        if diff between value and reference is bigger than half of the amplitude (2^32) then it means that
        PTS looping occured. fill the gap */
      while (Math.abs(value - reference) > 4294967296) {
        value += offset;
      }
      return value;
    }
  }, {
    key: 'passthrough',
    get: function get() {
      return false;
    }
  }]);

  return MP4Remuxer;
}();

exports.default = MP4Remuxer;

},{"../errors":28,"../events":30,"../helper/aac":31,"../remux/mp4-generator":39,"../utils/logger":47}],41:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * passthrough remuxer
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */


var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var PassThroughRemuxer = function () {
  function PassThroughRemuxer(observer, id) {
    _classCallCheck(this, PassThroughRemuxer);

    this.observer = observer;
    this.id = id;
    this.ISGenerated = false;
  }

  _createClass(PassThroughRemuxer, [{
    key: 'destroy',
    value: function destroy() {}
  }, {
    key: 'insertDiscontinuity',
    value: function insertDiscontinuity() {}
  }, {
    key: 'switchLevel',
    value: function switchLevel() {
      this.ISGenerated = false;
    }
  }, {
    key: 'remux',
    value: function remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, rawData) {
      var observer = this.observer;
      // generate Init Segment if needed
      if (!this.ISGenerated) {
        var tracks = {},
            data = { id: this.id, tracks: tracks, unique: true },
            track = videoTrack,
            codec = track.codec;

        if (codec) {
          data.tracks.video = {
            container: track.container,
            codec: codec,
            metadata: {
              width: track.width,
              height: track.height
            }
          };
        }

        track = audioTrack;
        codec = track.codec;
        if (codec) {
          data.tracks.audio = {
            container: track.container,
            codec: codec,
            metadata: {
              channelCount: track.channelCount
            }
          };
        }
        this.ISGenerated = true;
        observer.trigger(_events2.default.FRAG_PARSING_INIT_SEGMENT, data);
      }
      observer.trigger(_events2.default.FRAG_PARSING_DATA, {
        id: this.id,
        data1: rawData,
        startPTS: timeOffset,
        startDTS: timeOffset,
        type: 'audiovideo',
        nb: 1,
        dropped: 0
      });
    }
  }, {
    key: 'passthrough',
    get: function get() {
      return true;
    }
  }]);

  return PassThroughRemuxer;
}();

exports.default = PassThroughRemuxer;

},{"../events":30}],42:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var DECIMAL_RESOLUTION_REGEX = /^(\d+)x(\d+)$/;
var ATTR_LIST_REGEX = /\s*(.+?)\s*=((?:\".*?\")|.*?)(?:,|$)/g;

// adapted from https://github.com/kanongil/node-m3u8parse/blob/master/attrlist.js

var AttrList = function () {
  function AttrList(attrs) {
    _classCallCheck(this, AttrList);

    if (typeof attrs === 'string') {
      attrs = AttrList.parseAttrList(attrs);
    }
    for (var attr in attrs) {
      if (attrs.hasOwnProperty(attr)) {
        this[attr] = attrs[attr];
      }
    }
  }

  _createClass(AttrList, [{
    key: 'decimalInteger',
    value: function decimalInteger(attrName) {
      var intValue = parseInt(this[attrName], 10);
      if (intValue > Number.MAX_SAFE_INTEGER) {
        return Infinity;
      }
      return intValue;
    }
  }, {
    key: 'hexadecimalInteger',
    value: function hexadecimalInteger(attrName) {
      if (this[attrName]) {
        var stringValue = (this[attrName] || '0x').slice(2);
        stringValue = (stringValue.length & 1 ? '0' : '') + stringValue;

        var value = new Uint8Array(stringValue.length / 2);
        for (var i = 0; i < stringValue.length / 2; i++) {
          value[i] = parseInt(stringValue.slice(i * 2, i * 2 + 2), 16);
        }
        return value;
      } else {
        return null;
      }
    }
  }, {
    key: 'hexadecimalIntegerAsNumber',
    value: function hexadecimalIntegerAsNumber(attrName) {
      var intValue = parseInt(this[attrName], 16);
      if (intValue > Number.MAX_SAFE_INTEGER) {
        return Infinity;
      }
      return intValue;
    }
  }, {
    key: 'decimalFloatingPoint',
    value: function decimalFloatingPoint(attrName) {
      return parseFloat(this[attrName]);
    }
  }, {
    key: 'enumeratedString',
    value: function enumeratedString(attrName) {
      return this[attrName];
    }
  }, {
    key: 'decimalResolution',
    value: function decimalResolution(attrName) {
      var res = DECIMAL_RESOLUTION_REGEX.exec(this[attrName]);
      if (res === null) {
        return undefined;
      }
      return {
        width: parseInt(res[1], 10),
        height: parseInt(res[2], 10)
      };
    }
  }], [{
    key: 'parseAttrList',
    value: function parseAttrList(input) {
      var match,
          attrs = {};
      ATTR_LIST_REGEX.lastIndex = 0;
      while ((match = ATTR_LIST_REGEX.exec(input)) !== null) {
        var value = match[2],
            quote = '"';

        if (value.indexOf(quote) === 0 && value.lastIndexOf(quote) === value.length - 1) {
          value = value.slice(1, -1);
        }
        attrs[match[1]] = value;
      }
      return attrs;
    }
  }]);

  return AttrList;
}();

exports.default = AttrList;

},{}],43:[function(require,module,exports){
"use strict";

var BinarySearch = {
    /**
     * Searches for an item in an array which matches a certain condition.
     * This requires the condition to only match one item in the array,
     * and for the array to be ordered.
     *
     * @param {Array} list The array to search.
     * @param {Function} comparisonFunction
     *      Called and provided a candidate item as the first argument.
     *      Should return:
     *          > -1 if the item should be located at a lower index than the provided item.
     *          > 1 if the item should be located at a higher index than the provided item.
     *          > 0 if the item is the item you're looking for.
     *
     * @return {*} The object if it is found or null otherwise.
     */
    search: function search(list, comparisonFunction) {
        var minIndex = 0;
        var maxIndex = list.length - 1;
        var currentIndex = null;
        var currentElement = null;

        while (minIndex <= maxIndex) {
            currentIndex = (minIndex + maxIndex) / 2 | 0;
            currentElement = list[currentIndex];

            var comparisonResult = comparisonFunction(currentElement);
            if (comparisonResult > 0) {
                minIndex = currentIndex + 1;
            } else if (comparisonResult < 0) {
                maxIndex = currentIndex - 1;
            } else {
                return currentElement;
            }
        }

        return null;
    }
};

module.exports = BinarySearch;

},{}],44:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 *
 * This code was ported from the dash.js project at:
 *   https://github.com/Dash-Industry-Forum/dash.js/blob/development/externals/cea608-parser.js
 *   https://github.com/Dash-Industry-Forum/dash.js/commit/8269b26a761e0853bb21d78780ed945144ecdd4d#diff-71bc295a2d6b6b7093a1d3290d53a4b2
 *
 * The original copyright appears below:
 *
 * The copyright in this software is being made available under the BSD License,
 * included below. This software may be subject to other third party and contributor
 * rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2015-2016, DASH Industry Forum.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *  1. Redistributions of source code must retain the above copyright notice, this
 *  list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *  this list of conditions and the following disclaimer in the documentation and/or
 *  other materials provided with the distribution.
 *  2. Neither the name of Dash Industry Forum nor the names of its
 *  contributors may be used to endorse or promote products derived from this software
 *  without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY
 *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 *  POSSIBILITY OF SUCH DAMAGE.
 */
/**
 *  Exceptions from regular ASCII. CodePoints are mapped to UTF-16 codes
 */

var specialCea608CharsCodes = {
    0x2a: 0xe1, // lowercase a, acute accent
    0x5c: 0xe9, // lowercase e, acute accent
    0x5e: 0xed, // lowercase i, acute accent
    0x5f: 0xf3, // lowercase o, acute accent
    0x60: 0xfa, // lowercase u, acute accent
    0x7b: 0xe7, // lowercase c with cedilla
    0x7c: 0xf7, // division symbol
    0x7d: 0xd1, // uppercase N tilde
    0x7e: 0xf1, // lowercase n tilde
    0x7f: 0x2588, // Full block
    // THIS BLOCK INCLUDES THE 16 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS
    // THAT COME FROM HI BYTE=0x11 AND LOW BETWEEN 0x30 AND 0x3F
    // THIS MEANS THAT \x50 MUST BE ADDED TO THE VALUES
    0x80: 0xae, // Registered symbol (R)
    0x81: 0xb0, // degree sign
    0x82: 0xbd, // 1/2 symbol
    0x83: 0xbf, // Inverted (open) question mark
    0x84: 0x2122, // Trademark symbol (TM)
    0x85: 0xa2, // Cents symbol
    0x86: 0xa3, // Pounds sterling
    0x87: 0x266a, // Music 8'th note
    0x88: 0xe0, // lowercase a, grave accent
    0x89: 0x20, // transparent space (regular)
    0x8a: 0xe8, // lowercase e, grave accent
    0x8b: 0xe2, // lowercase a, circumflex accent
    0x8c: 0xea, // lowercase e, circumflex accent
    0x8d: 0xee, // lowercase i, circumflex accent
    0x8e: 0xf4, // lowercase o, circumflex accent
    0x8f: 0xfb, // lowercase u, circumflex accent
    // THIS BLOCK INCLUDES THE 32 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS
    // THAT COME FROM HI BYTE=0x12 AND LOW BETWEEN 0x20 AND 0x3F
    0x90: 0xc1, // capital letter A with acute
    0x91: 0xc9, // capital letter E with acute
    0x92: 0xd3, // capital letter O with acute
    0x93: 0xda, // capital letter U with acute
    0x94: 0xdc, // capital letter U with diaresis
    0x95: 0xfc, // lowercase letter U with diaeresis
    0x96: 0x2018, // opening single quote
    0x97: 0xa1, // inverted exclamation mark
    0x98: 0x2a, // asterisk
    0x99: 0x2019, // closing single quote
    0x9a: 0x2501, // box drawings heavy horizontal
    0x9b: 0xa9, // copyright sign
    0x9c: 0x2120, // Service mark
    0x9d: 0x2022, // (round) bullet
    0x9e: 0x201c, // Left double quotation mark
    0x9f: 0x201d, // Right double quotation mark
    0xa0: 0xc0, // uppercase A, grave accent
    0xa1: 0xc2, // uppercase A, circumflex
    0xa2: 0xc7, // uppercase C with cedilla
    0xa3: 0xc8, // uppercase E, grave accent
    0xa4: 0xca, // uppercase E, circumflex
    0xa5: 0xcb, // capital letter E with diaresis
    0xa6: 0xeb, // lowercase letter e with diaresis
    0xa7: 0xce, // uppercase I, circumflex
    0xa8: 0xcf, // uppercase I, with diaresis
    0xa9: 0xef, // lowercase i, with diaresis
    0xaa: 0xd4, // uppercase O, circumflex
    0xab: 0xd9, // uppercase U, grave accent
    0xac: 0xf9, // lowercase u, grave accent
    0xad: 0xdb, // uppercase U, circumflex
    0xae: 0xab, // left-pointing double angle quotation mark
    0xaf: 0xbb, // right-pointing double angle quotation mark
    // THIS BLOCK INCLUDES THE 32 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS
    // THAT COME FROM HI BYTE=0x13 AND LOW BETWEEN 0x20 AND 0x3F
    0xb0: 0xc3, // Uppercase A, tilde
    0xb1: 0xe3, // Lowercase a, tilde
    0xb2: 0xcd, // Uppercase I, acute accent
    0xb3: 0xcc, // Uppercase I, grave accent
    0xb4: 0xec, // Lowercase i, grave accent
    0xb5: 0xd2, // Uppercase O, grave accent
    0xb6: 0xf2, // Lowercase o, grave accent
    0xb7: 0xd5, // Uppercase O, tilde
    0xb8: 0xf5, // Lowercase o, tilde
    0xb9: 0x7b, // Open curly brace
    0xba: 0x7d, // Closing curly brace
    0xbb: 0x5c, // Backslash
    0xbc: 0x5e, // Caret
    0xbd: 0x5f, // Underscore
    0xbe: 0x7c, // Pipe (vertical line)
    0xbf: 0x223c, // Tilde operator
    0xc0: 0xc4, // Uppercase A, umlaut
    0xc1: 0xe4, // Lowercase A, umlaut
    0xc2: 0xd6, // Uppercase O, umlaut
    0xc3: 0xf6, // Lowercase o, umlaut
    0xc4: 0xdf, // Esszett (sharp S)
    0xc5: 0xa5, // Yen symbol
    0xc6: 0xa4, // Generic currency sign
    0xc7: 0x2503, // Box drawings heavy vertical
    0xc8: 0xc5, // Uppercase A, ring
    0xc9: 0xe5, // Lowercase A, ring
    0xca: 0xd8, // Uppercase O, stroke
    0xcb: 0xf8, // Lowercase o, strok
    0xcc: 0x250f, // Box drawings heavy down and right
    0xcd: 0x2513, // Box drawings heavy down and left
    0xce: 0x2517, // Box drawings heavy up and right
    0xcf: 0x251b // Box drawings heavy up and left
};

/**
 * Utils
 */
var getCharForByte = function getCharForByte(byte) {
    var charCode = byte;
    if (specialCea608CharsCodes.hasOwnProperty(byte)) {
        charCode = specialCea608CharsCodes[byte];
    }
    return String.fromCharCode(charCode);
};

var NR_ROWS = 15,
    NR_COLS = 100;
// Tables to look up row from PAC data
var rowsLowCh1 = { 0x11: 1, 0x12: 3, 0x15: 5, 0x16: 7, 0x17: 9, 0x10: 11, 0x13: 12, 0x14: 14 };
var rowsHighCh1 = { 0x11: 2, 0x12: 4, 0x15: 6, 0x16: 8, 0x17: 10, 0x13: 13, 0x14: 15 };
var rowsLowCh2 = { 0x19: 1, 0x1A: 3, 0x1D: 5, 0x1E: 7, 0x1F: 9, 0x18: 11, 0x1B: 12, 0x1C: 14 };
var rowsHighCh2 = { 0x19: 2, 0x1A: 4, 0x1D: 6, 0x1E: 8, 0x1F: 10, 0x1B: 13, 0x1C: 15 };

var backgroundColors = ['white', 'green', 'blue', 'cyan', 'red', 'yellow', 'magenta', 'black', 'transparent'];

/**
 * Simple logger class to be able to write with time-stamps and filter on level.
 */
var logger = {
    verboseFilter: { 'DATA': 3, 'DEBUG': 3, 'INFO': 2, 'WARNING': 2, 'TEXT': 1, 'ERROR': 0 },
    time: null,
    verboseLevel: 0, // Only write errors
    setTime: function setTime(newTime) {
        this.time = newTime;
    },
    log: function log(severity, msg) {
        var minLevel = this.verboseFilter[severity];
        if (this.verboseLevel >= minLevel) {
            console.log(this.time.toFixed(3) + ' [' + severity + '] ' + msg);
        }
    }
};

var numArrayToHexArray = function numArrayToHexArray(numArray) {
    var hexArray = [];
    for (var j = 0; j < numArray.length; j++) {
        hexArray.push(numArray[j].toString(16));
    }
    return hexArray;
};

var PenState = function () {
    function PenState(foreground, underline, italics, background, flash) {
        _classCallCheck(this, PenState);

        this.foreground = foreground || 'white';
        this.underline = underline || false;
        this.italics = italics || false;
        this.background = background || 'black';
        this.flash = flash || false;
    }

    _createClass(PenState, [{
        key: 'reset',
        value: function reset() {
            this.foreground = 'white';
            this.underline = false;
            this.italics = false;
            this.background = 'black';
            this.flash = false;
        }
    }, {
        key: 'setStyles',
        value: function setStyles(styles) {
            var attribs = ['foreground', 'underline', 'italics', 'background', 'flash'];
            for (var i = 0; i < attribs.length; i++) {
                var style = attribs[i];
                if (styles.hasOwnProperty(style)) {
                    this[style] = styles[style];
                }
            }
        }
    }, {
        key: 'isDefault',
        value: function isDefault() {
            return this.foreground === 'white' && !this.underline && !this.italics && this.background === 'black' && !this.flash;
        }
    }, {
        key: 'equals',
        value: function equals(other) {
            return this.foreground === other.foreground && this.underline === other.underline && this.italics === other.italics && this.background === other.background && this.flash === other.flash;
        }
    }, {
        key: 'copy',
        value: function copy(newPenState) {
            this.foreground = newPenState.foreground;
            this.underline = newPenState.underline;
            this.italics = newPenState.italics;
            this.background = newPenState.background;
            this.flash = newPenState.flash;
        }
    }, {
        key: 'toString',
        value: function toString() {
            return 'color=' + this.foreground + ', underline=' + this.underline + ', italics=' + this.italics + ', background=' + this.background + ', flash=' + this.flash;
        }
    }]);

    return PenState;
}();

/**
 * Unicode character with styling and background.
 * @constructor
 */


var StyledUnicodeChar = function () {
    function StyledUnicodeChar(uchar, foreground, underline, italics, background, flash) {
        _classCallCheck(this, StyledUnicodeChar);

        this.uchar = uchar || ' '; // unicode character
        this.penState = new PenState(foreground, underline, italics, background, flash);
    }

    _createClass(StyledUnicodeChar, [{
        key: 'reset',
        value: function reset() {
            this.uchar = ' ';
            this.penState.reset();
        }
    }, {
        key: 'setChar',
        value: function setChar(uchar, newPenState) {
            this.uchar = uchar;
            this.penState.copy(newPenState);
        }
    }, {
        key: 'setPenState',
        value: function setPenState(newPenState) {
            this.penState.copy(newPenState);
        }
    }, {
        key: 'equals',
        value: function equals(other) {
            return this.uchar === other.uchar && this.penState.equals(other.penState);
        }
    }, {
        key: 'copy',
        value: function copy(newChar) {
            this.uchar = newChar.uchar;
            this.penState.copy(newChar.penState);
        }
    }, {
        key: 'isEmpty',
        value: function isEmpty() {
            return this.uchar === ' ' && this.penState.isDefault();
        }
    }]);

    return StyledUnicodeChar;
}();

/**
 * CEA-608 row consisting of NR_COLS instances of StyledUnicodeChar.
 * @constructor
 */


var Row = function () {
    function Row() {
        _classCallCheck(this, Row);

        this.chars = [];
        for (var i = 0; i < NR_COLS; i++) {
            this.chars.push(new StyledUnicodeChar());
        }
        this.pos = 0;
        this.currPenState = new PenState();
    }

    _createClass(Row, [{
        key: 'equals',
        value: function equals(other) {
            var equal = true;
            for (var i = 0; i < NR_COLS; i++) {
                if (!this.chars[i].equals(other.chars[i])) {
                    equal = false;
                    break;
                }
            }
            return equal;
        }
    }, {
        key: 'copy',
        value: function copy(other) {
            for (var i = 0; i < NR_COLS; i++) {
                this.chars[i].copy(other.chars[i]);
            }
        }
    }, {
        key: 'isEmpty',
        value: function isEmpty() {
            var empty = true;
            for (var i = 0; i < NR_COLS; i++) {
                if (!this.chars[i].isEmpty()) {
                    empty = false;
                    break;
                }
            }
            return empty;
        }

        /**
         *  Set the cursor to a valid column.
         */

    }, {
        key: 'setCursor',
        value: function setCursor(absPos) {
            if (this.pos !== absPos) {
                this.pos = absPos;
            }
            if (this.pos < 0) {
                logger.log('ERROR', 'Negative cursor position ' + this.pos);
                this.pos = 0;
            } else if (this.pos > NR_COLS) {
                logger.log('ERROR', 'Too large cursor position ' + this.pos);
                this.pos = NR_COLS;
            }
        }

        /**
         * Move the cursor relative to current position.
         */

    }, {
        key: 'moveCursor',
        value: function moveCursor(relPos) {
            var newPos = this.pos + relPos;
            if (relPos > 1) {
                for (var i = this.pos + 1; i < newPos + 1; i++) {
                    this.chars[i].setPenState(this.currPenState);
                }
            }
            this.setCursor(newPos);
        }

        /**
         * Backspace, move one step back and clear character.
         */

    }, {
        key: 'backSpace',
        value: function backSpace() {
            this.moveCursor(-1);
            this.chars[this.pos].setChar(' ', this.currPenState);
        }
    }, {
        key: 'insertChar',
        value: function insertChar(byte) {
            if (byte >= 0x90) {
                //Extended char
                this.backSpace();
            }
            var char = getCharForByte(byte);
            if (this.pos >= NR_COLS) {
                logger.log('WARNING', 'Cannot insert ' + byte.toString(16) + ' (' + char + ') at position ' + this.pos + '. Skipping it!');
                return;
            }
            this.chars[this.pos].setChar(char, this.currPenState);
            this.moveCursor(1);
        }
    }, {
        key: 'clearFromPos',
        value: function clearFromPos(startPos) {
            var i;
            for (i = startPos; i < NR_COLS; i++) {
                this.chars[i].reset();
            }
        }
    }, {
        key: 'clear',
        value: function clear() {
            this.clearFromPos(0);
            this.pos = 0;
            this.currPenState.reset();
        }
    }, {
        key: 'clearToEndOfRow',
        value: function clearToEndOfRow() {
            this.clearFromPos(this.pos);
        }
    }, {
        key: 'getTextString',
        value: function getTextString() {
            var chars = [];
            var empty = true;
            for (var i = 0; i < NR_COLS; i++) {
                var char = this.chars[i].uchar;
                if (char !== ' ') {
                    empty = false;
                }
                chars.push(char);
            }
            if (empty) {
                return '';
            } else {
                return chars.join('');
            }
        }
    }, {
        key: 'setPenStyles',
        value: function setPenStyles(styles) {
            this.currPenState.setStyles(styles);
            var currChar = this.chars[this.pos];
            currChar.setPenState(this.currPenState);
        }
    }]);

    return Row;
}();

/**
 * Keep a CEA-608 screen of 32x15 styled characters
 * @constructor
*/


var CaptionScreen = function () {
    function CaptionScreen() {
        _classCallCheck(this, CaptionScreen);

        this.rows = [];
        for (var i = 0; i < NR_ROWS; i++) {
            this.rows.push(new Row()); // Note that we use zero-based numbering (0-14)
        }
        this.currRow = NR_ROWS - 1;
        this.nrRollUpRows = null;
        this.reset();
    }

    _createClass(CaptionScreen, [{
        key: 'reset',
        value: function reset() {
            for (var i = 0; i < NR_ROWS; i++) {
                this.rows[i].clear();
            }
            this.currRow = NR_ROWS - 1;
        }
    }, {
        key: 'equals',
        value: function equals(other) {
            var equal = true;
            for (var i = 0; i < NR_ROWS; i++) {
                if (!this.rows[i].equals(other.rows[i])) {
                    equal = false;
                    break;
                }
            }
            return equal;
        }
    }, {
        key: 'copy',
        value: function copy(other) {
            for (var i = 0; i < NR_ROWS; i++) {
                this.rows[i].copy(other.rows[i]);
            }
        }
    }, {
        key: 'isEmpty',
        value: function isEmpty() {
            var empty = true;
            for (var i = 0; i < NR_ROWS; i++) {
                if (!this.rows[i].isEmpty()) {
                    empty = false;
                    break;
                }
            }
            return empty;
        }
    }, {
        key: 'backSpace',
        value: function backSpace() {
            var row = this.rows[this.currRow];
            row.backSpace();
        }
    }, {
        key: 'clearToEndOfRow',
        value: function clearToEndOfRow() {
            var row = this.rows[this.currRow];
            row.clearToEndOfRow();
        }

        /**
         * Insert a character (without styling) in the current row.
         */

    }, {
        key: 'insertChar',
        value: function insertChar(char) {
            var row = this.rows[this.currRow];
            row.insertChar(char);
        }
    }, {
        key: 'setPen',
        value: function setPen(styles) {
            var row = this.rows[this.currRow];
            row.setPenStyles(styles);
        }
    }, {
        key: 'moveCursor',
        value: function moveCursor(relPos) {
            var row = this.rows[this.currRow];
            row.moveCursor(relPos);
        }
    }, {
        key: 'setCursor',
        value: function setCursor(absPos) {
            logger.log('INFO', 'setCursor: ' + absPos);
            var row = this.rows[this.currRow];
            row.setCursor(absPos);
        }
    }, {
        key: 'setPAC',
        value: function setPAC(pacData, lastOutputScreen) {
            logger.log('INFO', 'pacData = ' + JSON.stringify(pacData));
            var newRow = pacData.row - 1;
            if (this.nrRollUpRows && newRow < this.nrRollUpRows - 1) {
                newRow = this.nrRollUpRows - 1;
            }

            //Make sure this only affects Roll-up Captions by checking this.nrRollUpRows
            if (this.nrRollUpRows && this.currRow !== newRow) {
                //clear all rows first
                for (var i = 0; i < NR_ROWS; i++) {
                    this.rows[i].clear();
                }

                //Copy this.nrRollUpRows rows from lastOutputScreen and place it in the newRow location
                //topRowIndex - the start of rows to copy (inclusive index)
                var topRowIndex = this.currRow + 1 - this.nrRollUpRows;
                //We only copy if the last position was already shown.
                //We use the cueStartTime value to check this.
                var prevLineTime = lastOutputScreen.rows[topRowIndex].cueStartTime;
                if (prevLineTime && prevLineTime < logger.time) {
                    for (var _i = 0; _i < this.nrRollUpRows; _i++) {
                        this.rows[newRow - this.nrRollUpRows + _i + 1].copy(lastOutputScreen.rows[topRowIndex + _i]);
                    }
                }
            }

            this.currRow = newRow;
            var row = this.rows[this.currRow];
            if (pacData.indent !== null) {
                var indent = pacData.indent;
                var prevPos = Math.max(indent - 1, 0);
                row.setCursor(pacData.indent);
                pacData.color = row.chars[prevPos].penState.foreground;
            }
            var styles = { foreground: pacData.color, underline: pacData.underline, italics: pacData.italics, background: 'black', flash: false };
            this.setPen(styles);
        }

        /**
         * Set background/extra foreground, but first do back_space, and then insert space (backwards compatibility).
         */

    }, {
        key: 'setBkgData',
        value: function setBkgData(bkgData) {

            logger.log('INFO', 'bkgData = ' + JSON.stringify(bkgData));
            this.backSpace();
            this.setPen(bkgData);
            this.insertChar(0x20); //Space
        }
    }, {
        key: 'setRollUpRows',
        value: function setRollUpRows(nrRows) {
            this.nrRollUpRows = nrRows;
        }
    }, {
        key: 'rollUp',
        value: function rollUp() {
            if (this.nrRollUpRows === null) {
                logger.log('DEBUG', 'roll_up but nrRollUpRows not set yet');
                return; //Not properly setup
            }
            logger.log('TEXT', this.getDisplayText());
            var topRowIndex = this.currRow + 1 - this.nrRollUpRows;
            var topRow = this.rows.splice(topRowIndex, 1)[0];
            topRow.clear();
            this.rows.splice(this.currRow, 0, topRow);
            logger.log('INFO', 'Rolling up');
            //logger.log('TEXT', this.get_display_text())
        }

        /**
         * Get all non-empty rows with as unicode text.
         */

    }, {
        key: 'getDisplayText',
        value: function getDisplayText(asOneRow) {
            asOneRow = asOneRow || false;
            var displayText = [];
            var text = '';
            var rowNr = -1;
            for (var i = 0; i < NR_ROWS; i++) {
                var rowText = this.rows[i].getTextString();
                if (rowText) {
                    rowNr = i + 1;
                    if (asOneRow) {
                        displayText.push('Row ' + rowNr + ': \'' + rowText + '\'');
                    } else {
                        displayText.push(rowText.trim());
                    }
                }
            }
            if (displayText.length > 0) {
                if (asOneRow) {
                    text = '[' + displayText.join(' | ') + ']';
                } else {
                    text = displayText.join('\n');
                }
            }
            return text;
        }
    }, {
        key: 'getTextAndFormat',
        value: function getTextAndFormat() {
            return this.rows;
        }
    }]);

    return CaptionScreen;
}();

//var modes = ['MODE_ROLL-UP', 'MODE_POP-ON', 'MODE_PAINT-ON', 'MODE_TEXT'];

var Cea608Channel = function () {
    function Cea608Channel(channelNumber, outputFilter) {
        _classCallCheck(this, Cea608Channel);

        this.chNr = channelNumber;
        this.outputFilter = outputFilter;
        this.mode = null;
        this.verbose = 0;
        this.displayedMemory = new CaptionScreen();
        this.nonDisplayedMemory = new CaptionScreen();
        this.lastOutputScreen = new CaptionScreen();
        this.currRollUpRow = this.displayedMemory.rows[NR_ROWS - 1];
        this.writeScreen = this.displayedMemory;
        this.mode = null;
        this.cueStartTime = null; // Keeps track of where a cue started.
    }

    _createClass(Cea608Channel, [{
        key: 'reset',
        value: function reset() {
            this.mode = null;
            this.displayedMemory.reset();
            this.nonDisplayedMemory.reset();
            this.lastOutputScreen.reset();
            this.currRollUpRow = this.displayedMemory.rows[NR_ROWS - 1];
            this.writeScreen = this.displayedMemory;
            this.mode = null;
            this.cueStartTime = null;
            this.lastCueEndTime = null;
        }
    }, {
        key: 'getHandler',
        value: function getHandler() {
            return this.outputFilter;
        }
    }, {
        key: 'setHandler',
        value: function setHandler(newHandler) {
            this.outputFilter = newHandler;
        }
    }, {
        key: 'setPAC',
        value: function setPAC(pacData) {
            this.writeScreen.setPAC(pacData, this.lastOutputScreen);
        }
    }, {
        key: 'setBkgData',
        value: function setBkgData(bkgData) {
            this.writeScreen.setBkgData(bkgData);
        }
    }, {
        key: 'setMode',
        value: function setMode(newMode) {
            if (newMode === this.mode) {
                return;
            }
            this.mode = newMode;
            logger.log('INFO', 'MODE=' + newMode);
            if (this.mode === 'MODE_POP-ON') {
                this.writeScreen = this.nonDisplayedMemory;
            } else {
                this.writeScreen = this.displayedMemory;
                this.writeScreen.reset();
                this.lastOutputScreen.reset();
            }
            if (this.mode !== 'MODE_ROLL-UP') {
                this.displayedMemory.nrRollUpRows = null;
                this.nonDisplayedMemory.nrRollUpRows = null;
            }
            this.mode = newMode;
        }
    }, {
        key: 'insertChars',
        value: function insertChars(chars) {
            for (var i = 0; i < chars.length; i++) {
                this.writeScreen.insertChar(chars[i]);
            }
            var screen = this.writeScreen === this.displayedMemory ? 'DISP' : 'NON_DISP';
            logger.log('INFO', screen + ': ' + this.writeScreen.getDisplayText(true));
            if (this.mode === 'MODE_PAINT-ON' || this.mode === 'MODE_ROLL-UP') {
                logger.log('TEXT', 'DISPLAYED: ' + this.displayedMemory.getDisplayText(true));
                this.outputDataUpdate();
            }
        }
    }, {
        key: 'ccRCL',
        value: function ccRCL() {
            // Resume Caption Loading (switch mode to Pop On)
            logger.log('INFO', 'RCL - Resume Caption Loading');
            this.setMode('MODE_POP-ON');
        }
    }, {
        key: 'ccBS',
        value: function ccBS() {
            // BackSpace
            logger.log('INFO', 'BS - BackSpace');
            if (this.mode === 'MODE_TEXT') {
                return;
            }
            this.writeScreen.backSpace();
            if (this.writeScreen === this.displayedMemory) {
                this.outputDataUpdate();
            }
        }
    }, {
        key: 'ccAOF',
        value: function ccAOF() {
            // Reserved (formerly Alarm Off)
            return;
        }
    }, {
        key: 'ccAON',
        value: function ccAON() {
            // Reserved (formerly Alarm On)
            return;
        }
    }, {
        key: 'ccDER',
        value: function ccDER() {
            // Delete to End of Row
            logger.log('INFO', 'DER- Delete to End of Row');
            this.writeScreen.clearToEndOfRow();
            this.outputDataUpdate();
        }
    }, {
        key: 'ccRU',
        value: function ccRU(nrRows) {
            //Roll-Up Captions-2,3,or 4 Rows
            logger.log('INFO', 'RU(' + nrRows + ') - Roll Up');
            this.writeScreen = this.displayedMemory;
            this.setMode('MODE_ROLL-UP');
            this.writeScreen.setRollUpRows(nrRows);
        }
    }, {
        key: 'ccFON',
        value: function ccFON() {
            //Flash On
            logger.log('INFO', 'FON - Flash On');
            this.writeScreen.setPen({ flash: true });
        }
    }, {
        key: 'ccRDC',
        value: function ccRDC() {
            // Resume Direct Captioning (switch mode to PaintOn)
            logger.log('INFO', 'RDC - Resume Direct Captioning');
            this.setMode('MODE_PAINT-ON');
        }
    }, {
        key: 'ccTR',
        value: function ccTR() {
            // Text Restart in text mode (not supported, however)
            logger.log('INFO', 'TR');
            this.setMode('MODE_TEXT');
        }
    }, {
        key: 'ccRTD',
        value: function ccRTD() {
            // Resume Text Display in Text mode (not supported, however)
            logger.log('INFO', 'RTD');
            this.setMode('MODE_TEXT');
        }
    }, {
        key: 'ccEDM',
        value: function ccEDM() {
            // Erase Displayed Memory
            logger.log('INFO', 'EDM - Erase Displayed Memory');
            this.displayedMemory.reset();
            this.outputDataUpdate();
        }
    }, {
        key: 'ccCR',
        value: function ccCR() {
            // Carriage Return
            logger.log('CR - Carriage Return');
            this.writeScreen.rollUp();
            this.outputDataUpdate();
        }
    }, {
        key: 'ccENM',
        value: function ccENM() {
            //Erase Non-Displayed Memory
            logger.log('INFO', 'ENM - Erase Non-displayed Memory');
            this.nonDisplayedMemory.reset();
        }
    }, {
        key: 'ccEOC',
        value: function ccEOC() {
            //End of Caption (Flip Memories)
            logger.log('INFO', 'EOC - End Of Caption');
            if (this.mode === 'MODE_POP-ON') {
                var tmp = this.displayedMemory;
                this.displayedMemory = this.nonDisplayedMemory;
                this.nonDisplayedMemory = tmp;
                this.writeScreen = this.nonDisplayedMemory;
                logger.log('TEXT', 'DISP: ' + this.displayedMemory.getDisplayText());
            }
            this.outputDataUpdate();
        }
    }, {
        key: 'ccTO',
        value: function ccTO(nrCols) {
            // Tab Offset 1,2, or 3 columns
            logger.log('INFO', 'TO(' + nrCols + ') - Tab Offset');
            this.writeScreen.moveCursor(nrCols);
        }
    }, {
        key: 'ccMIDROW',
        value: function ccMIDROW(secondByte) {
            // Parse MIDROW command
            var styles = { flash: false };
            styles.underline = secondByte % 2 === 1;
            styles.italics = secondByte >= 0x2e;
            if (!styles.italics) {
                var colorIndex = Math.floor(secondByte / 2) - 0x10;
                var colors = ['white', 'green', 'blue', 'cyan', 'red', 'yellow', 'magenta'];
                styles.foreground = colors[colorIndex];
            } else {
                styles.foreground = 'white';
            }
            logger.log('INFO', 'MIDROW: ' + JSON.stringify(styles));
            this.writeScreen.setPen(styles);
        }
    }, {
        key: 'outputDataUpdate',
        value: function outputDataUpdate() {
            var t = logger.time;
            if (t === null) {
                return;
            }
            if (this.outputFilter) {
                if (this.outputFilter.updateData) {
                    this.outputFilter.updateData(t, this.displayedMemory);
                }
                if (this.cueStartTime === null && !this.displayedMemory.isEmpty()) {
                    // Start of a new cue
                    this.cueStartTime = t;
                } else {
                    if (!this.displayedMemory.equals(this.lastOutputScreen)) {
                        if (this.outputFilter.newCue) {
                            this.outputFilter.newCue(this.cueStartTime, t, this.lastOutputScreen);
                        }
                        this.cueStartTime = this.displayedMemory.isEmpty() ? null : t;
                    }
                }
                this.lastOutputScreen.copy(this.displayedMemory);
            }
        }
    }, {
        key: 'cueSplitAtTime',
        value: function cueSplitAtTime(t) {
            if (this.outputFilter) {
                if (!this.displayedMemory.isEmpty()) {
                    if (this.outputFilter.newCue) {
                        this.outputFilter.newCue(this.cueStartTime, t, this.displayedMemory);
                    }
                    this.cueStartTime = t;
                }
            }
        }
    }]);

    return Cea608Channel;
}();

var Cea608Parser = function () {
    function Cea608Parser(field, out1, out2) {
        _classCallCheck(this, Cea608Parser);

        this.field = field || 1;
        this.outputs = [out1, out2];
        this.channels = [new Cea608Channel(1, out1), new Cea608Channel(2, out2)];
        this.currChNr = -1; // Will be 1 or 2
        this.lastCmdA = null; // First byte of last command
        this.lastCmdB = null; // Second byte of last command
        this.bufferedData = [];
        this.startTime = null;
        this.lastTime = null;
        this.dataCounters = { 'padding': 0, 'char': 0, 'cmd': 0, 'other': 0 };
    }

    _createClass(Cea608Parser, [{
        key: 'getHandler',
        value: function getHandler(index) {
            return this.channels[index].getHandler();
        }
    }, {
        key: 'setHandler',
        value: function setHandler(index, newHandler) {
            this.channels[index].setHandler(newHandler);
        }

        /**
         * Add data for time t in forms of list of bytes (unsigned ints). The bytes are treated as pairs.
         */

    }, {
        key: 'addData',
        value: function addData(t, byteList) {
            var cmdFound,
                a,
                b,
                charsFound = false;

            this.lastTime = t;
            logger.setTime(t);

            for (var i = 0; i < byteList.length; i += 2) {
                a = byteList[i] & 0x7f;
                b = byteList[i + 1] & 0x7f;
                if (a === 0 && b === 0) {
                    this.dataCounters.padding += 2;
                    continue;
                } else {
                    logger.log('DATA', '[' + numArrayToHexArray([byteList[i], byteList[i + 1]]) + '] -> (' + numArrayToHexArray([a, b]) + ')');
                }
                cmdFound = this.parseCmd(a, b);
                if (!cmdFound) {
                    cmdFound = this.parseMidrow(a, b);
                }
                if (!cmdFound) {
                    cmdFound = this.parsePAC(a, b);
                }
                if (!cmdFound) {
                    cmdFound = this.parseBackgroundAttributes(a, b);
                }
                if (!cmdFound) {
                    charsFound = this.parseChars(a, b);
                    if (charsFound) {
                        if (this.currChNr && this.currChNr >= 0) {
                            var channel = this.channels[this.currChNr - 1];
                            channel.insertChars(charsFound);
                        } else {
                            logger.log('WARNING', 'No channel found yet. TEXT-MODE?');
                        }
                    }
                }
                if (cmdFound) {
                    this.dataCounters.cmd += 2;
                } else if (charsFound) {
                    this.dataCounters.char += 2;
                } else {
                    this.dataCounters.other += 2;
                    logger.log('WARNING', 'Couldn\'t parse cleaned data ' + numArrayToHexArray([a, b]) + ' orig: ' + numArrayToHexArray([byteList[i], byteList[i + 1]]));
                }
            }
        }

        /**
         * Parse Command.
         * @returns {Boolean} Tells if a command was found
         */

    }, {
        key: 'parseCmd',
        value: function parseCmd(a, b) {
            var chNr = null;

            var cond1 = (a === 0x14 || a === 0x1C) && 0x20 <= b && b <= 0x2F;
            var cond2 = (a === 0x17 || a === 0x1F) && 0x21 <= b && b <= 0x23;
            if (!(cond1 || cond2)) {
                return false;
            }

            if (a === this.lastCmdA && b === this.lastCmdB) {
                this.lastCmdA = null;
                this.lastCmdB = null; // Repeated commands are dropped (once)
                logger.log('DEBUG', 'Repeated command (' + numArrayToHexArray([a, b]) + ') is dropped');
                return true;
            }

            if (a === 0x14 || a === 0x17) {
                chNr = 1;
            } else {
                chNr = 2; // (a === 0x1C || a=== 0x1f)
            }

            var channel = this.channels[chNr - 1];

            if (a === 0x14 || a === 0x1C) {
                if (b === 0x20) {
                    channel.ccRCL();
                } else if (b === 0x21) {
                    channel.ccBS();
                } else if (b === 0x22) {
                    channel.ccAOF();
                } else if (b === 0x23) {
                    channel.ccAON();
                } else if (b === 0x24) {
                    channel.ccDER();
                } else if (b === 0x25) {
                    channel.ccRU(2);
                } else if (b === 0x26) {
                    channel.ccRU(3);
                } else if (b === 0x27) {
                    channel.ccRU(4);
                } else if (b === 0x28) {
                    channel.ccFON();
                } else if (b === 0x29) {
                    channel.ccRDC();
                } else if (b === 0x2A) {
                    channel.ccTR();
                } else if (b === 0x2B) {
                    channel.ccRTD();
                } else if (b === 0x2C) {
                    channel.ccEDM();
                } else if (b === 0x2D) {
                    channel.ccCR();
                } else if (b === 0x2E) {
                    channel.ccENM();
                } else if (b === 0x2F) {
                    channel.ccEOC();
                }
            } else {
                //a == 0x17 || a == 0x1F
                channel.ccTO(b - 0x20);
            }
            this.lastCmdA = a;
            this.lastCmdB = b;
            this.currChNr = chNr;
            return true;
        }

        /**
         * Parse midrow styling command
         * @returns {Boolean}
         */

    }, {
        key: 'parseMidrow',
        value: function parseMidrow(a, b) {
            var chNr = null;

            if ((a === 0x11 || a === 0x19) && 0x20 <= b && b <= 0x2f) {
                if (a === 0x11) {
                    chNr = 1;
                } else {
                    chNr = 2;
                }
                if (chNr !== this.currChNr) {
                    logger.log('ERROR', 'Mismatch channel in midrow parsing');
                    return false;
                }
                var channel = this.channels[chNr - 1];
                channel.ccMIDROW(b);
                logger.log('DEBUG', 'MIDROW (' + numArrayToHexArray([a, b]) + ')');
                return true;
            }
            return false;
        }
        /**
         * Parse Preable Access Codes (Table 53).
         * @returns {Boolean} Tells if PAC found
         */

    }, {
        key: 'parsePAC',
        value: function parsePAC(a, b) {

            var chNr = null;
            var row = null;

            var case1 = (0x11 <= a && a <= 0x17 || 0x19 <= a && a <= 0x1F) && 0x40 <= b && b <= 0x7F;
            var case2 = (a === 0x10 || a === 0x18) && 0x40 <= b && b <= 0x5F;
            if (!(case1 || case2)) {
                return false;
            }

            if (a === this.lastCmdA && b === this.lastCmdB) {
                this.lastCmdA = null;
                this.lastCmdB = null;
                return true; // Repeated commands are dropped (once)
            }

            chNr = a <= 0x17 ? 1 : 2;

            if (0x40 <= b && b <= 0x5F) {
                row = chNr === 1 ? rowsLowCh1[a] : rowsLowCh2[a];
            } else {
                // 0x60 <= b <= 0x7F
                row = chNr === 1 ? rowsHighCh1[a] : rowsHighCh2[a];
            }
            var pacData = this.interpretPAC(row, b);
            var channel = this.channels[chNr - 1];
            channel.setPAC(pacData);
            this.lastCmdA = a;
            this.lastCmdB = b;
            this.currChNr = chNr;
            return true;
        }

        /**
         * Interpret the second byte of the pac, and return the information.
         * @returns {Object} pacData with style parameters.
         */

    }, {
        key: 'interpretPAC',
        value: function interpretPAC(row, byte) {
            var pacIndex = byte;
            var pacData = { color: null, italics: false, indent: null, underline: false, row: row };

            if (byte > 0x5F) {
                pacIndex = byte - 0x60;
            } else {
                pacIndex = byte - 0x40;
            }
            pacData.underline = (pacIndex & 1) === 1;
            if (pacIndex <= 0xd) {
                pacData.color = ['white', 'green', 'blue', 'cyan', 'red', 'yellow', 'magenta', 'white'][Math.floor(pacIndex / 2)];
            } else if (pacIndex <= 0xf) {
                pacData.italics = true;
                pacData.color = 'white';
            } else {
                pacData.indent = Math.floor((pacIndex - 0x10) / 2) * 4;
            }
            return pacData; // Note that row has zero offset. The spec uses 1.
        }

        /**
         * Parse characters.
         * @returns An array with 1 to 2 codes corresponding to chars, if found. null otherwise.
         */

    }, {
        key: 'parseChars',
        value: function parseChars(a, b) {

            var channelNr = null,
                charCodes = null,
                charCode1 = null;

            if (a >= 0x19) {
                channelNr = 2;
                charCode1 = a - 8;
            } else {
                channelNr = 1;
                charCode1 = a;
            }
            if (0x11 <= charCode1 && charCode1 <= 0x13) {
                // Special character
                var oneCode = b;
                if (charCode1 === 0x11) {
                    oneCode = b + 0x50;
                } else if (charCode1 === 0x12) {
                    oneCode = b + 0x70;
                } else {
                    oneCode = b + 0x90;
                }
                logger.log('INFO', 'Special char \'' + getCharForByte(oneCode) + '\' in channel ' + channelNr);
                charCodes = [oneCode];
            } else if (0x20 <= a && a <= 0x7f) {
                charCodes = b === 0 ? [a] : [a, b];
            }
            if (charCodes) {
                var hexCodes = numArrayToHexArray(charCodes);
                logger.log('DEBUG', 'Char codes =  ' + hexCodes.join(','));
                this.lastCmdA = null;
                this.lastCmdB = null;
            }
            return charCodes;
        }

        /**
        * Parse extended background attributes as well as new foreground color black.
        * @returns{Boolean} Tells if background attributes are found
        */

    }, {
        key: 'parseBackgroundAttributes',
        value: function parseBackgroundAttributes(a, b) {
            var bkgData, index, chNr, channel;

            var case1 = (a === 0x10 || a === 0x18) && 0x20 <= b && b <= 0x2f;
            var case2 = (a === 0x17 || a === 0x1f) && 0x2d <= b && b <= 0x2f;
            if (!(case1 || case2)) {
                return false;
            }
            bkgData = {};
            if (a === 0x10 || a === 0x18) {
                index = Math.floor((b - 0x20) / 2);
                bkgData.background = backgroundColors[index];
                if (b % 2 === 1) {
                    bkgData.background = bkgData.background + '_semi';
                }
            } else if (b === 0x2d) {
                bkgData.background = 'transparent';
            } else {
                bkgData.foreground = 'black';
                if (b === 0x2f) {
                    bkgData.underline = true;
                }
            }
            chNr = a < 0x18 ? 1 : 2;
            channel = this.channels[chNr - 1];
            channel.setBkgData(bkgData);
            this.lastCmdA = null;
            this.lastCmdB = null;
            return true;
        }

        /**
         * Reset state of parser and its channels.
         */

    }, {
        key: 'reset',
        value: function reset() {
            for (var i = 0; i < this.channels.length; i++) {
                if (this.channels[i]) {
                    this.channels[i].reset();
                }
            }
            this.lastCmdA = null;
            this.lastCmdB = null;
        }

        /**
         * Trigger the generation of a cue, and the start of a new one if displayScreens are not empty.
         */

    }, {
        key: 'cueSplitAtTime',
        value: function cueSplitAtTime(t) {
            for (var i = 0; i < this.channels.length; i++) {
                if (this.channels[i]) {
                    this.channels[i].cueSplitAtTime(t);
                }
            }
        }
    }]);

    return Cea608Parser;
}();

exports.default = Cea608Parser;

},{}],45:[function(require,module,exports){
'use strict';

var _vttparser = require('./vttparser');

var Cues = {

  newCue: function newCue(track, startTime, endTime, captionScreen) {
    var row;
    var cue;
    var indenting;
    var indent;
    var text;
    var VTTCue = window.VTTCue || window.TextTrackCue;

    for (var r = 0; r < captionScreen.rows.length; r++) {
      row = captionScreen.rows[r];
      indenting = true;
      indent = 0;
      text = '';

      if (!row.isEmpty()) {
        for (var c = 0; c < row.chars.length; c++) {
          if (row.chars[c].uchar.match(/\s/) && indenting) {
            indent++;
          } else {
            text += row.chars[c].uchar;
            indenting = false;
          }
        }
        //To be used for cleaning-up orphaned roll-up captions
        row.cueStartTime = startTime;
        cue = new VTTCue(startTime, endTime, (0, _vttparser.fixLineBreaks)(text.trim()));

        if (indent >= 16) {
          indent--;
        } else {
          indent++;
        }

        // VTTCue.line get's flakey when using controls, so let's now include line 13&14
        // also, drop line 1 since it's to close to the top
        if (navigator.userAgent.match(/Firefox\//)) {
          cue.line = r + 1;
        } else {
          cue.line = r > 7 ? r - 2 : r + 1;
        }
        cue.align = 'left';
        // Clamp the position between 0 and 100 - if out of these bounds, Firefox throws an exception and captions break
        cue.position = Math.max(0, Math.min(100, 100 * (indent / 32) + (navigator.userAgent.match(/Firefox\//) ? 50 : 0)));
        track.addCue(cue);
      }
    }
  }

};

module.exports = Cues;

},{"./vttparser":50}],46:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/*
 * compute an Exponential Weighted moving average
 * - https://en.wikipedia.org/wiki/Moving_average#Exponential_moving_average
 *  - heavily inspired from shaka-player
 */

var EWMA = function () {

  //  About half of the estimated value will be from the last |halfLife| samples by weight.
  function EWMA(halfLife) {
    _classCallCheck(this, EWMA);

    // Larger values of alpha expire historical data more slowly.
    this.alpha_ = halfLife ? Math.exp(Math.log(0.5) / halfLife) : 0;
    this.estimate_ = 0;
    this.totalWeight_ = 0;
  }

  _createClass(EWMA, [{
    key: "sample",
    value: function sample(weight, value) {
      var adjAlpha = Math.pow(this.alpha_, weight);
      this.estimate_ = value * (1 - adjAlpha) + adjAlpha * this.estimate_;
      this.totalWeight_ += weight;
    }
  }, {
    key: "getTotalWeight",
    value: function getTotalWeight() {
      return this.totalWeight_;
    }
  }, {
    key: "getEstimate",
    value: function getEstimate() {
      if (this.alpha_) {
        var zeroFactor = 1 - Math.pow(this.alpha_, this.totalWeight_);
        return this.estimate_ / zeroFactor;
      } else {
        return this.estimate_;
      }
    }
  }]);

  return EWMA;
}();

exports.default = EWMA;

},{}],47:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function noop() {}

var fakeLogger = {
  trace: noop,
  debug: noop,
  log: noop,
  warn: noop,
  info: noop,
  error: noop
};

var exportedLogger = fakeLogger;

/*globals self: false */

//let lastCallTime;
// function formatMsgWithTimeInfo(type, msg) {
//   const now = Date.now();
//   const diff = lastCallTime ? '+' + (now - lastCallTime) : '0';
//   lastCallTime = now;
//   msg = (new Date(now)).toISOString() + ' | [' +  type + '] > ' + msg + ' ( ' + diff + ' ms )';
//   return msg;
// }

function formatMsg(type, msg) {
  msg = '[' + type + '] > ' + msg;
  return msg;
}

function consolePrintFn(type) {
  var func = self.console[type];
  if (func) {
    return function () {
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      if (args[0]) {
        args[0] = formatMsg(type, args[0]);
      }
      func.apply(self.console, args);
    };
  }
  return noop;
}

function exportLoggerFunctions(debugConfig) {
  for (var _len2 = arguments.length, functions = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    functions[_key2 - 1] = arguments[_key2];
  }

  functions.forEach(function (type) {
    exportedLogger[type] = debugConfig[type] ? debugConfig[type].bind(debugConfig) : consolePrintFn(type);
  });
}

var enableLogs = exports.enableLogs = function enableLogs(debugConfig) {
  if (debugConfig === true || (typeof debugConfig === 'undefined' ? 'undefined' : _typeof(debugConfig)) === 'object') {
    exportLoggerFunctions(debugConfig,
    // Remove out from list here to hard-disable a log-level
    //'trace',
    'debug', 'log', 'info', 'warn', 'error');
    // Some browsers don't allow to use bind on console object anyway
    // fallback to default if needed
    try {
      exportedLogger.log();
    } catch (e) {
      exportedLogger = fakeLogger;
    }
  } else {
    exportedLogger = fakeLogger;
  }
};

var logger = exports.logger = exportedLogger;

},{}],48:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 *  TimeRanges to string helper
 */

var TimeRanges = function () {
  function TimeRanges() {
    _classCallCheck(this, TimeRanges);
  }

  _createClass(TimeRanges, null, [{
    key: 'toString',
    value: function toString(r) {
      var log = '',
          len = r.length;
      for (var i = 0; i < len; i++) {
        log += '[' + r.start(i).toFixed(3) + ',' + r.end(i).toFixed(3) + ']';
      }
      return log;
    }
  }]);

  return TimeRanges;
}();

exports.default = TimeRanges;

},{}],49:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

/**
 * Copyright 2013 vtt.js Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

exports.default = function () {
  if (typeof window !== 'undefined' && window.VTTCue) {
    return window.VTTCue;
  }

  var autoKeyword = 'auto';
  var directionSetting = {
    '': true,
    lr: true,
    rl: true
  };
  var alignSetting = {
    start: true,
    middle: true,
    end: true,
    left: true,
    right: true
  };

  function findDirectionSetting(value) {
    if (typeof value !== 'string') {
      return false;
    }
    var dir = directionSetting[value.toLowerCase()];
    return dir ? value.toLowerCase() : false;
  }

  function findAlignSetting(value) {
    if (typeof value !== 'string') {
      return false;
    }
    var align = alignSetting[value.toLowerCase()];
    return align ? value.toLowerCase() : false;
  }

  function extend(obj) {
    var i = 1;
    for (; i < arguments.length; i++) {
      var cobj = arguments[i];
      for (var p in cobj) {
        obj[p] = cobj[p];
      }
    }

    return obj;
  }

  function VTTCue(startTime, endTime, text) {
    var cue = this;
    var isIE8 = function () {
      if (typeof navigator === 'undefined') {
        return;
      }
      return (/MSIE\s8\.0/.test(navigator.userAgent)
      );
    }();
    var baseObj = {};

    if (isIE8) {
      cue = document.createElement('custom');
    } else {
      baseObj.enumerable = true;
    }

    /**
     * Shim implementation specific properties. These properties are not in
     * the spec.
     */

    // Lets us know when the VTTCue's data has changed in such a way that we need
    // to recompute its display state. This lets us compute its display state
    // lazily.
    cue.hasBeenReset = false;

    /**
     * VTTCue and TextTrackCue properties
     * http://dev.w3.org/html5/webvtt/#vttcue-interface
     */

    var _id = '';
    var _pauseOnExit = false;
    var _startTime = startTime;
    var _endTime = endTime;
    var _text = text;
    var _region = null;
    var _vertical = '';
    var _snapToLines = true;
    var _line = 'auto';
    var _lineAlign = 'start';
    var _position = 50;
    var _positionAlign = 'middle';
    var _size = 50;
    var _align = 'middle';

    Object.defineProperty(cue, 'id', extend({}, baseObj, {
      get: function get() {
        return _id;
      },
      set: function set(value) {
        _id = '' + value;
      }
    }));

    Object.defineProperty(cue, 'pauseOnExit', extend({}, baseObj, {
      get: function get() {
        return _pauseOnExit;
      },
      set: function set(value) {
        _pauseOnExit = !!value;
      }
    }));

    Object.defineProperty(cue, 'startTime', extend({}, baseObj, {
      get: function get() {
        return _startTime;
      },
      set: function set(value) {
        if (typeof value !== 'number') {
          throw new TypeError('Start time must be set to a number.');
        }
        _startTime = value;
        this.hasBeenReset = true;
      }
    }));

    Object.defineProperty(cue, 'endTime', extend({}, baseObj, {
      get: function get() {
        return _endTime;
      },
      set: function set(value) {
        if (typeof value !== 'number') {
          throw new TypeError('End time must be set to a number.');
        }
        _endTime = value;
        this.hasBeenReset = true;
      }
    }));

    Object.defineProperty(cue, 'text', extend({}, baseObj, {
      get: function get() {
        return _text;
      },
      set: function set(value) {
        _text = '' + value;
        this.hasBeenReset = true;
      }
    }));

    Object.defineProperty(cue, 'region', extend({}, baseObj, {
      get: function get() {
        return _region;
      },
      set: function set(value) {
        _region = value;
        this.hasBeenReset = true;
      }
    }));

    Object.defineProperty(cue, 'vertical', extend({}, baseObj, {
      get: function get() {
        return _vertical;
      },
      set: function set(value) {
        var setting = findDirectionSetting(value);
        // Have to check for false because the setting an be an empty string.
        if (setting === false) {
          throw new SyntaxError('An invalid or illegal string was specified.');
        }
        _vertical = setting;
        this.hasBeenReset = true;
      }
    }));

    Object.defineProperty(cue, 'snapToLines', extend({}, baseObj, {
      get: function get() {
        return _snapToLines;
      },
      set: function set(value) {
        _snapToLines = !!value;
        this.hasBeenReset = true;
      }
    }));

    Object.defineProperty(cue, 'line', extend({}, baseObj, {
      get: function get() {
        return _line;
      },
      set: function set(value) {
        if (typeof value !== 'number' && value !== autoKeyword) {
          throw new SyntaxError('An invalid number or illegal string was specified.');
        }
        _line = value;
        this.hasBeenReset = true;
      }
    }));

    Object.defineProperty(cue, 'lineAlign', extend({}, baseObj, {
      get: function get() {
        return _lineAlign;
      },
      set: function set(value) {
        var setting = findAlignSetting(value);
        if (!setting) {
          throw new SyntaxError('An invalid or illegal string was specified.');
        }
        _lineAlign = setting;
        this.hasBeenReset = true;
      }
    }));

    Object.defineProperty(cue, 'position', extend({}, baseObj, {
      get: function get() {
        return _position;
      },
      set: function set(value) {
        if (value < 0 || value > 100) {
          throw new Error('Position must be between 0 and 100.');
        }
        _position = value;
        this.hasBeenReset = true;
      }
    }));

    Object.defineProperty(cue, 'positionAlign', extend({}, baseObj, {
      get: function get() {
        return _positionAlign;
      },
      set: function set(value) {
        var setting = findAlignSetting(value);
        if (!setting) {
          throw new SyntaxError('An invalid or illegal string was specified.');
        }
        _positionAlign = setting;
        this.hasBeenReset = true;
      }
    }));

    Object.defineProperty(cue, 'size', extend({}, baseObj, {
      get: function get() {
        return _size;
      },
      set: function set(value) {
        if (value < 0 || value > 100) {
          throw new Error('Size must be between 0 and 100.');
        }
        _size = value;
        this.hasBeenReset = true;
      }
    }));

    Object.defineProperty(cue, 'align', extend({}, baseObj, {
      get: function get() {
        return _align;
      },
      set: function set(value) {
        var setting = findAlignSetting(value);
        if (!setting) {
          throw new SyntaxError('An invalid or illegal string was specified.');
        }
        _align = setting;
        this.hasBeenReset = true;
      }
    }));

    /**
     * Other <track> spec defined properties
     */

    // http://www.whatwg.org/specs/web-apps/current-work/multipage/the-video-element.html#text-track-cue-display-state
    cue.displayState = undefined;

    if (isIE8) {
      return cue;
    }
  }

  /**
   * VTTCue methods
   */

  VTTCue.prototype.getCueAsHTML = function () {
    // Assume WebVTT.convertCueToDOMTree is on the global.
    var WebVTT = window.WebVTT;
    return WebVTT.convertCueToDOMTree(window, this.text);
  };

  return VTTCue;
}();

},{}],50:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fixLineBreaks = undefined;

var _vttcue = require('./vttcue');

var _vttcue2 = _interopRequireDefault(_vttcue);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var StringDecoder = function StringDecoder() {
  return {
    decode: function decode(data) {
      if (!data) {
        return '';
      }
      if (typeof data !== 'string') {
        throw new Error('Error - expected string data.');
      }
      return decodeURIComponent(encodeURIComponent(data));
    }
  };
}; /*
    * Source: https://github.com/mozilla/vtt.js/blob/master/dist/vtt.js#L1716
    */

function VTTParser() {
  this.window = window;
  this.state = 'INITIAL';
  this.buffer = '';
  this.decoder = new StringDecoder();
  this.regionList = [];
}

// Try to parse input as a time stamp.
function parseTimeStamp(input) {

  function computeSeconds(h, m, s, f) {
    return (h | 0) * 3600 + (m | 0) * 60 + (s | 0) + (f | 0) / 1000;
  }

  var m = input.match(/^(\d+):(\d{2})(:\d{2})?\.(\d{3})/);
  if (!m) {
    return null;
  }

  if (m[3]) {
    // Timestamp takes the form of [hours]:[minutes]:[seconds].[milliseconds]
    return computeSeconds(m[1], m[2], m[3].replace(':', ''), m[4]);
  } else if (m[1] > 59) {
    // Timestamp takes the form of [hours]:[minutes].[milliseconds]
    // First position is hours as it's over 59.
    return computeSeconds(m[1], m[2], 0, m[4]);
  } else {
    // Timestamp takes the form of [minutes]:[seconds].[milliseconds]
    return computeSeconds(0, m[1], m[2], m[4]);
  }
}

// A settings object holds key/value pairs and will ignore anything but the first
// assignment to a specific key.
function Settings() {
  this.values = Object.create(null);
}

Settings.prototype = {
  // Only accept the first assignment to any key.
  set: function set(k, v) {
    if (!this.get(k) && v !== '') {
      this.values[k] = v;
    }
  },
  // Return the value for a key, or a default value.
  // If 'defaultKey' is passed then 'dflt' is assumed to be an object with
  // a number of possible default values as properties where 'defaultKey' is
  // the key of the property that will be chosen; otherwise it's assumed to be
  // a single value.
  get: function get(k, dflt, defaultKey) {
    if (defaultKey) {
      return this.has(k) ? this.values[k] : dflt[defaultKey];
    }
    return this.has(k) ? this.values[k] : dflt;
  },
  // Check whether we have a value for a key.
  has: function has(k) {
    return k in this.values;
  },
  // Accept a setting if its one of the given alternatives.
  alt: function alt(k, v, a) {
    for (var n = 0; n < a.length; ++n) {
      if (v === a[n]) {
        this.set(k, v);
        break;
      }
    }
  },
  // Accept a setting if its a valid (signed) integer.
  integer: function integer(k, v) {
    if (/^-?\d+$/.test(v)) {
      // integer
      this.set(k, parseInt(v, 10));
    }
  },
  // Accept a setting if its a valid percentage.
  percent: function percent(k, v) {
    var m;
    if (m = v.match(/^([\d]{1,3})(\.[\d]*)?%$/)) {
      v = parseFloat(v);
      if (v >= 0 && v <= 100) {
        this.set(k, v);
        return true;
      }
    }
    return false;
  }
};

// Helper function to parse input into groups separated by 'groupDelim', and
// interprete each group as a key/value pair separated by 'keyValueDelim'.
function parseOptions(input, callback, keyValueDelim, groupDelim) {
  var groups = groupDelim ? input.split(groupDelim) : [input];
  for (var i in groups) {
    if (typeof groups[i] !== 'string') {
      continue;
    }
    var kv = groups[i].split(keyValueDelim);
    if (kv.length !== 2) {
      continue;
    }
    var k = kv[0];
    var v = kv[1];
    callback(k, v);
  }
}

var defaults = new _vttcue2.default(0, 0, 0);
// 'middle' was changed to 'center' in the spec: https://github.com/w3c/webvtt/pull/244
// Chrome and Safari don't yet support this change, but FF does
var center = defaults.align === 'middle' ? 'middle' : 'center';

function parseCue(input, cue, regionList) {
  // Remember the original input if we need to throw an error.
  var oInput = input;
  // 4.1 WebVTT timestamp
  function consumeTimeStamp() {
    var ts = parseTimeStamp(input);
    if (ts === null) {
      throw new Error('Malformed timestamp: ' + oInput);
    }
    // Remove time stamp from input.
    input = input.replace(/^[^\sa-zA-Z-]+/, '');
    return ts;
  }

  // 4.4.2 WebVTT cue settings
  function consumeCueSettings(input, cue) {
    var settings = new Settings();

    parseOptions(input, function (k, v) {
      switch (k) {
        case 'region':
          // Find the last region we parsed with the same region id.
          for (var i = regionList.length - 1; i >= 0; i--) {
            if (regionList[i].id === v) {
              settings.set(k, regionList[i].region);
              break;
            }
          }
          break;
        case 'vertical':
          settings.alt(k, v, ['rl', 'lr']);
          break;
        case 'line':
          var vals = v.split(','),
              vals0 = vals[0];
          settings.integer(k, vals0);
          if (settings.percent(k, vals0)) {
            settings.set('snapToLines', false);
          }
          settings.alt(k, vals0, ['auto']);
          if (vals.length === 2) {
            settings.alt('lineAlign', vals[1], ['start', center, 'end']);
          }
          break;
        case 'position':
          vals = v.split(',');
          settings.percent(k, vals[0]);
          if (vals.length === 2) {
            settings.alt('positionAlign', vals[1], ['start', center, 'end', 'line-left', 'line-right', 'auto']);
          }
          break;
        case 'size':
          settings.percent(k, v);
          break;
        case 'align':
          settings.alt(k, v, ['start', center, 'end', 'left', 'right']);
          break;
      }
    }, /:/, /\s/);

    // Apply default values for any missing fields.
    cue.region = settings.get('region', null);
    cue.vertical = settings.get('vertical', '');
    var line = settings.get('line', 'auto');
    if (line === 'auto' && defaults.line === -1) {
      // set numeric line number for Safari
      line = -1;
    }
    cue.line = line;
    cue.lineAlign = settings.get('lineAlign', 'start');
    cue.snapToLines = settings.get('snapToLines', true);
    cue.size = settings.get('size', 100);
    cue.align = settings.get('align', center);
    var position = settings.get('position', 'auto');
    if (position === 'auto' && defaults.position === 50) {
      // set numeric position for Safari
      position = cue.align === 'start' || cue.align === 'left' ? 0 : cue.align === 'end' || cue.align === 'right' ? 100 : 50;
    }
    cue.position = position;
  }

  function skipWhitespace() {
    input = input.replace(/^\s+/, '');
  }

  // 4.1 WebVTT cue timings.
  skipWhitespace();
  cue.startTime = consumeTimeStamp(); // (1) collect cue start time
  skipWhitespace();
  if (input.substr(0, 3) !== '-->') {
    // (3) next characters must match '-->'
    throw new Error('Malformed time stamp (time stamps must be separated by \'-->\'): ' + oInput);
  }
  input = input.substr(3);
  skipWhitespace();
  cue.endTime = consumeTimeStamp(); // (5) collect cue end time

  // 4.1 WebVTT cue settings list.
  skipWhitespace();
  consumeCueSettings(input, cue);
}

function fixLineBreaks(input) {
  return input.replace(/<br(?: \/)?>/gi, '\n');
}

VTTParser.prototype = {
  parse: function parse(data) {
    var self = this;

    // If there is no data then we won't decode it, but will just try to parse
    // whatever is in buffer already. This may occur in circumstances, for
    // example when flush() is called.
    if (data) {
      // Try to decode the data that we received.
      self.buffer += self.decoder.decode(data, { stream: true });
    }

    function collectNextLine() {
      var buffer = self.buffer;
      var pos = 0;

      buffer = fixLineBreaks(buffer);

      while (pos < buffer.length && buffer[pos] !== '\r' && buffer[pos] !== '\n') {
        ++pos;
      }
      var line = buffer.substr(0, pos);
      // Advance the buffer early in case we fail below.
      if (buffer[pos] === '\r') {
        ++pos;
      }
      if (buffer[pos] === '\n') {
        ++pos;
      }
      self.buffer = buffer.substr(pos);
      return line;
    }

    // 3.2 WebVTT metadata header syntax
    function parseHeader(input) {
      parseOptions(input, function (k, v) {
        switch (k) {
          case 'Region':
            // 3.3 WebVTT region metadata header syntax
            console.log('parse region', v);
            //parseRegion(v);
            break;
        }
      }, /:/);
    }

    // 5.1 WebVTT file parsing.
    try {
      var line;
      if (self.state === 'INITIAL') {
        // We can't start parsing until we have the first line.
        if (!/\r\n|\n/.test(self.buffer)) {
          return this;
        }

        line = collectNextLine();

        var m = line.match(/^WEBVTT([ \t].*)?$/);
        if (!m || !m[0]) {
          throw new Error('Malformed WebVTT signature.');
        }

        self.state = 'HEADER';
      }

      var alreadyCollectedLine = false;
      while (self.buffer) {
        // We can't parse a line until we have the full line.
        if (!/\r\n|\n/.test(self.buffer)) {
          return this;
        }

        if (!alreadyCollectedLine) {
          line = collectNextLine();
        } else {
          alreadyCollectedLine = false;
        }

        switch (self.state) {
          case 'HEADER':
            // 13-18 - Allow a header (metadata) under the WEBVTT line.
            if (/:/.test(line)) {
              parseHeader(line);
            } else if (!line) {
              // An empty line terminates the header and starts the body (cues).
              self.state = 'ID';
            }
            continue;
          case 'NOTE':
            // Ignore NOTE blocks.
            if (!line) {
              self.state = 'ID';
            }
            continue;
          case 'ID':
            // Check for the start of NOTE blocks.
            if (/^NOTE($|[ \t])/.test(line)) {
              self.state = 'NOTE';
              break;
            }
            // 19-29 - Allow any number of line terminators, then initialize new cue values.
            if (!line) {
              continue;
            }
            self.cue = new _vttcue2.default(0, 0, '');
            self.state = 'CUE';
            // 30-39 - Check if self line contains an optional identifier or timing data.
            if (line.indexOf('-->') === -1) {
              self.cue.id = line;
              continue;
            }
          // Process line as start of a cue.
          /*falls through*/
          case 'CUE':
            // 40 - Collect cue timings and settings.
            try {
              parseCue(line, self.cue, self.regionList);
            } catch (e) {
              // In case of an error ignore rest of the cue.
              self.cue = null;
              self.state = 'BADCUE';
              continue;
            }
            self.state = 'CUETEXT';
            continue;
          case 'CUETEXT':
            var hasSubstring = line.indexOf('-->') !== -1;
            // 34 - If we have an empty line then report the cue.
            // 35 - If we have the special substring '-->' then report the cue,
            // but do not collect the line as we need to process the current
            // one as a new cue.
            if (!line || hasSubstring && (alreadyCollectedLine = true)) {
              // We are done parsing self cue.
              if (self.oncue) {
                self.oncue(self.cue);
              }
              self.cue = null;
              self.state = 'ID';
              continue;
            }
            if (self.cue.text) {
              self.cue.text += '\n';
            }
            self.cue.text += line;
            continue;
          case 'BADCUE':
            // BADCUE
            // 54-62 - Collect and discard the remaining cue.
            if (!line) {
              self.state = 'ID';
            }
            continue;
        }
      }
    } catch (e) {

      // If we are currently parsing a cue, report what we have.
      if (self.state === 'CUETEXT' && self.cue && self.oncue) {
        self.oncue(self.cue);
      }
      self.cue = null;
      // Enter BADWEBVTT state if header was not parsed correctly otherwise
      // another exception occurred so enter BADCUE state.
      self.state = self.state === 'INITIAL' ? 'BADWEBVTT' : 'BADCUE';
    }
    return this;
  },
  flush: function flush() {
    var self = this;
    try {
      // Finish decoding the stream.
      self.buffer += self.decoder.decode();
      // Synthesize the end of the current cue or region.
      if (self.cue || self.state === 'HEADER') {
        self.buffer += '\n\n';
        self.parse();
      }
      // If we've flushed, parsed, and we're still on the INITIAL state then
      // that means we don't have enough of the stream to parse the first
      // line.
      if (self.state === 'INITIAL') {
        throw new Error('Malformed WebVTT signature.');
      }
    } catch (e) {
      throw e;
    }
    if (self.onflush) {
      self.onflush();
    }
    return this;
  }
};

exports.fixLineBreaks = fixLineBreaks;
exports.default = VTTParser;

},{"./vttcue":49}],51:[function(require,module,exports){
'use strict';

var _vttparser = require('./vttparser');

var _vttparser2 = _interopRequireDefault(_vttparser);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var cueString2millis = function cueString2millis(timeString) {
    var ts = parseInt(timeString.substr(-3));
    var secs = parseInt(timeString.substr(-6, 2));
    var mins = parseInt(timeString.substr(-9, 2));
    var hours = timeString.length > 9 ? parseInt(timeString.substr(0, timeString.indexOf(':'))) : 0;

    if (isNaN(ts) || isNaN(secs) || isNaN(mins) || isNaN(hours)) {
        return -1;
    }

    ts += 1000 * secs;
    ts += 60 * 1000 * mins;
    ts += 60 * 60 * 1000 * hours;

    return ts;
};

var calculateOffset = function calculateOffset(vttCCs, cc, presentationTime) {
    var currCC = vttCCs[cc];
    var prevCC = vttCCs[currCC.prevCC];

    // This is the first discontinuity or cues have been processed since the last discontinuity
    // Offset = current discontinuity time
    if (!prevCC || !prevCC.new && currCC.new) {
        vttCCs.ccOffset = vttCCs.presentationOffset = currCC.start;
        currCC.new = false;
        return;
    }

    // There have been discontinuities since cues were last parsed.
    // Offset = time elapsed
    while (prevCC && prevCC.new) {
        vttCCs.ccOffset += currCC.start - prevCC.start;
        currCC.new = false;
        currCC = prevCC;
        prevCC = vttCCs[currCC.prevCC];
    }

    vttCCs.presentationOffset = presentationTime;
};

var WebVTTParser = {
    parse: function parse(vttByteArray, syncPTS, vttCCs, cc, callBack, errorCallBack) {
        // Convert byteArray into string, replacing any somewhat exotic linefeeds with "\n", then split on that character.
        var re = /\r\n|\n\r|\n|\r/g;
        var vttLines = String.fromCharCode.apply(null, new Uint8Array(vttByteArray)).trim().replace(re, '\n').split('\n');
        var cueTime = '00:00.000';
        var mpegTs = 0;
        var localTime = 0;
        var presentationTime = 0;
        var cues = [];
        var parsingError = void 0;
        var inHeader = true;
        // let VTTCue = VTTCue || window.TextTrackCue;

        // Create parser object using VTTCue with TextTrackCue fallback on certain browsers.
        var parser = new _vttparser2.default();

        parser.oncue = function (cue) {
            // Adjust cue timing; clamp cues to start no earlier than - and drop cues that don't end after - 0 on timeline.
            var currCC = vttCCs[cc];
            var cueOffset = vttCCs.ccOffset;

            // Update offsets for new discontinuities
            if (currCC && currCC.new) {
                if (localTime) {
                    // When local time is provided, offset = discontinuity start time - local time
                    cueOffset = vttCCs.ccOffset = currCC.start;
                } else {
                    calculateOffset(vttCCs, cc, presentationTime);
                }
            }

            if (presentationTime && !localTime) {
                // If we have MPEGTS but no LOCAL time, offset = presentation time + discontinuity offset
                cueOffset = presentationTime + vttCCs.ccOffset - vttCCs.presentationOffset;
            }

            cue.startTime += cueOffset - localTime;
            cue.endTime += cueOffset - localTime;

            // Fix encoding of special characters. TODO: Test with all sorts of weird characters.
            cue.text = decodeURIComponent(escape(cue.text));
            if (cue.endTime > 0) {
                cues.push(cue);
            }
        };

        parser.onparsingerror = function (e) {
            parsingError = e;
        };

        parser.onflush = function () {
            if (parsingError && errorCallBack) {
                errorCallBack(parsingError);
                return;
            }
            callBack(cues);
        };

        // Go through contents line by line.
        vttLines.forEach(function (line) {
            if (inHeader) {
                // Look for X-TIMESTAMP-MAP in header.
                if (line.startsWith('X-TIMESTAMP-MAP=')) {
                    // Once found, no more are allowed anyway, so stop searching.
                    inHeader = false;
                    // Extract LOCAL and MPEGTS.
                    line.substr(16).split(',').forEach(function (timestamp) {
                        if (timestamp.startsWith('LOCAL:')) {
                            cueTime = timestamp.substr(6);
                        } else if (timestamp.startsWith('MPEGTS:')) {
                            mpegTs = parseInt(timestamp.substr(7));
                        }
                    });
                    try {
                        // Calculate subtitle offset in milliseconds.
                        // If sync PTS is less than zero, we have a 33-bit wraparound, which is fixed by adding 2^33 = 8589934592.
                        syncPTS = syncPTS < 0 ? syncPTS + 8589934592 : syncPTS;
                        // Adjust MPEGTS by sync PTS.
                        mpegTs -= syncPTS;
                        // Convert cue time to seconds
                        localTime = cueString2millis(cueTime) / 1000;
                        // Convert MPEGTS to seconds from 90kHz.
                        presentationTime = mpegTs / 90000;

                        if (localTime === -1) {
                            parsingError = new Error('Malformed X-TIMESTAMP-MAP: ' + line);
                        }
                    } catch (e) {
                        parsingError = new Error('Malformed X-TIMESTAMP-MAP: ' + line);
                    }
                    // Return without parsing X-TIMESTAMP-MAP line.
                    return;
                } else if (line === '') {
                    inHeader = false;
                }
            }
            // Parse line by default.
            parser.parse(line + '\n');
        });

        parser.flush();
    }
};

module.exports = WebVTTParser;

},{"./vttparser":50}],52:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * XHR based logger
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */

var _logger = require('../utils/logger');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var XhrLoader = function () {
  function XhrLoader(config) {
    _classCallCheck(this, XhrLoader);

    if (config && config.xhrSetup) {
      this.xhrSetup = config.xhrSetup;
    }
  }

  _createClass(XhrLoader, [{
    key: 'destroy',
    value: function destroy() {
      this.abort();
      this.loader = null;
    }
  }, {
    key: 'abort',
    value: function abort() {
      var loader = this.loader;
      if (loader && loader.readyState !== 4) {
        this.stats.aborted = true;
        loader.abort();
      }

      window.clearTimeout(this.requestTimeout);
      this.requestTimeout = null;
      window.clearTimeout(this.retryTimeout);
      this.retryTimeout = null;
    }
  }, {
    key: 'load',
    value: function load(context, config, callbacks) {
      this.context = context;
      this.config = config;
      this.callbacks = callbacks;
      this.stats = { trequest: performance.now(), retry: 0 };
      this.retryDelay = config.retryDelay;
      this.loadInternal();
    }
  }, {
    key: 'loadInternal',
    value: function loadInternal() {
      var xhr,
          context = this.context;

      if (typeof XDomainRequest !== 'undefined') {
        xhr = this.loader = new XDomainRequest();
      } else {
        xhr = this.loader = new XMLHttpRequest();
      }

      xhr.onreadystatechange = this.readystatechange.bind(this);
      xhr.onprogress = this.loadprogress.bind(this);

      xhr.open('GET', context.url, true);

      if (context.rangeEnd) {
        xhr.setRequestHeader('Range', 'bytes=' + context.rangeStart + '-' + (context.rangeEnd - 1));
      }
      xhr.responseType = context.responseType;
      var stats = this.stats;
      stats.tfirst = 0;
      stats.loaded = 0;
      if (this.xhrSetup) {
        this.xhrSetup(xhr, context.url);
      }
      // setup timeout before we perform request
      this.requestTimeout = window.setTimeout(this.loadtimeout.bind(this), this.config.timeout);
      xhr.send();
    }
  }, {
    key: 'readystatechange',
    value: function readystatechange(event) {
      var xhr = event.currentTarget,
          readyState = xhr.readyState,
          stats = this.stats,
          context = this.context,
          config = this.config;

      // don't proceed if xhr has been aborted
      if (stats.aborted) {
        return;
      }

      // in any case clear the current xhrs timeout
      window.clearTimeout(this.requestTimeout);

      // HEADERS_RECEIVED
      if (readyState >= 2) {
        if (stats.tfirst === 0) {
          stats.tfirst = Math.max(performance.now(), stats.trequest);
          // reset timeout to total timeout duration minus the time it took to receive headers
          this.requestTimeout = window.setTimeout(this.loadtimeout.bind(this), config.timeout - (stats.tfirst - stats.trequest));
        }
        if (readyState === 4) {
          var status = xhr.status;
          // http status between 200 to 299 are all successful
          if (status >= 200 && status < 300) {
            stats.tload = Math.max(stats.tfirst, performance.now());
            var data = void 0,
                len = void 0;
            if (context.responseType === 'arraybuffer') {
              data = xhr.response;
              len = data.byteLength;
            } else {
              data = xhr.responseText;
              len = data.length;
            }
            stats.loaded = stats.total = len;
            var response = { url: xhr.responseURL, data: data };
            this.callbacks.onSuccess(response, stats, context);
          } else {
            // if max nb of retries reached or if http status between 400 and 499 (such error cannot be recovered, retrying is useless), return error
            if (stats.retry >= config.maxRetry || status >= 400 && status < 499) {
              _logger.logger.error(status + ' while loading ' + context.url);
              this.callbacks.onError({ code: status, text: xhr.statusText }, context);
            } else {
              // retry
              _logger.logger.warn(status + ' while loading ' + context.url + ', retrying in ' + this.retryDelay + '...');
              // aborts and resets internal state
              this.destroy();
              // schedule retry
              this.retryTimeout = window.setTimeout(this.loadInternal.bind(this), this.retryDelay);
              // set exponential backoff
              this.retryDelay = Math.min(2 * this.retryDelay, config.maxRetryDelay);
              stats.retry++;
            }
          }
        }
      }
    }
  }, {
    key: 'loadtimeout',
    value: function loadtimeout() {
      _logger.logger.warn('timeout while loading ' + this.context.url);
      this.callbacks.onTimeout(this.stats, this.context);
    }
  }, {
    key: 'loadprogress',
    value: function loadprogress(event) {
      var stats = this.stats;
      stats.loaded = event.loaded;
      if (event.lengthComputable) {
        stats.total = event.total;
      }
      var onProgress = this.callbacks.onProgress;
      if (onProgress) {
        // last args is to provide on progress data
        onProgress(stats, this.context, null);
      }
    }
  }]);

  return XhrLoader;
}();

exports.default = XhrLoader;

},{"../utils/logger":47}]},{},[35])(35)
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvZXZlbnRzL2V2ZW50cy5qcyIsIm5vZGVfbW9kdWxlcy91cmwtdG9vbGtpdC9zcmMvdXJsLXRvb2xraXQuanMiLCJub2RlX21vZHVsZXMvd2Vid29ya2lmeS9pbmRleC5qcyIsInNyYy9jb250cm9sbGVyL2Fici1jb250cm9sbGVyLmpzIiwic3JjL2NvbnRyb2xsZXIvYXVkaW8tc3RyZWFtLWNvbnRyb2xsZXIuanMiLCJzcmMvY29udHJvbGxlci9hdWRpby10cmFjay1jb250cm9sbGVyLmpzIiwic3JjL2NvbnRyb2xsZXIvYnVmZmVyLWNvbnRyb2xsZXIuanMiLCJzcmMvY29udHJvbGxlci9jYXAtbGV2ZWwtY29udHJvbGxlci5qcyIsInNyYy9jb250cm9sbGVyL2V3bWEtYmFuZHdpZHRoLWVzdGltYXRvci5qcyIsInNyYy9jb250cm9sbGVyL2Zwcy1jb250cm9sbGVyLmpzIiwic3JjL2NvbnRyb2xsZXIvbGV2ZWwtY29udHJvbGxlci5qcyIsInNyYy9jb250cm9sbGVyL3N0cmVhbS1jb250cm9sbGVyLmpzIiwic3JjL2NvbnRyb2xsZXIvc3VidGl0bGUtc3RyZWFtLWNvbnRyb2xsZXIuanMiLCJzcmMvY29udHJvbGxlci9zdWJ0aXRsZS10cmFjay1jb250cm9sbGVyLmpzIiwic3JjL2NvbnRyb2xsZXIvdGltZWxpbmUtY29udHJvbGxlci5qcyIsInNyYy9jcnlwdC9hZXMtY3J5cHRvLmpzIiwic3JjL2NyeXB0L2Flcy1kZWNyeXB0b3IuanMiLCJzcmMvY3J5cHQvZGVjcnlwdGVyLmpzIiwic3JjL2NyeXB0L2Zhc3QtYWVzLWtleS5qcyIsInNyYy9kZW11eC9hYWNkZW11eGVyLmpzIiwic3JjL2RlbXV4L2FkdHMuanMiLCJzcmMvZGVtdXgvZGVtdXhlci1pbmxpbmUuanMiLCJzcmMvZGVtdXgvZGVtdXhlci13b3JrZXIuanMiLCJzcmMvZGVtdXgvZGVtdXhlci5qcyIsInNyYy9kZW11eC9leHAtZ29sb21iLmpzIiwic3JjL2RlbXV4L2lkMy5qcyIsInNyYy9kZW11eC90c2RlbXV4ZXIuanMiLCJzcmMvZXJyb3JzLmpzIiwic3JjL2V2ZW50LWhhbmRsZXIuanMiLCJzcmMvZXZlbnRzLmpzIiwic3JjL2hlbHBlci9hYWMuanMiLCJzcmMvaGVscGVyL2J1ZmZlci1oZWxwZXIuanMiLCJzcmMvaGVscGVyL2xldmVsLWhlbHBlci5qcyIsInNyYy9obHMuanMiLCJzcmMvaW5kZXguanMiLCJzcmMvbG9hZGVyL2ZyYWdtZW50LWxvYWRlci5qcyIsInNyYy9sb2FkZXIva2V5LWxvYWRlci5qcyIsInNyYy9sb2FkZXIvcGxheWxpc3QtbG9hZGVyLmpzIiwic3JjL3JlbXV4L21wNC1nZW5lcmF0b3IuanMiLCJzcmMvcmVtdXgvbXA0LXJlbXV4ZXIuanMiLCJzcmMvcmVtdXgvcGFzc3Rocm91Z2gtcmVtdXhlci5qcyIsInNyYy91dGlscy9hdHRyLWxpc3QuanMiLCJzcmMvdXRpbHMvYmluYXJ5LXNlYXJjaC5qcyIsInNyYy91dGlscy9jZWEtNjA4LXBhcnNlci5qcyIsInNyYy91dGlscy9jdWVzLmpzIiwic3JjL3V0aWxzL2V3bWEuanMiLCJzcmMvdXRpbHMvbG9nZ2VyLmpzIiwic3JjL3V0aWxzL3RpbWVSYW5nZXMuanMiLCJzcmMvdXRpbHMvdnR0Y3VlLmpzIiwic3JjL3V0aWxzL3Z0dHBhcnNlci5qcyIsInNyYy91dGlscy93ZWJ2dHQtcGFyc2VyLmpzIiwic3JjL3V0aWxzL3hoci1sb2FkZXIuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FDM0VBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOztBQUNBOztBQUNBOzs7Ozs7Ozs7OytlQVhBOzs7Ozs7SUFhTSxhOzs7QUFFSix5QkFBWSxHQUFaLEVBQWlCO0FBQUE7O0FBQUEsOEhBQ1QsR0FEUyxFQUNKLGlCQUFNLFlBREYsRUFFSixpQkFBTSxXQUZGLEVBR0osaUJBQU0sYUFIRixFQUlKLGlCQUFNLEtBSkY7O0FBS2YsVUFBSyxtQkFBTCxHQUEyQixDQUEzQjtBQUNBLFVBQUssaUJBQUwsR0FBeUIsQ0FBQyxDQUExQjtBQUNBLFVBQUssY0FBTCxHQUFzQixDQUFDLENBQXZCO0FBQ0EsVUFBSyxHQUFMLEdBQVcsR0FBWDtBQUNBLFVBQUssT0FBTCxHQUFlLE1BQUssaUJBQUwsQ0FBdUIsSUFBdkIsT0FBZjtBQVRlO0FBVWhCOzs7OzhCQUVTO0FBQ1IsV0FBSyxVQUFMO0FBQ0EsNkJBQWEsU0FBYixDQUF1QixPQUF2QixDQUErQixJQUEvQixDQUFvQyxJQUFwQztBQUNEOzs7a0NBRWEsSSxFQUFNO0FBQ2xCLFVBQUksT0FBTyxLQUFLLElBQWhCO0FBQ0EsVUFBSSxLQUFLLElBQUwsS0FBYyxNQUFsQixFQUEwQjtBQUN4QixZQUFJLENBQUMsS0FBSyxLQUFWLEVBQWlCO0FBQ2YsZUFBSyxLQUFMLEdBQWEsWUFBWSxLQUFLLE9BQWpCLEVBQTBCLEdBQTFCLENBQWI7QUFDRDtBQUNEO0FBQ0E7QUFDQSxZQUFJLENBQUMsS0FBSyxXQUFWLEVBQXVCO0FBQ3JCLGNBQUksTUFBTSxLQUFLLEdBQWY7QUFBQSxjQUNJLFFBQVEsS0FBSyxJQUFMLENBQVUsS0FEdEI7QUFBQSxjQUVJLFNBQVMsSUFBSSxNQUFKLENBQVcsS0FBWCxFQUFrQixPQUFsQixDQUEwQixJQUZ2QztBQUFBLGNBR0ksU0FBUyxJQUFJLE1BSGpCO0FBQUEsY0FJSSxpQkFKSjtBQUFBLGNBSWMsaUJBSmQ7O0FBTUEsY0FBSSxNQUFKLEVBQVk7QUFDVix1QkFBVyxPQUFPLGVBQWxCO0FBQ0EsdUJBQVcsT0FBTyxlQUFsQjtBQUNELFdBSEQsTUFHTztBQUNMLHVCQUFXLE9BQU8sY0FBbEI7QUFDQSx1QkFBVyxPQUFPLGNBQWxCO0FBQ0Q7QUFDRCxlQUFLLFdBQUwsR0FBbUIscUNBQTJCLEdBQTNCLEVBQStCLFFBQS9CLEVBQXdDLFFBQXhDLEVBQWlELE9BQU8sc0JBQXhELENBQW5CO0FBQ0Q7QUFDRCxhQUFLLFdBQUwsR0FBbUIsSUFBbkI7QUFDRDtBQUNGOzs7d0NBRW1CO0FBQ2xCOzs7OztBQUtBLFVBQUksTUFBTSxLQUFLLEdBQWY7QUFBQSxVQUFvQixJQUFJLElBQUksS0FBNUI7QUFBQSxVQUFrQyxPQUFPLEtBQUssV0FBOUM7QUFBQSxVQUEyRCxTQUFTLEtBQUssTUFBekU7QUFBQSxVQUFpRixlQUFlLEtBQUssWUFBckc7O0FBRUE7QUFDQSxVQUFHLENBQUMsTUFBRCxJQUFhLE9BQU8sS0FBUCxJQUFnQixPQUFPLEtBQVAsQ0FBYSxPQUE3QyxFQUF1RDtBQUNyRCx1QkFBTyxJQUFQLENBQVkscURBQVo7QUFDQSxhQUFLLFVBQUw7QUFDQTtBQUNEO0FBQ0QsVUFBSSxRQUFRLE9BQU8sS0FBbkI7QUFDQTs7QUFFQSxVQUFJLE1BQU8sQ0FBQyxFQUFFLE1BQUgsSUFBYyxFQUFFLFlBQUYsS0FBbUIsQ0FBbEMsSUFBeUMsQ0FBQyxFQUFFLFVBQWxELEtBQWlFLEtBQUssU0FBdEUsSUFBbUYsS0FBSyxLQUE1RixFQUFtRztBQUNqRyxZQUFJLGVBQWUsWUFBWSxHQUFaLEtBQW9CLE1BQU0sUUFBN0M7QUFBQSxZQUNJLGVBQWUsS0FBSyxHQUFMLENBQVMsRUFBRSxZQUFYLENBRG5CO0FBRUE7QUFDQSxZQUFJLGVBQWdCLE1BQU0sS0FBSyxRQUFYLEdBQXNCLFlBQTFDLEVBQXlEO0FBQ3ZELGNBQUksU0FBUyxJQUFJLE1BQWpCO0FBQUEsY0FDSSxXQUFXLEtBQUssR0FBTCxDQUFTLENBQVQsRUFBWSxNQUFNLEVBQU4sR0FBVyxNQUFNLEVBQU4sR0FBVyxDQUF0QixHQUEwQixNQUFNLE1BQU4sR0FBZSxJQUFmLEdBQXNCLFlBQTVELENBRGY7QUFBQSxjQUMwRjtBQUN0RjtBQUNBLHdCQUFjLE1BQU0sS0FBTixHQUFjLE1BQU0sS0FBcEIsR0FBNEIsS0FBSyxHQUFMLENBQVMsTUFBTSxNQUFmLEVBQXVCLEtBQUssS0FBTCxDQUFXLEtBQUssUUFBTCxHQUFnQixPQUFPLEtBQUssS0FBWixFQUFtQixPQUFuQyxHQUE2QyxDQUF4RCxDQUF2QixDQUg5QztBQUFBLGNBSUksTUFBTSxFQUFFLFdBSlo7QUFBQSxjQUtJLGtCQUFrQixDQUFDLGNBQWMsTUFBTSxNQUFyQixJQUErQixRQUxyRDtBQUFBLGNBTUksd0JBQXdCLENBQUMsdUJBQWEsVUFBYixDQUF3QixDQUF4QixFQUEwQixHQUExQixFQUE4QixJQUFJLE1BQUosQ0FBVyxhQUF6QyxFQUF3RCxHQUF4RCxHQUE4RCxHQUEvRCxJQUFzRSxZQU5sRztBQU9BO0FBQ0E7QUFDQTtBQUNBLGNBQUssd0JBQXlCLElBQUksS0FBSyxRQUFULEdBQW9CLFlBQTlDLElBQWlFLGtCQUFrQixxQkFBdkYsRUFBK0c7QUFDN0csZ0JBQUksaUNBQUo7QUFBQSxnQkFBOEIsc0JBQTlCO0FBQ0E7QUFDQTtBQUNBLGlCQUFLLGdCQUFnQixLQUFLLEtBQUwsR0FBYSxDQUFsQyxFQUFzQyxnQkFBZ0IsWUFBdEQsRUFBcUUsZUFBckUsRUFBc0Y7QUFDcEY7QUFDQTtBQUNBO0FBQ0EseUNBQTJCLEtBQUssUUFBTCxHQUFnQixPQUFPLGFBQVAsRUFBc0IsT0FBdEMsSUFBaUQsSUFBSSxHQUFKLEdBQVUsUUFBM0QsQ0FBM0I7QUFDQSxrQkFBSSwyQkFBMkIscUJBQS9CLEVBQXNEO0FBQ3BEO0FBQ0E7QUFDRDtBQUNGO0FBQ0Q7QUFDQTtBQUNBLGdCQUFJLDJCQUEyQixlQUEvQixFQUFnRDtBQUM5Qyw2QkFBTyxJQUFQLG1FQUE0RSxhQUE1RSx5QkFBNkcsYUFBN0csMkJBQStJLEtBQUssS0FBTCxHQUFXLENBQTFKLGlDQUFzTCx5QkFBeUIsT0FBekIsQ0FBaUMsQ0FBakMsQ0FBdEwsU0FBNk4sZ0JBQWdCLE9BQWhCLENBQXdCLENBQXhCLENBQTdOLFNBQTJQLHNCQUFzQixPQUF0QixDQUE4QixDQUE5QixDQUEzUDtBQUNBO0FBQ0Esa0JBQUksYUFBSixHQUFvQixhQUFwQjtBQUNBO0FBQ0EsbUJBQUssV0FBTCxDQUFpQixNQUFqQixDQUF3QixZQUF4QixFQUFxQyxNQUFNLE1BQTNDO0FBQ0E7QUFDQSxxQkFBTyxLQUFQO0FBQ0E7QUFDQSxtQkFBSyxVQUFMO0FBQ0Esa0JBQUksT0FBSixDQUFZLGlCQUFNLDJCQUFsQixFQUErQyxFQUFDLE1BQU0sSUFBUCxFQUFhLE9BQU8sS0FBcEIsRUFBL0M7QUFDRDtBQUNGO0FBQ0Y7QUFDRjtBQUNGOzs7aUNBRVksSSxFQUFNO0FBQ2pCLFVBQUksT0FBTyxLQUFLLElBQWhCO0FBQ0EsVUFBSSxLQUFLLElBQUwsS0FBYyxNQUFsQixFQUEwQjtBQUN4QjtBQUNBLGFBQUssVUFBTDtBQUNBO0FBQ0EsYUFBSyxtQkFBTCxHQUEyQixLQUFLLEtBQWhDO0FBQ0E7QUFDQSxhQUFLLGNBQUwsR0FBc0IsQ0FBQyxDQUF2QjtBQUNBO0FBQ0EsWUFBSSxLQUFLLElBQUwsQ0FBVSxXQUFkLEVBQTJCO0FBQ3pCLGNBQUksUUFBUSxLQUFLLEtBQWpCO0FBQ0EsZ0JBQU0sT0FBTixHQUFnQixNQUFNLFNBQU4sR0FBa0IsTUFBTSxLQUF4QztBQUNBLGVBQUssY0FBTCxDQUFvQixJQUFwQjtBQUNEO0FBQ0Y7QUFDRjs7O21DQUVjLEksRUFBTTtBQUNuQixVQUFJLFFBQVEsS0FBSyxLQUFqQjtBQUFBLFVBQXdCLE9BQU8sS0FBSyxJQUFwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBSSxNQUFNLE9BQU4sS0FBa0IsSUFBbEIsSUFBMEIsS0FBSyxXQUFMLEtBQXFCLENBQS9DLElBQW9ELEtBQUssSUFBTCxLQUFjLE1BQWxFLEtBQThFLENBQUMsS0FBSyxXQUFOLElBQXFCLE1BQU0sS0FBTixLQUFnQixNQUFNLFNBQXpILENBQUosRUFBMEk7QUFDeEk7QUFDQTtBQUNBO0FBQ0EsWUFBSSwwQkFBMEIsTUFBTSxPQUFOLEdBQWdCLE1BQU0sUUFBcEQ7QUFDQSx1QkFBTyxHQUFQLDBDQUFrRCxLQUFLLEtBQUwsQ0FBVyxNQUFNLE1BQU4sR0FBYSxNQUFNLFFBQTlCLENBQWxELFNBQTZGLEtBQUssS0FBTCxDQUFXLE1BQU0sS0FBTixHQUFZLE1BQU0sTUFBN0IsQ0FBN0YsU0FBcUksS0FBSyxLQUFMLENBQVcsTUFBTSxPQUFOLEdBQWMsTUFBTSxLQUEvQixDQUFySSxTQUE4SyxLQUFLLEtBQUwsQ0FBVyxNQUFNLFNBQU4sR0FBZ0IsTUFBTSxPQUFqQyxDQUE5SyxTQUEyTixLQUFLLEtBQUwsQ0FBVyxJQUFFLE1BQU0sTUFBUixJQUFnQixNQUFNLFNBQU4sR0FBZ0IsTUFBTSxRQUF0QyxDQUFYLENBQTNOO0FBQ0EsYUFBSyxXQUFMLENBQWlCLE1BQWpCLENBQXdCLHVCQUF4QixFQUFnRCxNQUFNLE1BQXREO0FBQ0E7QUFDQSxZQUFJLEtBQUssV0FBVCxFQUFzQjtBQUNwQixlQUFLLGdCQUFMLEdBQXdCLDBCQUF3QixJQUFoRDtBQUNELFNBRkQsTUFFTztBQUNMLGVBQUssZ0JBQUwsR0FBd0IsQ0FBeEI7QUFDRDtBQUNGO0FBQ0Y7Ozs0QkFFTyxJLEVBQU07QUFDWjtBQUNBLGNBQU8sS0FBSyxPQUFaO0FBQ0UsYUFBSyxxQkFBYSxlQUFsQjtBQUNBLGFBQUsscUJBQWEsaUJBQWxCO0FBQ0UsZUFBSyxVQUFMO0FBQ0E7QUFDRjtBQUNFO0FBTko7QUFRRDs7O2lDQUVXO0FBQ1YsVUFBSSxLQUFLLEtBQVQsRUFBZ0I7QUFDZCxzQkFBYyxLQUFLLEtBQW5CO0FBQ0EsYUFBSyxLQUFMLEdBQWEsSUFBYjtBQUNEO0FBQ0g7O0FBRUE7Ozs7a0NBK0ZjLFksRUFBYSxtQixFQUFvQixTLEVBQVUsWSxFQUFhLFksRUFBYSxnQixFQUFpQixRLEVBQVMsVSxFQUFXLE0sRUFBUTtBQUM5SCxXQUFLLElBQUksSUFBSSxZQUFiLEVBQTJCLEtBQUssWUFBaEMsRUFBOEMsR0FBOUMsRUFBbUQ7QUFDakQsWUFBSSxZQUFZLE9BQU8sQ0FBUCxDQUFoQjtBQUFBLFlBQ0ksZUFBZSxVQUFVLE9BRDdCO0FBQUEsWUFFSSxjQUFjLGVBQWUsYUFBYSxhQUFiLEdBQTJCLGFBQWEsU0FBYixDQUF1QixNQUFqRSxHQUEwRSxtQkFGNUY7QUFBQSxZQUdJLE9BQU8sZUFBZSxhQUFhLElBQTVCLEdBQW1DLEtBSDlDO0FBQUEsWUFJSSxtQkFKSjtBQUtGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFLFlBQUksS0FBSyxZQUFULEVBQXVCO0FBQ3JCLHVCQUFhLFdBQVcsU0FBeEI7QUFDRCxTQUZELE1BRU87QUFDTCx1QkFBYSxhQUFhLFNBQTFCO0FBQ0Q7QUFDRCxZQUFNLFVBQVUsT0FBTyxDQUFQLEVBQVUsT0FBMUI7QUFBQSxZQUNNLGdCQUFnQixVQUFVLFdBQVYsR0FBd0IsVUFEOUM7O0FBR0YsdUJBQU8sS0FBUCwyRUFBcUYsQ0FBckYsU0FBMEYsS0FBSyxLQUFMLENBQVcsVUFBWCxDQUExRixTQUFvSCxPQUFwSCxTQUErSCxXQUEvSCxTQUE4SSxnQkFBOUksU0FBa0ssYUFBbEs7QUFDRTtBQUNBLFlBQUksYUFBYSxPQUFiO0FBQ0o7QUFDQTtBQUNHLFNBQUMsYUFBRCxJQUFrQixJQUFsQixJQUEwQixnQkFBZ0IsZ0JBSHpDLENBQUosRUFHaUU7QUFDL0Q7O0FBRUEsaUJBQU8sQ0FBUDtBQUNEO0FBQ0Y7QUFDRDtBQUNBLGFBQU8sQ0FBQyxDQUFSO0FBQ0Q7Ozt3QkFoSXNCO0FBQ3JCLGFBQU8sS0FBSyxpQkFBWjtBQUNEOztBQUVEOztzQkFDcUIsUSxFQUFVO0FBQzdCLFdBQUssaUJBQUwsR0FBeUIsUUFBekI7QUFDRDs7O3dCQUVtQjtBQUNsQixVQUFJLGdCQUFnQixLQUFLLGNBQXpCO0FBQUEsVUFBeUMsY0FBYyxLQUFLLFdBQTVEO0FBQUEsVUFBeUUsTUFBTSxLQUFLLEdBQXBGO0FBQUEsVUFDRSxTQUFTLElBQUksTUFEZjtBQUFBLFVBQ3VCLGlCQUFpQixJQUFJLE1BQUosQ0FBVyxjQURuRDtBQUVBO0FBQ0EsVUFBSSxrQkFBa0IsQ0FBQyxDQUFuQixLQUF5QixDQUFDLFdBQUQsSUFBZ0IsQ0FBQyxZQUFZLFdBQVosRUFBMUMsQ0FBSixFQUEwRTtBQUN4RTtBQUNBLGVBQU8sS0FBSyxHQUFMLENBQVMsYUFBVCxFQUF1QixLQUFLLFlBQTVCLENBQVA7QUFDRDtBQUNEO0FBQ0EsVUFBSSxtQkFBbUIsS0FBSyxnQkFBNUI7QUFDQSxVQUFJLGtCQUFrQixDQUFDLENBQXZCLEVBQTBCO0FBQ3hCO0FBQ0EsMkJBQW1CLEtBQUssR0FBTCxDQUFTLGFBQVQsRUFBdUIsZ0JBQXZCLENBQW5CO0FBQ0Q7QUFDRCxVQUFHLG1CQUFtQixTQUF0QixFQUFpQztBQUMvQixlQUFPLE9BQU8sZ0JBQVAsRUFBeUIsT0FBekIsR0FBbUMsY0FBMUMsRUFBMEQ7QUFDeEQ7QUFDRDtBQUNGO0FBQ0QsYUFBTyxnQkFBUDtBQUNELEs7c0JBcUdpQixTLEVBQVc7QUFDM0IsV0FBSyxjQUFMLEdBQXNCLFNBQXRCO0FBQ0Q7Ozt3QkFyR2tCO0FBQ2pCLFVBQUksTUFBTSxLQUFLLEdBQWY7QUFBQSxVQUFvQixTQUFTLElBQUksTUFBakM7QUFBQSxVQUF5QyxpQkFBaUIsSUFBSSxNQUFKLENBQVcsY0FBckU7QUFBQSxVQUFxRixNQUFNLFNBQVMsT0FBTyxNQUFoQixHQUF5QixDQUFwSDtBQUNBLFdBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxHQUFwQixFQUF5QixHQUF6QixFQUE4QjtBQUM1QixZQUFJLE9BQU8sQ0FBUCxFQUFVLE9BQVYsR0FBb0IsY0FBeEIsRUFBd0M7QUFDdEMsaUJBQU8sQ0FBUDtBQUNEO0FBQ0Y7QUFDRCxhQUFPLENBQVA7QUFDRDs7O3dCQUVrQjtBQUNqQixVQUFJLFNBQVMsS0FBSyxHQUFMLENBQVMsTUFBdEI7QUFBQSxVQUE2QixtQkFBbUIsS0FBSyxpQkFBckQ7QUFBQSxVQUF3RSxZQUF4RTtBQUNBLFVBQUkscUJBQW9CLENBQUMsQ0FBckIsSUFBMEIsTUFBMUIsSUFBb0MsT0FBTyxNQUEvQyxFQUF1RDtBQUNyRCx1QkFBZSxPQUFPLE1BQVAsR0FBZ0IsQ0FBL0I7QUFDRCxPQUZELE1BRU87QUFDTCx1QkFBZSxnQkFBZjtBQUNEO0FBQ0QsYUFBTyxZQUFQO0FBQ0Q7Ozt3QkFFc0I7QUFDckIsVUFBSSxNQUFNLEtBQUssR0FBZjtBQUFBLFVBQW9CLGVBQWUsS0FBSyxZQUF4QztBQUFBLFVBQXNELFNBQVMsSUFBSSxNQUFuRTtBQUFBLFVBQTJFLFNBQVMsSUFBSSxNQUF4RjtBQUFBLFVBQWdHLGVBQWUsS0FBSyxZQUFwSDtBQUNBLFVBQU0sSUFBSSxJQUFJLEtBQWQ7QUFBQSxVQUNNLGVBQWUsS0FBSyxtQkFEMUI7QUFBQSxVQUVNLHNCQUFzQixLQUFLLFdBQUwsR0FBbUIsS0FBSyxXQUFMLENBQWlCLFFBQXBDLEdBQStDLENBRjNFO0FBQUEsVUFHTSxNQUFPLElBQUksRUFBRSxXQUFOLEdBQW9CLENBSGpDOztBQUlNO0FBQ0E7QUFDQSxxQkFBaUIsS0FBTSxFQUFFLFlBQUYsS0FBbUIsQ0FBMUIsR0FBZ0MsS0FBSyxHQUFMLENBQVMsRUFBRSxZQUFYLENBQWhDLEdBQTJELEdBTmpGO0FBQUEsVUFPTSxRQUFRLEtBQUssV0FBTCxHQUFtQixLQUFLLFdBQUwsQ0FBaUIsV0FBakIsRUFBbkIsR0FBb0QsT0FBTyxzQkFQekU7O0FBUU07QUFDQSw4QkFBd0IsQ0FBQyx1QkFBYSxVQUFiLENBQXdCLENBQXhCLEVBQTJCLEdBQTNCLEVBQWdDLE9BQU8sYUFBdkMsRUFBc0QsR0FBdEQsR0FBNEQsR0FBN0QsSUFBb0UsWUFUbEc7O0FBV0E7QUFDQSxVQUFJLFlBQVksS0FBSyxhQUFMLENBQW1CLFlBQW5CLEVBQWdDLG1CQUFoQyxFQUFvRCxLQUFwRCxFQUEwRCxZQUExRCxFQUF1RSxZQUF2RSxFQUFvRixxQkFBcEYsRUFBMEcsT0FBTyxrQkFBakgsRUFBb0ksT0FBTyxvQkFBM0ksRUFBZ0ssTUFBaEssQ0FBaEI7QUFDQSxVQUFJLGFBQWEsQ0FBakIsRUFBb0I7QUFDbEIsZUFBTyxTQUFQO0FBQ0QsT0FGRCxNQUVPO0FBQ0wsdUJBQU8sS0FBUCxDQUFhLDZGQUFiO0FBQ0E7QUFDQTtBQUNBLFlBQUkscUJBQXFCLE9BQU8sa0JBQWhDO0FBQUEsWUFDSSxXQUFXLE9BQU8sa0JBRHRCO0FBQUEsWUFFSSxhQUFhLE9BQU8sb0JBRnhCO0FBR0EsWUFBSSwwQkFBMEIsQ0FBOUIsRUFBaUM7QUFDL0I7QUFDQSxjQUFJLG1CQUFtQixLQUFLLGdCQUE1QjtBQUNBLGNBQUksZ0JBQUosRUFBc0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBcUIsT0FBTyxlQUFQLEdBQXlCLGdCQUE5QztBQUNBLDJCQUFPLEtBQVAsd0JBQWtDLEtBQUssS0FBTCxDQUFXLE9BQUssZ0JBQWhCLENBQWxDLG9EQUFrSCxLQUFLLEtBQUwsQ0FBVyxPQUFLLGtCQUFoQixDQUFsSDtBQUNBO0FBQ0EsdUJBQVcsYUFBYSxDQUF4QjtBQUNEO0FBQ0Y7QUFDRCxvQkFBWSxLQUFLLGFBQUwsQ0FBbUIsWUFBbkIsRUFBZ0MsbUJBQWhDLEVBQW9ELEtBQXBELEVBQTBELFlBQTFELEVBQXVFLFlBQXZFLEVBQW9GLHdCQUFzQixrQkFBMUcsRUFBNkgsUUFBN0gsRUFBc0ksVUFBdEksRUFBaUosTUFBakosQ0FBWjtBQUNBLGVBQU8sS0FBSyxHQUFMLENBQVMsU0FBVCxFQUFtQixDQUFuQixDQUFQO0FBQ0Q7QUFDRjs7Ozs7O2tCQTJDWSxhOzs7Ozs7Ozs7Ozs7O0FDNVRmOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7O0FBQ0E7Ozs7Ozs7OytlQVpBOzs7O0FBY0EsSUFBTSxRQUFRO0FBQ1osV0FBVSxTQURFO0FBRVosWUFBVyxVQUZDO0FBR1osUUFBTyxNQUhLO0FBSVosVUFBUyxRQUpHO0FBS1osZUFBYyxhQUxGO0FBTVosZ0JBQWUsY0FOSDtBQU9aLDhCQUE2Qiw0QkFQakI7QUFRWixpQkFBZ0IsZUFSSjtBQVNaLFdBQVUsU0FURTtBQVVaLFVBQVMsUUFWRztBQVdaLFNBQVEsT0FYSTtBQVlaLFNBQVEsT0FaSTtBQWFaLG9CQUFtQjtBQWJQLENBQWQ7O0lBZ0JNLHFCOzs7QUFFSixpQ0FBWSxHQUFaLEVBQWlCO0FBQUE7O0FBQUEsOElBQ1QsR0FEUyxFQUViLGlCQUFNLGNBRk8sRUFHYixpQkFBTSxlQUhPLEVBSWIsaUJBQU0sb0JBSk8sRUFLYixpQkFBTSxxQkFMTyxFQU1iLGlCQUFNLGtCQU5PLEVBT2IsaUJBQU0sVUFQTyxFQVFiLGlCQUFNLFdBUk8sRUFTYixpQkFBTSx5QkFUTyxFQVViLGlCQUFNLGlCQVZPLEVBV2IsaUJBQU0sV0FYTyxFQVliLGlCQUFNLEtBWk8sRUFhYixpQkFBTSxjQWJPLEVBY2IsaUJBQU0sZUFkTyxFQWViLGlCQUFNLGNBZk8sRUFnQmIsaUJBQU0sY0FoQk87O0FBa0JmLFVBQUssTUFBTCxHQUFjLElBQUksTUFBbEI7QUFDQSxVQUFLLGNBQUwsR0FBc0IsS0FBdEI7QUFDQSxVQUFLLEtBQUwsR0FBYSxDQUFiO0FBQ0EsVUFBSyxNQUFMLEdBQWMsTUFBSyxJQUFMLENBQVUsSUFBVixPQUFkO0FBQ0EsVUFBSyxPQUFMLEdBQWEsRUFBYjtBQUNBLFVBQUssZUFBTCxHQUFxQixJQUFyQjtBQXZCZTtBQXdCaEI7Ozs7OEJBRVM7QUFDUixXQUFLLFFBQUw7QUFDQSxVQUFJLEtBQUssS0FBVCxFQUFnQjtBQUNkLHNCQUFjLEtBQUssS0FBbkI7QUFDQSxhQUFLLEtBQUwsR0FBYSxJQUFiO0FBQ0Q7QUFDRCw2QkFBYSxTQUFiLENBQXVCLE9BQXZCLENBQStCLElBQS9CLENBQW9DLElBQXBDO0FBQ0EsV0FBSyxLQUFMLEdBQWEsTUFBTSxPQUFuQjtBQUNEOztBQUVEOzs7O21DQUNlLEksRUFBTTtBQUNuQixVQUFJLFlBQVUsS0FBSyxFQUFuQjtBQUFBLFVBQXVCLEtBQUssS0FBSyxFQUFqQztBQUFBLFVBQXFDLFVBQVUsS0FBSyxPQUFwRDtBQUNBLFVBQUcsY0FBYyxNQUFqQixFQUF5QjtBQUN2QjtBQUNBO0FBQ0EsYUFBSyxPQUFMLENBQWEsRUFBYixJQUFtQixPQUFuQjtBQUNBLHVCQUFPLEdBQVAscUJBQTZCLEVBQTdCLGdDQUEwRCxPQUExRDs7QUFFQTtBQUNBO0FBQ0EsWUFBSSxLQUFLLEtBQUwsS0FBZSxNQUFNLGdCQUF6QixFQUEyQztBQUN6Qyx5QkFBTyxHQUFQLENBQVcsdUNBQVg7QUFDQSxlQUFLLEtBQUwsR0FBYSxNQUFNLFlBQW5CO0FBQ0E7QUFDQTtBQUNBLGVBQUssWUFBTCxDQUFrQixLQUFLLGVBQXZCO0FBQ0E7QUFDQSxlQUFLLGVBQUwsR0FBdUIsSUFBdkI7QUFDRDtBQUNGO0FBQ0Y7Ozs4QkFFUyxhLEVBQWU7QUFDdkIsVUFBSSxLQUFLLE1BQVQsRUFBaUI7QUFDZixZQUFJLGtCQUFrQixLQUFLLGVBQTNCO0FBQ0EsYUFBSyxRQUFMO0FBQ0EsWUFBSSxDQUFDLEtBQUssS0FBVixFQUFpQjtBQUNmLGVBQUssS0FBTCxHQUFhLFlBQVksS0FBSyxNQUFqQixFQUF5QixHQUF6QixDQUFiO0FBQ0Q7QUFDRCxhQUFLLGFBQUwsR0FBcUIsQ0FBckI7QUFDQSxZQUFJLGtCQUFrQixDQUFsQixJQUF1QixrQkFBa0IsQ0FBQyxDQUE5QyxFQUFpRDtBQUMvQyx5QkFBTyxHQUFQLHlEQUFpRSxnQkFBZ0IsT0FBaEIsQ0FBd0IsQ0FBeEIsQ0FBakU7QUFDQSxlQUFLLEtBQUwsR0FBYSxNQUFNLElBQW5CO0FBQ0QsU0FIRCxNQUdPO0FBQ0wsZUFBSyxlQUFMLEdBQXVCLEtBQUssYUFBTCxHQUFxQixLQUFLLGFBQTFCLEdBQTBDLGFBQWpFO0FBQ0EsZUFBSyxLQUFMLEdBQWEsTUFBTSxRQUFuQjtBQUNEO0FBQ0QsYUFBSyxnQkFBTCxHQUF3QixLQUFLLGFBQUwsR0FBcUIsS0FBSyxlQUFsRDtBQUNBLGFBQUssSUFBTDtBQUNELE9BaEJELE1BZ0JPO0FBQ0wsYUFBSyxhQUFMLEdBQXFCLGFBQXJCO0FBQ0EsYUFBSyxLQUFMLEdBQWEsTUFBTSxPQUFuQjtBQUNEO0FBQ0Y7OzsrQkFFVTtBQUNULFVBQUksT0FBTyxLQUFLLFdBQWhCO0FBQ0EsVUFBSSxJQUFKLEVBQVU7QUFDUixZQUFJLEtBQUssTUFBVCxFQUFpQjtBQUNmLGVBQUssTUFBTCxDQUFZLEtBQVo7QUFDRDtBQUNELGFBQUssV0FBTCxHQUFtQixJQUFuQjtBQUNEO0FBQ0QsV0FBSyxZQUFMLEdBQW9CLElBQXBCO0FBQ0EsVUFBSSxLQUFLLE9BQVQsRUFBa0I7QUFDaEIsYUFBSyxPQUFMLENBQWEsT0FBYjtBQUNBLGFBQUssT0FBTCxHQUFlLElBQWY7QUFDRDtBQUNELFdBQUssS0FBTCxHQUFhLE1BQU0sT0FBbkI7QUFDRDs7OzJCQUVNO0FBQ0wsV0FBSyxLQUFMO0FBQ0EsVUFBSSxLQUFLLEtBQUwsS0FBZSxDQUFuQixFQUFzQjtBQUNwQixhQUFLLE1BQUw7QUFDQSxZQUFJLEtBQUssS0FBTCxHQUFhLENBQWpCLEVBQW9CO0FBQ2xCLHFCQUFXLEtBQUssSUFBaEIsRUFBc0IsQ0FBdEI7QUFDRDtBQUNELGFBQUssS0FBTCxHQUFhLENBQWI7QUFDRDtBQUNGOzs7NkJBRVE7QUFBQTs7QUFDUCxVQUFJLEdBQUo7QUFBQSxVQUFTLEtBQVQ7QUFBQSxVQUFnQixZQUFoQjtBQUFBLFVBQThCLE1BQU0sS0FBSyxHQUF6QztBQUFBLFVBQThDLFNBQVMsSUFBSSxNQUEzRDtBQUNBO0FBRk8sVUFpTUMsR0FqTUQ7QUFBQSxVQWtNQyxTQWxNRDtBQUFBLFVBb01DLFNBcE1EOztBQUFBO0FBR1AsZ0JBQU8sT0FBSyxLQUFaO0FBQ0UsZUFBSyxNQUFNLEtBQVg7QUFDRTtBQUNGLGVBQUssTUFBTSxNQUFYO0FBQ0U7QUFDQTtBQUNGLGVBQUssTUFBTSxRQUFYO0FBQ0UsbUJBQUssS0FBTCxHQUFhLE1BQU0sYUFBbkI7QUFDQSxtQkFBSyxjQUFMLEdBQXNCLEtBQXRCO0FBQ0E7QUFDRixlQUFLLE1BQU0sSUFBWDtBQUNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQUksQ0FBQyxPQUFLLEtBQU4sS0FDRCxPQUFLLGtCQUFMLElBQTJCLENBQUMsT0FBTyxpQkFEbEMsQ0FBSixFQUMwRDtBQUN4RDtBQUNEO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsZ0JBQUksT0FBSyxjQUFULEVBQXlCO0FBQ3ZCLG9CQUFNLE9BQUssS0FBTCxDQUFXLFdBQWpCO0FBQ0QsYUFGRCxNQUVPLElBQUksT0FBSyxnQkFBVCxFQUEyQjtBQUNoQyxvQkFBTSxPQUFLLGdCQUFYO0FBQ0QsYUFGTSxNQUVBO0FBQ0wsb0JBQU0sQ0FBTjtBQUNEOztBQUVELGdCQUFJLFFBQVEsT0FBSyxXQUFMLEdBQW1CLE9BQUssV0FBeEIsR0FBc0MsT0FBSyxLQUF2RDtBQUFBLGdCQUNJLGFBQWEsdUJBQWEsVUFBYixDQUF3QixLQUF4QixFQUE4QixHQUE5QixFQUFrQyxPQUFPLGFBQXpDLENBRGpCO0FBQUEsZ0JBRUksWUFBWSxXQUFXLEdBRjNCO0FBQUEsZ0JBR0ksWUFBWSxXQUFXLEdBSDNCO0FBQUEsZ0JBSUksZUFBZSxPQUFLLFlBSnhCO0FBQUEsZ0JBS0ksWUFBWSxPQUFPLGtCQUx2QjtBQUFBLGdCQU1JLGNBQWMsT0FBSyxXQU52Qjs7QUFRQTtBQUNBLGdCQUFJLFlBQVksU0FBWixJQUF5QixPQUFLLE9BQUwsR0FBZSxPQUFLLE1BQUwsQ0FBWSxNQUF4RCxFQUFnRTtBQUM5RCw2QkFBZSxPQUFLLE1BQUwsQ0FBWSxPQUFLLE9BQWpCLEVBQTBCLE9BQXpDO0FBQ0E7QUFDQSxrQkFBSSxPQUFPLFlBQVAsS0FBd0IsV0FBNUIsRUFBeUM7QUFDdkMsdUJBQUssS0FBTCxHQUFhLE1BQU0sYUFBbkI7QUFDQTtBQUNEOztBQUVIO0FBQ0Esa0JBQUksQ0FBQyxXQUFELElBQWdCLENBQUMsYUFBYSxJQUE5QixJQUFzQyxZQUF0QyxJQUFzRCxhQUFhLEVBQWIsS0FBb0IsYUFBYSxLQUEzRixFQUFrRztBQUM5RjtBQUNBO0FBQ0E7QUFDQSxvQkFBSSxDQUFDLE9BQUssS0FBTCxDQUFXLE9BQVosSUFBd0IsT0FBSyxLQUFMLENBQVcsUUFBWCxHQUFvQixTQUFyQixHQUFrQyxhQUFhLFFBQWIsR0FBc0IsQ0FBbkYsRUFBc0Y7QUFDdEY7QUFDQSx5QkFBSyxHQUFMLENBQVMsT0FBVCxDQUFpQixpQkFBTSxVQUF2QixFQUFrQyxFQUFFLE1BQU8sT0FBVCxFQUFsQztBQUNBLHlCQUFLLEtBQUwsR0FBYSxNQUFNLEtBQW5CO0FBQ0E7QUFDRDtBQUNGOztBQUVDO0FBQ0Esa0JBQUksWUFBWSxhQUFhLFNBQTdCO0FBQUEsa0JBQ0ksVUFBVSxVQUFVLE1BRHhCO0FBQUEsa0JBRUksUUFBUSxVQUFVLENBQVYsRUFBYSxLQUZ6QjtBQUFBLGtCQUdJLE1BQU0sVUFBVSxVQUFRLENBQWxCLEVBQXFCLEtBQXJCLEdBQTZCLFVBQVUsVUFBUSxDQUFsQixFQUFxQixRQUg1RDtBQUFBLGtCQUlJLGFBSko7O0FBTUE7QUFDQSxrQkFBRyxXQUFILEVBQWU7QUFDYixvQkFBSSxhQUFhLElBQWIsSUFBcUIsQ0FBQyxhQUFhLFFBQXZDLEVBQWlEO0FBQy9DLGlDQUFPLEdBQVA7QUFDQSw4QkFBWSxDQUFaO0FBQ0QsaUJBSEQsTUFHTztBQUNMLDhCQUFZLEdBQVo7QUFDQTtBQUNBLHNCQUFJLGFBQWEsUUFBYixJQUF5QixNQUFNLEtBQW5DLEVBQTBDO0FBQ3hDO0FBQ0Esd0JBQUksV0FBVyxHQUFYLEdBQWlCLEtBQXJCLEVBQTRCO0FBQzFCLHFDQUFPLEdBQVAsQ0FBVyx1RUFBWDtBQUNBLDZCQUFLLEtBQUwsQ0FBVyxXQUFYLEdBQXlCLFFBQVEsSUFBakM7QUFDRCxxQkFIRCxNQUdPO0FBQ0w7QUFBQTtBQUFBO0FBQ0Q7QUFDRjtBQUNGO0FBQ0Y7O0FBRUQ7QUFDQSxrQkFBSSxZQUFZLEtBQWhCLEVBQXVCO0FBQ3JCLHVCQUFPLFVBQVUsQ0FBVixDQUFQO0FBQ0QsZUFGRCxNQUVPO0FBQUE7QUFDTCxzQkFBSSxrQkFBSjtBQUNBLHNCQUFJLHlCQUF5QixPQUFPLHNCQUFwQztBQUNBLHNCQUFJLFdBQVksWUFBRCxHQUFpQixVQUFVLElBQVYsQ0FBZSxVQUFDLFFBQUQsRUFBYztBQUFFLDJCQUFPLFNBQVMsRUFBVCxLQUFnQixhQUFhLEVBQWIsR0FBa0IsQ0FBekM7QUFBNkMsbUJBQTVFLENBQWpCLEdBQWlHLFNBQWhIO0FBQ0Esc0JBQUksOEJBQThCLFNBQTlCLDJCQUE4QixDQUFDLFNBQUQsRUFBZTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQUksMkJBQTJCLEtBQUssR0FBTCxDQUFTLHNCQUFULEVBQWlDLFVBQVUsUUFBM0MsQ0FBL0I7QUFDQSx3QkFBSyxVQUFVLEtBQVYsR0FBa0IsVUFBVSxRQUE1QixHQUF1Qyx3QkFBeEMsSUFBcUUsU0FBekUsRUFBb0Y7QUFDbEYsNkJBQU8sQ0FBUDtBQUNELHFCQUZELENBRUM7QUFGRCx5QkFHSyxJQUFJLFVBQVUsS0FBVixHQUFrQix3QkFBbEIsR0FBNkMsU0FBN0MsSUFBMEQsVUFBVSxLQUF4RSxFQUErRTtBQUNsRiwrQkFBTyxDQUFDLENBQVI7QUFDRDtBQUNELDJCQUFPLENBQVA7QUFDRCxtQkF2QkQ7O0FBeUJBLHNCQUFJLFlBQVksR0FBaEIsRUFBcUI7QUFDbkIsd0JBQUksWUFBWSxNQUFNLHNCQUF0QixFQUE4QztBQUM1QywrQ0FBeUIsQ0FBekI7QUFDRDtBQUNEO0FBQ0Esd0JBQUksWUFBWSw0QkFBNEIsUUFBNUIsTUFBMEMsQ0FBMUQsRUFBNkQ7QUFDM0Qsa0NBQVksUUFBWjtBQUNELHFCQUZELE1BRU87QUFDTCxrQ0FBWSx1QkFBYSxNQUFiLENBQW9CLFNBQXBCLEVBQStCLDJCQUEvQixDQUFaO0FBQ0Q7QUFDRixtQkFWRCxNQVVPO0FBQ0w7QUFDQSxnQ0FBWSxVQUFVLFVBQVEsQ0FBbEIsQ0FBWjtBQUNEO0FBQ0Qsc0JBQUksU0FBSixFQUFlO0FBQ2IsMkJBQU8sU0FBUDtBQUNBLDRCQUFRLFVBQVUsS0FBbEI7QUFDQTtBQUNBLHdCQUFJLGdCQUFnQixLQUFLLEtBQUwsS0FBZSxhQUFhLEtBQTVDLElBQXFELEtBQUssRUFBTCxLQUFZLGFBQWEsRUFBbEYsRUFBc0Y7QUFDcEYsMEJBQUksS0FBSyxFQUFMLEdBQVUsYUFBYSxLQUEzQixFQUFrQztBQUNoQywrQkFBTyxVQUFVLEtBQUssRUFBTCxHQUFVLENBQVYsR0FBYyxhQUFhLE9BQXJDLENBQVA7QUFDQSx1Q0FBTyxHQUFQLHFDQUE2QyxLQUFLLEVBQWxEO0FBQ0QsdUJBSEQsTUFHTztBQUNMLCtCQUFPLElBQVA7QUFDRDtBQUNGO0FBQ0Y7QUF2REk7QUF3RE47QUFDRCxrQkFBRyxJQUFILEVBQVM7QUFDUDtBQUNBLG9CQUFLLEtBQUssV0FBTCxDQUFpQixHQUFqQixJQUF3QixJQUF6QixJQUFtQyxLQUFLLFdBQUwsQ0FBaUIsR0FBakIsSUFBd0IsSUFBL0QsRUFBc0U7QUFDcEUsaUNBQU8sR0FBUCxzQkFBOEIsS0FBSyxFQUFuQyxhQUE2QyxhQUFhLE9BQTFELFVBQXNFLGFBQWEsS0FBbkYsZ0JBQW1HLE9BQUssT0FBeEc7QUFDQSx5QkFBSyxLQUFMLEdBQWEsTUFBTSxXQUFuQjtBQUNBLHNCQUFJLE9BQUosQ0FBWSxpQkFBTSxXQUFsQixFQUErQixFQUFDLE1BQU0sSUFBUCxFQUEvQjtBQUNELGlCQUpELE1BSU87QUFDTCxpQ0FBTyxHQUFQLGNBQXNCLEtBQUssRUFBM0IsYUFBcUMsYUFBYSxPQUFsRCxVQUE4RCxhQUFhLEtBQTNFLGdCQUEyRixPQUFLLE9BQWhHLHNCQUF3SCxHQUF4SCxtQkFBeUksVUFBVSxPQUFWLENBQWtCLENBQWxCLENBQXpJO0FBQ0E7QUFDQSxzQkFBSSxPQUFLLFdBQUwsS0FBcUIsU0FBekIsRUFBb0M7QUFDbEMsMkJBQUssV0FBTDtBQUNELG1CQUZELE1BRU87QUFDTCwyQkFBSyxXQUFMLEdBQW1CLENBQW5CO0FBQ0Q7QUFDRCxzQkFBSSxLQUFLLFdBQVQsRUFBc0I7QUFDcEIseUJBQUssV0FBTDtBQUNBLHdCQUFJLGVBQWUsT0FBTyx3QkFBMUI7QUFDQTtBQUNBLHdCQUFJLEtBQUssV0FBTCxHQUFtQixZQUFuQixJQUFvQyxLQUFLLEdBQUwsQ0FBUyxPQUFLLFdBQUwsR0FBbUIsS0FBSyxPQUFqQyxJQUE0QyxZQUFwRixFQUFtRztBQUNqRywwQkFBSSxPQUFKLENBQVksaUJBQU0sS0FBbEIsRUFBeUIsRUFBQyxNQUFNLG1CQUFXLFdBQWxCLEVBQStCLFNBQVMscUJBQWEsdUJBQXJELEVBQThFLE9BQU8sS0FBckYsRUFBNEYsTUFBTSxJQUFsRyxFQUF6QjtBQUNBO0FBQUE7QUFBQTtBQUNEO0FBQ0YsbUJBUkQsTUFRTztBQUNMLHlCQUFLLFdBQUwsR0FBbUIsQ0FBbkI7QUFDRDtBQUNELHVCQUFLLE9BQUwsR0FBZSxPQUFLLFdBQXBCO0FBQ0EseUJBQUssV0FBTCxHQUFtQixJQUFuQjtBQUNBLHlCQUFLLGtCQUFMLEdBQTBCLElBQTFCO0FBQ0EseUJBQUssZ0JBQUwsR0FBd0IsS0FBSyxLQUFMLEdBQWEsS0FBSyxRQUExQztBQUNBLHNCQUFJLE9BQUosQ0FBWSxpQkFBTSxZQUFsQixFQUFnQyxFQUFDLE1BQU0sSUFBUCxFQUFoQztBQUNBLHlCQUFLLEtBQUwsR0FBYSxNQUFNLFlBQW5CO0FBQ0Q7QUFDRjtBQUNGO0FBQ0Q7QUFDRixlQUFLLE1BQU0sYUFBWDtBQUNFLG9CQUFRLE9BQUssTUFBTCxDQUFZLE9BQUssT0FBakIsQ0FBUjtBQUNBO0FBQ0EsZ0JBQUksU0FBUyxNQUFNLE9BQW5CLEVBQTRCO0FBQzFCLHFCQUFLLEtBQUwsR0FBYSxNQUFNLElBQW5CO0FBQ0Q7QUFDRDtBQUNGLGVBQUssTUFBTSwwQkFBWDtBQUNNLGtCQUFNLFlBQVksR0FBWixFQURaO0FBRU0sd0JBQVksT0FBSyxTQUZ2Qjs7QUFHRSxvQkFBUSxPQUFLLEtBQWI7QUFDSSx3QkFBWSxTQUFTLE1BQU0sT0FKakM7QUFLRTs7QUFDQSxnQkFBRyxDQUFDLFNBQUQsSUFBZSxPQUFPLFNBQXRCLElBQW9DLFNBQXZDLEVBQWtEO0FBQ2hELDZCQUFPLEdBQVA7QUFDQSxxQkFBSyxLQUFMLEdBQWEsTUFBTSxJQUFuQjtBQUNEO0FBQ0Q7QUFDRixlQUFLLE1BQU0sZ0JBQVg7QUFDQSxlQUFLLE1BQU0sT0FBWDtBQUNBLGVBQUssTUFBTSxZQUFYO0FBQ0EsZUFBSyxNQUFNLE9BQVg7QUFDQSxlQUFLLE1BQU0sTUFBWDtBQUNBLGVBQUssTUFBTSxLQUFYO0FBQ0U7QUFDRjtBQUNFO0FBaE5KO0FBSE87O0FBQUE7QUFxTlI7OztvQ0FFZSxJLEVBQU07QUFDcEIsVUFBSSxRQUFRLEtBQUssS0FBTCxHQUFhLEtBQUssV0FBTCxHQUFtQixLQUFLLEtBQWpEO0FBQ0EsV0FBSyxVQUFMLEdBQWtCLEtBQUssY0FBTCxDQUFvQixJQUFwQixDQUF5QixJQUF6QixDQUFsQjtBQUNBLFdBQUssUUFBTCxHQUFnQixLQUFLLFlBQUwsQ0FBa0IsSUFBbEIsQ0FBdUIsSUFBdkIsQ0FBaEI7QUFDQSxZQUFNLGdCQUFOLENBQXVCLFNBQXZCLEVBQWtDLEtBQUssVUFBdkM7QUFDQSxZQUFNLGdCQUFOLENBQXVCLE9BQXZCLEVBQWdDLEtBQUssUUFBckM7QUFDQSxVQUFJLFNBQVMsS0FBSyxNQUFsQjtBQUNBLFVBQUcsS0FBSyxNQUFMLElBQWUsT0FBTyxhQUF6QixFQUF3QztBQUN0QyxhQUFLLFNBQUwsQ0FBZSxPQUFPLGFBQXRCO0FBQ0Q7QUFDRjs7O3VDQUVrQjtBQUNqQixVQUFJLFFBQVEsS0FBSyxLQUFqQjtBQUNBLFVBQUksU0FBUyxNQUFNLEtBQW5CLEVBQTBCO0FBQ3hCLHVCQUFPLEdBQVAsQ0FBVyxvREFBWDtBQUNBLGFBQUssYUFBTCxHQUFxQixLQUFLLGVBQUwsR0FBdUIsQ0FBNUM7QUFDRDs7QUFFRDtBQUNBLFVBQUksU0FBUyxLQUFLLE1BQWxCO0FBQ0EsVUFBSSxNQUFKLEVBQVk7QUFDVjtBQUNFLGVBQU8sT0FBUCxDQUFlLGlCQUFTO0FBQ3RCLGNBQUcsTUFBTSxPQUFULEVBQWtCO0FBQ2hCLGtCQUFNLE9BQU4sQ0FBYyxTQUFkLENBQXdCLE9BQXhCLENBQWdDLG9CQUFZO0FBQzFDLHVCQUFTLFdBQVQsR0FBdUIsU0FBdkI7QUFDRCxhQUZEO0FBR0Q7QUFDSixTQU5DO0FBT0g7QUFDRDtBQUNBLFVBQUksS0FBSixFQUFXO0FBQ1QsY0FBTSxtQkFBTixDQUEwQixTQUExQixFQUFxQyxLQUFLLFVBQTFDO0FBQ0EsY0FBTSxtQkFBTixDQUEwQixPQUExQixFQUFtQyxLQUFLLFFBQXhDO0FBQ0EsYUFBSyxVQUFMLEdBQWtCLEtBQUssU0FBTCxHQUFrQixLQUFLLFFBQUwsR0FBZ0IsSUFBcEQ7QUFDRDtBQUNELFdBQUssS0FBTCxHQUFhLEtBQUssV0FBTCxHQUFtQixJQUFoQztBQUNBLFdBQUssY0FBTCxHQUFzQixLQUF0QjtBQUNBLFdBQUssUUFBTDtBQUNEOzs7cUNBRWdCO0FBQ2YsVUFBSSxLQUFLLEtBQUwsS0FBZSxNQUFNLEtBQXpCLEVBQWdDO0FBQzVCO0FBQ0EsYUFBSyxLQUFMLEdBQWEsTUFBTSxJQUFuQjtBQUNIO0FBQ0QsVUFBSSxLQUFLLEtBQVQsRUFBZ0I7QUFDZCxhQUFLLGVBQUwsR0FBdUIsS0FBSyxLQUFMLENBQVcsV0FBbEM7QUFDRDtBQUNEO0FBQ0EsVUFBSSxLQUFLLFdBQUwsS0FBcUIsU0FBekIsRUFBb0M7QUFDbEMsYUFBSyxXQUFMLElBQW9CLElBQUksS0FBSyxNQUFMLENBQVksd0JBQXBDO0FBQ0Q7QUFDRDtBQUNBLFdBQUssSUFBTDtBQUNEOzs7bUNBRWM7QUFDYjtBQUNBLFdBQUssYUFBTCxHQUFxQixLQUFLLGVBQUwsR0FBdUIsQ0FBNUM7QUFDRDs7O3lDQUdvQixJLEVBQU07QUFDekIscUJBQU8sR0FBUCxDQUFXLHNCQUFYO0FBQ0EsV0FBSyxNQUFMLEdBQWMsS0FBSyxXQUFuQjtBQUNEOzs7MENBRXFCLEksRUFBTTtBQUMxQjtBQUNBLFVBQUksV0FBVyxDQUFDLENBQUMsS0FBSyxHQUF0QjtBQUNBLFdBQUssT0FBTCxHQUFlLEtBQUssRUFBcEI7QUFDQSxXQUFLLEtBQUwsR0FBYSxNQUFNLElBQW5COztBQUVBLFdBQUssV0FBTCxHQUFtQixJQUFuQjtBQUNBLFdBQUssS0FBTCxHQUFhLE1BQU0sTUFBbkI7QUFDQSxXQUFLLGVBQUwsR0FBcUIsSUFBckI7QUFDQTtBQUNBLFVBQUksQ0FBQyxRQUFMLEVBQWU7QUFDYixZQUFJLEtBQUssT0FBVCxFQUFrQjtBQUNoQixlQUFLLE9BQUwsQ0FBYSxPQUFiO0FBQ0EsZUFBSyxPQUFMLEdBQWUsSUFBZjtBQUNEO0FBQ0YsT0FMRCxNQUtPO0FBQ0w7QUFDQSxZQUFJLENBQUMsS0FBSyxLQUFWLEVBQWlCO0FBQ2YsZUFBSyxLQUFMLEdBQWEsWUFBWSxLQUFLLE1BQWpCLEVBQXlCLEdBQXpCLENBQWI7QUFDRDtBQUNGOztBQUVEO0FBQ0EsVUFBRyxRQUFILEVBQVk7QUFDVixhQUFLLFdBQUwsR0FBbUIsSUFBbkI7QUFDQTtBQUNBLGFBQUssS0FBTCxHQUFXLE1BQU0sSUFBakI7QUFDQTtBQUNBLGFBQUssV0FBTCxJQUFvQixJQUFJLEtBQUssTUFBTCxDQUFZLHdCQUFwQztBQUNEO0FBQ0QsV0FBSyxJQUFMO0FBQ0Q7Ozt1Q0FFa0IsSSxFQUFNO0FBQ3ZCLFVBQUksYUFBYSxLQUFLLE9BQXRCO0FBQUEsVUFDSSxVQUFVLEtBQUssRUFEbkI7QUFBQSxVQUVJLFFBQVEsS0FBSyxNQUFMLENBQVksT0FBWixDQUZaO0FBQUEsVUFHSSxXQUFXLFdBQVcsYUFIMUI7QUFBQSxVQUlJLFVBQVUsQ0FKZDs7QUFNQSxxQkFBTyxHQUFQLFlBQW9CLE9BQXBCLGlCQUF1QyxXQUFXLE9BQWxELFNBQTZELFdBQVcsS0FBeEUsbUJBQTJGLFFBQTNGOztBQUVBLFVBQUksV0FBVyxJQUFmLEVBQXFCO0FBQ25CLFlBQUksYUFBYSxNQUFNLE9BQXZCO0FBQ0EsWUFBSSxjQUFjLFdBQVcsU0FBWCxDQUFxQixNQUFyQixHQUE4QixDQUFoRCxFQUFtRDtBQUNqRDtBQUNBLGdDQUFZLFlBQVosQ0FBeUIsVUFBekIsRUFBb0MsVUFBcEM7QUFDQSxvQkFBVSxXQUFXLFNBQVgsQ0FBcUIsQ0FBckIsRUFBd0IsS0FBbEM7QUFDQTtBQUNBO0FBQ0EsY0FBSSxXQUFXLFFBQWYsRUFBeUI7QUFDdkIsMkJBQU8sR0FBUCxrQ0FBMEMsUUFBUSxPQUFSLENBQWdCLENBQWhCLENBQTFDO0FBQ0QsV0FGRCxNQUVPO0FBQ0wsMkJBQU8sR0FBUCxDQUFXLHFEQUFYO0FBQ0Q7QUFDRixTQVhELE1BV087QUFDTCxxQkFBVyxRQUFYLEdBQXNCLEtBQXRCO0FBQ0EseUJBQU8sR0FBUCxDQUFXLG1EQUFYO0FBQ0Q7QUFDRixPQWpCRCxNQWlCTztBQUNMLG1CQUFXLFFBQVgsR0FBc0IsS0FBdEI7QUFDRDtBQUNELFlBQU0sT0FBTixHQUFnQixVQUFoQjs7QUFFQTtBQUNBLFVBQUksQ0FBQyxLQUFLLGtCQUFWLEVBQThCO0FBQzlCO0FBQ0UsWUFBSSxLQUFLLGFBQUwsS0FBdUIsQ0FBQyxDQUE1QixFQUErQjtBQUM3QjtBQUNBLGNBQUksa0JBQWtCLFdBQVcsZUFBakM7QUFDQSxjQUFHLENBQUMsTUFBTSxlQUFOLENBQUosRUFBNEI7QUFDMUIsMkJBQU8sR0FBUCxtRUFBMkUsZUFBM0U7QUFDQSxpQkFBSyxhQUFMLEdBQXFCLGVBQXJCO0FBQ0QsV0FIRCxNQUdPO0FBQ0wsaUJBQUssYUFBTCxHQUFxQixDQUFyQjtBQUNEO0FBQ0Y7QUFDRCxhQUFLLGdCQUFMLEdBQXdCLEtBQUssYUFBN0I7QUFDRDtBQUNEO0FBQ0EsVUFBSSxLQUFLLEtBQUwsS0FBZSxNQUFNLGFBQXpCLEVBQXdDO0FBQ3RDLGFBQUssS0FBTCxHQUFhLE1BQU0sSUFBbkI7QUFDRDtBQUNEO0FBQ0EsV0FBSyxJQUFMO0FBQ0Q7OztrQ0FFYTtBQUNaLFVBQUksS0FBSyxLQUFMLEtBQWUsTUFBTSxXQUF6QixFQUFzQztBQUNwQyxhQUFLLEtBQUwsR0FBYSxNQUFNLElBQW5CO0FBQ0EsYUFBSyxJQUFMO0FBQ0Q7QUFDRjs7O2lDQUVZLEksRUFBTTtBQUNqQixVQUFJLGNBQWMsS0FBSyxXQUF2QjtBQUNBLFVBQUksS0FBSyxLQUFMLEtBQWUsTUFBTSxZQUFyQixJQUNBLFdBREEsSUFFQSxLQUFLLElBQUwsQ0FBVSxJQUFWLEtBQW1CLE9BRm5CLElBR0EsS0FBSyxJQUFMLENBQVUsS0FBVixLQUFvQixZQUFZLEtBSGhDLElBSUEsS0FBSyxJQUFMLENBQVUsRUFBVixLQUFpQixZQUFZLEVBSmpDLEVBSXFDO0FBQ2pDLGFBQUssS0FBTCxHQUFhLE1BQU0sT0FBbkI7QUFDQTtBQUNBLGFBQUssS0FBTCxHQUFhLEtBQUssS0FBbEI7QUFDQSxZQUFJLFFBQVEsS0FBSyxNQUFMLENBQVksS0FBSyxPQUFqQixDQUFaO0FBQUEsWUFDSSxVQUFVLE1BQU0sT0FEcEI7QUFBQSxZQUVJLFdBQVcsUUFBUSxhQUZ2QjtBQUFBLFlBR0ksUUFBUSxZQUFZLEtBSHhCO0FBQUEsWUFJSSxVQUFVLFlBQVksS0FKMUI7QUFBQSxZQUtJLEtBQUssWUFBWSxFQUxyQjtBQUFBLFlBTUksS0FBSyxZQUFZLEVBTnJCO0FBQUEsWUFPSSxhQUFhLEtBQUssTUFBTCxDQUFZLGlCQUFaLElBQWlDLE1BQU0sVUFQeEQ7QUFRQSxhQUFLLFFBQUwsR0FBZ0IsS0FBaEI7QUFDQSxZQUFHLENBQUMsS0FBSyxPQUFULEVBQWtCO0FBQ2hCLGVBQUssT0FBTCxHQUFlLHNCQUFZLEtBQUssR0FBakIsRUFBcUIsT0FBckIsQ0FBZjtBQUNEO0FBQ0Q7QUFDQTtBQUNBLFlBQUksVUFBVSxLQUFLLE9BQUwsQ0FBYSxFQUFiLENBQWQ7QUFDQSxZQUFJLFlBQVksU0FBaEIsRUFBMEI7QUFDeEIsZUFBSyxnQkFBTCxHQUF3QixDQUFDLENBQXpCO0FBQ0EseUJBQU8sR0FBUCxlQUF1QixFQUF2QixhQUFpQyxRQUFRLE9BQXpDLFVBQXFELFFBQVEsS0FBN0QsZ0JBQTZFLE9BQTdFO0FBQ0E7QUFDQSxjQUFJLHFCQUFxQixLQUF6QixDQUp3QixDQUlRO0FBQ2hDLGVBQUssT0FBTCxDQUFhLElBQWIsQ0FBa0IsS0FBSyxPQUF2QixFQUFnQyxVQUFoQyxFQUE0QyxJQUE1QyxFQUFrRCxLQUFsRCxFQUF5RCxFQUF6RCxFQUE2RCxPQUE3RCxFQUFzRSxFQUF0RSxFQUEwRSxRQUExRSxFQUFvRixZQUFZLFdBQWhHLEVBQTZHLGtCQUE3RyxFQUFpSSxPQUFqSTtBQUNELFNBTkQsTUFNTztBQUNMLHlCQUFPLEdBQVAsK0NBQXVELEVBQXZELDJEQUErRyxFQUEvRyxhQUF5SCxRQUFRLE9BQWpJLFVBQTZJLFFBQVEsS0FBckosZ0JBQXFLLE9BQXJLO0FBQ0EsZUFBSyxlQUFMLEdBQXFCLElBQXJCO0FBQ0EsZUFBSyxLQUFMLEdBQVcsTUFBTSxnQkFBakI7QUFDRDtBQUNKO0FBQ0QsV0FBSyxhQUFMLEdBQXFCLENBQXJCO0FBQ0Q7Ozs2Q0FFd0IsSSxFQUFNO0FBQzdCLFVBQUksY0FBYyxLQUFLLFdBQXZCO0FBQ0EsVUFBSSxlQUNBLEtBQUssRUFBTCxLQUFZLE9BRFosSUFFQSxLQUFLLEVBQUwsS0FBWSxZQUFZLEVBRnhCLElBR0EsS0FBSyxLQUFMLEtBQWUsWUFBWSxLQUgzQixJQUlBLEtBQUssS0FBTCxLQUFlLE1BQU0sT0FKekIsRUFJa0M7QUFDaEMsWUFBSSxTQUFTLEtBQUssTUFBbEI7QUFBQSxZQUEwQixjQUExQjs7QUFFQTtBQUNBLFlBQUksT0FBTyxLQUFYLEVBQWtCO0FBQ2hCLGlCQUFPLE9BQU8sS0FBZDtBQUNEOztBQUVEO0FBQ0EsZ0JBQVEsT0FBTyxLQUFmO0FBQ0EsWUFBRyxLQUFILEVBQVU7QUFDUixnQkFBTSxVQUFOLEdBQW1CLFdBQW5CO0FBQ0EsZ0JBQU0sRUFBTixHQUFXLEtBQUssRUFBaEI7QUFDQSxlQUFLLEdBQUwsQ0FBUyxPQUFULENBQWlCLGlCQUFNLGFBQXZCLEVBQXFDLE1BQXJDO0FBQ0EseUJBQU8sR0FBUCxrQ0FBMEMsTUFBTSxTQUFoRCwrQkFBbUYsTUFBTSxVQUF6RixTQUF1RyxNQUFNLEtBQTdHO0FBQ0EsY0FBSSxjQUFjLE1BQU0sV0FBeEI7QUFDQSxjQUFJLFdBQUosRUFBaUI7QUFDZixnQkFBSSxZQUFZLEVBQUMsTUFBTSxPQUFQLEVBQWdCLE1BQU0sV0FBdEIsRUFBbUMsUUFBUyxPQUE1QyxFQUFvRCxTQUFVLGFBQTlELEVBQWhCO0FBQ0EsZ0JBQUksS0FBSyxXQUFULEVBQXNCO0FBQ3BCLG1CQUFLLFdBQUwsR0FBbUIsQ0FBQyxTQUFELENBQW5CO0FBQ0QsYUFGRCxNQUVPO0FBQ0wsbUJBQUssUUFBTCxHQUFnQixJQUFoQjtBQUNBLG1CQUFLLEdBQUwsQ0FBUyxPQUFULENBQWlCLGlCQUFNLGdCQUF2QixFQUF5QyxTQUF6QztBQUNEO0FBQ0Y7QUFDRDtBQUNBLGVBQUssSUFBTDtBQUNEO0FBQ0Y7QUFDRjs7O3NDQUVpQixJLEVBQU07QUFBQTs7QUFDdEIsVUFBSSxjQUFjLEtBQUssV0FBdkI7QUFDQSxVQUFJLGVBQ0EsS0FBSyxFQUFMLEtBQVksT0FEWixJQUVBLEtBQUssSUFBTCxLQUFjLE9BRmQsSUFHQSxLQUFLLEVBQUwsS0FBWSxZQUFZLEVBSHhCLElBSUEsS0FBSyxLQUFMLEtBQWUsWUFBWSxLQUozQixJQUtBLEtBQUssS0FBTCxLQUFlLE1BQU0sT0FMekIsRUFLa0M7QUFBQTtBQUNoQyxjQUFJLFVBQVMsT0FBSyxPQUFsQjtBQUFBLGNBQ0ksUUFBUSxPQUFLLE1BQUwsQ0FBWSxPQUFaLENBRFo7QUFBQSxjQUVJLE9BQU8sT0FBSyxXQUZoQjtBQUFBLGNBR0ksTUFBTSxPQUFLLEdBSGY7O0FBS0EseUJBQU8sR0FBUCxhQUFxQixLQUFLLElBQTFCLGNBQXVDLEtBQUssUUFBTCxDQUFjLE9BQWQsQ0FBc0IsQ0FBdEIsQ0FBdkMsU0FBbUUsS0FBSyxNQUFMLENBQVksT0FBWixDQUFvQixDQUFwQixDQUFuRSxlQUFtRyxLQUFLLFFBQUwsQ0FBYyxPQUFkLENBQXNCLENBQXRCLENBQW5HLFNBQStILEtBQUssTUFBTCxDQUFZLE9BQVosQ0FBb0IsQ0FBcEIsQ0FBL0gsYUFBNkosS0FBSyxFQUFsSztBQUNBLGdDQUFZLGdCQUFaLENBQTZCLE1BQU0sT0FBbkMsRUFBMkMsS0FBSyxFQUFoRCxFQUFtRCxLQUFLLFFBQXhELEVBQWlFLEtBQUssTUFBdEU7O0FBRUEsY0FBSSxjQUFjLE9BQUssV0FBdkI7QUFBQSxjQUFvQyxRQUFRLE9BQUssS0FBakQ7QUFBQSxjQUF3RCxzQkFBc0IsS0FBOUU7QUFDQTtBQUNBLGNBQUcsZUFBZSxLQUFsQixFQUF5QjtBQUN2QixnQkFBSSxNQUFNLFVBQVYsRUFBc0I7QUFDcEIsa0JBQUksY0FBYyxNQUFNLFdBQXhCO0FBQ0EsNkJBQU8sR0FBUCxDQUFXLHlDQUF3QyxXQUFuRDtBQUNBLGtCQUFJLGVBQWUsS0FBSyxRQUF4QixFQUFrQztBQUNoQywrQkFBTyxHQUFQLENBQVcsNENBQVg7QUFDRSxvQkFBSSxPQUFKLENBQVksaUJBQU0sZUFBbEIsRUFBbUMsRUFBQyxhQUFhLENBQWQsRUFBa0IsV0FBVyxPQUFPLGlCQUFwQyxFQUF1RCxNQUFPLE9BQTlELEVBQW5DO0FBQ0Esc0NBQXNCLElBQXRCO0FBQ0E7QUFDQSx1QkFBSyxXQUFMLEdBQW1CLEtBQW5CO0FBQ0Esb0JBQUksT0FBSixDQUFZLGlCQUFNLG9CQUFsQixFQUF3QyxFQUFDLElBQUssT0FBTixFQUF4QztBQUNIO0FBQ0YsYUFYRCxNQVdPO0FBQ0w7QUFDQSxxQkFBSyxXQUFMLEdBQWlCLEtBQWpCO0FBQ0Esa0JBQUksT0FBSixDQUFZLGlCQUFNLG9CQUFsQixFQUF3QyxFQUFDLElBQUssT0FBTixFQUF4QztBQUNEO0FBQ0Y7O0FBR0QsY0FBSSxjQUFjLE9BQUssV0FBdkI7QUFDQSxjQUFHLENBQUMsT0FBSyxXQUFULEVBQXNCO0FBQ3BCLGFBQUMsS0FBSyxLQUFOLEVBQWEsS0FBSyxLQUFsQixFQUF5QixPQUF6QixDQUFpQyxrQkFBVTtBQUN6QyxrQkFBSSxNQUFKLEVBQVk7QUFDViw0QkFBWSxJQUFaLENBQWlCLEVBQUMsTUFBTSxLQUFLLElBQVosRUFBa0IsTUFBTSxNQUF4QixFQUFnQyxRQUFTLE9BQXpDLEVBQWlELFNBQVUsTUFBM0QsRUFBakI7QUFDRDtBQUNGLGFBSkQ7QUFLRixnQkFBSSxDQUFDLG1CQUFELElBQXdCLFlBQVksTUFBeEMsRUFBZ0Q7QUFDNUMsMEJBQVksT0FBWixDQUFvQixxQkFBYTtBQUMvQix1QkFBSyxHQUFMLENBQVMsT0FBVCxDQUFpQixpQkFBTSxnQkFBdkIsRUFBeUMsU0FBekM7QUFDRCxlQUZEO0FBR0EscUJBQUssV0FBTCxHQUFtQixFQUFuQjtBQUNBLHFCQUFLLFFBQUwsR0FBZ0IsSUFBaEI7QUFDRDtBQUNGO0FBQ0Q7QUFDQSxpQkFBSyxJQUFMO0FBL0NnQztBQWdEakM7QUFDRjs7O2lDQUVZLEksRUFBTTtBQUNqQixVQUFJLGNBQWMsS0FBSyxXQUF2QjtBQUNBLFVBQUksZUFDQSxLQUFLLEVBQUwsS0FBWSxPQURaLElBRUEsS0FBSyxFQUFMLEtBQVksWUFBWSxFQUZ4QixJQUdBLEtBQUssS0FBTCxLQUFlLFlBQVksS0FIM0IsSUFJQSxLQUFLLEtBQUwsS0FBZSxNQUFNLE9BSnpCLEVBSWtDO0FBQ2hDLGFBQUssS0FBTCxDQUFXLE9BQVgsR0FBcUIsWUFBWSxHQUFaLEVBQXJCO0FBQ0EsYUFBSyxLQUFMLEdBQWEsTUFBTSxNQUFuQjtBQUNBLGFBQUssb0JBQUw7QUFDRDtBQUNGOzs7b0NBR2UsSSxFQUFNO0FBQ3BCLFVBQUksYUFBYSxLQUFLLE1BQUwsQ0FBWSxLQUE3QjtBQUNBLFVBQUksVUFBSixFQUFnQjtBQUNkLGFBQUssV0FBTCxHQUFtQixXQUFXLE1BQTlCO0FBQ0EsYUFBSyxjQUFMLEdBQXNCLElBQXRCO0FBQ0Q7QUFDRjs7O3FDQUVnQixJLEVBQU07QUFDckIsVUFBSSxLQUFLLE1BQUwsS0FBZ0IsT0FBcEIsRUFBNkI7QUFDM0IsWUFBTSxRQUFRLEtBQUssS0FBbkI7QUFDQSxZQUFJLFVBQVUsTUFBTSxPQUFoQixJQUEyQixVQUFVLE1BQU0sTUFBL0MsRUFBdUQ7QUFDckQsZUFBSyxnQkFBTCxHQUF3QixLQUFLLE9BQTdCO0FBQ0EsZUFBSyxvQkFBTDtBQUNEO0FBQ0Y7QUFDRjs7OzJDQUVzQjtBQUNyQjtBQUNBLFVBQUksS0FBSyxLQUFMLEtBQWUsTUFBTSxNQUFyQixLQUFnQyxDQUFDLEtBQUssUUFBTixJQUFrQixLQUFLLGdCQUFMLEtBQTBCLENBQTVFLENBQUosRUFBc0Y7QUFDcEYsWUFBSSxPQUFPLEtBQUssV0FBaEI7QUFBQSxZQUE2QixRQUFRLEtBQUssS0FBMUM7QUFBQSxZQUFpRCxNQUFNLEtBQUssR0FBNUQ7QUFDQSxZQUFJLElBQUosRUFBVTtBQUNSLGVBQUssWUFBTCxHQUFvQixJQUFwQjtBQUNBLGdCQUFNLFNBQU4sR0FBa0IsWUFBWSxHQUFaLEVBQWxCO0FBQ0EsY0FBSSxPQUFKLENBQVksaUJBQU0sYUFBbEIsRUFBaUMsRUFBQyxPQUFPLEtBQVIsRUFBZSxNQUFNLElBQXJCLEVBQTJCLElBQUssT0FBaEMsRUFBakM7QUFDQSxjQUFJLFFBQVEsS0FBSyxXQUFMLEdBQW1CLEtBQUssV0FBeEIsR0FBc0MsS0FBSyxLQUF2RDtBQUNBLHlCQUFPLEdBQVAsdUJBQStCLHFCQUFXLFFBQVgsQ0FBb0IsTUFBTSxRQUExQixDQUEvQjtBQUNBLGNBQUksS0FBSyxXQUFMLElBQW9CLEtBQUssUUFBN0IsRUFBdUM7QUFDckMsaUJBQUssV0FBTCxHQUFtQixLQUFuQjtBQUNBLGdCQUFJLE9BQUosQ0FBWSxpQkFBTSxvQkFBbEIsRUFBd0MsRUFBQyxJQUFLLEtBQUssT0FBWCxFQUF4QztBQUNEO0FBQ0QsZUFBSyxLQUFMLEdBQWEsTUFBTSxJQUFuQjtBQUNEO0FBQ0QsYUFBSyxJQUFMO0FBQ0Q7QUFDRjs7OzRCQUVPLEksRUFBTTtBQUNaLFVBQUksT0FBTyxLQUFLLElBQWhCO0FBQ0E7QUFDQSxVQUFJLFFBQVEsS0FBSyxJQUFMLEtBQWMsT0FBMUIsRUFBbUM7QUFDakM7QUFDRDtBQUNELGNBQU8sS0FBSyxPQUFaO0FBQ0UsYUFBSyxxQkFBYSxlQUFsQjtBQUNBLGFBQUsscUJBQWEsaUJBQWxCO0FBQ0UsY0FBRyxDQUFDLEtBQUssS0FBVCxFQUFnQjtBQUNkLGdCQUFJLFlBQVksS0FBSyxhQUFyQjtBQUNBLGdCQUFHLFNBQUgsRUFBYztBQUNaO0FBQ0QsYUFGRCxNQUVPO0FBQ0wsMEJBQVUsQ0FBVjtBQUNEO0FBQ0QsZ0JBQUksU0FBUyxLQUFLLE1BQWxCO0FBQ0EsZ0JBQUksYUFBYSxPQUFPLG1CQUF4QixFQUE2QztBQUMzQyxtQkFBSyxhQUFMLEdBQXFCLFNBQXJCO0FBQ0E7QUFDQSxtQkFBSyxXQUFMLEdBQW1CLENBQW5CO0FBQ0E7QUFDQSxrQkFBSSxRQUFRLEtBQUssR0FBTCxDQUFTLEtBQUssR0FBTCxDQUFTLENBQVQsRUFBVyxZQUFVLENBQXJCLElBQXdCLE9BQU8scUJBQXhDLEVBQThELE9BQU8sMEJBQXJFLENBQVo7QUFDQSw2QkFBTyxJQUFQLDJEQUFvRSxLQUFwRTtBQUNBLG1CQUFLLFNBQUwsR0FBaUIsWUFBWSxHQUFaLEtBQW9CLEtBQXJDO0FBQ0E7QUFDQSxtQkFBSyxLQUFMLEdBQWEsTUFBTSwwQkFBbkI7QUFDRCxhQVZELE1BVU87QUFDTCw2QkFBTyxLQUFQLDZCQUF1QyxLQUFLLE9BQTVDO0FBQ0E7QUFDQSxtQkFBSyxLQUFMLEdBQWEsSUFBYjtBQUNBLG1CQUFLLEdBQUwsQ0FBUyxPQUFULENBQWlCLGlCQUFNLEtBQXZCLEVBQThCLElBQTlCO0FBQ0EsbUJBQUssS0FBTCxHQUFhLE1BQU0sS0FBbkI7QUFDRDtBQUNGO0FBQ0Q7QUFDRixhQUFLLHFCQUFhLHVCQUFsQjtBQUNBLGFBQUsscUJBQWEsc0JBQWxCO0FBQ0EsYUFBSyxxQkFBYSx3QkFBbEI7QUFDQSxhQUFLLHFCQUFhLGNBQWxCO0FBQ0EsYUFBSyxxQkFBYSxnQkFBbEI7QUFDRTtBQUNBLGNBQUcsS0FBSyxLQUFMLEtBQWUsTUFBTSxLQUF4QixFQUErQjtBQUMzQjtBQUNBLGlCQUFLLEtBQUwsR0FBYSxLQUFLLEtBQUwsR0FBYSxNQUFNLEtBQW5CLEdBQTJCLE1BQU0sSUFBOUM7QUFDQSwyQkFBTyxJQUFQLDZCQUFzQyxLQUFLLE9BQTNDLHNDQUFtRixLQUFLLEtBQXhGO0FBQ0g7QUFDRDtBQUNGO0FBQ0U7QUEzQ0o7QUE2Q0Q7OztzQ0FFaUI7QUFBQTs7QUFDaEIsVUFBSSxjQUFjLEtBQUssV0FBdkI7QUFDQSxVQUFJLGVBQWUsWUFBWSxNQUEvQixFQUF1QztBQUNyQyx1QkFBTyxHQUFQLENBQVcsZ0RBQVg7QUFDQSxvQkFBWSxPQUFaLENBQW9CLHFCQUFhO0FBQy9CLGlCQUFLLEdBQUwsQ0FBUyxPQUFULENBQWlCLGlCQUFNLGdCQUF2QixFQUF5QyxTQUF6QztBQUNELFNBRkQ7QUFHQSxhQUFLLFFBQUwsR0FBZ0IsSUFBaEI7QUFDQSxhQUFLLFdBQUwsR0FBbUIsRUFBbkI7QUFDQSxhQUFLLEtBQUwsR0FBYSxNQUFNLE1BQW5CO0FBQ0QsT0FSRCxNQVFPO0FBQ0w7QUFDQSxhQUFLLEtBQUwsR0FBYSxNQUFNLElBQW5CO0FBQ0E7QUFDQSxhQUFLLFlBQUwsR0FBb0IsSUFBcEI7QUFDQSxhQUFLLElBQUw7QUFDRDtBQUNGOzs7Ozs7a0JBRVkscUI7Ozs7Ozs7Ozs7O0FDdHdCZjs7OztBQUNBOzs7O0FBQ0E7Ozs7Ozs7OytlQU5BOzs7O0lBUU0sb0I7OztBQUVKLGdDQUFZLEdBQVosRUFBaUI7QUFBQTs7QUFBQSw0SUFDVCxHQURTLEVBQ0osaUJBQU0sZ0JBREYsRUFFSixpQkFBTSxlQUZGLEVBR0osaUJBQU0sa0JBSEY7O0FBSWYsVUFBSyxLQUFMLEdBQWEsQ0FBYjtBQUNBLFVBQUssTUFBTCxHQUFjLE1BQUssSUFBTCxDQUFVLElBQVYsT0FBZDtBQUxlO0FBTWhCOzs7OzhCQUVTO0FBQ1IsNkJBQWEsU0FBYixDQUF1QixPQUF2QixDQUErQixJQUEvQixDQUFvQyxJQUFwQztBQUNEOzs7MkJBQ007QUFDTCxXQUFLLEtBQUw7QUFDQSxVQUFJLEtBQUssS0FBTCxLQUFlLENBQW5CLEVBQXNCO0FBQ3BCLGFBQUssTUFBTDtBQUNBLFlBQUksS0FBSyxLQUFMLEdBQWEsQ0FBakIsRUFBb0I7QUFDbEIscUJBQVcsS0FBSyxJQUFoQixFQUFzQixDQUF0QjtBQUNEO0FBQ0QsYUFBSyxLQUFMLEdBQWEsQ0FBYjtBQUNEO0FBQ0Y7Ozs2QkFDUTtBQUNQLFdBQUssV0FBTCxDQUFpQixLQUFLLE9BQXRCO0FBQ0Q7Ozt3Q0FDbUI7QUFDbEI7QUFDQSxXQUFLLE1BQUwsR0FBYyxFQUFkO0FBQ0EsV0FBSyxPQUFMLEdBQWUsQ0FBQyxDQUFoQjtBQUNEOzs7cUNBRWdCLEksRUFBTTtBQUFBOztBQUNyQixVQUFJLFNBQVMsS0FBSyxXQUFMLElBQW9CLEVBQWpDO0FBQ0EsVUFBSSxlQUFlLEtBQW5CO0FBQ0EsV0FBSyxNQUFMLEdBQWMsTUFBZDtBQUNBLFdBQUssR0FBTCxDQUFTLE9BQVQsQ0FBaUIsaUJBQU0sb0JBQXZCLEVBQTZDLEVBQUMsYUFBYyxNQUFmLEVBQTdDO0FBQ0E7QUFDQSxVQUFJLEtBQUssQ0FBVDtBQUNBLGFBQU8sT0FBUCxDQUFlLGlCQUFTO0FBQ3RCLFlBQUcsTUFBTSxPQUFULEVBQWtCO0FBQ2hCLGlCQUFLLFVBQUwsR0FBa0IsRUFBbEI7QUFDQSx5QkFBZSxJQUFmO0FBQ0E7QUFDRDtBQUNEO0FBQ0QsT0FQRDtBQVFBLFVBQUksaUJBQWlCLEtBQWpCLElBQTBCLE9BQU8sTUFBckMsRUFBNkM7QUFDM0MsdUJBQU8sR0FBUCxDQUFXLGtFQUFYO0FBQ0EsYUFBSyxVQUFMLEdBQWtCLENBQWxCO0FBQ0Q7QUFDRjs7O3VDQUVrQixJLEVBQU07QUFDdkIsVUFBSSxLQUFLLEVBQUwsR0FBVSxLQUFLLE1BQUwsQ0FBWSxNQUExQixFQUFrQztBQUNoQyx1QkFBTyxHQUFQLGlCQUF5QixLQUFLLEVBQTlCO0FBQ0EsYUFBSyxNQUFMLENBQVksS0FBSyxFQUFqQixFQUFxQixPQUFyQixHQUErQixLQUFLLE9BQXBDO0FBQ0E7QUFDQSxZQUFJLEtBQUssT0FBTCxDQUFhLElBQWIsSUFBcUIsQ0FBQyxLQUFLLEtBQS9CLEVBQXNDO0FBQ3BDO0FBQ0E7QUFDQSxlQUFLLEtBQUwsR0FBYSxZQUFZLEtBQUssTUFBakIsRUFBeUIsT0FBTyxLQUFLLE9BQUwsQ0FBYSxjQUE3QyxDQUFiO0FBQ0Q7QUFDRCxZQUFJLENBQUMsS0FBSyxPQUFMLENBQWEsSUFBZCxJQUFzQixLQUFLLEtBQS9CLEVBQXNDO0FBQ3BDO0FBQ0Esd0JBQWMsS0FBSyxLQUFuQjtBQUNBLGVBQUssS0FBTCxHQUFhLElBQWI7QUFDRDtBQUNGO0FBQ0Y7O0FBRUQ7Ozs7MENBaUJxQixLLEVBQU87QUFDMUI7QUFDQSxVQUFJLFNBQVMsQ0FBVCxJQUFjLFFBQVEsS0FBSyxNQUFMLENBQVksTUFBdEMsRUFBOEM7QUFDNUM7QUFDQSxZQUFJLEtBQUssS0FBVCxFQUFnQjtBQUNmLHdCQUFjLEtBQUssS0FBbkI7QUFDQSxlQUFLLEtBQUwsR0FBYSxJQUFiO0FBQ0E7QUFDRCxhQUFLLE9BQUwsR0FBZSxLQUFmO0FBQ0EsdUJBQU8sR0FBUCw4QkFBc0MsS0FBdEM7QUFDQSxZQUFJLGFBQWEsS0FBSyxNQUFMLENBQVksS0FBWixDQUFqQjtBQUFBLFlBQ0ksTUFBTSxLQUFLLEdBRGY7QUFBQSxZQUVJLE9BQU8sV0FBVyxJQUZ0QjtBQUFBLFlBR0ksTUFBTSxXQUFXLEdBSHJCO0FBQUEsWUFJSSxXQUFXLEVBQUMsSUFBSSxLQUFMLEVBQVksTUFBTyxJQUFuQixFQUF5QixLQUFNLEdBQS9CLEVBSmY7QUFLQTtBQUNBLFlBQUksT0FBSixDQUFZLGlCQUFNLGtCQUFsQixFQUFzQyxRQUF0QztBQUNBLFlBQUksT0FBSixDQUFZLGlCQUFNLHFCQUFsQixFQUF5QyxRQUF6QztBQUNDO0FBQ0EsWUFBSSxVQUFVLFdBQVcsT0FBekI7QUFDRCxZQUFJLFFBQVEsWUFBWSxTQUFaLElBQXlCLFFBQVEsSUFBUixLQUFpQixJQUFsRCxDQUFKLEVBQTZEO0FBQzNEO0FBQ0EseUJBQU8sR0FBUCwwQ0FBa0QsS0FBbEQ7QUFDQSxjQUFJLE9BQUosQ0FBWSxpQkFBTSxtQkFBbEIsRUFBdUMsRUFBQyxLQUFLLEdBQU4sRUFBVyxJQUFJLEtBQWYsRUFBdkM7QUFDRDtBQUNGO0FBQ0Y7OztnQ0FFVyxLLEVBQU87QUFDakI7QUFDQSxVQUFJLFNBQVMsQ0FBVCxJQUFjLFFBQVEsS0FBSyxNQUFMLENBQVksTUFBdEMsRUFBOEM7QUFDNUM7QUFDQSxZQUFJLEtBQUssS0FBVCxFQUFnQjtBQUNmLHdCQUFjLEtBQUssS0FBbkI7QUFDQSxlQUFLLEtBQUwsR0FBYSxJQUFiO0FBQ0E7QUFDRCxhQUFLLE9BQUwsR0FBZSxLQUFmO0FBQ0EsdUJBQU8sR0FBUCwwQkFBa0MsS0FBbEM7QUFDQSxZQUFJLGFBQWEsS0FBSyxNQUFMLENBQVksS0FBWixDQUFqQjtBQUFBLFlBQXFDLE1BQU0sV0FBVyxHQUF0RDtBQUNDO0FBQ0EsWUFBSSxVQUFVLFdBQVcsT0FBekI7QUFDRCxZQUFJLFFBQVEsWUFBWSxTQUFaLElBQXlCLFFBQVEsSUFBUixLQUFpQixJQUFsRCxDQUFKLEVBQTZEO0FBQzNEO0FBQ0EseUJBQU8sR0FBUCwwQ0FBa0QsS0FBbEQ7QUFDQSxlQUFLLEdBQUwsQ0FBUyxPQUFULENBQWlCLGlCQUFNLG1CQUF2QixFQUE0QyxFQUFDLEtBQUssR0FBTixFQUFXLElBQUksS0FBZixFQUE1QztBQUNEO0FBQ0Y7QUFDRjs7O3dCQS9EaUI7QUFDaEIsYUFBTyxLQUFLLE1BQVo7QUFDRDs7QUFFRDs7Ozt3QkFDaUI7QUFDaEIsYUFBTyxLQUFLLE9BQVo7QUFDQTs7QUFFRDs7c0JBQ2UsWSxFQUFjO0FBQzNCLFVBQUksS0FBSyxPQUFMLEtBQWlCLFlBQWpCLElBQWlDLEtBQUssTUFBTCxDQUFZLFlBQVosRUFBMEIsT0FBMUIsS0FBc0MsU0FBM0UsRUFBc0Y7QUFDcEYsYUFBSyxxQkFBTCxDQUEyQixZQUEzQjtBQUNEO0FBQ0Y7Ozs7OztrQkFvRFksb0I7Ozs7Ozs7Ozs7O0FDOUlmOzs7O0FBQ0E7Ozs7QUFDQTs7QUFDQTs7Ozs7Ozs7K2VBUEE7Ozs7SUFVTSxnQjs7O0FBRUosNEJBQVksR0FBWixFQUFpQjtBQUFBOztBQWFmO0FBQ0E7QUFkZSxvSUFDVCxHQURTLEVBRWIsaUJBQU0sZUFGTyxFQUdiLGlCQUFNLGVBSE8sRUFJYixpQkFBTSxlQUpPLEVBS2IsaUJBQU0sWUFMTyxFQU1iLGlCQUFNLGdCQU5PLEVBT2IsaUJBQU0sYUFQTyxFQVFiLGlCQUFNLFVBUk8sRUFTYixpQkFBTSxlQVRPLEVBVWIsaUJBQU0saUJBVk8sRUFXYixpQkFBTSxhQVhPOztBQWVmLFVBQUssV0FBTCxHQUFtQixJQUFuQjtBQUNBO0FBQ0EsVUFBSyxjQUFMLEdBQXNCLElBQXRCOztBQUVBO0FBQ0EsVUFBSyxNQUFMLEdBQWMsTUFBSyxhQUFMLENBQW1CLElBQW5CLE9BQWQ7QUFDQSxVQUFLLEtBQUwsR0FBYyxNQUFLLGVBQUwsQ0FBcUIsSUFBckIsT0FBZDtBQUNBLFVBQUssYUFBTCxHQUFxQixFQUFyQjtBQUNBLFVBQUssTUFBTCxHQUFjLEVBQWQ7QUF2QmU7QUF3QmhCOzs7OzhCQUVTO0FBQ1IsNkJBQWEsU0FBYixDQUF1QixPQUF2QixDQUErQixJQUEvQixDQUFvQyxJQUFwQztBQUNEOzs7c0NBRWlCLEksRUFBTTtBQUN0QixVQUFJLE9BQU8sS0FBSyxJQUFoQjtBQUNBLFVBQUksYUFBYSxLQUFLLE1BQUwsQ0FBWSxLQUE3Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBSSxTQUFTLE9BQVQsSUFBb0IsVUFBcEIsSUFBa0MsV0FBVyxTQUFYLEtBQXlCLFlBQS9ELEVBQTZFO0FBQUU7QUFDN0UsWUFBSSxjQUFjLEtBQUssWUFBTCxDQUFrQixLQUFwQztBQUNBLFlBQUksUUFBUSxLQUFLLEdBQUwsQ0FBUyxZQUFZLGVBQVosR0FBOEIsS0FBSyxLQUE1QyxDQUFaOztBQUVBO0FBQ0EsWUFBSSxRQUFRLEdBQVosRUFBaUI7QUFDZixjQUFJLFdBQVcsWUFBWSxRQUEzQjs7QUFFQSxjQUFJO0FBQ0Ysd0JBQVksS0FBWjtBQUNELFdBRkQsQ0FFRSxPQUFPLEdBQVAsRUFBWTtBQUNaLHVCQUFXLElBQVg7QUFDQSwyQkFBTyxJQUFQLENBQVksaUNBQWlDLEdBQTdDO0FBQ0Q7O0FBRUQsY0FBSSxDQUFDLFFBQUwsRUFBZTtBQUNiLDJCQUFPLElBQVAsQ0FBWSw2Q0FBNkMsWUFBWSxlQUF6RCxHQUEyRSxNQUEzRSxHQUFvRixLQUFLLEtBQXJHO0FBQ0Esd0JBQVksZUFBWixHQUE4QixLQUFLLEtBQW5DO0FBQ0QsV0FIRCxNQUdPO0FBQ0wsaUJBQUssb0JBQUwsR0FBNEIsS0FBSyxLQUFqQztBQUNEO0FBQ0Y7QUFDRjtBQUNGOzs7cUNBRWdCLEksRUFBTTtBQUNyQixVQUFJLGdCQUFnQixLQUFLLEtBQXpCO0FBQUEsVUFDSSxnQkFBZ0IsS0FBSyxLQUR6QjtBQUFBLFVBRUksaUJBQWlCLENBRnJCO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFJLEtBQUssUUFBTCxLQUFrQixpQkFBaUIsYUFBbkMsQ0FBSixFQUF1RDtBQUNyRCx5QkFBaUIsQ0FBQyxnQkFBZ0IsQ0FBaEIsR0FBb0IsQ0FBckIsS0FBMkIsZ0JBQWdCLENBQWhCLEdBQW9CLENBQS9DLENBQWpCO0FBQ0EsdUJBQU8sR0FBUCxDQUFjLGNBQWQ7QUFDRDtBQUNELFdBQUssY0FBTCxHQUFzQixjQUF0QjtBQUNEOzs7cUNBRWdCLEksRUFBTTtBQUNyQixVQUFJLFFBQVEsS0FBSyxLQUFMLEdBQWEsS0FBSyxLQUE5QjtBQUNBLFVBQUksS0FBSixFQUFXO0FBQ1Q7QUFDQSxZQUFJLEtBQUssS0FBSyxXQUFMLEdBQW1CLElBQUksV0FBSixFQUE1QjtBQUNBO0FBQ0EsYUFBSyxLQUFMLEdBQWEsS0FBSyxpQkFBTCxDQUF1QixJQUF2QixDQUE0QixJQUE1QixDQUFiO0FBQ0EsYUFBSyxLQUFMLEdBQWEsS0FBSyxrQkFBTCxDQUF3QixJQUF4QixDQUE2QixJQUE3QixDQUFiO0FBQ0EsYUFBSyxLQUFMLEdBQWEsS0FBSyxrQkFBTCxDQUF3QixJQUF4QixDQUE2QixJQUE3QixDQUFiO0FBQ0EsV0FBRyxnQkFBSCxDQUFvQixZQUFwQixFQUFrQyxLQUFLLEtBQXZDO0FBQ0EsV0FBRyxnQkFBSCxDQUFvQixhQUFwQixFQUFtQyxLQUFLLEtBQXhDO0FBQ0EsV0FBRyxnQkFBSCxDQUFvQixhQUFwQixFQUFtQyxLQUFLLEtBQXhDO0FBQ0E7QUFDQSxjQUFNLEdBQU4sR0FBWSxJQUFJLGVBQUosQ0FBb0IsRUFBcEIsQ0FBWjtBQUNEO0FBQ0Y7Ozt1Q0FFa0I7QUFDakIscUJBQU8sR0FBUCxDQUFXLHdCQUFYO0FBQ0EsVUFBSSxLQUFLLEtBQUssV0FBZDtBQUNBLFVBQUksRUFBSixFQUFRO0FBQ04sWUFBSSxHQUFHLFVBQUgsS0FBa0IsTUFBdEIsRUFBOEI7QUFDNUIsY0FBSTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBRyxXQUFIO0FBQ0QsV0FORCxDQU1FLE9BQU0sR0FBTixFQUFXO0FBQ1gsMkJBQU8sSUFBUCx1QkFBZ0MsSUFBSSxPQUFwQztBQUNEO0FBQ0Y7QUFDRCxXQUFHLG1CQUFILENBQXVCLFlBQXZCLEVBQXFDLEtBQUssS0FBMUM7QUFDQSxXQUFHLG1CQUFILENBQXVCLGFBQXZCLEVBQXNDLEtBQUssS0FBM0M7QUFDQSxXQUFHLG1CQUFILENBQXVCLGFBQXZCLEVBQXNDLEtBQUssS0FBM0M7O0FBRUE7QUFDQTtBQUNBLFlBQUksS0FBSyxLQUFULEVBQWdCO0FBQ2QsY0FBSSxlQUFKLENBQW9CLEtBQUssS0FBTCxDQUFXLEdBQS9CO0FBQ0EsZUFBSyxLQUFMLENBQVcsZUFBWCxDQUEyQixLQUEzQjtBQUNBLGVBQUssS0FBTCxDQUFXLElBQVg7QUFDRDs7QUFFRCxhQUFLLFdBQUwsR0FBbUIsSUFBbkI7QUFDQSxhQUFLLEtBQUwsR0FBYSxJQUFiO0FBQ0EsYUFBSyxhQUFMLEdBQXFCLEVBQXJCO0FBQ0EsYUFBSyxNQUFMLEdBQWMsRUFBZDtBQUNBLGFBQUssWUFBTCxHQUFvQixFQUFwQjtBQUNBLGFBQUssVUFBTCxHQUFrQixFQUFsQjtBQUNBLGFBQUssUUFBTCxHQUFnQixFQUFoQjtBQUNBLGFBQUssUUFBTCxHQUFnQixDQUFoQjtBQUNEO0FBQ0QsV0FBSyxLQUFMLEdBQWEsS0FBSyxLQUFMLEdBQWEsS0FBSyxLQUFMLEdBQWEsSUFBdkM7QUFDQSxXQUFLLEdBQUwsQ0FBUyxPQUFULENBQWlCLGlCQUFNLGNBQXZCO0FBQ0Q7Ozt3Q0FFbUI7QUFDbEIscUJBQU8sR0FBUCxDQUFXLHFCQUFYO0FBQ0EsV0FBSyxHQUFMLENBQVMsT0FBVCxDQUFpQixpQkFBTSxjQUF2QixFQUF1QyxFQUFFLE9BQVEsS0FBSyxLQUFmLEVBQXZDO0FBQ0EsVUFBSSxjQUFjLEtBQUssV0FBdkI7QUFDQSxVQUFJLFdBQUosRUFBaUI7QUFDZjtBQUNBLG9CQUFZLG1CQUFaLENBQWdDLFlBQWhDLEVBQThDLEtBQUssS0FBbkQ7QUFDRDtBQUNELFdBQUssa0JBQUw7QUFDRDs7O3lDQUVvQjtBQUNuQjtBQUNBLFVBQUksZ0JBQWdCLEtBQUssYUFBekI7QUFBQSxVQUNJLGtCQUFrQixPQUFPLElBQVAsQ0FBWSxhQUFaLEVBQTJCLE1BRGpEO0FBRUE7QUFDQSxVQUFJLG9CQUNBLEtBQUssY0FBTCxJQUF1QixlQUF2QixJQUNBLEtBQUssY0FBTCxLQUF3QixDQUZ4QixDQUFKLEVBRWdDO0FBQzlCO0FBQ0EsYUFBSyxtQkFBTCxDQUF5QixhQUF6QjtBQUNBLGFBQUssYUFBTCxHQUFxQixFQUFyQjtBQUNBO0FBQ0EsYUFBSyxXQUFMO0FBQ0Q7QUFDRjs7O3lDQUVvQjtBQUNuQixxQkFBTyxHQUFQLENBQVcscUJBQVg7QUFDRDs7O3lDQUVvQjtBQUNuQixxQkFBTyxHQUFQLENBQVcsb0JBQVg7QUFDRDs7O29DQUdlO0FBQ2Q7QUFDQSxVQUFJLEtBQUssb0JBQVQsRUFBK0I7QUFDN0IsWUFBSSxjQUFjLEtBQUssWUFBTCxDQUFrQixLQUFwQztBQUNBLHVCQUFPLElBQVAsQ0FBWSw2Q0FBNkMsWUFBWSxlQUF6RCxHQUEyRSxNQUEzRSxHQUFvRixLQUFLLG9CQUFyRztBQUNBLG9CQUFZLGVBQVosR0FBOEIsS0FBSyxvQkFBbkM7QUFDQSxlQUFPLEtBQUssb0JBQVo7QUFDRDs7QUFFRCxVQUFJLEtBQUssV0FBVCxFQUFzQjtBQUNwQixhQUFLLE9BQUw7QUFDRDs7QUFFRCxVQUFJLEtBQUssU0FBVCxFQUFvQjtBQUNsQixhQUFLLFFBQUw7QUFDRDtBQUNELFdBQUssU0FBTCxHQUFpQixLQUFqQjtBQUNBLFVBQUksU0FBUyxLQUFLLE1BQWxCO0FBQ0E7QUFDQSxVQUFJLFVBQVUsS0FBSyxRQUFMLENBQWMsTUFBZCxDQUFzQixVQUFDLE9BQUQsRUFBVSxPQUFWO0FBQUEsZUFBdUIsUUFBUSxNQUFSLEtBQW1CLE1BQXBCLEdBQThCLFVBQVUsQ0FBeEMsR0FBNEMsT0FBbEU7QUFBQSxPQUF0QixFQUFrRyxDQUFsRyxDQUFkO0FBQ0EsV0FBSyxHQUFMLENBQVMsT0FBVCxDQUFpQixpQkFBTSxlQUF2QixFQUF3QyxFQUFFLFFBQVMsTUFBWCxFQUFtQixTQUFVLE9BQTdCLEVBQXhDOztBQUVBO0FBQ0EsVUFBSSxDQUFDLEtBQUssV0FBVixFQUF1QjtBQUNyQixhQUFLLFdBQUw7QUFDRDs7QUFFRCxXQUFLLDBCQUFMO0FBQ0Q7OztvQ0FFZSxLLEVBQU87QUFDckIscUJBQU8sS0FBUCx5QkFBbUMsS0FBbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFLLEdBQUwsQ0FBUyxPQUFULENBQWlCLGlCQUFNLEtBQXZCLEVBQThCLEVBQUMsTUFBTSxtQkFBVyxXQUFsQixFQUErQixTQUFTLHFCQUFhLHNCQUFyRCxFQUE2RSxPQUFPLEtBQXBGLEVBQTlCO0FBQ0E7QUFDRDs7O29DQUVlO0FBQ2QsVUFBSSxlQUFlLEtBQUssWUFBeEI7QUFDQSxXQUFJLElBQUksSUFBUixJQUFnQixZQUFoQixFQUE4QjtBQUM1QixZQUFJLEtBQUssYUFBYSxJQUFiLENBQVQ7QUFDQSxZQUFJO0FBQ0YsZUFBSyxXQUFMLENBQWlCLGtCQUFqQixDQUFvQyxFQUFwQztBQUNBLGFBQUcsbUJBQUgsQ0FBdUIsV0FBdkIsRUFBb0MsS0FBSyxNQUF6QztBQUNBLGFBQUcsbUJBQUgsQ0FBdUIsT0FBdkIsRUFBZ0MsS0FBSyxLQUFyQztBQUNELFNBSkQsQ0FJRSxPQUFNLEdBQU4sRUFBVyxDQUNaO0FBQ0Y7QUFDRCxXQUFLLFlBQUwsR0FBb0IsRUFBcEI7QUFDQSxXQUFLLFVBQUwsR0FBa0IsRUFBbEI7QUFDQSxXQUFLLFFBQUwsR0FBZ0IsRUFBaEI7QUFDQSxXQUFLLFFBQUwsR0FBZ0IsQ0FBaEI7QUFDRDs7O21DQUVjLE0sRUFBUTtBQUNyQjtBQUNBO0FBQ0EsVUFBSSxPQUFPLElBQVAsQ0FBWSxLQUFLLFlBQWpCLEVBQStCLE1BQS9CLEtBQTBDLENBQTlDLEVBQWlEO0FBQy9DLGFBQUssSUFBSSxTQUFULElBQXNCLE1BQXRCLEVBQThCO0FBQUUsZUFBSyxhQUFMLENBQW1CLFNBQW5CLElBQWdDLE9BQU8sU0FBUCxDQUFoQztBQUFvRDtBQUNwRixZQUFJLGNBQWMsS0FBSyxXQUF2QjtBQUNBLFlBQUksZUFBZSxZQUFZLFVBQVosS0FBMkIsTUFBOUMsRUFBc0Q7QUFDcEQ7QUFDQSxlQUFLLGtCQUFMO0FBQ0Q7QUFDRjtBQUNGOzs7d0NBR21CLE0sRUFBUTtBQUMxQixVQUFJLGVBQWUsS0FBSyxZQUF4QjtBQUFBLFVBQXFDLGNBQWMsS0FBSyxXQUF4RDs7QUFFQSxXQUFLLElBQUksU0FBVCxJQUFzQixNQUF0QixFQUE4QjtBQUM1QixZQUFHLENBQUMsYUFBYSxTQUFiLENBQUosRUFBNkI7QUFDM0IsY0FBSSxRQUFRLE9BQU8sU0FBUCxDQUFaO0FBQ0E7QUFDQSxjQUFJLFFBQVEsTUFBTSxVQUFOLElBQW9CLE1BQU0sS0FBdEM7QUFDQSxjQUFJLFdBQWMsTUFBTSxTQUFwQixnQkFBd0MsS0FBNUM7QUFDQSx5QkFBTyxHQUFQLDRCQUFvQyxRQUFwQztBQUNBLGNBQUk7QUFDRixnQkFBSSxLQUFLLGFBQWEsU0FBYixJQUEwQixZQUFZLGVBQVosQ0FBNEIsUUFBNUIsQ0FBbkM7QUFDQSxlQUFHLGdCQUFILENBQW9CLFdBQXBCLEVBQWlDLEtBQUssTUFBdEM7QUFDQSxlQUFHLGdCQUFILENBQW9CLE9BQXBCLEVBQTZCLEtBQUssS0FBbEM7QUFDQSxpQkFBSyxNQUFMLENBQVksU0FBWixJQUF5QixFQUFDLE9BQU8sS0FBUixFQUFlLFdBQVcsTUFBTSxTQUFoQyxFQUF6QjtBQUNBLGtCQUFNLE1BQU4sR0FBZSxFQUFmO0FBQ0QsV0FORCxDQU1FLE9BQU0sR0FBTixFQUFXO0FBQ1gsMkJBQU8sS0FBUCw2Q0FBdUQsSUFBSSxPQUEzRDtBQUNBLGlCQUFLLEdBQUwsQ0FBUyxPQUFULENBQWlCLGlCQUFNLEtBQXZCLEVBQThCLEVBQUMsTUFBTSxtQkFBVyxXQUFsQixFQUErQixTQUFTLHFCQUFhLHNCQUFyRCxFQUE2RSxPQUFPLEtBQXBGLEVBQTJGLEtBQUssR0FBaEcsRUFBcUcsVUFBVyxRQUFoSCxFQUE5QjtBQUNEO0FBQ0Y7QUFDRjtBQUNELFdBQUssR0FBTCxDQUFTLE9BQVQsQ0FBaUIsaUJBQU0sY0FBdkIsRUFBdUMsRUFBRSxRQUFTLE1BQVgsRUFBdkM7QUFDRDs7O3NDQUVpQixJLEVBQU07QUFDdEIsVUFBSSxDQUFDLEtBQUssV0FBVixFQUF1QjtBQUNyQixZQUFJLENBQUMsS0FBSyxRQUFWLEVBQW9CO0FBQ2xCLGVBQUssUUFBTCxHQUFnQixDQUFFLElBQUYsQ0FBaEI7QUFDRCxTQUZELE1BRU87QUFDTCxlQUFLLFFBQUwsQ0FBYyxJQUFkLENBQW1CLElBQW5CO0FBQ0Q7QUFDRCxhQUFLLFdBQUw7QUFDRDtBQUNGOzs7dUNBRWtCLEksRUFBTTtBQUN2QixxQkFBTyxLQUFQLHlCQUFtQyxLQUFLLEtBQXhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBSyxHQUFMLENBQVMsT0FBVCxDQUFpQixpQkFBTSxLQUF2QixFQUE4QixFQUFDLE1BQU0sbUJBQVcsV0FBbEIsRUFBK0IsU0FBUyxxQkFBYSxzQkFBckQsRUFBNkUsT0FBTyxLQUFwRixFQUEyRixNQUFNLEtBQUssV0FBdEcsRUFBOUI7QUFDRDs7QUFFRDs7OztnQ0FDWSxJLEVBQU07QUFDaEIsVUFBSSxLQUFLLEtBQUssWUFBZDtBQUNBLFVBQUksV0FBVyxLQUFLLElBQXBCO0FBQ0EsV0FBSSxJQUFJLElBQVIsSUFBZ0IsRUFBaEIsRUFBb0I7QUFDbEIsWUFBSSxDQUFDLFFBQUQsSUFBYSxTQUFTLFFBQTFCLEVBQW9DO0FBQ2xDLGNBQUksQ0FBQyxHQUFHLElBQUgsRUFBUyxLQUFkLEVBQXFCO0FBQ25CLGVBQUcsSUFBSCxFQUFTLEtBQVQsR0FBaUIsSUFBakI7QUFDQSwyQkFBTyxHQUFQLENBQWMsSUFBZDtBQUNEO0FBQ0Y7QUFDRjtBQUNELFdBQUssUUFBTDtBQUNEOztBQUVGOzs7OytCQUNXO0FBQ1IsVUFBSSxLQUFLLEtBQUssWUFBZDtBQUFBLFVBQTRCLGNBQWMsS0FBSyxXQUEvQztBQUNBLFVBQUksQ0FBQyxXQUFELElBQWdCLFlBQVksVUFBWixLQUEyQixNQUEvQyxFQUF1RDtBQUNyRCxhQUFLLFNBQUwsR0FBaUIsS0FBakI7QUFDQTtBQUNEO0FBQ0QsV0FBSSxJQUFJLElBQVIsSUFBZ0IsRUFBaEIsRUFBb0I7QUFDbEIsWUFBSSxRQUFRLEdBQUcsSUFBSCxDQUFaO0FBQ0EsWUFBSSxDQUFDLE1BQU0sS0FBWCxFQUFrQjtBQUNoQjtBQUNEO0FBQ0QsWUFBRyxNQUFNLFFBQVQsRUFBbUI7QUFDakIsZUFBSyxTQUFMLEdBQWlCLElBQWpCO0FBQ0E7QUFDRDtBQUNGO0FBQ0QscUJBQU8sR0FBUCxDQUFXLHlGQUFYO0FBQ0E7QUFDQSxVQUFJO0FBQ0Ysb0JBQVksV0FBWjtBQUNELE9BRkQsQ0FFRSxPQUFNLENBQU4sRUFBUztBQUNULHVCQUFPLElBQVAsQ0FBWSxtREFBWjtBQUNEO0FBQ0QsV0FBSyxTQUFMLEdBQWlCLEtBQWpCO0FBQ0Y7OztxQ0FHaUIsSSxFQUFNO0FBQ3JCLFdBQUssVUFBTCxDQUFnQixJQUFoQixDQUFxQixFQUFDLE9BQU8sS0FBSyxXQUFiLEVBQTBCLEtBQUssS0FBSyxTQUFwQyxFQUErQyxNQUFPLEtBQUssSUFBM0QsRUFBckI7QUFDQTtBQUNBLFdBQUssa0JBQUwsR0FBMEIsQ0FBMUI7QUFDQSxXQUFLLE9BQUw7QUFDRDs7O21DQUVjLEssRUFBTztBQUNwQixVQUFJLFVBQVUsTUFBTSxPQUFwQjtBQUNBLFVBQUksUUFBUSxTQUFSLENBQWtCLE1BQWxCLEtBQTZCLENBQWpDLEVBQW9DO0FBQ2xDO0FBQ0Q7QUFDRCxXQUFLLGNBQUwsR0FBc0IsUUFBUSxhQUFSLEdBQXdCLFFBQVEsU0FBUixDQUFrQixDQUFsQixFQUFxQixLQUFuRTtBQUNBLFdBQUssMEJBQUw7QUFDRDs7QUFFRDs7OztpREFDNkI7QUFDM0IsVUFBSSxRQUFRLEtBQUssS0FBakI7QUFBQSxVQUNJLGNBQWMsS0FBSyxXQUR2QjtBQUFBLFVBRUksZUFBZSxLQUFLLFlBRnhCO0FBQUEsVUFHSSxnQkFBZ0IsS0FBSyxjQUh6QjtBQUlBLFVBQUksa0JBQWtCLElBQWxCLElBQTBCLENBQUMsS0FBM0IsSUFBb0MsQ0FBQyxXQUFyQyxJQUFvRCxDQUFDLFlBQXJELElBQXFFLE1BQU0sVUFBTixLQUFxQixDQUExRixJQUErRixZQUFZLFVBQVosS0FBMkIsTUFBOUgsRUFBc0k7QUFDcEk7QUFDRDtBQUNELFdBQUssSUFBSSxJQUFULElBQWlCLFlBQWpCLEVBQStCO0FBQzdCLFlBQUksYUFBYSxJQUFiLEVBQW1CLFFBQXZCLEVBQWlDO0FBQy9CO0FBQ0E7QUFDRDtBQUNGO0FBQ0QsVUFBSSxLQUFLLFdBQUwsS0FBcUIsSUFBekIsRUFBK0I7QUFDN0I7QUFDQSxhQUFLLFdBQUwsR0FBbUIsWUFBWSxRQUEvQjtBQUNEO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFJLGdCQUFnQixLQUFLLFdBQXJCLElBQW9DLGdCQUFnQixNQUFNLFFBQTlELEVBQXdFO0FBQ3RFLHVCQUFPLEdBQVAsdUNBQStDLGNBQWMsT0FBZCxDQUFzQixDQUF0QixDQUEvQztBQUNBLGFBQUssV0FBTCxHQUFtQixZQUFZLFFBQVosR0FBdUIsYUFBMUM7QUFDRDtBQUNGOzs7OEJBRVM7QUFDUjtBQUNBLGFBQU0sS0FBSyxVQUFMLENBQWdCLE1BQXRCLEVBQThCO0FBQzVCLFlBQUksUUFBUSxLQUFLLFVBQUwsQ0FBZ0IsQ0FBaEIsQ0FBWjtBQUNBO0FBQ0EsWUFBSSxLQUFLLFdBQUwsQ0FBaUIsTUFBTSxLQUF2QixFQUE4QixNQUFNLEdBQXBDLEVBQXlDLE1BQU0sSUFBL0MsQ0FBSixFQUEwRDtBQUN4RDtBQUNBLGVBQUssVUFBTCxDQUFnQixLQUFoQjtBQUNBLGVBQUssa0JBQUwsR0FBMEIsQ0FBMUI7QUFDRCxTQUpELE1BSU87QUFDTCxlQUFLLFdBQUwsR0FBbUIsSUFBbkI7QUFDQTtBQUNBO0FBQ0Q7QUFDRjtBQUNELFVBQUksS0FBSyxVQUFMLENBQWdCLE1BQWhCLEtBQTJCLENBQS9CLEVBQWtDO0FBQ2hDO0FBQ0EsYUFBSyxXQUFMLEdBQW1CLEtBQW5COztBQUVBO0FBQ0EsWUFBSSxXQUFXLENBQWY7QUFDQSxZQUFJLGVBQWUsS0FBSyxZQUF4QjtBQUNBLFlBQUk7QUFDRixlQUFLLElBQUksSUFBVCxJQUFpQixZQUFqQixFQUErQjtBQUM3Qix3QkFBWSxhQUFhLElBQWIsRUFBbUIsUUFBbkIsQ0FBNEIsTUFBeEM7QUFDRDtBQUNGLFNBSkQsQ0FJRSxPQUFNLEtBQU4sRUFBYTtBQUNiO0FBQ0E7QUFDQSx5QkFBTyxLQUFQLENBQWEsNkNBQWI7QUFDRDtBQUNELGFBQUssUUFBTCxHQUFnQixRQUFoQjtBQUNBLGFBQUssR0FBTCxDQUFTLE9BQVQsQ0FBaUIsaUJBQU0sY0FBdkI7QUFDRDtBQUNGOzs7a0NBRWE7QUFDWixVQUFJLE1BQU0sS0FBSyxHQUFmO0FBQUEsVUFBb0IsZUFBZSxLQUFLLFlBQXhDO0FBQUEsVUFBc0QsV0FBVyxLQUFLLFFBQXRFO0FBQ0EsVUFBSSxPQUFPLElBQVAsQ0FBWSxZQUFaLEVBQTBCLE1BQTlCLEVBQXNDO0FBQ3BDLFlBQUksS0FBSyxLQUFMLENBQVcsS0FBZixFQUFzQjtBQUNwQixlQUFLLFFBQUwsR0FBZ0IsRUFBaEI7QUFDQSx5QkFBTyxLQUFQLENBQWEsMEVBQWI7QUFDQTtBQUNEO0FBQ0QsWUFBSSxLQUFLLFNBQVQsRUFBb0I7QUFDbEI7QUFDQTtBQUNEO0FBQ0QsWUFBSSxZQUFZLFNBQVMsTUFBekIsRUFBaUM7QUFDL0IsY0FBSSxVQUFVLFNBQVMsS0FBVCxFQUFkO0FBQ0EsY0FBSTtBQUNGLGdCQUFJLE9BQU8sUUFBUSxJQUFuQjtBQUFBLGdCQUF5QixLQUFLLGFBQWEsSUFBYixDQUE5QjtBQUNBLGdCQUFHLEVBQUgsRUFBTztBQUNMLGtCQUFHLENBQUMsR0FBRyxRQUFQLEVBQWlCO0FBQ2Y7QUFDQSxtQkFBRyxLQUFILEdBQVcsS0FBWDtBQUNBO0FBQ0EscUJBQUssTUFBTCxHQUFjLFFBQVEsTUFBdEI7QUFDQSxtQkFBRyxZQUFILENBQWdCLFFBQVEsSUFBeEI7QUFDQSxxQkFBSyxXQUFMLEdBQW1CLENBQW5CO0FBQ0EscUJBQUssUUFBTDtBQUNBLHFCQUFLLFNBQUwsR0FBaUIsSUFBakI7QUFDRCxlQVRELE1BU087QUFDTCx5QkFBUyxPQUFULENBQWlCLE9BQWpCO0FBQ0Q7QUFDRixhQWJELE1BYU87QUFDTDtBQUNBO0FBQ0E7QUFDQSxtQkFBSyxhQUFMO0FBQ0Q7QUFDRixXQXJCRCxDQXFCRSxPQUFNLEdBQU4sRUFBVztBQUNYO0FBQ0EsMkJBQU8sS0FBUCwwQ0FBb0QsSUFBSSxPQUF4RDtBQUNBLHFCQUFTLE9BQVQsQ0FBaUIsT0FBakI7QUFDQSxnQkFBSSxRQUFRLEVBQUMsTUFBTSxtQkFBVyxXQUFsQixFQUFaO0FBQ0EsZ0JBQUcsSUFBSSxJQUFKLEtBQWEsRUFBaEIsRUFBb0I7QUFDbEIsa0JBQUksS0FBSyxXQUFULEVBQXNCO0FBQ3BCLHFCQUFLLFdBQUw7QUFDRCxlQUZELE1BRU87QUFDTCxxQkFBSyxXQUFMLEdBQW1CLENBQW5CO0FBQ0Q7QUFDRCxvQkFBTSxPQUFOLEdBQWdCLHFCQUFhLG1CQUE3QjtBQUNBLG9CQUFNLElBQU4sR0FBYSxLQUFLLFdBQWxCO0FBQ0E7OztBQUdBLGtCQUFJLEtBQUssV0FBTCxHQUFtQixJQUFJLE1BQUosQ0FBVyxtQkFBbEMsRUFBdUQ7QUFDckQsK0JBQU8sR0FBUCxXQUFtQixJQUFJLE1BQUosQ0FBVyxtQkFBOUI7QUFDQSwyQkFBVyxFQUFYO0FBQ0Esc0JBQU0sS0FBTixHQUFjLElBQWQ7QUFDQSxvQkFBSSxPQUFKLENBQVksaUJBQU0sS0FBbEIsRUFBeUIsS0FBekI7QUFDQTtBQUNELGVBTkQsTUFNTztBQUNMLHNCQUFNLEtBQU4sR0FBYyxLQUFkO0FBQ0Esb0JBQUksT0FBSixDQUFZLGlCQUFNLEtBQWxCLEVBQXlCLEtBQXpCO0FBQ0Q7QUFDRixhQXJCRCxNQXFCTztBQUNMO0FBQ0E7QUFDQSxtQkFBSyxRQUFMLEdBQWdCLEVBQWhCO0FBQ0Esb0JBQU0sT0FBTixHQUFnQixxQkFBYSxpQkFBN0I7QUFDQSxrQkFBSSxPQUFKLENBQVksaUJBQU0sS0FBbEIsRUFBd0IsS0FBeEI7QUFDQTtBQUNEO0FBQ0Y7QUFDRjtBQUNGO0FBQ0Y7O0FBRUQ7Ozs7Ozs7O2dDQUtZLFcsRUFBYSxTLEVBQVcsTSxFQUFRO0FBQzFDLFVBQUksRUFBSjtBQUFBLFVBQVEsQ0FBUjtBQUFBLFVBQVcsUUFBWDtBQUFBLFVBQXFCLE1BQXJCO0FBQUEsVUFBNkIsVUFBN0I7QUFBQSxVQUF5QyxRQUF6QztBQUFBLFVBQW1ELGVBQWUsS0FBSyxZQUF2RTtBQUNBLFVBQUksT0FBTyxJQUFQLENBQVksWUFBWixFQUEwQixNQUE5QixFQUFzQztBQUNwQyx1QkFBTyxHQUFQLENBQVcsZ0NBQWdDLEtBQUssS0FBTCxDQUFXLFdBQTNDLEdBQXlELEdBQXpELEdBQStELFdBQS9ELEdBQTZFLEdBQTdFLEdBQW1GLFNBQTlGO0FBQ0E7QUFDQSxZQUFJLEtBQUssa0JBQUwsR0FBMEIsS0FBSyxRQUFuQyxFQUE2QztBQUMzQyxlQUFLLElBQUksSUFBVCxJQUFpQixZQUFqQixFQUErQjtBQUM3QjtBQUNBO0FBQ0EsZ0JBQUksVUFBVSxTQUFTLE1BQXZCLEVBQStCO0FBQzdCO0FBQ0Q7QUFDRCxpQkFBSyxhQUFhLElBQWIsQ0FBTDtBQUNBO0FBQ0EsZUFBRyxLQUFILEdBQVcsS0FBWDtBQUNBLGdCQUFJLENBQUMsR0FBRyxRQUFSLEVBQWtCO0FBQ2hCLGtCQUFJO0FBQ0YscUJBQUssSUFBSSxDQUFULEVBQVksSUFBSSxHQUFHLFFBQUgsQ0FBWSxNQUE1QixFQUFvQyxHQUFwQyxFQUF5QztBQUN2Qyw2QkFBVyxHQUFHLFFBQUgsQ0FBWSxLQUFaLENBQWtCLENBQWxCLENBQVg7QUFDQSwyQkFBUyxHQUFHLFFBQUgsQ0FBWSxHQUFaLENBQWdCLENBQWhCLENBQVQ7QUFDQTtBQUNBLHNCQUFJLFVBQVUsU0FBVixDQUFvQixXQUFwQixHQUFrQyxPQUFsQyxDQUEwQyxTQUExQyxNQUF5RCxDQUFDLENBQTFELElBQStELGNBQWMsT0FBTyxpQkFBeEYsRUFBMkc7QUFDekcsaUNBQWEsV0FBYjtBQUNBLCtCQUFXLFNBQVg7QUFDRCxtQkFIRCxNQUdPO0FBQ0wsaUNBQWEsS0FBSyxHQUFMLENBQVMsUUFBVCxFQUFtQixXQUFuQixDQUFiO0FBQ0EsK0JBQVcsS0FBSyxHQUFMLENBQVMsTUFBVCxFQUFpQixTQUFqQixDQUFYO0FBQ0Q7QUFDRDs7Ozs7QUFLQSxzQkFBSSxLQUFLLEdBQUwsQ0FBUyxRQUFULEVBQWtCLE1BQWxCLElBQTRCLFVBQTVCLEdBQXlDLEdBQTdDLEVBQW1EO0FBQ2pELHlCQUFLLGtCQUFMO0FBQ0EsbUNBQU8sR0FBUCxZQUFvQixJQUFwQixVQUE2QixVQUE3QixTQUEyQyxRQUEzQyxlQUE2RCxRQUE3RCxTQUF5RSxNQUF6RSxlQUF5RixLQUFLLEtBQUwsQ0FBVyxXQUFwRztBQUNBLHVCQUFHLE1BQUgsQ0FBVSxVQUFWLEVBQXNCLFFBQXRCO0FBQ0EsMkJBQU8sS0FBUDtBQUNEO0FBQ0Y7QUFDRixlQXhCRCxDQXdCRSxPQUFNLENBQU4sRUFBUztBQUNULCtCQUFPLElBQVAsQ0FBWSxxRkFBWjtBQUNEO0FBQ0YsYUE1QkQsTUE0Qk87QUFDTDtBQUNBO0FBQ0E7QUFDQSw2QkFBTyxJQUFQLENBQVksdUNBQVo7QUFDQSxxQkFBTyxLQUFQO0FBQ0Q7QUFDRjtBQUNGLFNBOUNELE1BOENPO0FBQ0wseUJBQU8sSUFBUCxDQUFZLGlDQUFaO0FBQ0Q7QUFDRCx1QkFBTyxHQUFQLENBQVcsZ0JBQVg7QUFDRDtBQUNEO0FBQ0EsYUFBTyxJQUFQO0FBQ0Q7Ozs7OztrQkFHWSxnQjs7Ozs7Ozs7Ozs7QUNoakJmOzs7O0FBQ0E7Ozs7Ozs7Ozs7K2VBTEE7Ozs7SUFPTSxrQjs7O0FBQ0wsOEJBQVksR0FBWixFQUFpQjtBQUFBOztBQUFBLG1JQUNSLEdBRFEsRUFFWixpQkFBTSxzQkFGTSxFQUdaLGlCQUFNLGVBSE0sRUFJWixpQkFBTSxlQUpNO0FBS2hCOzs7OzhCQUVTO0FBQ1AsVUFBSSxLQUFLLEdBQUwsQ0FBUyxNQUFULENBQWdCLG9CQUFwQixFQUEwQztBQUN4QyxhQUFLLEtBQUwsR0FBYSxLQUFLLGdCQUFMLEdBQXdCLElBQXJDO0FBQ0EsYUFBSyxnQkFBTCxHQUF3QixPQUFPLGlCQUEvQjtBQUNBLFlBQUksS0FBSyxLQUFULEVBQWdCO0FBQ2QsZUFBSyxLQUFMLEdBQWEsY0FBYyxLQUFLLEtBQW5CLENBQWI7QUFDRDtBQUNGO0FBQ0Y7OzswQ0FFcUIsSSxFQUFNO0FBQzFCLFVBQUksQ0FBQyxLQUFLLGdCQUFWLEVBQTRCO0FBQzFCLGFBQUssZ0JBQUwsR0FBd0IsRUFBeEI7QUFDRDtBQUNELFVBQUksQ0FBQyxLQUFLLGlCQUFMLENBQXVCLEtBQUssWUFBNUIsQ0FBTCxFQUFnRDtBQUM5QyxhQUFLLGdCQUFMLENBQXNCLElBQXRCLENBQTJCLEtBQUssWUFBaEM7QUFDRDtBQUNGOzs7cUNBRWUsSSxFQUFNO0FBQ3BCLFdBQUssS0FBTCxHQUFhLEtBQUssS0FBTCxZQUFzQixnQkFBdEIsR0FBeUMsS0FBSyxLQUE5QyxHQUFzRCxJQUFuRTtBQUNEOzs7cUNBRWdCLEksRUFBTTtBQUNyQixVQUFJLEtBQUssR0FBTCxDQUFTLE1BQVQsQ0FBZ0Isb0JBQXBCLEVBQTBDO0FBQ3hDLGFBQUssZ0JBQUwsR0FBd0IsT0FBTyxpQkFBL0I7QUFDQSxhQUFLLE1BQUwsR0FBYyxLQUFLLE1BQW5CO0FBQ0EsYUFBSyxHQUFMLENBQVMsVUFBVCxHQUFzQixLQUFLLFdBQUwsQ0FBaUIsS0FBSyxVQUF0QixDQUF0QjtBQUNBLHNCQUFjLEtBQUssS0FBbkI7QUFDQSxhQUFLLEtBQUwsR0FBYSxZQUFZLEtBQUssZ0JBQUwsQ0FBc0IsSUFBdEIsQ0FBMkIsSUFBM0IsQ0FBWixFQUE4QyxJQUE5QyxDQUFiO0FBQ0EsYUFBSyxnQkFBTDtBQUNEO0FBQ0Y7Ozt1Q0FFa0I7QUFDakIsVUFBSSxLQUFLLEtBQVQsRUFBZ0I7QUFDZCxZQUFJLGVBQWUsS0FBSyxNQUFMLEdBQWMsS0FBSyxNQUFMLENBQVksTUFBMUIsR0FBbUMsQ0FBdEQ7QUFDQSxZQUFJLFlBQUosRUFBa0I7QUFDaEIsZUFBSyxHQUFMLENBQVMsZ0JBQVQsR0FBNEIsS0FBSyxXQUFMLENBQWlCLGVBQWUsQ0FBaEMsQ0FBNUI7QUFDQSxjQUFJLEtBQUssR0FBTCxDQUFTLGdCQUFULEdBQTRCLEtBQUssZ0JBQXJDLEVBQXVEO0FBQ3JEO0FBQ0E7QUFDQSxpQkFBSyxHQUFMLENBQVMsZ0JBQVQsQ0FBMEIsZUFBMUI7QUFDRDtBQUNELGVBQUssZ0JBQUwsR0FBd0IsS0FBSyxHQUFMLENBQVMsZ0JBQWpDO0FBQ0Q7QUFDRjtBQUNGOztBQUVEOzs7Ozs7Z0NBR1ksYSxFQUFlO0FBQ3pCLFVBQUksU0FBUyxDQUFiO0FBQUEsVUFDSSxVQURKO0FBQUEsVUFFSSxjQUZKO0FBQUEsVUFHSSxTQUFTLEtBQUssVUFIbEI7QUFBQSxVQUlJLFVBQVUsS0FBSyxXQUpuQjtBQUFBLFVBS0ksU0FBUyxDQUxiO0FBQUEsVUFNSSxVQUFVLENBTmQ7O0FBUUEsV0FBSyxJQUFJLENBQVQsRUFBWSxLQUFLLGFBQWpCLEVBQWdDLEdBQWhDLEVBQXFDO0FBQ25DLGdCQUFRLEtBQUssTUFBTCxDQUFZLENBQVosQ0FBUjtBQUNBLFlBQUksS0FBSyxpQkFBTCxDQUF1QixDQUF2QixDQUFKLEVBQStCO0FBQzdCO0FBQ0Q7QUFDRCxpQkFBUyxDQUFUO0FBQ0EsaUJBQVMsTUFBTSxLQUFmO0FBQ0Esa0JBQVUsTUFBTSxNQUFoQjtBQUNBLFlBQUksVUFBVSxNQUFWLElBQW9CLFdBQVcsT0FBbkMsRUFBNEM7QUFDMUM7QUFDRDtBQUNGO0FBQ0QsYUFBTyxNQUFQO0FBQ0Q7OztzQ0FFaUIsSyxFQUFPO0FBQ3ZCLGFBQVEsS0FBSyxnQkFBTCxJQUF5QixLQUFLLGdCQUFMLENBQXNCLE9BQXRCLENBQThCLEtBQTlCLE1BQXlDLENBQUMsQ0FBcEUsR0FBeUUsSUFBekUsR0FBZ0YsS0FBdkY7QUFDRDs7O3dCQUV3QjtBQUN2QixVQUFJLGFBQWEsQ0FBakI7QUFDQSxVQUFJO0FBQ0YscUJBQWMsT0FBTyxnQkFBckI7QUFDRCxPQUZELENBRUUsT0FBTSxDQUFOLEVBQVMsQ0FBRTtBQUNiLGFBQU8sVUFBUDtBQUNEOzs7d0JBRWdCO0FBQ2YsVUFBSSxjQUFKO0FBQ0EsVUFBSSxLQUFLLEtBQVQsRUFBZ0I7QUFDZCxnQkFBUSxLQUFLLEtBQUwsQ0FBVyxLQUFYLElBQW9CLEtBQUssS0FBTCxDQUFXLFdBQS9CLElBQThDLEtBQUssS0FBTCxDQUFXLFdBQWpFO0FBQ0EsaUJBQVMsS0FBSyxrQkFBZDtBQUNEO0FBQ0QsYUFBTyxLQUFQO0FBQ0Q7Ozt3QkFFaUI7QUFDaEIsVUFBSSxlQUFKO0FBQ0EsVUFBSSxLQUFLLEtBQVQsRUFBZ0I7QUFDZCxpQkFBUyxLQUFLLEtBQUwsQ0FBVyxNQUFYLElBQXFCLEtBQUssS0FBTCxDQUFXLFlBQWhDLElBQWdELEtBQUssS0FBTCxDQUFXLFlBQXBFO0FBQ0Esa0JBQVUsS0FBSyxrQkFBZjtBQUNEO0FBQ0QsYUFBTyxNQUFQO0FBQ0Q7Ozs7OztrQkFHWSxrQjs7Ozs7Ozs7O3FqQkMxSGY7Ozs7Ozs7O0FBUUE7Ozs7Ozs7O0lBR00sc0I7QUFFSixrQ0FBWSxHQUFaLEVBQWdCLElBQWhCLEVBQXFCLElBQXJCLEVBQTBCLGVBQTFCLEVBQTJDO0FBQUE7O0FBQ3pDLFNBQUssR0FBTCxHQUFXLEdBQVg7QUFDQSxTQUFLLGdCQUFMLEdBQXdCLGVBQXhCO0FBQ0EsU0FBSyxVQUFMLEdBQWtCLEtBQWxCO0FBQ0EsU0FBSyxXQUFMLEdBQW1CLEVBQW5CO0FBQ0EsU0FBSyxLQUFMLEdBQWEsbUJBQVMsSUFBVCxDQUFiO0FBQ0EsU0FBSyxLQUFMLEdBQWEsbUJBQVMsSUFBVCxDQUFiO0FBQ0Q7Ozs7MkJBRU0sVSxFQUFXLFEsRUFBVTtBQUMxQixtQkFBYSxLQUFLLEdBQUwsQ0FBUyxVQUFULEVBQXFCLEtBQUssV0FBMUIsQ0FBYjtBQUNBLFVBQUksWUFBWSxPQUFNLFFBQU4sR0FBaUIsVUFBakM7O0FBQ0E7QUFDQTtBQUNJLGVBQVMsYUFBYSxJQUgxQjtBQUlBLFdBQUssS0FBTCxDQUFXLE1BQVgsQ0FBa0IsTUFBbEIsRUFBeUIsU0FBekI7QUFDQSxXQUFLLEtBQUwsQ0FBVyxNQUFYLENBQWtCLE1BQWxCLEVBQXlCLFNBQXpCO0FBQ0Q7OztrQ0FFYTtBQUNaLFVBQUksT0FBTyxLQUFLLEtBQWhCO0FBQ0EsYUFBUSxRQUFRLEtBQUssY0FBTCxNQUF5QixLQUFLLFVBQTlDO0FBQ0Q7OztrQ0FHYTtBQUNaLFVBQUksS0FBSyxXQUFMLEVBQUosRUFBd0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFPLEtBQUssR0FBTCxDQUFTLEtBQUssS0FBTCxDQUFXLFdBQVgsRUFBVCxFQUFrQyxLQUFLLEtBQUwsQ0FBVyxXQUFYLEVBQWxDLENBQVA7QUFDRCxPQU5ELE1BTU87QUFDTCxlQUFPLEtBQUssZ0JBQVo7QUFDRDtBQUNGOzs7OEJBRVMsQ0FDVDs7Ozs7O2tCQUVZLHNCOzs7Ozs7Ozs7OztBQ2pEZjs7OztBQUNBOzs7O0FBQ0E7Ozs7Ozs7OytlQU5BOzs7O0lBUU0sYTs7O0FBRUoseUJBQVksR0FBWixFQUFpQjtBQUFBOztBQUFBLHlIQUNULEdBRFMsRUFDSixpQkFBTSxlQURGO0FBRWhCOzs7OzhCQUVTO0FBQ1IsVUFBSSxLQUFLLEtBQVQsRUFBZ0I7QUFDZCxzQkFBYyxLQUFLLEtBQW5CO0FBQ0Q7QUFDRCxXQUFLLCtCQUFMLEdBQXVDLEtBQXZDO0FBQ0Q7OztxQ0FFZ0IsSSxFQUFNO0FBQ3JCLFVBQUksS0FBSyxHQUFMLENBQVMsTUFBVCxDQUFnQixpQkFBcEIsRUFBdUM7QUFDckMsYUFBSyxLQUFMLEdBQWEsS0FBSyxLQUFMLFlBQXNCLGdCQUF0QixHQUF5QyxLQUFLLEtBQTlDLEdBQXNELElBQW5FO0FBQ0EsWUFBSSxPQUFPLEtBQUssS0FBTCxDQUFXLHVCQUFsQixLQUE4QyxVQUFsRCxFQUE4RDtBQUM1RCxlQUFLLCtCQUFMLEdBQXVDLElBQXZDO0FBQ0Q7QUFDRCxzQkFBYyxLQUFLLEtBQW5CO0FBQ0EsYUFBSyxLQUFMLEdBQWEsWUFBWSxLQUFLLGdCQUFMLENBQXNCLElBQXRCLENBQTJCLElBQTNCLENBQVosRUFBOEMsS0FBSyxHQUFMLENBQVMsTUFBVCxDQUFnQiwwQkFBOUQsQ0FBYjtBQUNEO0FBQ0Y7Ozs2QkFFUSxLLEVBQU8sYSxFQUFlLGEsRUFBZTtBQUM1QyxVQUFJLGNBQWMsWUFBWSxHQUFaLEVBQWxCO0FBQ0EsVUFBSSxhQUFKLEVBQW1CO0FBQ2pCLFlBQUksS0FBSyxRQUFULEVBQW1CO0FBQ2pCLGNBQUksZ0JBQWdCLGNBQWMsS0FBSyxRQUF2QztBQUFBLGNBQ0ksaUJBQWlCLGdCQUFnQixLQUFLLGlCQUQxQztBQUFBLGNBRUksaUJBQWlCLGdCQUFnQixLQUFLLGlCQUYxQztBQUFBLGNBR0ksYUFBYSxPQUFPLGNBQVAsR0FBd0IsYUFIekM7QUFJQSxlQUFLLEdBQUwsQ0FBUyxPQUFULENBQWlCLGlCQUFNLFFBQXZCLEVBQWlDLEVBQUMsZ0JBQWdCLGNBQWpCLEVBQWlDLGdCQUFnQixjQUFqRCxFQUFpRSxvQkFBb0IsYUFBckYsRUFBakM7QUFDQSxjQUFJLGFBQWEsQ0FBakIsRUFBb0I7QUFDbEI7QUFDQSxnQkFBSSxpQkFBaUIsS0FBSyxHQUFMLENBQVMsTUFBVCxDQUFnQiw2QkFBaEIsR0FBZ0QsY0FBckUsRUFBcUY7QUFDbkYsa0JBQUksZUFBZSxLQUFLLEdBQUwsQ0FBUyxZQUE1QjtBQUNBLDZCQUFPLElBQVAsQ0FBWSxxRUFBcUUsWUFBakY7QUFDQSxrQkFBSSxlQUFlLENBQWYsS0FBcUIsS0FBSyxHQUFMLENBQVMsZ0JBQVQsS0FBOEIsQ0FBQyxDQUEvQixJQUFvQyxLQUFLLEdBQUwsQ0FBUyxnQkFBVCxJQUE2QixZQUF0RixDQUFKLEVBQXlHO0FBQ3ZHLCtCQUFlLGVBQWUsQ0FBOUI7QUFDQSxxQkFBSyxHQUFMLENBQVMsT0FBVCxDQUFpQixpQkFBTSxzQkFBdkIsRUFBK0MsRUFBQyxPQUFPLFlBQVIsRUFBc0IsY0FBYyxLQUFLLEdBQUwsQ0FBUyxZQUE3QyxFQUEvQztBQUNBLHFCQUFLLEdBQUwsQ0FBUyxnQkFBVCxHQUE0QixZQUE1QjtBQUNBLHFCQUFLLEdBQUwsQ0FBUyxnQkFBVCxDQUEwQixlQUExQjtBQUNEO0FBQ0Y7QUFDRjtBQUNGO0FBQ0QsYUFBSyxRQUFMLEdBQWdCLFdBQWhCO0FBQ0EsYUFBSyxpQkFBTCxHQUF5QixhQUF6QjtBQUNBLGFBQUssaUJBQUwsR0FBeUIsYUFBekI7QUFDRDtBQUNGOzs7dUNBRWtCO0FBQ2pCLFVBQUksS0FBSyxLQUFULEVBQWdCO0FBQ2QsWUFBSSxLQUFLLCtCQUFULEVBQTBDO0FBQ3hDLGNBQUksdUJBQXVCLEtBQUssS0FBTCxDQUFXLHVCQUFYLEVBQTNCO0FBQ0EsZUFBSyxRQUFMLENBQWMsS0FBSyxLQUFuQixFQUEwQixxQkFBcUIsZ0JBQS9DLEVBQWlFLHFCQUFxQixrQkFBdEY7QUFDRCxTQUhELE1BR087QUFDTCxlQUFLLFFBQUwsQ0FBYyxLQUFLLEtBQW5CLEVBQTBCLEtBQUssS0FBTCxDQUFXLHVCQUFyQyxFQUE4RCxLQUFLLEtBQUwsQ0FBVyx1QkFBekU7QUFDRDtBQUNGO0FBQ0Y7Ozs7OztrQkFHWSxhOzs7Ozs7Ozs7OztBQ3JFZjs7OztBQUNBOzs7O0FBQ0E7O0FBQ0E7O0FBQ0E7Ozs7Ozs7Ozs7K2VBUkE7Ozs7SUFVTSxlOzs7QUFFSiwyQkFBWSxHQUFaLEVBQWlCO0FBQUE7O0FBQUEsa0lBQ1QsR0FEUyxFQUViLGlCQUFNLGVBRk8sRUFHYixpQkFBTSxZQUhPLEVBSWIsaUJBQU0sV0FKTyxFQUtiLGlCQUFNLEtBTE87O0FBTWYsVUFBSyxNQUFMLEdBQWMsTUFBSyxJQUFMLENBQVUsSUFBVixPQUFkO0FBQ0EsVUFBSyxZQUFMLEdBQW9CLE1BQUssaUJBQUwsR0FBeUIsQ0FBQyxDQUE5QztBQVBlO0FBUWhCOzs7OzhCQUVTO0FBQ1IsVUFBSSxLQUFLLEtBQVQsRUFBZ0I7QUFDZCxxQkFBYSxLQUFLLEtBQWxCO0FBQ0EsYUFBSyxLQUFMLEdBQWEsSUFBYjtBQUNEO0FBQ0QsV0FBSyxZQUFMLEdBQW9CLENBQUMsQ0FBckI7QUFDRDs7O2dDQUVXO0FBQ1YsV0FBSyxPQUFMLEdBQWUsSUFBZjtBQUNBLFVBQUksU0FBUyxLQUFLLE9BQWxCO0FBQ0E7QUFDQSxVQUFHLE1BQUgsRUFBVztBQUNULGVBQU8sT0FBUCxDQUFlLGlCQUFTO0FBQ3RCLGdCQUFNLFNBQU4sR0FBa0IsQ0FBbEI7QUFDQSxjQUFNLGVBQWUsTUFBTSxPQUEzQjtBQUNBLGNBQUksZ0JBQWdCLGFBQWEsSUFBakMsRUFBdUM7QUFDckMsa0JBQU0sT0FBTixHQUFnQixTQUFoQjtBQUNEO0FBQ0YsU0FORDtBQU9EO0FBQ0Q7QUFDQSxVQUFJLEtBQUssS0FBVCxFQUFnQjtBQUNkLGFBQUssSUFBTDtBQUNEO0FBQ0Y7OzsrQkFFVTtBQUNULFdBQUssT0FBTCxHQUFlLEtBQWY7QUFDRDs7O3FDQUVnQixJLEVBQU07QUFDckIsVUFBSSxVQUFVLEVBQWQ7QUFBQSxVQUNJLFNBQVMsRUFEYjtBQUFBLFVBRUksWUFGSjtBQUFBLFVBR0ksYUFBYSxFQUhqQjtBQUFBLFVBSUksa0JBQWtCLEtBSnRCO0FBQUEsVUFLSSxrQkFBa0IsS0FMdEI7QUFBQSxVQU1JLE1BQU0sS0FBSyxHQU5mO0FBQUEsVUFPSSxpQkFBaUIsaUJBQWlCLElBQWpCLENBQXNCLFVBQVUsU0FBVixDQUFvQixXQUFwQixFQUF0QixDQVByQjtBQUFBLFVBUUksaUJBQWlCLFNBQWpCLGNBQWlCLENBQVMsSUFBVCxFQUFjLEtBQWQsRUFBcUI7QUFBRSxlQUFPLFlBQVksZUFBWixDQUErQixJQUEvQixvQkFBa0QsS0FBbEQsQ0FBUDtBQUFtRSxPQVIvRzs7QUFVQTtBQUNBLFdBQUssTUFBTCxDQUFZLE9BQVosQ0FBb0IsaUJBQVM7QUFDM0IsWUFBRyxNQUFNLFVBQVQsRUFBcUI7QUFDbkIsNEJBQWtCLElBQWxCO0FBQ0Q7QUFDRDtBQUNBLFlBQUcsa0JBQWtCLE1BQU0sVUFBeEIsSUFBc0MsTUFBTSxVQUFOLENBQWlCLE9BQWpCLENBQXlCLFlBQXpCLE1BQTJDLENBQUMsQ0FBckYsRUFBd0Y7QUFDdEYsZ0JBQU0sVUFBTixHQUFtQixTQUFuQjtBQUNEO0FBQ0QsWUFBRyxNQUFNLFVBQU4sSUFBcUIsTUFBTSxLQUFOLElBQWUsTUFBTSxLQUFOLENBQVksS0FBbkQsRUFBMkQ7QUFDekQsNEJBQWtCLElBQWxCO0FBQ0Q7QUFDRCxZQUFJLG1CQUFtQixXQUFXLE1BQU0sT0FBakIsQ0FBdkI7QUFDQSxZQUFJLHFCQUFxQixTQUF6QixFQUFvQztBQUNsQyxxQkFBVyxNQUFNLE9BQWpCLElBQTRCLFFBQVEsTUFBcEM7QUFDQSxnQkFBTSxHQUFOLEdBQVksQ0FBQyxNQUFNLEdBQVAsQ0FBWjtBQUNBLGdCQUFNLEtBQU4sR0FBYyxDQUFkO0FBQ0Esa0JBQVEsSUFBUixDQUFhLEtBQWI7QUFDRCxTQUxELE1BS087QUFDTCxrQkFBUSxnQkFBUixFQUEwQixHQUExQixDQUE4QixJQUE5QixDQUFtQyxNQUFNLEdBQXpDO0FBQ0Q7QUFDRixPQXBCRDs7QUFzQkE7QUFDQSxVQUFHLG1CQUFtQixlQUF0QixFQUF1QztBQUNyQyxnQkFBUSxPQUFSLENBQWdCLGlCQUFTO0FBQ3ZCLGNBQUcsTUFBTSxVQUFULEVBQXFCO0FBQ25CLG1CQUFPLElBQVAsQ0FBWSxLQUFaO0FBQ0Q7QUFDRixTQUpEO0FBS0QsT0FORCxNQU1PO0FBQ0wsaUJBQVMsT0FBVDtBQUNEO0FBQ0Q7QUFDQSxlQUFTLE9BQU8sTUFBUCxDQUFjLFVBQVMsS0FBVCxFQUFnQjtBQUN2QyxZQUFJLGFBQWEsTUFBTSxVQUF2QjtBQUFBLFlBQW1DLGFBQWEsTUFBTSxVQUF0RDtBQUNFLGVBQU8sQ0FBQyxDQUFDLFVBQUQsSUFBZSxlQUFlLE9BQWYsRUFBdUIsVUFBdkIsQ0FBaEIsTUFDQyxDQUFDLFVBQUQsSUFBZSxlQUFlLE9BQWYsRUFBdUIsVUFBdkIsQ0FEaEIsQ0FBUDtBQUVELE9BSlEsQ0FBVDs7QUFNQSxVQUFHLE9BQU8sTUFBVixFQUFrQjtBQUNoQjtBQUNBLHVCQUFlLE9BQU8sQ0FBUCxFQUFVLE9BQXpCO0FBQ0E7QUFDQSxlQUFPLElBQVAsQ0FBWSxVQUFVLENBQVYsRUFBYSxDQUFiLEVBQWdCO0FBQzFCLGlCQUFPLEVBQUUsT0FBRixHQUFZLEVBQUUsT0FBckI7QUFDRCxTQUZEO0FBR0EsYUFBSyxPQUFMLEdBQWUsTUFBZjtBQUNBO0FBQ0EsYUFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLE9BQU8sTUFBM0IsRUFBbUMsR0FBbkMsRUFBd0M7QUFDdEMsY0FBSSxPQUFPLENBQVAsRUFBVSxPQUFWLEtBQXNCLFlBQTFCLEVBQXdDO0FBQ3RDLGlCQUFLLFdBQUwsR0FBbUIsQ0FBbkI7QUFDQSwyQkFBTyxHQUFQLHNCQUE4QixPQUFPLE1BQXJDLHVDQUE2RSxZQUE3RTtBQUNBO0FBQ0Q7QUFDRjtBQUNELFlBQUksT0FBSixDQUFZLGlCQUFNLGVBQWxCLEVBQW1DLEVBQUMsUUFBUSxNQUFULEVBQWlCLFlBQVksS0FBSyxXQUFsQyxFQUErQyxPQUFPLEtBQUssS0FBM0QsRUFBa0UsT0FBUSxlQUExRSxFQUEyRixPQUFRLGVBQW5HLEVBQW9ILFVBQVcsS0FBSyxXQUFMLENBQWlCLE1BQWpCLEdBQTBCLENBQXpKLEVBQW5DO0FBQ0QsT0FqQkQsTUFpQk87QUFDTCxZQUFJLE9BQUosQ0FBWSxpQkFBTSxLQUFsQixFQUF5QixFQUFDLE1BQU0sbUJBQVcsV0FBbEIsRUFBK0IsU0FBUyxxQkFBYSxrQ0FBckQsRUFBeUYsT0FBTyxJQUFoRyxFQUFzRyxLQUFLLElBQUksR0FBL0csRUFBb0gsUUFBUSxtREFBNUgsRUFBekI7QUFDRDtBQUNEO0FBQ0Q7OztxQ0FtQmUsUSxFQUFVO0FBQ3hCLFVBQUksU0FBUyxLQUFLLE9BQWxCO0FBQ0E7QUFDQSxVQUFJLFlBQVksQ0FBWixJQUFpQixXQUFXLE9BQU8sTUFBdkMsRUFBK0M7QUFDN0M7QUFDQSxZQUFJLEtBQUssS0FBVCxFQUFnQjtBQUNmLHVCQUFhLEtBQUssS0FBbEI7QUFDQSxlQUFLLEtBQUwsR0FBYSxJQUFiO0FBQ0E7QUFDRCxZQUFJLEtBQUssTUFBTCxLQUFnQixRQUFwQixFQUE4QjtBQUM1Qix5QkFBTyxHQUFQLHlCQUFpQyxRQUFqQztBQUNBLGVBQUssTUFBTCxHQUFjLFFBQWQ7QUFDQSxlQUFLLEdBQUwsQ0FBUyxPQUFULENBQWlCLGlCQUFNLFlBQXZCLEVBQXFDLEVBQUMsT0FBTyxRQUFSLEVBQXJDO0FBQ0Q7QUFDRCxZQUFJLFFBQVEsT0FBTyxRQUFQLENBQVo7QUFBQSxZQUE4QixlQUFlLE1BQU0sT0FBbkQ7QUFDQztBQUNELFlBQUksQ0FBQyxZQUFELElBQWlCLGFBQWEsSUFBYixLQUFzQixJQUEzQyxFQUFpRDtBQUMvQztBQUNBLGNBQUksUUFBUSxNQUFNLEtBQWxCO0FBQ0EsZUFBSyxHQUFMLENBQVMsT0FBVCxDQUFpQixpQkFBTSxhQUF2QixFQUFzQyxFQUFDLEtBQUssTUFBTSxHQUFOLENBQVUsS0FBVixDQUFOLEVBQXdCLE9BQU8sUUFBL0IsRUFBeUMsSUFBSSxLQUE3QyxFQUF0QztBQUNEO0FBQ0YsT0FsQkQsTUFrQk87QUFDTDtBQUNBLGFBQUssR0FBTCxDQUFTLE9BQVQsQ0FBaUIsaUJBQU0sS0FBdkIsRUFBOEIsRUFBQyxNQUFPLG1CQUFXLFdBQW5CLEVBQWdDLFNBQVMscUJBQWEsa0JBQXRELEVBQTBFLE9BQU8sUUFBakYsRUFBMkYsT0FBTyxLQUFsRyxFQUF5RyxRQUFRLG1CQUFqSCxFQUE5QjtBQUNEO0FBQ0g7Ozs0QkErQ1EsSSxFQUFNO0FBQ1osVUFBRyxLQUFLLEtBQVIsRUFBZTtBQUNiO0FBQ0Q7O0FBRUQsVUFBSSxVQUFVLEtBQUssT0FBbkI7QUFBQSxVQUE0QixNQUFNLEtBQUssR0FBdkM7QUFBQSxVQUE0QyxnQkFBNUM7QUFBQSxVQUFxRCxjQUFyRDtBQUFBLFVBQTRELGFBQWEsS0FBekU7QUFBQSxVQUFnRixnQkFBZ0IsSUFBSSxhQUFwRztBQUFBLFVBQW1ILGVBQWUsY0FBYyxZQUFoSjtBQUNBLFVBQUksY0FBYyxLQUFsQjtBQUNBO0FBQ0EsY0FBTyxPQUFQO0FBQ0UsYUFBSyxxQkFBYSxlQUFsQjtBQUNBLGFBQUsscUJBQWEsaUJBQWxCO0FBQ0EsYUFBSyxxQkFBYSx1QkFBbEI7QUFDQSxhQUFLLHFCQUFhLGNBQWxCO0FBQ0EsYUFBSyxxQkFBYSxnQkFBbEI7QUFDRyxvQkFBVSxLQUFLLElBQUwsQ0FBVSxLQUFwQjtBQUNBO0FBQ0gsYUFBSyxxQkFBYSxnQkFBbEI7QUFDQSxhQUFLLHFCQUFhLGtCQUFsQjtBQUNFLG9CQUFVLEtBQUssT0FBTCxDQUFhLEtBQXZCO0FBQ0EsdUJBQWEsSUFBYjtBQUNBO0FBQ0YsYUFBSyxxQkFBYSxpQkFBbEI7QUFDRSxvQkFBVSxLQUFLLEtBQWY7QUFDQTtBQUNGLGFBQUsscUJBQWEsb0JBQWxCO0FBQ0Usb0JBQVUsS0FBSyxPQUFMLENBQWEsS0FBdkI7QUFDQSx1QkFBYSxJQUFiO0FBQ0Esd0JBQWMsSUFBZDtBQUNBO0FBQ0Y7QUFDRTtBQXRCSjtBQXdCQTs7OztBQUlBLFVBQUksWUFBWSxTQUFoQixFQUEyQjtBQUN6QixnQkFBUSxLQUFLLE9BQUwsQ0FBYSxPQUFiLENBQVI7QUFDQSxZQUFHLENBQUMsTUFBTSxTQUFWLEVBQXFCO0FBQ25CLGdCQUFNLFNBQU4sR0FBa0IsQ0FBbEI7QUFDRCxTQUZELE1BRU87QUFDTCxnQkFBTSxTQUFOO0FBQ0Q7QUFDRDtBQUNBO0FBQ0EsWUFBTSxtQkFBbUIsTUFBTSxHQUFOLENBQVUsTUFBbkM7QUFDRCxZQUFJLG1CQUFtQixDQUFuQixJQUF3QixNQUFNLFNBQU4sR0FBa0IsZ0JBQTlDLEVBQWdFO0FBQzdELGdCQUFNLEtBQU4sR0FBYyxDQUFDLE1BQU0sS0FBTixHQUFjLENBQWYsSUFBb0IsZ0JBQWxDO0FBQ0EsZ0JBQU0sT0FBTixHQUFnQixTQUFoQjtBQUNBLHlCQUFPLElBQVAsdUJBQWdDLE9BQWhDLG1CQUFxRCxPQUFyRCwyQ0FBa0csTUFBTSxLQUF4RztBQUNELFNBSkYsTUFJUTtBQUNMLGNBQUksV0FBSixFQUFpQjtBQUNmLDJCQUFPLElBQVA7QUFDQSxpQkFBSyxPQUFMLEdBQWUsS0FBSyxNQUFMLENBQVksTUFBWixDQUFtQixVQUFDLENBQUQsRUFBSSxLQUFKO0FBQUEscUJBQWMsVUFBVSxPQUF4QjtBQUFBLGFBQW5CLENBQWY7QUFDQSxnQkFBSSxZQUFKLEdBQW1CLENBQUMsQ0FBcEI7QUFDQSxnQkFBSSxPQUFKLENBQVksaUJBQU0sYUFBbEIsRUFBaUMsRUFBRSxPQUFPLE9BQVQsRUFBakM7QUFDRDtBQUNEO0FBQ0EsY0FBSSxjQUFnQixLQUFLLFlBQUwsS0FBc0IsQ0FBQyxDQUF4QixJQUE4QixPQUFqRDtBQUNBLGNBQUksV0FBSixFQUFpQjtBQUNmLDJCQUFPLElBQVAsdUJBQWdDLE9BQWhDO0FBQ0EsMEJBQWMsYUFBZCxHQUE4QixLQUFLLEdBQUwsQ0FBUyxZQUFULEVBQXNCLFVBQVEsQ0FBOUIsQ0FBOUI7QUFDRCxXQUhELE1BR08sSUFBRyxTQUFTLE1BQU0sT0FBZixJQUEwQixNQUFNLE9BQU4sQ0FBYyxJQUEzQyxFQUFpRDtBQUN0RCwyQkFBTyxJQUFQLHVCQUFnQyxPQUFoQztBQUNBLGdCQUFJLFVBQUosRUFBZ0I7QUFDZDtBQUNBLG1CQUFLLE1BQUwsR0FBYyxTQUFkO0FBQ0Q7QUFDRDtBQUNELFdBUE0sTUFPQSxJQUFJLFlBQVkscUJBQWEsZ0JBQXpCLElBQ0EsWUFBWSxxQkFBYSxrQkFEN0IsRUFDaUQ7QUFDdEQsZ0JBQUksUUFBUSxJQUFJLEtBQWhCOztBQUNFO0FBQ0UsNEJBQWdCLFNBQVMsdUJBQWEsVUFBYixDQUF3QixLQUF4QixFQUE4QixNQUFNLFdBQXBDLENBQVQsSUFBNkQsdUJBQWEsVUFBYixDQUF3QixLQUF4QixFQUE4QixNQUFNLFdBQU4sR0FBa0IsR0FBaEQsQ0FGakY7QUFHQSxnQkFBSSxhQUFKLEVBQW1CO0FBQ2pCLGtCQUFJLGFBQWEsSUFBSSxNQUFKLENBQVcsc0JBQTVCO0FBQ0EsNkJBQU8sSUFBUCx1QkFBZ0MsT0FBaEMsdUNBQXlFLFVBQXpFO0FBQ0EsbUJBQUssS0FBTCxHQUFhLFdBQVcsS0FBSyxNQUFoQixFQUF1QixVQUF2QixDQUFiO0FBQ0QsYUFKRCxNQUlPO0FBQ0wsNkJBQU8sS0FBUCxxQkFBK0IsT0FBL0I7QUFDQSxtQkFBSyxNQUFMLEdBQWMsU0FBZDtBQUNBO0FBQ0Esa0JBQUksS0FBSyxLQUFULEVBQWdCO0FBQ2QsNkJBQWEsS0FBSyxLQUFsQjtBQUNBLHFCQUFLLEtBQUwsR0FBYSxJQUFiO0FBQ0Q7QUFDRDtBQUNBLG1CQUFLLEtBQUwsR0FBYSxJQUFiO0FBQ0Esa0JBQUksT0FBSixDQUFZLGlCQUFNLEtBQWxCLEVBQXlCLElBQXpCO0FBQ0Q7QUFDRjtBQUNGO0FBQ0Y7QUFDRjs7QUFFRDs7OztpQ0FDYSxJLEVBQU07QUFDakIsVUFBTSxhQUFhLEtBQUssSUFBeEI7QUFDQSxVQUFJLGNBQWMsV0FBVyxJQUFYLEtBQW9CLE1BQXRDLEVBQThDO0FBQzVDLFlBQU0sUUFBUSxLQUFLLE9BQUwsQ0FBYSxXQUFXLEtBQXhCLENBQWQ7QUFDQSxZQUFJLEtBQUosRUFBVztBQUNULGdCQUFNLFNBQU4sR0FBa0IsQ0FBbEI7QUFDRDtBQUNGO0FBQ0Y7OztrQ0FFYSxJLEVBQU07QUFDbEIsVUFBTSxVQUFVLEtBQUssS0FBckI7QUFDQztBQUNELFVBQUksWUFBWSxLQUFLLE1BQXJCLEVBQTZCO0FBQzNCLFlBQUksV0FBVyxLQUFLLE9BQUwsQ0FBYSxPQUFiLENBQWY7QUFDQTtBQUNBLGlCQUFTLFNBQVQsR0FBcUIsQ0FBckI7QUFDQSxZQUFJLGFBQWEsS0FBSyxPQUF0QjtBQUNBO0FBQ0EsWUFBSSxXQUFXLElBQWYsRUFBcUI7QUFDbkIsY0FBSSxpQkFBaUIsUUFBTyxXQUFXLHFCQUFYLEdBQW1DLFdBQVcscUJBQTlDLEdBQXNFLFdBQVcsY0FBeEYsQ0FBckI7QUFBQSxjQUNJLFlBQVcsS0FBSyxPQUFMLENBQWEsS0FBSyxLQUFsQixDQURmO0FBQUEsY0FFSSxhQUFhLFVBQVMsT0FGMUI7QUFHQSxjQUFJLGNBQWMsV0FBVyxLQUFYLEtBQXFCLFdBQVcsS0FBbEQsRUFBeUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0EsOEJBQWlCLENBQWpCO0FBQ0EsMkJBQU8sR0FBUDtBQUNEO0FBQ0Q7QUFDQSw0QkFBa0IsWUFBWSxHQUFaLEtBQW9CLEtBQUssS0FBTCxDQUFXLFFBQWpEO0FBQ0E7QUFDQSwyQkFBaUIsS0FBSyxHQUFMLENBQVMsSUFBVCxFQUFjLEtBQUssS0FBTCxDQUFXLGNBQVgsQ0FBZCxDQUFqQjtBQUNBLHlCQUFPLEdBQVAsK0JBQXVDLGNBQXZDO0FBQ0EsZUFBSyxLQUFMLEdBQWEsV0FBVyxLQUFLLE1BQWhCLEVBQXVCLGNBQXZCLENBQWI7QUFDRCxTQWpCRCxNQWlCTztBQUNMLGVBQUssS0FBTCxHQUFhLElBQWI7QUFDRDtBQUNGO0FBQ0Y7OzsyQkFFTTtBQUNMLFVBQUksVUFBVSxLQUFLLE1BQW5CO0FBQ0EsVUFBSSxZQUFZLFNBQVosSUFBeUIsS0FBSyxPQUFsQyxFQUEyQztBQUN6QyxZQUFJLFFBQVEsS0FBSyxPQUFMLENBQWEsT0FBYixDQUFaO0FBQUEsWUFBbUMsUUFBUSxNQUFNLEtBQWpEO0FBQ0EsYUFBSyxHQUFMLENBQVMsT0FBVCxDQUFpQixpQkFBTSxhQUF2QixFQUFzQyxFQUFDLEtBQUssTUFBTSxHQUFOLENBQVUsS0FBVixDQUFOLEVBQXdCLE9BQU8sT0FBL0IsRUFBd0MsSUFBSSxLQUE1QyxFQUF0QztBQUNEO0FBQ0Y7Ozt3QkF6T1k7QUFDWCxhQUFPLEtBQUssT0FBWjtBQUNEOzs7d0JBRVc7QUFDVixhQUFPLEtBQUssTUFBWjtBQUNELEs7c0JBRVMsUSxFQUFVO0FBQ2xCLFVBQUksU0FBUyxLQUFLLE9BQWxCO0FBQ0EsVUFBSSxVQUFVLE9BQU8sTUFBUCxHQUFnQixRQUE5QixFQUF3QztBQUN0QyxZQUFJLEtBQUssTUFBTCxLQUFnQixRQUFoQixJQUE0QixPQUFPLFFBQVAsRUFBaUIsT0FBakIsS0FBNkIsU0FBN0QsRUFBd0U7QUFDdEUsZUFBSyxnQkFBTCxDQUFzQixRQUF0QjtBQUNEO0FBQ0Y7QUFDRjs7O3dCQTZCaUI7QUFDaEIsYUFBTyxLQUFLLFlBQVo7QUFDRCxLO3NCQUVlLFEsRUFBVTtBQUN4QixXQUFLLFlBQUwsR0FBb0IsUUFBcEI7QUFDQSxVQUFJLEtBQUssV0FBTCxLQUFxQixTQUF6QixFQUFvQztBQUNsQyxhQUFLLFdBQUwsR0FBbUIsUUFBbkI7QUFDRDtBQUNELFVBQUksYUFBYSxDQUFDLENBQWxCLEVBQXFCO0FBQ25CLGFBQUssS0FBTCxHQUFhLFFBQWI7QUFDRDtBQUNGOzs7d0JBRWdCO0FBQ2YsYUFBTyxLQUFLLFdBQVo7QUFDRCxLO3NCQUVjLFEsRUFBVTtBQUN2QixXQUFLLFdBQUwsR0FBbUIsUUFBbkI7QUFDRDs7O3dCQUVnQjtBQUNmO0FBQ0E7QUFDQSxVQUFJLEtBQUssV0FBTCxLQUFxQixTQUF6QixFQUFvQztBQUNsQyxZQUFJLG1CQUFtQixLQUFLLEdBQUwsQ0FBUyxNQUFULENBQWdCLFVBQXZDO0FBQ0EsWUFBSSxxQkFBcUIsU0FBekIsRUFBb0M7QUFDbEMsaUJBQU8sZ0JBQVA7QUFDRCxTQUZELE1BRU87QUFDTCxpQkFBTyxLQUFLLFdBQVo7QUFDRDtBQUNGLE9BUEQsTUFPTztBQUNMLGVBQU8sS0FBSyxXQUFaO0FBQ0Q7QUFDRixLO3NCQUVjLFEsRUFBVTtBQUN2QjtBQUNBLFVBQUksYUFBYSxDQUFDLENBQWxCLEVBQXFCO0FBQ25CLG1CQUFXLEtBQUssR0FBTCxDQUFTLFFBQVQsRUFBbUIsS0FBSyxHQUFMLENBQVMsYUFBVCxDQUF1QixZQUExQyxDQUFYO0FBQ0Q7QUFDRCxXQUFLLFdBQUwsR0FBbUIsUUFBbkI7QUFDRDs7O3dCQW9KbUI7QUFDbEIsVUFBSSxLQUFLLFlBQUwsS0FBc0IsQ0FBQyxDQUEzQixFQUE4QjtBQUM1QixlQUFPLEtBQUssWUFBWjtBQUNELE9BRkQsTUFFTztBQUNOLGVBQU8sS0FBSyxHQUFMLENBQVMsYUFBVCxDQUF1QixhQUE5QjtBQUNBO0FBQ0YsSztzQkFFaUIsUyxFQUFXO0FBQzNCLFdBQUssS0FBTCxHQUFhLFNBQWI7QUFDQSxVQUFJLEtBQUssWUFBTCxLQUFzQixDQUFDLENBQTNCLEVBQThCO0FBQzVCLGFBQUssR0FBTCxDQUFTLGFBQVQsQ0FBdUIsYUFBdkIsR0FBdUMsU0FBdkM7QUFDRDtBQUNGOzs7Ozs7a0JBR1ksZTs7Ozs7Ozs7Ozs7QUN0WGY7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7QUFDQTs7Ozs7Ozs7K2VBWkE7Ozs7QUFjQSxJQUFNLFFBQVE7QUFDWixXQUFVLFNBREU7QUFFWixRQUFPLE1BRks7QUFHWixlQUFjLGFBSEY7QUFJWixnQkFBZSxjQUpIO0FBS1osOEJBQTZCLDRCQUxqQjtBQU1aLGlCQUFnQixlQU5KO0FBT1osV0FBVSxTQVBFO0FBUVosVUFBUyxRQVJHO0FBU1osbUJBQWtCLGlCQVROO0FBVVosU0FBUSxPQVZJO0FBV1osU0FBUTtBQVhJLENBQWQ7O0lBY00sZ0I7OztBQUVKLDRCQUFZLEdBQVosRUFBaUI7QUFBQTs7QUFBQSxvSUFDVCxHQURTLEVBRWIsaUJBQU0sY0FGTyxFQUdiLGlCQUFNLGVBSE8sRUFJYixpQkFBTSxnQkFKTyxFQUtiLGlCQUFNLGVBTE8sRUFNYixpQkFBTSxZQU5PLEVBT2IsaUJBQU0sVUFQTyxFQVFiLGlCQUFNLFdBUk8sRUFTYixpQkFBTSwyQkFUTyxFQVViLGlCQUFNLHlCQVZPLEVBV2IsaUJBQU0saUJBWE8sRUFZYixpQkFBTSxXQVpPLEVBYWIsaUJBQU0sS0FiTyxFQWNiLGlCQUFNLHFCQWRPLEVBZWIsaUJBQU0sb0JBZk8sRUFnQmIsaUJBQU0sY0FoQk8sRUFpQmIsaUJBQU0sZUFqQk8sRUFrQmIsaUJBQU0sY0FsQk8sRUFtQmIsaUJBQU0sYUFuQk87O0FBc0JmLFVBQUssTUFBTCxHQUFjLElBQUksTUFBbEI7QUFDQSxVQUFLLGNBQUwsR0FBc0IsS0FBdEI7QUFDQSxVQUFLLEtBQUwsR0FBYSxDQUFiO0FBQ0EsVUFBSyxNQUFMLEdBQWMsTUFBSyxJQUFMLENBQVUsSUFBVixPQUFkO0FBekJlO0FBMEJoQjs7Ozs4QkFFUztBQUNSLFdBQUssUUFBTDtBQUNBLFVBQUksS0FBSyxLQUFULEVBQWdCO0FBQ2Qsc0JBQWMsS0FBSyxLQUFuQjtBQUNBLGFBQUssS0FBTCxHQUFhLElBQWI7QUFDRDtBQUNELDZCQUFhLFNBQWIsQ0FBdUIsT0FBdkIsQ0FBK0IsSUFBL0IsQ0FBb0MsSUFBcEM7QUFDQSxXQUFLLEtBQUwsR0FBYSxNQUFNLE9BQW5CO0FBQ0Q7Ozs4QkFFUyxhLEVBQWU7QUFDdkIsVUFBSSxLQUFLLE1BQVQsRUFBaUI7QUFDZixZQUFJLGtCQUFrQixLQUFLLGVBQTNCO0FBQUEsWUFBNEMsTUFBTSxLQUFLLEdBQXZEO0FBQ0EsYUFBSyxRQUFMO0FBQ0EsWUFBSSxDQUFDLEtBQUssS0FBVixFQUFpQjtBQUNmLGVBQUssS0FBTCxHQUFhLFlBQVksS0FBSyxNQUFqQixFQUF5QixHQUF6QixDQUFiO0FBQ0Q7QUFDRCxhQUFLLEtBQUwsR0FBYSxDQUFDLENBQWQ7QUFDQSxhQUFLLGFBQUwsR0FBcUIsQ0FBckI7QUFDQSxZQUFJLENBQUMsS0FBSyxrQkFBVixFQUE4QjtBQUM1QjtBQUNBLGNBQUksYUFBYSxJQUFJLFVBQXJCO0FBQ0EsY0FBSSxlQUFlLENBQUMsQ0FBcEIsRUFBdUI7QUFDckI7QUFDQSx5QkFBYSxDQUFiO0FBQ0EsaUJBQUssV0FBTCxHQUFtQixJQUFuQjtBQUNEO0FBQ0Q7QUFDQTtBQUNBLGVBQUssS0FBTCxHQUFhLElBQUksYUFBSixHQUFvQixVQUFqQztBQUNBLGVBQUssY0FBTCxHQUFzQixLQUF0QjtBQUNEO0FBQ0Q7QUFDQSxZQUFJLGtCQUFrQixDQUFsQixJQUF1QixrQkFBa0IsQ0FBQyxDQUE5QyxFQUFpRDtBQUMvQyx5QkFBTyxHQUFQLG1EQUEyRCxnQkFBZ0IsT0FBaEIsQ0FBd0IsQ0FBeEIsQ0FBM0Q7QUFDQSwwQkFBZ0IsZUFBaEI7QUFDRDtBQUNELGFBQUssS0FBTCxHQUFhLE1BQU0sSUFBbkI7QUFDQSxhQUFLLGdCQUFMLEdBQXdCLEtBQUssYUFBTCxHQUFxQixLQUFLLGVBQUwsR0FBdUIsYUFBcEU7QUFDQSxhQUFLLElBQUw7QUFDRCxPQTdCRCxNQTZCTztBQUNMLHVCQUFPLElBQVAsQ0FBWSxpREFBWjtBQUNBLGFBQUssS0FBTCxHQUFhLE1BQU0sT0FBbkI7QUFDRDtBQUNGOzs7K0JBRVU7QUFDVCxVQUFJLE9BQU8sS0FBSyxXQUFoQjtBQUNBLFVBQUksSUFBSixFQUFVO0FBQ1IsWUFBSSxLQUFLLE1BQVQsRUFBaUI7QUFDZixlQUFLLE1BQUwsQ0FBWSxLQUFaO0FBQ0Q7QUFDRCxhQUFLLFdBQUwsR0FBbUIsSUFBbkI7QUFDRDtBQUNELFdBQUssWUFBTCxHQUFvQixJQUFwQjtBQUNBLFVBQUksS0FBSyxPQUFULEVBQWtCO0FBQ2hCLGFBQUssT0FBTCxDQUFhLE9BQWI7QUFDQSxhQUFLLE9BQUwsR0FBZSxJQUFmO0FBQ0Q7QUFDRCxXQUFLLEtBQUwsR0FBYSxNQUFNLE9BQW5CO0FBQ0Q7OzsyQkFFTTtBQUNMLFdBQUssS0FBTDtBQUNBLFVBQUksS0FBSyxLQUFMLEtBQWUsQ0FBbkIsRUFBc0I7QUFDcEIsYUFBSyxNQUFMO0FBQ0EsWUFBSSxLQUFLLEtBQUwsR0FBYSxDQUFqQixFQUFvQjtBQUNsQixxQkFBVyxLQUFLLElBQWhCLEVBQXNCLENBQXRCO0FBQ0Q7QUFDRCxhQUFLLEtBQUwsR0FBYSxDQUFiO0FBQ0Q7QUFDRjs7OzZCQUVRO0FBQ1AsY0FBTyxLQUFLLEtBQVo7QUFDRSxhQUFLLE1BQU0sS0FBWDtBQUNFO0FBQ0E7QUFDRixhQUFLLE1BQU0sZUFBWDtBQUNBO0FBQ0UsZUFBSyxhQUFMLEdBQXFCLENBQXJCO0FBQ0E7QUFDRixhQUFLLE1BQU0sSUFBWDtBQUNFO0FBQ0E7QUFDQSxjQUFJLENBQUMsS0FBSyxXQUFMLEVBQUwsRUFBeUI7QUFDdkI7QUFDRDtBQUNEO0FBQ0YsYUFBSyxNQUFNLGFBQVg7QUFDRSxjQUFJLFFBQVEsS0FBSyxNQUFMLENBQVksS0FBSyxLQUFqQixDQUFaO0FBQ0E7QUFDQSxjQUFJLFNBQVMsTUFBTSxPQUFuQixFQUE0QjtBQUMxQixpQkFBSyxLQUFMLEdBQWEsTUFBTSxJQUFuQjtBQUNEO0FBQ0Q7QUFDRixhQUFLLE1BQU0sMEJBQVg7QUFDRSxjQUFJLE1BQU0sWUFBWSxHQUFaLEVBQVY7QUFDQSxjQUFJLFlBQVksS0FBSyxTQUFyQjtBQUNBO0FBQ0EsY0FBRyxDQUFDLFNBQUQsSUFBZSxPQUFPLFNBQXRCLElBQXFDLEtBQUssS0FBTCxJQUFjLEtBQUssS0FBTCxDQUFXLE9BQWpFLEVBQTJFO0FBQ3pFLDJCQUFPLEdBQVA7QUFDQSxpQkFBSyxLQUFMLEdBQWEsTUFBTSxJQUFuQjtBQUNEO0FBQ0Q7QUFDRixhQUFLLE1BQU0sS0FBWDtBQUNBLGFBQUssTUFBTSxPQUFYO0FBQ0EsYUFBSyxNQUFNLFlBQVg7QUFDQSxhQUFLLE1BQU0sT0FBWDtBQUNBLGFBQUssTUFBTSxNQUFYO0FBQ0EsYUFBSyxNQUFNLEtBQVg7QUFDRTtBQUNGO0FBQ0U7QUF2Q0o7QUF5Q0E7QUFDQSxXQUFLLFlBQUw7QUFDQTtBQUNBLFdBQUsscUJBQUw7QUFDRDs7QUFFRDtBQUNBO0FBQ0E7Ozs7a0NBQ2M7QUFDWixVQUFNLE1BQU0sS0FBSyxHQUFqQjtBQUFBLFVBQ00sU0FBUyxJQUFJLE1BRG5CO0FBQUEsVUFFTSxRQUFRLEtBQUssS0FGbkI7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFJLEtBQUssZUFBTCxLQUF5QixTQUF6QixJQUFzQyxDQUFDLEtBQXZDLEtBQ0QsS0FBSyxrQkFBTCxJQUEyQixDQUFDLE9BQU8saUJBRGxDLENBQUosRUFDMEQ7QUFDeEQsZUFBTyxJQUFQO0FBQ0Q7O0FBRUQ7QUFDQSxVQUFJLE1BQU0sQ0FBVjtBQUNBLFVBQUksS0FBSyxjQUFULEVBQXlCO0FBQ3ZCLGNBQU0sTUFBTSxXQUFaO0FBQ0QsT0FGRCxNQUVPLElBQUksS0FBSyxnQkFBVCxFQUEyQjtBQUNoQyxjQUFNLEtBQUssZ0JBQVg7QUFDRDs7QUFFRDtBQUNBLFVBQUksUUFBUSxJQUFJLGFBQWhCO0FBQUEsVUFDSSxZQUFZLEtBQUssTUFBTCxDQUFZLEtBQVosQ0FEaEI7QUFBQSxVQUVJLGVBQWUsVUFBVSxPQUY3QjtBQUFBLFVBR0ksa0JBSEo7O0FBS0E7QUFDQSxVQUFJLFlBQUosRUFBa0I7QUFDaEIsb0JBQVksS0FBSyxHQUFMLENBQVMsSUFBSSxPQUFPLGFBQVgsR0FBMkIsWUFBcEMsRUFBa0QsT0FBTyxlQUF6RCxDQUFaO0FBQ0QsT0FGRCxNQUVPO0FBQ0wsb0JBQVksT0FBTyxlQUFuQjtBQUNEO0FBQ0Qsa0JBQVksS0FBSyxHQUFMLENBQVMsU0FBVCxFQUFvQixPQUFPLGtCQUEzQixDQUFaOztBQUVBO0FBQ0E7O0FBRUEsVUFBTSxhQUFhLHVCQUFhLFVBQWIsQ0FBd0IsS0FBSyxXQUFMLEdBQW1CLEtBQUssV0FBeEIsR0FBc0MsS0FBOUQsRUFBcUUsR0FBckUsRUFBMEUsT0FBTyxhQUFqRixDQUFuQjtBQUFBLFVBQ00sWUFBWSxXQUFXLEdBRDdCO0FBRUE7QUFDQSxVQUFJLGFBQWEsU0FBakIsRUFBNEI7QUFDMUIsZUFBTyxJQUFQO0FBQ0Q7O0FBRUQ7QUFDQSxxQkFBTyxLQUFQLHVCQUFpQyxVQUFVLE9BQVYsQ0FBa0IsQ0FBbEIsQ0FBakMseUJBQXlFLFVBQVUsT0FBVixDQUFrQixDQUFsQixDQUF6RTs7QUFFQTtBQUNBLFdBQUssS0FBTCxHQUFhLElBQUksYUFBSixHQUFvQixLQUFqQzs7QUFFQSxVQUFNLGVBQWUsVUFBVSxPQUEvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQUksT0FBTyxZQUFQLEtBQXdCLFdBQXhCLElBQXVDLGFBQWEsSUFBYixJQUFxQixLQUFLLGVBQUwsS0FBeUIsS0FBekYsRUFBZ0c7QUFDOUYsYUFBSyxLQUFMLEdBQWEsTUFBTSxhQUFuQjtBQUNBLGVBQU8sSUFBUDtBQUNEOztBQUVEO0FBQ0EsVUFBSSxlQUFlLEtBQUssWUFBeEI7QUFDQSxVQUFJLENBQUMsYUFBYSxJQUFkLElBQXNCLFlBQXRCLElBQXNDLGFBQWEsRUFBYixLQUFvQixhQUFhLEtBQTNFLEVBQWtGO0FBQzlFO0FBQ0E7QUFDQTtBQUNBLFlBQUssQ0FBQyxNQUFNLE9BQVAsSUFBa0IsV0FBVyxHQUE5QixJQUF1QyxNQUFNLFFBQU4sR0FBZSxXQUFXLEdBQTNCLElBQW1DLGFBQWEsUUFBYixHQUFzQixDQUFuRyxFQUFzRztBQUN0RztBQUNBLGNBQUksT0FBTyxFQUFYO0FBQ0EsY0FBSSxLQUFLLFFBQVQsRUFBbUI7QUFDakIsaUJBQUssSUFBTCxHQUFZLE9BQVo7QUFDRDtBQUNELGVBQUssR0FBTCxDQUFTLE9BQVQsQ0FBaUIsaUJBQU0sVUFBdkIsRUFBa0MsSUFBbEM7QUFDQSxlQUFLLEtBQUwsR0FBYSxNQUFNLEtBQW5CO0FBQ0EsaUJBQU8sSUFBUDtBQUNEO0FBQ0Y7O0FBRUQ7QUFDQSxhQUFPLEtBQUssa0JBQUwsQ0FBd0IsRUFBQyxRQUFELEVBQU0sc0JBQU4sRUFBa0IsMEJBQWxCLEVBQXhCLENBQVA7QUFDRDs7OzZDQUVtRDtBQUFBLFVBQWhDLEdBQWdDLFFBQWhDLEdBQWdDO0FBQUEsVUFBM0IsVUFBMkIsUUFBM0IsVUFBMkI7QUFBQSxVQUFmLFlBQWUsUUFBZixZQUFlOztBQUNsRCxVQUFNLGVBQWUsS0FBSyxZQUExQjtBQUFBLFVBQ00sUUFBUSxLQUFLLEtBRG5CO0FBQUEsVUFFTSxZQUFZLGFBQWEsU0FGL0I7QUFBQSxVQUdNLFVBQVUsVUFBVSxNQUgxQjs7QUFLQTtBQUNBLFVBQUksWUFBWSxDQUFoQixFQUFtQjtBQUNqQixlQUFPLEtBQVA7QUFDRDs7QUFFRDtBQUNBLFVBQUksUUFBUSxVQUFVLENBQVYsRUFBYSxLQUF6QjtBQUFBLFVBQ0ksTUFBTSxVQUFVLFVBQVEsQ0FBbEIsRUFBcUIsS0FBckIsR0FBNkIsVUFBVSxVQUFRLENBQWxCLEVBQXFCLFFBRDVEO0FBQUEsVUFFSSxZQUFZLFdBQVcsR0FGM0I7QUFBQSxVQUdJLGFBSEo7O0FBS0U7QUFDRixVQUFJLGFBQWEsSUFBakIsRUFBdUI7QUFDckIsWUFBSSwwQkFBMEIsS0FBSyxNQUFMLENBQVksdUJBQTFDO0FBQ0EsWUFBRyxVQUFVLHVCQUFiLEVBQXFDO0FBQ25DLHlCQUFPLElBQVAsc0VBQStFLE9BQS9FLFdBQTRGLHVCQUE1RjtBQUNBLGlCQUFPLEtBQVA7QUFDRDs7QUFFRCxlQUFPLEtBQUssMEJBQUwsQ0FBZ0MsRUFBQywwQkFBRCxFQUFlLG9CQUFmLEVBQTBCLFlBQTFCLEVBQWlDLFFBQWpDLEVBQXNDLDBCQUF0QyxFQUFvRCxvQkFBcEQsRUFBK0QsZ0JBQS9ELEVBQWhDLENBQVA7QUFDQTtBQUNBLFlBQUksU0FBUyxJQUFiLEVBQW1CO0FBQ2pCLGlCQUFPLEtBQVA7QUFDRDtBQUVGLE9BYkQsTUFhTztBQUNMO0FBQ0EsWUFBSSxZQUFZLEtBQWhCLEVBQXVCO0FBQ3JCLGlCQUFPLFVBQVUsQ0FBVixDQUFQO0FBQ0Q7QUFDRjtBQUNELFVBQUksQ0FBQyxJQUFMLEVBQVc7QUFDVCxlQUFPLEtBQUssYUFBTCxDQUFtQixFQUFDLFlBQUQsRUFBUSwwQkFBUixFQUFzQixnQkFBdEIsRUFBK0Isb0JBQS9CLEVBQTBDLG9CQUExQyxFQUFxRCxRQUFyRCxFQUEwRCwwQkFBMUQsRUFBbkIsQ0FBUDtBQUNEO0FBQ0QsVUFBRyxJQUFILEVBQVM7QUFDUCxlQUFPLEtBQUssa0JBQUwsQ0FBd0IsRUFBQyxVQUFELEVBQU8sWUFBUCxFQUFjLDBCQUFkLEVBQTRCLFFBQTVCLEVBQWlDLG9CQUFqQyxFQUF4QixDQUFQO0FBQ0Q7QUFDRCxhQUFPLElBQVA7QUFDRDs7O3NEQUVtRztBQUFBLFVBQXhFLFlBQXdFLFNBQXhFLFlBQXdFO0FBQUEsVUFBMUQsU0FBMEQsU0FBMUQsU0FBMEQ7QUFBQSxVQUEvQyxLQUErQyxTQUEvQyxLQUErQztBQUFBLFVBQXhDLEdBQXdDLFNBQXhDLEdBQXdDO0FBQUEsVUFBbkMsWUFBbUMsU0FBbkMsWUFBbUM7QUFBQSxVQUFyQixTQUFxQixTQUFyQixTQUFxQjtBQUFBLFVBQVYsT0FBVSxTQUFWLE9BQVU7O0FBQ2xHLFVBQU0sU0FBUyxLQUFLLEdBQUwsQ0FBUyxNQUF4QjtBQUFBLFVBQWdDLFFBQVEsS0FBSyxLQUE3Qzs7QUFFQSxVQUFJLGFBQUo7O0FBRUE7QUFDQTtBQUNBLFVBQUksYUFBYSxPQUFPLHNCQUFQLEtBQWtDLFNBQWxDLEdBQThDLE9BQU8sc0JBQXJELEdBQThFLE9BQU8sMkJBQVAsR0FBbUMsYUFBYSxjQUEvSTs7QUFFQSxVQUFJLFlBQVksS0FBSyxHQUFMLENBQVMsS0FBVCxFQUFnQixNQUFNLFVBQXRCLENBQWhCLEVBQW1EO0FBQy9DLFlBQUksbUJBQW1CLEtBQUssZ0JBQUwsR0FBd0IsS0FBSyxtQkFBTCxDQUF5QixLQUF6QixFQUFnQyxZQUFoQyxDQUEvQztBQUNBLHVCQUFPLEdBQVAsa0JBQTBCLFVBQVUsT0FBVixDQUFrQixDQUFsQixDQUExQiwwRkFBbUksaUJBQWlCLE9BQWpCLENBQXlCLENBQXpCLENBQW5JO0FBQ0Esb0JBQVksZ0JBQVo7QUFDQSxZQUFJLFNBQVMsTUFBTSxVQUFmLElBQTZCLE1BQU0sUUFBTixHQUFpQixnQkFBbEQsRUFBb0U7QUFDbEUsZ0JBQU0sV0FBTixHQUFvQixnQkFBcEI7QUFDRDtBQUNKOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBSSxhQUFhLFFBQWIsSUFBeUIsWUFBWSxHQUFyQyxJQUE0QyxLQUE1QyxJQUFxRCxNQUFNLFVBQS9ELEVBQTJFO0FBQ3pFLGVBQU8sSUFBUDtBQUNEOztBQUVELFVBQUksS0FBSyxrQkFBTCxJQUEyQixDQUFDLGFBQWEsUUFBN0MsRUFBdUQ7QUFDckQ7Ozs7QUFJQSxZQUFJLFlBQUosRUFBa0I7QUFDaEIsY0FBSSxXQUFXLGFBQWEsRUFBYixHQUFrQixDQUFqQztBQUNBLGNBQUksWUFBWSxhQUFhLE9BQXpCLElBQW9DLFlBQVksYUFBYSxLQUFqRSxFQUF3RTtBQUN0RSxtQkFBTyxVQUFVLFdBQVcsYUFBYSxPQUFsQyxDQUFQO0FBQ0EsMkJBQU8sR0FBUCxpRUFBeUUsS0FBSyxFQUE5RTtBQUNEO0FBQ0Y7QUFDRCxZQUFJLENBQUMsSUFBTCxFQUFXO0FBQ1Q7OztBQUdBLGlCQUFPLFVBQVUsS0FBSyxHQUFMLENBQVMsVUFBVSxDQUFuQixFQUFzQixLQUFLLEtBQUwsQ0FBVyxVQUFVLENBQXJCLENBQXRCLENBQVYsQ0FBUDtBQUNBLHlCQUFPLEdBQVAscUVBQTZFLEtBQUssRUFBbEY7QUFDRDtBQUNGO0FBQ0QsYUFBTyxJQUFQO0FBQ0Q7Ozt5Q0FFc0Y7QUFBQSxVQUF4RSxLQUF3RSxTQUF4RSxLQUF3RTtBQUFBLFVBQWpFLFlBQWlFLFNBQWpFLFlBQWlFO0FBQUEsVUFBbkQsT0FBbUQsU0FBbkQsT0FBbUQ7QUFBQSxVQUExQyxTQUEwQyxTQUExQyxTQUEwQztBQUFBLFVBQS9CLFNBQStCLFNBQS9CLFNBQStCO0FBQUEsVUFBcEIsR0FBb0IsU0FBcEIsR0FBb0I7QUFBQSxVQUFmLFlBQWUsU0FBZixZQUFlOztBQUNyRixVQUFNLFNBQVMsS0FBSyxHQUFMLENBQVMsTUFBeEI7QUFDQSxVQUFJLGFBQUo7QUFDQSxVQUFJLGtCQUFKO0FBQ0EsVUFBSSx5QkFBeUIsT0FBTyxzQkFBcEM7QUFDQSxVQUFJLFdBQVksWUFBRCxHQUFpQixVQUFVLElBQVYsQ0FBZSxVQUFDLFFBQUQ7QUFBQSxlQUFlLFNBQVMsRUFBVCxLQUFnQixhQUFhLEVBQWIsR0FBa0IsQ0FBakQ7QUFBQSxPQUFmLENBQWpCLEdBQXNGLFNBQXJHO0FBQ0EsVUFBSSw4QkFBOEIsU0FBOUIsMkJBQThCLENBQUMsU0FBRCxFQUFlO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFJLDJCQUEyQixLQUFLLEdBQUwsQ0FBUyxzQkFBVCxFQUFpQyxVQUFVLFFBQTNDLENBQS9CO0FBQ0EsWUFBSSxVQUFVLEtBQVYsR0FBa0IsVUFBVSxRQUE1QixHQUF1Qyx3QkFBdkMsSUFBbUUsU0FBdkUsRUFBa0Y7QUFDaEYsaUJBQU8sQ0FBUDtBQUNELFNBRkQsQ0FFRTtBQUZGLGFBR0ssSUFBSSxVQUFVLEtBQVYsR0FBa0Isd0JBQWxCLEdBQTZDLFNBQTdDLElBQTBELFVBQVUsS0FBeEUsRUFBK0U7QUFDbEYsbUJBQU8sQ0FBQyxDQUFSO0FBQ0Q7QUFDRCxlQUFPLENBQVA7QUFDRCxPQXZCRDs7QUF5QkEsVUFBSSxZQUFZLEdBQWhCLEVBQXFCO0FBQ25CLFlBQUksWUFBWSxNQUFNLHNCQUF0QixFQUE4QztBQUM1QyxtQ0FBeUIsQ0FBekI7QUFDRDtBQUNEO0FBQ0EsWUFBSSxZQUFZLENBQUMsNEJBQTRCLFFBQTVCLENBQWpCLEVBQXdEO0FBQ3RELHNCQUFZLFFBQVo7QUFDRCxTQUZELE1BRU87QUFDTCxzQkFBWSx1QkFBYSxNQUFiLENBQW9CLFNBQXBCLEVBQStCLDJCQUEvQixDQUFaO0FBQ0Q7QUFDRixPQVZELE1BVU87QUFDTDtBQUNBLG9CQUFZLFVBQVUsVUFBUSxDQUFsQixDQUFaO0FBQ0Q7QUFDRCxVQUFJLFNBQUosRUFBZTtBQUNiLGVBQU8sU0FBUDtBQUNBLFlBQU0sV0FBVyxLQUFLLEVBQUwsR0FBVSxhQUFhLE9BQXhDO0FBQ0EsWUFBTSxZQUFZLGdCQUFnQixLQUFLLEtBQUwsS0FBZSxhQUFhLEtBQTlEO0FBQ0EsWUFBTSxXQUFXLFVBQVUsV0FBVyxDQUFyQixDQUFqQjtBQUNBLFlBQU0sV0FBVyxVQUFVLFdBQVcsQ0FBckIsQ0FBakI7QUFDQTtBQUNDLFlBQUksYUFBYSxLQUFLLEVBQUwsS0FBWSxhQUFhLEVBQTFDLEVBQThDO0FBQzNDLGNBQUksS0FBSyxFQUFMLEdBQVUsYUFBYSxLQUEzQixFQUFrQztBQUNoQyxnQkFBSSxXQUFXLGFBQWEsUUFBNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFJLFlBQVksV0FBVyxPQUFPLGFBQTlCLElBQStDLGFBQWEsT0FBNUQsSUFBdUUsUUFBM0UsRUFBcUY7QUFDbkYscUJBQU8sUUFBUDtBQUNBLDZCQUFPLElBQVA7QUFDQTtBQUNBLDJCQUFhLFdBQWI7QUFDRCxhQUxELE1BS087QUFDTCxxQkFBTyxRQUFQO0FBQ0EsNkJBQU8sR0FBUCxxQ0FBNkMsS0FBSyxFQUFsRDtBQUNEO0FBQ0YsV0FmRCxNQWVPO0FBQ0wsbUJBQU8sSUFBUDtBQUNEO0FBQ0YsU0FuQkYsTUFtQlEsSUFBSSxLQUFLLE9BQUwsSUFBZ0IsQ0FBQyxTQUFyQixFQUFnQztBQUN0QztBQUNBLGNBQUksWUFBWSxTQUFTLFdBQXpCLEVBQXNDO0FBQ3BDLDJCQUFPLElBQVAseUNBQWlELFdBQVcsQ0FBNUQsMENBQWlHLFFBQWpHLDRCQUErSCxXQUFXLENBQTFJO0FBQ0EsbUJBQU8sUUFBUDtBQUNELFdBSEQsTUFHTztBQUNMO0FBQ0E7QUFDQSwyQkFBTyxJQUFQLENBQVksZ0ZBQVo7QUFDQSxpQkFBSyxPQUFMLEdBQWUsQ0FBZjtBQUNBLGdCQUFJLFlBQVksU0FBUyxXQUF6QixFQUFzQztBQUNwQyx1QkFBUyxXQUFUO0FBQ0EscUJBQU8sUUFBUDtBQUNELGFBSEQsTUFHTztBQUNMLHFCQUFPLElBQVA7QUFDRDtBQUNGO0FBQ0Y7QUFDSDtBQUNELGFBQU8sSUFBUDtBQUNEOzs7OENBRStEO0FBQUEsVUFBNUMsSUFBNEMsU0FBNUMsSUFBNEM7QUFBQSxVQUF0QyxLQUFzQyxTQUF0QyxLQUFzQztBQUFBLFVBQS9CLFlBQStCLFNBQS9CLFlBQStCO0FBQUEsVUFBakIsR0FBaUIsU0FBakIsR0FBaUI7QUFBQSxVQUFaLFNBQVksU0FBWixTQUFZOztBQUM5RCxVQUFNLE1BQU0sS0FBSyxHQUFqQjtBQUFBLFVBQ00sU0FBUyxJQUFJLE1BRG5COztBQUdBO0FBQ0EsVUFBSyxLQUFLLFdBQUwsQ0FBaUIsR0FBakIsSUFBd0IsSUFBekIsSUFBbUMsS0FBSyxXQUFMLENBQWlCLEdBQWpCLElBQXdCLElBQS9ELEVBQXNFO0FBQ3BFLHVCQUFPLEdBQVAsc0JBQThCLEtBQUssRUFBbkMsYUFBNkMsYUFBYSxPQUExRCxVQUFzRSxhQUFhLEtBQW5GLGdCQUFtRyxLQUFuRztBQUNBLGFBQUssS0FBTCxHQUFhLE1BQU0sV0FBbkI7QUFDQSxZQUFJLE9BQUosQ0FBWSxpQkFBTSxXQUFsQixFQUErQixFQUFDLE1BQU0sSUFBUCxFQUEvQjtBQUNELE9BSkQsTUFJTztBQUNMLHVCQUFPLEdBQVAsY0FBc0IsS0FBSyxFQUEzQixhQUFxQyxhQUFhLE9BQWxELFVBQThELGFBQWEsS0FBM0UsZ0JBQTJGLEtBQTNGLHNCQUFpSCxJQUFJLE9BQUosQ0FBWSxDQUFaLENBQWpILG1CQUE2SSxVQUFVLE9BQVYsQ0FBa0IsQ0FBbEIsQ0FBN0k7QUFDQTtBQUNBLFlBQUksS0FBSyxXQUFMLEtBQXFCLFNBQXpCLEVBQW9DO0FBQ2xDLGVBQUssV0FBTDtBQUNELFNBRkQsTUFFTztBQUNMLGVBQUssV0FBTCxHQUFtQixDQUFuQjtBQUNEO0FBQ0QsWUFBSSxLQUFLLFdBQVQsRUFBc0I7QUFDcEIsZUFBSyxXQUFMO0FBQ0EsY0FBSSxlQUFlLE9BQU8sd0JBQTFCO0FBQ0E7QUFDQSxjQUFJLEtBQUssV0FBTCxHQUFtQixZQUFuQixJQUFvQyxLQUFLLEdBQUwsQ0FBUyxLQUFLLFdBQUwsR0FBbUIsS0FBSyxPQUFqQyxJQUE0QyxZQUFwRixFQUFtRztBQUNqRyxnQkFBSSxPQUFKLENBQVksaUJBQU0sS0FBbEIsRUFBeUIsRUFBQyxNQUFNLG1CQUFXLFdBQWxCLEVBQStCLFNBQVMscUJBQWEsdUJBQXJELEVBQThFLE9BQU8sS0FBckYsRUFBNEYsTUFBTSxJQUFsRyxFQUF6QjtBQUNBLG1CQUFPLEtBQVA7QUFDRDtBQUNGLFNBUkQsTUFRTztBQUNMLGVBQUssV0FBTCxHQUFtQixDQUFuQjtBQUNEO0FBQ0QsYUFBSyxPQUFMLEdBQWUsS0FBSyxXQUFwQjtBQUNBLGFBQUssV0FBTCxHQUFtQixJQUFuQjtBQUNBLGFBQUssa0JBQUwsR0FBMEIsSUFBMUI7QUFDQSxhQUFLLGdCQUFMLEdBQXdCLEtBQUssS0FBTCxHQUFhLEtBQUssUUFBMUM7QUFDQSxhQUFLLFNBQUwsR0FBaUIsSUFBSSxnQkFBckI7QUFDQSxhQUFLLFdBQUwsR0FBbUIsS0FBSyxXQUF4QjtBQUNBLFlBQUksT0FBSixDQUFZLGlCQUFNLFlBQWxCLEVBQWdDLEVBQUMsTUFBTSxJQUFQLEVBQWhDO0FBQ0E7QUFDQSxZQUFJLENBQUMsS0FBSyxPQUFWLEVBQW1CO0FBQ2pCLGVBQUssT0FBTCxHQUFlLHNCQUFZLEdBQVosRUFBZ0IsTUFBaEIsQ0FBZjtBQUNEO0FBQ0QsYUFBSyxLQUFMLEdBQWEsTUFBTSxZQUFuQjtBQUNBLGVBQU8sSUFBUDtBQUNEO0FBQ0Y7OzttQ0FlYyxRLEVBQVU7QUFDdkIsVUFBSSxDQUFKO0FBQUEsVUFBTyxLQUFQO0FBQUEsVUFDSSxjQUFjLEtBQUssV0FEdkI7QUFFQSxVQUFJLFdBQUosRUFBaUI7QUFDZixhQUFLLElBQUksWUFBWSxNQUFaLEdBQXFCLENBQTlCLEVBQWlDLEtBQUksQ0FBckMsRUFBd0MsR0FBeEMsRUFBNkM7QUFDM0Msa0JBQVEsWUFBWSxDQUFaLENBQVI7QUFDQSxjQUFJLFlBQVksTUFBTSxLQUFsQixJQUEyQixZQUFZLE1BQU0sR0FBakQsRUFBc0Q7QUFDcEQsbUJBQU8sS0FBUDtBQUNEO0FBQ0Y7QUFDRjtBQUNELGFBQU8sSUFBUDtBQUNEOzs7eUNBdUJvQixLLEVBQU87QUFDMUIsVUFBSSxLQUFKLEVBQVc7QUFDVDtBQUNBLGVBQU8sS0FBSyxjQUFMLENBQW9CLE1BQU0sR0FBTixHQUFZLEdBQWhDLENBQVA7QUFDRDtBQUNELGFBQU8sSUFBUDtBQUNEOzs7NENBV3VCO0FBQ3RCLFVBQUksWUFBSjtBQUFBLFVBQWtCLFdBQWxCO0FBQUEsVUFBK0IsUUFBUSxLQUFLLEtBQTVDO0FBQ0EsVUFBSSxTQUFTLE1BQU0sVUFBZixJQUE2QixNQUFNLE9BQU4sS0FBa0IsS0FBbkQsRUFBMEQ7QUFDeEQsc0JBQWMsTUFBTSxXQUFwQjtBQUNBOzs7Ozs7QUFNQSxZQUFHLGNBQWMsTUFBTSxZQUFOLEdBQW1CLEtBQUssZUFBekMsRUFBMEQ7QUFDeEQsZUFBSyxlQUFMLEdBQXVCLFdBQXZCO0FBQ0Q7QUFDRCxZQUFJLHVCQUFhLFVBQWIsQ0FBd0IsS0FBeEIsRUFBOEIsV0FBOUIsQ0FBSixFQUFnRDtBQUM5Qyx5QkFBZSxLQUFLLGNBQUwsQ0FBb0IsV0FBcEIsQ0FBZjtBQUNELFNBRkQsTUFFTyxJQUFJLHVCQUFhLFVBQWIsQ0FBd0IsS0FBeEIsRUFBOEIsY0FBYyxHQUE1QyxDQUFKLEVBQXNEO0FBQzNEOzs7OztBQUtBLHlCQUFlLEtBQUssY0FBTCxDQUFvQixjQUFjLEdBQWxDLENBQWY7QUFDRDtBQUNELFlBQUksWUFBSixFQUFrQjtBQUNoQixjQUFJLGNBQWMsYUFBYSxJQUEvQjtBQUNBLGNBQUksZ0JBQWdCLEtBQUssV0FBekIsRUFBc0M7QUFDcEMsaUJBQUssV0FBTCxHQUFtQixXQUFuQjtBQUNBLGlCQUFLLEdBQUwsQ0FBUyxPQUFULENBQWlCLGlCQUFNLFlBQXZCLEVBQXFDLEVBQUMsTUFBTSxXQUFQLEVBQXJDO0FBQ0Q7QUFDRjtBQUNGO0FBQ0Y7O0FBRUQ7Ozs7Ozs7OzsyQ0FNdUI7QUFDckIscUJBQU8sR0FBUCxDQUFXLHNCQUFYO0FBQ0EsVUFBSSxDQUFDLEtBQUssZUFBVixFQUEyQjtBQUN6QixhQUFLLGVBQUwsR0FBdUIsSUFBdkI7QUFDQSxZQUFJLFFBQVEsS0FBSyxLQUFqQjtBQUFBLFlBQXdCLHlCQUF4QjtBQUNBLFlBQUksS0FBSixFQUFXO0FBQ1QsNkJBQW1CLE1BQU0sTUFBekI7QUFDQSxnQkFBTSxLQUFOO0FBQ0QsU0FIRCxNQUdPO0FBQ0w7QUFDQSw2QkFBbUIsSUFBbkI7QUFDRDtBQUNELGFBQUssZ0JBQUwsR0FBd0IsZ0JBQXhCO0FBQ0Q7QUFDRCxVQUFJLGNBQWMsS0FBSyxXQUF2QjtBQUNBLFVBQUksZUFBZSxZQUFZLE1BQS9CLEVBQXVDO0FBQ3JDLG9CQUFZLE1BQVosQ0FBbUIsS0FBbkI7QUFDRDtBQUNELFdBQUssV0FBTCxHQUFtQixJQUFuQjtBQUNBO0FBQ0EsV0FBSyxXQUFMLElBQW9CLElBQUksS0FBSyxNQUFMLENBQVksd0JBQXBDO0FBQ0E7QUFDQSxXQUFLLGVBQUwsQ0FBcUIsQ0FBckIsRUFBdUIsT0FBTyxpQkFBOUI7QUFDRDs7QUFFRDs7Ozs7Ozs7OENBSzBCO0FBQ3hCLFVBQUksUUFBUSxLQUFLLEtBQWpCO0FBQ0EsVUFBSSxTQUFTLE1BQU0sUUFBTixDQUFlLE1BQTVCLEVBQW9DO0FBQ2xDLGFBQUssZUFBTCxHQUF1QixLQUF2QjtBQUNBLFlBQUcsdUJBQWEsVUFBYixDQUF3QixLQUF4QixFQUE4QixNQUFNLFdBQXBDLENBQUgsRUFBcUQ7QUFDbkQ7QUFDQSxnQkFBTSxXQUFOLElBQXFCLE1BQXJCO0FBQ0Q7QUFDRCxZQUFJLENBQUMsS0FBSyxnQkFBVixFQUE0QjtBQUMxQixnQkFBTSxJQUFOO0FBQ0Q7QUFDRjtBQUNGOzs7c0NBRWlCO0FBQ2hCOzs7OztBQUtBLFVBQUksUUFBUSxLQUFLLEtBQWpCO0FBQ0E7QUFDQSxVQUFJLFNBQVMsTUFBTSxVQUFuQixFQUErQjtBQUM3QixZQUFJLG1CQUFKO0FBQUEsWUFBZ0IscUJBQWhCO0FBQUEsWUFBOEIsa0JBQTlCO0FBQ0E7QUFDQSxhQUFLLFdBQUwsSUFBb0IsSUFBSSxLQUFLLE1BQUwsQ0FBWSx3QkFBcEM7QUFDQSx1QkFBZSxLQUFLLGNBQUwsQ0FBb0IsTUFBTSxXQUExQixDQUFmO0FBQ0EsWUFBSSxnQkFBZ0IsYUFBYSxLQUFiLEdBQXFCLENBQXpDLEVBQTRDO0FBQzFDO0FBQ0E7QUFDQSxlQUFLLGVBQUwsQ0FBcUIsQ0FBckIsRUFBdUIsYUFBYSxLQUFiLEdBQXFCLENBQTVDO0FBQ0Q7QUFDRCxZQUFJLENBQUMsTUFBTSxNQUFYLEVBQW1CO0FBQ2pCO0FBQ0EsY0FBSSxjQUFjLEtBQUssR0FBTCxDQUFTLGFBQTNCO0FBQUEsY0FBeUMsWUFBWSxLQUFLLE1BQUwsQ0FBWSxXQUFaLENBQXJEO0FBQUEsY0FBK0UsZUFBZSxLQUFLLFlBQW5HO0FBQ0EsY0FBSSxnQkFBZ0IsS0FBSyxXQUF6QixFQUFzQztBQUNwQyx5QkFBYSxLQUFLLFdBQUwsQ0FBaUIsUUFBakIsR0FBNEIsVUFBVSxPQUF0QyxJQUFpRCxPQUFPLFlBQXhELElBQXdFLENBQXJGO0FBQ0QsV0FGRCxNQUVPO0FBQ0wseUJBQWEsQ0FBYjtBQUNEO0FBQ0YsU0FSRCxNQVFPO0FBQ0wsdUJBQWEsQ0FBYjtBQUNEO0FBQ0Q7QUFDQTtBQUNBLG9CQUFZLEtBQUssY0FBTCxDQUFvQixNQUFNLFdBQU4sR0FBb0IsVUFBeEMsQ0FBWjtBQUNBLFlBQUksU0FBSixFQUFlO0FBQ2I7QUFDQSxzQkFBWSxLQUFLLG9CQUFMLENBQTBCLFNBQTFCLENBQVo7QUFDQSxjQUFJLFNBQUosRUFBZTtBQUNiO0FBQ0EsZ0JBQUksY0FBYyxLQUFLLFdBQXZCO0FBQ0EsZ0JBQUksZUFBZSxZQUFZLE1BQS9CLEVBQXVDO0FBQ3JDLDBCQUFZLE1BQVosQ0FBbUIsS0FBbkI7QUFDRDtBQUNELGlCQUFLLFdBQUwsR0FBbUIsSUFBbkI7QUFDQTtBQUNBLGlCQUFLLGVBQUwsQ0FBcUIsVUFBVSxLQUEvQixFQUF1QyxPQUFPLGlCQUE5QztBQUNEO0FBQ0Y7QUFDRjtBQUNGOzs7b0NBRWUsVyxFQUFZLFMsRUFBVztBQUNyQyxXQUFLLEtBQUwsR0FBYSxNQUFNLGVBQW5CO0FBQ0EsVUFBSSxhQUFhLEVBQUMsYUFBYSxXQUFkLEVBQTJCLFdBQVcsU0FBdEMsRUFBakI7QUFDQTtBQUNBLFVBQUksS0FBSyxRQUFULEVBQW1CO0FBQ2pCLG1CQUFXLElBQVgsR0FBa0IsT0FBbEI7QUFDRDtBQUNELFdBQUssR0FBTCxDQUFTLE9BQVQsQ0FBaUIsaUJBQU0sZUFBdkIsRUFBd0MsVUFBeEM7QUFDRDs7O29DQUVlLEksRUFBTTtBQUNwQixVQUFJLFFBQVEsS0FBSyxLQUFMLEdBQWEsS0FBSyxXQUFMLEdBQW1CLEtBQUssS0FBakQ7QUFDQSxXQUFLLFVBQUwsR0FBa0IsS0FBSyxjQUFMLENBQW9CLElBQXBCLENBQXlCLElBQXpCLENBQWxCO0FBQ0EsV0FBSyxTQUFMLEdBQWlCLEtBQUssYUFBTCxDQUFtQixJQUFuQixDQUF3QixJQUF4QixDQUFqQjtBQUNBLFdBQUssUUFBTCxHQUFnQixLQUFLLFlBQUwsQ0FBa0IsSUFBbEIsQ0FBdUIsSUFBdkIsQ0FBaEI7QUFDQSxZQUFNLGdCQUFOLENBQXVCLFNBQXZCLEVBQWtDLEtBQUssVUFBdkM7QUFDQSxZQUFNLGdCQUFOLENBQXVCLFFBQXZCLEVBQWlDLEtBQUssU0FBdEM7QUFDQSxZQUFNLGdCQUFOLENBQXVCLE9BQXZCLEVBQWdDLEtBQUssUUFBckM7QUFDQSxVQUFJLFNBQVMsS0FBSyxNQUFsQjtBQUNBLFVBQUcsS0FBSyxNQUFMLElBQWUsT0FBTyxhQUF6QixFQUF3QztBQUN0QyxhQUFLLEdBQUwsQ0FBUyxTQUFULENBQW1CLE9BQU8sYUFBMUI7QUFDRDtBQUNGOzs7dUNBRWtCO0FBQ2pCLFVBQUksUUFBUSxLQUFLLEtBQWpCO0FBQ0EsVUFBSSxTQUFTLE1BQU0sS0FBbkIsRUFBMEI7QUFDeEIsdUJBQU8sR0FBUCxDQUFXLG9EQUFYO0FBQ0EsYUFBSyxhQUFMLEdBQXFCLEtBQUssZUFBTCxHQUF1QixDQUE1QztBQUNEOztBQUVEO0FBQ0EsVUFBSSxTQUFTLEtBQUssTUFBbEI7QUFDQSxVQUFJLE1BQUosRUFBWTtBQUNWO0FBQ0UsZUFBTyxPQUFQLENBQWUsaUJBQVM7QUFDdEIsY0FBRyxNQUFNLE9BQVQsRUFBa0I7QUFDaEIsa0JBQU0sT0FBTixDQUFjLFNBQWQsQ0FBd0IsT0FBeEIsQ0FBZ0Msb0JBQVk7QUFDMUMsdUJBQVMsV0FBVCxHQUF1QixTQUF2QjtBQUNBLHVCQUFTLFdBQVQsR0FBdUIsU0FBdkI7QUFDRCxhQUhEO0FBSUQ7QUFDSixTQVBDO0FBUUg7QUFDRDtBQUNBLFVBQUksS0FBSixFQUFXO0FBQ1QsY0FBTSxtQkFBTixDQUEwQixTQUExQixFQUFxQyxLQUFLLFVBQTFDO0FBQ0EsY0FBTSxtQkFBTixDQUEwQixRQUExQixFQUFvQyxLQUFLLFNBQXpDO0FBQ0EsY0FBTSxtQkFBTixDQUEwQixPQUExQixFQUFtQyxLQUFLLFFBQXhDO0FBQ0EsYUFBSyxVQUFMLEdBQWtCLEtBQUssU0FBTCxHQUFrQixLQUFLLFFBQUwsR0FBZ0IsSUFBcEQ7QUFDRDtBQUNELFdBQUssS0FBTCxHQUFhLEtBQUssV0FBTCxHQUFtQixJQUFoQztBQUNBLFdBQUssY0FBTCxHQUFzQixLQUF0QjtBQUNBLFdBQUssUUFBTDtBQUNEOzs7cUNBRWdCO0FBQ2YsVUFBSSxRQUFRLEtBQUssS0FBakI7QUFBQSxVQUF3QixjQUFjLFFBQVEsTUFBTSxXQUFkLEdBQTRCLFNBQWxFO0FBQUEsVUFBNkUsU0FBUyxLQUFLLE1BQTNGO0FBQ0EscUJBQU8sR0FBUCx1QkFBK0IsWUFBWSxPQUFaLENBQW9CLENBQXBCLENBQS9CO0FBQ0EsVUFBSSxLQUFLLEtBQUwsS0FBZSxNQUFNLFlBQXpCLEVBQXVDO0FBQ3JDLFlBQUksYUFBYSx1QkFBYSxVQUFiLENBQXdCLEtBQXhCLEVBQThCLFdBQTlCLEVBQTBDLEtBQUssTUFBTCxDQUFZLGFBQXRELENBQWpCO0FBQUEsWUFDSSxjQUFjLEtBQUssV0FEdkI7QUFFQTtBQUNBLFlBQUksV0FBVyxHQUFYLEtBQW1CLENBQW5CLElBQXdCLFdBQTVCLEVBQXlDO0FBQ3ZDLGNBQUksWUFBWSxPQUFPLHNCQUF2QjtBQUFBLGNBQ0ksa0JBQWtCLFlBQVksS0FBWixHQUFvQixTQUQxQztBQUFBLGNBRUksZ0JBQWdCLFlBQVksS0FBWixHQUFvQixZQUFZLFFBQWhDLEdBQTJDLFNBRi9EO0FBR0E7QUFDQSxjQUFJLGNBQWMsZUFBZCxJQUFpQyxjQUFjLGFBQW5ELEVBQWtFO0FBQ2hFLGdCQUFJLFlBQVksTUFBaEIsRUFBd0I7QUFDdEIsNkJBQU8sR0FBUCxDQUFXLGlGQUFYO0FBQ0EsMEJBQVksTUFBWixDQUFtQixLQUFuQjtBQUNEO0FBQ0QsaUJBQUssV0FBTCxHQUFtQixJQUFuQjtBQUNBLGlCQUFLLFlBQUwsR0FBb0IsSUFBcEI7QUFDQTtBQUNBLGlCQUFLLEtBQUwsR0FBYSxNQUFNLElBQW5CO0FBQ0QsV0FURCxNQVNPO0FBQ0wsMkJBQU8sR0FBUCxDQUFXLHNFQUFYO0FBQ0Q7QUFDRjtBQUNGLE9BdEJELE1Bc0JPLElBQUksS0FBSyxLQUFMLEtBQWUsTUFBTSxLQUF6QixFQUFnQztBQUNuQztBQUNBLGFBQUssS0FBTCxHQUFhLE1BQU0sSUFBbkI7QUFDSDtBQUNELFVBQUksS0FBSixFQUFXO0FBQ1QsYUFBSyxlQUFMLEdBQXVCLFdBQXZCO0FBQ0Q7QUFDRDtBQUNBLFVBQUksS0FBSyxLQUFMLEtBQWUsTUFBTSxZQUFyQixJQUFxQyxLQUFLLFdBQUwsS0FBcUIsU0FBOUQsRUFBeUU7QUFDdkUsYUFBSyxXQUFMLElBQW9CLElBQUksT0FBTyx3QkFBL0I7QUFDRDtBQUNEO0FBQ0EsVUFBRyxDQUFDLEtBQUssY0FBVCxFQUF5QjtBQUN2QixhQUFLLGdCQUFMLEdBQXdCLEtBQUssYUFBTCxHQUFxQixXQUE3QztBQUNEO0FBQ0Q7QUFDQSxXQUFLLElBQUw7QUFDRDs7O29DQUVlO0FBQ2QscUJBQU8sR0FBUCxzQkFBOEIsS0FBSyxLQUFMLENBQVcsV0FBWCxDQUF1QixPQUF2QixDQUErQixDQUEvQixDQUE5QjtBQUNBO0FBQ0EsV0FBSyxJQUFMO0FBQ0Q7OzttQ0FFYztBQUNiLHFCQUFPLEdBQVAsQ0FBVyxhQUFYO0FBQ0E7QUFDQSxXQUFLLGFBQUwsR0FBcUIsS0FBSyxlQUFMLEdBQXVCLENBQTVDO0FBQ0Q7Ozt3Q0FHbUI7QUFDbEI7QUFDQSxxQkFBTyxHQUFQLENBQVcsc0JBQVg7QUFDQSxXQUFLLEdBQUwsQ0FBUyxPQUFULENBQWlCLGlCQUFNLFlBQXZCO0FBQ0EsV0FBSyxXQUFMLEdBQW1CLEVBQW5CO0FBQ0EsV0FBSyxPQUFMLEdBQWUsS0FBZjtBQUNBLFdBQUssYUFBTCxHQUFxQixLQUFLLGVBQUwsR0FBdUIsQ0FBNUM7QUFDRDs7O3FDQUVnQixJLEVBQU07QUFDckIsVUFBSSxNQUFNLEtBQVY7QUFBQSxVQUFpQixRQUFRLEtBQXpCO0FBQUEsVUFBZ0MsS0FBaEM7QUFDQSxXQUFLLE1BQUwsQ0FBWSxPQUFaLENBQW9CLGlCQUFTO0FBQzNCO0FBQ0EsZ0JBQVEsTUFBTSxVQUFkO0FBQ0EsWUFBSSxLQUFKLEVBQVc7QUFDVCxjQUFJLE1BQU0sT0FBTixDQUFjLFdBQWQsTUFBK0IsQ0FBQyxDQUFwQyxFQUF1QztBQUNyQyxrQkFBTSxJQUFOO0FBQ0Q7QUFDRCxjQUFJLE1BQU0sT0FBTixDQUFjLFdBQWQsTUFBK0IsQ0FBQyxDQUFwQyxFQUF1QztBQUNyQyxvQkFBUSxJQUFSO0FBQ0Q7QUFDRjtBQUNGLE9BWEQ7QUFZQSxXQUFLLGdCQUFMLEdBQXlCLE9BQU8sS0FBaEM7QUFDQSxVQUFJLEtBQUssZ0JBQVQsRUFBMkI7QUFDekIsdUJBQU8sR0FBUCxDQUFXLHdFQUFYO0FBQ0Q7QUFDRCxXQUFLLE1BQUwsR0FBYyxLQUFLLE1BQW5CO0FBQ0EsV0FBSyxnQkFBTCxHQUF3QixLQUF4QjtBQUNBLFdBQUssa0JBQUwsR0FBMEIsS0FBMUI7QUFDQSxVQUFJLFNBQVMsS0FBSyxNQUFsQjtBQUNBLFVBQUksT0FBTyxhQUFYLEVBQTBCO0FBQ3hCLGFBQUssR0FBTCxDQUFTLFNBQVQsQ0FBbUIsT0FBTyxhQUExQjtBQUNEO0FBQ0Y7OztrQ0FFYSxJLEVBQU07QUFDbEIsVUFBSSxhQUFhLEtBQUssT0FBdEI7QUFBQSxVQUNJLGFBQWEsS0FBSyxLQUR0QjtBQUFBLFVBRUksV0FBVyxLQUFLLE1BQUwsQ0FBWSxVQUFaLENBRmY7QUFBQSxVQUdJLFdBQVcsV0FBVyxhQUgxQjtBQUFBLFVBSUksVUFBVSxDQUpkOztBQU1BLHFCQUFPLEdBQVAsWUFBb0IsVUFBcEIsaUJBQTBDLFdBQVcsT0FBckQsU0FBZ0UsV0FBVyxLQUEzRSxtQkFBOEYsUUFBOUY7QUFDQSxXQUFLLGVBQUwsR0FBdUIsVUFBdkI7O0FBRUEsVUFBSSxXQUFXLElBQWYsRUFBcUI7QUFDbkIsWUFBSSxhQUFhLFNBQVMsT0FBMUI7QUFDQSxZQUFJLGNBQWMsV0FBVyxTQUFYLENBQXFCLE1BQXJCLEdBQThCLENBQWhELEVBQW1EO0FBQ2pEO0FBQ0EsZ0NBQVksWUFBWixDQUF5QixVQUF6QixFQUFvQyxVQUFwQztBQUNBLG9CQUFVLFdBQVcsU0FBWCxDQUFxQixDQUFyQixFQUF3QixLQUFsQztBQUNBLGVBQUssZ0JBQUwsR0FBd0IsS0FBSyxtQkFBTCxDQUF5QixPQUF6QixFQUFrQyxVQUFsQyxDQUF4QjtBQUNBLGNBQUksV0FBVyxRQUFmLEVBQXlCO0FBQ3ZCLDJCQUFPLEdBQVAsNEJBQW9DLFFBQVEsT0FBUixDQUFnQixDQUFoQixDQUFwQztBQUNELFdBRkQsTUFFTztBQUNMLDJCQUFPLEdBQVAsQ0FBVywrQ0FBWDtBQUNEO0FBQ0YsU0FWRCxNQVVPO0FBQ0wscUJBQVcsUUFBWCxHQUFzQixLQUF0QjtBQUNBLHlCQUFPLEdBQVAsQ0FBVyw2Q0FBWDtBQUNEO0FBQ0YsT0FoQkQsTUFnQk87QUFDTCxtQkFBVyxRQUFYLEdBQXNCLEtBQXRCO0FBQ0Q7QUFDRDtBQUNBLGVBQVMsT0FBVCxHQUFtQixVQUFuQjtBQUNBLFdBQUssR0FBTCxDQUFTLE9BQVQsQ0FBaUIsaUJBQU0sYUFBdkIsRUFBc0MsRUFBRSxTQUFTLFVBQVgsRUFBdUIsT0FBTyxVQUE5QixFQUF0Qzs7QUFFQSxVQUFJLEtBQUssa0JBQUwsS0FBNEIsS0FBaEMsRUFBdUM7QUFDdkM7QUFDRSxZQUFJLEtBQUssYUFBTCxLQUF1QixDQUFDLENBQXhCLElBQTZCLEtBQUssZUFBTCxLQUF5QixDQUFDLENBQTNELEVBQThEO0FBQzVEO0FBQ0EsY0FBSSxrQkFBa0IsV0FBVyxlQUFqQztBQUNBLGNBQUcsQ0FBQyxNQUFNLGVBQU4sQ0FBSixFQUE0QjtBQUMxQixnQkFBSSxrQkFBa0IsQ0FBdEIsRUFBeUI7QUFDdkIsNkJBQU8sR0FBUCxpQ0FBeUMsZUFBekM7QUFDQSxnQ0FBa0IsVUFBVSxRQUFWLEdBQXFCLGVBQXZDO0FBQ0Q7QUFDRCwyQkFBTyxHQUFQLG1FQUEyRSxlQUEzRTtBQUNBLGlCQUFLLGFBQUwsR0FBcUIsZUFBckI7QUFDRCxXQVBELE1BT087QUFDTDtBQUNBLGdCQUFJLFdBQVcsSUFBZixFQUFxQjtBQUNuQixtQkFBSyxhQUFMLEdBQXFCLEtBQUssbUJBQUwsQ0FBeUIsT0FBekIsRUFBa0MsVUFBbEMsQ0FBckI7QUFDQSw2QkFBTyxHQUFQLGlDQUF5QyxLQUFLLGFBQTlDO0FBQ0QsYUFIRCxNQUdPO0FBQ0wsbUJBQUssYUFBTCxHQUFxQixDQUFyQjtBQUNEO0FBQ0Y7QUFDRCxlQUFLLGVBQUwsR0FBdUIsS0FBSyxhQUE1QjtBQUNEO0FBQ0QsYUFBSyxnQkFBTCxHQUF3QixLQUFLLGFBQTdCO0FBQ0Q7QUFDRDtBQUNBLFVBQUksS0FBSyxLQUFMLEtBQWUsTUFBTSxhQUF6QixFQUF3QztBQUN0QyxhQUFLLEtBQUwsR0FBYSxNQUFNLElBQW5CO0FBQ0Q7QUFDRDtBQUNBLFdBQUssSUFBTDtBQUNEOzs7a0NBRWE7QUFDWixVQUFJLEtBQUssS0FBTCxLQUFlLE1BQU0sV0FBekIsRUFBc0M7QUFDcEMsYUFBSyxLQUFMLEdBQWEsTUFBTSxJQUFuQjtBQUNBLGFBQUssSUFBTDtBQUNEO0FBQ0Y7OztpQ0FFWSxJLEVBQU07QUFDakIsVUFBSSxjQUFjLEtBQUssV0FBdkI7QUFBQSxVQUNJLGFBQWEsS0FBSyxJQUR0QjtBQUVBLFVBQUksS0FBSyxLQUFMLEtBQWUsTUFBTSxZQUFyQixJQUNBLFdBREEsSUFFQSxXQUFXLElBQVgsS0FBb0IsTUFGcEIsSUFHQSxXQUFXLEtBQVgsS0FBcUIsWUFBWSxLQUhqQyxJQUlBLFdBQVcsRUFBWCxLQUFrQixZQUFZLEVBSmxDLEVBSXNDO0FBQ3BDLFlBQUksUUFBUSxLQUFLLEtBQWpCO0FBQUEsWUFDSSxlQUFlLEtBQUssTUFBTCxDQUFZLFlBQVksS0FBeEIsQ0FEbkI7QUFBQSxZQUVJLFVBQVUsYUFBYSxPQUYzQjtBQUdBLHVCQUFPLEdBQVAsY0FBc0IsWUFBWSxFQUFsQyxhQUE0QyxRQUFRLE9BQXBELFVBQWdFLFFBQVEsS0FBeEUsZ0JBQXdGLFlBQVksS0FBcEc7QUFDQTtBQUNBLGFBQUssV0FBTCxHQUFtQixLQUFuQjtBQUNBO0FBQ0E7QUFDQSxZQUFJLFdBQVcsV0FBWCxLQUEyQixJQUEzQixJQUFtQyxLQUFLLEdBQUwsQ0FBUyxhQUFoRCxFQUErRDtBQUM3RDtBQUNBLGVBQUssS0FBTCxHQUFhLE1BQU0sSUFBbkI7QUFDQSxlQUFLLGtCQUFMLEdBQTBCLEtBQTFCO0FBQ0EsZ0JBQU0sT0FBTixHQUFnQixNQUFNLFNBQU4sR0FBa0IsWUFBWSxHQUFaLEVBQWxDO0FBQ0EsZUFBSyxHQUFMLENBQVMsT0FBVCxDQUFpQixpQkFBTSxhQUF2QixFQUFzQyxFQUFDLE9BQU8sS0FBUixFQUFlLE1BQU0sV0FBckIsRUFBa0MsSUFBSyxNQUF2QyxFQUF0QztBQUNBLGVBQUssSUFBTDtBQUNELFNBUEQsTUFPTztBQUNMLGVBQUssS0FBTCxHQUFhLE1BQU0sT0FBbkI7QUFDQTtBQUNBLGVBQUssS0FBTCxHQUFhLEtBQWI7QUFDQSxjQUFJLFdBQVcsUUFBUSxhQUF2QjtBQUFBLGNBQ0ksUUFBUSxDQUFDLE1BQU0sWUFBWSxRQUFsQixDQUFELEdBQStCLFlBQVksUUFBM0MsR0FBdUQsWUFBWSxLQUQvRTtBQUFBLGNBRUksUUFBUSxZQUFZLEtBRnhCO0FBQUEsY0FHSSxLQUFLLFlBQVksRUFIckI7QUFBQSxjQUlJLGFBQWEsS0FBSyxNQUFMLENBQVksaUJBQVosSUFBaUMsYUFBYSxVQUovRDtBQUtBLGNBQUcsS0FBSyxjQUFSLEVBQXdCO0FBQ3RCLDJCQUFPLEdBQVAsQ0FBVywrQkFBWDtBQUNBLGdCQUFHLGVBQWUsU0FBbEIsRUFBNkI7QUFDM0IsMkJBQWEsS0FBSyxjQUFsQjtBQUNEO0FBQ0QsZ0JBQUcsVUFBSCxFQUFlO0FBQ2Isa0JBQUcsV0FBVyxPQUFYLENBQW1CLFdBQW5CLE1BQW1DLENBQUMsQ0FBdkMsRUFBMEM7QUFDeEMsNkJBQWEsV0FBYjtBQUNELGVBRkQsTUFFTztBQUNMLDZCQUFhLFdBQWI7QUFDRDtBQUNGO0FBQ0Y7QUFDRCxlQUFLLGdCQUFMLEdBQXdCLENBQUMsQ0FBekI7QUFDQSxlQUFLLFFBQUwsR0FBZ0IsS0FBaEI7QUFDQSx5QkFBTyxHQUFQLGNBQXNCLEVBQXRCLGFBQWdDLFFBQVEsT0FBeEMsVUFBb0QsUUFBUSxLQUE1RCxnQkFBNEUsS0FBNUUsYUFBeUYsWUFBWSxFQUFyRztBQUNBLGNBQUksVUFBVSxLQUFLLE9BQW5CO0FBQ0EsY0FBSSxDQUFDLE9BQUwsRUFBYztBQUNaLHNCQUFVLEtBQUssT0FBTCxHQUFlLHNCQUFZLEtBQUssR0FBakIsRUFBcUIsTUFBckIsQ0FBekI7QUFDRDtBQUNEO0FBQ0EsY0FBSSxRQUFRLEtBQUssS0FBakI7QUFDQSxjQUFJLGVBQWUsU0FBUyxNQUFNLE9BQWxDO0FBQ0EsY0FBSSxxQkFBcUIsQ0FBQyxZQUFELEtBQWtCLFFBQVEsUUFBUixJQUFvQixDQUFDLFFBQVEsSUFBL0MsQ0FBekI7QUFDQSxrQkFBUSxJQUFSLENBQWEsS0FBSyxPQUFsQixFQUEyQixVQUEzQixFQUF1QyxhQUFhLFVBQXBELEVBQWdFLEtBQWhFLEVBQXVFLFlBQVksRUFBbkYsRUFBdUYsS0FBdkYsRUFBOEYsRUFBOUYsRUFBa0csUUFBbEcsRUFBNEcsWUFBWSxXQUF4SCxFQUFxSSxrQkFBckksRUFBd0osSUFBeEo7QUFDRDtBQUNGO0FBQ0QsV0FBSyxhQUFMLEdBQXFCLENBQXJCO0FBQ0Q7Ozs2Q0FFd0IsSSxFQUFNO0FBQzdCLFVBQUksY0FBYyxLQUFLLFdBQXZCO0FBQ0EsVUFBSSxlQUNBLEtBQUssRUFBTCxLQUFZLE1BRFosSUFFQSxLQUFLLEVBQUwsS0FBWSxZQUFZLEVBRnhCLElBR0EsS0FBSyxLQUFMLEtBQWUsWUFBWSxLQUgzQixJQUlBLEtBQUssS0FBTCxLQUFlLE1BQU0sT0FKekIsRUFJa0M7QUFDaEMsWUFBSSxTQUFTLEtBQUssTUFBbEI7QUFBQSxZQUEwQixTQUExQjtBQUFBLFlBQXFDLEtBQXJDOztBQUVBO0FBQ0EsWUFBSSxPQUFPLEtBQVAsSUFBZ0IsS0FBSyxRQUF6QixFQUFtQztBQUNqQyxpQkFBTyxPQUFPLEtBQWQ7QUFDRDtBQUNEO0FBQ0EsZ0JBQVEsT0FBTyxLQUFmO0FBQ0EsWUFBRyxLQUFILEVBQVU7QUFDUixjQUFJLGFBQWEsS0FBSyxNQUFMLENBQVksS0FBSyxLQUFqQixFQUF3QixVQUF6QztBQUFBLGNBQ0ksS0FBSyxVQUFVLFNBQVYsQ0FBb0IsV0FBcEIsRUFEVDtBQUVBLGNBQUcsY0FBYyxLQUFLLGNBQXRCLEVBQXNDO0FBQ3BDLDJCQUFPLEdBQVAsQ0FBVywrQkFBWDtBQUNBLGdCQUFHLFdBQVcsT0FBWCxDQUFtQixXQUFuQixNQUFtQyxDQUFDLENBQXZDLEVBQTBDO0FBQ3hDLDJCQUFhLFdBQWI7QUFDRCxhQUZELE1BRU87QUFDTCwyQkFBYSxXQUFiO0FBQ0Q7QUFDRjtBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBSSxLQUFLLGdCQUFULEVBQTJCO0FBQ3ZCO0FBQ0QsZ0JBQUcsTUFBTSxRQUFOLENBQWUsWUFBZixLQUFnQyxDQUFoQztBQUNGO0FBQ0EsZUFBRyxPQUFILENBQVcsU0FBWCxNQUEwQixDQUFDLENBRjVCLEVBRStCO0FBQzVCLDJCQUFhLFdBQWI7QUFDSDtBQUNGO0FBQ0Q7QUFDQSxjQUFHLEdBQUcsT0FBSCxDQUFXLFNBQVgsTUFBMEIsQ0FBQyxDQUEzQixJQUFnQyxNQUFNLFNBQU4sS0FBb0IsWUFBdkQsRUFBcUU7QUFBRTtBQUNyRSx5QkFBYSxXQUFiO0FBQ0EsMkJBQU8sR0FBUCxvQ0FBNEMsVUFBNUM7QUFDRDtBQUNELGdCQUFNLFVBQU4sR0FBbUIsVUFBbkI7QUFDQSxnQkFBTSxFQUFOLEdBQVcsS0FBSyxFQUFoQjtBQUNEO0FBQ0QsZ0JBQVEsT0FBTyxLQUFmO0FBQ0EsWUFBRyxLQUFILEVBQVU7QUFDUixnQkFBTSxVQUFOLEdBQW1CLEtBQUssTUFBTCxDQUFZLEtBQUssS0FBakIsRUFBd0IsVUFBM0M7QUFDQSxnQkFBTSxFQUFOLEdBQVcsS0FBSyxFQUFoQjtBQUNEOztBQUVEO0FBQ0E7QUFDQSxZQUFJLEtBQUssTUFBVCxFQUFpQjtBQUNmLGNBQUksY0FBYztBQUNkLG1CQUFRLEVBRE07QUFFZCx3QkFBYTtBQUZDLFdBQWxCO0FBSUEsZUFBSyxTQUFMLElBQWtCLEtBQUssTUFBdkIsRUFBK0I7QUFDN0Isb0JBQVEsT0FBTyxTQUFQLENBQVI7QUFDQSx3QkFBWSxTQUFaLEdBQXdCLE1BQU0sU0FBOUI7QUFDQSxnQkFBSSxZQUFZLEtBQWhCLEVBQXVCO0FBQ3JCLDBCQUFZLEtBQVosSUFBc0IsR0FBdEI7QUFDQSwwQkFBWSxVQUFaLElBQTJCLEdBQTNCO0FBQ0Q7QUFDRCxnQkFBRyxNQUFNLEtBQVQsRUFBZ0I7QUFDZCwwQkFBWSxLQUFaLElBQXNCLE1BQU0sS0FBNUI7QUFDRDtBQUNELGdCQUFJLE1BQU0sVUFBVixFQUFzQjtBQUNwQiwwQkFBWSxVQUFaLElBQTJCLE1BQU0sVUFBakM7QUFDRDtBQUNGO0FBQ0QsbUJBQVMsRUFBRSxZQUFhLFdBQWYsRUFBVDtBQUNEO0FBQ0QsYUFBSyxHQUFMLENBQVMsT0FBVCxDQUFpQixpQkFBTSxhQUF2QixFQUFxQyxNQUFyQztBQUNBO0FBQ0EsYUFBSyxTQUFMLElBQWtCLE1BQWxCLEVBQTBCO0FBQ3hCLGtCQUFRLE9BQU8sU0FBUCxDQUFSO0FBQ0EseUJBQU8sR0FBUCxpQkFBeUIsU0FBekIsbUJBQWdELE1BQU0sU0FBdEQsK0JBQXlGLE1BQU0sVUFBL0YsU0FBNkcsTUFBTSxLQUFuSDtBQUNBLGNBQUksY0FBYyxNQUFNLFdBQXhCO0FBQ0EsY0FBSSxXQUFKLEVBQWlCO0FBQ2YsaUJBQUssUUFBTCxHQUFnQixJQUFoQjtBQUNBLGlCQUFLLEdBQUwsQ0FBUyxPQUFULENBQWlCLGlCQUFNLGdCQUF2QixFQUF5QyxFQUFDLE1BQU0sU0FBUCxFQUFrQixNQUFNLFdBQXhCLEVBQXFDLFFBQVMsTUFBOUMsRUFBc0QsU0FBVSxhQUFoRSxFQUF6QztBQUNEO0FBQ0Y7QUFDRDtBQUNBLGFBQUssSUFBTDtBQUNEO0FBQ0Y7OztzQ0FFaUIsSSxFQUFNO0FBQUE7O0FBQ3RCLFVBQUksY0FBYyxLQUFLLFdBQXZCO0FBQ0EsVUFBSSxlQUNBLEtBQUssRUFBTCxLQUFZLE1BRFosSUFFQSxLQUFLLEVBQUwsS0FBWSxZQUFZLEVBRnhCLElBR0EsS0FBSyxLQUFMLEtBQWUsWUFBWSxLQUgzQixJQUlBLEVBQUUsS0FBSyxJQUFMLEtBQWMsT0FBZCxJQUF5QixLQUFLLFFBQWhDLENBSkEsSUFJNkM7QUFDN0MsV0FBSyxLQUFMLEtBQWUsTUFBTSxPQUx6QixFQUtrQztBQUNoQyxZQUFJLFFBQVEsS0FBSyxNQUFMLENBQVksS0FBSyxLQUFqQixDQUFaO0FBQUEsWUFDSSxPQUFPLEtBQUssV0FEaEI7O0FBR0EsdUJBQU8sR0FBUCxhQUFxQixLQUFLLElBQTFCLGNBQXVDLEtBQUssUUFBTCxDQUFjLE9BQWQsQ0FBc0IsQ0FBdEIsQ0FBdkMsU0FBbUUsS0FBSyxNQUFMLENBQVksT0FBWixDQUFvQixDQUFwQixDQUFuRSxlQUFtRyxLQUFLLFFBQUwsQ0FBYyxPQUFkLENBQXNCLENBQXRCLENBQW5HLFNBQStILEtBQUssTUFBTCxDQUFZLE9BQVosQ0FBb0IsQ0FBcEIsQ0FBL0gsYUFBNkosS0FBSyxFQUFsSyxrQkFBZ0wsS0FBSyxPQUFMLElBQWdCLENBQWhNOztBQUVBO0FBQ0EsWUFBRyxLQUFLLElBQUwsS0FBYyxPQUFqQixFQUEwQjtBQUN4QixlQUFLLE9BQUwsR0FBZSxLQUFLLE9BQXBCO0FBQ0EsY0FBSSxLQUFLLE9BQVQsRUFBa0I7QUFDaEIsZ0JBQUksQ0FBQyxLQUFLLFdBQVYsRUFBdUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsbUJBQUssV0FBTCxHQUFtQixJQUFuQjtBQUNBLG1CQUFLLGdCQUFMLEdBQXdCLEtBQUssUUFBN0I7QUFDQSxtQkFBSyxLQUFMLEdBQWEsTUFBTSxJQUFuQjtBQUNBLG1CQUFLLElBQUw7QUFDQTtBQUNELGFBVEQsTUFTTztBQUNMLDZCQUFPLElBQVAsQ0FBWSw4REFBWjtBQUNEO0FBQ0YsV0FiRCxNQWFPO0FBQ0w7QUFDQSxpQkFBSyxXQUFMLEdBQW1CLEtBQW5CO0FBQ0Q7QUFDRjs7QUFFRCxZQUFJLFFBQVEsc0JBQVksZ0JBQVosQ0FBNkIsTUFBTSxPQUFuQyxFQUEyQyxLQUFLLEVBQWhELEVBQW1ELEtBQUssUUFBeEQsRUFBaUUsS0FBSyxNQUF0RSxFQUE2RSxLQUFLLFFBQWxGLEVBQTJGLEtBQUssTUFBaEcsQ0FBWjtBQUFBLFlBQ0ksTUFBTSxLQUFLLEdBRGY7QUFFQSxZQUFJLE9BQUosQ0FBWSxpQkFBTSxpQkFBbEIsRUFBcUMsRUFBQyxTQUFTLE1BQU0sT0FBaEIsRUFBeUIsT0FBTyxLQUFLLEtBQXJDLEVBQTRDLE9BQU8sS0FBbkQsRUFBMEQsTUFBTSxLQUFLLElBQXJFLEVBQTJFLE9BQU8sS0FBSyxRQUF2RixFQUFpRyxLQUFLLEtBQUssTUFBM0csRUFBckM7O0FBRUE7QUFDQSxTQUFDLEtBQUssS0FBTixFQUFhLEtBQUssS0FBbEIsRUFBeUIsT0FBekIsQ0FBaUMsa0JBQVU7QUFDekMsY0FBSSxNQUFKLEVBQVk7QUFDVixtQkFBSyxRQUFMLEdBQWdCLElBQWhCO0FBQ0EsZ0JBQUksT0FBSixDQUFZLGlCQUFNLGdCQUFsQixFQUFvQyxFQUFDLE1BQU0sS0FBSyxJQUFaLEVBQWtCLE1BQU0sTUFBeEIsRUFBZ0MsUUFBUyxNQUF6QyxFQUFnRCxTQUFVLE1BQTFELEVBQXBDO0FBQ0Q7QUFDRixTQUxEOztBQU9BLGFBQUssV0FBTCxDQUFpQixJQUFqQixDQUFzQixFQUFDLE1BQU0sS0FBSyxJQUFaLEVBQWtCLE9BQU8sS0FBSyxRQUE5QixFQUF3QyxLQUFLLEtBQUssTUFBbEQsRUFBMEQsTUFBTSxJQUFoRSxFQUF0Qjs7QUFFQTtBQUNBLGFBQUssSUFBTDtBQUNEO0FBQ0Y7OztpQ0FFWSxJLEVBQU07QUFDakIsVUFBSSxjQUFjLEtBQUssV0FBdkI7QUFDQSxVQUFJLGVBQ0EsS0FBSyxFQUFMLEtBQVksTUFEWixJQUVBLEtBQUssRUFBTCxLQUFZLFlBQVksRUFGeEIsSUFHQSxLQUFLLEtBQUwsS0FBZSxZQUFZLEtBSDNCLElBSUEsS0FBSyxLQUFMLEtBQWUsTUFBTSxPQUp6QixFQUlrQztBQUNoQyxhQUFLLEtBQUwsQ0FBVyxPQUFYLEdBQXFCLFlBQVksR0FBWixFQUFyQjtBQUNBLGFBQUssS0FBTCxHQUFhLE1BQU0sTUFBbkI7QUFDQSxhQUFLLG9CQUFMO0FBQ0Q7QUFDRjs7OzBDQUVxQixJLEVBQU07QUFDMUI7QUFDQSxVQUFJLFdBQVcsQ0FBQyxDQUFDLEtBQUssR0FBdEI7QUFBQSxVQUNJLFVBQVUsS0FBSyxFQURuQjtBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQUksQ0FBQyxRQUFMLEVBQWU7QUFDYixZQUFJLEtBQUssV0FBTCxLQUFxQixLQUFLLEtBQTlCLEVBQXFDO0FBQ25DLHlCQUFPLEdBQVA7QUFDQSxlQUFLLFdBQUwsR0FBbUIsS0FBSyxLQUF4QjtBQUNBLGNBQUksY0FBYyxLQUFLLFdBQXZCO0FBQ0E7QUFDQSxjQUFJLFlBQVksTUFBaEIsRUFBd0I7QUFDdEIsMkJBQU8sR0FBUCxDQUFXLDBEQUFYO0FBQ0Esd0JBQVksTUFBWixDQUFtQixLQUFuQjtBQUNEO0FBQ0QsZUFBSyxXQUFMLEdBQW1CLElBQW5CO0FBQ0EsZUFBSyxZQUFMLEdBQW9CLElBQXBCO0FBQ0E7QUFDQSxjQUFJLEtBQUssT0FBVCxFQUFrQjtBQUNoQixpQkFBSyxPQUFMLENBQWEsT0FBYjtBQUNBLGlCQUFLLE9BQUwsR0FBZSxJQUFmO0FBQ0Q7QUFDRDtBQUNBLGVBQUssS0FBTCxHQUFhLE1BQU0sSUFBbkI7QUFDRDtBQUNELFlBQUksTUFBTSxLQUFLLEdBQWY7QUFDQTtBQUNBLFlBQUksT0FBSixDQUFZLGlCQUFNLGVBQWxCLEVBQW1DLEVBQUMsYUFBYSxDQUFkLEVBQWtCLFdBQVcsT0FBTyxpQkFBcEMsRUFBdUQsTUFBTyxPQUE5RCxFQUFuQztBQUNBLFlBQUksT0FBSixDQUFZLGlCQUFNLG9CQUFsQixFQUF3QyxFQUFDLElBQUssT0FBTixFQUF4QztBQUNBLGFBQUssUUFBTCxHQUFnQixLQUFoQjtBQUNEO0FBQ0Y7Ozt5Q0FFb0IsSSxFQUFNO0FBQ3pCLFVBQUksVUFBVSxLQUFLLEVBQW5CO0FBQUEsVUFDQSxXQUFXLENBQUMsQ0FBQyxLQUFLLEdBQUwsQ0FBUyxXQUFULENBQXFCLE9BQXJCLEVBQThCLEdBRDNDO0FBRUEsVUFBSSxRQUFKLEVBQWM7QUFDWixZQUFJLGNBQWMsS0FBSyxXQUF2QjtBQUNBO0FBQ0EsWUFBSSxlQUFlLEtBQUssV0FBTCxLQUFxQixXQUF4QyxFQUFxRDtBQUNuRCx5QkFBTyxHQUFQO0FBQ0EsZUFBSyxXQUFMLEdBQW1CLFdBQW5CO0FBQ0Q7QUFDRjtBQUNELFdBQUssUUFBTCxHQUFnQixRQUFoQjtBQUNBLFdBQUssSUFBTDtBQUNEOzs7b0NBSWUsSSxFQUFNO0FBQ3BCLFVBQUksU0FBUyxLQUFLLE1BQWxCO0FBQUEsVUFBMEIsbUJBQTFCO0FBQUEsVUFBc0MsYUFBdEM7QUFBQSxVQUE0QyxZQUFZLEtBQXhEO0FBQ0EsV0FBSSxJQUFJLElBQVIsSUFBZ0IsTUFBaEIsRUFBd0I7QUFDdEIsWUFBSSxRQUFRLE9BQU8sSUFBUCxDQUFaO0FBQ0EsWUFBSSxNQUFNLEVBQU4sS0FBYSxNQUFqQixFQUF5QjtBQUN2QixpQkFBTyxJQUFQO0FBQ0EsdUJBQWEsS0FBYjtBQUNBO0FBQ0EsY0FBSSxTQUFTLE9BQWIsRUFBc0I7QUFDcEIsaUJBQUssV0FBTCxHQUFtQixPQUFPLElBQVAsRUFBYSxNQUFoQztBQUNEO0FBQ0YsU0FQRCxNQU9PO0FBQ0wsc0JBQVksSUFBWjtBQUNEO0FBQ0Y7QUFDRCxVQUFJLGFBQWEsVUFBakIsRUFBNkI7QUFDM0IsdUJBQU8sR0FBUCxpQ0FBeUMsSUFBekM7QUFDQSxhQUFLLFdBQUwsR0FBbUIsV0FBVyxNQUE5QjtBQUNELE9BSEQsTUFHTztBQUNMLGFBQUssV0FBTCxHQUFtQixLQUFLLEtBQXhCO0FBQ0Q7QUFDRjs7O3FDQUVnQixJLEVBQU07QUFDckIsVUFBSSxLQUFLLE1BQUwsS0FBZ0IsTUFBcEIsRUFBNEI7QUFDMUIsWUFBTSxRQUFRLEtBQUssS0FBbkI7QUFDQSxZQUFJLFVBQVUsTUFBTSxPQUFoQixJQUEyQixVQUFVLE1BQU0sTUFBL0MsRUFBdUQ7QUFDckQsZUFBSyxnQkFBTCxHQUF3QixLQUFLLE9BQTdCO0FBQ0EsZUFBSyxvQkFBTDtBQUNEO0FBQ0Y7QUFDRjs7OzJDQUVzQjtBQUNyQjtBQUNBLFVBQUksS0FBSyxLQUFMLEtBQWUsTUFBTSxNQUFyQixLQUFnQyxDQUFDLEtBQUssUUFBTixJQUFrQixLQUFLLGdCQUFMLEtBQTBCLENBQTVFLENBQUosRUFBb0Y7QUFDbEYsWUFBSSxPQUFPLEtBQUssV0FBaEI7QUFBQSxZQUE2QixRQUFRLEtBQUssS0FBMUM7QUFDQSxZQUFJLElBQUosRUFBVTtBQUNSLGVBQUssWUFBTCxHQUFvQixJQUFwQjtBQUNBLGdCQUFNLFNBQU4sR0FBa0IsWUFBWSxHQUFaLEVBQWxCO0FBQ0E7QUFDQSxlQUFLLFlBQUwsR0FBb0IsS0FBSyxLQUFMLENBQVcsSUFBSSxNQUFNLEtBQVYsSUFBbUIsTUFBTSxTQUFOLEdBQWtCLE1BQU0sTUFBM0MsQ0FBWCxDQUFwQjtBQUNBLGVBQUssR0FBTCxDQUFTLE9BQVQsQ0FBaUIsaUJBQU0sYUFBdkIsRUFBc0MsRUFBQyxPQUFPLEtBQVIsRUFBZSxNQUFNLElBQXJCLEVBQTJCLElBQUssTUFBaEMsRUFBdEM7QUFDQSxjQUFJLFFBQVEsS0FBSyxXQUFMLEdBQW1CLEtBQUssV0FBeEIsR0FBc0MsS0FBSyxLQUF2RDtBQUNBLHlCQUFPLEdBQVAsc0JBQThCLHFCQUFXLFFBQVgsQ0FBb0IsTUFBTSxRQUExQixDQUE5QjtBQUNBLGVBQUssS0FBTCxHQUFhLE1BQU0sSUFBbkI7QUFDRDtBQUNELGFBQUssSUFBTDtBQUNEO0FBQ0Y7Ozs0QkFFTyxJLEVBQU07QUFDWixVQUFJLE9BQU8sS0FBSyxJQUFMLElBQWEsS0FBSyxXQUE3QjtBQUNBO0FBQ0EsVUFBSSxRQUFRLEtBQUssSUFBTCxLQUFjLE1BQTFCLEVBQWtDO0FBQ2hDO0FBQ0Q7QUFDRCxVQUFJLFFBQVEsS0FBSyxLQUFqQjs7QUFDSTtBQUNBLHNCQUFnQixTQUFTLHVCQUFhLFVBQWIsQ0FBd0IsS0FBeEIsRUFBOEIsTUFBTSxXQUFwQyxDQUFULElBQTZELHVCQUFhLFVBQWIsQ0FBd0IsS0FBeEIsRUFBOEIsTUFBTSxXQUFOLEdBQWtCLEdBQWhELENBRmpGO0FBR0EsY0FBTyxLQUFLLE9BQVo7QUFDRSxhQUFLLHFCQUFhLGVBQWxCO0FBQ0EsYUFBSyxxQkFBYSxpQkFBbEI7QUFDQSxhQUFLLHFCQUFhLGNBQWxCO0FBQ0EsYUFBSyxxQkFBYSxnQkFBbEI7QUFDRSxjQUFHLENBQUMsS0FBSyxLQUFULEVBQWdCO0FBQ2QsZ0JBQUksWUFBWSxLQUFLLGFBQXJCO0FBQ0EsZ0JBQUcsU0FBSCxFQUFjO0FBQ1o7QUFDRCxhQUZELE1BRU87QUFDTCwwQkFBVSxDQUFWO0FBQ0Q7QUFDRCxnQkFBSSxTQUFTLEtBQUssTUFBbEI7QUFDQTtBQUNBLGdCQUFJLGFBQWEsT0FBTyxtQkFBcEIsSUFBMkMsYUFBM0MsSUFBNkQsS0FBSyxTQUFMLElBQWtCLEtBQUssS0FBeEYsRUFBZ0c7QUFDOUYsbUJBQUssYUFBTCxHQUFxQixTQUFyQjtBQUNBO0FBQ0EsbUJBQUssV0FBTCxHQUFtQixDQUFuQjtBQUNBO0FBQ0Esa0JBQUksUUFBUSxLQUFLLEdBQUwsQ0FBUyxLQUFLLEdBQUwsQ0FBUyxDQUFULEVBQVcsWUFBVSxDQUFyQixJQUF3QixPQUFPLHFCQUF4QyxFQUE4RCxPQUFPLDBCQUFyRSxDQUFaO0FBQ0EsNkJBQU8sSUFBUCxxREFBOEQsS0FBOUQ7QUFDQSxtQkFBSyxTQUFMLEdBQWlCLFlBQVksR0FBWixLQUFvQixLQUFyQztBQUNBO0FBQ0EsbUJBQUssS0FBTCxHQUFhLE1BQU0sMEJBQW5CO0FBQ0QsYUFWRCxNQVVPO0FBQ0wsNkJBQU8sS0FBUCx1QkFBaUMsS0FBSyxPQUF0QztBQUNBO0FBQ0EsbUJBQUssS0FBTCxHQUFhLElBQWI7QUFDQSxtQkFBSyxHQUFMLENBQVMsT0FBVCxDQUFpQixpQkFBTSxLQUF2QixFQUE4QixJQUE5QjtBQUNBLG1CQUFLLEtBQUwsR0FBYSxNQUFNLEtBQW5CO0FBQ0Q7QUFDRjtBQUNEO0FBQ0YsYUFBSyxxQkFBYSx1QkFBbEI7QUFDRSxjQUFHLENBQUMsS0FBSyxLQUFULEVBQWdCO0FBQ2Q7QUFDQSxnQkFBSSxhQUFKLEVBQW1CO0FBQ2pCO0FBQ0E7QUFDQSxtQkFBSyxzQkFBTCxDQUE0QixLQUFLLFFBQWpDO0FBQ0EsbUJBQUssS0FBTCxHQUFhLE1BQU0sSUFBbkI7QUFDRCxhQUxELE1BS087QUFDTDtBQUNBO0FBQ0Esa0JBQUksQ0FBQyxLQUFLLFNBQU4sSUFBbUIsS0FBSyxLQUFMLEtBQWUsQ0FBdEMsRUFBeUM7QUFDdkM7QUFDQSxxQkFBSyxLQUFMLEdBQWEsSUFBYjtBQUNBLHFCQUFLLEdBQUwsQ0FBUyxPQUFULENBQWlCLGlCQUFNLEtBQXZCLEVBQThCLElBQTlCO0FBQ0EscUJBQUssS0FBTCxHQUFhLE1BQU0sS0FBbkI7QUFDRDtBQUNGO0FBQ0Y7QUFDRDtBQUNGLGFBQUsscUJBQWEsZ0JBQWxCO0FBQ0EsYUFBSyxxQkFBYSxrQkFBbEI7QUFDRSxjQUFHLEtBQUssS0FBTCxLQUFlLE1BQU0sS0FBeEIsRUFBK0I7QUFDN0IsZ0JBQUksS0FBSyxLQUFULEVBQWdCO0FBQ2Y7QUFDQyxtQkFBSyxLQUFMLEdBQWEsTUFBTSxLQUFuQjtBQUNBLDZCQUFPLElBQVAsd0JBQWlDLEtBQUssT0FBdEMsbUJBQTJELEtBQUssS0FBaEU7QUFDRCxhQUpELE1BSU87QUFDTDtBQUNBLGtCQUFJLEtBQUssS0FBTCxLQUFlLE1BQU0sYUFBekIsRUFBd0M7QUFDdEMscUJBQUssS0FBTCxHQUFhLE1BQU0sSUFBbkI7QUFDRDtBQUNGO0FBQ0Y7QUFDRDtBQUNGLGFBQUsscUJBQWEsaUJBQWxCO0FBQ0U7QUFDQSxjQUFJLEtBQUssS0FBTCxLQUFlLE1BQU0sT0FBckIsSUFBZ0MsS0FBSyxLQUFMLEtBQWUsTUFBTSxNQUF6RCxFQUFpRTtBQUMvRDtBQUNBLGdCQUFJLGFBQUosRUFBbUI7QUFDakIsbUJBQUssc0JBQUwsQ0FBNEIsS0FBSyxRQUFqQztBQUNBLG1CQUFLLEtBQUwsR0FBYSxNQUFNLElBQW5CO0FBQ0QsYUFIRCxNQUdPO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsNkJBQU8sSUFBUCxDQUFZLDRFQUFaO0FBQ0EsbUJBQUssV0FBTCxHQUFtQixJQUFuQjtBQUNBO0FBQ0EsbUJBQUssZUFBTCxDQUFxQixDQUFyQixFQUF1QixPQUFPLGlCQUE5QjtBQUNEO0FBQ0Y7QUFDRDtBQUNGO0FBQ0U7QUF2Rko7QUF5RkQ7OzsyQ0FFc0IsUyxFQUFXO0FBQ2hDLFVBQUksU0FBUyxLQUFLLE1BQWxCO0FBQ0EsVUFBSSxPQUFPLGtCQUFQLElBQTZCLFNBQWpDLEVBQTRDO0FBQzFDO0FBQ0EsZUFBTyxrQkFBUCxJQUEyQixDQUEzQjtBQUNBLHVCQUFPLElBQVAsa0NBQTJDLE9BQU8sa0JBQWxEO0FBQ0E7QUFDQSxhQUFLLFdBQUwsSUFBb0IsSUFBSSxPQUFPLHdCQUEvQjtBQUNEO0FBQ0Y7OzttQ0FFWTtBQUNYLFVBQUksUUFBUSxLQUFLLEtBQWpCO0FBQ0E7QUFDQSxVQUFHLFNBQVMsTUFBTSxVQUFsQixFQUE4QjtBQUMxQixZQUFJLGNBQWMsTUFBTSxXQUF4QjtBQUFBLFlBQ0ssV0FBVyxNQUFNLFFBRHRCO0FBRUY7QUFDQSxZQUFHLENBQUMsS0FBSyxjQUFOLElBQXdCLFNBQVMsTUFBakMsSUFBMkMsQ0FBQyxNQUFNLE9BQXJELEVBQThEO0FBQzVELGVBQUssY0FBTCxHQUFzQixJQUF0QjtBQUNBO0FBQ0E7QUFDQSxjQUFJLGdCQUFnQixLQUFLLGFBQXpCO0FBQUEsY0FDSSx3QkFBd0IsdUJBQWEsVUFBYixDQUF3QixLQUF4QixFQUE4QixhQUE5QixDQUQ1QjtBQUVBO0FBQ0EsY0FBSSxnQkFBZ0IsYUFBaEIsSUFBaUMsQ0FBQyxxQkFBdEMsRUFBNkQ7QUFDM0QsMkJBQU8sR0FBUCw0QkFBb0MsYUFBcEM7QUFDQTtBQUNBLGdCQUFHLENBQUMscUJBQUosRUFBMkI7QUFDekIsOEJBQWdCLFNBQVMsS0FBVCxDQUFlLENBQWYsQ0FBaEI7QUFDQSw2QkFBTyxHQUFQLG9FQUE0RSxhQUE1RTtBQUNEO0FBQ0QsMkJBQU8sR0FBUCw4QkFBc0MsV0FBdEMsWUFBd0QsYUFBeEQ7QUFDQSxrQkFBTSxXQUFOLEdBQW9CLGFBQXBCO0FBQ0Q7QUFDRixTQWpCRCxNQWlCTyxJQUFJLEtBQUssZUFBVCxFQUEwQjtBQUNqQyxlQUFLLHVCQUFMO0FBQ0MsU0FGTSxNQUVBO0FBQ0wsY0FBSSxhQUFhLHVCQUFhLFVBQWIsQ0FBd0IsS0FBeEIsRUFBOEIsV0FBOUIsRUFBMEMsQ0FBMUMsQ0FBakI7QUFBQSxjQUNJLGtCQUFrQixFQUFFLE1BQU0sTUFBTixJQUFnQjtBQUNoQixnQkFBTSxLQUROLElBQ2dCO0FBQ2hCLGdCQUFNLFFBQU4sQ0FBZSxNQUFmLEtBQTBCLENBRjVCLENBRHRCO0FBQUEsY0FHc0Q7QUFDbEQsMEJBQWdCLEdBSnBCO0FBQUEsY0FJeUI7QUFDckIsMkJBQWlCLGNBQWMsTUFBTSxZQUFOLEdBQW1CLEtBQUssZUFMM0Q7QUFBQSxjQU1JLFNBQVMsS0FBSyxNQU5sQjs7QUFRQSxjQUFJLEtBQUssT0FBTCxJQUFnQixjQUFwQixFQUFvQztBQUNsQyxpQkFBSyxPQUFMLEdBQWUsS0FBZjtBQUNBLDJCQUFPLEdBQVAsa0NBQTBDLFdBQTFDO0FBQ0Q7QUFDRDtBQUNBO0FBQ0EsY0FBRyxtQkFBbUIsV0FBVyxHQUFYLElBQWtCLGFBQXhDLEVBQXVEO0FBQ3JELGdCQUFHLGNBQUgsRUFBbUI7QUFDakI7QUFDQSw4QkFBZ0IsQ0FBaEI7QUFDQSxtQkFBSyxxQkFBTCxHQUE2QixDQUE3QjtBQUNELGFBSkQsTUFJTztBQUNMO0FBQ0Esa0JBQUcsQ0FBQyxLQUFLLE9BQVQsRUFBa0I7QUFDaEIscUJBQUsscUJBQUwsR0FBNkIsQ0FBN0I7QUFDQSwrQkFBTyxHQUFQLDRCQUFvQyxXQUFwQztBQUNBLHFCQUFLLEdBQUwsQ0FBUyxPQUFULENBQWlCLGlCQUFNLEtBQXZCLEVBQThCLEVBQUMsTUFBTSxtQkFBVyxXQUFsQixFQUErQixTQUFTLHFCQUFhLG9CQUFyRCxFQUEyRSxPQUFPLEtBQWxGLEVBQTlCO0FBQ0EscUJBQUssT0FBTCxHQUFlLElBQWY7QUFDRCxlQUxELE1BS087QUFDTCxxQkFBSyxxQkFBTCxJQUE4QixPQUFPLHFCQUFyQztBQUNEO0FBQ0Y7QUFDRDtBQUNBLGdCQUFHLFdBQVcsR0FBWCxJQUFrQixhQUFyQixFQUFvQztBQUNsQztBQUNBLGtCQUFJLGtCQUFrQixXQUFXLFNBQWpDO0FBQUEsa0JBQTRDLFFBQVEsa0JBQWdCLFdBQXBFO0FBQ0Esa0JBQUcsbUJBQ0MsUUFBUSxPQUFPLFdBRGhCLElBRUMsUUFBUSxDQUZaLEVBRWdCO0FBQ2Q7QUFDQTtBQUNBLCtCQUFPLEdBQVAsOEJBQXNDLE1BQU0sV0FBNUMsNEJBQThFLGVBQTlFLGlCQUF5RyxLQUFLLHFCQUE5RztBQUNBLG9CQUFJLE9BQU8sa0JBQWtCLEtBQUsscUJBQXZCLEdBQStDLE1BQU0sV0FBaEU7QUFDQSxzQkFBTSxXQUFOLEdBQW9CLGtCQUFrQixLQUFLLHFCQUEzQztBQUNBLHFCQUFLLEdBQUwsQ0FBUyxPQUFULENBQWlCLGlCQUFNLEtBQXZCLEVBQThCLEVBQUMsTUFBTSxtQkFBVyxXQUFsQixFQUErQixTQUFTLHFCQUFhLHFCQUFyRCxFQUE0RSxPQUFPLEtBQW5GLEVBQTBGLE1BQU8sSUFBakcsRUFBOUI7QUFDRDtBQUNGO0FBQ0Y7QUFDRjtBQUNGO0FBQ0Y7OztpREFFNEI7QUFDM0IsV0FBSyxLQUFMLEdBQWEsTUFBTSxJQUFuQjtBQUNBO0FBQ0E7QUFDQSxVQUFHLENBQUMsS0FBSyxjQUFULEVBQXlCO0FBQ3ZCLGFBQUssa0JBQUwsR0FBMEIsS0FBMUI7QUFDRDtBQUNELFdBQUssSUFBTDtBQUNEOzs7c0NBRWlCO0FBQ2hCOzs7OztBQUtBLFVBQUksUUFBUSxLQUFLLFdBQUwsR0FBbUIsS0FBSyxXQUF4QixHQUFzQyxLQUFLLEtBQXZEO0FBQUEsVUFDSSxjQUFjLEtBQUssV0FEdkI7QUFBQSxVQUVJLFdBQVcsRUFGZjtBQUFBLFVBRWtCLGNBRmxCO0FBQUEsVUFFd0IsVUFGeEI7QUFHQSxXQUFLLElBQUksQ0FBVCxFQUFZLElBQUksWUFBWSxNQUE1QixFQUFvQyxHQUFwQyxFQUF5QztBQUN2QyxnQkFBUSxZQUFZLENBQVosQ0FBUjtBQUNBLFlBQUksdUJBQWEsVUFBYixDQUF3QixLQUF4QixFQUE4QixDQUFDLE1BQU0sS0FBTixHQUFjLE1BQU0sR0FBckIsSUFBNEIsQ0FBMUQsQ0FBSixFQUFrRTtBQUNoRSxtQkFBUyxJQUFULENBQWMsS0FBZDtBQUNEO0FBQ0Y7QUFDRCxXQUFLLFdBQUwsR0FBbUIsUUFBbkI7O0FBRUE7QUFDQSxXQUFLLFdBQUwsSUFBb0IsSUFBSSxLQUFLLE1BQUwsQ0FBWSx3QkFBcEM7QUFDQTtBQUNBLFdBQUssS0FBTCxHQUFhLE1BQU0sSUFBbkI7QUFDQTtBQUNBLFdBQUssWUFBTCxHQUFvQixJQUFwQjtBQUNEOzs7bUNBRWMsSSxFQUFNO0FBQ25CLFdBQUssTUFBTCxHQUFjLEtBQUssTUFBTCxDQUFZLE1BQVosQ0FBbUIsVUFBQyxLQUFELEVBQVEsS0FBUjtBQUFBLGVBQWtCLFVBQVUsS0FBSyxLQUFqQztBQUFBLE9BQW5CLENBQWQ7QUFDRDs7O3FDQUVnQjtBQUNmLFdBQUssY0FBTCxHQUFzQixDQUFDLEtBQUssY0FBNUI7QUFDRDs7O3dDQUVtQixPLEVBQVMsWSxFQUFjO0FBQ3pDLFVBQUksZ0JBQWdCLEtBQUssTUFBTCxDQUFZLGdCQUFaLEtBQWlDLFNBQWpDLEdBQTZDLEtBQUssTUFBTCxDQUFZLGdCQUF6RCxHQUE0RSxLQUFLLE1BQUwsQ0FBWSxxQkFBWixHQUFvQyxhQUFhLGNBQWpKO0FBQ0EsYUFBTyxVQUFVLEtBQUssR0FBTCxDQUFTLENBQVQsRUFBWSxhQUFhLGFBQWIsR0FBNkIsYUFBekMsQ0FBakI7QUFDRDs7O3NCQWg5QlMsUyxFQUFXO0FBQ25CLFVBQUksS0FBSyxLQUFMLEtBQWUsU0FBbkIsRUFBOEI7QUFDNUIsWUFBTSxnQkFBZ0IsS0FBSyxLQUEzQjtBQUNBLGFBQUssTUFBTCxHQUFjLFNBQWQ7QUFDQSx1QkFBTyxHQUFQLG1DQUEyQyxhQUEzQyxZQUErRCxTQUEvRDtBQUNBLGFBQUssR0FBTCxDQUFTLE9BQVQsQ0FBaUIsaUJBQU0sdUJBQXZCLEVBQWdELEVBQUMsNEJBQUQsRUFBZ0Isb0JBQWhCLEVBQWhEO0FBQ0Q7QUFDRixLO3dCQUVXO0FBQ1YsYUFBTyxLQUFLLE1BQVo7QUFDRDs7O3dCQWdCa0I7QUFDakIsVUFBSSxRQUFRLEtBQUssS0FBakI7QUFDQSxVQUFJLEtBQUosRUFBVztBQUNULFlBQUksUUFBUSxLQUFLLGNBQUwsQ0FBb0IsTUFBTSxXQUExQixDQUFaO0FBQ0EsWUFBSSxLQUFKLEVBQVc7QUFDVCxpQkFBTyxNQUFNLElBQU4sQ0FBVyxLQUFsQjtBQUNEO0FBQ0Y7QUFDRCxhQUFPLENBQUMsQ0FBUjtBQUNEOzs7d0JBRXFCO0FBQ3BCLFVBQUksUUFBUSxLQUFLLEtBQWpCO0FBQ0EsVUFBSSxLQUFKLEVBQVc7QUFDVDtBQUNBLGVBQU8sS0FBSyxvQkFBTCxDQUEwQixLQUFLLGNBQUwsQ0FBb0IsTUFBTSxXQUExQixDQUExQixDQUFQO0FBQ0QsT0FIRCxNQUdPO0FBQ0wsZUFBTyxJQUFQO0FBQ0Q7QUFDRjs7O3dCQVVlO0FBQ2QsVUFBSSxRQUFRLEtBQUssZUFBakI7QUFDQSxVQUFJLEtBQUosRUFBVztBQUNULGVBQU8sTUFBTSxJQUFOLENBQVcsS0FBbEI7QUFDRCxPQUZELE1BRU87QUFDTCxlQUFPLENBQUMsQ0FBUjtBQUNEO0FBQ0Y7Ozt3QkFtNUJzQjtBQUNyQixhQUFPLEtBQUssaUJBQVo7QUFDRCxLO3NCQUVvQixLLEVBQU87QUFDMUIsV0FBSyxpQkFBTCxHQUF5QixLQUF6QjtBQUNEOzs7Ozs7a0JBRVksZ0I7Ozs7Ozs7Ozs7O0FDNzhDZjs7OztBQUNBOzs7O0FBQ0E7Ozs7Ozs7OytlQU5BOzs7O0lBUU0sd0I7OztBQUVKLG9DQUFZLEdBQVosRUFBaUI7QUFBQTs7QUFBQSxvSkFDVCxHQURTLEVBRWIsaUJBQU0sS0FGTyxFQUdiLGlCQUFNLHVCQUhPLEVBSWIsaUJBQU0scUJBSk8sRUFLYixpQkFBTSxxQkFMTyxFQU1iLGlCQUFNLHVCQU5POztBQU9mLFVBQUssTUFBTCxHQUFjLElBQUksTUFBbEI7QUFDQSxVQUFLLG1CQUFMLEdBQTJCLEVBQTNCO0FBQ0EsVUFBSyxhQUFMLEdBQXFCLFNBQXJCO0FBQ0EsVUFBSyxtQkFBTCxHQUEyQixJQUEzQjtBQUNBLFVBQUssY0FBTCxHQUFzQixDQUFDLENBQXZCO0FBWGU7QUFZaEI7Ozs7OEJBRVM7QUFDUiw2QkFBYSxTQUFiLENBQXVCLE9BQXZCLENBQStCLElBQS9CLENBQW9DLElBQXBDO0FBQ0Q7O0FBRUQ7Ozs7eUNBQ3FCO0FBQUE7O0FBQ25CLFdBQUssYUFBTCxHQUFxQixFQUFyQjtBQUNBLFdBQUssTUFBTCxDQUFZLE9BQVosQ0FBb0IsaUJBQVM7QUFDM0IsZUFBSyxhQUFMLENBQW1CLE1BQU0sRUFBekIsSUFBK0IsRUFBL0I7QUFDRCxPQUZEO0FBR0Q7O0FBRUQ7Ozs7K0JBQ1c7QUFDVCxVQUFHLEtBQUssbUJBQUwsS0FBNkIsSUFBN0IsSUFBcUMsS0FBSyxjQUFMLEdBQXNCLENBQUMsQ0FBNUQsSUFBaUUsS0FBSyxhQUFMLENBQW1CLEtBQUssY0FBeEIsRUFBd0MsTUFBNUcsRUFBb0g7QUFDbEgsWUFBSSxPQUFPLEtBQUssbUJBQUwsR0FBMkIsS0FBSyxhQUFMLENBQW1CLEtBQUssY0FBeEIsRUFBd0MsS0FBeEMsRUFBdEM7QUFDQSxhQUFLLEdBQUwsQ0FBUyxPQUFULENBQWlCLGlCQUFNLFlBQXZCLEVBQXFDLEVBQUMsVUFBRCxFQUFyQztBQUNEO0FBQ0Y7O0FBRUQ7Ozs7NENBQ3dCLEksRUFBTTtBQUM1QixVQUFHLEtBQUssT0FBUixFQUFpQjtBQUNmLGFBQUssbUJBQUwsQ0FBeUIsS0FBSyxJQUFMLENBQVUsT0FBbkMsRUFBNEMsSUFBNUMsQ0FBaUQsS0FBSyxJQUFMLENBQVUsRUFBM0Q7QUFDRDtBQUNELFdBQUssbUJBQUwsR0FBMkIsSUFBM0I7QUFDQSxXQUFLLFFBQUw7QUFDRDs7QUFFRDs7Ozs0QkFDUSxJLEVBQU07QUFDWixVQUFJLE9BQU8sS0FBSyxJQUFoQjtBQUNBO0FBQ0EsVUFBSSxRQUFRLEtBQUssSUFBTCxLQUFjLFVBQTFCLEVBQXNDO0FBQ3BDO0FBQ0Q7QUFDRCxVQUFHLEtBQUssbUJBQVIsRUFBNkI7QUFDM0IsYUFBSyxtQkFBTCxHQUEyQixJQUEzQjtBQUNBLGFBQUssUUFBTDtBQUNEO0FBQ0Y7O0FBRUQ7Ozs7NENBQ3dCLEksRUFBTTtBQUFBOztBQUM1QixxQkFBTyxHQUFQLENBQVcseUJBQVg7QUFDQSxXQUFLLE1BQUwsR0FBYyxLQUFLLGNBQW5CO0FBQ0EsV0FBSyxrQkFBTDtBQUNBLFdBQUssbUJBQUwsR0FBMkIsRUFBM0I7QUFDQSxXQUFLLE1BQUwsQ0FBWSxPQUFaLENBQW9CLGlCQUFTO0FBQzNCLGVBQUssbUJBQUwsQ0FBeUIsTUFBTSxFQUEvQixJQUFxQyxFQUFyQztBQUNELE9BRkQ7QUFHRDs7OzBDQUVxQixJLEVBQU07QUFDMUIsV0FBSyxjQUFMLEdBQXNCLEtBQUssRUFBM0I7QUFDQSxXQUFLLGtCQUFMO0FBQ0Q7O0FBRUQ7Ozs7MENBQ3NCLEksRUFBTTtBQUMxQixVQUFNLG1CQUFtQixLQUFLLG1CQUFMLENBQXlCLEtBQUssRUFBOUIsQ0FBekI7QUFBQSxVQUNJLFlBQVksS0FBSyxhQUFMLENBQW1CLEtBQUssRUFBeEIsQ0FEaEI7QUFBQSxVQUVJLGdCQUFnQixDQUFDLENBQUMsS0FBSyxtQkFBUCxHQUE2QixLQUFLLG1CQUFMLENBQXlCLEVBQXRELEdBQTJELENBQUMsQ0FGaEY7O0FBSUEsVUFBTSxtQkFBbUIsU0FBbkIsZ0JBQW1CLENBQVMsSUFBVCxFQUFlO0FBQ3RDLGVBQU8saUJBQWlCLE9BQWpCLENBQXlCLEtBQUssRUFBOUIsSUFBb0MsQ0FBQyxDQUE1QztBQUNELE9BRkQ7O0FBSUEsVUFBTSxpQkFBaUIsU0FBakIsY0FBaUIsQ0FBUyxJQUFULEVBQWU7QUFDcEMsZUFBTyxVQUFVLElBQVYsQ0FBZSx1QkFBZTtBQUFDLGlCQUFPLFlBQVksRUFBWixLQUFtQixLQUFLLEVBQS9CO0FBQW1DLFNBQWxFLENBQVA7QUFDRCxPQUZEOztBQUlBO0FBQ0EsV0FBSyxPQUFMLENBQWEsU0FBYixDQUF1QixPQUF2QixDQUErQixnQkFBUTtBQUNyQyxZQUFHLEVBQUUsaUJBQWlCLElBQWpCLEtBQTBCLEtBQUssRUFBTCxLQUFZLGFBQXRDLElBQXVELGVBQWUsSUFBZixDQUF6RCxDQUFILEVBQW1GO0FBQ2pGO0FBQ0EsZUFBSyxPQUFMLEdBQWUsS0FBSyxFQUFwQjtBQUNBLG9CQUFVLElBQVYsQ0FBZSxJQUFmO0FBQ0Q7QUFDRixPQU5EOztBQVFBLFdBQUssUUFBTDtBQUNEOzs7Ozs7a0JBRVksd0I7Ozs7Ozs7Ozs7O0FDeEdmOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7Ozs7K2VBTkE7Ozs7SUFRTSx1Qjs7O0FBRUosbUNBQVksR0FBWixFQUFpQjtBQUFBOztBQUFBLGtKQUNULEdBRFMsRUFFSixpQkFBTSxjQUZGLEVBR0osaUJBQU0sZUFIRixFQUlKLGlCQUFNLGdCQUpGLEVBS0osaUJBQU0sZUFMRixFQU1KLGlCQUFNLHFCQU5GOztBQU9mLFVBQUssTUFBTCxHQUFjLEVBQWQ7QUFDQSxVQUFLLE9BQUwsR0FBZSxDQUFDLENBQWhCO0FBQ0EsVUFBSyxLQUFMLEdBQWEsU0FBYjtBQVRlO0FBVWhCOzs7OzhCQUVTO0FBQ1IsNkJBQWEsU0FBYixDQUF1QixPQUF2QixDQUErQixJQUEvQixDQUFvQyxJQUFwQztBQUNEOztBQUVEOzs7O29DQUNnQixJLEVBQU07QUFBQTs7QUFDcEIsV0FBSyxLQUFMLEdBQWEsS0FBSyxLQUFsQjtBQUNBLFVBQUksQ0FBQyxLQUFLLEtBQVYsRUFBaUI7QUFDZjtBQUNEOztBQUVELFdBQUssS0FBTCxDQUFXLFVBQVgsQ0FBc0IsZ0JBQXRCLENBQXVDLFFBQXZDLEVBQWlELFlBQU07QUFDckQ7QUFDQSxZQUFJLENBQUMsT0FBSyxLQUFWLEVBQWlCO0FBQ2Y7QUFDRDs7QUFFRCxZQUFJLFVBQVUsQ0FBQyxDQUFmO0FBQ0EsWUFBSSxTQUFTLE9BQUssS0FBTCxDQUFXLFVBQXhCO0FBQ0EsYUFBSSxJQUFJLEtBQUssQ0FBYixFQUFnQixLQUFJLE9BQU8sTUFBM0IsRUFBbUMsSUFBbkMsRUFBeUM7QUFDdkMsY0FBRyxPQUFPLEVBQVAsRUFBVyxJQUFYLEtBQW9CLFNBQXZCLEVBQWtDO0FBQ2hDLHNCQUFVLEVBQVY7QUFDRDtBQUNGO0FBQ0Q7QUFDQSxlQUFLLGFBQUwsR0FBcUIsT0FBckI7QUFDRCxPQWZEO0FBZ0JEOzs7dUNBRWtCO0FBQ2pCO0FBQ0EsV0FBSyxLQUFMLEdBQWEsU0FBYjtBQUNEOztBQUVEOzs7O3dDQUNvQjtBQUNsQixXQUFLLE1BQUwsR0FBYyxFQUFkO0FBQ0EsV0FBSyxPQUFMLEdBQWUsQ0FBQyxDQUFoQjtBQUNEOztBQUVEOzs7O3FDQUNpQixJLEVBQU07QUFBQTs7QUFDckIsVUFBSSxTQUFTLEtBQUssU0FBTCxJQUFrQixFQUEvQjtBQUNBLFVBQUksZUFBZSxLQUFuQjtBQUNBLFdBQUssTUFBTCxHQUFjLE1BQWQ7QUFDQSxXQUFLLE9BQUwsR0FBZSxDQUFDLENBQWhCO0FBQ0EsV0FBSyxHQUFMLENBQVMsT0FBVCxDQUFpQixpQkFBTSx1QkFBdkIsRUFBZ0QsRUFBQyxnQkFBaUIsTUFBbEIsRUFBaEQ7O0FBRUE7QUFDQTtBQUNBLGFBQU8sT0FBUCxDQUFlLGlCQUFTO0FBQ3RCLFlBQUksTUFBTSxPQUFWLEVBQW1CO0FBQ2pCLGlCQUFLLGFBQUwsR0FBcUIsTUFBTSxFQUEzQjtBQUNBLHlCQUFlLElBQWY7QUFDRDtBQUNGLE9BTEQ7QUFNRDs7QUFFRDs7Ozs2QkFDUztBQUNQLFVBQU0sVUFBVSxLQUFLLE9BQXJCO0FBQ0EsVUFBTSxnQkFBZ0IsS0FBSyxNQUFMLENBQVksT0FBWixDQUF0QjtBQUNBLFVBQUksQ0FBQyxhQUFMLEVBQW9CO0FBQ2xCO0FBQ0Q7O0FBRUQsVUFBTSxVQUFVLGNBQWMsT0FBOUI7QUFDQTtBQUNBLFVBQUksWUFBWSxTQUFaLElBQXlCLFFBQVEsSUFBUixLQUFpQixJQUE5QyxFQUFvRDtBQUNsRDtBQUNBLHVCQUFPLEdBQVAsOENBQXNELE9BQXREO0FBQ0EsYUFBSyxHQUFMLENBQVMsT0FBVCxDQUFpQixpQkFBTSxzQkFBdkIsRUFBK0MsRUFBQyxLQUFLLGNBQWMsR0FBcEIsRUFBeUIsSUFBSSxPQUE3QixFQUEvQztBQUNEO0FBQ0Y7OzswQ0FFcUIsSSxFQUFNO0FBQUE7O0FBQzFCLFVBQUksS0FBSyxFQUFMLEdBQVUsS0FBSyxNQUFMLENBQVksTUFBMUIsRUFBa0M7QUFDaEMsdUJBQU8sR0FBUCxxQkFBNkIsS0FBSyxFQUFsQztBQUNBLGFBQUssTUFBTCxDQUFZLEtBQUssRUFBakIsRUFBcUIsT0FBckIsR0FBK0IsS0FBSyxPQUFwQztBQUNBO0FBQ0EsWUFBSSxLQUFLLE9BQUwsQ0FBYSxJQUFiLElBQXFCLENBQUMsS0FBSyxLQUEvQixFQUFzQztBQUNwQztBQUNBO0FBQ0EsZUFBSyxLQUFMLEdBQWEsWUFBWSxZQUFNO0FBQzdCLG1CQUFLLE1BQUw7QUFDRCxXQUZZLEVBRVYsT0FBTyxLQUFLLE9BQUwsQ0FBYSxjQUZWLEVBRTBCLElBRjFCLENBQWI7QUFHRDtBQUNELFlBQUksQ0FBQyxLQUFLLE9BQUwsQ0FBYSxJQUFkLElBQXNCLEtBQUssS0FBL0IsRUFBc0M7QUFDcEM7QUFDQSx3QkFBYyxLQUFLLEtBQW5CO0FBQ0EsZUFBSyxLQUFMLEdBQWEsSUFBYjtBQUNEO0FBQ0Y7QUFDRjs7QUFFRDs7Ozs2Q0FpQndCLEssRUFBTztBQUM3QjtBQUNBLFVBQUksU0FBUyxDQUFULElBQWMsUUFBUSxLQUFLLE1BQUwsQ0FBWSxNQUF0QyxFQUE4QztBQUM1QztBQUNBLFlBQUksS0FBSyxLQUFULEVBQWdCO0FBQ2Ysd0JBQWMsS0FBSyxLQUFuQjtBQUNBLGVBQUssS0FBTCxHQUFhLElBQWI7QUFDQTtBQUNELGFBQUssT0FBTCxHQUFlLEtBQWY7QUFDQSx1QkFBTyxHQUFQLGtDQUEwQyxLQUExQztBQUNBLFlBQUksZ0JBQWdCLEtBQUssTUFBTCxDQUFZLEtBQVosQ0FBcEI7QUFDQSxhQUFLLEdBQUwsQ0FBUyxPQUFULENBQWlCLGlCQUFNLHFCQUF2QixFQUE4QyxFQUFDLElBQUksS0FBTCxFQUE5QztBQUNDO0FBQ0QsWUFBSSxVQUFVLGNBQWMsT0FBNUI7QUFDQSxZQUFJLFlBQVksU0FBWixJQUF5QixRQUFRLElBQVIsS0FBaUIsSUFBOUMsRUFBb0Q7QUFDbEQ7QUFDQSx5QkFBTyxHQUFQLDhDQUFzRCxLQUF0RDtBQUNBLGVBQUssR0FBTCxDQUFTLE9BQVQsQ0FBaUIsaUJBQU0sc0JBQXZCLEVBQStDLEVBQUMsS0FBSyxjQUFjLEdBQXBCLEVBQXlCLElBQUksS0FBN0IsRUFBL0M7QUFDRDtBQUNGO0FBQ0Y7Ozt3QkFwQ29CO0FBQ25CLGFBQU8sS0FBSyxNQUFaO0FBQ0Q7O0FBRUQ7Ozs7d0JBQ29CO0FBQ25CLGFBQU8sS0FBSyxPQUFaO0FBQ0E7O0FBRUQ7O3NCQUNrQixlLEVBQWlCO0FBQ2pDLFVBQUksS0FBSyxPQUFMLEtBQWlCLGVBQXJCLEVBQXNDO0FBQUM7QUFDckMsYUFBSyx3QkFBTCxDQUE4QixlQUE5QjtBQUNEO0FBQ0Y7Ozs7OztrQkF5QlksdUI7Ozs7Ozs7Ozs7Ozs7QUN6SmY7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7Ozs7K2VBUkE7Ozs7QUFVQSxTQUFTLGdCQUFULENBQTBCLEtBQTFCLEVBQWlDO0FBQy9CLE1BQUksU0FBUyxNQUFNLElBQW5CLEVBQXlCO0FBQ3ZCLFdBQU8sTUFBTSxJQUFOLENBQVcsTUFBWCxHQUFvQixDQUEzQixFQUE4QjtBQUM1QixZQUFNLFNBQU4sQ0FBZ0IsTUFBTSxJQUFOLENBQVcsQ0FBWCxDQUFoQjtBQUNEO0FBQ0Y7QUFDRjs7QUFFRCxTQUFTLGlCQUFULENBQTJCLFVBQTNCLEVBQXVDLGFBQXZDLEVBQXNEO0FBQ3BELFNBQU8sY0FBYyxXQUFXLEtBQVgsS0FBcUIsY0FBYyxJQUFqRCxJQUF5RCxFQUFFLFdBQVcsVUFBWCxJQUF5QixXQUFXLFVBQXRDLENBQWhFO0FBQ0Q7O0FBRUQsU0FBUyxZQUFULENBQXNCLEVBQXRCLEVBQTBCLEVBQTFCLEVBQThCLEVBQTlCLEVBQWtDLEVBQWxDLEVBQXNDO0FBQ3BDLFNBQU8sS0FBSyxHQUFMLENBQVMsRUFBVCxFQUFhLEVBQWIsSUFBbUIsS0FBSyxHQUFMLENBQVMsRUFBVCxFQUFhLEVBQWIsQ0FBMUI7QUFDRDs7SUFFSyxrQjs7O0FBRUosOEJBQVksR0FBWixFQUFpQjtBQUFBOztBQUFBLHdJQUNULEdBRFMsRUFDSixpQkFBTSxlQURGLEVBRUgsaUJBQU0sZUFGSCxFQUdILGlCQUFNLHFCQUhILEVBSUgsaUJBQU0sZ0JBSkgsRUFLSCxpQkFBTSxlQUxILEVBTUgsaUJBQU0sV0FOSCxFQU9ILGlCQUFNLFlBUEgsRUFRSCxpQkFBTSxjQVJIOztBQVVmLFVBQUssR0FBTCxHQUFXLEdBQVg7QUFDQSxVQUFLLE1BQUwsR0FBYyxJQUFJLE1BQWxCO0FBQ0EsVUFBSyxPQUFMLEdBQWUsSUFBZjtBQUNBLFVBQUssSUFBTCxHQUFZLElBQUksTUFBSixDQUFXLFVBQXZCO0FBQ0EsVUFBSyxVQUFMLEdBQWtCLEVBQWxCO0FBQ0EsVUFBSyxNQUFMLEdBQWMsRUFBZDtBQUNBLFVBQUssZ0JBQUwsR0FBd0IsRUFBeEI7QUFDQSxVQUFLLE9BQUwsR0FBZSxTQUFmO0FBQ0EsVUFBSyxTQUFMLEdBQWlCLEVBQWpCOztBQUVBLFFBQUksTUFBSyxNQUFMLENBQVksb0JBQWhCLEVBQ0E7QUFDRSxVQUFJLFlBQUo7QUFDQSxVQUFJLG9CQUFvQixTQUFwQixpQkFBb0IsQ0FBVSxLQUFWLEVBQWlCLEtBQWpCLEVBQ3hCO0FBQ0UsWUFBSSxJQUFJLElBQVI7QUFDQSxZQUFJO0FBQ0YsY0FBSSxJQUFJLE9BQU8sS0FBWCxDQUFpQixVQUFqQixDQUFKO0FBQ0QsU0FGRCxDQUVFLE9BQU8sR0FBUCxFQUFZO0FBQ1o7QUFDQSxjQUFJLFNBQVMsV0FBVCxDQUFxQixPQUFyQixDQUFKO0FBQ0EsWUFBRSxTQUFGLENBQVksVUFBWixFQUF3QixLQUF4QixFQUErQixLQUEvQjtBQUNEO0FBQ0QsVUFBRSxLQUFGLEdBQVUsS0FBVjtBQUNBLGNBQU0sYUFBTixDQUFvQixDQUFwQjtBQUNELE9BWkQ7O0FBY0EsVUFBSSxXQUNKO0FBQ0Usa0JBQVUsZ0JBQVMsU0FBVCxFQUFvQixPQUFwQixFQUE2QixNQUE3QixFQUNWO0FBQ0UsY0FBSSxDQUFDLEtBQUssVUFBVixFQUNBO0FBQ0U7QUFDQSxnQkFBSSxpQkFBaUIsS0FBSyxnQkFBTCxDQUFzQixHQUF0QixDQUFyQjtBQUNBLGdCQUFJLENBQUMsY0FBTCxFQUNBO0FBQ0UsbUJBQUssVUFBTCxHQUFrQixLQUFLLGVBQUwsQ0FBcUIsVUFBckIsRUFBaUMsU0FBakMsRUFBNEMsSUFBNUMsQ0FBbEI7QUFDQSxtQkFBSyxVQUFMLENBQWdCLFVBQWhCLEdBQTZCLElBQTdCO0FBQ0QsYUFKRCxNQU1BO0FBQ0UsbUJBQUssVUFBTCxHQUFrQixjQUFsQjtBQUNBLG1CQUFLLGdCQUFMLENBQXNCLEtBQUssVUFBM0I7QUFDQSxnQ0FBa0IsS0FBSyxVQUF2QixFQUFtQyxLQUFLLEtBQXhDO0FBQ0Q7QUFDRjtBQUNELGVBQUssT0FBTCxDQUFhLFlBQWIsRUFBMkIsU0FBM0IsRUFBc0MsT0FBdEMsRUFBK0MsTUFBL0M7QUFDRDtBQXBCSCxPQURBOztBQXdCQSxVQUFJLFdBQ0o7QUFDRSxrQkFBVSxnQkFBUyxTQUFULEVBQW9CLE9BQXBCLEVBQTZCLE1BQTdCLEVBQ1Y7QUFDRSxjQUFJLENBQUMsS0FBSyxVQUFWLEVBQ0E7QUFDRTtBQUNBLGdCQUFJLGlCQUFpQixLQUFLLGdCQUFMLENBQXNCLEdBQXRCLENBQXJCO0FBQ0EsZ0JBQUksQ0FBQyxjQUFMLEVBQ0E7QUFDRSxtQkFBSyxVQUFMLEdBQWtCLEtBQUssZUFBTCxDQUFxQixVQUFyQixFQUFpQyxTQUFqQyxFQUE0QyxJQUE1QyxDQUFsQjtBQUNBLG1CQUFLLFVBQUwsQ0FBZ0IsVUFBaEIsR0FBNkIsSUFBN0I7QUFDRCxhQUpELE1BTUE7QUFDRSxtQkFBSyxVQUFMLEdBQWtCLGNBQWxCOztBQUVBLGdDQUFrQixLQUFLLFVBQXZCLEVBQW1DLEtBQUssS0FBeEM7QUFDRDtBQUNGO0FBQ0QsZUFBSyxPQUFMLENBQWEsWUFBYixFQUEyQixTQUEzQixFQUFzQyxPQUF0QyxFQUErQyxNQUEvQztBQUNEO0FBcEJILE9BREE7O0FBd0JBLFlBQUssWUFBTCxHQUFvQiwyQkFBaUIsQ0FBakIsRUFBb0IsUUFBcEIsRUFBOEIsUUFBOUIsQ0FBcEI7QUFDRDtBQXRGYztBQXVGaEI7Ozs7NEJBRU8sTyxFQUFTLFMsRUFBVyxPLEVBQVMsTSxFQUFRO0FBQzNDO0FBQ0EsVUFBTSxTQUFTLEtBQUssU0FBcEI7QUFDQSxVQUFJLFNBQVMsS0FBYjtBQUNBLFdBQUssSUFBSSxJQUFJLE9BQU8sTUFBcEIsRUFBNEIsR0FBNUIsR0FBa0M7QUFDaEMsWUFBSSxXQUFXLE9BQU8sQ0FBUCxDQUFmO0FBQ0EsWUFBSSxVQUFVLGFBQWEsU0FBUyxDQUFULENBQWIsRUFBMEIsU0FBUyxDQUFULENBQTFCLEVBQXVDLFNBQXZDLEVBQWtELE9BQWxELENBQWQ7QUFDQSxZQUFJLFdBQVcsQ0FBZixFQUFrQjtBQUNoQixtQkFBUyxDQUFULElBQWMsS0FBSyxHQUFMLENBQVMsU0FBUyxDQUFULENBQVQsRUFBc0IsU0FBdEIsQ0FBZDtBQUNBLG1CQUFTLENBQVQsSUFBYyxLQUFLLEdBQUwsQ0FBUyxTQUFTLENBQVQsQ0FBVCxFQUFzQixPQUF0QixDQUFkO0FBQ0EsbUJBQVMsSUFBVDtBQUNBLGNBQUssV0FBVyxVQUFVLFNBQXJCLENBQUQsR0FBb0MsR0FBeEMsRUFBNkM7QUFDM0M7QUFDRDtBQUNGO0FBQ0Y7QUFDRCxVQUFJLENBQUMsTUFBTCxFQUFhO0FBQ1gsZUFBTyxJQUFQLENBQVksQ0FBQyxTQUFELEVBQVksT0FBWixDQUFaO0FBQ0Q7QUFDRCxXQUFLLElBQUwsQ0FBVSxNQUFWLENBQWlCLEtBQUssT0FBTCxDQUFqQixFQUFnQyxTQUFoQyxFQUEyQyxPQUEzQyxFQUFvRCxNQUFwRDtBQUNEOztBQUVEOzs7O21DQUNlLEksRUFBTTtBQUFBOztBQUNuQixVQUFJLE9BQU8sS0FBSyxPQUFaLEtBQXdCLFdBQTVCLEVBQXlDO0FBQ3ZDLGFBQUssT0FBTCxHQUFlLEtBQUssT0FBcEI7QUFDRDs7QUFFRDtBQUNBO0FBQ0EsVUFBSSxLQUFLLGdCQUFMLENBQXNCLE1BQTFCLEVBQWtDO0FBQ2hDLGFBQUssZ0JBQUwsQ0FBc0IsT0FBdEIsQ0FBOEIsZ0JBQVE7QUFDcEMsaUJBQUssWUFBTCxDQUFrQixJQUFsQjtBQUNELFNBRkQ7QUFHQSxhQUFLLGdCQUFMLEdBQXdCLEVBQXhCO0FBQ0Q7QUFDRjs7O3FDQUVnQixhLEVBQWU7QUFDOUIsVUFBSSxRQUFRLEtBQUssS0FBakI7QUFDQSxVQUFJLEtBQUosRUFBVztBQUNULGFBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxNQUFNLFVBQU4sQ0FBaUIsTUFBckMsRUFBNkMsR0FBN0MsRUFBa0Q7QUFDaEQsY0FBSSxZQUFZLE1BQU0sVUFBTixDQUFpQixDQUFqQixDQUFoQjtBQUNBLGNBQUksV0FBVyxjQUFjLGFBQTdCO0FBQ0EsY0FBSSxVQUFVLFFBQVYsTUFBd0IsSUFBNUIsRUFBa0M7QUFDaEMsbUJBQU8sU0FBUDtBQUNEO0FBQ0Y7QUFDRjtBQUNELGFBQU8sSUFBUDtBQUNEOzs7b0NBRWUsSSxFQUFNLEssRUFBTyxJLEVBQU07QUFDakMsVUFBSSxLQUFLLEtBQVQsRUFDQTtBQUNFLGVBQU8sS0FBSyxLQUFMLENBQVcsWUFBWCxDQUF3QixJQUF4QixFQUE4QixLQUE5QixFQUFxQyxJQUFyQyxDQUFQO0FBQ0Q7QUFDRjs7OzhCQUVTO0FBQ1IsNkJBQWEsU0FBYixDQUF1QixPQUF2QixDQUErQixJQUEvQixDQUFvQyxJQUFwQztBQUNEOzs7cUNBRWdCLEksRUFBTTtBQUNyQixXQUFLLEtBQUwsR0FBYSxLQUFLLEtBQWxCO0FBQ0Q7Ozt1Q0FFa0I7QUFDakIsdUJBQWlCLEtBQUssVUFBdEI7QUFDQSx1QkFBaUIsS0FBSyxVQUF0QjtBQUNEOzs7d0NBR0Q7QUFDRSxXQUFLLE1BQUwsR0FBYyxDQUFDLENBQWYsQ0FERixDQUNvQjtBQUNsQixXQUFLLE1BQUwsR0FBYyxDQUFDLENBQWY7QUFDQSxXQUFLLE1BQUwsR0FBYyxFQUFDLFVBQVUsQ0FBWCxFQUFjLG9CQUFvQixDQUFsQyxFQUFkLENBSEYsQ0FHc0Q7QUFDckQ7OztxQ0FFZ0IsSSxFQUFNO0FBQUE7O0FBQ3JCLFdBQUssVUFBTCxHQUFrQixFQUFsQjtBQUNBLFdBQUssZ0JBQUwsR0FBd0IsS0FBSyxnQkFBTCxJQUF5QixFQUFqRDtBQUNBLFdBQUssT0FBTCxHQUFlLFNBQWY7QUFDQSxXQUFLLFNBQUwsR0FBaUIsRUFBakI7O0FBRUEsVUFBSSxLQUFLLE1BQUwsQ0FBWSxZQUFoQixFQUE4QjtBQUFBO0FBQzVCLGlCQUFLLE1BQUwsR0FBYyxLQUFLLFNBQUwsSUFBa0IsRUFBaEM7QUFDQSxjQUFNLGNBQWMsT0FBSyxLQUFMLEdBQWEsT0FBSyxLQUFMLENBQVcsVUFBeEIsR0FBcUMsRUFBekQ7O0FBRUEsaUJBQUssTUFBTCxDQUFZLE9BQVosQ0FBb0IsVUFBQyxLQUFELEVBQVEsS0FBUixFQUFrQjtBQUNwQyxnQkFBSSxrQkFBSjtBQUNBLGdCQUFNLGFBQWEsWUFBWSxLQUFaLENBQW5CO0FBQ0E7QUFDQSxnQkFBSSxrQkFBa0IsVUFBbEIsRUFBOEIsS0FBOUIsQ0FBSixFQUEwQztBQUN4QywwQkFBWSxVQUFaO0FBQ0QsYUFGRCxNQUVPO0FBQ0wsMEJBQVksT0FBSyxlQUFMLENBQXFCLFdBQXJCLEVBQWtDLE1BQU0sSUFBeEMsRUFBOEMsTUFBTSxJQUFwRCxDQUFaO0FBQ0Q7QUFDRCxzQkFBVSxJQUFWLEdBQWlCLE1BQU0sT0FBTixHQUFnQixTQUFoQixHQUE0QixRQUE3QztBQUNBLG1CQUFLLFVBQUwsQ0FBZ0IsSUFBaEIsQ0FBcUIsU0FBckI7QUFDRCxXQVhEO0FBSjRCO0FBZ0I3QjtBQUNGOzs7b0NBRWU7QUFDZCxXQUFLLE9BQUwsR0FBZSxLQUFLLEdBQUwsQ0FBUyxZQUFULENBQXNCLGNBQXRCLEtBQXlDLE1BQXhEO0FBQ0Q7OztpQ0FFWSxJLEVBQU07QUFBQTs7QUFDakIsVUFBSSxPQUFPLEtBQUssSUFBaEI7QUFBQSxVQUNFLFVBQVUsS0FBSyxPQURqQjtBQUVBLFVBQUksS0FBSyxJQUFMLEtBQWMsTUFBbEIsRUFBMEI7QUFDeEIsWUFBSSxLQUFLLEtBQUssRUFBZDtBQUNBO0FBQ0EsWUFBSSxPQUFPLEtBQUssTUFBTCxHQUFjLENBQXpCLEVBQTRCO0FBQzFCLGVBQUssWUFBTCxDQUFrQixLQUFsQjtBQUNEO0FBQ0QsYUFBSyxNQUFMLEdBQWMsRUFBZDtBQUNEO0FBQ0Q7QUFSQSxXQVNLLElBQUksS0FBSyxJQUFMLEtBQWMsVUFBbEIsRUFBOEI7QUFDakMsY0FBSSxRQUFRLFVBQVosRUFBd0I7QUFBQTtBQUN0QjtBQUNBLGtCQUFJLE9BQU8sT0FBSyxPQUFaLEtBQXdCLFdBQTVCLEVBQXlDO0FBQ3ZDLHVCQUFLLGdCQUFMLENBQXNCLElBQXRCLENBQTJCLElBQTNCO0FBQ0E7QUFBQTtBQUFBO0FBQ0Q7QUFDRCxrQkFBSSxTQUFTLE9BQUssTUFBbEI7QUFDQSxrQkFBSSxDQUFDLE9BQU8sS0FBSyxFQUFaLENBQUwsRUFBc0I7QUFDcEIsdUJBQU8sS0FBSyxFQUFaLElBQWtCLEVBQUUsT0FBTyxLQUFLLEtBQWQsRUFBcUIsUUFBUSxPQUFLLE1BQWxDLEVBQTBDLEtBQUssSUFBL0MsRUFBbEI7QUFDQSx1QkFBSyxNQUFMLEdBQWMsS0FBSyxFQUFuQjtBQUNEO0FBQ0Qsa0JBQUksYUFBYSxPQUFLLFVBQXRCO0FBQUEsa0JBQ0UsTUFBTSxPQUFLLEdBRGI7O0FBR0E7QUFDQSxxQ0FBYSxLQUFiLENBQW1CLE9BQW5CLEVBQTRCLE9BQUssT0FBakMsRUFBMEMsTUFBMUMsRUFBa0QsS0FBSyxFQUF2RCxFQUEyRCxVQUFVLElBQVYsRUFBZ0I7QUFDdkU7QUFDQSxxQkFBSyxPQUFMLENBQWEsZUFBTztBQUNsQiw2QkFBVyxLQUFLLE9BQWhCLEVBQXlCLE1BQXpCLENBQWdDLEdBQWhDO0FBQ0QsaUJBRkQ7QUFHQSxvQkFBSSxPQUFKLENBQVksaUJBQU0sdUJBQWxCLEVBQTJDLEVBQUMsU0FBUyxJQUFWLEVBQWdCLE1BQU0sSUFBdEIsRUFBM0M7QUFDRCxlQU5ILEVBT0UsVUFBVSxDQUFWLEVBQWE7QUFDWDtBQUNBLCtCQUFPLEdBQVAsK0JBQXVDLENBQXZDO0FBQ0Esb0JBQUksT0FBSixDQUFZLGlCQUFNLHVCQUFsQixFQUEyQyxFQUFDLFNBQVMsS0FBVixFQUFpQixNQUFNLElBQXZCLEVBQTNDO0FBQ0QsZUFYSDtBQWZzQjs7QUFBQTtBQTJCdkIsV0EzQkQsTUE0Qks7QUFDSDtBQUNBLGlCQUFLLEdBQUwsQ0FBUyxPQUFULENBQWlCLGlCQUFNLHVCQUF2QixFQUFnRCxFQUFDLFNBQVMsS0FBVixFQUFpQixNQUFNLElBQXZCLEVBQWhEO0FBQ0Q7QUFDRjtBQUNGOzs7MENBRXFCLEksRUFBTTtBQUMxQjtBQUNBO0FBQ0EsVUFBSSxLQUFLLE9BQUwsSUFBZ0IsS0FBSyxNQUFMLENBQVksb0JBQWhDLEVBQXNEO0FBQ3BELGFBQUssSUFBSSxJQUFFLENBQVgsRUFBYyxJQUFFLEtBQUssT0FBTCxDQUFhLE1BQTdCLEVBQXFDLEdBQXJDLEVBQTBDO0FBQ3hDLGNBQUksVUFBVSxLQUFLLGlCQUFMLENBQXVCLEtBQUssT0FBTCxDQUFhLENBQWIsRUFBZ0IsS0FBdkMsQ0FBZDtBQUNBLGVBQUssWUFBTCxDQUFrQixPQUFsQixDQUEwQixLQUFLLE9BQUwsQ0FBYSxDQUFiLEVBQWdCLEdBQTFDLEVBQStDLE9BQS9DO0FBQ0Q7QUFDRjtBQUNGOzs7c0NBRWlCLFMsRUFBVztBQUMzQixVQUFJLFFBQVEsVUFBVSxDQUFWLElBQWUsRUFBM0I7QUFDQSxVQUFJLFdBQVcsQ0FBZjtBQUNBLFVBQUksT0FBSixFQUFhLE9BQWIsRUFBc0IsT0FBdEIsRUFBK0IsT0FBL0IsRUFBd0MsTUFBeEM7QUFDQSxVQUFJLGdCQUFnQixFQUFwQjs7QUFFQSxXQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksS0FBcEIsRUFBMkIsR0FBM0IsRUFBZ0M7QUFDOUIsa0JBQVUsVUFBVSxVQUFWLENBQVY7QUFDQSxrQkFBVSxPQUFPLFVBQVUsVUFBVixDQUFqQjtBQUNBLGtCQUFVLE9BQU8sVUFBVSxVQUFWLENBQWpCO0FBQ0Esa0JBQVUsQ0FBQyxJQUFJLE9BQUwsTUFBa0IsQ0FBNUI7QUFDQSxpQkFBUyxJQUFJLE9BQWI7O0FBRUEsWUFBSSxZQUFZLENBQVosSUFBaUIsWUFBWSxDQUFqQyxFQUFvQztBQUNsQztBQUNEOztBQUVELFlBQUksT0FBSixFQUFhO0FBQ1gsY0FBSSxXQUFXLENBQWYsRUFBa0I7QUFDbEI7QUFDRSw0QkFBYyxJQUFkLENBQW1CLE9BQW5CO0FBQ0EsNEJBQWMsSUFBZCxDQUFtQixPQUFuQjtBQUNEO0FBQ0Y7QUFDRjtBQUNELGFBQU8sYUFBUDtBQUNEOzs7Ozs7a0JBR1ksa0I7Ozs7Ozs7Ozs7Ozs7SUN6VE0sUztBQUNuQixxQkFBWSxNQUFaLEVBQW1CLEVBQW5CLEVBQXVCO0FBQUE7O0FBQ3JCLFNBQUssTUFBTCxHQUFjLE1BQWQ7QUFDQSxTQUFLLEtBQUwsR0FBYSxFQUFiO0FBQ0Q7Ozs7NEJBRU8sSSxFQUFNLEcsRUFBSztBQUNqQixhQUFPLEtBQUssTUFBTCxDQUFZLE9BQVosQ0FBb0IsRUFBQyxNQUFNLFNBQVAsRUFBa0IsSUFBSSxLQUFLLEtBQTNCLEVBQXBCLEVBQXVELEdBQXZELEVBQTRELElBQTVELENBQVA7QUFDRDs7Ozs7O2tCQVJrQixTOzs7Ozs7Ozs7Ozs7O0lDQWYsWTtBQUNKLDBCQUFjO0FBQUE7O0FBQ1o7QUFDQSxTQUFLLElBQUwsR0FBWSxDQUFDLEdBQUQsRUFBTSxHQUFOLEVBQVcsR0FBWCxFQUFnQixHQUFoQixFQUFxQixHQUFyQixFQUEwQixJQUExQixFQUFnQyxJQUFoQyxFQUFzQyxJQUF0QyxFQUE0QyxJQUE1QyxFQUFrRCxJQUFsRCxFQUF3RCxJQUF4RCxDQUFaOztBQUVBLFNBQUssTUFBTCxHQUFjLEVBQWQ7QUFDQSxTQUFLLE1BQUwsQ0FBWSxDQUFaLElBQWlCLElBQUksV0FBSixDQUFnQixHQUFoQixDQUFqQjtBQUNBLFNBQUssTUFBTCxDQUFZLENBQVosSUFBaUIsSUFBSSxXQUFKLENBQWdCLEdBQWhCLENBQWpCO0FBQ0EsU0FBSyxNQUFMLENBQVksQ0FBWixJQUFpQixJQUFJLFdBQUosQ0FBZ0IsR0FBaEIsQ0FBakI7QUFDQSxTQUFLLE1BQUwsQ0FBWSxDQUFaLElBQWlCLElBQUksV0FBSixDQUFnQixHQUFoQixDQUFqQjs7QUFFQSxTQUFLLFNBQUwsR0FBaUIsRUFBakI7QUFDQSxTQUFLLFNBQUwsQ0FBZSxDQUFmLElBQW9CLElBQUksV0FBSixDQUFnQixHQUFoQixDQUFwQjtBQUNBLFNBQUssU0FBTCxDQUFlLENBQWYsSUFBb0IsSUFBSSxXQUFKLENBQWdCLEdBQWhCLENBQXBCO0FBQ0EsU0FBSyxTQUFMLENBQWUsQ0FBZixJQUFvQixJQUFJLFdBQUosQ0FBZ0IsR0FBaEIsQ0FBcEI7QUFDQSxTQUFLLFNBQUwsQ0FBZSxDQUFmLElBQW9CLElBQUksV0FBSixDQUFnQixHQUFoQixDQUFwQjs7QUFFQSxTQUFLLElBQUwsR0FBWSxJQUFJLFdBQUosQ0FBZ0IsR0FBaEIsQ0FBWjtBQUNBLFNBQUssT0FBTCxHQUFlLElBQUksV0FBSixDQUFnQixHQUFoQixDQUFmOztBQUVBO0FBQ0EsU0FBSyxHQUFMLEdBQVcsSUFBSSxXQUFKLENBQWdCLENBQWhCLENBQVg7O0FBRUEsU0FBSyxTQUFMO0FBQ0Q7O0FBRUQ7Ozs7OzZDQUN5QixXLEVBQWE7QUFDcEMsVUFBSSxPQUFPLElBQUksUUFBSixDQUFhLFdBQWIsQ0FBWDtBQUNBLFVBQUksV0FBVyxJQUFJLFdBQUosQ0FBZ0IsQ0FBaEIsQ0FBZjtBQUNBLFdBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxTQUFTLE1BQTdCLEVBQXFDLEdBQXJDLEVBQTBDO0FBQ3hDLGlCQUFTLENBQVQsSUFBYyxLQUFLLFNBQUwsQ0FBZSxJQUFJLENBQW5CLENBQWQ7QUFDRDtBQUNELGFBQU8sUUFBUDtBQUNEOzs7Z0NBRVc7QUFDVixVQUFJLE9BQU8sS0FBSyxJQUFoQjtBQUNBLFVBQUksVUFBVSxLQUFLLE9BQW5CO0FBQ0EsVUFBSSxVQUFVLEtBQUssTUFBTCxDQUFZLENBQVosQ0FBZDtBQUNBLFVBQUksVUFBVSxLQUFLLE1BQUwsQ0FBWSxDQUFaLENBQWQ7QUFDQSxVQUFJLFVBQVUsS0FBSyxNQUFMLENBQVksQ0FBWixDQUFkO0FBQ0EsVUFBSSxVQUFVLEtBQUssTUFBTCxDQUFZLENBQVosQ0FBZDtBQUNBLFVBQUksYUFBYSxLQUFLLFNBQUwsQ0FBZSxDQUFmLENBQWpCO0FBQ0EsVUFBSSxhQUFhLEtBQUssU0FBTCxDQUFlLENBQWYsQ0FBakI7QUFDQSxVQUFJLGFBQWEsS0FBSyxTQUFMLENBQWUsQ0FBZixDQUFqQjtBQUNBLFVBQUksYUFBYSxLQUFLLFNBQUwsQ0FBZSxDQUFmLENBQWpCOztBQUVBLFVBQUksSUFBSSxJQUFJLFdBQUosQ0FBZ0IsR0FBaEIsQ0FBUjtBQUNBLFVBQUksSUFBSSxDQUFSO0FBQ0EsVUFBSSxLQUFLLENBQVQ7QUFDQSxVQUFJLElBQUksQ0FBUjtBQUNBLFdBQUssSUFBSSxDQUFULEVBQVksSUFBSSxHQUFoQixFQUFxQixHQUFyQixFQUEwQjtBQUN4QixZQUFJLElBQUksR0FBUixFQUFhO0FBQ1gsWUFBRSxDQUFGLElBQU8sS0FBSyxDQUFaO0FBQ0QsU0FGRCxNQUVPO0FBQ0wsWUFBRSxDQUFGLElBQVEsS0FBSyxDQUFOLEdBQVcsS0FBbEI7QUFDRDtBQUNGOztBQUVELFdBQUssSUFBSSxDQUFULEVBQVksSUFBSSxHQUFoQixFQUFxQixHQUFyQixFQUEwQjtBQUN4QixZQUFJLEtBQUssS0FBTSxNQUFNLENBQVosR0FBa0IsTUFBTSxDQUF4QixHQUE4QixNQUFNLENBQXBDLEdBQTBDLE1BQU0sQ0FBekQ7QUFDQSxhQUFNLE9BQU8sQ0FBUixHQUFjLEtBQUssSUFBbkIsR0FBMkIsSUFBaEM7QUFDQSxhQUFLLENBQUwsSUFBVSxFQUFWO0FBQ0EsZ0JBQVEsRUFBUixJQUFjLENBQWQ7O0FBRUE7QUFDQSxZQUFJLEtBQUssRUFBRSxDQUFGLENBQVQ7QUFDQSxZQUFJLEtBQUssRUFBRSxFQUFGLENBQVQ7QUFDQSxZQUFJLEtBQUssRUFBRSxFQUFGLENBQVQ7O0FBRUE7QUFDQSxZQUFJLElBQUssRUFBRSxFQUFGLElBQVEsS0FBVCxHQUFtQixLQUFLLFNBQWhDO0FBQ0EsZ0JBQVEsQ0FBUixJQUFjLEtBQUssRUFBTixHQUFhLE1BQU0sQ0FBaEM7QUFDQSxnQkFBUSxDQUFSLElBQWMsS0FBSyxFQUFOLEdBQWEsTUFBTSxFQUFoQztBQUNBLGdCQUFRLENBQVIsSUFBYyxLQUFLLENBQU4sR0FBWSxNQUFNLEVBQS9CO0FBQ0EsZ0JBQVEsQ0FBUixJQUFhLENBQWI7O0FBRUE7QUFDQSxZQUFLLEtBQUssU0FBTixHQUFvQixLQUFLLE9BQXpCLEdBQXFDLEtBQUssS0FBMUMsR0FBb0QsSUFBSSxTQUE1RDtBQUNBLG1CQUFXLEVBQVgsSUFBa0IsS0FBSyxFQUFOLEdBQWEsTUFBTSxDQUFwQztBQUNBLG1CQUFXLEVBQVgsSUFBa0IsS0FBSyxFQUFOLEdBQWEsTUFBTSxFQUFwQztBQUNBLG1CQUFXLEVBQVgsSUFBa0IsS0FBSyxDQUFOLEdBQVksTUFBTSxFQUFuQztBQUNBLG1CQUFXLEVBQVgsSUFBaUIsQ0FBakI7O0FBRUE7QUFDQSxZQUFJLENBQUMsQ0FBTCxFQUFRO0FBQ04sY0FBSSxLQUFLLENBQVQ7QUFDRCxTQUZELE1BRU87QUFDTCxjQUFJLEtBQUssRUFBRSxFQUFFLEVBQUUsS0FBSyxFQUFQLENBQUYsQ0FBRixDQUFUO0FBQ0EsZ0JBQU0sRUFBRSxFQUFFLEVBQUYsQ0FBRixDQUFOO0FBQ0Q7QUFDRjtBQUNGOzs7OEJBRVMsUyxFQUFXO0FBQ25CO0FBQ0EsVUFBSSxNQUFNLEtBQUssd0JBQUwsQ0FBOEIsU0FBOUIsQ0FBVjtBQUNBLFVBQUksVUFBVSxJQUFkO0FBQ0EsVUFBSSxTQUFTLENBQWI7O0FBRUEsYUFBTyxTQUFTLElBQUksTUFBYixJQUF1QixPQUE5QixFQUF1QztBQUNyQyxrQkFBVyxJQUFJLE1BQUosTUFBZ0IsS0FBSyxHQUFMLENBQVMsTUFBVCxDQUEzQjtBQUNBO0FBQ0Q7O0FBRUQsVUFBSSxPQUFKLEVBQWE7QUFDWDtBQUNEOztBQUVELFdBQUssR0FBTCxHQUFXLEdBQVg7QUFDQSxVQUFJLFVBQVUsS0FBSyxPQUFMLEdBQWUsSUFBSSxNQUFqQzs7QUFFQSxVQUFJLFlBQVksQ0FBWixJQUFpQixZQUFZLENBQTdCLElBQWtDLFlBQVksQ0FBbEQsRUFBcUQ7QUFDbkQsY0FBTSxJQUFJLEtBQUosQ0FBVSwwQkFBMEIsT0FBcEMsQ0FBTjtBQUNEOztBQUVELFVBQUksU0FBUyxLQUFLLE1BQUwsR0FBYyxDQUFDLFVBQVUsQ0FBVixHQUFjLENBQWYsSUFBb0IsQ0FBL0M7QUFDQSxVQUFJLGNBQUo7QUFDQSxVQUFJLGlCQUFKOztBQUVBLFVBQUksY0FBYyxLQUFLLFdBQUwsR0FBbUIsSUFBSSxXQUFKLENBQWdCLEtBQUssTUFBckIsQ0FBckM7QUFDQSxVQUFJLGlCQUFpQixLQUFLLGNBQUwsR0FBc0IsSUFBSSxXQUFKLENBQWdCLEtBQUssTUFBckIsQ0FBM0M7QUFDQSxVQUFJLE9BQU8sS0FBSyxJQUFoQjtBQUNBLFVBQUksT0FBTyxLQUFLLElBQWhCOztBQUVBLFVBQUksYUFBYSxLQUFLLFNBQUwsQ0FBZSxDQUFmLENBQWpCO0FBQ0EsVUFBSSxhQUFhLEtBQUssU0FBTCxDQUFlLENBQWYsQ0FBakI7QUFDQSxVQUFJLGFBQWEsS0FBSyxTQUFMLENBQWUsQ0FBZixDQUFqQjtBQUNBLFVBQUksYUFBYSxLQUFLLFNBQUwsQ0FBZSxDQUFmLENBQWpCOztBQUVBLFVBQUksYUFBSjtBQUNBLFVBQUksVUFBSjs7QUFFQSxXQUFLLFFBQVEsQ0FBYixFQUFnQixRQUFRLE1BQXhCLEVBQWdDLE9BQWhDLEVBQXlDO0FBQ3ZDLFlBQUksUUFBUSxPQUFaLEVBQXFCO0FBQ25CLGlCQUFPLFlBQVksS0FBWixJQUFxQixJQUFJLEtBQUosQ0FBNUI7QUFDQTtBQUNEO0FBQ0QsWUFBSSxJQUFKOztBQUVBLFlBQUksUUFBUSxPQUFSLEtBQW9CLENBQXhCLEVBQTJCO0FBQ3pCO0FBQ0EsY0FBSyxLQUFLLENBQU4sR0FBWSxNQUFNLEVBQXRCOztBQUVBO0FBQ0EsY0FBSyxLQUFLLE1BQU0sRUFBWCxLQUFrQixFQUFuQixHQUEwQixLQUFNLE1BQU0sRUFBUCxHQUFhLElBQWxCLEtBQTJCLEVBQXJELEdBQTRELEtBQU0sTUFBTSxDQUFQLEdBQVksSUFBakIsS0FBMEIsQ0FBdEYsR0FBMkYsS0FBSyxJQUFJLElBQVQsQ0FBL0Y7O0FBRUE7QUFDQSxlQUFLLEtBQU0sUUFBUSxPQUFULEdBQW9CLENBQXpCLEtBQStCLEVBQXBDO0FBQ0QsU0FURCxNQVNPLElBQUksVUFBVSxDQUFWLElBQWUsUUFBUSxPQUFSLEtBQW9CLENBQXZDLEVBQTJDO0FBQ2hEO0FBQ0EsY0FBSyxLQUFLLE1BQU0sRUFBWCxLQUFrQixFQUFuQixHQUEwQixLQUFNLE1BQU0sRUFBUCxHQUFhLElBQWxCLEtBQTJCLEVBQXJELEdBQTRELEtBQU0sTUFBTSxDQUFQLEdBQVksSUFBakIsS0FBMEIsQ0FBdEYsR0FBMkYsS0FBSyxJQUFJLElBQVQsQ0FBL0Y7QUFDRDs7QUFFRCxvQkFBWSxLQUFaLElBQXFCLE9BQU8sQ0FBQyxZQUFZLFFBQVEsT0FBcEIsSUFBK0IsQ0FBaEMsTUFBdUMsQ0FBbkU7QUFDRDs7QUFFRCxXQUFLLFdBQVcsQ0FBaEIsRUFBbUIsV0FBVyxNQUE5QixFQUFzQyxVQUF0QyxFQUFrRDtBQUNoRCxnQkFBUSxTQUFTLFFBQWpCO0FBQ0EsWUFBSSxXQUFXLENBQWYsRUFBa0I7QUFDaEIsY0FBSSxZQUFZLEtBQVosQ0FBSjtBQUNELFNBRkQsTUFFTztBQUNMLGNBQUksWUFBWSxRQUFRLENBQXBCLENBQUo7QUFDRDs7QUFFRCxZQUFJLFdBQVcsQ0FBWCxJQUFnQixTQUFTLENBQTdCLEVBQWdDO0FBQzlCLHlCQUFlLFFBQWYsSUFBMkIsQ0FBM0I7QUFDRCxTQUZELE1BRU87QUFDTCx5QkFBZSxRQUFmLElBQTJCLFdBQVcsS0FBSyxNQUFNLEVBQVgsQ0FBWCxJQUE2QixXQUFXLEtBQU0sTUFBTSxFQUFQLEdBQWEsSUFBbEIsQ0FBWCxDQUE3QixHQUFtRSxXQUFXLEtBQU0sTUFBTSxDQUFQLEdBQVksSUFBakIsQ0FBWCxDQUFuRSxHQUF3RyxXQUFXLEtBQUssSUFBSSxJQUFULENBQVgsQ0FBbkk7QUFDRDs7QUFFRCx1QkFBZSxRQUFmLElBQTJCLGVBQWUsUUFBZixNQUE2QixDQUF4RDtBQUNEO0FBQ0Y7O0FBRUQ7Ozs7MkNBQ3VCLEksRUFBTTtBQUMzQixhQUFRLFFBQVEsRUFBVCxHQUFnQixDQUFDLE9BQU8sTUFBUixLQUFtQixDQUFuQyxHQUF5QyxDQUFDLE9BQU8sUUFBUixLQUFxQixDQUE5RCxHQUFvRSxTQUFTLEVBQXBGO0FBQ0Q7Ozs0QkFFTyxnQixFQUFrQixNLEVBQVEsSyxFQUFPO0FBQ3ZDLFVBQUksVUFBVSxLQUFLLE9BQUwsR0FBZSxDQUE3QjtBQUNBLFVBQUksaUJBQWlCLEtBQUssY0FBMUI7QUFDQSxVQUFJLFVBQVUsS0FBSyxPQUFuQjs7QUFFQSxVQUFJLGFBQWEsS0FBSyxTQUFMLENBQWUsQ0FBZixDQUFqQjtBQUNBLFVBQUksYUFBYSxLQUFLLFNBQUwsQ0FBZSxDQUFmLENBQWpCO0FBQ0EsVUFBSSxhQUFhLEtBQUssU0FBTCxDQUFlLENBQWYsQ0FBakI7QUFDQSxVQUFJLGFBQWEsS0FBSyxTQUFMLENBQWUsQ0FBZixDQUFqQjs7QUFFQSxVQUFJLGFBQWEsS0FBSyx3QkFBTCxDQUE4QixLQUE5QixDQUFqQjtBQUNBLFVBQUksY0FBYyxXQUFXLENBQVgsQ0FBbEI7QUFDQSxVQUFJLGNBQWMsV0FBVyxDQUFYLENBQWxCO0FBQ0EsVUFBSSxjQUFjLFdBQVcsQ0FBWCxDQUFsQjtBQUNBLFVBQUksY0FBYyxXQUFXLENBQVgsQ0FBbEI7O0FBRUEsVUFBSSxhQUFhLElBQUksVUFBSixDQUFlLGdCQUFmLENBQWpCO0FBQ0EsVUFBSSxjQUFjLElBQUksVUFBSixDQUFlLFdBQVcsTUFBMUIsQ0FBbEI7O0FBRUEsVUFBSSxXQUFKO0FBQUEsVUFBUSxXQUFSO0FBQUEsVUFBWSxXQUFaO0FBQUEsVUFBZ0IsV0FBaEI7QUFDQSxVQUFJLFdBQUo7QUFBQSxVQUFRLFdBQVI7QUFBQSxVQUFZLFdBQVo7QUFBQSxVQUFnQixXQUFoQjtBQUNBLFVBQUksb0JBQUo7QUFBQSxVQUFpQixvQkFBakI7QUFBQSxVQUE4QixvQkFBOUI7QUFBQSxVQUEyQyxvQkFBM0M7O0FBRUEsVUFBSSxLQUFKLEVBQVcsQ0FBWDs7QUFFQSxhQUFPLFNBQVMsV0FBVyxNQUEzQixFQUFtQztBQUNqQyxzQkFBYyxLQUFLLHNCQUFMLENBQTRCLFdBQVcsTUFBWCxDQUE1QixDQUFkO0FBQ0Esc0JBQWMsS0FBSyxzQkFBTCxDQUE0QixXQUFXLFNBQVMsQ0FBcEIsQ0FBNUIsQ0FBZDtBQUNBLHNCQUFjLEtBQUssc0JBQUwsQ0FBNEIsV0FBVyxTQUFTLENBQXBCLENBQTVCLENBQWQ7QUFDQSxzQkFBYyxLQUFLLHNCQUFMLENBQTRCLFdBQVcsU0FBUyxDQUFwQixDQUE1QixDQUFkOztBQUVBLGFBQUssY0FBYyxlQUFlLENBQWYsQ0FBbkI7QUFDQSxhQUFLLGNBQWMsZUFBZSxDQUFmLENBQW5CO0FBQ0EsYUFBSyxjQUFjLGVBQWUsQ0FBZixDQUFuQjtBQUNBLGFBQUssY0FBYyxlQUFlLENBQWYsQ0FBbkI7O0FBRUEsZ0JBQVEsQ0FBUjs7QUFFQTtBQUNBLGFBQUssSUFBSSxDQUFULEVBQVksSUFBSSxPQUFoQixFQUF5QixHQUF6QixFQUE4QjtBQUM1QixlQUFLLFdBQVcsT0FBTyxFQUFsQixJQUF3QixXQUFZLE1BQU0sRUFBUCxHQUFhLElBQXhCLENBQXhCLEdBQXdELFdBQVksTUFBTSxDQUFQLEdBQVksSUFBdkIsQ0FBeEQsR0FBdUYsV0FBVyxLQUFLLElBQWhCLENBQXZGLEdBQStHLGVBQWUsS0FBZixDQUFwSDtBQUNBLGVBQUssV0FBVyxPQUFPLEVBQWxCLElBQXdCLFdBQVksTUFBTSxFQUFQLEdBQWEsSUFBeEIsQ0FBeEIsR0FBd0QsV0FBWSxNQUFNLENBQVAsR0FBWSxJQUF2QixDQUF4RCxHQUF1RixXQUFXLEtBQUssSUFBaEIsQ0FBdkYsR0FBK0csZUFBZSxRQUFRLENBQXZCLENBQXBIO0FBQ0EsZUFBSyxXQUFXLE9BQU8sRUFBbEIsSUFBd0IsV0FBWSxNQUFNLEVBQVAsR0FBYSxJQUF4QixDQUF4QixHQUF3RCxXQUFZLE1BQU0sQ0FBUCxHQUFZLElBQXZCLENBQXhELEdBQXVGLFdBQVcsS0FBSyxJQUFoQixDQUF2RixHQUErRyxlQUFlLFFBQVEsQ0FBdkIsQ0FBcEg7QUFDQSxlQUFLLFdBQVcsT0FBTyxFQUFsQixJQUF3QixXQUFZLE1BQU0sRUFBUCxHQUFhLElBQXhCLENBQXhCLEdBQXdELFdBQVksTUFBTSxDQUFQLEdBQVksSUFBdkIsQ0FBeEQsR0FBdUYsV0FBVyxLQUFLLElBQWhCLENBQXZGLEdBQStHLGVBQWUsUUFBUSxDQUF2QixDQUFwSDtBQUNBO0FBQ0EsZUFBSyxFQUFMO0FBQ0EsZUFBSyxFQUFMO0FBQ0EsZUFBSyxFQUFMO0FBQ0EsZUFBSyxFQUFMOztBQUVBLGtCQUFRLFFBQVEsQ0FBaEI7QUFDRDs7QUFFRDtBQUNBLGFBQU8sUUFBUSxPQUFPLEVBQWYsS0FBc0IsRUFBdkIsR0FBOEIsUUFBUyxNQUFNLEVBQVAsR0FBYSxJQUFyQixLQUE4QixFQUE1RCxHQUFtRSxRQUFTLE1BQU0sQ0FBUCxHQUFZLElBQXBCLEtBQTZCLENBQWhHLEdBQXFHLFFBQVEsS0FBSyxJQUFiLENBQXRHLEdBQTRILGVBQWUsS0FBZixDQUFqSTtBQUNBLGFBQU8sUUFBUSxPQUFPLEVBQWYsS0FBc0IsRUFBdkIsR0FBOEIsUUFBUyxNQUFNLEVBQVAsR0FBYSxJQUFyQixLQUE4QixFQUE1RCxHQUFtRSxRQUFTLE1BQU0sQ0FBUCxHQUFZLElBQXBCLEtBQTZCLENBQWhHLEdBQXFHLFFBQVEsS0FBSyxJQUFiLENBQXRHLEdBQTRILGVBQWUsUUFBUSxDQUF2QixDQUFqSTtBQUNBLGFBQU8sUUFBUSxPQUFPLEVBQWYsS0FBc0IsRUFBdkIsR0FBOEIsUUFBUyxNQUFNLEVBQVAsR0FBYSxJQUFyQixLQUE4QixFQUE1RCxHQUFtRSxRQUFTLE1BQU0sQ0FBUCxHQUFZLElBQXBCLEtBQTZCLENBQWhHLEdBQXFHLFFBQVEsS0FBSyxJQUFiLENBQXRHLEdBQTRILGVBQWUsUUFBUSxDQUF2QixDQUFqSTtBQUNBLGFBQU8sUUFBUSxPQUFPLEVBQWYsS0FBc0IsRUFBdkIsR0FBOEIsUUFBUyxNQUFNLEVBQVAsR0FBYSxJQUFyQixLQUE4QixFQUE1RCxHQUFtRSxRQUFTLE1BQU0sQ0FBUCxHQUFZLElBQXBCLEtBQTZCLENBQWhHLEdBQXFHLFFBQVEsS0FBSyxJQUFiLENBQXRHLEdBQTRILGVBQWUsUUFBUSxDQUF2QixDQUFqSTtBQUNBLGdCQUFRLFFBQVEsQ0FBaEI7O0FBRUE7QUFDQSxvQkFBWSxNQUFaLElBQXNCLEtBQUssc0JBQUwsQ0FBNEIsS0FBSyxXQUFqQyxDQUF0QjtBQUNBLG9CQUFZLFNBQVMsQ0FBckIsSUFBMEIsS0FBSyxzQkFBTCxDQUE0QixLQUFLLFdBQWpDLENBQTFCO0FBQ0Esb0JBQVksU0FBUyxDQUFyQixJQUEwQixLQUFLLHNCQUFMLENBQTRCLEtBQUssV0FBakMsQ0FBMUI7QUFDQSxvQkFBWSxTQUFTLENBQXJCLElBQTBCLEtBQUssc0JBQUwsQ0FBNEIsS0FBSyxXQUFqQyxDQUExQjs7QUFFQTtBQUNBLHNCQUFjLFdBQWQ7QUFDQSxzQkFBYyxXQUFkO0FBQ0Esc0JBQWMsV0FBZDtBQUNBLHNCQUFjLFdBQWQ7O0FBRUEsaUJBQVMsU0FBUyxDQUFsQjtBQUNEOztBQUVELGFBQU8sWUFBWSxNQUFuQjtBQUNEOzs7OEJBRVM7QUFDUixXQUFLLEdBQUwsR0FBVyxTQUFYO0FBQ0EsV0FBSyxPQUFMLEdBQWUsU0FBZjtBQUNBLFdBQUssTUFBTCxHQUFjLFNBQWQ7O0FBRUEsV0FBSyxJQUFMLEdBQVksU0FBWjtBQUNBLFdBQUssT0FBTCxHQUFlLFNBQWY7QUFDQSxXQUFLLE1BQUwsR0FBYyxTQUFkO0FBQ0EsV0FBSyxTQUFMLEdBQWlCLFNBQWpCO0FBQ0EsV0FBSyxXQUFMLEdBQW1CLFNBQW5CO0FBQ0EsV0FBSyxjQUFMLEdBQXNCLFNBQXRCOztBQUVBLFdBQUssSUFBTCxHQUFZLFNBQVo7QUFDRDs7Ozs7O2tCQUdZLFk7Ozs7Ozs7Ozs7O0FDblJmOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUVBOztBQUNBOzs7Ozs7SUFFTSxTO0FBQ0oscUJBQVksR0FBWixFQUFpQjtBQUFBOztBQUNmLFNBQUssR0FBTCxHQUFXLEdBQVg7QUFDQSxRQUFJO0FBQ0YsVUFBTSxnQkFBZ0IsU0FBUyxPQUFPLE1BQWhCLEdBQXlCLE1BQS9DO0FBQ0EsV0FBSyxNQUFMLEdBQWMsY0FBYyxNQUFkLElBQXdCLGNBQWMsWUFBcEQ7QUFDRCxLQUhELENBR0UsT0FBTyxDQUFQLEVBQVUsQ0FBRTs7QUFFZCxTQUFLLGdCQUFMLEdBQXdCLENBQUMsS0FBSyxpQkFBTCxFQUF6QjtBQUNEOzs7O3dDQUVtQjtBQUNsQixhQUFPLEtBQUssTUFBTCxJQUFlLE9BQU8sUUFBUCxDQUFnQixRQUFoQixLQUE2QixRQUFuRDtBQUNEOzs7NEJBRU8sSSxFQUFNLEcsRUFBSyxFLEVBQUksUSxFQUFVO0FBQUE7O0FBQy9CLFVBQUksS0FBSyxnQkFBTCxJQUF5QixLQUFLLEdBQUwsQ0FBUyxNQUFULENBQWdCLGlCQUE3QyxFQUFnRTtBQUM5RCx1QkFBTyxHQUFQLENBQVcseUNBQVg7QUFDQSxZQUFJLENBQUMsS0FBSyxTQUFWLEVBQXFCO0FBQ25CLGVBQUssU0FBTCxHQUFpQiw0QkFBakI7QUFDRDtBQUNELGFBQUssU0FBTCxDQUFlLFNBQWYsQ0FBeUIsR0FBekI7QUFDQSxpQkFBUyxLQUFLLFNBQUwsQ0FBZSxPQUFmLENBQXVCLElBQXZCLEVBQTZCLENBQTdCLEVBQWdDLEVBQWhDLENBQVQ7QUFDRCxPQVBELE1BUUs7QUFBQTtBQUNILHlCQUFPLEdBQVAsQ0FBVyw2QkFBWDtBQUNBLGNBQU0sU0FBUyxNQUFLLE1BQXBCO0FBQ0EsY0FBSSxNQUFLLEdBQUwsS0FBYSxHQUFqQixFQUFzQjtBQUNwQixrQkFBSyxHQUFMLEdBQVcsR0FBWDtBQUNBLGtCQUFLLFVBQUwsR0FBa0IseUJBQWUsTUFBZixFQUFzQixHQUF0QixDQUFsQjtBQUNEOztBQUVELGdCQUFLLFVBQUwsQ0FBZ0IsU0FBaEIsR0FDRSxJQURGLENBQ08sVUFBQyxNQUFELEVBQVk7QUFDZjtBQUNBLGdCQUFJLFNBQVMsd0JBQWMsTUFBZCxFQUFxQixFQUFyQixDQUFiO0FBQ0EsbUJBQU8sT0FBUCxDQUFlLElBQWYsRUFBcUIsTUFBckIsRUFDRSxJQURGLENBQ08sVUFBQyxNQUFELEVBQVk7QUFDZix1QkFBUyxNQUFUO0FBQ0QsYUFISDtBQUlELFdBUkgsRUFTRSxLQVRGLENBU1MsVUFBQyxHQUFELEVBQVM7QUFDZCxrQkFBSyxnQkFBTCxDQUFzQixHQUF0QixFQUEyQixJQUEzQixFQUFpQyxHQUFqQyxFQUFzQyxFQUF0QyxFQUEwQyxRQUExQztBQUNELFdBWEg7QUFSRztBQW9CSjtBQUNGOzs7cUNBRWdCLEcsRUFBSyxJLEVBQU0sRyxFQUFLLEUsRUFBSSxRLEVBQVU7QUFDN0MsVUFBSSxNQUFNLEtBQUssR0FBZjtBQUNBLFVBQUksSUFBSSxNQUFKLENBQVcsaUJBQWYsRUFBa0M7QUFDaEMsdUJBQU8sR0FBUCxDQUFXLGdDQUFYO0FBQ0EsYUFBSyxnQkFBTCxHQUF3QixJQUF4QjtBQUNBLGFBQUssT0FBTCxDQUFhLElBQWIsRUFBbUIsR0FBbkIsRUFBd0IsRUFBeEIsRUFBNEIsUUFBNUI7QUFDRCxPQUpELE1BS0s7QUFDSCx1QkFBTyxLQUFQLHlCQUFtQyxJQUFJLE9BQXZDO0FBQ0EsWUFBSSxPQUFKLENBQVksTUFBTSxLQUFsQixFQUF5QixFQUFDLE1BQU8sbUJBQVcsV0FBbkIsRUFBZ0MsU0FBVSxxQkFBYSxrQkFBdkQsRUFBMkUsT0FBUSxJQUFuRixFQUF5RixRQUFTLElBQUksT0FBdEcsRUFBekI7QUFDRDtBQUNGOzs7OEJBRVM7QUFDUixVQUFJLFlBQVksS0FBSyxTQUFyQjtBQUNBLFVBQUksU0FBSixFQUFlO0FBQ2Isa0JBQVUsT0FBVjtBQUNBLGFBQUssU0FBTCxHQUFpQixTQUFqQjtBQUNEO0FBQ0Y7Ozs7OztrQkFHWSxTOzs7Ozs7Ozs7Ozs7O0lDNUVULFU7QUFDSixzQkFBWSxNQUFaLEVBQW1CLEdBQW5CLEVBQXdCO0FBQUE7O0FBQ3RCLFNBQUssTUFBTCxHQUFjLE1BQWQ7QUFDQSxTQUFLLEdBQUwsR0FBVyxHQUFYO0FBQ0Q7Ozs7Z0NBRVc7QUFDVixhQUFPLEtBQUssTUFBTCxDQUFZLFNBQVosQ0FBc0IsS0FBdEIsRUFBNkIsS0FBSyxHQUFsQyxFQUF1QyxFQUFDLE1BQU0sU0FBUCxFQUF2QyxFQUEwRCxLQUExRCxFQUFpRSxDQUFDLFNBQUQsRUFBWSxTQUFaLENBQWpFLENBQVA7QUFDRDs7Ozs7O2tCQUdZLFU7Ozs7Ozs7OztxakJDWGY7Ozs7O0FBR0E7Ozs7QUFDQTs7QUFDQTs7Ozs7Ozs7SUFFTyxVO0FBRUwsc0JBQVksUUFBWixFQUFzQixFQUF0QixFQUEwQixZQUExQixFQUF3QyxNQUF4QyxFQUFnRCxhQUFoRCxFQUErRDtBQUFBOztBQUM3RCxTQUFLLFFBQUwsR0FBZ0IsUUFBaEI7QUFDQSxTQUFLLEVBQUwsR0FBVSxFQUFWO0FBQ0EsU0FBSyxZQUFMLEdBQW9CLFlBQXBCO0FBQ0EsU0FBSyxNQUFMLEdBQWMsTUFBZDtBQUNBLFNBQUssT0FBTCxHQUFlLElBQUksS0FBSyxZQUFULENBQXNCLFFBQXRCLEVBQStCLEVBQS9CLEVBQW1DLE1BQW5DLEVBQTJDLGFBQTNDLENBQWY7QUFDQTtBQUNBO0FBQ0EsU0FBSyxZQUFMLEdBQW9CLE9BQU8sT0FBM0I7QUFDQSxTQUFLLG1CQUFMO0FBQ0Q7Ozs7MENBRXFCO0FBQ3BCLFdBQUssU0FBTCxHQUFpQixFQUFDLFdBQVksWUFBYixFQUEyQixNQUFNLE9BQWpDLEVBQTBDLElBQUksQ0FBQyxDQUEvQyxFQUFrRCxnQkFBZ0IsQ0FBbEUsRUFBcUUsT0FBUSxJQUE3RSxFQUFvRixTQUFVLEVBQTlGLEVBQWtHLEtBQU0sQ0FBeEcsRUFBakI7QUFDRDs7QUFFRDs7Ozs7O0FBYUE7eUJBQ0ssSSxFQUFNLFUsRUFBWSxVLEVBQVksVSxFQUFZLEUsRUFBSSxLLEVBQU8sRSxFQUFJLFEsRUFBUyxrQixFQUFvQixjLEVBQWdCO0FBQ3pHLFVBQUksS0FBSjtBQUFBLFVBQ0ksTUFBTSxpQkFBUSxJQUFSLENBRFY7QUFBQSxVQUVJLEdBRko7QUFBQSxVQUVTLE1BRlQ7QUFBQSxVQUVpQixXQUZqQjtBQUFBLFVBRThCLGFBRjlCO0FBQUEsVUFFNkMsVUFGN0M7QUFBQSxVQUV5RCxNQUZ6RDtBQUFBLFVBRWlFLFlBRmpFO0FBQUEsVUFFK0UsS0FGL0U7QUFBQSxVQUVzRixHQUZ0RjtBQUFBLFVBRTJGLFNBRjNGOztBQUlBO0FBQ0EsWUFBTyxLQUFLLFlBQU4sR0FBc0IsS0FBSyxJQUFJLFNBQS9CLEdBQTJDLGFBQWEsS0FBOUQ7O0FBRUEsVUFBSSxhQUFhLEtBQWpCO0FBQ0EsVUFBSSxPQUFPLEtBQUssTUFBaEIsRUFBd0I7QUFDdEIsdUJBQU8sR0FBUCxDQUFjLEtBQUssRUFBbkI7QUFDQSxhQUFLLE1BQUwsR0FBYyxFQUFkO0FBQ0EsYUFBSyxtQkFBTDtBQUNBLGFBQUssT0FBTCxDQUFhLFdBQWI7QUFDQSxhQUFLLE9BQUwsQ0FBYSxtQkFBYjtBQUNELE9BTkQsTUFNTyxJQUFJLFVBQVUsS0FBSyxTQUFuQixFQUE4QjtBQUNuQyx1QkFBTyxHQUFQLENBQVcsNkJBQVg7QUFDQSxhQUFLLFNBQUwsR0FBaUIsS0FBakI7QUFDQSxhQUFLLE9BQUwsQ0FBYSxXQUFiO0FBQ0EsYUFBSyxtQkFBTDtBQUNELE9BTE0sTUFLQSxJQUFJLE9BQVEsS0FBSyxNQUFMLEdBQVksQ0FBeEIsRUFBNEI7QUFDakMscUJBQWEsSUFBYjtBQUNEO0FBQ0QsY0FBUSxLQUFLLFNBQWI7QUFDQSxXQUFLLE1BQUwsR0FBYyxFQUFkO0FBQ0EsV0FBSyxTQUFMLEdBQWlCLEtBQWpCOztBQUVBO0FBQ0EsV0FBSyxTQUFTLElBQUksTUFBSixJQUFjLENBQXZCLEVBQTBCLE1BQU0sS0FBSyxNQUExQyxFQUFrRCxTQUFTLE1BQU0sQ0FBakUsRUFBb0UsUUFBcEUsRUFBOEU7QUFDNUUsWUFBSyxLQUFLLE1BQUwsTUFBaUIsSUFBbEIsSUFBMkIsQ0FBQyxLQUFLLFNBQU8sQ0FBWixJQUFpQixJQUFsQixNQUE0QixJQUEzRCxFQUFpRTtBQUMvRDtBQUNEO0FBQ0Y7O0FBRUQsVUFBSSxDQUFDLE1BQU0sZUFBWCxFQUE0QjtBQUMxQixpQkFBUyxlQUFLLGNBQUwsQ0FBb0IsS0FBSyxRQUF6QixFQUFrQyxJQUFsQyxFQUF3QyxNQUF4QyxFQUFnRCxVQUFoRCxDQUFUO0FBQ0EsY0FBTSxNQUFOLEdBQWUsT0FBTyxNQUF0QjtBQUNBLGNBQU0sZUFBTixHQUF3QixPQUFPLFVBQS9CO0FBQ0EsY0FBTSxZQUFOLEdBQXFCLE9BQU8sWUFBNUI7QUFDQSxjQUFNLEtBQU4sR0FBYyxPQUFPLEtBQXJCO0FBQ0EsY0FBTSxRQUFOLEdBQWlCLFFBQWpCO0FBQ0EsdUJBQU8sR0FBUCxtQkFBMkIsTUFBTSxLQUFqQyxjQUErQyxPQUFPLFVBQXRELG9CQUErRSxPQUFPLFlBQXRGO0FBQ0Q7QUFDRCxtQkFBYSxDQUFiO0FBQ0Esc0JBQWdCLE9BQU8sS0FBUCxHQUFlLE1BQU0sZUFBckM7QUFDQSxhQUFRLFNBQVMsQ0FBVixHQUFlLEdBQXRCLEVBQTJCO0FBQ3pCO0FBQ0EsdUJBQWdCLENBQUMsRUFBRSxLQUFLLFNBQVMsQ0FBZCxJQUFtQixJQUFyQixDQUFELEdBQThCLENBQTlCLEdBQWtDLENBQWxEO0FBQ0E7QUFDQSxzQkFBZSxDQUFDLEtBQUssU0FBUyxDQUFkLElBQW1CLElBQXBCLEtBQTZCLEVBQTlCLEdBQ0UsS0FBSyxTQUFTLENBQWQsS0FBb0IsQ0FEdEIsR0FFQyxDQUFDLEtBQUssU0FBUyxDQUFkLElBQW1CLElBQXBCLE1BQThCLENBRjdDO0FBR0EsdUJBQWdCLFlBQWhCO0FBQ0E7O0FBRUEsWUFBSyxjQUFjLENBQWYsSUFBdUIsU0FBUyxZQUFULEdBQXdCLFdBQXpCLElBQXlDLEdBQW5FLEVBQXlFO0FBQ3ZFLGtCQUFRLE1BQU0sYUFBYSxhQUEzQjtBQUNBO0FBQ0Esc0JBQVksRUFBQyxNQUFNLEtBQUssUUFBTCxDQUFjLFNBQVMsWUFBdkIsRUFBcUMsU0FBUyxZQUFULEdBQXdCLFdBQTdELENBQVAsRUFBa0YsS0FBSyxLQUF2RixFQUE4RixLQUFLLEtBQW5HLEVBQVo7QUFDQSxnQkFBTSxPQUFOLENBQWMsSUFBZCxDQUFtQixTQUFuQjtBQUNBLGdCQUFNLEdBQU4sSUFBYSxXQUFiO0FBQ0Esb0JBQVUsY0FBYyxZQUF4QjtBQUNBO0FBQ0E7QUFDQSxpQkFBUSxTQUFVLE1BQU0sQ0FBeEIsRUFBNEIsUUFBNUIsRUFBc0M7QUFDcEMsZ0JBQUssS0FBSyxNQUFMLE1BQWlCLElBQWxCLElBQTRCLENBQUMsS0FBSyxTQUFTLENBQWQsSUFBbUIsSUFBcEIsTUFBOEIsSUFBOUQsRUFBcUU7QUFDbkU7QUFDRDtBQUNGO0FBQ0YsU0FkRCxNQWNPO0FBQ0w7QUFDRDtBQUNGO0FBQ0QsVUFBTSxXQUFZLElBQUksT0FBTCxHQUFnQixFQUFFLFNBQVUsQ0FBRSxFQUFFLEtBQUssR0FBUCxFQUFZLEtBQU0sR0FBbEIsRUFBdUIsTUFBTyxJQUFJLE9BQWxDLEVBQUYsQ0FBWixFQUFoQixHQUErRSxFQUFFLFNBQVMsRUFBWCxFQUFoRztBQUNBLFdBQUssT0FBTCxDQUFhLEtBQWIsQ0FBbUIsS0FBbkIsRUFBMEIsRUFBMUIsRUFBOEIsRUFBOUIsRUFBa0MsS0FBSyxTQUF2QyxFQUFrRCxFQUFDLFNBQVUsRUFBWCxFQUFsRCxFQUFrRSxRQUFsRSxFQUE0RSxFQUFFLFNBQVMsRUFBWCxFQUE1RSxFQUE2RixVQUE3RixFQUF5RyxVQUF6RyxFQUFvSCxrQkFBcEgsRUFBd0ksY0FBeEk7QUFDRDs7OzhCQUVTLENBQ1Q7OzswQkEzRlksSSxFQUFNO0FBQ2pCLFVBQUksTUFBTSxpQkFBUSxJQUFSLENBQVY7QUFBQSxVQUF5QixNQUF6QjtBQUFBLFVBQWlDLEdBQWpDO0FBQ0EsV0FBTSxTQUFTLElBQUksTUFBSixJQUFjLENBQXZCLEVBQTBCLE1BQU0sS0FBSyxNQUEzQyxFQUFtRCxTQUFTLE1BQU0sQ0FBbEUsRUFBcUUsUUFBckUsRUFBK0U7QUFDN0U7QUFDQSxZQUFLLEtBQUssTUFBTCxNQUFpQixJQUFsQixJQUEyQixDQUFDLEtBQUssU0FBTyxDQUFaLElBQWlCLElBQWxCLE1BQTRCLElBQTNELEVBQWlFO0FBQy9EO0FBQ0EsaUJBQU8sSUFBUDtBQUNEO0FBQ0Y7QUFDRCxhQUFPLEtBQVA7QUFDRDs7Ozs7O2tCQXFGWSxVOzs7Ozs7Ozs7cWpCQ3pIZjs7Ozs7QUFHQTs7QUFDQTs7OztJQUVPLEk7Ozs7Ozs7bUNBRWlCLFEsRUFBVSxJLEVBQU0sTSxFQUFRLFUsRUFBWTtBQUN4RCxVQUFJLGNBQUo7QUFBQSxVQUFvQjtBQUNoQix3QkFESjtBQUFBLFVBQ3dCO0FBQ3BCLGlDQUZKO0FBQUEsVUFFaUM7QUFDN0Isc0JBSEo7QUFBQSxVQUdzQjtBQUNsQixZQUpKO0FBQUEsVUFLSSxZQUFZLFVBQVUsU0FBVixDQUFvQixXQUFwQixFQUxoQjtBQUFBLFVBTUkscUJBQXFCLENBQ2pCLEtBRGlCLEVBQ1YsS0FEVSxFQUVqQixLQUZpQixFQUVWLEtBRlUsRUFHakIsS0FIaUIsRUFHVixLQUhVLEVBSWpCLEtBSmlCLEVBSVYsS0FKVSxFQUtqQixLQUxpQixFQUtWLEtBTFUsRUFNakIsS0FOaUIsRUFNVixJQU5VLEVBT2pCLElBUGlCLENBTnpCO0FBY0E7QUFDQSx1QkFBaUIsQ0FBQyxDQUFDLEtBQUssU0FBUyxDQUFkLElBQW1CLElBQXBCLE1BQThCLENBQS9CLElBQW9DLENBQXJEO0FBQ0EsMkJBQXNCLENBQUMsS0FBSyxTQUFTLENBQWQsSUFBbUIsSUFBcEIsTUFBOEIsQ0FBcEQ7QUFDQSxVQUFHLHFCQUFxQixtQkFBbUIsTUFBbkIsR0FBMEIsQ0FBbEQsRUFBcUQ7QUFDbkQsaUJBQVMsT0FBVCxDQUFpQixNQUFNLEtBQXZCLEVBQThCLEVBQUMsTUFBTSxtQkFBVyxXQUFsQixFQUErQixTQUFTLHFCQUFhLGtCQUFyRCxFQUF5RSxPQUFPLElBQWhGLEVBQXNGLHlDQUF1QyxrQkFBN0gsRUFBOUI7QUFDQTtBQUNEO0FBQ0QseUJBQW9CLENBQUMsS0FBSyxTQUFTLENBQWQsSUFBbUIsSUFBcEIsS0FBNkIsQ0FBakQ7QUFDQTtBQUNBLDBCQUFxQixDQUFDLEtBQUssU0FBUyxDQUFkLElBQW1CLElBQXBCLE1BQThCLENBQW5EO0FBQ0EscUJBQU8sR0FBUCxxQkFBNkIsVUFBN0Isd0JBQTBELGNBQTFELHdCQUEyRixrQkFBM0YsU0FBaUgsbUJBQW1CLGtCQUFuQixDQUFqSCwwQkFBNEssZ0JBQTVLO0FBQ0E7QUFDQSxVQUFJLGVBQWUsSUFBZixDQUFvQixTQUFwQixDQUFKLEVBQW9DO0FBQ2xDLFlBQUksc0JBQXNCLENBQTFCLEVBQTZCO0FBQzNCLDJCQUFpQixDQUFqQjtBQUNBLG1CQUFTLElBQUksS0FBSixDQUFVLENBQVYsQ0FBVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUE4QixxQkFBcUIsQ0FBbkQ7QUFDRCxTQVBELE1BT087QUFDTCwyQkFBaUIsQ0FBakI7QUFDQSxtQkFBUyxJQUFJLEtBQUosQ0FBVSxDQUFWLENBQVQ7QUFDQSx3Q0FBOEIsa0JBQTlCO0FBQ0Q7QUFDRDtBQUNELE9BZEQsTUFjTyxJQUFJLFVBQVUsT0FBVixDQUFrQixTQUFsQixNQUFpQyxDQUFDLENBQXRDLEVBQXlDO0FBQzlDLHlCQUFpQixDQUFqQjtBQUNBLGlCQUFTLElBQUksS0FBSixDQUFVLENBQVYsQ0FBVDtBQUNBLHNDQUE4QixrQkFBOUI7QUFDRCxPQUpNLE1BSUE7QUFDTDs7O0FBR0EseUJBQWlCLENBQWpCO0FBQ0EsaUJBQVMsSUFBSSxLQUFKLENBQVUsQ0FBVixDQUFUO0FBQ0E7QUFDQSxZQUFLLGVBQWdCLFdBQVcsT0FBWCxDQUFtQixZQUFuQixNQUFxQyxDQUFDLENBQXZDLElBQ0MsV0FBVyxPQUFYLENBQW1CLFdBQW5CLE1BQW9DLENBQUMsQ0FEckQsQ0FBRCxJQUVDLENBQUMsVUFBRCxJQUFlLHNCQUFzQixDQUYxQyxFQUU4QztBQUM1QztBQUNBO0FBQ0E7QUFDQSx3Q0FBOEIscUJBQXFCLENBQW5EO0FBQ0QsU0FQRCxNQU9PO0FBQ0w7QUFDQTtBQUNBLGNBQUksY0FBYyxXQUFXLE9BQVgsQ0FBbUIsV0FBbkIsTUFBb0MsQ0FBQyxDQUFuRCxJQUF5RCxzQkFBc0IsQ0FBdEIsSUFBMkIscUJBQXFCLENBQXpHLElBQ0MsQ0FBQyxVQUFELElBQWUscUJBQXFCLENBRHpDLEVBQzZDO0FBQzNDLDZCQUFpQixDQUFqQjtBQUNBLHFCQUFTLElBQUksS0FBSixDQUFVLENBQVYsQ0FBVDtBQUNEO0FBQ0Qsd0NBQThCLGtCQUE5QjtBQUNEO0FBQ0Y7QUFDRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUNBO0FBQ0EsYUFBTyxDQUFQLElBQVksa0JBQWtCLENBQTlCO0FBQ0E7QUFDQSxhQUFPLENBQVAsS0FBYSxDQUFDLHFCQUFxQixJQUF0QixLQUErQixDQUE1QztBQUNBLGFBQU8sQ0FBUCxLQUFhLENBQUMscUJBQXFCLElBQXRCLEtBQStCLENBQTVDO0FBQ0E7QUFDQSxhQUFPLENBQVAsS0FBYSxvQkFBb0IsQ0FBakM7QUFDQSxVQUFJLG1CQUFtQixDQUF2QixFQUEwQjtBQUN4QjtBQUNBLGVBQU8sQ0FBUCxLQUFhLENBQUMsOEJBQThCLElBQS9CLEtBQXdDLENBQXJEO0FBQ0EsZUFBTyxDQUFQLElBQVksQ0FBQyw4QkFBOEIsSUFBL0IsS0FBd0MsQ0FBcEQ7QUFDQTtBQUNBO0FBQ0EsZUFBTyxDQUFQLEtBQWEsS0FBSyxDQUFsQjtBQUNBLGVBQU8sQ0FBUCxJQUFZLENBQVo7QUFDRDtBQUNELGFBQU8sRUFBQyxRQUFRLE1BQVQsRUFBaUIsWUFBWSxtQkFBbUIsa0JBQW5CLENBQTdCLEVBQXFFLGNBQWMsZ0JBQW5GLEVBQXFHLE9BQVEsYUFBYSxjQUExSCxFQUFQO0FBQ0Q7Ozs7OztrQkFHWSxJOzs7Ozs7Ozs7cWpCQ25JZjs7OztBQUlBOzs7O0FBQ0E7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7Ozs7O0lBRU0sYTtBQUVKLHlCQUFZLEdBQVosRUFBZ0IsRUFBaEIsRUFBb0IsYUFBcEIsRUFBZ0Q7QUFBQSxRQUFiLE1BQWEsdUVBQU4sSUFBTTs7QUFBQTs7QUFDOUMsU0FBSyxHQUFMLEdBQVcsR0FBWDtBQUNBLFNBQUssRUFBTCxHQUFVLEVBQVY7QUFDQSxTQUFLLE1BQUwsR0FBYyxLQUFLLEdBQUwsQ0FBUyxNQUFULElBQW1CLE1BQWpDO0FBQ0EsU0FBSyxhQUFMLEdBQXFCLGFBQXJCO0FBQ0Q7Ozs7OEJBRVM7QUFDUixVQUFJLFVBQVUsS0FBSyxPQUFuQjtBQUNBLFVBQUksT0FBSixFQUFhO0FBQ1gsZ0JBQVEsT0FBUjtBQUNEO0FBQ0Y7Ozt5QkFFSSxJLEVBQU0sVSxFQUFZLFUsRUFBWSxVLEVBQVksRSxFQUFJLEssRUFBTyxFLEVBQUksUSxFQUFTLGtCLEVBQW1CLGMsRUFBZ0I7QUFDeEcsVUFBSSxVQUFVLEtBQUssT0FBbkI7QUFDQSxVQUFJLENBQUMsT0FBRDtBQUNEO0FBQ0E7QUFDRSxhQUFPLEtBQUssRUFBWixJQUFrQixDQUFDLFFBQVEsS0FBUixDQUFjLElBQWQsQ0FIeEIsRUFHOEM7QUFDNUMsWUFBSSxNQUFNLEtBQUssR0FBZjtBQUFBLFlBQ0ksS0FBSyxLQUFLLEVBRGQ7QUFBQSxZQUVJLFNBQVMsS0FBSyxNQUZsQjtBQUFBLFlBR0ksZ0JBQWdCLEtBQUssYUFIekI7QUFJQTtBQUNBLFlBQUksb0JBQVUsS0FBVixDQUFnQixJQUFoQixDQUFKLEVBQTJCO0FBQ3pCLGNBQUksS0FBSyxhQUFMLENBQW1CLElBQW5CLEtBQTRCLElBQWhDLEVBQXNDO0FBQ3BDLHNCQUFVLHdCQUFjLEdBQWQsRUFBbUIsRUFBbkIsZ0NBQTJDLE1BQTNDLEVBQW1ELGFBQW5ELENBQVY7QUFDRCxXQUZELE1BRU87QUFDTCxzQkFBVSx3QkFBYyxHQUFkLEVBQW1CLEVBQW5CLHdCQUFtQyxNQUFuQyxFQUEyQyxhQUEzQyxDQUFWO0FBQ0Q7QUFDRCxrQkFBUSxLQUFSLEdBQWdCLG9CQUFVLEtBQTFCO0FBQ0QsU0FQRCxNQU9PLElBQUcscUJBQVcsS0FBWCxDQUFpQixJQUFqQixDQUFILEVBQTJCO0FBQ2hDLG9CQUFVLHlCQUFlLEdBQWYsRUFBb0IsRUFBcEIsd0JBQW9DLE1BQXBDLEVBQTRDLGFBQTVDLENBQVY7QUFDQSxrQkFBUSxLQUFSLEdBQWdCLHFCQUFXLEtBQTNCO0FBQ0QsU0FITSxNQUdBO0FBQ0wsY0FBSSxPQUFKLENBQVksaUJBQU0sS0FBbEIsRUFBeUIsRUFBQyxNQUFPLG1CQUFXLFdBQW5CLEVBQWdDLElBQUssRUFBckMsRUFBeUMsU0FBUyxxQkFBYSxrQkFBL0QsRUFBbUYsT0FBTyxJQUExRixFQUFnRyxRQUFRLHNDQUF4RyxFQUF6QjtBQUNBO0FBQ0Q7QUFDRCxhQUFLLE9BQUwsR0FBZSxPQUFmO0FBQ0Q7QUFDRCxjQUFRLElBQVIsQ0FBYSxJQUFiLEVBQWtCLFVBQWxCLEVBQTZCLFVBQTdCLEVBQXdDLFVBQXhDLEVBQW1ELEVBQW5ELEVBQXNELEtBQXRELEVBQTRELEVBQTVELEVBQStELFFBQS9ELEVBQXdFLGtCQUF4RSxFQUEyRixjQUEzRjtBQUNBLFdBQUssRUFBTCxHQUFVLEVBQVY7QUFDRDs7Ozs7O2tCQUdZLGE7Ozs7Ozs7OztBQ3REZDs7OztBQUNBOzs7O0FBQ0E7O0FBQ0E7Ozs7OztBQVJEOzs7OztBQVVBLElBQUksZ0JBQWdCLFNBQWhCLGFBQWdCLENBQVUsSUFBVixFQUFnQjtBQUNsQztBQUNBLE1BQUksV0FBVyxzQkFBZjtBQUNBLFdBQVMsT0FBVCxHQUFtQixTQUFTLE9BQVQsQ0FBa0IsS0FBbEIsRUFBa0M7QUFBQSxzQ0FBTixJQUFNO0FBQU4sVUFBTTtBQUFBOztBQUNuRCxhQUFTLElBQVQsa0JBQWMsS0FBZCxFQUFxQixLQUFyQixTQUErQixJQUEvQjtBQUNELEdBRkQ7O0FBSUEsV0FBUyxHQUFULEdBQWUsU0FBUyxHQUFULENBQWMsS0FBZCxFQUE4QjtBQUFBLHVDQUFOLElBQU07QUFBTixVQUFNO0FBQUE7O0FBQzNDLGFBQVMsY0FBVCxrQkFBd0IsS0FBeEIsU0FBa0MsSUFBbEM7QUFDRCxHQUZEOztBQUlBLE1BQUksaUJBQWlCLFNBQWpCLGNBQWlCLENBQVMsRUFBVCxFQUFZLElBQVosRUFBa0I7QUFDckMsU0FBSyxXQUFMLENBQWlCLEVBQUMsT0FBTyxFQUFSLEVBQVksTUFBSyxJQUFqQixFQUFqQjtBQUNELEdBRkQ7O0FBSUEsT0FBSyxnQkFBTCxDQUFzQixTQUF0QixFQUFpQyxVQUFVLEVBQVYsRUFBYztBQUM3QyxRQUFJLE9BQU8sR0FBRyxJQUFkO0FBQ0E7QUFDQSxZQUFRLEtBQUssR0FBYjtBQUNFLFdBQUssTUFBTDtBQUNFLFlBQUksU0FBUyxLQUFLLEtBQUwsQ0FBVyxLQUFLLE1BQWhCLENBQWI7QUFDQSxhQUFLLE9BQUwsR0FBZSw0QkFBa0IsUUFBbEIsRUFBNEIsS0FBSyxFQUFqQyxFQUFxQyxLQUFLLGFBQTFDLEVBQXlELE1BQXpELENBQWY7QUFDQSxZQUFJO0FBQ0Ysa0NBQVcsT0FBTyxLQUFQLEtBQWlCLElBQTVCO0FBQ0QsU0FGRCxDQUVFLE9BQU0sR0FBTixFQUFXO0FBQ1gsa0JBQVEsSUFBUixDQUFhLHNDQUFiO0FBQ0Q7QUFDRDtBQUNBLHVCQUFlLE1BQWYsRUFBc0IsSUFBdEI7QUFDQTtBQUNGLFdBQUssT0FBTDtBQUNFLGFBQUssT0FBTCxDQUFhLElBQWIsQ0FBa0IsSUFBSSxVQUFKLENBQWUsS0FBSyxJQUFwQixDQUFsQixFQUE2QyxLQUFLLFVBQWxELEVBQThELEtBQUssVUFBbkUsRUFBK0UsS0FBSyxVQUFwRixFQUFnRyxLQUFLLEVBQXJHLEVBQXlHLEtBQUssS0FBOUcsRUFBcUgsS0FBSyxFQUExSCxFQUE4SCxLQUFLLFFBQW5JLEVBQTRJLEtBQUssa0JBQWpKLEVBQW9LLEtBQUssY0FBeks7QUFDQTtBQUNGO0FBQ0U7QUFoQko7QUFrQkQsR0FyQkQ7O0FBdUJBO0FBQ0EsV0FBUyxFQUFULENBQVksaUJBQU0seUJBQWxCLEVBQTZDLGNBQTdDO0FBQ0EsV0FBUyxFQUFULENBQVksaUJBQU0sV0FBbEIsRUFBK0IsY0FBL0I7QUFDQSxXQUFTLEVBQVQsQ0FBWSxpQkFBTSxLQUFsQixFQUF5QixjQUF6QjtBQUNBLFdBQVMsRUFBVCxDQUFZLGlCQUFNLHFCQUFsQixFQUF5QyxjQUF6QztBQUNBLFdBQVMsRUFBVCxDQUFZLGlCQUFNLHFCQUFsQixFQUF5QyxjQUF6QztBQUNBLFdBQVMsRUFBVCxDQUFZLGlCQUFNLGNBQWxCLEVBQWtDLGNBQWxDOztBQUVBO0FBQ0EsV0FBUyxFQUFULENBQVksaUJBQU0saUJBQWxCLEVBQXFDLFVBQVMsRUFBVCxFQUFhLElBQWIsRUFBbUI7QUFDdEQsUUFBSSxRQUFRLEtBQUssS0FBTCxDQUFXLE1BQXZCO0FBQUEsUUFBK0IsUUFBUSxLQUFLLEtBQUwsQ0FBVyxNQUFsRDtBQUNBO0FBQ0EsV0FBTyxLQUFLLEtBQVo7QUFDQSxXQUFPLEtBQUssS0FBWjtBQUNBLFNBQUssV0FBTCxDQUFpQixFQUFDLE9BQU8sRUFBUixFQUFZLE1BQUssSUFBakIsRUFBd0IsT0FBUSxLQUFoQyxFQUF1QyxPQUFRLEtBQS9DLEVBQWpCLEVBQXVFLENBQUMsS0FBRCxFQUFRLEtBQVIsQ0FBdkU7QUFDRCxHQU5EO0FBT0QsQ0F0REQ7O2tCQXdEZSxhOzs7Ozs7Ozs7OztBQ2xFZjs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7QUFDQTs7OztBQUNBOzs7Ozs7SUFFTSxPO0FBRUosbUJBQVksR0FBWixFQUFpQixFQUFqQixFQUFxQjtBQUFBOztBQUNuQixTQUFLLEdBQUwsR0FBVyxHQUFYO0FBQ0EsU0FBSyxFQUFMLEdBQVUsRUFBVjtBQUNBLFFBQUksZ0JBQWdCO0FBQ2xCLFdBQU0sWUFBWSxlQUFaLENBQTRCLFdBQTVCLENBRFk7QUFFbEIsWUFBTyxJQUFJLE1BQUosQ0FBVyxxQkFBWCxJQUFvQyxZQUFZLGVBQVosQ0FBNEIsWUFBNUIsQ0FGekI7QUFHbEIsWUFBTSxZQUFZLGVBQVosQ0FBNEIsWUFBNUIsQ0FIWTtBQUlsQixXQUFLLFlBQVksZUFBWixDQUE0Qix5QkFBNUI7QUFKYSxLQUFwQjtBQU1BLFFBQUksSUFBSSxNQUFKLENBQVcsWUFBWCxJQUE0QixPQUFPLE1BQVAsS0FBbUIsV0FBbkQsRUFBaUU7QUFDN0QscUJBQU8sR0FBUCxDQUFXLHVCQUFYO0FBQ0EsVUFBSSxVQUFKO0FBQ0EsVUFBSTtBQUNGLFlBQUksT0FBTyxRQUFRLFlBQVIsQ0FBWDtBQUNBLFlBQUksS0FBSyxDQUFMLEdBQVMsNkJBQWI7QUFDQSxhQUFLLE1BQUwsR0FBYyxLQUFLLGVBQUwsQ0FBcUIsSUFBckIsQ0FBMEIsSUFBMUIsQ0FBZDtBQUNBLFVBQUUsZ0JBQUYsQ0FBbUIsU0FBbkIsRUFBOEIsS0FBSyxNQUFuQztBQUNBLFVBQUUsT0FBRixHQUFZLFVBQVMsS0FBVCxFQUFnQjtBQUFFLGNBQUksT0FBSixDQUFZLGlCQUFNLEtBQWxCLEVBQXlCLEVBQUMsTUFBTSxtQkFBVyxXQUFsQixFQUErQixTQUFTLHFCQUFhLGtCQUFyRCxFQUF5RSxPQUFPLElBQWhGLEVBQXNGLE9BQVEsZUFBOUYsRUFBK0csS0FBTSxFQUFFLFNBQVUsTUFBTSxPQUFOLEdBQWdCLElBQWhCLEdBQXVCLE1BQU0sUUFBN0IsR0FBd0MsR0FBeEMsR0FBOEMsTUFBTSxNQUFwRCxHQUE2RCxHQUF6RSxFQUFySCxFQUF6QjtBQUFnTyxTQUE5UDtBQUNBLFVBQUUsV0FBRixDQUFjLEVBQUMsS0FBSyxNQUFOLEVBQWMsZUFBZ0IsYUFBOUIsRUFBNkMsSUFBSyxFQUFsRCxFQUFzRCxRQUFRLEtBQUssU0FBTCxDQUFlLElBQUksTUFBbkIsQ0FBOUQsRUFBZDtBQUNELE9BUEQsQ0FPRSxPQUFNLEdBQU4sRUFBVztBQUNYLHVCQUFPLEtBQVAsQ0FBYSxtRUFBYjtBQUNBLFlBQUksQ0FBSixFQUFPO0FBQ0w7QUFDQSxjQUFJLGVBQUosQ0FBb0IsRUFBRSxTQUF0QjtBQUNEO0FBQ0QsYUFBSyxPQUFMLEdBQWUsNEJBQWtCLEdBQWxCLEVBQXNCLEVBQXRCLEVBQXlCLGFBQXpCLENBQWY7QUFDRDtBQUNGLEtBbEJILE1Ba0JTO0FBQ0wsV0FBSyxPQUFMLEdBQWUsNEJBQWtCLEdBQWxCLEVBQXNCLEVBQXRCLEVBQXlCLGFBQXpCLENBQWY7QUFDRDtBQUNELFNBQUssZ0JBQUwsR0FBd0IsSUFBeEI7QUFDSDs7Ozs4QkFFUztBQUNSLFVBQUksSUFBSSxLQUFLLENBQWI7QUFDQSxVQUFJLENBQUosRUFBTztBQUNMLFVBQUUsbUJBQUYsQ0FBc0IsU0FBdEIsRUFBaUMsS0FBSyxNQUF0QztBQUNBLFVBQUUsU0FBRjtBQUNBLGFBQUssQ0FBTCxHQUFTLElBQVQ7QUFDRCxPQUpELE1BSU87QUFDTCxZQUFJLFVBQVUsS0FBSyxPQUFuQjtBQUNBLFlBQUksT0FBSixFQUFhO0FBQ1gsa0JBQVEsT0FBUjtBQUNBLGVBQUssT0FBTCxHQUFlLElBQWY7QUFDRDtBQUNGO0FBQ0QsVUFBSSxZQUFZLEtBQUssU0FBckI7QUFDQSxVQUFJLFNBQUosRUFBZTtBQUNiLGtCQUFVLE9BQVY7QUFDQSxhQUFLLFNBQUwsR0FBaUIsSUFBakI7QUFDRDtBQUNGOzs7a0NBRWEsSSxFQUFNLFUsRUFBWSxVLEVBQVksVSxFQUFZLEUsRUFBSSxLLEVBQU8sRSxFQUFJLFEsRUFBUyxrQixFQUFtQixjLEVBQWdCO0FBQ2pILFVBQUksSUFBSSxLQUFLLENBQWI7QUFDQSxVQUFJLENBQUosRUFBTztBQUNMO0FBQ0EsVUFBRSxXQUFGLENBQWMsRUFBQyxLQUFLLE9BQU4sRUFBZSxNQUFNLElBQXJCLEVBQTJCLFlBQVksVUFBdkMsRUFBbUQsWUFBWSxVQUEvRCxFQUEyRSxZQUFZLFVBQXZGLEVBQW1HLElBQUksRUFBdkcsRUFBMkcsT0FBTyxLQUFsSCxFQUF5SCxJQUFLLEVBQTlILEVBQWtJLFVBQVUsUUFBNUksRUFBc0osb0JBQXFCLGtCQUEzSyxFQUErTCxnQkFBaUIsY0FBaE4sRUFBZCxFQUFnUCxDQUFDLElBQUQsQ0FBaFA7QUFDRCxPQUhELE1BR087QUFDTCxZQUFJLFVBQVUsS0FBSyxPQUFuQjtBQUNBLFlBQUksT0FBSixFQUFhO0FBQ1gsa0JBQVEsSUFBUixDQUFhLElBQUksVUFBSixDQUFlLElBQWYsQ0FBYixFQUFtQyxVQUFuQyxFQUErQyxVQUEvQyxFQUEyRCxVQUEzRCxFQUF1RSxFQUF2RSxFQUEyRSxLQUEzRSxFQUFrRixFQUFsRixFQUFzRixRQUF0RixFQUErRixrQkFBL0YsRUFBa0gsY0FBbEg7QUFDRDtBQUNGO0FBQ0Y7Ozt5QkFFSSxJLEVBQU0sVSxFQUFZLFUsRUFBWSxVLEVBQVksRSxFQUFJLEssRUFBTyxFLEVBQUksUSxFQUFVLFcsRUFBWSxrQixFQUFtQixjLEVBQWdCO0FBQ3JILFVBQUssS0FBSyxVQUFMLEdBQWtCLENBQW5CLElBQTBCLGVBQWUsSUFBekMsSUFBbUQsWUFBWSxHQUFaLElBQW1CLElBQXRFLElBQWdGLFlBQVksTUFBWixLQUF1QixTQUEzRyxFQUF1SDtBQUNySCxZQUFJLEtBQUssU0FBTCxJQUFrQixJQUF0QixFQUE0QjtBQUMxQixlQUFLLFNBQUwsR0FBaUIsd0JBQWMsS0FBSyxHQUFuQixDQUFqQjtBQUNEO0FBQ0QsWUFBSSxZQUFZLElBQWhCO0FBQ0EsWUFBSSxZQUFZLFlBQVksR0FBWixFQUFoQjtBQUNBLGFBQUssU0FBTCxDQUFlLE9BQWYsQ0FBdUIsSUFBdkIsRUFBNkIsWUFBWSxHQUFaLENBQWdCLE1BQTdDLEVBQXFELFlBQVksRUFBWixDQUFlLE1BQXBFLEVBQTRFLFVBQVUsYUFBVixFQUF5QjtBQUNuRyxvQkFBVSxHQUFWLENBQWMsT0FBZCxDQUFzQixpQkFBTSxjQUE1QixFQUE0QyxFQUFFLE9BQVEsS0FBVixFQUFpQixJQUFLLEVBQXRCLEVBQTBCLE9BQU8sRUFBRSxRQUFRLFNBQVYsRUFBcUIsVUFBVSxZQUFZLEdBQVosRUFBL0IsRUFBakMsRUFBNUM7QUFDQSxvQkFBVSxhQUFWLENBQXdCLGFBQXhCLEVBQXVDLFVBQXZDLEVBQW1ELFVBQW5ELEVBQStELFVBQS9ELEVBQTJFLEVBQTNFLEVBQStFLEtBQS9FLEVBQXNGLEVBQXRGLEVBQTBGLFFBQTFGLEVBQW9HLGtCQUFwRyxFQUF1SCxjQUF2SDtBQUNELFNBSEQ7QUFJRCxPQVZELE1BVU87QUFDTCxhQUFLLGFBQUwsQ0FBbUIsSUFBbkIsRUFBeUIsVUFBekIsRUFBcUMsVUFBckMsRUFBaUQsVUFBakQsRUFBNkQsRUFBN0QsRUFBaUUsS0FBakUsRUFBd0UsRUFBeEUsRUFBNEUsUUFBNUUsRUFBcUYsa0JBQXJGLEVBQXdHLGNBQXhHO0FBQ0Q7QUFDRjs7O29DQUVlLEUsRUFBSTtBQUNsQixVQUFJLE9BQU8sR0FBRyxJQUFkO0FBQUEsVUFDSSxNQUFNLEtBQUssR0FEZjtBQUVBO0FBQ0EsY0FBTyxLQUFLLEtBQVo7QUFDRSxhQUFLLE1BQUw7QUFDRTtBQUNBLGNBQUksZUFBSixDQUFvQixLQUFLLENBQUwsQ0FBTyxTQUEzQjtBQUNBO0FBQ0Y7QUFDQSxhQUFLLGlCQUFNLGlCQUFYO0FBQ0UsZUFBSyxJQUFMLENBQVUsS0FBVixHQUFrQixJQUFJLFVBQUosQ0FBZSxLQUFLLEtBQXBCLENBQWxCO0FBQ0EsZUFBSyxJQUFMLENBQVUsS0FBVixHQUFrQixJQUFJLFVBQUosQ0FBZSxLQUFLLEtBQXBCLENBQWxCO0FBQ0E7QUFDRjtBQUNFLGNBQUksT0FBSixDQUFZLEtBQUssS0FBakIsRUFBd0IsS0FBSyxJQUE3QjtBQUNBO0FBWko7QUFjRDs7Ozs7O2tCQUdZLE87Ozs7Ozs7OztxakJDaEhmOzs7O0FBSUE7Ozs7SUFFTSxTO0FBRUoscUJBQVksSUFBWixFQUFrQjtBQUFBOztBQUNoQixTQUFLLElBQUwsR0FBWSxJQUFaO0FBQ0E7QUFDQSxTQUFLLGNBQUwsR0FBc0IsS0FBSyxVQUEzQjtBQUNBO0FBQ0EsU0FBSyxJQUFMLEdBQVksQ0FBWixDQUxnQixDQUtEO0FBQ2Y7QUFDQSxTQUFLLGFBQUwsR0FBcUIsQ0FBckIsQ0FQZ0IsQ0FPUTtBQUN6Qjs7QUFFRDs7Ozs7K0JBQ1c7QUFDVCxVQUNFLE9BQU8sS0FBSyxJQURkO0FBQUEsVUFFRSxpQkFBaUIsS0FBSyxjQUZ4QjtBQUFBLFVBR0UsV0FBVyxLQUFLLFVBQUwsR0FBa0IsY0FIL0I7QUFBQSxVQUlFLGVBQWUsSUFBSSxVQUFKLENBQWUsQ0FBZixDQUpqQjtBQUFBLFVBS0UsaUJBQWlCLEtBQUssR0FBTCxDQUFTLENBQVQsRUFBWSxjQUFaLENBTG5CO0FBTUEsVUFBSSxtQkFBbUIsQ0FBdkIsRUFBMEI7QUFDeEIsY0FBTSxJQUFJLEtBQUosQ0FBVSxvQkFBVixDQUFOO0FBQ0Q7QUFDRCxtQkFBYSxHQUFiLENBQWlCLEtBQUssUUFBTCxDQUFjLFFBQWQsRUFBd0IsV0FBVyxjQUFuQyxDQUFqQjtBQUNBLFdBQUssSUFBTCxHQUFZLElBQUksUUFBSixDQUFhLGFBQWEsTUFBMUIsRUFBa0MsU0FBbEMsQ0FBNEMsQ0FBNUMsQ0FBWjtBQUNBO0FBQ0EsV0FBSyxhQUFMLEdBQXFCLGlCQUFpQixDQUF0QztBQUNBLFdBQUssY0FBTCxJQUF1QixjQUF2QjtBQUNEOztBQUVEOzs7OzZCQUNTLEssRUFBTztBQUNkLFVBQUksU0FBSixDQURjLENBQ0M7QUFDZixVQUFJLEtBQUssYUFBTCxHQUFxQixLQUF6QixFQUFnQztBQUM5QixhQUFLLElBQUwsS0FBYyxLQUFkO0FBQ0EsYUFBSyxhQUFMLElBQXNCLEtBQXRCO0FBQ0QsT0FIRCxNQUdPO0FBQ0wsaUJBQVMsS0FBSyxhQUFkO0FBQ0Esb0JBQVksU0FBUyxDQUFyQjtBQUNBLGlCQUFVLGFBQWEsQ0FBdkI7QUFDQSxhQUFLLGNBQUwsSUFBdUIsU0FBdkI7QUFDQSxhQUFLLFFBQUw7QUFDQSxhQUFLLElBQUwsS0FBYyxLQUFkO0FBQ0EsYUFBSyxhQUFMLElBQXNCLEtBQXRCO0FBQ0Q7QUFDRjs7QUFFRDs7Ozs2QkFDUyxJLEVBQU07QUFDYixVQUNFLE9BQU8sS0FBSyxHQUFMLENBQVMsS0FBSyxhQUFkLEVBQTZCLElBQTdCLENBRFQ7QUFBQSxVQUM2QztBQUMzQyxhQUFPLEtBQUssSUFBTCxLQUFlLEtBQUssSUFGN0IsQ0FEYSxDQUd1QjtBQUNwQyxVQUFJLE9BQU8sRUFBWCxFQUFlO0FBQ2IsdUJBQU8sS0FBUCxDQUFhLHlDQUFiO0FBQ0Q7QUFDRCxXQUFLLGFBQUwsSUFBc0IsSUFBdEI7QUFDQSxVQUFJLEtBQUssYUFBTCxHQUFxQixDQUF6QixFQUE0QjtBQUMxQixhQUFLLElBQUwsS0FBYyxJQUFkO0FBQ0QsT0FGRCxNQUVPLElBQUksS0FBSyxjQUFMLEdBQXNCLENBQTFCLEVBQTZCO0FBQ2xDLGFBQUssUUFBTDtBQUNEO0FBQ0QsYUFBTyxPQUFPLElBQWQ7QUFDQSxVQUFJLE9BQU8sQ0FBUCxJQUFZLEtBQUssYUFBckIsRUFBb0M7QUFDbEMsZUFBTyxRQUFRLElBQVIsR0FBZSxLQUFLLFFBQUwsQ0FBYyxJQUFkLENBQXRCO0FBQ0QsT0FGRCxNQUVPO0FBQ0wsZUFBTyxJQUFQO0FBQ0Q7QUFDRjs7QUFFRDs7Ozs2QkFDUztBQUNQLFVBQUksZ0JBQUosQ0FETyxDQUNlO0FBQ3RCLFdBQUssbUJBQW1CLENBQXhCLEVBQTJCLG1CQUFtQixLQUFLLGFBQW5ELEVBQWtFLEVBQUUsZ0JBQXBFLEVBQXNGO0FBQ3BGLFlBQUksT0FBTyxLQUFLLElBQUwsR0FBYSxlQUFlLGdCQUFuQyxDQUFKLEVBQTJEO0FBQ3pEO0FBQ0EsZUFBSyxJQUFMLEtBQWMsZ0JBQWQ7QUFDQSxlQUFLLGFBQUwsSUFBc0IsZ0JBQXRCO0FBQ0EsaUJBQU8sZ0JBQVA7QUFDRDtBQUNGO0FBQ0Q7QUFDQSxXQUFLLFFBQUw7QUFDQSxhQUFPLG1CQUFtQixLQUFLLE1BQUwsRUFBMUI7QUFDRDs7QUFFRDs7Ozs4QkFDVTtBQUNSLFdBQUssUUFBTCxDQUFjLElBQUksS0FBSyxNQUFMLEVBQWxCO0FBQ0Q7O0FBRUQ7Ozs7NkJBQ1M7QUFDUCxXQUFLLFFBQUwsQ0FBYyxJQUFJLEtBQUssTUFBTCxFQUFsQjtBQUNEOztBQUVEOzs7OzhCQUNVO0FBQ1IsVUFBSSxNQUFNLEtBQUssTUFBTCxFQUFWLENBRFEsQ0FDaUI7QUFDekIsYUFBTyxLQUFLLFFBQUwsQ0FBYyxNQUFNLENBQXBCLElBQXlCLENBQWhDO0FBQ0Q7O0FBRUQ7Ozs7NkJBQ1M7QUFDUCxVQUFJLE9BQU8sS0FBSyxPQUFMLEVBQVgsQ0FETyxDQUNvQjtBQUMzQixVQUFJLE9BQU8sSUFBWCxFQUFpQjtBQUNmO0FBQ0EsZUFBUSxJQUFJLElBQUwsS0FBZSxDQUF0QixDQUZlLENBRVU7QUFDMUIsT0FIRCxNQUdPO0FBQ0wsZUFBTyxDQUFDLENBQUQsSUFBTSxTQUFTLENBQWYsQ0FBUCxDQURLLENBQ3FCO0FBQzNCO0FBQ0Y7O0FBRUQ7QUFDQTs7OztrQ0FDYztBQUNaLGFBQU8sTUFBTSxLQUFLLFFBQUwsQ0FBYyxDQUFkLENBQWI7QUFDRDs7QUFFRDs7OztnQ0FDWTtBQUNWLGFBQU8sS0FBSyxRQUFMLENBQWMsQ0FBZCxDQUFQO0FBQ0Q7O0FBRUQ7Ozs7aUNBQ2E7QUFDWCxhQUFPLEtBQUssUUFBTCxDQUFjLEVBQWQsQ0FBUDtBQUNEO0FBQ0M7Ozs7K0JBQ1M7QUFDVCxhQUFPLEtBQUssUUFBTCxDQUFjLEVBQWQsQ0FBUDtBQUNEOztBQUVEOzs7Ozs7Ozs7O29DQU9nQixLLEVBQU87QUFDckIsVUFDRSxZQUFZLENBRGQ7QUFBQSxVQUVFLFlBQVksQ0FGZDtBQUFBLFVBR0UsQ0FIRjtBQUFBLFVBSUUsVUFKRjtBQUtBLFdBQUssSUFBSSxDQUFULEVBQVksSUFBSSxLQUFoQixFQUF1QixHQUF2QixFQUE0QjtBQUMxQixZQUFJLGNBQWMsQ0FBbEIsRUFBcUI7QUFDbkIsdUJBQWEsS0FBSyxNQUFMLEVBQWI7QUFDQSxzQkFBWSxDQUFDLFlBQVksVUFBWixHQUF5QixHQUExQixJQUFpQyxHQUE3QztBQUNEO0FBQ0Qsb0JBQWEsY0FBYyxDQUFmLEdBQW9CLFNBQXBCLEdBQWdDLFNBQTVDO0FBQ0Q7QUFDRjs7QUFFRDs7Ozs7Ozs7Ozs7OzhCQVNVO0FBQ1IsVUFDRSxzQkFBc0IsQ0FEeEI7QUFBQSxVQUVFLHVCQUF1QixDQUZ6QjtBQUFBLFVBR0UscUJBQXFCLENBSHZCO0FBQUEsVUFJRSx3QkFBd0IsQ0FKMUI7QUFBQSxVQUtFLFdBQVcsQ0FMYjtBQUFBLFVBTUUsVUFORjtBQUFBLFVBTWEsYUFOYjtBQUFBLFVBTTJCLFFBTjNCO0FBQUEsVUFPRSw4QkFQRjtBQUFBLFVBT2tDLG1CQVBsQztBQUFBLFVBUUUseUJBUkY7QUFBQSxVQVNFLGdCQVRGO0FBQUEsVUFVRSxnQkFWRjtBQUFBLFVBV0UsQ0FYRjtBQUFBLFVBWUUsWUFBWSxLQUFLLFNBQUwsQ0FBZSxJQUFmLENBQW9CLElBQXBCLENBWmQ7QUFBQSxVQWFFLFdBQVcsS0FBSyxRQUFMLENBQWMsSUFBZCxDQUFtQixJQUFuQixDQWJiO0FBQUEsVUFjRSxVQUFVLEtBQUssT0FBTCxDQUFhLElBQWIsQ0FBa0IsSUFBbEIsQ0FkWjtBQUFBLFVBZUUsY0FBYyxLQUFLLFdBQUwsQ0FBaUIsSUFBakIsQ0FBc0IsSUFBdEIsQ0FmaEI7QUFBQSxVQWdCRSxXQUFXLEtBQUssUUFBTCxDQUFjLElBQWQsQ0FBbUIsSUFBbkIsQ0FoQmI7QUFBQSxVQWlCRSxTQUFTLEtBQUssTUFBTCxDQUFZLElBQVosQ0FBaUIsSUFBakIsQ0FqQlg7QUFBQSxVQWtCRSxVQUFVLEtBQUssT0FBTCxDQUFhLElBQWIsQ0FBa0IsSUFBbEIsQ0FsQlo7QUFBQSxVQW1CRSxrQkFBa0IsS0FBSyxlQUFMLENBQXFCLElBQXJCLENBQTBCLElBQTFCLENBbkJwQjs7QUFxQkE7QUFDQSxtQkFBYSxXQUFiLENBdkJRLENBdUJrQjtBQUMxQixzQkFBZ0IsU0FBUyxDQUFULENBQWhCLENBeEJRLENBd0JxQjtBQUM3QixlQUFTLENBQVQsRUF6QlEsQ0F5Qks7QUFDYixpQkFBVyxXQUFYLENBMUJRLENBMEJnQjtBQUN4QixnQkEzQlEsQ0EyQkc7QUFDWDtBQUNBLFVBQUksZUFBZSxHQUFmLElBQ0EsZUFBZSxHQURmLElBRUEsZUFBZSxHQUZmLElBR0EsZUFBZSxHQUhmLElBSUEsZUFBZSxFQUpmLElBS0EsZUFBZSxFQUxmLElBTUEsZUFBZSxFQU5mLElBT0EsZUFBZSxHQVBmLElBUUEsZUFBZSxHQVJuQixFQVF3QjtBQUN0QixZQUFJLGtCQUFrQixTQUF0QjtBQUNBLFlBQUksb0JBQW9CLENBQXhCLEVBQTJCO0FBQ3pCLG1CQUFTLENBQVQsRUFEeUIsQ0FDWjtBQUNkO0FBQ0Qsa0JBTHNCLENBS1g7QUFDWCxrQkFOc0IsQ0FNWDtBQUNYLGlCQUFTLENBQVQsRUFQc0IsQ0FPVDtBQUNiLFlBQUksYUFBSixFQUFtQjtBQUFFO0FBQ25CLDZCQUFvQixvQkFBb0IsQ0FBckIsR0FBMEIsQ0FBMUIsR0FBOEIsRUFBakQ7QUFDQSxlQUFLLElBQUksQ0FBVCxFQUFZLElBQUksZ0JBQWhCLEVBQWtDLEdBQWxDLEVBQXVDO0FBQ3JDLGdCQUFJLGFBQUosRUFBbUI7QUFBRTtBQUNuQixrQkFBSSxJQUFJLENBQVIsRUFBVztBQUNULGdDQUFnQixFQUFoQjtBQUNELGVBRkQsTUFFTztBQUNMLGdDQUFnQixFQUFoQjtBQUNEO0FBQ0Y7QUFDRjtBQUNGO0FBQ0Y7QUFDRCxnQkExRFEsQ0EwREc7QUFDWCxVQUFJLGtCQUFrQixTQUF0QjtBQUNBLFVBQUksb0JBQW9CLENBQXhCLEVBQTJCO0FBQ3pCLGtCQUR5QixDQUNkO0FBQ1osT0FGRCxNQUVPLElBQUksb0JBQW9CLENBQXhCLEVBQTJCO0FBQ2hDLGlCQUFTLENBQVQsRUFEZ0MsQ0FDbkI7QUFDYixpQkFGZ0MsQ0FFdEI7QUFDVixpQkFIZ0MsQ0FHdEI7QUFDVix5Q0FBaUMsU0FBakM7QUFDQSxhQUFJLElBQUksQ0FBUixFQUFXLElBQUksOEJBQWYsRUFBK0MsR0FBL0MsRUFBb0Q7QUFDbEQsbUJBRGtELENBQ3hDO0FBQ1g7QUFDRjtBQUNELGdCQXZFUSxDQXVFRztBQUNYLGVBQVMsQ0FBVCxFQXhFUSxDQXdFSztBQUNiLDRCQUFzQixTQUF0QjtBQUNBLGtDQUE0QixTQUE1QjtBQUNBLHlCQUFtQixTQUFTLENBQVQsQ0FBbkI7QUFDQSxVQUFJLHFCQUFxQixDQUF6QixFQUE0QjtBQUMxQixpQkFBUyxDQUFULEVBRDBCLENBQ2I7QUFDZDtBQUNELGVBQVMsQ0FBVCxFQS9FUSxDQStFSztBQUNiLFVBQUksYUFBSixFQUFtQjtBQUFFO0FBQ25CLDhCQUFzQixTQUF0QjtBQUNBLCtCQUF1QixTQUF2QjtBQUNBLDZCQUFxQixTQUFyQjtBQUNBLGdDQUF3QixTQUF4QjtBQUNEO0FBQ0QsVUFBSSxhQUFKLEVBQW1CO0FBQ2pCO0FBQ0EsWUFBSSxhQUFKLEVBQW1CO0FBQ2pCO0FBQ0EsY0FBSSxpQkFBSjtBQUNBLGNBQU0saUJBQWlCLFdBQXZCO0FBQ0Esa0JBQVEsY0FBUjtBQUNFLGlCQUFLLENBQUw7QUFBUSx5QkFBVyxDQUFDLENBQUQsRUFBRyxDQUFILENBQVgsQ0FBa0I7QUFDMUIsaUJBQUssQ0FBTDtBQUFRLHlCQUFXLENBQUMsRUFBRCxFQUFJLEVBQUosQ0FBWCxDQUFvQjtBQUM1QixpQkFBSyxDQUFMO0FBQVEseUJBQVcsQ0FBQyxFQUFELEVBQUksRUFBSixDQUFYLENBQW9CO0FBQzVCLGlCQUFLLENBQUw7QUFBUSx5QkFBVyxDQUFDLEVBQUQsRUFBSSxFQUFKLENBQVgsQ0FBb0I7QUFDNUIsaUJBQUssQ0FBTDtBQUFRLHlCQUFXLENBQUMsRUFBRCxFQUFJLEVBQUosQ0FBWCxDQUFvQjtBQUM1QixpQkFBSyxDQUFMO0FBQVEseUJBQVcsQ0FBQyxFQUFELEVBQUksRUFBSixDQUFYLENBQW9CO0FBQzVCLGlCQUFLLENBQUw7QUFBUSx5QkFBVyxDQUFDLEVBQUQsRUFBSSxFQUFKLENBQVgsQ0FBb0I7QUFDNUIsaUJBQUssQ0FBTDtBQUFRLHlCQUFXLENBQUMsRUFBRCxFQUFJLEVBQUosQ0FBWCxDQUFvQjtBQUM1QixpQkFBSyxDQUFMO0FBQVEseUJBQVcsQ0FBQyxFQUFELEVBQUksRUFBSixDQUFYLENBQW9CO0FBQzVCLGlCQUFLLEVBQUw7QUFBUyx5QkFBVyxDQUFDLEVBQUQsRUFBSSxFQUFKLENBQVgsQ0FBb0I7QUFDN0IsaUJBQUssRUFBTDtBQUFTLHlCQUFXLENBQUMsRUFBRCxFQUFJLEVBQUosQ0FBWCxDQUFvQjtBQUM3QixpQkFBSyxFQUFMO0FBQVMseUJBQVcsQ0FBQyxFQUFELEVBQUksRUFBSixDQUFYLENBQW9CO0FBQzdCLGlCQUFLLEVBQUw7QUFBUyx5QkFBVyxDQUFDLEdBQUQsRUFBSyxFQUFMLENBQVgsQ0FBcUI7QUFDOUIsaUJBQUssRUFBTDtBQUFTLHlCQUFXLENBQUMsQ0FBRCxFQUFHLENBQUgsQ0FBWCxDQUFrQjtBQUMzQixpQkFBSyxFQUFMO0FBQVMseUJBQVcsQ0FBQyxDQUFELEVBQUcsQ0FBSCxDQUFYLENBQWtCO0FBQzNCLGlCQUFLLEVBQUw7QUFBUyx5QkFBVyxDQUFDLENBQUQsRUFBRyxDQUFILENBQVgsQ0FBa0I7QUFDM0IsaUJBQUssR0FBTDtBQUFVO0FBQ1IsMkJBQVcsQ0FBQyxlQUFlLENBQWYsR0FBbUIsV0FBcEIsRUFBaUMsZUFBZSxDQUFmLEdBQW1CLFdBQXBELENBQVg7QUFDQTtBQUNEO0FBcEJIO0FBc0JBLGNBQUksUUFBSixFQUFjO0FBQ1osdUJBQVcsU0FBUyxDQUFULElBQWMsU0FBUyxDQUFULENBQXpCO0FBQ0Q7QUFDRjtBQUNGO0FBQ0QsYUFBTztBQUNMLGVBQU8sS0FBSyxJQUFMLENBQVUsQ0FBRSxDQUFDLHNCQUFzQixDQUF2QixJQUE0QixFQUE3QixHQUFtQyxzQkFBc0IsQ0FBekQsR0FBNkQsdUJBQXVCLENBQXJGLElBQTBGLFFBQXBHLENBREY7QUFFTCxnQkFBUyxDQUFDLElBQUksZ0JBQUwsS0FBMEIsNEJBQTRCLENBQXRELElBQTJELEVBQTVELEdBQW1FLENBQUMsbUJBQWtCLENBQWxCLEdBQXNCLENBQXZCLEtBQTZCLHFCQUFxQixxQkFBbEQ7QUFGdEUsT0FBUDtBQUlEOzs7b0NBRWU7QUFDZDtBQUNBLFdBQUssU0FBTDtBQUNBO0FBQ0EsV0FBSyxPQUFMO0FBQ0E7QUFDQSxhQUFPLEtBQUssT0FBTCxFQUFQO0FBQ0Q7Ozs7OztrQkFHWSxTOzs7Ozs7Ozs7cWpCQ2hUZjs7Ozs7QUFHQTs7OztBQUNBOztJQUVPLEc7QUFFTCxlQUFZLElBQVosRUFBa0I7QUFBQTs7QUFDaEIsU0FBSyxhQUFMLEdBQXFCLEtBQXJCO0FBQ0EsUUFBSSxTQUFTLENBQWI7QUFBQSxRQUFnQixLQUFoQjtBQUFBLFFBQXNCLEtBQXRCO0FBQUEsUUFBNEIsS0FBNUI7QUFBQSxRQUFrQyxLQUFsQztBQUFBLFFBQXdDLE9BQXhDO0FBQUEsUUFBZ0QsTUFBaEQ7QUFBQSxRQUF1RCxNQUF2RDtBQUFBLFFBQThELEdBQTlEO0FBQ0UsT0FBRztBQUNELGVBQVMsS0FBSyxPQUFMLENBQWEsSUFBYixFQUFrQixNQUFsQixFQUF5QixDQUF6QixDQUFUO0FBQ0EsZ0JBQVEsQ0FBUjtBQUNFO0FBQ0EsVUFBSSxXQUFXLEtBQWYsRUFBc0I7QUFDbEI7QUFDQSxrQkFBVSxDQUFWO0FBQ0E7QUFDQSxnQkFBUSxLQUFLLFFBQUwsSUFBaUIsSUFBekI7QUFDQSxnQkFBUSxLQUFLLFFBQUwsSUFBaUIsSUFBekI7QUFDQSxnQkFBUSxLQUFLLFFBQUwsSUFBaUIsSUFBekI7QUFDQSxnQkFBUSxLQUFLLFFBQUwsSUFBaUIsSUFBekI7QUFDQSxrQkFBVSxDQUFDLFNBQVMsRUFBVixLQUFpQixTQUFTLEVBQTFCLEtBQWlDLFNBQVMsQ0FBMUMsSUFBK0MsS0FBekQ7QUFDQSxpQkFBUyxTQUFTLE9BQWxCO0FBQ0E7O0FBRUE7QUFDQSxhQUFLLGVBQUwsQ0FBcUIsSUFBckIsRUFBMkIsTUFBM0IsRUFBa0MsTUFBbEM7QUFDQSxpQkFBUyxNQUFUO0FBQ0gsT0FmRCxNQWVPLElBQUksV0FBVyxLQUFmLEVBQXNCO0FBQ3pCO0FBQ0Esa0JBQVUsQ0FBVjtBQUNJLHVCQUFPLEdBQVAsNkJBQXFDLE1BQXJDO0FBQ1AsT0FKTSxNQUlBO0FBQ0gsa0JBQVUsQ0FBVjtBQUNBLGNBQU0sTUFBTjtBQUNJLFlBQUksR0FBSixFQUFTO0FBQ0w7QUFDQSxjQUFJLENBQUMsS0FBSyxZQUFWLEVBQXdCO0FBQ3BCLDJCQUFPLElBQVAsQ0FBWSxpQ0FBWjtBQUNIO0FBQ0QsZUFBSyxPQUFMLEdBQWUsR0FBZjtBQUNBLGVBQUssUUFBTCxHQUFnQixLQUFLLFFBQUwsQ0FBYyxDQUFkLEVBQWdCLEdBQWhCLENBQWhCO0FBQ0g7QUFDTDtBQUNIO0FBQ0osS0FwQ0QsUUFvQ1MsSUFwQ1Q7QUFxQ0g7Ozs7NEJBRU8sSSxFQUFLLEssRUFBTSxHLEVBQUs7O0FBRXRCLFVBQUksU0FBUyxFQUFiO0FBQUEsVUFBZ0IsU0FBUyxLQUF6QjtBQUFBLFVBQWdDLE1BQU0sUUFBUSxHQUE5QztBQUNBLFNBQUc7QUFDRCxrQkFBVSxPQUFPLFlBQVAsQ0FBb0IsS0FBSyxRQUFMLENBQXBCLENBQVY7QUFDRCxPQUZELFFBRVEsU0FBUyxHQUZqQjtBQUdBLGFBQU8sTUFBUDtBQUNEOzs7b0NBRWUsSSxFQUFLLE0sRUFBTyxNLEVBQVE7QUFDbEMsVUFBSSxLQUFKLEVBQVUsTUFBVixFQUFpQixRQUFqQixFQUEwQixRQUExQixFQUFtQyxTQUFuQztBQUNBLGFBQU0sU0FBUyxDQUFULElBQWMsTUFBcEIsRUFBNEI7QUFDMUIsZ0JBQVEsS0FBSyxPQUFMLENBQWEsSUFBYixFQUFrQixNQUFsQixFQUF5QixDQUF6QixDQUFSO0FBQ0Esa0JBQVMsQ0FBVDs7QUFFQSxpQkFBUyxLQUFLLFFBQUwsS0FBa0IsS0FDakIsS0FBSyxRQUFMLENBREQsSUFDbUIsS0FDbEIsS0FBSyxRQUFMLENBRkQsSUFFbUIsSUFDbEIsS0FBSyxRQUFMLENBSFY7O0FBS0EsbUJBQVcsS0FBSyxRQUFMLEtBQWtCLElBQ2pCLEtBQUssUUFBTCxDQURaOztBQUdBLG1CQUFXLE1BQVg7QUFDQTtBQUNBLGdCQUFPLEtBQVA7QUFDRSxlQUFLLE1BQUw7QUFDSTtBQUNBO0FBQ0EsZ0JBQUksS0FBSyxPQUFMLENBQWEsSUFBYixFQUFrQixNQUFsQixFQUF5QixFQUF6QixNQUFpQyw4Q0FBckMsRUFBcUY7QUFDakYsd0JBQVEsRUFBUjtBQUNBO0FBQ0E7QUFDQSx3QkFBUyxDQUFUOztBQUVBO0FBQ0Esa0JBQUksV0FBWSxLQUFLLFFBQUwsSUFBaUIsR0FBakM7QUFDQSxtQkFBSyxhQUFMLEdBQXFCLElBQXJCOztBQUVBLDBCQUFZLENBQUMsQ0FBQyxLQUFLLFFBQUwsS0FBa0IsRUFBbkIsS0FDQyxLQUFLLFFBQUwsS0FBa0IsRUFEbkIsS0FFQyxLQUFLLFFBQUwsS0FBbUIsQ0FGcEIsSUFHQSxLQUFLLFFBQUwsQ0FIRCxJQUdrQixFQUg5Qjs7QUFLQSxrQkFBSSxRQUFKLEVBQWM7QUFDViw2QkFBZSxXQUFmLENBRFUsQ0FDa0I7QUFDL0I7QUFDRCwwQkFBWSxLQUFLLEtBQUwsQ0FBVyxTQUFYLENBQVo7QUFDQSw2QkFBTyxLQUFQLDJCQUFxQyxTQUFyQztBQUNBLG1CQUFLLFVBQUwsR0FBa0IsU0FBbEI7QUFDSDtBQUNEO0FBQ0o7QUFDSTtBQTVCTjtBQThCRDtBQUNGOzs7d0JBRWtCO0FBQ2pCLGFBQU8sS0FBSyxhQUFaO0FBQ0Q7Ozt3QkFFZTtBQUNkLGFBQU8sS0FBSyxVQUFaO0FBQ0Q7Ozt3QkFFWTtBQUNYLGFBQU8sS0FBSyxPQUFaO0FBQ0Q7Ozt3QkFFYTtBQUNaLGFBQU8sS0FBSyxRQUFaO0FBQ0Q7Ozs7OztrQkFJWSxHOzs7Ozs7Ozs7cWpCQzlIZjs7Ozs7Ozs7Ozs7QUFjQTs7O0FBSEM7Ozs7QUFDQTs7OztBQUNBOzs7O0FBRUE7O0FBQ0E7Ozs7OztJQUVNLFM7QUFFTCxxQkFBWSxRQUFaLEVBQXNCLEVBQXRCLEVBQTBCLFlBQTFCLEVBQXdDLE1BQXhDLEVBQWdELGFBQWhELEVBQStEO0FBQUE7O0FBQzdELFNBQUssUUFBTCxHQUFnQixRQUFoQjtBQUNBLFNBQUssRUFBTCxHQUFVLEVBQVY7QUFDQSxTQUFLLFlBQUwsR0FBb0IsWUFBcEI7QUFDQSxTQUFLLE1BQUwsR0FBYyxNQUFkO0FBQ0EsU0FBSyxhQUFMLEdBQXFCLGFBQXJCO0FBQ0EsU0FBSyxNQUFMLEdBQWMsQ0FBZDtBQUNBLFNBQUssT0FBTCxHQUFlLElBQUksS0FBSyxZQUFULENBQXNCLFFBQXRCLEVBQWdDLEVBQWhDLEVBQW9DLE1BQXBDLEVBQTRDLGFBQTVDLENBQWY7QUFDRDs7OztrQ0FXYTtBQUNaLFdBQUssU0FBTCxHQUFpQixLQUFqQjtBQUNBLFdBQUssTUFBTCxHQUFjLENBQUMsQ0FBZjtBQUNBLFdBQUssU0FBTCxHQUFpQixFQUFDLFdBQVksWUFBYixFQUEyQixNQUFNLE9BQWpDLEVBQTBDLElBQUksQ0FBQyxDQUEvQyxFQUFrRCxnQkFBZ0IsQ0FBbEUsRUFBcUUsU0FBVSxFQUEvRSxFQUFtRixLQUFNLENBQXpGLEVBQTRGLFNBQVUsQ0FBdEcsRUFBakI7QUFDQSxXQUFLLFdBQUwsR0FBbUIsRUFBQyxXQUFZLFlBQWIsRUFBMkIsTUFBTSxPQUFqQyxFQUEwQyxJQUFJLENBQUMsQ0FBL0MsRUFBa0QsZ0JBQWdCLENBQWxFLEVBQXFFLFNBQVUsRUFBL0UsRUFBbUYsS0FBTSxDQUF6RixFQUE0RixPQUFPLElBQW5HLEVBQW5CO0FBQ0EsV0FBSyxTQUFMLEdBQWlCLEVBQUMsTUFBTSxLQUFQLEVBQWMsSUFBSSxDQUFDLENBQW5CLEVBQXNCLGdCQUFnQixDQUF0QyxFQUF5QyxTQUFVLEVBQW5ELEVBQXVELEtBQU0sQ0FBN0QsRUFBakI7QUFDQSxXQUFLLFNBQUwsR0FBaUIsRUFBQyxNQUFNLE1BQVAsRUFBZSxJQUFJLENBQUMsQ0FBcEIsRUFBdUIsZ0JBQWdCLENBQXZDLEVBQTBDLFNBQVUsRUFBcEQsRUFBd0QsS0FBTSxDQUE5RCxFQUFqQjtBQUNBO0FBQ0EsV0FBSyxXQUFMLEdBQW1CLElBQW5CO0FBQ0EsV0FBSyxVQUFMLEdBQWtCLElBQWxCO0FBQ0EsV0FBSyxTQUFMLEdBQWlCLElBQWpCO0FBQ0EsV0FBSyxPQUFMLENBQWEsV0FBYjtBQUNEOzs7MENBRXFCO0FBQ3BCLFdBQUssV0FBTDtBQUNBLFdBQUssT0FBTCxDQUFhLG1CQUFiO0FBQ0Q7O0FBRUQ7Ozs7eUJBQ0ssSSxFQUFNLFUsRUFBWSxVLEVBQVksVSxFQUFZLEUsRUFBSSxLLEVBQU8sRSxFQUFJLFEsRUFBUyxrQixFQUFtQixjLEVBQWdCO0FBQ3hHLFVBQUksS0FBSjtBQUFBLFVBQVcsTUFBTSxLQUFLLE1BQXRCO0FBQUEsVUFBOEIsR0FBOUI7QUFBQSxVQUFtQyxHQUFuQztBQUFBLFVBQXdDLEdBQXhDO0FBQUEsVUFBNkMsTUFBN0M7QUFBQSxVQUFvRCxHQUFwRDtBQUFBLFVBQ0ksYUFBYSxLQUFLLE9BQUwsQ0FBYSxXQUQ5QjtBQUFBLFVBRUksY0FBYyxLQUZsQjs7QUFJQSxXQUFLLFVBQUwsR0FBa0IsVUFBbEI7QUFDQSxXQUFLLFVBQUwsR0FBa0IsVUFBbEI7QUFDQSxXQUFLLFNBQUwsR0FBaUIsUUFBakI7QUFDQSxXQUFLLFVBQUwsR0FBa0IsS0FBbEI7QUFDQSxXQUFLLGtCQUFMLEdBQTBCLGtCQUExQjtBQUNBLFVBQUksT0FBTyxLQUFLLE1BQWhCLEVBQXdCO0FBQ3RCLHVCQUFPLEdBQVAsQ0FBVyx3QkFBWDtBQUNBLGFBQUssbUJBQUw7QUFDQSxhQUFLLE1BQUwsR0FBYyxFQUFkO0FBQ0Q7QUFDRCxVQUFJLFVBQVUsS0FBSyxTQUFuQixFQUE4QjtBQUM1Qix1QkFBTyxHQUFQLENBQVcsdUJBQVg7QUFDQSxhQUFLLFdBQUw7QUFDQSxhQUFLLFNBQUwsR0FBaUIsS0FBakI7QUFDRCxPQUpELE1BSU8sSUFBSSxPQUFRLEtBQUssTUFBTCxHQUFZLENBQXhCLEVBQTRCO0FBQ2pDLGFBQUssVUFBTCxHQUFrQixJQUFsQjtBQUNEO0FBQ0QsV0FBSyxNQUFMLEdBQWMsRUFBZDs7QUFFQSxVQUFJLFlBQVksS0FBSyxTQUFyQjtBQUFBLFVBQ0ksV0FBVyxLQUFLLFNBRHBCO0FBQUEsVUFFSSxhQUFhLEtBQUssV0FGdEI7QUFBQSxVQUdJLFdBQVcsS0FBSyxTQUhwQjtBQUFBLFVBSUksUUFBUSxTQUFTLEVBSnJCO0FBQUEsVUFLSSxVQUFVLFdBQVcsRUFMekI7QUFBQSxVQU1JLFFBQVEsU0FBUyxFQU5yQjtBQUFBLFVBT0ksUUFBUSxLQUFLLE1BUGpCO0FBQUEsVUFRSSxVQUFVLFNBQVMsT0FSdkI7QUFBQSxVQVNJLFlBQVksV0FBVyxPQVQzQjtBQUFBLFVBVUksVUFBVSxTQUFTLE9BVnZCO0FBQUEsVUFXSSxXQUFXLEtBQUssU0FYcEI7QUFBQSxVQVlJLFdBQVcsS0FBSyxTQVpwQjtBQUFBLFVBYUksV0FBVyxLQUFLLFNBYnBCO0FBQUEsVUFjSSxjQUFjLEtBQUssWUFBTCxDQUFrQixJQUFsQixDQUF1QixJQUF2QixDQWRsQjtBQUFBLFVBZUksY0FBYyxLQUFLLFlBQUwsQ0FBa0IsSUFBbEIsQ0FBdUIsSUFBdkIsQ0FmbEI7QUFBQSxVQWdCSSxlQUFlLEtBQUssYUFBTCxDQUFtQixJQUFuQixDQUF3QixJQUF4QixDQWhCbkI7QUFBQSxVQWlCSSxjQUFlLEtBQUssWUFBTCxDQUFrQixJQUFsQixDQUF1QixJQUF2QixDQWpCbkI7O0FBbUJBO0FBQ0EsYUFBTyxNQUFNLEdBQWI7QUFDQTtBQUNBLFdBQUssUUFBUSxDQUFiLEVBQWdCLFFBQVEsR0FBeEIsRUFBNkIsU0FBUyxHQUF0QyxFQUEyQztBQUN6QyxZQUFJLEtBQUssS0FBTCxNQUFnQixJQUFwQixFQUEwQjtBQUN4QixnQkFBTSxDQUFDLEVBQUUsS0FBSyxRQUFRLENBQWIsSUFBa0IsSUFBcEIsQ0FBUDtBQUNBO0FBQ0EsZ0JBQU0sQ0FBQyxDQUFDLEtBQUssUUFBUSxDQUFiLElBQWtCLElBQW5CLEtBQTRCLENBQTdCLElBQWtDLEtBQUssUUFBUSxDQUFiLENBQXhDO0FBQ0EsZ0JBQU0sQ0FBQyxLQUFLLFFBQVEsQ0FBYixJQUFrQixJQUFuQixLQUE0QixDQUFsQztBQUNBO0FBQ0EsY0FBSSxNQUFNLENBQVYsRUFBYTtBQUNYLHFCQUFTLFFBQVEsQ0FBUixHQUFZLEtBQUssUUFBUSxDQUFiLENBQXJCO0FBQ0E7QUFDQSxnQkFBSSxXQUFZLFFBQVEsR0FBeEIsRUFBOEI7QUFDNUI7QUFDRDtBQUNGLFdBTkQsTUFNTztBQUNMLHFCQUFTLFFBQVEsQ0FBakI7QUFDRDtBQUNELGtCQUFPLEdBQVA7QUFDRSxpQkFBSyxLQUFMO0FBQ0Usa0JBQUksR0FBSixFQUFTO0FBQ1Asb0JBQUksWUFBWSxNQUFNLFNBQVMsT0FBVCxDQUFsQixDQUFKLEVBQTBDO0FBQ3hDLDhCQUFZLEdBQVosRUFBZ0IsS0FBaEI7QUFDQSxzQkFBSSxVQUFKLEVBQWdCO0FBQ2Q7QUFDQTtBQUNBO0FBQ0Esd0JBQUksU0FBUyxLQUFULEtBQW1CLFlBQVksQ0FBQyxDQUFiLElBQWtCLFdBQVcsS0FBaEQsQ0FBSixFQUE0RDtBQUMxRCwyQkFBSyxLQUFMLENBQVcsS0FBWCxFQUFpQixFQUFqQixFQUFvQixFQUFwQixFQUF1QixJQUF2QixFQUE0QixVQUE1QjtBQUNBO0FBQ0Q7QUFDRjtBQUNGO0FBQ0QsMEJBQVUsRUFBQyxNQUFNLEVBQVAsRUFBVyxNQUFNLENBQWpCLEVBQVY7QUFDRDtBQUNELGtCQUFJLE9BQUosRUFBYTtBQUNYLHdCQUFRLElBQVIsQ0FBYSxJQUFiLENBQWtCLEtBQUssUUFBTCxDQUFjLE1BQWQsRUFBc0IsUUFBUSxHQUE5QixDQUFsQjtBQUNBLHdCQUFRLElBQVIsSUFBZ0IsUUFBUSxHQUFSLEdBQWMsTUFBOUI7QUFDRDtBQUNEO0FBQ0YsaUJBQUssT0FBTDtBQUNFLGtCQUFJLEdBQUosRUFBUztBQUNQLG9CQUFJLGNBQWMsTUFBTSxTQUFTLFNBQVQsQ0FBcEIsQ0FBSixFQUE4QztBQUM1QyxzQkFBSSxXQUFXLEtBQWYsRUFBc0I7QUFDcEIsZ0NBQVksR0FBWjtBQUNELG1CQUZELE1BRU87QUFDTCxpQ0FBYSxHQUFiO0FBQ0Q7QUFDRCxzQkFBSSxVQUFKLEVBQWdCO0FBQ2Q7QUFDQTtBQUNBO0FBQ0Esd0JBQUksV0FBVyxLQUFYLEtBQXFCLFVBQVUsQ0FBQyxDQUFYLElBQWdCLFNBQVMsS0FBOUMsQ0FBSixFQUEwRDtBQUN4RCwyQkFBSyxLQUFMLENBQVcsS0FBWCxFQUFpQixFQUFqQixFQUFvQixFQUFwQixFQUF1QixJQUF2QixFQUE0QixVQUE1QjtBQUNBO0FBQ0Q7QUFDRjtBQUNGO0FBQ0QsNEJBQVksRUFBQyxNQUFNLEVBQVAsRUFBVyxNQUFNLENBQWpCLEVBQVo7QUFDRDtBQUNELGtCQUFJLFNBQUosRUFBZTtBQUNiLDBCQUFVLElBQVYsQ0FBZSxJQUFmLENBQW9CLEtBQUssUUFBTCxDQUFjLE1BQWQsRUFBc0IsUUFBUSxHQUE5QixDQUFwQjtBQUNBLDBCQUFVLElBQVYsSUFBa0IsUUFBUSxHQUFSLEdBQWMsTUFBaEM7QUFDRDtBQUNEO0FBQ0YsaUJBQUssS0FBTDtBQUNFLGtCQUFJLEdBQUosRUFBUztBQUNQLG9CQUFJLFlBQVksTUFBTSxTQUFTLE9BQVQsQ0FBbEIsQ0FBSixFQUEwQztBQUN4Qyw4QkFBWSxHQUFaO0FBQ0Q7QUFDRCwwQkFBVSxFQUFDLE1BQU0sRUFBUCxFQUFXLE1BQU0sQ0FBakIsRUFBVjtBQUNEO0FBQ0Qsa0JBQUksT0FBSixFQUFhO0FBQ1gsd0JBQVEsSUFBUixDQUFhLElBQWIsQ0FBa0IsS0FBSyxRQUFMLENBQWMsTUFBZCxFQUFzQixRQUFRLEdBQTlCLENBQWxCO0FBQ0Esd0JBQVEsSUFBUixJQUFnQixRQUFRLEdBQVIsR0FBYyxNQUE5QjtBQUNEO0FBQ0Q7QUFDRixpQkFBSyxDQUFMO0FBQ0Usa0JBQUksR0FBSixFQUFTO0FBQ1AsMEJBQVUsS0FBSyxNQUFMLElBQWUsQ0FBekI7QUFDRDtBQUNELHNCQUFRLEtBQUssTUFBTCxHQUFjLFNBQVMsSUFBVCxFQUFlLE1BQWYsQ0FBdEI7QUFDQTtBQUNGLGlCQUFLLEtBQUw7QUFDRSxrQkFBSSxHQUFKLEVBQVM7QUFDUCwwQkFBVSxLQUFLLE1BQUwsSUFBZSxDQUF6QjtBQUNEO0FBQ0Qsa0JBQUksYUFBYSxTQUFTLElBQVQsRUFBZSxNQUFmLEVBQXVCLEtBQUssYUFBTCxDQUFtQixJQUFuQixLQUE0QixJQUE1QixJQUFvQyxLQUFLLGFBQUwsQ0FBbUIsR0FBbkIsS0FBMkIsSUFBdEYsQ0FBakI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBUSxXQUFXLEdBQW5CO0FBQ0Esa0JBQUksUUFBUSxDQUFaLEVBQWU7QUFDYix5QkFBUyxFQUFULEdBQWMsS0FBZDtBQUNEO0FBQ0Qsd0JBQVUsV0FBVyxLQUFyQjtBQUNBLGtCQUFJLFVBQVUsQ0FBZCxFQUFpQjtBQUNmLDJCQUFXLEVBQVgsR0FBZ0IsT0FBaEI7QUFDQSwyQkFBVyxLQUFYLEdBQW1CLFdBQVcsS0FBOUI7QUFDRDtBQUNELHNCQUFRLFdBQVcsR0FBbkI7QUFDQSxrQkFBSSxRQUFRLENBQVosRUFBZTtBQUNiLHlCQUFTLEVBQVQsR0FBYyxLQUFkO0FBQ0Q7QUFDRCxrQkFBSSxlQUFlLENBQUMsU0FBcEIsRUFBK0I7QUFDN0IsK0JBQU8sR0FBUCxDQUFXLHdCQUFYO0FBQ0EsOEJBQWMsS0FBZDtBQUNBO0FBQ0Esd0JBQVEsQ0FBQyxHQUFUO0FBQ0Q7QUFDRCwwQkFBWSxLQUFLLFNBQUwsR0FBaUIsSUFBN0I7QUFDQTtBQUNGLGlCQUFLLEVBQUw7QUFDQSxpQkFBSyxNQUFMO0FBQ0U7QUFDRjtBQUNFLDRCQUFjLElBQWQ7QUFDQTtBQXJHSjtBQXVHRCxTQXRIRCxNQXNITztBQUNMLGVBQUssUUFBTCxDQUFjLE9BQWQsQ0FBc0IsaUJBQU0sS0FBNUIsRUFBbUMsRUFBQyxNQUFPLG1CQUFXLFdBQW5CLEVBQWdDLElBQUssS0FBSyxFQUExQyxFQUE4QyxTQUFTLHFCQUFhLGtCQUFwRSxFQUF3RixPQUFPLEtBQS9GLEVBQXNHLFFBQVEsbUNBQTlHLEVBQW5DO0FBQ0Q7QUFDRjtBQUNEO0FBQ0EsVUFBSSxZQUFZLE1BQU0sU0FBUyxPQUFULENBQWxCLENBQUosRUFBMEM7QUFDeEMsb0JBQVksR0FBWixFQUFnQixJQUFoQjtBQUNBLGlCQUFTLE9BQVQsR0FBbUIsSUFBbkI7QUFDRCxPQUhELE1BR087QUFDTDtBQUNBLGlCQUFTLE9BQVQsR0FBbUIsT0FBbkI7QUFDRDs7QUFFRCxVQUFJLGNBQWMsTUFBTSxTQUFTLFNBQVQsQ0FBcEIsQ0FBSixFQUE4QztBQUM1QyxZQUFJLFdBQVcsS0FBZixFQUFzQjtBQUNwQixzQkFBWSxHQUFaO0FBQ0QsU0FGRCxNQUVPO0FBQ0wsdUJBQWEsR0FBYjtBQUNEO0FBQ0QsbUJBQVcsT0FBWCxHQUFxQixJQUFyQjtBQUNELE9BUEQsTUFPTztBQUNMLFlBQUksYUFBYSxVQUFVLElBQTNCLEVBQWlDO0FBQy9CLHlCQUFPLEdBQVAsQ0FBVywrREFBWDtBQUNEO0FBQ0Y7QUFDQyxtQkFBVyxPQUFYLEdBQXFCLFNBQXJCO0FBQ0Q7O0FBRUQsVUFBSSxZQUFZLE1BQU0sU0FBUyxPQUFULENBQWxCLENBQUosRUFBMEM7QUFDeEMsb0JBQVksR0FBWjtBQUNBLGlCQUFTLE9BQVQsR0FBbUIsSUFBbkI7QUFDRCxPQUhELE1BR087QUFDTDtBQUNBLGlCQUFTLE9BQVQsR0FBbUIsT0FBbkI7QUFDRDtBQUNELFdBQUssS0FBTCxDQUFXLEtBQVgsRUFBaUIsRUFBakIsRUFBb0IsRUFBcEIsRUFBdUIsSUFBdkIsRUFBNEIsVUFBNUIsRUFBdUMsY0FBdkM7QUFDRDs7OzBCQUVLLEssRUFBTyxFLEVBQUksRSxFQUFJLEksRUFBTSxVLEVBQVcsYyxFQUFnQjtBQUNwRCxVQUFJLFdBQVcsS0FBSyxTQUFwQjtBQUFBLFVBQStCLFVBQVUsU0FBUyxPQUFsRDtBQUFBLFVBQTJELFNBQVMsQ0FBcEU7QUFBQSxVQUF1RSxVQUFVLENBQWpGOztBQUVBO0FBQ0EsV0FBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLFFBQVEsTUFBNUIsRUFBb0MsR0FBcEMsRUFBeUM7QUFDdkMsWUFBSSxTQUFTLFFBQVEsQ0FBUixDQUFiO0FBQUEsWUFBeUIsUUFBUSxPQUFPLEtBQVAsQ0FBYSxLQUE5QztBQUFBLFlBQXFELFVBQVUsTUFBTSxNQUFyRTtBQUFBLFlBQTZFLFlBQVksQ0FBekY7QUFDQSxhQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksT0FBcEIsRUFBNkIsR0FBN0IsRUFBa0M7QUFDaEMsdUJBQWEsTUFBTSxDQUFOLEVBQVMsSUFBVCxDQUFjLE1BQTNCO0FBQ0Q7QUFDRCxtQkFBVyxTQUFYO0FBQ0Esa0JBQVUsT0FBVjtBQUNBLGVBQU8sTUFBUCxHQUFnQixTQUFoQjtBQUNEO0FBQ0QsZUFBUyxHQUFULEdBQWUsT0FBZjtBQUNBLGVBQVMsTUFBVCxHQUFrQixNQUFsQjtBQUNBLFdBQUssT0FBTCxDQUFhLEtBQWIsQ0FBbUIsS0FBbkIsRUFBMEIsRUFBMUIsRUFBOEIsRUFBOUIsRUFBa0MsS0FBSyxXQUF2QyxFQUFvRCxLQUFLLFNBQXpELEVBQW9FLEtBQUssU0FBekUsRUFBb0YsS0FBSyxTQUF6RixFQUFvRyxVQUFwRyxFQUFnSCxLQUFLLFVBQXJILEVBQWlJLEtBQUssa0JBQXRJLEVBQTBKLGNBQTFKLEVBQTBLLElBQTFLO0FBQ0Q7Ozs4QkFFUztBQUNSLFdBQUssV0FBTDtBQUNBLFdBQUssUUFBTCxHQUFnQixLQUFLLFFBQUwsR0FBZ0IsU0FBaEM7QUFDQSxXQUFLLFNBQUwsR0FBaUIsQ0FBakI7QUFDRDs7OzhCQUVTLEksRUFBTSxNLEVBQVE7QUFDdEI7QUFDQSxhQUFPLENBQUMsS0FBSyxTQUFTLEVBQWQsSUFBb0IsSUFBckIsS0FBOEIsQ0FBOUIsR0FBa0MsS0FBSyxTQUFTLEVBQWQsQ0FBekM7QUFDQTtBQUNEOzs7OEJBRVMsSSxFQUFNLE0sRUFBUSxhLEVBQWU7QUFDckMsVUFBSSxhQUFKO0FBQUEsVUFBbUIsUUFBbkI7QUFBQSxVQUE2QixpQkFBN0I7QUFBQSxVQUFnRCxHQUFoRDtBQUFBLFVBQXFELFNBQVMsRUFBRSxPQUFRLENBQUMsQ0FBWCxFQUFjLEtBQU0sQ0FBQyxDQUFyQixFQUF3QixLQUFNLENBQUMsQ0FBL0IsRUFBa0MsT0FBUSxJQUExQyxFQUE5RDtBQUNBLHNCQUFnQixDQUFDLEtBQUssU0FBUyxDQUFkLElBQW1CLElBQXBCLEtBQTZCLENBQTdCLEdBQWlDLEtBQUssU0FBUyxDQUFkLENBQWpEO0FBQ0EsaUJBQVcsU0FBUyxDQUFULEdBQWEsYUFBYixHQUE2QixDQUF4QztBQUNBO0FBQ0E7QUFDQSwwQkFBb0IsQ0FBQyxLQUFLLFNBQVMsRUFBZCxJQUFvQixJQUFyQixLQUE4QixDQUE5QixHQUFrQyxLQUFLLFNBQVMsRUFBZCxDQUF0RDtBQUNBO0FBQ0EsZ0JBQVUsS0FBSyxpQkFBZjtBQUNBLGFBQU8sU0FBUyxRQUFoQixFQUEwQjtBQUN4QixjQUFNLENBQUMsS0FBSyxTQUFTLENBQWQsSUFBbUIsSUFBcEIsS0FBNkIsQ0FBN0IsR0FBaUMsS0FBSyxTQUFTLENBQWQsQ0FBdkM7QUFDQSxnQkFBTyxLQUFLLE1BQUwsQ0FBUDtBQUNFO0FBQ0EsZUFBSyxJQUFMO0FBQ0U7QUFDQSxnQkFBSSxPQUFPLEtBQVAsS0FBaUIsQ0FBQyxDQUF0QixFQUF5QjtBQUN2QixxQkFBTyxLQUFQLEdBQWUsR0FBZjtBQUNEO0FBQ0Q7QUFDRjtBQUNBLGVBQUssSUFBTDtBQUNFO0FBQ0EsZ0JBQUksT0FBTyxHQUFQLEtBQWUsQ0FBQyxDQUFwQixFQUF1QjtBQUNyQixxQkFBTyxHQUFQLEdBQWEsR0FBYjtBQUNEO0FBQ0Q7QUFDRjtBQUNBLGVBQUssSUFBTDtBQUNFO0FBQ0EsZ0JBQUksT0FBTyxHQUFQLEtBQWUsQ0FBQyxDQUFwQixFQUF1QjtBQUNyQixxQkFBTyxHQUFQLEdBQWEsR0FBYjtBQUNEO0FBQ0Q7QUFDRjtBQUNBO0FBQ0EsZUFBSyxJQUFMO0FBQ0EsZUFBSyxJQUFMO0FBQ0U7QUFDQSxnQkFBSSxDQUFDLGFBQUwsRUFBb0I7QUFDbEIsNkJBQU8sR0FBUCxDQUFXLHlEQUFYO0FBQ0QsYUFGRCxNQUVPLElBQUksT0FBTyxLQUFQLEtBQWlCLENBQUMsQ0FBdEIsRUFBeUI7QUFDOUIscUJBQU8sS0FBUCxHQUFlLEdBQWY7QUFDQSxxQkFBTyxLQUFQLEdBQWUsS0FBZjtBQUNEO0FBQ0Q7QUFDRixlQUFLLElBQUw7QUFDRSwyQkFBTyxJQUFQLENBQVksK0NBQVo7QUFDQTtBQUNGO0FBQ0UsMkJBQU8sR0FBUCxDQUFXLHdCQUF5QixLQUFLLE1BQUwsQ0FBcEM7QUFDQTtBQXZDSjtBQXlDQTtBQUNBO0FBQ0Esa0JBQVUsQ0FBQyxDQUFDLEtBQUssU0FBUyxDQUFkLElBQW1CLElBQXBCLEtBQTZCLENBQTdCLEdBQWlDLEtBQUssU0FBUyxDQUFkLENBQWxDLElBQXNELENBQWhFO0FBQ0Q7QUFDRCxhQUFPLE1BQVA7QUFDRDs7OzhCQUVTLE0sRUFBUTtBQUNoQixVQUFJLElBQUksQ0FBUjtBQUFBLFVBQVcsSUFBWDtBQUFBLFVBQWlCLFFBQWpCO0FBQUEsVUFBMkIsU0FBM0I7QUFBQSxVQUFzQyxNQUF0QztBQUFBLFVBQThDLFNBQTlDO0FBQUEsVUFBeUQsT0FBekQ7QUFBQSxVQUFrRSxNQUFsRTtBQUFBLFVBQTBFLE1BQTFFO0FBQUEsVUFBa0Ysa0JBQWxGO0FBQUEsVUFBc0csT0FBTyxPQUFPLElBQXBIO0FBQ0E7QUFDQSxVQUFJLENBQUMsTUFBRCxJQUFXLE9BQU8sSUFBUCxLQUFnQixDQUEvQixFQUFrQztBQUNoQyxlQUFPLElBQVA7QUFDRDs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxhQUFNLEtBQUssQ0FBTCxFQUFRLE1BQVIsR0FBaUIsRUFBakIsSUFBdUIsS0FBSyxNQUFMLEdBQWMsQ0FBM0MsRUFBOEM7QUFDNUMsWUFBSSxVQUFVLElBQUksVUFBSixDQUFlLEtBQUssQ0FBTCxFQUFRLE1BQVIsR0FBaUIsS0FBSyxDQUFMLEVBQVEsTUFBeEMsQ0FBZDtBQUNBLGdCQUFRLEdBQVIsQ0FBWSxLQUFLLENBQUwsQ0FBWjtBQUNBLGdCQUFRLEdBQVIsQ0FBWSxLQUFLLENBQUwsQ0FBWixFQUFxQixLQUFLLENBQUwsRUFBUSxNQUE3QjtBQUNBLGFBQUssQ0FBTCxJQUFVLE9BQVY7QUFDQSxhQUFLLE1BQUwsQ0FBWSxDQUFaLEVBQWMsQ0FBZDtBQUNEO0FBQ0Q7QUFDQSxhQUFPLEtBQUssQ0FBTCxDQUFQO0FBQ0Esa0JBQVksQ0FBQyxLQUFLLENBQUwsS0FBVyxFQUFaLEtBQW1CLEtBQUssQ0FBTCxLQUFXLENBQTlCLElBQW1DLEtBQUssQ0FBTCxDQUEvQztBQUNBLFVBQUksY0FBYyxDQUFsQixFQUFxQjtBQUNuQixpQkFBUyxDQUFDLEtBQUssQ0FBTCxLQUFXLENBQVosSUFBaUIsS0FBSyxDQUFMLENBQTFCO0FBQ0E7QUFDQTtBQUNBLFlBQUksVUFBVSxTQUFTLE9BQU8sSUFBUCxHQUFjLENBQXJDLEVBQXdDO0FBQ3RDLGlCQUFPLElBQVA7QUFDRDtBQUNELG1CQUFXLEtBQUssQ0FBTCxDQUFYO0FBQ0EsWUFBSSxXQUFXLElBQWYsRUFBcUI7QUFDbkI7OztBQUdBLG1CQUFTLENBQUMsS0FBSyxDQUFMLElBQVUsSUFBWCxJQUFtQixTQUFuQixHQUE4QjtBQUNyQyxXQUFDLEtBQUssRUFBTCxJQUFXLElBQVosSUFBb0IsT0FEYixHQUNzQjtBQUM3QixXQUFDLEtBQUssRUFBTCxJQUFXLElBQVosSUFBb0IsS0FGYixHQUVvQjtBQUMzQixXQUFDLEtBQUssRUFBTCxJQUFXLElBQVosSUFBb0IsR0FIYixHQUdrQjtBQUN6QixXQUFDLEtBQUssRUFBTCxJQUFXLElBQVosSUFBb0IsQ0FKdEI7QUFLRTtBQUNBLGNBQUksU0FBUyxVQUFiLEVBQXlCO0FBQ3ZCO0FBQ0Esc0JBQVUsVUFBVjtBQUNEO0FBQ0gsY0FBSSxXQUFXLElBQWYsRUFBcUI7QUFDbkIscUJBQVMsQ0FBQyxLQUFLLEVBQUwsSUFBVyxJQUFaLElBQXFCLFNBQXJCLEdBQWdDO0FBQ3ZDLGFBQUMsS0FBSyxFQUFMLElBQVcsSUFBWixJQUFxQixPQURkLEdBQ3VCO0FBQzlCLGFBQUMsS0FBSyxFQUFMLElBQVcsSUFBWixJQUFxQixLQUZkLEdBRXFCO0FBQzVCLGFBQUMsS0FBSyxFQUFMLElBQVcsSUFBWixJQUFxQixHQUhkLEdBR21CO0FBQzFCLGFBQUMsS0FBSyxFQUFMLElBQVcsSUFBWixJQUFxQixDQUp2QjtBQUtBO0FBQ0EsZ0JBQUksU0FBUyxVQUFiLEVBQXlCO0FBQ3ZCO0FBQ0Esd0JBQVUsVUFBVjtBQUNEO0FBQ0QsZ0JBQUksU0FBUyxNQUFULEdBQWtCLEtBQUcsS0FBekIsRUFBZ0M7QUFDOUIsNkJBQU8sSUFBUCxDQUFlLEtBQUssS0FBTCxDQUFXLENBQUMsU0FBUyxNQUFWLElBQWtCLEtBQTdCLENBQWY7QUFDQSx1QkFBUyxNQUFUO0FBQ0Q7QUFDRixXQWZELE1BZU87QUFDTCxxQkFBUyxNQUFUO0FBQ0Q7QUFDRjtBQUNELG9CQUFZLEtBQUssQ0FBTCxDQUFaO0FBQ0E7QUFDQSw2QkFBcUIsWUFBWSxDQUFqQzs7QUFFQSxlQUFPLElBQVAsSUFBZSxrQkFBZjtBQUNBO0FBQ0Esa0JBQVUsSUFBSSxVQUFKLENBQWUsT0FBTyxJQUF0QixDQUFWO0FBQ0EsYUFBSyxJQUFJLElBQUksQ0FBUixFQUFXLFVBQVUsS0FBSyxNQUEvQixFQUF1QyxJQUFJLE9BQTNDLEVBQXFELEdBQXJELEVBQTBEO0FBQ3hELGlCQUFPLEtBQUssQ0FBTCxDQUFQO0FBQ0EsY0FBSSxNQUFNLEtBQUssVUFBZjtBQUNBLGNBQUksa0JBQUosRUFBd0I7QUFDdEIsZ0JBQUkscUJBQXFCLEdBQXpCLEVBQThCO0FBQzVCO0FBQ0Esb0NBQW9CLEdBQXBCO0FBQ0E7QUFDRCxhQUpELE1BSU87QUFDTDtBQUNBLHFCQUFPLEtBQUssUUFBTCxDQUFjLGtCQUFkLENBQVA7QUFDQSxxQkFBSyxrQkFBTDtBQUNBLG1DQUFxQixDQUFyQjtBQUNEO0FBQ0Y7QUFDRCxrQkFBUSxHQUFSLENBQVksSUFBWixFQUFrQixDQUFsQjtBQUNBLGVBQUcsR0FBSDtBQUNEO0FBQ0QsWUFBSSxNQUFKLEVBQVk7QUFDVjtBQUNBLG9CQUFVLFlBQVUsQ0FBcEI7QUFDRDtBQUNELGVBQU8sRUFBQyxNQUFNLE9BQVAsRUFBZ0IsS0FBSyxNQUFyQixFQUE2QixLQUFLLE1BQWxDLEVBQTBDLEtBQUssTUFBL0MsRUFBUDtBQUNELE9BdkVELE1BdUVPO0FBQ0wsZUFBTyxJQUFQO0FBQ0Q7QUFDRjs7O2tDQUVhLFMsRUFBVSxRLEVBQVU7QUFDaEMsVUFBSSxVQUFVLEtBQVYsQ0FBZ0IsS0FBaEIsQ0FBc0IsTUFBdEIsSUFBZ0MsVUFBVSxLQUE5QyxFQUFxRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQUksQ0FBQyxLQUFLLE1BQUwsQ0FBWSw0QkFBYixJQUNBLFVBQVUsR0FBVixLQUFrQixJQURsQixJQUVDLFNBQVMsR0FBVCxLQUFpQixTQUFTLE9BQVQsQ0FBaUIsTUFBakIsSUFBMkIsS0FBSyxVQUFqRCxDQUZMLEVBRW9FO0FBQ2xFLG1CQUFTLE9BQVQsQ0FBaUIsSUFBakIsQ0FBc0IsU0FBdEI7QUFDRCxTQUpELE1BSU87QUFDTDtBQUNBLG1CQUFTLE9BQVQ7QUFDRDtBQUNGO0FBQ0QsVUFBRyxVQUFVLEtBQVYsQ0FBZ0IsTUFBbkIsRUFBMkI7QUFDekIsdUJBQU8sR0FBUCxDQUFXLFVBQVUsR0FBVixHQUFnQixHQUFoQixHQUFzQixVQUFVLEdBQWhDLEdBQXNDLEdBQXRDLEdBQTRDLFVBQVUsS0FBdEQsR0FBOEQsR0FBOUQsR0FBb0UsVUFBVSxLQUFWLENBQWdCLE1BQS9GO0FBQ0Q7QUFDRjs7O2lDQUVZLEcsRUFBSSxJLEVBQU07QUFBQTs7QUFDckI7QUFDQSxVQUFJLFFBQVEsS0FBSyxTQUFqQjtBQUFBLFVBQ0ksUUFBUSxLQUFLLGFBQUwsQ0FBbUIsSUFBSSxJQUF2QixDQURaO0FBQUEsVUFFSSxRQUFRLEtBRlo7QUFBQSxVQUdJLGdCQUhKO0FBQUEsVUFJSSxZQUFZLEtBQUssU0FKckI7QUFBQSxVQUtJLElBTEo7QUFBQSxVQU1JLENBTko7QUFPQTtBQUNBLFVBQUksSUFBSixHQUFXLElBQVg7O0FBRUEsWUFBTSxPQUFOLENBQWMsZ0JBQVE7QUFDcEIsZ0JBQU8sS0FBSyxJQUFaO0FBQ0U7QUFDQyxlQUFLLENBQUw7QUFDRSxtQkFBTyxJQUFQO0FBQ0EsZ0JBQUcsU0FBUyxTQUFaLEVBQXVCO0FBQ3RCLHdCQUFVLEtBQVYsSUFBbUIsTUFBbkI7QUFDQTtBQUNELHNCQUFVLEtBQVYsR0FBa0IsSUFBbEI7QUFDQTtBQUNBLGdCQUFJLE9BQU8sS0FBSyxJQUFoQjtBQUNBLGdCQUFJLEtBQUssTUFBTCxHQUFjLENBQWxCLEVBQXFCO0FBQ25CLGtCQUFJLFlBQVksd0JBQWMsSUFBZCxFQUFvQixhQUFwQixFQUFoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBSSxjQUFjLENBQWQsSUFBbUIsY0FBYyxDQUFqQyxJQUFzQyxjQUFjLENBQXBELElBQXlELGNBQWMsQ0FBM0UsRUFBOEU7QUFDM0UsMEJBQVUsR0FBVixHQUFnQixJQUFoQjtBQUNGO0FBQ0Y7QUFDRDtBQUNIO0FBQ0EsZUFBSyxDQUFMO0FBQ0UsbUJBQU8sSUFBUDtBQUNBO0FBQ0EsZ0JBQUksQ0FBQyxTQUFMLEVBQWdCO0FBQ2QsMEJBQVksTUFBSyxTQUFMLEdBQWlCLE1BQUssZ0JBQUwsQ0FBc0IsSUFBdEIsRUFBMkIsSUFBSSxHQUEvQixFQUFtQyxJQUFJLEdBQXZDLEVBQTJDLEVBQTNDLENBQTdCO0FBQ0Q7QUFDRCxnQkFBRyxLQUFILEVBQVU7QUFDUix3QkFBVSxLQUFWLElBQW1CLE1BQW5CO0FBQ0Q7QUFDRCxzQkFBVSxHQUFWLEdBQWdCLElBQWhCO0FBQ0Esc0JBQVUsS0FBVixHQUFrQixJQUFsQjtBQUNBO0FBQ0Y7QUFDQSxlQUFLLENBQUw7QUFDRSxtQkFBTyxJQUFQO0FBQ0EsZ0JBQUcsU0FBUyxTQUFaLEVBQXVCO0FBQ3JCLHdCQUFVLEtBQVYsSUFBbUIsTUFBbkI7QUFDRDtBQUNELCtCQUFtQix3QkFBYyxNQUFLLFVBQUwsQ0FBZ0IsS0FBSyxJQUFyQixDQUFkLENBQW5COztBQUVBO0FBQ0EsNkJBQWlCLFNBQWpCOztBQUVBLGdCQUFJLGNBQWMsQ0FBbEI7QUFDQSxnQkFBSSxjQUFjLENBQWxCO0FBQ0EsZ0JBQUksZ0JBQWdCLEtBQXBCO0FBQ0EsZ0JBQUksSUFBSSxDQUFSOztBQUVBLG1CQUFPLENBQUMsYUFBRCxJQUFrQixpQkFBaUIsY0FBakIsR0FBa0MsQ0FBM0QsRUFBOEQ7QUFDNUQsNEJBQWMsQ0FBZDtBQUNBLGlCQUFHO0FBQ0Msb0JBQUksaUJBQWlCLFNBQWpCLEVBQUo7QUFDQSwrQkFBZSxDQUFmO0FBQ0gsZUFIRCxRQUdTLE1BQU0sSUFIZjs7QUFLQTtBQUNBLDRCQUFjLENBQWQ7QUFDQSxpQkFBRztBQUNDLG9CQUFJLGlCQUFpQixTQUFqQixFQUFKO0FBQ0EsK0JBQWUsQ0FBZjtBQUNILGVBSEQsUUFHUyxNQUFNLElBSGY7O0FBS0E7QUFDQTtBQUNBLGtCQUFJLGdCQUFnQixDQUFoQixJQUFxQixpQkFBaUIsY0FBakIsS0FBb0MsQ0FBN0QsRUFBZ0U7O0FBRTlELGdDQUFnQixJQUFoQjs7QUFFQSxvQkFBSSxjQUFjLGlCQUFpQixTQUFqQixFQUFsQjs7QUFFQSxvQkFBSSxnQkFBZ0IsR0FBcEIsRUFBeUI7QUFDdkIsc0JBQUksZUFBZSxpQkFBaUIsVUFBakIsRUFBbkI7O0FBRUEsc0JBQUksaUJBQWlCLEVBQXJCLEVBQXlCO0FBQ3ZCLHdCQUFJLGdCQUFnQixpQkFBaUIsUUFBakIsRUFBcEI7O0FBRUEsd0JBQUksa0JBQWtCLFVBQXRCLEVBQWtDO0FBQ2hDLDBCQUFJLGVBQWUsaUJBQWlCLFNBQWpCLEVBQW5COztBQUVBO0FBQ0EsMEJBQUksaUJBQWlCLENBQXJCLEVBQXdCO0FBQ3RCLDRCQUFJLFlBQVksaUJBQWlCLFNBQWpCLEVBQWhCO0FBQ0EsNEJBQUksYUFBYSxpQkFBaUIsU0FBakIsRUFBakI7O0FBRUEsNEJBQUksV0FBVyxLQUFLLFNBQXBCO0FBQ0EsNEJBQUksWUFBWSxDQUFDLFNBQUQsRUFBWSxVQUFaLENBQWhCOztBQUVBLDZCQUFLLElBQUksQ0FBVCxFQUFZLElBQUksUUFBaEIsRUFBMEIsR0FBMUIsRUFBK0I7QUFDN0I7QUFDQSxvQ0FBVSxJQUFWLENBQWUsaUJBQWlCLFNBQWpCLEVBQWY7QUFDQSxvQ0FBVSxJQUFWLENBQWUsaUJBQWlCLFNBQWpCLEVBQWY7QUFDQSxvQ0FBVSxJQUFWLENBQWUsaUJBQWlCLFNBQWpCLEVBQWY7QUFDRDs7QUFFRCw4QkFBSyxvQkFBTCxDQUEwQixNQUFLLFNBQUwsQ0FBZSxPQUF6QyxFQUFrRCxFQUFFLE1BQU0sQ0FBUixFQUFXLEtBQUssSUFBSSxHQUFwQixFQUF5QixPQUFPLFNBQWhDLEVBQWxEO0FBQ0Q7QUFDRjtBQUNGO0FBQ0Y7QUFDRixlQW5DRCxNQW9DSyxJQUFJLGNBQWMsaUJBQWlCLGNBQW5DLEVBQ0w7QUFDRSxxQkFBSyxJQUFJLENBQVQsRUFBWSxJQUFFLFdBQWQsRUFBMkIsR0FBM0IsRUFDQTtBQUNFLG1DQUFpQixTQUFqQjtBQUNEO0FBQ0Y7QUFDRjtBQUNEO0FBQ0Y7QUFDQSxlQUFLLENBQUw7QUFDRSxtQkFBTyxJQUFQO0FBQ0EsZ0JBQUcsU0FBUyxTQUFaLEVBQXVCO0FBQ3JCLHdCQUFVLEtBQVYsSUFBbUIsTUFBbkI7QUFDRDtBQUNELGdCQUFHLENBQUMsTUFBTSxHQUFWLEVBQWU7QUFDYixpQ0FBbUIsd0JBQWMsS0FBSyxJQUFuQixDQUFuQjtBQUNBLGtCQUFJLFNBQVMsaUJBQWlCLE9BQWpCLEVBQWI7QUFDQSxvQkFBTSxLQUFOLEdBQWMsT0FBTyxLQUFyQjtBQUNBLG9CQUFNLE1BQU4sR0FBZSxPQUFPLE1BQXRCO0FBQ0Esb0JBQU0sR0FBTixHQUFZLENBQUMsS0FBSyxJQUFOLENBQVo7QUFDQSxvQkFBTSxRQUFOLEdBQWlCLE1BQUssU0FBdEI7QUFDQSxrQkFBSSxhQUFhLEtBQUssSUFBTCxDQUFVLFFBQVYsQ0FBbUIsQ0FBbkIsRUFBc0IsQ0FBdEIsQ0FBakI7QUFDQSxrQkFBSSxjQUFjLE9BQWxCO0FBQ0EsbUJBQUssSUFBSSxDQUFULEVBQVksSUFBSSxDQUFoQixFQUFtQixHQUFuQixFQUF3QjtBQUN0QixvQkFBSSxJQUFJLFdBQVcsQ0FBWCxFQUFjLFFBQWQsQ0FBdUIsRUFBdkIsQ0FBUjtBQUNBLG9CQUFJLEVBQUUsTUFBRixHQUFXLENBQWYsRUFBa0I7QUFDaEIsc0JBQUksTUFBTSxDQUFWO0FBQ0Q7QUFDRCwrQkFBZSxDQUFmO0FBQ0Q7QUFDRCxvQkFBTSxLQUFOLEdBQWMsV0FBZDtBQUNEO0FBQ0Q7QUFDRjtBQUNBLGVBQUssQ0FBTDtBQUNFLG1CQUFPLElBQVA7QUFDQSxnQkFBRyxTQUFTLFNBQVosRUFBdUI7QUFDckIsd0JBQVUsS0FBVixJQUFtQixNQUFuQjtBQUNEO0FBQ0QsZ0JBQUksQ0FBQyxNQUFNLEdBQVgsRUFBZ0I7QUFDZCxvQkFBTSxHQUFOLEdBQVksQ0FBQyxLQUFLLElBQU4sQ0FBWjtBQUNEO0FBQ0Q7QUFDRjtBQUNBLGVBQUssQ0FBTDtBQUNFLG1CQUFPLEtBQVA7QUFDQSxnQkFBSSxTQUFKLEVBQWU7QUFDYixvQkFBSyxhQUFMLENBQW1CLFNBQW5CLEVBQTZCLEtBQTdCO0FBQ0Q7QUFDRCx3QkFBWSxNQUFLLFNBQUwsR0FBaUIsTUFBSyxnQkFBTCxDQUFzQixLQUF0QixFQUE0QixJQUFJLEdBQWhDLEVBQW9DLElBQUksR0FBeEMsRUFBNEMsUUFBUSxNQUFSLEdBQWdCLEVBQTVELENBQTdCO0FBQ0E7QUFDRjtBQUNBLGVBQUssRUFBTDtBQUNFLG1CQUFPLEtBQVA7QUFDQTtBQUNGO0FBQ0UsbUJBQU8sS0FBUDtBQUNBLGdCQUFJLFNBQUosRUFBZTtBQUNiLHdCQUFVLEtBQVYsSUFBbUIsaUJBQWlCLEtBQUssSUFBdEIsR0FBNkIsR0FBaEQ7QUFDRDtBQUNEO0FBcEtKO0FBc0tBLFlBQUcsYUFBYSxJQUFoQixFQUFzQjtBQUNwQixjQUFJLFNBQVEsVUFBVSxLQUF0QjtBQUNBLGlCQUFNLEtBQU4sQ0FBWSxJQUFaLENBQWlCLElBQWpCO0FBQ0Q7QUFDRixPQTNLRDtBQTRLQTtBQUNBLFVBQUksUUFBUSxTQUFaLEVBQXVCO0FBQ3JCLGFBQUssYUFBTCxDQUFtQixTQUFuQixFQUE2QixLQUE3QjtBQUNBLGFBQUssU0FBTCxHQUFpQixJQUFqQjtBQUNEO0FBQ0Y7OztxQ0FFZ0IsRyxFQUFJLEcsRUFBSSxHLEVBQUksSyxFQUFPO0FBQ2xDLGFBQU8sRUFBRSxLQUFNLEdBQVIsRUFBYSxLQUFNLEdBQW5CLEVBQXdCLEtBQU0sR0FBOUIsRUFBbUMsT0FBUSxFQUFFLE9BQVEsRUFBVixFQUFjLFFBQVMsQ0FBdkIsRUFBM0MsRUFBc0UsT0FBUSxLQUE5RSxFQUFQO0FBQ0Q7Ozt5Q0FFb0IsRyxFQUFLLEksRUFBTTtBQUM5QixVQUFJLE1BQU0sSUFBSSxNQUFkO0FBQ0EsVUFBSSxNQUFNLENBQVYsRUFBYTtBQUNYLFlBQUksS0FBSyxHQUFMLElBQVksSUFBSSxNQUFJLENBQVIsRUFBVyxHQUEzQixFQUNBO0FBQ0UsY0FBSSxJQUFKLENBQVMsSUFBVDtBQUNELFNBSEQsTUFJSztBQUNILGVBQUssSUFBSSxNQUFNLE1BQU0sQ0FBckIsRUFBd0IsT0FBTyxDQUEvQixFQUFrQyxLQUFsQyxFQUF5QztBQUN2QyxnQkFBSSxLQUFLLEdBQUwsR0FBVyxJQUFJLEdBQUosRUFBUyxHQUF4QixFQUE2QjtBQUMzQixrQkFBSSxNQUFKLENBQVcsR0FBWCxFQUFnQixDQUFoQixFQUFtQixJQUFuQjtBQUNBO0FBQ0Q7QUFDRjtBQUNGO0FBQ0YsT0FiRCxNQWNLO0FBQ0gsWUFBSSxJQUFKLENBQVMsSUFBVDtBQUNEO0FBQ0Y7OztzQ0FFaUI7QUFDaEIsVUFBSSxZQUFZLEtBQUssU0FBckI7QUFBQSxVQUFnQyxpQkFBaEM7QUFDQTtBQUNBLFVBQUksQ0FBQyxTQUFELElBQWMsVUFBVSxLQUFWLENBQWdCLEtBQWhCLENBQXNCLE1BQXRCLEtBQWlDLENBQW5ELEVBQXNEO0FBQ3BELFlBQUksUUFBUSxLQUFLLFNBQWpCO0FBQUEsWUFBNEIsVUFBVSxNQUFNLE9BQTVDO0FBQ0Esb0JBQVksUUFBUSxRQUFRLE1BQVIsR0FBZSxDQUF2QixDQUFaO0FBQ0Q7QUFDRCxVQUFJLFNBQUosRUFBZTtBQUNiLFlBQUksUUFBUSxVQUFVLEtBQVYsQ0FBZ0IsS0FBNUI7QUFDQSxtQkFBVyxNQUFNLE1BQU0sTUFBTixHQUFlLENBQXJCLENBQVg7QUFDRDtBQUNELGFBQU8sUUFBUDtBQUNEOzs7a0NBRWEsSyxFQUFPO0FBQ25CLFVBQUksSUFBSSxDQUFSO0FBQUEsVUFBVyxNQUFNLE1BQU0sVUFBdkI7QUFBQSxVQUFtQyxLQUFuQztBQUFBLFVBQTBDLFFBQTFDO0FBQUEsVUFBb0QsUUFBUSxLQUFLLFNBQWpFO0FBQUEsVUFBNEUsUUFBUSxNQUFNLFNBQU4sSUFBbUIsQ0FBdkc7QUFBQSxVQUEwRyxZQUFZLEtBQXRIO0FBQ0EsVUFBSSxRQUFRLEVBQVo7QUFBQSxVQUFnQixJQUFoQjtBQUFBLFVBQXNCLFFBQXRCO0FBQUEsVUFBZ0MsZ0JBQWdCLENBQUMsQ0FBakQ7QUFBQSxVQUFvRCxZQUFwRDtBQUNBOztBQUVBLFVBQUksVUFBVSxDQUFDLENBQWYsRUFBa0I7QUFDbEI7QUFDRSx3QkFBZ0IsQ0FBaEI7QUFDQTtBQUNBLHVCQUFlLE1BQU0sQ0FBTixJQUFXLElBQTFCO0FBQ0EsZ0JBQVEsQ0FBUjtBQUNBLFlBQUksQ0FBSjtBQUNEOztBQUVELGFBQU8sSUFBSSxHQUFYLEVBQWdCO0FBQ2QsZ0JBQVEsTUFBTSxHQUFOLENBQVI7QUFDQTtBQUNBLFlBQUksQ0FBQyxLQUFMLEVBQVk7QUFDVixrQkFBUSxRQUFRLENBQVIsR0FBWSxDQUFwQjtBQUNBO0FBQ0Q7QUFDRCxZQUFJLFVBQVUsQ0FBZCxFQUFpQjtBQUNmLGtCQUFRLFFBQVEsQ0FBUixHQUFZLENBQXBCO0FBQ0E7QUFDRDtBQUNEO0FBQ0EsWUFBRyxDQUFDLEtBQUosRUFBVztBQUNULGtCQUFRLENBQVI7QUFDRCxTQUZELE1BRU8sSUFBSSxVQUFVLENBQWQsRUFBaUI7QUFDdEIsY0FBSSxpQkFBZ0IsQ0FBcEIsRUFBdUI7QUFDckIsbUJBQU8sRUFBQyxNQUFNLE1BQU0sUUFBTixDQUFlLGFBQWYsRUFBOEIsSUFBSSxLQUFKLEdBQVksQ0FBMUMsQ0FBUCxFQUFxRCxNQUFNLFlBQTNELEVBQVA7QUFDQTtBQUNBLGtCQUFNLElBQU4sQ0FBVyxJQUFYO0FBQ0QsV0FKRCxNQUlPO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBSSxXQUFXLEtBQUssZUFBTCxFQUFmO0FBQ0EsZ0JBQUksUUFBSixFQUFjO0FBQ1osa0JBQUcsYUFBZSxLQUFLLElBQUksU0FBM0IsRUFBdUM7QUFDckM7QUFDQTtBQUNFO0FBQ0Ysb0JBQUksU0FBUyxLQUFiLEVBQW9CO0FBQ2xCO0FBQ0EsMkJBQVMsSUFBVCxHQUFnQixTQUFTLElBQVQsQ0FBYyxRQUFkLENBQXVCLENBQXZCLEVBQXlCLFNBQVMsSUFBVCxDQUFjLFVBQWQsR0FBMkIsU0FBcEQsQ0FBaEI7QUFDRDtBQUNGO0FBQ0Q7QUFDQSx5QkFBWSxJQUFJLEtBQUosR0FBWSxDQUF4QjtBQUNBLGtCQUFJLFdBQVcsQ0FBZixFQUFrQjtBQUNoQjtBQUNBLG9CQUFJLE1BQU0sSUFBSSxVQUFKLENBQWUsU0FBUyxJQUFULENBQWMsVUFBZCxHQUEyQixRQUExQyxDQUFWO0FBQ0Esb0JBQUksR0FBSixDQUFRLFNBQVMsSUFBakIsRUFBdUIsQ0FBdkI7QUFDQSxvQkFBSSxHQUFKLENBQVEsTUFBTSxRQUFOLENBQWUsQ0FBZixFQUFrQixRQUFsQixDQUFSLEVBQXFDLFNBQVMsSUFBVCxDQUFjLFVBQW5EO0FBQ0EseUJBQVMsSUFBVCxHQUFnQixHQUFoQjtBQUNEO0FBQ0Y7QUFDRjtBQUNEO0FBQ0EsY0FBSSxJQUFJLEdBQVIsRUFBYTtBQUNYLHVCQUFXLE1BQU0sQ0FBTixJQUFXLElBQXRCO0FBQ0E7QUFDQSw0QkFBZ0IsQ0FBaEI7QUFDQSwyQkFBZSxRQUFmO0FBQ0Esb0JBQVEsQ0FBUjtBQUNELFdBTkQsTUFNTztBQUNMO0FBQ0Esb0JBQVEsQ0FBQyxDQUFUO0FBQ0Q7QUFDRixTQTNDTSxNQTJDQTtBQUNMLGtCQUFRLENBQVI7QUFDRDtBQUNGO0FBQ0QsVUFBSSxpQkFBZ0IsQ0FBaEIsSUFBcUIsU0FBUSxDQUFqQyxFQUFvQztBQUNsQyxlQUFPLEVBQUMsTUFBTSxNQUFNLFFBQU4sQ0FBZSxhQUFmLEVBQThCLEdBQTlCLENBQVAsRUFBMkMsTUFBTSxZQUFqRCxFQUErRCxPQUFRLEtBQXZFLEVBQVA7QUFDQSxjQUFNLElBQU4sQ0FBVyxJQUFYO0FBQ0E7QUFDRDtBQUNEO0FBQ0EsVUFBSSxNQUFNLE1BQU4sS0FBaUIsQ0FBckIsRUFBd0I7QUFDdEI7QUFDQSxZQUFLLFlBQVcsS0FBSyxlQUFMLEVBQWhCO0FBQ0EsWUFBSSxTQUFKLEVBQWM7QUFDWixjQUFJLE9BQU0sSUFBSSxVQUFKLENBQWUsVUFBUyxJQUFULENBQWMsVUFBZCxHQUEyQixNQUFNLFVBQWhELENBQVY7QUFDQSxlQUFJLEdBQUosQ0FBUSxVQUFTLElBQWpCLEVBQXVCLENBQXZCO0FBQ0EsZUFBSSxHQUFKLENBQVEsS0FBUixFQUFlLFVBQVMsSUFBVCxDQUFjLFVBQTdCO0FBQ0Esb0JBQVMsSUFBVCxHQUFnQixJQUFoQjtBQUNEO0FBQ0Y7QUFDRCxZQUFNLFNBQU4sR0FBa0IsS0FBbEI7QUFDQSxhQUFPLEtBQVA7QUFDRDs7QUFFRDs7Ozs7OytCQUdXLEksRUFBTTtBQUNmLFVBQUksU0FBUyxLQUFLLFVBQWxCO0FBQUEsVUFDSSxlQUFlLEVBRG5CO0FBQUEsVUFFSSxJQUFJLENBRlI7QUFBQSxVQUdJLFNBSEo7QUFBQSxVQUdlLE9BSGY7O0FBS0E7QUFDQSxhQUFPLElBQUksU0FBUyxDQUFwQixFQUF1QjtBQUNyQixZQUFJLEtBQUssQ0FBTCxNQUFZLENBQVosSUFDQSxLQUFLLElBQUksQ0FBVCxNQUFnQixDQURoQixJQUVBLEtBQUssSUFBSSxDQUFULE1BQWdCLElBRnBCLEVBRTBCO0FBQ3hCLHVCQUFhLElBQWIsQ0FBa0IsSUFBSSxDQUF0QjtBQUNBLGVBQUssQ0FBTDtBQUNELFNBTEQsTUFLTztBQUNMO0FBQ0Q7QUFDRjs7QUFFRDtBQUNBO0FBQ0EsVUFBSSxhQUFhLE1BQWIsS0FBd0IsQ0FBNUIsRUFBK0I7QUFDN0IsZUFBTyxJQUFQO0FBQ0Q7O0FBRUQ7QUFDQSxrQkFBWSxTQUFTLGFBQWEsTUFBbEM7QUFDQSxnQkFBVSxJQUFJLFVBQUosQ0FBZSxTQUFmLENBQVY7QUFDQSxVQUFJLGNBQWMsQ0FBbEI7O0FBRUEsV0FBSyxJQUFJLENBQVQsRUFBWSxJQUFJLFNBQWhCLEVBQTJCLGVBQWUsR0FBMUMsRUFBK0M7QUFDN0MsWUFBSSxnQkFBZ0IsYUFBYSxDQUFiLENBQXBCLEVBQXFDO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLHVCQUFhLEtBQWI7QUFDRDtBQUNELGdCQUFRLENBQVIsSUFBYSxLQUFLLFdBQUwsQ0FBYjtBQUNEO0FBQ0QsYUFBTyxPQUFQO0FBQ0Q7OztpQ0FFWSxHLEVBQUs7QUFDaEIsVUFBSSxRQUFRLEtBQUssV0FBakI7QUFBQSxVQUNJLE9BQU8sSUFBSSxJQURmO0FBQUEsVUFFSSxNQUFNLElBQUksR0FGZDtBQUFBLFVBR0ksY0FBYyxDQUhsQjtBQUFBLFVBSUksY0FBYyxLQUFLLFdBSnZCO0FBQUEsVUFLSSxhQUFhLEtBQUssVUFMdEI7QUFBQSxVQU1JLE1BTko7QUFBQSxVQU1ZLFdBTlo7QUFBQSxVQU15QixhQU56QjtBQUFBLFVBTXdDLFVBTnhDO0FBQUEsVUFNb0QsTUFOcEQ7QUFBQSxVQU00RCxZQU41RDtBQUFBLFVBTTBFLEtBTjFFO0FBQUEsVUFNaUYsR0FOakY7QUFBQSxVQU1zRixTQU50RjtBQU9BLFVBQUksV0FBSixFQUFpQjtBQUNmLFlBQUksTUFBTSxJQUFJLFVBQUosQ0FBZSxZQUFZLFVBQVosR0FBeUIsS0FBSyxVQUE3QyxDQUFWO0FBQ0EsWUFBSSxHQUFKLENBQVEsV0FBUixFQUFxQixDQUFyQjtBQUNBLFlBQUksR0FBSixDQUFRLElBQVIsRUFBYyxZQUFZLFVBQTFCO0FBQ0E7QUFDQSxlQUFPLEdBQVA7QUFDRDtBQUNEO0FBQ0EsV0FBSyxTQUFTLFdBQVQsRUFBc0IsTUFBTSxLQUFLLE1BQXRDLEVBQThDLFNBQVMsTUFBTSxDQUE3RCxFQUFnRSxRQUFoRSxFQUEwRTtBQUN4RSxZQUFLLEtBQUssTUFBTCxNQUFpQixJQUFsQixJQUEyQixDQUFDLEtBQUssU0FBTyxDQUFaLElBQWlCLElBQWxCLE1BQTRCLElBQTNELEVBQWlFO0FBQy9EO0FBQ0Q7QUFDRjtBQUNEO0FBQ0EsVUFBSSxNQUFKLEVBQVk7QUFDVixZQUFJLE1BQUosRUFBWSxLQUFaO0FBQ0EsWUFBSSxTQUFTLE1BQU0sQ0FBbkIsRUFBc0I7QUFDcEIsc0VBQTBELE1BQTFEO0FBQ0Esa0JBQVEsS0FBUjtBQUNELFNBSEQsTUFHTztBQUNMLG1CQUFTLGlDQUFUO0FBQ0Esa0JBQVEsSUFBUjtBQUNEO0FBQ0QsdUJBQU8sSUFBUCxvQkFBNkIsTUFBN0I7QUFDQSxhQUFLLFFBQUwsQ0FBYyxPQUFkLENBQXNCLGlCQUFNLEtBQTVCLEVBQW1DLEVBQUMsTUFBTSxtQkFBVyxXQUFsQixFQUErQixJQUFLLEtBQUssRUFBekMsRUFBNkMsU0FBUyxxQkFBYSxrQkFBbkUsRUFBdUYsT0FBTyxLQUE5RixFQUFxRyxRQUFRLE1BQTdHLEVBQW5DO0FBQ0EsWUFBSSxLQUFKLEVBQVc7QUFDVDtBQUNEO0FBQ0Y7QUFDRCxVQUFJLENBQUMsTUFBTSxlQUFYLEVBQTRCO0FBQzFCLGlCQUFTLGVBQUssY0FBTCxDQUFvQixLQUFLLFFBQXpCLEVBQWtDLElBQWxDLEVBQXdDLE1BQXhDLEVBQWdELEtBQUssVUFBckQsQ0FBVDtBQUNBLGNBQU0sTUFBTixHQUFlLE9BQU8sTUFBdEI7QUFDQSxjQUFNLGVBQU4sR0FBd0IsT0FBTyxVQUEvQjtBQUNBLGNBQU0sWUFBTixHQUFxQixPQUFPLFlBQTVCO0FBQ0EsY0FBTSxLQUFOLEdBQWMsT0FBTyxLQUFyQjtBQUNBLGNBQU0sUUFBTixHQUFpQixLQUFLLFNBQXRCO0FBQ0EsdUJBQU8sR0FBUCxtQkFBMkIsTUFBTSxLQUFqQyxjQUErQyxPQUFPLFVBQXRELG9CQUErRSxPQUFPLFlBQXRGO0FBQ0Q7QUFDRCxtQkFBYSxDQUFiO0FBQ0Esc0JBQWdCLE9BQU8sS0FBUCxHQUFlLE1BQU0sZUFBckM7O0FBRUE7QUFDQTtBQUNBLFVBQUcsZUFBZSxVQUFsQixFQUE4QjtBQUM1QixZQUFJLFNBQVMsYUFBVyxhQUF4QjtBQUNBLFlBQUcsS0FBSyxHQUFMLENBQVMsU0FBTyxHQUFoQixJQUF1QixDQUExQixFQUE2QjtBQUMzQix5QkFBTyxHQUFQLCtDQUF1RCxLQUFLLEtBQUwsQ0FBVyxDQUFDLFNBQU8sR0FBUixJQUFhLEVBQXhCLENBQXZEO0FBQ0EsZ0JBQUksTUFBSjtBQUNEO0FBQ0Y7O0FBRUQsYUFBUSxTQUFTLENBQVYsR0FBZSxHQUF0QixFQUEyQjtBQUN6QjtBQUNBLHVCQUFnQixDQUFDLEVBQUUsS0FBSyxTQUFTLENBQWQsSUFBbUIsSUFBckIsQ0FBRCxHQUE4QixDQUE5QixHQUFrQyxDQUFsRDtBQUNBO0FBQ0Esc0JBQWUsQ0FBQyxLQUFLLFNBQVMsQ0FBZCxJQUFtQixJQUFwQixLQUE2QixFQUE5QixHQUNFLEtBQUssU0FBUyxDQUFkLEtBQW9CLENBRHRCLEdBRUMsQ0FBQyxLQUFLLFNBQVMsQ0FBZCxJQUFtQixJQUFwQixNQUE4QixDQUY3QztBQUdBLHVCQUFnQixZQUFoQjtBQUNBOztBQUVBLFlBQUssY0FBYyxDQUFmLElBQXVCLFNBQVMsWUFBVCxHQUF3QixXQUF6QixJQUF5QyxHQUFuRSxFQUF5RTtBQUN2RSxrQkFBUSxNQUFNLGFBQWEsYUFBM0I7QUFDQTtBQUNBLHNCQUFZLEVBQUMsTUFBTSxLQUFLLFFBQUwsQ0FBYyxTQUFTLFlBQXZCLEVBQXFDLFNBQVMsWUFBVCxHQUF3QixXQUE3RCxDQUFQLEVBQWtGLEtBQUssS0FBdkYsRUFBOEYsS0FBSyxLQUFuRyxFQUFaO0FBQ0EsZ0JBQU0sT0FBTixDQUFjLElBQWQsQ0FBbUIsU0FBbkI7QUFDQSxnQkFBTSxHQUFOLElBQWEsV0FBYjtBQUNBLG9CQUFVLGNBQWMsWUFBeEI7QUFDQTtBQUNBO0FBQ0EsaUJBQVEsU0FBVSxNQUFNLENBQXhCLEVBQTRCLFFBQTVCLEVBQXNDO0FBQ3BDLGdCQUFLLEtBQUssTUFBTCxNQUFpQixJQUFsQixJQUE0QixDQUFDLEtBQUssU0FBUyxDQUFkLElBQW1CLElBQXBCLE1BQThCLElBQTlELEVBQXFFO0FBQ25FO0FBQ0Q7QUFDRjtBQUNGLFNBZEQsTUFjTztBQUNMO0FBQ0Q7QUFDRjtBQUNELFVBQUksU0FBUyxHQUFiLEVBQWtCO0FBQ2hCLHNCQUFjLEtBQUssUUFBTCxDQUFjLE1BQWQsRUFBc0IsR0FBdEIsQ0FBZDtBQUNBO0FBQ0QsT0FIRCxNQUdPO0FBQ0wsc0JBQWMsSUFBZDtBQUNEO0FBQ0QsV0FBSyxXQUFMLEdBQW1CLFdBQW5CO0FBQ0EsV0FBSyxVQUFMLEdBQWtCLEtBQWxCO0FBQ0Q7OztrQ0FFYSxHLEVBQUs7QUFDakIsVUFBSSxPQUFPLElBQUksSUFBZjtBQUNBLFVBQUksTUFBTSxJQUFJLEdBQWQ7QUFDQSxVQUFJLFNBQVMsS0FBSyxNQUFsQjtBQUNBLFVBQUksYUFBYSxDQUFqQjtBQUNBLFVBQUksU0FBUyxDQUFiO0FBQ0EsVUFBSSxNQUFKOztBQUVBLGFBQU8sU0FBUyxNQUFULElBQ0gsQ0FBQyxTQUFTLEtBQUssVUFBTCxDQUFnQixJQUFoQixFQUFzQixNQUF0QixFQUE4QixNQUE5QixFQUFzQyxZQUF0QyxFQUFvRCxHQUFwRCxDQUFWLElBQXNFLENBRDFFLEVBQzZFO0FBQ3pFLGtCQUFVLE1BQVY7QUFDSDtBQUNGOzs7aUNBRVksSSxFQUFNLE8sRUFBUyxVLEVBQVksWSxFQUFjLFUsRUFBWSxHLEVBQUs7QUFDckUsVUFBSSxnQkFBaUIsT0FBTyxVQUFSLEdBQXNCLElBQTFDO0FBQ0EsVUFBSSxRQUFRLE1BQU0sYUFBYSxhQUEvQjtBQUNBLFVBQUksUUFBUSxLQUFLLFdBQWpCOztBQUVBLFlBQU0sTUFBTixHQUFlLEVBQWY7QUFDQSxZQUFNLFlBQU4sR0FBcUIsWUFBckI7QUFDQSxZQUFNLGVBQU4sR0FBd0IsVUFBeEI7QUFDQSxZQUFNLFFBQU4sR0FBaUIsS0FBSyxTQUF0QjtBQUNBLFlBQU0sT0FBTixDQUFjLElBQWQsQ0FBbUIsRUFBQyxNQUFNLElBQVAsRUFBYSxLQUFLLEtBQWxCLEVBQXlCLEtBQUssS0FBOUIsRUFBbkI7QUFDQSxZQUFNLEdBQU4sSUFBYSxLQUFLLE1BQWxCO0FBQ0Q7OztpQ0FFWSxJLEVBQU07QUFDakIscUJBQU8sSUFBUCxDQUFZLDJCQUEyQixLQUFLLE1BQWhDLEdBQXlDLFFBQXJEO0FBQ0Q7OzsrQkFFVSxJLEVBQU0sSyxFQUFPLEcsRUFBSyxVLEVBQVksRyxFQUFLO0FBQzVDLFVBQUksY0FBYyxDQUNkLEVBRGMsRUFDVixFQURVLEVBQ04sRUFETSxFQUNGLEdBREUsRUFDRyxHQURILEVBQ1EsR0FEUixFQUNhLEdBRGIsRUFDa0IsR0FEbEIsRUFDdUIsR0FEdkIsRUFDNEIsR0FENUIsRUFDaUMsR0FEakMsRUFDc0MsR0FEdEMsRUFDMkMsR0FEM0MsRUFDZ0QsR0FEaEQsRUFFZCxFQUZjLEVBRVYsRUFGVSxFQUVOLEVBRk0sRUFFRixFQUZFLEVBRUUsRUFGRixFQUVNLEVBRk4sRUFFVSxHQUZWLEVBRWUsR0FGZixFQUVvQixHQUZwQixFQUV5QixHQUZ6QixFQUU4QixHQUY5QixFQUVtQyxHQUZuQyxFQUV3QyxHQUZ4QyxFQUU2QyxHQUY3QyxFQUdkLEVBSGMsRUFHVixFQUhVLEVBR04sRUFITSxFQUdGLEVBSEUsRUFHRSxFQUhGLEVBR00sRUFITixFQUdVLEVBSFYsRUFHYyxHQUhkLEVBR21CLEdBSG5CLEVBR3dCLEdBSHhCLEVBRzZCLEdBSDdCLEVBR2tDLEdBSGxDLEVBR3VDLEdBSHZDLEVBRzRDLEdBSDVDLEVBSWQsRUFKYyxFQUlWLEVBSlUsRUFJTixFQUpNLEVBSUYsRUFKRSxFQUlFLEVBSkYsRUFJTSxFQUpOLEVBSVUsR0FKVixFQUllLEdBSmYsRUFJb0IsR0FKcEIsRUFJeUIsR0FKekIsRUFJOEIsR0FKOUIsRUFJbUMsR0FKbkMsRUFJd0MsR0FKeEMsRUFJNkMsR0FKN0MsRUFLZCxDQUxjLEVBS1gsRUFMVyxFQUtQLEVBTE8sRUFLSCxFQUxHLEVBS0MsRUFMRCxFQUtLLEVBTEwsRUFLUyxFQUxULEVBS2EsRUFMYixFQUtpQixFQUxqQixFQUtxQixFQUxyQixFQUt5QixHQUx6QixFQUs4QixHQUw5QixFQUttQyxHQUxuQyxFQUt3QyxHQUx4QyxDQUFsQjtBQU1BLFVBQUksa0JBQWtCLENBQUMsS0FBRCxFQUFRLEtBQVIsRUFBZSxLQUFmLEVBQXNCLEtBQXRCLEVBQTZCLEtBQTdCLEVBQW9DLEtBQXBDLEVBQTJDLEtBQTNDLEVBQWtELEtBQWxELEVBQXlELElBQXpELENBQXRCOztBQUVBLFVBQUksUUFBUSxDQUFSLEdBQVksR0FBaEIsRUFBcUI7QUFDakIsZUFBTyxDQUFDLENBQVIsQ0FEaUIsQ0FDTjtBQUNkO0FBQ0QsVUFBSSxLQUFLLEtBQUwsTUFBZ0IsSUFBaEIsSUFBd0IsQ0FBQyxLQUFLLFFBQVEsQ0FBYixJQUFrQixJQUFuQixNQUE2QixJQUF6RCxFQUErRDtBQUMzRDtBQUNBLFlBQUksUUFBUSxFQUFSLEdBQWEsR0FBakIsRUFBc0I7QUFDbEIsaUJBQU8sQ0FBQyxDQUFSO0FBQ0g7QUFDRCxZQUFJLFVBQVcsS0FBSyxRQUFRLENBQWIsS0FBbUIsQ0FBcEIsR0FBeUIsQ0FBdkM7QUFDQSxZQUFJLFVBQVcsS0FBSyxRQUFRLENBQWIsS0FBbUIsQ0FBcEIsR0FBeUIsQ0FBdkM7QUFDQSxZQUFJLFVBQVcsS0FBSyxRQUFRLENBQWIsS0FBbUIsQ0FBcEIsR0FBeUIsRUFBdkM7QUFDQSxZQUFJLFVBQVcsS0FBSyxRQUFRLENBQWIsS0FBbUIsQ0FBcEIsR0FBeUIsQ0FBdkM7QUFDQSxZQUFJLFVBQVUsQ0FBQyxFQUFFLEtBQUssUUFBUSxDQUFiLElBQWtCLENBQXBCLENBQWY7QUFDQSxZQUFJLFlBQVksQ0FBWixJQUFpQixZQUFZLENBQTdCLElBQWtDLFlBQVksRUFBOUMsSUFBb0QsWUFBWSxDQUFwRSxFQUF1RTtBQUNuRSxjQUFJLG1CQUFtQixZQUFZLENBQVosR0FBaUIsSUFBSSxPQUFyQixHQUFpQyxZQUFZLENBQVosR0FBZ0IsQ0FBaEIsR0FBb0IsQ0FBNUU7QUFDQSxjQUFJLFVBQVUsWUFBWSxtQkFBbUIsRUFBbkIsR0FBd0IsT0FBeEIsR0FBa0MsQ0FBOUMsSUFBbUQsSUFBakU7QUFDQSxjQUFJLHNCQUFzQixZQUFZLENBQVosR0FBZ0IsQ0FBaEIsR0FBb0IsWUFBWSxDQUFaLEdBQWdCLENBQWhCLEdBQW9CLENBQWxFO0FBQ0EsY0FBSSxhQUFhLGdCQUFnQixzQkFBc0IsQ0FBdEIsR0FBMEIsT0FBMUMsQ0FBakI7QUFDQSxjQUFJLFVBQVUsVUFBVSxDQUFWLEdBQWMsQ0FBNUI7QUFDQSxjQUFJLGVBQWUsS0FBSyxRQUFRLENBQWIsS0FBbUIsQ0FBbkIsS0FBeUIsQ0FBekIsR0FBNkIsQ0FBN0IsR0FBaUMsQ0FBcEQsQ0FObUUsQ0FNWjtBQUN2RCxjQUFJLGNBQWMsWUFBWSxDQUFaLEdBQ2IsQ0FBQyxZQUFZLENBQVosR0FBZ0IsRUFBaEIsR0FBcUIsQ0FBdEIsSUFBMkIsT0FBM0IsR0FBcUMsVUFBckMsR0FBa0QsT0FBbkQsSUFBK0QsQ0FEakQsR0FFYixDQUFDLFlBQVksQ0FBWixHQUFnQixHQUFoQixHQUFzQixFQUF2QixJQUE2QixPQUE3QixHQUF1QyxVQUF2QyxHQUFvRCxPQUFyRCxHQUFnRSxDQUZwRTtBQUdBLGNBQUksUUFBUSxXQUFSLEdBQXNCLEdBQTFCLEVBQStCO0FBQzNCLG1CQUFPLENBQUMsQ0FBUjtBQUNIO0FBQ0QsY0FBSSxLQUFLLFlBQVQsRUFBdUI7QUFDbkIsaUJBQUssWUFBTCxDQUFrQixLQUFLLFFBQUwsQ0FBYyxLQUFkLEVBQXFCLFFBQVEsV0FBN0IsQ0FBbEIsRUFBNkQsT0FBN0QsRUFBc0UsVUFBdEUsRUFBa0YsWUFBbEYsRUFBZ0csVUFBaEcsRUFBNEcsR0FBNUc7QUFDSDtBQUNELGlCQUFPLFdBQVA7QUFDSDtBQUNKO0FBQ0Q7QUFDQSxVQUFJLFNBQVMsUUFBUSxDQUFyQjtBQUNBLGFBQU8sU0FBUyxHQUFoQixFQUFxQjtBQUNqQixZQUFJLEtBQUssU0FBUyxDQUFkLE1BQXFCLElBQXJCLElBQTZCLENBQUMsS0FBSyxNQUFMLElBQWUsSUFBaEIsTUFBMEIsSUFBM0QsRUFBaUU7QUFDN0Q7QUFDQSxjQUFJLEtBQUssWUFBVCxFQUF1QjtBQUNuQixpQkFBSyxZQUFMLENBQWtCLEtBQUssUUFBTCxDQUFjLEtBQWQsRUFBcUIsU0FBUyxDQUE5QixDQUFsQjtBQUNIO0FBQ0QsaUJBQU8sU0FBUyxLQUFULEdBQWlCLENBQXhCO0FBQ0g7QUFDRDtBQUNIO0FBQ0QsYUFBTyxDQUFDLENBQVI7QUFDRDs7O2lDQUVZLEcsRUFBSztBQUNoQixXQUFLLFNBQUwsQ0FBZSxPQUFmLENBQXVCLElBQXZCLENBQTRCLEdBQTVCO0FBQ0Q7OzswQkFoK0JZLEksRUFBTTtBQUNqQjtBQUNBLFVBQUksS0FBSyxNQUFMLElBQWUsSUFBRSxHQUFqQixJQUF3QixLQUFLLENBQUwsTUFBWSxJQUFwQyxJQUE0QyxLQUFLLEdBQUwsTUFBYyxJQUExRCxJQUFrRSxLQUFLLElBQUUsR0FBUCxNQUFnQixJQUF0RixFQUE0RjtBQUMxRixlQUFPLElBQVA7QUFDRCxPQUZELE1BRU87QUFDTCxlQUFPLEtBQVA7QUFDRDtBQUNGOzs7Ozs7a0JBNDlCWSxTOzs7Ozs7OztBQ2pnQ1IsSUFBTSxrQ0FBYTtBQUN4QjtBQUNBLGlCQUFlLGNBRlM7QUFHeEI7QUFDQSxlQUFhLFlBSlc7QUFLeEI7QUFDQSxhQUFXLFVBTmE7QUFPeEI7QUFDQSxlQUFhO0FBUlcsQ0FBbkI7O0FBV0EsSUFBTSxzQ0FBZTtBQUMxQjtBQUNBLHVCQUFxQixtQkFGSztBQUcxQjtBQUNBLHlCQUF1QixxQkFKRztBQUsxQjtBQUNBLDBCQUF3QixzQkFORTtBQU8xQjtBQUNBLHNDQUFvQyxpQ0FSVjtBQVMxQjtBQUNBLHdCQUFzQixvQkFWSTtBQVcxQjtBQUNBLG9CQUFrQixnQkFaUTtBQWExQjtBQUNBLHNCQUFvQixrQkFkTTtBQWUxQjtBQUNBLHNCQUFvQixrQkFoQk07QUFpQjFCO0FBQ0EsMEJBQXdCLHFCQWxCRTtBQW1CMUI7QUFDQSw0QkFBMEIsdUJBcEJBO0FBcUIxQjtBQUNBLG1CQUFpQixlQXRCUztBQXVCMUI7QUFDQSwyQkFBeUIsc0JBeEJDO0FBeUIxQjtBQUNBLHFCQUFtQixpQkExQk87QUEyQjFCO0FBQ0Esc0JBQW9CLGtCQTVCTTtBQTZCMUI7QUFDQTtBQUNBLHNCQUFvQixrQkEvQk07QUFnQzFCO0FBQ0EscUJBQW9CLGlCQWpDTTtBQWtDMUI7QUFDQSxrQkFBZ0IsY0FuQ1U7QUFvQzFCO0FBQ0Esb0JBQWtCLGdCQXJDUTtBQXNDMUI7QUFDQSwwQkFBd0IscUJBdkNFO0FBd0MxQjtBQUNBLHVCQUFxQixtQkF6Q0s7QUEwQzFCO0FBQ0EsMEJBQXdCLHNCQTNDRTtBQTRDMUI7QUFDQSx3QkFBc0Isb0JBN0NJO0FBOEMxQjtBQUNBLHFCQUFtQixpQkEvQ087QUFnRDFCO0FBQ0EseUJBQXVCLG9CQWpERztBQWtEMUI7QUFDQSxzQkFBb0IsbUJBbkRNO0FBb0QxQjtBQUNBLG9CQUFrQjtBQXJEUSxDQUFyQjs7Ozs7Ozs7Ozs7cWpCQ1hQOzs7Ozs7QUFNQTs7QUFDQTs7QUFDQTs7Ozs7Ozs7SUFFTSxZO0FBRUosd0JBQVksR0FBWixFQUE0QjtBQUFBOztBQUMxQixTQUFLLEdBQUwsR0FBVyxHQUFYO0FBQ0EsU0FBSyxPQUFMLEdBQWUsS0FBSyxPQUFMLENBQWEsSUFBYixDQUFrQixJQUFsQixDQUFmOztBQUYwQixzQ0FBUixNQUFRO0FBQVIsWUFBUTtBQUFBOztBQUcxQixTQUFLLGFBQUwsR0FBcUIsTUFBckI7QUFDQSxTQUFLLGlCQUFMLEdBQXlCLElBQXpCOztBQUVBLFNBQUssaUJBQUw7QUFDRDs7Ozs4QkFFUztBQUNSLFdBQUssbUJBQUw7QUFDRDs7O3FDQUVnQjtBQUNmLGFBQU8sUUFBTyxLQUFLLGFBQVosTUFBOEIsUUFBOUIsSUFBMEMsS0FBSyxhQUFMLENBQW1CLE1BQTdELElBQXVFLE9BQU8sS0FBSyxPQUFaLEtBQXdCLFVBQXRHO0FBQ0Q7Ozt3Q0FFbUI7QUFDbEIsVUFBSSxLQUFLLGNBQUwsRUFBSixFQUEyQjtBQUN6QixhQUFLLGFBQUwsQ0FBbUIsT0FBbkIsQ0FBMkIsVUFBUyxLQUFULEVBQWdCO0FBQ3pDLGNBQUksVUFBVSxpQkFBZCxFQUFpQztBQUMvQixrQkFBTSxJQUFJLEtBQUosQ0FBVSwyQkFBMkIsS0FBckMsQ0FBTjtBQUNEO0FBQ0QsZUFBSyxHQUFMLENBQVMsRUFBVCxDQUFZLEtBQVosRUFBbUIsS0FBSyxPQUF4QjtBQUNELFNBTDBCLENBS3pCLElBTHlCLENBS3BCLElBTG9CLENBQTNCO0FBTUQ7QUFDRjs7OzBDQUVxQjtBQUNwQixVQUFJLEtBQUssY0FBTCxFQUFKLEVBQTJCO0FBQ3pCLGFBQUssYUFBTCxDQUFtQixPQUFuQixDQUEyQixVQUFTLEtBQVQsRUFBZ0I7QUFDekMsZUFBSyxHQUFMLENBQVMsR0FBVCxDQUFhLEtBQWIsRUFBb0IsS0FBSyxPQUF6QjtBQUNELFNBRjBCLENBRXpCLElBRnlCLENBRXBCLElBRm9CLENBQTNCO0FBR0Q7QUFDRjs7QUFFRDs7Ozs7OzRCQUdRLEssRUFBTyxJLEVBQU07QUFDbkIsV0FBSyxjQUFMLENBQW9CLEtBQXBCLEVBQTJCLElBQTNCO0FBQ0Q7OzttQ0FFYyxLLEVBQU8sSSxFQUFNO0FBQzFCLFVBQUksa0JBQWtCLFNBQWxCLGVBQWtCLENBQVMsS0FBVCxFQUFnQixJQUFoQixFQUFzQjtBQUMxQyxZQUFJLFdBQVcsT0FBTyxNQUFNLE9BQU4sQ0FBYyxLQUFkLEVBQXFCLEVBQXJCLENBQXRCO0FBQ0EsWUFBSSxPQUFPLEtBQUssUUFBTCxDQUFQLEtBQTBCLFVBQTlCLEVBQTBDO0FBQ3hDLGdCQUFNLElBQUksS0FBSixZQUFtQixLQUFuQix3Q0FBMkQsS0FBSyxXQUFMLENBQWlCLElBQTVFLHNCQUFpRyxRQUFqRyxPQUFOO0FBQ0Q7QUFDRCxlQUFPLEtBQUssUUFBTCxFQUFlLElBQWYsQ0FBb0IsSUFBcEIsRUFBMEIsSUFBMUIsQ0FBUDtBQUNELE9BTkQ7QUFPQSxVQUFJO0FBQ0Ysd0JBQWdCLElBQWhCLENBQXFCLElBQXJCLEVBQTJCLEtBQTNCLEVBQWtDLElBQWxDLEVBQXdDLElBQXhDO0FBQ0QsT0FGRCxDQUVFLE9BQU8sR0FBUCxFQUFZO0FBQ1osdUJBQU8sS0FBUCwrQ0FBeUQsS0FBekQsU0FBa0UsSUFBSSxPQUF0RTtBQUNBLGFBQUssR0FBTCxDQUFTLE9BQVQsQ0FBaUIsaUJBQU0sS0FBdkIsRUFBOEIsRUFBQyxNQUFNLG1CQUFXLFdBQWxCLEVBQStCLFNBQVMscUJBQWEsa0JBQXJELEVBQXlFLE9BQU8sS0FBaEYsRUFBdUYsT0FBUSxLQUEvRixFQUFzRyxLQUFNLEdBQTVHLEVBQTlCO0FBQ0Q7QUFDRjs7Ozs7O2tCQUdZLFk7Ozs7O0FDeEVmLE9BQU8sT0FBUCxHQUFpQjtBQUNmO0FBQ0EsbUJBQWlCLG1CQUZGO0FBR2Y7QUFDQSxrQkFBZ0Isa0JBSkQ7QUFLZjtBQUNBLG1CQUFpQixtQkFORjtBQU9mO0FBQ0Esa0JBQWdCLGtCQVJEO0FBU2Y7QUFDQSxnQkFBYyxnQkFWQztBQVdmO0FBQ0EsaUJBQWUsaUJBWkE7QUFhZjtBQUNBLGtCQUFnQixrQkFkRDtBQWVmO0FBQ0Esb0JBQWtCLG9CQWhCSDtBQWlCZjtBQUNBLG1CQUFpQixtQkFsQkY7QUFtQmY7QUFDQSxjQUFZLGNBcEJHO0FBcUJmO0FBQ0EsbUJBQWlCLG1CQXRCRjtBQXVCZjtBQUNBLGtCQUFnQixrQkF4QkQ7QUF5QmY7QUFDQSxvQkFBa0Isb0JBMUJIO0FBMkJmO0FBQ0EsbUJBQWlCLG1CQTVCRjtBQTZCZjtBQUNBLG1CQUFpQixtQkE5QkY7QUErQmY7QUFDQSxpQkFBZSxpQkFoQ0E7QUFpQ2Y7QUFDQSxnQkFBYyxnQkFsQ0M7QUFtQ2Y7QUFDQSxpQkFBZSxpQkFwQ0E7QUFxQ2Y7QUFDQSxxQkFBbUIsb0JBdENKO0FBdUNmO0FBQ0EsZ0JBQWMsZ0JBeENDO0FBeUNmO0FBQ0EsaUJBQWUsaUJBMUNBO0FBMkNmO0FBQ0Esd0JBQXNCLHVCQTVDUDtBQTZDZjtBQUNBLHNCQUFvQixxQkE5Q0w7QUErQ2Y7QUFDQSx5QkFBdUIsd0JBaERSO0FBaURmO0FBQ0Esd0JBQXNCLHVCQWxEUDtBQW1EZjtBQUNBLHVCQUFxQixzQkFwRE47QUFxRGY7QUFDQSxzQkFBb0IscUJBdERMO0FBdURmO0FBQ0EsMkJBQXlCLDBCQXhEVjtBQXlEZjtBQUNBLHlCQUF1Qix3QkExRFI7QUEyRGY7QUFDQSwwQkFBd0IseUJBNURUO0FBNkRmO0FBQ0EseUJBQXVCLHdCQTlEUjtBQStEZjtBQUNBLDJCQUF5QiwwQkFoRVY7QUFpRWY7QUFDQSxrQkFBZ0IsaUJBbEVEO0FBbUVmO0FBQ0EsZ0JBQWMsZ0JBcEVDO0FBcUVmO0FBQ0Esc0JBQW9CLHFCQXRFTDtBQXVFZjtBQUNBLCtCQUE2Qiw2QkF4RWQ7QUF5RWY7QUFDQSxlQUFhLGVBMUVFO0FBMkVmO0FBQ0Esd0JBQXNCLHVCQTVFUDtBQTZFZjtBQUNBLGtCQUFnQixrQkE5RUQ7QUErRWY7QUFDQSw2QkFBMkIsMkJBaEZaO0FBaUZmO0FBQ0EseUJBQXVCLHdCQWxGUjtBQW1GZjtBQUNBLHlCQUF1Qix3QkFwRlI7QUFxRmY7QUFDQSxxQkFBbUIsb0JBdEZKO0FBdUZmO0FBQ0EsZUFBYSxlQXhGRTtBQXlGZjtBQUNBLGlCQUFlLGlCQTFGQTtBQTJGZjtBQUNBLGdCQUFjLGdCQTVGQztBQTZGZjtBQUNBLFlBQVUsWUE5Rks7QUErRmY7QUFDQSwwQkFBd0Isd0JBaEdUO0FBaUdmO0FBQ0EsU0FBTyxVQWxHUTtBQW1HZjtBQUNBLGNBQVksZUFwR0c7QUFxR2Y7QUFDQSxlQUFhLGVBdEdFO0FBdUdmO0FBQ0EsY0FBWSxjQXhHRztBQXlHZjtBQUNBLDJCQUF5QjtBQTFHVixDQUFqQjs7Ozs7Ozs7Ozs7OztBQ0FBOzs7O0lBSU0sRzs7Ozs7OzttQ0FDa0IsWSxFQUFjO0FBQ2xDLFVBQUksaUJBQWlCLENBQXJCLEVBQXdCO0FBQ3RCLGVBQU8sSUFBSSxVQUFKLENBQWUsQ0FBQyxJQUFELEVBQU8sSUFBUCxFQUFhLElBQWIsRUFBbUIsSUFBbkIsRUFBeUIsSUFBekIsRUFBK0IsSUFBL0IsQ0FBZixDQUFQO0FBQ0QsT0FGRCxNQUVPLElBQUksaUJBQWlCLENBQXJCLEVBQXdCO0FBQzdCLGVBQU8sSUFBSSxVQUFKLENBQWUsQ0FBQyxJQUFELEVBQU8sSUFBUCxFQUFhLElBQWIsRUFBbUIsSUFBbkIsRUFBeUIsSUFBekIsRUFBK0IsSUFBL0IsRUFBcUMsSUFBckMsRUFBMkMsSUFBM0MsRUFBaUQsSUFBakQsQ0FBZixDQUFQO0FBQ0QsT0FGTSxNQUVBLElBQUksaUJBQWlCLENBQXJCLEVBQXdCO0FBQzdCLGVBQU8sSUFBSSxVQUFKLENBQWUsQ0FBQyxJQUFELEVBQU8sSUFBUCxFQUFhLElBQWIsRUFBbUIsSUFBbkIsRUFBeUIsSUFBekIsRUFBK0IsSUFBL0IsRUFBcUMsSUFBckMsRUFBMkMsSUFBM0MsRUFBaUQsSUFBakQsRUFBdUQsSUFBdkQsRUFBNkQsSUFBN0QsRUFBbUUsSUFBbkUsRUFBeUUsSUFBekUsQ0FBZixDQUFQO0FBQ0QsT0FGTSxNQUVBLElBQUksaUJBQWlCLENBQXJCLEVBQXdCO0FBQzdCLGVBQU8sSUFBSSxVQUFKLENBQWUsQ0FBQyxJQUFELEVBQU8sSUFBUCxFQUFhLElBQWIsRUFBbUIsSUFBbkIsRUFBeUIsSUFBekIsRUFBK0IsSUFBL0IsRUFBcUMsSUFBckMsRUFBMkMsSUFBM0MsRUFBaUQsSUFBakQsRUFBdUQsSUFBdkQsRUFBNkQsSUFBN0QsRUFBbUUsSUFBbkUsRUFBeUUsSUFBekUsRUFBK0UsSUFBL0UsRUFBcUYsSUFBckYsRUFBMkYsSUFBM0YsRUFBaUcsSUFBakcsRUFBdUcsSUFBdkcsQ0FBZixDQUFQO0FBQ0QsT0FGTSxNQUVBLElBQUksaUJBQWlCLENBQXJCLEVBQXdCO0FBQzdCLGVBQU8sSUFBSSxVQUFKLENBQWUsQ0FBQyxJQUFELEVBQU8sSUFBUCxFQUFhLElBQWIsRUFBbUIsSUFBbkIsRUFBeUIsSUFBekIsRUFBK0IsSUFBL0IsRUFBcUMsSUFBckMsRUFBMkMsSUFBM0MsRUFBaUQsSUFBakQsRUFBdUQsSUFBdkQsRUFBNkQsSUFBN0QsRUFBbUUsSUFBbkUsRUFBeUUsSUFBekUsRUFBK0UsSUFBL0UsRUFBcUYsSUFBckYsRUFBMkYsSUFBM0YsRUFBaUcsSUFBakcsRUFBdUcsSUFBdkcsRUFBNkcsSUFBN0csRUFBbUgsSUFBbkgsRUFBeUgsSUFBekgsQ0FBZixDQUFQO0FBQ0QsT0FGTSxNQUVBLElBQUksaUJBQWlCLENBQXJCLEVBQXdCO0FBQzdCLGVBQU8sSUFBSSxVQUFKLENBQWUsQ0FBQyxJQUFELEVBQU8sSUFBUCxFQUFhLElBQWIsRUFBbUIsSUFBbkIsRUFBeUIsSUFBekIsRUFBK0IsSUFBL0IsRUFBcUMsSUFBckMsRUFBMkMsSUFBM0MsRUFBaUQsSUFBakQsRUFBdUQsSUFBdkQsRUFBNkQsSUFBN0QsRUFBbUUsSUFBbkUsRUFBeUUsSUFBekUsRUFBK0UsSUFBL0UsRUFBcUYsSUFBckYsRUFBMkYsSUFBM0YsRUFBaUcsSUFBakcsRUFBdUcsSUFBdkcsRUFBNkcsSUFBN0csRUFBbUgsSUFBbkgsRUFBeUgsSUFBekgsRUFBK0gsSUFBL0gsRUFBcUksSUFBckksRUFBMkksSUFBM0ksRUFBaUosSUFBakosRUFBdUosSUFBdkosQ0FBZixDQUFQO0FBQ0Q7QUFDRCxhQUFPLElBQVA7QUFDRDs7Ozs7O2tCQUdZLEc7Ozs7Ozs7Ozs7Ozs7QUN2QmY7Ozs7SUFLTSxZOzs7Ozs7OytCQUdjLEssRUFBTSxRLEVBQVU7QUFDaEMsVUFBSSxLQUFKLEVBQVc7QUFDVCxZQUFJLFdBQVcsTUFBTSxRQUFyQjtBQUNBLGFBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxTQUFTLE1BQTdCLEVBQXFDLEdBQXJDLEVBQTBDO0FBQ3hDLGNBQUksWUFBWSxTQUFTLEtBQVQsQ0FBZSxDQUFmLENBQVosSUFBaUMsWUFBWSxTQUFTLEdBQVQsQ0FBYSxDQUFiLENBQWpELEVBQWtFO0FBQ2hFLG1CQUFPLElBQVA7QUFDRDtBQUNGO0FBQ0Y7QUFDRCxhQUFPLEtBQVA7QUFDRDs7OytCQUVpQixLLEVBQU8sRyxFQUFJLGUsRUFBaUI7QUFDNUMsVUFBSSxLQUFKLEVBQVc7QUFDVCxZQUFJO0FBQ0YsY0FBSSxZQUFZLE1BQU0sUUFBdEI7QUFBQSxjQUFnQyxXQUFXLEVBQTNDO0FBQUEsY0FBK0MsQ0FBL0M7QUFDQSxlQUFLLElBQUksQ0FBVCxFQUFZLElBQUksVUFBVSxNQUExQixFQUFrQyxHQUFsQyxFQUF1QztBQUNyQyxxQkFBUyxJQUFULENBQWMsRUFBQyxPQUFPLFVBQVUsS0FBVixDQUFnQixDQUFoQixDQUFSLEVBQTRCLEtBQUssVUFBVSxHQUFWLENBQWMsQ0FBZCxDQUFqQyxFQUFkO0FBQ0Q7QUFDRCxpQkFBTyxLQUFLLFlBQUwsQ0FBa0IsUUFBbEIsRUFBNEIsR0FBNUIsRUFBaUMsZUFBakMsQ0FBUDtBQUNELFNBTkQsQ0FNRSxPQUFNLENBQU4sRUFBUztBQUNULGlCQUFPLEVBQUMsS0FBSyxDQUFOLEVBQVMsT0FBTyxDQUFoQixFQUFtQixLQUFLLENBQXhCLEVBQTJCLFdBQVksU0FBdkMsRUFBUDtBQUNEO0FBQ0YsT0FWRCxNQVVPO0FBQ0wsZUFBTyxFQUFDLEtBQUssQ0FBTixFQUFTLE9BQU8sQ0FBaEIsRUFBbUIsS0FBSyxDQUF4QixFQUEyQixXQUFZLFNBQXZDLEVBQVA7QUFDRDtBQUNGOzs7aUNBRW1CLFEsRUFBUyxHLEVBQUksZSxFQUFpQjtBQUNoRCxVQUFJLFlBQVksRUFBaEI7O0FBQ0k7QUFDQSxlQUZKO0FBQUEsVUFFYyxXQUZkO0FBQUEsVUFFMkIsU0FGM0I7QUFBQSxVQUVxQyxlQUZyQztBQUFBLFVBRXFELENBRnJEO0FBR0E7QUFDQSxlQUFTLElBQVQsQ0FBYyxVQUFVLENBQVYsRUFBYSxDQUFiLEVBQWdCO0FBQzVCLFlBQUksT0FBTyxFQUFFLEtBQUYsR0FBVSxFQUFFLEtBQXZCO0FBQ0EsWUFBSSxJQUFKLEVBQVU7QUFDUixpQkFBTyxJQUFQO0FBQ0QsU0FGRCxNQUVPO0FBQ0wsaUJBQU8sRUFBRSxHQUFGLEdBQVEsRUFBRSxHQUFqQjtBQUNEO0FBQ0YsT0FQRDtBQVFBO0FBQ0E7QUFDQTtBQUNBLFdBQUssSUFBSSxDQUFULEVBQVksSUFBSSxTQUFTLE1BQXpCLEVBQWlDLEdBQWpDLEVBQXNDO0FBQ3BDLFlBQUksVUFBVSxVQUFVLE1BQXhCO0FBQ0EsWUFBRyxPQUFILEVBQVk7QUFDVixjQUFJLFVBQVUsVUFBVSxVQUFVLENBQXBCLEVBQXVCLEdBQXJDO0FBQ0E7QUFDQSxjQUFJLFNBQVMsQ0FBVCxFQUFZLEtBQVosR0FBb0IsT0FBckIsR0FBZ0MsZUFBbkMsRUFBb0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBRyxTQUFTLENBQVQsRUFBWSxHQUFaLEdBQWtCLE9BQXJCLEVBQThCO0FBQzVCLHdCQUFVLFVBQVUsQ0FBcEIsRUFBdUIsR0FBdkIsR0FBNkIsU0FBUyxDQUFULEVBQVksR0FBekM7QUFDRDtBQUNGLFdBUkQsTUFRTztBQUNMO0FBQ0Esc0JBQVUsSUFBVixDQUFlLFNBQVMsQ0FBVCxDQUFmO0FBQ0Q7QUFDRixTQWZELE1BZU87QUFDTDtBQUNBLG9CQUFVLElBQVYsQ0FBZSxTQUFTLENBQVQsQ0FBZjtBQUNEO0FBQ0Y7QUFDRCxXQUFLLElBQUksQ0FBSixFQUFPLFlBQVksQ0FBbkIsRUFBc0IsY0FBYyxZQUFZLEdBQXJELEVBQTBELElBQUksVUFBVSxNQUF4RSxFQUFnRixHQUFoRixFQUFxRjtBQUNuRixZQUFJLFFBQVMsVUFBVSxDQUFWLEVBQWEsS0FBMUI7QUFBQSxZQUNJLE1BQU0sVUFBVSxDQUFWLEVBQWEsR0FEdkI7QUFFQTtBQUNBLFlBQUssTUFBTSxlQUFQLElBQTJCLEtBQTNCLElBQW9DLE1BQU0sR0FBOUMsRUFBbUQ7QUFDakQ7QUFDQSx3QkFBYyxLQUFkO0FBQ0Esc0JBQVksR0FBWjtBQUNBLHNCQUFZLFlBQVksR0FBeEI7QUFDRCxTQUxELE1BS08sSUFBSyxNQUFNLGVBQVAsR0FBMEIsS0FBOUIsRUFBcUM7QUFDMUMsNEJBQWtCLEtBQWxCO0FBQ0E7QUFDRDtBQUNGO0FBQ0QsYUFBTyxFQUFDLEtBQUssU0FBTixFQUFpQixPQUFPLGVBQWUsQ0FBdkMsRUFBMEMsS0FBSyxhQUFhLENBQTVELEVBQStELFdBQVksZUFBM0UsRUFBUDtBQUNEOzs7Ozs7a0JBSVksWTs7Ozs7Ozs7O3FqQkM3RmY7Ozs7QUFJQTs7OztJQUVNLFc7Ozs7Ozs7aUNBRWdCLFUsRUFBVyxVLEVBQVk7QUFDekMsVUFBSSxRQUFRLEtBQUssR0FBTCxDQUFTLFdBQVcsT0FBcEIsRUFBNEIsV0FBVyxPQUF2QyxJQUFnRCxXQUFXLE9BQXZFO0FBQUEsVUFDSSxNQUFNLEtBQUssR0FBTCxDQUFTLFdBQVcsS0FBcEIsRUFBMEIsV0FBVyxLQUFyQyxJQUE0QyxXQUFXLE9BRGpFO0FBQUEsVUFFSSxRQUFRLFdBQVcsT0FBWCxHQUFxQixXQUFXLE9BRjVDO0FBQUEsVUFHSSxlQUFlLFdBQVcsU0FIOUI7QUFBQSxVQUlJLGVBQWUsV0FBVyxTQUo5QjtBQUFBLFVBS0ksV0FBVSxDQUxkO0FBQUEsVUFNSSxPQU5KOztBQVFBO0FBQ0EsVUFBSyxNQUFNLEtBQVgsRUFBa0I7QUFDaEIsbUJBQVcsUUFBWCxHQUFzQixLQUF0QjtBQUNBO0FBQ0Q7QUFDRDtBQUNBLFdBQUksSUFBSSxJQUFJLEtBQVosRUFBb0IsS0FBSyxHQUF6QixFQUErQixHQUEvQixFQUFvQztBQUNsQyxZQUFJLFVBQVUsYUFBYSxRQUFNLENBQW5CLENBQWQ7QUFBQSxZQUNJLFVBQVUsYUFBYSxDQUFiLENBRGQ7QUFFQSxZQUFJLFdBQVcsT0FBZixFQUF3QjtBQUN0QixxQkFBVyxRQUFRLEVBQVIsR0FBYSxRQUFRLEVBQWhDO0FBQ0EsY0FBSSxDQUFDLE1BQU0sUUFBUSxRQUFkLENBQUwsRUFBOEI7QUFDNUIsb0JBQVEsS0FBUixHQUFnQixRQUFRLFFBQVIsR0FBbUIsUUFBUSxRQUEzQztBQUNBLG9CQUFRLE1BQVIsR0FBaUIsUUFBUSxNQUF6QjtBQUNBLG9CQUFRLFFBQVIsR0FBbUIsUUFBUSxRQUEzQjtBQUNBLHNCQUFVLE9BQVY7QUFDRDtBQUNGO0FBQ0Y7O0FBRUQsVUFBRyxRQUFILEVBQWE7QUFDWCx1QkFBTyxHQUFQO0FBQ0EsYUFBSSxJQUFJLENBQVIsRUFBWSxJQUFJLGFBQWEsTUFBN0IsRUFBc0MsR0FBdEMsRUFBMkM7QUFDekMsdUJBQWEsQ0FBYixFQUFnQixFQUFoQixJQUFzQixRQUF0QjtBQUNEO0FBQ0Y7O0FBRUQ7QUFDQSxVQUFHLE9BQUgsRUFBWTtBQUNWLG9CQUFZLGdCQUFaLENBQTZCLFVBQTdCLEVBQXdDLFFBQVEsRUFBaEQsRUFBbUQsUUFBUSxRQUEzRCxFQUFvRSxRQUFRLE1BQTVFLEVBQW1GLFFBQVEsUUFBM0YsRUFBb0csUUFBUSxNQUE1RztBQUNELE9BRkQsTUFFTztBQUNMO0FBQ0E7QUFDQTtBQUNBLFlBQUksU0FBUyxDQUFULElBQWMsUUFBUSxhQUFhLE1BQXZDLEVBQStDO0FBQzdDO0FBQ0EsY0FBSSxVQUFVLGFBQWEsS0FBYixFQUFvQixLQUFsQztBQUNBLGVBQUksSUFBSSxDQUFSLEVBQVksSUFBSSxhQUFhLE1BQTdCLEVBQXNDLEdBQXRDLEVBQTJDO0FBQ3pDLHlCQUFhLENBQWIsRUFBZ0IsS0FBaEIsSUFBeUIsT0FBekI7QUFDRDtBQUNGO0FBQ0Y7QUFDRDtBQUNBO0FBQ0EsaUJBQVcsUUFBWCxHQUFzQixXQUFXLFFBQWpDO0FBQ0E7QUFDRDs7O3FDQUV1QixPLEVBQVEsRSxFQUFHLFEsRUFBUyxNLEVBQU8sUSxFQUFTLE0sRUFBUTtBQUNsRSxVQUFJLE9BQUosRUFBYSxTQUFiLEVBQXdCLElBQXhCLEVBQThCLENBQTlCO0FBQ0E7QUFDQSxVQUFJLENBQUMsT0FBRCxJQUFZLEtBQUssUUFBUSxPQUF6QixJQUFvQyxLQUFLLFFBQVEsS0FBckQsRUFBNEQ7QUFDMUQsZUFBTyxDQUFQO0FBQ0Q7QUFDRCxnQkFBVSxLQUFLLFFBQVEsT0FBdkI7QUFDQSxrQkFBWSxRQUFRLFNBQXBCO0FBQ0EsYUFBTyxVQUFVLE9BQVYsQ0FBUDtBQUNBLFVBQUcsQ0FBQyxNQUFNLEtBQUssUUFBWCxDQUFKLEVBQTBCO0FBQ3hCO0FBQ0EsWUFBSSxXQUFXLEtBQUssR0FBTCxDQUFTLEtBQUssUUFBTCxHQUFjLFFBQXZCLENBQWY7QUFDQSxZQUFJLE1BQU0sS0FBSyxRQUFYLENBQUosRUFBMEI7QUFDeEIsZUFBSyxRQUFMLEdBQWdCLFFBQWhCO0FBQ0QsU0FGRCxNQUVPO0FBQ0wsZUFBSyxRQUFMLEdBQWdCLEtBQUssR0FBTCxDQUFTLFFBQVQsRUFBa0IsS0FBSyxRQUF2QixDQUFoQjtBQUNEO0FBQ0QsbUJBQVcsS0FBSyxHQUFMLENBQVMsUUFBVCxFQUFrQixLQUFLLFFBQXZCLENBQVg7QUFDQSxpQkFBUyxLQUFLLEdBQUwsQ0FBUyxNQUFULEVBQWlCLEtBQUssTUFBdEIsQ0FBVDtBQUNBLG1CQUFXLEtBQUssR0FBTCxDQUFTLFFBQVQsRUFBa0IsS0FBSyxRQUF2QixDQUFYO0FBQ0EsaUJBQVMsS0FBSyxHQUFMLENBQVMsTUFBVCxFQUFpQixLQUFLLE1BQXRCLENBQVQ7QUFDRDs7QUFFRCxVQUFJLFFBQVEsV0FBVyxLQUFLLEtBQTVCOztBQUVBLFdBQUssS0FBTCxHQUFhLEtBQUssUUFBTCxHQUFnQixRQUE3QjtBQUNBLFdBQUssTUFBTCxHQUFjLE1BQWQ7QUFDQSxXQUFLLFFBQUwsR0FBZ0IsUUFBaEI7QUFDQSxXQUFLLE1BQUwsR0FBYyxNQUFkO0FBQ0EsV0FBSyxRQUFMLEdBQWdCLFNBQVMsUUFBekI7QUFDQTtBQUNBLFdBQUksSUFBSSxPQUFSLEVBQWtCLElBQUksQ0FBdEIsRUFBMEIsR0FBMUIsRUFBK0I7QUFDN0Isb0JBQVksU0FBWixDQUFzQixTQUF0QixFQUFnQyxDQUFoQyxFQUFrQyxJQUFFLENBQXBDO0FBQ0Q7O0FBRUQ7QUFDQSxXQUFJLElBQUksT0FBUixFQUFrQixJQUFJLFVBQVUsTUFBVixHQUFtQixDQUF6QyxFQUE2QyxHQUE3QyxFQUFrRDtBQUNoRCxvQkFBWSxTQUFaLENBQXNCLFNBQXRCLEVBQWdDLENBQWhDLEVBQWtDLElBQUUsQ0FBcEM7QUFDRDtBQUNELGNBQVEsUUFBUixHQUFtQixJQUFuQjtBQUNBOztBQUVBLGFBQU8sS0FBUDtBQUNEOzs7OEJBRWdCLFMsRUFBVSxPLEVBQVMsSyxFQUFPO0FBQ3pDLFVBQUksV0FBVyxVQUFVLE9BQVYsQ0FBZjtBQUFBLFVBQWtDLFNBQVMsVUFBVSxLQUFWLENBQTNDO0FBQUEsVUFBNkQsWUFBWSxPQUFPLFFBQWhGO0FBQ0E7QUFDQSxVQUFHLENBQUMsTUFBTSxTQUFOLENBQUosRUFBc0I7QUFDcEI7QUFDQTtBQUNBLFlBQUksUUFBUSxPQUFaLEVBQXFCO0FBQ25CLG1CQUFTLFFBQVQsR0FBb0IsWUFBVSxTQUFTLEtBQXZDO0FBQ0EsY0FBRyxTQUFTLFFBQVQsR0FBb0IsQ0FBdkIsRUFBMEI7QUFDeEIsMkJBQU8sSUFBUCwwQ0FBbUQsU0FBUyxFQUE1RCxlQUF3RSxTQUFTLEtBQWpGO0FBQ0Q7QUFDRixTQUxELE1BS087QUFDTCxpQkFBTyxRQUFQLEdBQWtCLFNBQVMsS0FBVCxHQUFpQixTQUFuQztBQUNBLGNBQUcsT0FBTyxRQUFQLEdBQWtCLENBQXJCLEVBQXdCO0FBQ3RCLDJCQUFPLElBQVAsMENBQW1ELE9BQU8sRUFBMUQsZUFBc0UsT0FBTyxLQUE3RTtBQUNEO0FBQ0Y7QUFDRixPQWRELE1BY087QUFDTDtBQUNBLFlBQUksUUFBUSxPQUFaLEVBQXFCO0FBQ25CLGlCQUFPLEtBQVAsR0FBZSxTQUFTLEtBQVQsR0FBaUIsU0FBUyxRQUF6QztBQUNELFNBRkQsTUFFTztBQUNMLGlCQUFPLEtBQVAsR0FBZSxTQUFTLEtBQVQsR0FBaUIsT0FBTyxRQUF2QztBQUNEO0FBQ0Y7QUFDRjs7Ozs7O2tCQUdZLFc7OztBQzFJZjs7O0FBR0E7Ozs7Ozs7QUFrQkE7OztBQWhCQTs7OztBQUNBOztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7O0FBRUE7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7Ozs7O0lBRU0sRzs7O2tDQU9pQjtBQUNuQixhQUFPLFdBQVAsR0FBcUIsT0FBTyxXQUFQLElBQXNCLE9BQU8saUJBQWxEO0FBQ0EsYUFBUSxPQUFPLFdBQVAsSUFDQSxPQUFPLE9BQU8sV0FBUCxDQUFtQixlQUExQixLQUE4QyxVQUQ5QyxJQUVBLE9BQU8sV0FBUCxDQUFtQixlQUFuQixDQUFtQywyQ0FBbkMsQ0FGUjtBQUdEOzs7d0JBVm9CO0FBQ25CO0FBQ0EsYUFBTyxhQUFQO0FBQ0Q7Ozt3QkFTbUI7QUFDbEI7QUFDRDs7O3dCQUV1QjtBQUN0QjtBQUNEOzs7d0JBRXlCO0FBQ3hCO0FBQ0Q7Ozt3QkFFMEI7QUFDekIsVUFBRyxDQUFDLElBQUksYUFBUixFQUF1QjtBQUNwQixZQUFJLGFBQUosR0FBb0I7QUFDakIseUJBQWUsSUFERTtBQUVqQix5QkFBZSxDQUFDLENBRkM7QUFHakIsNkJBQW1CLFNBSEY7QUFJakIsaUJBQU8sS0FKVTtBQUtqQiw2QkFBbUIsS0FMRjtBQU1qQixnQ0FBc0IsS0FOTDtBQU9qQixtQ0FBeUIsQ0FQUjtBQVFqQiwyQkFBaUIsRUFSQTtBQVNqQix5QkFBZSxLQUFLLElBQUwsR0FBWSxJQVRWO0FBVWpCLHlCQUFlLEdBVkU7QUFXakIsdUJBQWEsQ0FYSTtBQVlqQixpQ0FBdUIsSUFaTjtBQWFqQiwyQ0FBaUMsRUFiaEI7QUFjakIsa0NBQXdCLEdBZFA7QUFlakIsaUNBQXNCLENBZkw7QUFnQmpCLHVDQUE2QixRQWhCWjtBQWlCakIsNEJBQWtCLFNBakJEO0FBa0JqQixrQ0FBd0IsU0FsQlA7QUFtQmpCLDhCQUFvQixHQW5CSDtBQW9CakIsd0JBQWMsSUFwQkc7QUFxQmpCLDZCQUFtQixJQXJCRjtBQXNCakIsa0NBQXdCLEtBdEJQO0FBdUJqQixtQ0FBeUIsQ0F2QlI7QUF3QmpCLHFDQUEyQixJQXhCVjtBQXlCakIsMENBQWdDLEtBekJmO0FBMEJqQixzQkFBWSxTQTFCSztBQTJCakIsK0JBQXFCLEtBM0JKO0FBNEJqQixnQ0FBc0IsQ0E1Qkw7QUE2QmpCLGtDQUF3QixJQTdCUDtBQThCakIsdUNBQTZCLEtBOUJaO0FBK0JqQiw4QkFBb0IsS0EvQkg7QUFnQ2pCLCtCQUFxQixDQWhDSjtBQWlDakIsaUNBQXVCLElBakNOO0FBa0NqQixzQ0FBNEIsS0FsQ1g7QUFtQ2pCLG9DQUEwQixDQW5DVDtBQW9DakIsNkJBQW1CLEtBcENGO0FBcUNqQixzQ0FBNEIsSUFyQ1g7QUFzQ2pCLHlDQUErQixHQXRDZDtBQXVDakIsK0JBQXFCLENBdkNKO0FBd0NqQixxQ0F4Q2lCO0FBeUNqQjtBQUNBLG1CQUFTLFNBMUNRO0FBMkNqQixtQkFBUyxTQTNDUTtBQTRDakIsb0JBQVUsU0E1Q087QUE2Q2pCLHNCQUFZLFNBN0NLO0FBOENqQixnREE5Q2lCO0FBK0NqQixzREEvQ2lCO0FBZ0RqQiwwREFoRGlCO0FBaURqQixnREFqRGlCO0FBa0RqQixzREFsRGlCO0FBbURqQixnRUFuRGlCO0FBb0RqQixzRUFwRGlCO0FBcURqQiwwREFyRGlCO0FBc0RqQixvQ0F0RGlCO0FBdURqQixnQ0FBc0IsSUF2REw7QUF3RGpCLHdCQUFjLElBeERHO0FBeURqQixpQ0FBdUIsS0F6RE47QUEwRGpCLGtDQUF3QixLQTFEUDtBQTJEakIsd0NBQThCLElBM0RiO0FBNERqQiwyQkFBaUIsQ0E1REE7QUE2RGpCLDJCQUFpQixDQTdEQTtBQThEakIsMEJBQWdCLENBOURDO0FBK0RqQiwwQkFBZ0IsQ0EvREM7QUFnRWpCLGtDQUF3QixHQWhFUCxFQWdFWTtBQUM3Qiw4QkFBcUIsSUFqRUo7QUFrRWpCLGdDQUF1QixHQWxFTjtBQW1FakIsOEJBQXFCLENBbkVKO0FBb0VqQiwyQkFBa0IsQ0FwRUQ7QUFxRWpCLDBCQUFnQjtBQXJFQyxTQUFwQjtBQXVFRjtBQUNELGFBQU8sSUFBSSxhQUFYO0FBQ0QsSztzQkFFd0IsYSxFQUFlO0FBQ3RDLFVBQUksYUFBSixHQUFvQixhQUFwQjtBQUNEOzs7QUFFRCxpQkFBeUI7QUFBQSxRQUFiLE1BQWEsdUVBQUosRUFBSTs7QUFBQTs7QUFDdkIsUUFBSSxnQkFBZ0IsSUFBSSxhQUF4Qjs7QUFFQSxRQUFJLENBQUMsT0FBTyxxQkFBUCxJQUFnQyxPQUFPLDJCQUF4QyxNQUF5RSxPQUFPLGdCQUFQLElBQTJCLE9BQU8sc0JBQTNHLENBQUosRUFBd0k7QUFDdEksWUFBTSxJQUFJLEtBQUosQ0FBVSxvSUFBVixDQUFOO0FBQ0Q7O0FBRUQsU0FBSyxJQUFJLElBQVQsSUFBaUIsYUFBakIsRUFBZ0M7QUFDNUIsVUFBSSxRQUFRLE1BQVosRUFBb0I7QUFBRTtBQUFXO0FBQ2pDLGFBQU8sSUFBUCxJQUFlLGNBQWMsSUFBZCxDQUFmO0FBQ0g7O0FBRUQsUUFBSSxPQUFPLDJCQUFQLEtBQXVDLFNBQXZDLElBQW9ELE9BQU8sMkJBQVAsSUFBc0MsT0FBTyxxQkFBckcsRUFBNEg7QUFDMUgsWUFBTSxJQUFJLEtBQUosQ0FBVSx5RkFBVixDQUFOO0FBQ0Q7O0FBRUQsUUFBSSxPQUFPLHNCQUFQLEtBQWtDLFNBQWxDLEtBQWdELE9BQU8sc0JBQVAsSUFBaUMsT0FBTyxnQkFBeEMsSUFBNEQsT0FBTyxnQkFBUCxLQUE0QixTQUF4SSxDQUFKLEVBQXdKO0FBQ3RKLFlBQU0sSUFBSSxLQUFKLENBQVUsK0VBQVYsQ0FBTjtBQUNEOztBQUVELDRCQUFXLE9BQU8sS0FBbEI7QUFDQSxTQUFLLE1BQUwsR0FBYyxNQUFkO0FBQ0E7QUFDQSxRQUFJLFdBQVcsS0FBSyxRQUFMLEdBQWdCLHNCQUEvQjtBQUNBLGFBQVMsT0FBVCxHQUFtQixTQUFTLE9BQVQsQ0FBa0IsS0FBbEIsRUFBa0M7QUFBQSx3Q0FBTixJQUFNO0FBQU4sWUFBTTtBQUFBOztBQUNuRCxlQUFTLElBQVQsa0JBQWMsS0FBZCxFQUFxQixLQUFyQixTQUErQixJQUEvQjtBQUNELEtBRkQ7O0FBSUEsYUFBUyxHQUFULEdBQWUsU0FBUyxHQUFULENBQWMsS0FBZCxFQUE4QjtBQUFBLHlDQUFOLElBQU07QUFBTixZQUFNO0FBQUE7O0FBQzNDLGVBQVMsY0FBVCxrQkFBd0IsS0FBeEIsU0FBa0MsSUFBbEM7QUFDRCxLQUZEO0FBR0EsU0FBSyxFQUFMLEdBQVUsU0FBUyxFQUFULENBQVksSUFBWixDQUFpQixRQUFqQixDQUFWO0FBQ0EsU0FBSyxHQUFMLEdBQVcsU0FBUyxHQUFULENBQWEsSUFBYixDQUFrQixRQUFsQixDQUFYO0FBQ0EsU0FBSyxPQUFMLEdBQWUsU0FBUyxPQUFULENBQWlCLElBQWpCLENBQXNCLFFBQXRCLENBQWY7QUFDQSxTQUFLLGNBQUwsR0FBc0IsNkJBQW1CLElBQW5CLENBQXRCO0FBQ0EsU0FBSyxjQUFMLEdBQXNCLDZCQUFtQixJQUFuQixDQUF0QjtBQUNBLFNBQUssZUFBTCxHQUF1Qiw4QkFBb0IsSUFBcEIsQ0FBdkI7QUFDQSxTQUFLLGFBQUwsR0FBcUIsSUFBSSxPQUFPLGFBQVgsQ0FBeUIsSUFBekIsQ0FBckI7QUFDQSxTQUFLLGdCQUFMLEdBQXdCLElBQUksT0FBTyxnQkFBWCxDQUE0QixJQUE1QixDQUF4QjtBQUNBLFNBQUssa0JBQUwsR0FBMEIsSUFBSSxPQUFPLGtCQUFYLENBQThCLElBQTlCLENBQTFCO0FBQ0EsU0FBSyxhQUFMLEdBQXFCLElBQUksT0FBTyxhQUFYLENBQXlCLElBQXpCLENBQXJCO0FBQ0EsU0FBSyxnQkFBTCxHQUF3QixJQUFJLE9BQU8sZ0JBQVgsQ0FBNEIsSUFBNUIsQ0FBeEI7QUFDQSxTQUFLLHFCQUFMLEdBQTZCLElBQUksT0FBTyxxQkFBWCxDQUFpQyxJQUFqQyxDQUE3QjtBQUNBLFNBQUssd0JBQUwsR0FBZ0MsSUFBSSxPQUFPLHdCQUFYLENBQW9DLElBQXBDLENBQWhDO0FBQ0EsU0FBSyxrQkFBTCxHQUEwQixJQUFJLE9BQU8sa0JBQVgsQ0FBOEIsSUFBOUIsQ0FBMUI7QUFDQSxTQUFLLG9CQUFMLEdBQTRCLG1DQUF5QixJQUF6QixDQUE1QjtBQUNBLFNBQUssdUJBQUwsR0FBK0Isc0NBQTRCLElBQTVCLENBQS9CO0FBQ0EsU0FBSyxTQUFMLEdBQWlCLHdCQUFjLElBQWQsQ0FBakI7QUFDRDs7Ozs4QkFFUztBQUNSLHFCQUFPLEdBQVAsQ0FBVyxTQUFYO0FBQ0EsV0FBSyxPQUFMLENBQWEsaUJBQU0sVUFBbkI7QUFDQSxXQUFLLFdBQUw7QUFDQSxXQUFLLGNBQUwsQ0FBb0IsT0FBcEI7QUFDQSxXQUFLLGNBQUwsQ0FBb0IsT0FBcEI7QUFDQSxXQUFLLGVBQUwsQ0FBcUIsT0FBckI7QUFDQSxXQUFLLGFBQUwsQ0FBbUIsT0FBbkI7QUFDQSxXQUFLLGdCQUFMLENBQXNCLE9BQXRCO0FBQ0EsV0FBSyxrQkFBTCxDQUF3QixPQUF4QjtBQUNBLFdBQUssYUFBTCxDQUFtQixPQUFuQjtBQUNBLFdBQUssZ0JBQUwsQ0FBc0IsT0FBdEI7QUFDQSxXQUFLLHFCQUFMLENBQTJCLE9BQTNCO0FBQ0EsV0FBSyx3QkFBTCxDQUE4QixPQUE5QjtBQUNBLFdBQUssa0JBQUwsQ0FBd0IsT0FBeEI7QUFDQSxXQUFLLG9CQUFMLENBQTBCLE9BQTFCO0FBQ0EsV0FBSyx1QkFBTCxDQUE2QixPQUE3QjtBQUNBLFdBQUssU0FBTCxDQUFlLE9BQWY7QUFDQSxXQUFLLEdBQUwsR0FBVyxJQUFYO0FBQ0EsV0FBSyxRQUFMLENBQWMsa0JBQWQ7QUFDRDs7O2dDQUVXLEssRUFBTztBQUNqQixxQkFBTyxHQUFQLENBQVcsYUFBWDtBQUNBLFdBQUssS0FBTCxHQUFhLEtBQWI7QUFDQSxXQUFLLE9BQUwsQ0FBYSxpQkFBTSxlQUFuQixFQUFvQyxFQUFDLE9BQU8sS0FBUixFQUFwQztBQUNEOzs7a0NBRWE7QUFDWixxQkFBTyxHQUFQLENBQVcsYUFBWDtBQUNBLFdBQUssT0FBTCxDQUFhLGlCQUFNLGVBQW5CO0FBQ0EsV0FBSyxLQUFMLEdBQWEsSUFBYjtBQUNEOzs7K0JBRVUsRyxFQUFLO0FBQ2QscUJBQU8sR0FBUCxpQkFBeUIsR0FBekI7QUFDQSxXQUFLLEdBQUwsR0FBVyxHQUFYO0FBQ0E7QUFDQSxXQUFLLE9BQUwsQ0FBYSxpQkFBTSxnQkFBbkIsRUFBcUMsRUFBQyxLQUFLLEdBQU4sRUFBckM7QUFDRDs7O2dDQUUyQjtBQUFBLFVBQWxCLGFBQWtCLHVFQUFKLENBQUMsQ0FBRzs7QUFDMUIscUJBQU8sR0FBUCxnQkFBd0IsYUFBeEI7QUFDQSxXQUFLLGVBQUwsQ0FBcUIsU0FBckI7QUFDQSxXQUFLLGdCQUFMLENBQXNCLFNBQXRCLENBQWdDLGFBQWhDO0FBQ0EsV0FBSyxxQkFBTCxDQUEyQixTQUEzQixDQUFxQyxhQUFyQztBQUNEOzs7K0JBRVU7QUFDVCxxQkFBTyxHQUFQLENBQVcsVUFBWDtBQUNBLFdBQUssZUFBTCxDQUFxQixRQUFyQjtBQUNBLFdBQUssZ0JBQUwsQ0FBc0IsUUFBdEI7QUFDQSxXQUFLLHFCQUFMLENBQTJCLFFBQTNCO0FBQ0Q7OztxQ0FFZ0I7QUFDZixxQkFBTyxHQUFQLENBQVcsZ0JBQVg7QUFDQSxXQUFLLGdCQUFMLENBQXNCLGNBQXRCO0FBQ0Q7Ozt3Q0FFbUI7QUFDbEIscUJBQU8sR0FBUCxDQUFXLG1CQUFYO0FBQ0EsVUFBSSxRQUFRLEtBQUssS0FBakI7QUFDQSxXQUFLLFdBQUw7QUFDQSxXQUFLLFdBQUwsQ0FBaUIsS0FBakI7QUFDRDs7O2lDQUVZO0FBQ1gscUJBQU8sR0FBUCxDQUFXLFlBQVg7QUFDQSxVQUFJLEtBQUssTUFBTCxDQUFZLG9CQUFoQixFQUFzQztBQUNwQyxhQUFLLGtCQUFMLENBQXdCLGdCQUF4QjtBQUNEO0FBQ0Y7O0FBRUQ7Ozs7d0JBQ2E7QUFDWCxhQUFPLEtBQUssZUFBTCxDQUFxQixNQUE1QjtBQUNEOztBQUVEOzs7O3dCQUNtQjtBQUNqQixhQUFPLEtBQUssZ0JBQUwsQ0FBc0IsWUFBN0I7QUFDRDs7QUFFRDs7c0JBQ2lCLFEsRUFBVTtBQUN6QixxQkFBTyxHQUFQLHVCQUErQixRQUEvQjtBQUNBLFdBQUssU0FBTCxHQUFpQixRQUFqQjtBQUNBLFdBQUssZ0JBQUwsQ0FBc0Isb0JBQXRCO0FBQ0Q7O0FBRUQ7Ozs7d0JBQ2dCO0FBQ2QsYUFBTyxLQUFLLGdCQUFMLENBQXNCLFNBQTdCO0FBQ0Q7O0FBRUQ7O3NCQUNjLFEsRUFBVTtBQUN0QixxQkFBTyxHQUFQLG9CQUE0QixRQUE1QjtBQUNBLFdBQUssZUFBTCxDQUFxQixXQUFyQixHQUFtQyxRQUFuQztBQUNBLFdBQUssZ0JBQUwsQ0FBc0IsZUFBdEI7QUFDRDs7QUFFRDs7Ozt3QkFDZ0I7QUFDZCxhQUFPLEtBQUssZUFBTCxDQUFxQixLQUE1QjtBQUNEOztBQUVEOztzQkFDYyxRLEVBQVU7QUFDdEIscUJBQU8sR0FBUCxvQkFBNEIsUUFBNUI7QUFDQSxXQUFLLGVBQUwsQ0FBcUIsV0FBckIsR0FBbUMsUUFBbkM7QUFDRDs7QUFFRDs7Ozt3QkFDb0I7QUFDbEIsYUFBTyxLQUFLLGVBQUwsQ0FBcUIsYUFBNUI7QUFDRDs7QUFFRDs7c0JBQ2tCLEssRUFBTztBQUN2QixXQUFLLGVBQUwsQ0FBcUIsYUFBckIsR0FBcUMsS0FBckM7QUFDRDs7QUFFRDs7Ozs7d0JBRWlCO0FBQ2YsYUFBTyxLQUFLLEdBQUwsQ0FBUyxLQUFLLGVBQUwsQ0FBcUIsVUFBOUIsRUFBMEMsS0FBSyxhQUFMLENBQW1CLFlBQTdELENBQVA7QUFDRDs7QUFFRDs7O3NCQUVlLFEsRUFBVTtBQUN2QixxQkFBTyxHQUFQLHFCQUE2QixRQUE3QjtBQUNBLFdBQUssZUFBTCxDQUFxQixVQUFyQixHQUFrQyxRQUFsQztBQUNEOztBQUVEOzs7Ozs7O3dCQUlpQjtBQUNmLGFBQU8sS0FBSyxlQUFMLENBQXFCLFVBQTVCO0FBQ0Q7O0FBRUQ7Ozs7O3NCQUllLFEsRUFBVTtBQUN2QixxQkFBTyxHQUFQLHFCQUE2QixRQUE3QjtBQUNBLFdBQUssZUFBTCxDQUFxQixVQUFyQixHQUFrQyxRQUFsQztBQUNEOztBQUVEOzs7O3dCQUN1QjtBQUNyQixhQUFPLEtBQUssYUFBTCxDQUFtQixnQkFBMUI7QUFDRDs7QUFFRDs7c0JBQ3FCLFEsRUFBVTtBQUM3QixxQkFBTyxHQUFQLDJCQUFtQyxRQUFuQztBQUNBLFdBQUssYUFBTCxDQUFtQixnQkFBbkIsR0FBc0MsUUFBdEM7QUFDRDs7QUFFRDs7Ozt3QkFDdUI7QUFDckIsYUFBUSxLQUFLLGVBQUwsQ0FBcUIsV0FBckIsS0FBcUMsQ0FBQyxDQUE5QztBQUNEOztBQUVEOzs7O3dCQUNrQjtBQUNoQixhQUFPLEtBQUssZUFBTCxDQUFxQixXQUE1QjtBQUNEOztBQUVEOzs7O3dCQUNrQjtBQUNoQixhQUFPLEtBQUssb0JBQUwsQ0FBMEIsV0FBakM7QUFDRDs7QUFFRDs7Ozt3QkFDaUI7QUFDaEIsYUFBTyxLQUFLLG9CQUFMLENBQTBCLFVBQWpDO0FBQ0E7O0FBRUQ7O3NCQUNlLFksRUFBYztBQUMzQixXQUFLLG9CQUFMLENBQTBCLFVBQTFCLEdBQXVDLFlBQXZDO0FBQ0Q7Ozt3QkFFc0I7QUFDckIsYUFBTyxLQUFLLGdCQUFMLENBQXNCLGdCQUE3QjtBQUNEOztBQUVEOzs7O3dCQUNxQjtBQUNuQixhQUFPLEtBQUssdUJBQUwsQ0FBNkIsY0FBcEM7QUFDRDs7QUFFRDs7Ozt3QkFDb0I7QUFDbkIsYUFBTyxLQUFLLHVCQUFMLENBQTZCLGFBQXBDO0FBQ0E7O0FBRUQ7O3NCQUNrQixlLEVBQWlCO0FBQ2pDLFdBQUssdUJBQUwsQ0FBNkIsYUFBN0IsR0FBNkMsZUFBN0M7QUFDRDs7Ozs7O2tCQUdZLEc7Ozs7O0FDMVlmO0FBQ0E7QUFDQTtBQUNBLE9BQU8sT0FBUCxHQUFpQixRQUFRLFVBQVIsRUFBb0IsT0FBckM7Ozs7Ozs7Ozs7O0FDQ0E7Ozs7QUFDQTs7OztBQUNBOztBQUNBOzs7Ozs7OzsrZUFQQTs7OztJQVNNLGM7OztBQUVKLDBCQUFZLEdBQVosRUFBaUI7QUFBQTs7QUFBQSxnSUFDVCxHQURTLEVBQ0osaUJBQU0sWUFERjs7QUFFZixVQUFLLE9BQUwsR0FBZSxFQUFmO0FBRmU7QUFHaEI7Ozs7OEJBRVM7QUFDUixVQUFJLFVBQVUsS0FBSyxPQUFuQjtBQUNBLFdBQUssSUFBSSxVQUFULElBQXVCLE9BQXZCLEVBQWdDO0FBQzlCLFlBQUksU0FBUyxRQUFRLFVBQVIsQ0FBYjtBQUNBLFlBQUksTUFBSixFQUFZO0FBQ1YsaUJBQU8sT0FBUDtBQUNEO0FBQ0Y7QUFDRCxXQUFLLE9BQUwsR0FBZSxFQUFmO0FBQ0EsNkJBQWEsU0FBYixDQUF1QixPQUF2QixDQUErQixJQUEvQixDQUFvQyxJQUFwQztBQUNEOzs7a0NBRWEsSSxFQUFNO0FBQ2xCLFVBQUksT0FBTyxLQUFLLElBQWhCO0FBQUEsVUFDSSxPQUFPLEtBQUssSUFEaEI7QUFBQSxVQUVJLFNBQVMsS0FBSyxPQUFMLENBQWEsSUFBYixDQUZiO0FBQUEsVUFHSSxTQUFTLEtBQUssR0FBTCxDQUFTLE1BSHRCOztBQUtBLFdBQUssTUFBTCxHQUFjLENBQWQ7QUFDQSxVQUFJLE1BQUosRUFBWTtBQUNWLHVCQUFPLElBQVAsOENBQXVELElBQXZEO0FBQ0EsZUFBTyxLQUFQO0FBQ0Q7QUFDRCxlQUFVLEtBQUssT0FBTCxDQUFhLElBQWIsSUFBcUIsS0FBSyxNQUFMLEdBQWMsT0FBTyxPQUFPLE9BQWQsS0FBMkIsV0FBM0IsR0FBeUMsSUFBSSxPQUFPLE9BQVgsQ0FBbUIsTUFBbkIsQ0FBekMsR0FBc0UsSUFBSSxPQUFPLE1BQVgsQ0FBa0IsTUFBbEIsQ0FBbkg7O0FBRUEsVUFBSSxzQkFBSjtBQUFBLFVBQW1CLHFCQUFuQjtBQUFBLFVBQWlDLHdCQUFqQztBQUNBLHNCQUFnQixFQUFFLEtBQU0sS0FBSyxHQUFiLEVBQWtCLE1BQU8sSUFBekIsRUFBK0IsY0FBZSxhQUE5QyxFQUE2RCxjQUFlLEtBQTVFLEVBQWhCO0FBQ0EsVUFBSSxRQUFRLEtBQUssb0JBQWpCO0FBQUEsVUFBdUMsTUFBTSxLQUFLLGtCQUFsRDtBQUNBLFVBQUksQ0FBQyxNQUFNLEtBQU4sQ0FBRCxJQUFpQixDQUFDLE1BQU0sR0FBTixDQUF0QixFQUFrQztBQUNoQyxzQkFBYyxVQUFkLEdBQTJCLEtBQTNCO0FBQ0Esc0JBQWMsUUFBZCxHQUF5QixHQUF6QjtBQUNEO0FBQ0QscUJBQWUsRUFBRSxTQUFVLE9BQU8sa0JBQW5CLEVBQXVDLFVBQVcsQ0FBbEQsRUFBc0QsWUFBYSxDQUFuRSxFQUFzRSxlQUFnQixPQUFPLDBCQUE3RixFQUFmO0FBQ0Esd0JBQWtCLEVBQUUsV0FBWSxLQUFLLFdBQUwsQ0FBaUIsSUFBakIsQ0FBc0IsSUFBdEIsQ0FBZCxFQUEyQyxTQUFTLEtBQUssU0FBTCxDQUFlLElBQWYsQ0FBb0IsSUFBcEIsQ0FBcEQsRUFBK0UsV0FBWSxLQUFLLFdBQUwsQ0FBaUIsSUFBakIsQ0FBc0IsSUFBdEIsQ0FBM0YsRUFBd0gsWUFBWSxLQUFLLFlBQUwsQ0FBa0IsSUFBbEIsQ0FBdUIsSUFBdkIsQ0FBcEksRUFBbEI7QUFDQSxhQUFPLElBQVAsQ0FBWSxhQUFaLEVBQTBCLFlBQTFCLEVBQXVDLGVBQXZDO0FBQ0Q7OztnQ0FFVyxRLEVBQVUsSyxFQUFPLE8sRUFBUztBQUNwQyxVQUFJLFVBQVUsU0FBUyxJQUF2QjtBQUFBLFVBQTZCLE9BQU8sUUFBUSxJQUE1QztBQUNBO0FBQ0EsV0FBSyxNQUFMLEdBQWMsU0FBZDtBQUNBLFdBQUssT0FBTCxDQUFhLEtBQUssSUFBbEIsSUFBMEIsU0FBMUI7QUFDQSxXQUFLLEdBQUwsQ0FBUyxPQUFULENBQWlCLGlCQUFNLFdBQXZCLEVBQW9DLEVBQUMsU0FBUyxPQUFWLEVBQW1CLE1BQU0sSUFBekIsRUFBK0IsT0FBTyxLQUF0QyxFQUFwQztBQUNEOzs7OEJBRVMsUSxFQUFVLE8sRUFBUztBQUMzQixVQUFJLFNBQVMsUUFBUSxNQUFyQjtBQUNBLFVBQUksTUFBSixFQUFZO0FBQ1YsZUFBTyxLQUFQO0FBQ0Q7QUFDRCxXQUFLLE9BQUwsQ0FBYSxRQUFRLElBQXJCLElBQTZCLFNBQTdCO0FBQ0EsV0FBSyxHQUFMLENBQVMsT0FBVCxDQUFpQixpQkFBTSxLQUF2QixFQUE4QixFQUFDLE1BQU0sbUJBQVcsYUFBbEIsRUFBaUMsU0FBUyxxQkFBYSxlQUF2RCxFQUF3RSxPQUFPLEtBQS9FLEVBQXNGLE1BQU0sUUFBUSxJQUFwRyxFQUEwRyxVQUFVLFFBQXBILEVBQTlCO0FBQ0Q7OztnQ0FFVyxLLEVBQU8sTyxFQUFTO0FBQzFCLFVBQUksU0FBUyxRQUFRLE1BQXJCO0FBQ0EsVUFBSSxNQUFKLEVBQVk7QUFDVixlQUFPLEtBQVA7QUFDRDtBQUNELFdBQUssT0FBTCxDQUFhLFFBQVEsSUFBckIsSUFBNkIsU0FBN0I7QUFDQSxXQUFLLEdBQUwsQ0FBUyxPQUFULENBQWlCLGlCQUFNLEtBQXZCLEVBQThCLEVBQUMsTUFBTSxtQkFBVyxhQUFsQixFQUFpQyxTQUFTLHFCQUFhLGlCQUF2RCxFQUEwRSxPQUFPLEtBQWpGLEVBQXdGLE1BQU0sUUFBUSxJQUF0RyxFQUE5QjtBQUNEOztBQUVEOzs7O2lDQUNhLEssRUFBTyxPLEVBQVMsSSxFQUFNO0FBQUU7QUFDbkMsVUFBSSxPQUFPLFFBQVEsSUFBbkI7QUFDQSxXQUFLLE1BQUwsR0FBYyxNQUFNLE1BQXBCO0FBQ0EsV0FBSyxHQUFMLENBQVMsT0FBVCxDQUFpQixpQkFBTSxrQkFBdkIsRUFBMkMsRUFBQyxNQUFNLElBQVAsRUFBYSxPQUFPLEtBQXBCLEVBQTNDO0FBQ0Q7Ozs7OztrQkFHWSxjOzs7Ozs7Ozs7OztBQ25GZjs7OztBQUNBOzs7O0FBQ0E7O0FBQ0E7Ozs7Ozs7OytlQVBBOzs7O0lBU00sUzs7O0FBRUoscUJBQVksR0FBWixFQUFpQjtBQUFBOztBQUFBLHNIQUNULEdBRFMsRUFDSixpQkFBTSxXQURGOztBQUVmLFVBQUssT0FBTCxHQUFlLEVBQWY7QUFDQSxVQUFLLFVBQUwsR0FBa0IsSUFBbEI7QUFDQSxVQUFLLFVBQUwsR0FBa0IsSUFBbEI7QUFKZTtBQUtoQjs7Ozs4QkFFUztBQUNSLFdBQUssSUFBSSxVQUFULElBQXVCLEtBQUssT0FBNUIsRUFBcUM7QUFDbkMsWUFBSSxTQUFTLEtBQUssT0FBTCxDQUFhLFVBQWIsQ0FBYjtBQUNBLFlBQUksTUFBSixFQUFZO0FBQ1YsaUJBQU8sT0FBUDtBQUNEO0FBQ0Y7QUFDRCxXQUFLLE9BQUwsR0FBZSxFQUFmO0FBQ0EsNkJBQWEsU0FBYixDQUF1QixPQUF2QixDQUErQixJQUEvQixDQUFvQyxJQUFwQztBQUNEOzs7aUNBRVksSSxFQUFNO0FBQ2pCLFVBQUksT0FBTyxLQUFLLElBQWhCO0FBQUEsVUFDSSxPQUFPLEtBQUssSUFEaEI7QUFBQSxVQUVJLFNBQVMsS0FBSyxPQUFMLENBQWEsSUFBYixDQUZiO0FBQUEsVUFHSSxjQUFjLEtBQUssV0FIdkI7QUFBQSxVQUlJLE1BQU0sWUFBWSxHQUp0QjtBQUtJO0FBQ0YsVUFBSSxRQUFRLEtBQUssVUFBYixJQUEyQixLQUFLLFVBQUwsS0FBb0IsSUFBbkQsRUFBeUQ7QUFDdkQsWUFBSSxTQUFTLEtBQUssR0FBTCxDQUFTLE1BQXRCOztBQUVBLFlBQUksTUFBSixFQUFZO0FBQ1YseUJBQU8sSUFBUCx5Q0FBa0QsSUFBbEQ7QUFDQSxpQkFBTyxLQUFQO0FBQ0Q7QUFDRCxhQUFLLE1BQUwsR0FBYyxLQUFLLE9BQUwsQ0FBYSxJQUFiLElBQXFCLElBQUksT0FBTyxNQUFYLENBQWtCLE1BQWxCLENBQW5DO0FBQ0EsYUFBSyxVQUFMLEdBQWtCLEdBQWxCO0FBQ0EsYUFBSyxVQUFMLEdBQWtCLElBQWxCOztBQUVBLFlBQUksc0JBQUo7QUFBQSxZQUFtQixxQkFBbkI7QUFBQSxZQUFpQyx3QkFBakM7QUFDQSx3QkFBZ0IsRUFBRSxLQUFNLEdBQVIsRUFBYSxNQUFPLElBQXBCLEVBQTBCLGNBQWUsYUFBekMsRUFBaEI7QUFDQSx1QkFBZSxFQUFFLFNBQVUsT0FBTyxrQkFBbkIsRUFBdUMsVUFBVyxPQUFPLG1CQUF6RCxFQUErRSxZQUFhLE9BQU8scUJBQW5HLEVBQTBILGVBQWdCLE9BQU8sMEJBQWpKLEVBQWY7QUFDQSwwQkFBa0IsRUFBRSxXQUFZLEtBQUssV0FBTCxDQUFpQixJQUFqQixDQUFzQixJQUF0QixDQUFkLEVBQTJDLFNBQVMsS0FBSyxTQUFMLENBQWUsSUFBZixDQUFvQixJQUFwQixDQUFwRCxFQUErRSxXQUFZLEtBQUssV0FBTCxDQUFpQixJQUFqQixDQUFzQixJQUF0QixDQUEzRixFQUFsQjtBQUNBLGFBQUssTUFBTCxDQUFZLElBQVosQ0FBaUIsYUFBakIsRUFBK0IsWUFBL0IsRUFBNEMsZUFBNUM7QUFDRCxPQWhCRCxNQWdCTyxJQUFJLEtBQUssVUFBVCxFQUFxQjtBQUMxQjtBQUNBLG9CQUFZLEdBQVosR0FBa0IsS0FBSyxVQUF2QjtBQUNBLGFBQUssR0FBTCxDQUFTLE9BQVQsQ0FBaUIsaUJBQU0sVUFBdkIsRUFBbUMsRUFBQyxNQUFNLElBQVAsRUFBbkM7QUFDRDtBQUNKOzs7Z0NBRVcsUSxFQUFVLEssRUFBTyxPLEVBQVM7QUFDcEMsVUFBSSxPQUFPLFFBQVEsSUFBbkI7QUFDQSxXQUFLLFVBQUwsR0FBa0IsS0FBSyxXQUFMLENBQWlCLEdBQWpCLEdBQXVCLElBQUksVUFBSixDQUFlLFNBQVMsSUFBeEIsQ0FBekM7QUFDQTtBQUNBLFdBQUssTUFBTCxHQUFjLFNBQWQ7QUFDQSxXQUFLLE9BQUwsQ0FBYSxLQUFLLElBQWxCLElBQTBCLFNBQTFCO0FBQ0EsV0FBSyxHQUFMLENBQVMsT0FBVCxDQUFpQixpQkFBTSxVQUF2QixFQUFtQyxFQUFDLE1BQU0sSUFBUCxFQUFuQztBQUNEOzs7OEJBRVMsUSxFQUFVLE8sRUFBUztBQUMzQixVQUFJLE9BQU8sUUFBUSxJQUFuQjtBQUFBLFVBQ0ksU0FBUyxLQUFLLE1BRGxCO0FBRUEsVUFBSSxNQUFKLEVBQVk7QUFDVixlQUFPLEtBQVA7QUFDRDtBQUNELFdBQUssT0FBTCxDQUFhLFFBQVEsSUFBckIsSUFBNkIsU0FBN0I7QUFDQSxXQUFLLEdBQUwsQ0FBUyxPQUFULENBQWlCLGlCQUFNLEtBQXZCLEVBQThCLEVBQUMsTUFBTSxtQkFBVyxhQUFsQixFQUFpQyxTQUFTLHFCQUFhLGNBQXZELEVBQXVFLE9BQU8sS0FBOUUsRUFBcUYsTUFBTSxJQUEzRixFQUFpRyxVQUFVLFFBQTNHLEVBQTlCO0FBQ0Q7OztnQ0FFVyxLLEVBQU8sTyxFQUFTO0FBQzFCLFVBQUksT0FBTyxRQUFRLElBQW5CO0FBQUEsVUFDSSxTQUFTLEtBQUssTUFEbEI7QUFFQSxVQUFJLE1BQUosRUFBWTtBQUNWLGVBQU8sS0FBUDtBQUNEO0FBQ0QsV0FBSyxPQUFMLENBQWEsUUFBUSxJQUFyQixJQUE2QixTQUE3QjtBQUNBLFdBQUssR0FBTCxDQUFTLE9BQVQsQ0FBaUIsaUJBQU0sS0FBdkIsRUFBOEIsRUFBQyxNQUFNLG1CQUFXLGFBQWxCLEVBQWlDLFNBQVMscUJBQWEsZ0JBQXZELEVBQXlFLE9BQU8sS0FBaEYsRUFBdUYsTUFBTSxJQUE3RixFQUE5QjtBQUNEOzs7Ozs7a0JBR1ksUzs7Ozs7Ozs7O3FqQkN6RmY7Ozs7QUFJQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7QUFDQTs7OztBQUNBOzs7Ozs7Ozs7O0FBRUE7QUFDQSxJQUFNLHdCQUF3QixnREFBOUI7QUFDQSxJQUFNLDhCQUE4QixvQkFBcEM7QUFDQSxJQUFNLDRCQUE0QixnR0FBbEM7QUFDQSxJQUFNLDRCQUE0Qix1VUFBbEM7O0lBRU0sUTtBQUVKLHNCQUFjO0FBQUE7O0FBQ1osU0FBSyxNQUFMLEdBQWMsSUFBZDtBQUNBLFNBQUssR0FBTCxHQUFXLElBQVg7QUFDQSxTQUFLLEVBQUwsR0FBVSxJQUFWO0FBQ0EsU0FBSyxJQUFMLEdBQVksSUFBWjtBQUNEOzs7O3dCQUVTO0FBQ1IsVUFBSSxDQUFDLEtBQUssSUFBTixJQUFjLEtBQUssTUFBdkIsRUFBK0I7QUFDN0IsYUFBSyxJQUFMLEdBQVkscUJBQVcsZ0JBQVgsQ0FBNEIsS0FBSyxPQUFqQyxFQUEwQyxLQUFLLE1BQS9DLENBQVo7QUFDRDtBQUNELGFBQU8sS0FBSyxJQUFaO0FBQ0Q7Ozs7OztJQUlHLFE7QUFFSixzQkFBYztBQUFBOztBQUNaLFNBQUssSUFBTCxHQUFZLElBQVo7QUFDQSxTQUFLLFVBQUwsR0FBa0IsSUFBbEI7QUFDQSxTQUFLLFlBQUwsR0FBb0IsSUFBcEI7QUFDRDs7Ozs7O0FBb0REOzs7OytDQUkyQixhLEVBQWU7QUFDeEMsVUFBSSxZQUFZLElBQUksVUFBSixDQUFlLEVBQWYsQ0FBaEI7O0FBRUEsV0FBSyxJQUFJLElBQUksRUFBYixFQUFpQixJQUFJLEVBQXJCLEVBQXlCLEdBQXpCLEVBQThCO0FBQzVCLGtCQUFVLENBQVYsSUFBZ0IsaUJBQWlCLEtBQUssS0FBSyxDQUFWLENBQWxCLEdBQWtDLElBQWpEO0FBQ0Q7O0FBRUQsYUFBTyxTQUFQO0FBQ0Q7O0FBRUQ7Ozs7Ozs7OztvREFNZ0MsUSxFQUFVLGEsRUFBZTtBQUN2RCxVQUFJLGNBQWMsUUFBbEI7O0FBRUEsVUFBSSxZQUFZLFNBQVMsTUFBckIsSUFBK0IsU0FBUyxHQUF4QyxJQUErQyxDQUFDLFNBQVMsRUFBN0QsRUFBaUU7QUFDL0Qsc0JBQWMsT0FBTyxNQUFQLENBQWMsSUFBSSxRQUFKLEVBQWQsRUFBOEIsS0FBSyxRQUFMLENBQWMsUUFBZCxDQUE5QixDQUFkO0FBQ0Esb0JBQVksRUFBWixHQUFpQixLQUFLLDBCQUFMLENBQWdDLGFBQWhDLENBQWpCO0FBQ0Q7O0FBRUQsYUFBTyxXQUFQO0FBQ0Q7Ozs2QkFFUSxHLEVBQUs7QUFDWixhQUFPLEtBQUssS0FBTCxDQUFXLEtBQUssU0FBTCxDQUFlLEdBQWYsQ0FBWCxDQUFQO0FBQ0Q7Ozt3QkFuRlM7QUFDUixVQUFJLENBQUMsS0FBSyxJQUFOLElBQWMsS0FBSyxNQUF2QixFQUErQjtBQUM3QixhQUFLLElBQUwsR0FBWSxxQkFBVyxnQkFBWCxDQUE0QixLQUFLLE9BQWpDLEVBQTBDLEtBQUssTUFBL0MsQ0FBWjtBQUNEO0FBQ0QsYUFBTyxLQUFLLElBQVo7QUFDRCxLO3NCQUVPLEssRUFBTztBQUNiLFdBQUssSUFBTCxHQUFZLEtBQVo7QUFDRDs7O3dCQUVxQjtBQUNwQixVQUFJLENBQUMsS0FBSyxnQkFBTixJQUEwQixLQUFLLGtCQUFuQyxFQUF1RDtBQUNyRCxhQUFLLGdCQUFMLEdBQXdCLElBQUksSUFBSixDQUFTLEtBQUssS0FBTCxDQUFXLEtBQUssa0JBQWhCLENBQVQsQ0FBeEI7QUFDRDtBQUNELGFBQU8sS0FBSyxnQkFBWjtBQUNEOzs7d0JBRWU7QUFDZCxVQUFJLENBQUMsS0FBSyxVQUFWLEVBQXNCO0FBQ3BCLGFBQUssVUFBTCxHQUFrQixFQUFsQjtBQUNBLFlBQUksS0FBSyxZQUFULEVBQXVCO0FBQ3JCLGNBQU0sU0FBUyxLQUFLLFlBQUwsQ0FBa0IsS0FBbEIsQ0FBd0IsR0FBeEIsRUFBNkIsQ0FBN0IsQ0FBZjtBQUNBLGNBQUksT0FBTyxNQUFQLEtBQWtCLENBQXRCLEVBQXlCO0FBQ3ZCLGlCQUFLLFVBQUwsQ0FBZ0IsQ0FBaEIsSUFBcUIsS0FBSyxRQUFMLEdBQWdCLEtBQUssUUFBTCxDQUFjLGtCQUE5QixHQUFtRCxDQUF4RTtBQUNELFdBRkQsTUFFTztBQUNMLGlCQUFLLFVBQUwsQ0FBZ0IsQ0FBaEIsSUFBcUIsU0FBUyxPQUFPLENBQVAsQ0FBVCxDQUFyQjtBQUNEO0FBQ0QsZUFBSyxVQUFMLENBQWdCLENBQWhCLElBQXFCLFNBQVMsT0FBTyxDQUFQLENBQVQsSUFBc0IsS0FBSyxVQUFMLENBQWdCLENBQWhCLENBQTNDO0FBQ0EsZUFBSyxRQUFMLEdBQWdCLElBQWhCO0FBQ0Q7QUFDRjtBQUNELGFBQU8sS0FBSyxVQUFaO0FBQ0Q7Ozt3QkFFMEI7QUFDekIsYUFBTyxLQUFLLFNBQUwsQ0FBZSxDQUFmLENBQVA7QUFDRDs7O3dCQUV3QjtBQUN2QixhQUFPLEtBQUssU0FBTCxDQUFlLENBQWYsQ0FBUDtBQUNEOzs7d0JBRWlCO0FBQ2hCLFVBQUksQ0FBQyxLQUFLLFlBQVYsRUFBd0I7QUFDdEIsYUFBSyxZQUFMLEdBQW9CLEtBQUssK0JBQUwsQ0FBcUMsS0FBSyxRQUExQyxFQUFvRCxLQUFLLEVBQXpELENBQXBCO0FBQ0Q7QUFDRCxhQUFPLEtBQUssWUFBWjtBQUNEOzs7Ozs7SUFzQ0csYzs7O0FBRUosMEJBQVksR0FBWixFQUFpQjtBQUFBOztBQUFBLGdJQUNULEdBRFMsRUFFYixpQkFBTSxnQkFGTyxFQUdiLGlCQUFNLGFBSE8sRUFJYixpQkFBTSxtQkFKTyxFQUtiLGlCQUFNLHNCQUxPOztBQU1mLFVBQUssT0FBTCxHQUFlLEVBQWY7QUFOZTtBQU9oQjs7Ozs4QkFFUztBQUNSLFdBQUssSUFBSSxVQUFULElBQXVCLEtBQUssT0FBNUIsRUFBcUM7QUFDbkMsWUFBSSxTQUFTLEtBQUssT0FBTCxDQUFhLFVBQWIsQ0FBYjtBQUNBLFlBQUksTUFBSixFQUFZO0FBQ1YsaUJBQU8sT0FBUDtBQUNEO0FBQ0Y7QUFDRCxXQUFLLE9BQUwsR0FBZSxFQUFmO0FBQ0EsNkJBQWEsU0FBYixDQUF1QixPQUF2QixDQUErQixJQUEvQixDQUFvQyxJQUFwQztBQUNEOzs7c0NBRWlCLEksRUFBTTtBQUN0QixXQUFLLElBQUwsQ0FBVSxLQUFLLEdBQWYsRUFBb0IsRUFBRSxNQUFPLFVBQVQsRUFBcEI7QUFDRDs7O21DQUVjLEksRUFBTTtBQUNuQixXQUFLLElBQUwsQ0FBVSxLQUFLLEdBQWYsRUFBb0IsRUFBRSxNQUFPLE9BQVQsRUFBa0IsT0FBUSxLQUFLLEtBQS9CLEVBQXNDLElBQUssS0FBSyxFQUFoRCxFQUFwQjtBQUNEOzs7d0NBRW1CLEksRUFBTTtBQUN4QixXQUFLLElBQUwsQ0FBVSxLQUFLLEdBQWYsRUFBb0IsRUFBRSxNQUFPLFlBQVQsRUFBdUIsSUFBSyxLQUFLLEVBQWpDLEVBQXBCO0FBQ0Q7OzsyQ0FFc0IsSSxFQUFNO0FBQzNCLFdBQUssSUFBTCxDQUFVLEtBQUssR0FBZixFQUFvQixFQUFFLE1BQU8sZUFBVCxFQUEwQixJQUFLLEtBQUssRUFBcEMsRUFBcEI7QUFDRDs7O3lCQUVJLEcsRUFBSyxPLEVBQVM7QUFDakIsVUFBSSxTQUFTLEtBQUssT0FBTCxDQUFhLFFBQVEsSUFBckIsQ0FBYjtBQUNBLFVBQUksTUFBSixFQUFZO0FBQ1YsWUFBSSxnQkFBZ0IsT0FBTyxPQUEzQjtBQUNBLFlBQUksaUJBQWlCLGNBQWMsR0FBZCxLQUFzQixHQUEzQyxFQUFnRDtBQUM5Qyx5QkFBTyxLQUFQO0FBQ0E7QUFDRCxTQUhELE1BR087QUFDTCx5QkFBTyxJQUFQLHFDQUE4QyxRQUFRLElBQXREO0FBQ0EsaUJBQU8sS0FBUDtBQUNEO0FBQ0Y7QUFDRCxVQUFJLFNBQVMsS0FBSyxHQUFMLENBQVMsTUFBdEI7QUFBQSxVQUNJLGNBREo7QUFBQSxVQUVJLGdCQUZKO0FBQUEsVUFHSSxtQkFISjtBQUFBLFVBSUksc0JBSko7QUFLQSxVQUFHLFFBQVEsSUFBUixLQUFpQixVQUFwQixFQUFnQztBQUM5QixnQkFBUSxPQUFPLHVCQUFmO0FBQ0Esa0JBQVUsT0FBTyxzQkFBakI7QUFDQSxxQkFBYSxPQUFPLHlCQUFwQjtBQUNBLHdCQUFnQixPQUFPLDhCQUF2QjtBQUNELE9BTEQsTUFLTztBQUNMLGdCQUFRLE9BQU8sb0JBQWY7QUFDQSxrQkFBVSxPQUFPLG1CQUFqQjtBQUNBLHFCQUFhLE9BQU8sc0JBQXBCO0FBQ0Esd0JBQWdCLE9BQU8sMkJBQXZCO0FBQ0EsdUJBQU8sR0FBUCwyQkFBbUMsUUFBUSxJQUEzQyxVQUFtRCxRQUFRLEtBQVIsSUFBaUIsUUFBUSxFQUE1RTtBQUNEO0FBQ0QsZUFBVSxLQUFLLE9BQUwsQ0FBYSxRQUFRLElBQXJCLElBQTZCLFFBQVEsTUFBUixHQUFpQixPQUFPLE9BQU8sT0FBZCxLQUEyQixXQUEzQixHQUF5QyxJQUFJLE9BQU8sT0FBWCxDQUFtQixNQUFuQixDQUF6QyxHQUFzRSxJQUFJLE9BQU8sTUFBWCxDQUFrQixNQUFsQixDQUE5SDtBQUNBLGNBQVEsR0FBUixHQUFjLEdBQWQ7QUFDQSxjQUFRLFlBQVIsR0FBdUIsRUFBdkI7O0FBRUEsVUFBSSxxQkFBSjtBQUFBLFVBQWtCLHdCQUFsQjtBQUNBLHFCQUFlLEVBQUUsU0FBVSxPQUFaLEVBQXFCLFVBQVcsS0FBaEMsRUFBd0MsWUFBYSxVQUFyRCxFQUFpRSxlQUFnQixhQUFqRixFQUFmO0FBQ0Esd0JBQWtCLEVBQUUsV0FBWSxLQUFLLFdBQUwsQ0FBaUIsSUFBakIsQ0FBc0IsSUFBdEIsQ0FBZCxFQUEyQyxTQUFTLEtBQUssU0FBTCxDQUFlLElBQWYsQ0FBb0IsSUFBcEIsQ0FBcEQsRUFBK0UsV0FBWSxLQUFLLFdBQUwsQ0FBaUIsSUFBakIsQ0FBc0IsSUFBdEIsQ0FBM0YsRUFBbEI7QUFDQSxhQUFPLElBQVAsQ0FBWSxPQUFaLEVBQW9CLFlBQXBCLEVBQWlDLGVBQWpDO0FBQ0Q7Ozs0QkFFTyxHLEVBQUssTyxFQUFTO0FBQ3BCLGFBQU8scUJBQVcsZ0JBQVgsQ0FBNEIsT0FBNUIsRUFBcUMsR0FBckMsQ0FBUDtBQUNEOzs7d0NBRW1CLE0sRUFBUSxPLEVBQVM7QUFDbkMsVUFBSSxTQUFTLEVBQWI7QUFBQSxVQUFpQixlQUFqQjtBQUNBLDRCQUFzQixTQUF0QixHQUFrQyxDQUFsQztBQUNBLGFBQU8sQ0FBQyxTQUFTLHNCQUFzQixJQUF0QixDQUEyQixNQUEzQixDQUFWLEtBQWlELElBQXhELEVBQTZEO0FBQzNELFlBQU0sUUFBUSxFQUFkOztBQUVBLFlBQUksUUFBUSxNQUFNLEtBQU4sR0FBYyx1QkFBYSxPQUFPLENBQVAsQ0FBYixDQUExQjtBQUNBLGNBQU0sR0FBTixHQUFZLEtBQUssT0FBTCxDQUFhLE9BQU8sQ0FBUCxDQUFiLEVBQXdCLE9BQXhCLENBQVo7O0FBRUEsWUFBSSxhQUFhLE1BQU0saUJBQU4sQ0FBd0IsWUFBeEIsQ0FBakI7QUFDQSxZQUFHLFVBQUgsRUFBZTtBQUNiLGdCQUFNLEtBQU4sR0FBYyxXQUFXLEtBQXpCO0FBQ0EsZ0JBQU0sTUFBTixHQUFlLFdBQVcsTUFBMUI7QUFDRDtBQUNELGNBQU0sT0FBTixHQUFnQixNQUFNLGNBQU4sQ0FBcUIsbUJBQXJCLEtBQTZDLE1BQU0sY0FBTixDQUFxQixXQUFyQixDQUE3RDtBQUNBLGNBQU0sSUFBTixHQUFhLE1BQU0sSUFBbkI7O0FBRUEsWUFBSSxTQUFTLE1BQU0sTUFBbkI7QUFDQSxZQUFHLE1BQUgsRUFBVztBQUNULG1CQUFTLE9BQU8sS0FBUCxDQUFhLE9BQWIsQ0FBVDtBQUNBLGVBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxPQUFPLE1BQTNCLEVBQW1DLEdBQW5DLEVBQXdDO0FBQ3RDLGdCQUFNLFFBQVEsT0FBTyxDQUFQLENBQWQ7QUFDQSxnQkFBSSxNQUFNLE9BQU4sQ0FBYyxNQUFkLE1BQTBCLENBQUMsQ0FBL0IsRUFBa0M7QUFDaEMsb0JBQU0sVUFBTixHQUFtQixLQUFLLFlBQUwsQ0FBa0IsS0FBbEIsQ0FBbkI7QUFDRCxhQUZELE1BRU87QUFDTCxvQkFBTSxVQUFOLEdBQW1CLEtBQW5CO0FBQ0Q7QUFDRjtBQUNGOztBQUVELGVBQU8sSUFBUCxDQUFZLEtBQVo7QUFDRDtBQUNELGFBQU8sTUFBUDtBQUNEOzs7NkNBRXdCLE0sRUFBUSxPLEVBQVMsSSxFQUFNO0FBQzlDLFVBQUksZUFBSjtBQUFBLFVBQVksU0FBUyxFQUFyQjtBQUFBLFVBQXlCLEtBQUssQ0FBOUI7QUFDQSxrQ0FBNEIsU0FBNUIsR0FBd0MsQ0FBeEM7QUFDQSxhQUFPLENBQUMsU0FBUyw0QkFBNEIsSUFBNUIsQ0FBaUMsTUFBakMsQ0FBVixLQUF1RCxJQUE5RCxFQUFtRTtBQUNqRSxZQUFNLFFBQVEsRUFBZDtBQUNBLFlBQUksUUFBUSx1QkFBYSxPQUFPLENBQVAsQ0FBYixDQUFaO0FBQ0EsWUFBRyxNQUFNLElBQU4sS0FBZSxJQUFsQixFQUF3QjtBQUN0QixnQkFBTSxPQUFOLEdBQWdCLE1BQU0sVUFBTixDQUFoQjtBQUNBLGdCQUFNLElBQU4sR0FBYSxNQUFNLElBQW5CO0FBQ0EsZ0JBQU0sSUFBTixHQUFhLElBQWI7QUFDQSxnQkFBTSxPQUFOLEdBQWlCLE1BQU0sT0FBTixLQUFrQixLQUFuQztBQUNBLGdCQUFNLFVBQU4sR0FBb0IsTUFBTSxVQUFOLEtBQXFCLEtBQXpDO0FBQ0EsZ0JBQU0sTUFBTixHQUFnQixNQUFNLE1BQU4sS0FBaUIsS0FBakM7QUFDQSxjQUFJLE1BQU0sR0FBVixFQUFlO0FBQ2Isa0JBQU0sR0FBTixHQUFZLEtBQUssT0FBTCxDQUFhLE1BQU0sR0FBbkIsRUFBd0IsT0FBeEIsQ0FBWjtBQUNEO0FBQ0QsZ0JBQU0sSUFBTixHQUFhLE1BQU0sUUFBbkI7QUFDQSxjQUFHLENBQUMsTUFBTSxJQUFWLEVBQWdCO0FBQ1osa0JBQU0sSUFBTixHQUFhLE1BQU0sSUFBbkI7QUFDSDtBQUNELGdCQUFNLEVBQU4sR0FBVyxJQUFYO0FBQ0EsaUJBQU8sSUFBUCxDQUFZLEtBQVo7QUFDRDtBQUNGO0FBQ0QsYUFBTyxNQUFQO0FBQ0Q7OztpQ0FFWSxLLEVBQU87QUFDbEIsVUFBSSxNQUFKO0FBQUEsVUFBWSxVQUFVLE1BQU0sS0FBTixDQUFZLEdBQVosQ0FBdEI7QUFDQSxVQUFJLFFBQVEsTUFBUixHQUFpQixDQUFyQixFQUF3QjtBQUN0QixpQkFBUyxRQUFRLEtBQVIsS0FBa0IsR0FBM0I7QUFDQSxrQkFBVSxTQUFTLFFBQVEsS0FBUixFQUFULEVBQTBCLFFBQTFCLENBQW1DLEVBQW5DLENBQVY7QUFDQSxrQkFBVSxDQUFDLFFBQVEsU0FBUyxRQUFRLEtBQVIsRUFBVCxFQUEwQixRQUExQixDQUFtQyxFQUFuQyxDQUFULEVBQWlELE1BQWpELENBQXdELENBQUMsQ0FBekQsQ0FBVjtBQUNELE9BSkQsTUFJTztBQUNMLGlCQUFTLEtBQVQ7QUFDRDtBQUNELGFBQU8sTUFBUDtBQUNEOzs7dUNBRWtCLE0sRUFBUSxPLEVBQVMsRSxFQUFJLEksRUFBTTtBQUM1QyxVQUFJLFlBQVksQ0FBaEI7QUFBQSxVQUNJLGdCQUFnQixDQURwQjtBQUFBLFVBRUksUUFBUSxFQUFDLE1BQU0sSUFBUCxFQUFhLFNBQVMsSUFBdEIsRUFBNEIsS0FBSyxPQUFqQyxFQUEwQyxXQUFXLEVBQXJELEVBQXlELE1BQU0sSUFBL0QsRUFBcUUsU0FBUyxDQUE5RSxFQUZaO0FBQUEsVUFHSSxXQUFXLElBQUksUUFBSixFQUhmO0FBQUEsVUFJSSxLQUFLLENBSlQ7QUFBQSxVQUtJLFdBQVcsSUFMZjtBQUFBLFVBTUksT0FBTyxJQUFJLFFBQUosRUFOWDtBQUFBLFVBT0ksTUFQSjtBQUFBLFVBUUksQ0FSSjs7QUFVQSxXQUFLLE9BQUwsR0FBZSxFQUFmOztBQUVBLGdDQUEwQixTQUExQixHQUFzQyxDQUF0Qzs7QUFFQSxhQUFPLENBQUMsU0FBUywwQkFBMEIsSUFBMUIsQ0FBK0IsTUFBL0IsQ0FBVixNQUFzRCxJQUE3RCxFQUFtRTtBQUNqRSxZQUFNLFdBQVcsT0FBTyxDQUFQLENBQWpCO0FBQ0EsWUFBSSxRQUFKLEVBQWM7QUFBRTtBQUNkLGVBQUssUUFBTCxHQUFnQixXQUFXLFFBQVgsQ0FBaEI7QUFDQSxjQUFNLFFBQVEsT0FBTyxDQUFQLENBQWQ7QUFDQSxlQUFLLEtBQUwsR0FBYSxRQUFRLEtBQVIsR0FBZ0IsSUFBN0I7QUFDQSxlQUFLLE9BQUwsQ0FBYSxJQUFiLENBQWtCLFFBQVEsQ0FBRSxLQUFGLEVBQVEsUUFBUixFQUFpQixLQUFqQixDQUFSLEdBQW1DLENBQUUsS0FBRixFQUFRLFFBQVIsQ0FBckQ7QUFDRCxTQUxELE1BS08sSUFBSSxPQUFPLENBQVAsQ0FBSixFQUFlO0FBQUU7QUFDdEIsY0FBSSxDQUFDLE1BQU0sS0FBSyxRQUFYLENBQUwsRUFBMkI7QUFDekIsZ0JBQU0sS0FBSyxXQUFYO0FBQ0EsaUJBQUssSUFBTCxHQUFZLElBQVo7QUFDQSxpQkFBSyxRQUFMLEdBQWdCLFFBQWhCO0FBQ0EsaUJBQUssS0FBTCxHQUFhLGFBQWI7QUFDQSxpQkFBSyxRQUFMLEdBQWdCLFFBQWhCO0FBQ0EsaUJBQUssRUFBTCxHQUFVLEVBQVY7QUFDQSxpQkFBSyxLQUFMLEdBQWEsRUFBYjtBQUNBLGlCQUFLLEVBQUwsR0FBVSxFQUFWO0FBQ0EsaUJBQUssT0FBTCxHQUFlLE9BQWY7QUFDQSxpQkFBSyxNQUFMLEdBQWMsT0FBTyxDQUFQLENBQWQ7O0FBRUEsa0JBQU0sU0FBTixDQUFnQixJQUFoQixDQUFxQixJQUFyQjtBQUNBLHVCQUFXLElBQVg7QUFDQSw2QkFBaUIsS0FBSyxRQUF0Qjs7QUFFQSxtQkFBTyxJQUFJLFFBQUosRUFBUDtBQUNBLGlCQUFLLE9BQUwsR0FBZSxFQUFmO0FBQ0Q7QUFDRixTQXBCTSxNQW9CQSxJQUFJLE9BQU8sQ0FBUCxDQUFKLEVBQWU7QUFBRTtBQUN0QixlQUFLLFlBQUwsR0FBb0IsT0FBTyxDQUFQLENBQXBCO0FBQ0QsU0FGTSxNQUVBLElBQUksT0FBTyxDQUFQLENBQUosRUFBZTtBQUFFO0FBQ3RCLGVBQUssa0JBQUwsR0FBMEIsT0FBTyxDQUFQLENBQTFCO0FBQ0EsZUFBSyxPQUFMLENBQWEsSUFBYixDQUFrQixDQUFDLG1CQUFELEVBQXNCLE9BQU8sQ0FBUCxDQUF0QixDQUFsQjtBQUNELFNBSE0sTUFHQTtBQUNMLG1CQUFTLE9BQU8sQ0FBUCxFQUFVLEtBQVYsQ0FBZ0IseUJBQWhCLENBQVQ7QUFDQSxlQUFLLElBQUksQ0FBVCxFQUFZLElBQUksT0FBTyxNQUF2QixFQUErQixHQUEvQixFQUFvQztBQUNsQyxnQkFBSSxPQUFPLENBQVAsTUFBYyxTQUFsQixFQUE2QjtBQUMzQjtBQUNEO0FBQ0Y7O0FBRUQsY0FBTSxTQUFTLE9BQU8sSUFBRSxDQUFULENBQWY7QUFDQSxjQUFNLFNBQVMsT0FBTyxJQUFFLENBQVQsQ0FBZjs7QUFFQSxrQkFBUSxPQUFPLENBQVAsQ0FBUjtBQUNFLGlCQUFLLEdBQUw7QUFDRSxtQkFBSyxPQUFMLENBQWEsSUFBYixDQUFrQixTQUFTLENBQUUsTUFBRixFQUFTLE1BQVQsQ0FBVCxHQUE2QixDQUFFLE1BQUYsQ0FBL0M7QUFDQTtBQUNGLGlCQUFLLGVBQUw7QUFDRSxvQkFBTSxJQUFOLEdBQWEsT0FBTyxXQUFQLEVBQWI7QUFDQTtBQUNGLGlCQUFLLGdCQUFMO0FBQ0UsMEJBQVksTUFBTSxPQUFOLEdBQWdCLFNBQVMsTUFBVCxDQUE1QjtBQUNBO0FBQ0YsaUJBQUssZ0JBQUw7QUFDRSxvQkFBTSxjQUFOLEdBQXVCLFdBQVcsTUFBWCxDQUF2QjtBQUNBO0FBQ0YsaUJBQUssU0FBTDtBQUNFLG9CQUFNLE9BQU4sR0FBZ0IsU0FBUyxNQUFULENBQWhCO0FBQ0E7QUFDRixpQkFBSyxRQUFMO0FBQ0U7QUFDRixpQkFBSyxTQUFMO0FBQ0Usb0JBQU0sSUFBTixHQUFhLEtBQWI7QUFDQTtBQUNGLGlCQUFLLEtBQUw7QUFDRTtBQUNBLG1CQUFLLE9BQUwsQ0FBYSxJQUFiLENBQWtCLENBQUMsS0FBRCxDQUFsQjtBQUNBO0FBQ0YsaUJBQUssbUJBQUw7QUFDRSxtQkFBSyxTQUFTLE1BQVQsQ0FBTDtBQUNBO0FBQ0YsaUJBQUssS0FBTDtBQUNFO0FBQ0Esa0JBQUksZ0JBQWdCLE1BQXBCO0FBQ0Esa0JBQUksV0FBVyx1QkFBYSxhQUFiLENBQWY7QUFDQSxrQkFBSSxnQkFBZ0IsU0FBUyxnQkFBVCxDQUEwQixRQUExQixDQUFwQjtBQUFBLGtCQUNJLGFBQWEsU0FBUyxHQUQxQjtBQUFBLGtCQUVJLFlBQVksU0FBUyxrQkFBVCxDQUE0QixJQUE1QixDQUZoQjtBQUdBLGtCQUFJLGFBQUosRUFBbUI7QUFDakIsMkJBQVcsSUFBSSxRQUFKLEVBQVg7QUFDQSxvQkFBSyxVQUFELElBQWlCLGtCQUFrQixTQUF2QyxFQUFtRDtBQUNqRCwyQkFBUyxNQUFULEdBQWtCLGFBQWxCO0FBQ0E7QUFDQSwyQkFBUyxPQUFULEdBQW1CLE9BQW5CO0FBQ0EsMkJBQVMsTUFBVCxHQUFrQixVQUFsQjtBQUNBLDJCQUFTLEdBQVQsR0FBZSxJQUFmO0FBQ0E7QUFDQSwyQkFBUyxFQUFULEdBQWMsU0FBZDtBQUNEO0FBQ0Y7QUFDRDtBQUNGLGlCQUFLLE9BQUw7QUFDRSxrQkFBSSxjQUFjLE1BQWxCO0FBQ0Esa0JBQUksYUFBYSx1QkFBYSxXQUFiLENBQWpCO0FBQ0Esa0JBQUksa0JBQWtCLFdBQVcsb0JBQVgsQ0FBZ0MsYUFBaEMsQ0FBdEI7QUFDQTtBQUNBLGtCQUFLLENBQUMsTUFBTSxlQUFOLENBQU4sRUFBK0I7QUFDN0Isc0JBQU0sZUFBTixHQUF3QixlQUF4QjtBQUNEO0FBQ0Q7QUFDRjtBQUNFLDZCQUFPLElBQVAsbUNBQTRDLE1BQTVDO0FBQ0E7QUEzREo7QUE2REQ7QUFDRjtBQUNELGFBQU8sUUFBUDtBQUNBO0FBQ0EsVUFBRyxRQUFRLENBQUMsS0FBSyxNQUFqQixFQUF5QjtBQUN2QixjQUFNLFNBQU4sQ0FBZ0IsR0FBaEI7QUFDQSx5QkFBZSxLQUFLLFFBQXBCO0FBQ0Q7QUFDRCxZQUFNLGFBQU4sR0FBc0IsYUFBdEI7QUFDQSxZQUFNLHFCQUFOLEdBQThCLGdCQUFnQixNQUFNLFNBQU4sQ0FBZ0IsTUFBOUQ7QUFDQSxZQUFNLEtBQU4sR0FBYyxZQUFZLENBQTFCO0FBQ0EsYUFBTyxLQUFQO0FBQ0Q7OztnQ0FFVyxRLEVBQVUsSyxFQUFPLE8sRUFBUztBQUNwQyxVQUFJLFNBQVMsU0FBUyxJQUF0QjtBQUFBLFVBQ0ksTUFBTSxTQUFTLEdBRG5CO0FBQUEsVUFFSSxPQUFPLFFBQVEsSUFGbkI7QUFBQSxVQUdJLEtBQUssUUFBUSxFQUhqQjtBQUFBLFVBSUksUUFBUSxRQUFRLEtBSnBCO0FBQUEsVUFLSSxNQUFNLEtBQUssR0FMZjs7QUFPQSxXQUFLLE9BQUwsQ0FBYSxJQUFiLElBQXFCLFNBQXJCO0FBQ0E7QUFDQTtBQUNBLFVBQUksUUFBUSxTQUFSLElBQXFCLElBQUksT0FBSixDQUFZLE9BQVosTUFBeUIsQ0FBbEQsRUFBcUQ7QUFDbkQ7QUFDQSxjQUFNLFFBQVEsR0FBZDtBQUNEO0FBQ0QsWUFBTSxLQUFOLEdBQWMsWUFBWSxHQUFaLEVBQWQ7QUFDQTtBQUNBLFVBQUksT0FBTyxPQUFQLENBQWUsU0FBZixNQUE4QixDQUFsQyxFQUFxQztBQUNuQyxZQUFJLE9BQU8sT0FBUCxDQUFlLFVBQWYsSUFBNkIsQ0FBakMsRUFBb0M7QUFDbEMsY0FBSSxVQUFXLFNBQVMsWUFBVCxJQUF5QixTQUFTLGVBQWpEO0FBQUEsY0FDSSxlQUFlLEtBQUssa0JBQUwsQ0FBd0IsTUFBeEIsRUFBZ0MsR0FBaEMsRUFBcUMsU0FBUyxFQUFULElBQWUsQ0FBcEQsRUFBd0QsU0FBUyxZQUFULEdBQXdCLE9BQXhCLEdBQW1DLFNBQVMsZUFBVCxHQUEyQixVQUEzQixHQUF3QyxNQUFuSSxDQURuQjtBQUVBLGNBQUksU0FBUyxVQUFiLEVBQXlCO0FBQ3pCO0FBQ0UsZ0JBQUksT0FBSixDQUFZLGlCQUFNLGVBQWxCLEVBQW1DLEVBQUMsUUFBUSxDQUFDLEVBQUMsS0FBSyxHQUFOLEVBQVcsU0FBVSxZQUFyQixFQUFELENBQVQsRUFBK0MsYUFBYyxFQUE3RCxFQUFpRSxLQUFLLEdBQXRFLEVBQTJFLE9BQU8sS0FBbEYsRUFBbkM7QUFDRDtBQUNELGdCQUFNLE9BQU4sR0FBZ0IsWUFBWSxHQUFaLEVBQWhCO0FBQ0EsY0FBSSxhQUFhLGNBQWpCLEVBQWlDO0FBQy9CLGdCQUFJLE9BQUosRUFBYTtBQUNYLGtCQUFJLE9BQUosQ0FBWSxpQkFBTSxZQUFsQixFQUFnQyxFQUFDLFNBQVMsWUFBVixFQUF3QixPQUFPLFNBQVMsQ0FBeEMsRUFBMkMsSUFBSSxNQUFNLENBQXJELEVBQXdELE9BQU8sS0FBL0QsRUFBaEM7QUFDRCxhQUZELE1BRU87QUFDTCxrQkFBSSxTQUFTLFlBQWIsRUFBMkI7QUFDekIsb0JBQUksT0FBSixDQUFZLGlCQUFNLGtCQUFsQixFQUFzQyxFQUFDLFNBQVMsWUFBVixFQUF3QixJQUFJLEVBQTVCLEVBQWdDLE9BQU8sS0FBdkMsRUFBdEM7QUFDRCxlQUZELE1BR0ssSUFBSSxTQUFTLGVBQWIsRUFBOEI7QUFDakMsb0JBQUksT0FBSixDQUFZLGlCQUFNLHFCQUFsQixFQUF5QyxFQUFDLFNBQVMsWUFBVixFQUF3QixJQUFJLEVBQTVCLEVBQWdDLE9BQU8sS0FBdkMsRUFBekM7QUFDRDtBQUNGO0FBQ0YsV0FYRCxNQVdPO0FBQ0wsZ0JBQUksT0FBSixDQUFZLGlCQUFNLEtBQWxCLEVBQXlCLEVBQUMsTUFBTSxtQkFBVyxhQUFsQixFQUFpQyxTQUFTLHFCQUFhLHNCQUF2RCxFQUErRSxPQUFPLElBQXRGLEVBQTRGLEtBQUssR0FBakcsRUFBc0csUUFBUSx3QkFBOUcsRUFBekI7QUFDRDtBQUNGLFNBdEJELE1Bc0JPO0FBQ0wsY0FBSSxTQUFTLEtBQUssbUJBQUwsQ0FBeUIsTUFBekIsRUFBaUMsR0FBakMsQ0FBYjtBQUNBO0FBQ0EsY0FBSSxPQUFPLE1BQVgsRUFBbUI7QUFDakIsZ0JBQUksY0FBYyxLQUFLLHdCQUFMLENBQThCLE1BQTlCLEVBQXNDLEdBQXRDLEVBQTJDLE9BQTNDLENBQWxCO0FBQ0EsZ0JBQUksWUFBWSxLQUFLLHdCQUFMLENBQThCLE1BQTlCLEVBQXNDLEdBQXRDLEVBQTJDLFdBQTNDLENBQWhCO0FBQ0EsZ0JBQUksWUFBWSxNQUFoQixFQUF3QjtBQUN0QjtBQUNBLGtCQUFJLHFCQUFxQixLQUF6QjtBQUNBLDBCQUFZLE9BQVosQ0FBb0Isc0JBQWM7QUFDaEMsb0JBQUcsQ0FBQyxXQUFXLEdBQWYsRUFBb0I7QUFDbEIsdUNBQXFCLElBQXJCO0FBQ0Q7QUFDRixlQUpEO0FBS0E7QUFDQTtBQUNBLGtCQUFJLHVCQUF1QixLQUF2QixJQUFnQyxPQUFPLENBQVAsRUFBVSxVQUExQyxJQUF3RCxDQUFDLE9BQU8sQ0FBUCxFQUFVLEtBQVYsQ0FBZ0IsS0FBN0UsRUFBb0Y7QUFDbEYsK0JBQU8sR0FBUCxDQUFXLHlGQUFYO0FBQ0EsNEJBQVksT0FBWixDQUFvQixFQUFFLE1BQU8sTUFBVCxFQUFpQixNQUFPLE1BQXhCLEVBQXBCO0FBQ0Q7QUFDRjtBQUNELGdCQUFJLE9BQUosQ0FBWSxpQkFBTSxlQUFsQixFQUFtQyxFQUFDLGNBQUQsRUFBUyx3QkFBVCxFQUFzQixvQkFBdEIsRUFBaUMsUUFBakMsRUFBc0MsWUFBdEMsRUFBbkM7QUFDRCxXQW5CRCxNQW1CTztBQUNMLGdCQUFJLE9BQUosQ0FBWSxpQkFBTSxLQUFsQixFQUF5QixFQUFDLE1BQU0sbUJBQVcsYUFBbEIsRUFBaUMsU0FBUyxxQkFBYSxvQkFBdkQsRUFBNkUsT0FBTyxLQUFwRixFQUEyRixLQUFLLEdBQWhHLEVBQXFHLFFBQVEsNEJBQTdHLEVBQTJJLGdCQUEzSSxFQUF6QjtBQUNEO0FBQ0Y7QUFDRixPQWpERCxNQWlETztBQUNMLFlBQUksT0FBSixDQUFZLGlCQUFNLEtBQWxCLEVBQXlCLEVBQUMsTUFBTSxtQkFBVyxhQUFsQixFQUFpQyxTQUFTLHFCQUFhLHNCQUF2RCxFQUErRSxPQUFPLElBQXRGLEVBQTRGLEtBQUssR0FBakcsRUFBc0csUUFBUSxxQkFBOUcsRUFBekI7QUFDRDtBQUNGOzs7OEJBRVMsUSxFQUFVLE8sRUFBUztBQUMzQixVQUFJLE9BQUo7QUFBQSxVQUFhLEtBQWI7QUFBQSxVQUFtQixTQUFTLFFBQVEsTUFBcEM7QUFDQSxjQUFPLFFBQVEsSUFBZjtBQUNFLGFBQUssVUFBTDtBQUNFLG9CQUFVLHFCQUFhLG1CQUF2QjtBQUNBLGtCQUFRLElBQVI7QUFDQTtBQUNGLGFBQUssT0FBTDtBQUNFLG9CQUFVLHFCQUFhLGdCQUF2QjtBQUNBLGtCQUFRLEtBQVI7QUFDQTtBQUNGLGFBQUssWUFBTDtBQUNFLG9CQUFVLHFCQUFhLHNCQUF2QjtBQUNBLGtCQUFRLEtBQVI7QUFDQTtBQVpKO0FBY0EsVUFBSSxNQUFKLEVBQVk7QUFDVixlQUFPLEtBQVA7QUFDQSxhQUFLLE9BQUwsQ0FBYSxRQUFRLElBQXJCLElBQTZCLFNBQTdCO0FBQ0Q7QUFDRCxXQUFLLEdBQUwsQ0FBUyxPQUFULENBQWlCLGlCQUFNLEtBQXZCLEVBQThCLEVBQUMsTUFBTSxtQkFBVyxhQUFsQixFQUFpQyxTQUFTLE9BQTFDLEVBQW1ELE9BQU8sS0FBMUQsRUFBaUUsS0FBSyxRQUFRLEdBQTlFLEVBQW1GLFFBQVEsTUFBM0YsRUFBbUcsVUFBVSxRQUE3RyxFQUF1SCxTQUFVLE9BQWpJLEVBQTlCO0FBQ0Q7OztnQ0FFVyxLLEVBQU8sTyxFQUFTO0FBQzFCLFVBQUksT0FBSjtBQUFBLFVBQWEsS0FBYjtBQUFBLFVBQW9CLFNBQVMsUUFBUSxNQUFyQztBQUNBLGNBQU8sUUFBUSxJQUFmO0FBQ0UsYUFBSyxVQUFMO0FBQ0Usb0JBQVUscUJBQWEscUJBQXZCO0FBQ0Esa0JBQVEsSUFBUjtBQUNBO0FBQ0YsYUFBSyxPQUFMO0FBQ0Usb0JBQVUscUJBQWEsa0JBQXZCO0FBQ0Esa0JBQVEsS0FBUjtBQUNBO0FBQ0YsYUFBSyxZQUFMO0FBQ0Usb0JBQVUscUJBQWEsd0JBQXZCO0FBQ0Esa0JBQVEsS0FBUjtBQUNBO0FBWko7QUFjQSxVQUFJLE1BQUosRUFBWTtBQUNWLGVBQU8sS0FBUDtBQUNBLGFBQUssT0FBTCxDQUFhLFFBQVEsSUFBckIsSUFBNkIsU0FBN0I7QUFDRDtBQUNELFdBQUssR0FBTCxDQUFTLE9BQVQsQ0FBaUIsaUJBQU0sS0FBdkIsRUFBOEIsRUFBQyxNQUFNLG1CQUFXLGFBQWxCLEVBQWlDLFNBQVMsT0FBMUMsRUFBbUQsT0FBTyxLQUExRCxFQUFpRSxLQUFLLFFBQVEsR0FBOUUsRUFBbUYsUUFBUSxNQUEzRixFQUFtRyxTQUFVLE9BQTdHLEVBQTlCO0FBQ0Q7Ozs7OztrQkFHWSxjOzs7Ozs7Ozs7Ozs7O0FDdmhCZjs7OztBQUlBO0lBQ00sRzs7Ozs7OzsyQkFDVTtBQUNaLFVBQUksS0FBSixHQUFZO0FBQ1YsY0FBTSxFQURJLEVBQ0E7QUFDVixjQUFNLEVBRkk7QUFHVixjQUFNLEVBSEk7QUFJVixjQUFNLEVBSkk7QUFLVixjQUFNLEVBTEk7QUFNVixjQUFNLEVBTkk7QUFPVixjQUFNLEVBUEk7QUFRVixjQUFNLEVBUkk7QUFTVixjQUFNLEVBVEk7QUFVVixjQUFNLEVBVkk7QUFXVixjQUFNLEVBWEk7QUFZVixjQUFNLEVBWkk7QUFhVixjQUFNLEVBYkk7QUFjVixjQUFNLEVBZEk7QUFlVixjQUFNLEVBZkk7QUFnQlYsY0FBTSxFQWhCSTtBQWlCVixnQkFBUSxFQWpCRTtBQWtCVixjQUFNLEVBbEJJO0FBbUJWLGNBQU0sRUFuQkk7QUFvQlYsY0FBTSxFQXBCSTtBQXFCVixjQUFNLEVBckJJO0FBc0JWLGNBQU0sRUF0Qkk7QUF1QlYsY0FBTSxFQXZCSTtBQXdCVixjQUFNLEVBeEJJO0FBeUJWLGNBQU0sRUF6Qkk7QUEwQlYsY0FBTSxFQTFCSTtBQTJCVixjQUFNLEVBM0JJO0FBNEJWLGNBQU0sRUE1Qkk7QUE2QlYsY0FBTSxFQTdCSTtBQThCVixjQUFNLEVBOUJJO0FBK0JWLGNBQU0sRUEvQkk7QUFnQ1YsY0FBTSxFQWhDSTtBQWlDVixjQUFNLEVBakNJO0FBa0NWLGNBQU0sRUFsQ0k7QUFtQ1YsY0FBTTtBQW5DSSxPQUFaOztBQXNDQSxVQUFJLENBQUo7QUFDQSxXQUFLLENBQUwsSUFBVSxJQUFJLEtBQWQsRUFBcUI7QUFDbkIsWUFBSSxJQUFJLEtBQUosQ0FBVSxjQUFWLENBQXlCLENBQXpCLENBQUosRUFBaUM7QUFDL0IsY0FBSSxLQUFKLENBQVUsQ0FBVixJQUFlLENBQ2IsRUFBRSxVQUFGLENBQWEsQ0FBYixDQURhLEVBRWIsRUFBRSxVQUFGLENBQWEsQ0FBYixDQUZhLEVBR2IsRUFBRSxVQUFGLENBQWEsQ0FBYixDQUhhLEVBSWIsRUFBRSxVQUFGLENBQWEsQ0FBYixDQUphLENBQWY7QUFNRDtBQUNGOztBQUVELFVBQUksWUFBWSxJQUFJLFVBQUosQ0FBZSxDQUM3QixJQUQ2QixFQUN2QjtBQUNOLFVBRjZCLEVBRXZCLElBRnVCLEVBRWpCLElBRmlCLEVBRVg7QUFDbEIsVUFINkIsRUFHdkIsSUFIdUIsRUFHakIsSUFIaUIsRUFHWCxJQUhXLEVBR0w7QUFDeEIsVUFKNkIsRUFJdkIsSUFKdUIsRUFJakIsSUFKaUIsRUFJWCxJQUpXLEVBSUw7QUFDeEIsVUFMNkIsRUFLdkIsSUFMdUIsRUFLakIsSUFMaUIsRUFLWCxJQUxXLEVBS0w7QUFDeEIsVUFONkIsRUFNdkIsSUFOdUIsRUFNakIsSUFOaUIsRUFNWCxJQU5XLEVBTUw7QUFDeEIsVUFQNkIsRUFPdkIsSUFQdUIsRUFPakIsSUFQaUIsRUFPWCxJQVBXLEVBT0w7QUFDeEIsVUFSNkIsRUFRdkIsSUFSdUIsRUFRakIsSUFSaUIsRUFRWCxJQVJXLEVBUzdCLElBVDZCLEVBU3ZCLElBVHVCLEVBU2pCLElBVGlCLEVBU1gsSUFUVyxFQVU3QixJQVY2QixFQVV2QixJQVZ1QixFQVVqQixJQVZpQixFQVVYLElBVlcsRUFVTCxJQVZLLENBVUE7QUFWQSxPQUFmLENBQWhCOztBQWFBLFVBQUksWUFBWSxJQUFJLFVBQUosQ0FBZSxDQUM3QixJQUQ2QixFQUN2QjtBQUNOLFVBRjZCLEVBRXZCLElBRnVCLEVBRWpCLElBRmlCLEVBRVg7QUFDbEIsVUFINkIsRUFHdkIsSUFIdUIsRUFHakIsSUFIaUIsRUFHWCxJQUhXLEVBR0w7QUFDeEIsVUFKNkIsRUFJdkIsSUFKdUIsRUFJakIsSUFKaUIsRUFJWCxJQUpXLEVBSUw7QUFDeEIsVUFMNkIsRUFLdkIsSUFMdUIsRUFLakIsSUFMaUIsRUFLWCxJQUxXLEVBS0w7QUFDeEIsVUFONkIsRUFNdkIsSUFOdUIsRUFNakIsSUFOaUIsRUFNWCxJQU5XLEVBTUw7QUFDeEIsVUFQNkIsRUFPdkIsSUFQdUIsRUFPakIsSUFQaUIsRUFPWCxJQVBXLEVBT0w7QUFDeEIsVUFSNkIsRUFRdkIsSUFSdUIsRUFRakIsSUFSaUIsRUFRWCxJQVJXLEVBUzdCLElBVDZCLEVBU3ZCLElBVHVCLEVBU2pCLElBVGlCLEVBU1gsSUFUVyxFQVU3QixJQVY2QixFQVV2QixJQVZ1QixFQVVqQixJQVZpQixFQVVYLElBVlcsRUFVTCxJQVZLLENBVUE7QUFWQSxPQUFmLENBQWhCOztBQWFBLFVBQUksVUFBSixHQUFpQjtBQUNmLGlCQUFTLFNBRE07QUFFZixpQkFBUztBQUZNLE9BQWpCOztBQUtBLFVBQUksT0FBTyxJQUFJLFVBQUosQ0FBZSxDQUN4QixJQUR3QixFQUNsQjtBQUNOLFVBRndCLEVBRWxCLElBRmtCLEVBRVosSUFGWSxFQUVOO0FBQ2xCLFVBSHdCLEVBR2xCLElBSGtCLEVBR1osSUFIWSxFQUdOLElBSE0sRUFHQTtBQUN4QixVQUp3QixFQUlsQixJQUprQixFQUlaLElBSlksRUFJTixJQUpNLEVBSUE7QUFDeEIsVUFMd0IsRUFLbEIsSUFMa0IsRUFLWixJQUxZLEVBS04sSUFMTSxFQUtBO0FBQ3hCLFVBTndCLEVBTWxCO0FBQ04sVUFQd0IsRUFPbEIsSUFQa0IsRUFPWixJQVBZLENBT1A7QUFQTyxPQUFmLENBQVg7O0FBVUEsVUFBSSxPQUFPLElBQUksVUFBSixDQUFlLENBQ3hCLElBRHdCLEVBQ2xCO0FBQ04sVUFGd0IsRUFFbEIsSUFGa0IsRUFFWixJQUZZLEVBRU47QUFDbEIsVUFId0IsRUFHbEIsSUFIa0IsRUFHWixJQUhZLEVBR04sSUFITSxDQUdEO0FBSEMsT0FBZixDQUFYOztBQU1BLFVBQUksSUFBSixHQUFXLElBQUksSUFBSixHQUFXLElBQUksSUFBSixHQUFXLElBQWpDOztBQUVBLFVBQUksSUFBSixHQUFXLElBQUksVUFBSixDQUFlLENBQ3hCLElBRHdCLEVBQ2xCO0FBQ04sVUFGd0IsRUFFbEIsSUFGa0IsRUFFWixJQUZZLEVBRU47QUFDbEIsVUFId0IsRUFHbEIsSUFIa0IsRUFHWixJQUhZLEVBR04sSUFITSxFQUdBO0FBQ3hCLFVBSndCLEVBSWxCLElBSmtCLEVBSVosSUFKWSxFQUlOLElBSk0sQ0FBZixDQUFYO0FBTUEsVUFBSSxJQUFKLEdBQVcsSUFBSSxVQUFKLENBQWUsQ0FDeEIsSUFEd0IsRUFDbEI7QUFDTixVQUZ3QixFQUVsQixJQUZrQixFQUVaLElBRlksRUFFTjtBQUNsQixVQUh3QixFQUdsQixJQUhrQixFQUdaO0FBQ1osVUFKd0IsRUFJbEIsSUFKa0IsRUFLeEIsSUFMd0IsRUFLbEIsSUFMa0IsRUFNeEIsSUFOd0IsRUFNbEIsSUFOa0IsQ0FNYjtBQU5hLE9BQWYsQ0FBWDtBQVFBLFVBQUksSUFBSixHQUFXLElBQUksVUFBSixDQUFlLENBQ3hCLElBRHdCLEVBQ2xCO0FBQ04sVUFGd0IsRUFFbEIsSUFGa0IsRUFFWixJQUZZLEVBRU47QUFDbEIsVUFId0IsRUFHbEIsSUFIa0IsRUFHWjtBQUNaLFVBSndCLEVBSWxCLElBSmtCLENBSWI7QUFKYSxPQUFmLENBQVg7O0FBT0EsVUFBSSxJQUFKLEdBQVcsSUFBSSxVQUFKLENBQWUsQ0FDeEIsSUFEd0IsRUFDbEI7QUFDTixVQUZ3QixFQUVsQixJQUZrQixFQUVaLElBRlksRUFFTjtBQUNsQixVQUh3QixFQUdsQixJQUhrQixFQUdaLElBSFksRUFHTixJQUhNLENBQWYsQ0FBWCxDQXpIWSxDQTRIZTs7QUFFM0IsVUFBSSxhQUFhLElBQUksVUFBSixDQUFlLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULEVBQWEsR0FBYixDQUFmLENBQWpCLENBOUhZLENBOEh3QztBQUNwRCxVQUFJLFlBQVksSUFBSSxVQUFKLENBQWUsQ0FBQyxFQUFELEVBQUksR0FBSixFQUFRLEVBQVIsRUFBVyxFQUFYLENBQWYsQ0FBaEIsQ0EvSFksQ0ErSG9DO0FBQ2hELFVBQUksZUFBZSxJQUFJLFVBQUosQ0FBZSxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxFQUFVLENBQVYsQ0FBZixDQUFuQjs7QUFFQSxVQUFJLElBQUosR0FBVyxJQUFJLEdBQUosQ0FBUSxJQUFJLEtBQUosQ0FBVSxJQUFsQixFQUF3QixVQUF4QixFQUFvQyxZQUFwQyxFQUFrRCxVQUFsRCxFQUE4RCxTQUE5RCxDQUFYO0FBQ0EsVUFBSSxJQUFKLEdBQVcsSUFBSSxHQUFKLENBQVEsSUFBSSxLQUFKLENBQVUsSUFBbEIsRUFBd0IsSUFBSSxHQUFKLENBQVEsSUFBSSxLQUFKLENBQVUsSUFBbEIsRUFBd0IsSUFBeEIsQ0FBeEIsQ0FBWDtBQUNEOzs7d0JBRVUsSSxFQUFNO0FBQ2pCLFVBQ0UsVUFBVSxNQUFNLFNBQU4sQ0FBZ0IsS0FBaEIsQ0FBc0IsSUFBdEIsQ0FBMkIsU0FBM0IsRUFBc0MsQ0FBdEMsQ0FEWjtBQUFBLFVBRUUsT0FBTyxDQUZUO0FBQUEsVUFHRSxJQUFJLFFBQVEsTUFIZDtBQUFBLFVBSUUsTUFBTSxDQUpSO0FBQUEsVUFLRSxNQUxGO0FBTUU7QUFDQSxhQUFPLEdBQVAsRUFBWTtBQUNWLGdCQUFRLFFBQVEsQ0FBUixFQUFXLFVBQW5CO0FBQ0Q7QUFDRCxlQUFTLElBQUksVUFBSixDQUFlLElBQWYsQ0FBVDtBQUNBLGFBQU8sQ0FBUCxJQUFhLFFBQVEsRUFBVCxHQUFlLElBQTNCO0FBQ0EsYUFBTyxDQUFQLElBQWEsUUFBUSxFQUFULEdBQWUsSUFBM0I7QUFDQSxhQUFPLENBQVAsSUFBYSxRQUFRLENBQVQsR0FBYyxJQUExQjtBQUNBLGFBQU8sQ0FBUCxJQUFZLE9BQVEsSUFBcEI7QUFDQSxhQUFPLEdBQVAsQ0FBVyxJQUFYLEVBQWlCLENBQWpCO0FBQ0E7QUFDQSxXQUFLLElBQUksQ0FBSixFQUFPLE9BQU8sQ0FBbkIsRUFBc0IsSUFBSSxHQUExQixFQUErQixHQUEvQixFQUFvQztBQUNsQztBQUNBLGVBQU8sR0FBUCxDQUFXLFFBQVEsQ0FBUixDQUFYLEVBQXVCLElBQXZCO0FBQ0EsZ0JBQVEsUUFBUSxDQUFSLEVBQVcsVUFBbkI7QUFDRDtBQUNELGFBQU8sTUFBUDtBQUNEOzs7eUJBRVcsSSxFQUFNO0FBQ2hCLGFBQU8sSUFBSSxHQUFKLENBQVEsSUFBSSxLQUFKLENBQVUsSUFBbEIsRUFBd0IsSUFBSSxVQUFKLENBQWUsSUFBZixDQUF4QixDQUFQO0FBQ0Q7Ozt5QkFFVyxJLEVBQU07QUFDaEIsYUFBTyxJQUFJLEdBQUosQ0FBUSxJQUFJLEtBQUosQ0FBVSxJQUFsQixFQUF3QixJQUF4QixDQUFQO0FBQ0Q7Ozt5QkFFVyxTLEVBQVcsUSxFQUFVO0FBQy9CLGtCQUFZLFNBQVo7QUFDQSxhQUFPLElBQUksR0FBSixDQUFRLElBQUksS0FBSixDQUFVLElBQWxCLEVBQXdCLElBQUksVUFBSixDQUFlLENBQzVDLElBRDRDLEVBQ3RDO0FBQ04sVUFGNEMsRUFFdEMsSUFGc0MsRUFFaEMsSUFGZ0MsRUFFMUI7QUFDbEIsVUFINEMsRUFHdEMsSUFIc0MsRUFHaEMsSUFIZ0MsRUFHMUIsSUFIMEIsRUFHcEI7QUFDeEIsVUFKNEMsRUFJdEMsSUFKc0MsRUFJaEMsSUFKZ0MsRUFJMUIsSUFKMEIsRUFJcEI7QUFDdkIsbUJBQWEsRUFBZCxHQUFvQixJQUx3QixFQU0zQyxhQUFhLEVBQWQsR0FBb0IsSUFOd0IsRUFPM0MsYUFBYyxDQUFmLEdBQW9CLElBUHdCLEVBUTVDLFlBQVksSUFSZ0MsRUFRMUI7QUFDakIsa0JBQVksRUFUK0IsRUFVM0MsWUFBWSxFQUFiLEdBQW1CLElBVnlCLEVBVzNDLFlBQWEsQ0FBZCxHQUFtQixJQVh5QixFQVk1QyxXQUFXLElBWmlDLEVBWTNCO0FBQ2pCLFVBYjRDLEVBYXRDLElBYnNDLEVBYWhDO0FBQ1osVUFkNEMsRUFjdEMsSUFkc0MsQ0FBZixDQUF4QixDQUFQO0FBZ0JEOzs7eUJBRVcsSyxFQUFPO0FBQ2pCLGFBQU8sSUFBSSxHQUFKLENBQVEsSUFBSSxLQUFKLENBQVUsSUFBbEIsRUFBd0IsSUFBSSxJQUFKLENBQVMsTUFBTSxTQUFmLEVBQTBCLE1BQU0sUUFBaEMsQ0FBeEIsRUFBbUUsSUFBSSxJQUFKLENBQVMsTUFBTSxJQUFmLENBQW5FLEVBQXlGLElBQUksSUFBSixDQUFTLEtBQVQsQ0FBekYsQ0FBUDtBQUNEOzs7eUJBRVcsYyxFQUFnQjtBQUMxQixhQUFPLElBQUksR0FBSixDQUFRLElBQUksS0FBSixDQUFVLElBQWxCLEVBQXdCLElBQUksVUFBSixDQUFlLENBQzVDLElBRDRDLEVBRTVDLElBRjRDLEVBRXRDLElBRnNDLEVBRWhDLElBRmdDLEVBRTFCO0FBQ2pCLHdCQUFrQixFQUh5QixFQUkzQyxrQkFBa0IsRUFBbkIsR0FBeUIsSUFKbUIsRUFLM0Msa0JBQW1CLENBQXBCLEdBQXlCLElBTG1CLEVBTTVDLGlCQUFpQixJQU4yQixDQUFmLENBQXhCLENBQVA7QUFRRDs7O3lCQUVXLEssRUFBTztBQUNqQixVQUFJLE1BQU0sSUFBTixLQUFlLE9BQW5CLEVBQTRCO0FBQzFCLGVBQU8sSUFBSSxHQUFKLENBQVEsSUFBSSxLQUFKLENBQVUsSUFBbEIsRUFBd0IsSUFBSSxHQUFKLENBQVEsSUFBSSxLQUFKLENBQVUsSUFBbEIsRUFBd0IsSUFBSSxJQUE1QixDQUF4QixFQUEyRCxJQUFJLElBQS9ELEVBQXFFLElBQUksSUFBSixDQUFTLEtBQVQsQ0FBckUsQ0FBUDtBQUNELE9BRkQsTUFFTztBQUNMLGVBQU8sSUFBSSxHQUFKLENBQVEsSUFBSSxLQUFKLENBQVUsSUFBbEIsRUFBd0IsSUFBSSxHQUFKLENBQVEsSUFBSSxLQUFKLENBQVUsSUFBbEIsRUFBd0IsSUFBSSxJQUE1QixDQUF4QixFQUEyRCxJQUFJLElBQS9ELEVBQXFFLElBQUksSUFBSixDQUFTLEtBQVQsQ0FBckUsQ0FBUDtBQUNEO0FBQ0Y7Ozt5QkFFVyxFLEVBQUksbUIsRUFBcUIsSyxFQUFPO0FBQzFDLGFBQU8sSUFBSSxHQUFKLENBQVEsSUFBSSxLQUFKLENBQVUsSUFBbEIsRUFBd0IsSUFBSSxJQUFKLENBQVMsRUFBVCxDQUF4QixFQUFzQyxJQUFJLElBQUosQ0FBUyxLQUFULEVBQWUsbUJBQWYsQ0FBdEMsQ0FBUDtBQUNEO0FBQ0g7Ozs7Ozt5QkFHYyxNLEVBQVE7QUFDbEIsVUFDRSxJQUFJLE9BQU8sTUFEYjtBQUFBLFVBRUUsUUFBUSxFQUZWOztBQUlBLGFBQU8sR0FBUCxFQUFZO0FBQ1YsY0FBTSxDQUFOLElBQVcsSUFBSSxJQUFKLENBQVMsT0FBTyxDQUFQLENBQVQsQ0FBWDtBQUNEOztBQUVELGFBQU8sSUFBSSxHQUFKLENBQVEsS0FBUixDQUFjLElBQWQsRUFBb0IsQ0FBQyxJQUFJLEtBQUosQ0FBVSxJQUFYLEVBQWlCLElBQUksSUFBSixDQUFTLE9BQU8sQ0FBUCxFQUFVLFNBQW5CLEVBQThCLE9BQU8sQ0FBUCxFQUFVLFFBQXhDLENBQWpCLEVBQW9FLE1BQXBFLENBQTJFLEtBQTNFLEVBQWtGLE1BQWxGLENBQXlGLElBQUksSUFBSixDQUFTLE1BQVQsQ0FBekYsQ0FBcEIsQ0FBUDtBQUNEOzs7eUJBRVcsTSxFQUFRO0FBQ2xCLFVBQ0UsSUFBSSxPQUFPLE1BRGI7QUFBQSxVQUVFLFFBQVEsRUFGVjs7QUFJQSxhQUFPLEdBQVAsRUFBWTtBQUNWLGNBQU0sQ0FBTixJQUFXLElBQUksSUFBSixDQUFTLE9BQU8sQ0FBUCxDQUFULENBQVg7QUFDRDtBQUNELGFBQU8sSUFBSSxHQUFKLENBQVEsS0FBUixDQUFjLElBQWQsRUFBb0IsQ0FBQyxJQUFJLEtBQUosQ0FBVSxJQUFYLEVBQWlCLE1BQWpCLENBQXdCLEtBQXhCLENBQXBCLENBQVA7QUFDRDs7O3lCQUVXLFMsRUFBVSxRLEVBQVU7QUFDOUIsa0JBQVUsU0FBVjtBQUNBLFVBQ0UsUUFBUSxJQUFJLFVBQUosQ0FBZSxDQUNyQixJQURxQixFQUNmO0FBQ04sVUFGcUIsRUFFZixJQUZlLEVBRVQsSUFGUyxFQUVIO0FBQ2xCLFVBSHFCLEVBR2YsSUFIZSxFQUdULElBSFMsRUFHSCxJQUhHLEVBR0c7QUFDeEIsVUFKcUIsRUFJZixJQUplLEVBSVQsSUFKUyxFQUlILElBSkcsRUFJRztBQUN2QixtQkFBYSxFQUFkLEdBQW9CLElBTEMsRUFNcEIsYUFBYSxFQUFkLEdBQW9CLElBTkMsRUFPcEIsYUFBYyxDQUFmLEdBQW9CLElBUEMsRUFRckIsWUFBWSxJQVJTLEVBUUg7QUFDakIsa0JBQVksRUFBYixHQUFtQixJQVRFLEVBVXBCLFlBQVksRUFBYixHQUFtQixJQVZFLEVBV3BCLFlBQWEsQ0FBZCxHQUFtQixJQVhFLEVBWXJCLFdBQVcsSUFaVSxFQVlKO0FBQ2pCLFVBYnFCLEVBYWYsSUFiZSxFQWFULElBYlMsRUFhSCxJQWJHLEVBYUc7QUFDeEIsVUFkcUIsRUFjZixJQWRlLEVBY1Q7QUFDWixVQWZxQixFQWVmLElBZmUsRUFlVDtBQUNaLFVBaEJxQixFQWdCZixJQWhCZSxFQWdCVCxJQWhCUyxFQWdCSCxJQWhCRyxFQWdCRztBQUN4QixVQWpCcUIsRUFpQmYsSUFqQmUsRUFpQlQsSUFqQlMsRUFpQkgsSUFqQkcsRUFpQkc7QUFDeEIsVUFsQnFCLEVBa0JmLElBbEJlLEVBa0JULElBbEJTLEVBa0JILElBbEJHLEVBbUJyQixJQW5CcUIsRUFtQmYsSUFuQmUsRUFtQlQsSUFuQlMsRUFtQkgsSUFuQkcsRUFvQnJCLElBcEJxQixFQW9CZixJQXBCZSxFQW9CVCxJQXBCUyxFQW9CSCxJQXBCRyxFQXFCckIsSUFyQnFCLEVBcUJmLElBckJlLEVBcUJULElBckJTLEVBcUJILElBckJHLEVBc0JyQixJQXRCcUIsRUFzQmYsSUF0QmUsRUFzQlQsSUF0QlMsRUFzQkgsSUF0QkcsRUF1QnJCLElBdkJxQixFQXVCZixJQXZCZSxFQXVCVCxJQXZCUyxFQXVCSCxJQXZCRyxFQXdCckIsSUF4QnFCLEVBd0JmLElBeEJlLEVBd0JULElBeEJTLEVBd0JILElBeEJHLEVBeUJyQixJQXpCcUIsRUF5QmYsSUF6QmUsRUF5QlQsSUF6QlMsRUF5QkgsSUF6QkcsRUEwQnJCLElBMUJxQixFQTBCZixJQTFCZSxFQTBCVCxJQTFCUyxFQTBCSCxJQTFCRyxFQTBCRztBQUN4QixVQTNCcUIsRUEyQmYsSUEzQmUsRUEyQlQsSUEzQlMsRUEyQkgsSUEzQkcsRUE0QnJCLElBNUJxQixFQTRCZixJQTVCZSxFQTRCVCxJQTVCUyxFQTRCSCxJQTVCRyxFQTZCckIsSUE3QnFCLEVBNkJmLElBN0JlLEVBNkJULElBN0JTLEVBNkJILElBN0JHLEVBOEJyQixJQTlCcUIsRUE4QmYsSUE5QmUsRUE4QlQsSUE5QlMsRUE4QkgsSUE5QkcsRUErQnJCLElBL0JxQixFQStCZixJQS9CZSxFQStCVCxJQS9CUyxFQStCSCxJQS9CRyxFQWdDckIsSUFoQ3FCLEVBZ0NmLElBaENlLEVBZ0NULElBaENTLEVBZ0NILElBaENHLEVBZ0NHO0FBQ3hCLFVBakNxQixFQWlDZixJQWpDZSxFQWlDVCxJQWpDUyxFQWlDSCxJQWpDRyxDQWlDRTtBQWpDRixPQUFmLENBRFY7QUFvQ0EsYUFBTyxJQUFJLEdBQUosQ0FBUSxJQUFJLEtBQUosQ0FBVSxJQUFsQixFQUF3QixLQUF4QixDQUFQO0FBQ0Q7Ozt5QkFFVyxLLEVBQU87QUFDakIsVUFDRSxVQUFVLE1BQU0sT0FBTixJQUFpQixFQUQ3QjtBQUFBLFVBRUUsUUFBUSxJQUFJLFVBQUosQ0FBZSxJQUFJLFFBQVEsTUFBM0IsQ0FGVjtBQUFBLFVBR0UsS0FIRjtBQUFBLFVBSUUsQ0FKRjtBQUtBO0FBQ0E7QUFDQSxXQUFLLElBQUksQ0FBVCxFQUFZLElBQUksUUFBUSxNQUF4QixFQUFnQyxHQUFoQyxFQUFxQztBQUNuQyxnQkFBUSxRQUFRLENBQVIsRUFBVyxLQUFuQjtBQUNBLGNBQU0sSUFBSSxDQUFWLElBQWdCLE1BQU0sU0FBTixJQUFtQixDQUFwQixHQUNaLE1BQU0sWUFBTixJQUFzQixDQURWLEdBRVosTUFBTSxhQUZUO0FBR0Q7O0FBRUQsYUFBTyxJQUFJLEdBQUosQ0FBUSxJQUFJLEtBQUosQ0FBVSxJQUFsQixFQUF3QixLQUF4QixDQUFQO0FBQ0Q7Ozt5QkFFVyxLLEVBQU87QUFDakIsYUFBTyxJQUFJLEdBQUosQ0FBUSxJQUFJLEtBQUosQ0FBVSxJQUFsQixFQUF3QixJQUFJLElBQUosQ0FBUyxLQUFULENBQXhCLEVBQXlDLElBQUksR0FBSixDQUFRLElBQUksS0FBSixDQUFVLElBQWxCLEVBQXdCLElBQUksSUFBNUIsQ0FBekMsRUFBNEUsSUFBSSxHQUFKLENBQVEsSUFBSSxLQUFKLENBQVUsSUFBbEIsRUFBd0IsSUFBSSxJQUE1QixDQUE1RSxFQUErRyxJQUFJLEdBQUosQ0FBUSxJQUFJLEtBQUosQ0FBVSxJQUFsQixFQUF3QixJQUFJLElBQTVCLENBQS9HLEVBQWtKLElBQUksR0FBSixDQUFRLElBQUksS0FBSixDQUFVLElBQWxCLEVBQXdCLElBQUksSUFBNUIsQ0FBbEosQ0FBUDtBQUNEOzs7eUJBRVcsSyxFQUFPO0FBQ2pCLFVBQUksTUFBTSxFQUFWO0FBQUEsVUFBYyxNQUFNLEVBQXBCO0FBQUEsVUFBd0IsQ0FBeEI7QUFBQSxVQUEyQixJQUEzQjtBQUFBLFVBQWlDLEdBQWpDO0FBQ0E7O0FBRUEsV0FBSyxJQUFJLENBQVQsRUFBWSxJQUFJLE1BQU0sR0FBTixDQUFVLE1BQTFCLEVBQWtDLEdBQWxDLEVBQXVDO0FBQ3JDLGVBQU8sTUFBTSxHQUFOLENBQVUsQ0FBVixDQUFQO0FBQ0EsY0FBTSxLQUFLLFVBQVg7QUFDQSxZQUFJLElBQUosQ0FBVSxRQUFRLENBQVQsR0FBYyxJQUF2QjtBQUNBLFlBQUksSUFBSixDQUFVLE1BQU0sSUFBaEI7QUFDQSxjQUFNLElBQUksTUFBSixDQUFXLE1BQU0sU0FBTixDQUFnQixLQUFoQixDQUFzQixJQUF0QixDQUEyQixJQUEzQixDQUFYLENBQU4sQ0FMcUMsQ0FLZTtBQUNyRDs7QUFFRDtBQUNBLFdBQUssSUFBSSxDQUFULEVBQVksSUFBSSxNQUFNLEdBQU4sQ0FBVSxNQUExQixFQUFrQyxHQUFsQyxFQUF1QztBQUNyQyxlQUFPLE1BQU0sR0FBTixDQUFVLENBQVYsQ0FBUDtBQUNBLGNBQU0sS0FBSyxVQUFYO0FBQ0EsWUFBSSxJQUFKLENBQVUsUUFBUSxDQUFULEdBQWMsSUFBdkI7QUFDQSxZQUFJLElBQUosQ0FBVSxNQUFNLElBQWhCO0FBQ0EsY0FBTSxJQUFJLE1BQUosQ0FBVyxNQUFNLFNBQU4sQ0FBZ0IsS0FBaEIsQ0FBc0IsSUFBdEIsQ0FBMkIsSUFBM0IsQ0FBWCxDQUFOO0FBQ0Q7O0FBRUQsVUFBSSxPQUFPLElBQUksR0FBSixDQUFRLElBQUksS0FBSixDQUFVLElBQWxCLEVBQXdCLElBQUksVUFBSixDQUFlLENBQzFDLElBRDBDLEVBQ2xDO0FBQ1IsVUFBSSxDQUFKLENBRjBDLEVBRWxDO0FBQ1IsVUFBSSxDQUFKLENBSDBDLEVBR2xDO0FBQ1IsVUFBSSxDQUFKLENBSjBDLEVBSWxDO0FBQ1IsYUFBTyxDQUxtQyxFQUtoQztBQUNWLGFBQU8sTUFBTSxHQUFOLENBQVUsTUFOeUIsQ0FNbEI7QUFOa0IsUUFPMUMsTUFQMEMsQ0FPbkMsR0FQbUMsRUFPOUIsTUFQOEIsQ0FPdkIsQ0FDbkIsTUFBTSxHQUFOLENBQVUsTUFEUyxDQUNGO0FBREUsT0FQdUIsRUFTekMsTUFUeUMsQ0FTbEMsR0FUa0MsQ0FBZixDQUF4QixDQUFYO0FBQUEsVUFTd0I7QUFDcEIsY0FBUSxNQUFNLEtBVmxCO0FBQUEsVUFXSSxTQUFTLE1BQU0sTUFYbkI7QUFZQTtBQUNBLGFBQU8sSUFBSSxHQUFKLENBQVEsSUFBSSxLQUFKLENBQVUsSUFBbEIsRUFBd0IsSUFBSSxVQUFKLENBQWUsQ0FDMUMsSUFEMEMsRUFDcEMsSUFEb0MsRUFDOUIsSUFEOEIsRUFDeEI7QUFDbEIsVUFGMEMsRUFFcEMsSUFGb0MsRUFFOUIsSUFGOEIsRUFFeEI7QUFDbEIsVUFIMEMsRUFHcEMsSUFIb0MsRUFHOUI7QUFDWixVQUowQyxFQUlwQyxJQUpvQyxFQUk5QjtBQUNaLFVBTDBDLEVBS3BDLElBTG9DLEVBSzlCO0FBQ1osVUFOMEMsRUFNcEMsSUFOb0MsRUFNOUIsSUFOOEIsRUFNeEIsSUFOd0IsRUFPMUMsSUFQMEMsRUFPcEMsSUFQb0MsRUFPOUIsSUFQOEIsRUFPeEIsSUFQd0IsRUFRMUMsSUFSMEMsRUFRcEMsSUFSb0MsRUFROUIsSUFSOEIsRUFReEIsSUFSd0IsRUFRbEI7QUFDdkIsZUFBUyxDQUFWLEdBQWUsSUFUMkIsRUFVMUMsUUFBUSxJQVZrQyxFQVU1QjtBQUNiLGdCQUFVLENBQVgsR0FBZ0IsSUFYMEIsRUFZMUMsU0FBUyxJQVppQyxFQVkzQjtBQUNmLFVBYjBDLEVBYXBDLElBYm9DLEVBYTlCLElBYjhCLEVBYXhCLElBYndCLEVBYWxCO0FBQ3hCLFVBZDBDLEVBY3BDLElBZG9DLEVBYzlCLElBZDhCLEVBY3hCLElBZHdCLEVBY2xCO0FBQ3hCLFVBZjBDLEVBZXBDLElBZm9DLEVBZTlCLElBZjhCLEVBZXhCLElBZndCLEVBZWxCO0FBQ3hCLFVBaEIwQyxFQWdCcEMsSUFoQm9DLEVBZ0I5QjtBQUNaLFVBakIwQyxFQWtCMUMsSUFsQjBDLEVBa0JwQyxJQWxCb0MsRUFrQjlCLElBbEI4QixFQWtCeEIsSUFsQndCLEVBa0JsQjtBQUN4QixVQW5CMEMsRUFtQnBDLElBbkJvQyxFQW1COUIsSUFuQjhCLEVBbUJ4QixJQW5Cd0IsRUFvQjFDLElBcEIwQyxFQW9CcEMsSUFwQm9DLEVBb0I5QixJQXBCOEIsRUFvQnhCLElBcEJ3QixFQXFCMUMsSUFyQjBDLEVBcUJwQyxJQXJCb0MsRUFxQjlCLElBckI4QixFQXFCeEIsSUFyQndCLEVBc0IxQyxJQXRCMEMsRUFzQnBDLElBdEJvQyxFQXNCOUIsSUF0QjhCLEVBc0J4QixJQXRCd0IsRUF1QjFDLElBdkIwQyxFQXVCcEMsSUF2Qm9DLEVBdUI5QixJQXZCOEIsRUF1QnhCLElBdkJ3QixFQXdCMUMsSUF4QjBDLEVBd0JwQyxJQXhCb0MsRUF3QjlCLElBeEI4QixFQXdCeEIsSUF4QndCLEVBeUIxQyxJQXpCMEMsRUF5QnBDLElBekJvQyxFQXlCOUIsSUF6QjhCLEVBeUJ4QjtBQUNsQixVQTFCMEMsRUEwQnBDLElBMUJvQyxFQTBCNUI7QUFDZCxVQTNCMEMsRUEyQnBDLElBM0JvQyxDQUFmLENBQXhCLEVBMkJXO0FBQ1osVUE1QkMsRUE2QkQsSUFBSSxHQUFKLENBQVEsSUFBSSxLQUFKLENBQVUsSUFBbEIsRUFBd0IsSUFBSSxVQUFKLENBQWUsQ0FDckMsSUFEcUMsRUFDL0IsSUFEK0IsRUFDekIsSUFEeUIsRUFDbkIsSUFEbUIsRUFDYjtBQUN4QixVQUZxQyxFQUUvQixJQUYrQixFQUV6QixJQUZ5QixFQUVuQixJQUZtQixFQUViO0FBQ3hCLFVBSHFDLEVBRy9CLElBSCtCLEVBR3pCLElBSHlCLEVBR25CLElBSG1CLENBQWYsQ0FBeEIsQ0E3QkMsQ0FnQzJCO0FBaEMzQixPQUFQO0FBa0NEOzs7eUJBRVcsSyxFQUFPO0FBQ2pCLFVBQUksWUFBWSxNQUFNLE1BQU4sQ0FBYSxNQUE3QjtBQUNBLGFBQU8sSUFBSSxVQUFKLENBQWUsQ0FDcEIsSUFEb0IsRUFDZDtBQUNOLFVBRm9CLEVBRWQsSUFGYyxFQUVSLElBRlEsRUFFRjs7QUFFbEIsVUFKb0IsRUFJZDtBQUNOLGFBQUssU0FMZSxFQUtKO0FBQ2hCLFVBTm9CLEVBTWQsSUFOYyxFQU1SO0FBQ1osVUFQb0IsRUFPZDs7QUFFTixVQVRvQixFQVNkO0FBQ04sYUFBSyxTQVZlLEVBVUo7QUFDaEIsVUFYb0IsRUFXZDtBQUNOLFVBWm9CLEVBWWQ7QUFDTixVQWJvQixFQWFkLElBYmMsRUFhUixJQWJRLEVBYUY7QUFDbEIsVUFkb0IsRUFjZCxJQWRjLEVBY1IsSUFkUSxFQWNGLElBZEUsRUFjSTtBQUN4QixVQWZvQixFQWVkLElBZmMsRUFlUixJQWZRLEVBZUYsSUFmRSxFQWVJOztBQUV4QixVQWpCb0IsQ0FpQmY7QUFqQmUsUUFrQmxCLE1BbEJrQixDQWtCWCxDQUFDLFNBQUQsQ0FsQlcsRUFrQkUsTUFsQkYsQ0FrQlMsTUFBTSxNQWxCZixFQWtCdUIsTUFsQnZCLENBa0I4QixDQUFDLElBQUQsRUFBTyxJQUFQLEVBQWEsSUFBYixDQWxCOUIsQ0FBZixDQUFQLENBRmlCLENBb0J5RDtBQUMzRTs7O3lCQUVXLEssRUFBTztBQUNqQixVQUFJLGtCQUFrQixNQUFNLGVBQTVCO0FBQ0UsYUFBTyxJQUFJLEdBQUosQ0FBUSxJQUFJLEtBQUosQ0FBVSxJQUFsQixFQUF3QixJQUFJLFVBQUosQ0FBZSxDQUM5QyxJQUQ4QyxFQUN4QyxJQUR3QyxFQUNsQyxJQURrQyxFQUM1QjtBQUNsQixVQUY4QyxFQUV4QyxJQUZ3QyxFQUVsQyxJQUZrQyxFQUU1QjtBQUNsQixVQUg4QyxFQUd4QyxJQUh3QyxFQUdsQztBQUNaLFVBSjhDLEVBSXhDLElBSndDLEVBSWxDLElBSmtDLEVBSTVCLElBSjRCLEVBSzlDLElBTDhDLEVBS3hDLElBTHdDLEVBS2xDLElBTGtDLEVBSzVCLElBTDRCLEVBS3RCO0FBQ3hCLFVBTjhDLEVBTXhDLE1BQU0sWUFOa0MsRUFNcEI7QUFDMUIsVUFQOEMsRUFPeEMsSUFQd0MsRUFPbEM7QUFDWixVQVI4QyxFQVF4QyxJQVJ3QyxFQVFsQyxJQVJrQyxFQVE1QixJQVI0QixFQVF0QjtBQUN2Qix5QkFBbUIsQ0FBcEIsR0FBeUIsSUFUcUIsRUFVOUMsa0JBQWtCLElBVjRCLEVBVXRCO0FBQ3hCLFVBWDhDLEVBV3hDLElBWHdDLENBQWYsQ0FBeEIsRUFZUCxJQUFJLEdBQUosQ0FBUSxJQUFJLEtBQUosQ0FBVSxJQUFsQixFQUF3QixJQUFJLElBQUosQ0FBUyxLQUFULENBQXhCLENBWk8sQ0FBUDtBQWFIOzs7d0JBRVUsSyxFQUFPO0FBQ2hCLFVBQUksa0JBQWtCLE1BQU0sZUFBNUI7QUFDRSxhQUFPLElBQUksR0FBSixDQUFRLElBQUksS0FBSixDQUFVLE1BQVYsQ0FBUixFQUEyQixJQUFJLFVBQUosQ0FBZSxDQUNqRCxJQURpRCxFQUMzQyxJQUQyQyxFQUNyQyxJQURxQyxFQUMvQjtBQUNsQixVQUZpRCxFQUUzQyxJQUYyQyxFQUVyQyxJQUZxQyxFQUUvQjtBQUNsQixVQUhpRCxFQUczQyxJQUgyQyxFQUdyQztBQUNaLFVBSmlELEVBSTNDLElBSjJDLEVBSXJDLElBSnFDLEVBSS9CLElBSitCLEVBS2pELElBTGlELEVBSzNDLElBTDJDLEVBS3JDLElBTHFDLEVBSy9CLElBTCtCLEVBS3pCO0FBQ3hCLFVBTmlELEVBTTNDLE1BQU0sWUFOcUMsRUFNdkI7QUFDMUIsVUFQaUQsRUFPM0MsSUFQMkMsRUFPckM7QUFDWixVQVJpRCxFQVEzQyxJQVIyQyxFQVFyQyxJQVJxQyxFQVEvQixJQVIrQixFQVF6QjtBQUN2Qix5QkFBbUIsQ0FBcEIsR0FBeUIsSUFUd0IsRUFVakQsa0JBQWtCLElBVitCLEVBVXpCO0FBQ3hCLFVBWGlELEVBVzNDLElBWDJDLENBQWYsQ0FBM0IsQ0FBUDtBQVlIOzs7eUJBRVcsSyxFQUFPO0FBQ2pCLFVBQUksTUFBTSxJQUFOLEtBQWUsT0FBbkIsRUFBNEI7QUFDMUIsWUFBSSxDQUFDLE1BQU0sS0FBUCxJQUFnQixNQUFNLEtBQU4sS0FBZ0IsS0FBcEMsRUFBMkM7QUFDekMsaUJBQU8sSUFBSSxHQUFKLENBQVEsSUFBSSxLQUFKLENBQVUsSUFBbEIsRUFBd0IsSUFBSSxJQUE1QixFQUFrQyxJQUFJLEdBQUosQ0FBUSxLQUFSLENBQWxDLENBQVA7QUFDRDtBQUNELGVBQU8sSUFBSSxHQUFKLENBQVEsSUFBSSxLQUFKLENBQVUsSUFBbEIsRUFBd0IsSUFBSSxJQUE1QixFQUFrQyxJQUFJLElBQUosQ0FBUyxLQUFULENBQWxDLENBQVA7QUFDRCxPQUxELE1BS087QUFDTCxlQUFPLElBQUksR0FBSixDQUFRLElBQUksS0FBSixDQUFVLElBQWxCLEVBQXdCLElBQUksSUFBNUIsRUFBa0MsSUFBSSxJQUFKLENBQVMsS0FBVCxDQUFsQyxDQUFQO0FBQ0Q7QUFDRjs7O3lCQUVXLEssRUFBTztBQUNqQixVQUFJLEtBQUssTUFBTSxFQUFmO0FBQUEsVUFDSSxXQUFXLE1BQU0sUUFBTixHQUFlLE1BQU0sU0FEcEM7QUFBQSxVQUVJLFFBQVEsTUFBTSxLQUZsQjtBQUFBLFVBR0ksU0FBUyxNQUFNLE1BSG5CO0FBSUEsYUFBTyxJQUFJLEdBQUosQ0FBUSxJQUFJLEtBQUosQ0FBVSxJQUFsQixFQUF3QixJQUFJLFVBQUosQ0FBZSxDQUM1QyxJQUQ0QyxFQUN0QztBQUNOLFVBRjRDLEVBRXRDLElBRnNDLEVBRWhDLElBRmdDLEVBRTFCO0FBQ2xCLFVBSDRDLEVBR3RDLElBSHNDLEVBR2hDLElBSGdDLEVBRzFCLElBSDBCLEVBR3BCO0FBQ3hCLFVBSjRDLEVBSXRDLElBSnNDLEVBSWhDLElBSmdDLEVBSTFCLElBSjBCLEVBSXBCO0FBQ3ZCLFlBQU0sRUFBUCxHQUFhLElBTCtCLEVBTTNDLE1BQU0sRUFBUCxHQUFhLElBTitCLEVBTzNDLE1BQU0sQ0FBUCxHQUFZLElBUGdDLEVBUTVDLEtBQUssSUFSdUMsRUFRakM7QUFDWCxVQVQ0QyxFQVN0QyxJQVRzQyxFQVNoQyxJQVRnQyxFQVMxQixJQVQwQixFQVNwQjtBQUN2QixrQkFBWSxFQVYrQixFQVczQyxZQUFZLEVBQWIsR0FBbUIsSUFYeUIsRUFZM0MsWUFBYSxDQUFkLEdBQW1CLElBWnlCLEVBYTVDLFdBQVcsSUFiaUMsRUFhM0I7QUFDakIsVUFkNEMsRUFjdEMsSUFkc0MsRUFjaEMsSUFkZ0MsRUFjMUIsSUFkMEIsRUFlNUMsSUFmNEMsRUFldEMsSUFmc0MsRUFlaEMsSUFmZ0MsRUFlMUIsSUFmMEIsRUFlcEI7QUFDeEIsVUFoQjRDLEVBZ0J0QyxJQWhCc0MsRUFnQmhDO0FBQ1osVUFqQjRDLEVBaUJ0QyxJQWpCc0MsRUFpQmhDO0FBQ1osVUFsQjRDLEVBa0J0QyxJQWxCc0MsRUFrQmhDO0FBQ1osVUFuQjRDLEVBbUJ0QyxJQW5Cc0MsRUFtQmhDO0FBQ1osVUFwQjRDLEVBb0J0QyxJQXBCc0MsRUFvQmhDLElBcEJnQyxFQW9CMUIsSUFwQjBCLEVBcUI1QyxJQXJCNEMsRUFxQnRDLElBckJzQyxFQXFCaEMsSUFyQmdDLEVBcUIxQixJQXJCMEIsRUFzQjVDLElBdEI0QyxFQXNCdEMsSUF0QnNDLEVBc0JoQyxJQXRCZ0MsRUFzQjFCLElBdEIwQixFQXVCNUMsSUF2QjRDLEVBdUJ0QyxJQXZCc0MsRUF1QmhDLElBdkJnQyxFQXVCMUIsSUF2QjBCLEVBd0I1QyxJQXhCNEMsRUF3QnRDLElBeEJzQyxFQXdCaEMsSUF4QmdDLEVBd0IxQixJQXhCMEIsRUF5QjVDLElBekI0QyxFQXlCdEMsSUF6QnNDLEVBeUJoQyxJQXpCZ0MsRUF5QjFCLElBekIwQixFQTBCNUMsSUExQjRDLEVBMEJ0QyxJQTFCc0MsRUEwQmhDLElBMUJnQyxFQTBCMUIsSUExQjBCLEVBMkI1QyxJQTNCNEMsRUEyQnRDLElBM0JzQyxFQTJCaEMsSUEzQmdDLEVBMkIxQixJQTNCMEIsRUE0QjVDLElBNUI0QyxFQTRCdEMsSUE1QnNDLEVBNEJoQyxJQTVCZ0MsRUE0QjFCLElBNUIwQixFQTRCcEI7QUFDdkIsZUFBUyxDQUFWLEdBQWUsSUE3QjZCLEVBOEI1QyxRQUFRLElBOUJvQyxFQStCNUMsSUEvQjRDLEVBK0J0QyxJQS9Cc0MsRUErQmhDO0FBQ1gsZ0JBQVUsQ0FBWCxHQUFnQixJQWhDNEIsRUFpQzVDLFNBQVMsSUFqQ21DLEVBa0M1QyxJQWxDNEMsRUFrQ3RDLElBbENzQyxDQWtDakM7QUFsQ2lDLE9BQWYsQ0FBeEIsQ0FBUDtBQW9DRDs7O3lCQUVXLEssRUFBTSxtQixFQUFxQjtBQUNyQyxVQUFJLHdCQUF3QixJQUFJLElBQUosQ0FBUyxLQUFULENBQTVCO0FBQUEsVUFDSSxLQUFLLE1BQU0sRUFEZjtBQUVBLGFBQU8sSUFBSSxHQUFKLENBQVEsSUFBSSxLQUFKLENBQVUsSUFBbEIsRUFDSSxJQUFJLEdBQUosQ0FBUSxJQUFJLEtBQUosQ0FBVSxJQUFsQixFQUF3QixJQUFJLFVBQUosQ0FBZSxDQUNyQyxJQURxQyxFQUMvQjtBQUNOLFVBRnFDLEVBRS9CLElBRitCLEVBRXpCLElBRnlCLEVBRW5CO0FBQ2pCLFlBQU0sRUFIOEIsRUFJcEMsTUFBTSxFQUFQLEdBQWEsSUFKd0IsRUFLcEMsTUFBTSxDQUFQLEdBQVksSUFMeUIsRUFNcEMsS0FBSyxJQU4rQixDQUFmLENBQXhCLENBREosRUFTSSxJQUFJLEdBQUosQ0FBUSxJQUFJLEtBQUosQ0FBVSxJQUFsQixFQUF3QixJQUFJLFVBQUosQ0FBZSxDQUNyQyxJQURxQyxFQUMvQjtBQUNOLFVBRnFDLEVBRS9CLElBRitCLEVBRXpCLElBRnlCLEVBRW5CO0FBQ2pCLDZCQUFzQixFQUhjLEVBSXBDLHVCQUF1QixFQUF4QixHQUE4QixJQUpPLEVBS3BDLHVCQUF1QixDQUF4QixHQUE2QixJQUxRLEVBTXBDLHNCQUFzQixJQU5jLENBQWYsQ0FBeEIsQ0FUSixFQWlCSSxJQUFJLElBQUosQ0FBUyxLQUFULEVBQ0ssc0JBQXNCLE1BQXRCLEdBQ0EsRUFEQSxHQUNLO0FBQ0wsUUFGQSxHQUVLO0FBQ0wsT0FIQSxHQUdLO0FBQ0wsUUFKQSxHQUlLO0FBQ0wsT0FMQSxHQUtLO0FBQ0wsT0FQTCxDQWpCSixFQXdCYztBQUNWLDJCQXpCSixDQUFQO0FBMEJEOztBQUVEOzs7Ozs7Ozt5QkFLWSxLLEVBQU87QUFDakIsWUFBTSxRQUFOLEdBQWlCLE1BQU0sUUFBTixJQUFrQixVQUFuQztBQUNBLGFBQU8sSUFBSSxHQUFKLENBQVEsSUFBSSxLQUFKLENBQVUsSUFBbEIsRUFBd0IsSUFBSSxJQUFKLENBQVMsS0FBVCxDQUF4QixFQUF5QyxJQUFJLElBQUosQ0FBUyxLQUFULENBQXpDLENBQVA7QUFDRDs7O3lCQUVXLEssRUFBTztBQUNqQixVQUFJLEtBQUssTUFBTSxFQUFmO0FBQ0EsYUFBTyxJQUFJLEdBQUosQ0FBUSxJQUFJLEtBQUosQ0FBVSxJQUFsQixFQUF3QixJQUFJLFVBQUosQ0FBZSxDQUM1QyxJQUQ0QyxFQUN0QztBQUNOLFVBRjRDLEVBRXRDLElBRnNDLEVBRWhDLElBRmdDLEVBRTFCO0FBQ2xCLFlBQU0sRUFIc0MsRUFJNUMsTUFBTSxFQUFQLEdBQWEsSUFKZ0MsRUFLNUMsTUFBTSxDQUFQLEdBQVksSUFMaUMsRUFNNUMsS0FBSyxJQU51QyxFQU1oQztBQUNaLFVBUDRDLEVBT3RDLElBUHNDLEVBT2hDLElBUGdDLEVBTzFCLElBUDBCLEVBT3BCO0FBQ3hCLFVBUjRDLEVBUXRDLElBUnNDLEVBUWhDLElBUmdDLEVBUTFCLElBUjBCLEVBUXBCO0FBQ3hCLFVBVDRDLEVBU3RDLElBVHNDLEVBU2hDLElBVGdDLEVBUzFCLElBVDBCLEVBU3BCO0FBQ3hCLFVBVjRDLEVBVXRDLElBVnNDLEVBVWhDLElBVmdDLEVBVTFCLElBVjBCLENBVXJCO0FBVnFCLE9BQWYsQ0FBeEIsQ0FBUDtBQVlEOzs7eUJBRVcsSyxFQUFPLE0sRUFBUTtBQUN6QixVQUFJLFVBQVMsTUFBTSxPQUFOLElBQWlCLEVBQTlCO0FBQUEsVUFDSSxNQUFNLFFBQVEsTUFEbEI7QUFBQSxVQUVJLFdBQVcsS0FBTSxLQUFLLEdBRjFCO0FBQUEsVUFHSSxRQUFRLElBQUksVUFBSixDQUFlLFFBQWYsQ0FIWjtBQUFBLFVBSUksQ0FKSjtBQUFBLFVBSU0sTUFKTjtBQUFBLFVBSWEsUUFKYjtBQUFBLFVBSXNCLElBSnRCO0FBQUEsVUFJMkIsS0FKM0I7QUFBQSxVQUlpQyxHQUpqQztBQUtBLGdCQUFVLElBQUksUUFBZDtBQUNBLFlBQU0sR0FBTixDQUFVLENBQ1IsSUFEUSxFQUNGO0FBQ04sVUFGUSxFQUVGLElBRkUsRUFFSSxJQUZKLEVBRVU7QUFDakIsY0FBUSxFQUFULEdBQWUsSUFIUCxFQUlQLFFBQVEsRUFBVCxHQUFlLElBSlAsRUFLUCxRQUFRLENBQVQsR0FBYyxJQUxOLEVBTVIsTUFBTSxJQU5FLEVBTUk7QUFDWCxpQkFBVyxFQUFaLEdBQWtCLElBUFYsRUFRUCxXQUFXLEVBQVosR0FBa0IsSUFSVixFQVNQLFdBQVcsQ0FBWixHQUFpQixJQVRULEVBVVIsU0FBUyxJQVZELENBVU07QUFWTixPQUFWLEVBV0UsQ0FYRjtBQVlBLFdBQUssSUFBSSxDQUFULEVBQVksSUFBSSxHQUFoQixFQUFxQixHQUFyQixFQUEwQjtBQUN4QixpQkFBUyxRQUFRLENBQVIsQ0FBVDtBQUNBLG1CQUFXLE9BQU8sUUFBbEI7QUFDQSxlQUFPLE9BQU8sSUFBZDtBQUNBLGdCQUFRLE9BQU8sS0FBZjtBQUNBLGNBQU0sT0FBTyxHQUFiO0FBQ0EsY0FBTSxHQUFOLENBQVUsQ0FDUCxhQUFhLEVBQWQsR0FBb0IsSUFEWixFQUVQLGFBQWEsRUFBZCxHQUFvQixJQUZaLEVBR1AsYUFBYSxDQUFkLEdBQW1CLElBSFgsRUFJUixXQUFXLElBSkgsRUFJUztBQUNoQixpQkFBUyxFQUFWLEdBQWdCLElBTFIsRUFNUCxTQUFTLEVBQVYsR0FBZ0IsSUFOUixFQU9QLFNBQVMsQ0FBVixHQUFlLElBUFAsRUFRUixPQUFPLElBUkMsRUFRSztBQUNaLGNBQU0sU0FBTixJQUFtQixDQUFwQixHQUF5QixNQUFNLFNBVHZCLEVBVVAsTUFBTSxZQUFOLElBQXNCLENBQXZCLEdBQ0csTUFBTSxhQUFOLElBQXVCLENBRDFCLEdBRUcsTUFBTSxZQUFOLElBQXNCLENBRnpCLEdBR0UsTUFBTSxTQWJBLEVBY1IsTUFBTSxVQUFOLEdBQW1CLFFBQVEsQ0FkbkIsRUFlUixNQUFNLFVBQU4sR0FBbUIsSUFmWCxFQWVpQjtBQUN4QixnQkFBUSxFQUFULEdBQWUsSUFoQlAsRUFpQlAsUUFBUSxFQUFULEdBQWUsSUFqQlAsRUFrQlAsUUFBUSxDQUFULEdBQWMsSUFsQk4sRUFtQlIsTUFBTSxJQW5CRSxDQW1CRztBQW5CSCxTQUFWLEVBb0JFLEtBQUcsS0FBRyxDQXBCUjtBQXFCRDtBQUNELGFBQU8sSUFBSSxHQUFKLENBQVEsSUFBSSxLQUFKLENBQVUsSUFBbEIsRUFBd0IsS0FBeEIsQ0FBUDtBQUNEOzs7Z0NBRWtCLE0sRUFBUTtBQUN6QixVQUFJLENBQUMsSUFBSSxLQUFULEVBQWdCO0FBQ2QsWUFBSSxJQUFKO0FBQ0Q7QUFDRCxVQUFJLFFBQVEsSUFBSSxJQUFKLENBQVMsTUFBVCxDQUFaO0FBQUEsVUFBOEIsTUFBOUI7QUFDQSxlQUFTLElBQUksVUFBSixDQUFlLElBQUksSUFBSixDQUFTLFVBQVQsR0FBc0IsTUFBTSxVQUEzQyxDQUFUO0FBQ0EsYUFBTyxHQUFQLENBQVcsSUFBSSxJQUFmO0FBQ0EsYUFBTyxHQUFQLENBQVcsS0FBWCxFQUFrQixJQUFJLElBQUosQ0FBUyxVQUEzQjtBQUNBLGFBQU8sTUFBUDtBQUNEOzs7Ozs7a0JBR1ksRzs7Ozs7Ozs7O3FqQkNobUJmOzs7O0FBS0E7Ozs7QUFDQTs7OztBQUNBOztBQUNBOzs7O0FBQ0E7Ozs7OztJQUVNLFU7QUFDSixzQkFBWSxRQUFaLEVBQXNCLEVBQXRCLEVBQTBCLE1BQTFCLEVBQWtDLGFBQWxDLEVBQWlEO0FBQUE7O0FBQy9DLFNBQUssUUFBTCxHQUFnQixRQUFoQjtBQUNBLFNBQUssRUFBTCxHQUFVLEVBQVY7QUFDQSxTQUFLLE1BQUwsR0FBYyxNQUFkO0FBQ0EsU0FBSyxhQUFMLEdBQXFCLGFBQXJCO0FBQ0EsU0FBSyxXQUFMLEdBQW1CLEtBQW5CO0FBQ0EsU0FBSyxrQkFBTCxHQUEwQixDQUExQjtBQUNBLFNBQUssYUFBTCxHQUFxQixLQUFyQjtBQUNBLFNBQUssYUFBTCxHQUFxQixLQUFLLGFBQUwsR0FBcUIsS0FBSyxrQkFBL0M7QUFDRDs7Ozs4QkFNUyxDQUNUOzs7MENBRXFCO0FBQ3BCLFdBQUssUUFBTCxHQUFnQixLQUFLLFFBQUwsR0FBZ0IsU0FBaEM7QUFDRDs7O2tDQUVhO0FBQ1osV0FBSyxXQUFMLEdBQW1CLEtBQW5CO0FBQ0Q7OzswQkFFSyxLLEVBQU0sRSxFQUFHLEUsRUFBRyxVLEVBQVcsVSxFQUFXLFEsRUFBUyxTLEVBQVUsVSxFQUFZLFUsRUFBVyxrQixFQUFtQixjLEVBQWdCO0FBQ25ILFdBQUssS0FBTCxHQUFhLEtBQWI7QUFDQSxXQUFLLEVBQUwsR0FBVSxFQUFWO0FBQ0E7QUFDQSxVQUFJLENBQUMsS0FBSyxXQUFWLEVBQXVCO0FBQ3JCLGFBQUssVUFBTCxDQUFnQixVQUFoQixFQUEyQixVQUEzQixFQUFzQyxVQUF0QyxFQUFpRCxFQUFqRDtBQUNEOztBQUVELFVBQUksbUJBQWlCLElBQXJCLEVBQTJCO0FBQ3pCLGFBQUssUUFBTCxHQUFjLEtBQUssUUFBTCxHQUFlLGNBQTdCO0FBQ0Q7O0FBRUQsVUFBSSxLQUFLLFdBQVQsRUFBc0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsWUFBSSxXQUFXLE9BQVgsQ0FBbUIsTUFBdkIsRUFBK0I7QUFDN0IsY0FBSSxZQUFZLEtBQUssVUFBTCxDQUFnQixVQUFoQixFQUEyQixVQUEzQixFQUFzQyxVQUF0QyxFQUFpRCxrQkFBakQsQ0FBaEI7QUFDQTtBQUNBLGNBQUksV0FBVyxPQUFYLENBQW1CLE1BQXZCLEVBQStCO0FBQzdCLGdCQUFJLHlCQUFKO0FBQ0EsZ0JBQUksU0FBSixFQUFlO0FBQ2IsaUNBQW1CLFVBQVUsTUFBVixHQUFtQixVQUFVLFFBQWhEO0FBQ0Q7QUFDRCxpQkFBSyxVQUFMLENBQWdCLFVBQWhCLEVBQTJCLFVBQTNCLEVBQXNDLFVBQXRDLEVBQWlELGdCQUFqRDtBQUNEO0FBQ0YsU0FWRCxNQVVPO0FBQ0wsY0FBSSxrQkFBSjtBQUNBO0FBQ0EsY0FBSSxXQUFXLE9BQVgsQ0FBbUIsTUFBdkIsRUFBK0I7QUFDN0Isd0JBQVksS0FBSyxVQUFMLENBQWdCLFVBQWhCLEVBQTJCLFVBQTNCLEVBQXNDLFVBQXRDLENBQVo7QUFDRDtBQUNELGNBQUksYUFBYSxXQUFXLEtBQTVCLEVBQW1DO0FBQ2pDLGlCQUFLLGVBQUwsQ0FBcUIsVUFBckIsRUFBaUMsVUFBakMsRUFBNkMsVUFBN0MsRUFBeUQsU0FBekQ7QUFDRDtBQUNGO0FBQ0Y7QUFDRDtBQUNBLFVBQUksU0FBUyxPQUFULENBQWlCLE1BQXJCLEVBQTZCO0FBQzNCLGFBQUssUUFBTCxDQUFjLFFBQWQsRUFBdUIsVUFBdkI7QUFDRDtBQUNEO0FBQ0EsVUFBSSxVQUFVLE9BQVYsQ0FBa0IsTUFBdEIsRUFBOEI7QUFDNUIsYUFBSyxTQUFMLENBQWUsU0FBZixFQUF5QixVQUF6QjtBQUNEO0FBQ0Q7QUFDQSxXQUFLLFFBQUwsQ0FBYyxPQUFkLENBQXNCLGlCQUFNLFdBQTVCLEVBQXlDLEVBQUUsSUFBSyxLQUFLLEVBQVosRUFBaUIsT0FBUSxLQUFLLEtBQTlCLEVBQXFDLElBQUssS0FBSyxFQUEvQyxFQUF6QztBQUNEOzs7K0JBRVUsVSxFQUFXLFUsRUFBVyxVLEVBQVcsRSxFQUFJO0FBQzlDLFVBQUksV0FBVyxLQUFLLFFBQXBCO0FBQUEsVUFDSSxlQUFlLFdBQVcsT0FEOUI7QUFBQSxVQUVJLGVBQWUsV0FBVyxPQUY5QjtBQUFBLFVBR0ksZUFBZSxLQUFLLGFBSHhCO0FBQUEsVUFJSSxnQkFBZ0IsS0FBSyxhQUp6QjtBQUFBLFVBS0ksWUFBWSxXQUxoQjtBQUFBLFVBTUksU0FBUyxFQU5iO0FBQUEsVUFPSSxPQUFPLEVBQUUsSUFBSyxLQUFLLEVBQVosRUFBZ0IsT0FBUSxLQUFLLEtBQTdCLEVBQW9DLElBQUssS0FBSyxFQUE5QyxFQUFrRCxRQUFTLE1BQTNELEVBQW1FLFFBQVMsS0FBNUUsRUFQWDtBQUFBLFVBUUksZ0JBQWlCLEtBQUssUUFBTCxLQUFrQixTQVJ2QztBQUFBLFVBU0ksT0FUSjtBQUFBLFVBU2EsT0FUYjs7QUFXQSxVQUFJLGFBQUosRUFBbUI7QUFDakIsa0JBQVUsVUFBVSxRQUFwQjtBQUNEO0FBQ0QsVUFBSSxXQUFXLE1BQVgsSUFBcUIsYUFBYSxNQUF0QyxFQUE4QztBQUM1QyxtQkFBVyxTQUFYLEdBQXVCLFdBQVcsZUFBbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQUksV0FBVyxTQUFYLEdBQXVCLFdBQVcsUUFBbEMsR0FBNkMsS0FBSyxHQUFMLENBQVMsQ0FBVCxFQUFZLEVBQVosQ0FBakQsRUFBa0U7QUFBQTtBQUNoRSxnQkFBSSx3QkFBd0IsU0FBeEIscUJBQXdCLENBQVMsQ0FBVCxFQUFZLENBQVosRUFBZTtBQUN2QyxrQkFBSyxDQUFFLENBQVAsRUFBVTtBQUNOLHVCQUFPLENBQVA7QUFDSDtBQUNELHFCQUFPLHNCQUFzQixDQUF0QixFQUF5QixJQUFJLENBQTdCLENBQVA7QUFDSCxhQUxEO0FBTUEsdUJBQVcsU0FBWCxHQUF1QixXQUFXLGVBQVgsR0FBNkIsc0JBQXNCLFdBQVcsZUFBakMsRUFBa0QsV0FBVyxLQUFYLEdBQW1CLElBQW5CLEdBQTBCLElBQTVFLENBQXBEO0FBUGdFO0FBUWpFO0FBQ0QsdUJBQU8sR0FBUCxDQUFZLDBCQUF5QixXQUFXLFNBQWhEO0FBQ0EsWUFBSSxDQUFDLFdBQVcsS0FBaEIsRUFBdUI7QUFDckIsY0FBSSxjQUFjLElBQWxCLEVBQXdCO0FBQUU7QUFDeEIsd0JBQVksWUFBWjtBQUNBLHVCQUFXLEtBQVgsR0FBbUIsRUFBbkI7QUFDRCxXQUhELE1BR08sSUFBSSxjQUFjLEdBQWxCLEVBQXVCO0FBQUU7QUFDOUIsdUJBQVcsS0FBWCxHQUFtQixLQUFuQjtBQUNEO0FBQ0Y7QUFDRCxlQUFPLEtBQVAsR0FBZTtBQUNiLHFCQUFZLFNBREM7QUFFYixpQkFBUyxXQUFXLEtBRlA7QUFHYix1QkFBYyxDQUFDLFdBQVcsS0FBWixJQUFxQixjQUFjLElBQW5DLEdBQTBDLElBQUksVUFBSixFQUExQyxHQUE2RCx1QkFBSSxXQUFKLENBQWdCLENBQUMsVUFBRCxDQUFoQixDQUg5RDtBQUliLG9CQUFXO0FBQ1QsMEJBQWUsV0FBVztBQURqQjtBQUpFLFNBQWY7QUFRQSxZQUFJLGFBQUosRUFBbUI7QUFDakI7QUFDQSxvQkFBVSxVQUFVLGFBQWEsQ0FBYixFQUFnQixHQUFoQixHQUFzQixlQUFlLFVBQXpEO0FBQ0Q7QUFDRjs7QUFFRCxVQUFJLFdBQVcsR0FBWCxJQUFrQixXQUFXLEdBQTdCLElBQW9DLGFBQWEsTUFBckQsRUFBNkQ7QUFDM0QsbUJBQVcsU0FBWCxHQUF1QixLQUFLLGFBQTVCO0FBQ0EsZUFBTyxLQUFQLEdBQWU7QUFDYixxQkFBWSxXQURDO0FBRWIsaUJBQVMsV0FBVyxLQUZQO0FBR2IsdUJBQWMsdUJBQUksV0FBSixDQUFnQixDQUFDLFVBQUQsQ0FBaEIsQ0FIRDtBQUliLG9CQUFXO0FBQ1QsbUJBQVEsV0FBVyxLQURWO0FBRVQsb0JBQVMsV0FBVztBQUZYO0FBSkUsU0FBZjtBQVNBLFlBQUksYUFBSixFQUFtQjtBQUNqQixvQkFBVSxLQUFLLEdBQUwsQ0FBUyxPQUFULEVBQWlCLGFBQWEsQ0FBYixFQUFnQixHQUFoQixHQUFzQixlQUFlLFVBQXRELENBQVY7QUFDQSxvQkFBVSxLQUFLLEdBQUwsQ0FBUyxPQUFULEVBQWlCLGFBQWEsQ0FBYixFQUFnQixHQUFoQixHQUFzQixlQUFlLFVBQXRELENBQVY7QUFDQSxlQUFLLFFBQUwsQ0FBYyxPQUFkLENBQXNCLGlCQUFNLGNBQTVCLEVBQTRDLEVBQUMsZ0JBQUQsRUFBNUM7QUFDQSxlQUFLLFFBQUwsQ0FBYyxPQUFkLENBQXNCLGlCQUFNLGNBQTVCLEVBQTRDLEVBQUUsSUFBSSxLQUFLLEVBQVgsRUFBZSxTQUFTLE9BQXhCLEVBQWlDLElBQUksRUFBckMsRUFBNUM7QUFDRDtBQUNGOztBQUVELFVBQUcsT0FBTyxJQUFQLENBQVksTUFBWixFQUFvQixNQUF2QixFQUErQjtBQUM3QixpQkFBUyxPQUFULENBQWlCLGlCQUFNLHlCQUF2QixFQUFpRCxJQUFqRDtBQUNBLGFBQUssV0FBTCxHQUFtQixJQUFuQjtBQUNBLFlBQUksYUFBSixFQUFtQjtBQUNqQixlQUFLLFFBQUwsR0FBZ0IsT0FBaEI7QUFDQSxlQUFLLFFBQUwsR0FBZ0IsT0FBaEI7QUFDRDtBQUNGLE9BUEQsTUFPTztBQUNMLGlCQUFTLE9BQVQsQ0FBaUIsaUJBQU0sS0FBdkIsRUFBOEIsRUFBQyxNQUFPLG1CQUFXLFdBQW5CLEVBQWdDLElBQUssS0FBSyxFQUExQyxFQUE4QyxTQUFTLHFCQUFhLGtCQUFwRSxFQUF3RixPQUFPLEtBQS9GLEVBQXNHLFFBQVEsOEJBQTlHLEVBQTlCO0FBQ0Q7QUFDRjs7OytCQUVVLEssRUFBTyxVLEVBQVksVSxFQUFZLGdCLEVBQWtCO0FBQzFELFVBQUksU0FBUyxDQUFiO0FBQUEsVUFDSSxlQUFlLEtBQUssYUFEeEI7QUFBQSxVQUVJLHFCQUFxQixLQUFLLGtCQUY5QjtBQUFBLFVBR0ksaUJBSEo7QUFBQSxVQUlJLElBSko7QUFBQSxVQUlVLElBSlY7QUFBQSxVQUtJLFFBTEo7QUFBQSxVQUtjLFFBTGQ7QUFBQSxVQU1JLE9BTko7QUFBQSxVQU9JLE9BUEo7QUFBQSxVQU9hLE9BUGI7QUFBQSxVQVFJLGVBQWUsTUFBTSxPQVJ6QjtBQUFBLFVBU0ksZ0JBQWdCLEVBVHBCO0FBQUEsVUFVSSxZQUFZLGFBQWEsTUFWN0I7QUFBQSxVQVdJLGVBQWUsS0FBSyxhQVh4QjtBQUFBLFVBWUksVUFBVSxLQUFLLFFBWm5COztBQWNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFRTtBQUNBLG1CQUFhLElBQWIsQ0FBa0IsVUFBUyxDQUFULEVBQVksQ0FBWixFQUFlO0FBQy9CLGVBQVEsRUFBRSxHQUFGLEdBQU0sRUFBRSxHQUFoQjtBQUNELE9BRkQ7O0FBSUE7QUFDQSxVQUFJLGNBQWMsYUFBYSxNQUFiLENBQXFCLFVBQUMsSUFBRCxFQUFPLElBQVA7QUFBQSxlQUFnQixLQUFLLEdBQUwsQ0FBUyxLQUFLLEdBQUwsQ0FBUyxJQUFULEVBQWMsS0FBSyxHQUFMLEdBQVMsS0FBSyxHQUE1QixDQUFULEVBQTBDLENBQUMsS0FBM0MsQ0FBaEI7QUFBQSxPQUFyQixFQUF1RixDQUF2RixDQUFsQjtBQUNBLFVBQUksY0FBYyxDQUFsQixFQUFxQjtBQUNuQix1QkFBTyxJQUFQLDJEQUFvRSxLQUFLLEtBQUwsQ0FBVyxjQUFZLEVBQXZCLENBQXBFO0FBQ0EsYUFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLGFBQWEsTUFBakMsRUFBeUMsR0FBekMsRUFBOEM7QUFDNUMsdUJBQWEsQ0FBYixFQUFnQixHQUFoQixJQUF1QixXQUF2QjtBQUNEO0FBQ0Y7O0FBRUg7QUFDQTtBQUNDLFVBQUksbUJBQUo7QUFDQTtBQUNDLFVBQUksVUFBSixFQUFnQjtBQUNkO0FBQ0EscUJBQWEsS0FBSyxVQUFsQjtBQUNELE9BSEQsTUFHTztBQUNMO0FBQ0EscUJBQWEsYUFBVyxZQUF4QjtBQUNEOztBQUVEO0FBQ0EsVUFBSSxTQUFTLGFBQWEsQ0FBYixDQUFiO0FBQ0EsaUJBQVksS0FBSyxHQUFMLENBQVMsYUFBYSxPQUFPLEdBQVAsR0FBYSxPQUExQixFQUFrQyxVQUFsQyxDQUFULEVBQXVELENBQXZELENBQVo7QUFDQSxpQkFBWSxLQUFLLEdBQUwsQ0FBUyxhQUFhLE9BQU8sR0FBUCxHQUFhLE9BQTFCLEVBQWtDLFVBQWxDLENBQVQsRUFBdUQsQ0FBdkQsQ0FBWjs7QUFFQTtBQUNBLFVBQUksUUFBUSxLQUFLLEtBQUwsQ0FBVyxDQUFDLFdBQVcsVUFBWixJQUEwQixFQUFyQyxDQUFaO0FBQ0E7QUFDQSxVQUFJLFVBQUosRUFBZ0I7QUFDZCxZQUFJLEtBQUosRUFBVztBQUNULGNBQUksUUFBUSxDQUFaLEVBQWU7QUFDYiwyQkFBTyxHQUFQLFVBQWtCLEtBQWxCO0FBQ0QsV0FGRCxNQUVPLElBQUksUUFBUSxDQUFDLENBQWIsRUFBZ0I7QUFDckIsMkJBQU8sR0FBUCxVQUFtQixDQUFDLEtBQXBCO0FBQ0Q7QUFDRDtBQUNBLHFCQUFXLFVBQVg7QUFDQSx1QkFBYSxDQUFiLEVBQWdCLEdBQWhCLEdBQXNCLFdBQVcsT0FBakM7QUFDQTtBQUNBLHFCQUFXLEtBQUssR0FBTCxDQUFTLFdBQVcsS0FBcEIsRUFBMkIsVUFBM0IsQ0FBWDtBQUNBLHVCQUFhLENBQWIsRUFBZ0IsR0FBaEIsR0FBc0IsV0FBVyxPQUFqQztBQUNBLHlCQUFPLEdBQVAsOEJBQXNDLEtBQUssS0FBTCxDQUFXLFdBQVMsRUFBcEIsQ0FBdEMsU0FBaUUsS0FBSyxLQUFMLENBQVcsV0FBUyxFQUFwQixDQUFqRSxlQUFrRyxLQUFsRztBQUNEO0FBQ0Y7QUFDRCxnQkFBVSxRQUFWOztBQUVBO0FBQ0EsZUFBUyxhQUFhLGFBQWEsTUFBYixHQUFvQixDQUFqQyxDQUFUO0FBQ0EsZ0JBQVUsS0FBSyxHQUFMLENBQVMsYUFBYSxPQUFPLEdBQVAsR0FBYSxPQUExQixFQUFrQyxVQUFsQyxDQUFULEVBQXdELENBQXhELENBQVY7QUFDQSxnQkFBVSxLQUFLLEdBQUwsQ0FBUyxhQUFhLE9BQU8sR0FBUCxHQUFhLE9BQTFCLEVBQWtDLFVBQWxDLENBQVQsRUFBd0QsQ0FBeEQsQ0FBVjtBQUNBLGdCQUFVLEtBQUssR0FBTCxDQUFTLE9BQVQsRUFBa0IsT0FBbEIsQ0FBVjs7QUFFQSxVQUFJLFNBQVMsVUFBVSxNQUF2QjtBQUFBLFVBQStCLFlBQVksVUFBVSxTQUFyRDtBQUFBLFVBQ0ksV0FBVyxVQUFVLE9BQU8sT0FBUCxDQUFlLE9BQWYsSUFBMEIsQ0FBQyxDQUFyQyxJQUEwQyxTQUExQyxJQUF1RCxDQUFDLFVBQVUsS0FBVixDQUFnQixPQUFoQixDQUR2RTs7QUFHRTtBQUNBO0FBQ0E7QUFDRixVQUFJLFFBQUosRUFBYztBQUNaLDRCQUFvQixLQUFLLEtBQUwsQ0FBVyxDQUFDLFVBQVEsUUFBVCxLQUFvQixzQkFBb0IsYUFBYSxNQUFiLEdBQW9CLENBQXhDLENBQXBCLENBQVgsQ0FBcEI7QUFDRDs7QUFFRDtBQUNBLFdBQUssSUFBSSxLQUFJLENBQWIsRUFBaUIsS0FBSSxTQUFyQixFQUFnQyxJQUFoQyxFQUFxQztBQUNuQyxZQUFJLFVBQVMsYUFBYSxFQUFiLENBQWI7QUFDQSxZQUFJLFFBQUosRUFBYztBQUNaO0FBQ0Esa0JBQU8sR0FBUCxHQUFhLFdBQVcsS0FBRSxrQkFBRixHQUFxQixpQkFBN0M7QUFDRCxTQUhELE1BR087QUFDTDtBQUNBLGtCQUFPLEdBQVAsR0FBYSxLQUFLLEdBQUwsQ0FBUyxhQUFhLFFBQU8sR0FBUCxHQUFhLE9BQTFCLEVBQW1DLFVBQW5DLENBQVQsRUFBd0QsUUFBeEQsQ0FBYjtBQUNBO0FBQ0Esa0JBQU8sR0FBUCxHQUFhLEtBQUssS0FBTCxDQUFXLFFBQU8sR0FBUCxHQUFXLGtCQUF0QixJQUEwQyxrQkFBdkQ7QUFDRDtBQUNEO0FBQ0E7QUFDQSxnQkFBTyxHQUFQLEdBQWEsS0FBSyxHQUFMLENBQVMsYUFBYSxRQUFPLEdBQVAsR0FBYSxPQUExQixFQUFrQyxVQUFsQyxDQUFULEVBQXlELFFBQU8sR0FBaEUsQ0FBYjtBQUNBO0FBQ0EsZ0JBQU8sR0FBUCxHQUFhLEtBQUssS0FBTCxDQUFXLFFBQU8sR0FBUCxHQUFXLGtCQUF0QixJQUEwQyxrQkFBdkQ7QUFDRDs7QUFFRDs7QUFFQSxVQUFJLFdBQVcsTUFBTSxHQUFOLEdBQWEsSUFBSSxNQUFNLE1BQXZCLEdBQWlDLENBQWhEO0FBQ0EsVUFBSTtBQUNGLGVBQU8sSUFBSSxVQUFKLENBQWUsUUFBZixDQUFQO0FBQ0QsT0FGRCxDQUVFLE9BQU0sR0FBTixFQUFXO0FBQ1gsYUFBSyxRQUFMLENBQWMsT0FBZCxDQUFzQixpQkFBTSxLQUE1QixFQUFtQyxFQUFDLE1BQU8sbUJBQVcsU0FBbkIsRUFBOEIsT0FBTyxLQUFLLEtBQTFDLEVBQWlELElBQUssS0FBSyxFQUEzRCxFQUErRCxTQUFTLHFCQUFhLGlCQUFyRixFQUF3RyxPQUFPLEtBQS9HLEVBQXNILE9BQVEsUUFBOUgsRUFBd0ksd0NBQXNDLFFBQTlLLEVBQW5DO0FBQ0E7QUFDRDtBQUNELFVBQUksT0FBTyxJQUFJLFFBQUosQ0FBYSxLQUFLLE1BQWxCLENBQVg7QUFDQSxXQUFLLFNBQUwsQ0FBZSxDQUFmLEVBQWtCLFFBQWxCO0FBQ0EsV0FBSyxHQUFMLENBQVMsdUJBQUksS0FBSixDQUFVLElBQW5CLEVBQXlCLENBQXpCOztBQUVBLFdBQUssSUFBSSxNQUFJLENBQWIsRUFBaUIsTUFBSSxTQUFyQixFQUFnQyxLQUFoQyxFQUFxQztBQUNuQyxZQUFJLFlBQVksYUFBYSxHQUFiLENBQWhCO0FBQUEsWUFDSSxpQkFBaUIsVUFBVSxLQUFWLENBQWdCLEtBRHJDO0FBQUEsWUFFSSxrQkFBa0IsQ0FGdEI7QUFBQSxZQUdJLDhCQUhKO0FBSUE7QUFDQSxhQUFJLElBQUksSUFBSSxDQUFSLEVBQVcsVUFBVSxlQUFlLE1BQXhDLEVBQWdELElBQUksT0FBcEQsRUFBOEQsR0FBOUQsRUFBbUU7QUFDakUsY0FBSSxPQUFPLGVBQWUsQ0FBZixDQUFYO0FBQUEsY0FDSSxXQUFXLEtBQUssSUFEcEI7QUFBQSxjQUVJLGNBQWMsS0FBSyxJQUFMLENBQVUsVUFGNUI7QUFHQSxlQUFLLFNBQUwsQ0FBZSxNQUFmLEVBQXVCLFdBQXZCO0FBQ0Esb0JBQVUsQ0FBVjtBQUNBLGVBQUssR0FBTCxDQUFTLFFBQVQsRUFBbUIsTUFBbkI7QUFDQSxvQkFBVSxXQUFWO0FBQ0EsNkJBQW1CLElBQUksV0FBdkI7QUFDRDs7QUFFRCxZQUFHLENBQUMsUUFBSixFQUFjO0FBQ1o7QUFDQSxjQUFJLE1BQUksWUFBWSxDQUFwQixFQUF1QjtBQUNyQixnQ0FBb0IsYUFBYSxNQUFFLENBQWYsRUFBa0IsR0FBbEIsR0FBd0IsVUFBVSxHQUF0RDtBQUNELFdBRkQsTUFFTztBQUNMLGdCQUFJLFNBQVMsS0FBSyxNQUFsQjtBQUFBLGdCQUNJLG9CQUFvQixVQUFVLEdBQVYsR0FBZ0IsYUFBYSxNQUFJLENBQUosR0FBUSxNQUFFLENBQVYsR0FBYyxHQUEzQixFQUE4QixHQUR0RTtBQUVBLGdCQUFJLE9BQU8sc0JBQVgsRUFBbUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFJLGdCQUFnQixPQUFPLGFBQTNCO0FBQUEsa0JBQ0ksY0FBYyxPQUFPLFdBRHpCO0FBQUEsa0JBRUksZUFBZSxLQUFLLEtBQUwsQ0FBVyxLQUFLLEdBQUwsQ0FBUyxhQUFULEVBQXdCLFdBQXhCLElBQXVDLFlBQWxELENBRm5CO0FBQUEsa0JBR0ksa0JBQWtCLENBQUMsbUJBQW1CLFdBQVcsbUJBQW1CLFlBQWpELEdBQWdFLEtBQUssWUFBdEUsSUFBc0YsVUFBVSxHQUh0SDtBQUlBLGtCQUFJLGtCQUFrQixZQUF0QixFQUFvQztBQUNsQztBQUNBO0FBQ0Esb0NBQW9CLGtCQUFrQixpQkFBdEM7QUFDQSxvQkFBSSxvQkFBb0IsQ0FBeEIsRUFBMkI7QUFDekIsc0NBQW9CLGlCQUFwQjtBQUNEO0FBQ0QsK0JBQU8sR0FBUCwwQkFBa0Msa0JBQWdCLEVBQWxELGdEQUErRixvQkFBa0IsRUFBakg7QUFDRCxlQVJELE1BUU87QUFDTCxvQ0FBb0IsaUJBQXBCO0FBQ0Q7QUFDRixhQXJCRCxNQXFCTztBQUNMLGtDQUFvQixpQkFBcEI7QUFDRDtBQUNGO0FBQ0QsK0JBQXFCLGtCQUFyQjtBQUNBLGtDQUF3QixLQUFLLEtBQUwsQ0FBVyxDQUFDLFVBQVUsR0FBVixHQUFnQixVQUFVLEdBQTNCLElBQWtDLGtCQUE3QyxDQUF4QjtBQUNELFNBbENELE1Ba0NPO0FBQ0wsa0NBQXdCLEtBQUssR0FBTCxDQUFTLENBQVQsRUFBVyxvQkFBa0IsS0FBSyxLQUFMLENBQVcsQ0FBQyxVQUFVLEdBQVYsR0FBZ0IsVUFBVSxHQUEzQixLQUFpQyxxQkFBbUIsaUJBQXBELENBQVgsQ0FBN0IsQ0FBeEI7QUFDRDs7QUFHRDtBQUNBLHNCQUFjLElBQWQsQ0FBbUI7QUFDakIsZ0JBQU0sZUFEVztBQUVoQjtBQUNELG9CQUFVLGlCQUhPO0FBSWpCLGVBQUsscUJBSlk7QUFLakIsaUJBQU87QUFDTCx1QkFBVyxDQUROO0FBRUwsMEJBQWMsQ0FGVDtBQUdMLDJCQUFlLENBSFY7QUFJTCx3QkFBWSxDQUpQO0FBS0wsdUJBQVksVUFBVSxHQUFWLEdBQWdCLENBQWhCLEdBQW9CLENBTDNCO0FBTUwsdUJBQVksVUFBVSxHQUFWLEdBQWdCLENBQWhCLEdBQW9CO0FBTjNCO0FBTFUsU0FBbkI7QUFjRDtBQUNEO0FBQ0EsV0FBSyxVQUFMLEdBQWtCLFVBQVUsb0JBQWtCLGtCQUE5QztBQUNBLFVBQUksVUFBVSxNQUFNLE9BQXBCO0FBQ0EsWUFBTSxHQUFOLEdBQVksQ0FBWjtBQUNBLFlBQU0sTUFBTixHQUFlLENBQWY7QUFDQSxZQUFNLE9BQU4sR0FBZ0IsQ0FBaEI7QUFDQSxVQUFHLGNBQWMsTUFBZCxJQUF3QixVQUFVLFNBQVYsQ0FBb0IsV0FBcEIsR0FBa0MsT0FBbEMsQ0FBMEMsUUFBMUMsSUFBc0QsQ0FBQyxDQUFsRixFQUFxRjtBQUNuRixZQUFJLFFBQVEsY0FBYyxDQUFkLEVBQWlCLEtBQTdCO0FBQ0Y7QUFDQTtBQUNFLGNBQU0sU0FBTixHQUFrQixDQUFsQjtBQUNBLGNBQU0sU0FBTixHQUFrQixDQUFsQjtBQUNEO0FBQ0QsWUFBTSxPQUFOLEdBQWdCLGFBQWhCO0FBQ0EsYUFBTyx1QkFBSSxJQUFKLENBQVMsTUFBTSxjQUFOLEVBQVQsRUFBaUMsV0FBVyxrQkFBNUMsRUFBZ0UsS0FBaEUsQ0FBUDtBQUNBLFlBQU0sT0FBTixHQUFnQixFQUFoQjs7QUFFQSxVQUFJLE9BQU87QUFDVCxZQUFLLEtBQUssRUFERDtBQUVULGVBQVEsS0FBSyxLQUZKO0FBR1QsWUFBSyxLQUFLLEVBSEQ7QUFJVCxlQUFPLElBSkU7QUFLVCxlQUFPLElBTEU7QUFNVCxrQkFBVSxXQUFXLFlBTlo7QUFPVCxnQkFBUSxDQUFDLFVBQVUscUJBQXFCLGlCQUFoQyxJQUFxRCxZQVBwRDtBQVFULGtCQUFVLFdBQVcsWUFSWjtBQVNULGdCQUFRLEtBQUssVUFBTCxHQUFrQixZQVRqQjtBQVVULGNBQU0sT0FWRztBQVdULFlBQUksY0FBYyxNQVhUO0FBWVQsaUJBQVU7QUFaRCxPQUFYO0FBY0EsV0FBSyxRQUFMLENBQWMsT0FBZCxDQUFzQixpQkFBTSxpQkFBNUIsRUFBK0MsSUFBL0M7QUFDQSxhQUFPLElBQVA7QUFDRDs7OytCQUVVLEssRUFBTyxVLEVBQVksVSxFQUFXLGtCLEVBQW9CO0FBQzNELFVBQU0sZUFBZSxLQUFLLGFBQTFCO0FBQUEsVUFDTSxlQUFlLE1BQU0sU0FEM0I7QUFBQSxVQUVNLHFCQUFxQixlQUFhLFlBRnhDO0FBQUEsVUFHTSx5QkFBeUIsTUFBTSxTQUFOLElBQW1CLE1BQU0sS0FBTixHQUFjLElBQWQsR0FBcUIsSUFBeEMsSUFBZ0QsTUFBTSxlQUhyRjtBQUFBLFVBSU0sbUJBQW1CLHlCQUF5QixrQkFKbEQ7QUFBQSxVQUtNLGVBQWUsS0FBSyxhQUwxQjtBQUFBLFVBTU0sVUFBVSxLQUFLLFFBTnJCO0FBQUEsVUFPTSxVQUFVLENBQUMsTUFBTSxLQUFQLElBQWdCLEtBQUssYUFBTCxDQUFtQixJQVBuRDs7QUFTQSxVQUFJLElBQUo7QUFBQSxVQUNJLFNBQVMsVUFBVSxDQUFWLEdBQWMsQ0FEM0I7QUFBQSxVQUVJLFdBRko7QUFBQSxVQUVpQixTQUZqQjtBQUFBLFVBR0ksSUFISjtBQUFBLFVBSUksSUFKSjtBQUFBLFVBSVUsSUFKVjtBQUFBLFVBS0ksUUFMSjtBQUFBLFVBS2MsUUFMZDtBQUFBLFVBS3dCLE9BTHhCO0FBQUEsVUFNSSxHQU5KO0FBQUEsVUFNUyxHQU5UO0FBQUEsVUFNYyxPQU5kO0FBQUEsVUFNdUIsT0FOdkI7QUFBQSxVQU9JLGdCQUFnQixFQVBwQjtBQUFBLFVBUUksZUFBZSxFQVJuQjtBQUFBLFVBU0ksU0FUSjtBQUFBLFVBU2UsUUFUZjtBQUFBLFVBVUksWUFWSjs7QUFZQSxZQUFNLE9BQU4sQ0FBYyxJQUFkLENBQW1CLFVBQVMsQ0FBVCxFQUFZLENBQVosRUFBZTtBQUNoQyxlQUFRLEVBQUUsR0FBRixHQUFNLEVBQUUsR0FBaEI7QUFDRCxPQUZEO0FBR0EscUJBQWUsTUFBTSxPQUFyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFlLEtBQUssWUFBcEI7QUFDQSxvQkFBZSxhQUFhLE1BQWIsSUFBdUIsWUFBdkIsS0FDQyxLQUFLLEdBQUwsQ0FBUyxhQUFXLGVBQWEsWUFBakMsSUFBaUQsR0FBakQsSUFDQSxLQUFLLEdBQUwsQ0FBVSxhQUFhLENBQWIsRUFBZ0IsR0FBaEIsR0FBb0IsWUFBcEIsR0FBaUMsS0FBSyxRQUFoRCxJQUE2RCxLQUFHLGdCQUZqRSxDQUFmOztBQUtBLFVBQUksQ0FBQyxVQUFMLEVBQWlCO0FBQ2Y7QUFDQSx1QkFBZSxhQUFXLFlBQTFCO0FBQ0Q7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBSSxzQkFBc0IsTUFBTSxLQUFoQyxFQUF1QztBQUNyQyxhQUFLLElBQUksSUFBSSxDQUFSLEVBQVcsY0FBYyxZQUE5QixFQUE0QyxJQUFJLGFBQWEsTUFBN0QsR0FBdUU7QUFDckU7QUFDQSxjQUFJLFNBQVMsYUFBYSxDQUFiLENBQWI7QUFBQSxjQUNJLFVBQVUsYUFBYSxPQUFPLEdBQVAsR0FBYSxPQUExQixFQUFtQyxZQUFuQyxDQURkO0FBQUEsY0FFSSxRQUFRLFVBQVUsV0FGdEI7O0FBSUE7QUFDQSxjQUFJLFNBQVMsQ0FBQyxnQkFBZCxFQUFnQztBQUM5QiwyQkFBTyxJQUFQLCtCQUF3QyxLQUFLLEtBQUwsQ0FBVyxjQUFZLEVBQXZCLElBQTJCLElBQW5FLGlCQUFtRixLQUFLLEtBQUwsQ0FBVyxLQUFLLEdBQUwsQ0FBUyxRQUFRLEVBQWpCLENBQVgsQ0FBbkY7QUFDQSx5QkFBYSxNQUFiLENBQW9CLENBQXBCLEVBQXVCLENBQXZCO0FBQ0Esa0JBQU0sR0FBTixJQUFhLE9BQU8sSUFBUCxDQUFZLE1BQXpCO0FBQ0E7QUFDRDtBQUNEO0FBTkEsZUFPSyxJQUFJLFNBQVMsZ0JBQWIsRUFBK0I7QUFDbEMsa0JBQUksVUFBVSxLQUFLLEtBQUwsQ0FBVyxRQUFRLGdCQUFuQixDQUFkO0FBQ0EsNkJBQU8sSUFBUCxnQkFBeUIsT0FBekIsdUJBQWtELEtBQUssS0FBTCxDQUFXLGNBQVksRUFBdkIsSUFBMkIsSUFBN0UsaUJBQTZGLEtBQUssS0FBTCxDQUFXLFFBQVEsRUFBbkIsQ0FBN0Y7QUFDQSxtQkFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLE9BQXBCLEVBQTZCLEdBQTdCLEVBQWtDO0FBQ2hDLDJCQUFXLGNBQWMsT0FBekI7QUFDQSwyQkFBVyxLQUFLLEdBQUwsQ0FBUyxRQUFULEVBQW1CLE9BQW5CLENBQVg7QUFDQSw0QkFBWSxjQUFJLGNBQUosQ0FBbUIsTUFBTSxZQUF6QixDQUFaO0FBQ0Esb0JBQUksQ0FBQyxTQUFMLEVBQWdCO0FBQ2QsaUNBQU8sR0FBUCxDQUFXLG1GQUFYO0FBQ0EsOEJBQVksT0FBTyxJQUFQLENBQVksUUFBWixFQUFaO0FBQ0Q7QUFDRCw2QkFBYSxNQUFiLENBQW9CLENBQXBCLEVBQXVCLENBQXZCLEVBQTBCLEVBQUMsTUFBTSxTQUFQLEVBQWtCLEtBQUssUUFBdkIsRUFBaUMsS0FBSyxRQUF0QyxFQUExQjtBQUNBLHNCQUFNLEdBQU4sSUFBYSxVQUFVLE1BQXZCO0FBQ0EsK0JBQWUsZ0JBQWY7QUFDQSxxQkFBSyxDQUFMO0FBQ0Q7O0FBRUQ7QUFDQSxxQkFBTyxHQUFQLEdBQWEsT0FBTyxHQUFQLEdBQWEsY0FBYyxPQUF4QztBQUNBLDZCQUFlLGdCQUFmO0FBQ0EsbUJBQUssQ0FBTDtBQUNEO0FBQ0Q7QUF0QkssaUJBdUJBO0FBQ0gsb0JBQUksS0FBSyxHQUFMLENBQVMsS0FBVCxJQUFtQixNQUFNLGdCQUE3QixFQUFnRDtBQUM5QztBQUNEO0FBQ0QsK0JBQWUsZ0JBQWY7QUFDQSxvQkFBSSxNQUFNLENBQVYsRUFBYTtBQUNYLHlCQUFPLEdBQVAsR0FBYSxPQUFPLEdBQVAsR0FBYSxVQUFVLFlBQXBDO0FBQ0QsaUJBRkQsTUFFTztBQUNMLHlCQUFPLEdBQVAsR0FBYSxPQUFPLEdBQVAsR0FBYSxhQUFhLElBQUksQ0FBakIsRUFBb0IsR0FBcEIsR0FBMEIsZ0JBQXBEO0FBQ0Q7QUFDRCxxQkFBSyxDQUFMO0FBQ0Q7QUFDRjtBQUNGOztBQUdELFdBQUssSUFBSSxLQUFHLENBQVAsRUFBVyxhQUFZLGFBQWEsTUFBekMsRUFBaUQsS0FBSSxVQUFyRCxFQUFpRSxJQUFqRSxFQUFzRTtBQUNwRSxzQkFBYyxhQUFhLEVBQWIsQ0FBZDtBQUNBLGVBQU8sWUFBWSxJQUFuQjtBQUNBLGNBQU0sWUFBWSxHQUFaLEdBQWtCLE9BQXhCO0FBQ0EsY0FBTSxZQUFZLEdBQVosR0FBa0IsT0FBeEI7QUFDQTtBQUNBO0FBQ0EsWUFBSSxZQUFZLFNBQWhCLEVBQTJCO0FBQ3pCLG9CQUFVLGFBQWEsR0FBYixFQUFrQixPQUFsQixDQUFWO0FBQ0Esb0JBQVUsYUFBYSxHQUFiLEVBQWtCLE9BQWxCLENBQVY7QUFDQSxvQkFBVSxRQUFWLEdBQXFCLEtBQUssS0FBTCxDQUFXLENBQUMsVUFBVSxPQUFYLElBQXNCLGtCQUFqQyxDQUFyQjtBQUNELFNBSkQsTUFJTztBQUNMLG9CQUFVLGFBQWEsR0FBYixFQUFrQixZQUFsQixDQUFWO0FBQ0Esb0JBQVUsYUFBYSxHQUFiLEVBQWtCLFlBQWxCLENBQVY7QUFDQSxjQUFJLFNBQVEsS0FBSyxLQUFMLENBQVcsUUFBUSxVQUFVLFlBQWxCLElBQWtDLFlBQTdDLENBQVo7QUFBQSxjQUNJLG1CQUFtQixDQUR2QjtBQUVBO0FBQ0E7QUFDQSxjQUFJLGNBQWMsTUFBTSxLQUF4QixFQUErQjtBQUM3QjtBQUNBLGdCQUFJLE1BQUosRUFBVztBQUNULGtCQUFJLFNBQVEsQ0FBWixFQUFlO0FBQ2IsbUNBQW1CLEtBQUssS0FBTCxDQUFXLENBQUMsVUFBVSxZQUFYLElBQTJCLGdCQUF0QyxDQUFuQjtBQUNBLCtCQUFPLEdBQVAsQ0FBYyxNQUFkO0FBQ0Esb0JBQUksbUJBQW1CLENBQXZCLEVBQTBCO0FBQ3hCLDhCQUFZLGNBQUksY0FBSixDQUFtQixNQUFNLFlBQXpCLENBQVo7QUFDQSxzQkFBSSxDQUFDLFNBQUwsRUFBZ0I7QUFDZCxnQ0FBWSxLQUFLLFFBQUwsRUFBWjtBQUNEO0FBQ0Qsd0JBQU0sR0FBTixJQUFhLG1CQUFtQixVQUFVLE1BQTFDO0FBQ0Q7QUFDRDtBQUNELGVBWEQsTUFXTyxJQUFJLFNBQVEsQ0FBQyxFQUFiLEVBQWlCO0FBQ3RCO0FBQ0EsK0JBQU8sR0FBUCxDQUFlLENBQUMsTUFBaEI7QUFDQSxzQkFBTSxHQUFOLElBQWEsS0FBSyxVQUFsQjtBQUNBO0FBQ0Q7QUFDRDtBQUNBLHdCQUFVLFVBQVUsWUFBcEI7QUFDRDtBQUNGO0FBQ0Q7QUFDQSxxQkFBVyxLQUFLLEdBQUwsQ0FBUyxDQUFULEVBQVksT0FBWixDQUFYO0FBQ0EscUJBQVcsS0FBSyxHQUFMLENBQVMsQ0FBVCxFQUFZLE9BQVosQ0FBWDtBQUNBLGNBQUcsTUFBTSxHQUFOLEdBQVksQ0FBZixFQUFrQjtBQUNoQjs7O0FBSUEsZ0JBQUksV0FBVyxVQUFVLE1BQU0sR0FBaEIsR0FBc0IsTUFBTSxHQUFOLEdBQVksQ0FBakQ7QUFDQSxnQkFBSTtBQUNGLHFCQUFPLElBQUksVUFBSixDQUFlLFFBQWYsQ0FBUDtBQUNELGFBRkQsQ0FFRSxPQUFNLEdBQU4sRUFBVztBQUNYLG1CQUFLLFFBQUwsQ0FBYyxPQUFkLENBQXNCLGlCQUFNLEtBQTVCLEVBQW1DLEVBQUMsTUFBTyxtQkFBVyxTQUFuQixFQUE4QixPQUFPLEtBQUssS0FBMUMsRUFBaUQsSUFBSyxLQUFLLEVBQTNELEVBQStELFNBQVMscUJBQWEsaUJBQXJGLEVBQXdHLE9BQU8sS0FBL0csRUFBc0gsT0FBUSxRQUE5SCxFQUF3SSx3Q0FBc0MsUUFBOUssRUFBbkM7QUFDQTtBQUNEO0FBQ0QsZ0JBQUksQ0FBQyxPQUFMLEVBQWM7QUFDWixxQkFBTyxJQUFJLFFBQUosQ0FBYSxLQUFLLE1BQWxCLENBQVA7QUFDQSxtQkFBSyxTQUFMLENBQWUsQ0FBZixFQUFrQixRQUFsQjtBQUNBLG1CQUFLLEdBQUwsQ0FBUyx1QkFBSSxLQUFKLENBQVUsSUFBbkIsRUFBeUIsQ0FBekI7QUFDRDtBQUNGLFdBakJELE1BaUJPO0FBQ0w7QUFDQTtBQUNEO0FBQ0QsZUFBSyxJQUFJLE1BQUksQ0FBYixFQUFnQixNQUFJLGdCQUFwQixFQUFzQyxLQUF0QyxFQUEyQztBQUN6Qyx1QkFBVyxVQUFVLENBQUMsbUJBQW1CLEdBQXBCLElBQXlCLGdCQUE5QztBQUNBLHdCQUFZLGNBQUksY0FBSixDQUFtQixNQUFNLFlBQXpCLENBQVo7QUFDQSxnQkFBSSxDQUFDLFNBQUwsRUFBZ0I7QUFDZCw2QkFBTyxHQUFQLENBQVcsbUZBQVg7QUFDQSwwQkFBWSxLQUFLLFFBQUwsRUFBWjtBQUNEO0FBQ0QsaUJBQUssR0FBTCxDQUFTLFNBQVQsRUFBb0IsTUFBcEI7QUFDQSxzQkFBVSxVQUFVLFVBQXBCO0FBQ0Esd0JBQVk7QUFDVixvQkFBTSxVQUFVLFVBRE47QUFFVixtQkFBSyxDQUZLO0FBR1Ysd0JBQVUsSUFIQTtBQUlWLHFCQUFPO0FBQ0wsMkJBQVcsQ0FETjtBQUVMLDhCQUFjLENBRlQ7QUFHTCwrQkFBZSxDQUhWO0FBSUwsNEJBQVksQ0FKUDtBQUtMLDJCQUFXO0FBTE47QUFKRyxhQUFaO0FBWUEsMEJBQWMsSUFBZCxDQUFtQixTQUFuQjtBQUNEO0FBQ0Y7QUFDRCxhQUFLLEdBQUwsQ0FBUyxJQUFULEVBQWUsTUFBZjtBQUNBLFlBQUksVUFBVSxLQUFLLFVBQW5CO0FBQ0Esa0JBQVUsT0FBVjtBQUNBO0FBQ0Esb0JBQVk7QUFDVixnQkFBTSxPQURJO0FBRVYsZUFBSyxDQUZLO0FBR1Ysb0JBQVUsQ0FIQTtBQUlWLGlCQUFPO0FBQ0wsdUJBQVcsQ0FETjtBQUVMLDBCQUFjLENBRlQ7QUFHTCwyQkFBZSxDQUhWO0FBSUwsd0JBQVksQ0FKUDtBQUtMLHVCQUFXO0FBTE47QUFKRyxTQUFaO0FBWUEsc0JBQWMsSUFBZCxDQUFtQixTQUFuQjtBQUNBLGtCQUFVLE9BQVY7QUFDRDtBQUNELFVBQUkscUJBQXFCLENBQXpCO0FBQ0EsVUFBSSxZQUFZLGNBQWMsTUFBOUI7QUFDQTtBQUNBLFVBQUksYUFBYSxDQUFqQixFQUFvQjtBQUNsQiw2QkFBcUIsY0FBYyxZQUFZLENBQTFCLEVBQTZCLFFBQWxEO0FBQ0Esa0JBQVUsUUFBVixHQUFxQixrQkFBckI7QUFDRDtBQUNELFVBQUksU0FBSixFQUFlO0FBQ2I7QUFDQSxhQUFLLFlBQUwsR0FBb0IsVUFBVSxxQkFBcUIsa0JBQW5EO0FBQ0E7QUFDQSxjQUFNLEdBQU4sR0FBWSxDQUFaO0FBQ0EsY0FBTSxPQUFOLEdBQWdCLGFBQWhCO0FBQ0EsWUFBSSxPQUFKLEVBQWE7QUFDWCxpQkFBTyxJQUFJLFVBQUosRUFBUDtBQUNELFNBRkQsTUFFTztBQUNMLGlCQUFPLHVCQUFJLElBQUosQ0FBUyxNQUFNLGNBQU4sRUFBVCxFQUFpQyxXQUFXLGtCQUE1QyxFQUFnRSxLQUFoRSxDQUFQO0FBQ0Q7QUFDRCxjQUFNLE9BQU4sR0FBZ0IsRUFBaEI7QUFDQSxZQUFJLFlBQVk7QUFDZCxjQUFLLEtBQUssRUFESTtBQUVkLGlCQUFRLEtBQUssS0FGQztBQUdkLGNBQUssS0FBSyxFQUhJO0FBSWQsaUJBQU8sSUFKTztBQUtkLGlCQUFPLElBTE87QUFNZCxvQkFBVSxXQUFXLFlBTlA7QUFPZCxrQkFBUSxLQUFLLFlBQUwsR0FBb0IsWUFQZDtBQVFkLG9CQUFVLFdBQVcsWUFSUDtBQVNkLGtCQUFRLENBQUMsVUFBVSxxQkFBcUIsa0JBQWhDLElBQXNELFlBVGhEO0FBVWQsZ0JBQU0sT0FWUTtBQVdkLGNBQUk7QUFYVSxTQUFoQjtBQWFBLGFBQUssUUFBTCxDQUFjLE9BQWQsQ0FBc0IsaUJBQU0saUJBQTVCLEVBQStDLFNBQS9DO0FBQ0EsZUFBTyxTQUFQO0FBQ0Q7QUFDRCxhQUFPLElBQVA7QUFDRDs7O29DQUVlLEssRUFBTyxVLEVBQVksVSxFQUFZLFMsRUFBVztBQUN4RCxVQUFJLGVBQWUsS0FBSyxhQUF4QjtBQUFBLFVBQ0ksZUFBZSxNQUFNLFNBQU4sR0FBa0IsTUFBTSxTQUF4QixHQUFvQyxNQUFNLGVBRDdEO0FBQUEsVUFFSSxxQkFBcUIsZUFBYSxZQUZ0QztBQUFBLFVBR0ksZUFBZSxLQUFLLFlBSHhCOzs7QUFLSTtBQUNBLGlCQUFXLENBQUMsaUJBQWlCLFNBQWpCLEdBQTZCLFlBQTdCLEdBQTRDLFVBQVUsUUFBVixHQUFxQixZQUFsRSxJQUFrRixLQUFLLFFBTnRHO0FBQUEsVUFPSSxTQUFTLFVBQVUsTUFBVixHQUFtQixZQUFuQixHQUFrQyxLQUFLLFFBUHBEOztBQVFJO0FBQ0EsdUJBQWlCLElBVHJCO0FBQUEsVUFVSSxnQkFBZ0IscUJBQXFCLGNBVnpDOzs7QUFZSTtBQUNBLGtCQUFZLEtBQUssSUFBTCxDQUFVLENBQUMsU0FBUyxRQUFWLElBQXNCLGFBQWhDLENBYmhCOzs7QUFlSTtBQUNBLG9CQUFjLGNBQUksY0FBSixDQUFtQixNQUFNLFlBQXpCLENBaEJsQjs7QUFrQkkscUJBQU8sSUFBUCxDQUFZLG1CQUFaO0FBQ0o7QUFDQSxVQUFJLENBQUMsV0FBTCxFQUFrQjtBQUNoQix1QkFBTyxLQUFQLENBQWEsNkZBQWI7QUFDQTtBQUNEOztBQUVELFVBQUksVUFBVSxFQUFkO0FBQ0EsV0FBSSxJQUFJLElBQUksQ0FBWixFQUFlLElBQUksU0FBbkIsRUFBOEIsR0FBOUIsRUFBbUM7QUFDakMsWUFBSSxRQUFRLFdBQVcsSUFBSSxhQUEzQjtBQUNBLGdCQUFRLElBQVIsQ0FBYSxFQUFDLE1BQU0sV0FBUCxFQUFvQixLQUFLLEtBQXpCLEVBQWdDLEtBQUssS0FBckMsRUFBYjtBQUNBLGNBQU0sR0FBTixJQUFhLFlBQVksTUFBekI7QUFDRDtBQUNELFlBQU0sT0FBTixHQUFnQixPQUFoQjs7QUFFQSxXQUFLLFVBQUwsQ0FBZ0IsS0FBaEIsRUFBdUIsVUFBdkIsRUFBbUMsVUFBbkM7QUFDRDs7OzZCQUVRLEssRUFBTSxVLEVBQVk7QUFDekIsVUFBSSxTQUFTLE1BQU0sT0FBTixDQUFjLE1BQTNCO0FBQUEsVUFBbUMsTUFBbkM7QUFDQTtBQUNBLFVBQUcsTUFBSCxFQUFXO0FBQ1QsYUFBSSxJQUFJLFFBQVEsQ0FBaEIsRUFBbUIsUUFBUSxNQUEzQixFQUFtQyxPQUFuQyxFQUE0QztBQUMxQyxtQkFBUyxNQUFNLE9BQU4sQ0FBYyxLQUFkLENBQVQ7QUFDQTtBQUNBO0FBQ0EsaUJBQU8sR0FBUCxHQUFjLENBQUMsT0FBTyxHQUFQLEdBQWEsS0FBSyxRQUFuQixJQUErQixLQUFLLGFBQWxEO0FBQ0EsaUJBQU8sR0FBUCxHQUFjLENBQUMsT0FBTyxHQUFQLEdBQWEsS0FBSyxRQUFuQixJQUErQixLQUFLLGFBQWxEO0FBQ0Q7QUFDRCxhQUFLLFFBQUwsQ0FBYyxPQUFkLENBQXNCLGlCQUFNLHFCQUE1QixFQUFtRDtBQUNqRCxjQUFLLEtBQUssRUFEdUM7QUFFakQsaUJBQVEsS0FBSyxLQUZvQztBQUdqRCxjQUFLLEtBQUssRUFIdUM7QUFJakQsbUJBQVEsTUFBTTtBQUptQyxTQUFuRDtBQU1EOztBQUVELFlBQU0sT0FBTixHQUFnQixFQUFoQjtBQUNBLG1CQUFhLFVBQWI7QUFDRDs7OzhCQUVTLEssRUFBTSxVLEVBQVk7QUFDMUIsWUFBTSxPQUFOLENBQWMsSUFBZCxDQUFtQixVQUFTLENBQVQsRUFBWSxDQUFaLEVBQWU7QUFDaEMsZUFBUSxFQUFFLEdBQUYsR0FBTSxFQUFFLEdBQWhCO0FBQ0QsT0FGRDs7QUFJQSxVQUFJLFNBQVMsTUFBTSxPQUFOLENBQWMsTUFBM0I7QUFBQSxVQUFtQyxNQUFuQztBQUNBO0FBQ0EsVUFBRyxNQUFILEVBQVc7QUFDVCxhQUFJLElBQUksUUFBUSxDQUFoQixFQUFtQixRQUFRLE1BQTNCLEVBQW1DLE9BQW5DLEVBQTRDO0FBQzFDLG1CQUFTLE1BQU0sT0FBTixDQUFjLEtBQWQsQ0FBVDtBQUNBO0FBQ0E7QUFDQSxpQkFBTyxHQUFQLEdBQWMsQ0FBQyxPQUFPLEdBQVAsR0FBYSxLQUFLLFFBQW5CLElBQStCLEtBQUssYUFBbEQ7QUFDRDtBQUNELGFBQUssUUFBTCxDQUFjLE9BQWQsQ0FBc0IsaUJBQU0scUJBQTVCLEVBQW1EO0FBQ2pELGNBQUssS0FBSyxFQUR1QztBQUVqRCxpQkFBUSxLQUFLLEtBRm9DO0FBR2pELGNBQUssS0FBSyxFQUh1QztBQUlqRCxtQkFBUSxNQUFNO0FBSm1DLFNBQW5EO0FBTUQ7O0FBRUQsWUFBTSxPQUFOLEdBQWdCLEVBQWhCO0FBQ0EsbUJBQWEsVUFBYjtBQUNEOzs7a0NBRWEsSyxFQUFPLFMsRUFBVztBQUM5QixVQUFJLE1BQUo7QUFDQSxVQUFJLGNBQWMsU0FBbEIsRUFBNkI7QUFDM0IsZUFBTyxLQUFQO0FBQ0Q7QUFDRCxVQUFJLFlBQVksS0FBaEIsRUFBdUI7QUFDckI7QUFDQSxpQkFBUyxDQUFDLFVBQVY7QUFDRCxPQUhELE1BR087QUFDTDtBQUNBLGlCQUFTLFVBQVQ7QUFDRDtBQUNEOzs7QUFHQSxhQUFPLEtBQUssR0FBTCxDQUFTLFFBQVEsU0FBakIsSUFBOEIsVUFBckMsRUFBaUQ7QUFDN0MsaUJBQVMsTUFBVDtBQUNIO0FBQ0QsYUFBTyxLQUFQO0FBQ0Q7Ozt3QkF0dUJpQjtBQUNoQixhQUFPLEtBQVA7QUFDRDs7Ozs7O2tCQXd1QlksVTs7Ozs7Ozs7O3FqQkNqd0JmOzs7OztBQUdBOzs7Ozs7OztJQUVNLGtCO0FBQ0osOEJBQVksUUFBWixFQUFxQixFQUFyQixFQUF5QjtBQUFBOztBQUN2QixTQUFLLFFBQUwsR0FBZ0IsUUFBaEI7QUFDQSxTQUFLLEVBQUwsR0FBVSxFQUFWO0FBQ0EsU0FBSyxXQUFMLEdBQW1CLEtBQW5CO0FBQ0Q7Ozs7OEJBTVMsQ0FDVDs7OzBDQUVxQixDQUNyQjs7O2tDQUVhO0FBQ1osV0FBSyxXQUFMLEdBQW1CLEtBQW5CO0FBQ0Q7OzswQkFFSyxVLEVBQVcsVSxFQUFXLFEsRUFBUyxTLEVBQVUsVSxFQUFXLE8sRUFBUztBQUNqRSxVQUFJLFdBQVcsS0FBSyxRQUFwQjtBQUNBO0FBQ0EsVUFBSSxDQUFDLEtBQUssV0FBVixFQUF1QjtBQUNyQixZQUFJLFNBQVMsRUFBYjtBQUFBLFlBQ0ksT0FBTyxFQUFFLElBQUssS0FBSyxFQUFaLEVBQWdCLFFBQVMsTUFBekIsRUFBaUMsUUFBUyxJQUExQyxFQURYO0FBQUEsWUFFSSxRQUFRLFVBRlo7QUFBQSxZQUdJLFFBQVEsTUFBTSxLQUhsQjs7QUFLQSxZQUFJLEtBQUosRUFBVztBQUNULGVBQUssTUFBTCxDQUFZLEtBQVosR0FBb0I7QUFDbEIsdUJBQVksTUFBTSxTQURBO0FBRWxCLG1CQUFTLEtBRlM7QUFHbEIsc0JBQVc7QUFDVCxxQkFBUSxNQUFNLEtBREw7QUFFVCxzQkFBUyxNQUFNO0FBRk47QUFITyxXQUFwQjtBQVFEOztBQUVELGdCQUFRLFVBQVI7QUFDQSxnQkFBUSxNQUFNLEtBQWQ7QUFDQSxZQUFJLEtBQUosRUFBVztBQUNULGVBQUssTUFBTCxDQUFZLEtBQVosR0FBb0I7QUFDbEIsdUJBQVksTUFBTSxTQURBO0FBRWxCLG1CQUFTLEtBRlM7QUFHbEIsc0JBQVc7QUFDVCw0QkFBZSxNQUFNO0FBRFo7QUFITyxXQUFwQjtBQU9EO0FBQ0QsYUFBSyxXQUFMLEdBQW1CLElBQW5CO0FBQ0EsaUJBQVMsT0FBVCxDQUFpQixpQkFBTSx5QkFBdkIsRUFBaUQsSUFBakQ7QUFDRDtBQUNELGVBQVMsT0FBVCxDQUFpQixpQkFBTSxpQkFBdkIsRUFBMEM7QUFDeEMsWUFBSyxLQUFLLEVBRDhCO0FBRXhDLGVBQU8sT0FGaUM7QUFHeEMsa0JBQVUsVUFIOEI7QUFJeEMsa0JBQVUsVUFKOEI7QUFLeEMsY0FBTSxZQUxrQztBQU14QyxZQUFJLENBTm9DO0FBT3hDLGlCQUFVO0FBUDhCLE9BQTFDO0FBU0Q7Ozt3QkF6RGlCO0FBQ2hCLGFBQU8sSUFBUDtBQUNEOzs7Ozs7a0JBMERZLGtCOzs7Ozs7Ozs7Ozs7O0FDeEVmLElBQU0sMkJBQTJCLGVBQWpDO0FBQ0EsSUFBTSxrQkFBa0IsdUNBQXhCOztBQUVBOztJQUNNLFE7QUFFSixvQkFBWSxLQUFaLEVBQW1CO0FBQUE7O0FBQ2pCLFFBQUksT0FBTyxLQUFQLEtBQWlCLFFBQXJCLEVBQStCO0FBQzdCLGNBQVEsU0FBUyxhQUFULENBQXVCLEtBQXZCLENBQVI7QUFDRDtBQUNELFNBQUksSUFBSSxJQUFSLElBQWdCLEtBQWhCLEVBQXNCO0FBQ3BCLFVBQUcsTUFBTSxjQUFOLENBQXFCLElBQXJCLENBQUgsRUFBK0I7QUFDN0IsYUFBSyxJQUFMLElBQWEsTUFBTSxJQUFOLENBQWI7QUFDRDtBQUNGO0FBQ0Y7Ozs7bUNBRWMsUSxFQUFVO0FBQ3ZCLFVBQU0sV0FBVyxTQUFTLEtBQUssUUFBTCxDQUFULEVBQXlCLEVBQXpCLENBQWpCO0FBQ0EsVUFBSSxXQUFXLE9BQU8sZ0JBQXRCLEVBQXdDO0FBQ3RDLGVBQU8sUUFBUDtBQUNEO0FBQ0QsYUFBTyxRQUFQO0FBQ0Q7Ozt1Q0FFa0IsUSxFQUFVO0FBQzNCLFVBQUcsS0FBSyxRQUFMLENBQUgsRUFBbUI7QUFDakIsWUFBSSxjQUFjLENBQUMsS0FBSyxRQUFMLEtBQWtCLElBQW5CLEVBQXlCLEtBQXpCLENBQStCLENBQS9CLENBQWxCO0FBQ0Esc0JBQWMsQ0FBRSxZQUFZLE1BQVosR0FBcUIsQ0FBdEIsR0FBMkIsR0FBM0IsR0FBaUMsRUFBbEMsSUFBd0MsV0FBdEQ7O0FBRUEsWUFBTSxRQUFRLElBQUksVUFBSixDQUFlLFlBQVksTUFBWixHQUFxQixDQUFwQyxDQUFkO0FBQ0EsYUFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLFlBQVksTUFBWixHQUFxQixDQUF6QyxFQUE0QyxHQUE1QyxFQUFpRDtBQUMvQyxnQkFBTSxDQUFOLElBQVcsU0FBUyxZQUFZLEtBQVosQ0FBa0IsSUFBSSxDQUF0QixFQUF5QixJQUFJLENBQUosR0FBUSxDQUFqQyxDQUFULEVBQThDLEVBQTlDLENBQVg7QUFDRDtBQUNELGVBQU8sS0FBUDtBQUNELE9BVEQsTUFTTztBQUNMLGVBQU8sSUFBUDtBQUNEO0FBQ0Y7OzsrQ0FFMEIsUSxFQUFVO0FBQ25DLFVBQU0sV0FBVyxTQUFTLEtBQUssUUFBTCxDQUFULEVBQXlCLEVBQXpCLENBQWpCO0FBQ0EsVUFBSSxXQUFXLE9BQU8sZ0JBQXRCLEVBQXdDO0FBQ3RDLGVBQU8sUUFBUDtBQUNEO0FBQ0QsYUFBTyxRQUFQO0FBQ0Q7Ozt5Q0FFb0IsUSxFQUFVO0FBQzdCLGFBQU8sV0FBVyxLQUFLLFFBQUwsQ0FBWCxDQUFQO0FBQ0Q7OztxQ0FFZ0IsUSxFQUFVO0FBQ3pCLGFBQU8sS0FBSyxRQUFMLENBQVA7QUFDRDs7O3NDQUVpQixRLEVBQVU7QUFDMUIsVUFBTSxNQUFNLHlCQUF5QixJQUF6QixDQUE4QixLQUFLLFFBQUwsQ0FBOUIsQ0FBWjtBQUNBLFVBQUksUUFBUSxJQUFaLEVBQWtCO0FBQ2hCLGVBQU8sU0FBUDtBQUNEO0FBQ0QsYUFBTztBQUNMLGVBQU8sU0FBUyxJQUFJLENBQUosQ0FBVCxFQUFpQixFQUFqQixDQURGO0FBRUwsZ0JBQVEsU0FBUyxJQUFJLENBQUosQ0FBVCxFQUFpQixFQUFqQjtBQUZILE9BQVA7QUFJRDs7O2tDQUVvQixLLEVBQU87QUFDMUIsVUFBSSxLQUFKO0FBQUEsVUFBVyxRQUFRLEVBQW5CO0FBQ0Esc0JBQWdCLFNBQWhCLEdBQTRCLENBQTVCO0FBQ0EsYUFBTyxDQUFDLFFBQVEsZ0JBQWdCLElBQWhCLENBQXFCLEtBQXJCLENBQVQsTUFBMEMsSUFBakQsRUFBdUQ7QUFDckQsWUFBSSxRQUFRLE1BQU0sQ0FBTixDQUFaO0FBQUEsWUFBc0IsUUFBUSxHQUE5Qjs7QUFFQSxZQUFJLE1BQU0sT0FBTixDQUFjLEtBQWQsTUFBeUIsQ0FBekIsSUFDQSxNQUFNLFdBQU4sQ0FBa0IsS0FBbEIsTUFBOEIsTUFBTSxNQUFOLEdBQWEsQ0FEL0MsRUFDbUQ7QUFDakQsa0JBQVEsTUFBTSxLQUFOLENBQVksQ0FBWixFQUFlLENBQUMsQ0FBaEIsQ0FBUjtBQUNEO0FBQ0QsY0FBTSxNQUFNLENBQU4sQ0FBTixJQUFrQixLQUFsQjtBQUNEO0FBQ0QsYUFBTyxLQUFQO0FBQ0Q7Ozs7OztrQkFJWSxROzs7OztBQ3BGZixJQUFJLGVBQWU7QUFDZjs7Ozs7Ozs7Ozs7Ozs7O0FBZUEsWUFBUSxnQkFBUyxJQUFULEVBQWUsa0JBQWYsRUFBbUM7QUFDdkMsWUFBSSxXQUFXLENBQWY7QUFDQSxZQUFJLFdBQVcsS0FBSyxNQUFMLEdBQWMsQ0FBN0I7QUFDQSxZQUFJLGVBQWUsSUFBbkI7QUFDQSxZQUFJLGlCQUFpQixJQUFyQjs7QUFFQSxlQUFPLFlBQVksUUFBbkIsRUFBNkI7QUFDekIsMkJBQWUsQ0FBQyxXQUFXLFFBQVosSUFBd0IsQ0FBeEIsR0FBNEIsQ0FBM0M7QUFDQSw2QkFBaUIsS0FBSyxZQUFMLENBQWpCOztBQUVBLGdCQUFJLG1CQUFtQixtQkFBbUIsY0FBbkIsQ0FBdkI7QUFDQSxnQkFBSSxtQkFBbUIsQ0FBdkIsRUFBMEI7QUFDdEIsMkJBQVcsZUFBZSxDQUExQjtBQUNILGFBRkQsTUFHSyxJQUFJLG1CQUFtQixDQUF2QixFQUEwQjtBQUMzQiwyQkFBVyxlQUFlLENBQTFCO0FBQ0gsYUFGSSxNQUdBO0FBQ0QsdUJBQU8sY0FBUDtBQUNIO0FBQ0o7O0FBRUQsZUFBTyxJQUFQO0FBQ0g7QUF2Q2MsQ0FBbkI7O0FBMENBLE9BQU8sT0FBUCxHQUFpQixZQUFqQjs7Ozs7Ozs7Ozs7OztBQzFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXFDSTs7OztBQUlKLElBQUksMEJBQTBCO0FBQzFCLFVBQU8sSUFEbUIsRUFDYjtBQUNiLFVBQU8sSUFGbUIsRUFFYjtBQUNiLFVBQU8sSUFIbUIsRUFHYjtBQUNiLFVBQU8sSUFKbUIsRUFJYjtBQUNiLFVBQU8sSUFMbUIsRUFLYjtBQUNiLFVBQU8sSUFObUIsRUFNYjtBQUNiLFVBQU8sSUFQbUIsRUFPYjtBQUNiLFVBQU8sSUFSbUIsRUFRYjtBQUNiLFVBQU8sSUFUbUIsRUFTYjtBQUNiLFVBQU8sTUFWbUIsRUFVWDtBQUNmO0FBQ0E7QUFDQTtBQUNBLFVBQU8sSUFkbUIsRUFjYjtBQUNiLFVBQU8sSUFmbUIsRUFlYjtBQUNiLFVBQU8sSUFoQm1CLEVBZ0JiO0FBQ2IsVUFBTyxJQWpCbUIsRUFpQmI7QUFDYixVQUFPLE1BbEJtQixFQWtCWDtBQUNmLFVBQU8sSUFuQm1CLEVBbUJiO0FBQ2IsVUFBTyxJQXBCbUIsRUFvQmI7QUFDYixVQUFPLE1BckJtQixFQXFCWDtBQUNmLFVBQU8sSUF0Qm1CLEVBc0JiO0FBQ2IsVUFBTyxJQXZCbUIsRUF1QmI7QUFDYixVQUFPLElBeEJtQixFQXdCYjtBQUNiLFVBQU8sSUF6Qm1CLEVBeUJiO0FBQ2IsVUFBTyxJQTFCbUIsRUEwQmI7QUFDYixVQUFPLElBM0JtQixFQTJCYjtBQUNiLFVBQU8sSUE1Qm1CLEVBNEJiO0FBQ2IsVUFBTyxJQTdCbUIsRUE2QmI7QUFDYjtBQUNBO0FBQ0EsVUFBTyxJQWhDbUIsRUFnQ2I7QUFDYixVQUFPLElBakNtQixFQWlDYjtBQUNiLFVBQU8sSUFsQ21CLEVBa0NiO0FBQ2IsVUFBTyxJQW5DbUIsRUFtQ2I7QUFDYixVQUFPLElBcENtQixFQW9DYjtBQUNiLFVBQU8sSUFyQ21CLEVBcUNiO0FBQ2IsVUFBTyxNQXRDbUIsRUFzQ1g7QUFDZixVQUFPLElBdkNtQixFQXVDYjtBQUNiLFVBQU8sSUF4Q21CLEVBd0NiO0FBQ2IsVUFBTyxNQXpDbUIsRUF5Q1g7QUFDZixVQUFPLE1BMUNtQixFQTBDWDtBQUNmLFVBQU8sSUEzQ21CLEVBMkNiO0FBQ2IsVUFBTyxNQTVDbUIsRUE0Q1g7QUFDZixVQUFPLE1BN0NtQixFQTZDWDtBQUNmLFVBQU8sTUE5Q21CLEVBOENYO0FBQ2YsVUFBTyxNQS9DbUIsRUErQ1g7QUFDZixVQUFPLElBaERtQixFQWdEYjtBQUNiLFVBQU8sSUFqRG1CLEVBaURiO0FBQ2IsVUFBTyxJQWxEbUIsRUFrRGI7QUFDYixVQUFPLElBbkRtQixFQW1EYjtBQUNiLFVBQU8sSUFwRG1CLEVBb0RiO0FBQ2IsVUFBTyxJQXJEbUIsRUFxRGI7QUFDYixVQUFPLElBdERtQixFQXNEYjtBQUNiLFVBQU8sSUF2RG1CLEVBdURiO0FBQ2IsVUFBTyxJQXhEbUIsRUF3RGI7QUFDYixVQUFPLElBekRtQixFQXlEYjtBQUNiLFVBQU8sSUExRG1CLEVBMERiO0FBQ2IsVUFBTyxJQTNEbUIsRUEyRGI7QUFDYixVQUFPLElBNURtQixFQTREYjtBQUNiLFVBQU8sSUE3RG1CLEVBNkRiO0FBQ2IsVUFBTyxJQTlEbUIsRUE4RGI7QUFDYixVQUFPLElBL0RtQixFQStEYjtBQUNiO0FBQ0E7QUFDQSxVQUFPLElBbEVtQixFQWtFYjtBQUNiLFVBQU8sSUFuRW1CLEVBbUViO0FBQ2IsVUFBTyxJQXBFbUIsRUFvRWI7QUFDYixVQUFPLElBckVtQixFQXFFYjtBQUNiLFVBQU8sSUF0RW1CLEVBc0ViO0FBQ2IsVUFBTyxJQXZFbUIsRUF1RWI7QUFDYixVQUFPLElBeEVtQixFQXdFYjtBQUNiLFVBQU8sSUF6RW1CLEVBeUViO0FBQ2IsVUFBTyxJQTFFbUIsRUEwRWI7QUFDYixVQUFPLElBM0VtQixFQTJFYjtBQUNiLFVBQU8sSUE1RW1CLEVBNEViO0FBQ2IsVUFBTyxJQTdFbUIsRUE2RWI7QUFDYixVQUFPLElBOUVtQixFQThFYjtBQUNiLFVBQU8sSUEvRW1CLEVBK0ViO0FBQ2IsVUFBTyxJQWhGbUIsRUFnRmI7QUFDYixVQUFPLE1BakZtQixFQWlGWDtBQUNmLFVBQU8sSUFsRm1CLEVBa0ZiO0FBQ2IsVUFBTyxJQW5GbUIsRUFtRmI7QUFDYixVQUFPLElBcEZtQixFQW9GYjtBQUNiLFVBQU8sSUFyRm1CLEVBcUZiO0FBQ2IsVUFBTyxJQXRGbUIsRUFzRmI7QUFDYixVQUFPLElBdkZtQixFQXVGYjtBQUNiLFVBQU8sSUF4Rm1CLEVBd0ZiO0FBQ2IsVUFBTyxNQXpGbUIsRUF5Rlg7QUFDZixVQUFPLElBMUZtQixFQTBGYjtBQUNiLFVBQU8sSUEzRm1CLEVBMkZiO0FBQ2IsVUFBTyxJQTVGbUIsRUE0RmI7QUFDYixVQUFPLElBN0ZtQixFQTZGYjtBQUNiLFVBQU8sTUE5Rm1CLEVBOEZYO0FBQ2YsVUFBTyxNQS9GbUIsRUErRlg7QUFDZixVQUFPLE1BaEdtQixFQWdHWDtBQUNmLFVBQU8sTUFqR21CLENBaUdaO0FBakdZLENBQTlCOztBQW9HQTs7O0FBR0EsSUFBSSxpQkFBaUIsU0FBakIsY0FBaUIsQ0FBUyxJQUFULEVBQWU7QUFDaEMsUUFBSSxXQUFXLElBQWY7QUFDQSxRQUFJLHdCQUF3QixjQUF4QixDQUF1QyxJQUF2QyxDQUFKLEVBQWtEO0FBQzlDLG1CQUFXLHdCQUF3QixJQUF4QixDQUFYO0FBQ0g7QUFDRCxXQUFPLE9BQU8sWUFBUCxDQUFvQixRQUFwQixDQUFQO0FBQ0gsQ0FORDs7QUFRQSxJQUFJLFVBQVUsRUFBZDtBQUFBLElBQ0ksVUFBVSxHQURkO0FBRUE7QUFDQSxJQUFJLGFBQWEsRUFBQyxNQUFPLENBQVIsRUFBVyxNQUFPLENBQWxCLEVBQXFCLE1BQU8sQ0FBNUIsRUFBK0IsTUFBTyxDQUF0QyxFQUF5QyxNQUFPLENBQWhELEVBQW1ELE1BQU8sRUFBMUQsRUFBOEQsTUFBTyxFQUFyRSxFQUF5RSxNQUFPLEVBQWhGLEVBQWpCO0FBQ0EsSUFBSSxjQUFjLEVBQUMsTUFBTyxDQUFSLEVBQVcsTUFBTyxDQUFsQixFQUFxQixNQUFPLENBQTVCLEVBQStCLE1BQU8sQ0FBdEMsRUFBeUMsTUFBTyxFQUFoRCxFQUFvRCxNQUFPLEVBQTNELEVBQStELE1BQU8sRUFBdEUsRUFBbEI7QUFDQSxJQUFJLGFBQWEsRUFBQyxNQUFPLENBQVIsRUFBVyxNQUFPLENBQWxCLEVBQXFCLE1BQU8sQ0FBNUIsRUFBK0IsTUFBTyxDQUF0QyxFQUF5QyxNQUFPLENBQWhELEVBQW1ELE1BQU8sRUFBMUQsRUFBOEQsTUFBTyxFQUFyRSxFQUF5RSxNQUFPLEVBQWhGLEVBQWpCO0FBQ0EsSUFBSSxjQUFjLEVBQUMsTUFBTyxDQUFSLEVBQVcsTUFBTyxDQUFsQixFQUFxQixNQUFPLENBQTVCLEVBQStCLE1BQU8sQ0FBdEMsRUFBeUMsTUFBTyxFQUFoRCxFQUFvRCxNQUFPLEVBQTNELEVBQStELE1BQU8sRUFBdEUsRUFBbEI7O0FBRUEsSUFBSSxtQkFBbUIsQ0FBQyxPQUFELEVBQVUsT0FBVixFQUFtQixNQUFuQixFQUEyQixNQUEzQixFQUFtQyxLQUFuQyxFQUEwQyxRQUExQyxFQUFvRCxTQUFwRCxFQUErRCxPQUEvRCxFQUF3RSxhQUF4RSxDQUF2Qjs7QUFFQTs7O0FBR0EsSUFBSSxTQUFTO0FBQ1QsbUJBQWdCLEVBQUMsUUFBUyxDQUFWLEVBQWEsU0FBVSxDQUF2QixFQUEwQixRQUFTLENBQW5DLEVBQXNDLFdBQVksQ0FBbEQsRUFBcUQsUUFBUyxDQUE5RCxFQUFpRSxTQUFVLENBQTNFLEVBRFA7QUFFVCxVQUFPLElBRkU7QUFHVCxrQkFBZSxDQUhOLEVBR1M7QUFDbEIsYUFBVSxpQkFBUyxPQUFULEVBQWtCO0FBQ3hCLGFBQUssSUFBTCxHQUFZLE9BQVo7QUFDSCxLQU5RO0FBT1QsU0FBTSxhQUFTLFFBQVQsRUFBbUIsR0FBbkIsRUFBd0I7QUFDMUIsWUFBSSxXQUFXLEtBQUssYUFBTCxDQUFtQixRQUFuQixDQUFmO0FBQ0EsWUFBSSxLQUFLLFlBQUwsSUFBcUIsUUFBekIsRUFBbUM7QUFDL0Isb0JBQVEsR0FBUixDQUFZLEtBQUssSUFBTCxDQUFVLE9BQVYsQ0FBa0IsQ0FBbEIsSUFBdUIsSUFBdkIsR0FBOEIsUUFBOUIsR0FBeUMsSUFBekMsR0FBZ0QsR0FBNUQ7QUFDSDtBQUNKO0FBWlEsQ0FBYjs7QUFlQSxJQUFJLHFCQUFxQixTQUFyQixrQkFBcUIsQ0FBUyxRQUFULEVBQW1CO0FBQ3hDLFFBQUksV0FBVyxFQUFmO0FBQ0EsU0FBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLFNBQVMsTUFBN0IsRUFBcUMsR0FBckMsRUFBMEM7QUFDdEMsaUJBQVMsSUFBVCxDQUFjLFNBQVMsQ0FBVCxFQUFZLFFBQVosQ0FBcUIsRUFBckIsQ0FBZDtBQUNIO0FBQ0QsV0FBTyxRQUFQO0FBQ0gsQ0FORDs7SUFRTSxRO0FBRUYsc0JBQVksVUFBWixFQUF3QixTQUF4QixFQUFtQyxPQUFuQyxFQUE0QyxVQUE1QyxFQUF3RCxLQUF4RCxFQUErRDtBQUFBOztBQUMzRCxhQUFLLFVBQUwsR0FBa0IsY0FBYyxPQUFoQztBQUNBLGFBQUssU0FBTCxHQUFpQixhQUFhLEtBQTlCO0FBQ0EsYUFBSyxPQUFMLEdBQWUsV0FBVyxLQUExQjtBQUNBLGFBQUssVUFBTCxHQUFrQixjQUFjLE9BQWhDO0FBQ0EsYUFBSyxLQUFMLEdBQWEsU0FBUyxLQUF0QjtBQUNIOzs7O2dDQUVPO0FBQ0osaUJBQUssVUFBTCxHQUFrQixPQUFsQjtBQUNBLGlCQUFLLFNBQUwsR0FBaUIsS0FBakI7QUFDQSxpQkFBSyxPQUFMLEdBQWUsS0FBZjtBQUNBLGlCQUFLLFVBQUwsR0FBa0IsT0FBbEI7QUFDQSxpQkFBSyxLQUFMLEdBQWEsS0FBYjtBQUNIOzs7a0NBRVMsTSxFQUFRO0FBQ2QsZ0JBQUksVUFBVSxDQUFDLFlBQUQsRUFBZSxXQUFmLEVBQTRCLFNBQTVCLEVBQXVDLFlBQXZDLEVBQXFELE9BQXJELENBQWQ7QUFDQSxpQkFBSyxJQUFJLElBQUksQ0FBYixFQUFpQixJQUFJLFFBQVEsTUFBN0IsRUFBcUMsR0FBckMsRUFBMEM7QUFDdEMsb0JBQUksUUFBUSxRQUFRLENBQVIsQ0FBWjtBQUNBLG9CQUFJLE9BQU8sY0FBUCxDQUFzQixLQUF0QixDQUFKLEVBQWtDO0FBQzlCLHlCQUFLLEtBQUwsSUFBYyxPQUFPLEtBQVAsQ0FBZDtBQUNIO0FBQ0o7QUFDSjs7O29DQUVXO0FBQ1IsbUJBQVEsS0FBSyxVQUFMLEtBQW9CLE9BQXBCLElBQStCLENBQUMsS0FBSyxTQUFyQyxJQUFrRCxDQUFDLEtBQUssT0FBeEQsSUFDQSxLQUFLLFVBQUwsS0FBb0IsT0FEcEIsSUFDK0IsQ0FBQyxLQUFLLEtBRDdDO0FBRUg7OzsrQkFFTSxLLEVBQU87QUFDVixtQkFBVSxLQUFLLFVBQUwsS0FBb0IsTUFBTSxVQUEzQixJQUNDLEtBQUssU0FBTCxLQUFtQixNQUFNLFNBRDFCLElBRUMsS0FBSyxPQUFMLEtBQWlCLE1BQU0sT0FGeEIsSUFHQyxLQUFLLFVBQUwsS0FBb0IsTUFBTSxVQUgzQixJQUlDLEtBQUssS0FBTCxLQUFlLE1BQU0sS0FKL0I7QUFLSDs7OzZCQUVJLFcsRUFBYTtBQUNkLGlCQUFLLFVBQUwsR0FBa0IsWUFBWSxVQUE5QjtBQUNBLGlCQUFLLFNBQUwsR0FBaUIsWUFBWSxTQUE3QjtBQUNBLGlCQUFLLE9BQUwsR0FBZSxZQUFZLE9BQTNCO0FBQ0EsaUJBQUssVUFBTCxHQUFrQixZQUFZLFVBQTlCO0FBQ0EsaUJBQUssS0FBTCxHQUFhLFlBQVksS0FBekI7QUFDSDs7O21DQUVVO0FBQ1AsbUJBQVEsV0FBVyxLQUFLLFVBQWhCLEdBQTZCLGNBQTdCLEdBQThDLEtBQUssU0FBbkQsR0FBK0QsWUFBL0QsR0FBOEUsS0FBSyxPQUFuRixHQUNKLGVBREksR0FDYyxLQUFLLFVBRG5CLEdBQ2dDLFVBRGhDLEdBQzZDLEtBQUssS0FEMUQ7QUFFSDs7Ozs7O0FBR0w7Ozs7OztJQUlNLGlCO0FBR0YsK0JBQVksS0FBWixFQUFtQixVQUFuQixFQUErQixTQUEvQixFQUEwQyxPQUExQyxFQUFtRCxVQUFuRCxFQUErRCxLQUEvRCxFQUFzRTtBQUFBOztBQUNsRSxhQUFLLEtBQUwsR0FBYSxTQUFTLEdBQXRCLENBRGtFLENBQ3ZDO0FBQzNCLGFBQUssUUFBTCxHQUFnQixJQUFJLFFBQUosQ0FBYSxVQUFiLEVBQXlCLFNBQXpCLEVBQW1DLE9BQW5DLEVBQTRDLFVBQTVDLEVBQXdELEtBQXhELENBQWhCO0FBQ0g7Ozs7Z0NBRU87QUFDSixpQkFBSyxLQUFMLEdBQWEsR0FBYjtBQUNBLGlCQUFLLFFBQUwsQ0FBYyxLQUFkO0FBQ0g7OztnQ0FFTyxLLEVBQU8sVyxFQUFhO0FBQ3hCLGlCQUFLLEtBQUwsR0FBYSxLQUFiO0FBQ0EsaUJBQUssUUFBTCxDQUFjLElBQWQsQ0FBbUIsV0FBbkI7QUFDSDs7O29DQUVXLFcsRUFBYTtBQUNyQixpQkFBSyxRQUFMLENBQWMsSUFBZCxDQUFtQixXQUFuQjtBQUNIOzs7K0JBRU0sSyxFQUFPO0FBQ1YsbUJBQU8sS0FBSyxLQUFMLEtBQWUsTUFBTSxLQUFyQixJQUE4QixLQUFLLFFBQUwsQ0FBYyxNQUFkLENBQXFCLE1BQU0sUUFBM0IsQ0FBckM7QUFDSDs7OzZCQUVJLE8sRUFBUztBQUNWLGlCQUFLLEtBQUwsR0FBYSxRQUFRLEtBQXJCO0FBQ0EsaUJBQUssUUFBTCxDQUFjLElBQWQsQ0FBbUIsUUFBUSxRQUEzQjtBQUNIOzs7a0NBRVM7QUFDTixtQkFBTyxLQUFLLEtBQUwsS0FBZSxHQUFmLElBQXNCLEtBQUssUUFBTCxDQUFjLFNBQWQsRUFBN0I7QUFDSDs7Ozs7O0FBR0w7Ozs7OztJQUlNLEc7QUFDRixtQkFBYztBQUFBOztBQUNWLGFBQUssS0FBTCxHQUFhLEVBQWI7QUFDQSxhQUFLLElBQUksSUFBSSxDQUFiLEVBQWlCLElBQUksT0FBckIsRUFBK0IsR0FBL0IsRUFBb0M7QUFDaEMsaUJBQUssS0FBTCxDQUFXLElBQVgsQ0FBZ0IsSUFBSSxpQkFBSixFQUFoQjtBQUNIO0FBQ0QsYUFBSyxHQUFMLEdBQVcsQ0FBWDtBQUNBLGFBQUssWUFBTCxHQUFvQixJQUFJLFFBQUosRUFBcEI7QUFDSDs7OzsrQkFFTSxLLEVBQU87QUFDVixnQkFBSSxRQUFRLElBQVo7QUFDQSxpQkFBSyxJQUFJLElBQUksQ0FBYixFQUFpQixJQUFJLE9BQXJCLEVBQThCLEdBQTlCLEVBQW9DO0FBQ2hDLG9CQUFJLENBQUMsS0FBSyxLQUFMLENBQVcsQ0FBWCxFQUFjLE1BQWQsQ0FBcUIsTUFBTSxLQUFOLENBQVksQ0FBWixDQUFyQixDQUFMLEVBQTJDO0FBQ3ZDLDRCQUFRLEtBQVI7QUFDQTtBQUNIO0FBQ0o7QUFDRCxtQkFBTyxLQUFQO0FBQ0g7Ozs2QkFFSSxLLEVBQU87QUFDUixpQkFBSyxJQUFJLElBQUksQ0FBYixFQUFpQixJQUFJLE9BQXJCLEVBQThCLEdBQTlCLEVBQW9DO0FBQ2hDLHFCQUFLLEtBQUwsQ0FBVyxDQUFYLEVBQWMsSUFBZCxDQUFtQixNQUFNLEtBQU4sQ0FBWSxDQUFaLENBQW5CO0FBQ0g7QUFDSjs7O2tDQUVTO0FBQ04sZ0JBQUksUUFBUSxJQUFaO0FBQ0EsaUJBQUssSUFBSSxJQUFJLENBQWIsRUFBaUIsSUFBSSxPQUFyQixFQUE4QixHQUE5QixFQUFvQztBQUNoQyxvQkFBSSxDQUFDLEtBQUssS0FBTCxDQUFXLENBQVgsRUFBYyxPQUFkLEVBQUwsRUFBOEI7QUFDMUIsNEJBQVEsS0FBUjtBQUNBO0FBQ0g7QUFDSjtBQUNELG1CQUFPLEtBQVA7QUFDSDs7QUFFRDs7Ozs7O2tDQUdVLE0sRUFBUTtBQUNkLGdCQUFJLEtBQUssR0FBTCxLQUFhLE1BQWpCLEVBQXlCO0FBQ3JCLHFCQUFLLEdBQUwsR0FBVyxNQUFYO0FBQ0g7QUFDRCxnQkFBSSxLQUFLLEdBQUwsR0FBVyxDQUFmLEVBQWtCO0FBQ2QsdUJBQU8sR0FBUCxDQUFXLE9BQVgsRUFBb0IsOEJBQThCLEtBQUssR0FBdkQ7QUFDQSxxQkFBSyxHQUFMLEdBQVcsQ0FBWDtBQUNILGFBSEQsTUFHTyxJQUFJLEtBQUssR0FBTCxHQUFXLE9BQWYsRUFBd0I7QUFDM0IsdUJBQU8sR0FBUCxDQUFXLE9BQVgsRUFBb0IsK0JBQStCLEtBQUssR0FBeEQ7QUFDQSxxQkFBSyxHQUFMLEdBQVcsT0FBWDtBQUNIO0FBQ0o7O0FBRUQ7Ozs7OzttQ0FHVyxNLEVBQVE7QUFDZixnQkFBSSxTQUFTLEtBQUssR0FBTCxHQUFXLE1BQXhCO0FBQ0EsZ0JBQUksU0FBUyxDQUFiLEVBQWdCO0FBQ1oscUJBQUssSUFBSSxJQUFJLEtBQUssR0FBTCxHQUFTLENBQXRCLEVBQXlCLElBQUksU0FBTyxDQUFwQyxFQUF3QyxHQUF4QyxFQUE2QztBQUN6Qyx5QkFBSyxLQUFMLENBQVcsQ0FBWCxFQUFjLFdBQWQsQ0FBMEIsS0FBSyxZQUEvQjtBQUNIO0FBQ0o7QUFDRCxpQkFBSyxTQUFMLENBQWUsTUFBZjtBQUNIOztBQUVEOzs7Ozs7b0NBR1k7QUFDUixpQkFBSyxVQUFMLENBQWdCLENBQUMsQ0FBakI7QUFDQSxpQkFBSyxLQUFMLENBQVcsS0FBSyxHQUFoQixFQUFxQixPQUFyQixDQUE2QixHQUE3QixFQUFrQyxLQUFLLFlBQXZDO0FBQ0g7OzttQ0FFVSxJLEVBQU07QUFDYixnQkFBSSxRQUFRLElBQVosRUFBa0I7QUFBRTtBQUNoQixxQkFBSyxTQUFMO0FBQ0g7QUFDRCxnQkFBSSxPQUFPLGVBQWUsSUFBZixDQUFYO0FBQ0EsZ0JBQUksS0FBSyxHQUFMLElBQVksT0FBaEIsRUFBeUI7QUFDckIsdUJBQU8sR0FBUCxDQUFXLFNBQVgsRUFBc0IsbUJBQW1CLEtBQUssUUFBTCxDQUFjLEVBQWQsQ0FBbkIsR0FDVixJQURVLEdBQ0gsSUFERyxHQUNJLGdCQURKLEdBQ3VCLEtBQUssR0FENUIsR0FDa0MsZ0JBRHhEO0FBRUE7QUFDSDtBQUNELGlCQUFLLEtBQUwsQ0FBVyxLQUFLLEdBQWhCLEVBQXFCLE9BQXJCLENBQTZCLElBQTdCLEVBQW1DLEtBQUssWUFBeEM7QUFDQSxpQkFBSyxVQUFMLENBQWdCLENBQWhCO0FBQ0g7OztxQ0FFWSxRLEVBQVU7QUFDbkIsZ0JBQUksQ0FBSjtBQUNBLGlCQUFLLElBQUksUUFBVCxFQUFvQixJQUFJLE9BQXhCLEVBQWtDLEdBQWxDLEVBQXVDO0FBQ25DLHFCQUFLLEtBQUwsQ0FBVyxDQUFYLEVBQWMsS0FBZDtBQUNIO0FBQ0o7OztnQ0FFTztBQUNKLGlCQUFLLFlBQUwsQ0FBa0IsQ0FBbEI7QUFDQSxpQkFBSyxHQUFMLEdBQVcsQ0FBWDtBQUNBLGlCQUFLLFlBQUwsQ0FBa0IsS0FBbEI7QUFDSDs7OzBDQUVpQjtBQUNkLGlCQUFLLFlBQUwsQ0FBa0IsS0FBSyxHQUF2QjtBQUNIOzs7d0NBRWU7QUFDWixnQkFBSSxRQUFRLEVBQVo7QUFDQSxnQkFBSSxRQUFRLElBQVo7QUFDQSxpQkFBSyxJQUFJLElBQUksQ0FBYixFQUFpQixJQUFJLE9BQXJCLEVBQStCLEdBQS9CLEVBQW9DO0FBQ2hDLG9CQUFJLE9BQU8sS0FBSyxLQUFMLENBQVcsQ0FBWCxFQUFjLEtBQXpCO0FBQ0Esb0JBQUksU0FBUyxHQUFiLEVBQWtCO0FBQ2QsNEJBQVEsS0FBUjtBQUNIO0FBQ0Qsc0JBQU0sSUFBTixDQUFXLElBQVg7QUFDSDtBQUNELGdCQUFJLEtBQUosRUFBVztBQUNQLHVCQUFPLEVBQVA7QUFDSCxhQUZELE1BRU87QUFDSCx1QkFBTyxNQUFNLElBQU4sQ0FBVyxFQUFYLENBQVA7QUFDSDtBQUNKOzs7cUNBRVksTSxFQUFRO0FBQ2pCLGlCQUFLLFlBQUwsQ0FBa0IsU0FBbEIsQ0FBNEIsTUFBNUI7QUFDQSxnQkFBSSxXQUFXLEtBQUssS0FBTCxDQUFXLEtBQUssR0FBaEIsQ0FBZjtBQUNBLHFCQUFTLFdBQVQsQ0FBcUIsS0FBSyxZQUExQjtBQUNIOzs7Ozs7QUFHTDs7Ozs7O0lBSU0sYTtBQUVGLDZCQUFjO0FBQUE7O0FBQ1YsYUFBSyxJQUFMLEdBQVksRUFBWjtBQUNBLGFBQUssSUFBSSxJQUFJLENBQWIsRUFBaUIsSUFBSyxPQUF0QixFQUErQixHQUEvQixFQUFvQztBQUNoQyxpQkFBSyxJQUFMLENBQVUsSUFBVixDQUFlLElBQUksR0FBSixFQUFmLEVBRGdDLENBQ0w7QUFDOUI7QUFDRCxhQUFLLE9BQUwsR0FBZSxVQUFVLENBQXpCO0FBQ0EsYUFBSyxZQUFMLEdBQW9CLElBQXBCO0FBQ0EsYUFBSyxLQUFMO0FBQ0g7Ozs7Z0NBRU87QUFDSixpQkFBSyxJQUFJLElBQUksQ0FBYixFQUFpQixJQUFJLE9BQXJCLEVBQStCLEdBQS9CLEVBQW9DO0FBQ2hDLHFCQUFLLElBQUwsQ0FBVSxDQUFWLEVBQWEsS0FBYjtBQUNIO0FBQ0QsaUJBQUssT0FBTCxHQUFlLFVBQVUsQ0FBekI7QUFDSDs7OytCQUVNLEssRUFBTztBQUNWLGdCQUFJLFFBQVEsSUFBWjtBQUNBLGlCQUFLLElBQUksSUFBSSxDQUFiLEVBQWlCLElBQUksT0FBckIsRUFBK0IsR0FBL0IsRUFBb0M7QUFDaEMsb0JBQUksQ0FBQyxLQUFLLElBQUwsQ0FBVSxDQUFWLEVBQWEsTUFBYixDQUFvQixNQUFNLElBQU4sQ0FBVyxDQUFYLENBQXBCLENBQUwsRUFBeUM7QUFDckMsNEJBQVEsS0FBUjtBQUNBO0FBQ0g7QUFDSjtBQUNELG1CQUFPLEtBQVA7QUFDSDs7OzZCQUVJLEssRUFBTztBQUNSLGlCQUFLLElBQUksSUFBSSxDQUFiLEVBQWlCLElBQUksT0FBckIsRUFBK0IsR0FBL0IsRUFBb0M7QUFDaEMscUJBQUssSUFBTCxDQUFVLENBQVYsRUFBYSxJQUFiLENBQWtCLE1BQU0sSUFBTixDQUFXLENBQVgsQ0FBbEI7QUFDSDtBQUNKOzs7a0NBRVM7QUFDTixnQkFBSSxRQUFRLElBQVo7QUFDQSxpQkFBSyxJQUFJLElBQUksQ0FBYixFQUFpQixJQUFJLE9BQXJCLEVBQStCLEdBQS9CLEVBQW9DO0FBQ2hDLG9CQUFJLENBQUMsS0FBSyxJQUFMLENBQVUsQ0FBVixFQUFhLE9BQWIsRUFBTCxFQUE2QjtBQUN6Qiw0QkFBUSxLQUFSO0FBQ0E7QUFDSDtBQUNKO0FBQ0QsbUJBQU8sS0FBUDtBQUNIOzs7b0NBRVc7QUFDUixnQkFBSSxNQUFNLEtBQUssSUFBTCxDQUFVLEtBQUssT0FBZixDQUFWO0FBQ0EsZ0JBQUksU0FBSjtBQUNIOzs7MENBRWlCO0FBQ2QsZ0JBQUksTUFBTSxLQUFLLElBQUwsQ0FBVSxLQUFLLE9BQWYsQ0FBVjtBQUNBLGdCQUFJLGVBQUo7QUFDSDs7QUFFRDs7Ozs7O21DQUdXLEksRUFBTTtBQUNiLGdCQUFJLE1BQU0sS0FBSyxJQUFMLENBQVUsS0FBSyxPQUFmLENBQVY7QUFDQSxnQkFBSSxVQUFKLENBQWUsSUFBZjtBQUNIOzs7K0JBRU0sTSxFQUFRO0FBQ1gsZ0JBQUksTUFBTSxLQUFLLElBQUwsQ0FBVSxLQUFLLE9BQWYsQ0FBVjtBQUNBLGdCQUFJLFlBQUosQ0FBaUIsTUFBakI7QUFDSDs7O21DQUVVLE0sRUFBUTtBQUNmLGdCQUFJLE1BQU0sS0FBSyxJQUFMLENBQVUsS0FBSyxPQUFmLENBQVY7QUFDQSxnQkFBSSxVQUFKLENBQWUsTUFBZjtBQUNIOzs7a0NBRVMsTSxFQUFRO0FBQ2QsbUJBQU8sR0FBUCxDQUFXLE1BQVgsRUFBbUIsZ0JBQWdCLE1BQW5DO0FBQ0EsZ0JBQUksTUFBTSxLQUFLLElBQUwsQ0FBVSxLQUFLLE9BQWYsQ0FBVjtBQUNBLGdCQUFJLFNBQUosQ0FBYyxNQUFkO0FBQ0g7OzsrQkFFTSxPLEVBQVMsZ0IsRUFBa0I7QUFDOUIsbUJBQU8sR0FBUCxDQUFXLE1BQVgsRUFBbUIsZUFBZSxLQUFLLFNBQUwsQ0FBZSxPQUFmLENBQWxDO0FBQ0EsZ0JBQUksU0FBUyxRQUFRLEdBQVIsR0FBYyxDQUEzQjtBQUNBLGdCQUFJLEtBQUssWUFBTCxJQUFzQixTQUFTLEtBQUssWUFBTCxHQUFvQixDQUF2RCxFQUEwRDtBQUNsRCx5QkFBUyxLQUFLLFlBQUwsR0FBa0IsQ0FBM0I7QUFDUDs7QUFFRDtBQUNBLGdCQUFJLEtBQUssWUFBTCxJQUFxQixLQUFLLE9BQUwsS0FBaUIsTUFBMUMsRUFBa0Q7QUFDaEQ7QUFDQSxxQkFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLE9BQXBCLEVBQTZCLEdBQTdCLEVBQWtDO0FBQ2hDLHlCQUFLLElBQUwsQ0FBVSxDQUFWLEVBQWEsS0FBYjtBQUNEOztBQUVEO0FBQ0E7QUFDQSxvQkFBSSxjQUFjLEtBQUssT0FBTCxHQUFlLENBQWYsR0FBb0IsS0FBSyxZQUEzQztBQUNBO0FBQ0E7QUFDQSxvQkFBSSxlQUFlLGlCQUFpQixJQUFqQixDQUFzQixXQUF0QixFQUFtQyxZQUF0RDtBQUNBLG9CQUFHLGdCQUFnQixlQUFlLE9BQU8sSUFBekMsRUFBK0M7QUFDN0MseUJBQUssSUFBSSxLQUFJLENBQWIsRUFBZ0IsS0FBSSxLQUFLLFlBQXpCLEVBQXVDLElBQXZDLEVBQTRDO0FBQzFDLDZCQUFLLElBQUwsQ0FBVSxTQUFPLEtBQUssWUFBWixHQUF5QixFQUF6QixHQUEyQixDQUFyQyxFQUF3QyxJQUF4QyxDQUE2QyxpQkFBaUIsSUFBakIsQ0FBc0IsY0FBWSxFQUFsQyxDQUE3QztBQUNEO0FBQ0Y7QUFDRjs7QUFFRCxpQkFBSyxPQUFMLEdBQWUsTUFBZjtBQUNBLGdCQUFJLE1BQU0sS0FBSyxJQUFMLENBQVUsS0FBSyxPQUFmLENBQVY7QUFDQSxnQkFBSSxRQUFRLE1BQVIsS0FBbUIsSUFBdkIsRUFBNkI7QUFDekIsb0JBQUksU0FBUyxRQUFRLE1BQXJCO0FBQ0Esb0JBQUksVUFBVSxLQUFLLEdBQUwsQ0FBUyxTQUFPLENBQWhCLEVBQW1CLENBQW5CLENBQWQ7QUFDQSxvQkFBSSxTQUFKLENBQWMsUUFBUSxNQUF0QjtBQUNBLHdCQUFRLEtBQVIsR0FBZ0IsSUFBSSxLQUFKLENBQVUsT0FBVixFQUFtQixRQUFuQixDQUE0QixVQUE1QztBQUNIO0FBQ0QsZ0JBQUksU0FBUyxFQUFDLFlBQWEsUUFBUSxLQUF0QixFQUE2QixXQUFZLFFBQVEsU0FBakQsRUFBNEQsU0FBVSxRQUFRLE9BQTlFLEVBQXVGLFlBQWEsT0FBcEcsRUFBNkcsT0FBUSxLQUFySCxFQUFiO0FBQ0EsaUJBQUssTUFBTCxDQUFZLE1BQVo7QUFDSDs7QUFFRDs7Ozs7O21DQUdXLE8sRUFBUzs7QUFFaEIsbUJBQU8sR0FBUCxDQUFXLE1BQVgsRUFBbUIsZUFBZSxLQUFLLFNBQUwsQ0FBZSxPQUFmLENBQWxDO0FBQ0EsaUJBQUssU0FBTDtBQUNBLGlCQUFLLE1BQUwsQ0FBWSxPQUFaO0FBQ0EsaUJBQUssVUFBTCxDQUFnQixJQUFoQixFQUxnQixDQUtPO0FBQzFCOzs7c0NBRWEsTSxFQUFRO0FBQ2xCLGlCQUFLLFlBQUwsR0FBb0IsTUFBcEI7QUFDSDs7O2lDQUVRO0FBQ0wsZ0JBQUksS0FBSyxZQUFMLEtBQXNCLElBQTFCLEVBQWdDO0FBQzVCLHVCQUFPLEdBQVAsQ0FBVyxPQUFYLEVBQW9CLHNDQUFwQjtBQUNBLHVCQUY0QixDQUVwQjtBQUNYO0FBQ0QsbUJBQU8sR0FBUCxDQUFXLE1BQVgsRUFBbUIsS0FBSyxjQUFMLEVBQW5CO0FBQ0EsZ0JBQUksY0FBYyxLQUFLLE9BQUwsR0FBZSxDQUFmLEdBQW1CLEtBQUssWUFBMUM7QUFDQSxnQkFBSSxTQUFTLEtBQUssSUFBTCxDQUFVLE1BQVYsQ0FBaUIsV0FBakIsRUFBOEIsQ0FBOUIsRUFBaUMsQ0FBakMsQ0FBYjtBQUNBLG1CQUFPLEtBQVA7QUFDQSxpQkFBSyxJQUFMLENBQVUsTUFBVixDQUFpQixLQUFLLE9BQXRCLEVBQStCLENBQS9CLEVBQWtDLE1BQWxDO0FBQ0EsbUJBQU8sR0FBUCxDQUFXLE1BQVgsRUFBbUIsWUFBbkI7QUFDQTtBQUNIOztBQUVGOzs7Ozs7dUNBR2dCLFEsRUFBVTtBQUNyQix1QkFBVyxZQUFZLEtBQXZCO0FBQ0EsZ0JBQUksY0FBYyxFQUFsQjtBQUNBLGdCQUFJLE9BQU8sRUFBWDtBQUNBLGdCQUFJLFFBQVEsQ0FBQyxDQUFiO0FBQ0EsaUJBQUssSUFBSSxJQUFJLENBQWIsRUFBaUIsSUFBSSxPQUFyQixFQUErQixHQUEvQixFQUFvQztBQUNoQyxvQkFBSSxVQUFVLEtBQUssSUFBTCxDQUFVLENBQVYsRUFBYSxhQUFiLEVBQWQ7QUFDQSxvQkFBSSxPQUFKLEVBQWE7QUFDVCw0QkFBUSxJQUFFLENBQVY7QUFDQSx3QkFBSSxRQUFKLEVBQWM7QUFDVixvQ0FBWSxJQUFaLENBQWlCLFNBQVMsS0FBVCxHQUFpQixNQUFqQixHQUEwQixPQUExQixHQUFvQyxJQUFyRDtBQUNILHFCQUZELE1BRU87QUFDSCxvQ0FBWSxJQUFaLENBQWlCLFFBQVEsSUFBUixFQUFqQjtBQUNIO0FBQ0o7QUFDSjtBQUNELGdCQUFJLFlBQVksTUFBWixHQUFxQixDQUF6QixFQUE0QjtBQUN4QixvQkFBSSxRQUFKLEVBQWM7QUFDViwyQkFBTyxNQUFNLFlBQVksSUFBWixDQUFpQixLQUFqQixDQUFOLEdBQWdDLEdBQXZDO0FBQ0gsaUJBRkQsTUFFTztBQUNILDJCQUFPLFlBQVksSUFBWixDQUFpQixJQUFqQixDQUFQO0FBQ0g7QUFDSjtBQUNELG1CQUFPLElBQVA7QUFDSDs7OzJDQUVrQjtBQUNmLG1CQUFPLEtBQUssSUFBWjtBQUNIOzs7Ozs7QUFHTDs7SUFFTSxhO0FBRUYsMkJBQVksYUFBWixFQUEyQixZQUEzQixFQUF5QztBQUFBOztBQUVyQyxhQUFLLElBQUwsR0FBWSxhQUFaO0FBQ0EsYUFBSyxZQUFMLEdBQW9CLFlBQXBCO0FBQ0EsYUFBSyxJQUFMLEdBQVksSUFBWjtBQUNBLGFBQUssT0FBTCxHQUFlLENBQWY7QUFDQSxhQUFLLGVBQUwsR0FBdUIsSUFBSSxhQUFKLEVBQXZCO0FBQ0EsYUFBSyxrQkFBTCxHQUEwQixJQUFJLGFBQUosRUFBMUI7QUFDQSxhQUFLLGdCQUFMLEdBQXdCLElBQUksYUFBSixFQUF4QjtBQUNBLGFBQUssYUFBTCxHQUFxQixLQUFLLGVBQUwsQ0FBcUIsSUFBckIsQ0FBMEIsVUFBUSxDQUFsQyxDQUFyQjtBQUNBLGFBQUssV0FBTCxHQUFtQixLQUFLLGVBQXhCO0FBQ0EsYUFBSyxJQUFMLEdBQVksSUFBWjtBQUNBLGFBQUssWUFBTCxHQUFvQixJQUFwQixDQVpxQyxDQVlYO0FBQzdCOzs7O2dDQUVPO0FBQ0osaUJBQUssSUFBTCxHQUFZLElBQVo7QUFDQSxpQkFBSyxlQUFMLENBQXFCLEtBQXJCO0FBQ0EsaUJBQUssa0JBQUwsQ0FBd0IsS0FBeEI7QUFDQSxpQkFBSyxnQkFBTCxDQUFzQixLQUF0QjtBQUNBLGlCQUFLLGFBQUwsR0FBcUIsS0FBSyxlQUFMLENBQXFCLElBQXJCLENBQTBCLFVBQVEsQ0FBbEMsQ0FBckI7QUFDQSxpQkFBSyxXQUFMLEdBQW1CLEtBQUssZUFBeEI7QUFDQSxpQkFBSyxJQUFMLEdBQVksSUFBWjtBQUNBLGlCQUFLLFlBQUwsR0FBb0IsSUFBcEI7QUFDQSxpQkFBSyxjQUFMLEdBQXNCLElBQXRCO0FBQ0g7OztxQ0FFWTtBQUNULG1CQUFPLEtBQUssWUFBWjtBQUNIOzs7bUNBRVUsVSxFQUFZO0FBQ25CLGlCQUFLLFlBQUwsR0FBb0IsVUFBcEI7QUFDSDs7OytCQUVNLE8sRUFBUztBQUNaLGlCQUFLLFdBQUwsQ0FBaUIsTUFBakIsQ0FBd0IsT0FBeEIsRUFBaUMsS0FBSyxnQkFBdEM7QUFDSDs7O21DQUVVLE8sRUFBUztBQUNoQixpQkFBSyxXQUFMLENBQWlCLFVBQWpCLENBQTRCLE9BQTVCO0FBQ0g7OztnQ0FFTyxPLEVBQVM7QUFDYixnQkFBSSxZQUFZLEtBQUssSUFBckIsRUFBMkI7QUFDdkI7QUFDSDtBQUNELGlCQUFLLElBQUwsR0FBWSxPQUFaO0FBQ0EsbUJBQU8sR0FBUCxDQUFXLE1BQVgsRUFBbUIsVUFBVSxPQUE3QjtBQUNBLGdCQUFJLEtBQUssSUFBTCxLQUFjLGFBQWxCLEVBQWlDO0FBQzdCLHFCQUFLLFdBQUwsR0FBbUIsS0FBSyxrQkFBeEI7QUFDSCxhQUZELE1BRU87QUFDSCxxQkFBSyxXQUFMLEdBQW1CLEtBQUssZUFBeEI7QUFDQSxxQkFBSyxXQUFMLENBQWlCLEtBQWpCO0FBQ0EscUJBQUssZ0JBQUwsQ0FBc0IsS0FBdEI7QUFDSDtBQUNELGdCQUFJLEtBQUssSUFBTCxLQUFjLGNBQWxCLEVBQWtDO0FBQzlCLHFCQUFLLGVBQUwsQ0FBcUIsWUFBckIsR0FBb0MsSUFBcEM7QUFDQSxxQkFBSyxrQkFBTCxDQUF3QixZQUF4QixHQUF1QyxJQUF2QztBQUNIO0FBQ0QsaUJBQUssSUFBTCxHQUFZLE9BQVo7QUFDSDs7O29DQUVXLEssRUFBTztBQUNmLGlCQUFLLElBQUksSUFBSSxDQUFiLEVBQWlCLElBQUksTUFBTSxNQUEzQixFQUFvQyxHQUFwQyxFQUF5QztBQUNyQyxxQkFBSyxXQUFMLENBQWlCLFVBQWpCLENBQTRCLE1BQU0sQ0FBTixDQUE1QjtBQUNIO0FBQ0QsZ0JBQUksU0FBUyxLQUFLLFdBQUwsS0FBcUIsS0FBSyxlQUExQixHQUE0QyxNQUE1QyxHQUFxRCxVQUFsRTtBQUNBLG1CQUFPLEdBQVAsQ0FBVyxNQUFYLEVBQW1CLFNBQVMsSUFBVCxHQUFnQixLQUFLLFdBQUwsQ0FBaUIsY0FBakIsQ0FBZ0MsSUFBaEMsQ0FBbkM7QUFDQSxnQkFBSSxLQUFLLElBQUwsS0FBYyxlQUFkLElBQWlDLEtBQUssSUFBTCxLQUFjLGNBQW5ELEVBQW1FO0FBQy9ELHVCQUFPLEdBQVAsQ0FBVyxNQUFYLEVBQW1CLGdCQUFnQixLQUFLLGVBQUwsQ0FBcUIsY0FBckIsQ0FBb0MsSUFBcEMsQ0FBbkM7QUFDQSxxQkFBSyxnQkFBTDtBQUNIO0FBQ0o7OztnQ0FFTztBQUFFO0FBQ04sbUJBQU8sR0FBUCxDQUFXLE1BQVgsRUFBbUIsOEJBQW5CO0FBQ0EsaUJBQUssT0FBTCxDQUFhLGFBQWI7QUFDSDs7OytCQUVNO0FBQUU7QUFDTCxtQkFBTyxHQUFQLENBQVcsTUFBWCxFQUFtQixnQkFBbkI7QUFDQSxnQkFBSSxLQUFLLElBQUwsS0FBYyxXQUFsQixFQUErQjtBQUMzQjtBQUNIO0FBQ0QsaUJBQUssV0FBTCxDQUFpQixTQUFqQjtBQUNBLGdCQUFJLEtBQUssV0FBTCxLQUFxQixLQUFLLGVBQTlCLEVBQStDO0FBQzNDLHFCQUFLLGdCQUFMO0FBQ0g7QUFDSjs7O2dDQUVPO0FBQUU7QUFDTjtBQUNIOzs7Z0NBRU87QUFBRTtBQUNOO0FBQ0g7OztnQ0FFTztBQUFFO0FBQ04sbUJBQU8sR0FBUCxDQUFXLE1BQVgsRUFBbUIsMkJBQW5CO0FBQ0EsaUJBQUssV0FBTCxDQUFpQixlQUFqQjtBQUNBLGlCQUFLLGdCQUFMO0FBQ0g7Ozs2QkFFSSxNLEVBQVE7QUFBRTtBQUNYLG1CQUFPLEdBQVAsQ0FBVyxNQUFYLEVBQW1CLFFBQVEsTUFBUixHQUFnQixhQUFuQztBQUNBLGlCQUFLLFdBQUwsR0FBbUIsS0FBSyxlQUF4QjtBQUNBLGlCQUFLLE9BQUwsQ0FBYSxjQUFiO0FBQ0EsaUJBQUssV0FBTCxDQUFpQixhQUFqQixDQUErQixNQUEvQjtBQUNIOzs7Z0NBRU87QUFBRTtBQUNOLG1CQUFPLEdBQVAsQ0FBVyxNQUFYLEVBQW1CLGdCQUFuQjtBQUNBLGlCQUFLLFdBQUwsQ0FBaUIsTUFBakIsQ0FBd0IsRUFBQyxPQUFRLElBQVQsRUFBeEI7QUFDSDs7O2dDQUVPO0FBQUU7QUFDTixtQkFBTyxHQUFQLENBQVcsTUFBWCxFQUFtQixnQ0FBbkI7QUFDQSxpQkFBSyxPQUFMLENBQWEsZUFBYjtBQUNIOzs7K0JBRU07QUFBRTtBQUNMLG1CQUFPLEdBQVAsQ0FBVyxNQUFYLEVBQW1CLElBQW5CO0FBQ0EsaUJBQUssT0FBTCxDQUFhLFdBQWI7QUFDSDs7O2dDQUVPO0FBQUU7QUFDTixtQkFBTyxHQUFQLENBQVcsTUFBWCxFQUFtQixLQUFuQjtBQUNBLGlCQUFLLE9BQUwsQ0FBYSxXQUFiO0FBQ0g7OztnQ0FFTztBQUFFO0FBQ04sbUJBQU8sR0FBUCxDQUFXLE1BQVgsRUFBbUIsOEJBQW5CO0FBQ0EsaUJBQUssZUFBTCxDQUFxQixLQUFyQjtBQUNBLGlCQUFLLGdCQUFMO0FBQ0g7OzsrQkFFTTtBQUFFO0FBQ0wsbUJBQU8sR0FBUCxDQUFXLHNCQUFYO0FBQ0EsaUJBQUssV0FBTCxDQUFpQixNQUFqQjtBQUNBLGlCQUFLLGdCQUFMO0FBQ0g7OztnQ0FFTztBQUFFO0FBQ04sbUJBQU8sR0FBUCxDQUFXLE1BQVgsRUFBbUIsa0NBQW5CO0FBQ0EsaUJBQUssa0JBQUwsQ0FBd0IsS0FBeEI7QUFDSDs7O2dDQUVPO0FBQUU7QUFDTixtQkFBTyxHQUFQLENBQVcsTUFBWCxFQUFtQixzQkFBbkI7QUFDQSxnQkFBSSxLQUFLLElBQUwsS0FBYyxhQUFsQixFQUFpQztBQUM3QixvQkFBSSxNQUFNLEtBQUssZUFBZjtBQUNBLHFCQUFLLGVBQUwsR0FBdUIsS0FBSyxrQkFBNUI7QUFDQSxxQkFBSyxrQkFBTCxHQUEwQixHQUExQjtBQUNBLHFCQUFLLFdBQUwsR0FBbUIsS0FBSyxrQkFBeEI7QUFDQSx1QkFBTyxHQUFQLENBQVcsTUFBWCxFQUFtQixXQUFXLEtBQUssZUFBTCxDQUFxQixjQUFyQixFQUE5QjtBQUNIO0FBQ0QsaUJBQUssZ0JBQUw7QUFDSDs7OzZCQUVJLE0sRUFBUTtBQUFFO0FBQ1gsbUJBQU8sR0FBUCxDQUFXLE1BQVgsRUFBbUIsUUFBUSxNQUFSLEdBQWlCLGdCQUFwQztBQUNBLGlCQUFLLFdBQUwsQ0FBaUIsVUFBakIsQ0FBNEIsTUFBNUI7QUFDSDs7O2lDQUVRLFUsRUFBWTtBQUFFO0FBQ25CLGdCQUFJLFNBQVMsRUFBQyxPQUFRLEtBQVQsRUFBYjtBQUNBLG1CQUFPLFNBQVAsR0FBbUIsYUFBYSxDQUFiLEtBQW1CLENBQXRDO0FBQ0EsbUJBQU8sT0FBUCxHQUFpQixjQUFjLElBQS9CO0FBQ0EsZ0JBQUksQ0FBQyxPQUFPLE9BQVosRUFBcUI7QUFDakIsb0JBQUksYUFBYSxLQUFLLEtBQUwsQ0FBVyxhQUFXLENBQXRCLElBQTJCLElBQTVDO0FBQ0Esb0JBQUksU0FBUyxDQUFDLE9BQUQsRUFBVSxPQUFWLEVBQW1CLE1BQW5CLEVBQTJCLE1BQTNCLEVBQW1DLEtBQW5DLEVBQTBDLFFBQTFDLEVBQW9ELFNBQXBELENBQWI7QUFDQSx1QkFBTyxVQUFQLEdBQW9CLE9BQU8sVUFBUCxDQUFwQjtBQUNILGFBSkQsTUFJTztBQUNILHVCQUFPLFVBQVAsR0FBb0IsT0FBcEI7QUFDSDtBQUNELG1CQUFPLEdBQVAsQ0FBVyxNQUFYLEVBQW1CLGFBQWEsS0FBSyxTQUFMLENBQWUsTUFBZixDQUFoQztBQUNBLGlCQUFLLFdBQUwsQ0FBaUIsTUFBakIsQ0FBd0IsTUFBeEI7QUFDSDs7OzJDQUVrQjtBQUNmLGdCQUFJLElBQUksT0FBTyxJQUFmO0FBQ0EsZ0JBQUksTUFBTSxJQUFWLEVBQWdCO0FBQ1o7QUFDSDtBQUNELGdCQUFJLEtBQUssWUFBVCxFQUF1QjtBQUNuQixvQkFBSSxLQUFLLFlBQUwsQ0FBa0IsVUFBdEIsRUFBa0M7QUFDOUIseUJBQUssWUFBTCxDQUFrQixVQUFsQixDQUE2QixDQUE3QixFQUFnQyxLQUFLLGVBQXJDO0FBQ0g7QUFDRCxvQkFBSSxLQUFLLFlBQUwsS0FBc0IsSUFBdEIsSUFBOEIsQ0FBQyxLQUFLLGVBQUwsQ0FBcUIsT0FBckIsRUFBbkMsRUFBbUU7QUFBRTtBQUNqRSx5QkFBSyxZQUFMLEdBQW9CLENBQXBCO0FBQ0gsaUJBRkQsTUFFTztBQUNILHdCQUFJLENBQUMsS0FBSyxlQUFMLENBQXFCLE1BQXJCLENBQTRCLEtBQUssZ0JBQWpDLENBQUwsRUFBeUQ7QUFDckQsNEJBQUksS0FBSyxZQUFMLENBQWtCLE1BQXRCLEVBQThCO0FBQzFCLGlDQUFLLFlBQUwsQ0FBa0IsTUFBbEIsQ0FBeUIsS0FBSyxZQUE5QixFQUE0QyxDQUE1QyxFQUErQyxLQUFLLGdCQUFwRDtBQUNIO0FBQ0QsNkJBQUssWUFBTCxHQUFvQixLQUFLLGVBQUwsQ0FBcUIsT0FBckIsS0FBaUMsSUFBakMsR0FBd0MsQ0FBNUQ7QUFDSDtBQUNKO0FBQ0QscUJBQUssZ0JBQUwsQ0FBc0IsSUFBdEIsQ0FBMkIsS0FBSyxlQUFoQztBQUNIO0FBQ0o7Ozt1Q0FFYyxDLEVBQUc7QUFDZCxnQkFBSSxLQUFLLFlBQVQsRUFBdUI7QUFDbkIsb0JBQUksQ0FBQyxLQUFLLGVBQUwsQ0FBcUIsT0FBckIsRUFBTCxFQUFxQztBQUNqQyx3QkFBSSxLQUFLLFlBQUwsQ0FBa0IsTUFBdEIsRUFBOEI7QUFDMUIsNkJBQUssWUFBTCxDQUFrQixNQUFsQixDQUF5QixLQUFLLFlBQTlCLEVBQTRDLENBQTVDLEVBQStDLEtBQUssZUFBcEQ7QUFDSDtBQUNELHlCQUFLLFlBQUwsR0FBb0IsQ0FBcEI7QUFDSDtBQUNKO0FBQ0o7Ozs7OztJQUdDLFk7QUFFRiwwQkFBWSxLQUFaLEVBQW1CLElBQW5CLEVBQXlCLElBQXpCLEVBQStCO0FBQUE7O0FBQzNCLGFBQUssS0FBTCxHQUFhLFNBQVMsQ0FBdEI7QUFDQSxhQUFLLE9BQUwsR0FBZSxDQUFDLElBQUQsRUFBTyxJQUFQLENBQWY7QUFDQSxhQUFLLFFBQUwsR0FBZ0IsQ0FBQyxJQUFJLGFBQUosQ0FBa0IsQ0FBbEIsRUFBcUIsSUFBckIsQ0FBRCxFQUE2QixJQUFJLGFBQUosQ0FBa0IsQ0FBbEIsRUFBcUIsSUFBckIsQ0FBN0IsQ0FBaEI7QUFDQSxhQUFLLFFBQUwsR0FBZ0IsQ0FBQyxDQUFqQixDQUoyQixDQUlQO0FBQ3BCLGFBQUssUUFBTCxHQUFnQixJQUFoQixDQUwyQixDQUtMO0FBQ3RCLGFBQUssUUFBTCxHQUFnQixJQUFoQixDQU4yQixDQU1MO0FBQ3RCLGFBQUssWUFBTCxHQUFvQixFQUFwQjtBQUNBLGFBQUssU0FBTCxHQUFpQixJQUFqQjtBQUNBLGFBQUssUUFBTCxHQUFnQixJQUFoQjtBQUNBLGFBQUssWUFBTCxHQUFvQixFQUFDLFdBQVksQ0FBYixFQUFnQixRQUFTLENBQXpCLEVBQTRCLE9BQVEsQ0FBcEMsRUFBdUMsU0FBVSxDQUFqRCxFQUFwQjtBQUNIOzs7O21DQUVVLEssRUFBTztBQUNkLG1CQUFPLEtBQUssUUFBTCxDQUFjLEtBQWQsRUFBcUIsVUFBckIsRUFBUDtBQUNIOzs7bUNBRVUsSyxFQUFPLFUsRUFBWTtBQUMxQixpQkFBSyxRQUFMLENBQWMsS0FBZCxFQUFxQixVQUFyQixDQUFnQyxVQUFoQztBQUNIOztBQUVEOzs7Ozs7Z0NBR1EsQyxFQUFHLFEsRUFBVTtBQUNqQixnQkFBSSxRQUFKO0FBQUEsZ0JBQWMsQ0FBZDtBQUFBLGdCQUFpQixDQUFqQjtBQUFBLGdCQUNBLGFBQWEsS0FEYjs7QUFHQSxpQkFBSyxRQUFMLEdBQWdCLENBQWhCO0FBQ0EsbUJBQU8sT0FBUCxDQUFlLENBQWY7O0FBRUEsaUJBQUssSUFBSSxJQUFJLENBQWIsRUFBaUIsSUFBSSxTQUFTLE1BQTlCLEVBQXVDLEtBQUcsQ0FBMUMsRUFBNkM7QUFDekMsb0JBQUksU0FBUyxDQUFULElBQWMsSUFBbEI7QUFDQSxvQkFBSSxTQUFTLElBQUUsQ0FBWCxJQUFnQixJQUFwQjtBQUNBLG9CQUFJLE1BQU0sQ0FBTixJQUFXLE1BQU0sQ0FBckIsRUFBd0I7QUFDcEIseUJBQUssWUFBTCxDQUFrQixPQUFsQixJQUE2QixDQUE3QjtBQUNBO0FBQ0gsaUJBSEQsTUFHTztBQUNILDJCQUFPLEdBQVAsQ0FBVyxNQUFYLEVBQW1CLE1BQU0sbUJBQW1CLENBQUMsU0FBUyxDQUFULENBQUQsRUFBYyxTQUFTLElBQUUsQ0FBWCxDQUFkLENBQW5CLENBQU4sR0FBd0QsUUFBeEQsR0FBbUUsbUJBQW1CLENBQUMsQ0FBRCxFQUFJLENBQUosQ0FBbkIsQ0FBbkUsR0FBZ0csR0FBbkg7QUFDSDtBQUNELDJCQUFXLEtBQUssUUFBTCxDQUFjLENBQWQsRUFBaUIsQ0FBakIsQ0FBWDtBQUNBLG9CQUFJLENBQUMsUUFBTCxFQUFlO0FBQ1gsK0JBQVcsS0FBSyxXQUFMLENBQWlCLENBQWpCLEVBQW9CLENBQXBCLENBQVg7QUFDSDtBQUNELG9CQUFJLENBQUMsUUFBTCxFQUFlO0FBQ1gsK0JBQVcsS0FBSyxRQUFMLENBQWMsQ0FBZCxFQUFpQixDQUFqQixDQUFYO0FBQ0g7QUFDRCxvQkFBSSxDQUFDLFFBQUwsRUFBZTtBQUNYLCtCQUFXLEtBQUsseUJBQUwsQ0FBK0IsQ0FBL0IsRUFBa0MsQ0FBbEMsQ0FBWDtBQUNIO0FBQ0Qsb0JBQUksQ0FBQyxRQUFMLEVBQWU7QUFDWCxpQ0FBYSxLQUFLLFVBQUwsQ0FBZ0IsQ0FBaEIsRUFBbUIsQ0FBbkIsQ0FBYjtBQUNBLHdCQUFJLFVBQUosRUFBZ0I7QUFDWiw0QkFBSSxLQUFLLFFBQUwsSUFBaUIsS0FBSyxRQUFMLElBQWdCLENBQXJDLEVBQXdDO0FBQ3BDLGdDQUFJLFVBQVUsS0FBSyxRQUFMLENBQWMsS0FBSyxRQUFMLEdBQWMsQ0FBNUIsQ0FBZDtBQUNBLG9DQUFRLFdBQVIsQ0FBb0IsVUFBcEI7QUFDSCx5QkFIRCxNQUdPO0FBQ0gsbUNBQU8sR0FBUCxDQUFXLFNBQVgsRUFBc0Isa0NBQXRCO0FBQ0g7QUFDSjtBQUNKO0FBQ0Qsb0JBQUksUUFBSixFQUFjO0FBQ1YseUJBQUssWUFBTCxDQUFrQixHQUFsQixJQUF5QixDQUF6QjtBQUNILGlCQUZELE1BRU8sSUFBSSxVQUFKLEVBQWdCO0FBQ25CLHlCQUFLLFlBQUwsQ0FBa0IsSUFBbEIsSUFBMEIsQ0FBMUI7QUFDSCxpQkFGTSxNQUVBO0FBQ0gseUJBQUssWUFBTCxDQUFrQixLQUFsQixJQUEyQixDQUEzQjtBQUNBLDJCQUFPLEdBQVAsQ0FBVyxTQUFYLEVBQXNCLGtDQUFrQyxtQkFBbUIsQ0FBQyxDQUFELEVBQUksQ0FBSixDQUFuQixDQUFsQyxHQUNWLFNBRFUsR0FDRSxtQkFBbUIsQ0FBQyxTQUFTLENBQVQsQ0FBRCxFQUFjLFNBQVMsSUFBRSxDQUFYLENBQWQsQ0FBbkIsQ0FEeEI7QUFFSDtBQUNKO0FBQ0o7O0FBRUQ7Ozs7Ozs7aUNBSVMsQyxFQUFHLEMsRUFBRztBQUNYLGdCQUFJLE9BQU8sSUFBWDs7QUFFQSxnQkFBSSxRQUFRLENBQUMsTUFBTSxJQUFOLElBQWMsTUFBTSxJQUFyQixLQUErQixRQUFRLENBQVIsSUFBYSxLQUFLLElBQTdEO0FBQ0EsZ0JBQUksUUFBUSxDQUFDLE1BQU0sSUFBTixJQUFjLE1BQU0sSUFBckIsS0FBK0IsUUFBUSxDQUFSLElBQWEsS0FBSyxJQUE3RDtBQUNBLGdCQUFJLEVBQUUsU0FBUyxLQUFYLENBQUosRUFBdUI7QUFDbkIsdUJBQU8sS0FBUDtBQUNIOztBQUVELGdCQUFJLE1BQU0sS0FBSyxRQUFYLElBQXVCLE1BQU0sS0FBSyxRQUF0QyxFQUFnRDtBQUM1QyxxQkFBSyxRQUFMLEdBQWdCLElBQWhCO0FBQ0EscUJBQUssUUFBTCxHQUFnQixJQUFoQixDQUY0QyxDQUV0QjtBQUN0Qix1QkFBTyxHQUFQLENBQVcsT0FBWCxFQUFvQix1QkFBdUIsbUJBQW1CLENBQUMsQ0FBRCxFQUFJLENBQUosQ0FBbkIsQ0FBdkIsR0FBb0QsY0FBeEU7QUFDQSx1QkFBTyxJQUFQO0FBQ0g7O0FBRUQsZ0JBQUksTUFBTSxJQUFOLElBQWMsTUFBTSxJQUF4QixFQUE4QjtBQUMxQix1QkFBTyxDQUFQO0FBQ0gsYUFGRCxNQUVPO0FBQ0gsdUJBQU8sQ0FBUCxDQURHLENBQ087QUFDYjs7QUFFRCxnQkFBSSxVQUFVLEtBQUssUUFBTCxDQUFjLE9BQU8sQ0FBckIsQ0FBZDs7QUFFQSxnQkFBSSxNQUFNLElBQU4sSUFBYyxNQUFNLElBQXhCLEVBQThCO0FBQzFCLG9CQUFJLE1BQU0sSUFBVixFQUFnQjtBQUNaLDRCQUFRLEtBQVI7QUFDSCxpQkFGRCxNQUVPLElBQUksTUFBTSxJQUFWLEVBQWdCO0FBQ25CLDRCQUFRLElBQVI7QUFDSCxpQkFGTSxNQUVBLElBQUksTUFBTSxJQUFWLEVBQWdCO0FBQ25CLDRCQUFRLEtBQVI7QUFDSCxpQkFGTSxNQUVBLElBQUksTUFBTSxJQUFWLEVBQWdCO0FBQ25CLDRCQUFRLEtBQVI7QUFDSCxpQkFGTSxNQUVBLElBQUksTUFBTSxJQUFWLEVBQWdCO0FBQ25CLDRCQUFRLEtBQVI7QUFDSCxpQkFGTSxNQUVBLElBQUksTUFBTSxJQUFWLEVBQWdCO0FBQ25CLDRCQUFRLElBQVIsQ0FBYSxDQUFiO0FBQ0gsaUJBRk0sTUFFQSxJQUFJLE1BQU0sSUFBVixFQUFnQjtBQUNuQiw0QkFBUSxJQUFSLENBQWEsQ0FBYjtBQUNILGlCQUZNLE1BRUEsSUFBSSxNQUFNLElBQVYsRUFBZ0I7QUFDbkIsNEJBQVEsSUFBUixDQUFhLENBQWI7QUFDSCxpQkFGTSxNQUVBLElBQUksTUFBTSxJQUFWLEVBQWdCO0FBQ25CLDRCQUFRLEtBQVI7QUFDSCxpQkFGTSxNQUVBLElBQUksTUFBTSxJQUFWLEVBQWdCO0FBQ25CLDRCQUFRLEtBQVI7QUFDSCxpQkFGTSxNQUVBLElBQUksTUFBTSxJQUFWLEVBQWdCO0FBQ25CLDRCQUFRLElBQVI7QUFDSCxpQkFGTSxNQUVBLElBQUksTUFBTSxJQUFWLEVBQWdCO0FBQ25CLDRCQUFRLEtBQVI7QUFDSCxpQkFGTSxNQUVBLElBQUksTUFBTSxJQUFWLEVBQWdCO0FBQ25CLDRCQUFRLEtBQVI7QUFDSCxpQkFGTSxNQUVBLElBQUksTUFBTSxJQUFWLEVBQWdCO0FBQ25CLDRCQUFRLElBQVI7QUFDSCxpQkFGTSxNQUVBLElBQUksTUFBTSxJQUFWLEVBQWdCO0FBQ25CLDRCQUFRLEtBQVI7QUFDSCxpQkFGTSxNQUVBLElBQUksTUFBTSxJQUFWLEVBQWdCO0FBQ25CLDRCQUFRLEtBQVI7QUFDSDtBQUNKLGFBbENELE1Ba0NPO0FBQUU7QUFDTCx3QkFBUSxJQUFSLENBQWEsSUFBSSxJQUFqQjtBQUNIO0FBQ0QsaUJBQUssUUFBTCxHQUFnQixDQUFoQjtBQUNBLGlCQUFLLFFBQUwsR0FBZ0IsQ0FBaEI7QUFDQSxpQkFBSyxRQUFMLEdBQWdCLElBQWhCO0FBQ0EsbUJBQU8sSUFBUDtBQUNIOztBQUVEOzs7Ozs7O29DQUlZLEMsRUFBRyxDLEVBQUc7QUFDZCxnQkFBSSxPQUFPLElBQVg7O0FBRUEsZ0JBQUssQ0FBRSxNQUFNLElBQVAsSUFBaUIsTUFBTSxJQUF4QixLQUFrQyxRQUFRLENBQTFDLElBQStDLEtBQUssSUFBekQsRUFBK0Q7QUFDM0Qsb0JBQUksTUFBTSxJQUFWLEVBQWdCO0FBQ1osMkJBQU8sQ0FBUDtBQUNILGlCQUZELE1BRVE7QUFDSiwyQkFBTyxDQUFQO0FBQ0g7QUFDRCxvQkFBSSxTQUFTLEtBQUssUUFBbEIsRUFBNEI7QUFDeEIsMkJBQU8sR0FBUCxDQUFXLE9BQVgsRUFBb0Isb0NBQXBCO0FBQ0EsMkJBQU8sS0FBUDtBQUNIO0FBQ0Qsb0JBQUksVUFBVSxLQUFLLFFBQUwsQ0FBYyxPQUFLLENBQW5CLENBQWQ7QUFDQSx3QkFBUSxRQUFSLENBQWlCLENBQWpCO0FBQ0EsdUJBQU8sR0FBUCxDQUFXLE9BQVgsRUFBb0IsYUFBYSxtQkFBbUIsQ0FBQyxDQUFELEVBQUksQ0FBSixDQUFuQixDQUFiLEdBQTBDLEdBQTlEO0FBQ0EsdUJBQU8sSUFBUDtBQUNIO0FBQ0QsbUJBQU8sS0FBUDtBQUNIO0FBQ0Q7Ozs7Ozs7aUNBSVMsQyxFQUFHLEMsRUFBRzs7QUFFWixnQkFBSSxPQUFPLElBQVg7QUFDQSxnQkFBSSxNQUFNLElBQVY7O0FBRUMsZ0JBQUksUUFBUSxDQUFFLFFBQVEsQ0FBUixJQUFjLEtBQUssSUFBcEIsSUFBOEIsUUFBUSxDQUFSLElBQWEsS0FBSyxJQUFqRCxLQUE0RCxRQUFRLENBQVIsSUFBYSxLQUFLLElBQTFGO0FBQ0EsZ0JBQUksUUFBUSxDQUFDLE1BQU0sSUFBTixJQUFjLE1BQU0sSUFBckIsS0FBK0IsUUFBUSxDQUFSLElBQWEsS0FBSyxJQUE3RDtBQUNBLGdCQUFJLEVBQUcsU0FBUyxLQUFaLENBQUosRUFBd0I7QUFDcEIsdUJBQU8sS0FBUDtBQUNIOztBQUVELGdCQUFJLE1BQU0sS0FBSyxRQUFYLElBQXVCLE1BQU0sS0FBSyxRQUF0QyxFQUFnRDtBQUM1QyxxQkFBSyxRQUFMLEdBQWdCLElBQWhCO0FBQ0EscUJBQUssUUFBTCxHQUFnQixJQUFoQjtBQUNBLHVCQUFPLElBQVAsQ0FINEMsQ0FHL0I7QUFDaEI7O0FBRUQsbUJBQVEsS0FBSyxJQUFOLEdBQWMsQ0FBZCxHQUFrQixDQUF6Qjs7QUFFQSxnQkFBSSxRQUFRLENBQVIsSUFBYSxLQUFLLElBQXRCLEVBQTRCO0FBQ3hCLHNCQUFPLFNBQVMsQ0FBVixHQUFlLFdBQVcsQ0FBWCxDQUFmLEdBQStCLFdBQVcsQ0FBWCxDQUFyQztBQUNILGFBRkQsTUFFTztBQUFFO0FBQ0wsc0JBQU8sU0FBUyxDQUFWLEdBQWUsWUFBWSxDQUFaLENBQWYsR0FBZ0MsWUFBWSxDQUFaLENBQXRDO0FBQ0g7QUFDRCxnQkFBSSxVQUFVLEtBQUssWUFBTCxDQUFrQixHQUFsQixFQUF1QixDQUF2QixDQUFkO0FBQ0EsZ0JBQUksVUFBVSxLQUFLLFFBQUwsQ0FBYyxPQUFLLENBQW5CLENBQWQ7QUFDQSxvQkFBUSxNQUFSLENBQWUsT0FBZjtBQUNBLGlCQUFLLFFBQUwsR0FBZ0IsQ0FBaEI7QUFDQSxpQkFBSyxRQUFMLEdBQWdCLENBQWhCO0FBQ0EsaUJBQUssUUFBTCxHQUFnQixJQUFoQjtBQUNBLG1CQUFPLElBQVA7QUFDSDs7QUFFRDs7Ozs7OztxQ0FJYSxHLEVBQUssSSxFQUFNO0FBQ3BCLGdCQUFJLFdBQVcsSUFBZjtBQUNBLGdCQUFJLFVBQVUsRUFBQyxPQUFRLElBQVQsRUFBZSxTQUFVLEtBQXpCLEVBQWdDLFFBQVMsSUFBekMsRUFBK0MsV0FBWSxLQUEzRCxFQUFrRSxLQUFNLEdBQXhFLEVBQWQ7O0FBRUEsZ0JBQUksT0FBTyxJQUFYLEVBQWlCO0FBQ2IsMkJBQVcsT0FBTyxJQUFsQjtBQUNILGFBRkQsTUFFTztBQUNILDJCQUFXLE9BQU8sSUFBbEI7QUFDSDtBQUNELG9CQUFRLFNBQVIsR0FBb0IsQ0FBQyxXQUFXLENBQVosTUFBbUIsQ0FBdkM7QUFDQSxnQkFBSSxZQUFZLEdBQWhCLEVBQXFCO0FBQ2pCLHdCQUFRLEtBQVIsR0FBZ0IsQ0FBQyxPQUFELEVBQVUsT0FBVixFQUFtQixNQUFuQixFQUEyQixNQUEzQixFQUFtQyxLQUFuQyxFQUEwQyxRQUExQyxFQUFvRCxTQUFwRCxFQUErRCxPQUEvRCxFQUF3RSxLQUFLLEtBQUwsQ0FBVyxXQUFTLENBQXBCLENBQXhFLENBQWhCO0FBQ0gsYUFGRCxNQUVPLElBQUksWUFBWSxHQUFoQixFQUFxQjtBQUN4Qix3QkFBUSxPQUFSLEdBQWtCLElBQWxCO0FBQ0Esd0JBQVEsS0FBUixHQUFnQixPQUFoQjtBQUNILGFBSE0sTUFHQTtBQUNILHdCQUFRLE1BQVIsR0FBa0IsS0FBSyxLQUFMLENBQVcsQ0FBQyxXQUFTLElBQVYsSUFBZ0IsQ0FBM0IsQ0FBRCxHQUFnQyxDQUFqRDtBQUNIO0FBQ0QsbUJBQU8sT0FBUCxDQWxCb0IsQ0FrQko7QUFDbkI7O0FBRUQ7Ozs7Ozs7bUNBSVcsQyxFQUFHLEMsRUFBRzs7QUFFZCxnQkFBSyxZQUFZLElBQWpCO0FBQUEsZ0JBQ0ssWUFBWSxJQURqQjtBQUFBLGdCQUVLLFlBQVksSUFGakI7O0FBSUMsZ0JBQUksS0FBSyxJQUFULEVBQWU7QUFDWCw0QkFBWSxDQUFaO0FBQ0EsNEJBQVksSUFBSSxDQUFoQjtBQUNILGFBSEQsTUFHTztBQUNILDRCQUFZLENBQVo7QUFDQSw0QkFBWSxDQUFaO0FBQ0g7QUFDRCxnQkFBSSxRQUFRLFNBQVIsSUFBcUIsYUFBYSxJQUF0QyxFQUE0QztBQUN4QztBQUNBLG9CQUFJLFVBQVUsQ0FBZDtBQUNBLG9CQUFJLGNBQWMsSUFBbEIsRUFBd0I7QUFDcEIsOEJBQVUsSUFBSSxJQUFkO0FBQ0gsaUJBRkQsTUFFTyxJQUFJLGNBQWMsSUFBbEIsRUFBd0I7QUFDM0IsOEJBQVUsSUFBSSxJQUFkO0FBQ0gsaUJBRk0sTUFFQTtBQUNILDhCQUFVLElBQUksSUFBZDtBQUNIO0FBQ0QsdUJBQU8sR0FBUCxDQUFXLE1BQVgsRUFBbUIsb0JBQW9CLGVBQWUsT0FBZixDQUFwQixHQUE4QyxnQkFBOUMsR0FBaUUsU0FBcEY7QUFDQSw0QkFBWSxDQUFDLE9BQUQsQ0FBWjtBQUNILGFBWkQsTUFZTyxJQUFJLFFBQVEsQ0FBUixJQUFhLEtBQUssSUFBdEIsRUFBNEI7QUFDL0IsNEJBQWEsTUFBTSxDQUFQLEdBQVksQ0FBQyxDQUFELENBQVosR0FBa0IsQ0FBQyxDQUFELEVBQUksQ0FBSixDQUE5QjtBQUNIO0FBQ0QsZ0JBQUksU0FBSixFQUFlO0FBQ1gsb0JBQUksV0FBVyxtQkFBbUIsU0FBbkIsQ0FBZjtBQUNBLHVCQUFPLEdBQVAsQ0FBVyxPQUFYLEVBQW9CLG1CQUFtQixTQUFTLElBQVQsQ0FBYyxHQUFkLENBQXZDO0FBQ0EscUJBQUssUUFBTCxHQUFnQixJQUFoQjtBQUNBLHFCQUFLLFFBQUwsR0FBZ0IsSUFBaEI7QUFDSDtBQUNELG1CQUFPLFNBQVA7QUFDSDs7QUFFRDs7Ozs7OztrREFJMEIsQyxFQUFHLEMsRUFBRztBQUM3QixnQkFBSyxPQUFMLEVBQ0ssS0FETCxFQUVLLElBRkwsRUFHSyxPQUhMOztBQUtDLGdCQUFJLFFBQVEsQ0FBQyxNQUFNLElBQU4sSUFBYyxNQUFNLElBQXJCLEtBQStCLFFBQVEsQ0FBUixJQUFhLEtBQUssSUFBN0Q7QUFDQSxnQkFBSSxRQUFRLENBQUMsTUFBTSxJQUFOLElBQWMsTUFBTSxJQUFyQixLQUErQixRQUFPLENBQVAsSUFBWSxLQUFLLElBQTVEO0FBQ0EsZ0JBQUksRUFBRSxTQUFTLEtBQVgsQ0FBSixFQUF1QjtBQUNuQix1QkFBTyxLQUFQO0FBQ0g7QUFDRCxzQkFBVSxFQUFWO0FBQ0EsZ0JBQUksTUFBTyxJQUFQLElBQWUsTUFBTSxJQUF6QixFQUErQjtBQUMzQix3QkFBUSxLQUFLLEtBQUwsQ0FBVyxDQUFDLElBQUUsSUFBSCxJQUFTLENBQXBCLENBQVI7QUFDQSx3QkFBUSxVQUFSLEdBQXFCLGlCQUFpQixLQUFqQixDQUFyQjtBQUNBLG9CQUFJLElBQUksQ0FBSixLQUFVLENBQWQsRUFBaUI7QUFDYiw0QkFBUSxVQUFSLEdBQXFCLFFBQVEsVUFBUixHQUFxQixPQUExQztBQUNIO0FBQ0osYUFORCxNQU1PLElBQUksTUFBTSxJQUFWLEVBQWdCO0FBQ25CLHdCQUFRLFVBQVIsR0FBcUIsYUFBckI7QUFDSCxhQUZNLE1BRUE7QUFDSCx3QkFBUSxVQUFSLEdBQXFCLE9BQXJCO0FBQ0Esb0JBQUksTUFBTSxJQUFWLEVBQWdCO0FBQ1osNEJBQVEsU0FBUixHQUFvQixJQUFwQjtBQUNIO0FBQ0o7QUFDRCxtQkFBUSxJQUFJLElBQUwsR0FBYSxDQUFiLEdBQWlCLENBQXhCO0FBQ0Esc0JBQVUsS0FBSyxRQUFMLENBQWMsT0FBSyxDQUFuQixDQUFWO0FBQ0Esb0JBQVEsVUFBUixDQUFtQixPQUFuQjtBQUNBLGlCQUFLLFFBQUwsR0FBZ0IsSUFBaEI7QUFDQSxpQkFBSyxRQUFMLEdBQWdCLElBQWhCO0FBQ0EsbUJBQU8sSUFBUDtBQUNIOztBQUVEOzs7Ozs7Z0NBR1E7QUFDSixpQkFBSyxJQUFJLElBQUUsQ0FBWCxFQUFlLElBQUksS0FBSyxRQUFMLENBQWMsTUFBakMsRUFBMEMsR0FBMUMsRUFBK0M7QUFDM0Msb0JBQUksS0FBSyxRQUFMLENBQWMsQ0FBZCxDQUFKLEVBQXNCO0FBQ2xCLHlCQUFLLFFBQUwsQ0FBYyxDQUFkLEVBQWlCLEtBQWpCO0FBQ0g7QUFDSjtBQUNELGlCQUFLLFFBQUwsR0FBZ0IsSUFBaEI7QUFDQSxpQkFBSyxRQUFMLEdBQWdCLElBQWhCO0FBQ0g7O0FBRUQ7Ozs7Ozt1Q0FHZSxDLEVBQUc7QUFDZCxpQkFBSyxJQUFJLElBQUUsQ0FBWCxFQUFlLElBQUksS0FBSyxRQUFMLENBQWMsTUFBakMsRUFBMEMsR0FBMUMsRUFBK0M7QUFDM0Msb0JBQUksS0FBSyxRQUFMLENBQWMsQ0FBZCxDQUFKLEVBQXNCO0FBQ2xCLHlCQUFLLFFBQUwsQ0FBYyxDQUFkLEVBQWlCLGNBQWpCLENBQWdDLENBQWhDO0FBQ0g7QUFDSjtBQUNKOzs7Ozs7a0JBR1UsWTs7Ozs7QUN4b0NmOztBQUVBLElBQU0sT0FBTzs7QUFFWCxVQUFRLGdCQUFTLEtBQVQsRUFBZ0IsU0FBaEIsRUFBMkIsT0FBM0IsRUFBb0MsYUFBcEMsRUFBbUQ7QUFDekQsUUFBSSxHQUFKO0FBQ0EsUUFBSSxHQUFKO0FBQ0EsUUFBSSxTQUFKO0FBQ0EsUUFBSSxNQUFKO0FBQ0EsUUFBSSxJQUFKO0FBQ0EsUUFBSSxTQUFTLE9BQU8sTUFBUCxJQUFpQixPQUFPLFlBQXJDOztBQUVBLFNBQUssSUFBSSxJQUFFLENBQVgsRUFBYyxJQUFFLGNBQWMsSUFBZCxDQUFtQixNQUFuQyxFQUEyQyxHQUEzQyxFQUNBO0FBQ0UsWUFBTSxjQUFjLElBQWQsQ0FBbUIsQ0FBbkIsQ0FBTjtBQUNBLGtCQUFZLElBQVo7QUFDQSxlQUFTLENBQVQ7QUFDQSxhQUFPLEVBQVA7O0FBRUEsVUFBSSxDQUFDLElBQUksT0FBSixFQUFMLEVBQ0E7QUFDRSxhQUFLLElBQUksSUFBRSxDQUFYLEVBQWMsSUFBRSxJQUFJLEtBQUosQ0FBVSxNQUExQixFQUFrQyxHQUFsQyxFQUNBO0FBQ0UsY0FBSSxJQUFJLEtBQUosQ0FBVSxDQUFWLEVBQWEsS0FBYixDQUFtQixLQUFuQixDQUF5QixJQUF6QixLQUFrQyxTQUF0QyxFQUNBO0FBQ0U7QUFDRCxXQUhELE1BS0E7QUFDRSxvQkFBUSxJQUFJLEtBQUosQ0FBVSxDQUFWLEVBQWEsS0FBckI7QUFDQSx3QkFBWSxLQUFaO0FBQ0Q7QUFDRjtBQUNEO0FBQ0EsWUFBSSxZQUFKLEdBQW1CLFNBQW5CO0FBQ0EsY0FBTSxJQUFJLE1BQUosQ0FBVyxTQUFYLEVBQXNCLE9BQXRCLEVBQStCLDhCQUFjLEtBQUssSUFBTCxFQUFkLENBQS9CLENBQU47O0FBRUEsWUFBSSxVQUFVLEVBQWQsRUFDQTtBQUNFO0FBQ0QsU0FIRCxNQUtBO0FBQ0U7QUFDRDs7QUFFRDtBQUNBO0FBQ0EsWUFBSSxVQUFVLFNBQVYsQ0FBb0IsS0FBcEIsQ0FBMEIsV0FBMUIsQ0FBSixFQUNBO0FBQ0UsY0FBSSxJQUFKLEdBQVcsSUFBSSxDQUFmO0FBQ0QsU0FIRCxNQUtBO0FBQ0UsY0FBSSxJQUFKLEdBQVksSUFBSSxDQUFKLEdBQVEsSUFBSSxDQUFaLEdBQWdCLElBQUksQ0FBaEM7QUFDRDtBQUNELFlBQUksS0FBSixHQUFZLE1BQVo7QUFDQTtBQUNBLFlBQUksUUFBSixHQUFlLEtBQUssR0FBTCxDQUFTLENBQVQsRUFBWSxLQUFLLEdBQUwsQ0FBUyxHQUFULEVBQWMsT0FBTyxTQUFTLEVBQWhCLEtBQXVCLFVBQVUsU0FBVixDQUFvQixLQUFwQixDQUEwQixXQUExQixJQUF5QyxFQUF6QyxHQUE4QyxDQUFyRSxDQUFkLENBQVosQ0FBZjtBQUNBLGNBQU0sTUFBTixDQUFhLEdBQWI7QUFDRDtBQUNGO0FBQ0Y7O0FBNURVLENBQWI7O0FBZ0VBLE9BQU8sT0FBUCxHQUFpQixJQUFqQjs7Ozs7Ozs7Ozs7OztBQ2xFQTs7Ozs7O0lBTU0sSTs7QUFFTDtBQUNDLGdCQUFZLFFBQVosRUFBc0I7QUFBQTs7QUFDcEI7QUFDQSxTQUFLLE1BQUwsR0FBYyxXQUFXLEtBQUssR0FBTCxDQUFTLEtBQUssR0FBTCxDQUFTLEdBQVQsSUFBZ0IsUUFBekIsQ0FBWCxHQUFnRCxDQUE5RDtBQUNBLFNBQUssU0FBTCxHQUFpQixDQUFqQjtBQUNBLFNBQUssWUFBTCxHQUFvQixDQUFwQjtBQUNEOzs7OzJCQUVNLE0sRUFBTyxLLEVBQU87QUFDbkIsVUFBSSxXQUFXLEtBQUssR0FBTCxDQUFTLEtBQUssTUFBZCxFQUFzQixNQUF0QixDQUFmO0FBQ0EsV0FBSyxTQUFMLEdBQWlCLFNBQVMsSUFBSSxRQUFiLElBQXlCLFdBQVcsS0FBSyxTQUExRDtBQUNBLFdBQUssWUFBTCxJQUFxQixNQUFyQjtBQUNEOzs7cUNBRWdCO0FBQ2YsYUFBTyxLQUFLLFlBQVo7QUFDRDs7O2tDQUVhO0FBQ1osVUFBSSxLQUFLLE1BQVQsRUFBaUI7QUFDZixZQUFJLGFBQWEsSUFBSSxLQUFLLEdBQUwsQ0FBUyxLQUFLLE1BQWQsRUFBc0IsS0FBSyxZQUEzQixDQUFyQjtBQUNBLGVBQU8sS0FBSyxTQUFMLEdBQWlCLFVBQXhCO0FBQ0QsT0FIRCxNQUdPO0FBQ0wsZUFBTyxLQUFLLFNBQVo7QUFDRDtBQUNGOzs7Ozs7a0JBR1ksSTs7O0FDcENmOzs7Ozs7OztBQUVBLFNBQVMsSUFBVCxHQUFnQixDQUFFOztBQUVsQixJQUFNLGFBQWE7QUFDakIsU0FBTyxJQURVO0FBRWpCLFNBQU8sSUFGVTtBQUdqQixPQUFLLElBSFk7QUFJakIsUUFBTSxJQUpXO0FBS2pCLFFBQU0sSUFMVztBQU1qQixTQUFPO0FBTlUsQ0FBbkI7O0FBU0EsSUFBSSxpQkFBaUIsVUFBckI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTLFNBQVQsQ0FBbUIsSUFBbkIsRUFBeUIsR0FBekIsRUFBOEI7QUFDNUIsUUFBTSxNQUFPLElBQVAsR0FBYyxNQUFkLEdBQXVCLEdBQTdCO0FBQ0EsU0FBTyxHQUFQO0FBQ0Q7O0FBRUQsU0FBUyxjQUFULENBQXdCLElBQXhCLEVBQThCO0FBQzVCLE1BQU0sT0FBTyxLQUFLLE9BQUwsQ0FBYSxJQUFiLENBQWI7QUFDQSxNQUFJLElBQUosRUFBVTtBQUNSLFdBQU8sWUFBa0I7QUFBQSx3Q0FBTixJQUFNO0FBQU4sWUFBTTtBQUFBOztBQUN2QixVQUFHLEtBQUssQ0FBTCxDQUFILEVBQVk7QUFDVixhQUFLLENBQUwsSUFBVSxVQUFVLElBQVYsRUFBZ0IsS0FBSyxDQUFMLENBQWhCLENBQVY7QUFDRDtBQUNELFdBQUssS0FBTCxDQUFXLEtBQUssT0FBaEIsRUFBeUIsSUFBekI7QUFDRCxLQUxEO0FBTUQ7QUFDRCxTQUFPLElBQVA7QUFDRDs7QUFFRCxTQUFTLHFCQUFULENBQStCLFdBQS9CLEVBQTBEO0FBQUEscUNBQVgsU0FBVztBQUFYLGFBQVc7QUFBQTs7QUFDeEQsWUFBVSxPQUFWLENBQWtCLFVBQVMsSUFBVCxFQUFlO0FBQy9CLG1CQUFlLElBQWYsSUFBdUIsWUFBWSxJQUFaLElBQW9CLFlBQVksSUFBWixFQUFrQixJQUFsQixDQUF1QixXQUF2QixDQUFwQixHQUEwRCxlQUFlLElBQWYsQ0FBakY7QUFDRCxHQUZEO0FBR0Q7O0FBRU0sSUFBSSxrQ0FBYSxTQUFiLFVBQWEsQ0FBUyxXQUFULEVBQXNCO0FBQzVDLE1BQUksZ0JBQWdCLElBQWhCLElBQXdCLFFBQU8sV0FBUCx5Q0FBTyxXQUFQLE9BQXVCLFFBQW5ELEVBQTZEO0FBQzNELDBCQUFzQixXQUF0QjtBQUNFO0FBQ0E7QUFDQSxXQUhGLEVBSUUsS0FKRixFQUtFLE1BTEYsRUFNRSxNQU5GLEVBT0UsT0FQRjtBQVNBO0FBQ0E7QUFDQSxRQUFJO0FBQ0gscUJBQWUsR0FBZjtBQUNBLEtBRkQsQ0FFRSxPQUFPLENBQVAsRUFBVTtBQUNWLHVCQUFpQixVQUFqQjtBQUNEO0FBQ0YsR0FqQkQsTUFrQks7QUFDSCxxQkFBaUIsVUFBakI7QUFDRDtBQUNGLENBdEJNOztBQXdCQSxJQUFJLDBCQUFTLGNBQWI7Ozs7Ozs7Ozs7Ozs7QUMxRVA7Ozs7SUFJTSxVOzs7Ozs7OzZCQUNZLEMsRUFBRztBQUNqQixVQUFJLE1BQU0sRUFBVjtBQUFBLFVBQWMsTUFBTSxFQUFFLE1BQXRCO0FBQ0EsV0FBSyxJQUFJLElBQUUsQ0FBWCxFQUFjLElBQUUsR0FBaEIsRUFBcUIsR0FBckIsRUFBMEI7QUFDeEIsZUFBTyxNQUFNLEVBQUUsS0FBRixDQUFRLENBQVIsRUFBVyxPQUFYLENBQW1CLENBQW5CLENBQU4sR0FBOEIsR0FBOUIsR0FBb0MsRUFBRSxHQUFGLENBQU0sQ0FBTixFQUFTLE9BQVQsQ0FBaUIsQ0FBakIsQ0FBcEMsR0FBMEQsR0FBakU7QUFDRDtBQUNELGFBQU8sR0FBUDtBQUNEOzs7Ozs7a0JBR1ksVTs7Ozs7Ozs7O0FDZGY7Ozs7Ozs7Ozs7Ozs7Ozs7a0JBZ0JnQixZQUFXO0FBQ3pCLE1BQUksT0FBTyxNQUFQLEtBQWtCLFdBQWxCLElBQWlDLE9BQU8sTUFBNUMsRUFBb0Q7QUFDbEQsV0FBTyxPQUFPLE1BQWQ7QUFDRDs7QUFFRCxNQUFJLGNBQWMsTUFBbEI7QUFDQSxNQUFJLG1CQUFtQjtBQUNyQixRQUFJLElBRGlCO0FBRXJCLFFBQUksSUFGaUI7QUFHckIsUUFBSTtBQUhpQixHQUF2QjtBQUtBLE1BQUksZUFBZTtBQUNqQixXQUFPLElBRFU7QUFFakIsWUFBUSxJQUZTO0FBR2pCLFNBQUssSUFIWTtBQUlqQixVQUFNLElBSlc7QUFLakIsV0FBTztBQUxVLEdBQW5COztBQVFBLFdBQVMsb0JBQVQsQ0FBOEIsS0FBOUIsRUFBcUM7QUFDbkMsUUFBSSxPQUFPLEtBQVAsS0FBaUIsUUFBckIsRUFBK0I7QUFDN0IsYUFBTyxLQUFQO0FBQ0Q7QUFDRCxRQUFJLE1BQU0saUJBQWlCLE1BQU0sV0FBTixFQUFqQixDQUFWO0FBQ0EsV0FBTyxNQUFNLE1BQU0sV0FBTixFQUFOLEdBQTRCLEtBQW5DO0FBQ0Q7O0FBRUQsV0FBUyxnQkFBVCxDQUEwQixLQUExQixFQUFpQztBQUMvQixRQUFJLE9BQU8sS0FBUCxLQUFpQixRQUFyQixFQUErQjtBQUM3QixhQUFPLEtBQVA7QUFDRDtBQUNELFFBQUksUUFBUSxhQUFhLE1BQU0sV0FBTixFQUFiLENBQVo7QUFDQSxXQUFPLFFBQVEsTUFBTSxXQUFOLEVBQVIsR0FBOEIsS0FBckM7QUFDRDs7QUFFRCxXQUFTLE1BQVQsQ0FBZ0IsR0FBaEIsRUFBcUI7QUFDbkIsUUFBSSxJQUFJLENBQVI7QUFDQSxXQUFPLElBQUksVUFBVSxNQUFyQixFQUE2QixHQUE3QixFQUFrQztBQUNoQyxVQUFJLE9BQU8sVUFBVSxDQUFWLENBQVg7QUFDQSxXQUFLLElBQUksQ0FBVCxJQUFjLElBQWQsRUFBb0I7QUFDbEIsWUFBSSxDQUFKLElBQVMsS0FBSyxDQUFMLENBQVQ7QUFDRDtBQUNGOztBQUVELFdBQU8sR0FBUDtBQUNEOztBQUVELFdBQVMsTUFBVCxDQUFnQixTQUFoQixFQUEyQixPQUEzQixFQUFvQyxJQUFwQyxFQUEwQztBQUN4QyxRQUFJLE1BQU0sSUFBVjtBQUNBLFFBQUksUUFBUyxZQUFZO0FBQ3ZCLFVBQUksT0FBTyxTQUFQLEtBQXFCLFdBQXpCLEVBQXNDO0FBQ3BDO0FBQ0Q7QUFDRCxhQUFRLGFBQUQsQ0FBZSxJQUFmLENBQW9CLFVBQVUsU0FBOUI7QUFBUDtBQUNELEtBTFcsRUFBWjtBQU1BLFFBQUksVUFBVSxFQUFkOztBQUVBLFFBQUksS0FBSixFQUFXO0FBQ1QsWUFBTSxTQUFTLGFBQVQsQ0FBdUIsUUFBdkIsQ0FBTjtBQUNELEtBRkQsTUFFTztBQUNMLGNBQVEsVUFBUixHQUFxQixJQUFyQjtBQUNEOztBQUVEOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBLFFBQUksWUFBSixHQUFtQixLQUFuQjs7QUFFQTs7Ozs7QUFLQSxRQUFJLE1BQU0sRUFBVjtBQUNBLFFBQUksZUFBZSxLQUFuQjtBQUNBLFFBQUksYUFBYSxTQUFqQjtBQUNBLFFBQUksV0FBVyxPQUFmO0FBQ0EsUUFBSSxRQUFRLElBQVo7QUFDQSxRQUFJLFVBQVUsSUFBZDtBQUNBLFFBQUksWUFBWSxFQUFoQjtBQUNBLFFBQUksZUFBZSxJQUFuQjtBQUNBLFFBQUksUUFBUSxNQUFaO0FBQ0EsUUFBSSxhQUFhLE9BQWpCO0FBQ0EsUUFBSSxZQUFZLEVBQWhCO0FBQ0EsUUFBSSxpQkFBaUIsUUFBckI7QUFDQSxRQUFJLFFBQVEsRUFBWjtBQUNBLFFBQUksU0FBUyxRQUFiOztBQUVBLFdBQU8sY0FBUCxDQUFzQixHQUF0QixFQUEyQixJQUEzQixFQUFpQyxPQUFPLEVBQVAsRUFBVyxPQUFYLEVBQW9CO0FBQ25ELFdBQUssZUFBWTtBQUNmLGVBQU8sR0FBUDtBQUNELE9BSGtEO0FBSW5ELFdBQUssYUFBVSxLQUFWLEVBQWlCO0FBQ3BCLGNBQU0sS0FBSyxLQUFYO0FBQ0Q7QUFOa0QsS0FBcEIsQ0FBakM7O0FBU0EsV0FBTyxjQUFQLENBQXNCLEdBQXRCLEVBQTJCLGFBQTNCLEVBQTBDLE9BQU8sRUFBUCxFQUFXLE9BQVgsRUFBb0I7QUFDNUQsV0FBSyxlQUFZO0FBQ2YsZUFBTyxZQUFQO0FBQ0QsT0FIMkQ7QUFJNUQsV0FBSyxhQUFVLEtBQVYsRUFBaUI7QUFDcEIsdUJBQWUsQ0FBQyxDQUFDLEtBQWpCO0FBQ0Q7QUFOMkQsS0FBcEIsQ0FBMUM7O0FBU0EsV0FBTyxjQUFQLENBQXNCLEdBQXRCLEVBQTJCLFdBQTNCLEVBQXdDLE9BQU8sRUFBUCxFQUFXLE9BQVgsRUFBb0I7QUFDMUQsV0FBSyxlQUFZO0FBQ2YsZUFBTyxVQUFQO0FBQ0QsT0FIeUQ7QUFJMUQsV0FBSyxhQUFVLEtBQVYsRUFBaUI7QUFDcEIsWUFBSSxPQUFPLEtBQVAsS0FBaUIsUUFBckIsRUFBK0I7QUFDN0IsZ0JBQU0sSUFBSSxTQUFKLENBQWMscUNBQWQsQ0FBTjtBQUNEO0FBQ0QscUJBQWEsS0FBYjtBQUNBLGFBQUssWUFBTCxHQUFvQixJQUFwQjtBQUNEO0FBVnlELEtBQXBCLENBQXhDOztBQWFBLFdBQU8sY0FBUCxDQUFzQixHQUF0QixFQUEyQixTQUEzQixFQUFzQyxPQUFPLEVBQVAsRUFBVyxPQUFYLEVBQW9CO0FBQ3hELFdBQUssZUFBWTtBQUNmLGVBQU8sUUFBUDtBQUNELE9BSHVEO0FBSXhELFdBQUssYUFBVSxLQUFWLEVBQWlCO0FBQ3BCLFlBQUksT0FBTyxLQUFQLEtBQWlCLFFBQXJCLEVBQStCO0FBQzdCLGdCQUFNLElBQUksU0FBSixDQUFjLG1DQUFkLENBQU47QUFDRDtBQUNELG1CQUFXLEtBQVg7QUFDQSxhQUFLLFlBQUwsR0FBb0IsSUFBcEI7QUFDRDtBQVZ1RCxLQUFwQixDQUF0Qzs7QUFhQSxXQUFPLGNBQVAsQ0FBc0IsR0FBdEIsRUFBMkIsTUFBM0IsRUFBbUMsT0FBTyxFQUFQLEVBQVcsT0FBWCxFQUFvQjtBQUNyRCxXQUFLLGVBQVk7QUFDZixlQUFPLEtBQVA7QUFDRCxPQUhvRDtBQUlyRCxXQUFLLGFBQVUsS0FBVixFQUFpQjtBQUNwQixnQkFBUSxLQUFLLEtBQWI7QUFDQSxhQUFLLFlBQUwsR0FBb0IsSUFBcEI7QUFDRDtBQVBvRCxLQUFwQixDQUFuQzs7QUFVQSxXQUFPLGNBQVAsQ0FBc0IsR0FBdEIsRUFBMkIsUUFBM0IsRUFBcUMsT0FBTyxFQUFQLEVBQVcsT0FBWCxFQUFvQjtBQUN2RCxXQUFLLGVBQVk7QUFDZixlQUFPLE9BQVA7QUFDRCxPQUhzRDtBQUl2RCxXQUFLLGFBQVUsS0FBVixFQUFpQjtBQUNwQixrQkFBVSxLQUFWO0FBQ0EsYUFBSyxZQUFMLEdBQW9CLElBQXBCO0FBQ0Q7QUFQc0QsS0FBcEIsQ0FBckM7O0FBVUEsV0FBTyxjQUFQLENBQXNCLEdBQXRCLEVBQTJCLFVBQTNCLEVBQXVDLE9BQU8sRUFBUCxFQUFXLE9BQVgsRUFBb0I7QUFDekQsV0FBSyxlQUFZO0FBQ2YsZUFBTyxTQUFQO0FBQ0QsT0FId0Q7QUFJekQsV0FBSyxhQUFVLEtBQVYsRUFBaUI7QUFDcEIsWUFBSSxVQUFVLHFCQUFxQixLQUFyQixDQUFkO0FBQ0E7QUFDQSxZQUFJLFlBQVksS0FBaEIsRUFBdUI7QUFDckIsZ0JBQU0sSUFBSSxXQUFKLENBQWdCLDZDQUFoQixDQUFOO0FBQ0Q7QUFDRCxvQkFBWSxPQUFaO0FBQ0EsYUFBSyxZQUFMLEdBQW9CLElBQXBCO0FBQ0Q7QUFad0QsS0FBcEIsQ0FBdkM7O0FBZUEsV0FBTyxjQUFQLENBQXNCLEdBQXRCLEVBQTJCLGFBQTNCLEVBQTBDLE9BQU8sRUFBUCxFQUFXLE9BQVgsRUFBb0I7QUFDNUQsV0FBSyxlQUFZO0FBQ2YsZUFBTyxZQUFQO0FBQ0QsT0FIMkQ7QUFJNUQsV0FBSyxhQUFVLEtBQVYsRUFBaUI7QUFDcEIsdUJBQWUsQ0FBQyxDQUFDLEtBQWpCO0FBQ0EsYUFBSyxZQUFMLEdBQW9CLElBQXBCO0FBQ0Q7QUFQMkQsS0FBcEIsQ0FBMUM7O0FBVUEsV0FBTyxjQUFQLENBQXNCLEdBQXRCLEVBQTJCLE1BQTNCLEVBQW1DLE9BQU8sRUFBUCxFQUFXLE9BQVgsRUFBb0I7QUFDckQsV0FBSyxlQUFZO0FBQ2YsZUFBTyxLQUFQO0FBQ0QsT0FIb0Q7QUFJckQsV0FBSyxhQUFVLEtBQVYsRUFBaUI7QUFDcEIsWUFBSSxPQUFPLEtBQVAsS0FBaUIsUUFBakIsSUFBNkIsVUFBVSxXQUEzQyxFQUF3RDtBQUN0RCxnQkFBTSxJQUFJLFdBQUosQ0FBZ0Isb0RBQWhCLENBQU47QUFDRDtBQUNELGdCQUFRLEtBQVI7QUFDQSxhQUFLLFlBQUwsR0FBb0IsSUFBcEI7QUFDRDtBQVZvRCxLQUFwQixDQUFuQzs7QUFhQSxXQUFPLGNBQVAsQ0FBc0IsR0FBdEIsRUFBMkIsV0FBM0IsRUFBd0MsT0FBTyxFQUFQLEVBQVcsT0FBWCxFQUFvQjtBQUMxRCxXQUFLLGVBQVk7QUFDZixlQUFPLFVBQVA7QUFDRCxPQUh5RDtBQUkxRCxXQUFLLGFBQVUsS0FBVixFQUFpQjtBQUNwQixZQUFJLFVBQVUsaUJBQWlCLEtBQWpCLENBQWQ7QUFDQSxZQUFJLENBQUMsT0FBTCxFQUFjO0FBQ1osZ0JBQU0sSUFBSSxXQUFKLENBQWdCLDZDQUFoQixDQUFOO0FBQ0Q7QUFDRCxxQkFBYSxPQUFiO0FBQ0EsYUFBSyxZQUFMLEdBQW9CLElBQXBCO0FBQ0Q7QUFYeUQsS0FBcEIsQ0FBeEM7O0FBY0EsV0FBTyxjQUFQLENBQXNCLEdBQXRCLEVBQTJCLFVBQTNCLEVBQXVDLE9BQU8sRUFBUCxFQUFXLE9BQVgsRUFBb0I7QUFDekQsV0FBSyxlQUFZO0FBQ2YsZUFBTyxTQUFQO0FBQ0QsT0FId0Q7QUFJekQsV0FBSyxhQUFVLEtBQVYsRUFBaUI7QUFDcEIsWUFBSSxRQUFRLENBQVIsSUFBYSxRQUFRLEdBQXpCLEVBQThCO0FBQzVCLGdCQUFNLElBQUksS0FBSixDQUFVLHFDQUFWLENBQU47QUFDRDtBQUNELG9CQUFZLEtBQVo7QUFDQSxhQUFLLFlBQUwsR0FBb0IsSUFBcEI7QUFDRDtBQVZ3RCxLQUFwQixDQUF2Qzs7QUFhQSxXQUFPLGNBQVAsQ0FBc0IsR0FBdEIsRUFBMkIsZUFBM0IsRUFBNEMsT0FBTyxFQUFQLEVBQVcsT0FBWCxFQUFvQjtBQUM5RCxXQUFLLGVBQVk7QUFDZixlQUFPLGNBQVA7QUFDRCxPQUg2RDtBQUk5RCxXQUFLLGFBQVUsS0FBVixFQUFpQjtBQUNwQixZQUFJLFVBQVUsaUJBQWlCLEtBQWpCLENBQWQ7QUFDQSxZQUFJLENBQUMsT0FBTCxFQUFjO0FBQ1osZ0JBQU0sSUFBSSxXQUFKLENBQWdCLDZDQUFoQixDQUFOO0FBQ0Q7QUFDRCx5QkFBaUIsT0FBakI7QUFDQSxhQUFLLFlBQUwsR0FBb0IsSUFBcEI7QUFDRDtBQVg2RCxLQUFwQixDQUE1Qzs7QUFjQSxXQUFPLGNBQVAsQ0FBc0IsR0FBdEIsRUFBMkIsTUFBM0IsRUFBbUMsT0FBTyxFQUFQLEVBQVcsT0FBWCxFQUFvQjtBQUNyRCxXQUFLLGVBQVk7QUFDZixlQUFPLEtBQVA7QUFDRCxPQUhvRDtBQUlyRCxXQUFLLGFBQVUsS0FBVixFQUFpQjtBQUNwQixZQUFJLFFBQVEsQ0FBUixJQUFhLFFBQVEsR0FBekIsRUFBOEI7QUFDNUIsZ0JBQU0sSUFBSSxLQUFKLENBQVUsaUNBQVYsQ0FBTjtBQUNEO0FBQ0QsZ0JBQVEsS0FBUjtBQUNBLGFBQUssWUFBTCxHQUFvQixJQUFwQjtBQUNEO0FBVm9ELEtBQXBCLENBQW5DOztBQWFBLFdBQU8sY0FBUCxDQUFzQixHQUF0QixFQUEyQixPQUEzQixFQUFvQyxPQUFPLEVBQVAsRUFBVyxPQUFYLEVBQW9CO0FBQ3RELFdBQUssZUFBWTtBQUNmLGVBQU8sTUFBUDtBQUNELE9BSHFEO0FBSXRELFdBQUssYUFBVSxLQUFWLEVBQWlCO0FBQ3BCLFlBQUksVUFBVSxpQkFBaUIsS0FBakIsQ0FBZDtBQUNBLFlBQUksQ0FBQyxPQUFMLEVBQWM7QUFDWixnQkFBTSxJQUFJLFdBQUosQ0FBZ0IsNkNBQWhCLENBQU47QUFDRDtBQUNELGlCQUFTLE9BQVQ7QUFDQSxhQUFLLFlBQUwsR0FBb0IsSUFBcEI7QUFDRDtBQVhxRCxLQUFwQixDQUFwQzs7QUFjQTs7OztBQUlBO0FBQ0EsUUFBSSxZQUFKLEdBQW1CLFNBQW5COztBQUVBLFFBQUksS0FBSixFQUFXO0FBQ1QsYUFBTyxHQUFQO0FBQ0Q7QUFDRjs7QUFFRDs7OztBQUlBLFNBQU8sU0FBUCxDQUFpQixZQUFqQixHQUFnQyxZQUFZO0FBQzFDO0FBQ0EsUUFBSSxTQUFTLE9BQU8sTUFBcEI7QUFDQSxXQUFPLE9BQU8sbUJBQVAsQ0FBMkIsTUFBM0IsRUFBbUMsS0FBSyxJQUF4QyxDQUFQO0FBQ0QsR0FKRDs7QUFNQSxTQUFPLE1BQVA7QUFDRCxDQTlSYyxFOzs7Ozs7Ozs7O0FDWmY7Ozs7OztBQUVBLElBQU0sZ0JBQWdCLFNBQVMsYUFBVCxHQUF5QjtBQUM3QyxTQUFPO0FBQ0wsWUFBUSxnQkFBUyxJQUFULEVBQWU7QUFDckIsVUFBSSxDQUFDLElBQUwsRUFBVztBQUNULGVBQU8sRUFBUDtBQUNEO0FBQ0QsVUFBSSxPQUFPLElBQVAsS0FBZ0IsUUFBcEIsRUFBOEI7QUFDNUIsY0FBTSxJQUFJLEtBQUosQ0FBVSwrQkFBVixDQUFOO0FBQ0Q7QUFDRCxhQUFPLG1CQUFtQixtQkFBbUIsSUFBbkIsQ0FBbkIsQ0FBUDtBQUNHO0FBVEEsR0FBUDtBQVdDLENBWkgsQyxDQU5BOzs7O0FBb0JBLFNBQVMsU0FBVCxHQUFxQjtBQUNqQixPQUFLLE1BQUwsR0FBYyxNQUFkO0FBQ0EsT0FBSyxLQUFMLEdBQWEsU0FBYjtBQUNBLE9BQUssTUFBTCxHQUFjLEVBQWQ7QUFDQSxPQUFLLE9BQUwsR0FBZSxJQUFJLGFBQUosRUFBZjtBQUNBLE9BQUssVUFBTCxHQUFrQixFQUFsQjtBQUNIOztBQUdEO0FBQ0EsU0FBUyxjQUFULENBQXdCLEtBQXhCLEVBQStCOztBQUU3QixXQUFTLGNBQVQsQ0FBd0IsQ0FBeEIsRUFBMkIsQ0FBM0IsRUFBOEIsQ0FBOUIsRUFBaUMsQ0FBakMsRUFBb0M7QUFDbEMsV0FBTyxDQUFDLElBQUksQ0FBTCxJQUFVLElBQVYsR0FBaUIsQ0FBQyxJQUFJLENBQUwsSUFBVSxFQUEzQixJQUFpQyxJQUFJLENBQXJDLElBQTBDLENBQUMsSUFBSSxDQUFMLElBQVUsSUFBM0Q7QUFDRDs7QUFFRCxNQUFJLElBQUksTUFBTSxLQUFOLENBQVksa0NBQVosQ0FBUjtBQUNBLE1BQUksQ0FBQyxDQUFMLEVBQVE7QUFDTixXQUFPLElBQVA7QUFDRDs7QUFFRCxNQUFJLEVBQUUsQ0FBRixDQUFKLEVBQVU7QUFDUjtBQUNBLFdBQU8sZUFBZSxFQUFFLENBQUYsQ0FBZixFQUFxQixFQUFFLENBQUYsQ0FBckIsRUFBMkIsRUFBRSxDQUFGLEVBQUssT0FBTCxDQUFhLEdBQWIsRUFBa0IsRUFBbEIsQ0FBM0IsRUFBa0QsRUFBRSxDQUFGLENBQWxELENBQVA7QUFDRCxHQUhELE1BR08sSUFBSSxFQUFFLENBQUYsSUFBTyxFQUFYLEVBQWU7QUFDcEI7QUFDQTtBQUNBLFdBQU8sZUFBZSxFQUFFLENBQUYsQ0FBZixFQUFxQixFQUFFLENBQUYsQ0FBckIsRUFBMkIsQ0FBM0IsRUFBOEIsRUFBRSxDQUFGLENBQTlCLENBQVA7QUFDRCxHQUpNLE1BSUE7QUFDTDtBQUNBLFdBQU8sZUFBZSxDQUFmLEVBQWtCLEVBQUUsQ0FBRixDQUFsQixFQUF3QixFQUFFLENBQUYsQ0FBeEIsRUFBOEIsRUFBRSxDQUFGLENBQTlCLENBQVA7QUFDRDtBQUNGOztBQUVEO0FBQ0E7QUFDQSxTQUFTLFFBQVQsR0FBb0I7QUFDbEIsT0FBSyxNQUFMLEdBQWMsT0FBTyxNQUFQLENBQWMsSUFBZCxDQUFkO0FBQ0Q7O0FBRUQsU0FBUyxTQUFULEdBQXFCO0FBQ25CO0FBQ0EsT0FBSyxhQUFTLENBQVQsRUFBWSxDQUFaLEVBQWU7QUFDbEIsUUFBSSxDQUFDLEtBQUssR0FBTCxDQUFTLENBQVQsQ0FBRCxJQUFnQixNQUFNLEVBQTFCLEVBQThCO0FBQzVCLFdBQUssTUFBTCxDQUFZLENBQVosSUFBaUIsQ0FBakI7QUFDRDtBQUNGLEdBTmtCO0FBT25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFLLGFBQVMsQ0FBVCxFQUFZLElBQVosRUFBa0IsVUFBbEIsRUFBOEI7QUFDakMsUUFBSSxVQUFKLEVBQWdCO0FBQ2QsYUFBTyxLQUFLLEdBQUwsQ0FBUyxDQUFULElBQWMsS0FBSyxNQUFMLENBQVksQ0FBWixDQUFkLEdBQStCLEtBQUssVUFBTCxDQUF0QztBQUNEO0FBQ0QsV0FBTyxLQUFLLEdBQUwsQ0FBUyxDQUFULElBQWMsS0FBSyxNQUFMLENBQVksQ0FBWixDQUFkLEdBQStCLElBQXRDO0FBQ0QsR0FqQmtCO0FBa0JuQjtBQUNBLE9BQUssYUFBUyxDQUFULEVBQVk7QUFDZixXQUFPLEtBQUssS0FBSyxNQUFqQjtBQUNELEdBckJrQjtBQXNCbkI7QUFDQSxPQUFLLGFBQVMsQ0FBVCxFQUFZLENBQVosRUFBZSxDQUFmLEVBQWtCO0FBQ3JCLFNBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxFQUFFLE1BQXRCLEVBQThCLEVBQUUsQ0FBaEMsRUFBbUM7QUFDakMsVUFBSSxNQUFNLEVBQUUsQ0FBRixDQUFWLEVBQWdCO0FBQ2QsYUFBSyxHQUFMLENBQVMsQ0FBVCxFQUFZLENBQVo7QUFDQTtBQUNEO0FBQ0Y7QUFDRixHQTlCa0I7QUErQm5CO0FBQ0EsV0FBUyxpQkFBUyxDQUFULEVBQVksQ0FBWixFQUFlO0FBQ3RCLFFBQUksVUFBVSxJQUFWLENBQWUsQ0FBZixDQUFKLEVBQXVCO0FBQUU7QUFDdkIsV0FBSyxHQUFMLENBQVMsQ0FBVCxFQUFZLFNBQVMsQ0FBVCxFQUFZLEVBQVosQ0FBWjtBQUNEO0FBQ0YsR0FwQ2tCO0FBcUNuQjtBQUNBLFdBQVMsaUJBQVMsQ0FBVCxFQUFZLENBQVosRUFBZTtBQUN0QixRQUFJLENBQUo7QUFDQSxRQUFLLElBQUksRUFBRSxLQUFGLENBQVEsMEJBQVIsQ0FBVCxFQUErQztBQUM3QyxVQUFJLFdBQVcsQ0FBWCxDQUFKO0FBQ0EsVUFBSSxLQUFLLENBQUwsSUFBVSxLQUFLLEdBQW5CLEVBQXdCO0FBQ3RCLGFBQUssR0FBTCxDQUFTLENBQVQsRUFBWSxDQUFaO0FBQ0EsZUFBTyxJQUFQO0FBQ0Q7QUFDRjtBQUNELFdBQU8sS0FBUDtBQUNEO0FBaERrQixDQUFyQjs7QUFtREE7QUFDQTtBQUNBLFNBQVMsWUFBVCxDQUFzQixLQUF0QixFQUE2QixRQUE3QixFQUF1QyxhQUF2QyxFQUFzRCxVQUF0RCxFQUFrRTtBQUNoRSxNQUFJLFNBQVMsYUFBYSxNQUFNLEtBQU4sQ0FBWSxVQUFaLENBQWIsR0FBdUMsQ0FBQyxLQUFELENBQXBEO0FBQ0EsT0FBSyxJQUFJLENBQVQsSUFBYyxNQUFkLEVBQXNCO0FBQ3BCLFFBQUksT0FBTyxPQUFPLENBQVAsQ0FBUCxLQUFxQixRQUF6QixFQUFtQztBQUNqQztBQUNEO0FBQ0QsUUFBSSxLQUFLLE9BQU8sQ0FBUCxFQUFVLEtBQVYsQ0FBZ0IsYUFBaEIsQ0FBVDtBQUNBLFFBQUksR0FBRyxNQUFILEtBQWMsQ0FBbEIsRUFBcUI7QUFDbkI7QUFDRDtBQUNELFFBQUksSUFBSSxHQUFHLENBQUgsQ0FBUjtBQUNBLFFBQUksSUFBSSxHQUFHLENBQUgsQ0FBUjtBQUNBLGFBQVMsQ0FBVCxFQUFZLENBQVo7QUFDRDtBQUNGOztBQUVELElBQUksV0FBVyxxQkFBVyxDQUFYLEVBQWMsQ0FBZCxFQUFpQixDQUFqQixDQUFmO0FBQ0E7QUFDQTtBQUNBLElBQUksU0FBUyxTQUFTLEtBQVQsS0FBbUIsUUFBbkIsR0FBOEIsUUFBOUIsR0FBeUMsUUFBdEQ7O0FBRUEsU0FBUyxRQUFULENBQWtCLEtBQWxCLEVBQXlCLEdBQXpCLEVBQThCLFVBQTlCLEVBQTBDO0FBQ3hDO0FBQ0EsTUFBSSxTQUFTLEtBQWI7QUFDQTtBQUNBLFdBQVMsZ0JBQVQsR0FBNEI7QUFDMUIsUUFBSSxLQUFLLGVBQWUsS0FBZixDQUFUO0FBQ0EsUUFBSSxPQUFPLElBQVgsRUFBaUI7QUFDZixZQUFNLElBQUksS0FBSixDQUFVLDBCQUEwQixNQUFwQyxDQUFOO0FBQ0Q7QUFDRDtBQUNBLFlBQVEsTUFBTSxPQUFOLENBQWMsZ0JBQWQsRUFBZ0MsRUFBaEMsQ0FBUjtBQUNBLFdBQU8sRUFBUDtBQUNEOztBQUVEO0FBQ0EsV0FBUyxrQkFBVCxDQUE0QixLQUE1QixFQUFtQyxHQUFuQyxFQUF3QztBQUN0QyxRQUFJLFdBQVcsSUFBSSxRQUFKLEVBQWY7O0FBRUEsaUJBQWEsS0FBYixFQUFvQixVQUFTLENBQVQsRUFBWSxDQUFaLEVBQWU7QUFDakMsY0FBUSxDQUFSO0FBQ0UsYUFBSyxRQUFMO0FBQ0U7QUFDQSxlQUFLLElBQUksSUFBSSxXQUFXLE1BQVgsR0FBb0IsQ0FBakMsRUFBb0MsS0FBSyxDQUF6QyxFQUE0QyxHQUE1QyxFQUFpRDtBQUMvQyxnQkFBSSxXQUFXLENBQVgsRUFBYyxFQUFkLEtBQXFCLENBQXpCLEVBQTRCO0FBQzFCLHVCQUFTLEdBQVQsQ0FBYSxDQUFiLEVBQWdCLFdBQVcsQ0FBWCxFQUFjLE1BQTlCO0FBQ0E7QUFDRDtBQUNGO0FBQ0Q7QUFDRixhQUFLLFVBQUw7QUFDRSxtQkFBUyxHQUFULENBQWEsQ0FBYixFQUFnQixDQUFoQixFQUFtQixDQUFDLElBQUQsRUFBTyxJQUFQLENBQW5CO0FBQ0E7QUFDRixhQUFLLE1BQUw7QUFDRSxjQUFJLE9BQU8sRUFBRSxLQUFGLENBQVEsR0FBUixDQUFYO0FBQUEsY0FDRSxRQUFRLEtBQUssQ0FBTCxDQURWO0FBRUEsbUJBQVMsT0FBVCxDQUFpQixDQUFqQixFQUFvQixLQUFwQjtBQUNBLGNBQUksU0FBUyxPQUFULENBQWlCLENBQWpCLEVBQW9CLEtBQXBCLENBQUosRUFBZ0M7QUFDOUIscUJBQVMsR0FBVCxDQUFhLGFBQWIsRUFBNEIsS0FBNUI7QUFDRDtBQUNELG1CQUFTLEdBQVQsQ0FBYSxDQUFiLEVBQWdCLEtBQWhCLEVBQXVCLENBQUMsTUFBRCxDQUF2QjtBQUNBLGNBQUksS0FBSyxNQUFMLEtBQWdCLENBQXBCLEVBQXVCO0FBQ3JCLHFCQUFTLEdBQVQsQ0FBYSxXQUFiLEVBQTBCLEtBQUssQ0FBTCxDQUExQixFQUFtQyxDQUFDLE9BQUQsRUFBVSxNQUFWLEVBQWtCLEtBQWxCLENBQW5DO0FBQ0Q7QUFDRDtBQUNGLGFBQUssVUFBTDtBQUNFLGlCQUFPLEVBQUUsS0FBRixDQUFRLEdBQVIsQ0FBUDtBQUNBLG1CQUFTLE9BQVQsQ0FBaUIsQ0FBakIsRUFBb0IsS0FBSyxDQUFMLENBQXBCO0FBQ0EsY0FBSSxLQUFLLE1BQUwsS0FBZ0IsQ0FBcEIsRUFBdUI7QUFDckIscUJBQVMsR0FBVCxDQUFhLGVBQWIsRUFBOEIsS0FBSyxDQUFMLENBQTlCLEVBQXVDLENBQUMsT0FBRCxFQUFVLE1BQVYsRUFBa0IsS0FBbEIsRUFBeUIsV0FBekIsRUFBc0MsWUFBdEMsRUFBb0QsTUFBcEQsQ0FBdkM7QUFDRDtBQUNEO0FBQ0YsYUFBSyxNQUFMO0FBQ0UsbUJBQVMsT0FBVCxDQUFpQixDQUFqQixFQUFvQixDQUFwQjtBQUNBO0FBQ0YsYUFBSyxPQUFMO0FBQ0UsbUJBQVMsR0FBVCxDQUFhLENBQWIsRUFBZ0IsQ0FBaEIsRUFBbUIsQ0FBQyxPQUFELEVBQVUsTUFBVixFQUFrQixLQUFsQixFQUF5QixNQUF6QixFQUFpQyxPQUFqQyxDQUFuQjtBQUNBO0FBckNKO0FBdUNELEtBeENELEVBd0NHLEdBeENILEVBd0NRLElBeENSOztBQTBDQTtBQUNBLFFBQUksTUFBSixHQUFhLFNBQVMsR0FBVCxDQUFhLFFBQWIsRUFBdUIsSUFBdkIsQ0FBYjtBQUNBLFFBQUksUUFBSixHQUFlLFNBQVMsR0FBVCxDQUFhLFVBQWIsRUFBeUIsRUFBekIsQ0FBZjtBQUNBLFFBQUksT0FBTyxTQUFTLEdBQVQsQ0FBYSxNQUFiLEVBQXFCLE1BQXJCLENBQVg7QUFDQSxRQUFJLFNBQVMsTUFBVCxJQUFtQixTQUFTLElBQVQsS0FBa0IsQ0FBQyxDQUExQyxFQUE2QztBQUMzQztBQUNBLGFBQU8sQ0FBQyxDQUFSO0FBQ0Q7QUFDRCxRQUFJLElBQUosR0FBVyxJQUFYO0FBQ0EsUUFBSSxTQUFKLEdBQWdCLFNBQVMsR0FBVCxDQUFhLFdBQWIsRUFBMEIsT0FBMUIsQ0FBaEI7QUFDQSxRQUFJLFdBQUosR0FBa0IsU0FBUyxHQUFULENBQWEsYUFBYixFQUE0QixJQUE1QixDQUFsQjtBQUNBLFFBQUksSUFBSixHQUFXLFNBQVMsR0FBVCxDQUFhLE1BQWIsRUFBcUIsR0FBckIsQ0FBWDtBQUNBLFFBQUksS0FBSixHQUFZLFNBQVMsR0FBVCxDQUFhLE9BQWIsRUFBc0IsTUFBdEIsQ0FBWjtBQUNBLFFBQUksV0FBVyxTQUFTLEdBQVQsQ0FBYSxVQUFiLEVBQXlCLE1BQXpCLENBQWY7QUFDQSxRQUFJLGFBQWEsTUFBYixJQUF1QixTQUFTLFFBQVQsS0FBc0IsRUFBakQsRUFBcUQ7QUFDbkQ7QUFDQSxpQkFBVyxJQUFJLEtBQUosS0FBYyxPQUFkLElBQXlCLElBQUksS0FBSixLQUFjLE1BQXZDLEdBQWdELENBQWhELEdBQW9ELElBQUksS0FBSixLQUFjLEtBQWQsSUFBdUIsSUFBSSxLQUFKLEtBQWMsT0FBckMsR0FBK0MsR0FBL0MsR0FBcUQsRUFBcEg7QUFDRDtBQUNELFFBQUksUUFBSixHQUFlLFFBQWY7QUFDRDs7QUFFRCxXQUFTLGNBQVQsR0FBMEI7QUFDeEIsWUFBUSxNQUFNLE9BQU4sQ0FBYyxNQUFkLEVBQXNCLEVBQXRCLENBQVI7QUFDRDs7QUFFRDtBQUNBO0FBQ0EsTUFBSSxTQUFKLEdBQWdCLGtCQUFoQixDQXZGd0MsQ0F1RkY7QUFDdEM7QUFDQSxNQUFJLE1BQU0sTUFBTixDQUFhLENBQWIsRUFBZ0IsQ0FBaEIsTUFBdUIsS0FBM0IsRUFBa0M7QUFBTTtBQUN0QyxVQUFNLElBQUksS0FBSixDQUFVLHNFQUNkLE1BREksQ0FBTjtBQUVEO0FBQ0QsVUFBUSxNQUFNLE1BQU4sQ0FBYSxDQUFiLENBQVI7QUFDQTtBQUNBLE1BQUksT0FBSixHQUFjLGtCQUFkLENBL0Z3QyxDQStGRjs7QUFFdEM7QUFDQTtBQUNBLHFCQUFtQixLQUFuQixFQUEwQixHQUExQjtBQUNEOztBQUVELFNBQVMsYUFBVCxDQUF1QixLQUF2QixFQUE4QjtBQUM1QixTQUFPLE1BQU0sT0FBTixDQUFjLGdCQUFkLEVBQWdDLElBQWhDLENBQVA7QUFDRDs7QUFFRCxVQUFVLFNBQVYsR0FBc0I7QUFDcEIsU0FBTyxlQUFTLElBQVQsRUFBZTtBQUNwQixRQUFJLE9BQU8sSUFBWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFJLElBQUosRUFBVTtBQUNSO0FBQ0EsV0FBSyxNQUFMLElBQWUsS0FBSyxPQUFMLENBQWEsTUFBYixDQUFvQixJQUFwQixFQUEwQixFQUFDLFFBQVEsSUFBVCxFQUExQixDQUFmO0FBQ0Q7O0FBRUQsYUFBUyxlQUFULEdBQTJCO0FBQ3pCLFVBQUksU0FBUyxLQUFLLE1BQWxCO0FBQ0EsVUFBSSxNQUFNLENBQVY7O0FBRUEsZUFBUyxjQUFjLE1BQWQsQ0FBVDs7QUFFQSxhQUFPLE1BQU0sT0FBTyxNQUFiLElBQXVCLE9BQU8sR0FBUCxNQUFnQixJQUF2QyxJQUErQyxPQUFPLEdBQVAsTUFBZ0IsSUFBdEUsRUFBNEU7QUFDMUUsVUFBRSxHQUFGO0FBQ0Q7QUFDRCxVQUFJLE9BQU8sT0FBTyxNQUFQLENBQWMsQ0FBZCxFQUFpQixHQUFqQixDQUFYO0FBQ0E7QUFDQSxVQUFJLE9BQU8sR0FBUCxNQUFnQixJQUFwQixFQUEwQjtBQUN4QixVQUFFLEdBQUY7QUFDRDtBQUNELFVBQUksT0FBTyxHQUFQLE1BQWdCLElBQXBCLEVBQTBCO0FBQ3hCLFVBQUUsR0FBRjtBQUNEO0FBQ0QsV0FBSyxNQUFMLEdBQWMsT0FBTyxNQUFQLENBQWMsR0FBZCxDQUFkO0FBQ0EsYUFBTyxJQUFQO0FBQ0Q7O0FBRUQ7QUFDQSxhQUFTLFdBQVQsQ0FBcUIsS0FBckIsRUFBNEI7QUFDMUIsbUJBQWEsS0FBYixFQUFvQixVQUFTLENBQVQsRUFBWSxDQUFaLEVBQWU7QUFDakMsZ0JBQVEsQ0FBUjtBQUNFLGVBQUssUUFBTDtBQUNFO0FBQ0Esb0JBQVEsR0FBUixDQUFZLGNBQVosRUFBNEIsQ0FBNUI7QUFDQTtBQUNBO0FBTEo7QUFPRCxPQVJELEVBUUcsR0FSSDtBQVNEOztBQUVEO0FBQ0EsUUFBSTtBQUNGLFVBQUksSUFBSjtBQUNBLFVBQUksS0FBSyxLQUFMLEtBQWUsU0FBbkIsRUFBOEI7QUFDNUI7QUFDQSxZQUFJLENBQUMsVUFBVSxJQUFWLENBQWUsS0FBSyxNQUFwQixDQUFMLEVBQWtDO0FBQ2hDLGlCQUFPLElBQVA7QUFDRDs7QUFFRCxlQUFPLGlCQUFQOztBQUVBLFlBQUksSUFBSSxLQUFLLEtBQUwsQ0FBVyxvQkFBWCxDQUFSO0FBQ0EsWUFBSSxDQUFDLENBQUQsSUFBTSxDQUFDLEVBQUUsQ0FBRixDQUFYLEVBQWlCO0FBQ2YsZ0JBQU0sSUFBSSxLQUFKLENBQVUsNkJBQVYsQ0FBTjtBQUNEOztBQUVELGFBQUssS0FBTCxHQUFhLFFBQWI7QUFDRDs7QUFFRCxVQUFJLHVCQUF1QixLQUEzQjtBQUNBLGFBQU8sS0FBSyxNQUFaLEVBQW9CO0FBQ2xCO0FBQ0EsWUFBSSxDQUFDLFVBQVUsSUFBVixDQUFlLEtBQUssTUFBcEIsQ0FBTCxFQUFrQztBQUNoQyxpQkFBTyxJQUFQO0FBQ0Q7O0FBRUQsWUFBSSxDQUFDLG9CQUFMLEVBQTJCO0FBQ3pCLGlCQUFPLGlCQUFQO0FBQ0QsU0FGRCxNQUVPO0FBQ0wsaUNBQXVCLEtBQXZCO0FBQ0Q7O0FBRUQsZ0JBQVEsS0FBSyxLQUFiO0FBQ0UsZUFBSyxRQUFMO0FBQ0U7QUFDQSxnQkFBSSxJQUFJLElBQUosQ0FBUyxJQUFULENBQUosRUFBb0I7QUFDbEIsMEJBQVksSUFBWjtBQUNELGFBRkQsTUFFTyxJQUFJLENBQUMsSUFBTCxFQUFXO0FBQ2hCO0FBQ0EsbUJBQUssS0FBTCxHQUFhLElBQWI7QUFDRDtBQUNEO0FBQ0YsZUFBSyxNQUFMO0FBQ0U7QUFDQSxnQkFBSSxDQUFDLElBQUwsRUFBVztBQUNULG1CQUFLLEtBQUwsR0FBYSxJQUFiO0FBQ0Q7QUFDRDtBQUNGLGVBQUssSUFBTDtBQUNFO0FBQ0EsZ0JBQUksaUJBQWlCLElBQWpCLENBQXNCLElBQXRCLENBQUosRUFBaUM7QUFDL0IsbUJBQUssS0FBTCxHQUFhLE1BQWI7QUFDQTtBQUNEO0FBQ0Q7QUFDQSxnQkFBSSxDQUFDLElBQUwsRUFBVztBQUNUO0FBQ0Q7QUFDRCxpQkFBSyxHQUFMLEdBQVcscUJBQVcsQ0FBWCxFQUFjLENBQWQsRUFBaUIsRUFBakIsQ0FBWDtBQUNBLGlCQUFLLEtBQUwsR0FBYSxLQUFiO0FBQ0E7QUFDQSxnQkFBSSxLQUFLLE9BQUwsQ0FBYSxLQUFiLE1BQXdCLENBQUMsQ0FBN0IsRUFBZ0M7QUFDOUIsbUJBQUssR0FBTCxDQUFTLEVBQVQsR0FBYyxJQUFkO0FBQ0E7QUFDRDtBQUNIO0FBQ0E7QUFDQSxlQUFLLEtBQUw7QUFDRTtBQUNBLGdCQUFJO0FBQ0YsdUJBQVMsSUFBVCxFQUFlLEtBQUssR0FBcEIsRUFBeUIsS0FBSyxVQUE5QjtBQUNELGFBRkQsQ0FFRSxPQUFPLENBQVAsRUFBVTtBQUNWO0FBQ0EsbUJBQUssR0FBTCxHQUFXLElBQVg7QUFDQSxtQkFBSyxLQUFMLEdBQWEsUUFBYjtBQUNBO0FBQ0Q7QUFDRCxpQkFBSyxLQUFMLEdBQWEsU0FBYjtBQUNBO0FBQ0YsZUFBSyxTQUFMO0FBQ0UsZ0JBQUksZUFBZSxLQUFLLE9BQUwsQ0FBYSxLQUFiLE1BQXdCLENBQUMsQ0FBNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFJLENBQUMsSUFBRCxJQUFTLGlCQUFpQix1QkFBdUIsSUFBeEMsQ0FBYixFQUE0RDtBQUMxRDtBQUNBLGtCQUFJLEtBQUssS0FBVCxFQUFnQjtBQUNkLHFCQUFLLEtBQUwsQ0FBVyxLQUFLLEdBQWhCO0FBQ0Q7QUFDRCxtQkFBSyxHQUFMLEdBQVcsSUFBWDtBQUNBLG1CQUFLLEtBQUwsR0FBYSxJQUFiO0FBQ0E7QUFDRDtBQUNELGdCQUFJLEtBQUssR0FBTCxDQUFTLElBQWIsRUFBbUI7QUFDakIsbUJBQUssR0FBTCxDQUFTLElBQVQsSUFBaUIsSUFBakI7QUFDRDtBQUNELGlCQUFLLEdBQUwsQ0FBUyxJQUFULElBQWlCLElBQWpCO0FBQ0E7QUFDRixlQUFLLFFBQUw7QUFBZTtBQUNiO0FBQ0EsZ0JBQUksQ0FBQyxJQUFMLEVBQVc7QUFDVCxtQkFBSyxLQUFMLEdBQWEsSUFBYjtBQUNEO0FBQ0Q7QUF4RUo7QUEwRUQ7QUFDRixLQTFHRCxDQTBHRSxPQUFPLENBQVAsRUFBVTs7QUFFVjtBQUNBLFVBQUksS0FBSyxLQUFMLEtBQWUsU0FBZixJQUE0QixLQUFLLEdBQWpDLElBQXdDLEtBQUssS0FBakQsRUFBd0Q7QUFDdEQsYUFBSyxLQUFMLENBQVcsS0FBSyxHQUFoQjtBQUNEO0FBQ0QsV0FBSyxHQUFMLEdBQVcsSUFBWDtBQUNBO0FBQ0E7QUFDQSxXQUFLLEtBQUwsR0FBYSxLQUFLLEtBQUwsS0FBZSxTQUFmLEdBQTJCLFdBQTNCLEdBQXlDLFFBQXREO0FBQ0Q7QUFDRCxXQUFPLElBQVA7QUFDRCxHQXJLbUI7QUFzS3BCLFNBQU8saUJBQVc7QUFDaEIsUUFBSSxPQUFPLElBQVg7QUFDQSxRQUFJO0FBQ0Y7QUFDQSxXQUFLLE1BQUwsSUFBZSxLQUFLLE9BQUwsQ0FBYSxNQUFiLEVBQWY7QUFDQTtBQUNBLFVBQUksS0FBSyxHQUFMLElBQVksS0FBSyxLQUFMLEtBQWUsUUFBL0IsRUFBeUM7QUFDdkMsYUFBSyxNQUFMLElBQWUsTUFBZjtBQUNBLGFBQUssS0FBTDtBQUNEO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsVUFBSSxLQUFLLEtBQUwsS0FBZSxTQUFuQixFQUE4QjtBQUM1QixjQUFNLElBQUksS0FBSixDQUFVLDZCQUFWLENBQU47QUFDRDtBQUNGLEtBZEQsQ0FjRSxPQUFPLENBQVAsRUFBVTtBQUNWLFlBQU0sQ0FBTjtBQUNEO0FBQ0QsUUFBSSxLQUFLLE9BQVQsRUFBa0I7QUFDaEIsV0FBSyxPQUFMO0FBQ0Q7QUFDRCxXQUFPLElBQVA7QUFDRDtBQTdMbUIsQ0FBdEI7O1FBZ01TLGEsR0FBQSxhO2tCQUVNLFM7Ozs7O0FDbGJmOzs7Ozs7QUFFQSxJQUFNLG1CQUFtQixTQUFuQixnQkFBbUIsQ0FBUyxVQUFULEVBQXFCO0FBQzFDLFFBQUksS0FBSyxTQUFTLFdBQVcsTUFBWCxDQUFrQixDQUFDLENBQW5CLENBQVQsQ0FBVDtBQUNBLFFBQUksT0FBTyxTQUFTLFdBQVcsTUFBWCxDQUFrQixDQUFDLENBQW5CLEVBQXFCLENBQXJCLENBQVQsQ0FBWDtBQUNBLFFBQUksT0FBTyxTQUFTLFdBQVcsTUFBWCxDQUFrQixDQUFDLENBQW5CLEVBQXFCLENBQXJCLENBQVQsQ0FBWDtBQUNBLFFBQUksUUFBUSxXQUFXLE1BQVgsR0FBb0IsQ0FBcEIsR0FBd0IsU0FBUyxXQUFXLE1BQVgsQ0FBa0IsQ0FBbEIsRUFBcUIsV0FBVyxPQUFYLENBQW1CLEdBQW5CLENBQXJCLENBQVQsQ0FBeEIsR0FBa0YsQ0FBOUY7O0FBRUEsUUFBSSxNQUFNLEVBQU4sS0FBYSxNQUFNLElBQU4sQ0FBYixJQUE0QixNQUFNLElBQU4sQ0FBNUIsSUFBMkMsTUFBTSxLQUFOLENBQS9DLEVBQTZEO0FBQ3pELGVBQU8sQ0FBQyxDQUFSO0FBQ0g7O0FBRUQsVUFBTSxPQUFPLElBQWI7QUFDQSxVQUFNLEtBQUcsSUFBSCxHQUFVLElBQWhCO0FBQ0EsVUFBTSxLQUFHLEVBQUgsR0FBTSxJQUFOLEdBQWEsS0FBbkI7O0FBRUEsV0FBTyxFQUFQO0FBQ0gsQ0FmRDs7QUFpQkEsSUFBTSxrQkFBa0IsU0FBbEIsZUFBa0IsQ0FBUyxNQUFULEVBQWlCLEVBQWpCLEVBQXFCLGdCQUFyQixFQUF1QztBQUMzRCxRQUFJLFNBQVMsT0FBTyxFQUFQLENBQWI7QUFDQSxRQUFJLFNBQVMsT0FBTyxPQUFPLE1BQWQsQ0FBYjs7QUFFQTtBQUNBO0FBQ0EsUUFBSSxDQUFDLE1BQUQsSUFBWSxDQUFDLE9BQU8sR0FBUixJQUFlLE9BQU8sR0FBdEMsRUFBNEM7QUFDeEMsZUFBTyxRQUFQLEdBQWtCLE9BQU8sa0JBQVAsR0FBNEIsT0FBTyxLQUFyRDtBQUNBLGVBQU8sR0FBUCxHQUFhLEtBQWI7QUFDQTtBQUNIOztBQUVEO0FBQ0E7QUFDQSxXQUFPLFVBQVUsT0FBTyxHQUF4QixFQUE2QjtBQUN6QixlQUFPLFFBQVAsSUFBbUIsT0FBTyxLQUFQLEdBQWUsT0FBTyxLQUF6QztBQUNBLGVBQU8sR0FBUCxHQUFhLEtBQWI7QUFDQSxpQkFBUyxNQUFUO0FBQ0EsaUJBQVMsT0FBTyxPQUFPLE1BQWQsQ0FBVDtBQUNIOztBQUVELFdBQU8sa0JBQVAsR0FBNEIsZ0JBQTVCO0FBQ0gsQ0F0QkQ7O0FBd0JBLElBQU0sZUFBZTtBQUNqQixXQUFPLGVBQVMsWUFBVCxFQUF1QixPQUF2QixFQUFnQyxNQUFoQyxFQUF3QyxFQUF4QyxFQUE0QyxRQUE1QyxFQUFzRCxhQUF0RCxFQUFxRTtBQUN4RTtBQUNBLFlBQUksS0FBSyxrQkFBVDtBQUNBLFlBQUksV0FBVyxPQUFPLFlBQVAsQ0FBb0IsS0FBcEIsQ0FBMEIsSUFBMUIsRUFBZ0MsSUFBSSxVQUFKLENBQWUsWUFBZixDQUFoQyxFQUE4RCxJQUE5RCxHQUFxRSxPQUFyRSxDQUE2RSxFQUE3RSxFQUFpRixJQUFqRixFQUF1RixLQUF2RixDQUE2RixJQUE3RixDQUFmO0FBQ0EsWUFBSSxVQUFVLFdBQWQ7QUFDQSxZQUFJLFNBQVMsQ0FBYjtBQUNBLFlBQUksWUFBWSxDQUFoQjtBQUNBLFlBQUksbUJBQW1CLENBQXZCO0FBQ0EsWUFBSSxPQUFPLEVBQVg7QUFDQSxZQUFJLHFCQUFKO0FBQ0EsWUFBSSxXQUFXLElBQWY7QUFDQTs7QUFFQTtBQUNBLFlBQUksU0FBUyx5QkFBYjs7QUFFQSxlQUFPLEtBQVAsR0FBZSxVQUFTLEdBQVQsRUFBYztBQUN6QjtBQUNBLGdCQUFJLFNBQVMsT0FBTyxFQUFQLENBQWI7QUFDQSxnQkFBSSxZQUFZLE9BQU8sUUFBdkI7O0FBRUE7QUFDQSxnQkFBSSxVQUFVLE9BQU8sR0FBckIsRUFBMEI7QUFDdEIsb0JBQUksU0FBSixFQUFlO0FBQ1g7QUFDQSxnQ0FBWSxPQUFPLFFBQVAsR0FBa0IsT0FBTyxLQUFyQztBQUNILGlCQUhELE1BR087QUFDSCxvQ0FBZ0IsTUFBaEIsRUFBd0IsRUFBeEIsRUFBNEIsZ0JBQTVCO0FBQ0g7QUFDSjs7QUFFRCxnQkFBSSxvQkFBb0IsQ0FBQyxTQUF6QixFQUFvQztBQUNoQztBQUNBLDRCQUFZLG1CQUFtQixPQUFPLFFBQTFCLEdBQXFDLE9BQU8sa0JBQXhEO0FBQ0g7O0FBRUQsZ0JBQUksU0FBSixJQUFpQixZQUFZLFNBQTdCO0FBQ0EsZ0JBQUksT0FBSixJQUFlLFlBQVksU0FBM0I7O0FBRUE7QUFDQSxnQkFBSSxJQUFKLEdBQVcsbUJBQW1CLE9BQU8sSUFBSSxJQUFYLENBQW5CLENBQVg7QUFDQSxnQkFBSSxJQUFJLE9BQUosR0FBYyxDQUFsQixFQUFxQjtBQUNuQixxQkFBSyxJQUFMLENBQVUsR0FBVjtBQUNEO0FBQ0osU0E1QkQ7O0FBOEJBLGVBQU8sY0FBUCxHQUF3QixVQUFTLENBQVQsRUFBWTtBQUNoQywyQkFBZSxDQUFmO0FBQ0gsU0FGRDs7QUFJQSxlQUFPLE9BQVAsR0FBaUIsWUFBVztBQUN4QixnQkFBSSxnQkFBZ0IsYUFBcEIsRUFBbUM7QUFDL0IsOEJBQWMsWUFBZDtBQUNBO0FBQ0g7QUFDRCxxQkFBUyxJQUFUO0FBQ0gsU0FORDs7QUFRQTtBQUNBLGlCQUFTLE9BQVQsQ0FBaUIsZ0JBQVE7QUFDckIsZ0JBQUksUUFBSixFQUFjO0FBQ1Y7QUFDQSxvQkFBSSxLQUFLLFVBQUwsQ0FBZ0Isa0JBQWhCLENBQUosRUFBeUM7QUFDckM7QUFDQSwrQkFBVyxLQUFYO0FBQ0E7QUFDQSx5QkFBSyxNQUFMLENBQVksRUFBWixFQUFnQixLQUFoQixDQUFzQixHQUF0QixFQUEyQixPQUEzQixDQUFtQyxxQkFBYTtBQUM1Qyw0QkFBSSxVQUFVLFVBQVYsQ0FBcUIsUUFBckIsQ0FBSixFQUFvQztBQUNsQyxzQ0FBVSxVQUFVLE1BQVYsQ0FBaUIsQ0FBakIsQ0FBVjtBQUNELHlCQUZELE1BRU8sSUFBSSxVQUFVLFVBQVYsQ0FBcUIsU0FBckIsQ0FBSixFQUFxQztBQUMxQyxxQ0FBUyxTQUFTLFVBQVUsTUFBVixDQUFpQixDQUFqQixDQUFULENBQVQ7QUFDRDtBQUNKLHFCQU5EO0FBT0Esd0JBQUk7QUFDQTtBQUNBO0FBQ0Esa0NBQVUsVUFBVSxDQUFWLEdBQWMsVUFBVSxVQUF4QixHQUFxQyxPQUEvQztBQUNBO0FBQ0Esa0NBQVUsT0FBVjtBQUNBO0FBQ0Esb0NBQVksaUJBQWlCLE9BQWpCLElBQTRCLElBQXhDO0FBQ0E7QUFDQSwyQ0FBbUIsU0FBUyxLQUE1Qjs7QUFFQSw0QkFBSSxjQUFjLENBQUMsQ0FBbkIsRUFBc0I7QUFDbEIsMkNBQWUsSUFBSSxLQUFKLGlDQUF3QyxJQUF4QyxDQUFmO0FBQ0g7QUFDSixxQkFkRCxDQWVBLE9BQU0sQ0FBTixFQUFTO0FBQ0wsdUNBQWUsSUFBSSxLQUFKLGlDQUF3QyxJQUF4QyxDQUFmO0FBQ0g7QUFDRDtBQUNBO0FBQ0gsaUJBL0JELE1BK0JPLElBQUksU0FBUyxFQUFiLEVBQWlCO0FBQ3RCLCtCQUFXLEtBQVg7QUFDRDtBQUNKO0FBQ0Q7QUFDQSxtQkFBTyxLQUFQLENBQWEsT0FBSyxJQUFsQjtBQUNILFNBeENEOztBQTBDQSxlQUFPLEtBQVA7QUFDSDtBQXZHZ0IsQ0FBckI7O0FBMkdBLE9BQU8sT0FBUCxHQUFpQixZQUFqQjs7Ozs7Ozs7O3FqQkN0SkE7Ozs7QUFJQTs7OztJQUVNLFM7QUFFSixxQkFBWSxNQUFaLEVBQW9CO0FBQUE7O0FBQ2xCLFFBQUksVUFBVSxPQUFPLFFBQXJCLEVBQStCO0FBQzdCLFdBQUssUUFBTCxHQUFnQixPQUFPLFFBQXZCO0FBQ0Q7QUFDRjs7Ozs4QkFFUztBQUNSLFdBQUssS0FBTDtBQUNBLFdBQUssTUFBTCxHQUFjLElBQWQ7QUFDRDs7OzRCQUVPO0FBQ04sVUFBSSxTQUFTLEtBQUssTUFBbEI7QUFDQSxVQUFJLFVBQVUsT0FBTyxVQUFQLEtBQXNCLENBQXBDLEVBQXVDO0FBQ3JDLGFBQUssS0FBTCxDQUFXLE9BQVgsR0FBcUIsSUFBckI7QUFDQSxlQUFPLEtBQVA7QUFDRDs7QUFFRCxhQUFPLFlBQVAsQ0FBb0IsS0FBSyxjQUF6QjtBQUNBLFdBQUssY0FBTCxHQUFzQixJQUF0QjtBQUNBLGFBQU8sWUFBUCxDQUFvQixLQUFLLFlBQXpCO0FBQ0EsV0FBSyxZQUFMLEdBQW9CLElBQXBCO0FBQ0Q7Ozt5QkFFSSxPLEVBQVMsTSxFQUFRLFMsRUFBVztBQUMvQixXQUFLLE9BQUwsR0FBZSxPQUFmO0FBQ0EsV0FBSyxNQUFMLEdBQWMsTUFBZDtBQUNBLFdBQUssU0FBTCxHQUFpQixTQUFqQjtBQUNBLFdBQUssS0FBTCxHQUFhLEVBQUMsVUFBVSxZQUFZLEdBQVosRUFBWCxFQUE4QixPQUFPLENBQXJDLEVBQWI7QUFDQSxXQUFLLFVBQUwsR0FBa0IsT0FBTyxVQUF6QjtBQUNBLFdBQUssWUFBTDtBQUNEOzs7bUNBRWM7QUFDYixVQUFJLEdBQUo7QUFBQSxVQUFTLFVBQVUsS0FBSyxPQUF4Qjs7QUFFQSxVQUFJLE9BQU8sY0FBUCxLQUEwQixXQUE5QixFQUEyQztBQUN4QyxjQUFNLEtBQUssTUFBTCxHQUFjLElBQUksY0FBSixFQUFwQjtBQUNGLE9BRkQsTUFFTztBQUNKLGNBQU0sS0FBSyxNQUFMLEdBQWMsSUFBSSxjQUFKLEVBQXBCO0FBQ0Y7O0FBRUQsVUFBSSxrQkFBSixHQUF5QixLQUFLLGdCQUFMLENBQXNCLElBQXRCLENBQTJCLElBQTNCLENBQXpCO0FBQ0EsVUFBSSxVQUFKLEdBQWlCLEtBQUssWUFBTCxDQUFrQixJQUFsQixDQUF1QixJQUF2QixDQUFqQjs7QUFFQSxVQUFJLElBQUosQ0FBUyxLQUFULEVBQWdCLFFBQVEsR0FBeEIsRUFBNkIsSUFBN0I7O0FBRUEsVUFBSSxRQUFRLFFBQVosRUFBc0I7QUFDcEIsWUFBSSxnQkFBSixDQUFxQixPQUFyQixFQUE2QixXQUFXLFFBQVEsVUFBbkIsR0FBZ0MsR0FBaEMsSUFBdUMsUUFBUSxRQUFSLEdBQWlCLENBQXhELENBQTdCO0FBQ0Q7QUFDRCxVQUFJLFlBQUosR0FBbUIsUUFBUSxZQUEzQjtBQUNBLFVBQUksUUFBUSxLQUFLLEtBQWpCO0FBQ0EsWUFBTSxNQUFOLEdBQWUsQ0FBZjtBQUNBLFlBQU0sTUFBTixHQUFlLENBQWY7QUFDQSxVQUFJLEtBQUssUUFBVCxFQUFtQjtBQUNqQixhQUFLLFFBQUwsQ0FBYyxHQUFkLEVBQW1CLFFBQVEsR0FBM0I7QUFDRDtBQUNEO0FBQ0EsV0FBSyxjQUFMLEdBQXNCLE9BQU8sVUFBUCxDQUFrQixLQUFLLFdBQUwsQ0FBaUIsSUFBakIsQ0FBc0IsSUFBdEIsQ0FBbEIsRUFBK0MsS0FBSyxNQUFMLENBQVksT0FBM0QsQ0FBdEI7QUFDQSxVQUFJLElBQUo7QUFDRDs7O3FDQUVnQixLLEVBQU87QUFDdEIsVUFBSSxNQUFNLE1BQU0sYUFBaEI7QUFBQSxVQUNJLGFBQWEsSUFBSSxVQURyQjtBQUFBLFVBRUksUUFBUSxLQUFLLEtBRmpCO0FBQUEsVUFHSSxVQUFVLEtBQUssT0FIbkI7QUFBQSxVQUlJLFNBQVMsS0FBSyxNQUpsQjs7QUFNQTtBQUNBLFVBQUksTUFBTSxPQUFWLEVBQW1CO0FBQ2pCO0FBQ0Q7O0FBRUQ7QUFDQSxhQUFPLFlBQVAsQ0FBb0IsS0FBSyxjQUF6Qjs7QUFFQTtBQUNBLFVBQUksY0FBYSxDQUFqQixFQUFvQjtBQUNsQixZQUFJLE1BQU0sTUFBTixLQUFpQixDQUFyQixFQUF3QjtBQUN0QixnQkFBTSxNQUFOLEdBQWUsS0FBSyxHQUFMLENBQVMsWUFBWSxHQUFaLEVBQVQsRUFBNEIsTUFBTSxRQUFsQyxDQUFmO0FBQ0E7QUFDQSxlQUFLLGNBQUwsR0FBc0IsT0FBTyxVQUFQLENBQWtCLEtBQUssV0FBTCxDQUFpQixJQUFqQixDQUFzQixJQUF0QixDQUFsQixFQUErQyxPQUFPLE9BQVAsSUFBa0IsTUFBTSxNQUFOLEdBQWEsTUFBTSxRQUFyQyxDQUEvQyxDQUF0QjtBQUNEO0FBQ0QsWUFBSSxlQUFlLENBQW5CLEVBQXNCO0FBQ3BCLGNBQUksU0FBUyxJQUFJLE1BQWpCO0FBQ0E7QUFDQSxjQUFJLFVBQVUsR0FBVixJQUFpQixTQUFTLEdBQTlCLEVBQW9DO0FBQ2xDLGtCQUFNLEtBQU4sR0FBYyxLQUFLLEdBQUwsQ0FBUyxNQUFNLE1BQWYsRUFBc0IsWUFBWSxHQUFaLEVBQXRCLENBQWQ7QUFDQSxnQkFBSSxhQUFKO0FBQUEsZ0JBQVMsWUFBVDtBQUNBLGdCQUFJLFFBQVEsWUFBUixLQUF5QixhQUE3QixFQUE0QztBQUMxQyxxQkFBTyxJQUFJLFFBQVg7QUFDQSxvQkFBTSxLQUFLLFVBQVg7QUFDRCxhQUhELE1BR087QUFDTCxxQkFBTyxJQUFJLFlBQVg7QUFDQSxvQkFBTSxLQUFLLE1BQVg7QUFDRDtBQUNELGtCQUFNLE1BQU4sR0FBZSxNQUFNLEtBQU4sR0FBYyxHQUE3QjtBQUNBLGdCQUFJLFdBQVcsRUFBRSxLQUFNLElBQUksV0FBWixFQUF5QixNQUFPLElBQWhDLEVBQWY7QUFDQSxpQkFBSyxTQUFMLENBQWUsU0FBZixDQUF5QixRQUF6QixFQUFtQyxLQUFuQyxFQUEwQyxPQUExQztBQUNELFdBYkQsTUFhTztBQUNIO0FBQ0YsZ0JBQUksTUFBTSxLQUFOLElBQWUsT0FBTyxRQUF0QixJQUFtQyxVQUFVLEdBQVYsSUFBaUIsU0FBUyxHQUFqRSxFQUF1RTtBQUNyRSw2QkFBTyxLQUFQLENBQWdCLE1BQWhCLHVCQUF3QyxRQUFRLEdBQWhEO0FBQ0EsbUJBQUssU0FBTCxDQUFlLE9BQWYsQ0FBdUIsRUFBRSxNQUFPLE1BQVQsRUFBaUIsTUFBTyxJQUFJLFVBQTVCLEVBQXZCLEVBQWdFLE9BQWhFO0FBQ0QsYUFIRCxNQUdPO0FBQ0w7QUFDQSw2QkFBTyxJQUFQLENBQWUsTUFBZix1QkFBdUMsUUFBUSxHQUEvQyxzQkFBbUUsS0FBSyxVQUF4RTtBQUNBO0FBQ0EsbUJBQUssT0FBTDtBQUNBO0FBQ0EsbUJBQUssWUFBTCxHQUFvQixPQUFPLFVBQVAsQ0FBa0IsS0FBSyxZQUFMLENBQWtCLElBQWxCLENBQXVCLElBQXZCLENBQWxCLEVBQWdELEtBQUssVUFBckQsQ0FBcEI7QUFDQTtBQUNBLG1CQUFLLFVBQUwsR0FBa0IsS0FBSyxHQUFMLENBQVMsSUFBSSxLQUFLLFVBQWxCLEVBQThCLE9BQU8sYUFBckMsQ0FBbEI7QUFDQSxvQkFBTSxLQUFOO0FBQ0Q7QUFDRjtBQUNGO0FBQ0Y7QUFDRjs7O2tDQUVhO0FBQ1oscUJBQU8sSUFBUCw0QkFBcUMsS0FBSyxPQUFMLENBQWEsR0FBbEQ7QUFDQSxXQUFLLFNBQUwsQ0FBZSxTQUFmLENBQXlCLEtBQUssS0FBOUIsRUFBcUMsS0FBSyxPQUExQztBQUNEOzs7aUNBRVksSyxFQUFPO0FBQ2xCLFVBQUksUUFBUSxLQUFLLEtBQWpCO0FBQ0EsWUFBTSxNQUFOLEdBQWUsTUFBTSxNQUFyQjtBQUNBLFVBQUksTUFBTSxnQkFBVixFQUE0QjtBQUMxQixjQUFNLEtBQU4sR0FBYyxNQUFNLEtBQXBCO0FBQ0Q7QUFDRCxVQUFJLGFBQWEsS0FBSyxTQUFMLENBQWUsVUFBaEM7QUFDQSxVQUFJLFVBQUosRUFBZ0I7QUFDZDtBQUNBLG1CQUFXLEtBQVgsRUFBa0IsS0FBSyxPQUF2QixFQUFnQyxJQUFoQztBQUNEO0FBQ0Y7Ozs7OztrQkFHWSxTIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIHRoaXMuX2V2ZW50cyA9IHRoaXMuX2V2ZW50cyB8fCB7fTtcbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gdGhpcy5fbWF4TGlzdGVuZXJzIHx8IHVuZGVmaW5lZDtcbn1cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjEwLnhcbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cyA9IHVuZGVmaW5lZDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX21heExpc3RlbmVycyA9IHVuZGVmaW5lZDtcblxuLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhbiAxMCBsaXN0ZW5lcnMgYXJlXG4vLyBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxuRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcblxuLy8gT2J2aW91c2x5IG5vdCBhbGwgRW1pdHRlcnMgc2hvdWxkIGJlIGxpbWl0ZWQgdG8gMTAuIFRoaXMgZnVuY3Rpb24gYWxsb3dzXG4vLyB0aGF0IHRvIGJlIGluY3JlYXNlZC4gU2V0IHRvIHplcm8gZm9yIHVubGltaXRlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24obikge1xuICBpZiAoIWlzTnVtYmVyKG4pIHx8IG4gPCAwIHx8IGlzTmFOKG4pKVxuICAgIHRocm93IFR5cGVFcnJvcignbiBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJyk7XG4gIHRoaXMuX21heExpc3RlbmVycyA9IG47XG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIgZXIsIGhhbmRsZXIsIGxlbiwgYXJncywgaSwgbGlzdGVuZXJzO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuXG4gIC8vIElmIHRoZXJlIGlzIG5vICdlcnJvcicgZXZlbnQgbGlzdGVuZXIgdGhlbiB0aHJvdy5cbiAgaWYgKHR5cGUgPT09ICdlcnJvcicpIHtcbiAgICBpZiAoIXRoaXMuX2V2ZW50cy5lcnJvciB8fFxuICAgICAgICAoaXNPYmplY3QodGhpcy5fZXZlbnRzLmVycm9yKSAmJiAhdGhpcy5fZXZlbnRzLmVycm9yLmxlbmd0aCkpIHtcbiAgICAgIGVyID0gYXJndW1lbnRzWzFdO1xuICAgICAgaWYgKGVyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBBdCBsZWFzdCBnaXZlIHNvbWUga2luZCBvZiBjb250ZXh0IHRvIHRoZSB1c2VyXG4gICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ1VuY2F1Z2h0LCB1bnNwZWNpZmllZCBcImVycm9yXCIgZXZlbnQuICgnICsgZXIgKyAnKScpO1xuICAgICAgICBlcnIuY29udGV4dCA9IGVyO1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaGFuZGxlciA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICBpZiAoaXNVbmRlZmluZWQoaGFuZGxlcikpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIGlmIChpc0Z1bmN0aW9uKGhhbmRsZXIpKSB7XG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAvLyBmYXN0IGNhc2VzXG4gICAgICBjYXNlIDE6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBzbG93ZXJcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICBoYW5kbGVyLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc09iamVjdChoYW5kbGVyKSkge1xuICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgIGxpc3RlbmVycyA9IGhhbmRsZXIuc2xpY2UoKTtcbiAgICBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKylcbiAgICAgIGxpc3RlbmVyc1tpXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBtO1xuXG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcblxuICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09PSBcIm5ld0xpc3RlbmVyXCIhIEJlZm9yZVxuICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcIm5ld0xpc3RlbmVyXCIuXG4gIGlmICh0aGlzLl9ldmVudHMubmV3TGlzdGVuZXIpXG4gICAgdGhpcy5lbWl0KCduZXdMaXN0ZW5lcicsIHR5cGUsXG4gICAgICAgICAgICAgIGlzRnVuY3Rpb24obGlzdGVuZXIubGlzdGVuZXIpID9cbiAgICAgICAgICAgICAgbGlzdGVuZXIubGlzdGVuZXIgOiBsaXN0ZW5lcik7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XG4gIGVsc2UgaWYgKGlzT2JqZWN0KHRoaXMuX2V2ZW50c1t0eXBlXSkpXG4gICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5wdXNoKGxpc3RlbmVyKTtcbiAgZWxzZVxuICAgIC8vIEFkZGluZyB0aGUgc2Vjb25kIGVsZW1lbnQsIG5lZWQgdG8gY2hhbmdlIHRvIGFycmF5LlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IFt0aGlzLl9ldmVudHNbdHlwZV0sIGxpc3RlbmVyXTtcblxuICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xuICBpZiAoaXNPYmplY3QodGhpcy5fZXZlbnRzW3R5cGVdKSAmJiAhdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCkge1xuICAgIGlmICghaXNVbmRlZmluZWQodGhpcy5fbWF4TGlzdGVuZXJzKSkge1xuICAgICAgbSA9IHRoaXMuX21heExpc3RlbmVycztcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzO1xuICAgIH1cblxuICAgIGlmIChtICYmIG0gPiAwICYmIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGggPiBtKSB7XG4gICAgICB0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkID0gdHJ1ZTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJyhub2RlKSB3YXJuaW5nOiBwb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5ICcgK1xuICAgICAgICAgICAgICAgICAgICAnbGVhayBkZXRlY3RlZC4gJWQgbGlzdGVuZXJzIGFkZGVkLiAnICtcbiAgICAgICAgICAgICAgICAgICAgJ1VzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvIGluY3JlYXNlIGxpbWl0LicsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGgpO1xuICAgICAgaWYgKHR5cGVvZiBjb25zb2xlLnRyYWNlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIG5vdCBzdXBwb3J0ZWQgaW4gSUUgMTBcbiAgICAgICAgY29uc29sZS50cmFjZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICB2YXIgZmlyZWQgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBnKCkge1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgZyk7XG5cbiAgICBpZiAoIWZpcmVkKSB7XG4gICAgICBmaXJlZCA9IHRydWU7XG4gICAgICBsaXN0ZW5lci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfVxuXG4gIGcubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgdGhpcy5vbih0eXBlLCBnKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIGVtaXRzIGEgJ3JlbW92ZUxpc3RlbmVyJyBldmVudCBpZmYgdGhlIGxpc3RlbmVyIHdhcyByZW1vdmVkXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIGxpc3QsIHBvc2l0aW9uLCBsZW5ndGgsIGk7XG5cbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgbGlzdCA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgbGVuZ3RoID0gbGlzdC5sZW5ndGg7XG4gIHBvc2l0aW9uID0gLTE7XG5cbiAgaWYgKGxpc3QgPT09IGxpc3RlbmVyIHx8XG4gICAgICAoaXNGdW5jdGlvbihsaXN0Lmxpc3RlbmVyKSAmJiBsaXN0Lmxpc3RlbmVyID09PSBsaXN0ZW5lcikpIHtcbiAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIGlmICh0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIpO1xuXG4gIH0gZWxzZSBpZiAoaXNPYmplY3QobGlzdCkpIHtcbiAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSA+IDA7KSB7XG4gICAgICBpZiAobGlzdFtpXSA9PT0gbGlzdGVuZXIgfHxcbiAgICAgICAgICAobGlzdFtpXS5saXN0ZW5lciAmJiBsaXN0W2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikpIHtcbiAgICAgICAgcG9zaXRpb24gPSBpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocG9zaXRpb24gPCAwKVxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICBpZiAobGlzdC5sZW5ndGggPT09IDEpIHtcbiAgICAgIGxpc3QubGVuZ3RoID0gMDtcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpc3Quc3BsaWNlKHBvc2l0aW9uLCAxKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3RlbmVyKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciBrZXksIGxpc3RlbmVycztcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICByZXR1cm4gdGhpcztcblxuICAvLyBub3QgbGlzdGVuaW5nIGZvciByZW1vdmVMaXN0ZW5lciwgbm8gbmVlZCB0byBlbWl0XG4gIGlmICghdGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApXG4gICAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICBlbHNlIGlmICh0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gZW1pdCByZW1vdmVMaXN0ZW5lciBmb3IgYWxsIGxpc3RlbmVycyBvbiBhbGwgZXZlbnRzXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgZm9yIChrZXkgaW4gdGhpcy5fZXZlbnRzKSB7XG4gICAgICBpZiAoa2V5ID09PSAncmVtb3ZlTGlzdGVuZXInKSBjb250aW51ZTtcbiAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGtleSk7XG4gICAgfVxuICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdyZW1vdmVMaXN0ZW5lcicpO1xuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChpc0Z1bmN0aW9uKGxpc3RlbmVycykpIHtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVycyk7XG4gIH0gZWxzZSBpZiAobGlzdGVuZXJzKSB7XG4gICAgLy8gTElGTyBvcmRlclxuICAgIHdoaWxlIChsaXN0ZW5lcnMubGVuZ3RoKVxuICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbbGlzdGVuZXJzLmxlbmd0aCAtIDFdKTtcbiAgfVxuICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciByZXQ7XG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0ID0gW107XG4gIGVsc2UgaWYgKGlzRnVuY3Rpb24odGhpcy5fZXZlbnRzW3R5cGVdKSlcbiAgICByZXQgPSBbdGhpcy5fZXZlbnRzW3R5cGVdXTtcbiAgZWxzZVxuICAgIHJldCA9IHRoaXMuX2V2ZW50c1t0eXBlXS5zbGljZSgpO1xuICByZXR1cm4gcmV0O1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24odHlwZSkge1xuICBpZiAodGhpcy5fZXZlbnRzKSB7XG4gICAgdmFyIGV2bGlzdGVuZXIgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgICBpZiAoaXNGdW5jdGlvbihldmxpc3RlbmVyKSlcbiAgICAgIHJldHVybiAxO1xuICAgIGVsc2UgaWYgKGV2bGlzdGVuZXIpXG4gICAgICByZXR1cm4gZXZsaXN0ZW5lci5sZW5ndGg7XG4gIH1cbiAgcmV0dXJuIDA7XG59O1xuXG5FdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHtcbiAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJDb3VudCh0eXBlKTtcbn07XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbiIsIi8qIGpzaGludCBpZ25vcmU6c3RhcnQgKi9cclxuKGZ1bmN0aW9uKHJvb3QpIHsgXHJcbi8qIGpzaGludCBpZ25vcmU6ZW5kICovXHJcbiAgdmFyIFVSTFRvb2xraXQgPSB7XHJcbiAgICAvLyBidWlsZCBhbiBhYnNvbHV0ZSBVUkwgZnJvbSBhIHJlbGF0aXZlIG9uZSB1c2luZyB0aGUgcHJvdmlkZWQgYmFzZVVSTFxyXG4gICAgLy8gaWYgcmVsYXRpdmVVUkwgaXMgYW4gYWJzb2x1dGUgVVJMIGl0IHdpbGwgYmUgcmV0dXJuZWQgYXMgaXMuXHJcbiAgICBidWlsZEFic29sdXRlVVJMOiBmdW5jdGlvbihiYXNlVVJMLCByZWxhdGl2ZVVSTCkge1xyXG4gICAgICAvLyByZW1vdmUgYW55IHJlbWFpbmluZyBzcGFjZSBhbmQgQ1JMRlxyXG4gICAgICByZWxhdGl2ZVVSTCA9IHJlbGF0aXZlVVJMLnRyaW0oKTtcclxuICAgICAgaWYgKC9eW2Etel0rOi9pLnRlc3QocmVsYXRpdmVVUkwpKSB7XHJcbiAgICAgICAgLy8gY29tcGxldGUgdXJsLCBub3QgcmVsYXRpdmVcclxuICAgICAgICByZXR1cm4gcmVsYXRpdmVVUkw7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciByZWxhdGl2ZVVSTFF1ZXJ5ID0gbnVsbDtcclxuICAgICAgdmFyIHJlbGF0aXZlVVJMSGFzaCA9IG51bGw7XHJcblxyXG4gICAgICB2YXIgcmVsYXRpdmVVUkxIYXNoU3BsaXQgPSAvXihbXiNdKikoLiopJC8uZXhlYyhyZWxhdGl2ZVVSTCk7XHJcbiAgICAgIGlmIChyZWxhdGl2ZVVSTEhhc2hTcGxpdCkge1xyXG4gICAgICAgIHJlbGF0aXZlVVJMSGFzaCA9IHJlbGF0aXZlVVJMSGFzaFNwbGl0WzJdO1xyXG4gICAgICAgIHJlbGF0aXZlVVJMID0gcmVsYXRpdmVVUkxIYXNoU3BsaXRbMV07XHJcbiAgICAgIH1cclxuICAgICAgdmFyIHJlbGF0aXZlVVJMUXVlcnlTcGxpdCA9IC9eKFteXFw/XSopKC4qKSQvLmV4ZWMocmVsYXRpdmVVUkwpO1xyXG4gICAgICBpZiAocmVsYXRpdmVVUkxRdWVyeVNwbGl0KSB7XHJcbiAgICAgICAgcmVsYXRpdmVVUkxRdWVyeSA9IHJlbGF0aXZlVVJMUXVlcnlTcGxpdFsyXTtcclxuICAgICAgICByZWxhdGl2ZVVSTCA9IHJlbGF0aXZlVVJMUXVlcnlTcGxpdFsxXTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIGJhc2VVUkxIYXNoU3BsaXQgPSAvXihbXiNdKikoLiopJC8uZXhlYyhiYXNlVVJMKTtcclxuICAgICAgaWYgKGJhc2VVUkxIYXNoU3BsaXQpIHtcclxuICAgICAgICBiYXNlVVJMID0gYmFzZVVSTEhhc2hTcGxpdFsxXTtcclxuICAgICAgfVxyXG4gICAgICB2YXIgYmFzZVVSTFF1ZXJ5U3BsaXQgPSAvXihbXlxcP10qKSguKikkLy5leGVjKGJhc2VVUkwpO1xyXG4gICAgICBpZiAoYmFzZVVSTFF1ZXJ5U3BsaXQpIHtcclxuICAgICAgICBiYXNlVVJMID0gYmFzZVVSTFF1ZXJ5U3BsaXRbMV07XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciBiYXNlVVJMRG9tYWluU3BsaXQgPSAvXigoW2Etel0rOik/XFwvXFwvW2EtejAtOVxcLlxcLV9+XSsoOlswLTldKyk/KT8oXFwvLiopJC9pLmV4ZWMoYmFzZVVSTCk7XHJcbiAgICAgIGlmICghYmFzZVVSTERvbWFpblNwbGl0KSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFcnJvciB0cnlpbmcgdG8gcGFyc2UgYmFzZSBVUkwuJyk7XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIC8vIGUuZy4gJ2h0dHA6JywgJ2h0dHBzOicsICcnXHJcbiAgICAgIHZhciBiYXNlVVJMUHJvdG9jb2wgPSBiYXNlVVJMRG9tYWluU3BsaXRbMl0gfHwgJyc7XHJcbiAgICAgIC8vIGUuZy4gJ2h0dHA6Ly9leGFtcGxlLmNvbScsICcvL2V4YW1wbGUuY29tJywgJydcclxuICAgICAgdmFyIGJhc2VVUkxQcm90b2NvbERvbWFpbiA9IGJhc2VVUkxEb21haW5TcGxpdFsxXSB8fCAnJztcclxuICAgICAgLy8gZS5nLiAnL2EvYi9jL3BsYXlsaXN0Lm0zdTgnXHJcbiAgICAgIHZhciBiYXNlVVJMUGF0aCA9IGJhc2VVUkxEb21haW5TcGxpdFs0XTtcclxuXHJcbiAgICAgIHZhciBidWlsdFVSTCA9IG51bGw7XHJcbiAgICAgIGlmICgvXlxcL1xcLy8udGVzdChyZWxhdGl2ZVVSTCkpIHtcclxuICAgICAgICAvLyByZWxhdGl2ZSB1cmwgc3RhcnRzIHd0aCAnLy8nIHNvIGNvcHkgcHJvdG9jb2wgKHdoaWNoIG1heSBiZSAnJyBpZiBiYXNlVXJsIGRpZG4ndCBwcm92aWRlIG9uZSlcclxuICAgICAgICBidWlsdFVSTCA9IGJhc2VVUkxQcm90b2NvbCsnLy8nK1VSTFRvb2xraXQuYnVpbGRBYnNvbHV0ZVBhdGgoJycsIHJlbGF0aXZlVVJMLnN1YnN0cmluZygyKSk7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSBpZiAoL15cXC8vLnRlc3QocmVsYXRpdmVVUkwpKSB7XHJcbiAgICAgICAgLy8gcmVsYXRpdmUgdXJsIHN0YXJ0cyB3aXRoICcvJyBzbyBzdGFydCBmcm9tIHJvb3Qgb2YgZG9tYWluXHJcbiAgICAgICAgYnVpbHRVUkwgPSBiYXNlVVJMUHJvdG9jb2xEb21haW4rJy8nK1VSTFRvb2xraXQuYnVpbGRBYnNvbHV0ZVBhdGgoJycsIHJlbGF0aXZlVVJMLnN1YnN0cmluZygxKSk7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSB7XHJcbiAgICAgICAgYnVpbHRVUkwgPSBVUkxUb29sa2l0LmJ1aWxkQWJzb2x1dGVQYXRoKGJhc2VVUkxQcm90b2NvbERvbWFpbitiYXNlVVJMUGF0aCwgcmVsYXRpdmVVUkwpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBwdXQgdGhlIHF1ZXJ5IGFuZCBoYXNoIHBhcnRzIGJhY2tcclxuICAgICAgaWYgKHJlbGF0aXZlVVJMUXVlcnkpIHtcclxuICAgICAgICBidWlsdFVSTCArPSByZWxhdGl2ZVVSTFF1ZXJ5O1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChyZWxhdGl2ZVVSTEhhc2gpIHtcclxuICAgICAgICBidWlsdFVSTCArPSByZWxhdGl2ZVVSTEhhc2g7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGJ1aWx0VVJMO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyBidWlsZCBhbiBhYnNvbHV0ZSBwYXRoIHVzaW5nIHRoZSBwcm92aWRlZCBiYXNlUGF0aFxyXG4gICAgLy8gYWRhcHRlZCBmcm9tIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9kb2N1bWVudC9jb29raWUjVXNpbmdfcmVsYXRpdmVfVVJMc19pbl90aGVfcGF0aF9wYXJhbWV0ZXJcclxuICAgIC8vIHRoaXMgZG9lcyBub3QgaGFuZGxlIHRoZSBjYXNlIHdoZXJlIHJlbGF0aXZlUGF0aCBpcyBcIi9cIiBvciBcIi8vXCIuIFRoZXNlIGNhc2VzIHNob3VsZCBiZSBoYW5kbGVkIG91dHNpZGUgdGhpcy5cclxuICAgIGJ1aWxkQWJzb2x1dGVQYXRoOiBmdW5jdGlvbihiYXNlUGF0aCwgcmVsYXRpdmVQYXRoKSB7XHJcbiAgICAgIHZhciBzUmVsUGF0aCA9IHJlbGF0aXZlUGF0aDtcclxuICAgICAgdmFyIG5VcExuLCBzRGlyID0gJycsIHNQYXRoID0gYmFzZVBhdGgucmVwbGFjZSgvW15cXC9dKiQvLCBzUmVsUGF0aC5yZXBsYWNlKC8oXFwvfF4pKD86XFwuP1xcLyspKy9nLCAnJDEnKSk7XHJcbiAgICAgIGZvciAodmFyIG5FbmQsIG5TdGFydCA9IDA7IG5FbmQgPSBzUGF0aC5pbmRleE9mKCcvLi4vJywgblN0YXJ0KSwgbkVuZCA+IC0xOyBuU3RhcnQgPSBuRW5kICsgblVwTG4pIHtcclxuICAgICAgICBuVXBMbiA9IC9eXFwvKD86XFwuXFwuXFwvKSovLmV4ZWMoc1BhdGguc2xpY2UobkVuZCkpWzBdLmxlbmd0aDtcclxuICAgICAgICBzRGlyID0gKHNEaXIgKyBzUGF0aC5zdWJzdHJpbmcoblN0YXJ0LCBuRW5kKSkucmVwbGFjZShuZXcgUmVnRXhwKCcoPzpcXFxcXFwvK1teXFxcXFxcL10qKXswLCcgKyAoKG5VcExuIC0gMSkgLyAzKSArICd9JCcpLCAnLycpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBzRGlyICsgc1BhdGguc3Vic3RyKG5TdGFydCk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbi8qIGpzaGludCBpZ25vcmU6c3RhcnQgKi9cclxuICBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IFVSTFRvb2xraXQ7XHJcbiAgZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXHJcbiAgICBkZWZpbmUoW10sIGZ1bmN0aW9uKCkgeyByZXR1cm4gVVJMVG9vbGtpdDsgfSk7XHJcbiAgZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXHJcbiAgICBleHBvcnRzW1wiVVJMVG9vbGtpdFwiXSA9IFVSTFRvb2xraXQ7XHJcbiAgZWxzZVxyXG4gICAgcm9vdFtcIlVSTFRvb2xraXRcIl0gPSBVUkxUb29sa2l0O1xyXG59KSh0aGlzKTtcclxuLyoganNoaW50IGlnbm9yZTplbmQgKi9cclxuIiwidmFyIGJ1bmRsZUZuID0gYXJndW1lbnRzWzNdO1xudmFyIHNvdXJjZXMgPSBhcmd1bWVudHNbNF07XG52YXIgY2FjaGUgPSBhcmd1bWVudHNbNV07XG5cbnZhciBzdHJpbmdpZnkgPSBKU09OLnN0cmluZ2lmeTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZm4sIG9wdGlvbnMpIHtcbiAgICB2YXIgd2tleTtcbiAgICB2YXIgY2FjaGVLZXlzID0gT2JqZWN0LmtleXMoY2FjaGUpO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjYWNoZUtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBrZXkgPSBjYWNoZUtleXNbaV07XG4gICAgICAgIHZhciBleHAgPSBjYWNoZVtrZXldLmV4cG9ydHM7XG4gICAgICAgIC8vIFVzaW5nIGJhYmVsIGFzIGEgdHJhbnNwaWxlciB0byB1c2UgZXNtb2R1bGUsIHRoZSBleHBvcnQgd2lsbCBhbHdheXNcbiAgICAgICAgLy8gYmUgYW4gb2JqZWN0IHdpdGggdGhlIGRlZmF1bHQgZXhwb3J0IGFzIGEgcHJvcGVydHkgb2YgaXQuIFRvIGVuc3VyZVxuICAgICAgICAvLyB0aGUgZXhpc3RpbmcgYXBpIGFuZCBiYWJlbCBlc21vZHVsZSBleHBvcnRzIGFyZSBib3RoIHN1cHBvcnRlZCB3ZVxuICAgICAgICAvLyBjaGVjayBmb3IgYm90aFxuICAgICAgICBpZiAoZXhwID09PSBmbiB8fCBleHAgJiYgZXhwLmRlZmF1bHQgPT09IGZuKSB7XG4gICAgICAgICAgICB3a2V5ID0ga2V5O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXdrZXkpIHtcbiAgICAgICAgd2tleSA9IE1hdGguZmxvb3IoTWF0aC5wb3coMTYsIDgpICogTWF0aC5yYW5kb20oKSkudG9TdHJpbmcoMTYpO1xuICAgICAgICB2YXIgd2NhY2hlID0ge307XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2FjaGVLZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgdmFyIGtleSA9IGNhY2hlS2V5c1tpXTtcbiAgICAgICAgICAgIHdjYWNoZVtrZXldID0ga2V5O1xuICAgICAgICB9XG4gICAgICAgIHNvdXJjZXNbd2tleV0gPSBbXG4gICAgICAgICAgICBGdW5jdGlvbihbJ3JlcXVpcmUnLCdtb2R1bGUnLCdleHBvcnRzJ10sICcoJyArIGZuICsgJykoc2VsZiknKSxcbiAgICAgICAgICAgIHdjYWNoZVxuICAgICAgICBdO1xuICAgIH1cbiAgICB2YXIgc2tleSA9IE1hdGguZmxvb3IoTWF0aC5wb3coMTYsIDgpICogTWF0aC5yYW5kb20oKSkudG9TdHJpbmcoMTYpO1xuXG4gICAgdmFyIHNjYWNoZSA9IHt9OyBzY2FjaGVbd2tleV0gPSB3a2V5O1xuICAgIHNvdXJjZXNbc2tleV0gPSBbXG4gICAgICAgIEZ1bmN0aW9uKFsncmVxdWlyZSddLCAoXG4gICAgICAgICAgICAvLyB0cnkgdG8gY2FsbCBkZWZhdWx0IGlmIGRlZmluZWQgdG8gYWxzbyBzdXBwb3J0IGJhYmVsIGVzbW9kdWxlXG4gICAgICAgICAgICAvLyBleHBvcnRzXG4gICAgICAgICAgICAndmFyIGYgPSByZXF1aXJlKCcgKyBzdHJpbmdpZnkod2tleSkgKyAnKTsnICtcbiAgICAgICAgICAgICcoZi5kZWZhdWx0ID8gZi5kZWZhdWx0IDogZikoc2VsZik7J1xuICAgICAgICApKSxcbiAgICAgICAgc2NhY2hlXG4gICAgXTtcblxuICAgIHZhciB3b3JrZXJTb3VyY2VzID0ge307XG4gICAgcmVzb2x2ZVNvdXJjZXMoc2tleSk7XG5cbiAgICBmdW5jdGlvbiByZXNvbHZlU291cmNlcyhrZXkpIHtcbiAgICAgICAgd29ya2VyU291cmNlc1trZXldID0gdHJ1ZTtcblxuICAgICAgICBmb3IgKHZhciBkZXBQYXRoIGluIHNvdXJjZXNba2V5XVsxXSkge1xuICAgICAgICAgICAgdmFyIGRlcEtleSA9IHNvdXJjZXNba2V5XVsxXVtkZXBQYXRoXTtcbiAgICAgICAgICAgIGlmICghd29ya2VyU291cmNlc1tkZXBLZXldKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZVNvdXJjZXMoZGVwS2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBzcmMgPSAnKCcgKyBidW5kbGVGbiArICcpKHsnXG4gICAgICAgICsgT2JqZWN0LmtleXMod29ya2VyU291cmNlcykubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHJpbmdpZnkoa2V5KSArICc6WydcbiAgICAgICAgICAgICAgICArIHNvdXJjZXNba2V5XVswXVxuICAgICAgICAgICAgICAgICsgJywnICsgc3RyaW5naWZ5KHNvdXJjZXNba2V5XVsxXSkgKyAnXSdcbiAgICAgICAgICAgIDtcbiAgICAgICAgfSkuam9pbignLCcpXG4gICAgICAgICsgJ30se30sWycgKyBzdHJpbmdpZnkoc2tleSkgKyAnXSknXG4gICAgO1xuXG4gICAgdmFyIFVSTCA9IHdpbmRvdy5VUkwgfHwgd2luZG93LndlYmtpdFVSTCB8fCB3aW5kb3cubW96VVJMIHx8IHdpbmRvdy5tc1VSTDtcblxuICAgIHZhciBibG9iID0gbmV3IEJsb2IoW3NyY10sIHsgdHlwZTogJ3RleHQvamF2YXNjcmlwdCcgfSk7XG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5iYXJlKSB7IHJldHVybiBibG9iOyB9XG4gICAgdmFyIHdvcmtlclVybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG4gICAgdmFyIHdvcmtlciA9IG5ldyBXb3JrZXIod29ya2VyVXJsKTtcbiAgICB3b3JrZXIub2JqZWN0VVJMID0gd29ya2VyVXJsO1xuICAgIHJldHVybiB3b3JrZXI7XG59O1xuIiwiLypcbiAqIHNpbXBsZSBBQlIgQ29udHJvbGxlclxuICogIC0gY29tcHV0ZSBuZXh0IGxldmVsIGJhc2VkIG9uIGxhc3QgZnJhZ21lbnQgYncgaGV1cmlzdGljc1xuICogIC0gaW1wbGVtZW50IGFuIGFiYW5kb24gcnVsZXMgdHJpZ2dlcmVkIGlmIHdlIGhhdmUgbGVzcyB0aGFuIDIgZnJhZyBidWZmZXJlZCBhbmQgaWYgY29tcHV0ZWQgYncgc2hvd3MgdGhhdCB3ZSByaXNrIGJ1ZmZlciBzdGFsbGluZ1xuICovXG5cbmltcG9ydCBFdmVudCBmcm9tICcuLi9ldmVudHMnO1xuaW1wb3J0IEV2ZW50SGFuZGxlciBmcm9tICcuLi9ldmVudC1oYW5kbGVyJztcbmltcG9ydCBCdWZmZXJIZWxwZXIgZnJvbSAnLi4vaGVscGVyL2J1ZmZlci1oZWxwZXInO1xuaW1wb3J0IHtFcnJvckRldGFpbHN9IGZyb20gJy4uL2Vycm9ycyc7XG5pbXBvcnQge2xvZ2dlcn0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcbmltcG9ydCBFd21hQmFuZFdpZHRoRXN0aW1hdG9yIGZyb20gJy4vZXdtYS1iYW5kd2lkdGgtZXN0aW1hdG9yJztcblxuY2xhc3MgQWJyQ29udHJvbGxlciBleHRlbmRzIEV2ZW50SGFuZGxlciB7XG5cbiAgY29uc3RydWN0b3IoaGxzKSB7XG4gICAgc3VwZXIoaGxzLCBFdmVudC5GUkFHX0xPQURJTkcsXG4gICAgICAgICAgICAgICBFdmVudC5GUkFHX0xPQURFRCxcbiAgICAgICAgICAgICAgIEV2ZW50LkZSQUdfQlVGRkVSRUQsXG4gICAgICAgICAgICAgICBFdmVudC5FUlJPUik7XG4gICAgdGhpcy5sYXN0TG9hZGVkRnJhZ0xldmVsID0gMDtcbiAgICB0aGlzLl9hdXRvTGV2ZWxDYXBwaW5nID0gLTE7XG4gICAgdGhpcy5fbmV4dEF1dG9MZXZlbCA9IC0xO1xuICAgIHRoaXMuaGxzID0gaGxzO1xuICAgIHRoaXMub25DaGVjayA9IHRoaXMuYWJhbmRvblJ1bGVzQ2hlY2suYmluZCh0aGlzKTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5jbGVhclRpbWVyKCk7XG4gICAgRXZlbnRIYW5kbGVyLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XG4gIH1cblxuICBvbkZyYWdMb2FkaW5nKGRhdGEpIHtcbiAgICBsZXQgZnJhZyA9IGRhdGEuZnJhZztcbiAgICBpZiAoZnJhZy50eXBlID09PSAnbWFpbicpIHtcbiAgICAgIGlmICghdGhpcy50aW1lcikge1xuICAgICAgICB0aGlzLnRpbWVyID0gc2V0SW50ZXJ2YWwodGhpcy5vbkNoZWNrLCAxMDApO1xuICAgICAgfVxuICAgICAgLy8gbGF6eSBpbml0IG9mIGJ3IEVzdGltYXRvciwgcmF0aW9uYWxlIGlzIHRoYXQgd2UgdXNlIGRpZmZlcmVudCBwYXJhbXMgZm9yIExpdmUvVm9EXG4gICAgICAvLyBzbyB3ZSBuZWVkIHRvIHdhaXQgZm9yIHN0cmVhbSBtYW5pZmVzdCAvIHBsYXlsaXN0IHR5cGUgdG8gaW5zdGFudGlhdGUgaXQuXG4gICAgICBpZiAoIXRoaXMuYndFc3RpbWF0b3IpIHtcbiAgICAgICAgbGV0IGhscyA9IHRoaXMuaGxzLFxuICAgICAgICAgICAgbGV2ZWwgPSBkYXRhLmZyYWcubGV2ZWwsXG4gICAgICAgICAgICBpc0xpdmUgPSBobHMubGV2ZWxzW2xldmVsXS5kZXRhaWxzLmxpdmUsXG4gICAgICAgICAgICBjb25maWcgPSBobHMuY29uZmlnLFxuICAgICAgICAgICAgZXdtYUZhc3QsIGV3bWFTbG93O1xuXG4gICAgICAgIGlmIChpc0xpdmUpIHtcbiAgICAgICAgICBld21hRmFzdCA9IGNvbmZpZy5hYnJFd21hRmFzdExpdmU7XG4gICAgICAgICAgZXdtYVNsb3cgPSBjb25maWcuYWJyRXdtYVNsb3dMaXZlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGV3bWFGYXN0ID0gY29uZmlnLmFickV3bWFGYXN0Vm9EO1xuICAgICAgICAgIGV3bWFTbG93ID0gY29uZmlnLmFickV3bWFTbG93Vm9EO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYndFc3RpbWF0b3IgPSBuZXcgRXdtYUJhbmRXaWR0aEVzdGltYXRvcihobHMsZXdtYVNsb3csZXdtYUZhc3QsY29uZmlnLmFickV3bWFEZWZhdWx0RXN0aW1hdGUpO1xuICAgICAgfVxuICAgICAgdGhpcy5mcmFnQ3VycmVudCA9IGZyYWc7XG4gICAgfVxuICB9XG5cbiAgYWJhbmRvblJ1bGVzQ2hlY2soKSB7XG4gICAgLypcbiAgICAgIG1vbml0b3IgZnJhZ21lbnQgcmV0cmlldmFsIHRpbWUuLi5cbiAgICAgIHdlIGNvbXB1dGUgZXhwZWN0ZWQgdGltZSBvZiBhcnJpdmFsIG9mIHRoZSBjb21wbGV0ZSBmcmFnbWVudC5cbiAgICAgIHdlIGNvbXBhcmUgaXQgdG8gZXhwZWN0ZWQgdGltZSBvZiBidWZmZXIgc3RhcnZhdGlvblxuICAgICovXG4gICAgbGV0IGhscyA9IHRoaXMuaGxzLCB2ID0gaGxzLm1lZGlhLGZyYWcgPSB0aGlzLmZyYWdDdXJyZW50LCBsb2FkZXIgPSBmcmFnLmxvYWRlciwgbWluQXV0b0xldmVsID0gdGhpcy5taW5BdXRvTGV2ZWw7XG5cbiAgICAvLyBpZiBsb2FkZXIgaGFzIGJlZW4gZGVzdHJveWVkIG9yIGxvYWRpbmcgaGFzIGJlZW4gYWJvcnRlZCwgc3RvcCB0aW1lciBhbmQgcmV0dXJuXG4gICAgaWYoIWxvYWRlciB8fCAoIGxvYWRlci5zdGF0cyAmJiBsb2FkZXIuc3RhdHMuYWJvcnRlZCkpIHtcbiAgICAgIGxvZ2dlci53YXJuKCdmcmFnIGxvYWRlciBkZXN0cm95IG9yIGFib3J0ZWQsIGRpc2FybSBhYmFuZG9uUnVsZXMnKTtcbiAgICAgIHRoaXMuY2xlYXJUaW1lcigpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgc3RhdHMgPSBsb2FkZXIuc3RhdHM7XG4gICAgLyogb25seSBtb25pdG9yIGZyYWcgcmV0cmlldmFsIHRpbWUgaWZcbiAgICAodmlkZW8gbm90IHBhdXNlZCBPUiBmaXJzdCBmcmFnbWVudCBiZWluZyBsb2FkZWQocmVhZHkgc3RhdGUgPT09IEhBVkVfTk9USElORyA9IDApKSBBTkQgYXV0b3N3aXRjaGluZyBlbmFibGVkIEFORCBub3QgbG93ZXN0IGxldmVsICg9PiBtZWFucyB0aGF0IHdlIGhhdmUgc2V2ZXJhbCBsZXZlbHMpICovXG4gICAgaWYgKHYgJiYgKCghdi5wYXVzZWQgJiYgKHYucGxheWJhY2tSYXRlICE9PSAwKSkgfHwgIXYucmVhZHlTdGF0ZSkgJiYgZnJhZy5hdXRvTGV2ZWwgJiYgZnJhZy5sZXZlbCkge1xuICAgICAgbGV0IHJlcXVlc3REZWxheSA9IHBlcmZvcm1hbmNlLm5vdygpIC0gc3RhdHMudHJlcXVlc3QsXG4gICAgICAgICAgcGxheWJhY2tSYXRlID0gTWF0aC5hYnModi5wbGF5YmFja1JhdGUpO1xuICAgICAgLy8gbW9uaXRvciBmcmFnbWVudCBsb2FkIHByb2dyZXNzIGFmdGVyIGhhbGYgb2YgZXhwZWN0ZWQgZnJhZ21lbnQgZHVyYXRpb24sdG8gc3RhYmlsaXplIGJpdHJhdGVcbiAgICAgIGlmIChyZXF1ZXN0RGVsYXkgPiAoNTAwICogZnJhZy5kdXJhdGlvbiAvIHBsYXliYWNrUmF0ZSkpIHtcbiAgICAgICAgbGV0IGxldmVscyA9IGhscy5sZXZlbHMsXG4gICAgICAgICAgICBsb2FkUmF0ZSA9IE1hdGgubWF4KDEsIHN0YXRzLmJ3ID8gc3RhdHMuYncgLyA4IDogc3RhdHMubG9hZGVkICogMTAwMCAvIHJlcXVlc3REZWxheSksIC8vIGJ5dGUvczsgYXQgbGVhc3QgMSBieXRlL3MgdG8gYXZvaWQgZGl2aXNpb24gYnkgemVyb1xuICAgICAgICAgICAgLy8gY29tcHV0ZSBleHBlY3RlZCBmcmFnbWVudCBsZW5ndGggdXNpbmcgZnJhZyBkdXJhdGlvbiBhbmQgbGV2ZWwgYml0cmF0ZS4gYWxzbyBlbnN1cmUgdGhhdCBleHBlY3RlZCBsZW4gaXMgZ3RlIHRoYW4gYWxyZWFkeSBsb2FkZWQgc2l6ZVxuICAgICAgICAgICAgZXhwZWN0ZWRMZW4gPSBzdGF0cy50b3RhbCA/IHN0YXRzLnRvdGFsIDogTWF0aC5tYXgoc3RhdHMubG9hZGVkLCBNYXRoLnJvdW5kKGZyYWcuZHVyYXRpb24gKiBsZXZlbHNbZnJhZy5sZXZlbF0uYml0cmF0ZSAvIDgpKSxcbiAgICAgICAgICAgIHBvcyA9IHYuY3VycmVudFRpbWUsXG4gICAgICAgICAgICBmcmFnTG9hZGVkRGVsYXkgPSAoZXhwZWN0ZWRMZW4gLSBzdGF0cy5sb2FkZWQpIC8gbG9hZFJhdGUsXG4gICAgICAgICAgICBidWZmZXJTdGFydmF0aW9uRGVsYXkgPSAoQnVmZmVySGVscGVyLmJ1ZmZlckluZm8odixwb3MsaGxzLmNvbmZpZy5tYXhCdWZmZXJIb2xlKS5lbmQgLSBwb3MpIC8gcGxheWJhY2tSYXRlO1xuICAgICAgICAvLyBjb25zaWRlciBlbWVyZ2VuY3kgc3dpdGNoIGRvd24gb25seSBpZiB3ZSBoYXZlIGxlc3MgdGhhbiAyIGZyYWcgYnVmZmVyZWQgQU5EXG4gICAgICAgIC8vIHRpbWUgdG8gZmluaXNoIGxvYWRpbmcgY3VycmVudCBmcmFnbWVudCBpcyBiaWdnZXIgdGhhbiBidWZmZXIgc3RhcnZhdGlvbiBkZWxheVxuICAgICAgICAvLyBpZSBpZiB3ZSByaXNrIGJ1ZmZlciBzdGFydmF0aW9uIGlmIGJ3IGRvZXMgbm90IGluY3JlYXNlIHF1aWNrbHlcbiAgICAgICAgaWYgKChidWZmZXJTdGFydmF0aW9uRGVsYXkgPCAoMiAqIGZyYWcuZHVyYXRpb24gLyBwbGF5YmFja1JhdGUpKSAmJiAoZnJhZ0xvYWRlZERlbGF5ID4gYnVmZmVyU3RhcnZhdGlvbkRlbGF5KSkge1xuICAgICAgICAgIGxldCBmcmFnTGV2ZWxOZXh0TG9hZGVkRGVsYXksIG5leHRMb2FkTGV2ZWw7XG4gICAgICAgICAgLy8gbGV0cyBpdGVyYXRlIHRocm91Z2ggbG93ZXIgbGV2ZWwgYW5kIHRyeSB0byBmaW5kIHRoZSBiaWdnZXN0IG9uZSB0aGF0IGNvdWxkIGF2b2lkIHJlYnVmZmVyaW5nXG4gICAgICAgICAgLy8gd2Ugc3RhcnQgZnJvbSBjdXJyZW50IGxldmVsIC0gMSBhbmQgd2Ugc3RlcCBkb3duICwgdW50aWwgd2UgZmluZCBhIG1hdGNoaW5nIGxldmVsXG4gICAgICAgICAgZm9yIChuZXh0TG9hZExldmVsID0gZnJhZy5sZXZlbCAtIDEgOyBuZXh0TG9hZExldmVsID4gbWluQXV0b0xldmVsIDsgbmV4dExvYWRMZXZlbC0tKSB7XG4gICAgICAgICAgICAvLyBjb21wdXRlIHRpbWUgdG8gbG9hZCBuZXh0IGZyYWdtZW50IGF0IGxvd2VyIGxldmVsXG4gICAgICAgICAgICAvLyAwLjggOiBjb25zaWRlciBvbmx5IDgwJSBvZiBjdXJyZW50IGJ3IHRvIGJlIGNvbnNlcnZhdGl2ZVxuICAgICAgICAgICAgLy8gOCA9IGJpdHMgcGVyIGJ5dGUgKGJwcy9CcHMpXG4gICAgICAgICAgICBmcmFnTGV2ZWxOZXh0TG9hZGVkRGVsYXkgPSBmcmFnLmR1cmF0aW9uICogbGV2ZWxzW25leHRMb2FkTGV2ZWxdLmJpdHJhdGUgLyAoOCAqIDAuOCAqIGxvYWRSYXRlKTtcbiAgICAgICAgICAgIGlmIChmcmFnTGV2ZWxOZXh0TG9hZGVkRGVsYXkgPCBidWZmZXJTdGFydmF0aW9uRGVsYXkpIHtcbiAgICAgICAgICAgICAgLy8gd2UgZm91bmQgYSBsb3dlciBsZXZlbCB0aGF0IGJlIHJlYnVmZmVyaW5nIGZyZWUgd2l0aCBjdXJyZW50IGVzdGltYXRlZCBidyAhXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBvbmx5IGVtZXJnZW5jeSBzd2l0Y2ggZG93biBpZiBpdCB0YWtlcyBsZXNzIHRpbWUgdG8gbG9hZCBuZXcgZnJhZ21lbnQgYXQgbG93ZXN0IGxldmVsIGluc3RlYWRcbiAgICAgICAgICAvLyBvZiBmaW5pc2hpbmcgbG9hZGluZyBjdXJyZW50IG9uZSAuLi5cbiAgICAgICAgICBpZiAoZnJhZ0xldmVsTmV4dExvYWRlZERlbGF5IDwgZnJhZ0xvYWRlZERlbGF5KSB7XG4gICAgICAgICAgICBsb2dnZXIud2FybihgbG9hZGluZyB0b28gc2xvdywgYWJvcnQgZnJhZ21lbnQgbG9hZGluZyBhbmQgc3dpdGNoIHRvIGxldmVsICR7bmV4dExvYWRMZXZlbH06ZnJhZ0xvYWRlZERlbGF5WyR7bmV4dExvYWRMZXZlbH1dPGZyYWdMb2FkZWREZWxheVske2ZyYWcubGV2ZWwtMX1dO2J1ZmZlclN0YXJ2YXRpb25EZWxheToke2ZyYWdMZXZlbE5leHRMb2FkZWREZWxheS50b0ZpeGVkKDEpfTwke2ZyYWdMb2FkZWREZWxheS50b0ZpeGVkKDEpfToke2J1ZmZlclN0YXJ2YXRpb25EZWxheS50b0ZpeGVkKDEpfWApO1xuICAgICAgICAgICAgLy8gZm9yY2UgbmV4dCBsb2FkIGxldmVsIGluIGF1dG8gbW9kZVxuICAgICAgICAgICAgaGxzLm5leHRMb2FkTGV2ZWwgPSBuZXh0TG9hZExldmVsO1xuICAgICAgICAgICAgLy8gdXBkYXRlIGJ3IGVzdGltYXRlIGZvciB0aGlzIGZyYWdtZW50IGJlZm9yZSBjYW5jZWxsaW5nIGxvYWQgKHRoaXMgd2lsbCBoZWxwIHJlZHVjaW5nIHRoZSBidylcbiAgICAgICAgICAgIHRoaXMuYndFc3RpbWF0b3Iuc2FtcGxlKHJlcXVlc3REZWxheSxzdGF0cy5sb2FkZWQpO1xuICAgICAgICAgICAgLy9hYm9ydCBmcmFnbWVudCBsb2FkaW5nXG4gICAgICAgICAgICBsb2FkZXIuYWJvcnQoKTtcbiAgICAgICAgICAgIC8vIHN0b3AgYWJhbmRvbiBydWxlcyB0aW1lclxuICAgICAgICAgICAgdGhpcy5jbGVhclRpbWVyKCk7XG4gICAgICAgICAgICBobHMudHJpZ2dlcihFdmVudC5GUkFHX0xPQURfRU1FUkdFTkNZX0FCT1JURUQsIHtmcmFnOiBmcmFnLCBzdGF0czogc3RhdHMgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgb25GcmFnTG9hZGVkKGRhdGEpIHtcbiAgICBsZXQgZnJhZyA9IGRhdGEuZnJhZztcbiAgICBpZiAoZnJhZy50eXBlID09PSAnbWFpbicpIHtcbiAgICAgIC8vIHN0b3AgbW9uaXRvcmluZyBidyBvbmNlIGZyYWcgbG9hZGVkXG4gICAgICB0aGlzLmNsZWFyVGltZXIoKTtcbiAgICAgIC8vIHN0b3JlIGxldmVsIGlkIGFmdGVyIHN1Y2Nlc3NmdWwgZnJhZ21lbnQgbG9hZFxuICAgICAgdGhpcy5sYXN0TG9hZGVkRnJhZ0xldmVsID0gZnJhZy5sZXZlbDtcbiAgICAgIC8vIHJlc2V0IGZvcmNlZCBhdXRvIGxldmVsIHZhbHVlIHNvIHRoYXQgbmV4dCBsZXZlbCB3aWxsIGJlIHNlbGVjdGVkXG4gICAgICB0aGlzLl9uZXh0QXV0b0xldmVsID0gLTE7XG4gICAgICAvLyBpZiBmcmFnbWVudCBoYXMgYmVlbiBsb2FkZWQgdG8gcGVyZm9ybSBhIGJpdHJhdGUgdGVzdCxcbiAgICAgIGlmIChkYXRhLmZyYWcuYml0cmF0ZVRlc3QpIHtcbiAgICAgICAgbGV0IHN0YXRzID0gZGF0YS5zdGF0cztcbiAgICAgICAgc3RhdHMudHBhcnNlZCA9IHN0YXRzLnRidWZmZXJlZCA9IHN0YXRzLnRsb2FkO1xuICAgICAgICB0aGlzLm9uRnJhZ0J1ZmZlcmVkKGRhdGEpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIG9uRnJhZ0J1ZmZlcmVkKGRhdGEpIHtcbiAgICB2YXIgc3RhdHMgPSBkYXRhLnN0YXRzLCBmcmFnID0gZGF0YS5mcmFnO1xuICAgIC8vIG9ubHkgdXBkYXRlIHN0YXRzIG9uIGZpcnN0IGZyYWcgYnVmZmVyaW5nXG4gICAgLy8gaWYgc2FtZSBmcmFnIGlzIGxvYWRlZCBtdWx0aXBsZSB0aW1lcywgaXQgbWlnaHQgYmUgaW4gYnJvd3NlciBjYWNoZSwgYW5kIGxvYWRlZCBxdWlja2x5XG4gICAgLy8gYW5kIGxlYWRpbmcgdG8gd3JvbmcgYncgZXN0aW1hdGlvblxuICAgIC8vIG9uIGJpdHJhdGUgdGVzdCwgYWxzbyBvbmx5IHVwZGF0ZSBzdGF0cyBvbmNlIChpZiB0bG9hZCA9IHRidWZmZXJlZCA9PSBvbiBGUkFHX0xPQURFRClcbiAgICBpZiAoc3RhdHMuYWJvcnRlZCAhPT0gdHJ1ZSAmJiBmcmFnLmxvYWRDb3VudGVyID09PSAxICYmIGZyYWcudHlwZSA9PT0gJ21haW4nICYmICgoIWZyYWcuYml0cmF0ZVRlc3QgfHwgc3RhdHMudGxvYWQgPT09IHN0YXRzLnRidWZmZXJlZCkpKSB7XG4gICAgICAvLyB1c2UgdHBhcnNlZC10cmVxdWVzdCBpbnN0ZWFkIG9mIHRidWZmZXJlZC10cmVxdWVzdCB0byBjb21wdXRlIGZyYWdMb2FkaW5nUHJvY2Vzc2luZzsgcmF0aW9uYWxlIGlzIHRoYXQgIGJ1ZmZlciBhcHBlbmRpbmcgb25seSBoYXBwZW5zIG9uY2UgbWVkaWEgaXMgYXR0YWNoZWRcbiAgICAgIC8vIGluIGNhc2Ugd2UgdXNlIGNvbmZpZy5zdGFydEZyYWdQcmVmZXRjaCB3aGlsZSBtZWRpYSBpcyBub3QgYXR0YWNoZWQgeWV0LCBmcmFnbWVudCBtaWdodCBiZSBwYXJzZWQgd2hpbGUgbWVkaWEgbm90IGF0dGFjaGVkIHlldCwgYnV0IGl0IHdpbGwgb25seSBiZSBidWZmZXJlZCBvbiBtZWRpYSBhdHRhY2hlZFxuICAgICAgLy8gYXMgYSBjb25zZXF1ZW5jZSBpdCBjb3VsZCBoYXBwZW4gcmVhbGx5IGxhdGUgaW4gdGhlIHByb2Nlc3MuIG1lYW5pbmcgdGhhdCBhcHBlbmRpbmcgZHVyYXRpb24gbWlnaHQgYXBwZWFycyBodWdlIC4uLiBsZWFkaW5nIHRvIHVuZGVyZXN0aW1hdGVkIHRocm91Z2hwdXQgZXN0aW1hdGlvblxuICAgICAgbGV0IGZyYWdMb2FkaW5nUHJvY2Vzc2luZ01zID0gc3RhdHMudHBhcnNlZCAtIHN0YXRzLnRyZXF1ZXN0O1xuICAgICAgbG9nZ2VyLmxvZyhgbGF0ZW5jeS9sb2FkaW5nL3BhcnNpbmcvYXBwZW5kL2ticHM6JHtNYXRoLnJvdW5kKHN0YXRzLnRmaXJzdC1zdGF0cy50cmVxdWVzdCl9LyR7TWF0aC5yb3VuZChzdGF0cy50bG9hZC1zdGF0cy50Zmlyc3QpfS8ke01hdGgucm91bmQoc3RhdHMudHBhcnNlZC1zdGF0cy50bG9hZCl9LyR7TWF0aC5yb3VuZChzdGF0cy50YnVmZmVyZWQtc3RhdHMudHBhcnNlZCl9LyR7TWF0aC5yb3VuZCg4KnN0YXRzLmxvYWRlZC8oc3RhdHMudGJ1ZmZlcmVkLXN0YXRzLnRyZXF1ZXN0KSl9YCk7XG4gICAgICB0aGlzLmJ3RXN0aW1hdG9yLnNhbXBsZShmcmFnTG9hZGluZ1Byb2Nlc3NpbmdNcyxzdGF0cy5sb2FkZWQpO1xuICAgICAgLy8gaWYgZnJhZ21lbnQgaGFzIGJlZW4gbG9hZGVkIHRvIHBlcmZvcm0gYSBiaXRyYXRlIHRlc3QsIChobHMuc3RhcnRMZXZlbCA9IC0xKSwgc3RvcmUgYml0cmF0ZSB0ZXN0IGRlbGF5IGR1cmF0aW9uXG4gICAgICBpZiAoZnJhZy5iaXRyYXRlVGVzdCkge1xuICAgICAgICB0aGlzLmJpdHJhdGVUZXN0RGVsYXkgPSBmcmFnTG9hZGluZ1Byb2Nlc3NpbmdNcy8xMDAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5iaXRyYXRlVGVzdERlbGF5ID0gMDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBvbkVycm9yKGRhdGEpIHtcbiAgICAvLyBzdG9wIHRpbWVyIGluIGNhc2Ugb2YgZnJhZyBsb2FkaW5nIGVycm9yXG4gICAgc3dpdGNoKGRhdGEuZGV0YWlscykge1xuICAgICAgY2FzZSBFcnJvckRldGFpbHMuRlJBR19MT0FEX0VSUk9SOlxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuRlJBR19MT0FEX1RJTUVPVVQ6XG4gICAgICAgIHRoaXMuY2xlYXJUaW1lcigpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gY2xlYXJUaW1lcigpIHtcbiAgICBpZiAodGhpcy50aW1lcikge1xuICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLnRpbWVyKTtcbiAgICAgIHRoaXMudGltZXIgPSBudWxsO1xuICAgIH1cbiB9XG5cbiAgLyoqIFJldHVybiB0aGUgY2FwcGluZy9tYXggbGV2ZWwgdmFsdWUgdGhhdCBjb3VsZCBiZSB1c2VkIGJ5IGF1dG9tYXRpYyBsZXZlbCBzZWxlY3Rpb24gYWxnb3JpdGhtICoqL1xuICBnZXQgYXV0b0xldmVsQ2FwcGluZygpIHtcbiAgICByZXR1cm4gdGhpcy5fYXV0b0xldmVsQ2FwcGluZztcbiAgfVxuXG4gIC8qKiBzZXQgdGhlIGNhcHBpbmcvbWF4IGxldmVsIHZhbHVlIHRoYXQgY291bGQgYmUgdXNlZCBieSBhdXRvbWF0aWMgbGV2ZWwgc2VsZWN0aW9uIGFsZ29yaXRobSAqKi9cbiAgc2V0IGF1dG9MZXZlbENhcHBpbmcobmV3TGV2ZWwpIHtcbiAgICB0aGlzLl9hdXRvTGV2ZWxDYXBwaW5nID0gbmV3TGV2ZWw7XG4gIH1cblxuICBnZXQgbmV4dEF1dG9MZXZlbCgpIHtcbiAgICBsZXQgbmV4dEF1dG9MZXZlbCA9IHRoaXMuX25leHRBdXRvTGV2ZWwsIGJ3RXN0aW1hdG9yID0gdGhpcy5id0VzdGltYXRvciwgaGxzID0gdGhpcy5obHMsXG4gICAgICBsZXZlbHMgPSBobHMubGV2ZWxzLCBtaW5BdXRvQml0cmF0ZSA9IGhscy5jb25maWcubWluQXV0b0JpdHJhdGU7XG4gICAgLy8gaW4gY2FzZSBuZXh0IGF1dG8gbGV2ZWwgaGFzIGJlZW4gZm9yY2VkLCBhbmQgYncgbm90IGF2YWlsYWJsZSBvciBub3QgcmVsaWFibGVcbiAgICBpZiAobmV4dEF1dG9MZXZlbCAhPT0gLTEgJiYgKCFid0VzdGltYXRvciB8fCAhYndFc3RpbWF0b3IuY2FuRXN0aW1hdGUoKSkpIHtcbiAgICAgIC8vIGNhcCBuZXh0IGF1dG8gbGV2ZWwgYnkgbWF4IGF1dG8gbGV2ZWxcbiAgICAgIHJldHVybiBNYXRoLm1pbihuZXh0QXV0b0xldmVsLHRoaXMubWF4QXV0b0xldmVsKTtcbiAgICB9XG4gICAgLy8gY29tcHV0ZSBuZXh0IGxldmVsIHVzaW5nIEFCUiBsb2dpY1xuICAgIGxldCBuZXh0QUJSQXV0b0xldmVsID0gdGhpcy5uZXh0QUJSQXV0b0xldmVsO1xuICAgIGlmIChuZXh0QXV0b0xldmVsICE9PSAtMSkge1xuICAgICAgLy8gbmV4dEF1dG9MZXZlbCBpcyBkZWZpbmVkLCB1c2UgaXQgdG8gY2FwIEFCUiBjb21wdXRlZCBxdWFsaXR5IGxldmVsXG4gICAgICBuZXh0QUJSQXV0b0xldmVsID0gTWF0aC5taW4obmV4dEF1dG9MZXZlbCxuZXh0QUJSQXV0b0xldmVsKTtcbiAgICB9XG4gICAgaWYobWluQXV0b0JpdHJhdGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgd2hpbGUgKGxldmVsc1tuZXh0QUJSQXV0b0xldmVsXS5iaXRyYXRlIDwgbWluQXV0b0JpdHJhdGUpIHtcbiAgICAgICAgbmV4dEFCUkF1dG9MZXZlbCsrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV4dEFCUkF1dG9MZXZlbDtcbiAgfVxuXG4gIGdldCBtaW5BdXRvTGV2ZWwoKSB7XG4gICAgbGV0IGhscyA9IHRoaXMuaGxzLCBsZXZlbHMgPSBobHMubGV2ZWxzLCBtaW5BdXRvQml0cmF0ZSA9IGhscy5jb25maWcubWluQXV0b0JpdHJhdGUsIGxlbiA9IGxldmVscyA/IGxldmVscy5sZW5ndGggOiAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmIChsZXZlbHNbaV0uYml0cmF0ZSA+IG1pbkF1dG9CaXRyYXRlKSB7XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIGdldCBtYXhBdXRvTGV2ZWwoKSB7XG4gICAgdmFyIGxldmVscyA9IHRoaXMuaGxzLmxldmVscyxhdXRvTGV2ZWxDYXBwaW5nID0gdGhpcy5fYXV0b0xldmVsQ2FwcGluZywgbWF4QXV0b0xldmVsO1xuICAgIGlmIChhdXRvTGV2ZWxDYXBwaW5nPT09IC0xICYmIGxldmVscyAmJiBsZXZlbHMubGVuZ3RoKSB7XG4gICAgICBtYXhBdXRvTGV2ZWwgPSBsZXZlbHMubGVuZ3RoIC0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWF4QXV0b0xldmVsID0gYXV0b0xldmVsQ2FwcGluZztcbiAgICB9XG4gICAgcmV0dXJuIG1heEF1dG9MZXZlbDtcbiAgfVxuXG4gIGdldCBuZXh0QUJSQXV0b0xldmVsKCkge1xuICAgIHZhciBobHMgPSB0aGlzLmhscywgbWF4QXV0b0xldmVsID0gdGhpcy5tYXhBdXRvTGV2ZWwsIGxldmVscyA9IGhscy5sZXZlbHMsIGNvbmZpZyA9IGhscy5jb25maWcsIG1pbkF1dG9MZXZlbCA9IHRoaXMubWluQXV0b0xldmVsO1xuICAgIGNvbnN0IHYgPSBobHMubWVkaWEsXG4gICAgICAgICAgY3VycmVudExldmVsID0gdGhpcy5sYXN0TG9hZGVkRnJhZ0xldmVsLFxuICAgICAgICAgIGN1cnJlbnRGcmFnRHVyYXRpb24gPSB0aGlzLmZyYWdDdXJyZW50ID8gdGhpcy5mcmFnQ3VycmVudC5kdXJhdGlvbiA6IDAsXG4gICAgICAgICAgcG9zID0gKHYgPyB2LmN1cnJlbnRUaW1lIDogMCksXG4gICAgICAgICAgLy8gcGxheWJhY2tSYXRlIGlzIHRoZSBhYnNvbHV0ZSB2YWx1ZSBvZiB0aGUgcGxheWJhY2sgcmF0ZTsgaWYgdi5wbGF5YmFja1JhdGUgaXMgMCwgd2UgdXNlIDEgdG8gbG9hZCBhc1xuICAgICAgICAgIC8vIGlmIHdlJ3JlIHBsYXlpbmcgYmFjayBhdCB0aGUgbm9ybWFsIHJhdGUuXG4gICAgICAgICAgcGxheWJhY2tSYXRlID0gKCh2ICYmICh2LnBsYXliYWNrUmF0ZSAhPT0gMCkpID8gTWF0aC5hYnModi5wbGF5YmFja1JhdGUpIDogMS4wKSxcbiAgICAgICAgICBhdmdidyA9IHRoaXMuYndFc3RpbWF0b3IgPyB0aGlzLmJ3RXN0aW1hdG9yLmdldEVzdGltYXRlKCkgOiBjb25maWcuYWJyRXdtYURlZmF1bHRFc3RpbWF0ZSxcbiAgICAgICAgICAvLyBidWZmZXJTdGFydmF0aW9uRGVsYXkgaXMgdGhlIHdhbGwtY2xvY2sgdGltZSBsZWZ0IHVudGlsIHRoZSBwbGF5YmFjayBidWZmZXIgaXMgZXhoYXVzdGVkLlxuICAgICAgICAgIGJ1ZmZlclN0YXJ2YXRpb25EZWxheSA9IChCdWZmZXJIZWxwZXIuYnVmZmVySW5mbyh2LCBwb3MsIGNvbmZpZy5tYXhCdWZmZXJIb2xlKS5lbmQgLSBwb3MpIC8gcGxheWJhY2tSYXRlO1xuXG4gICAgLy8gRmlyc3QsIGxvb2sgdG8gc2VlIGlmIHdlIGNhbiBmaW5kIGEgbGV2ZWwgbWF0Y2hpbmcgd2l0aCBvdXIgYXZnIGJhbmR3aWR0aCBBTkQgdGhhdCBjb3VsZCBhbHNvIGd1YXJhbnRlZSBubyByZWJ1ZmZlcmluZyBhdCBhbGxcbiAgICBsZXQgYmVzdExldmVsID0gdGhpcy5maW5kQmVzdExldmVsKGN1cnJlbnRMZXZlbCxjdXJyZW50RnJhZ0R1cmF0aW9uLGF2Z2J3LG1pbkF1dG9MZXZlbCxtYXhBdXRvTGV2ZWwsYnVmZmVyU3RhcnZhdGlvbkRlbGF5LGNvbmZpZy5hYnJCYW5kV2lkdGhGYWN0b3IsY29uZmlnLmFickJhbmRXaWR0aFVwRmFjdG9yLGxldmVscyk7XG4gICAgaWYgKGJlc3RMZXZlbCA+PSAwKSB7XG4gICAgICByZXR1cm4gYmVzdExldmVsO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb2dnZXIudHJhY2UoJ3JlYnVmZmVyaW5nIGV4cGVjdGVkIHRvIGhhcHBlbiwgbGV0cyB0cnkgdG8gZmluZCBhIHF1YWxpdHkgbGV2ZWwgbWluaW1pemluZyB0aGUgcmVidWZmZXJpbmcnKTtcbiAgICAgIC8vIG5vdCBwb3NzaWJsZSB0byBnZXQgcmlkIG9mIHJlYnVmZmVyaW5nIC4uLiBsZXQncyB0cnkgdG8gZmluZCBsZXZlbCB0aGF0IHdpbGwgZ3VhcmFudGVlIGxlc3MgdGhhbiBtYXhTdGFydmF0aW9uRGVsYXkgb2YgcmVidWZmZXJpbmdcbiAgICAgIC8vIGlmIG5vIG1hdGNoaW5nIGxldmVsIGZvdW5kLCBsb2dpYyB3aWxsIHJldHVybiAwXG4gICAgICBsZXQgbWF4U3RhcnZhdGlvbkRlbGF5ID0gY29uZmlnLm1heFN0YXJ2YXRpb25EZWxheSxcbiAgICAgICAgICBid0ZhY3RvciA9IGNvbmZpZy5hYnJCYW5kV2lkdGhGYWN0b3IsXG4gICAgICAgICAgYndVcEZhY3RvciA9IGNvbmZpZy5hYnJCYW5kV2lkdGhVcEZhY3RvcjtcbiAgICAgIGlmIChidWZmZXJTdGFydmF0aW9uRGVsYXkgPT09IDApIHtcbiAgICAgICAgLy8gaW4gY2FzZSBidWZmZXIgaXMgZW1wdHksIGxldCdzIGNoZWNrIGlmIHByZXZpb3VzIGZyYWdtZW50IHdhcyBsb2FkZWQgdG8gcGVyZm9ybSBhIGJpdHJhdGUgdGVzdFxuICAgICAgICBsZXQgYml0cmF0ZVRlc3REZWxheSA9IHRoaXMuYml0cmF0ZVRlc3REZWxheTtcbiAgICAgICAgaWYgKGJpdHJhdGVUZXN0RGVsYXkpIHtcbiAgICAgICAgICAvLyBpZiBpdCBpcyB0aGUgY2FzZSwgdGhlbiB3ZSBuZWVkIHRvIGFkanVzdCBvdXIgbWF4IHN0YXJ2YXRpb24gZGVsYXkgdXNpbmcgbWF4TG9hZGluZ0RlbGF5IGNvbmZpZyB2YWx1ZVxuICAgICAgICAgIC8vIG1heCB2aWRlbyBsb2FkaW5nIGRlbGF5IHVzZWQgaW4gIGF1dG9tYXRpYyBzdGFydCBsZXZlbCBzZWxlY3Rpb24gOlxuICAgICAgICAgIC8vIGluIHRoYXQgbW9kZSBBQlIgY29udHJvbGxlciB3aWxsIGVuc3VyZSB0aGF0IHZpZGVvIGxvYWRpbmcgdGltZSAoaWUgdGhlIHRpbWUgdG8gZmV0Y2ggdGhlIGZpcnN0IGZyYWdtZW50IGF0IGxvd2VzdCBxdWFsaXR5IGxldmVsICtcbiAgICAgICAgICAvLyB0aGUgdGltZSB0byBmZXRjaCB0aGUgZnJhZ21lbnQgYXQgdGhlIGFwcHJvcHJpYXRlIHF1YWxpdHkgbGV2ZWwgaXMgbGVzcyB0aGFuIGBgYG1heExvYWRpbmdEZWxheWBgYCApXG4gICAgICAgICAgbWF4U3RhcnZhdGlvbkRlbGF5ID0gY29uZmlnLm1heExvYWRpbmdEZWxheSAtIGJpdHJhdGVUZXN0RGVsYXk7XG4gICAgICAgICAgbG9nZ2VyLnRyYWNlKGBiaXRyYXRlIHRlc3QgdG9vayAke01hdGgucm91bmQoMTAwMCpiaXRyYXRlVGVzdERlbGF5KX1tcywgc2V0IGZpcnN0IGZyYWdtZW50IG1heCBmZXRjaER1cmF0aW9uIHRvICR7TWF0aC5yb3VuZCgxMDAwKm1heFN0YXJ2YXRpb25EZWxheSl9IG1zYCk7XG4gICAgICAgICAgLy8gZG9uJ3QgdXNlIGNvbnNlcnZhdGl2ZSBmYWN0b3Igb24gYml0cmF0ZSB0ZXN0XG4gICAgICAgICAgYndGYWN0b3IgPSBid1VwRmFjdG9yID0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYmVzdExldmVsID0gdGhpcy5maW5kQmVzdExldmVsKGN1cnJlbnRMZXZlbCxjdXJyZW50RnJhZ0R1cmF0aW9uLGF2Z2J3LG1pbkF1dG9MZXZlbCxtYXhBdXRvTGV2ZWwsYnVmZmVyU3RhcnZhdGlvbkRlbGF5K21heFN0YXJ2YXRpb25EZWxheSxid0ZhY3Rvcixid1VwRmFjdG9yLGxldmVscyk7XG4gICAgICByZXR1cm4gTWF0aC5tYXgoYmVzdExldmVsLDApO1xuICAgIH1cbiAgfVxuXG4gIGZpbmRCZXN0TGV2ZWwoY3VycmVudExldmVsLGN1cnJlbnRGcmFnRHVyYXRpb24sY3VycmVudEJ3LG1pbkF1dG9MZXZlbCxtYXhBdXRvTGV2ZWwsbWF4RmV0Y2hEdXJhdGlvbixid0ZhY3Rvcixid1VwRmFjdG9yLGxldmVscykge1xuICAgIGZvciAobGV0IGkgPSBtYXhBdXRvTGV2ZWw7IGkgPj0gbWluQXV0b0xldmVsOyBpLS0pIHtcbiAgICAgIGxldCBsZXZlbEluZm8gPSBsZXZlbHNbaV0sXG4gICAgICAgICAgbGV2ZWxEZXRhaWxzID0gbGV2ZWxJbmZvLmRldGFpbHMsXG4gICAgICAgICAgYXZnRHVyYXRpb24gPSBsZXZlbERldGFpbHMgPyBsZXZlbERldGFpbHMudG90YWxkdXJhdGlvbi9sZXZlbERldGFpbHMuZnJhZ21lbnRzLmxlbmd0aCA6IGN1cnJlbnRGcmFnRHVyYXRpb24sXG4gICAgICAgICAgbGl2ZSA9IGxldmVsRGV0YWlscyA/IGxldmVsRGV0YWlscy5saXZlIDogZmFsc2UsXG4gICAgICAgICAgYWRqdXN0ZWRidztcbiAgICAvLyBmb2xsb3cgYWxnb3JpdGhtIGNhcHR1cmVkIGZyb20gc3RhZ2VmcmlnaHQgOlxuICAgIC8vIGh0dHBzOi8vYW5kcm9pZC5nb29nbGVzb3VyY2UuY29tL3BsYXRmb3JtL2ZyYW1ld29ya3MvYXYvKy9tYXN0ZXIvbWVkaWEvbGlic3RhZ2VmcmlnaHQvaHR0cGxpdmUvTGl2ZVNlc3Npb24uY3BwXG4gICAgLy8gUGljayB0aGUgaGlnaGVzdCBiYW5kd2lkdGggc3RyZWFtIGJlbG93IG9yIGVxdWFsIHRvIGVzdGltYXRlZCBiYW5kd2lkdGguXG4gICAgLy8gY29uc2lkZXIgb25seSA4MCUgb2YgdGhlIGF2YWlsYWJsZSBiYW5kd2lkdGgsIGJ1dCBpZiB3ZSBhcmUgc3dpdGNoaW5nIHVwLFxuICAgIC8vIGJlIGV2ZW4gbW9yZSBjb25zZXJ2YXRpdmUgKDcwJSkgdG8gYXZvaWQgb3ZlcmVzdGltYXRpbmcgYW5kIGltbWVkaWF0ZWx5XG4gICAgLy8gc3dpdGNoaW5nIGJhY2suXG4gICAgICBpZiAoaSA8PSBjdXJyZW50TGV2ZWwpIHtcbiAgICAgICAgYWRqdXN0ZWRidyA9IGJ3RmFjdG9yICogY3VycmVudEJ3O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWRqdXN0ZWRidyA9IGJ3VXBGYWN0b3IgKiBjdXJyZW50Qnc7XG4gICAgICB9XG4gICAgICBjb25zdCBiaXRyYXRlID0gbGV2ZWxzW2ldLmJpdHJhdGUsXG4gICAgICAgICAgICBmZXRjaER1cmF0aW9uID0gYml0cmF0ZSAqIGF2Z0R1cmF0aW9uIC8gYWRqdXN0ZWRidztcblxuICAgIGxvZ2dlci50cmFjZShgbGV2ZWwvYWRqdXN0ZWRidy9iaXRyYXRlL2F2Z0R1cmF0aW9uL21heEZldGNoRHVyYXRpb24vZmV0Y2hEdXJhdGlvbjogJHtpfS8ke01hdGgucm91bmQoYWRqdXN0ZWRidyl9LyR7Yml0cmF0ZX0vJHthdmdEdXJhdGlvbn0vJHttYXhGZXRjaER1cmF0aW9ufS8ke2ZldGNoRHVyYXRpb259YCk7XG4gICAgICAvLyBpZiBhZGp1c3RlZCBidyBpcyBncmVhdGVyIHRoYW4gbGV2ZWwgYml0cmF0ZSBBTkRcbiAgICAgIGlmIChhZGp1c3RlZGJ3ID4gYml0cmF0ZSAmJlxuICAgICAgLy8gZnJhZ21lbnQgZmV0Y2hEdXJhdGlvbiB1bmtub3duIE9SIGxpdmUgc3RyZWFtIE9SIGZyYWdtZW50IGZldGNoRHVyYXRpb24gbGVzcyB0aGFuIG1heCBhbGxvd2VkIGZldGNoIGR1cmF0aW9uLCB0aGVuIHRoaXMgbGV2ZWwgbWF0Y2hlc1xuICAgICAgLy8gd2UgZG9uJ3QgYWNjb3VudCBmb3IgbWF4IEZldGNoIER1cmF0aW9uIGZvciBsaXZlIHN0cmVhbXMsIHRoaXMgaXMgdG8gYXZvaWQgc3dpdGNoaW5nIGRvd24gd2hlbiBuZWFyIHRoZSBlZGdlIG9mIGxpdmUgc2xpZGluZyB3aW5kb3cgLi4uXG4gICAgICAgICghZmV0Y2hEdXJhdGlvbiB8fMKgbGl2ZSB8fCBmZXRjaER1cmF0aW9uIDwgbWF4RmV0Y2hEdXJhdGlvbikgKSB7XG4gICAgICAgIC8vIGFzIHdlIGFyZSBsb29waW5nIGZyb20gaGlnaGVzdCB0byBsb3dlc3QsIHRoaXMgd2lsbCByZXR1cm4gdGhlIGJlc3QgYWNoaWV2YWJsZSBxdWFsaXR5IGxldmVsXG5cbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIG5vdCBlbm91Z2ggdGltZSBidWRnZXQgZXZlbiB3aXRoIHF1YWxpdHkgbGV2ZWwgMCAuLi4gcmVidWZmZXJpbmcgbWlnaHQgaGFwcGVuXG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgc2V0IG5leHRBdXRvTGV2ZWwobmV4dExldmVsKSB7XG4gICAgdGhpcy5fbmV4dEF1dG9MZXZlbCA9IG5leHRMZXZlbDtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBBYnJDb250cm9sbGVyO1xuXG4iLCIvKlxuICogQXVkaW8gU3RyZWFtIENvbnRyb2xsZXJcbiovXG5cbmltcG9ydCBCaW5hcnlTZWFyY2ggZnJvbSAnLi4vdXRpbHMvYmluYXJ5LXNlYXJjaCc7XG5pbXBvcnQgQnVmZmVySGVscGVyIGZyb20gJy4uL2hlbHBlci9idWZmZXItaGVscGVyJztcbmltcG9ydCBEZW11eGVyIGZyb20gJy4uL2RlbXV4L2RlbXV4ZXInO1xuaW1wb3J0IEV2ZW50IGZyb20gJy4uL2V2ZW50cyc7XG5pbXBvcnQgRXZlbnRIYW5kbGVyIGZyb20gJy4uL2V2ZW50LWhhbmRsZXInO1xuaW1wb3J0IExldmVsSGVscGVyIGZyb20gJy4uL2hlbHBlci9sZXZlbC1oZWxwZXInO1xuaW1wb3J0IFRpbWVSYW5nZXMgZnJvbSAnLi4vdXRpbHMvdGltZVJhbmdlcyc7XG5pbXBvcnQge0Vycm9yVHlwZXMsIEVycm9yRGV0YWlsc30gZnJvbSAnLi4vZXJyb3JzJztcbmltcG9ydCB7bG9nZ2VyfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xuXG5jb25zdCBTdGF0ZSA9IHtcbiAgU1RPUFBFRCA6ICdTVE9QUEVEJyxcbiAgU1RBUlRJTkcgOiAnU1RBUlRJTkcnLFxuICBJRExFIDogJ0lETEUnLFxuICBQQVVTRUQgOiAnUEFVU0VEJyxcbiAgS0VZX0xPQURJTkcgOiAnS0VZX0xPQURJTkcnLFxuICBGUkFHX0xPQURJTkcgOiAnRlJBR19MT0FESU5HJyxcbiAgRlJBR19MT0FESU5HX1dBSVRJTkdfUkVUUlkgOiAnRlJBR19MT0FESU5HX1dBSVRJTkdfUkVUUlknLFxuICBXQUlUSU5HX1RSQUNLIDogJ1dBSVRJTkdfVFJBQ0snLFxuICBQQVJTSU5HIDogJ1BBUlNJTkcnLFxuICBQQVJTRUQgOiAnUEFSU0VEJyxcbiAgRU5ERUQgOiAnRU5ERUQnLFxuICBFUlJPUiA6ICdFUlJPUicsXG4gIFdBSVRJTkdfSU5JVF9QVFMgOiAnV0FJVElOR19JTklUX1BUUydcbn07XG5cbmNsYXNzIEF1ZGlvU3RyZWFtQ29udHJvbGxlciBleHRlbmRzIEV2ZW50SGFuZGxlciB7XG5cbiAgY29uc3RydWN0b3IoaGxzKSB7XG4gICAgc3VwZXIoaGxzLFxuICAgICAgRXZlbnQuTUVESUFfQVRUQUNIRUQsXG4gICAgICBFdmVudC5NRURJQV9ERVRBQ0hJTkcsXG4gICAgICBFdmVudC5BVURJT19UUkFDS1NfVVBEQVRFRCxcbiAgICAgIEV2ZW50LkFVRElPX1RSQUNLX1NXSVRDSElORyxcbiAgICAgIEV2ZW50LkFVRElPX1RSQUNLX0xPQURFRCxcbiAgICAgIEV2ZW50LktFWV9MT0FERUQsXG4gICAgICBFdmVudC5GUkFHX0xPQURFRCxcbiAgICAgIEV2ZW50LkZSQUdfUEFSU0lOR19JTklUX1NFR01FTlQsXG4gICAgICBFdmVudC5GUkFHX1BBUlNJTkdfREFUQSxcbiAgICAgIEV2ZW50LkZSQUdfUEFSU0VELFxuICAgICAgRXZlbnQuRVJST1IsXG4gICAgICBFdmVudC5CVUZGRVJfQ1JFQVRFRCxcbiAgICAgIEV2ZW50LkJVRkZFUl9BUFBFTkRFRCxcbiAgICAgIEV2ZW50LkJVRkZFUl9GTFVTSEVELFxuICAgICAgRXZlbnQuSU5JVF9QVFNfRk9VTkQpO1xuXG4gICAgdGhpcy5jb25maWcgPSBobHMuY29uZmlnO1xuICAgIHRoaXMuYXVkaW9Db2RlY1N3YXAgPSBmYWxzZTtcbiAgICB0aGlzLnRpY2tzID0gMDtcbiAgICB0aGlzLm9udGljayA9IHRoaXMudGljay5iaW5kKHRoaXMpO1xuICAgIHRoaXMuaW5pdFBUUz1bXTtcbiAgICB0aGlzLndhaXRpbmdGcmFnbWVudD1udWxsO1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnN0b3BMb2FkKCk7XG4gICAgaWYgKHRoaXMudGltZXIpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy50aW1lcik7XG4gICAgICB0aGlzLnRpbWVyID0gbnVsbDtcbiAgICB9XG4gICAgRXZlbnRIYW5kbGVyLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XG4gICAgdGhpcy5zdGF0ZSA9IFN0YXRlLlNUT1BQRUQ7XG4gIH1cblxuICAvL1NpZ25hbCB0aGF0IHZpZGVvIFBUUyB3YXMgZm91bmRcbiAgb25Jbml0UHRzRm91bmQoZGF0YSkge1xuICAgIHZhciBkZW11eGVySWQ9ZGF0YS5pZCwgY2MgPSBkYXRhLmNjLCBpbml0UFRTID0gZGF0YS5pbml0UFRTO1xuICAgIGlmKGRlbXV4ZXJJZCA9PT0gJ21haW4nKSB7XG4gICAgICAvL0Fsd2F5cyB1cGRhdGUgdGhlIG5ldyBJTklUIFBUU1xuICAgICAgLy9DYW4gY2hhbmdlIGR1ZSBsZXZlbCBzd2l0Y2hcbiAgICAgIHRoaXMuaW5pdFBUU1tjY10gPSBpbml0UFRTO1xuICAgICAgbG9nZ2VyLmxvZyhgSW5pdFBUUyBmb3IgY2M6JHtjY30gZm91bmQgZnJvbSB2aWRlbyB0cmFjazoke2luaXRQVFN9YCk7XG5cbiAgICAgIC8vSWYgd2UgYXJlIHdhaXRpbmcgd2UgbmVlZCB0byBkZW11eC9yZW11eCB0aGUgd2FpdGluZyBmcmFnXG4gICAgICAvL1dpdGggdGhlIG5ldyBpbml0UFRTXG4gICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuV0FJVElOR19JTklUX1BUUykge1xuICAgICAgICBsb2dnZXIubG9nKCdzZW5kaW5nIHBlbmRpbmcgYXVkaW8gZnJhZyB0byBkZW11eGVyJyk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5GUkFHX0xPQURJTkc7XG4gICAgICAgIC8vV2UgaGF2ZSBhdWRpbyBmcmFnIHdhaXRpbmcgb3IgdmlkZW8gcHRzXG4gICAgICAgIC8vTGV0IHByb2Nlc3MgaXRcbiAgICAgICAgdGhpcy5vbkZyYWdMb2FkZWQodGhpcy53YWl0aW5nRnJhZ21lbnQpO1xuICAgICAgICAvL0xldHMgY2xlYW4gdGhlIHdhaXRpbmcgZnJhZ1xuICAgICAgICB0aGlzLndhaXRpbmdGcmFnbWVudCA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgc3RhcnRMb2FkKHN0YXJ0UG9zaXRpb24pIHtcbiAgICBpZiAodGhpcy50cmFja3MpIHtcbiAgICAgIHZhciBsYXN0Q3VycmVudFRpbWUgPSB0aGlzLmxhc3RDdXJyZW50VGltZTtcbiAgICAgIHRoaXMuc3RvcExvYWQoKTtcbiAgICAgIGlmICghdGhpcy50aW1lcikge1xuICAgICAgICB0aGlzLnRpbWVyID0gc2V0SW50ZXJ2YWwodGhpcy5vbnRpY2ssIDEwMCk7XG4gICAgICB9XG4gICAgICB0aGlzLmZyYWdMb2FkRXJyb3IgPSAwO1xuICAgICAgaWYgKGxhc3RDdXJyZW50VGltZSA+IDAgJiYgc3RhcnRQb3NpdGlvbiA9PT0gLTEpIHtcbiAgICAgICAgbG9nZ2VyLmxvZyhgYXVkaW86b3ZlcnJpZGUgc3RhcnRQb3NpdGlvbiB3aXRoIGxhc3RDdXJyZW50VGltZSBAJHtsYXN0Q3VycmVudFRpbWUudG9GaXhlZCgzKX1gKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmxhc3RDdXJyZW50VGltZSA9IHRoaXMuc3RhcnRQb3NpdGlvbiA/IHRoaXMuc3RhcnRQb3NpdGlvbiA6IHN0YXJ0UG9zaXRpb247XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5TVEFSVElORztcbiAgICAgIH1cbiAgICAgIHRoaXMubmV4dExvYWRQb3NpdGlvbiA9IHRoaXMuc3RhcnRQb3NpdGlvbiA9IHRoaXMubGFzdEN1cnJlbnRUaW1lO1xuICAgICAgdGhpcy50aWNrKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3RhcnRQb3NpdGlvbiA9IHN0YXJ0UG9zaXRpb247XG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuU1RPUFBFRDtcbiAgICB9XG4gIH1cblxuICBzdG9wTG9hZCgpIHtcbiAgICB2YXIgZnJhZyA9IHRoaXMuZnJhZ0N1cnJlbnQ7XG4gICAgaWYgKGZyYWcpIHtcbiAgICAgIGlmIChmcmFnLmxvYWRlcikge1xuICAgICAgICBmcmFnLmxvYWRlci5hYm9ydCgpO1xuICAgICAgfVxuICAgICAgdGhpcy5mcmFnQ3VycmVudCA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMuZnJhZ1ByZXZpb3VzID0gbnVsbDtcbiAgICBpZiAodGhpcy5kZW11eGVyKSB7XG4gICAgICB0aGlzLmRlbXV4ZXIuZGVzdHJveSgpO1xuICAgICAgdGhpcy5kZW11eGVyID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5zdGF0ZSA9IFN0YXRlLlNUT1BQRUQ7XG4gIH1cblxuICB0aWNrKCkge1xuICAgIHRoaXMudGlja3MrKztcbiAgICBpZiAodGhpcy50aWNrcyA9PT0gMSkge1xuICAgICAgdGhpcy5kb1RpY2soKTtcbiAgICAgIGlmICh0aGlzLnRpY2tzID4gMSkge1xuICAgICAgICBzZXRUaW1lb3V0KHRoaXMudGljaywgMSk7XG4gICAgICB9XG4gICAgICB0aGlzLnRpY2tzID0gMDtcbiAgICB9XG4gIH1cblxuICBkb1RpY2soKSB7XG4gICAgdmFyIHBvcywgdHJhY2ssIHRyYWNrRGV0YWlscywgaGxzID0gdGhpcy5obHMsIGNvbmZpZyA9IGhscy5jb25maWc7XG4gICAgLy9sb2dnZXIubG9nKCdhdWRpb1N0cmVhbTonICsgdGhpcy5zdGF0ZSk7XG4gICAgc3dpdGNoKHRoaXMuc3RhdGUpIHtcbiAgICAgIGNhc2UgU3RhdGUuRVJST1I6XG4gICAgICAgIC8vZG9uJ3QgZG8gYW55dGhpbmcgaW4gZXJyb3Igc3RhdGUgdG8gYXZvaWQgYnJlYWtpbmcgZnVydGhlciAuLi5cbiAgICAgIGNhc2UgU3RhdGUuUEFVU0VEOlxuICAgICAgICAvL2Rvbid0IGRvIGFueXRoaW5nIGluIHBhdXNlZCBzdGF0ZSBlaXRoZXIgLi4uXG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBTdGF0ZS5TVEFSVElORzpcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLldBSVRJTkdfVFJBQ0s7XG4gICAgICAgIHRoaXMubG9hZGVkbWV0YWRhdGEgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFN0YXRlLklETEU6XG4gICAgICAgIC8vIGlmIHZpZGVvIG5vdCBhdHRhY2hlZCBBTkRcbiAgICAgICAgLy8gc3RhcnQgZnJhZ21lbnQgYWxyZWFkeSByZXF1ZXN0ZWQgT1Igc3RhcnQgZnJhZyBwcmVmZXRjaCBkaXNhYmxlXG4gICAgICAgIC8vIGV4aXQgbG9vcFxuICAgICAgICAvLyA9PiBpZiBtZWRpYSBub3QgYXR0YWNoZWQgYnV0IHN0YXJ0IGZyYWcgcHJlZmV0Y2ggaXMgZW5hYmxlZCBhbmQgc3RhcnQgZnJhZyBub3QgcmVxdWVzdGVkIHlldCwgd2Ugd2lsbCBub3QgZXhpdCBsb29wXG4gICAgICAgIGlmICghdGhpcy5tZWRpYSAmJlxuICAgICAgICAgICh0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCB8fCAhY29uZmlnLnN0YXJ0RnJhZ1ByZWZldGNoKSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vIGRldGVybWluZSBuZXh0IGNhbmRpZGF0ZSBmcmFnbWVudCB0byBiZSBsb2FkZWQsIGJhc2VkIG9uIGN1cnJlbnQgcG9zaXRpb24gYW5kXG4gICAgICAgIC8vICBlbmQgb2YgYnVmZmVyIHBvc2l0aW9uXG4gICAgICAgIC8vIGlmIHdlIGhhdmUgbm90IHlldCBsb2FkZWQgYW55IGZyYWdtZW50LCBzdGFydCBsb2FkaW5nIGZyb20gc3RhcnQgcG9zaXRpb25cbiAgICAgICAgaWYgKHRoaXMubG9hZGVkbWV0YWRhdGEpIHtcbiAgICAgICAgICBwb3MgPSB0aGlzLm1lZGlhLmN1cnJlbnRUaW1lO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMubmV4dExvYWRQb3NpdGlvbikge1xuICAgICAgICAgIHBvcyA9IHRoaXMubmV4dExvYWRQb3NpdGlvbjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwb3MgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IG1lZGlhID0gdGhpcy5tZWRpYUJ1ZmZlciA/IHRoaXMubWVkaWFCdWZmZXIgOiB0aGlzLm1lZGlhLFxuICAgICAgICAgICAgYnVmZmVySW5mbyA9IEJ1ZmZlckhlbHBlci5idWZmZXJJbmZvKG1lZGlhLHBvcyxjb25maWcubWF4QnVmZmVySG9sZSksXG4gICAgICAgICAgICBidWZmZXJMZW4gPSBidWZmZXJJbmZvLmxlbixcbiAgICAgICAgICAgIGJ1ZmZlckVuZCA9IGJ1ZmZlckluZm8uZW5kLFxuICAgICAgICAgICAgZnJhZ1ByZXZpb3VzID0gdGhpcy5mcmFnUHJldmlvdXMsXG4gICAgICAgICAgICBtYXhCdWZMZW4gPSBjb25maWcubWF4TWF4QnVmZmVyTGVuZ3RoLFxuICAgICAgICAgICAgYXVkaW9Td2l0Y2ggPSB0aGlzLmF1ZGlvU3dpdGNoO1xuXG4gICAgICAgIC8vIGlmIGJ1ZmZlciBsZW5ndGggaXMgbGVzcyB0aGFuIG1heEJ1ZkxlbiB0cnkgdG8gbG9hZCBhIG5ldyBmcmFnbWVudFxuICAgICAgICBpZiAoYnVmZmVyTGVuIDwgbWF4QnVmTGVuICYmIHRoaXMudHJhY2tJZCA8IHRoaXMudHJhY2tzLmxlbmd0aCkge1xuICAgICAgICAgIHRyYWNrRGV0YWlscyA9IHRoaXMudHJhY2tzW3RoaXMudHJhY2tJZF0uZGV0YWlscztcbiAgICAgICAgICAvLyBpZiB0cmFjayBpbmZvIG5vdCByZXRyaWV2ZWQgeWV0LCBzd2l0Y2ggc3RhdGUgYW5kIHdhaXQgZm9yIHRyYWNrIHJldHJpZXZhbFxuICAgICAgICAgIGlmICh0eXBlb2YgdHJhY2tEZXRhaWxzID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLldBSVRJTkdfVFJBQ0s7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgLy8gd2UganVzdCBnb3QgZG9uZSBsb2FkaW5nIHRoZSBmaW5hbCBmcmFnbWVudCwgY2hlY2sgaWYgd2UgbmVlZCB0byBmaW5hbGl6ZSBtZWRpYSBzdHJlYW1cbiAgICAgICAgaWYgKCFhdWRpb1N3aXRjaCAmJiAhdHJhY2tEZXRhaWxzLmxpdmUgJiYgZnJhZ1ByZXZpb3VzICYmIGZyYWdQcmV2aW91cy5zbiA9PT0gdHJhY2tEZXRhaWxzLmVuZFNOKSB7XG4gICAgICAgICAgICAvLyBpZiB3ZSBhcmUgbm90IHNlZWtpbmcgb3IgaWYgd2UgYXJlIHNlZWtpbmcgYnV0IGV2ZXJ5dGhpbmcgKGFsbW9zdCkgdGlsIHRoZSBlbmQgaXMgYnVmZmVyZWQsIGxldCdzIHNpZ25hbCBlb3NcbiAgICAgICAgICAgIC8vIHdlIGRvbid0IGNvbXBhcmUgZXhhY3RseSBtZWRpYS5kdXJhdGlvbiA9PT0gYnVmZmVySW5mby5lbmQgYXMgdGhlcmUgY291bGQgYmUgc29tZSBzdWJ0bGUgbWVkaWEgZHVyYXRpb24gZGlmZmVyZW5jZSB3aGVuIHN3aXRjaGluZ1xuICAgICAgICAgICAgLy8gYmV0d2VlbiBkaWZmZXJlbnQgcmVuZGl0aW9ucy4gdXNpbmcgaGFsZiBmcmFnIGR1cmF0aW9uIHNob3VsZCBoZWxwIGNvcGUgd2l0aCB0aGVzZSBjYXNlcy5cbiAgICAgICAgICAgIGlmICghdGhpcy5tZWRpYS5zZWVraW5nIHx8ICh0aGlzLm1lZGlhLmR1cmF0aW9uLWJ1ZmZlckVuZCkgPCBmcmFnUHJldmlvdXMuZHVyYXRpb24vMikge1xuICAgICAgICAgICAgLy8gRmluYWxpemUgdGhlIG1lZGlhIHN0cmVhbVxuICAgICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5CVUZGRVJfRU9TLHsgdHlwZSA6ICdhdWRpbyd9KTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5FTkRFRDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgICAgLy8gZmluZCBmcmFnbWVudCBpbmRleCwgY29udGlndW91cyB3aXRoIGVuZCBvZiBidWZmZXIgcG9zaXRpb25cbiAgICAgICAgICBsZXQgZnJhZ21lbnRzID0gdHJhY2tEZXRhaWxzLmZyYWdtZW50cyxcbiAgICAgICAgICAgICAgZnJhZ0xlbiA9IGZyYWdtZW50cy5sZW5ndGgsXG4gICAgICAgICAgICAgIHN0YXJ0ID0gZnJhZ21lbnRzWzBdLnN0YXJ0LFxuICAgICAgICAgICAgICBlbmQgPSBmcmFnbWVudHNbZnJhZ0xlbi0xXS5zdGFydCArIGZyYWdtZW50c1tmcmFnTGVuLTFdLmR1cmF0aW9uLFxuICAgICAgICAgICAgICBmcmFnO1xuXG4gICAgICAgICAgLy8gV2hlbiBzd2l0Y2hpbmcgYXVkaW8gdHJhY2ssIHJlbG9hZCBhdWRpbyBhcyBjbG9zZSBhcyBwb3NzaWJsZSB0byBjdXJyZW50VGltZVxuICAgICAgICAgIGlmKGF1ZGlvU3dpdGNoKXtcbiAgICAgICAgICAgIGlmICh0cmFja0RldGFpbHMubGl2ZSAmJiAhdHJhY2tEZXRhaWxzLlBUU0tub3duKSB7XG4gICAgICAgICAgICAgIGxvZ2dlci5sb2coYHN3aXRjaGluZyBhdWRpb3RyYWNrLCBsaXZlIHN0cmVhbSwgdW5rbm93biBQVFMsbG9hZCBmaXJzdCBmcmFnbWVudGApO1xuICAgICAgICAgICAgICBidWZmZXJFbmQgPSAwO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYnVmZmVyRW5kID0gcG9zO1xuICAgICAgICAgICAgICAvLyBpZiBjdXJyZW50VGltZSAocG9zKSBpcyBsZXNzIHRoYW4gYWx0IGF1ZGlvIHBsYXlsaXN0IHN0YXJ0IHRpbWUsIGl0IG1lYW5zIHRoYXQgYWx0IGF1ZGlvIGlzIGFoZWFkIG9mIGN1cnJlbnRUaW1lXG4gICAgICAgICAgICAgIGlmICh0cmFja0RldGFpbHMuUFRTS25vd24gJiYgcG9zIDwgc3RhcnQpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiBldmVyeXRoaW5nIGlzIGJ1ZmZlcmVkIGZyb20gcG9zIHRvIHN0YXJ0LCBsZXQncyBzZWVrIHRvIHN0YXJ0XG4gICAgICAgICAgICAgICAgaWYgKGJ1ZmZlckluZm8uZW5kID4gc3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgIGxvZ2dlci5sb2coJ2FsdCBhdWRpbyB0cmFjayBhaGVhZCBvZiBtYWluIHRyYWNrLCBzZWVrIHRvIHN0YXJ0IG9mIGFsdCBhdWRpbyB0cmFjaycpO1xuICAgICAgICAgICAgICAgICAgdGhpcy5tZWRpYS5jdXJyZW50VGltZSA9IHN0YXJ0ICsgMC4wNTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGlmIGJ1ZmZlckVuZCBiZWZvcmUgc3RhcnQgb2YgcGxheWxpc3QsIGxvYWQgZmlyc3QgZnJhZ21lbnRcbiAgICAgICAgICBpZiAoYnVmZmVyRW5kIDwgc3RhcnQpIHtcbiAgICAgICAgICAgIGZyYWcgPSBmcmFnbWVudHNbMF07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBmb3VuZEZyYWc7XG4gICAgICAgICAgICBsZXQgbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSA9IGNvbmZpZy5tYXhGcmFnTG9va1VwVG9sZXJhbmNlO1xuICAgICAgICAgICAgbGV0IGZyYWdOZXh0ID0gKGZyYWdQcmV2aW91cykgPyBmcmFnbWVudHMuZmluZCgoZnJhZ21lbnQpID0+IHsgcmV0dXJuIGZyYWdtZW50LnNuID09PSBmcmFnUHJldmlvdXMuc24gKyAxOyB9KSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGxldCBmcmFnbWVudFdpdGhpblRvbGVyYW5jZVRlc3QgPSAoY2FuZGlkYXRlKSA9PiB7XG4gICAgICAgICAgICAgIC8vIG9mZnNldCBzaG91bGQgYmUgd2l0aGluIGZyYWdtZW50IGJvdW5kYXJ5IC0gY29uZmlnLm1heEZyYWdMb29rVXBUb2xlcmFuY2VcbiAgICAgICAgICAgICAgLy8gdGhpcyBpcyB0byBjb3BlIHdpdGggc2l0dWF0aW9ucyBsaWtlXG4gICAgICAgICAgICAgIC8vIGJ1ZmZlckVuZCA9IDkuOTkxXG4gICAgICAgICAgICAgIC8vIGZyYWdbw5hdIDogWzAsMTBdXG4gICAgICAgICAgICAgIC8vIGZyYWdbMV0gOiBbMTAsMjBdXG4gICAgICAgICAgICAgIC8vIGJ1ZmZlckVuZCBpcyB3aXRoaW4gZnJhZ1swXSByYW5nZSAuLi4gYWx0aG91Z2ggd2hhdCB3ZSBhcmUgZXhwZWN0aW5nIGlzIHRvIHJldHVybiBmcmFnWzFdIGhlcmVcbiAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgIGZyYWcgc3RhcnQgICAgICAgICAgICAgICBmcmFnIHN0YXJ0K2R1cmF0aW9uXG4gICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICAgfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfFxuICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgPC0tLT4gICAgICAgICAgICAgICAgICAgICAgICAgPC0tLT5cbiAgICAgICAgICAgICAgLy8gIC4uLi0tLS0tLS0tPjwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLT48LS0tLS0tLS0tLi4uLlxuICAgICAgICAgICAgICAvLyBwcmV2aW91cyBmcmFnICAgICAgICAgbWF0Y2hpbmcgZnJhZ21lbnQgICAgICAgICBuZXh0IGZyYWdcbiAgICAgICAgICAgICAgLy8gIHJldHVybiAtMSAgICAgICAgICAgICByZXR1cm4gMCAgICAgICAgICAgICAgICAgcmV0dXJuIDFcbiAgICAgICAgICAgICAgLy9sb2dnZXIubG9nKGBsZXZlbC9zbi9zdGFydC9lbmQvYnVmRW5kOiR7bGV2ZWx9LyR7Y2FuZGlkYXRlLnNufS8ke2NhbmRpZGF0ZS5zdGFydH0vJHsoY2FuZGlkYXRlLnN0YXJ0K2NhbmRpZGF0ZS5kdXJhdGlvbil9LyR7YnVmZmVyRW5kfWApO1xuICAgICAgICAgICAgICAvLyBTZXQgdGhlIGxvb2t1cCB0b2xlcmFuY2UgdG8gYmUgc21hbGwgZW5vdWdoIHRvIGRldGVjdCB0aGUgY3VycmVudCBzZWdtZW50IC0gZW5zdXJlcyB3ZSBkb24ndCBza2lwIG92ZXIgdmVyeSBzbWFsbCBzZWdtZW50c1xuICAgICAgICAgICAgICBsZXQgY2FuZGlkYXRlTG9va3VwVG9sZXJhbmNlID0gTWF0aC5taW4obWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSwgY2FuZGlkYXRlLmR1cmF0aW9uKTtcbiAgICAgICAgICAgICAgaWYgKChjYW5kaWRhdGUuc3RhcnQgKyBjYW5kaWRhdGUuZHVyYXRpb24gLSBjYW5kaWRhdGVMb29rdXBUb2xlcmFuY2UpIDw9IGJ1ZmZlckVuZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgICB9Ly8gaWYgbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSB3aWxsIGhhdmUgbmVnYXRpdmUgdmFsdWUgdGhlbiBkb24ndCByZXR1cm4gLTEgZm9yIGZpcnN0IGVsZW1lbnRcbiAgICAgICAgICAgICAgZWxzZSBpZiAoY2FuZGlkYXRlLnN0YXJ0IC0gY2FuZGlkYXRlTG9va3VwVG9sZXJhbmNlID4gYnVmZmVyRW5kICYmIGNhbmRpZGF0ZS5zdGFydCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGlmIChidWZmZXJFbmQgPCBlbmQpIHtcbiAgICAgICAgICAgICAgaWYgKGJ1ZmZlckVuZCA+IGVuZCAtIG1heEZyYWdMb29rVXBUb2xlcmFuY2UpIHtcbiAgICAgICAgICAgICAgICBtYXhGcmFnTG9va1VwVG9sZXJhbmNlID0gMDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyBQcmVmZXIgdGhlIG5leHQgZnJhZ21lbnQgaWYgaXQncyB3aXRoaW4gdG9sZXJhbmNlXG4gICAgICAgICAgICAgIGlmIChmcmFnTmV4dCAmJiBmcmFnbWVudFdpdGhpblRvbGVyYW5jZVRlc3QoZnJhZ05leHQpICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgZm91bmRGcmFnID0gZnJhZ05leHQ7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZm91bmRGcmFnID0gQmluYXJ5U2VhcmNoLnNlYXJjaChmcmFnbWVudHMsIGZyYWdtZW50V2l0aGluVG9sZXJhbmNlVGVzdCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIHJlYWNoIGVuZCBvZiBwbGF5bGlzdFxuICAgICAgICAgICAgICBmb3VuZEZyYWcgPSBmcmFnbWVudHNbZnJhZ0xlbi0xXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmb3VuZEZyYWcpIHtcbiAgICAgICAgICAgICAgZnJhZyA9IGZvdW5kRnJhZztcbiAgICAgICAgICAgICAgc3RhcnQgPSBmb3VuZEZyYWcuc3RhcnQ7XG4gICAgICAgICAgICAgIC8vbG9nZ2VyLmxvZygnZmluZCBTTiBtYXRjaGluZyB3aXRoIHBvczonICsgIGJ1ZmZlckVuZCArICc6JyArIGZyYWcuc24pO1xuICAgICAgICAgICAgICBpZiAoZnJhZ1ByZXZpb3VzICYmIGZyYWcubGV2ZWwgPT09IGZyYWdQcmV2aW91cy5sZXZlbCAmJiBmcmFnLnNuID09PSBmcmFnUHJldmlvdXMuc24pIHtcbiAgICAgICAgICAgICAgICBpZiAoZnJhZy5zbiA8IHRyYWNrRGV0YWlscy5lbmRTTikge1xuICAgICAgICAgICAgICAgICAgZnJhZyA9IGZyYWdtZW50c1tmcmFnLnNuICsgMSAtIHRyYWNrRGV0YWlscy5zdGFydFNOXTtcbiAgICAgICAgICAgICAgICAgIGxvZ2dlci5sb2coYFNOIGp1c3QgbG9hZGVkLCBsb2FkIG5leHQgb25lOiAke2ZyYWcuc259YCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGZyYWcgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZihmcmFnKSB7XG4gICAgICAgICAgICAvL2xvZ2dlci5sb2coJyAgICAgIGxvYWRpbmcgZnJhZyAnICsgaSArJyxwb3MvYnVmRW5kOicgKyBwb3MudG9GaXhlZCgzKSArICcvJyArIGJ1ZmZlckVuZC50b0ZpeGVkKDMpKTtcbiAgICAgICAgICAgIGlmICgoZnJhZy5kZWNyeXB0ZGF0YS51cmkgIT0gbnVsbCkgJiYgKGZyYWcuZGVjcnlwdGRhdGEua2V5ID09IG51bGwpKSB7XG4gICAgICAgICAgICAgIGxvZ2dlci5sb2coYExvYWRpbmcga2V5IGZvciAke2ZyYWcuc259IG9mIFske3RyYWNrRGV0YWlscy5zdGFydFNOfSAsJHt0cmFja0RldGFpbHMuZW5kU059XSx0cmFjayAke3RoaXMudHJhY2tJZH1gKTtcbiAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLktFWV9MT0FESU5HO1xuICAgICAgICAgICAgICBobHMudHJpZ2dlcihFdmVudC5LRVlfTE9BRElORywge2ZyYWc6IGZyYWd9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGxvZ2dlci5sb2coYExvYWRpbmcgJHtmcmFnLnNufSBvZiBbJHt0cmFja0RldGFpbHMuc3RhcnRTTn0gLCR7dHJhY2tEZXRhaWxzLmVuZFNOfV0sdHJhY2sgJHt0aGlzLnRyYWNrSWR9LCBjdXJyZW50VGltZToke3Bvc30sYnVmZmVyRW5kOiR7YnVmZmVyRW5kLnRvRml4ZWQoMyl9YCk7XG4gICAgICAgICAgICAgIC8vIGVuc3VyZSB0aGF0IHdlIGFyZSBub3QgcmVsb2FkaW5nIHRoZSBzYW1lIGZyYWdtZW50cyBpbiBsb29wIC4uLlxuICAgICAgICAgICAgICBpZiAodGhpcy5mcmFnTG9hZElkeCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mcmFnTG9hZElkeCsrO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZnJhZ0xvYWRJZHggPSAwO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChmcmFnLmxvYWRDb3VudGVyKSB7XG4gICAgICAgICAgICAgICAgZnJhZy5sb2FkQ291bnRlcisrO1xuICAgICAgICAgICAgICAgIGxldCBtYXhUaHJlc2hvbGQgPSBjb25maWcuZnJhZ0xvYWRpbmdMb29wVGhyZXNob2xkO1xuICAgICAgICAgICAgICAgIC8vIGlmIHRoaXMgZnJhZyBoYXMgYWxyZWFkeSBiZWVuIGxvYWRlZCAzIHRpbWVzLCBhbmQgaWYgaXQgaGFzIGJlZW4gcmVsb2FkZWQgcmVjZW50bHlcbiAgICAgICAgICAgICAgICBpZiAoZnJhZy5sb2FkQ291bnRlciA+IG1heFRocmVzaG9sZCAmJiAoTWF0aC5hYnModGhpcy5mcmFnTG9hZElkeCAtIGZyYWcubG9hZElkeCkgPCBtYXhUaHJlc2hvbGQpKSB7XG4gICAgICAgICAgICAgICAgICBobHMudHJpZ2dlcihFdmVudC5FUlJPUiwge3R5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsIGRldGFpbHM6IEVycm9yRGV0YWlscy5GUkFHX0xPT1BfTE9BRElOR19FUlJPUiwgZmF0YWw6IGZhbHNlLCBmcmFnOiBmcmFnfSk7XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZyYWcubG9hZENvdW50ZXIgPSAxO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGZyYWcubG9hZElkeCA9IHRoaXMuZnJhZ0xvYWRJZHg7XG4gICAgICAgICAgICAgIHRoaXMuZnJhZ0N1cnJlbnQgPSBmcmFnO1xuICAgICAgICAgICAgICB0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCA9IHRydWU7XG4gICAgICAgICAgICAgIHRoaXMubmV4dExvYWRQb3NpdGlvbiA9IGZyYWcuc3RhcnQgKyBmcmFnLmR1cmF0aW9uO1xuICAgICAgICAgICAgICBobHMudHJpZ2dlcihFdmVudC5GUkFHX0xPQURJTkcsIHtmcmFnOiBmcmFnfSk7XG4gICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5GUkFHX0xPQURJTkc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBTdGF0ZS5XQUlUSU5HX1RSQUNLOlxuICAgICAgICB0cmFjayA9IHRoaXMudHJhY2tzW3RoaXMudHJhY2tJZF07XG4gICAgICAgIC8vIGNoZWNrIGlmIHBsYXlsaXN0IGlzIGFscmVhZHkgbG9hZGVkXG4gICAgICAgIGlmICh0cmFjayAmJiB0cmFjay5kZXRhaWxzKSB7XG4gICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFN0YXRlLkZSQUdfTE9BRElOR19XQUlUSU5HX1JFVFJZOlxuICAgICAgICB2YXIgbm93ID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIHZhciByZXRyeURhdGUgPSB0aGlzLnJldHJ5RGF0ZTtcbiAgICAgICAgbWVkaWEgPSB0aGlzLm1lZGlhO1xuICAgICAgICB2YXIgaXNTZWVraW5nID0gbWVkaWEgJiYgbWVkaWEuc2Vla2luZztcbiAgICAgICAgLy8gaWYgY3VycmVudCB0aW1lIGlzIGd0IHRoYW4gcmV0cnlEYXRlLCBvciBpZiBtZWRpYSBzZWVraW5nIGxldCdzIHN3aXRjaCB0byBJRExFIHN0YXRlIHRvIHJldHJ5IGxvYWRpbmdcbiAgICAgICAgaWYoIXJldHJ5RGF0ZSB8fCAobm93ID49IHJldHJ5RGF0ZSkgfHwgaXNTZWVraW5nKSB7XG4gICAgICAgICAgbG9nZ2VyLmxvZyhgYXVkaW9TdHJlYW1Db250cm9sbGVyOiByZXRyeURhdGUgcmVhY2hlZCwgc3dpdGNoIGJhY2sgdG8gSURMRSBzdGF0ZWApO1xuICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBTdGF0ZS5XQUlUSU5HX0lOSVRfUFRTOlxuICAgICAgY2FzZSBTdGF0ZS5TVE9QUEVEOlxuICAgICAgY2FzZSBTdGF0ZS5GUkFHX0xPQURJTkc6XG4gICAgICBjYXNlIFN0YXRlLlBBUlNJTkc6XG4gICAgICBjYXNlIFN0YXRlLlBBUlNFRDpcbiAgICAgIGNhc2UgU3RhdGUuRU5ERUQ6XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgb25NZWRpYUF0dGFjaGVkKGRhdGEpIHtcbiAgICB2YXIgbWVkaWEgPSB0aGlzLm1lZGlhID0gdGhpcy5tZWRpYUJ1ZmZlciA9IGRhdGEubWVkaWE7XG4gICAgdGhpcy5vbnZzZWVraW5nID0gdGhpcy5vbk1lZGlhU2Vla2luZy5iaW5kKHRoaXMpO1xuICAgIHRoaXMub252ZW5kZWQgPSB0aGlzLm9uTWVkaWFFbmRlZC5iaW5kKHRoaXMpO1xuICAgIG1lZGlhLmFkZEV2ZW50TGlzdGVuZXIoJ3NlZWtpbmcnLCB0aGlzLm9udnNlZWtpbmcpO1xuICAgIG1lZGlhLmFkZEV2ZW50TGlzdGVuZXIoJ2VuZGVkJywgdGhpcy5vbnZlbmRlZCk7XG4gICAgbGV0IGNvbmZpZyA9IHRoaXMuY29uZmlnO1xuICAgIGlmKHRoaXMudHJhY2tzICYmIGNvbmZpZy5hdXRvU3RhcnRMb2FkKSB7XG4gICAgICB0aGlzLnN0YXJ0TG9hZChjb25maWcuc3RhcnRQb3NpdGlvbik7XG4gICAgfVxuICB9XG5cbiAgb25NZWRpYURldGFjaGluZygpIHtcbiAgICB2YXIgbWVkaWEgPSB0aGlzLm1lZGlhO1xuICAgIGlmIChtZWRpYSAmJiBtZWRpYS5lbmRlZCkge1xuICAgICAgbG9nZ2VyLmxvZygnTVNFIGRldGFjaGluZyBhbmQgdmlkZW8gZW5kZWQsIHJlc2V0IHN0YXJ0UG9zaXRpb24nKTtcbiAgICAgIHRoaXMuc3RhcnRQb3NpdGlvbiA9IHRoaXMubGFzdEN1cnJlbnRUaW1lID0gMDtcbiAgICB9XG5cbiAgICAvLyByZXNldCBmcmFnbWVudCBsb2FkaW5nIGNvdW50ZXIgb24gTVNFIGRldGFjaGluZyB0byBhdm9pZCByZXBvcnRpbmcgRlJBR19MT09QX0xPQURJTkdfRVJST1IgYWZ0ZXIgZXJyb3IgcmVjb3ZlcnlcbiAgICB2YXIgdHJhY2tzID0gdGhpcy50cmFja3M7XG4gICAgaWYgKHRyYWNrcykge1xuICAgICAgLy8gcmVzZXQgZnJhZ21lbnQgbG9hZCBjb3VudGVyXG4gICAgICAgIHRyYWNrcy5mb3JFYWNoKHRyYWNrID0+IHtcbiAgICAgICAgICBpZih0cmFjay5kZXRhaWxzKSB7XG4gICAgICAgICAgICB0cmFjay5kZXRhaWxzLmZyYWdtZW50cy5mb3JFYWNoKGZyYWdtZW50ID0+IHtcbiAgICAgICAgICAgICAgZnJhZ21lbnQubG9hZENvdW50ZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgLy8gcmVtb3ZlIHZpZGVvIGxpc3RlbmVyc1xuICAgIGlmIChtZWRpYSkge1xuICAgICAgbWVkaWEucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Vla2luZycsIHRoaXMub252c2Vla2luZyk7XG4gICAgICBtZWRpYS5yZW1vdmVFdmVudExpc3RlbmVyKCdlbmRlZCcsIHRoaXMub252ZW5kZWQpO1xuICAgICAgdGhpcy5vbnZzZWVraW5nID0gdGhpcy5vbnZzZWVrZWQgID0gdGhpcy5vbnZlbmRlZCA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMubWVkaWEgPSB0aGlzLm1lZGlhQnVmZmVyID0gbnVsbDtcbiAgICB0aGlzLmxvYWRlZG1ldGFkYXRhID0gZmFsc2U7XG4gICAgdGhpcy5zdG9wTG9hZCgpO1xuICB9XG5cbiAgb25NZWRpYVNlZWtpbmcoKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLkVOREVEKSB7XG4gICAgICAgIC8vIHN3aXRjaCB0byBJRExFIHN0YXRlIHRvIGNoZWNrIGZvciBwb3RlbnRpYWwgbmV3IGZyYWdtZW50XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgIH1cbiAgICBpZiAodGhpcy5tZWRpYSkge1xuICAgICAgdGhpcy5sYXN0Q3VycmVudFRpbWUgPSB0aGlzLm1lZGlhLmN1cnJlbnRUaW1lO1xuICAgIH1cbiAgICAvLyBhdm9pZCByZXBvcnRpbmcgZnJhZ21lbnQgbG9vcCBsb2FkaW5nIGVycm9yIGluIGNhc2UgdXNlciBpcyBzZWVraW5nIHNldmVyYWwgdGltZXMgb24gc2FtZSBwb3NpdGlvblxuICAgIGlmICh0aGlzLmZyYWdMb2FkSWR4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuZnJhZ0xvYWRJZHggKz0gMiAqIHRoaXMuY29uZmlnLmZyYWdMb2FkaW5nTG9vcFRocmVzaG9sZDtcbiAgICB9XG4gICAgLy8gdGljayB0byBzcGVlZCB1cCBwcm9jZXNzaW5nXG4gICAgdGhpcy50aWNrKCk7XG4gIH1cblxuICBvbk1lZGlhRW5kZWQoKSB7XG4gICAgLy8gcmVzZXQgc3RhcnRQb3NpdGlvbiBhbmQgbGFzdEN1cnJlbnRUaW1lIHRvIHJlc3RhcnQgcGxheWJhY2sgQCBzdHJlYW0gYmVnaW5uaW5nXG4gICAgdGhpcy5zdGFydFBvc2l0aW9uID0gdGhpcy5sYXN0Q3VycmVudFRpbWUgPSAwO1xuICB9XG5cblxuICBvbkF1ZGlvVHJhY2tzVXBkYXRlZChkYXRhKSB7XG4gICAgbG9nZ2VyLmxvZygnYXVkaW8gdHJhY2tzIHVwZGF0ZWQnKTtcbiAgICB0aGlzLnRyYWNrcyA9IGRhdGEuYXVkaW9UcmFja3M7XG4gIH1cblxuICBvbkF1ZGlvVHJhY2tTd2l0Y2hpbmcoZGF0YSkge1xuICAgIC8vIGlmIGFueSBVUkwgZm91bmQgb24gbmV3IGF1ZGlvIHRyYWNrLCBpdCBpcyBhbiBhbHRlcm5hdGUgYXVkaW8gdHJhY2tcbiAgICB2YXIgYWx0QXVkaW8gPSAhIWRhdGEudXJsO1xuICAgIHRoaXMudHJhY2tJZCA9IGRhdGEuaWQ7XG4gICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG5cbiAgICB0aGlzLmZyYWdDdXJyZW50ID0gbnVsbDtcbiAgICB0aGlzLnN0YXRlID0gU3RhdGUuUEFVU0VEO1xuICAgIHRoaXMud2FpdGluZ0ZyYWdtZW50PW51bGw7XG4gICAgLy8gZGVzdHJveSB1c2VsZXNzIGRlbXV4ZXIgd2hlbiBzd2l0Y2hpbmcgYXVkaW8gdG8gbWFpblxuICAgIGlmICghYWx0QXVkaW8pIHtcbiAgICAgIGlmICh0aGlzLmRlbXV4ZXIpIHtcbiAgICAgICAgdGhpcy5kZW11eGVyLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5kZW11eGVyID0gbnVsbDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gc3dpdGNoaW5nIHRvIGF1ZGlvIHRyYWNrLCBzdGFydCB0aW1lciBpZiBub3QgYWxyZWFkeSBzdGFydGVkXG4gICAgICBpZiAoIXRoaXMudGltZXIpIHtcbiAgICAgICAgdGhpcy50aW1lciA9IHNldEludGVydmFsKHRoaXMub250aWNrLCAxMDApO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vc2hvdWxkIHdlIHN3aXRjaCB0cmFja3MgP1xuICAgIGlmKGFsdEF1ZGlvKXtcbiAgICAgIHRoaXMuYXVkaW9Td2l0Y2ggPSB0cnVlO1xuICAgICAgLy9tYWluIGF1ZGlvIHRyYWNrIGFyZSBoYW5kbGVkIGJ5IHN0cmVhbS1jb250cm9sbGVyLCBqdXN0IGRvIHNvbWV0aGluZyBpZiBzd2l0Y2hpbmcgdG8gYWx0IGF1ZGlvIHRyYWNrXG4gICAgICB0aGlzLnN0YXRlPVN0YXRlLklETEU7XG4gICAgICAvLyBpbmNyZWFzZSBmcmFnbWVudCBsb2FkIEluZGV4IHRvIGF2b2lkIGZyYWcgbG9vcCBsb2FkaW5nIGVycm9yIGFmdGVyIGJ1ZmZlciBmbHVzaFxuICAgICAgdGhpcy5mcmFnTG9hZElkeCArPSAyICogdGhpcy5jb25maWcuZnJhZ0xvYWRpbmdMb29wVGhyZXNob2xkO1xuICAgIH1cbiAgICB0aGlzLnRpY2soKTtcbiAgfVxuXG4gIG9uQXVkaW9UcmFja0xvYWRlZChkYXRhKSB7XG4gICAgdmFyIG5ld0RldGFpbHMgPSBkYXRhLmRldGFpbHMsXG4gICAgICAgIHRyYWNrSWQgPSBkYXRhLmlkLFxuICAgICAgICB0cmFjayA9IHRoaXMudHJhY2tzW3RyYWNrSWRdLFxuICAgICAgICBkdXJhdGlvbiA9IG5ld0RldGFpbHMudG90YWxkdXJhdGlvbixcbiAgICAgICAgc2xpZGluZyA9IDA7XG5cbiAgICBsb2dnZXIubG9nKGB0cmFjayAke3RyYWNrSWR9IGxvYWRlZCBbJHtuZXdEZXRhaWxzLnN0YXJ0U059LCR7bmV3RGV0YWlscy5lbmRTTn1dLGR1cmF0aW9uOiR7ZHVyYXRpb259YCk7XG5cbiAgICBpZiAobmV3RGV0YWlscy5saXZlKSB7XG4gICAgICB2YXIgY3VyRGV0YWlscyA9IHRyYWNrLmRldGFpbHM7XG4gICAgICBpZiAoY3VyRGV0YWlscyAmJiBuZXdEZXRhaWxzLmZyYWdtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIC8vIHdlIGFscmVhZHkgaGF2ZSBkZXRhaWxzIGZvciB0aGF0IGxldmVsLCBtZXJnZSB0aGVtXG4gICAgICAgIExldmVsSGVscGVyLm1lcmdlRGV0YWlscyhjdXJEZXRhaWxzLG5ld0RldGFpbHMpO1xuICAgICAgICBzbGlkaW5nID0gbmV3RGV0YWlscy5mcmFnbWVudHNbMF0uc3RhcnQ7XG4gICAgICAgIC8vIFRPRE9cbiAgICAgICAgLy90aGlzLmxpdmVTeW5jUG9zaXRpb24gPSB0aGlzLmNvbXB1dGVMaXZlUG9zaXRpb24oc2xpZGluZywgY3VyRGV0YWlscyk7XG4gICAgICAgIGlmIChuZXdEZXRhaWxzLlBUU0tub3duKSB7XG4gICAgICAgICAgbG9nZ2VyLmxvZyhgbGl2ZSBhdWRpbyBwbGF5bGlzdCBzbGlkaW5nOiR7c2xpZGluZy50b0ZpeGVkKDMpfWApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxvZ2dlci5sb2coJ2xpdmUgYXVkaW8gcGxheWxpc3QgLSBvdXRkYXRlZCBQVFMsIHVua25vd24gc2xpZGluZycpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXdEZXRhaWxzLlBUU0tub3duID0gZmFsc2U7XG4gICAgICAgIGxvZ2dlci5sb2coJ2xpdmUgYXVkaW8gcGxheWxpc3QgLSBmaXJzdCBsb2FkLCB1bmtub3duIHNsaWRpbmcnKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbmV3RGV0YWlscy5QVFNLbm93biA9IGZhbHNlO1xuICAgIH1cbiAgICB0cmFjay5kZXRhaWxzID0gbmV3RGV0YWlscztcblxuICAgIC8vIGNvbXB1dGUgc3RhcnQgcG9zaXRpb25cbiAgICBpZiAoIXRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkKSB7XG4gICAgLy8gY29tcHV0ZSBzdGFydCBwb3NpdGlvbiBpZiBzZXQgdG8gLTEuIHVzZSBpdCBzdHJhaWdodCBhd2F5IGlmIHZhbHVlIGlzIGRlZmluZWRcbiAgICAgIGlmICh0aGlzLnN0YXJ0UG9zaXRpb24gPT09IC0xKSB7XG4gICAgICAgIC8vIGZpcnN0LCBjaGVjayBpZiBzdGFydCB0aW1lIG9mZnNldCBoYXMgYmVlbiBzZXQgaW4gcGxheWxpc3QsIGlmIHllcywgdXNlIHRoaXMgdmFsdWVcbiAgICAgICAgbGV0IHN0YXJ0VGltZU9mZnNldCA9IG5ld0RldGFpbHMuc3RhcnRUaW1lT2Zmc2V0O1xuICAgICAgICBpZighaXNOYU4oc3RhcnRUaW1lT2Zmc2V0KSkge1xuICAgICAgICAgIGxvZ2dlci5sb2coYHN0YXJ0IHRpbWUgb2Zmc2V0IGZvdW5kIGluIHBsYXlsaXN0LCBhZGp1c3Qgc3RhcnRQb3NpdGlvbiB0byAke3N0YXJ0VGltZU9mZnNldH1gKTtcbiAgICAgICAgICB0aGlzLnN0YXJ0UG9zaXRpb24gPSBzdGFydFRpbWVPZmZzZXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5zdGFydFBvc2l0aW9uID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5uZXh0TG9hZFBvc2l0aW9uID0gdGhpcy5zdGFydFBvc2l0aW9uO1xuICAgIH1cbiAgICAvLyBvbmx5IHN3aXRjaCBiYXRjayB0byBJRExFIHN0YXRlIGlmIHdlIHdlcmUgd2FpdGluZyBmb3IgdHJhY2sgdG8gc3RhcnQgZG93bmxvYWRpbmcgYSBuZXcgZnJhZ21lbnRcbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuV0FJVElOR19UUkFDSykge1xuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgfVxuICAgIC8vdHJpZ2dlciBoYW5kbGVyIHJpZ2h0IG5vd1xuICAgIHRoaXMudGljaygpO1xuICB9XG5cbiAgb25LZXlMb2FkZWQoKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLktFWV9MT0FESU5HKSB7XG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgIHRoaXMudGljaygpO1xuICAgIH1cbiAgfVxuXG4gIG9uRnJhZ0xvYWRlZChkYXRhKSB7XG4gICAgdmFyIGZyYWdDdXJyZW50ID0gdGhpcy5mcmFnQ3VycmVudDtcbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuRlJBR19MT0FESU5HICYmXG4gICAgICAgIGZyYWdDdXJyZW50ICYmXG4gICAgICAgIGRhdGEuZnJhZy50eXBlID09PSAnYXVkaW8nICYmXG4gICAgICAgIGRhdGEuZnJhZy5sZXZlbCA9PT0gZnJhZ0N1cnJlbnQubGV2ZWwgJiZcbiAgICAgICAgZGF0YS5mcmFnLnNuID09PSBmcmFnQ3VycmVudC5zbikge1xuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuUEFSU0lORztcbiAgICAgICAgLy8gdHJhbnNtdXggdGhlIE1QRUctVFMgZGF0YSB0byBJU08tQk1GRiBzZWdtZW50c1xuICAgICAgICB0aGlzLnN0YXRzID0gZGF0YS5zdGF0cztcbiAgICAgICAgdmFyIHRyYWNrID0gdGhpcy50cmFja3NbdGhpcy50cmFja0lkXSxcbiAgICAgICAgICAgIGRldGFpbHMgPSB0cmFjay5kZXRhaWxzLFxuICAgICAgICAgICAgZHVyYXRpb24gPSBkZXRhaWxzLnRvdGFsZHVyYXRpb24sXG4gICAgICAgICAgICBzdGFydCA9IGZyYWdDdXJyZW50LnN0YXJ0LFxuICAgICAgICAgICAgdHJhY2tJZCA9IGZyYWdDdXJyZW50LmxldmVsLFxuICAgICAgICAgICAgc24gPSBmcmFnQ3VycmVudC5zbixcbiAgICAgICAgICAgIGNjID0gZnJhZ0N1cnJlbnQuY2MsXG4gICAgICAgICAgICBhdWRpb0NvZGVjID0gdGhpcy5jb25maWcuZGVmYXVsdEF1ZGlvQ29kZWMgfHwgdHJhY2suYXVkaW9Db2RlYztcbiAgICAgICAgdGhpcy5hcHBlbmRlZCA9IGZhbHNlO1xuICAgICAgICBpZighdGhpcy5kZW11eGVyKSB7XG4gICAgICAgICAgdGhpcy5kZW11eGVyID0gbmV3IERlbXV4ZXIodGhpcy5obHMsJ2F1ZGlvJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy9DaGVjayBpZiB3ZSBoYXZlIHZpZGVvIGluaXRQVFNcbiAgICAgICAgLy8gSWYgbm90IHdlIG5lZWQgdG8gd2FpdCBmb3IgaXRcbiAgICAgICAgbGV0IGluaXRQVFMgPSB0aGlzLmluaXRQVFNbY2NdO1xuICAgICAgICBpZiAoaW5pdFBUUyAhPT0gdW5kZWZpbmVkKXtcbiAgICAgICAgICB0aGlzLnBlbmRpbmdCdWZmZXJpbmcgPSAtMTtcbiAgICAgICAgICBsb2dnZXIubG9nKGBEZW11eGluZyAke3NufSBvZiBbJHtkZXRhaWxzLnN0YXJ0U059ICwke2RldGFpbHMuZW5kU059XSx0cmFjayAke3RyYWNrSWR9YCk7XG4gICAgICAgICAgLy8gdGltZSBPZmZzZXQgaXMgYWNjdXJhdGUgaWYgbGV2ZWwgUFRTIGlzIGtub3duLCBvciBpZiBwbGF5bGlzdCBpcyBub3Qgc2xpZGluZyAobm90IGxpdmUpXG4gICAgICAgICAgbGV0IGFjY3VyYXRlVGltZU9mZnNldCA9IGZhbHNlOyAvL2RldGFpbHMuUFRTS25vd24gfHwgIWRldGFpbHMubGl2ZTtcbiAgICAgICAgICB0aGlzLmRlbXV4ZXIucHVzaChkYXRhLnBheWxvYWQsIGF1ZGlvQ29kZWMsIG51bGwsIHN0YXJ0LCBjYywgdHJhY2tJZCwgc24sIGR1cmF0aW9uLCBmcmFnQ3VycmVudC5kZWNyeXB0ZGF0YSwgYWNjdXJhdGVUaW1lT2Zmc2V0LCBpbml0UFRTKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsb2dnZXIubG9nKGB1bmtub3duIHZpZGVvIFBUUyBmb3IgY29udGludWl0eSBjb3VudGVyICR7Y2N9LCB3YWl0aW5nIGZvciB2aWRlbyBQVFMgYmVmb3JlIGRlbXV4aW5nIGF1ZGlvIGZyYWcgJHtzbn0gb2YgWyR7ZGV0YWlscy5zdGFydFNOfSAsJHtkZXRhaWxzLmVuZFNOfV0sdHJhY2sgJHt0cmFja0lkfWApO1xuICAgICAgICAgIHRoaXMud2FpdGluZ0ZyYWdtZW50PWRhdGE7XG4gICAgICAgICAgdGhpcy5zdGF0ZT1TdGF0ZS5XQUlUSU5HX0lOSVRfUFRTO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRoaXMuZnJhZ0xvYWRFcnJvciA9IDA7XG4gIH1cblxuICBvbkZyYWdQYXJzaW5nSW5pdFNlZ21lbnQoZGF0YSkge1xuICAgIGxldCBmcmFnQ3VycmVudCA9IHRoaXMuZnJhZ0N1cnJlbnQ7XG4gICAgaWYgKGZyYWdDdXJyZW50ICYmXG4gICAgICAgIGRhdGEuaWQgPT09ICdhdWRpbycgJiZcbiAgICAgICAgZGF0YS5zbiA9PT0gZnJhZ0N1cnJlbnQuc24gJiZcbiAgICAgICAgZGF0YS5sZXZlbCA9PT0gZnJhZ0N1cnJlbnQubGV2ZWwgJiZcbiAgICAgICAgdGhpcy5zdGF0ZSA9PT0gU3RhdGUuUEFSU0lORykge1xuICAgICAgbGV0IHRyYWNrcyA9IGRhdGEudHJhY2tzLCB0cmFjaztcblxuICAgICAgLy8gZGVsZXRlIGFueSB2aWRlbyB0cmFjayBmb3VuZCBvbiBhdWRpbyBkZW11eGVyXG4gICAgICBpZiAodHJhY2tzLnZpZGVvKSB7XG4gICAgICAgIGRlbGV0ZSB0cmFja3MudmlkZW87XG4gICAgICB9XG5cbiAgICAgIC8vIGluY2x1ZGUgbGV2ZWxDb2RlYyBpbiBhdWRpbyBhbmQgdmlkZW8gdHJhY2tzXG4gICAgICB0cmFjayA9IHRyYWNrcy5hdWRpbztcbiAgICAgIGlmKHRyYWNrKSB7XG4gICAgICAgIHRyYWNrLmxldmVsQ29kZWMgPSAnbXA0YS40MC4yJztcbiAgICAgICAgdHJhY2suaWQgPSBkYXRhLmlkO1xuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkJVRkZFUl9DT0RFQ1MsdHJhY2tzKTtcbiAgICAgICAgbG9nZ2VyLmxvZyhgYXVkaW8gdHJhY2s6YXVkaW8sY29udGFpbmVyOiR7dHJhY2suY29udGFpbmVyfSxjb2RlY3NbbGV2ZWwvcGFyc2VkXT1bJHt0cmFjay5sZXZlbENvZGVjfS8ke3RyYWNrLmNvZGVjfV1gKTtcbiAgICAgICAgbGV0IGluaXRTZWdtZW50ID0gdHJhY2suaW5pdFNlZ21lbnQ7XG4gICAgICAgIGlmIChpbml0U2VnbWVudCkge1xuICAgICAgICAgIGxldCBhcHBlbmRPYmogPSB7dHlwZTogJ2F1ZGlvJywgZGF0YTogaW5pdFNlZ21lbnQsIHBhcmVudCA6ICdhdWRpbycsY29udGVudCA6ICdpbml0U2VnbWVudCd9O1xuICAgICAgICAgIGlmICh0aGlzLmF1ZGlvU3dpdGNoKSB7XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdEYXRhID0gW2FwcGVuZE9ial07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5CVUZGRVJfQVBQRU5ESU5HLCBhcHBlbmRPYmopO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvL3RyaWdnZXIgaGFuZGxlciByaWdodCBub3dcbiAgICAgICAgdGhpcy50aWNrKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgb25GcmFnUGFyc2luZ0RhdGEoZGF0YSkge1xuICAgIGxldCBmcmFnQ3VycmVudCA9IHRoaXMuZnJhZ0N1cnJlbnQ7XG4gICAgaWYgKGZyYWdDdXJyZW50ICYmXG4gICAgICAgIGRhdGEuaWQgPT09ICdhdWRpbycgJiZcbiAgICAgICAgZGF0YS50eXBlID09PSAnYXVkaW8nICYmXG4gICAgICAgIGRhdGEuc24gPT09IGZyYWdDdXJyZW50LnNuICYmXG4gICAgICAgIGRhdGEubGV2ZWwgPT09IGZyYWdDdXJyZW50LmxldmVsICYmXG4gICAgICAgIHRoaXMuc3RhdGUgPT09IFN0YXRlLlBBUlNJTkcpIHtcbiAgICAgIGxldCB0cmFja0lkPSB0aGlzLnRyYWNrSWQsXG4gICAgICAgICAgdHJhY2sgPSB0aGlzLnRyYWNrc1t0cmFja0lkXSxcbiAgICAgICAgICBmcmFnID0gdGhpcy5mcmFnQ3VycmVudCxcbiAgICAgICAgICBobHMgPSB0aGlzLmhscztcblxuICAgICAgbG9nZ2VyLmxvZyhgcGFyc2VkICR7ZGF0YS50eXBlfSxQVFM6WyR7ZGF0YS5zdGFydFBUUy50b0ZpeGVkKDMpfSwke2RhdGEuZW5kUFRTLnRvRml4ZWQoMyl9XSxEVFM6WyR7ZGF0YS5zdGFydERUUy50b0ZpeGVkKDMpfS8ke2RhdGEuZW5kRFRTLnRvRml4ZWQoMyl9XSxuYjoke2RhdGEubmJ9YCk7XG4gICAgICBMZXZlbEhlbHBlci51cGRhdGVGcmFnUFRTRFRTKHRyYWNrLmRldGFpbHMsZnJhZy5zbixkYXRhLnN0YXJ0UFRTLGRhdGEuZW5kUFRTKTtcblxuICAgICAgbGV0IGF1ZGlvU3dpdGNoID0gdGhpcy5hdWRpb1N3aXRjaCwgbWVkaWEgPSB0aGlzLm1lZGlhLCBhcHBlbmRPbkJ1ZmZlckZsdXNoID0gZmFsc2U7XG4gICAgICAvL09ubHkgZmx1c2ggYXVkaW8gZnJvbSBvbGQgYXVkaW8gdHJhY2tzIHdoZW4gUFRTIGlzIGtub3duIG9uIG5ldyBhdWRpbyB0cmFja1xuICAgICAgaWYoYXVkaW9Td2l0Y2ggJiYgbWVkaWEpIHtcbiAgICAgICAgaWYgKG1lZGlhLnJlYWR5U3RhdGUpIHtcbiAgICAgICAgICBsZXQgY3VycmVudFRpbWUgPSBtZWRpYS5jdXJyZW50VGltZTtcbiAgICAgICAgICBsb2dnZXIubG9nKCdzd2l0Y2hpbmcgYXVkaW8gdHJhY2sgOiBjdXJyZW50VGltZTonKyBjdXJyZW50VGltZSk7XG4gICAgICAgICAgaWYgKGN1cnJlbnRUaW1lID49IGRhdGEuc3RhcnRQVFMpIHtcbiAgICAgICAgICAgIGxvZ2dlci5sb2coJ3N3aXRjaGluZyBhdWRpbyB0cmFjayA6IGZsdXNoaW5nIGFsbCBhdWRpbycpO1xuICAgICAgICAgICAgICBobHMudHJpZ2dlcihFdmVudC5CVUZGRVJfRkxVU0hJTkcsIHtzdGFydE9mZnNldDogMCAsIGVuZE9mZnNldDogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLCB0eXBlIDogJ2F1ZGlvJ30pO1xuICAgICAgICAgICAgICBhcHBlbmRPbkJ1ZmZlckZsdXNoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgLy9MZXRzIGFubm91bmNlIHRoYXQgdGhlIGluaXRpYWwgYXVkaW8gdHJhY2sgc3dpdGNoIGZsdXNoIG9jY3VyXG4gICAgICAgICAgICAgIHRoaXMuYXVkaW9Td2l0Y2ggPSBmYWxzZTtcbiAgICAgICAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnQuQVVESU9fVFJBQ0tfU1dJVENIRUQsIHtpZCA6IHRyYWNrSWR9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy9MZXRzIGFubm91bmNlIHRoYXQgdGhlIGluaXRpYWwgYXVkaW8gdHJhY2sgc3dpdGNoIGZsdXNoIG9jY3VyXG4gICAgICAgICAgdGhpcy5hdWRpb1N3aXRjaD1mYWxzZTtcbiAgICAgICAgICBobHMudHJpZ2dlcihFdmVudC5BVURJT19UUkFDS19TV0lUQ0hFRCwge2lkIDogdHJhY2tJZH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cblxuICAgICAgbGV0IHBlbmRpbmdEYXRhID0gdGhpcy5wZW5kaW5nRGF0YTtcbiAgICAgIGlmKCF0aGlzLmF1ZGlvU3dpdGNoKSB7XG4gICAgICAgIFtkYXRhLmRhdGExLCBkYXRhLmRhdGEyXS5mb3JFYWNoKGJ1ZmZlciA9PiB7XG4gICAgICAgICAgaWYgKGJ1ZmZlcikge1xuICAgICAgICAgICAgcGVuZGluZ0RhdGEucHVzaCh7dHlwZTogZGF0YS50eXBlLCBkYXRhOiBidWZmZXIsIHBhcmVudCA6ICdhdWRpbycsY29udGVudCA6ICdkYXRhJ30pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICBpZiAoIWFwcGVuZE9uQnVmZmVyRmx1c2ggJiYgcGVuZGluZ0RhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgcGVuZGluZ0RhdGEuZm9yRWFjaChhcHBlbmRPYmogPT4ge1xuICAgICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5CVUZGRVJfQVBQRU5ESU5HLCBhcHBlbmRPYmopO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRoaXMucGVuZGluZ0RhdGEgPSBbXTtcbiAgICAgICAgICB0aGlzLmFwcGVuZGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy90cmlnZ2VyIGhhbmRsZXIgcmlnaHQgbm93XG4gICAgICB0aGlzLnRpY2soKTtcbiAgICB9XG4gIH1cblxuICBvbkZyYWdQYXJzZWQoZGF0YSkge1xuICAgIGxldCBmcmFnQ3VycmVudCA9IHRoaXMuZnJhZ0N1cnJlbnQ7XG4gICAgaWYgKGZyYWdDdXJyZW50ICYmXG4gICAgICAgIGRhdGEuaWQgPT09ICdhdWRpbycgJiZcbiAgICAgICAgZGF0YS5zbiA9PT0gZnJhZ0N1cnJlbnQuc24gJiZcbiAgICAgICAgZGF0YS5sZXZlbCA9PT0gZnJhZ0N1cnJlbnQubGV2ZWwgJiZcbiAgICAgICAgdGhpcy5zdGF0ZSA9PT0gU3RhdGUuUEFSU0lORykge1xuICAgICAgdGhpcy5zdGF0cy50cGFyc2VkID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuUEFSU0VEO1xuICAgICAgdGhpcy5fY2hlY2tBcHBlbmRlZFBhcnNlZCgpO1xuICAgIH1cbiAgfVxuXG5cbiAgb25CdWZmZXJDcmVhdGVkKGRhdGEpIHtcbiAgICBsZXQgYXVkaW9UcmFjayA9IGRhdGEudHJhY2tzLmF1ZGlvO1xuICAgIGlmIChhdWRpb1RyYWNrKSB7XG4gICAgICB0aGlzLm1lZGlhQnVmZmVyID0gYXVkaW9UcmFjay5idWZmZXI7XG4gICAgICB0aGlzLmxvYWRlZG1ldGFkYXRhID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBvbkJ1ZmZlckFwcGVuZGVkKGRhdGEpIHtcbiAgICBpZiAoZGF0YS5wYXJlbnQgPT09ICdhdWRpbycpIHtcbiAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICAgIGlmIChzdGF0ZSA9PT0gU3RhdGUuUEFSU0lORyB8fCBzdGF0ZSA9PT0gU3RhdGUuUEFSU0VEKSB7XG4gICAgICAgIHRoaXMucGVuZGluZ0J1ZmZlcmluZyA9IGRhdGEucGVuZGluZztcbiAgICAgICAgdGhpcy5fY2hlY2tBcHBlbmRlZFBhcnNlZCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIF9jaGVja0FwcGVuZGVkUGFyc2VkKCkge1xuICAgIC8vdHJpZ2dlciBoYW5kbGVyIHJpZ2h0IG5vd1xuICAgIGlmICh0aGlzLnN0YXRlID09PSBTdGF0ZS5QQVJTRUQgJiYgKCF0aGlzLmFwcGVuZGVkIHx8IHRoaXMucGVuZGluZ0J1ZmZlcmluZyA9PT0gMCkpICAge1xuICAgICAgbGV0IGZyYWcgPSB0aGlzLmZyYWdDdXJyZW50LCBzdGF0cyA9IHRoaXMuc3RhdHMsIGhscyA9IHRoaXMuaGxzO1xuICAgICAgaWYgKGZyYWcpIHtcbiAgICAgICAgdGhpcy5mcmFnUHJldmlvdXMgPSBmcmFnO1xuICAgICAgICBzdGF0cy50YnVmZmVyZWQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnQuRlJBR19CVUZGRVJFRCwge3N0YXRzOiBzdGF0cywgZnJhZzogZnJhZywgaWQgOiAnYXVkaW8nfSk7XG4gICAgICAgIGxldCBtZWRpYSA9IHRoaXMubWVkaWFCdWZmZXIgPyB0aGlzLm1lZGlhQnVmZmVyIDogdGhpcy5tZWRpYTtcbiAgICAgICAgbG9nZ2VyLmxvZyhgYXVkaW8gYnVmZmVyZWQgOiAke1RpbWVSYW5nZXMudG9TdHJpbmcobWVkaWEuYnVmZmVyZWQpfWApO1xuICAgICAgICBpZiAodGhpcy5hdWRpb1N3aXRjaCAmJiB0aGlzLmFwcGVuZGVkKSB7XG4gICAgICAgICAgdGhpcy5hdWRpb1N3aXRjaCA9IGZhbHNlO1xuICAgICAgICAgIGhscy50cmlnZ2VyKEV2ZW50LkFVRElPX1RSQUNLX1NXSVRDSEVELCB7aWQgOiB0aGlzLnRyYWNrSWR9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgIH1cbiAgICAgIHRoaXMudGljaygpO1xuICAgIH1cbiAgfVxuXG4gIG9uRXJyb3IoZGF0YSkge1xuICAgIGxldCBmcmFnID0gZGF0YS5mcmFnO1xuICAgIC8vIGRvbid0IGhhbmRsZSBmcmFnIGVycm9yIG5vdCByZWxhdGVkIHRvIGF1ZGlvIGZyYWdtZW50XG4gICAgaWYgKGZyYWcgJiYgZnJhZy50eXBlICE9PSAnYXVkaW8nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN3aXRjaChkYXRhLmRldGFpbHMpIHtcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkZSQUdfTE9BRF9FUlJPUjpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkZSQUdfTE9BRF9USU1FT1VUOlxuICAgICAgICBpZighZGF0YS5mYXRhbCkge1xuICAgICAgICAgIHZhciBsb2FkRXJyb3IgPSB0aGlzLmZyYWdMb2FkRXJyb3I7XG4gICAgICAgICAgaWYobG9hZEVycm9yKSB7XG4gICAgICAgICAgICBsb2FkRXJyb3IrKztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbG9hZEVycm9yPTE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxldCBjb25maWcgPSB0aGlzLmNvbmZpZztcbiAgICAgICAgICBpZiAobG9hZEVycm9yIDw9IGNvbmZpZy5mcmFnTG9hZGluZ01heFJldHJ5KSB7XG4gICAgICAgICAgICB0aGlzLmZyYWdMb2FkRXJyb3IgPSBsb2FkRXJyb3I7XG4gICAgICAgICAgICAvLyByZXNldCBsb2FkIGNvdW50ZXIgdG8gYXZvaWQgZnJhZyBsb29wIGxvYWRpbmcgZXJyb3JcbiAgICAgICAgICAgIGZyYWcubG9hZENvdW50ZXIgPSAwO1xuICAgICAgICAgICAgLy8gZXhwb25lbnRpYWwgYmFja29mZiBjYXBwZWQgdG8gY29uZmlnLmZyYWdMb2FkaW5nTWF4UmV0cnlUaW1lb3V0XG4gICAgICAgICAgICB2YXIgZGVsYXkgPSBNYXRoLm1pbihNYXRoLnBvdygyLGxvYWRFcnJvci0xKSpjb25maWcuZnJhZ0xvYWRpbmdSZXRyeURlbGF5LGNvbmZpZy5mcmFnTG9hZGluZ01heFJldHJ5VGltZW91dCk7XG4gICAgICAgICAgICBsb2dnZXIud2FybihgYXVkaW9TdHJlYW1Db250cm9sbGVyOiBmcmFnIGxvYWRpbmcgZmFpbGVkLCByZXRyeSBpbiAke2RlbGF5fSBtc2ApO1xuICAgICAgICAgICAgdGhpcy5yZXRyeURhdGUgPSBwZXJmb3JtYW5jZS5ub3coKSArIGRlbGF5O1xuICAgICAgICAgICAgLy8gcmV0cnkgbG9hZGluZyBzdGF0ZVxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkZSQUdfTE9BRElOR19XQUlUSU5HX1JFVFJZO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsb2dnZXIuZXJyb3IoYGF1ZGlvU3RyZWFtQ29udHJvbGxlcjogJHtkYXRhLmRldGFpbHN9IHJlYWNoZXMgbWF4IHJldHJ5LCByZWRpc3BhdGNoIGFzIGZhdGFsIC4uLmApO1xuICAgICAgICAgICAgLy8gcmVkaXNwYXRjaCBzYW1lIGVycm9yIGJ1dCB3aXRoIGZhdGFsIHNldCB0byB0cnVlXG4gICAgICAgICAgICBkYXRhLmZhdGFsID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuRVJST1IsIGRhdGEpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkVSUk9SO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkZSQUdfTE9PUF9MT0FESU5HX0VSUk9SOlxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuQVVESU9fVFJBQ0tfTE9BRF9FUlJPUjpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkFVRElPX1RSQUNLX0xPQURfVElNRU9VVDpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLktFWV9MT0FEX0VSUk9SOlxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuS0VZX0xPQURfVElNRU9VVDpcbiAgICAgICAgLy8gIHdoZW4gaW4gRVJST1Igc3RhdGUsIGRvbid0IHN3aXRjaCBiYWNrIHRvIElETEUgc3RhdGUgaW4gY2FzZSBhIG5vbi1mYXRhbCBlcnJvciBpcyByZWNlaXZlZFxuICAgICAgICBpZih0aGlzLnN0YXRlICE9PSBTdGF0ZS5FUlJPUikge1xuICAgICAgICAgICAgLy8gaWYgZmF0YWwgZXJyb3IsIHN0b3AgcHJvY2Vzc2luZywgb3RoZXJ3aXNlIG1vdmUgdG8gSURMRSB0byByZXRyeSBsb2FkaW5nXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gZGF0YS5mYXRhbCA/IFN0YXRlLkVSUk9SIDogU3RhdGUuSURMRTtcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKGBhdWRpb1N0cmVhbUNvbnRyb2xsZXI6ICR7ZGF0YS5kZXRhaWxzfSB3aGlsZSBsb2FkaW5nIGZyYWcsc3dpdGNoIHRvICR7dGhpcy5zdGF0ZX0gc3RhdGUgLi4uYCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBvbkJ1ZmZlckZsdXNoZWQoKSB7XG4gICAgbGV0IHBlbmRpbmdEYXRhID0gdGhpcy5wZW5kaW5nRGF0YTtcbiAgICBpZiAocGVuZGluZ0RhdGEgJiYgcGVuZGluZ0RhdGEubGVuZ3RoKSB7XG4gICAgICBsb2dnZXIubG9nKCdhcHBlbmRpbmcgcGVuZGluZyBhdWRpbyBkYXRhIG9uIEJ1ZmZlciBGbHVzaGVkJyk7XG4gICAgICBwZW5kaW5nRGF0YS5mb3JFYWNoKGFwcGVuZE9iaiA9PiB7XG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuQlVGRkVSX0FQUEVORElORywgYXBwZW5kT2JqKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5hcHBlbmRlZCA9IHRydWU7XG4gICAgICB0aGlzLnBlbmRpbmdEYXRhID0gW107XG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuUEFSU0VEO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBtb3ZlIHRvIElETEUgb25jZSBmbHVzaCBjb21wbGV0ZS4gdGhpcyBzaG91bGQgdHJpZ2dlciBuZXcgZnJhZ21lbnQgbG9hZGluZ1xuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICAvLyByZXNldCByZWZlcmVuY2UgdG8gZnJhZ1xuICAgICAgdGhpcy5mcmFnUHJldmlvdXMgPSBudWxsO1xuICAgICAgdGhpcy50aWNrKCk7XG4gICAgfVxuICB9XG59XG5leHBvcnQgZGVmYXVsdCBBdWRpb1N0cmVhbUNvbnRyb2xsZXI7XG5cbiIsIi8qXG4gKiBhdWRpbyB0cmFjayBjb250cm9sbGVyXG4qL1xuXG5pbXBvcnQgRXZlbnQgZnJvbSAnLi4vZXZlbnRzJztcbmltcG9ydCBFdmVudEhhbmRsZXIgZnJvbSAnLi4vZXZlbnQtaGFuZGxlcic7XG5pbXBvcnQge2xvZ2dlcn0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcblxuY2xhc3MgQXVkaW9UcmFja0NvbnRyb2xsZXIgZXh0ZW5kcyBFdmVudEhhbmRsZXIge1xuXG4gIGNvbnN0cnVjdG9yKGhscykge1xuICAgIHN1cGVyKGhscywgRXZlbnQuTUFOSUZFU1RfTE9BRElORyxcbiAgICAgICAgICAgICAgIEV2ZW50Lk1BTklGRVNUX0xPQURFRCxcbiAgICAgICAgICAgICAgIEV2ZW50LkFVRElPX1RSQUNLX0xPQURFRCk7XG4gICAgdGhpcy50aWNrcyA9IDA7XG4gICAgdGhpcy5vbnRpY2sgPSB0aGlzLnRpY2suYmluZCh0aGlzKTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgRXZlbnRIYW5kbGVyLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XG4gIH1cbiAgdGljaygpIHtcbiAgICB0aGlzLnRpY2tzKys7XG4gICAgaWYgKHRoaXMudGlja3MgPT09IDEpIHtcbiAgICAgIHRoaXMuZG9UaWNrKCk7XG4gICAgICBpZiAodGhpcy50aWNrcyA+IDEpIHtcbiAgICAgICAgc2V0VGltZW91dCh0aGlzLnRpY2ssIDEpO1xuICAgICAgfVxuICAgICAgdGhpcy50aWNrcyA9IDA7XG4gICAgfVxuICB9XG4gIGRvVGljaygpIHtcbiAgICB0aGlzLnVwZGF0ZVRyYWNrKHRoaXMudHJhY2tJZCk7XG4gIH1cbiAgb25NYW5pZmVzdExvYWRpbmcoKSB7XG4gICAgLy8gcmVzZXQgYXVkaW8gdHJhY2tzIG9uIG1hbmlmZXN0IGxvYWRpbmdcbiAgICB0aGlzLnRyYWNrcyA9IFtdO1xuICAgIHRoaXMudHJhY2tJZCA9IC0xO1xuICB9XG5cbiAgb25NYW5pZmVzdExvYWRlZChkYXRhKSB7XG4gICAgbGV0IHRyYWNrcyA9IGRhdGEuYXVkaW9UcmFja3MgfHwgW107XG4gICAgbGV0IGRlZmF1bHRGb3VuZCA9IGZhbHNlO1xuICAgIHRoaXMudHJhY2tzID0gdHJhY2tzO1xuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuQVVESU9fVFJBQ0tTX1VQREFURUQsIHthdWRpb1RyYWNrcyA6IHRyYWNrc30pO1xuICAgIC8vIGxvb3AgdGhyb3VnaCBhdmFpbGFibGUgYXVkaW8gdHJhY2tzIGFuZCBhdXRvc2VsZWN0IGRlZmF1bHQgaWYgbmVlZGVkXG4gICAgbGV0IGlkID0gMDtcbiAgICB0cmFja3MuZm9yRWFjaCh0cmFjayA9PiB7XG4gICAgICBpZih0cmFjay5kZWZhdWx0KSB7XG4gICAgICAgIHRoaXMuYXVkaW9UcmFjayA9IGlkO1xuICAgICAgICBkZWZhdWx0Rm91bmQgPSB0cnVlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZCsrO1xuICAgIH0pO1xuICAgIGlmIChkZWZhdWx0Rm91bmQgPT09IGZhbHNlICYmIHRyYWNrcy5sZW5ndGgpIHtcbiAgICAgIGxvZ2dlci5sb2coJ25vIGRlZmF1bHQgYXVkaW8gdHJhY2sgZGVmaW5lZCwgdXNlIGZpcnN0IGF1ZGlvIHRyYWNrIGFzIGRlZmF1bHQnKTtcbiAgICAgIHRoaXMuYXVkaW9UcmFjayA9IDA7XG4gICAgfVxuICB9XG5cbiAgb25BdWRpb1RyYWNrTG9hZGVkKGRhdGEpIHtcbiAgICBpZiAoZGF0YS5pZCA8IHRoaXMudHJhY2tzLmxlbmd0aCkge1xuICAgICAgbG9nZ2VyLmxvZyhgYXVkaW9UcmFjayAke2RhdGEuaWR9IGxvYWRlZGApO1xuICAgICAgdGhpcy50cmFja3NbZGF0YS5pZF0uZGV0YWlscyA9IGRhdGEuZGV0YWlscztcbiAgICAgIC8vIGNoZWNrIGlmIGN1cnJlbnQgcGxheWxpc3QgaXMgYSBsaXZlIHBsYXlsaXN0XG4gICAgICBpZiAoZGF0YS5kZXRhaWxzLmxpdmUgJiYgIXRoaXMudGltZXIpIHtcbiAgICAgICAgLy8gaWYgbGl2ZSBwbGF5bGlzdCB3ZSB3aWxsIGhhdmUgdG8gcmVsb2FkIGl0IHBlcmlvZGljYWxseVxuICAgICAgICAvLyBzZXQgcmVsb2FkIHBlcmlvZCB0byBwbGF5bGlzdCB0YXJnZXQgZHVyYXRpb25cbiAgICAgICAgdGhpcy50aW1lciA9IHNldEludGVydmFsKHRoaXMub250aWNrLCAxMDAwICogZGF0YS5kZXRhaWxzLnRhcmdldGR1cmF0aW9uKTtcbiAgICAgIH1cbiAgICAgIGlmICghZGF0YS5kZXRhaWxzLmxpdmUgJiYgdGhpcy50aW1lcikge1xuICAgICAgICAvLyBwbGF5bGlzdCBpcyBub3QgbGl2ZSBhbmQgdGltZXIgaXMgYXJtZWQgOiBzdG9wcGluZyBpdFxuICAgICAgICBjbGVhckludGVydmFsKHRoaXMudGltZXIpO1xuICAgICAgICB0aGlzLnRpbWVyID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKiogZ2V0IGFsdGVybmF0ZSBhdWRpbyB0cmFja3MgbGlzdCBmcm9tIHBsYXlsaXN0ICoqL1xuICBnZXQgYXVkaW9UcmFja3MoKSB7XG4gICAgcmV0dXJuIHRoaXMudHJhY2tzO1xuICB9XG5cbiAgLyoqIGdldCBpbmRleCBvZiB0aGUgc2VsZWN0ZWQgYXVkaW8gdHJhY2sgKGluZGV4IGluIGF1ZGlvIHRyYWNrIGxpc3RzKSAqKi9cbiAgZ2V0IGF1ZGlvVHJhY2soKSB7XG4gICByZXR1cm4gdGhpcy50cmFja0lkO1xuICB9XG5cbiAgLyoqIHNlbGVjdCBhbiBhdWRpbyB0cmFjaywgYmFzZWQgb24gaXRzIGluZGV4IGluIGF1ZGlvIHRyYWNrIGxpc3RzKiovXG4gIHNldCBhdWRpb1RyYWNrKGF1ZGlvVHJhY2tJZCkge1xuICAgIGlmICh0aGlzLnRyYWNrSWQgIT09IGF1ZGlvVHJhY2tJZCB8fCB0aGlzLnRyYWNrc1thdWRpb1RyYWNrSWRdLmRldGFpbHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5zZXRBdWRpb1RyYWNrSW50ZXJuYWwoYXVkaW9UcmFja0lkKTtcbiAgICB9XG4gIH1cblxuIHNldEF1ZGlvVHJhY2tJbnRlcm5hbChuZXdJZCkge1xuICAgIC8vIGNoZWNrIGlmIGxldmVsIGlkeCBpcyB2YWxpZFxuICAgIGlmIChuZXdJZCA+PSAwICYmIG5ld0lkIDwgdGhpcy50cmFja3MubGVuZ3RoKSB7XG4gICAgICAvLyBzdG9wcGluZyBsaXZlIHJlbG9hZGluZyB0aW1lciBpZiBhbnlcbiAgICAgIGlmICh0aGlzLnRpbWVyKSB7XG4gICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLnRpbWVyKTtcbiAgICAgICB0aGlzLnRpbWVyID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHRoaXMudHJhY2tJZCA9IG5ld0lkO1xuICAgICAgbG9nZ2VyLmxvZyhgc3dpdGNoaW5nIHRvIGF1ZGlvVHJhY2sgJHtuZXdJZH1gKTtcbiAgICAgIGxldCBhdWRpb1RyYWNrID0gdGhpcy50cmFja3NbbmV3SWRdLFxuICAgICAgICAgIGhscyA9IHRoaXMuaGxzLFxuICAgICAgICAgIHR5cGUgPSBhdWRpb1RyYWNrLnR5cGUsXG4gICAgICAgICAgdXJsID0gYXVkaW9UcmFjay51cmwsXG4gICAgICAgICAgZXZlbnRPYmogPSB7aWQ6IG5ld0lkLCB0eXBlIDogdHlwZSwgdXJsIDogdXJsfTtcbiAgICAgIC8vIGtlZXAgQVVESU9fVFJBQ0tfU1dJVENIIGZvciBsZWdhY3kgcmVhc29uXG4gICAgICBobHMudHJpZ2dlcihFdmVudC5BVURJT19UUkFDS19TV0lUQ0gsIGV2ZW50T2JqKTtcbiAgICAgIGhscy50cmlnZ2VyKEV2ZW50LkFVRElPX1RSQUNLX1NXSVRDSElORywgZXZlbnRPYmopO1xuICAgICAgIC8vIGNoZWNrIGlmIHdlIG5lZWQgdG8gbG9hZCBwbGF5bGlzdCBmb3IgdGhpcyBhdWRpbyBUcmFja1xuICAgICAgIGxldCBkZXRhaWxzID0gYXVkaW9UcmFjay5kZXRhaWxzO1xuICAgICAgaWYgKHVybCAmJiAoZGV0YWlscyA9PT0gdW5kZWZpbmVkIHx8IGRldGFpbHMubGl2ZSA9PT0gdHJ1ZSkpIHtcbiAgICAgICAgLy8gdHJhY2sgbm90IHJldHJpZXZlZCB5ZXQsIG9yIGxpdmUgcGxheWxpc3Qgd2UgbmVlZCB0byAocmUpbG9hZCBpdFxuICAgICAgICBsb2dnZXIubG9nKGAocmUpbG9hZGluZyBwbGF5bGlzdCBmb3IgYXVkaW9UcmFjayAke25ld0lkfWApO1xuICAgICAgICBobHMudHJpZ2dlcihFdmVudC5BVURJT19UUkFDS19MT0FESU5HLCB7dXJsOiB1cmwsIGlkOiBuZXdJZH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHVwZGF0ZVRyYWNrKG5ld0lkKSB7XG4gICAgLy8gY2hlY2sgaWYgbGV2ZWwgaWR4IGlzIHZhbGlkXG4gICAgaWYgKG5ld0lkID49IDAgJiYgbmV3SWQgPCB0aGlzLnRyYWNrcy5sZW5ndGgpIHtcbiAgICAgIC8vIHN0b3BwaW5nIGxpdmUgcmVsb2FkaW5nIHRpbWVyIGlmIGFueVxuICAgICAgaWYgKHRoaXMudGltZXIpIHtcbiAgICAgICBjbGVhckludGVydmFsKHRoaXMudGltZXIpO1xuICAgICAgIHRoaXMudGltZXIgPSBudWxsO1xuICAgICAgfVxuICAgICAgdGhpcy50cmFja0lkID0gbmV3SWQ7XG4gICAgICBsb2dnZXIubG9nKGB1cGRhdGluZyBhdWRpb1RyYWNrICR7bmV3SWR9YCk7XG4gICAgICBsZXQgYXVkaW9UcmFjayA9IHRoaXMudHJhY2tzW25ld0lkXSwgdXJsID0gYXVkaW9UcmFjay51cmw7XG4gICAgICAgLy8gY2hlY2sgaWYgd2UgbmVlZCB0byBsb2FkIHBsYXlsaXN0IGZvciB0aGlzIGF1ZGlvIFRyYWNrXG4gICAgICAgbGV0IGRldGFpbHMgPSBhdWRpb1RyYWNrLmRldGFpbHM7XG4gICAgICBpZiAodXJsICYmIChkZXRhaWxzID09PSB1bmRlZmluZWQgfHwgZGV0YWlscy5saXZlID09PSB0cnVlKSkge1xuICAgICAgICAvLyB0cmFjayBub3QgcmV0cmlldmVkIHlldCwgb3IgbGl2ZSBwbGF5bGlzdCB3ZSBuZWVkIHRvIChyZSlsb2FkIGl0XG4gICAgICAgIGxvZ2dlci5sb2coYChyZSlsb2FkaW5nIHBsYXlsaXN0IGZvciBhdWRpb1RyYWNrICR7bmV3SWR9YCk7XG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuQVVESU9fVFJBQ0tfTE9BRElORywge3VybDogdXJsLCBpZDogbmV3SWR9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQXVkaW9UcmFja0NvbnRyb2xsZXI7XG4iLCIvKlxuICogQnVmZmVyIENvbnRyb2xsZXJcbiovXG5cbmltcG9ydCBFdmVudCBmcm9tICcuLi9ldmVudHMnO1xuaW1wb3J0IEV2ZW50SGFuZGxlciBmcm9tICcuLi9ldmVudC1oYW5kbGVyJztcbmltcG9ydCB7bG9nZ2VyfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xuaW1wb3J0IHtFcnJvclR5cGVzLCBFcnJvckRldGFpbHN9IGZyb20gJy4uL2Vycm9ycyc7XG5cblxuY2xhc3MgQnVmZmVyQ29udHJvbGxlciBleHRlbmRzIEV2ZW50SGFuZGxlciB7XG5cbiAgY29uc3RydWN0b3IoaGxzKSB7XG4gICAgc3VwZXIoaGxzLFxuICAgICAgRXZlbnQuTUVESUFfQVRUQUNISU5HLFxuICAgICAgRXZlbnQuTUVESUFfREVUQUNISU5HLFxuICAgICAgRXZlbnQuTUFOSUZFU1RfUEFSU0VELFxuICAgICAgRXZlbnQuQlVGRkVSX1JFU0VULFxuICAgICAgRXZlbnQuQlVGRkVSX0FQUEVORElORyxcbiAgICAgIEV2ZW50LkJVRkZFUl9DT0RFQ1MsXG4gICAgICBFdmVudC5CVUZGRVJfRU9TLFxuICAgICAgRXZlbnQuQlVGRkVSX0ZMVVNISU5HLFxuICAgICAgRXZlbnQuTEVWRUxfUFRTX1VQREFURUQsXG4gICAgICBFdmVudC5MRVZFTF9VUERBVEVEKTtcblxuICAgIC8vIHRoZSB2YWx1ZSB0aGF0IHdlIGhhdmUgc2V0IG1lZGlhc291cmNlLmR1cmF0aW9uIHRvXG4gICAgLy8gKHRoZSBhY3R1YWwgZHVyYXRpb24gbWF5IGJlIHR3ZWFrZWQgc2xpZ2hseSBieSB0aGUgYnJvd3NlcilcbiAgICB0aGlzLl9tc0R1cmF0aW9uID0gbnVsbDtcbiAgICAvLyB0aGUgdmFsdWUgdGhhdCB3ZSB3YW50IHRvIHNldCBtZWRpYVNvdXJjZS5kdXJhdGlvbiB0b1xuICAgIHRoaXMuX2xldmVsRHVyYXRpb24gPSBudWxsO1xuXG4gICAgLy8gU291cmNlIEJ1ZmZlciBsaXN0ZW5lcnNcbiAgICB0aGlzLm9uc2J1ZSA9IHRoaXMub25TQlVwZGF0ZUVuZC5iaW5kKHRoaXMpO1xuICAgIHRoaXMub25zYmUgID0gdGhpcy5vblNCVXBkYXRlRXJyb3IuYmluZCh0aGlzKTtcbiAgICB0aGlzLnBlbmRpbmdUcmFja3MgPSB7fTtcbiAgICB0aGlzLnRyYWNrcyA9IHt9O1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICBFdmVudEhhbmRsZXIucHJvdG90eXBlLmRlc3Ryb3kuY2FsbCh0aGlzKTtcbiAgfVxuXG4gIG9uTGV2ZWxQdHNVcGRhdGVkKGRhdGEpIHtcbiAgICBsZXQgdHlwZSA9IGRhdGEudHlwZTtcbiAgICBsZXQgYXVkaW9UcmFjayA9IHRoaXMudHJhY2tzLmF1ZGlvO1xuXG4gICAgLy8gQWRqdXN0aW5nIGBTb3VyY2VCdWZmZXIudGltZXN0YW1wT2Zmc2V0YCAoZGVzaXJlZCBwb2ludCBpbiB0aGUgdGltZWxpbmUgd2hlcmUgdGhlIG5leHQgZnJhbWVzIHNob3VsZCBiZSBhcHBlbmRlZClcbiAgICAvLyBpbiBDaHJvbWUgYnJvd3NlciB3aGVuIHdlIGRldGVjdCBNUEVHIGF1ZGlvIGNvbnRhaW5lciBhbmQgdGltZSBkZWx0YSBiZXR3ZWVuIGxldmVsIFBUUyBhbmQgYFNvdXJjZUJ1ZmZlci50aW1lc3RhbXBPZmZzZXRgXG4gICAgLy8gaXMgZ3JlYXRlciB0aGFuIDEwMG1zICh0aGlzIGlzIGVub3VnaCB0byBoYW5kbGUgc2VlayBmb3IgVk9EIG9yIGxldmVsIGNoYW5nZSBmb3IgTElWRSB2aWRlb3MpLiBBdCB0aGUgdGltZSBvZiBjaGFuZ2Ugd2UgaXNzdWVcbiAgICAvLyBgU291cmNlQnVmZmVyLmFib3J0KClgIGFuZCBhZGp1c3RpbmcgYFNvdXJjZUJ1ZmZlci50aW1lc3RhbXBPZmZzZXRgIGlmIGBTb3VyY2VCdWZmZXIudXBkYXRpbmdgIGlzIGZhbHNlIG9yIGF3YWl0aW5nIGB1cGRhdGVlbmRgXG4gICAgLy8gZXZlbnQgaWYgU0IgaXMgaW4gdXBkYXRpbmcgc3RhdGUuXG4gICAgLy8gTW9yZSBpbmZvIGhlcmU6IGh0dHBzOi8vZ2l0aHViLmNvbS9kYWlseW1vdGlvbi9obHMuanMvaXNzdWVzLzMzMiNpc3N1ZWNvbW1lbnQtMjU3OTg2NDg2XG5cbiAgICBpZiAodHlwZSA9PT0gJ2F1ZGlvJyAmJiBhdWRpb1RyYWNrICYmIGF1ZGlvVHJhY2suY29udGFpbmVyID09PSAnYXVkaW8vbXBlZycpIHsgLy8gQ2hyb21lIGF1ZGlvIG1wMyB0cmFja1xuICAgICAgbGV0IGF1ZGlvQnVmZmVyID0gdGhpcy5zb3VyY2VCdWZmZXIuYXVkaW87XG4gICAgICBsZXQgZGVsdGEgPSBNYXRoLmFicyhhdWRpb0J1ZmZlci50aW1lc3RhbXBPZmZzZXQgLSBkYXRhLnN0YXJ0KTtcblxuICAgICAgLy8gYWRqdXN0IHRpbWVzdGFtcCBvZmZzZXQgaWYgdGltZSBkZWx0YSBpcyBncmVhdGVyIHRoYW4gMTAwbXNcbiAgICAgIGlmIChkZWx0YSA+IDAuMSkge1xuICAgICAgICBsZXQgdXBkYXRpbmcgPSBhdWRpb0J1ZmZlci51cGRhdGluZztcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGF1ZGlvQnVmZmVyLmFib3J0KCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIHVwZGF0aW5nID0gdHJ1ZTtcbiAgICAgICAgICBsb2dnZXIud2FybignY2FuIG5vdCBhYm9ydCBhdWRpbyBidWZmZXI6ICcgKyBlcnIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF1cGRhdGluZykge1xuICAgICAgICAgIGxvZ2dlci53YXJuKCdjaGFuZ2UgbXBlZyBhdWRpbyB0aW1lc3RhbXAgb2Zmc2V0IGZyb20gJyArIGF1ZGlvQnVmZmVyLnRpbWVzdGFtcE9mZnNldCArICcgdG8gJyArIGRhdGEuc3RhcnQpO1xuICAgICAgICAgIGF1ZGlvQnVmZmVyLnRpbWVzdGFtcE9mZnNldCA9IGRhdGEuc3RhcnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5hdWRpb1RpbWVzdGFtcE9mZnNldCA9IGRhdGEuc3RhcnQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBvbk1hbmlmZXN0UGFyc2VkKGRhdGEpIHtcbiAgICBsZXQgYXVkaW9FeHBlY3RlZCA9IGRhdGEuYXVkaW8sXG4gICAgICAgIHZpZGVvRXhwZWN0ZWQgPSBkYXRhLnZpZGVvLFxuICAgICAgICBzb3VyY2VCdWZmZXJOYiA9IDA7XG4gICAgLy8gaW4gY2FzZSBvZiBhbHQgYXVkaW8gMiBCVUZGRVJfQ09ERUNTIGV2ZW50cyB3aWxsIGJlIHRyaWdnZXJlZCwgb25lIHBlciBzdHJlYW0gY29udHJvbGxlclxuICAgIC8vIHNvdXJjZWJ1ZmZlcnMgd2lsbCBiZSBjcmVhdGVkIGFsbCBhdCBvbmNlIHdoZW4gdGhlIGV4cGVjdGVkIG5iIG9mIHRyYWNrcyB3aWxsIGJlIHJlYWNoZWRcbiAgICAvLyBpbiBjYXNlIGFsdCBhdWRpbyBpcyBub3QgdXNlZCwgb25seSBvbmUgQlVGRkVSX0NPREVDIGV2ZW50IHdpbGwgYmUgZmlyZWQgZnJvbSBtYWluIHN0cmVhbSBjb250cm9sbGVyXG4gICAgLy8gaXQgd2lsbCBjb250YWluIHRoZSBleHBlY3RlZCBuYiBvZiBzb3VyY2UgYnVmZmVycywgbm8gbmVlZCB0byBjb21wdXRlIGl0XG4gICAgaWYgKGRhdGEuYWx0QXVkaW8gJiYgKGF1ZGlvRXhwZWN0ZWQgfHwgdmlkZW9FeHBlY3RlZCkpIHtcbiAgICAgIHNvdXJjZUJ1ZmZlck5iID0gKGF1ZGlvRXhwZWN0ZWQgPyAxIDogMCkgKyAodmlkZW9FeHBlY3RlZCA/IDEgOiAwKTtcbiAgICAgIGxvZ2dlci5sb2coYCR7c291cmNlQnVmZmVyTmJ9IHNvdXJjZUJ1ZmZlcihzKSBleHBlY3RlZGApO1xuICAgIH1cbiAgICB0aGlzLnNvdXJjZUJ1ZmZlck5iID0gc291cmNlQnVmZmVyTmI7XG4gIH1cblxuICBvbk1lZGlhQXR0YWNoaW5nKGRhdGEpIHtcbiAgICBsZXQgbWVkaWEgPSB0aGlzLm1lZGlhID0gZGF0YS5tZWRpYTtcbiAgICBpZiAobWVkaWEpIHtcbiAgICAgIC8vIHNldHVwIHRoZSBtZWRpYSBzb3VyY2VcbiAgICAgIHZhciBtcyA9IHRoaXMubWVkaWFTb3VyY2UgPSBuZXcgTWVkaWFTb3VyY2UoKTtcbiAgICAgIC8vTWVkaWEgU291cmNlIGxpc3RlbmVyc1xuICAgICAgdGhpcy5vbm1zbyA9IHRoaXMub25NZWRpYVNvdXJjZU9wZW4uYmluZCh0aGlzKTtcbiAgICAgIHRoaXMub25tc2UgPSB0aGlzLm9uTWVkaWFTb3VyY2VFbmRlZC5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5vbm1zYyA9IHRoaXMub25NZWRpYVNvdXJjZUNsb3NlLmJpbmQodGhpcyk7XG4gICAgICBtcy5hZGRFdmVudExpc3RlbmVyKCdzb3VyY2VvcGVuJywgdGhpcy5vbm1zbyk7XG4gICAgICBtcy5hZGRFdmVudExpc3RlbmVyKCdzb3VyY2VlbmRlZCcsIHRoaXMub25tc2UpO1xuICAgICAgbXMuYWRkRXZlbnRMaXN0ZW5lcignc291cmNlY2xvc2UnLCB0aGlzLm9ubXNjKTtcbiAgICAgIC8vIGxpbmsgdmlkZW8gYW5kIG1lZGlhIFNvdXJjZVxuICAgICAgbWVkaWEuc3JjID0gVVJMLmNyZWF0ZU9iamVjdFVSTChtcyk7XG4gICAgfVxuICB9XG5cbiAgb25NZWRpYURldGFjaGluZygpIHtcbiAgICBsb2dnZXIubG9nKCdtZWRpYSBzb3VyY2UgZGV0YWNoaW5nJyk7XG4gICAgdmFyIG1zID0gdGhpcy5tZWRpYVNvdXJjZTtcbiAgICBpZiAobXMpIHtcbiAgICAgIGlmIChtcy5yZWFkeVN0YXRlID09PSAnb3BlbicpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBlbmRPZlN0cmVhbSBjb3VsZCB0cmlnZ2VyIGV4Y2VwdGlvbiBpZiBhbnkgc291cmNlYnVmZmVyIGlzIGluIHVwZGF0aW5nIHN0YXRlXG4gICAgICAgICAgLy8gd2UgZG9uJ3QgcmVhbGx5IGNhcmUgYWJvdXQgY2hlY2tpbmcgc291cmNlYnVmZmVyIHN0YXRlIGhlcmUsXG4gICAgICAgICAgLy8gYXMgd2UgYXJlIGFueXdheSBkZXRhY2hpbmcgdGhlIE1lZGlhU291cmNlXG4gICAgICAgICAgLy8gbGV0J3MganVzdCBhdm9pZCB0aGlzIGV4Y2VwdGlvbiB0byBwcm9wYWdhdGVcbiAgICAgICAgICBtcy5lbmRPZlN0cmVhbSgpO1xuICAgICAgICB9IGNhdGNoKGVycikge1xuICAgICAgICAgIGxvZ2dlci53YXJuKGBvbk1lZGlhRGV0YWNoaW5nOiR7ZXJyLm1lc3NhZ2V9IHdoaWxlIGNhbGxpbmcgZW5kT2ZTdHJlYW1gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignc291cmNlb3BlbicsIHRoaXMub25tc28pO1xuICAgICAgbXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignc291cmNlZW5kZWQnLCB0aGlzLm9ubXNlKTtcbiAgICAgIG1zLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3NvdXJjZWNsb3NlJywgdGhpcy5vbm1zYyk7XG5cbiAgICAgIC8vIERldGFjaCBwcm9wZXJseSB0aGUgTWVkaWFTb3VyY2UgZnJvbSB0aGUgSFRNTE1lZGlhRWxlbWVudCBhc1xuICAgICAgLy8gc3VnZ2VzdGVkIGluIGh0dHBzOi8vZ2l0aHViLmNvbS93M2MvbWVkaWEtc291cmNlL2lzc3Vlcy81My5cbiAgICAgIGlmICh0aGlzLm1lZGlhKSB7XG4gICAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwodGhpcy5tZWRpYS5zcmMpO1xuICAgICAgICB0aGlzLm1lZGlhLnJlbW92ZUF0dHJpYnV0ZSgnc3JjJyk7XG4gICAgICAgIHRoaXMubWVkaWEubG9hZCgpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLm1lZGlhU291cmNlID0gbnVsbDtcbiAgICAgIHRoaXMubWVkaWEgPSBudWxsO1xuICAgICAgdGhpcy5wZW5kaW5nVHJhY2tzID0ge307XG4gICAgICB0aGlzLnRyYWNrcyA9IHt9O1xuICAgICAgdGhpcy5zb3VyY2VCdWZmZXIgPSB7fTtcbiAgICAgIHRoaXMuZmx1c2hSYW5nZSA9IFtdO1xuICAgICAgdGhpcy5zZWdtZW50cyA9IFtdO1xuICAgICAgdGhpcy5hcHBlbmRlZCA9IDA7XG4gICAgfVxuICAgIHRoaXMub25tc28gPSB0aGlzLm9ubXNlID0gdGhpcy5vbm1zYyA9IG51bGw7XG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5NRURJQV9ERVRBQ0hFRCk7XG4gIH1cblxuICBvbk1lZGlhU291cmNlT3BlbigpIHtcbiAgICBsb2dnZXIubG9nKCdtZWRpYSBzb3VyY2Ugb3BlbmVkJyk7XG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5NRURJQV9BVFRBQ0hFRCwgeyBtZWRpYSA6IHRoaXMubWVkaWEgfSk7XG4gICAgbGV0IG1lZGlhU291cmNlID0gdGhpcy5tZWRpYVNvdXJjZTtcbiAgICBpZiAobWVkaWFTb3VyY2UpIHtcbiAgICAgIC8vIG9uY2UgcmVjZWl2ZWQsIGRvbid0IGxpc3RlbiBhbnltb3JlIHRvIHNvdXJjZW9wZW4gZXZlbnRcbiAgICAgIG1lZGlhU291cmNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3NvdXJjZW9wZW4nLCB0aGlzLm9ubXNvKTtcbiAgICB9XG4gICAgdGhpcy5jaGVja1BlbmRpbmdUcmFja3MoKTtcbiAgfVxuXG4gIGNoZWNrUGVuZGluZ1RyYWNrcygpIHtcbiAgICAvLyBpZiBhbnkgYnVmZmVyIGNvZGVjcyBwZW5kaW5nLCBjaGVjayBpZiB3ZSBoYXZlIGVub3VnaCB0byBjcmVhdGUgc291cmNlQnVmZmVyc1xuICAgIGxldCBwZW5kaW5nVHJhY2tzID0gdGhpcy5wZW5kaW5nVHJhY2tzLFxuICAgICAgICBwZW5kaW5nVHJhY2tzTmIgPSBPYmplY3Qua2V5cyhwZW5kaW5nVHJhY2tzKS5sZW5ndGg7XG4gICAgLy8gaWYgYW55IHBlbmRpbmcgdHJhY2tzIGFuZCAoaWYgbmIgb2YgcGVuZGluZyB0cmFja3MgZ3Qgb3IgZXF1YWwgdGhhbiBleHBlY3RlZCBuYiBvciBpZiB1bmtub3duIGV4cGVjdGVkIG5iKVxuICAgIGlmIChwZW5kaW5nVHJhY2tzTmIgJiYgKFxuICAgICAgICB0aGlzLnNvdXJjZUJ1ZmZlck5iIDw9IHBlbmRpbmdUcmFja3NOYiB8fFxuICAgICAgICB0aGlzLnNvdXJjZUJ1ZmZlck5iID09PSAwKSkge1xuICAgICAgLy8gb2ssIGxldCdzIGNyZWF0ZSB0aGVtIG5vdyAhXG4gICAgICB0aGlzLmNyZWF0ZVNvdXJjZUJ1ZmZlcnMocGVuZGluZ1RyYWNrcyk7XG4gICAgICB0aGlzLnBlbmRpbmdUcmFja3MgPSB7fTtcbiAgICAgIC8vIGFwcGVuZCBhbnkgcGVuZGluZyBzZWdtZW50cyBub3cgIVxuICAgICAgdGhpcy5kb0FwcGVuZGluZygpO1xuICAgIH1cbiAgfVxuXG4gIG9uTWVkaWFTb3VyY2VDbG9zZSgpIHtcbiAgICBsb2dnZXIubG9nKCdtZWRpYSBzb3VyY2UgY2xvc2VkJyk7XG4gIH1cblxuICBvbk1lZGlhU291cmNlRW5kZWQoKSB7XG4gICAgbG9nZ2VyLmxvZygnbWVkaWEgc291cmNlIGVuZGVkJyk7XG4gIH1cblxuXG4gIG9uU0JVcGRhdGVFbmQoKSB7XG4gICAgLy8gdXBkYXRlIHRpbWVzdGFtcE9mZnNldFxuICAgIGlmICh0aGlzLmF1ZGlvVGltZXN0YW1wT2Zmc2V0KSB7XG4gICAgICBsZXQgYXVkaW9CdWZmZXIgPSB0aGlzLnNvdXJjZUJ1ZmZlci5hdWRpbztcbiAgICAgIGxvZ2dlci53YXJuKCdjaGFuZ2UgbXBlZyBhdWRpbyB0aW1lc3RhbXAgb2Zmc2V0IGZyb20gJyArIGF1ZGlvQnVmZmVyLnRpbWVzdGFtcE9mZnNldCArICcgdG8gJyArIHRoaXMuYXVkaW9UaW1lc3RhbXBPZmZzZXQpO1xuICAgICAgYXVkaW9CdWZmZXIudGltZXN0YW1wT2Zmc2V0ID0gdGhpcy5hdWRpb1RpbWVzdGFtcE9mZnNldDtcbiAgICAgIGRlbGV0ZSB0aGlzLmF1ZGlvVGltZXN0YW1wT2Zmc2V0O1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9uZWVkc0ZsdXNoKSB7XG4gICAgICB0aGlzLmRvRmx1c2goKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fbmVlZHNFb3MpIHtcbiAgICAgIHRoaXMuY2hlY2tFb3MoKTtcbiAgICB9XG4gICAgdGhpcy5hcHBlbmRpbmcgPSBmYWxzZTtcbiAgICBsZXQgcGFyZW50ID0gdGhpcy5wYXJlbnQ7XG4gICAgLy8gY291bnQgbmIgb2YgcGVuZGluZyBzZWdtZW50cyB3YWl0aW5nIGZvciBhcHBlbmRpbmcgb24gdGhpcyBzb3VyY2VidWZmZXJcbiAgICBsZXQgcGVuZGluZyA9IHRoaXMuc2VnbWVudHMucmVkdWNlKCAoY291bnRlciwgc2VnbWVudCkgPT4gKHNlZ21lbnQucGFyZW50ID09PSBwYXJlbnQpID8gY291bnRlciArIDEgOiBjb3VudGVyICwgMCk7XG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5CVUZGRVJfQVBQRU5ERUQsIHsgcGFyZW50IDogcGFyZW50LCBwZW5kaW5nIDogcGVuZGluZyB9KTtcblxuICAgIC8vIGRvbid0IGFwcGVuZCBpbiBmbHVzaGluZyBtb2RlXG4gICAgaWYgKCF0aGlzLl9uZWVkc0ZsdXNoKSB7XG4gICAgICB0aGlzLmRvQXBwZW5kaW5nKCk7XG4gICAgfVxuXG4gICAgdGhpcy51cGRhdGVNZWRpYUVsZW1lbnREdXJhdGlvbigpO1xuICB9XG5cbiAgb25TQlVwZGF0ZUVycm9yKGV2ZW50KSB7XG4gICAgbG9nZ2VyLmVycm9yKGBzb3VyY2VCdWZmZXIgZXJyb3I6JHtldmVudH1gKTtcbiAgICAvLyBhY2NvcmRpbmcgdG8gaHR0cDovL3d3dy53My5vcmcvVFIvbWVkaWEtc291cmNlLyNzb3VyY2VidWZmZXItYXBwZW5kLWVycm9yXG4gICAgLy8gdGhpcyBlcnJvciBtaWdodCBub3QgYWx3YXlzIGJlIGZhdGFsIChpdCBpcyBmYXRhbCBpZiBkZWNvZGUgZXJyb3IgaXMgc2V0LCBpbiB0aGF0IGNhc2VcbiAgICAvLyBpdCB3aWxsIGJlIGZvbGxvd2VkIGJ5IGEgbWVkaWFFbGVtZW50IGVycm9yIC4uLilcbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkVSUk9SLCB7dHlwZTogRXJyb3JUeXBlcy5NRURJQV9FUlJPUiwgZGV0YWlsczogRXJyb3JEZXRhaWxzLkJVRkZFUl9BUFBFTkRJTkdfRVJST1IsIGZhdGFsOiBmYWxzZX0pO1xuICAgIC8vIHdlIGRvbid0IG5lZWQgdG8gZG8gbW9yZSB0aGFuIHRoYXQsIGFzIGFjY29yZGluIHRvIHRoZSBzcGVjLCB1cGRhdGVlbmQgd2lsbCBiZSBmaXJlZCBqdXN0IGFmdGVyXG4gIH1cblxuICBvbkJ1ZmZlclJlc2V0KCkge1xuICAgIHZhciBzb3VyY2VCdWZmZXIgPSB0aGlzLnNvdXJjZUJ1ZmZlcjtcbiAgICBmb3IodmFyIHR5cGUgaW4gc291cmNlQnVmZmVyKSB7XG4gICAgICB2YXIgc2IgPSBzb3VyY2VCdWZmZXJbdHlwZV07XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLm1lZGlhU291cmNlLnJlbW92ZVNvdXJjZUJ1ZmZlcihzYik7XG4gICAgICAgIHNiLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3VwZGF0ZWVuZCcsIHRoaXMub25zYnVlKTtcbiAgICAgICAgc2IucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCB0aGlzLm9uc2JlKTtcbiAgICAgIH0gY2F0Y2goZXJyKSB7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuc291cmNlQnVmZmVyID0ge307XG4gICAgdGhpcy5mbHVzaFJhbmdlID0gW107XG4gICAgdGhpcy5zZWdtZW50cyA9IFtdO1xuICAgIHRoaXMuYXBwZW5kZWQgPSAwO1xuICB9XG5cbiAgb25CdWZmZXJDb2RlY3ModHJhY2tzKSB7XG4gICAgLy8gaWYgc291cmNlIGJ1ZmZlcihzKSBub3QgY3JlYXRlZCB5ZXQsIGFwcGVuZGVkIGJ1ZmZlciB0cmFja3MgaW4gdGhpcy5wZW5kaW5nVHJhY2tzXG4gICAgLy8gaWYgc291cmNlYnVmZmVycyBhbHJlYWR5IGNyZWF0ZWQsIGRvIG5vdGhpbmcgLi4uXG4gICAgaWYgKE9iamVjdC5rZXlzKHRoaXMuc291cmNlQnVmZmVyKS5sZW5ndGggPT09IDApIHtcbiAgICAgIGZvciAodmFyIHRyYWNrTmFtZSBpbiB0cmFja3MpIHsgdGhpcy5wZW5kaW5nVHJhY2tzW3RyYWNrTmFtZV0gPSB0cmFja3NbdHJhY2tOYW1lXTsgfVxuICAgICAgbGV0IG1lZGlhU291cmNlID0gdGhpcy5tZWRpYVNvdXJjZTtcbiAgICAgIGlmIChtZWRpYVNvdXJjZSAmJiBtZWRpYVNvdXJjZS5yZWFkeVN0YXRlID09PSAnb3BlbicpIHtcbiAgICAgICAgLy8gdHJ5IHRvIGNyZWF0ZSBzb3VyY2VidWZmZXJzIGlmIG1lZGlhc291cmNlIG9wZW5lZFxuICAgICAgICB0aGlzLmNoZWNrUGVuZGluZ1RyYWNrcygpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG5cbiAgY3JlYXRlU291cmNlQnVmZmVycyh0cmFja3MpIHtcbiAgICB2YXIgc291cmNlQnVmZmVyID0gdGhpcy5zb3VyY2VCdWZmZXIsbWVkaWFTb3VyY2UgPSB0aGlzLm1lZGlhU291cmNlO1xuXG4gICAgZm9yIChsZXQgdHJhY2tOYW1lIGluIHRyYWNrcykge1xuICAgICAgaWYoIXNvdXJjZUJ1ZmZlclt0cmFja05hbWVdKSB7XG4gICAgICAgIGxldCB0cmFjayA9IHRyYWNrc1t0cmFja05hbWVdO1xuICAgICAgICAvLyB1c2UgbGV2ZWxDb2RlYyBhcyBmaXJzdCBwcmlvcml0eVxuICAgICAgICBsZXQgY29kZWMgPSB0cmFjay5sZXZlbENvZGVjIHx8IHRyYWNrLmNvZGVjO1xuICAgICAgICBsZXQgbWltZVR5cGUgPSBgJHt0cmFjay5jb250YWluZXJ9O2NvZGVjcz0ke2NvZGVjfWA7XG4gICAgICAgIGxvZ2dlci5sb2coYGNyZWF0aW5nIHNvdXJjZUJ1ZmZlcigke21pbWVUeXBlfSlgKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBsZXQgc2IgPSBzb3VyY2VCdWZmZXJbdHJhY2tOYW1lXSA9IG1lZGlhU291cmNlLmFkZFNvdXJjZUJ1ZmZlcihtaW1lVHlwZSk7XG4gICAgICAgICAgc2IuYWRkRXZlbnRMaXN0ZW5lcigndXBkYXRlZW5kJywgdGhpcy5vbnNidWUpO1xuICAgICAgICAgIHNiLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgdGhpcy5vbnNiZSk7XG4gICAgICAgICAgdGhpcy50cmFja3NbdHJhY2tOYW1lXSA9IHtjb2RlYzogY29kZWMsIGNvbnRhaW5lcjogdHJhY2suY29udGFpbmVyfTtcbiAgICAgICAgICB0cmFjay5idWZmZXIgPSBzYjtcbiAgICAgICAgfSBjYXRjaChlcnIpIHtcbiAgICAgICAgICBsb2dnZXIuZXJyb3IoYGVycm9yIHdoaWxlIHRyeWluZyB0byBhZGQgc291cmNlQnVmZmVyOiR7ZXJyLm1lc3NhZ2V9YCk7XG4gICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5FUlJPUiwge3R5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsIGRldGFpbHM6IEVycm9yRGV0YWlscy5CVUZGRVJfQUREX0NPREVDX0VSUk9SLCBmYXRhbDogZmFsc2UsIGVycjogZXJyLCBtaW1lVHlwZSA6IG1pbWVUeXBlfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5CVUZGRVJfQ1JFQVRFRCwgeyB0cmFja3MgOiB0cmFja3MgfSApO1xuICB9XG5cbiAgb25CdWZmZXJBcHBlbmRpbmcoZGF0YSkge1xuICAgIGlmICghdGhpcy5fbmVlZHNGbHVzaCkge1xuICAgICAgaWYgKCF0aGlzLnNlZ21lbnRzKSB7XG4gICAgICAgIHRoaXMuc2VnbWVudHMgPSBbIGRhdGEgXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2VnbWVudHMucHVzaChkYXRhKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZG9BcHBlbmRpbmcoKTtcbiAgICB9XG4gIH1cblxuICBvbkJ1ZmZlckFwcGVuZEZhaWwoZGF0YSkge1xuICAgIGxvZ2dlci5lcnJvcihgc291cmNlQnVmZmVyIGVycm9yOiR7ZGF0YS5ldmVudH1gKTtcbiAgICAvLyBhY2NvcmRpbmcgdG8gaHR0cDovL3d3dy53My5vcmcvVFIvbWVkaWEtc291cmNlLyNzb3VyY2VidWZmZXItYXBwZW5kLWVycm9yXG4gICAgLy8gdGhpcyBlcnJvciBtaWdodCBub3QgYWx3YXlzIGJlIGZhdGFsIChpdCBpcyBmYXRhbCBpZiBkZWNvZGUgZXJyb3IgaXMgc2V0LCBpbiB0aGF0IGNhc2VcbiAgICAvLyBpdCB3aWxsIGJlIGZvbGxvd2VkIGJ5IGEgbWVkaWFFbGVtZW50IGVycm9yIC4uLilcbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkVSUk9SLCB7dHlwZTogRXJyb3JUeXBlcy5NRURJQV9FUlJPUiwgZGV0YWlsczogRXJyb3JEZXRhaWxzLkJVRkZFUl9BUFBFTkRJTkdfRVJST1IsIGZhdGFsOiBmYWxzZSwgZnJhZzogdGhpcy5mcmFnQ3VycmVudH0pO1xuICB9XG5cbiAgLy8gb24gQlVGRkVSX0VPUyBtYXJrIG1hdGNoaW5nIHNvdXJjZWJ1ZmZlcihzKSBhcyBlbmRlZCBhbmQgdHJpZ2dlciBjaGVja0VvcygpXG4gIG9uQnVmZmVyRW9zKGRhdGEpIHtcbiAgICB2YXIgc2IgPSB0aGlzLnNvdXJjZUJ1ZmZlcjtcbiAgICBsZXQgZGF0YVR5cGUgPSBkYXRhLnR5cGU7XG4gICAgZm9yKGxldCB0eXBlIGluIHNiKSB7XG4gICAgICBpZiAoIWRhdGFUeXBlIHx8IHR5cGUgPT09IGRhdGFUeXBlKSB7XG4gICAgICAgIGlmICghc2JbdHlwZV0uZW5kZWQpIHtcbiAgICAgICAgICBzYlt0eXBlXS5lbmRlZCA9IHRydWU7XG4gICAgICAgICAgbG9nZ2VyLmxvZyhgJHt0eXBlfSBzb3VyY2VCdWZmZXIgbm93IEVPU2ApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuY2hlY2tFb3MoKTtcbiAgfVxuXG4gLy8gaWYgYWxsIHNvdXJjZSBidWZmZXJzIGFyZSBtYXJrZWQgYXMgZW5kZWQsIHNpZ25hbCBlbmRPZlN0cmVhbSgpIHRvIE1lZGlhU291cmNlLlxuIGNoZWNrRW9zKCkge1xuICAgIHZhciBzYiA9IHRoaXMuc291cmNlQnVmZmVyLCBtZWRpYVNvdXJjZSA9IHRoaXMubWVkaWFTb3VyY2U7XG4gICAgaWYgKCFtZWRpYVNvdXJjZSB8fCBtZWRpYVNvdXJjZS5yZWFkeVN0YXRlICE9PSAnb3BlbicpIHtcbiAgICAgIHRoaXMuX25lZWRzRW9zID0gZmFsc2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvcihsZXQgdHlwZSBpbiBzYikge1xuICAgICAgbGV0IHNib2JqID0gc2JbdHlwZV07XG4gICAgICBpZiAoIXNib2JqLmVuZGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmKHNib2JqLnVwZGF0aW5nKSB7XG4gICAgICAgIHRoaXMuX25lZWRzRW9zID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBsb2dnZXIubG9nKCdhbGwgbWVkaWEgZGF0YSBhdmFpbGFibGUsIHNpZ25hbCBlbmRPZlN0cmVhbSgpIHRvIE1lZGlhU291cmNlIGFuZCBzdG9wIGxvYWRpbmcgZnJhZ21lbnQnKTtcbiAgICAvL05vdGlmeSB0aGUgbWVkaWEgZWxlbWVudCB0aGF0IGl0IG5vdyBoYXMgYWxsIG9mIHRoZSBtZWRpYSBkYXRhXG4gICAgdHJ5IHtcbiAgICAgIG1lZGlhU291cmNlLmVuZE9mU3RyZWFtKCk7XG4gICAgfSBjYXRjaChlKSB7XG4gICAgICBsb2dnZXIud2FybignZXhjZXB0aW9uIHdoaWxlIGNhbGxpbmcgbWVkaWFTb3VyY2UuZW5kT2ZTdHJlYW0oKScpO1xuICAgIH1cbiAgICB0aGlzLl9uZWVkc0VvcyA9IGZhbHNlO1xuIH1cblxuXG4gIG9uQnVmZmVyRmx1c2hpbmcoZGF0YSkge1xuICAgIHRoaXMuZmx1c2hSYW5nZS5wdXNoKHtzdGFydDogZGF0YS5zdGFydE9mZnNldCwgZW5kOiBkYXRhLmVuZE9mZnNldCwgdHlwZSA6IGRhdGEudHlwZX0pO1xuICAgIC8vIGF0dGVtcHQgZmx1c2ggaW1tZWRpYXRseVxuICAgIHRoaXMuZmx1c2hCdWZmZXJDb3VudGVyID0gMDtcbiAgICB0aGlzLmRvRmx1c2goKTtcbiAgfVxuXG4gIG9uTGV2ZWxVcGRhdGVkKGV2ZW50KSB7XG4gICAgbGV0IGRldGFpbHMgPSBldmVudC5kZXRhaWxzO1xuICAgIGlmIChkZXRhaWxzLmZyYWdtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fbGV2ZWxEdXJhdGlvbiA9IGRldGFpbHMudG90YWxkdXJhdGlvbiArIGRldGFpbHMuZnJhZ21lbnRzWzBdLnN0YXJ0O1xuICAgIHRoaXMudXBkYXRlTWVkaWFFbGVtZW50RHVyYXRpb24oKTtcbiAgfVxuXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9kYWlseW1vdGlvbi9obHMuanMvaXNzdWVzLzM1NVxuICB1cGRhdGVNZWRpYUVsZW1lbnREdXJhdGlvbigpIHtcbiAgICBsZXQgbWVkaWEgPSB0aGlzLm1lZGlhLFxuICAgICAgICBtZWRpYVNvdXJjZSA9IHRoaXMubWVkaWFTb3VyY2UsXG4gICAgICAgIHNvdXJjZUJ1ZmZlciA9IHRoaXMuc291cmNlQnVmZmVyLFxuICAgICAgICBsZXZlbER1cmF0aW9uID0gdGhpcy5fbGV2ZWxEdXJhdGlvbjtcbiAgICBpZiAobGV2ZWxEdXJhdGlvbiA9PT0gbnVsbCB8fCAhbWVkaWEgfHwgIW1lZGlhU291cmNlIHx8ICFzb3VyY2VCdWZmZXIgfHwgbWVkaWEucmVhZHlTdGF0ZSA9PT0gMCB8fCBtZWRpYVNvdXJjZS5yZWFkeVN0YXRlICE9PSAnb3BlbicpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChsZXQgdHlwZSBpbiBzb3VyY2VCdWZmZXIpIHtcbiAgICAgIGlmIChzb3VyY2VCdWZmZXJbdHlwZV0udXBkYXRpbmcpIHtcbiAgICAgICAgLy8gY2FuJ3Qgc2V0IGR1cmF0aW9uIHdoaWxzdCBhIGJ1ZmZlciBpcyB1cGRhdGluZ1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLl9tc0R1cmF0aW9uID09PSBudWxsKSB7XG4gICAgICAvLyBpbml0aWFsaXNlIHRvIHRoZSB2YWx1ZSB0aGF0IHRoZSBtZWRpYSBzb3VyY2UgaXMgcmVwb3J0aW5nXG4gICAgICB0aGlzLl9tc0R1cmF0aW9uID0gbWVkaWFTb3VyY2UuZHVyYXRpb247XG4gICAgfVxuICAgIC8vIGxldmVsRHVyYXRpb24gd2FzIHRoZSBsYXN0IHZhbHVlIHdlIHNldC5cbiAgICAvLyBub3QgdXNpbmcgbWVkaWFTb3VyY2UuZHVyYXRpb24gYXMgdGhlIGJyb3dzZXIgbWF5IHR3ZWFrIHRoaXMgdmFsdWVcbiAgICAvLyBvbmx5IHVwZGF0ZSBtZWRpYXNvdXJjZSBkdXJhdGlvbiBpZiBpdHMgdmFsdWUgaW5jcmVhc2UsIHRoaXMgaXMgdG8gYXZvaWRcbiAgICAvLyBmbHVzaGluZyBhbHJlYWR5IGJ1ZmZlcmVkIHBvcnRpb24gd2hlbiBzd2l0Y2hpbmcgYmV0d2VlbiBxdWFsaXR5IGxldmVsXG4gICAgaWYgKGxldmVsRHVyYXRpb24gPiB0aGlzLl9tc0R1cmF0aW9uICYmIGxldmVsRHVyYXRpb24gPiBtZWRpYS5kdXJhdGlvbikge1xuICAgICAgbG9nZ2VyLmxvZyhgVXBkYXRpbmcgbWVkaWFzb3VyY2UgZHVyYXRpb24gdG8gJHtsZXZlbER1cmF0aW9uLnRvRml4ZWQoMyl9YCk7XG4gICAgICB0aGlzLl9tc0R1cmF0aW9uID0gbWVkaWFTb3VyY2UuZHVyYXRpb24gPSBsZXZlbER1cmF0aW9uO1xuICAgIH1cbiAgfVxuXG4gIGRvRmx1c2goKSB7XG4gICAgLy8gbG9vcCB0aHJvdWdoIGFsbCBidWZmZXIgcmFuZ2VzIHRvIGZsdXNoXG4gICAgd2hpbGUodGhpcy5mbHVzaFJhbmdlLmxlbmd0aCkge1xuICAgICAgdmFyIHJhbmdlID0gdGhpcy5mbHVzaFJhbmdlWzBdO1xuICAgICAgLy8gZmx1c2hCdWZmZXIgd2lsbCBhYm9ydCBhbnkgYnVmZmVyIGFwcGVuZCBpbiBwcm9ncmVzcyBhbmQgZmx1c2ggQXVkaW8vVmlkZW8gQnVmZmVyXG4gICAgICBpZiAodGhpcy5mbHVzaEJ1ZmZlcihyYW5nZS5zdGFydCwgcmFuZ2UuZW5kLCByYW5nZS50eXBlKSkge1xuICAgICAgICAvLyByYW5nZSBmbHVzaGVkLCByZW1vdmUgZnJvbSBmbHVzaCBhcnJheVxuICAgICAgICB0aGlzLmZsdXNoUmFuZ2Uuc2hpZnQoKTtcbiAgICAgICAgdGhpcy5mbHVzaEJ1ZmZlckNvdW50ZXIgPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fbmVlZHNGbHVzaCA9IHRydWU7XG4gICAgICAgIC8vIGF2b2lkIGxvb3BpbmcsIHdhaXQgZm9yIFNCIHVwZGF0ZSBlbmQgdG8gcmV0cmlnZ2VyIGEgZmx1c2hcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5mbHVzaFJhbmdlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgLy8gZXZlcnl0aGluZyBmbHVzaGVkXG4gICAgICB0aGlzLl9uZWVkc0ZsdXNoID0gZmFsc2U7XG5cbiAgICAgIC8vIGxldCdzIHJlY29tcHV0ZSB0aGlzLmFwcGVuZGVkLCB3aGljaCBpcyB1c2VkIHRvIGF2b2lkIGZsdXNoIGxvb3BpbmdcbiAgICAgIHZhciBhcHBlbmRlZCA9IDA7XG4gICAgICB2YXIgc291cmNlQnVmZmVyID0gdGhpcy5zb3VyY2VCdWZmZXI7XG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKHZhciB0eXBlIGluIHNvdXJjZUJ1ZmZlcikge1xuICAgICAgICAgIGFwcGVuZGVkICs9IHNvdXJjZUJ1ZmZlclt0eXBlXS5idWZmZXJlZC5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2goZXJyb3IpIHtcbiAgICAgICAgLy8gZXJyb3IgY291bGQgYmUgdGhyb3duIHdoaWxlIGFjY2Vzc2luZyBidWZmZXJlZCwgaW4gY2FzZSBzb3VyY2VidWZmZXIgaGFzIGFscmVhZHkgYmVlbiByZW1vdmVkIGZyb20gTWVkaWFTb3VyY2VcbiAgICAgICAgLy8gdGhpcyBpcyBoYXJtZXNzIGF0IHRoaXMgc3RhZ2UsIGNhdGNoIHRoaXMgdG8gYXZvaWQgcmVwb3J0aW5nIGFuIGludGVybmFsIGV4Y2VwdGlvblxuICAgICAgICBsb2dnZXIuZXJyb3IoJ2Vycm9yIHdoaWxlIGFjY2Vzc2luZyBzb3VyY2VCdWZmZXIuYnVmZmVyZWQnKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYXBwZW5kZWQgPSBhcHBlbmRlZDtcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuQlVGRkVSX0ZMVVNIRUQpO1xuICAgIH1cbiAgfVxuXG4gIGRvQXBwZW5kaW5nKCkge1xuICAgIHZhciBobHMgPSB0aGlzLmhscywgc291cmNlQnVmZmVyID0gdGhpcy5zb3VyY2VCdWZmZXIsIHNlZ21lbnRzID0gdGhpcy5zZWdtZW50cztcbiAgICBpZiAoT2JqZWN0LmtleXMoc291cmNlQnVmZmVyKS5sZW5ndGgpIHtcbiAgICAgIGlmICh0aGlzLm1lZGlhLmVycm9yKSB7XG4gICAgICAgIHRoaXMuc2VnbWVudHMgPSBbXTtcbiAgICAgICAgbG9nZ2VyLmVycm9yKCd0cnlpbmcgdG8gYXBwZW5kIGFsdGhvdWdoIGEgbWVkaWEgZXJyb3Igb2NjdXJlZCwgZmx1c2ggc2VnbWVudCBhbmQgYWJvcnQnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuYXBwZW5kaW5nKSB7XG4gICAgICAgIC8vbG9nZ2VyLmxvZyhgc2IgYXBwZW5kaW5nIGluIHByb2dyZXNzYCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChzZWdtZW50cyAmJiBzZWdtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgbGV0IHNlZ21lbnQgPSBzZWdtZW50cy5zaGlmdCgpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGxldCB0eXBlID0gc2VnbWVudC50eXBlLCBzYiA9IHNvdXJjZUJ1ZmZlclt0eXBlXTtcbiAgICAgICAgICBpZihzYikge1xuICAgICAgICAgICAgaWYoIXNiLnVwZGF0aW5nKSB7XG4gICAgICAgICAgICAgIC8vIHJlc2V0IHNvdXJjZUJ1ZmZlciBlbmRlZCBmbGFnIGJlZm9yZSBhcHBlbmRpbmcgc2VnbWVudFxuICAgICAgICAgICAgICBzYi5lbmRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAvL2xvZ2dlci5sb2coYGFwcGVuZGluZyAke3NlZ21lbnQuY29udGVudH0gJHt0eXBlfSBTQiwgc2l6ZToke3NlZ21lbnQuZGF0YS5sZW5ndGh9LCAke3NlZ21lbnQucGFyZW50fWApO1xuICAgICAgICAgICAgICB0aGlzLnBhcmVudCA9IHNlZ21lbnQucGFyZW50O1xuICAgICAgICAgICAgICBzYi5hcHBlbmRCdWZmZXIoc2VnbWVudC5kYXRhKTtcbiAgICAgICAgICAgICAgdGhpcy5hcHBlbmRFcnJvciA9IDA7XG4gICAgICAgICAgICAgIHRoaXMuYXBwZW5kZWQrKztcbiAgICAgICAgICAgICAgdGhpcy5hcHBlbmRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc2VnbWVudHMudW5zaGlmdChzZWdtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gaW4gY2FzZSB3ZSBkb24ndCBoYXZlIGFueSBzb3VyY2UgYnVmZmVyIG1hdGNoaW5nIHdpdGggdGhpcyBzZWdtZW50IHR5cGUsXG4gICAgICAgICAgICAvLyBpdCBtZWFucyB0aGF0IE1lZGlhc291cmNlIGZhaWxzIHRvIGNyZWF0ZSBzb3VyY2VidWZmZXJcbiAgICAgICAgICAgIC8vIGRpc2NhcmQgdGhpcyBzZWdtZW50LCBhbmQgdHJpZ2dlciB1cGRhdGUgZW5kXG4gICAgICAgICAgICB0aGlzLm9uU0JVcGRhdGVFbmQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2goZXJyKSB7XG4gICAgICAgICAgLy8gaW4gY2FzZSBhbnkgZXJyb3Igb2NjdXJlZCB3aGlsZSBhcHBlbmRpbmcsIHB1dCBiYWNrIHNlZ21lbnQgaW4gc2VnbWVudHMgdGFibGVcbiAgICAgICAgICBsb2dnZXIuZXJyb3IoYGVycm9yIHdoaWxlIHRyeWluZyB0byBhcHBlbmQgYnVmZmVyOiR7ZXJyLm1lc3NhZ2V9YCk7XG4gICAgICAgICAgc2VnbWVudHMudW5zaGlmdChzZWdtZW50KTtcbiAgICAgICAgICB2YXIgZXZlbnQgPSB7dHlwZTogRXJyb3JUeXBlcy5NRURJQV9FUlJPUn07XG4gICAgICAgICAgaWYoZXJyLmNvZGUgIT09IDIyKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5hcHBlbmRFcnJvcikge1xuICAgICAgICAgICAgICB0aGlzLmFwcGVuZEVycm9yKys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLmFwcGVuZEVycm9yID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV2ZW50LmRldGFpbHMgPSBFcnJvckRldGFpbHMuQlVGRkVSX0FQUEVORF9FUlJPUjtcbiAgICAgICAgICAgIGV2ZW50LmZyYWcgPSB0aGlzLmZyYWdDdXJyZW50O1xuICAgICAgICAgICAgLyogd2l0aCBVSEQgY29udGVudCwgd2UgY291bGQgZ2V0IGxvb3Agb2YgcXVvdGEgZXhjZWVkZWQgZXJyb3IgdW50aWxcbiAgICAgICAgICAgICAgYnJvd3NlciBpcyBhYmxlIHRvIGV2aWN0IHNvbWUgZGF0YSBmcm9tIHNvdXJjZWJ1ZmZlci4gcmV0cnlpbmcgaGVscCByZWNvdmVyaW5nIHRoaXNcbiAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAodGhpcy5hcHBlbmRFcnJvciA+IGhscy5jb25maWcuYXBwZW5kRXJyb3JNYXhSZXRyeSkge1xuICAgICAgICAgICAgICBsb2dnZXIubG9nKGBmYWlsICR7aGxzLmNvbmZpZy5hcHBlbmRFcnJvck1heFJldHJ5fSB0aW1lcyB0byBhcHBlbmQgc2VnbWVudCBpbiBzb3VyY2VCdWZmZXJgKTtcbiAgICAgICAgICAgICAgc2VnbWVudHMgPSBbXTtcbiAgICAgICAgICAgICAgZXZlbnQuZmF0YWwgPSB0cnVlO1xuICAgICAgICAgICAgICBobHMudHJpZ2dlcihFdmVudC5FUlJPUiwgZXZlbnQpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBldmVudC5mYXRhbCA9IGZhbHNlO1xuICAgICAgICAgICAgICBobHMudHJpZ2dlcihFdmVudC5FUlJPUiwgZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBRdW90YUV4Y2VlZGVkRXJyb3I6IGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1L2luZnJhc3RydWN0dXJlLmh0bWwjcXVvdGFleGNlZWRlZGVycm9yXG4gICAgICAgICAgICAvLyBsZXQncyBzdG9wIGFwcGVuZGluZyBhbnkgc2VnbWVudHMsIGFuZCByZXBvcnQgQlVGRkVSX0ZVTExfRVJST1IgZXJyb3JcbiAgICAgICAgICAgIHRoaXMuc2VnbWVudHMgPSBbXTtcbiAgICAgICAgICAgIGV2ZW50LmRldGFpbHMgPSBFcnJvckRldGFpbHMuQlVGRkVSX0ZVTExfRVJST1I7XG4gICAgICAgICAgICBobHMudHJpZ2dlcihFdmVudC5FUlJPUixldmVudCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLypcbiAgICBmbHVzaCBzcGVjaWZpZWQgYnVmZmVyZWQgcmFuZ2UsXG4gICAgcmV0dXJuIHRydWUgb25jZSByYW5nZSBoYXMgYmVlbiBmbHVzaGVkLlxuICAgIGFzIHNvdXJjZUJ1ZmZlci5yZW1vdmUoKSBpcyBhc3luY2hyb25vdXMsIGZsdXNoQnVmZmVyIHdpbGwgYmUgcmV0cmlnZ2VyZWQgb24gc291cmNlQnVmZmVyIHVwZGF0ZSBlbmRcbiAgKi9cbiAgZmx1c2hCdWZmZXIoc3RhcnRPZmZzZXQsIGVuZE9mZnNldCwgdHlwZUluKSB7XG4gICAgdmFyIHNiLCBpLCBidWZTdGFydCwgYnVmRW5kLCBmbHVzaFN0YXJ0LCBmbHVzaEVuZCwgc291cmNlQnVmZmVyID0gdGhpcy5zb3VyY2VCdWZmZXI7XG4gICAgaWYgKE9iamVjdC5rZXlzKHNvdXJjZUJ1ZmZlcikubGVuZ3RoKSB7XG4gICAgICBsb2dnZXIubG9nKCdmbHVzaEJ1ZmZlcixwb3Mvc3RhcnQvZW5kOiAnICsgdGhpcy5tZWRpYS5jdXJyZW50VGltZSArICcvJyArIHN0YXJ0T2Zmc2V0ICsgJy8nICsgZW5kT2Zmc2V0KTtcbiAgICAgIC8vIHNhZmVndWFyZCB0byBhdm9pZCBpbmZpbml0ZSBsb29waW5nIDogZG9uJ3QgdHJ5IHRvIGZsdXNoIG1vcmUgdGhhbiB0aGUgbmIgb2YgYXBwZW5kZWQgc2VnbWVudHNcbiAgICAgIGlmICh0aGlzLmZsdXNoQnVmZmVyQ291bnRlciA8IHRoaXMuYXBwZW5kZWQpIHtcbiAgICAgICAgZm9yICh2YXIgdHlwZSBpbiBzb3VyY2VCdWZmZXIpIHtcbiAgICAgICAgICAvLyBjaGVjayBpZiBzb3VyY2VidWZmZXIgdHlwZSBpcyBkZWZpbmVkICh0eXBlSW4pOiBpZiB5ZXMsIGxldCdzIG9ubHkgZmx1c2ggdGhpcyBvbmVcbiAgICAgICAgICAvLyBpZiBubywgbGV0J3MgZmx1c2ggYWxsIHNvdXJjZWJ1ZmZlcnNcbiAgICAgICAgICBpZiAodHlwZUluICYmIHR5cGUgIT09IHR5cGVJbikge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNiID0gc291cmNlQnVmZmVyW3R5cGVdO1xuICAgICAgICAgIC8vIHdlIGFyZSBnb2luZyB0byBmbHVzaCBidWZmZXIsIG1hcmsgc291cmNlIGJ1ZmZlciBhcyAnbm90IGVuZGVkJ1xuICAgICAgICAgIHNiLmVuZGVkID0gZmFsc2U7XG4gICAgICAgICAgaWYgKCFzYi51cGRhdGluZykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHNiLmJ1ZmZlcmVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYnVmU3RhcnQgPSBzYi5idWZmZXJlZC5zdGFydChpKTtcbiAgICAgICAgICAgICAgICBidWZFbmQgPSBzYi5idWZmZXJlZC5lbmQoaSk7XG4gICAgICAgICAgICAgICAgLy8gd29ya2Fyb3VuZCBmaXJlZm94IG5vdCBhYmxlIHRvIHByb3Blcmx5IGZsdXNoIG11bHRpcGxlIGJ1ZmZlcmVkIHJhbmdlLlxuICAgICAgICAgICAgICAgIGlmIChuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkuaW5kZXhPZignZmlyZWZveCcpICE9PSAtMSAmJiBlbmRPZmZzZXQgPT09IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSkge1xuICAgICAgICAgICAgICAgICAgZmx1c2hTdGFydCA9IHN0YXJ0T2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgZmx1c2hFbmQgPSBlbmRPZmZzZXQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGZsdXNoU3RhcnQgPSBNYXRoLm1heChidWZTdGFydCwgc3RhcnRPZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgZmx1c2hFbmQgPSBNYXRoLm1pbihidWZFbmQsIGVuZE9mZnNldCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8qIHNvbWV0aW1lcyBzb3VyY2VidWZmZXIucmVtb3ZlKCkgZG9lcyBub3QgZmx1c2hcbiAgICAgICAgICAgICAgICAgICB0aGUgZXhhY3QgZXhwZWN0ZWQgdGltZSByYW5nZS5cbiAgICAgICAgICAgICAgICAgICB0byBhdm9pZCByb3VuZGluZyBpc3N1ZXMvaW5maW5pdGUgbG9vcCxcbiAgICAgICAgICAgICAgICAgICBvbmx5IGZsdXNoIGJ1ZmZlciByYW5nZSBvZiBsZW5ndGggZ3JlYXRlciB0aGFuIDUwMG1zLlxuICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgaWYgKE1hdGgubWluKGZsdXNoRW5kLGJ1ZkVuZCkgLSBmbHVzaFN0YXJ0ID4gMC41ICkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5mbHVzaEJ1ZmZlckNvdW50ZXIrKztcbiAgICAgICAgICAgICAgICAgIGxvZ2dlci5sb2coYGZsdXNoICR7dHlwZX0gWyR7Zmx1c2hTdGFydH0sJHtmbHVzaEVuZH1dLCBvZiBbJHtidWZTdGFydH0sJHtidWZFbmR9XSwgcG9zOiR7dGhpcy5tZWRpYS5jdXJyZW50VGltZX1gKTtcbiAgICAgICAgICAgICAgICAgIHNiLnJlbW92ZShmbHVzaFN0YXJ0LCBmbHVzaEVuZCk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgICAgICAgbG9nZ2VyLndhcm4oJ2V4Y2VwdGlvbiB3aGlsZSBhY2Nlc3Npbmcgc291cmNlYnVmZmVyLCBpdCBtaWdodCBoYXZlIGJlZW4gcmVtb3ZlZCBmcm9tIE1lZGlhU291cmNlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vbG9nZ2VyLmxvZygnYWJvcnQgJyArIHR5cGUgKyAnIGFwcGVuZCBpbiBwcm9ncmVzcycpO1xuICAgICAgICAgICAgLy8gdGhpcyB3aWxsIGFib3J0IGFueSBhcHBlbmRpbmcgaW4gcHJvZ3Jlc3NcbiAgICAgICAgICAgIC8vc2IuYWJvcnQoKTtcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKCdjYW5ub3QgZmx1c2gsIHNiIHVwZGF0aW5nIGluIHByb2dyZXNzJyk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsb2dnZXIud2FybignYWJvcnQgZmx1c2hpbmcgdG9vIG1hbnkgcmV0cmllcycpO1xuICAgICAgfVxuICAgICAgbG9nZ2VyLmxvZygnYnVmZmVyIGZsdXNoZWQnKTtcbiAgICB9XG4gICAgLy8gZXZlcnl0aGluZyBmbHVzaGVkICFcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBCdWZmZXJDb250cm9sbGVyO1xuIiwiLypcbiAqIGNhcCBzdHJlYW0gbGV2ZWwgdG8gbWVkaWEgc2l6ZSBkaW1lbnNpb24gY29udHJvbGxlclxuKi9cblxuaW1wb3J0IEV2ZW50IGZyb20gJy4uL2V2ZW50cyc7XG5pbXBvcnQgRXZlbnRIYW5kbGVyIGZyb20gJy4uL2V2ZW50LWhhbmRsZXInO1xuXG5jbGFzcyBDYXBMZXZlbENvbnRyb2xsZXIgZXh0ZW5kcyBFdmVudEhhbmRsZXIge1xuXHRjb25zdHJ1Y3RvcihobHMpIHtcbiAgICBzdXBlcihobHMsXG4gICAgICBFdmVudC5GUFNfRFJPUF9MRVZFTF9DQVBQSU5HLFxuICAgICAgRXZlbnQuTUVESUFfQVRUQUNISU5HLFxuICAgICAgRXZlbnQuTUFOSUZFU1RfUEFSU0VEKTtcblx0fVxuXG5cdGRlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMuaGxzLmNvbmZpZy5jYXBMZXZlbFRvUGxheWVyU2l6ZSkge1xuICAgICAgdGhpcy5tZWRpYSA9IHRoaXMucmVzdHJpY3RlZExldmVscyA9IG51bGw7XG4gICAgICB0aGlzLmF1dG9MZXZlbENhcHBpbmcgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgICBpZiAodGhpcy50aW1lcikge1xuICAgICAgICB0aGlzLnRpbWVyID0gY2xlYXJJbnRlcnZhbCh0aGlzLnRpbWVyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBvbkZwc0Ryb3BMZXZlbENhcHBpbmcoZGF0YSkge1xuICAgIGlmICghdGhpcy5yZXN0cmljdGVkTGV2ZWxzKSB7XG4gICAgICB0aGlzLnJlc3RyaWN0ZWRMZXZlbHMgPSBbXTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmlzTGV2ZWxSZXN0cmljdGVkKGRhdGEuZHJvcHBlZExldmVsKSkge1xuICAgICAgdGhpcy5yZXN0cmljdGVkTGV2ZWxzLnB1c2goZGF0YS5kcm9wcGVkTGV2ZWwpO1xuICAgIH1cbiAgfVxuXG5cdG9uTWVkaWFBdHRhY2hpbmcoZGF0YSkge1xuICAgIHRoaXMubWVkaWEgPSBkYXRhLm1lZGlhIGluc3RhbmNlb2YgSFRNTFZpZGVvRWxlbWVudCA/IGRhdGEubWVkaWEgOiBudWxsO1xuICB9XG5cbiAgb25NYW5pZmVzdFBhcnNlZChkYXRhKSB7XG4gICAgaWYgKHRoaXMuaGxzLmNvbmZpZy5jYXBMZXZlbFRvUGxheWVyU2l6ZSkge1xuICAgICAgdGhpcy5hdXRvTGV2ZWxDYXBwaW5nID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgICAgdGhpcy5sZXZlbHMgPSBkYXRhLmxldmVscztcbiAgICAgIHRoaXMuaGxzLmZpcnN0TGV2ZWwgPSB0aGlzLmdldE1heExldmVsKGRhdGEuZmlyc3RMZXZlbCk7XG4gICAgICBjbGVhckludGVydmFsKHRoaXMudGltZXIpO1xuICAgICAgdGhpcy50aW1lciA9IHNldEludGVydmFsKHRoaXMuZGV0ZWN0UGxheWVyU2l6ZS5iaW5kKHRoaXMpLCAxMDAwKTtcbiAgICAgIHRoaXMuZGV0ZWN0UGxheWVyU2l6ZSgpO1xuICAgIH1cbiAgfVxuXG4gIGRldGVjdFBsYXllclNpemUoKSB7XG4gICAgaWYgKHRoaXMubWVkaWEpIHtcbiAgICAgIGxldCBsZXZlbHNMZW5ndGggPSB0aGlzLmxldmVscyA/IHRoaXMubGV2ZWxzLmxlbmd0aCA6IDA7XG4gICAgICBpZiAobGV2ZWxzTGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuaGxzLmF1dG9MZXZlbENhcHBpbmcgPSB0aGlzLmdldE1heExldmVsKGxldmVsc0xlbmd0aCAtIDEpO1xuICAgICAgICBpZiAodGhpcy5obHMuYXV0b0xldmVsQ2FwcGluZyA+IHRoaXMuYXV0b0xldmVsQ2FwcGluZykge1xuICAgICAgICAgIC8vIGlmIGF1dG8gbGV2ZWwgY2FwcGluZyBoYXMgYSBoaWdoZXIgdmFsdWUgZm9yIHRoZSBwcmV2aW91cyBvbmUsIGZsdXNoIHRoZSBidWZmZXIgdXNpbmcgbmV4dExldmVsU3dpdGNoXG4gICAgICAgICAgLy8gdXN1YWxseSBoYXBwZW4gd2hlbiB0aGUgdXNlciBnbyB0byB0aGUgZnVsbHNjcmVlbiBtb2RlLlxuICAgICAgICAgIHRoaXMuaGxzLnN0cmVhbUNvbnRyb2xsZXIubmV4dExldmVsU3dpdGNoKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hdXRvTGV2ZWxDYXBwaW5nID0gdGhpcy5obHMuYXV0b0xldmVsQ2FwcGluZztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKlxuICAqIHJldHVybnMgbGV2ZWwgc2hvdWxkIGJlIHRoZSBvbmUgd2l0aCB0aGUgZGltZW5zaW9ucyBlcXVhbCBvciBncmVhdGVyIHRoYW4gdGhlIG1lZGlhIChwbGF5ZXIpIGRpbWVuc2lvbnMgKHNvIHRoZSB2aWRlbyB3aWxsIGJlIGRvd25zY2FsZWQpXG4gICovXG4gIGdldE1heExldmVsKGNhcExldmVsSW5kZXgpIHtcbiAgICBsZXQgcmVzdWx0ID0gMCxcbiAgICAgICAgaSxcbiAgICAgICAgbGV2ZWwsXG4gICAgICAgIG1XaWR0aCA9IHRoaXMubWVkaWFXaWR0aCxcbiAgICAgICAgbUhlaWdodCA9IHRoaXMubWVkaWFIZWlnaHQsXG4gICAgICAgIGxXaWR0aCA9IDAsXG4gICAgICAgIGxIZWlnaHQgPSAwO1xuXG4gICAgZm9yIChpID0gMDsgaSA8PSBjYXBMZXZlbEluZGV4OyBpKyspIHtcbiAgICAgIGxldmVsID0gdGhpcy5sZXZlbHNbaV07XG4gICAgICBpZiAodGhpcy5pc0xldmVsUmVzdHJpY3RlZChpKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHJlc3VsdCA9IGk7XG4gICAgICBsV2lkdGggPSBsZXZlbC53aWR0aDtcbiAgICAgIGxIZWlnaHQgPSBsZXZlbC5oZWlnaHQ7XG4gICAgICBpZiAobVdpZHRoIDw9IGxXaWR0aCB8fCBtSGVpZ2h0IDw9IGxIZWlnaHQpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBpc0xldmVsUmVzdHJpY3RlZChsZXZlbCkge1xuICAgIHJldHVybiAodGhpcy5yZXN0cmljdGVkTGV2ZWxzICYmIHRoaXMucmVzdHJpY3RlZExldmVscy5pbmRleE9mKGxldmVsKSAhPT0gLTEpID8gdHJ1ZSA6IGZhbHNlO1xuICB9XG5cbiAgZ2V0IGNvbnRlbnRTY2FsZUZhY3RvcigpIHtcbiAgICBsZXQgcGl4ZWxSYXRpbyA9IDE7XG4gICAgdHJ5IHtcbiAgICAgIHBpeGVsUmF0aW8gPSAgd2luZG93LmRldmljZVBpeGVsUmF0aW87XG4gICAgfSBjYXRjaChlKSB7fVxuICAgIHJldHVybiBwaXhlbFJhdGlvO1xuICB9XG5cbiAgZ2V0IG1lZGlhV2lkdGgoKSB7XG4gICAgbGV0IHdpZHRoO1xuICAgIGlmICh0aGlzLm1lZGlhKSB7XG4gICAgICB3aWR0aCA9IHRoaXMubWVkaWEud2lkdGggfHwgdGhpcy5tZWRpYS5jbGllbnRXaWR0aCB8fCB0aGlzLm1lZGlhLm9mZnNldFdpZHRoO1xuICAgICAgd2lkdGggKj0gdGhpcy5jb250ZW50U2NhbGVGYWN0b3I7XG4gICAgfVxuICAgIHJldHVybiB3aWR0aDtcbiAgfVxuXG4gIGdldCBtZWRpYUhlaWdodCgpIHtcbiAgICBsZXQgaGVpZ2h0O1xuICAgIGlmICh0aGlzLm1lZGlhKSB7XG4gICAgICBoZWlnaHQgPSB0aGlzLm1lZGlhLmhlaWdodCB8fCB0aGlzLm1lZGlhLmNsaWVudEhlaWdodCB8fCB0aGlzLm1lZGlhLm9mZnNldEhlaWdodDtcbiAgICAgIGhlaWdodCAqPSB0aGlzLmNvbnRlbnRTY2FsZUZhY3RvcjtcbiAgICB9XG4gICAgcmV0dXJuIGhlaWdodDtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDYXBMZXZlbENvbnRyb2xsZXI7XG4iLCIvKlxuICogRVdNQSBCYW5kd2lkdGggRXN0aW1hdG9yXG4gKiAgLSBoZWF2aWx5IGluc3BpcmVkIGZyb20gc2hha2EtcGxheWVyXG4gKiBUcmFja3MgYmFuZHdpZHRoIHNhbXBsZXMgYW5kIGVzdGltYXRlcyBhdmFpbGFibGUgYmFuZHdpZHRoLlxuICogQmFzZWQgb24gdGhlIG1pbmltdW0gb2YgdHdvIGV4cG9uZW50aWFsbHktd2VpZ2h0ZWQgbW92aW5nIGF2ZXJhZ2VzIHdpdGhcbiAqIGRpZmZlcmVudCBoYWxmLWxpdmVzLlxuICovXG5cbmltcG9ydCBFV01BIGZyb20gJy4uL3V0aWxzL2V3bWEnO1xuXG5cbmNsYXNzIEV3bWFCYW5kV2lkdGhFc3RpbWF0b3Ige1xuXG4gIGNvbnN0cnVjdG9yKGhscyxzbG93LGZhc3QsZGVmYXVsdEVzdGltYXRlKSB7XG4gICAgdGhpcy5obHMgPSBobHM7XG4gICAgdGhpcy5kZWZhdWx0RXN0aW1hdGVfID0gZGVmYXVsdEVzdGltYXRlO1xuICAgIHRoaXMubWluV2VpZ2h0XyA9IDAuMDAxO1xuICAgIHRoaXMubWluRGVsYXlNc18gPSA1MDtcbiAgICB0aGlzLnNsb3dfID0gbmV3IEVXTUEoc2xvdyk7XG4gICAgdGhpcy5mYXN0XyA9IG5ldyBFV01BKGZhc3QpO1xuICB9XG5cbiAgc2FtcGxlKGR1cmF0aW9uTXMsbnVtQnl0ZXMpIHtcbiAgICBkdXJhdGlvbk1zID0gTWF0aC5tYXgoZHVyYXRpb25NcywgdGhpcy5taW5EZWxheU1zXyk7XG4gICAgdmFyIGJhbmR3aWR0aCA9IDgwMDAqIG51bUJ5dGVzIC8gZHVyYXRpb25NcyxcbiAgICAvL2NvbnNvbGUubG9nKCdpbnN0YW50IGJ3OicrIE1hdGgucm91bmQoYmFuZHdpZHRoKSk7XG4gICAgLy8gd2Ugd2VpZ2h0IHNhbXBsZSB1c2luZyBsb2FkaW5nIGR1cmF0aW9uLi4uLlxuICAgICAgICB3ZWlnaHQgPSBkdXJhdGlvbk1zIC8gMTAwMDtcbiAgICB0aGlzLmZhc3RfLnNhbXBsZSh3ZWlnaHQsYmFuZHdpZHRoKTtcbiAgICB0aGlzLnNsb3dfLnNhbXBsZSh3ZWlnaHQsYmFuZHdpZHRoKTtcbiAgfVxuXG4gIGNhbkVzdGltYXRlKCkge1xuICAgIGxldCBmYXN0ID0gdGhpcy5mYXN0XztcbiAgICByZXR1cm4gKGZhc3QgJiYgZmFzdC5nZXRUb3RhbFdlaWdodCgpID49IHRoaXMubWluV2VpZ2h0Xyk7XG4gIH1cblxuXG4gIGdldEVzdGltYXRlKCkge1xuICAgIGlmICh0aGlzLmNhbkVzdGltYXRlKCkpIHtcbiAgICAgIC8vY29uc29sZS5sb2coJ3Nsb3cgZXN0aW1hdGU6JysgTWF0aC5yb3VuZCh0aGlzLnNsb3dfLmdldEVzdGltYXRlKCkpKTtcbiAgICAgIC8vY29uc29sZS5sb2coJ2Zhc3QgZXN0aW1hdGU6JysgTWF0aC5yb3VuZCh0aGlzLmZhc3RfLmdldEVzdGltYXRlKCkpKTtcbiAgICAgIC8vIFRha2UgdGhlIG1pbmltdW0gb2YgdGhlc2UgdHdvIGVzdGltYXRlcy4gIFRoaXMgc2hvdWxkIGhhdmUgdGhlIGVmZmVjdCBvZlxuICAgICAgLy8gYWRhcHRpbmcgZG93biBxdWlja2x5LCBidXQgdXAgbW9yZSBzbG93bHkuXG4gICAgICByZXR1cm4gTWF0aC5taW4odGhpcy5mYXN0Xy5nZXRFc3RpbWF0ZSgpLHRoaXMuc2xvd18uZ2V0RXN0aW1hdGUoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmRlZmF1bHRFc3RpbWF0ZV87XG4gICAgfVxuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgfVxufVxuZXhwb3J0IGRlZmF1bHQgRXdtYUJhbmRXaWR0aEVzdGltYXRvcjtcblxuIiwiLypcbiAqIEZQUyBDb250cm9sbGVyXG4qL1xuXG5pbXBvcnQgRXZlbnQgZnJvbSAnLi4vZXZlbnRzJztcbmltcG9ydCBFdmVudEhhbmRsZXIgZnJvbSAnLi4vZXZlbnQtaGFuZGxlcic7XG5pbXBvcnQge2xvZ2dlcn0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcblxuY2xhc3MgRlBTQ29udHJvbGxlciBleHRlbmRzIEV2ZW50SGFuZGxlcntcblxuICBjb25zdHJ1Y3RvcihobHMpIHtcbiAgICBzdXBlcihobHMsIEV2ZW50Lk1FRElBX0FUVEFDSElORyk7XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIGlmICh0aGlzLnRpbWVyKSB7XG4gICAgICBjbGVhckludGVydmFsKHRoaXMudGltZXIpO1xuICAgIH1cbiAgICB0aGlzLmlzVmlkZW9QbGF5YmFja1F1YWxpdHlBdmFpbGFibGUgPSBmYWxzZTtcbiAgfVxuICBcbiAgb25NZWRpYUF0dGFjaGluZyhkYXRhKSB7XG4gICAgaWYgKHRoaXMuaGxzLmNvbmZpZy5jYXBMZXZlbE9uRlBTRHJvcCkge1xuICAgICAgdGhpcy52aWRlbyA9IGRhdGEubWVkaWEgaW5zdGFuY2VvZiBIVE1MVmlkZW9FbGVtZW50ID8gZGF0YS5tZWRpYSA6IG51bGw7XG4gICAgICBpZiAodHlwZW9mIHRoaXMudmlkZW8uZ2V0VmlkZW9QbGF5YmFja1F1YWxpdHkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5pc1ZpZGVvUGxheWJhY2tRdWFsaXR5QXZhaWxhYmxlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy50aW1lcik7XG4gICAgICB0aGlzLnRpbWVyID0gc2V0SW50ZXJ2YWwodGhpcy5jaGVja0ZQU0ludGVydmFsLmJpbmQodGhpcyksIHRoaXMuaGxzLmNvbmZpZy5mcHNEcm9wcGVkTW9uaXRvcmluZ1BlcmlvZCk7XG4gICAgfSBcbiAgfVxuICBcbiAgY2hlY2tGUFModmlkZW8sIGRlY29kZWRGcmFtZXMsIGRyb3BwZWRGcmFtZXMpIHtcbiAgICBsZXQgY3VycmVudFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICBpZiAoZGVjb2RlZEZyYW1lcykge1xuICAgICAgaWYgKHRoaXMubGFzdFRpbWUpIHtcbiAgICAgICAgbGV0IGN1cnJlbnRQZXJpb2QgPSBjdXJyZW50VGltZSAtIHRoaXMubGFzdFRpbWUsXG4gICAgICAgICAgICBjdXJyZW50RHJvcHBlZCA9IGRyb3BwZWRGcmFtZXMgLSB0aGlzLmxhc3REcm9wcGVkRnJhbWVzLFxuICAgICAgICAgICAgY3VycmVudERlY29kZWQgPSBkZWNvZGVkRnJhbWVzIC0gdGhpcy5sYXN0RGVjb2RlZEZyYW1lcyxcbiAgICAgICAgICAgIGRyb3BwZWRGUFMgPSAxMDAwICogY3VycmVudERyb3BwZWQgLyBjdXJyZW50UGVyaW9kO1xuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkZQU19EUk9QLCB7Y3VycmVudERyb3BwZWQ6IGN1cnJlbnREcm9wcGVkLCBjdXJyZW50RGVjb2RlZDogY3VycmVudERlY29kZWQsIHRvdGFsRHJvcHBlZEZyYW1lczogZHJvcHBlZEZyYW1lc30pO1xuICAgICAgICBpZiAoZHJvcHBlZEZQUyA+IDApIHtcbiAgICAgICAgICAvL2xvZ2dlci5sb2coJ2NoZWNrRlBTIDogZHJvcHBlZEZQUy9kZWNvZGVkRlBTOicgKyBkcm9wcGVkRlBTLygxMDAwICogY3VycmVudERlY29kZWQgLyBjdXJyZW50UGVyaW9kKSk7XG4gICAgICAgICAgaWYgKGN1cnJlbnREcm9wcGVkID4gdGhpcy5obHMuY29uZmlnLmZwc0Ryb3BwZWRNb25pdG9yaW5nVGhyZXNob2xkICogY3VycmVudERlY29kZWQpIHtcbiAgICAgICAgICAgIGxldCBjdXJyZW50TGV2ZWwgPSB0aGlzLmhscy5jdXJyZW50TGV2ZWw7XG4gICAgICAgICAgICBsb2dnZXIud2FybignZHJvcCBGUFMgcmF0aW8gZ3JlYXRlciB0aGFuIG1heCBhbGxvd2VkIHZhbHVlIGZvciBjdXJyZW50TGV2ZWw6ICcgKyBjdXJyZW50TGV2ZWwpO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRMZXZlbCA+IDAgJiYgKHRoaXMuaGxzLmF1dG9MZXZlbENhcHBpbmcgPT09IC0xIHx8IHRoaXMuaGxzLmF1dG9MZXZlbENhcHBpbmcgPj0gY3VycmVudExldmVsKSkge1xuICAgICAgICAgICAgICBjdXJyZW50TGV2ZWwgPSBjdXJyZW50TGV2ZWwgLSAxO1xuICAgICAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkZQU19EUk9QX0xFVkVMX0NBUFBJTkcsIHtsZXZlbDogY3VycmVudExldmVsLCBkcm9wcGVkTGV2ZWw6IHRoaXMuaGxzLmN1cnJlbnRMZXZlbH0pO1xuICAgICAgICAgICAgICB0aGlzLmhscy5hdXRvTGV2ZWxDYXBwaW5nID0gY3VycmVudExldmVsO1xuICAgICAgICAgICAgICB0aGlzLmhscy5zdHJlYW1Db250cm9sbGVyLm5leHRMZXZlbFN3aXRjaCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5sYXN0VGltZSA9IGN1cnJlbnRUaW1lO1xuICAgICAgdGhpcy5sYXN0RHJvcHBlZEZyYW1lcyA9IGRyb3BwZWRGcmFtZXM7XG4gICAgICB0aGlzLmxhc3REZWNvZGVkRnJhbWVzID0gZGVjb2RlZEZyYW1lcztcbiAgICB9XG4gIH1cbiAgXG4gIGNoZWNrRlBTSW50ZXJ2YWwoKSB7XG4gICAgaWYgKHRoaXMudmlkZW8pIHtcbiAgICAgIGlmICh0aGlzLmlzVmlkZW9QbGF5YmFja1F1YWxpdHlBdmFpbGFibGUpIHtcbiAgICAgICAgbGV0IHZpZGVvUGxheWJhY2tRdWFsaXR5ID0gdGhpcy52aWRlby5nZXRWaWRlb1BsYXliYWNrUXVhbGl0eSgpO1xuICAgICAgICB0aGlzLmNoZWNrRlBTKHRoaXMudmlkZW8sIHZpZGVvUGxheWJhY2tRdWFsaXR5LnRvdGFsVmlkZW9GcmFtZXMsIHZpZGVvUGxheWJhY2tRdWFsaXR5LmRyb3BwZWRWaWRlb0ZyYW1lcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNoZWNrRlBTKHRoaXMudmlkZW8sIHRoaXMudmlkZW8ud2Via2l0RGVjb2RlZEZyYW1lQ291bnQsIHRoaXMudmlkZW8ud2Via2l0RHJvcHBlZEZyYW1lQ291bnQpOyAgXG4gICAgICB9XG4gICAgfVxuICB9IFxufVxuXG5leHBvcnQgZGVmYXVsdCBGUFNDb250cm9sbGVyO1xuXG4iLCIvKlxuICogTGV2ZWwgQ29udHJvbGxlclxuKi9cblxuaW1wb3J0IEV2ZW50IGZyb20gJy4uL2V2ZW50cyc7XG5pbXBvcnQgRXZlbnRIYW5kbGVyIGZyb20gJy4uL2V2ZW50LWhhbmRsZXInO1xuaW1wb3J0IHtsb2dnZXJ9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XG5pbXBvcnQge0Vycm9yVHlwZXMsIEVycm9yRGV0YWlsc30gZnJvbSAnLi4vZXJyb3JzJztcbmltcG9ydCBCdWZmZXJIZWxwZXIgZnJvbSAnLi4vaGVscGVyL2J1ZmZlci1oZWxwZXInO1xuXG5jbGFzcyBMZXZlbENvbnRyb2xsZXIgZXh0ZW5kcyBFdmVudEhhbmRsZXIge1xuXG4gIGNvbnN0cnVjdG9yKGhscykge1xuICAgIHN1cGVyKGhscyxcbiAgICAgIEV2ZW50Lk1BTklGRVNUX0xPQURFRCxcbiAgICAgIEV2ZW50LkxFVkVMX0xPQURFRCxcbiAgICAgIEV2ZW50LkZSQUdfTE9BREVELFxuICAgICAgRXZlbnQuRVJST1IpO1xuICAgIHRoaXMub250aWNrID0gdGhpcy50aWNrLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fbWFudWFsTGV2ZWwgPSB0aGlzLl9hdXRvTGV2ZWxDYXBwaW5nID0gLTE7XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIGlmICh0aGlzLnRpbWVyKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lcik7XG4gICAgICB0aGlzLnRpbWVyID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5fbWFudWFsTGV2ZWwgPSAtMTtcbiAgfVxuXG4gIHN0YXJ0TG9hZCgpIHtcbiAgICB0aGlzLmNhbmxvYWQgPSB0cnVlO1xuICAgIGxldCBsZXZlbHMgPSB0aGlzLl9sZXZlbHM7XG4gICAgLy8gY2xlYW4gdXAgbGl2ZSBsZXZlbCBkZXRhaWxzIHRvIGZvcmNlIHJlbG9hZCB0aGVtLCBhbmQgcmVzZXQgbG9hZCBlcnJvcnNcbiAgICBpZihsZXZlbHMpIHtcbiAgICAgIGxldmVscy5mb3JFYWNoKGxldmVsID0+IHtcbiAgICAgICAgbGV2ZWwubG9hZEVycm9yID0gMDtcbiAgICAgICAgY29uc3QgbGV2ZWxEZXRhaWxzID0gbGV2ZWwuZGV0YWlscztcbiAgICAgICAgaWYgKGxldmVsRGV0YWlscyAmJiBsZXZlbERldGFpbHMubGl2ZSkge1xuICAgICAgICAgIGxldmVsLmRldGFpbHMgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBzcGVlZCB1cCBsaXZlIHBsYXlsaXN0IHJlZnJlc2ggaWYgdGltZXIgZXhpc3RzXG4gICAgaWYgKHRoaXMudGltZXIpIHtcbiAgICAgIHRoaXMudGljaygpO1xuICAgIH1cbiAgfVxuXG4gIHN0b3BMb2FkKCkge1xuICAgIHRoaXMuY2FubG9hZCA9IGZhbHNlO1xuICB9XG5cbiAgb25NYW5pZmVzdExvYWRlZChkYXRhKSB7XG4gICAgdmFyIGxldmVsczAgPSBbXSxcbiAgICAgICAgbGV2ZWxzID0gW10sXG4gICAgICAgIGJpdHJhdGVTdGFydCxcbiAgICAgICAgYml0cmF0ZVNldCA9IHt9LFxuICAgICAgICB2aWRlb0NvZGVjRm91bmQgPSBmYWxzZSxcbiAgICAgICAgYXVkaW9Db2RlY0ZvdW5kID0gZmFsc2UsXG4gICAgICAgIGhscyA9IHRoaXMuaGxzLFxuICAgICAgICBicm9rZW5tcDRpbm1wMyA9IC9jaHJvbWV8ZmlyZWZveC8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkpLFxuICAgICAgICBjaGVja1N1cHBvcnRlZCA9IGZ1bmN0aW9uKHR5cGUsY29kZWMpIHsgcmV0dXJuIE1lZGlhU291cmNlLmlzVHlwZVN1cHBvcnRlZChgJHt0eXBlfS9tcDQ7Y29kZWNzPSR7Y29kZWN9YCk7fTtcblxuICAgIC8vIHJlZ3JvdXAgcmVkdW5kYW50IGxldmVsIHRvZ2V0aGVyXG4gICAgZGF0YS5sZXZlbHMuZm9yRWFjaChsZXZlbCA9PiB7XG4gICAgICBpZihsZXZlbC52aWRlb0NvZGVjKSB7XG4gICAgICAgIHZpZGVvQ29kZWNGb3VuZCA9IHRydWU7XG4gICAgICB9XG4gICAgICAvLyBlcmFzZSBhdWRpbyBjb2RlYyBpbmZvIGlmIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBtcDRhLjQwLjM0LiBkZW11eGVyIHdpbGwgYXV0b2RldGVjdCBjb2RlYyBhbmQgZmFsbGJhY2sgdG8gbXBlZy9hdWRpb1xuICAgICAgaWYoYnJva2VubXA0aW5tcDMgJiYgbGV2ZWwuYXVkaW9Db2RlYyAmJiBsZXZlbC5hdWRpb0NvZGVjLmluZGV4T2YoJ21wNGEuNDAuMzQnKSAhPT0gLTEpIHtcbiAgICAgICAgbGV2ZWwuYXVkaW9Db2RlYyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGlmKGxldmVsLmF1ZGlvQ29kZWMgfHwgKGxldmVsLmF0dHJzICYmIGxldmVsLmF0dHJzLkFVRElPKSkge1xuICAgICAgICBhdWRpb0NvZGVjRm91bmQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgbGV0IHJlZHVuZGFudExldmVsSWQgPSBiaXRyYXRlU2V0W2xldmVsLmJpdHJhdGVdO1xuICAgICAgaWYgKHJlZHVuZGFudExldmVsSWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBiaXRyYXRlU2V0W2xldmVsLmJpdHJhdGVdID0gbGV2ZWxzMC5sZW5ndGg7XG4gICAgICAgIGxldmVsLnVybCA9IFtsZXZlbC51cmxdO1xuICAgICAgICBsZXZlbC51cmxJZCA9IDA7XG4gICAgICAgIGxldmVsczAucHVzaChsZXZlbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXZlbHMwW3JlZHVuZGFudExldmVsSWRdLnVybC5wdXNoKGxldmVsLnVybCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyByZW1vdmUgYXVkaW8tb25seSBsZXZlbCBpZiB3ZSBhbHNvIGhhdmUgbGV2ZWxzIHdpdGggYXVkaW8rdmlkZW8gY29kZWNzIHNpZ25hbGxlZFxuICAgIGlmKHZpZGVvQ29kZWNGb3VuZCAmJiBhdWRpb0NvZGVjRm91bmQpIHtcbiAgICAgIGxldmVsczAuZm9yRWFjaChsZXZlbCA9PiB7XG4gICAgICAgIGlmKGxldmVsLnZpZGVvQ29kZWMpIHtcbiAgICAgICAgICBsZXZlbHMucHVzaChsZXZlbCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXZlbHMgPSBsZXZlbHMwO1xuICAgIH1cbiAgICAvLyBvbmx5IGtlZXAgbGV2ZWwgd2l0aCBzdXBwb3J0ZWQgYXVkaW8vdmlkZW8gY29kZWNzXG4gICAgbGV2ZWxzID0gbGV2ZWxzLmZpbHRlcihmdW5jdGlvbihsZXZlbCkge1xuICAgIGxldCBhdWRpb0NvZGVjID0gbGV2ZWwuYXVkaW9Db2RlYywgdmlkZW9Db2RlYyA9IGxldmVsLnZpZGVvQ29kZWM7XG4gICAgICByZXR1cm4gKCFhdWRpb0NvZGVjIHx8IGNoZWNrU3VwcG9ydGVkKCdhdWRpbycsYXVkaW9Db2RlYykpICYmXG4gICAgICAgICAgICAgKCF2aWRlb0NvZGVjIHx8IGNoZWNrU3VwcG9ydGVkKCd2aWRlbycsdmlkZW9Db2RlYykpO1xuICAgIH0pO1xuXG4gICAgaWYobGV2ZWxzLmxlbmd0aCkge1xuICAgICAgLy8gc3RhcnQgYml0cmF0ZSBpcyB0aGUgZmlyc3QgYml0cmF0ZSBvZiB0aGUgbWFuaWZlc3RcbiAgICAgIGJpdHJhdGVTdGFydCA9IGxldmVsc1swXS5iaXRyYXRlO1xuICAgICAgLy8gc29ydCBsZXZlbCBvbiBiaXRyYXRlXG4gICAgICBsZXZlbHMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gYS5iaXRyYXRlIC0gYi5iaXRyYXRlO1xuICAgICAgfSk7XG4gICAgICB0aGlzLl9sZXZlbHMgPSBsZXZlbHM7XG4gICAgICAvLyBmaW5kIGluZGV4IG9mIGZpcnN0IGxldmVsIGluIHNvcnRlZCBsZXZlbHNcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGV2ZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChsZXZlbHNbaV0uYml0cmF0ZSA9PT0gYml0cmF0ZVN0YXJ0KSB7XG4gICAgICAgICAgdGhpcy5fZmlyc3RMZXZlbCA9IGk7XG4gICAgICAgICAgbG9nZ2VyLmxvZyhgbWFuaWZlc3QgbG9hZGVkLCR7bGV2ZWxzLmxlbmd0aH0gbGV2ZWwocykgZm91bmQsIGZpcnN0IGJpdHJhdGU6JHtiaXRyYXRlU3RhcnR9YCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGhscy50cmlnZ2VyKEV2ZW50Lk1BTklGRVNUX1BBUlNFRCwge2xldmVsczogbGV2ZWxzLCBmaXJzdExldmVsOiB0aGlzLl9maXJzdExldmVsLCBzdGF0czogZGF0YS5zdGF0cywgYXVkaW8gOiBhdWRpb0NvZGVjRm91bmQsIHZpZGVvIDogdmlkZW9Db2RlY0ZvdW5kLCBhbHRBdWRpbyA6IGRhdGEuYXVkaW9UcmFja3MubGVuZ3RoID4gMH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBobHMudHJpZ2dlcihFdmVudC5FUlJPUiwge3R5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsIGRldGFpbHM6IEVycm9yRGV0YWlscy5NQU5JRkVTVF9JTkNPTVBBVElCTEVfQ09ERUNTX0VSUk9SLCBmYXRhbDogdHJ1ZSwgdXJsOiBobHMudXJsLCByZWFzb246ICdubyBsZXZlbCB3aXRoIGNvbXBhdGlibGUgY29kZWNzIGZvdW5kIGluIG1hbmlmZXN0J30pO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cblxuICBnZXQgbGV2ZWxzKCkge1xuICAgIHJldHVybiB0aGlzLl9sZXZlbHM7XG4gIH1cblxuICBnZXQgbGV2ZWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xldmVsO1xuICB9XG5cbiAgc2V0IGxldmVsKG5ld0xldmVsKSB7XG4gICAgbGV0IGxldmVscyA9IHRoaXMuX2xldmVscztcbiAgICBpZiAobGV2ZWxzICYmIGxldmVscy5sZW5ndGggPiBuZXdMZXZlbCkge1xuICAgICAgaWYgKHRoaXMuX2xldmVsICE9PSBuZXdMZXZlbCB8fCBsZXZlbHNbbmV3TGV2ZWxdLmRldGFpbHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLnNldExldmVsSW50ZXJuYWwobmV3TGV2ZWwpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gc2V0TGV2ZWxJbnRlcm5hbChuZXdMZXZlbCkge1xuICAgIGxldCBsZXZlbHMgPSB0aGlzLl9sZXZlbHM7XG4gICAgLy8gY2hlY2sgaWYgbGV2ZWwgaWR4IGlzIHZhbGlkXG4gICAgaWYgKG5ld0xldmVsID49IDAgJiYgbmV3TGV2ZWwgPCBsZXZlbHMubGVuZ3RoKSB7XG4gICAgICAvLyBzdG9wcGluZyBsaXZlIHJlbG9hZGluZyB0aW1lciBpZiBhbnlcbiAgICAgIGlmICh0aGlzLnRpbWVyKSB7XG4gICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZXIpO1xuICAgICAgIHRoaXMudGltZXIgPSBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX2xldmVsICE9PSBuZXdMZXZlbCkge1xuICAgICAgICBsb2dnZXIubG9nKGBzd2l0Y2hpbmcgdG8gbGV2ZWwgJHtuZXdMZXZlbH1gKTtcbiAgICAgICAgdGhpcy5fbGV2ZWwgPSBuZXdMZXZlbDtcbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5MRVZFTF9TV0lUQ0gsIHtsZXZlbDogbmV3TGV2ZWx9KTtcbiAgICAgIH1cbiAgICAgIHZhciBsZXZlbCA9IGxldmVsc1tuZXdMZXZlbF0sIGxldmVsRGV0YWlscyA9IGxldmVsLmRldGFpbHM7XG4gICAgICAgLy8gY2hlY2sgaWYgd2UgbmVlZCB0byBsb2FkIHBsYXlsaXN0IGZvciB0aGlzIGxldmVsXG4gICAgICBpZiAoIWxldmVsRGV0YWlscyB8fCBsZXZlbERldGFpbHMubGl2ZSA9PT0gdHJ1ZSkge1xuICAgICAgICAvLyBsZXZlbCBub3QgcmV0cmlldmVkIHlldCwgb3IgbGl2ZSBwbGF5bGlzdCB3ZSBuZWVkIHRvIChyZSlsb2FkIGl0XG4gICAgICAgIHZhciB1cmxJZCA9IGxldmVsLnVybElkO1xuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkxFVkVMX0xPQURJTkcsIHt1cmw6IGxldmVsLnVybFt1cmxJZF0sIGxldmVsOiBuZXdMZXZlbCwgaWQ6IHVybElkfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGludmFsaWQgbGV2ZWwgaWQgZ2l2ZW4sIHRyaWdnZXIgZXJyb3JcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuRVJST1IsIHt0eXBlIDogRXJyb3JUeXBlcy5PVEhFUl9FUlJPUiwgZGV0YWlsczogRXJyb3JEZXRhaWxzLkxFVkVMX1NXSVRDSF9FUlJPUiwgbGV2ZWw6IG5ld0xldmVsLCBmYXRhbDogZmFsc2UsIHJlYXNvbjogJ2ludmFsaWQgbGV2ZWwgaWR4J30pO1xuICAgIH1cbiB9XG5cbiAgZ2V0IG1hbnVhbExldmVsKCkge1xuICAgIHJldHVybiB0aGlzLl9tYW51YWxMZXZlbDtcbiAgfVxuXG4gIHNldCBtYW51YWxMZXZlbChuZXdMZXZlbCkge1xuICAgIHRoaXMuX21hbnVhbExldmVsID0gbmV3TGV2ZWw7XG4gICAgaWYgKHRoaXMuX3N0YXJ0TGV2ZWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5fc3RhcnRMZXZlbCA9IG5ld0xldmVsO1xuICAgIH1cbiAgICBpZiAobmV3TGV2ZWwgIT09IC0xKSB7XG4gICAgICB0aGlzLmxldmVsID0gbmV3TGV2ZWw7XG4gICAgfVxuICB9XG5cbiAgZ2V0IGZpcnN0TGV2ZWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZpcnN0TGV2ZWw7XG4gIH1cblxuICBzZXQgZmlyc3RMZXZlbChuZXdMZXZlbCkge1xuICAgIHRoaXMuX2ZpcnN0TGV2ZWwgPSBuZXdMZXZlbDtcbiAgfVxuXG4gIGdldCBzdGFydExldmVsKCkge1xuICAgIC8vIGhscy5zdGFydExldmVsIHRha2VzIHByZWNlZGVuY2Ugb3ZlciBjb25maWcuc3RhcnRMZXZlbFxuICAgIC8vIGlmIG5vbmUgb2YgdGhlc2UgdmFsdWVzIGFyZSBkZWZpbmVkLCBmYWxsYmFjayBvbiB0aGlzLl9maXJzdExldmVsIChmaXJzdCBxdWFsaXR5IGxldmVsIGFwcGVhcmluZyBpbiB2YXJpYW50IG1hbmlmZXN0KVxuICAgIGlmICh0aGlzLl9zdGFydExldmVsID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGxldCBjb25maWdTdGFydExldmVsID0gdGhpcy5obHMuY29uZmlnLnN0YXJ0TGV2ZWw7XG4gICAgICBpZiAoY29uZmlnU3RhcnRMZXZlbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBjb25maWdTdGFydExldmVsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZpcnN0TGV2ZWw7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLl9zdGFydExldmVsO1xuICAgIH1cbiAgfVxuXG4gIHNldCBzdGFydExldmVsKG5ld0xldmVsKSB7XG4gICAgLy8gaWYgbm90IGluIGF1dG9zdGFydCBsZXZlbCwgZW5zdXJlIHN0YXJ0TGV2ZWwgaXMgZ3JlYXRlciB0aGFuIG1pbkF1dG9MZXZlbFxuICAgIGlmIChuZXdMZXZlbCAhPT0gLTEpIHtcbiAgICAgIG5ld0xldmVsID0gTWF0aC5tYXgobmV3TGV2ZWwsIHRoaXMuaGxzLmFickNvbnRyb2xsZXIubWluQXV0b0xldmVsKTtcbiAgICB9XG4gICAgdGhpcy5fc3RhcnRMZXZlbCA9IG5ld0xldmVsO1xuICB9XG5cbiAgb25FcnJvcihkYXRhKSB7XG4gICAgaWYoZGF0YS5mYXRhbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCBkZXRhaWxzID0gZGF0YS5kZXRhaWxzLCBobHMgPSB0aGlzLmhscywgbGV2ZWxJZCwgbGV2ZWwsIGxldmVsRXJyb3IgPSBmYWxzZSwgYWJyQ29udHJvbGxlciA9IGhscy5hYnJDb250cm9sbGVyLCBtaW5BdXRvTGV2ZWwgPSBhYnJDb250cm9sbGVyLm1pbkF1dG9MZXZlbDtcbiAgICBsZXQgcmVtb3ZlTGV2ZWwgPSBmYWxzZTtcbiAgICAvLyB0cnkgdG8gcmVjb3ZlciBub3QgZmF0YWwgZXJyb3JzXG4gICAgc3dpdGNoKGRldGFpbHMpIHtcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkZSQUdfTE9BRF9FUlJPUjpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkZSQUdfTE9BRF9USU1FT1VUOlxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuRlJBR19MT09QX0xPQURJTkdfRVJST1I6XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5LRVlfTE9BRF9FUlJPUjpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLktFWV9MT0FEX1RJTUVPVVQ6XG4gICAgICAgICBsZXZlbElkID0gZGF0YS5mcmFnLmxldmVsO1xuICAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5MRVZFTF9MT0FEX0VSUk9SOlxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuTEVWRUxfTE9BRF9USU1FT1VUOlxuICAgICAgICBsZXZlbElkID0gZGF0YS5jb250ZXh0LmxldmVsO1xuICAgICAgICBsZXZlbEVycm9yID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5SRU1VWF9BTExPQ19FUlJPUjpcbiAgICAgICAgbGV2ZWxJZCA9IGRhdGEubGV2ZWw7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBFcnJvckRldGFpbHMuTUFOSUZFU1RfRU1QVFlfRVJST1I6XG4gICAgICAgIGxldmVsSWQgPSBkYXRhLmNvbnRleHQubGV2ZWw7XG4gICAgICAgIGxldmVsRXJyb3IgPSB0cnVlO1xuICAgICAgICByZW1vdmVMZXZlbCA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIC8qIHRyeSB0byBzd2l0Y2ggdG8gYSByZWR1bmRhbnQgc3RyZWFtIGlmIGFueSBhdmFpbGFibGUuXG4gICAgICogaWYgbm8gcmVkdW5kYW50IHN0cmVhbSBhdmFpbGFibGUsIGVtZXJnZW5jeSBzd2l0Y2ggZG93biAoaWYgaW4gYXV0byBtb2RlIGFuZCBjdXJyZW50IGxldmVsIG5vdCAwKVxuICAgICAqIG90aGVyd2lzZSwgd2UgY2Fubm90IHJlY292ZXIgdGhpcyBuZXR3b3JrIGVycm9yIC4uLlxuICAgICAqL1xuICAgIGlmIChsZXZlbElkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGxldmVsID0gdGhpcy5fbGV2ZWxzW2xldmVsSWRdO1xuICAgICAgaWYoIWxldmVsLmxvYWRFcnJvcikge1xuICAgICAgICBsZXZlbC5sb2FkRXJyb3IgPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV2ZWwubG9hZEVycm9yKys7XG4gICAgICB9XG4gICAgICAvLyBpZiBhbnkgcmVkdW5kYW50IHN0cmVhbXMgYXZhaWxhYmxlIGFuZCBpZiB3ZSBoYXZlbid0IHRyeSB0aGVtIGFsbCAobGV2ZWwubG9hZEVycm9yIGlzIHJlc2V0ZWQgb24gc3VjY2Vzc2Z1bCBmcmFnL2xldmVsIGxvYWQuXG4gICAgICAvLyBpZiBsZXZlbC5sb2FkRXJyb3IgcmVhY2hlcyBuYlJlZHVuZGFudExldmVsIGl0IG1lYW5zIHRoYXQgd2UgdHJpZWQgdGhlbSBhbGwsIG5vIGhvcGUgID0+IGxldCdzIHN3aXRjaCBkb3duXG4gICAgICBjb25zdCBuYlJlZHVuZGFudExldmVsID0gbGV2ZWwudXJsLmxlbmd0aDtcbiAgICAgaWYgKG5iUmVkdW5kYW50TGV2ZWwgPiAxICYmIGxldmVsLmxvYWRFcnJvciA8IG5iUmVkdW5kYW50TGV2ZWwpIHtcbiAgICAgICAgbGV2ZWwudXJsSWQgPSAobGV2ZWwudXJsSWQgKyAxKSAlIG5iUmVkdW5kYW50TGV2ZWw7XG4gICAgICAgIGxldmVsLmRldGFpbHMgPSB1bmRlZmluZWQ7XG4gICAgICAgIGxvZ2dlci53YXJuKGBsZXZlbCBjb250cm9sbGVyLCR7ZGV0YWlsc30gZm9yIGxldmVsICR7bGV2ZWxJZH06IHN3aXRjaGluZyB0byByZWR1bmRhbnQgc3RyZWFtIGlkICR7bGV2ZWwudXJsSWR9YCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocmVtb3ZlTGV2ZWwpIHtcbiAgICAgICAgICBsb2dnZXIud2FybihgQmFkIGxldmVsIGVuY291bnRlcmVkLCByZW1vdmluZyAmIGZvcmNpbmcgdG8gYXV0byBtb2RlYCk7XG4gICAgICAgICAgdGhpcy5fbGV2ZWxzID0gdGhpcy5sZXZlbHMuZmlsdGVyKChsLCBpbmRleCkgPT4gaW5kZXggIT09IGxldmVsSWQpO1xuICAgICAgICAgIGhscy5jdXJyZW50TGV2ZWwgPSAtMTtcbiAgICAgICAgICBobHMudHJpZ2dlcihFdmVudC5MRVZFTF9SRU1PVkVELCB7IGxldmVsOiBsZXZlbElkIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIHdlIGNvdWxkIHRyeSB0byByZWNvdmVyIGlmIGluIGF1dG8gbW9kZSBhbmQgY3VycmVudCBsZXZlbCBub3QgbG93ZXN0IGxldmVsICgwKVxuICAgICAgICBsZXQgcmVjb3ZlcmFibGUgPSAoKHRoaXMuX21hbnVhbExldmVsID09PSAtMSkgJiYgbGV2ZWxJZCk7XG4gICAgICAgIGlmIChyZWNvdmVyYWJsZSkge1xuICAgICAgICAgIGxvZ2dlci53YXJuKGBsZXZlbCBjb250cm9sbGVyLCR7ZGV0YWlsc306IHN3aXRjaC1kb3duIGZvciBuZXh0IGZyYWdtZW50YCk7XG4gICAgICAgICAgYWJyQ29udHJvbGxlci5uZXh0QXV0b0xldmVsID0gTWF0aC5tYXgobWluQXV0b0xldmVsLGxldmVsSWQtMSk7XG4gICAgICAgIH0gZWxzZSBpZihsZXZlbCAmJiBsZXZlbC5kZXRhaWxzICYmIGxldmVsLmRldGFpbHMubGl2ZSkge1xuICAgICAgICAgIGxvZ2dlci53YXJuKGBsZXZlbCBjb250cm9sbGVyLCR7ZGV0YWlsc30gb24gbGl2ZSBzdHJlYW0sIGRpc2NhcmRgKTtcbiAgICAgICAgICBpZiAobGV2ZWxFcnJvcikge1xuICAgICAgICAgICAgLy8gcmVzZXQgdGhpcy5fbGV2ZWwgc28gdGhhdCBhbm90aGVyIGNhbGwgdG8gc2V0IGxldmVsKCkgd2lsbCByZXRyaWdnZXIgYSBmcmFnIGxvYWRcbiAgICAgICAgICAgIHRoaXMuX2xldmVsID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBvdGhlciBlcnJvcnMgYXJlIGhhbmRsZWQgYnkgc3RyZWFtIGNvbnRyb2xsZXJcbiAgICAgICAgfSBlbHNlIGlmIChkZXRhaWxzID09PSBFcnJvckRldGFpbHMuTEVWRUxfTE9BRF9FUlJPUiB8fFxuICAgICAgICAgICAgICAgICAgIGRldGFpbHMgPT09IEVycm9yRGV0YWlscy5MRVZFTF9MT0FEX1RJTUVPVVQpIHtcbiAgICAgICAgICBsZXQgbWVkaWEgPSBobHMubWVkaWEsXG4gICAgICAgICAgICAvLyAwLjUgOiB0b2xlcmFuY2UgbmVlZGVkIGFzIHNvbWUgYnJvd3NlcnMgc3RhbGxzIHBsYXliYWNrIGJlZm9yZSByZWFjaGluZyBidWZmZXJlZCBlbmRcbiAgICAgICAgICAgICAgbWVkaWFCdWZmZXJlZCA9IG1lZGlhICYmIEJ1ZmZlckhlbHBlci5pc0J1ZmZlcmVkKG1lZGlhLG1lZGlhLmN1cnJlbnRUaW1lKSAmJiBCdWZmZXJIZWxwZXIuaXNCdWZmZXJlZChtZWRpYSxtZWRpYS5jdXJyZW50VGltZSswLjUpO1xuICAgICAgICAgIGlmIChtZWRpYUJ1ZmZlcmVkKSB7XG4gICAgICAgICAgICBsZXQgcmV0cnlEZWxheSA9IGhscy5jb25maWcubGV2ZWxMb2FkaW5nUmV0cnlEZWxheTtcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKGBsZXZlbCBjb250cm9sbGVyLCR7ZGV0YWlsc30sIGJ1dCBtZWRpYSBidWZmZXJlZCwgcmV0cnkgaW4gJHtyZXRyeURlbGF5fW1zYCk7XG4gICAgICAgICAgICB0aGlzLnRpbWVyID0gc2V0VGltZW91dCh0aGlzLm9udGljayxyZXRyeURlbGF5KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGBjYW5ub3QgcmVjb3ZlciAke2RldGFpbHN9IGVycm9yYCk7XG4gICAgICAgICAgICB0aGlzLl9sZXZlbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIC8vIHN0b3BwaW5nIGxpdmUgcmVsb2FkaW5nIHRpbWVyIGlmIGFueVxuICAgICAgICAgICAgaWYgKHRoaXMudGltZXIpIHtcbiAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZXIpO1xuICAgICAgICAgICAgICB0aGlzLnRpbWVyID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHJlZGlzcGF0Y2ggc2FtZSBlcnJvciBidXQgd2l0aCBmYXRhbCBzZXQgdG8gdHJ1ZVxuICAgICAgICAgICAgZGF0YS5mYXRhbCA9IHRydWU7XG4gICAgICAgICAgICBobHMudHJpZ2dlcihFdmVudC5FUlJPUiwgZGF0YSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gcmVzZXQgbGV2ZWwgbG9hZCBlcnJvciBjb3VudGVyIG9uIHN1Y2Nlc3NmdWwgZnJhZyBsb2FkZWRcbiAgb25GcmFnTG9hZGVkKGRhdGEpIHtcbiAgICBjb25zdCBmcmFnTG9hZGVkID0gZGF0YS5mcmFnO1xuICAgIGlmIChmcmFnTG9hZGVkICYmIGZyYWdMb2FkZWQudHlwZSA9PT0gJ21haW4nKSB7XG4gICAgICBjb25zdCBsZXZlbCA9IHRoaXMuX2xldmVsc1tmcmFnTG9hZGVkLmxldmVsXTtcbiAgICAgIGlmIChsZXZlbCkge1xuICAgICAgICBsZXZlbC5sb2FkRXJyb3IgPSAwO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIG9uTGV2ZWxMb2FkZWQoZGF0YSkge1xuICAgIGNvbnN0IGxldmVsSWQgPSBkYXRhLmxldmVsO1xuICAgICAvLyBvbmx5IHByb2Nlc3MgbGV2ZWwgbG9hZGVkIGV2ZW50cyBtYXRjaGluZyB3aXRoIGV4cGVjdGVkIGxldmVsXG4gICAgaWYgKGxldmVsSWQgPT09IHRoaXMuX2xldmVsKSB7XG4gICAgICBsZXQgY3VyTGV2ZWwgPSB0aGlzLl9sZXZlbHNbbGV2ZWxJZF07XG4gICAgICAvLyByZXNldCBsZXZlbCBsb2FkIGVycm9yIGNvdW50ZXIgb24gc3VjY2Vzc2Z1bCBsZXZlbCBsb2FkZWRcbiAgICAgIGN1ckxldmVsLmxvYWRFcnJvciA9IDA7XG4gICAgICBsZXQgbmV3RGV0YWlscyA9IGRhdGEuZGV0YWlscztcbiAgICAgIC8vIGlmIGN1cnJlbnQgcGxheWxpc3QgaXMgYSBsaXZlIHBsYXlsaXN0LCBhcm0gYSB0aW1lciB0byByZWxvYWQgaXRcbiAgICAgIGlmIChuZXdEZXRhaWxzLmxpdmUpIHtcbiAgICAgICAgbGV0IHJlbG9hZEludGVydmFsID0gMTAwMCooIG5ld0RldGFpbHMuYXZlcmFnZXRhcmdldGR1cmF0aW9uID8gbmV3RGV0YWlscy5hdmVyYWdldGFyZ2V0ZHVyYXRpb24gOiBuZXdEZXRhaWxzLnRhcmdldGR1cmF0aW9uKSxcbiAgICAgICAgICAgIGN1ckxldmVsID0gdGhpcy5fbGV2ZWxzW2RhdGEubGV2ZWxdLFxuICAgICAgICAgICAgY3VyRGV0YWlscyA9IGN1ckxldmVsLmRldGFpbHM7XG4gICAgICAgIGlmIChjdXJEZXRhaWxzICYmIG5ld0RldGFpbHMuZW5kU04gPT09IGN1ckRldGFpbHMuZW5kU04pIHtcbiAgICAgICAgICAvLyBmb2xsb3cgSExTIFNwZWMsIElmIHRoZSBjbGllbnQgcmVsb2FkcyBhIFBsYXlsaXN0IGZpbGUgYW5kIGZpbmRzIHRoYXQgaXQgaGFzIG5vdFxuICAgICAgICAgIC8vIGNoYW5nZWQgdGhlbiBpdCBNVVNUIHdhaXQgZm9yIGEgcGVyaW9kIG9mIG9uZS1oYWxmIHRoZSB0YXJnZXRcbiAgICAgICAgICAvLyBkdXJhdGlvbiBiZWZvcmUgcmV0cnlpbmcuXG4gICAgICAgICAgcmVsb2FkSW50ZXJ2YWwgLz0yO1xuICAgICAgICAgIGxvZ2dlci5sb2coYHNhbWUgbGl2ZSBwbGF5bGlzdCwgcmVsb2FkIHR3aWNlIGZhc3RlcmApO1xuICAgICAgICB9XG4gICAgICAgIC8vIGRlY3JlbWVudCByZWxvYWRJbnRlcnZhbCB3aXRoIGxldmVsIGxvYWRpbmcgZGVsYXlcbiAgICAgICAgcmVsb2FkSW50ZXJ2YWwgLT0gcGVyZm9ybWFuY2Uubm93KCkgLSBkYXRhLnN0YXRzLnRyZXF1ZXN0O1xuICAgICAgICAvLyBpbiBhbnkgY2FzZSwgZG9uJ3QgcmVsb2FkIG1vcmUgdGhhbiBldmVyeSBzZWNvbmRcbiAgICAgICAgcmVsb2FkSW50ZXJ2YWwgPSBNYXRoLm1heCgxMDAwLE1hdGgucm91bmQocmVsb2FkSW50ZXJ2YWwpKTtcbiAgICAgICAgbG9nZ2VyLmxvZyhgbGl2ZSBwbGF5bGlzdCwgcmVsb2FkIGluICR7cmVsb2FkSW50ZXJ2YWx9IG1zYCk7XG4gICAgICAgIHRoaXMudGltZXIgPSBzZXRUaW1lb3V0KHRoaXMub250aWNrLHJlbG9hZEludGVydmFsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudGltZXIgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHRpY2soKSB7XG4gICAgdmFyIGxldmVsSWQgPSB0aGlzLl9sZXZlbDtcbiAgICBpZiAobGV2ZWxJZCAhPT0gdW5kZWZpbmVkICYmIHRoaXMuY2FubG9hZCkge1xuICAgICAgdmFyIGxldmVsID0gdGhpcy5fbGV2ZWxzW2xldmVsSWRdLCB1cmxJZCA9IGxldmVsLnVybElkO1xuICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5MRVZFTF9MT0FESU5HLCB7dXJsOiBsZXZlbC51cmxbdXJsSWRdLCBsZXZlbDogbGV2ZWxJZCwgaWQ6IHVybElkfSk7XG4gICAgfVxuICB9XG5cbiAgZ2V0IG5leHRMb2FkTGV2ZWwoKSB7XG4gICAgaWYgKHRoaXMuX21hbnVhbExldmVsICE9PSAtMSkge1xuICAgICAgcmV0dXJuIHRoaXMuX21hbnVhbExldmVsO1xuICAgIH0gZWxzZSB7XG4gICAgIHJldHVybiB0aGlzLmhscy5hYnJDb250cm9sbGVyLm5leHRBdXRvTGV2ZWw7XG4gICAgfVxuICB9XG5cbiAgc2V0IG5leHRMb2FkTGV2ZWwobmV4dExldmVsKSB7XG4gICAgdGhpcy5sZXZlbCA9IG5leHRMZXZlbDtcbiAgICBpZiAodGhpcy5fbWFudWFsTGV2ZWwgPT09IC0xKSB7XG4gICAgICB0aGlzLmhscy5hYnJDb250cm9sbGVyLm5leHRBdXRvTGV2ZWwgPSBuZXh0TGV2ZWw7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IExldmVsQ29udHJvbGxlcjtcblxuIiwiLypcbiAqIFN0cmVhbSBDb250cm9sbGVyXG4qL1xuXG5pbXBvcnQgQmluYXJ5U2VhcmNoIGZyb20gJy4uL3V0aWxzL2JpbmFyeS1zZWFyY2gnO1xuaW1wb3J0IEJ1ZmZlckhlbHBlciBmcm9tICcuLi9oZWxwZXIvYnVmZmVyLWhlbHBlcic7XG5pbXBvcnQgRGVtdXhlciBmcm9tICcuLi9kZW11eC9kZW11eGVyJztcbmltcG9ydCBFdmVudCBmcm9tICcuLi9ldmVudHMnO1xuaW1wb3J0IEV2ZW50SGFuZGxlciBmcm9tICcuLi9ldmVudC1oYW5kbGVyJztcbmltcG9ydCBMZXZlbEhlbHBlciBmcm9tICcuLi9oZWxwZXIvbGV2ZWwtaGVscGVyJztcbmltcG9ydCBUaW1lUmFuZ2VzIGZyb20gJy4uL3V0aWxzL3RpbWVSYW5nZXMnO1xuaW1wb3J0IHtFcnJvclR5cGVzLCBFcnJvckRldGFpbHN9IGZyb20gJy4uL2Vycm9ycyc7XG5pbXBvcnQge2xvZ2dlcn0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcblxuY29uc3QgU3RhdGUgPSB7XG4gIFNUT1BQRUQgOiAnU1RPUFBFRCcsXG4gIElETEUgOiAnSURMRScsXG4gIEtFWV9MT0FESU5HIDogJ0tFWV9MT0FESU5HJyxcbiAgRlJBR19MT0FESU5HIDogJ0ZSQUdfTE9BRElORycsXG4gIEZSQUdfTE9BRElOR19XQUlUSU5HX1JFVFJZIDogJ0ZSQUdfTE9BRElOR19XQUlUSU5HX1JFVFJZJyxcbiAgV0FJVElOR19MRVZFTCA6ICdXQUlUSU5HX0xFVkVMJyxcbiAgUEFSU0lORyA6ICdQQVJTSU5HJyxcbiAgUEFSU0VEIDogJ1BBUlNFRCcsXG4gIEJVRkZFUl9GTFVTSElORyA6ICdCVUZGRVJfRkxVU0hJTkcnLFxuICBFTkRFRCA6ICdFTkRFRCcsXG4gIEVSUk9SIDogJ0VSUk9SJ1xufTtcblxuY2xhc3MgU3RyZWFtQ29udHJvbGxlciBleHRlbmRzIEV2ZW50SGFuZGxlciB7XG5cbiAgY29uc3RydWN0b3IoaGxzKSB7XG4gICAgc3VwZXIoaGxzLFxuICAgICAgRXZlbnQuTUVESUFfQVRUQUNIRUQsXG4gICAgICBFdmVudC5NRURJQV9ERVRBQ0hJTkcsXG4gICAgICBFdmVudC5NQU5JRkVTVF9MT0FESU5HLFxuICAgICAgRXZlbnQuTUFOSUZFU1RfUEFSU0VELFxuICAgICAgRXZlbnQuTEVWRUxfTE9BREVELFxuICAgICAgRXZlbnQuS0VZX0xPQURFRCxcbiAgICAgIEV2ZW50LkZSQUdfTE9BREVELFxuICAgICAgRXZlbnQuRlJBR19MT0FEX0VNRVJHRU5DWV9BQk9SVEVELFxuICAgICAgRXZlbnQuRlJBR19QQVJTSU5HX0lOSVRfU0VHTUVOVCxcbiAgICAgIEV2ZW50LkZSQUdfUEFSU0lOR19EQVRBLFxuICAgICAgRXZlbnQuRlJBR19QQVJTRUQsXG4gICAgICBFdmVudC5FUlJPUixcbiAgICAgIEV2ZW50LkFVRElPX1RSQUNLX1NXSVRDSElORyxcbiAgICAgIEV2ZW50LkFVRElPX1RSQUNLX1NXSVRDSEVELFxuICAgICAgRXZlbnQuQlVGRkVSX0NSRUFURUQsXG4gICAgICBFdmVudC5CVUZGRVJfQVBQRU5ERUQsXG4gICAgICBFdmVudC5CVUZGRVJfRkxVU0hFRCxcbiAgICAgIEV2ZW50LkxFVkVMX1JFTU9WRURcbiAgICApO1xuXG4gICAgdGhpcy5jb25maWcgPSBobHMuY29uZmlnO1xuICAgIHRoaXMuYXVkaW9Db2RlY1N3YXAgPSBmYWxzZTtcbiAgICB0aGlzLnRpY2tzID0gMDtcbiAgICB0aGlzLm9udGljayA9IHRoaXMudGljay5iaW5kKHRoaXMpO1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnN0b3BMb2FkKCk7XG4gICAgaWYgKHRoaXMudGltZXIpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy50aW1lcik7XG4gICAgICB0aGlzLnRpbWVyID0gbnVsbDtcbiAgICB9XG4gICAgRXZlbnRIYW5kbGVyLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XG4gICAgdGhpcy5zdGF0ZSA9IFN0YXRlLlNUT1BQRUQ7XG4gIH1cblxuICBzdGFydExvYWQoc3RhcnRQb3NpdGlvbikge1xuICAgIGlmICh0aGlzLmxldmVscykge1xuICAgICAgbGV0IGxhc3RDdXJyZW50VGltZSA9IHRoaXMubGFzdEN1cnJlbnRUaW1lLCBobHMgPSB0aGlzLmhscztcbiAgICAgIHRoaXMuc3RvcExvYWQoKTtcbiAgICAgIGlmICghdGhpcy50aW1lcikge1xuICAgICAgICB0aGlzLnRpbWVyID0gc2V0SW50ZXJ2YWwodGhpcy5vbnRpY2ssIDEwMCk7XG4gICAgICB9XG4gICAgICB0aGlzLmxldmVsID0gLTE7XG4gICAgICB0aGlzLmZyYWdMb2FkRXJyb3IgPSAwO1xuICAgICAgaWYgKCF0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCkge1xuICAgICAgICAvLyBkZXRlcm1pbmUgbG9hZCBsZXZlbFxuICAgICAgICBsZXQgc3RhcnRMZXZlbCA9IGhscy5zdGFydExldmVsO1xuICAgICAgICBpZiAoc3RhcnRMZXZlbCA9PT0gLTEpIHtcbiAgICAgICAgICAvLyAtMSA6IGd1ZXNzIHN0YXJ0IExldmVsIGJ5IGRvaW5nIGEgYml0cmF0ZSB0ZXN0IGJ5IGxvYWRpbmcgZmlyc3QgZnJhZ21lbnQgb2YgbG93ZXN0IHF1YWxpdHkgbGV2ZWxcbiAgICAgICAgICBzdGFydExldmVsID0gMDtcbiAgICAgICAgICB0aGlzLmJpdHJhdGVUZXN0ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzZXQgbmV3IGxldmVsIHRvIHBsYXlsaXN0IGxvYWRlciA6IHRoaXMgd2lsbCB0cmlnZ2VyIHN0YXJ0IGxldmVsIGxvYWRcbiAgICAgICAgLy8gaGxzLm5leHRMb2FkTGV2ZWwgcmVtYWlucyB1bnRpbCBpdCBpcyBzZXQgdG8gYSBuZXcgdmFsdWUgb3IgdW50aWwgYSBuZXcgZnJhZyBpcyBzdWNjZXNzZnVsbHkgbG9hZGVkXG4gICAgICAgIHRoaXMubGV2ZWwgPSBobHMubmV4dExvYWRMZXZlbCA9IHN0YXJ0TGV2ZWw7XG4gICAgICAgIHRoaXMubG9hZGVkbWV0YWRhdGEgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIGlmIHN0YXJ0UG9zaXRpb24gdW5kZWZpbmVkIGJ1dCBsYXN0Q3VycmVudFRpbWUgc2V0LCBzZXQgc3RhcnRQb3NpdGlvbiB0byBsYXN0IGN1cnJlbnRUaW1lXG4gICAgICBpZiAobGFzdEN1cnJlbnRUaW1lID4gMCAmJiBzdGFydFBvc2l0aW9uID09PSAtMSkge1xuICAgICAgICBsb2dnZXIubG9nKGBvdmVycmlkZSBzdGFydFBvc2l0aW9uIHdpdGggbGFzdEN1cnJlbnRUaW1lIEAke2xhc3RDdXJyZW50VGltZS50b0ZpeGVkKDMpfWApO1xuICAgICAgICBzdGFydFBvc2l0aW9uID0gbGFzdEN1cnJlbnRUaW1lO1xuICAgICAgfVxuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICB0aGlzLm5leHRMb2FkUG9zaXRpb24gPSB0aGlzLnN0YXJ0UG9zaXRpb24gPSB0aGlzLmxhc3RDdXJyZW50VGltZSA9IHN0YXJ0UG9zaXRpb247XG4gICAgICB0aGlzLnRpY2soKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbG9nZ2VyLndhcm4oJ2Nhbm5vdCBzdGFydCBsb2FkaW5nIGFzIG1hbmlmZXN0IG5vdCBwYXJzZWQgeWV0Jyk7XG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuU1RPUFBFRDtcbiAgICB9XG4gIH1cblxuICBzdG9wTG9hZCgpIHtcbiAgICB2YXIgZnJhZyA9IHRoaXMuZnJhZ0N1cnJlbnQ7XG4gICAgaWYgKGZyYWcpIHtcbiAgICAgIGlmIChmcmFnLmxvYWRlcikge1xuICAgICAgICBmcmFnLmxvYWRlci5hYm9ydCgpO1xuICAgICAgfVxuICAgICAgdGhpcy5mcmFnQ3VycmVudCA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMuZnJhZ1ByZXZpb3VzID0gbnVsbDtcbiAgICBpZiAodGhpcy5kZW11eGVyKSB7XG4gICAgICB0aGlzLmRlbXV4ZXIuZGVzdHJveSgpO1xuICAgICAgdGhpcy5kZW11eGVyID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5zdGF0ZSA9IFN0YXRlLlNUT1BQRUQ7XG4gIH1cblxuICB0aWNrKCkge1xuICAgIHRoaXMudGlja3MrKztcbiAgICBpZiAodGhpcy50aWNrcyA9PT0gMSkge1xuICAgICAgdGhpcy5kb1RpY2soKTtcbiAgICAgIGlmICh0aGlzLnRpY2tzID4gMSkge1xuICAgICAgICBzZXRUaW1lb3V0KHRoaXMudGljaywgMSk7XG4gICAgICB9XG4gICAgICB0aGlzLnRpY2tzID0gMDtcbiAgICB9XG4gIH1cblxuICBkb1RpY2soKSB7XG4gICAgc3dpdGNoKHRoaXMuc3RhdGUpIHtcbiAgICAgIGNhc2UgU3RhdGUuRVJST1I6XG4gICAgICAgIC8vZG9uJ3QgZG8gYW55dGhpbmcgaW4gZXJyb3Igc3RhdGUgdG8gYXZvaWQgYnJlYWtpbmcgZnVydGhlciAuLi5cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFN0YXRlLkJVRkZFUl9GTFVTSElORzpcbiAgICAgIC8vIGluIGJ1ZmZlciBmbHVzaGluZyBzdGF0ZSwgcmVzZXQgZnJhZ0xvYWRFcnJvciBjb3VudGVyXG4gICAgICAgIHRoaXMuZnJhZ0xvYWRFcnJvciA9IDA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBTdGF0ZS5JRExFOlxuICAgICAgICAvLyB3aGVuIHRoaXMgcmV0dXJucyBmYWxzZSB0aGVyZSB3YXMgYW4gZXJyb3IgYW5kIHdlIHNoYWxsIHJldHVybiBpbW1lZGlhdGx5XG4gICAgICAgIC8vIGZyb20gY3VycmVudCB0aWNrXG4gICAgICAgIGlmICghdGhpcy5fZG9UaWNrSWRsZSgpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBTdGF0ZS5XQUlUSU5HX0xFVkVMOlxuICAgICAgICB2YXIgbGV2ZWwgPSB0aGlzLmxldmVsc1t0aGlzLmxldmVsXTtcbiAgICAgICAgLy8gY2hlY2sgaWYgcGxheWxpc3QgaXMgYWxyZWFkeSBsb2FkZWRcbiAgICAgICAgaWYgKGxldmVsICYmIGxldmVsLmRldGFpbHMpIHtcbiAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgU3RhdGUuRlJBR19MT0FESU5HX1dBSVRJTkdfUkVUUlk6XG4gICAgICAgIHZhciBub3cgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgdmFyIHJldHJ5RGF0ZSA9IHRoaXMucmV0cnlEYXRlO1xuICAgICAgICAvLyBpZiBjdXJyZW50IHRpbWUgaXMgZ3QgdGhhbiByZXRyeURhdGUsIG9yIGlmIG1lZGlhIHNlZWtpbmcgbGV0J3Mgc3dpdGNoIHRvIElETEUgc3RhdGUgdG8gcmV0cnkgbG9hZGluZ1xuICAgICAgICBpZighcmV0cnlEYXRlIHx8IChub3cgPj0gcmV0cnlEYXRlKSB8fCAodGhpcy5tZWRpYSAmJiB0aGlzLm1lZGlhLnNlZWtpbmcpKSB7XG4gICAgICAgICAgbG9nZ2VyLmxvZyhgbWVkaWFDb250cm9sbGVyOiByZXRyeURhdGUgcmVhY2hlZCwgc3dpdGNoIGJhY2sgdG8gSURMRSBzdGF0ZWApO1xuICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBTdGF0ZS5FUlJPUjpcbiAgICAgIGNhc2UgU3RhdGUuU1RPUFBFRDpcbiAgICAgIGNhc2UgU3RhdGUuRlJBR19MT0FESU5HOlxuICAgICAgY2FzZSBTdGF0ZS5QQVJTSU5HOlxuICAgICAgY2FzZSBTdGF0ZS5QQVJTRUQ6XG4gICAgICBjYXNlIFN0YXRlLkVOREVEOlxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICAvLyBjaGVjayBidWZmZXJcbiAgICB0aGlzLl9jaGVja0J1ZmZlcigpO1xuICAgIC8vIGNoZWNrL3VwZGF0ZSBjdXJyZW50IGZyYWdtZW50XG4gICAgdGhpcy5fY2hlY2tGcmFnbWVudENoYW5nZWQoKTtcbiAgfVxuXG4gIC8vIElyb25pY2FsbHkgdGhlIFwiaWRsZVwiIHN0YXRlIGlzIHRoZSBvbiB3ZSBkbyB0aGUgbW9zdCBsb2dpYyBpbiBpdCBzZWVtcyAuLi4uXG4gIC8vIE5PVEU6IE1heWJlIHdlIGNvdWxkIHJhdGhlciBzY2hlZHVsZSBhIGNoZWNrIGZvciBidWZmZXIgbGVuZ3RoIGFmdGVyIGhhbGYgb2YgdGhlIGN1cnJlbnRseVxuICAvLyAgICAgICBwbGF5ZWQgc2VnbWVudCwgb3Igb24gcGF1c2UvcGxheS9zZWVrIGluc3RlYWQgb2YgbmFpdmVseSBjaGVja2luZyBldmVyeSAxMDBtcz9cbiAgX2RvVGlja0lkbGUoKSB7XG4gICAgY29uc3QgaGxzID0gdGhpcy5obHMsXG4gICAgICAgICAgY29uZmlnID0gaGxzLmNvbmZpZyxcbiAgICAgICAgICBtZWRpYSA9IHRoaXMubWVkaWE7XG5cbiAgICAvLyBpZiB2aWRlbyBub3QgYXR0YWNoZWQgQU5EXG4gICAgLy8gc3RhcnQgZnJhZ21lbnQgYWxyZWFkeSByZXF1ZXN0ZWQgT1Igc3RhcnQgZnJhZyBwcmVmZXRjaCBkaXNhYmxlXG4gICAgLy8gZXhpdCBsb29wXG4gICAgLy8gPT4gaWYgc3RhcnQgbGV2ZWwgbG9hZGVkIGFuZCBtZWRpYSBub3QgYXR0YWNoZWQgYnV0IHN0YXJ0IGZyYWcgcHJlZmV0Y2ggaXMgZW5hYmxlZCBhbmQgc3RhcnQgZnJhZyBub3QgcmVxdWVzdGVkIHlldCwgd2Ugd2lsbCBub3QgZXhpdCBsb29wXG4gICAgaWYgKHRoaXMubGV2ZWxMYXN0TG9hZGVkICE9PSB1bmRlZmluZWQgJiYgIW1lZGlhICYmXG4gICAgICAodGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgfHwgIWNvbmZpZy5zdGFydEZyYWdQcmVmZXRjaCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIGlmIHdlIGhhdmUgbm90IHlldCBsb2FkZWQgYW55IGZyYWdtZW50LCBzdGFydCBsb2FkaW5nIGZyb20gc3RhcnQgcG9zaXRpb25cbiAgICBsZXQgcG9zID0gMDtcbiAgICBpZiAodGhpcy5sb2FkZWRtZXRhZGF0YSkge1xuICAgICAgcG9zID0gbWVkaWEuY3VycmVudFRpbWU7XG4gICAgfSBlbHNlIGlmICh0aGlzLm5leHRMb2FkUG9zaXRpb24pIHtcbiAgICAgIHBvcyA9IHRoaXMubmV4dExvYWRQb3NpdGlvbjtcbiAgICB9XG5cbiAgICAvLyBkZXRlcm1pbmUgbmV4dCBsb2FkIGxldmVsXG4gICAgbGV0IGxldmVsID0gaGxzLm5leHRMb2FkTGV2ZWwsXG4gICAgICAgIGxldmVsSW5mbyA9IHRoaXMubGV2ZWxzW2xldmVsXSxcbiAgICAgICAgbGV2ZWxCaXRyYXRlID0gbGV2ZWxJbmZvLmJpdHJhdGUsXG4gICAgICAgIG1heEJ1ZkxlbjtcblxuICAgIC8vIGNvbXB1dGUgbWF4IEJ1ZmZlciBMZW5ndGggdGhhdCB3ZSBjb3VsZCBnZXQgZnJvbSB0aGlzIGxvYWQgbGV2ZWwsIGJhc2VkIG9uIGxldmVsIGJpdHJhdGUuIGRvbid0IGJ1ZmZlciBtb3JlIHRoYW4gNjAgTUIgYW5kIG1vcmUgdGhhbiAzMHNcbiAgICBpZiAobGV2ZWxCaXRyYXRlKSB7XG4gICAgICBtYXhCdWZMZW4gPSBNYXRoLm1heCg4ICogY29uZmlnLm1heEJ1ZmZlclNpemUgLyBsZXZlbEJpdHJhdGUsIGNvbmZpZy5tYXhCdWZmZXJMZW5ndGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBtYXhCdWZMZW4gPSBjb25maWcubWF4QnVmZmVyTGVuZ3RoO1xuICAgIH1cbiAgICBtYXhCdWZMZW4gPSBNYXRoLm1pbihtYXhCdWZMZW4sIGNvbmZpZy5tYXhNYXhCdWZmZXJMZW5ndGgpO1xuXG4gICAgLy8gZGV0ZXJtaW5lIG5leHQgY2FuZGlkYXRlIGZyYWdtZW50IHRvIGJlIGxvYWRlZCwgYmFzZWQgb24gY3VycmVudCBwb3NpdGlvbiBhbmQgZW5kIG9mIGJ1ZmZlciBwb3NpdGlvblxuICAgIC8vIGVuc3VyZSB1cCB0byBgY29uZmlnLm1heE1heEJ1ZmZlckxlbmd0aGAgb2YgYnVmZmVyIHVwZnJvbnRcblxuICAgIGNvbnN0IGJ1ZmZlckluZm8gPSBCdWZmZXJIZWxwZXIuYnVmZmVySW5mbyh0aGlzLm1lZGlhQnVmZmVyID8gdGhpcy5tZWRpYUJ1ZmZlciA6IG1lZGlhLCBwb3MsIGNvbmZpZy5tYXhCdWZmZXJIb2xlKSxcbiAgICAgICAgICBidWZmZXJMZW4gPSBidWZmZXJJbmZvLmxlbjtcbiAgICAvLyBTdGF5IGlkbGUgaWYgd2UgYXJlIHN0aWxsIHdpdGggYnVmZmVyIG1hcmdpbnNcbiAgICBpZiAoYnVmZmVyTGVuID49IG1heEJ1Zkxlbikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gaWYgYnVmZmVyIGxlbmd0aCBpcyBsZXNzIHRoYW4gbWF4QnVmTGVuIHRyeSB0byBsb2FkIGEgbmV3IGZyYWdtZW50IC4uLlxuICAgIGxvZ2dlci50cmFjZShgYnVmZmVyIGxlbmd0aCBvZiAke2J1ZmZlckxlbi50b0ZpeGVkKDMpfSBpcyBiZWxvdyBtYXggb2YgJHttYXhCdWZMZW4udG9GaXhlZCgzKX0uIGNoZWNraW5nIGZvciBtb3JlIHBheWxvYWQgLi4uYCk7XG5cbiAgICAvLyBzZXQgbmV4dCBsb2FkIGxldmVsIDogdGhpcyB3aWxsIHRyaWdnZXIgYSBwbGF5bGlzdCBsb2FkIGlmIG5lZWRlZFxuICAgIHRoaXMubGV2ZWwgPSBobHMubmV4dExvYWRMZXZlbCA9IGxldmVsO1xuXG4gICAgY29uc3QgbGV2ZWxEZXRhaWxzID0gbGV2ZWxJbmZvLmRldGFpbHM7XG4gICAgLy8gaWYgbGV2ZWwgaW5mbyBub3QgcmV0cmlldmVkIHlldCwgc3dpdGNoIHN0YXRlIGFuZCB3YWl0IGZvciBsZXZlbCByZXRyaWV2YWxcbiAgICAvLyBpZiBsaXZlIHBsYXlsaXN0LCBlbnN1cmUgdGhhdCBuZXcgcGxheWxpc3QgaGFzIGJlZW4gcmVmcmVzaGVkIHRvIGF2b2lkIGxvYWRpbmcvdHJ5IHRvIGxvYWRcbiAgICAvLyBhIHVzZWxlc3MgYW5kIG91dGRhdGVkIGZyYWdtZW50ICh0aGF0IG1pZ2h0IGV2ZW4gaW50cm9kdWNlIGxvYWQgZXJyb3IgaWYgaXQgaXMgYWxyZWFkeSBvdXQgb2YgdGhlIGxpdmUgcGxheWxpc3QpXG4gICAgaWYgKHR5cGVvZiBsZXZlbERldGFpbHMgPT09ICd1bmRlZmluZWQnIHx8IGxldmVsRGV0YWlscy5saXZlICYmIHRoaXMubGV2ZWxMYXN0TG9hZGVkICE9PSBsZXZlbCkge1xuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLldBSVRJTkdfTEVWRUw7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyB3ZSBqdXN0IGdvdCBkb25lIGxvYWRpbmcgdGhlIGZpbmFsIGZyYWdtZW50LCBjaGVjayBpZiB3ZSBuZWVkIHRvIGZpbmFsaXplIG1lZGlhIHN0cmVhbVxuICAgIGxldCBmcmFnUHJldmlvdXMgPSB0aGlzLmZyYWdQcmV2aW91cztcbiAgICBpZiAoIWxldmVsRGV0YWlscy5saXZlICYmIGZyYWdQcmV2aW91cyAmJiBmcmFnUHJldmlvdXMuc24gPT09IGxldmVsRGV0YWlscy5lbmRTTikge1xuICAgICAgICAvLyBpZiAod2UgYXJlIG5vdCBzZWVraW5nIEFORCBjdXJyZW50IHBvc2l0aW9uIGlzIGJ1ZmZlcmVkKSBPUiAoaWYgd2UgYXJlIHNlZWtpbmcgYnV0IGV2ZXJ5dGhpbmcgKGFsbW9zdCkgdGlsIHRoZSBlbmQgaXMgYnVmZmVyZWQpLCBsZXQncyBzaWduYWwgZW9zXG4gICAgICAgIC8vIHdlIGRvbid0IGNvbXBhcmUgZXhhY3RseSBtZWRpYS5kdXJhdGlvbiA9PT0gYnVmZmVySW5mby5lbmQgYXMgdGhlcmUgY291bGQgYmUgc29tZSBzdWJ0bGUgbWVkaWEgZHVyYXRpb24gZGlmZmVyZW5jZSB3aGVuIHN3aXRjaGluZ1xuICAgICAgICAvLyBiZXR3ZWVuIGRpZmZlcmVudCByZW5kaXRpb25zLiB1c2luZyBoYWxmIGZyYWcgZHVyYXRpb24gc2hvdWxkIGhlbHAgY29wZSB3aXRoIHRoZXNlIGNhc2VzLlxuICAgICAgICBpZiAoKCFtZWRpYS5zZWVraW5nICYmIGJ1ZmZlckluZm8ubGVuKSB8fCAobWVkaWEuZHVyYXRpb24tYnVmZmVySW5mby5lbmQpIDw9IGZyYWdQcmV2aW91cy5kdXJhdGlvbi8yKSB7XG4gICAgICAgIC8vIEZpbmFsaXplIHRoZSBtZWRpYSBzdHJlYW1cbiAgICAgICAgbGV0IGRhdGEgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYWx0QXVkaW8pIHtcbiAgICAgICAgICBkYXRhLnR5cGUgPSAndmlkZW8nO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuQlVGRkVSX0VPUyxkYXRhKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkVOREVEO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBpZiB3ZSBoYXZlIHRoZSBsZXZlbERldGFpbHMgZm9yIHRoZSBzZWxlY3RlZCB2YXJpYW50LCBsZXRzIGNvbnRpbnVlIGVucmljaGVuIG91ciBzdHJlYW0gKGxvYWQga2V5cy9mcmFnbWVudHMgb3IgdHJpZ2dlciBFT1MsIGV0Yy4uKVxuICAgIHJldHVybiB0aGlzLl9mZXRjaFBheWxvYWRPckVvcyh7cG9zLCBidWZmZXJJbmZvLCBsZXZlbERldGFpbHN9KTtcbiAgfVxuXG4gIF9mZXRjaFBheWxvYWRPckVvcyh7cG9zLCBidWZmZXJJbmZvLCBsZXZlbERldGFpbHN9KSB7XG4gICAgY29uc3QgZnJhZ1ByZXZpb3VzID0gdGhpcy5mcmFnUHJldmlvdXMsXG4gICAgICAgICAgbGV2ZWwgPSB0aGlzLmxldmVsLFxuICAgICAgICAgIGZyYWdtZW50cyA9IGxldmVsRGV0YWlscy5mcmFnbWVudHMsXG4gICAgICAgICAgZnJhZ0xlbiA9IGZyYWdtZW50cy5sZW5ndGg7XG5cbiAgICAvLyBlbXB0eSBwbGF5bGlzdFxuICAgIGlmIChmcmFnTGVuID09PSAwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gZmluZCBmcmFnbWVudCBpbmRleCwgY29udGlndW91cyB3aXRoIGVuZCBvZiBidWZmZXIgcG9zaXRpb25cbiAgICBsZXQgc3RhcnQgPSBmcmFnbWVudHNbMF0uc3RhcnQsXG4gICAgICAgIGVuZCA9IGZyYWdtZW50c1tmcmFnTGVuLTFdLnN0YXJ0ICsgZnJhZ21lbnRzW2ZyYWdMZW4tMV0uZHVyYXRpb24sXG4gICAgICAgIGJ1ZmZlckVuZCA9IGJ1ZmZlckluZm8uZW5kLFxuICAgICAgICBmcmFnO1xuXG4gICAgICAvLyBpbiBjYXNlIG9mIGxpdmUgcGxheWxpc3Qgd2UgbmVlZCB0byBlbnN1cmUgdGhhdCByZXF1ZXN0ZWQgcG9zaXRpb24gaXMgbm90IGxvY2F0ZWQgYmVmb3JlIHBsYXlsaXN0IHN0YXJ0XG4gICAgaWYgKGxldmVsRGV0YWlscy5saXZlKSB7XG4gICAgICBsZXQgaW5pdGlhbExpdmVNYW5pZmVzdFNpemUgPSB0aGlzLmNvbmZpZy5pbml0aWFsTGl2ZU1hbmlmZXN0U2l6ZTtcbiAgICAgIGlmKGZyYWdMZW4gPCBpbml0aWFsTGl2ZU1hbmlmZXN0U2l6ZSl7XG4gICAgICAgIGxvZ2dlci53YXJuKGBDYW4gbm90IHN0YXJ0IHBsYXliYWNrIG9mIGEgbGV2ZWwsIHJlYXNvbjogbm90IGVub3VnaCBmcmFnbWVudHMgJHtmcmFnTGVufSA8ICR7aW5pdGlhbExpdmVNYW5pZmVzdFNpemV9YCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgZnJhZyA9IHRoaXMuX2Vuc3VyZUZyYWdtZW50QXRMaXZlUG9pbnQoe2xldmVsRGV0YWlscywgYnVmZmVyRW5kLCBzdGFydCwgZW5kLCBmcmFnUHJldmlvdXMsIGZyYWdtZW50cywgZnJhZ0xlbn0pO1xuICAgICAgLy8gaWYgaXQgZXhwbGljaXRlbHkgcmV0dXJucyBudWxsIGRvbid0IGxvYWQgYW55IGZyYWdtZW50IGFuZCBleGl0IGZ1bmN0aW9uIG5vd1xuICAgICAgaWYgKGZyYWcgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFZvRCBwbGF5bGlzdDogaWYgYnVmZmVyRW5kIGJlZm9yZSBzdGFydCBvZiBwbGF5bGlzdCwgbG9hZCBmaXJzdCBmcmFnbWVudFxuICAgICAgaWYgKGJ1ZmZlckVuZCA8IHN0YXJ0KSB7XG4gICAgICAgIGZyYWcgPSBmcmFnbWVudHNbMF07XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghZnJhZykge1xuICAgICAgZnJhZyA9IHRoaXMuX2ZpbmRGcmFnbWVudCh7c3RhcnQsIGZyYWdQcmV2aW91cywgZnJhZ0xlbiwgZnJhZ21lbnRzLCBidWZmZXJFbmQsIGVuZCwgbGV2ZWxEZXRhaWxzfSk7XG4gICAgfVxuICAgIGlmKGZyYWcpIHtcbiAgICAgIHJldHVybiB0aGlzLl9sb2FkRnJhZ21lbnRPcktleSh7ZnJhZywgbGV2ZWwsIGxldmVsRGV0YWlscywgcG9zLCBidWZmZXJFbmR9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBfZW5zdXJlRnJhZ21lbnRBdExpdmVQb2ludCh7bGV2ZWxEZXRhaWxzLCBidWZmZXJFbmQsIHN0YXJ0LCBlbmQsIGZyYWdQcmV2aW91cywgZnJhZ21lbnRzLCBmcmFnTGVufSkge1xuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuaGxzLmNvbmZpZywgbWVkaWEgPSB0aGlzLm1lZGlhO1xuXG4gICAgbGV0IGZyYWc7XG5cbiAgICAvLyBjaGVjayBpZiByZXF1ZXN0ZWQgcG9zaXRpb24gaXMgd2l0aGluIHNlZWthYmxlIGJvdW5kYXJpZXMgOlxuICAgIC8vbG9nZ2VyLmxvZyhgc3RhcnQvcG9zL2J1ZkVuZC9zZWVraW5nOiR7c3RhcnQudG9GaXhlZCgzKX0vJHtwb3MudG9GaXhlZCgzKX0vJHtidWZmZXJFbmQudG9GaXhlZCgzKX0vJHt0aGlzLm1lZGlhLnNlZWtpbmd9YCk7XG4gICAgbGV0IG1heExhdGVuY3kgPSBjb25maWcubGl2ZU1heExhdGVuY3lEdXJhdGlvbiAhPT0gdW5kZWZpbmVkID8gY29uZmlnLmxpdmVNYXhMYXRlbmN5RHVyYXRpb24gOiBjb25maWcubGl2ZU1heExhdGVuY3lEdXJhdGlvbkNvdW50KmxldmVsRGV0YWlscy50YXJnZXRkdXJhdGlvbjtcblxuICAgIGlmIChidWZmZXJFbmQgPCBNYXRoLm1heChzdGFydCwgZW5kIC0gbWF4TGF0ZW5jeSkpIHtcbiAgICAgICAgbGV0IGxpdmVTeW5jUG9zaXRpb24gPSB0aGlzLmxpdmVTeW5jUG9zaXRpb24gPSB0aGlzLmNvbXB1dGVMaXZlUG9zaXRpb24oc3RhcnQsIGxldmVsRGV0YWlscyk7XG4gICAgICAgIGxvZ2dlci5sb2coYGJ1ZmZlciBlbmQ6ICR7YnVmZmVyRW5kLnRvRml4ZWQoMyl9IGlzIGxvY2F0ZWQgdG9vIGZhciBmcm9tIHRoZSBlbmQgb2YgbGl2ZSBzbGlkaW5nIHBsYXlsaXN0LCByZXNldCBjdXJyZW50VGltZSB0byA6ICR7bGl2ZVN5bmNQb3NpdGlvbi50b0ZpeGVkKDMpfWApO1xuICAgICAgICBidWZmZXJFbmQgPSBsaXZlU3luY1Bvc2l0aW9uO1xuICAgICAgICBpZiAobWVkaWEgJiYgbWVkaWEucmVhZHlTdGF0ZSAmJiBtZWRpYS5kdXJhdGlvbiA+IGxpdmVTeW5jUG9zaXRpb24pIHtcbiAgICAgICAgICBtZWRpYS5jdXJyZW50VGltZSA9IGxpdmVTeW5jUG9zaXRpb247XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBpZiBlbmQgb2YgYnVmZmVyIGdyZWF0ZXIgdGhhbiBsaXZlIGVkZ2UsIGRvbid0IGxvYWQgYW55IGZyYWdtZW50XG4gICAgLy8gdGhpcyBjb3VsZCBoYXBwZW4gaWYgbGl2ZSBwbGF5bGlzdCBpbnRlcm1pdHRlbnRseSBzbGlkZXMgaW4gdGhlIHBhc3QuXG4gICAgLy8gbGV2ZWwgMSBsb2FkZWQgWzE4MjU4MDE2MSwxODI1ODAxNjddXG4gICAgLy8gbGV2ZWwgMSBsb2FkZWQgWzE4MjU4MDE2MiwxODI1ODAxNjldXG4gICAgLy8gTG9hZGluZyAxODI1ODAxNjggb2YgWzE4MjU4MDE2MiAsMTgyNTgwMTY5XSxsZXZlbCAxIC4uXG4gICAgLy8gTG9hZGluZyAxODI1ODAxNjkgb2YgWzE4MjU4MDE2MiAsMTgyNTgwMTY5XSxsZXZlbCAxIC4uXG4gICAgLy8gbGV2ZWwgMSBsb2FkZWQgWzE4MjU4MDE2MiwxODI1ODAxNjhdIDw9PT09PT09PT09PT09IGhlcmUgd2Ugc2hvdWxkIGhhdmUgYnVmZmVyRW5kID4gZW5kLiBpbiB0aGF0IGNhc2UgYnJlYWsgdG8gYXZvaWQgcmVsb2FkaW5nIDE4MjU4MDE2OFxuICAgIC8vIGxldmVsIDEgbG9hZGVkIFsxODI1ODAxNjQsMTgyNTgwMTcxXVxuICAgIC8vXG4gICAgLy8gZG9uJ3QgcmV0dXJuIG51bGwgaW4gY2FzZSBtZWRpYSBub3QgbG9hZGVkIHlldCAocmVhZHlzdGF0ZSA9PT0gMClcbiAgICBpZiAobGV2ZWxEZXRhaWxzLlBUU0tub3duICYmIGJ1ZmZlckVuZCA+IGVuZCAmJiBtZWRpYSAmJiBtZWRpYS5yZWFkeVN0YXRlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgJiYgIWxldmVsRGV0YWlscy5QVFNLbm93bikge1xuICAgICAgLyogd2UgYXJlIHN3aXRjaGluZyBsZXZlbCBvbiBsaXZlIHBsYXlsaXN0LCBidXQgd2UgZG9uJ3QgaGF2ZSBhbnkgUFRTIGluZm8gZm9yIHRoYXQgcXVhbGl0eSBsZXZlbCAuLi5cbiAgICAgICAgIHRyeSB0byBsb2FkIGZyYWcgbWF0Y2hpbmcgd2l0aCBuZXh0IFNOLlxuICAgICAgICAgZXZlbiBpZiBTTiBhcmUgbm90IHN5bmNocm9uaXplZCBiZXR3ZWVuIHBsYXlsaXN0cywgbG9hZGluZyB0aGlzIGZyYWcgd2lsbCBoZWxwIHVzXG4gICAgICAgICBjb21wdXRlIHBsYXlsaXN0IHNsaWRpbmcgYW5kIGZpbmQgdGhlIHJpZ2h0IG9uZSBhZnRlciBpbiBjYXNlIGl0IHdhcyBub3QgdGhlIHJpZ2h0IGNvbnNlY3V0aXZlIG9uZSAqL1xuICAgICAgaWYgKGZyYWdQcmV2aW91cykge1xuICAgICAgICB2YXIgdGFyZ2V0U04gPSBmcmFnUHJldmlvdXMuc24gKyAxO1xuICAgICAgICBpZiAodGFyZ2V0U04gPj0gbGV2ZWxEZXRhaWxzLnN0YXJ0U04gJiYgdGFyZ2V0U04gPD0gbGV2ZWxEZXRhaWxzLmVuZFNOKSB7XG4gICAgICAgICAgZnJhZyA9IGZyYWdtZW50c1t0YXJnZXRTTiAtIGxldmVsRGV0YWlscy5zdGFydFNOXTtcbiAgICAgICAgICBsb2dnZXIubG9nKGBsaXZlIHBsYXlsaXN0LCBzd2l0Y2hpbmcgcGxheWxpc3QsIGxvYWQgZnJhZyB3aXRoIG5leHQgU046ICR7ZnJhZy5zbn1gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFmcmFnKSB7XG4gICAgICAgIC8qIHdlIGhhdmUgbm8gaWRlYSBhYm91dCB3aGljaCBmcmFnbWVudCBzaG91bGQgYmUgbG9hZGVkLlxuICAgICAgICAgICBzbyBsZXQncyBsb2FkIG1pZCBmcmFnbWVudC4gaXQgd2lsbCBoZWxwIGNvbXB1dGluZyBwbGF5bGlzdCBzbGlkaW5nIGFuZCBmaW5kIHRoZSByaWdodCBvbmVcbiAgICAgICAgKi9cbiAgICAgICAgZnJhZyA9IGZyYWdtZW50c1tNYXRoLm1pbihmcmFnTGVuIC0gMSwgTWF0aC5yb3VuZChmcmFnTGVuIC8gMikpXTtcbiAgICAgICAgbG9nZ2VyLmxvZyhgbGl2ZSBwbGF5bGlzdCwgc3dpdGNoaW5nIHBsYXlsaXN0LCB1bmtub3duLCBsb2FkIG1pZGRsZSBmcmFnIDogJHtmcmFnLnNufWApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZnJhZztcbiAgfVxuXG4gIF9maW5kRnJhZ21lbnQoe3N0YXJ0LCBmcmFnUHJldmlvdXMsIGZyYWdMZW4sIGZyYWdtZW50cywgYnVmZmVyRW5kLCBlbmQsIGxldmVsRGV0YWlsc30pIHtcbiAgICBjb25zdCBjb25maWcgPSB0aGlzLmhscy5jb25maWc7XG4gICAgbGV0IGZyYWc7XG4gICAgbGV0IGZvdW5kRnJhZztcbiAgICBsZXQgbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSA9IGNvbmZpZy5tYXhGcmFnTG9va1VwVG9sZXJhbmNlO1xuICAgIGxldCBmcmFnTmV4dCA9IChmcmFnUHJldmlvdXMpID8gZnJhZ21lbnRzLmZpbmQoKGZyYWdtZW50KSA9PiAgZnJhZ21lbnQuc24gPT09IGZyYWdQcmV2aW91cy5zbiArIDEpIDogdW5kZWZpbmVkO1xuICAgIGxldCBmcmFnbWVudFdpdGhpblRvbGVyYW5jZVRlc3QgPSAoY2FuZGlkYXRlKSA9PiB7XG4gICAgICAvLyBvZmZzZXQgc2hvdWxkIGJlIHdpdGhpbiBmcmFnbWVudCBib3VuZGFyeSAtIGNvbmZpZy5tYXhGcmFnTG9va1VwVG9sZXJhbmNlXG4gICAgICAvLyB0aGlzIGlzIHRvIGNvcGUgd2l0aCBzaXR1YXRpb25zIGxpa2VcbiAgICAgIC8vIGJ1ZmZlckVuZCA9IDkuOTkxXG4gICAgICAvLyBmcmFnW8OYXSA6IFswLDEwXVxuICAgICAgLy8gZnJhZ1sxXSA6IFsxMCwyMF1cbiAgICAgIC8vIGJ1ZmZlckVuZCBpcyB3aXRoaW4gZnJhZ1swXSByYW5nZSAuLi4gYWx0aG91Z2ggd2hhdCB3ZSBhcmUgZXhwZWN0aW5nIGlzIHRvIHJldHVybiBmcmFnWzFdIGhlcmVcbiAgICAgIC8vICAgICAgICAgICAgICBmcmFnIHN0YXJ0ICAgICAgICAgICAgICAgZnJhZyBzdGFydCtkdXJhdGlvblxuICAgICAgLy8gICAgICAgICAgICAgICAgICB8LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18XG4gICAgICAvLyAgICAgICAgICAgICAgPC0tLT4gICAgICAgICAgICAgICAgICAgICAgICAgPC0tLT5cbiAgICAgIC8vICAuLi4tLS0tLS0tLT48LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0+PC0tLS0tLS0tLS4uLi5cbiAgICAgIC8vIHByZXZpb3VzIGZyYWcgICAgICAgICBtYXRjaGluZyBmcmFnbWVudCAgICAgICAgIG5leHQgZnJhZ1xuICAgICAgLy8gIHJldHVybiAtMSAgICAgICAgICAgICByZXR1cm4gMCAgICAgICAgICAgICAgICAgcmV0dXJuIDFcbiAgICAgIC8vbG9nZ2VyLmxvZyhgbGV2ZWwvc24vc3RhcnQvZW5kL2J1ZkVuZDoke2xldmVsfS8ke2NhbmRpZGF0ZS5zbn0vJHtjYW5kaWRhdGUuc3RhcnR9LyR7KGNhbmRpZGF0ZS5zdGFydCtjYW5kaWRhdGUuZHVyYXRpb24pfS8ke2J1ZmZlckVuZH1gKTtcbiAgICAgIC8vIFNldCB0aGUgbG9va3VwIHRvbGVyYW5jZSB0byBiZSBzbWFsbCBlbm91Z2ggdG8gZGV0ZWN0IHRoZSBjdXJyZW50IHNlZ21lbnQgLSBlbnN1cmVzIHdlIGRvbid0IHNraXAgb3ZlciB2ZXJ5IHNtYWxsIHNlZ21lbnRzXG4gICAgICBsZXQgY2FuZGlkYXRlTG9va3VwVG9sZXJhbmNlID0gTWF0aC5taW4obWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSwgY2FuZGlkYXRlLmR1cmF0aW9uKTtcbiAgICAgIGlmIChjYW5kaWRhdGUuc3RhcnQgKyBjYW5kaWRhdGUuZHVyYXRpb24gLSBjYW5kaWRhdGVMb29rdXBUb2xlcmFuY2UgPD0gYnVmZmVyRW5kKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfSAvLyBpZiBtYXhGcmFnTG9va1VwVG9sZXJhbmNlIHdpbGwgaGF2ZSBuZWdhdGl2ZSB2YWx1ZSB0aGVuIGRvbid0IHJldHVybiAtMSBmb3IgZmlyc3QgZWxlbWVudFxuICAgICAgZWxzZSBpZiAoY2FuZGlkYXRlLnN0YXJ0IC0gY2FuZGlkYXRlTG9va3VwVG9sZXJhbmNlID4gYnVmZmVyRW5kICYmIGNhbmRpZGF0ZS5zdGFydCkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICByZXR1cm4gMDtcbiAgICB9O1xuXG4gICAgaWYgKGJ1ZmZlckVuZCA8IGVuZCkge1xuICAgICAgaWYgKGJ1ZmZlckVuZCA+IGVuZCAtIG1heEZyYWdMb29rVXBUb2xlcmFuY2UpIHtcbiAgICAgICAgbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSA9IDA7XG4gICAgICB9XG4gICAgICAvLyBQcmVmZXIgdGhlIG5leHQgZnJhZ21lbnQgaWYgaXQncyB3aXRoaW4gdG9sZXJhbmNlXG4gICAgICBpZiAoZnJhZ05leHQgJiYgIWZyYWdtZW50V2l0aGluVG9sZXJhbmNlVGVzdChmcmFnTmV4dCkpIHtcbiAgICAgICAgZm91bmRGcmFnID0gZnJhZ05leHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3VuZEZyYWcgPSBCaW5hcnlTZWFyY2guc2VhcmNoKGZyYWdtZW50cywgZnJhZ21lbnRXaXRoaW5Ub2xlcmFuY2VUZXN0KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcmVhY2ggZW5kIG9mIHBsYXlsaXN0XG4gICAgICBmb3VuZEZyYWcgPSBmcmFnbWVudHNbZnJhZ0xlbi0xXTtcbiAgICB9XG4gICAgaWYgKGZvdW5kRnJhZykge1xuICAgICAgZnJhZyA9IGZvdW5kRnJhZztcbiAgICAgIGNvbnN0IGN1clNOSWR4ID0gZnJhZy5zbiAtIGxldmVsRGV0YWlscy5zdGFydFNOO1xuICAgICAgY29uc3Qgc2FtZUxldmVsID0gZnJhZ1ByZXZpb3VzICYmIGZyYWcubGV2ZWwgPT09IGZyYWdQcmV2aW91cy5sZXZlbDtcbiAgICAgIGNvbnN0IHByZXZGcmFnID0gZnJhZ21lbnRzW2N1clNOSWR4IC0gMV07XG4gICAgICBjb25zdCBuZXh0RnJhZyA9IGZyYWdtZW50c1tjdXJTTklkeCArIDFdO1xuICAgICAgLy9sb2dnZXIubG9nKCdmaW5kIFNOIG1hdGNoaW5nIHdpdGggcG9zOicgKyAgYnVmZmVyRW5kICsgJzonICsgZnJhZy5zbik7XG4gICAgICAgaWYgKHNhbWVMZXZlbCAmJiBmcmFnLnNuID09PSBmcmFnUHJldmlvdXMuc24pIHtcbiAgICAgICAgICBpZiAoZnJhZy5zbiA8IGxldmVsRGV0YWlscy5lbmRTTikge1xuICAgICAgICAgICAgbGV0IGRlbHRhUFRTID0gZnJhZ1ByZXZpb3VzLmRlbHRhUFRTO1xuICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgYSBzaWduaWZpY2FudCBkZWx0YSBiZXR3ZWVuIGF1ZGlvIGFuZCB2aWRlbywgbGFyZ2VyIHRoYW4gbWF4IGFsbG93ZWQgaG9sZSxcbiAgICAgICAgICAgIC8vIGFuZCBpZiBwcmV2aW91cyByZW11eGVkIGZyYWdtZW50IGRpZCBub3Qgc3RhcnQgd2l0aCBhIGtleWZyYW1lLiAoZnJhZ1ByZXZpb3VzLmRyb3BwZWQpXG4gICAgICAgICAgICAvLyBsZXQncyB0cnkgdG8gbG9hZCBwcmV2aW91cyBmcmFnbWVudCBhZ2FpbiB0byBnZXQgbGFzdCBrZXlmcmFtZVxuICAgICAgICAgICAgLy8gdGhlbiB3ZSB3aWxsIHJlbG9hZCBhZ2FpbiBjdXJyZW50IGZyYWdtZW50ICh0aGF0IHdheSB3ZSBzaG91bGQgYmUgYWJsZSB0byBmaWxsIHRoZSBidWZmZXIgaG9sZSAuLi4pXG4gICAgICAgICAgICBpZiAoZGVsdGFQVFMgJiYgZGVsdGFQVFMgPiBjb25maWcubWF4QnVmZmVySG9sZSAmJiBmcmFnUHJldmlvdXMuZHJvcHBlZCAmJiBjdXJTTklkeCkge1xuICAgICAgICAgICAgICBmcmFnID0gcHJldkZyYWc7XG4gICAgICAgICAgICAgIGxvZ2dlci53YXJuKGBTTiBqdXN0IGxvYWRlZCwgd2l0aCBsYXJnZSBQVFMgZ2FwIGJldHdlZW4gYXVkaW8gYW5kIHZpZGVvLCBtYXliZSBmcmFnIGlzIG5vdCBzdGFydGluZyB3aXRoIGEga2V5ZnJhbWUgPyBsb2FkIHByZXZpb3VzIG9uZSB0byB0cnkgdG8gb3ZlcmNvbWUgdGhpc2ApO1xuICAgICAgICAgICAgICAvLyBkZWNyZW1lbnQgcHJldmlvdXMgZnJhZyBsb2FkIGNvdW50ZXIgdG8gYXZvaWQgZnJhZyBsb29wIGxvYWRpbmcgZXJyb3Igd2hlbiBuZXh0IGZyYWdtZW50IHdpbGwgZ2V0IHJlbG9hZGVkXG4gICAgICAgICAgICAgIGZyYWdQcmV2aW91cy5sb2FkQ291bnRlci0tO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZnJhZyA9IG5leHRGcmFnO1xuICAgICAgICAgICAgICBsb2dnZXIubG9nKGBTTiBqdXN0IGxvYWRlZCwgbG9hZCBuZXh0IG9uZTogJHtmcmFnLnNufWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmcmFnID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZnJhZy5kcm9wcGVkICYmICFzYW1lTGV2ZWwpIHtcbiAgICAgICAgIC8vIE9ubHkgYmFja3RyYWNrIGEgbWF4IG9mIDEgY29uc2VjdXRpdmUgZnJhZ21lbnQgdG8gcHJldmVudCBzbGlkaW5nIGJhY2sgdG9vIGZhciB3aGVuIGxpdHRsZSBvciBubyBmcmFncyBzdGFydCB3aXRoIGtleWZyYW1lc1xuICAgICAgICAgaWYgKG5leHRGcmFnICYmIG5leHRGcmFnLmJhY2t0cmFja2VkKSB7XG4gICAgICAgICAgIGxvZ2dlci53YXJuKGBBbHJlYWR5IGJhY2t0cmFja2VkIGZyb20gZnJhZ21lbnQgJHtjdXJTTklkeCArIDF9LCB3aWxsIG5vdCBiYWNrdHJhY2sgdG8gZnJhZ21lbnQgJHtjdXJTTklkeH0uIExvYWRpbmcgZnJhZ21lbnQgJHtjdXJTTklkeCArIDF9YCk7XG4gICAgICAgICAgIGZyYWcgPSBuZXh0RnJhZztcbiAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgIC8vIElmIGEgZnJhZ21lbnQgaGFzIGRyb3BwZWQgZnJhbWVzIGFuZCBpdCdzIGluIGEgZGlmZmVyZW50IGxldmVsL3NlcXVlbmNlLCBsb2FkIHRoZSBwcmV2aW91cyBmcmFnbWVudCB0byB0cnkgYW5kIGZpbmQgdGhlIGtleWZyYW1lXG4gICAgICAgICAgIC8vIFJlc2V0IHRoZSBkcm9wcGVkIGNvdW50IG5vdyBzaW5jZSBpdCB3b24ndCBiZSByZXNldCB1bnRpbCB3ZSBwYXJzZSB0aGUgZnJhZ21lbnQgYWdhaW4sIHdoaWNoIHByZXZlbnRzIGluZmluaXRlIGJhY2t0cmFja2luZyBvbiB0aGUgc2FtZSBzZWdtZW50XG4gICAgICAgICAgIGxvZ2dlci53YXJuKCdMb2FkZWQgZnJhZ21lbnQgd2l0aCBkcm9wcGVkIGZyYW1lcywgYmFja3RyYWNraW5nIDEgc2VnbWVudCB0byBmaW5kIGEga2V5ZnJhbWUnKTtcbiAgICAgICAgICAgZnJhZy5kcm9wcGVkID0gMDtcbiAgICAgICAgICAgaWYgKHByZXZGcmFnICYmIHByZXZGcmFnLmxvYWRDb3VudGVyKSB7XG4gICAgICAgICAgICAgcHJldkZyYWcubG9hZENvdW50ZXItLTtcbiAgICAgICAgICAgICBmcmFnID0gcHJldkZyYWc7XG4gICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgZnJhZyA9IG51bGw7XG4gICAgICAgICAgIH1cbiAgICAgICAgIH1cbiAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmcmFnO1xuICB9XG5cbiAgX2xvYWRGcmFnbWVudE9yS2V5KHtmcmFnLCBsZXZlbCwgbGV2ZWxEZXRhaWxzLCBwb3MsIGJ1ZmZlckVuZH0pIHtcbiAgICBjb25zdCBobHMgPSB0aGlzLmhscyxcbiAgICAgICAgICBjb25maWcgPSBobHMuY29uZmlnO1xuXG4gICAgLy9sb2dnZXIubG9nKCdsb2FkaW5nIGZyYWcgJyArIGkgKycscG9zL2J1ZkVuZDonICsgcG9zLnRvRml4ZWQoMykgKyAnLycgKyBidWZmZXJFbmQudG9GaXhlZCgzKSk7XG4gICAgaWYgKChmcmFnLmRlY3J5cHRkYXRhLnVyaSAhPSBudWxsKSAmJiAoZnJhZy5kZWNyeXB0ZGF0YS5rZXkgPT0gbnVsbCkpIHtcbiAgICAgIGxvZ2dlci5sb2coYExvYWRpbmcga2V5IGZvciAke2ZyYWcuc259IG9mIFske2xldmVsRGV0YWlscy5zdGFydFNOfSAsJHtsZXZlbERldGFpbHMuZW5kU059XSxsZXZlbCAke2xldmVsfWApO1xuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLktFWV9MT0FESU5HO1xuICAgICAgaGxzLnRyaWdnZXIoRXZlbnQuS0VZX0xPQURJTkcsIHtmcmFnOiBmcmFnfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvZ2dlci5sb2coYExvYWRpbmcgJHtmcmFnLnNufSBvZiBbJHtsZXZlbERldGFpbHMuc3RhcnRTTn0gLCR7bGV2ZWxEZXRhaWxzLmVuZFNOfV0sbGV2ZWwgJHtsZXZlbH0sIGN1cnJlbnRUaW1lOiR7cG9zLnRvRml4ZWQoMyl9LGJ1ZmZlckVuZDoke2J1ZmZlckVuZC50b0ZpeGVkKDMpfWApO1xuICAgICAgLy8gZW5zdXJlIHRoYXQgd2UgYXJlIG5vdCByZWxvYWRpbmcgdGhlIHNhbWUgZnJhZ21lbnRzIGluIGxvb3AgLi4uXG4gICAgICBpZiAodGhpcy5mcmFnTG9hZElkeCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuZnJhZ0xvYWRJZHgrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZnJhZ0xvYWRJZHggPSAwO1xuICAgICAgfVxuICAgICAgaWYgKGZyYWcubG9hZENvdW50ZXIpIHtcbiAgICAgICAgZnJhZy5sb2FkQ291bnRlcisrO1xuICAgICAgICBsZXQgbWF4VGhyZXNob2xkID0gY29uZmlnLmZyYWdMb2FkaW5nTG9vcFRocmVzaG9sZDtcbiAgICAgICAgLy8gaWYgdGhpcyBmcmFnIGhhcyBhbHJlYWR5IGJlZW4gbG9hZGVkIDMgdGltZXMsIGFuZCBpZiBpdCBoYXMgYmVlbiByZWxvYWRlZCByZWNlbnRseVxuICAgICAgICBpZiAoZnJhZy5sb2FkQ291bnRlciA+IG1heFRocmVzaG9sZCAmJiAoTWF0aC5hYnModGhpcy5mcmFnTG9hZElkeCAtIGZyYWcubG9hZElkeCkgPCBtYXhUaHJlc2hvbGQpKSB7XG4gICAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnQuRVJST1IsIHt0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLCBkZXRhaWxzOiBFcnJvckRldGFpbHMuRlJBR19MT09QX0xPQURJTkdfRVJST1IsIGZhdGFsOiBmYWxzZSwgZnJhZzogZnJhZ30pO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZnJhZy5sb2FkQ291bnRlciA9IDE7XG4gICAgICB9XG4gICAgICBmcmFnLmxvYWRJZHggPSB0aGlzLmZyYWdMb2FkSWR4O1xuICAgICAgdGhpcy5mcmFnQ3VycmVudCA9IGZyYWc7XG4gICAgICB0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCA9IHRydWU7XG4gICAgICB0aGlzLm5leHRMb2FkUG9zaXRpb24gPSBmcmFnLnN0YXJ0ICsgZnJhZy5kdXJhdGlvbjtcbiAgICAgIGZyYWcuYXV0b0xldmVsID0gaGxzLmF1dG9MZXZlbEVuYWJsZWQ7XG4gICAgICBmcmFnLmJpdHJhdGVUZXN0ID0gdGhpcy5iaXRyYXRlVGVzdDtcbiAgICAgIGhscy50cmlnZ2VyKEV2ZW50LkZSQUdfTE9BRElORywge2ZyYWc6IGZyYWd9KTtcbiAgICAgIC8vIGxhenkgZGVtdXhlciBpbml0LCBhcyB0aGlzIGNvdWxkIHRha2Ugc29tZSB0aW1lIC4uLiBkbyBpdCBkdXJpbmcgZnJhZyBsb2FkaW5nXG4gICAgICBpZiAoIXRoaXMuZGVtdXhlcikge1xuICAgICAgICB0aGlzLmRlbXV4ZXIgPSBuZXcgRGVtdXhlcihobHMsJ21haW4nKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5GUkFHX0xPQURJTkc7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBzZXQgc3RhdGUobmV4dFN0YXRlKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUgIT09IG5leHRTdGF0ZSkge1xuICAgICAgY29uc3QgcHJldmlvdXNTdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgICB0aGlzLl9zdGF0ZSA9IG5leHRTdGF0ZTtcbiAgICAgIGxvZ2dlci5sb2coYGVuZ2luZSBzdGF0ZSB0cmFuc2l0aW9uIGZyb20gJHtwcmV2aW91c1N0YXRlfSB0byAke25leHRTdGF0ZX1gKTtcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuU1RSRUFNX1NUQVRFX1RSQU5TSVRJT04sIHtwcmV2aW91c1N0YXRlLCBuZXh0U3RhdGV9KTtcbiAgICB9XG4gIH1cblxuICBnZXQgc3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXRlO1xuICB9XG5cbiAgZ2V0QnVmZmVyUmFuZ2UocG9zaXRpb24pIHtcbiAgICB2YXIgaSwgcmFuZ2UsXG4gICAgICAgIGJ1ZmZlclJhbmdlID0gdGhpcy5idWZmZXJSYW5nZTtcbiAgICBpZiAoYnVmZmVyUmFuZ2UpIHtcbiAgICAgIGZvciAoaSA9IGJ1ZmZlclJhbmdlLmxlbmd0aCAtIDE7IGkgPj0wOyBpLS0pIHtcbiAgICAgICAgcmFuZ2UgPSBidWZmZXJSYW5nZVtpXTtcbiAgICAgICAgaWYgKHBvc2l0aW9uID49IHJhbmdlLnN0YXJ0ICYmIHBvc2l0aW9uIDw9IHJhbmdlLmVuZCkge1xuICAgICAgICAgIHJldHVybiByYW5nZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGdldCBjdXJyZW50TGV2ZWwoKSB7XG4gICAgbGV0IG1lZGlhID0gdGhpcy5tZWRpYTtcbiAgICBpZiAobWVkaWEpIHtcbiAgICAgIHZhciByYW5nZSA9IHRoaXMuZ2V0QnVmZmVyUmFuZ2UobWVkaWEuY3VycmVudFRpbWUpO1xuICAgICAgaWYgKHJhbmdlKSB7XG4gICAgICAgIHJldHVybiByYW5nZS5mcmFnLmxldmVsO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICBnZXQgbmV4dEJ1ZmZlclJhbmdlKCkge1xuICAgIGxldCBtZWRpYSA9IHRoaXMubWVkaWE7XG4gICAgaWYgKG1lZGlhKSB7XG4gICAgICAvLyBmaXJzdCBnZXQgZW5kIHJhbmdlIG9mIGN1cnJlbnQgZnJhZ21lbnRcbiAgICAgIHJldHVybiB0aGlzLmZvbGxvd2luZ0J1ZmZlclJhbmdlKHRoaXMuZ2V0QnVmZmVyUmFuZ2UobWVkaWEuY3VycmVudFRpbWUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgZm9sbG93aW5nQnVmZmVyUmFuZ2UocmFuZ2UpIHtcbiAgICBpZiAocmFuZ2UpIHtcbiAgICAgIC8vIHRyeSB0byBnZXQgcmFuZ2Ugb2YgbmV4dCBmcmFnbWVudCAoNTAwbXMgYWZ0ZXIgdGhpcyByYW5nZSlcbiAgICAgIHJldHVybiB0aGlzLmdldEJ1ZmZlclJhbmdlKHJhbmdlLmVuZCArIDAuNSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZ2V0IG5leHRMZXZlbCgpIHtcbiAgICB2YXIgcmFuZ2UgPSB0aGlzLm5leHRCdWZmZXJSYW5nZTtcbiAgICBpZiAocmFuZ2UpIHtcbiAgICAgIHJldHVybiByYW5nZS5mcmFnLmxldmVsO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICB9XG5cbiAgX2NoZWNrRnJhZ21lbnRDaGFuZ2VkKCkge1xuICAgIHZhciByYW5nZUN1cnJlbnQsIGN1cnJlbnRUaW1lLCB2aWRlbyA9IHRoaXMubWVkaWE7XG4gICAgaWYgKHZpZGVvICYmIHZpZGVvLnJlYWR5U3RhdGUgJiYgdmlkZW8uc2Vla2luZyA9PT0gZmFsc2UpIHtcbiAgICAgIGN1cnJlbnRUaW1lID0gdmlkZW8uY3VycmVudFRpbWU7XG4gICAgICAvKiBpZiB2aWRlbyBlbGVtZW50IGlzIGluIHNlZWtlZCBzdGF0ZSwgY3VycmVudFRpbWUgY2FuIG9ubHkgaW5jcmVhc2UuXG4gICAgICAgIChhc3N1bWluZyB0aGF0IHBsYXliYWNrIHJhdGUgaXMgcG9zaXRpdmUgLi4uKVxuICAgICAgICBBcyBzb21ldGltZXMgY3VycmVudFRpbWUganVtcHMgYmFjayB0byB6ZXJvIGFmdGVyIGFcbiAgICAgICAgbWVkaWEgZGVjb2RlIGVycm9yLCBjaGVjayB0aGlzLCB0byBhdm9pZCBzZWVraW5nIGJhY2sgdG9cbiAgICAgICAgd3JvbmcgcG9zaXRpb24gYWZ0ZXIgYSBtZWRpYSBkZWNvZGUgZXJyb3JcbiAgICAgICovXG4gICAgICBpZihjdXJyZW50VGltZSA+IHZpZGVvLnBsYXliYWNrUmF0ZSp0aGlzLmxhc3RDdXJyZW50VGltZSkge1xuICAgICAgICB0aGlzLmxhc3RDdXJyZW50VGltZSA9IGN1cnJlbnRUaW1lO1xuICAgICAgfVxuICAgICAgaWYgKEJ1ZmZlckhlbHBlci5pc0J1ZmZlcmVkKHZpZGVvLGN1cnJlbnRUaW1lKSkge1xuICAgICAgICByYW5nZUN1cnJlbnQgPSB0aGlzLmdldEJ1ZmZlclJhbmdlKGN1cnJlbnRUaW1lKTtcbiAgICAgIH0gZWxzZSBpZiAoQnVmZmVySGVscGVyLmlzQnVmZmVyZWQodmlkZW8sY3VycmVudFRpbWUgKyAwLjEpKSB7XG4gICAgICAgIC8qIGVuc3VyZSB0aGF0IEZSQUdfQ0hBTkdFRCBldmVudCBpcyB0cmlnZ2VyZWQgYXQgc3RhcnR1cCxcbiAgICAgICAgICB3aGVuIGZpcnN0IHZpZGVvIGZyYW1lIGlzIGRpc3BsYXllZCBhbmQgcGxheWJhY2sgaXMgcGF1c2VkLlxuICAgICAgICAgIGFkZCBhIHRvbGVyYW5jZSBvZiAxMDBtcywgaW4gY2FzZSBjdXJyZW50IHBvc2l0aW9uIGlzIG5vdCBidWZmZXJlZCxcbiAgICAgICAgICBjaGVjayBpZiBjdXJyZW50IHBvcysxMDBtcyBpcyBidWZmZXJlZCBhbmQgdXNlIHRoYXQgYnVmZmVyIHJhbmdlXG4gICAgICAgICAgZm9yIEZSQUdfQ0hBTkdFRCBldmVudCByZXBvcnRpbmcgKi9cbiAgICAgICAgcmFuZ2VDdXJyZW50ID0gdGhpcy5nZXRCdWZmZXJSYW5nZShjdXJyZW50VGltZSArIDAuMSk7XG4gICAgICB9XG4gICAgICBpZiAocmFuZ2VDdXJyZW50KSB7XG4gICAgICAgIHZhciBmcmFnUGxheWluZyA9IHJhbmdlQ3VycmVudC5mcmFnO1xuICAgICAgICBpZiAoZnJhZ1BsYXlpbmcgIT09IHRoaXMuZnJhZ1BsYXlpbmcpIHtcbiAgICAgICAgICB0aGlzLmZyYWdQbGF5aW5nID0gZnJhZ1BsYXlpbmc7XG4gICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5GUkFHX0NIQU5HRUQsIHtmcmFnOiBmcmFnUGxheWluZ30pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLypcbiAgICBvbiBpbW1lZGlhdGUgbGV2ZWwgc3dpdGNoIDpcbiAgICAgLSBwYXVzZSBwbGF5YmFjayBpZiBwbGF5aW5nXG4gICAgIC0gY2FuY2VsIGFueSBwZW5kaW5nIGxvYWQgcmVxdWVzdFxuICAgICAtIGFuZCB0cmlnZ2VyIGEgYnVmZmVyIGZsdXNoXG4gICovXG4gIGltbWVkaWF0ZUxldmVsU3dpdGNoKCkge1xuICAgIGxvZ2dlci5sb2coJ2ltbWVkaWF0ZUxldmVsU3dpdGNoJyk7XG4gICAgaWYgKCF0aGlzLmltbWVkaWF0ZVN3aXRjaCkge1xuICAgICAgdGhpcy5pbW1lZGlhdGVTd2l0Y2ggPSB0cnVlO1xuICAgICAgbGV0IG1lZGlhID0gdGhpcy5tZWRpYSwgcHJldmlvdXNseVBhdXNlZDtcbiAgICAgIGlmIChtZWRpYSkge1xuICAgICAgICBwcmV2aW91c2x5UGF1c2VkID0gbWVkaWEucGF1c2VkO1xuICAgICAgICBtZWRpYS5wYXVzZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZG9uJ3QgcmVzdGFydCBwbGF5YmFjayBhZnRlciBpbnN0YW50IGxldmVsIHN3aXRjaCBpbiBjYXNlIG1lZGlhIG5vdCBhdHRhY2hlZFxuICAgICAgICBwcmV2aW91c2x5UGF1c2VkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHRoaXMucHJldmlvdXNseVBhdXNlZCA9IHByZXZpb3VzbHlQYXVzZWQ7XG4gICAgfVxuICAgIHZhciBmcmFnQ3VycmVudCA9IHRoaXMuZnJhZ0N1cnJlbnQ7XG4gICAgaWYgKGZyYWdDdXJyZW50ICYmIGZyYWdDdXJyZW50LmxvYWRlcikge1xuICAgICAgZnJhZ0N1cnJlbnQubG9hZGVyLmFib3J0KCk7XG4gICAgfVxuICAgIHRoaXMuZnJhZ0N1cnJlbnQgPSBudWxsO1xuICAgIC8vIGluY3JlYXNlIGZyYWdtZW50IGxvYWQgSW5kZXggdG8gYXZvaWQgZnJhZyBsb29wIGxvYWRpbmcgZXJyb3IgYWZ0ZXIgYnVmZmVyIGZsdXNoXG4gICAgdGhpcy5mcmFnTG9hZElkeCArPSAyICogdGhpcy5jb25maWcuZnJhZ0xvYWRpbmdMb29wVGhyZXNob2xkO1xuICAgIC8vIGZsdXNoIGV2ZXJ5dGhpbmdcbiAgICB0aGlzLmZsdXNoTWFpbkJ1ZmZlcigwLE51bWJlci5QT1NJVElWRV9JTkZJTklUWSk7XG4gIH1cblxuICAvKlxuICAgICBvbiBpbW1lZGlhdGUgbGV2ZWwgc3dpdGNoIGVuZCwgYWZ0ZXIgbmV3IGZyYWdtZW50IGhhcyBiZWVuIGJ1ZmZlcmVkIDpcbiAgICAgIC0gbnVkZ2UgdmlkZW8gZGVjb2RlciBieSBzbGlnaHRseSBhZGp1c3RpbmcgdmlkZW8gY3VycmVudFRpbWUgKGlmIGN1cnJlbnRUaW1lIGJ1ZmZlcmVkKVxuICAgICAgLSByZXN1bWUgdGhlIHBsYXliYWNrIGlmIG5lZWRlZFxuICAqL1xuICBpbW1lZGlhdGVMZXZlbFN3aXRjaEVuZCgpIHtcbiAgICBsZXQgbWVkaWEgPSB0aGlzLm1lZGlhO1xuICAgIGlmIChtZWRpYSAmJiBtZWRpYS5idWZmZXJlZC5sZW5ndGgpIHtcbiAgICAgIHRoaXMuaW1tZWRpYXRlU3dpdGNoID0gZmFsc2U7XG4gICAgICBpZihCdWZmZXJIZWxwZXIuaXNCdWZmZXJlZChtZWRpYSxtZWRpYS5jdXJyZW50VGltZSkpIHtcbiAgICAgICAgLy8gb25seSBudWRnZSBpZiBjdXJyZW50VGltZSBpcyBidWZmZXJlZFxuICAgICAgICBtZWRpYS5jdXJyZW50VGltZSAtPSAwLjAwMDE7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMucHJldmlvdXNseVBhdXNlZCkge1xuICAgICAgICBtZWRpYS5wbGF5KCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgbmV4dExldmVsU3dpdGNoKCkge1xuICAgIC8qIHRyeSB0byBzd2l0Y2ggQVNBUCB3aXRob3V0IGJyZWFraW5nIHZpZGVvIHBsYXliYWNrIDpcbiAgICAgICBpbiBvcmRlciB0byBlbnN1cmUgc21vb3RoIGJ1dCBxdWljayBsZXZlbCBzd2l0Y2hpbmcsXG4gICAgICB3ZSBuZWVkIHRvIGZpbmQgdGhlIG5leHQgZmx1c2hhYmxlIGJ1ZmZlciByYW5nZVxuICAgICAgd2Ugc2hvdWxkIHRha2UgaW50byBhY2NvdW50IG5ldyBzZWdtZW50IGZldGNoIHRpbWVcbiAgICAqL1xuICAgIGxldCBtZWRpYSA9IHRoaXMubWVkaWE7XG4gICAgLy8gZW5zdXJlIHRoYXQgbWVkaWEgaXMgZGVmaW5lZCBhbmQgdGhhdCBtZXRhZGF0YSBhcmUgYXZhaWxhYmxlICh0byByZXRyaWV2ZSBjdXJyZW50VGltZSlcbiAgICBpZiAobWVkaWEgJiYgbWVkaWEucmVhZHlTdGF0ZSkge1xuICAgICAgbGV0IGZldGNoZGVsYXksIGN1cnJlbnRSYW5nZSwgbmV4dFJhbmdlO1xuICAgICAgLy8gaW5jcmVhc2UgZnJhZ21lbnQgbG9hZCBJbmRleCB0byBhdm9pZCBmcmFnIGxvb3AgbG9hZGluZyBlcnJvciBhZnRlciBidWZmZXIgZmx1c2hcbiAgICAgIHRoaXMuZnJhZ0xvYWRJZHggKz0gMiAqIHRoaXMuY29uZmlnLmZyYWdMb2FkaW5nTG9vcFRocmVzaG9sZDtcbiAgICAgIGN1cnJlbnRSYW5nZSA9IHRoaXMuZ2V0QnVmZmVyUmFuZ2UobWVkaWEuY3VycmVudFRpbWUpO1xuICAgICAgaWYgKGN1cnJlbnRSYW5nZSAmJiBjdXJyZW50UmFuZ2Uuc3RhcnQgPiAxKSB7XG4gICAgICAgIC8vIGZsdXNoIGJ1ZmZlciBwcmVjZWRpbmcgY3VycmVudCBmcmFnbWVudCAoZmx1c2ggdW50aWwgY3VycmVudCBmcmFnbWVudCBzdGFydCBvZmZzZXQpXG4gICAgICAgIC8vIG1pbnVzIDFzIHRvIGF2b2lkIHZpZGVvIGZyZWV6aW5nLCB0aGF0IGNvdWxkIGhhcHBlbiBpZiB3ZSBmbHVzaCBrZXlmcmFtZSBvZiBjdXJyZW50IHZpZGVvIC4uLlxuICAgICAgICB0aGlzLmZsdXNoTWFpbkJ1ZmZlcigwLGN1cnJlbnRSYW5nZS5zdGFydCAtIDEpO1xuICAgICAgfVxuICAgICAgaWYgKCFtZWRpYS5wYXVzZWQpIHtcbiAgICAgICAgLy8gYWRkIGEgc2FmZXR5IGRlbGF5IG9mIDFzXG4gICAgICAgIHZhciBuZXh0TGV2ZWxJZCA9IHRoaXMuaGxzLm5leHRMb2FkTGV2ZWwsbmV4dExldmVsID0gdGhpcy5sZXZlbHNbbmV4dExldmVsSWRdLCBmcmFnTGFzdEticHMgPSB0aGlzLmZyYWdMYXN0S2JwcztcbiAgICAgICAgaWYgKGZyYWdMYXN0S2JwcyAmJiB0aGlzLmZyYWdDdXJyZW50KSB7XG4gICAgICAgICAgZmV0Y2hkZWxheSA9IHRoaXMuZnJhZ0N1cnJlbnQuZHVyYXRpb24gKiBuZXh0TGV2ZWwuYml0cmF0ZSAvICgxMDAwICogZnJhZ0xhc3RLYnBzKSArIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZmV0Y2hkZWxheSA9IDA7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZldGNoZGVsYXkgPSAwO1xuICAgICAgfVxuICAgICAgLy9sb2dnZXIubG9nKCdmZXRjaGRlbGF5OicrZmV0Y2hkZWxheSk7XG4gICAgICAvLyBmaW5kIGJ1ZmZlciByYW5nZSB0aGF0IHdpbGwgYmUgcmVhY2hlZCBvbmNlIG5ldyBmcmFnbWVudCB3aWxsIGJlIGZldGNoZWRcbiAgICAgIG5leHRSYW5nZSA9IHRoaXMuZ2V0QnVmZmVyUmFuZ2UobWVkaWEuY3VycmVudFRpbWUgKyBmZXRjaGRlbGF5KTtcbiAgICAgIGlmIChuZXh0UmFuZ2UpIHtcbiAgICAgICAgLy8gd2UgY2FuIGZsdXNoIGJ1ZmZlciByYW5nZSBmb2xsb3dpbmcgdGhpcyBvbmUgd2l0aG91dCBzdGFsbGluZyBwbGF5YmFja1xuICAgICAgICBuZXh0UmFuZ2UgPSB0aGlzLmZvbGxvd2luZ0J1ZmZlclJhbmdlKG5leHRSYW5nZSk7XG4gICAgICAgIGlmIChuZXh0UmFuZ2UpIHtcbiAgICAgICAgICAvLyBpZiB3ZSBhcmUgaGVyZSwgd2UgY2FuIGFsc28gY2FuY2VsIGFueSBsb2FkaW5nL2RlbXV4aW5nIGluIHByb2dyZXNzLCBhcyB0aGV5IGFyZSB1c2VsZXNzXG4gICAgICAgICAgdmFyIGZyYWdDdXJyZW50ID0gdGhpcy5mcmFnQ3VycmVudDtcbiAgICAgICAgICBpZiAoZnJhZ0N1cnJlbnQgJiYgZnJhZ0N1cnJlbnQubG9hZGVyKSB7XG4gICAgICAgICAgICBmcmFnQ3VycmVudC5sb2FkZXIuYWJvcnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5mcmFnQ3VycmVudCA9IG51bGw7XG4gICAgICAgICAgLy8gZmx1c2ggcG9zaXRpb24gaXMgdGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoaXMgbmV3IGJ1ZmZlclxuICAgICAgICAgIHRoaXMuZmx1c2hNYWluQnVmZmVyKG5leHRSYW5nZS5zdGFydCAsIE51bWJlci5QT1NJVElWRV9JTkZJTklUWSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmbHVzaE1haW5CdWZmZXIoc3RhcnRPZmZzZXQsZW5kT2Zmc2V0KSB7XG4gICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkJVRkZFUl9GTFVTSElORztcbiAgICBsZXQgZmx1c2hTY29wZSA9IHtzdGFydE9mZnNldDogc3RhcnRPZmZzZXQsIGVuZE9mZnNldDogZW5kT2Zmc2V0fTtcbiAgICAvLyBpZiBhbHRlcm5hdGUgYXVkaW8gdHJhY2tzIGFyZSB1c2VkLCBvbmx5IGZsdXNoIHZpZGVvLCBvdGhlcndpc2UgZmx1c2ggZXZlcnl0aGluZ1xuICAgIGlmICh0aGlzLmFsdEF1ZGlvKSB7XG4gICAgICBmbHVzaFNjb3BlLnR5cGUgPSAndmlkZW8nO1xuICAgIH1cbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkJVRkZFUl9GTFVTSElORywgZmx1c2hTY29wZSk7XG4gIH1cblxuICBvbk1lZGlhQXR0YWNoZWQoZGF0YSkge1xuICAgIHZhciBtZWRpYSA9IHRoaXMubWVkaWEgPSB0aGlzLm1lZGlhQnVmZmVyID0gZGF0YS5tZWRpYTtcbiAgICB0aGlzLm9udnNlZWtpbmcgPSB0aGlzLm9uTWVkaWFTZWVraW5nLmJpbmQodGhpcyk7XG4gICAgdGhpcy5vbnZzZWVrZWQgPSB0aGlzLm9uTWVkaWFTZWVrZWQuYmluZCh0aGlzKTtcbiAgICB0aGlzLm9udmVuZGVkID0gdGhpcy5vbk1lZGlhRW5kZWQuYmluZCh0aGlzKTtcbiAgICBtZWRpYS5hZGRFdmVudExpc3RlbmVyKCdzZWVraW5nJywgdGhpcy5vbnZzZWVraW5nKTtcbiAgICBtZWRpYS5hZGRFdmVudExpc3RlbmVyKCdzZWVrZWQnLCB0aGlzLm9udnNlZWtlZCk7XG4gICAgbWVkaWEuYWRkRXZlbnRMaXN0ZW5lcignZW5kZWQnLCB0aGlzLm9udmVuZGVkKTtcbiAgICBsZXQgY29uZmlnID0gdGhpcy5jb25maWc7XG4gICAgaWYodGhpcy5sZXZlbHMgJiYgY29uZmlnLmF1dG9TdGFydExvYWQpIHtcbiAgICAgIHRoaXMuaGxzLnN0YXJ0TG9hZChjb25maWcuc3RhcnRQb3NpdGlvbik7XG4gICAgfVxuICB9XG5cbiAgb25NZWRpYURldGFjaGluZygpIHtcbiAgICB2YXIgbWVkaWEgPSB0aGlzLm1lZGlhO1xuICAgIGlmIChtZWRpYSAmJiBtZWRpYS5lbmRlZCkge1xuICAgICAgbG9nZ2VyLmxvZygnTVNFIGRldGFjaGluZyBhbmQgdmlkZW8gZW5kZWQsIHJlc2V0IHN0YXJ0UG9zaXRpb24nKTtcbiAgICAgIHRoaXMuc3RhcnRQb3NpdGlvbiA9IHRoaXMubGFzdEN1cnJlbnRUaW1lID0gMDtcbiAgICB9XG5cbiAgICAvLyByZXNldCBmcmFnbWVudCBsb2FkaW5nIGNvdW50ZXIgb24gTVNFIGRldGFjaGluZyB0byBhdm9pZCByZXBvcnRpbmcgRlJBR19MT09QX0xPQURJTkdfRVJST1IgYWZ0ZXIgZXJyb3IgcmVjb3ZlcnlcbiAgICB2YXIgbGV2ZWxzID0gdGhpcy5sZXZlbHM7XG4gICAgaWYgKGxldmVscykge1xuICAgICAgLy8gcmVzZXQgZnJhZ21lbnQgbG9hZCBjb3VudGVyXG4gICAgICAgIGxldmVscy5mb3JFYWNoKGxldmVsID0+IHtcbiAgICAgICAgICBpZihsZXZlbC5kZXRhaWxzKSB7XG4gICAgICAgICAgICBsZXZlbC5kZXRhaWxzLmZyYWdtZW50cy5mb3JFYWNoKGZyYWdtZW50ID0+IHtcbiAgICAgICAgICAgICAgZnJhZ21lbnQubG9hZENvdW50ZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgIGZyYWdtZW50LmJhY2t0cmFja2VkID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIC8vIHJlbW92ZSB2aWRlbyBsaXN0ZW5lcnNcbiAgICBpZiAobWVkaWEpIHtcbiAgICAgIG1lZGlhLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3NlZWtpbmcnLCB0aGlzLm9udnNlZWtpbmcpO1xuICAgICAgbWVkaWEucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Vla2VkJywgdGhpcy5vbnZzZWVrZWQpO1xuICAgICAgbWVkaWEucmVtb3ZlRXZlbnRMaXN0ZW5lcignZW5kZWQnLCB0aGlzLm9udmVuZGVkKTtcbiAgICAgIHRoaXMub252c2Vla2luZyA9IHRoaXMub252c2Vla2VkICA9IHRoaXMub252ZW5kZWQgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLm1lZGlhID0gdGhpcy5tZWRpYUJ1ZmZlciA9IG51bGw7XG4gICAgdGhpcy5sb2FkZWRtZXRhZGF0YSA9IGZhbHNlO1xuICAgIHRoaXMuc3RvcExvYWQoKTtcbiAgfVxuXG4gIG9uTWVkaWFTZWVraW5nKCkge1xuICAgIGxldCBtZWRpYSA9IHRoaXMubWVkaWEsIGN1cnJlbnRUaW1lID0gbWVkaWEgPyBtZWRpYS5jdXJyZW50VGltZSA6IHVuZGVmaW5lZCwgY29uZmlnID0gdGhpcy5jb25maWc7XG4gICAgbG9nZ2VyLmxvZyhgbWVkaWEgc2Vla2luZyB0byAke2N1cnJlbnRUaW1lLnRvRml4ZWQoMyl9YCk7XG4gICAgaWYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLkZSQUdfTE9BRElORykge1xuICAgICAgbGV0IGJ1ZmZlckluZm8gPSBCdWZmZXJIZWxwZXIuYnVmZmVySW5mbyhtZWRpYSxjdXJyZW50VGltZSx0aGlzLmNvbmZpZy5tYXhCdWZmZXJIb2xlKSxcbiAgICAgICAgICBmcmFnQ3VycmVudCA9IHRoaXMuZnJhZ0N1cnJlbnQ7XG4gICAgICAvLyBjaGVjayBpZiB3ZSBhcmUgc2Vla2luZyB0byBhIHVuYnVmZmVyZWQgYXJlYSBBTkQgaWYgZnJhZyBsb2FkaW5nIGlzIGluIHByb2dyZXNzXG4gICAgICBpZiAoYnVmZmVySW5mby5sZW4gPT09IDAgJiYgZnJhZ0N1cnJlbnQpIHtcbiAgICAgICAgbGV0IHRvbGVyYW5jZSA9IGNvbmZpZy5tYXhGcmFnTG9va1VwVG9sZXJhbmNlLFxuICAgICAgICAgICAgZnJhZ1N0YXJ0T2Zmc2V0ID0gZnJhZ0N1cnJlbnQuc3RhcnQgLSB0b2xlcmFuY2UsXG4gICAgICAgICAgICBmcmFnRW5kT2Zmc2V0ID0gZnJhZ0N1cnJlbnQuc3RhcnQgKyBmcmFnQ3VycmVudC5kdXJhdGlvbiArIHRvbGVyYW5jZTtcbiAgICAgICAgLy8gY2hlY2sgaWYgd2Ugc2VlayBwb3NpdGlvbiB3aWxsIGJlIG91dCBvZiBjdXJyZW50bHkgbG9hZGVkIGZyYWcgcmFuZ2UgOiBpZiBvdXQgY2FuY2VsIGZyYWcgbG9hZCwgaWYgaW4sIGRvbid0IGRvIGFueXRoaW5nXG4gICAgICAgIGlmIChjdXJyZW50VGltZSA8IGZyYWdTdGFydE9mZnNldCB8fCBjdXJyZW50VGltZSA+IGZyYWdFbmRPZmZzZXQpIHtcbiAgICAgICAgICBpZiAoZnJhZ0N1cnJlbnQubG9hZGVyKSB7XG4gICAgICAgICAgICBsb2dnZXIubG9nKCdzZWVraW5nIG91dHNpZGUgb2YgYnVmZmVyIHdoaWxlIGZyYWdtZW50IGxvYWQgaW4gcHJvZ3Jlc3MsIGNhbmNlbCBmcmFnbWVudCBsb2FkJyk7XG4gICAgICAgICAgICBmcmFnQ3VycmVudC5sb2FkZXIuYWJvcnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5mcmFnQ3VycmVudCA9IG51bGw7XG4gICAgICAgICAgdGhpcy5mcmFnUHJldmlvdXMgPSBudWxsO1xuICAgICAgICAgIC8vIHN3aXRjaCB0byBJRExFIHN0YXRlIHRvIGxvYWQgbmV3IGZyYWdtZW50XG4gICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbG9nZ2VyLmxvZygnc2Vla2luZyBvdXRzaWRlIG9mIGJ1ZmZlciBidXQgd2l0aGluIGN1cnJlbnRseSBsb2FkZWQgZnJhZ21lbnQgcmFuZ2UnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuRU5ERUQpIHtcbiAgICAgICAgLy8gc3dpdGNoIHRvIElETEUgc3RhdGUgdG8gY2hlY2sgZm9yIHBvdGVudGlhbCBuZXcgZnJhZ21lbnRcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgfVxuICAgIGlmIChtZWRpYSkge1xuICAgICAgdGhpcy5sYXN0Q3VycmVudFRpbWUgPSBjdXJyZW50VGltZTtcbiAgICB9XG4gICAgLy8gYXZvaWQgcmVwb3J0aW5nIGZyYWdtZW50IGxvb3AgbG9hZGluZyBlcnJvciBpbiBjYXNlIHVzZXIgaXMgc2Vla2luZyBzZXZlcmFsIHRpbWVzIG9uIHNhbWUgcG9zaXRpb25cbiAgICBpZiAodGhpcy5zdGF0ZSAhPT0gU3RhdGUuRlJBR19MT0FESU5HICYmIHRoaXMuZnJhZ0xvYWRJZHggIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5mcmFnTG9hZElkeCArPSAyICogY29uZmlnLmZyYWdMb2FkaW5nTG9vcFRocmVzaG9sZDtcbiAgICB9XG4gICAgLy8gaW4gY2FzZSBzZWVraW5nIG9jY3VycyBhbHRob3VnaCBubyBtZWRpYSBidWZmZXJlZCwgYWRqdXN0IHN0YXJ0UG9zaXRpb24gYW5kIG5leHRMb2FkUG9zaXRpb24gdG8gc2VlayB0YXJnZXRcbiAgICBpZighdGhpcy5sb2FkZWRtZXRhZGF0YSkge1xuICAgICAgdGhpcy5uZXh0TG9hZFBvc2l0aW9uID0gdGhpcy5zdGFydFBvc2l0aW9uID0gY3VycmVudFRpbWU7XG4gICAgfVxuICAgIC8vIHRpY2sgdG8gc3BlZWQgdXAgcHJvY2Vzc2luZ1xuICAgIHRoaXMudGljaygpO1xuICB9XG5cbiAgb25NZWRpYVNlZWtlZCgpIHtcbiAgICBsb2dnZXIubG9nKGBtZWRpYSBzZWVrZWQgdG8gJHt0aGlzLm1lZGlhLmN1cnJlbnRUaW1lLnRvRml4ZWQoMyl9YCk7XG4gICAgLy8gdGljayB0byBzcGVlZCB1cCBGUkFHTUVOVF9QTEFZSU5HIHRyaWdnZXJpbmdcbiAgICB0aGlzLnRpY2soKTtcbiAgfVxuXG4gIG9uTWVkaWFFbmRlZCgpIHtcbiAgICBsb2dnZXIubG9nKCdtZWRpYSBlbmRlZCcpO1xuICAgIC8vIHJlc2V0IHN0YXJ0UG9zaXRpb24gYW5kIGxhc3RDdXJyZW50VGltZSB0byByZXN0YXJ0IHBsYXliYWNrIEAgc3RyZWFtIGJlZ2lubmluZ1xuICAgIHRoaXMuc3RhcnRQb3NpdGlvbiA9IHRoaXMubGFzdEN1cnJlbnRUaW1lID0gMDtcbiAgfVxuXG5cbiAgb25NYW5pZmVzdExvYWRpbmcoKSB7XG4gICAgLy8gcmVzZXQgYnVmZmVyIG9uIG1hbmlmZXN0IGxvYWRpbmdcbiAgICBsb2dnZXIubG9nKCd0cmlnZ2VyIEJVRkZFUl9SRVNFVCcpO1xuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuQlVGRkVSX1JFU0VUKTtcbiAgICB0aGlzLmJ1ZmZlclJhbmdlID0gW107XG4gICAgdGhpcy5zdGFsbGVkID0gZmFsc2U7XG4gICAgdGhpcy5zdGFydFBvc2l0aW9uID0gdGhpcy5sYXN0Q3VycmVudFRpbWUgPSAwO1xuICB9XG5cbiAgb25NYW5pZmVzdFBhcnNlZChkYXRhKSB7XG4gICAgdmFyIGFhYyA9IGZhbHNlLCBoZWFhYyA9IGZhbHNlLCBjb2RlYztcbiAgICBkYXRhLmxldmVscy5mb3JFYWNoKGxldmVsID0+IHtcbiAgICAgIC8vIGRldGVjdCBpZiB3ZSBoYXZlIGRpZmZlcmVudCBraW5kIG9mIGF1ZGlvIGNvZGVjcyB1c2VkIGFtb25nc3QgcGxheWxpc3RzXG4gICAgICBjb2RlYyA9IGxldmVsLmF1ZGlvQ29kZWM7XG4gICAgICBpZiAoY29kZWMpIHtcbiAgICAgICAgaWYgKGNvZGVjLmluZGV4T2YoJ21wNGEuNDAuMicpICE9PSAtMSkge1xuICAgICAgICAgIGFhYyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvZGVjLmluZGV4T2YoJ21wNGEuNDAuNScpICE9PSAtMSkge1xuICAgICAgICAgIGhlYWFjID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuYXVkaW9Db2RlY1N3aXRjaCA9IChhYWMgJiYgaGVhYWMpO1xuICAgIGlmICh0aGlzLmF1ZGlvQ29kZWNTd2l0Y2gpIHtcbiAgICAgIGxvZ2dlci5sb2coJ2JvdGggQUFDL0hFLUFBQyBhdWRpbyBmb3VuZCBpbiBsZXZlbHM7IGRlY2xhcmluZyBsZXZlbCBjb2RlYyBhcyBIRS1BQUMnKTtcbiAgICB9XG4gICAgdGhpcy5sZXZlbHMgPSBkYXRhLmxldmVscztcbiAgICB0aGlzLnN0YXJ0TGV2ZWxMb2FkZWQgPSBmYWxzZTtcbiAgICB0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCA9IGZhbHNlO1xuICAgIGxldCBjb25maWcgPSB0aGlzLmNvbmZpZztcbiAgICBpZiAoY29uZmlnLmF1dG9TdGFydExvYWQpIHtcbiAgICAgIHRoaXMuaGxzLnN0YXJ0TG9hZChjb25maWcuc3RhcnRQb3NpdGlvbik7XG4gICAgfVxuICB9XG5cbiAgb25MZXZlbExvYWRlZChkYXRhKSB7XG4gICAgdmFyIG5ld0RldGFpbHMgPSBkYXRhLmRldGFpbHMsXG4gICAgICAgIG5ld0xldmVsSWQgPSBkYXRhLmxldmVsLFxuICAgICAgICBjdXJMZXZlbCA9IHRoaXMubGV2ZWxzW25ld0xldmVsSWRdLFxuICAgICAgICBkdXJhdGlvbiA9IG5ld0RldGFpbHMudG90YWxkdXJhdGlvbixcbiAgICAgICAgc2xpZGluZyA9IDA7XG5cbiAgICBsb2dnZXIubG9nKGBsZXZlbCAke25ld0xldmVsSWR9IGxvYWRlZCBbJHtuZXdEZXRhaWxzLnN0YXJ0U059LCR7bmV3RGV0YWlscy5lbmRTTn1dLGR1cmF0aW9uOiR7ZHVyYXRpb259YCk7XG4gICAgdGhpcy5sZXZlbExhc3RMb2FkZWQgPSBuZXdMZXZlbElkO1xuXG4gICAgaWYgKG5ld0RldGFpbHMubGl2ZSkge1xuICAgICAgdmFyIGN1ckRldGFpbHMgPSBjdXJMZXZlbC5kZXRhaWxzO1xuICAgICAgaWYgKGN1ckRldGFpbHMgJiYgbmV3RGV0YWlscy5mcmFnbWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAvLyB3ZSBhbHJlYWR5IGhhdmUgZGV0YWlscyBmb3IgdGhhdCBsZXZlbCwgbWVyZ2UgdGhlbVxuICAgICAgICBMZXZlbEhlbHBlci5tZXJnZURldGFpbHMoY3VyRGV0YWlscyxuZXdEZXRhaWxzKTtcbiAgICAgICAgc2xpZGluZyA9IG5ld0RldGFpbHMuZnJhZ21lbnRzWzBdLnN0YXJ0O1xuICAgICAgICB0aGlzLmxpdmVTeW5jUG9zaXRpb24gPSB0aGlzLmNvbXB1dGVMaXZlUG9zaXRpb24oc2xpZGluZywgY3VyRGV0YWlscyk7XG4gICAgICAgIGlmIChuZXdEZXRhaWxzLlBUU0tub3duKSB7XG4gICAgICAgICAgbG9nZ2VyLmxvZyhgbGl2ZSBwbGF5bGlzdCBzbGlkaW5nOiR7c2xpZGluZy50b0ZpeGVkKDMpfWApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxvZ2dlci5sb2coJ2xpdmUgcGxheWxpc3QgLSBvdXRkYXRlZCBQVFMsIHVua25vd24gc2xpZGluZycpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXdEZXRhaWxzLlBUU0tub3duID0gZmFsc2U7XG4gICAgICAgIGxvZ2dlci5sb2coJ2xpdmUgcGxheWxpc3QgLSBmaXJzdCBsb2FkLCB1bmtub3duIHNsaWRpbmcnKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbmV3RGV0YWlscy5QVFNLbm93biA9IGZhbHNlO1xuICAgIH1cbiAgICAvLyBvdmVycmlkZSBsZXZlbCBpbmZvXG4gICAgY3VyTGV2ZWwuZGV0YWlscyA9IG5ld0RldGFpbHM7XG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5MRVZFTF9VUERBVEVELCB7IGRldGFpbHM6IG5ld0RldGFpbHMsIGxldmVsOiBuZXdMZXZlbElkIH0pO1xuXG4gICAgaWYgKHRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkID09PSBmYWxzZSkge1xuICAgIC8vIGNvbXB1dGUgc3RhcnQgcG9zaXRpb24gaWYgc2V0IHRvIC0xLiB1c2UgaXQgc3RyYWlnaHQgYXdheSBpZiB2YWx1ZSBpcyBkZWZpbmVkXG4gICAgICBpZiAodGhpcy5zdGFydFBvc2l0aW9uID09PSAtMSB8fMKgdGhpcy5sYXN0Q3VycmVudFRpbWUgPT09IC0xKSB7XG4gICAgICAgIC8vIGZpcnN0LCBjaGVjayBpZiBzdGFydCB0aW1lIG9mZnNldCBoYXMgYmVlbiBzZXQgaW4gcGxheWxpc3QsIGlmIHllcywgdXNlIHRoaXMgdmFsdWVcbiAgICAgICAgbGV0IHN0YXJ0VGltZU9mZnNldCA9IG5ld0RldGFpbHMuc3RhcnRUaW1lT2Zmc2V0O1xuICAgICAgICBpZighaXNOYU4oc3RhcnRUaW1lT2Zmc2V0KSkge1xuICAgICAgICAgIGlmIChzdGFydFRpbWVPZmZzZXQgPCAwKSB7XG4gICAgICAgICAgICBsb2dnZXIubG9nKGBuZWdhdGl2ZSBzdGFydCB0aW1lIG9mZnNldCAke3N0YXJ0VGltZU9mZnNldH0sIGNvdW50IGZyb20gZW5kIG9mIGxhc3QgZnJhZ21lbnRgKTtcbiAgICAgICAgICAgIHN0YXJ0VGltZU9mZnNldCA9IHNsaWRpbmcgKyBkdXJhdGlvbiArIHN0YXJ0VGltZU9mZnNldDtcbiAgICAgICAgICB9XG4gICAgICAgICAgbG9nZ2VyLmxvZyhgc3RhcnQgdGltZSBvZmZzZXQgZm91bmQgaW4gcGxheWxpc3QsIGFkanVzdCBzdGFydFBvc2l0aW9uIHRvICR7c3RhcnRUaW1lT2Zmc2V0fWApO1xuICAgICAgICAgIHRoaXMuc3RhcnRQb3NpdGlvbiA9IHN0YXJ0VGltZU9mZnNldDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBpZiBsaXZlIHBsYXlsaXN0LCBzZXQgc3RhcnQgcG9zaXRpb24gdG8gYmUgZnJhZ21lbnQgTi10aGlzLmNvbmZpZy5saXZlU3luY0R1cmF0aW9uQ291bnQgKHVzdWFsbHkgMylcbiAgICAgICAgICBpZiAobmV3RGV0YWlscy5saXZlKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0UG9zaXRpb24gPSB0aGlzLmNvbXB1dGVMaXZlUG9zaXRpb24oc2xpZGluZywgbmV3RGV0YWlscyk7XG4gICAgICAgICAgICBsb2dnZXIubG9nKGBjb25maWd1cmUgc3RhcnRQb3NpdGlvbiB0byAke3RoaXMuc3RhcnRQb3NpdGlvbn1gKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zdGFydFBvc2l0aW9uID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sYXN0Q3VycmVudFRpbWUgPSB0aGlzLnN0YXJ0UG9zaXRpb247XG4gICAgICB9XG4gICAgICB0aGlzLm5leHRMb2FkUG9zaXRpb24gPSB0aGlzLnN0YXJ0UG9zaXRpb247XG4gICAgfVxuICAgIC8vIG9ubHkgc3dpdGNoIGJhdGNrIHRvIElETEUgc3RhdGUgaWYgd2Ugd2VyZSB3YWl0aW5nIGZvciBsZXZlbCB0byBzdGFydCBkb3dubG9hZGluZyBhIG5ldyBmcmFnbWVudFxuICAgIGlmICh0aGlzLnN0YXRlID09PSBTdGF0ZS5XQUlUSU5HX0xFVkVMKSB7XG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICB9XG4gICAgLy90cmlnZ2VyIGhhbmRsZXIgcmlnaHQgbm93XG4gICAgdGhpcy50aWNrKCk7XG4gIH1cblxuICBvbktleUxvYWRlZCgpIHtcbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuS0VZX0xPQURJTkcpIHtcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgdGhpcy50aWNrKCk7XG4gICAgfVxuICB9XG5cbiAgb25GcmFnTG9hZGVkKGRhdGEpIHtcbiAgICB2YXIgZnJhZ0N1cnJlbnQgPSB0aGlzLmZyYWdDdXJyZW50LFxuICAgICAgICBmcmFnTG9hZGVkID0gZGF0YS5mcmFnO1xuICAgIGlmICh0aGlzLnN0YXRlID09PSBTdGF0ZS5GUkFHX0xPQURJTkcgJiZcbiAgICAgICAgZnJhZ0N1cnJlbnQgJiZcbiAgICAgICAgZnJhZ0xvYWRlZC50eXBlID09PSAnbWFpbicgJiZcbiAgICAgICAgZnJhZ0xvYWRlZC5sZXZlbCA9PT0gZnJhZ0N1cnJlbnQubGV2ZWwgJiZcbiAgICAgICAgZnJhZ0xvYWRlZC5zbiA9PT0gZnJhZ0N1cnJlbnQuc24pIHtcbiAgICAgIGxldCBzdGF0cyA9IGRhdGEuc3RhdHMsXG4gICAgICAgICAgY3VycmVudExldmVsID0gdGhpcy5sZXZlbHNbZnJhZ0N1cnJlbnQubGV2ZWxdLFxuICAgICAgICAgIGRldGFpbHMgPSBjdXJyZW50TGV2ZWwuZGV0YWlscztcbiAgICAgIGxvZ2dlci5sb2coYExvYWRlZCAgJHtmcmFnQ3VycmVudC5zbn0gb2YgWyR7ZGV0YWlscy5zdGFydFNOfSAsJHtkZXRhaWxzLmVuZFNOfV0sbGV2ZWwgJHtmcmFnQ3VycmVudC5sZXZlbH1gKTtcbiAgICAgIC8vIHJlc2V0IGZyYWcgYml0cmF0ZSB0ZXN0IGluIGFueSBjYXNlIGFmdGVyIGZyYWcgbG9hZGVkIGV2ZW50XG4gICAgICB0aGlzLmJpdHJhdGVUZXN0ID0gZmFsc2U7XG4gICAgICAvLyBpZiB0aGlzIGZyYWcgd2FzIGxvYWRlZCB0byBwZXJmb3JtIGEgYml0cmF0ZSB0ZXN0IEFORCBpZiBobHMubmV4dExvYWRMZXZlbCBpcyBncmVhdGVyIHRoYW4gMFxuICAgICAgLy8gdGhlbiB0aGlzIG1lYW5zIHRoYXQgd2Ugc2hvdWxkIGJlIGFibGUgdG8gbG9hZCBhIGZyYWdtZW50IGF0IGEgaGlnaGVyIHF1YWxpdHkgbGV2ZWxcbiAgICAgIGlmIChmcmFnTG9hZGVkLmJpdHJhdGVUZXN0ID09PSB0cnVlICYmIHRoaXMuaGxzLm5leHRMb2FkTGV2ZWwpIHtcbiAgICAgICAgLy8gc3dpdGNoIGJhY2sgdG8gSURMRSBzdGF0ZSAuLi4gd2UganVzdCBsb2FkZWQgYSBmcmFnbWVudCB0byBkZXRlcm1pbmUgYWRlcXVhdGUgc3RhcnQgYml0cmF0ZSBhbmQgaW5pdGlhbGl6ZSBhdXRvc3dpdGNoIGFsZ29cbiAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICAgIHRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkID0gZmFsc2U7XG4gICAgICAgIHN0YXRzLnRwYXJzZWQgPSBzdGF0cy50YnVmZmVyZWQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5GUkFHX0JVRkZFUkVELCB7c3RhdHM6IHN0YXRzLCBmcmFnOiBmcmFnQ3VycmVudCwgaWQgOiAnbWFpbid9KTtcbiAgICAgICAgdGhpcy50aWNrKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuUEFSU0lORztcbiAgICAgICAgLy8gdHJhbnNtdXggdGhlIE1QRUctVFMgZGF0YSB0byBJU08tQk1GRiBzZWdtZW50c1xuICAgICAgICB0aGlzLnN0YXRzID0gc3RhdHM7XG4gICAgICAgIGxldCBkdXJhdGlvbiA9IGRldGFpbHMudG90YWxkdXJhdGlvbixcbiAgICAgICAgICAgIHN0YXJ0ID0gIWlzTmFOKGZyYWdDdXJyZW50LnN0YXJ0RFRTKSA/IGZyYWdDdXJyZW50LnN0YXJ0RFRTICA6IGZyYWdDdXJyZW50LnN0YXJ0LFxuICAgICAgICAgICAgbGV2ZWwgPSBmcmFnQ3VycmVudC5sZXZlbCxcbiAgICAgICAgICAgIHNuID0gZnJhZ0N1cnJlbnQuc24sXG4gICAgICAgICAgICBhdWRpb0NvZGVjID0gdGhpcy5jb25maWcuZGVmYXVsdEF1ZGlvQ29kZWMgfHwgY3VycmVudExldmVsLmF1ZGlvQ29kZWM7XG4gICAgICAgIGlmKHRoaXMuYXVkaW9Db2RlY1N3YXApIHtcbiAgICAgICAgICBsb2dnZXIubG9nKCdzd2FwcGluZyBwbGF5bGlzdCBhdWRpbyBjb2RlYycpO1xuICAgICAgICAgIGlmKGF1ZGlvQ29kZWMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYXVkaW9Db2RlYyA9IHRoaXMubGFzdEF1ZGlvQ29kZWM7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmKGF1ZGlvQ29kZWMpIHtcbiAgICAgICAgICAgIGlmKGF1ZGlvQ29kZWMuaW5kZXhPZignbXA0YS40MC41JykgIT09LTEpIHtcbiAgICAgICAgICAgICAgYXVkaW9Db2RlYyA9ICdtcDRhLjQwLjInO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYXVkaW9Db2RlYyA9ICdtcDRhLjQwLjUnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBlbmRpbmdCdWZmZXJpbmcgPSAtMTtcbiAgICAgICAgdGhpcy5hcHBlbmRlZCA9IGZhbHNlO1xuICAgICAgICBsb2dnZXIubG9nKGBQYXJzaW5nICR7c259IG9mIFske2RldGFpbHMuc3RhcnRTTn0gLCR7ZGV0YWlscy5lbmRTTn1dLGxldmVsICR7bGV2ZWx9LCBjYyAke2ZyYWdDdXJyZW50LmNjfWApO1xuICAgICAgICBsZXQgZGVtdXhlciA9IHRoaXMuZGVtdXhlcjtcbiAgICAgICAgaWYgKCFkZW11eGVyKSB7XG4gICAgICAgICAgZGVtdXhlciA9IHRoaXMuZGVtdXhlciA9IG5ldyBEZW11eGVyKHRoaXMuaGxzLCdtYWluJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdGltZSBPZmZzZXQgaXMgYWNjdXJhdGUgaWYgbGV2ZWwgUFRTIGlzIGtub3duLCBvciBpZiBwbGF5bGlzdCBpcyBub3Qgc2xpZGluZyAobm90IGxpdmUpIGFuZCBpZiBtZWRpYSBpcyBub3Qgc2Vla2luZyAodGhpcyBpcyB0byBvdmVyY29tZSBwb3RlbnRpYWwgdGltZXN0YW1wIGRyaWZ0cyBiZXR3ZWVuIHBsYXlsaXN0cyBhbmQgZnJhZ21lbnRzKVxuICAgICAgICBsZXQgbWVkaWEgPSB0aGlzLm1lZGlhO1xuICAgICAgICBsZXQgbWVkaWFTZWVraW5nID0gbWVkaWEgJiYgbWVkaWEuc2Vla2luZztcbiAgICAgICAgbGV0IGFjY3VyYXRlVGltZU9mZnNldCA9ICFtZWRpYVNlZWtpbmcgJiYgKGRldGFpbHMuUFRTS25vd24gfHwgIWRldGFpbHMubGl2ZSk7XG4gICAgICAgIGRlbXV4ZXIucHVzaChkYXRhLnBheWxvYWQsIGF1ZGlvQ29kZWMsIGN1cnJlbnRMZXZlbC52aWRlb0NvZGVjLCBzdGFydCwgZnJhZ0N1cnJlbnQuY2MsIGxldmVsLCBzbiwgZHVyYXRpb24sIGZyYWdDdXJyZW50LmRlY3J5cHRkYXRhLCBhY2N1cmF0ZVRpbWVPZmZzZXQsbnVsbCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuZnJhZ0xvYWRFcnJvciA9IDA7XG4gIH1cblxuICBvbkZyYWdQYXJzaW5nSW5pdFNlZ21lbnQoZGF0YSkge1xuICAgIGxldCBmcmFnQ3VycmVudCA9IHRoaXMuZnJhZ0N1cnJlbnQ7XG4gICAgaWYgKGZyYWdDdXJyZW50ICYmXG4gICAgICAgIGRhdGEuaWQgPT09ICdtYWluJyAmJlxuICAgICAgICBkYXRhLnNuID09PSBmcmFnQ3VycmVudC5zbiAmJlxuICAgICAgICBkYXRhLmxldmVsID09PSBmcmFnQ3VycmVudC5sZXZlbCAmJlxuICAgICAgICB0aGlzLnN0YXRlID09PSBTdGF0ZS5QQVJTSU5HKSB7XG4gICAgICB2YXIgdHJhY2tzID0gZGF0YS50cmFja3MsIHRyYWNrTmFtZSwgdHJhY2s7XG5cbiAgICAgIC8vIGlmIGF1ZGlvIHRyYWNrIGlzIGV4cGVjdGVkIHRvIGNvbWUgZnJvbSBhdWRpbyBzdHJlYW0gY29udHJvbGxlciwgZGlzY2FyZCBhbnkgY29taW5nIGZyb20gbWFpblxuICAgICAgaWYgKHRyYWNrcy5hdWRpbyAmJiB0aGlzLmFsdEF1ZGlvKSB7XG4gICAgICAgIGRlbGV0ZSB0cmFja3MuYXVkaW87XG4gICAgICB9XG4gICAgICAvLyBpbmNsdWRlIGxldmVsQ29kZWMgaW4gYXVkaW8gYW5kIHZpZGVvIHRyYWNrc1xuICAgICAgdHJhY2sgPSB0cmFja3MuYXVkaW87XG4gICAgICBpZih0cmFjaykge1xuICAgICAgICB2YXIgYXVkaW9Db2RlYyA9IHRoaXMubGV2ZWxzW3RoaXMubGV2ZWxdLmF1ZGlvQ29kZWMsXG4gICAgICAgICAgICB1YSA9IG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYoYXVkaW9Db2RlYyAmJiB0aGlzLmF1ZGlvQ29kZWNTd2FwKSB7XG4gICAgICAgICAgbG9nZ2VyLmxvZygnc3dhcHBpbmcgcGxheWxpc3QgYXVkaW8gY29kZWMnKTtcbiAgICAgICAgICBpZihhdWRpb0NvZGVjLmluZGV4T2YoJ21wNGEuNDAuNScpICE9PS0xKSB7XG4gICAgICAgICAgICBhdWRpb0NvZGVjID0gJ21wNGEuNDAuMic7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGF1ZGlvQ29kZWMgPSAnbXA0YS40MC41JztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gaW4gY2FzZSBBQUMgYW5kIEhFLUFBQyBhdWRpbyBjb2RlY3MgYXJlIHNpZ25hbGxlZCBpbiBtYW5pZmVzdFxuICAgICAgICAvLyBmb3JjZSBIRS1BQUMgLCBhcyBpdCBzZWVtcyB0aGF0IG1vc3QgYnJvd3NlcnMgcHJlZmVycyB0aGF0IHdheSxcbiAgICAgICAgLy8gZXhjZXB0IGZvciBtb25vIHN0cmVhbXMgT1Igb24gRkZcbiAgICAgICAgLy8gdGhlc2UgY29uZGl0aW9ucyBtaWdodCBuZWVkIHRvIGJlIHJldmlld2VkIC4uLlxuICAgICAgICBpZiAodGhpcy5hdWRpb0NvZGVjU3dpdGNoKSB7XG4gICAgICAgICAgICAvLyBkb24ndCBmb3JjZSBIRS1BQUMgaWYgbW9ubyBzdHJlYW1cbiAgICAgICAgICAgaWYodHJhY2subWV0YWRhdGEuY2hhbm5lbENvdW50ICE9PSAxICYmXG4gICAgICAgICAgICAvLyBkb24ndCBmb3JjZSBIRS1BQUMgaWYgZmlyZWZveFxuICAgICAgICAgICAgdWEuaW5kZXhPZignZmlyZWZveCcpID09PSAtMSkge1xuICAgICAgICAgICAgICBhdWRpb0NvZGVjID0gJ21wNGEuNDAuNSc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEhFLUFBQyBpcyBicm9rZW4gb24gQW5kcm9pZCwgYWx3YXlzIHNpZ25hbCBhdWRpbyBjb2RlYyBhcyBBQUMgZXZlbiBpZiB2YXJpYW50IG1hbmlmZXN0IHN0YXRlcyBvdGhlcndpc2VcbiAgICAgICAgaWYodWEuaW5kZXhPZignYW5kcm9pZCcpICE9PSAtMSAmJiB0cmFjay5jb250YWluZXIgIT09ICdhdWRpby9tcGVnJykgeyAvLyBFeGNsdWRlIG1wZWcgYXVkaW9cbiAgICAgICAgICBhdWRpb0NvZGVjID0gJ21wNGEuNDAuMic7XG4gICAgICAgICAgbG9nZ2VyLmxvZyhgQW5kcm9pZDogZm9yY2UgYXVkaW8gY29kZWMgdG8gJHthdWRpb0NvZGVjfWApO1xuICAgICAgICB9XG4gICAgICAgIHRyYWNrLmxldmVsQ29kZWMgPSBhdWRpb0NvZGVjO1xuICAgICAgICB0cmFjay5pZCA9IGRhdGEuaWQ7XG4gICAgICB9XG4gICAgICB0cmFjayA9IHRyYWNrcy52aWRlbztcbiAgICAgIGlmKHRyYWNrKSB7XG4gICAgICAgIHRyYWNrLmxldmVsQ29kZWMgPSB0aGlzLmxldmVsc1t0aGlzLmxldmVsXS52aWRlb0NvZGVjO1xuICAgICAgICB0cmFjay5pZCA9IGRhdGEuaWQ7XG4gICAgICB9XG5cbiAgICAgIC8vIGlmIHJlbXV4ZXIgc3BlY2lmeSB0aGF0IGEgdW5pcXVlIHRyYWNrIG5lZWRzIHRvIGdlbmVyYXRlZCxcbiAgICAgIC8vIGxldCdzIG1lcmdlIGFsbCB0cmFja3MgdG9nZXRoZXJcbiAgICAgIGlmIChkYXRhLnVuaXF1ZSkge1xuICAgICAgICB2YXIgbWVyZ2VkVHJhY2sgPSB7XG4gICAgICAgICAgICBjb2RlYyA6ICcnLFxuICAgICAgICAgICAgbGV2ZWxDb2RlYyA6ICcnXG4gICAgICAgICAgfTtcbiAgICAgICAgZm9yICh0cmFja05hbWUgaW4gZGF0YS50cmFja3MpIHtcbiAgICAgICAgICB0cmFjayA9IHRyYWNrc1t0cmFja05hbWVdO1xuICAgICAgICAgIG1lcmdlZFRyYWNrLmNvbnRhaW5lciA9IHRyYWNrLmNvbnRhaW5lcjtcbiAgICAgICAgICBpZiAobWVyZ2VkVHJhY2suY29kZWMpIHtcbiAgICAgICAgICAgIG1lcmdlZFRyYWNrLmNvZGVjICs9ICAnLCc7XG4gICAgICAgICAgICBtZXJnZWRUcmFjay5sZXZlbENvZGVjICs9ICAnLCc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmKHRyYWNrLmNvZGVjKSB7XG4gICAgICAgICAgICBtZXJnZWRUcmFjay5jb2RlYyArPSAgdHJhY2suY29kZWM7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0cmFjay5sZXZlbENvZGVjKSB7XG4gICAgICAgICAgICBtZXJnZWRUcmFjay5sZXZlbENvZGVjICs9ICB0cmFjay5sZXZlbENvZGVjO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0cmFja3MgPSB7IGF1ZGlvdmlkZW8gOiBtZXJnZWRUcmFjayB9O1xuICAgICAgfVxuICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5CVUZGRVJfQ09ERUNTLHRyYWNrcyk7XG4gICAgICAvLyBsb29wIHRocm91Z2ggdHJhY2tzIHRoYXQgYXJlIGdvaW5nIHRvIGJlIHByb3ZpZGVkIHRvIGJ1ZmZlckNvbnRyb2xsZXJcbiAgICAgIGZvciAodHJhY2tOYW1lIGluIHRyYWNrcykge1xuICAgICAgICB0cmFjayA9IHRyYWNrc1t0cmFja05hbWVdO1xuICAgICAgICBsb2dnZXIubG9nKGBtYWluIHRyYWNrOiR7dHJhY2tOYW1lfSxjb250YWluZXI6JHt0cmFjay5jb250YWluZXJ9LGNvZGVjc1tsZXZlbC9wYXJzZWRdPVske3RyYWNrLmxldmVsQ29kZWN9LyR7dHJhY2suY29kZWN9XWApO1xuICAgICAgICB2YXIgaW5pdFNlZ21lbnQgPSB0cmFjay5pbml0U2VnbWVudDtcbiAgICAgICAgaWYgKGluaXRTZWdtZW50KSB7XG4gICAgICAgICAgdGhpcy5hcHBlbmRlZCA9IHRydWU7XG4gICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5CVUZGRVJfQVBQRU5ESU5HLCB7dHlwZTogdHJhY2tOYW1lLCBkYXRhOiBpbml0U2VnbWVudCwgcGFyZW50IDogJ21haW4nLCBjb250ZW50IDogJ2luaXRTZWdtZW50J30pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvL3RyaWdnZXIgaGFuZGxlciByaWdodCBub3dcbiAgICAgIHRoaXMudGljaygpO1xuICAgIH1cbiAgfVxuXG4gIG9uRnJhZ1BhcnNpbmdEYXRhKGRhdGEpIHtcbiAgICBsZXQgZnJhZ0N1cnJlbnQgPSB0aGlzLmZyYWdDdXJyZW50O1xuICAgIGlmIChmcmFnQ3VycmVudCAmJlxuICAgICAgICBkYXRhLmlkID09PSAnbWFpbicgJiZcbiAgICAgICAgZGF0YS5zbiA9PT0gZnJhZ0N1cnJlbnQuc24gJiZcbiAgICAgICAgZGF0YS5sZXZlbCA9PT0gZnJhZ0N1cnJlbnQubGV2ZWwgJiZcbiAgICAgICAgIShkYXRhLnR5cGUgPT09ICdhdWRpbycgJiYgdGhpcy5hbHRBdWRpbykgJiYgLy8gZmlsdGVyIG91dCBtYWluIGF1ZGlvIGlmIGF1ZGlvIHRyYWNrIGlzIGxvYWRlZCB0aHJvdWdoIGF1ZGlvIHN0cmVhbSBjb250cm9sbGVyXG4gICAgICAgIHRoaXMuc3RhdGUgPT09IFN0YXRlLlBBUlNJTkcpIHtcbiAgICAgIHZhciBsZXZlbCA9IHRoaXMubGV2ZWxzW3RoaXMubGV2ZWxdLFxuICAgICAgICAgIGZyYWcgPSB0aGlzLmZyYWdDdXJyZW50O1xuXG4gICAgICBsb2dnZXIubG9nKGBQYXJzZWQgJHtkYXRhLnR5cGV9LFBUUzpbJHtkYXRhLnN0YXJ0UFRTLnRvRml4ZWQoMyl9LCR7ZGF0YS5lbmRQVFMudG9GaXhlZCgzKX1dLERUUzpbJHtkYXRhLnN0YXJ0RFRTLnRvRml4ZWQoMyl9LyR7ZGF0YS5lbmREVFMudG9GaXhlZCgzKX1dLG5iOiR7ZGF0YS5uYn0sZHJvcHBlZDoke2RhdGEuZHJvcHBlZCB8fCAwfWApO1xuXG4gICAgICAvLyBEZXRlY3QgZ2FwcyBpbiBhIGZyYWdtZW50ICBhbmQgdHJ5IHRvIGZpeCBpdCBieSBmaW5kaW5nIGEga2V5ZnJhbWUgaW4gdGhlIHByZXZpb3VzIGZyYWdtZW50IChzZWUgX2ZpbmRGcmFnbWVudHMpXG4gICAgICBpZihkYXRhLnR5cGUgPT09ICd2aWRlbycpIHtcbiAgICAgICAgZnJhZy5kcm9wcGVkID0gZGF0YS5kcm9wcGVkO1xuICAgICAgICBpZiAoZnJhZy5kcm9wcGVkKSB7XG4gICAgICAgICAgaWYgKCFmcmFnLmJhY2t0cmFja2VkKSB7XG4gICAgICAgICAgICAvLyBSZXR1cm4gYmFjayB0byB0aGUgSURMRSBzdGF0ZSB3aXRob3V0IGFwcGVuZGluZyB0byBidWZmZXJcbiAgICAgICAgICAgIC8vIENhdXNlcyBmaW5kRnJhZ21lbnRzIHRvIGJhY2t0cmFjayBhIHNlZ21lbnQgYW5kIGZpbmQgdGhlIGtleWZyYW1lXG4gICAgICAgICAgICAvLyBBdWRpbyBmcmFnbWVudHMgYXJyaXZpbmcgYmVmb3JlIHZpZGVvIHNldHMgdGhlIG5leHRMb2FkUG9zaXRpb24sIGNhdXNpbmcgX2ZpbmRGcmFnbWVudHMgdG8gc2tpcCB0aGUgYmFja3RyYWNrZWQgZnJhZ21lbnRcbiAgICAgICAgICAgIGZyYWcuYmFja3RyYWNrZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5uZXh0TG9hZFBvc2l0aW9uID0gZnJhZy5zdGFydFBUUztcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgICAgICAgdGhpcy50aWNrKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKCdBbHJlYWR5IGJhY2t0cmFja2VkIG9uIHRoaXMgZnJhZ21lbnQsIGFwcGVuZGluZyB3aXRoIHRoZSBnYXAnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gT25seSByZXNldCB0aGUgYmFja3RyYWNrZWQgZmxhZyBpZiB3ZSd2ZSBsb2FkZWQgdGhlIGZyYWcgd2l0aG91dCBhbnkgZHJvcHBlZCBmcmFtZXNcbiAgICAgICAgICBmcmFnLmJhY2t0cmFja2VkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGRyaWZ0ID0gTGV2ZWxIZWxwZXIudXBkYXRlRnJhZ1BUU0RUUyhsZXZlbC5kZXRhaWxzLGZyYWcuc24sZGF0YS5zdGFydFBUUyxkYXRhLmVuZFBUUyxkYXRhLnN0YXJ0RFRTLGRhdGEuZW5kRFRTKSxcbiAgICAgICAgICBobHMgPSB0aGlzLmhscztcbiAgICAgIGhscy50cmlnZ2VyKEV2ZW50LkxFVkVMX1BUU19VUERBVEVELCB7ZGV0YWlsczogbGV2ZWwuZGV0YWlscywgbGV2ZWw6IHRoaXMubGV2ZWwsIGRyaWZ0OiBkcmlmdCwgdHlwZTogZGF0YS50eXBlLCBzdGFydDogZGF0YS5zdGFydFBUUywgZW5kOiBkYXRhLmVuZFBUU30pO1xuXG4gICAgICAvLyBoYXMgcmVtdXhlciBkcm9wcGVkIHZpZGVvIGZyYW1lcyBsb2NhdGVkIGJlZm9yZSBmaXJzdCBrZXlmcmFtZSA/XG4gICAgICBbZGF0YS5kYXRhMSwgZGF0YS5kYXRhMl0uZm9yRWFjaChidWZmZXIgPT4ge1xuICAgICAgICBpZiAoYnVmZmVyKSB7XG4gICAgICAgICAgdGhpcy5hcHBlbmRlZCA9IHRydWU7XG4gICAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnQuQlVGRkVSX0FQUEVORElORywge3R5cGU6IGRhdGEudHlwZSwgZGF0YTogYnVmZmVyLCBwYXJlbnQgOiAnbWFpbicsY29udGVudCA6ICdkYXRhJ30pO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5idWZmZXJSYW5nZS5wdXNoKHt0eXBlOiBkYXRhLnR5cGUsIHN0YXJ0OiBkYXRhLnN0YXJ0UFRTLCBlbmQ6IGRhdGEuZW5kUFRTLCBmcmFnOiBmcmFnfSk7XG5cbiAgICAgIC8vdHJpZ2dlciBoYW5kbGVyIHJpZ2h0IG5vd1xuICAgICAgdGhpcy50aWNrKCk7XG4gICAgfVxuICB9XG5cbiAgb25GcmFnUGFyc2VkKGRhdGEpIHtcbiAgICBsZXQgZnJhZ0N1cnJlbnQgPSB0aGlzLmZyYWdDdXJyZW50O1xuICAgIGlmIChmcmFnQ3VycmVudCAmJlxuICAgICAgICBkYXRhLmlkID09PSAnbWFpbicgJiZcbiAgICAgICAgZGF0YS5zbiA9PT0gZnJhZ0N1cnJlbnQuc24gJiZcbiAgICAgICAgZGF0YS5sZXZlbCA9PT0gZnJhZ0N1cnJlbnQubGV2ZWwgJiZcbiAgICAgICAgdGhpcy5zdGF0ZSA9PT0gU3RhdGUuUEFSU0lORykge1xuICAgICAgdGhpcy5zdGF0cy50cGFyc2VkID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuUEFSU0VEO1xuICAgICAgdGhpcy5fY2hlY2tBcHBlbmRlZFBhcnNlZCgpO1xuICAgIH1cbiAgfVxuXG4gIG9uQXVkaW9UcmFja1N3aXRjaGluZyhkYXRhKSB7XG4gICAgLy8gaWYgYW55IFVSTCBmb3VuZCBvbiBuZXcgYXVkaW8gdHJhY2ssIGl0IGlzIGFuIGFsdGVybmF0ZSBhdWRpbyB0cmFja1xuICAgIHZhciBhbHRBdWRpbyA9ICEhZGF0YS51cmwsXG4gICAgICAgIHRyYWNrSWQgPSBkYXRhLmlkO1xuICAgIC8vIGlmIHdlIHN3aXRjaCBvbiBtYWluIGF1ZGlvLCBlbnN1cmUgdGhhdCBtYWluIGZyYWdtZW50IHNjaGVkdWxpbmcgaXMgc3luY2VkIHdpdGggbWVkaWEuYnVmZmVyZWRcbiAgICAvLyBkb24ndCBkbyBhbnl0aGluZyBpZiB3ZSBzd2l0Y2ggdG8gYWx0IGF1ZGlvOiBhdWRpbyBzdHJlYW0gY29udHJvbGxlciBpcyBoYW5kbGluZyBpdC5cbiAgICAvLyB3ZSB3aWxsIGp1c3QgaGF2ZSB0byBjaGFuZ2UgYnVmZmVyIHNjaGVkdWxpbmcgb24gYXVkaW9UcmFja1N3aXRjaGVkXG4gICAgaWYgKCFhbHRBdWRpbykge1xuICAgICAgaWYgKHRoaXMubWVkaWFCdWZmZXIgIT09IHRoaXMubWVkaWEpIHtcbiAgICAgICAgbG9nZ2VyLmxvZyhgc3dpdGNoaW5nIG9uIG1haW4gYXVkaW8sIHVzZSBtZWRpYS5idWZmZXJlZCB0byBzY2hlZHVsZSBtYWluIGZyYWdtZW50IGxvYWRpbmdgKTtcbiAgICAgICAgdGhpcy5tZWRpYUJ1ZmZlciA9IHRoaXMubWVkaWE7XG4gICAgICAgIGxldCBmcmFnQ3VycmVudCA9IHRoaXMuZnJhZ0N1cnJlbnQ7XG4gICAgICAgIC8vIHdlIG5lZWQgdG8gcmVmaWxsIGF1ZGlvIGJ1ZmZlciBmcm9tIG1haW46IGNhbmNlbCBhbnkgZnJhZyBsb2FkaW5nIHRvIHNwZWVkIHVwIGF1ZGlvIHN3aXRjaFxuICAgICAgICBpZiAoZnJhZ0N1cnJlbnQubG9hZGVyKSB7XG4gICAgICAgICAgbG9nZ2VyLmxvZygnc3dpdGNoaW5nIHRvIG1haW4gYXVkaW8gdHJhY2ssIGNhbmNlbCBtYWluIGZyYWdtZW50IGxvYWQnKTtcbiAgICAgICAgICBmcmFnQ3VycmVudC5sb2FkZXIuYWJvcnQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZyYWdDdXJyZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5mcmFnUHJldmlvdXMgPSBudWxsO1xuICAgICAgICAvLyBkZXN0cm95IGRlbXV4ZXIgdG8gZm9yY2UgaW5pdCBzZWdtZW50IGdlbmVyYXRpb24gKGZvbGxvd2luZyBhdWRpbyBzd2l0Y2gpXG4gICAgICAgIGlmICh0aGlzLmRlbXV4ZXIpIHtcbiAgICAgICAgICB0aGlzLmRlbXV4ZXIuZGVzdHJveSgpO1xuICAgICAgICAgIHRoaXMuZGVtdXhlciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc3dpdGNoIHRvIElETEUgc3RhdGUgdG8gbG9hZCBuZXcgZnJhZ21lbnRcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICB9XG4gICAgICBsZXQgaGxzID0gdGhpcy5obHM7XG4gICAgICAvLyBzd2l0Y2hpbmcgdG8gbWFpbiBhdWRpbywgZmx1c2ggYWxsIGF1ZGlvIGFuZCB0cmlnZ2VyIHRyYWNrIHN3aXRjaGVkXG4gICAgICBobHMudHJpZ2dlcihFdmVudC5CVUZGRVJfRkxVU0hJTkcsIHtzdGFydE9mZnNldDogMCAsIGVuZE9mZnNldDogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLCB0eXBlIDogJ2F1ZGlvJ30pO1xuICAgICAgaGxzLnRyaWdnZXIoRXZlbnQuQVVESU9fVFJBQ0tfU1dJVENIRUQsIHtpZCA6IHRyYWNrSWR9KTtcbiAgICAgIHRoaXMuYWx0QXVkaW8gPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBvbkF1ZGlvVHJhY2tTd2l0Y2hlZChkYXRhKSB7XG4gICAgdmFyIHRyYWNrSWQgPSBkYXRhLmlkLFxuICAgIGFsdEF1ZGlvID0gISF0aGlzLmhscy5hdWRpb1RyYWNrc1t0cmFja0lkXS51cmw7XG4gICAgaWYgKGFsdEF1ZGlvKSB7XG4gICAgICBsZXQgdmlkZW9CdWZmZXIgPSB0aGlzLnZpZGVvQnVmZmVyO1xuICAgICAgLy8gaWYgd2Ugc3dpdGNoZWQgb24gYWx0ZXJuYXRlIGF1ZGlvLCBlbnN1cmUgdGhhdCBtYWluIGZyYWdtZW50IHNjaGVkdWxpbmcgaXMgc3luY2VkIHdpdGggdmlkZW8gc291cmNlYnVmZmVyIGJ1ZmZlcmVkXG4gICAgICBpZiAodmlkZW9CdWZmZXIgJiYgdGhpcy5tZWRpYUJ1ZmZlciAhPT0gdmlkZW9CdWZmZXIpIHtcbiAgICAgICAgbG9nZ2VyLmxvZyhgc3dpdGNoaW5nIG9uIGFsdGVybmF0ZSBhdWRpbywgdXNlIHZpZGVvLmJ1ZmZlcmVkIHRvIHNjaGVkdWxlIG1haW4gZnJhZ21lbnQgbG9hZGluZ2ApO1xuICAgICAgICB0aGlzLm1lZGlhQnVmZmVyID0gdmlkZW9CdWZmZXI7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuYWx0QXVkaW8gPSBhbHRBdWRpbztcbiAgICB0aGlzLnRpY2soKTtcbiAgfVxuXG5cblxuICBvbkJ1ZmZlckNyZWF0ZWQoZGF0YSkge1xuICAgIGxldCB0cmFja3MgPSBkYXRhLnRyYWNrcywgbWVkaWFUcmFjaywgbmFtZSwgYWx0ZXJuYXRlID0gZmFsc2U7XG4gICAgZm9yKHZhciB0eXBlIGluIHRyYWNrcykge1xuICAgICAgbGV0IHRyYWNrID0gdHJhY2tzW3R5cGVdO1xuICAgICAgaWYgKHRyYWNrLmlkID09PSAnbWFpbicpIHtcbiAgICAgICAgbmFtZSA9IHR5cGU7XG4gICAgICAgIG1lZGlhVHJhY2sgPSB0cmFjaztcbiAgICAgICAgLy8ga2VlcCB2aWRlbyBzb3VyY2UgYnVmZmVyIHJlZmVyZW5jZVxuICAgICAgICBpZiAodHlwZSA9PT0gJ3ZpZGVvJykge1xuICAgICAgICAgIHRoaXMudmlkZW9CdWZmZXIgPSB0cmFja3NbdHlwZV0uYnVmZmVyO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhbHRlcm5hdGUgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoYWx0ZXJuYXRlICYmIG1lZGlhVHJhY2spIHtcbiAgICAgIGxvZ2dlci5sb2coYGFsdGVybmF0ZSB0cmFjayBmb3VuZCwgdXNlICR7bmFtZX0uYnVmZmVyZWQgdG8gc2NoZWR1bGUgbWFpbiBmcmFnbWVudCBsb2FkaW5nYCk7XG4gICAgICB0aGlzLm1lZGlhQnVmZmVyID0gbWVkaWFUcmFjay5idWZmZXI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubWVkaWFCdWZmZXIgPSB0aGlzLm1lZGlhO1xuICAgIH1cbiAgfVxuXG4gIG9uQnVmZmVyQXBwZW5kZWQoZGF0YSkge1xuICAgIGlmIChkYXRhLnBhcmVudCA9PT0gJ21haW4nKSB7XG4gICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgICBpZiAoc3RhdGUgPT09IFN0YXRlLlBBUlNJTkcgfHwgc3RhdGUgPT09IFN0YXRlLlBBUlNFRCkge1xuICAgICAgICB0aGlzLnBlbmRpbmdCdWZmZXJpbmcgPSBkYXRhLnBlbmRpbmc7XG4gICAgICAgIHRoaXMuX2NoZWNrQXBwZW5kZWRQYXJzZWQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBfY2hlY2tBcHBlbmRlZFBhcnNlZCgpIHtcbiAgICAvL3RyaWdnZXIgaGFuZGxlciByaWdodCBub3dcbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuUEFSU0VEICYmICghdGhpcy5hcHBlbmRlZCB8fCB0aGlzLnBlbmRpbmdCdWZmZXJpbmcgPT09IDApKSB7XG4gICAgICB2YXIgZnJhZyA9IHRoaXMuZnJhZ0N1cnJlbnQsIHN0YXRzID0gdGhpcy5zdGF0cztcbiAgICAgIGlmIChmcmFnKSB7XG4gICAgICAgIHRoaXMuZnJhZ1ByZXZpb3VzID0gZnJhZztcbiAgICAgICAgc3RhdHMudGJ1ZmZlcmVkID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIC8vIHdlIHNob3VsZCBnZXQgcmlkIG9mIHRoaXMuZnJhZ0xhc3RLYnBzXG4gICAgICAgIHRoaXMuZnJhZ0xhc3RLYnBzID0gTWF0aC5yb3VuZCg4ICogc3RhdHMudG90YWwgLyAoc3RhdHMudGJ1ZmZlcmVkIC0gc3RhdHMudGZpcnN0KSk7XG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuRlJBR19CVUZGRVJFRCwge3N0YXRzOiBzdGF0cywgZnJhZzogZnJhZywgaWQgOiAnbWFpbid9KTtcbiAgICAgICAgbGV0IG1lZGlhID0gdGhpcy5tZWRpYUJ1ZmZlciA/IHRoaXMubWVkaWFCdWZmZXIgOiB0aGlzLm1lZGlhO1xuICAgICAgICBsb2dnZXIubG9nKGBtYWluIGJ1ZmZlcmVkIDogJHtUaW1lUmFuZ2VzLnRvU3RyaW5nKG1lZGlhLmJ1ZmZlcmVkKX1gKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICB9XG4gICAgICB0aGlzLnRpY2soKTtcbiAgICB9XG4gIH1cblxuICBvbkVycm9yKGRhdGEpIHtcbiAgICBsZXQgZnJhZyA9IGRhdGEuZnJhZyB8fMKgdGhpcy5mcmFnQ3VycmVudDtcbiAgICAvLyBkb24ndCBoYW5kbGUgZnJhZyBlcnJvciBub3QgcmVsYXRlZCB0byBtYWluIGZyYWdtZW50XG4gICAgaWYgKGZyYWcgJiYgZnJhZy50eXBlICE9PSAnbWFpbicpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IG1lZGlhID0gdGhpcy5tZWRpYSxcbiAgICAgICAgLy8gMC41IDogdG9sZXJhbmNlIG5lZWRlZCBhcyBzb21lIGJyb3dzZXJzIHN0YWxscyBwbGF5YmFjayBiZWZvcmUgcmVhY2hpbmcgYnVmZmVyZWQgZW5kXG4gICAgICAgIG1lZGlhQnVmZmVyZWQgPSBtZWRpYSAmJiBCdWZmZXJIZWxwZXIuaXNCdWZmZXJlZChtZWRpYSxtZWRpYS5jdXJyZW50VGltZSkgJiYgQnVmZmVySGVscGVyLmlzQnVmZmVyZWQobWVkaWEsbWVkaWEuY3VycmVudFRpbWUrMC41KTtcbiAgICBzd2l0Y2goZGF0YS5kZXRhaWxzKSB7XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5GUkFHX0xPQURfRVJST1I6XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5GUkFHX0xPQURfVElNRU9VVDpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLktFWV9MT0FEX0VSUk9SOlxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuS0VZX0xPQURfVElNRU9VVDpcbiAgICAgICAgaWYoIWRhdGEuZmF0YWwpIHtcbiAgICAgICAgICB2YXIgbG9hZEVycm9yID0gdGhpcy5mcmFnTG9hZEVycm9yO1xuICAgICAgICAgIGlmKGxvYWRFcnJvcikge1xuICAgICAgICAgICAgbG9hZEVycm9yKys7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxvYWRFcnJvcj0xO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgY29uZmlnID0gdGhpcy5jb25maWc7XG4gICAgICAgICAgLy8ga2VlcCByZXRyeWluZyAvIGRvbid0IHJhaXNlIGZhdGFsIG5ldHdvcmsgZXJyb3IgaWYgY3VycmVudCBwb3NpdGlvbiBpcyBidWZmZXJlZCBvciBpZiBpbiBhdXRvbW9kZSB3aXRoIGN1cnJlbnQgbGV2ZWwgbm90IDBcbiAgICAgICAgICBpZiAobG9hZEVycm9yIDw9IGNvbmZpZy5mcmFnTG9hZGluZ01heFJldHJ5IHx8IG1lZGlhQnVmZmVyZWQgfHwgKGZyYWcuYXV0b0xldmVsICYmIGZyYWcubGV2ZWwpKSB7XG4gICAgICAgICAgICB0aGlzLmZyYWdMb2FkRXJyb3IgPSBsb2FkRXJyb3I7XG4gICAgICAgICAgICAvLyByZXNldCBsb2FkIGNvdW50ZXIgdG8gYXZvaWQgZnJhZyBsb29wIGxvYWRpbmcgZXJyb3JcbiAgICAgICAgICAgIGZyYWcubG9hZENvdW50ZXIgPSAwO1xuICAgICAgICAgICAgLy8gZXhwb25lbnRpYWwgYmFja29mZiBjYXBwZWQgdG8gY29uZmlnLmZyYWdMb2FkaW5nTWF4UmV0cnlUaW1lb3V0XG4gICAgICAgICAgICB2YXIgZGVsYXkgPSBNYXRoLm1pbihNYXRoLnBvdygyLGxvYWRFcnJvci0xKSpjb25maWcuZnJhZ0xvYWRpbmdSZXRyeURlbGF5LGNvbmZpZy5mcmFnTG9hZGluZ01heFJldHJ5VGltZW91dCk7XG4gICAgICAgICAgICBsb2dnZXIud2FybihgbWVkaWFDb250cm9sbGVyOiBmcmFnIGxvYWRpbmcgZmFpbGVkLCByZXRyeSBpbiAke2RlbGF5fSBtc2ApO1xuICAgICAgICAgICAgdGhpcy5yZXRyeURhdGUgPSBwZXJmb3JtYW5jZS5ub3coKSArIGRlbGF5O1xuICAgICAgICAgICAgLy8gcmV0cnkgbG9hZGluZyBzdGF0ZVxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkZSQUdfTE9BRElOR19XQUlUSU5HX1JFVFJZO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsb2dnZXIuZXJyb3IoYG1lZGlhQ29udHJvbGxlcjogJHtkYXRhLmRldGFpbHN9IHJlYWNoZXMgbWF4IHJldHJ5LCByZWRpc3BhdGNoIGFzIGZhdGFsIC4uLmApO1xuICAgICAgICAgICAgLy8gcmVkaXNwYXRjaCBzYW1lIGVycm9yIGJ1dCB3aXRoIGZhdGFsIHNldCB0byB0cnVlXG4gICAgICAgICAgICBkYXRhLmZhdGFsID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuRVJST1IsIGRhdGEpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkVSUk9SO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkZSQUdfTE9PUF9MT0FESU5HX0VSUk9SOlxuICAgICAgICBpZighZGF0YS5mYXRhbCkge1xuICAgICAgICAgIC8vIGlmIGJ1ZmZlciBpcyBub3QgZW1wdHlcbiAgICAgICAgICBpZiAobWVkaWFCdWZmZXJlZCkge1xuICAgICAgICAgICAgLy8gdHJ5IHRvIHJlZHVjZSBtYXggYnVmZmVyIGxlbmd0aCA6IHJhdGlvbmFsZSBpcyB0aGF0IHdlIGNvdWxkIGdldFxuICAgICAgICAgICAgLy8gZnJhZyBsb29wIGxvYWRpbmcgZXJyb3IgYmVjYXVzZSBvZiBidWZmZXIgZXZpY3Rpb25cbiAgICAgICAgICAgIHRoaXMuX3JlZHVjZU1heEJ1ZmZlckxlbmd0aChmcmFnLmR1cmF0aW9uKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBidWZmZXIgZW1wdHkuIHJlcG9ydCBhcyBmYXRhbCBpZiBpbiBtYW51YWwgbW9kZSBvciBpZiBsb3dlc3QgbGV2ZWwuXG4gICAgICAgICAgICAvLyBsZXZlbCBjb250cm9sbGVyIHRha2VzIGNhcmUgb2YgZW1lcmdlbmN5IHN3aXRjaCBkb3duIGxvZ2ljXG4gICAgICAgICAgICBpZiAoIWZyYWcuYXV0b0xldmVsIHx8IGZyYWcubGV2ZWwgPT09IDApIHtcbiAgICAgICAgICAgICAgLy8gcmVkaXNwYXRjaCBzYW1lIGVycm9yIGJ1dCB3aXRoIGZhdGFsIHNldCB0byB0cnVlXG4gICAgICAgICAgICAgIGRhdGEuZmF0YWwgPSB0cnVlO1xuICAgICAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkVSUk9SLCBkYXRhKTtcbiAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkVSUk9SO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkxFVkVMX0xPQURfRVJST1I6XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5MRVZFTF9MT0FEX1RJTUVPVVQ6XG4gICAgICAgIGlmKHRoaXMuc3RhdGUgIT09IFN0YXRlLkVSUk9SKSB7XG4gICAgICAgICAgaWYgKGRhdGEuZmF0YWwpIHtcbiAgICAgICAgICAgLy8gaWYgZmF0YWwgZXJyb3IsIHN0b3AgcHJvY2Vzc2luZ1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkVSUk9SO1xuICAgICAgICAgICAgbG9nZ2VyLndhcm4oYHN0cmVhbUNvbnRyb2xsZXI6ICR7ZGF0YS5kZXRhaWxzfSxzd2l0Y2ggdG8gJHt0aGlzLnN0YXRlfSBzdGF0ZSAuLi5gKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gaW4gY2FzIG9mIG5vbiBmYXRhbCBlcnJvciB3aGlsZSB3YWl0aW5nIGxldmVsIGxvYWQgdG8gYmUgY29tcGxldGVkLCBzd2l0Y2ggYmFjayB0byBJRExFXG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuV0FJVElOR19MRVZFTCkge1xuICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5CVUZGRVJfRlVMTF9FUlJPUjpcbiAgICAgICAgLy8gaWYgaW4gYXBwZW5kaW5nIHN0YXRlXG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09PSBTdGF0ZS5QQVJTSU5HIHx8wqB0aGlzLnN0YXRlID09PSBTdGF0ZS5QQVJTRUQpIHtcbiAgICAgICAgICAvLyByZWR1Y2UgbWF4IGJ1ZiBsZW4gaWYgY3VycmVudCBwb3NpdGlvbiBpcyBidWZmZXJlZFxuICAgICAgICAgIGlmIChtZWRpYUJ1ZmZlcmVkKSB7XG4gICAgICAgICAgICB0aGlzLl9yZWR1Y2VNYXhCdWZmZXJMZW5ndGgoZnJhZy5kdXJhdGlvbik7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gY3VycmVudCBwb3NpdGlvbiBpcyBub3QgYnVmZmVyZWQsIGJ1dCBicm93c2VyIGlzIHN0aWxsIGNvbXBsYWluaW5nIGFib3V0IGJ1ZmZlciBmdWxsIGVycm9yXG4gICAgICAgICAgICAvLyB0aGlzIGhhcHBlbnMgb24gSUUvRWRnZSwgcmVmZXIgdG8gaHR0cHM6Ly9naXRodWIuY29tL2RhaWx5bW90aW9uL2hscy5qcy9wdWxsLzcwOFxuICAgICAgICAgICAgLy8gaW4gdGhhdCBjYXNlIGZsdXNoIHRoZSB3aG9sZSBidWZmZXIgdG8gcmVjb3ZlclxuICAgICAgICAgICAgbG9nZ2VyLndhcm4oJ2J1ZmZlciBmdWxsIGVycm9yIGFsc28gbWVkaWEuY3VycmVudFRpbWUgaXMgbm90IGJ1ZmZlcmVkLCBmbHVzaCBldmVyeXRoaW5nJyk7XG4gICAgICAgICAgICB0aGlzLmZyYWdDdXJyZW50ID0gbnVsbDtcbiAgICAgICAgICAgIC8vIGZsdXNoIGV2ZXJ5dGhpbmdcbiAgICAgICAgICAgIHRoaXMuZmx1c2hNYWluQnVmZmVyKDAsTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBfcmVkdWNlTWF4QnVmZmVyTGVuZ3RoKG1pbkxlbmd0aCkge1xuICAgIGxldCBjb25maWcgPSB0aGlzLmNvbmZpZztcbiAgICBpZiAoY29uZmlnLm1heE1heEJ1ZmZlckxlbmd0aCA+PSBtaW5MZW5ndGgpIHtcbiAgICAgIC8vIHJlZHVjZSBtYXggYnVmZmVyIGxlbmd0aCBhcyBpdCBtaWdodCBiZSB0b28gaGlnaC4gd2UgZG8gdGhpcyB0byBhdm9pZCBsb29wIGZsdXNoaW5nIC4uLlxuICAgICAgY29uZmlnLm1heE1heEJ1ZmZlckxlbmd0aC89MjtcbiAgICAgIGxvZ2dlci53YXJuKGByZWR1Y2UgbWF4IGJ1ZmZlciBsZW5ndGggdG8gJHtjb25maWcubWF4TWF4QnVmZmVyTGVuZ3RofXMgYW5kIHN3aXRjaCB0byBJRExFIHN0YXRlYCk7XG4gICAgICAvLyBpbmNyZWFzZSBmcmFnbWVudCBsb2FkIEluZGV4IHRvIGF2b2lkIGZyYWcgbG9vcCBsb2FkaW5nIGVycm9yIGFmdGVyIGJ1ZmZlciBmbHVzaFxuICAgICAgdGhpcy5mcmFnTG9hZElkeCArPSAyICogY29uZmlnLmZyYWdMb2FkaW5nTG9vcFRocmVzaG9sZDtcbiAgICB9XG4gIH1cblxuX2NoZWNrQnVmZmVyKCkge1xuICAgIHZhciBtZWRpYSA9IHRoaXMubWVkaWE7XG4gICAgLy8gaWYgcmVhZHkgc3RhdGUgZGlmZmVyZW50IGZyb20gSEFWRV9OT1RISU5HIChudW1lcmljIHZhbHVlIDApLCB3ZSBhcmUgYWxsb3dlZCB0byBzZWVrXG4gICAgaWYobWVkaWEgJiYgbWVkaWEucmVhZHlTdGF0ZSkge1xuICAgICAgICBsZXQgY3VycmVudFRpbWUgPSBtZWRpYS5jdXJyZW50VGltZSxcbiAgICAgICAgICAgICBidWZmZXJlZCA9IG1lZGlhLmJ1ZmZlcmVkO1xuICAgICAgLy8gYWRqdXN0IGN1cnJlbnRUaW1lIHRvIHN0YXJ0IHBvc2l0aW9uIG9uIGxvYWRlZCBtZXRhZGF0YVxuICAgICAgaWYoIXRoaXMubG9hZGVkbWV0YWRhdGEgJiYgYnVmZmVyZWQubGVuZ3RoICYmICFtZWRpYS5zZWVraW5nKSB7XG4gICAgICAgIHRoaXMubG9hZGVkbWV0YWRhdGEgPSB0cnVlO1xuICAgICAgICAvLyBvbmx5IGFkanVzdCBjdXJyZW50VGltZSBpZiBkaWZmZXJlbnQgZnJvbSBzdGFydFBvc2l0aW9uIG9yIGlmIHN0YXJ0UG9zaXRpb24gbm90IGJ1ZmZlcmVkXG4gICAgICAgIC8vIGF0IHRoYXQgc3RhZ2UsIHRoZXJlIHNob3VsZCBiZSBvbmx5IG9uZSBidWZmZXJlZCByYW5nZSwgYXMgd2UgcmVhY2ggdGhhdCBjb2RlIGFmdGVyIGZpcnN0IGZyYWdtZW50IGhhcyBiZWVuIGJ1ZmZlcmVkXG4gICAgICAgIGxldCBzdGFydFBvc2l0aW9uID0gdGhpcy5zdGFydFBvc2l0aW9uLFxuICAgICAgICAgICAgc3RhcnRQb3NpdGlvbkJ1ZmZlcmVkID0gQnVmZmVySGVscGVyLmlzQnVmZmVyZWQobWVkaWEsc3RhcnRQb3NpdGlvbik7XG4gICAgICAgIC8vIGlmIGN1cnJlbnRUaW1lIG5vdCBtYXRjaGluZyB3aXRoIGV4cGVjdGVkIHN0YXJ0UG9zaXRpb24gb3Igc3RhcnRQb3NpdGlvbiBub3QgYnVmZmVyZWRcbiAgICAgICAgaWYgKGN1cnJlbnRUaW1lICE9PSBzdGFydFBvc2l0aW9uIHx8ICFzdGFydFBvc2l0aW9uQnVmZmVyZWQpIHtcbiAgICAgICAgICBsb2dnZXIubG9nKGB0YXJnZXQgc3RhcnQgcG9zaXRpb246JHtzdGFydFBvc2l0aW9ufWApO1xuICAgICAgICAgIC8vIGlmIHN0YXJ0UG9zaXRpb24gbm90IGJ1ZmZlcmVkLCBsZXQncyBzZWVrIHRvIGJ1ZmZlcmVkLnN0YXJ0KDApXG4gICAgICAgICAgaWYoIXN0YXJ0UG9zaXRpb25CdWZmZXJlZCkge1xuICAgICAgICAgICAgc3RhcnRQb3NpdGlvbiA9IGJ1ZmZlcmVkLnN0YXJ0KDApO1xuICAgICAgICAgICAgbG9nZ2VyLmxvZyhgdGFyZ2V0IHN0YXJ0IHBvc2l0aW9uIG5vdCBidWZmZXJlZCwgc2VlayB0byBidWZmZXJlZC5zdGFydCgwKSAke3N0YXJ0UG9zaXRpb259YCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxvZ2dlci5sb2coYGFkanVzdCBjdXJyZW50VGltZSBmcm9tICR7Y3VycmVudFRpbWV9IHRvICR7c3RhcnRQb3NpdGlvbn1gKTtcbiAgICAgICAgICBtZWRpYS5jdXJyZW50VGltZSA9IHN0YXJ0UG9zaXRpb247XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodGhpcy5pbW1lZGlhdGVTd2l0Y2gpIHtcbiAgICAgIHRoaXMuaW1tZWRpYXRlTGV2ZWxTd2l0Y2hFbmQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBidWZmZXJJbmZvID0gQnVmZmVySGVscGVyLmJ1ZmZlckluZm8obWVkaWEsY3VycmVudFRpbWUsMCksXG4gICAgICAgICAgICBleHBlY3RlZFBsYXlpbmcgPSAhKG1lZGlhLnBhdXNlZCB8fCAvLyBub3QgcGxheWluZyB3aGVuIG1lZGlhIGlzIHBhdXNlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZWRpYS5lbmRlZCAgfHwgLy8gbm90IHBsYXlpbmcgd2hlbiBtZWRpYSBpcyBlbmRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZWRpYS5idWZmZXJlZC5sZW5ndGggPT09IDApLCAvLyBub3QgcGxheWluZyBpZiBub3RoaW5nIGJ1ZmZlcmVkXG4gICAgICAgICAgICBqdW1wVGhyZXNob2xkID0gMC41LCAvLyB0b2xlcmFuY2UgbmVlZGVkIGFzIHNvbWUgYnJvd3NlcnMgc3RhbGxzIHBsYXliYWNrIGJlZm9yZSByZWFjaGluZyBidWZmZXJlZCByYW5nZSBlbmRcbiAgICAgICAgICAgIHBsYXloZWFkTW92aW5nID0gY3VycmVudFRpbWUgPiBtZWRpYS5wbGF5YmFja1JhdGUqdGhpcy5sYXN0Q3VycmVudFRpbWUsXG4gICAgICAgICAgICBjb25maWcgPSB0aGlzLmNvbmZpZztcblxuICAgICAgICBpZiAodGhpcy5zdGFsbGVkICYmIHBsYXloZWFkTW92aW5nKSB7XG4gICAgICAgICAgdGhpcy5zdGFsbGVkID0gZmFsc2U7XG4gICAgICAgICAgbG9nZ2VyLmxvZyhgcGxheWJhY2sgbm90IHN0dWNrIGFueW1vcmUgQCR7Y3VycmVudFRpbWV9YCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY2hlY2sgYnVmZmVyIHVwZnJvbnRcbiAgICAgICAgLy8gaWYgbGVzcyB0aGFuIGp1bXBUaHJlc2hvbGQgc2Vjb25kIGlzIGJ1ZmZlcmVkLCBsZXQncyBjaGVjayBpbiBtb3JlIGRldGFpbHNcbiAgICAgICAgaWYoZXhwZWN0ZWRQbGF5aW5nICYmIGJ1ZmZlckluZm8ubGVuIDw9IGp1bXBUaHJlc2hvbGQpIHtcbiAgICAgICAgICBpZihwbGF5aGVhZE1vdmluZykge1xuICAgICAgICAgICAgLy8gcGxheWhlYWQgbW92aW5nXG4gICAgICAgICAgICBqdW1wVGhyZXNob2xkID0gMDtcbiAgICAgICAgICAgIHRoaXMuc2Vla0hvbGVOdWRnZUR1cmF0aW9uID0gMDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gcGxheWhlYWQgbm90IG1vdmluZyBBTkQgbWVkaWEgZXhwZWN0ZWQgdG8gcGxheVxuICAgICAgICAgICAgaWYoIXRoaXMuc3RhbGxlZCkge1xuICAgICAgICAgICAgICB0aGlzLnNlZWtIb2xlTnVkZ2VEdXJhdGlvbiA9IDA7XG4gICAgICAgICAgICAgIGxvZ2dlci5sb2coYHBsYXliYWNrIHNlZW1zIHN0dWNrIEAke2N1cnJlbnRUaW1lfWApO1xuICAgICAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkVSUk9SLCB7dHlwZTogRXJyb3JUeXBlcy5NRURJQV9FUlJPUiwgZGV0YWlsczogRXJyb3JEZXRhaWxzLkJVRkZFUl9TVEFMTEVEX0VSUk9SLCBmYXRhbDogZmFsc2V9KTtcbiAgICAgICAgICAgICAgdGhpcy5zdGFsbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuc2Vla0hvbGVOdWRnZUR1cmF0aW9uICs9IGNvbmZpZy5zZWVrSG9sZU51ZGdlRHVyYXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIGlmIHdlIGFyZSBiZWxvdyB0aHJlc2hvbGQsIHRyeSB0byBqdW1wIHRvIHN0YXJ0IG9mIG5leHQgYnVmZmVyIHJhbmdlIGlmIGNsb3NlXG4gICAgICAgICAgaWYoYnVmZmVySW5mby5sZW4gPD0ganVtcFRocmVzaG9sZCkge1xuICAgICAgICAgICAgLy8gbm8gYnVmZmVyIGF2YWlsYWJsZSBAIGN1cnJlbnRUaW1lLCBjaGVjayBpZiBuZXh0IGJ1ZmZlciBpcyBjbG9zZSAod2l0aGluIGEgY29uZmlnLm1heFNlZWtIb2xlIHNlY29uZCByYW5nZSlcbiAgICAgICAgICAgIHZhciBuZXh0QnVmZmVyU3RhcnQgPSBidWZmZXJJbmZvLm5leHRTdGFydCwgZGVsdGEgPSBuZXh0QnVmZmVyU3RhcnQtY3VycmVudFRpbWU7XG4gICAgICAgICAgICBpZihuZXh0QnVmZmVyU3RhcnQgJiZcbiAgICAgICAgICAgICAgIChkZWx0YSA8IGNvbmZpZy5tYXhTZWVrSG9sZSkgJiZcbiAgICAgICAgICAgICAgIChkZWx0YSA+IDApKSB7XG4gICAgICAgICAgICAgIC8vIG5leHQgYnVmZmVyIGlzIGNsb3NlICEgYWRqdXN0IGN1cnJlbnRUaW1lIHRvIG5leHRCdWZmZXJTdGFydFxuICAgICAgICAgICAgICAvLyB0aGlzIHdpbGwgZW5zdXJlIGVmZmVjdGl2ZSB2aWRlbyBkZWNvZGluZ1xuICAgICAgICAgICAgICBsb2dnZXIubG9nKGBhZGp1c3QgY3VycmVudFRpbWUgZnJvbSAke21lZGlhLmN1cnJlbnRUaW1lfSB0byBuZXh0IGJ1ZmZlcmVkIEAgJHtuZXh0QnVmZmVyU3RhcnR9ICsgbnVkZ2UgJHt0aGlzLnNlZWtIb2xlTnVkZ2VEdXJhdGlvbn1gKTtcbiAgICAgICAgICAgICAgbGV0IGhvbGUgPSBuZXh0QnVmZmVyU3RhcnQgKyB0aGlzLnNlZWtIb2xlTnVkZ2VEdXJhdGlvbiAtIG1lZGlhLmN1cnJlbnRUaW1lO1xuICAgICAgICAgICAgICBtZWRpYS5jdXJyZW50VGltZSA9IG5leHRCdWZmZXJTdGFydCArIHRoaXMuc2Vla0hvbGVOdWRnZUR1cmF0aW9uO1xuICAgICAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkVSUk9SLCB7dHlwZTogRXJyb3JUeXBlcy5NRURJQV9FUlJPUiwgZGV0YWlsczogRXJyb3JEZXRhaWxzLkJVRkZFUl9TRUVLX09WRVJfSE9MRSwgZmF0YWw6IGZhbHNlLCBob2xlIDogaG9sZX0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIG9uRnJhZ0xvYWRFbWVyZ2VuY3lBYm9ydGVkKCkge1xuICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgIC8vIGlmIGxvYWRlZG1ldGFkYXRhIGlzIG5vdCBzZXQsIGl0IG1lYW5zIHRoYXQgd2UgYXJlIGVtZXJnZW5jeSBzd2l0Y2ggZG93biBvbiBmaXJzdCBmcmFnXG4gICAgLy8gaW4gdGhhdCBjYXNlLCByZXNldCBzdGFydEZyYWdSZXF1ZXN0ZWQgZmxhZ1xuICAgIGlmKCF0aGlzLmxvYWRlZG1ldGFkYXRhKSB7XG4gICAgICB0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCA9IGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLnRpY2soKTtcbiAgfVxuXG4gIG9uQnVmZmVyRmx1c2hlZCgpIHtcbiAgICAvKiBhZnRlciBzdWNjZXNzZnVsIGJ1ZmZlciBmbHVzaGluZywgcmVidWlsZCBidWZmZXIgUmFuZ2UgYXJyYXlcbiAgICAgIGxvb3AgdGhyb3VnaCBleGlzdGluZyBidWZmZXIgcmFuZ2UgYW5kIGNoZWNrIGlmXG4gICAgICBjb3JyZXNwb25kaW5nIHJhbmdlIGlzIHN0aWxsIGJ1ZmZlcmVkLiBvbmx5IHB1c2ggdG8gbmV3IGFycmF5IGFscmVhZHkgYnVmZmVyZWQgcmFuZ2VcbiAgICAgIHVzZSBtZWRpYUJ1ZmZlcmVkIGluc3RlYWQgb2YgbWVkaWEgKHNvIHRoYXQgd2Ugd2lsbCBjaGVjayBhZ2FpbnN0IHZpZGVvLmJ1ZmZlcmVkIHJhbmdlcyBpbiBjYXNlIG9mIGFsdCBhdWRpbyB0cmFjaylcbiAgICAqL1xuICAgIGxldCBtZWRpYSA9IHRoaXMubWVkaWFCdWZmZXIgPyB0aGlzLm1lZGlhQnVmZmVyIDogdGhpcy5tZWRpYSxcbiAgICAgICAgYnVmZmVyUmFuZ2UgPSB0aGlzLmJ1ZmZlclJhbmdlLFxuICAgICAgICBuZXdSYW5nZSA9IFtdLHJhbmdlLGk7XG4gICAgZm9yIChpID0gMDsgaSA8IGJ1ZmZlclJhbmdlLmxlbmd0aDsgaSsrKSB7XG4gICAgICByYW5nZSA9IGJ1ZmZlclJhbmdlW2ldO1xuICAgICAgaWYgKEJ1ZmZlckhlbHBlci5pc0J1ZmZlcmVkKG1lZGlhLChyYW5nZS5zdGFydCArIHJhbmdlLmVuZCkgLyAyKSkge1xuICAgICAgICBuZXdSYW5nZS5wdXNoKHJhbmdlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5idWZmZXJSYW5nZSA9IG5ld1JhbmdlO1xuXG4gICAgLy8gaW5jcmVhc2UgZnJhZ21lbnQgbG9hZCBJbmRleCB0byBhdm9pZCBmcmFnIGxvb3AgbG9hZGluZyBlcnJvciBhZnRlciBidWZmZXIgZmx1c2hcbiAgICB0aGlzLmZyYWdMb2FkSWR4ICs9IDIgKiB0aGlzLmNvbmZpZy5mcmFnTG9hZGluZ0xvb3BUaHJlc2hvbGQ7XG4gICAgLy8gbW92ZSB0byBJRExFIG9uY2UgZmx1c2ggY29tcGxldGUuIHRoaXMgc2hvdWxkIHRyaWdnZXIgbmV3IGZyYWdtZW50IGxvYWRpbmdcbiAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAvLyByZXNldCByZWZlcmVuY2UgdG8gZnJhZ1xuICAgIHRoaXMuZnJhZ1ByZXZpb3VzID0gbnVsbDtcbiAgfVxuXG4gIG9uTGV2ZWxSZW1vdmVkKGRhdGEpIHtcbiAgICB0aGlzLmxldmVscyA9IHRoaXMubGV2ZWxzLmZpbHRlcigobGV2ZWwsIGluZGV4KSA9PiBpbmRleCAhPT0gZGF0YS5sZXZlbCk7XG4gIH1cblxuICBzd2FwQXVkaW9Db2RlYygpIHtcbiAgICB0aGlzLmF1ZGlvQ29kZWNTd2FwID0gIXRoaXMuYXVkaW9Db2RlY1N3YXA7XG4gIH1cblxuICBjb21wdXRlTGl2ZVBvc2l0aW9uKHNsaWRpbmcsIGxldmVsRGV0YWlscykge1xuICAgIGxldCB0YXJnZXRMYXRlbmN5ID0gdGhpcy5jb25maWcubGl2ZVN5bmNEdXJhdGlvbiAhPT0gdW5kZWZpbmVkID8gdGhpcy5jb25maWcubGl2ZVN5bmNEdXJhdGlvbiA6IHRoaXMuY29uZmlnLmxpdmVTeW5jRHVyYXRpb25Db3VudCAqIGxldmVsRGV0YWlscy50YXJnZXRkdXJhdGlvbjtcbiAgICByZXR1cm4gc2xpZGluZyArIE1hdGgubWF4KDAsIGxldmVsRGV0YWlscy50b3RhbGR1cmF0aW9uIC0gdGFyZ2V0TGF0ZW5jeSk7XG4gIH1cblxuICBnZXQgbGl2ZVN5bmNQb3NpdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fbGl2ZVN5bmNQb3NpdGlvbjtcbiAgfVxuXG4gIHNldCBsaXZlU3luY1Bvc2l0aW9uKHZhbHVlKSB7XG4gICAgdGhpcy5fbGl2ZVN5bmNQb3NpdGlvbiA9IHZhbHVlO1xuICB9XG59XG5leHBvcnQgZGVmYXVsdCBTdHJlYW1Db250cm9sbGVyO1xuXG4iLCIvKlxuICogU3VidGl0bGUgU3RyZWFtIENvbnRyb2xsZXJcbiovXG5cbmltcG9ydCBFdmVudCBmcm9tICcuLi9ldmVudHMnO1xuaW1wb3J0IEV2ZW50SGFuZGxlciBmcm9tICcuLi9ldmVudC1oYW5kbGVyJztcbmltcG9ydCB7bG9nZ2VyfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xuXG5jbGFzcyBTdWJ0aXRsZVN0cmVhbUNvbnRyb2xsZXIgZXh0ZW5kcyBFdmVudEhhbmRsZXIge1xuXG4gIGNvbnN0cnVjdG9yKGhscykge1xuICAgIHN1cGVyKGhscyxcbiAgICAgIEV2ZW50LkVSUk9SLFxuICAgICAgRXZlbnQuU1VCVElUTEVfVFJBQ0tTX1VQREFURUQsXG4gICAgICBFdmVudC5TVUJUSVRMRV9UUkFDS19TV0lUQ0gsXG4gICAgICBFdmVudC5TVUJUSVRMRV9UUkFDS19MT0FERUQsXG4gICAgICBFdmVudC5TVUJUSVRMRV9GUkFHX1BST0NFU1NFRCk7XG4gICAgdGhpcy5jb25maWcgPSBobHMuY29uZmlnO1xuICAgIHRoaXMudnR0RnJhZ1NOc1Byb2Nlc3NlZCA9IHt9O1xuICAgIHRoaXMudnR0RnJhZ1F1ZXVlcyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmN1cnJlbnRseVByb2Nlc3NpbmcgPSBudWxsO1xuICAgIHRoaXMuY3VycmVudFRyYWNrSWQgPSAtMTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgRXZlbnRIYW5kbGVyLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XG4gIH1cblxuICAvLyBSZW1vdmUgYWxsIHF1ZXVlZCBpdGVtcyBhbmQgY3JlYXRlIGEgbmV3LCBlbXB0eSBxdWV1ZSBmb3IgZWFjaCB0cmFjay5cbiAgY2xlYXJWdHRGcmFnUXVldWVzKCkge1xuICAgIHRoaXMudnR0RnJhZ1F1ZXVlcyA9IHt9O1xuICAgIHRoaXMudHJhY2tzLmZvckVhY2godHJhY2sgPT4ge1xuICAgICAgdGhpcy52dHRGcmFnUXVldWVzW3RyYWNrLmlkXSA9IFtdO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gSWYgbm8gZnJhZyBpcyBiZWluZyBwcm9jZXNzZWQgYW5kIHF1ZXVlIGlzbid0IGVtcHR5LCBpbml0aWF0ZSBwcm9jZXNzaW5nIG9mIG5leHQgZnJhZyBpbiBsaW5lLlxuICBuZXh0RnJhZygpIHtcbiAgICBpZih0aGlzLmN1cnJlbnRseVByb2Nlc3NpbmcgPT09IG51bGwgJiYgdGhpcy5jdXJyZW50VHJhY2tJZCA+IC0xICYmIHRoaXMudnR0RnJhZ1F1ZXVlc1t0aGlzLmN1cnJlbnRUcmFja0lkXS5sZW5ndGgpIHtcbiAgICAgIGxldCBmcmFnID0gdGhpcy5jdXJyZW50bHlQcm9jZXNzaW5nID0gdGhpcy52dHRGcmFnUXVldWVzW3RoaXMuY3VycmVudFRyYWNrSWRdLnNoaWZ0KCk7XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkZSQUdfTE9BRElORywge2ZyYWd9KTtcbiAgICB9XG4gIH1cblxuICAvLyBXaGVuIGZyYWdtZW50IGhhcyBmaW5pc2hlZCBwcm9jZXNzaW5nLCBhZGQgc24gdG8gbGlzdCBvZiBjb21wbGV0ZWQgaWYgc3VjY2Vzc2Z1bC5cbiAgb25TdWJ0aXRsZUZyYWdQcm9jZXNzZWQoZGF0YSkge1xuICAgIGlmKGRhdGEuc3VjY2Vzcykge1xuICAgICAgdGhpcy52dHRGcmFnU05zUHJvY2Vzc2VkW2RhdGEuZnJhZy50cmFja0lkXS5wdXNoKGRhdGEuZnJhZy5zbik7XG4gICAgfVxuICAgIHRoaXMuY3VycmVudGx5UHJvY2Vzc2luZyA9IG51bGw7XG4gICAgdGhpcy5uZXh0RnJhZygpO1xuICB9XG5cbiAgLy8gSWYgc29tZXRoaW5nIGdvZXMgd3JvbmcsIHByb2NlZGUgdG8gbmV4dCBmcmFnLCBpZiB3ZSB3ZXJlIHByb2Nlc3Npbmcgb25lLlxuICBvbkVycm9yKGRhdGEpIHtcbiAgICBsZXQgZnJhZyA9IGRhdGEuZnJhZztcbiAgICAvLyBkb24ndCBoYW5kbGUgZnJhZyBlcnJvciBub3QgcmVsYXRlZCB0byBzdWJ0aXRsZSBmcmFnbWVudFxuICAgIGlmIChmcmFnICYmIGZyYWcudHlwZSAhPT0gJ3N1YnRpdGxlJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZih0aGlzLmN1cnJlbnRseVByb2Nlc3NpbmcpIHtcbiAgICAgIHRoaXMuY3VycmVudGx5UHJvY2Vzc2luZyA9IG51bGw7XG4gICAgICB0aGlzLm5leHRGcmFnKCk7XG4gICAgfVxuICB9XG5cbiAgLy8gR290IGFsbCBuZXcgc3VidGl0bGUgdHJhY2tzLlxuICBvblN1YnRpdGxlVHJhY2tzVXBkYXRlZChkYXRhKSB7XG4gICAgbG9nZ2VyLmxvZygnc3VidGl0bGUgdHJhY2tzIHVwZGF0ZWQnKTtcbiAgICB0aGlzLnRyYWNrcyA9IGRhdGEuc3VidGl0bGVUcmFja3M7XG4gICAgdGhpcy5jbGVhclZ0dEZyYWdRdWV1ZXMoKTtcbiAgICB0aGlzLnZ0dEZyYWdTTnNQcm9jZXNzZWQgPSB7fTtcbiAgICB0aGlzLnRyYWNrcy5mb3JFYWNoKHRyYWNrID0+IHtcbiAgICAgIHRoaXMudnR0RnJhZ1NOc1Byb2Nlc3NlZFt0cmFjay5pZF0gPSBbXTtcbiAgICB9KTtcbiAgfVxuXG4gIG9uU3VidGl0bGVUcmFja1N3aXRjaChkYXRhKSB7XG4gICAgdGhpcy5jdXJyZW50VHJhY2tJZCA9IGRhdGEuaWQ7XG4gICAgdGhpcy5jbGVhclZ0dEZyYWdRdWV1ZXMoKTtcbiAgfVxuXG4gIC8vIEdvdCBhIG5ldyBzZXQgb2Ygc3VidGl0bGUgZnJhZ21lbnRzLlxuICBvblN1YnRpdGxlVHJhY2tMb2FkZWQoZGF0YSkge1xuICAgIGNvbnN0IHByb2Nlc3NlZEZyYWdTTnMgPSB0aGlzLnZ0dEZyYWdTTnNQcm9jZXNzZWRbZGF0YS5pZF0sXG4gICAgICAgIGZyYWdRdWV1ZSA9IHRoaXMudnR0RnJhZ1F1ZXVlc1tkYXRhLmlkXSxcbiAgICAgICAgY3VycmVudEZyYWdTTiA9ICEhdGhpcy5jdXJyZW50bHlQcm9jZXNzaW5nID8gdGhpcy5jdXJyZW50bHlQcm9jZXNzaW5nLnNuIDogLTE7XG5cbiAgICBjb25zdCBhbHJlYWR5UHJvY2Vzc2VkID0gZnVuY3Rpb24oZnJhZykge1xuICAgICAgcmV0dXJuIHByb2Nlc3NlZEZyYWdTTnMuaW5kZXhPZihmcmFnLnNuKSA+IC0xO1xuICAgIH07XG5cbiAgICBjb25zdCBhbHJlYWR5SW5RdWV1ZSA9IGZ1bmN0aW9uKGZyYWcpIHtcbiAgICAgIHJldHVybiBmcmFnUXVldWUuc29tZShmcmFnSW5RdWV1ZSA9PiB7cmV0dXJuIGZyYWdJblF1ZXVlLnNuID09PSBmcmFnLnNuO30pO1xuICAgIH07XG5cbiAgICAvLyBBZGQgYWxsIGZyYWdtZW50cyB0aGF0IGhhdmVuJ3QgYmVlbiwgYXJlbid0IGN1cnJlbnRseSBiZWluZyBhbmQgYXJlbid0IHdhaXRpbmcgdG8gYmUgcHJvY2Vzc2VkLCB0byBxdWV1ZS5cbiAgICBkYXRhLmRldGFpbHMuZnJhZ21lbnRzLmZvckVhY2goZnJhZyA9PsKge1xuICAgICAgaWYoIShhbHJlYWR5UHJvY2Vzc2VkKGZyYWcpIHx8IGZyYWcuc24gPT09IGN1cnJlbnRGcmFnU04gfHwgYWxyZWFkeUluUXVldWUoZnJhZykpKSB7XG4gICAgICAgIC8vIEZyYWdzIGRvbid0IGtub3cgdGhlaXIgc3VidGl0bGUgdHJhY2sgSUQsIHNvIGxldCdzIGp1c3QgYWRkIHRoYXQuLi5cbiAgICAgICAgZnJhZy50cmFja0lkID0gZGF0YS5pZDtcbiAgICAgICAgZnJhZ1F1ZXVlLnB1c2goZnJhZyk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzLm5leHRGcmFnKCk7XG4gIH1cbn1cbmV4cG9ydCBkZWZhdWx0IFN1YnRpdGxlU3RyZWFtQ29udHJvbGxlcjtcblxuIiwiLypcbiAqIGF1ZGlvIHRyYWNrIGNvbnRyb2xsZXJcbiovXG5cbmltcG9ydCBFdmVudCBmcm9tICcuLi9ldmVudHMnO1xuaW1wb3J0IEV2ZW50SGFuZGxlciBmcm9tICcuLi9ldmVudC1oYW5kbGVyJztcbmltcG9ydCB7bG9nZ2VyfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xuXG5jbGFzcyBTdWJ0aXRsZVRyYWNrQ29udHJvbGxlciBleHRlbmRzIEV2ZW50SGFuZGxlciB7XG5cbiAgY29uc3RydWN0b3IoaGxzKSB7XG4gICAgc3VwZXIoaGxzLFxuICAgICAgICAgICAgICAgRXZlbnQuTUVESUFfQVRUQUNIRUQsXG4gICAgICAgICAgICAgICBFdmVudC5NRURJQV9ERVRBQ0hJTkcsXG4gICAgICAgICAgICAgICBFdmVudC5NQU5JRkVTVF9MT0FESU5HLFxuICAgICAgICAgICAgICAgRXZlbnQuTUFOSUZFU1RfTE9BREVELFxuICAgICAgICAgICAgICAgRXZlbnQuU1VCVElUTEVfVFJBQ0tfTE9BREVEKTtcbiAgICB0aGlzLnRyYWNrcyA9IFtdO1xuICAgIHRoaXMudHJhY2tJZCA9IC0xO1xuICAgIHRoaXMubWVkaWEgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIEV2ZW50SGFuZGxlci5wcm90b3R5cGUuZGVzdHJveS5jYWxsKHRoaXMpO1xuICB9XG5cbiAgLy8gTGlzdGVuIGZvciBzdWJ0aXRsZSB0cmFjayBjaGFuZ2UsIHRoZW4gZXh0cmFjdCB0aGUgY3VycmVudCB0cmFjayBJRC5cbiAgb25NZWRpYUF0dGFjaGVkKGRhdGEpIHtcbiAgICB0aGlzLm1lZGlhID0gZGF0YS5tZWRpYTtcbiAgICBpZiAoIXRoaXMubWVkaWEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLm1lZGlhLnRleHRUcmFja3MuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgKCkgPT4ge1xuICAgICAgLy8gTWVkaWEgaXMgdW5kZWZpbmVkIHdoZW4gc3dpdGNoaW5nIHN0cmVhbXMgdmlhIGxvYWRTb3VyY2UoKVxuICAgICAgaWYgKCF0aGlzLm1lZGlhKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgbGV0IHRyYWNrSWQgPSAtMTtcbiAgICAgIGxldCB0cmFja3MgPSB0aGlzLm1lZGlhLnRleHRUcmFja3M7XG4gICAgICBmb3IobGV0IGlkID0gMDsgaWQ8IHRyYWNrcy5sZW5ndGg7IGlkKyspIHtcbiAgICAgICAgaWYodHJhY2tzW2lkXS5tb2RlID09PSAnc2hvd2luZycpIHtcbiAgICAgICAgICB0cmFja0lkID0gaWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIFNldHRpbmcgY3VycmVudCBzdWJ0aXRsZVRyYWNrIHdpbGwgaW52b2tlIGNvZGUuXG4gICAgICB0aGlzLnN1YnRpdGxlVHJhY2sgPSB0cmFja0lkO1xuICAgIH0pO1xuICB9XG5cbiAgb25NZWRpYURldGFjaGluZygpIHtcbiAgICAvLyBUT0RPOiBSZW1vdmUgZXZlbnQgbGlzdGVuZXJzLlxuICAgIHRoaXMubWVkaWEgPSB1bmRlZmluZWQ7XG4gIH1cblxuICAvLyBSZXNldCBzdWJ0aXRsZSB0cmFja3Mgb24gbWFuaWZlc3QgbG9hZGluZ1xuICBvbk1hbmlmZXN0TG9hZGluZygpIHtcbiAgICB0aGlzLnRyYWNrcyA9IFtdO1xuICAgIHRoaXMudHJhY2tJZCA9IC0xO1xuICB9XG5cbiAgLy8gRmlyZWQgd2hlbmV2ZXIgYSBuZXcgbWFuaWZlc3QgaXMgbG9hZGVkLlxuICBvbk1hbmlmZXN0TG9hZGVkKGRhdGEpIHtcbiAgICBsZXQgdHJhY2tzID0gZGF0YS5zdWJ0aXRsZXMgfHwgW107XG4gICAgbGV0IGRlZmF1bHRGb3VuZCA9IGZhbHNlO1xuICAgIHRoaXMudHJhY2tzID0gdHJhY2tzO1xuICAgIHRoaXMudHJhY2tJZCA9IC0xO1xuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuU1VCVElUTEVfVFJBQ0tTX1VQREFURUQsIHtzdWJ0aXRsZVRyYWNrcyA6IHRyYWNrc30pO1xuXG4gICAgLy8gbG9vcCB0aHJvdWdoIGF2YWlsYWJsZSBzdWJ0aXRsZSB0cmFja3MgYW5kIGF1dG9zZWxlY3QgZGVmYXVsdCBpZiBuZWVkZWRcbiAgICAvLyBUT0RPOiBpbXByb3ZlIHNlbGVjdGlvbiBsb2dpYyB0byBoYW5kbGUgZm9yY2VkLCBldGNcbiAgICB0cmFja3MuZm9yRWFjaCh0cmFjayA9PiB7XG4gICAgICBpZiAodHJhY2suZGVmYXVsdCkge1xuICAgICAgICB0aGlzLnN1YnRpdGxlVHJhY2sgPSB0cmFjay5pZDtcbiAgICAgICAgZGVmYXVsdEZvdW5kID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8vIFRyaWdnZXIgc3VidGl0bGUgdHJhY2sgcGxheWxpc3QgcmVsb2FkLlxuICBvblRpY2soKSB7XG4gICAgY29uc3QgdHJhY2tJZCA9IHRoaXMudHJhY2tJZDtcbiAgICBjb25zdCBzdWJ0aXRsZVRyYWNrID0gdGhpcy50cmFja3NbdHJhY2tJZF07XG4gICAgaWYgKCFzdWJ0aXRsZVRyYWNrKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgZGV0YWlscyA9IHN1YnRpdGxlVHJhY2suZGV0YWlscztcbiAgICAvLyBjaGVjayBpZiB3ZSBuZWVkIHRvIGxvYWQgcGxheWxpc3QgZm9yIHRoaXMgc3VidGl0bGUgVHJhY2tcbiAgICBpZiAoZGV0YWlscyA9PT0gdW5kZWZpbmVkIHx8IGRldGFpbHMubGl2ZSA9PT0gdHJ1ZSkge1xuICAgICAgLy8gdHJhY2sgbm90IHJldHJpZXZlZCB5ZXQsIG9yIGxpdmUgcGxheWxpc3Qgd2UgbmVlZCB0byAocmUpbG9hZCBpdFxuICAgICAgbG9nZ2VyLmxvZyhgKHJlKWxvYWRpbmcgcGxheWxpc3QgZm9yIHN1YnRpdGxlIHRyYWNrICR7dHJhY2tJZH1gKTtcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuU1VCVElUTEVfVFJBQ0tfTE9BRElORywge3VybDogc3VidGl0bGVUcmFjay51cmwsIGlkOiB0cmFja0lkfSk7XG4gICAgfVxuICB9XG5cbiAgb25TdWJ0aXRsZVRyYWNrTG9hZGVkKGRhdGEpIHtcbiAgICBpZiAoZGF0YS5pZCA8IHRoaXMudHJhY2tzLmxlbmd0aCkge1xuICAgICAgbG9nZ2VyLmxvZyhgc3VidGl0bGUgdHJhY2sgJHtkYXRhLmlkfSBsb2FkZWRgKTtcbiAgICAgIHRoaXMudHJhY2tzW2RhdGEuaWRdLmRldGFpbHMgPSBkYXRhLmRldGFpbHM7XG4gICAgICAvLyBjaGVjayBpZiBjdXJyZW50IHBsYXlsaXN0IGlzIGEgbGl2ZSBwbGF5bGlzdFxuICAgICAgaWYgKGRhdGEuZGV0YWlscy5saXZlICYmICF0aGlzLnRpbWVyKSB7XG4gICAgICAgIC8vIGlmIGxpdmUgcGxheWxpc3Qgd2Ugd2lsbCBoYXZlIHRvIHJlbG9hZCBpdCBwZXJpb2RpY2FsbHlcbiAgICAgICAgLy8gc2V0IHJlbG9hZCBwZXJpb2QgdG8gcGxheWxpc3QgdGFyZ2V0IGR1cmF0aW9uXG4gICAgICAgIHRoaXMudGltZXIgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgICAgdGhpcy5vblRpY2soKTtcbiAgICAgICAgfSwgMTAwMCAqIGRhdGEuZGV0YWlscy50YXJnZXRkdXJhdGlvbiwgdGhpcyk7XG4gICAgICB9XG4gICAgICBpZiAoIWRhdGEuZGV0YWlscy5saXZlICYmIHRoaXMudGltZXIpIHtcbiAgICAgICAgLy8gcGxheWxpc3QgaXMgbm90IGxpdmUgYW5kIHRpbWVyIGlzIGFybWVkIDogc3RvcHBpbmcgaXRcbiAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLnRpbWVyKTtcbiAgICAgICAgdGhpcy50aW1lciA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqIGdldCBhbHRlcm5hdGUgc3VidGl0bGUgdHJhY2tzIGxpc3QgZnJvbSBwbGF5bGlzdCAqKi9cbiAgZ2V0IHN1YnRpdGxlVHJhY2tzKCkge1xuICAgIHJldHVybiB0aGlzLnRyYWNrcztcbiAgfVxuXG4gIC8qKiBnZXQgaW5kZXggb2YgdGhlIHNlbGVjdGVkIHN1YnRpdGxlIHRyYWNrIChpbmRleCBpbiBzdWJ0aXRsZSB0cmFjayBsaXN0cykgKiovXG4gIGdldCBzdWJ0aXRsZVRyYWNrKCkge1xuICAgcmV0dXJuIHRoaXMudHJhY2tJZDtcbiAgfVxuXG4gIC8qKiBzZWxlY3QgYSBzdWJ0aXRsZSB0cmFjaywgYmFzZWQgb24gaXRzIGluZGV4IGluIHN1YnRpdGxlIHRyYWNrIGxpc3RzKiovXG4gIHNldCBzdWJ0aXRsZVRyYWNrKHN1YnRpdGxlVHJhY2tJZCkge1xuICAgIGlmICh0aGlzLnRyYWNrSWQgIT09IHN1YnRpdGxlVHJhY2tJZCkgey8vIHx8IHRoaXMudHJhY2tzW3N1YnRpdGxlVHJhY2tJZF0uZGV0YWlscyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLnNldFN1YnRpdGxlVHJhY2tJbnRlcm5hbChzdWJ0aXRsZVRyYWNrSWQpO1xuICAgIH1cbiAgfVxuXG4gc2V0U3VidGl0bGVUcmFja0ludGVybmFsKG5ld0lkKSB7XG4gICAgLy8gY2hlY2sgaWYgbGV2ZWwgaWR4IGlzIHZhbGlkXG4gICAgaWYgKG5ld0lkID49IDAgJiYgbmV3SWQgPCB0aGlzLnRyYWNrcy5sZW5ndGgpIHtcbiAgICAgIC8vIHN0b3BwaW5nIGxpdmUgcmVsb2FkaW5nIHRpbWVyIGlmIGFueVxuICAgICAgaWYgKHRoaXMudGltZXIpIHtcbiAgICAgICBjbGVhckludGVydmFsKHRoaXMudGltZXIpO1xuICAgICAgIHRoaXMudGltZXIgPSBudWxsO1xuICAgICAgfVxuICAgICAgdGhpcy50cmFja0lkID0gbmV3SWQ7XG4gICAgICBsb2dnZXIubG9nKGBzd2l0Y2hpbmcgdG8gc3VidGl0bGUgdHJhY2sgJHtuZXdJZH1gKTtcbiAgICAgIGxldCBzdWJ0aXRsZVRyYWNrID0gdGhpcy50cmFja3NbbmV3SWRdO1xuICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5TVUJUSVRMRV9UUkFDS19TV0lUQ0gsIHtpZDogbmV3SWR9KTtcbiAgICAgICAvLyBjaGVjayBpZiB3ZSBuZWVkIHRvIGxvYWQgcGxheWxpc3QgZm9yIHRoaXMgc3VidGl0bGUgVHJhY2tcbiAgICAgIGxldCBkZXRhaWxzID0gc3VidGl0bGVUcmFjay5kZXRhaWxzO1xuICAgICAgaWYgKGRldGFpbHMgPT09IHVuZGVmaW5lZCB8fCBkZXRhaWxzLmxpdmUgPT09IHRydWUpIHtcbiAgICAgICAgLy8gdHJhY2sgbm90IHJldHJpZXZlZCB5ZXQsIG9yIGxpdmUgcGxheWxpc3Qgd2UgbmVlZCB0byAocmUpbG9hZCBpdFxuICAgICAgICBsb2dnZXIubG9nKGAocmUpbG9hZGluZyBwbGF5bGlzdCBmb3Igc3VidGl0bGUgdHJhY2sgJHtuZXdJZH1gKTtcbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5TVUJUSVRMRV9UUkFDS19MT0FESU5HLCB7dXJsOiBzdWJ0aXRsZVRyYWNrLnVybCwgaWQ6IG5ld0lkfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFN1YnRpdGxlVHJhY2tDb250cm9sbGVyO1xuIiwiLypcbiAqIFRpbWVsaW5lIENvbnRyb2xsZXJcbiovXG5cbmltcG9ydCBFdmVudCBmcm9tICcuLi9ldmVudHMnO1xuaW1wb3J0IEV2ZW50SGFuZGxlciBmcm9tICcuLi9ldmVudC1oYW5kbGVyJztcbmltcG9ydCBDZWE2MDhQYXJzZXIgZnJvbSAnLi4vdXRpbHMvY2VhLTYwOC1wYXJzZXInO1xuaW1wb3J0IFdlYlZUVFBhcnNlciBmcm9tICcuLi91dGlscy93ZWJ2dHQtcGFyc2VyJztcbmltcG9ydCB7bG9nZ2VyfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xuXG5mdW5jdGlvbiBjbGVhckN1cnJlbnRDdWVzKHRyYWNrKSB7XG4gIGlmICh0cmFjayAmJiB0cmFjay5jdWVzKSB7XG4gICAgd2hpbGUgKHRyYWNrLmN1ZXMubGVuZ3RoID4gMCkge1xuICAgICAgdHJhY2sucmVtb3ZlQ3VlKHRyYWNrLmN1ZXNbMF0pO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZXVzZVZ0dFRleHRUcmFjayhpblVzZVRyYWNrLCBtYW5pZmVzdFRyYWNrKSB7XG4gIHJldHVybiBpblVzZVRyYWNrICYmIGluVXNlVHJhY2subGFiZWwgPT09IG1hbmlmZXN0VHJhY2submFtZSAmJiAhKGluVXNlVHJhY2sudGV4dFRyYWNrMSB8fCBpblVzZVRyYWNrLnRleHRUcmFjazIpO1xufVxuXG5mdW5jdGlvbiBpbnRlcnNlY3Rpb24oeDEsIHgyLCB5MSwgeTIpIHtcbiAgcmV0dXJuIE1hdGgubWluKHgyLCB5MikgLSBNYXRoLm1heCh4MSwgeTEpO1xufVxuXG5jbGFzcyBUaW1lbGluZUNvbnRyb2xsZXIgZXh0ZW5kcyBFdmVudEhhbmRsZXIge1xuXG4gIGNvbnN0cnVjdG9yKGhscykge1xuICAgIHN1cGVyKGhscywgRXZlbnQuTUVESUFfQVRUQUNISU5HLFxuICAgICAgICAgICAgICAgIEV2ZW50Lk1FRElBX0RFVEFDSElORyxcbiAgICAgICAgICAgICAgICBFdmVudC5GUkFHX1BBUlNJTkdfVVNFUkRBVEEsXG4gICAgICAgICAgICAgICAgRXZlbnQuTUFOSUZFU1RfTE9BRElORyxcbiAgICAgICAgICAgICAgICBFdmVudC5NQU5JRkVTVF9MT0FERUQsXG4gICAgICAgICAgICAgICAgRXZlbnQuRlJBR19MT0FERUQsXG4gICAgICAgICAgICAgICAgRXZlbnQuTEVWRUxfU1dJVENILFxuICAgICAgICAgICAgICAgIEV2ZW50LklOSVRfUFRTX0ZPVU5EKTtcblxuICAgIHRoaXMuaGxzID0gaGxzO1xuICAgIHRoaXMuY29uZmlnID0gaGxzLmNvbmZpZztcbiAgICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xuICAgIHRoaXMuQ3VlcyA9IGhscy5jb25maWcuY3VlSGFuZGxlcjtcbiAgICB0aGlzLnRleHRUcmFja3MgPSBbXTtcbiAgICB0aGlzLnRyYWNrcyA9IFtdO1xuICAgIHRoaXMudW5wYXJzZWRWdHRGcmFncyA9IFtdO1xuICAgIHRoaXMuaW5pdFBUUyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmN1ZVJhbmdlcyA9IFtdO1xuXG4gICAgaWYgKHRoaXMuY29uZmlnLmVuYWJsZUNFQTcwOENhcHRpb25zKVxuICAgIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBzZW5kQWRkVHJhY2tFdmVudCA9IGZ1bmN0aW9uICh0cmFjaywgbWVkaWEpXG4gICAgICB7XG4gICAgICAgIHZhciBlID0gbnVsbDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBlID0gbmV3IHdpbmRvdy5FdmVudCgnYWRkdHJhY2snKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgLy9mb3IgSUUxMVxuICAgICAgICAgIGUgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcbiAgICAgICAgICBlLmluaXRFdmVudCgnYWRkdHJhY2snLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGUudHJhY2sgPSB0cmFjaztcbiAgICAgICAgbWVkaWEuZGlzcGF0Y2hFdmVudChlKTtcbiAgICAgIH07XG5cbiAgICAgIHZhciBjaGFubmVsMSA9XG4gICAgICB7XG4gICAgICAgICduZXdDdWUnOiBmdW5jdGlvbihzdGFydFRpbWUsIGVuZFRpbWUsIHNjcmVlbilcbiAgICAgICAge1xuICAgICAgICAgIGlmICghc2VsZi50ZXh0VHJhY2sxKVxuICAgICAgICAgIHtcbiAgICAgICAgICAgIC8vRW5hYmxlIHJldXNlIG9mIGV4aXN0aW5nIHRleHQgdHJhY2suXG4gICAgICAgICAgICB2YXIgZXhpc3RpbmdUcmFjazEgPSBzZWxmLmdldEV4aXN0aW5nVHJhY2soJzEnKTtcbiAgICAgICAgICAgIGlmICghZXhpc3RpbmdUcmFjazEpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHNlbGYudGV4dFRyYWNrMSA9IHNlbGYuY3JlYXRlVGV4dFRyYWNrKCdjYXB0aW9ucycsICdFbmdsaXNoJywgJ2VuJyk7XG4gICAgICAgICAgICAgIHNlbGYudGV4dFRyYWNrMS50ZXh0VHJhY2sxID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgc2VsZi50ZXh0VHJhY2sxID0gZXhpc3RpbmdUcmFjazE7XG4gICAgICAgICAgICAgIHNlbGYuY2xlYXJDdXJyZW50Q3VlcyhzZWxmLnRleHRUcmFjazEpO1xuICAgICAgICAgICAgICBzZW5kQWRkVHJhY2tFdmVudChzZWxmLnRleHRUcmFjazEsIHNlbGYubWVkaWEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBzZWxmLmFkZEN1ZXMoJ3RleHRUcmFjazEnLCBzdGFydFRpbWUsIGVuZFRpbWUsIHNjcmVlbik7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHZhciBjaGFubmVsMiA9XG4gICAgICB7XG4gICAgICAgICduZXdDdWUnOiBmdW5jdGlvbihzdGFydFRpbWUsIGVuZFRpbWUsIHNjcmVlbilcbiAgICAgICAge1xuICAgICAgICAgIGlmICghc2VsZi50ZXh0VHJhY2syKVxuICAgICAgICAgIHtcbiAgICAgICAgICAgIC8vRW5hYmxlIHJldXNlIG9mIGV4aXN0aW5nIHRleHQgdHJhY2suXG4gICAgICAgICAgICB2YXIgZXhpc3RpbmdUcmFjazIgPSBzZWxmLmdldEV4aXN0aW5nVHJhY2soJzInKTtcbiAgICAgICAgICAgIGlmICghZXhpc3RpbmdUcmFjazIpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHNlbGYudGV4dFRyYWNrMiA9IHNlbGYuY3JlYXRlVGV4dFRyYWNrKCdjYXB0aW9ucycsICdTcGFuaXNoJywgJ2VzJyk7XG4gICAgICAgICAgICAgIHNlbGYudGV4dFRyYWNrMi50ZXh0VHJhY2syID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgc2VsZi50ZXh0VHJhY2syID0gZXhpc3RpbmdUcmFjazI7XG5cbiAgICAgICAgICAgICAgc2VuZEFkZFRyYWNrRXZlbnQoc2VsZi50ZXh0VHJhY2syLCBzZWxmLm1lZGlhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgc2VsZi5hZGRDdWVzKCd0ZXh0VHJhY2syJywgc3RhcnRUaW1lLCBlbmRUaW1lLCBzY3JlZW4pO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB0aGlzLmNlYTYwOFBhcnNlciA9IG5ldyBDZWE2MDhQYXJzZXIoMCwgY2hhbm5lbDEsIGNoYW5uZWwyKTtcbiAgICB9XG4gIH1cblxuICBhZGRDdWVzKGNoYW5uZWwsIHN0YXJ0VGltZSwgZW5kVGltZSwgc2NyZWVuKSB7XG4gICAgLy8gc2tpcCBjdWVzIHdoaWNoIG92ZXJsYXAgbW9yZSB0aGFuIDUwJSB3aXRoIHByZXZpb3VzbHkgcGFyc2VkIHRpbWUgcmFuZ2VzXG4gICAgY29uc3QgcmFuZ2VzID0gdGhpcy5jdWVSYW5nZXM7XG4gICAgbGV0IG1lcmdlZCA9IGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSByYW5nZXMubGVuZ3RoOyBpLS07KSB7XG4gICAgICBsZXQgY3VlUmFuZ2UgPSByYW5nZXNbaV07XG4gICAgICBsZXQgb3ZlcmxhcCA9IGludGVyc2VjdGlvbihjdWVSYW5nZVswXSwgY3VlUmFuZ2VbMV0sIHN0YXJ0VGltZSwgZW5kVGltZSk7XG4gICAgICBpZiAob3ZlcmxhcCA+PSAwKSB7XG4gICAgICAgIGN1ZVJhbmdlWzBdID0gTWF0aC5taW4oY3VlUmFuZ2VbMF0sIHN0YXJ0VGltZSk7XG4gICAgICAgIGN1ZVJhbmdlWzFdID0gTWF0aC5tYXgoY3VlUmFuZ2VbMV0sIGVuZFRpbWUpO1xuICAgICAgICBtZXJnZWQgPSB0cnVlO1xuICAgICAgICBpZiAoKG92ZXJsYXAgLyAoZW5kVGltZSAtIHN0YXJ0VGltZSkpID4gMC41KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghbWVyZ2VkKSB7XG4gICAgICByYW5nZXMucHVzaChbc3RhcnRUaW1lLCBlbmRUaW1lXSk7XG4gICAgfVxuICAgIHRoaXMuQ3Vlcy5uZXdDdWUodGhpc1tjaGFubmVsXSwgc3RhcnRUaW1lLCBlbmRUaW1lLCBzY3JlZW4pO1xuICB9XG5cbiAgLy8gVHJpZ2dlcmVkIHdoZW4gYW4gaW5pdGlhbCBQVFMgaXMgZm91bmQ7IHVzZWQgZm9yIHN5bmNocm9uaXNhdGlvbiBvZiBXZWJWVFQuXG4gIG9uSW5pdFB0c0ZvdW5kKGRhdGEpIHtcbiAgICBpZiAodHlwZW9mIHRoaXMuaW5pdFBUUyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRoaXMuaW5pdFBUUyA9IGRhdGEuaW5pdFBUUztcbiAgICB9XG5cbiAgICAvLyBEdWUgdG8gYXN5bmNocm9ueSwgaW5pdGlhbCBQVFMgbWF5IGFycml2ZSBsYXRlciB0aGFuIHRoZSBmaXJzdCBWVFQgZnJhZ21lbnRzIGFyZSBsb2FkZWQuXG4gICAgLy8gUGFyc2UgYW55IHVucGFyc2VkIGZyYWdtZW50cyB1cG9uIHJlY2VpdmluZyB0aGUgaW5pdGlhbCBQVFMuXG4gICAgaWYgKHRoaXMudW5wYXJzZWRWdHRGcmFncy5sZW5ndGgpIHtcbiAgICAgIHRoaXMudW5wYXJzZWRWdHRGcmFncy5mb3JFYWNoKGZyYWcgPT4ge1xuICAgICAgICB0aGlzLm9uRnJhZ0xvYWRlZChmcmFnKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy51bnBhcnNlZFZ0dEZyYWdzID0gW107XG4gICAgfVxuICB9XG5cbiAgZ2V0RXhpc3RpbmdUcmFjayhjaGFubmVsTnVtYmVyKSB7XG4gICAgbGV0IG1lZGlhID0gdGhpcy5tZWRpYTtcbiAgICBpZiAobWVkaWEpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWVkaWEudGV4dFRyYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgdGV4dFRyYWNrID0gbWVkaWEudGV4dFRyYWNrc1tpXTtcbiAgICAgICAgbGV0IHByb3BOYW1lID0gJ3RleHRUcmFjaycgKyBjaGFubmVsTnVtYmVyO1xuICAgICAgICBpZiAodGV4dFRyYWNrW3Byb3BOYW1lXSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHJldHVybiB0ZXh0VHJhY2s7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBjcmVhdGVUZXh0VHJhY2soa2luZCwgbGFiZWwsIGxhbmcpIHtcbiAgICBpZiAodGhpcy5tZWRpYSlcbiAgICB7XG4gICAgICByZXR1cm4gdGhpcy5tZWRpYS5hZGRUZXh0VHJhY2soa2luZCwgbGFiZWwsIGxhbmcpO1xuICAgIH1cbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgRXZlbnRIYW5kbGVyLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XG4gIH1cblxuICBvbk1lZGlhQXR0YWNoaW5nKGRhdGEpIHtcbiAgICB0aGlzLm1lZGlhID0gZGF0YS5tZWRpYTtcbiAgfVxuXG4gIG9uTWVkaWFEZXRhY2hpbmcoKSB7XG4gICAgY2xlYXJDdXJyZW50Q3Vlcyh0aGlzLnRleHRUcmFjazEpO1xuICAgIGNsZWFyQ3VycmVudEN1ZXModGhpcy50ZXh0VHJhY2syKTtcbiAgfVxuXG4gIG9uTWFuaWZlc3RMb2FkaW5nKClcbiAge1xuICAgIHRoaXMubGFzdFNuID0gLTE7IC8vIERldGVjdCBkaXNjb250aWd1aXR5IGluIGZyYWdtZW50IHBhcnNpbmdcbiAgICB0aGlzLnByZXZDQyA9IC0xO1xuICAgIHRoaXMudnR0Q0NzID0ge2NjT2Zmc2V0OiAwLCBwcmVzZW50YXRpb25PZmZzZXQ6IDB9OyAvLyBEZXRlY3QgZGlzY29udGludWl0eSBpbiBzdWJ0aXRsZSBtYW5pZmVzdHNcbiAgfVxuXG4gIG9uTWFuaWZlc3RMb2FkZWQoZGF0YSkge1xuICAgIHRoaXMudGV4dFRyYWNrcyA9IFtdO1xuICAgIHRoaXMudW5wYXJzZWRWdHRGcmFncyA9IHRoaXMudW5wYXJzZWRWdHRGcmFncyB8fCBbXTtcbiAgICB0aGlzLmluaXRQVFMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5jdWVSYW5nZXMgPSBbXTtcblxuICAgIGlmICh0aGlzLmNvbmZpZy5lbmFibGVXZWJWVFQpIHtcbiAgICAgIHRoaXMudHJhY2tzID0gZGF0YS5zdWJ0aXRsZXMgfHwgW107XG4gICAgICBjb25zdCBpblVzZVRyYWNrcyA9IHRoaXMubWVkaWEgPyB0aGlzLm1lZGlhLnRleHRUcmFja3MgOiBbXTtcblxuICAgICAgdGhpcy50cmFja3MuZm9yRWFjaCgodHJhY2ssIGluZGV4KSA9PiB7XG4gICAgICAgIGxldCB0ZXh0VHJhY2s7XG4gICAgICAgIGNvbnN0IGluVXNlVHJhY2sgPSBpblVzZVRyYWNrc1tpbmRleF07XG4gICAgICAgIC8vIFJldXNlIHRyYWNrcyB3aXRoIHRoZSBzYW1lIGxhYmVsLCBidXQgZG8gbm90IHJldXNlIDYwOC83MDggdHJhY2tzXG4gICAgICAgIGlmIChyZXVzZVZ0dFRleHRUcmFjayhpblVzZVRyYWNrLCB0cmFjaykpIHtcbiAgICAgICAgICB0ZXh0VHJhY2sgPSBpblVzZVRyYWNrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRleHRUcmFjayA9IHRoaXMuY3JlYXRlVGV4dFRyYWNrKCdzdWJ0aXRsZXMnLCB0cmFjay5uYW1lLCB0cmFjay5sYW5nKTtcbiAgICAgICAgfVxuICAgICAgICB0ZXh0VHJhY2subW9kZSA9IHRyYWNrLmRlZmF1bHQgPyAnc2hvd2luZycgOiAnaGlkZGVuJztcbiAgICAgICAgdGhpcy50ZXh0VHJhY2tzLnB1c2godGV4dFRyYWNrKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIG9uTGV2ZWxTd2l0Y2goKSB7XG4gICAgdGhpcy5lbmFibGVkID0gdGhpcy5obHMuY3VycmVudExldmVsLmNsb3NlZENhcHRpb25zICE9PSAnTk9ORSc7XG4gIH1cblxuICBvbkZyYWdMb2FkZWQoZGF0YSkge1xuICAgIGxldCBmcmFnID0gZGF0YS5mcmFnLFxuICAgICAgcGF5bG9hZCA9IGRhdGEucGF5bG9hZDtcbiAgICBpZiAoZnJhZy50eXBlID09PSAnbWFpbicpIHtcbiAgICAgIHZhciBzbiA9IGZyYWcuc247XG4gICAgICAvLyBpZiB0aGlzIGZyYWcgaXNuJ3QgY29udGlndW91cywgY2xlYXIgdGhlIHBhcnNlciBzbyBjdWVzIHdpdGggYmFkIHN0YXJ0L2VuZCB0aW1lcyBhcmVuJ3QgYWRkZWQgdG8gdGhlIHRleHRUcmFja1xuICAgICAgaWYgKHNuICE9PSB0aGlzLmxhc3RTbiArIDEpIHtcbiAgICAgICAgdGhpcy5jZWE2MDhQYXJzZXIucmVzZXQoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMubGFzdFNuID0gc247XG4gICAgfVxuICAgIC8vIElmIGZyYWdtZW50IGlzIHN1YnRpdGxlIHR5cGUsIHBhcnNlIGFzIFdlYlZUVC5cbiAgICBlbHNlIGlmIChmcmFnLnR5cGUgPT09ICdzdWJ0aXRsZScpIHtcbiAgICAgIGlmIChwYXlsb2FkLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgLy8gV2UgbmVlZCBhbiBpbml0aWFsIHN5bmNocm9uaXNhdGlvbiBQVFMuIFN0b3JlIGZyYWdtZW50cyBhcyBsb25nIGFzIG5vbmUgaGFzIGFycml2ZWQuXG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5pbml0UFRTID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHRoaXMudW5wYXJzZWRWdHRGcmFncy5wdXNoKGRhdGEpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdnR0Q0NzID0gdGhpcy52dHRDQ3M7XG4gICAgICAgIGlmICghdnR0Q0NzW2ZyYWcuY2NdKSB7XG4gICAgICAgICAgdnR0Q0NzW2ZyYWcuY2NdID0geyBzdGFydDogZnJhZy5zdGFydCwgcHJldkNDOiB0aGlzLnByZXZDQywgbmV3OiB0cnVlIH07XG4gICAgICAgICAgdGhpcy5wcmV2Q0MgPSBmcmFnLmNjO1xuICAgICAgICB9XG4gICAgICAgIGxldCB0ZXh0VHJhY2tzID0gdGhpcy50ZXh0VHJhY2tzLFxuICAgICAgICAgIGhscyA9IHRoaXMuaGxzO1xuXG4gICAgICAgIC8vIFBhcnNlIHRoZSBXZWJWVFQgZmlsZSBjb250ZW50cy5cbiAgICAgICAgV2ViVlRUUGFyc2VyLnBhcnNlKHBheWxvYWQsIHRoaXMuaW5pdFBUUywgdnR0Q0NzLCBmcmFnLmNjLCBmdW5jdGlvbiAoY3Vlcykge1xuICAgICAgICAgICAgLy8gQWRkIGN1ZXMgYW5kIHRyaWdnZXIgZXZlbnQgd2l0aCBzdWNjZXNzIHRydWUuXG4gICAgICAgICAgICBjdWVzLmZvckVhY2goY3VlID0+IHtcbiAgICAgICAgICAgICAgdGV4dFRyYWNrc1tmcmFnLnRyYWNrSWRdLmFkZEN1ZShjdWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBobHMudHJpZ2dlcihFdmVudC5TVUJUSVRMRV9GUkFHX1BST0NFU1NFRCwge3N1Y2Nlc3M6IHRydWUsIGZyYWc6IGZyYWd9KTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAvLyBTb21ldGhpbmcgd2VudCB3cm9uZyB3aGlsZSBwYXJzaW5nLiBUcmlnZ2VyIGV2ZW50IHdpdGggc3VjY2VzcyBmYWxzZS5cbiAgICAgICAgICAgIGxvZ2dlci5sb2coYEZhaWxlZCB0byBwYXJzZSBWVFQgY3VlOiAke2V9YCk7XG4gICAgICAgICAgICBobHMudHJpZ2dlcihFdmVudC5TVUJUSVRMRV9GUkFHX1BST0NFU1NFRCwge3N1Y2Nlc3M6IGZhbHNlLCBmcmFnOiBmcmFnfSk7XG4gICAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgLy8gSW4gY2FzZSB0aGVyZSBpcyBubyBwYXlsb2FkLCBmaW5pc2ggdW5zdWNjZXNzZnVsbHkuXG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuU1VCVElUTEVfRlJBR19QUk9DRVNTRUQsIHtzdWNjZXNzOiBmYWxzZSwgZnJhZzogZnJhZ30pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIG9uRnJhZ1BhcnNpbmdVc2VyZGF0YShkYXRhKSB7XG4gICAgLy8gcHVzaCBhbGwgb2YgdGhlIENFQS03MDggbWVzc2FnZXMgaW50byB0aGUgaW50ZXJwcmV0ZXJcbiAgICAvLyBpbW1lZGlhdGVseS4gSXQgd2lsbCBjcmVhdGUgdGhlIHByb3BlciB0aW1lc3RhbXBzIGJhc2VkIG9uIG91ciBQVFMgdmFsdWVcbiAgICBpZiAodGhpcy5lbmFibGVkICYmIHRoaXMuY29uZmlnLmVuYWJsZUNFQTcwOENhcHRpb25zKSB7XG4gICAgICBmb3IgKHZhciBpPTA7IGk8ZGF0YS5zYW1wbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjY2RhdGFzID0gdGhpcy5leHRyYWN0Q2VhNjA4RGF0YShkYXRhLnNhbXBsZXNbaV0uYnl0ZXMpO1xuICAgICAgICB0aGlzLmNlYTYwOFBhcnNlci5hZGREYXRhKGRhdGEuc2FtcGxlc1tpXS5wdHMsIGNjZGF0YXMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGV4dHJhY3RDZWE2MDhEYXRhKGJ5dGVBcnJheSkge1xuICAgIHZhciBjb3VudCA9IGJ5dGVBcnJheVswXSAmIDMxO1xuICAgIHZhciBwb3NpdGlvbiA9IDI7XG4gICAgdmFyIHRtcEJ5dGUsIGNjYnl0ZTEsIGNjYnl0ZTIsIGNjVmFsaWQsIGNjVHlwZTtcbiAgICB2YXIgYWN0dWFsQ0NCeXRlcyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBjb3VudDsgaisrKSB7XG4gICAgICB0bXBCeXRlID0gYnl0ZUFycmF5W3Bvc2l0aW9uKytdO1xuICAgICAgY2NieXRlMSA9IDB4N0YgJiBieXRlQXJyYXlbcG9zaXRpb24rK107XG4gICAgICBjY2J5dGUyID0gMHg3RiAmIGJ5dGVBcnJheVtwb3NpdGlvbisrXTtcbiAgICAgIGNjVmFsaWQgPSAoNCAmIHRtcEJ5dGUpICE9PSAwO1xuICAgICAgY2NUeXBlID0gMyAmIHRtcEJ5dGU7XG5cbiAgICAgIGlmIChjY2J5dGUxID09PSAwICYmIGNjYnl0ZTIgPT09IDApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChjY1ZhbGlkKSB7XG4gICAgICAgIGlmIChjY1R5cGUgPT09IDApIC8vIHx8IGNjVHlwZSA9PT0gMVxuICAgICAgICB7XG4gICAgICAgICAgYWN0dWFsQ0NCeXRlcy5wdXNoKGNjYnl0ZTEpO1xuICAgICAgICAgIGFjdHVhbENDQnl0ZXMucHVzaChjY2J5dGUyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYWN0dWFsQ0NCeXRlcztcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBUaW1lbGluZUNvbnRyb2xsZXI7XG4iLCJleHBvcnQgZGVmYXVsdCBjbGFzcyBBRVNDcnlwdG8ge1xuICBjb25zdHJ1Y3RvcihzdWJ0bGUsaXYpIHtcbiAgICB0aGlzLnN1YnRsZSA9IHN1YnRsZTtcbiAgICB0aGlzLmFlc0lWID0gaXY7XG4gIH1cblxuICBkZWNyeXB0KGRhdGEsIGtleSkge1xuICAgIHJldHVybiB0aGlzLnN1YnRsZS5kZWNyeXB0KHtuYW1lOiAnQUVTLUNCQycsIGl2OiB0aGlzLmFlc0lWfSwga2V5LCBkYXRhKTtcbiAgfVxufVxuIiwiY2xhc3MgQUVTRGVjcnlwdG9yIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgLy8gU3RhdGljIGFmdGVyIHJ1bm5pbmcgaW5pdFRhYmxlXG4gICAgdGhpcy5yY29uID0gWzB4MCwgMHgxLCAweDIsIDB4NCwgMHg4LCAweDEwLCAweDIwLCAweDQwLCAweDgwLCAweDFiLCAweDM2XTtcblxuICAgIHRoaXMuc3ViTWl4ID0gW107XG4gICAgdGhpcy5zdWJNaXhbMF0gPSBuZXcgVWludDMyQXJyYXkoMjU2KTtcbiAgICB0aGlzLnN1Yk1peFsxXSA9IG5ldyBVaW50MzJBcnJheSgyNTYpO1xuICAgIHRoaXMuc3ViTWl4WzJdID0gbmV3IFVpbnQzMkFycmF5KDI1Nik7XG4gICAgdGhpcy5zdWJNaXhbM10gPSBuZXcgVWludDMyQXJyYXkoMjU2KTtcblxuICAgIHRoaXMuaW52U3ViTWl4ID0gW107XG4gICAgdGhpcy5pbnZTdWJNaXhbMF0gPSBuZXcgVWludDMyQXJyYXkoMjU2KTtcbiAgICB0aGlzLmludlN1Yk1peFsxXSA9IG5ldyBVaW50MzJBcnJheSgyNTYpO1xuICAgIHRoaXMuaW52U3ViTWl4WzJdID0gbmV3IFVpbnQzMkFycmF5KDI1Nik7XG4gICAgdGhpcy5pbnZTdWJNaXhbM10gPSBuZXcgVWludDMyQXJyYXkoMjU2KTtcblxuICAgIHRoaXMuc0JveCA9IG5ldyBVaW50MzJBcnJheSgyNTYpO1xuICAgIHRoaXMuaW52U0JveCA9IG5ldyBVaW50MzJBcnJheSgyNTYpO1xuXG4gICAgLy8gQ2hhbmdlcyBkdXJpbmcgcnVudGltZVxuICAgIHRoaXMua2V5ID0gbmV3IFVpbnQzMkFycmF5KDApO1xuXG4gICAgdGhpcy5pbml0VGFibGUoKTtcbiAgfVxuXG4gIC8vIFVzaW5nIHZpZXcuZ2V0VWludDMyKCkgYWxzbyBzd2FwcyB0aGUgYnl0ZSBvcmRlci5cbiAgdWludDhBcnJheVRvVWludDMyQXJyYXlfKGFycmF5QnVmZmVyKSB7XG4gICAgbGV0IHZpZXcgPSBuZXcgRGF0YVZpZXcoYXJyYXlCdWZmZXIpO1xuICAgIGxldCBuZXdBcnJheSA9IG5ldyBVaW50MzJBcnJheSg0KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5ld0FycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBuZXdBcnJheVtpXSA9IHZpZXcuZ2V0VWludDMyKGkgKiA0KTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld0FycmF5O1xuICB9XG5cbiAgaW5pdFRhYmxlKCkge1xuICAgIGxldCBzQm94ID0gdGhpcy5zQm94O1xuICAgIGxldCBpbnZTQm94ID0gdGhpcy5pbnZTQm94O1xuICAgIGxldCBzdWJNaXgwID0gdGhpcy5zdWJNaXhbMF07XG4gICAgbGV0IHN1Yk1peDEgPSB0aGlzLnN1Yk1peFsxXTtcbiAgICBsZXQgc3ViTWl4MiA9IHRoaXMuc3ViTWl4WzJdO1xuICAgIGxldCBzdWJNaXgzID0gdGhpcy5zdWJNaXhbM107XG4gICAgbGV0IGludlN1Yk1peDAgPSB0aGlzLmludlN1Yk1peFswXTtcbiAgICBsZXQgaW52U3ViTWl4MSA9IHRoaXMuaW52U3ViTWl4WzFdO1xuICAgIGxldCBpbnZTdWJNaXgyID0gdGhpcy5pbnZTdWJNaXhbMl07XG4gICAgbGV0IGludlN1Yk1peDMgPSB0aGlzLmludlN1Yk1peFszXTtcblxuICAgIGxldCBkID0gbmV3IFVpbnQzMkFycmF5KDI1Nik7XG4gICAgbGV0IHggPSAwO1xuICAgIGxldCB4aSA9IDA7XG4gICAgbGV0IGkgPSAwO1xuICAgIGZvciAoaSA9IDA7IGkgPCAyNTY7IGkrKykge1xuICAgICAgaWYgKGkgPCAxMjgpIHtcbiAgICAgICAgZFtpXSA9IGkgPDwgMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRbaV0gPSAoaSA8PCAxKSBeIDB4MTFiO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCAyNTY7IGkrKykge1xuICAgICAgbGV0IHN4ID0geGkgXiAoeGkgPDwgMSkgXiAoeGkgPDwgMikgXiAoeGkgPDwgMykgXiAoeGkgPDwgNCk7XG4gICAgICBzeCA9IChzeCA+Pj4gOCkgXiAoc3ggJiAweGZmKSBeIDB4NjM7XG4gICAgICBzQm94W3hdID0gc3g7XG4gICAgICBpbnZTQm94W3N4XSA9IHg7XG5cbiAgICAgIC8vIENvbXB1dGUgbXVsdGlwbGljYXRpb25cbiAgICAgIGxldCB4MiA9IGRbeF07XG4gICAgICBsZXQgeDQgPSBkW3gyXTtcbiAgICAgIGxldCB4OCA9IGRbeDRdO1xuXG4gICAgICAvLyBDb21wdXRlIHN1Yi9pbnZTdWIgYnl0ZXMsIG1peCBjb2x1bW5zIHRhYmxlc1xuICAgICAgbGV0IHQgPSAoZFtzeF0gKiAweDEwMSkgXiAoc3ggKiAweDEwMTAxMDApO1xuICAgICAgc3ViTWl4MFt4XSA9ICh0IDw8IDI0KSB8ICh0ID4+PiA4KTtcbiAgICAgIHN1Yk1peDFbeF0gPSAodCA8PCAxNikgfCAodCA+Pj4gMTYpO1xuICAgICAgc3ViTWl4Mlt4XSA9ICh0IDw8IDgpIHwgKHQgPj4+IDI0KTtcbiAgICAgIHN1Yk1peDNbeF0gPSB0O1xuXG4gICAgICAvLyBDb21wdXRlIGludiBzdWIgYnl0ZXMsIGludiBtaXggY29sdW1ucyB0YWJsZXNcbiAgICAgIHQgPSAoeDggKiAweDEwMTAxMDEpIF4gKHg0ICogMHgxMDAwMSkgXiAoeDIgKiAweDEwMSkgXiAoeCAqIDB4MTAxMDEwMCk7XG4gICAgICBpbnZTdWJNaXgwW3N4XSA9ICh0IDw8IDI0KSB8ICh0ID4+PiA4KTtcbiAgICAgIGludlN1Yk1peDFbc3hdID0gKHQgPDwgMTYpIHwgKHQgPj4+IDE2KTtcbiAgICAgIGludlN1Yk1peDJbc3hdID0gKHQgPDwgOCkgfCAodCA+Pj4gMjQpO1xuICAgICAgaW52U3ViTWl4M1tzeF0gPSB0O1xuXG4gICAgICAvLyBDb21wdXRlIG5leHQgY291bnRlclxuICAgICAgaWYgKCF4KSB7XG4gICAgICAgIHggPSB4aSA9IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB4ID0geDIgXiBkW2RbZFt4OCBeIHgyXV1dO1xuICAgICAgICB4aSBePSBkW2RbeGldXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBleHBhbmRLZXkoa2V5QnVmZmVyKSB7XG4gICAgLy8gY29udmVydCBrZXlCdWZmZXIgdG8gVWludDMyQXJyYXlcbiAgICBsZXQga2V5ID0gdGhpcy51aW50OEFycmF5VG9VaW50MzJBcnJheV8oa2V5QnVmZmVyKTtcbiAgICBsZXQgc2FtZUtleSA9IHRydWU7XG4gICAgbGV0IG9mZnNldCA9IDA7XG5cbiAgICB3aGlsZSAob2Zmc2V0IDwga2V5Lmxlbmd0aCAmJiBzYW1lS2V5KSB7XG4gICAgICBzYW1lS2V5ID0gKGtleVtvZmZzZXRdID09PSB0aGlzLmtleVtvZmZzZXRdKTtcbiAgICAgIG9mZnNldCsrO1xuICAgIH1cblxuICAgIGlmIChzYW1lS2V5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgbGV0IGtleVNpemUgPSB0aGlzLmtleVNpemUgPSBrZXkubGVuZ3RoO1xuXG4gICAgaWYgKGtleVNpemUgIT09IDQgJiYga2V5U2l6ZSAhPT0gNiAmJiBrZXlTaXplICE9PSA4KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYWVzIGtleSBzaXplPScgKyBrZXlTaXplKTtcbiAgICB9XG5cbiAgICBsZXQga3NSb3dzID0gdGhpcy5rc1Jvd3MgPSAoa2V5U2l6ZSArIDYgKyAxKSAqIDQ7XG4gICAgbGV0IGtzUm93O1xuICAgIGxldCBpbnZLc1JvdztcblxuICAgIGxldCBrZXlTY2hlZHVsZSA9IHRoaXMua2V5U2NoZWR1bGUgPSBuZXcgVWludDMyQXJyYXkodGhpcy5rc1Jvd3MpO1xuICAgIGxldCBpbnZLZXlTY2hlZHVsZSA9IHRoaXMuaW52S2V5U2NoZWR1bGUgPSBuZXcgVWludDMyQXJyYXkodGhpcy5rc1Jvd3MpO1xuICAgIGxldCBzYm94ID0gdGhpcy5zQm94O1xuICAgIGxldCByY29uID0gdGhpcy5yY29uO1xuXG4gICAgbGV0IGludlN1Yk1peDAgPSB0aGlzLmludlN1Yk1peFswXTtcbiAgICBsZXQgaW52U3ViTWl4MSA9IHRoaXMuaW52U3ViTWl4WzFdO1xuICAgIGxldCBpbnZTdWJNaXgyID0gdGhpcy5pbnZTdWJNaXhbMl07XG4gICAgbGV0IGludlN1Yk1peDMgPSB0aGlzLmludlN1Yk1peFszXTtcblxuICAgIGxldCBwcmV2O1xuICAgIGxldCB0O1xuXG4gICAgZm9yIChrc1JvdyA9IDA7IGtzUm93IDwga3NSb3dzOyBrc1JvdysrKSB7XG4gICAgICBpZiAoa3NSb3cgPCBrZXlTaXplKSB7XG4gICAgICAgIHByZXYgPSBrZXlTY2hlZHVsZVtrc1Jvd10gPSBrZXlba3NSb3ddO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHQgPSBwcmV2O1xuXG4gICAgICBpZiAoa3NSb3cgJSBrZXlTaXplID09PSAwKSB7XG4gICAgICAgIC8vIFJvdCB3b3JkXG4gICAgICAgIHQgPSAodCA8PCA4KSB8ICh0ID4+PiAyNCk7XG5cbiAgICAgICAgLy8gU3ViIHdvcmRcbiAgICAgICAgdCA9IChzYm94W3QgPj4+IDI0XSA8PCAyNCkgfCAoc2JveFsodCA+Pj4gMTYpICYgMHhmZl0gPDwgMTYpIHwgKHNib3hbKHQgPj4+IDgpICYgMHhmZl0gPDwgOCkgfCBzYm94W3QgJiAweGZmXTtcblxuICAgICAgICAvLyBNaXggUmNvblxuICAgICAgICB0IF49IHJjb25bKGtzUm93IC8ga2V5U2l6ZSkgfCAwXSA8PCAyNDtcbiAgICAgIH0gZWxzZSBpZiAoa2V5U2l6ZSA+IDYgJiYga3NSb3cgJSBrZXlTaXplID09PSA0KSAge1xuICAgICAgICAvLyBTdWIgd29yZFxuICAgICAgICB0ID0gKHNib3hbdCA+Pj4gMjRdIDw8IDI0KSB8IChzYm94Wyh0ID4+PiAxNikgJiAweGZmXSA8PCAxNikgfCAoc2JveFsodCA+Pj4gOCkgJiAweGZmXSA8PCA4KSB8IHNib3hbdCAmIDB4ZmZdO1xuICAgICAgfVxuXG4gICAgICBrZXlTY2hlZHVsZVtrc1Jvd10gPSBwcmV2ID0gKGtleVNjaGVkdWxlW2tzUm93IC0ga2V5U2l6ZV0gXiB0KSA+Pj4gMDtcbiAgICB9XG5cbiAgICBmb3IgKGludktzUm93ID0gMDsgaW52S3NSb3cgPCBrc1Jvd3M7IGludktzUm93KyspIHtcbiAgICAgIGtzUm93ID0ga3NSb3dzIC0gaW52S3NSb3c7XG4gICAgICBpZiAoaW52S3NSb3cgJiAzKSB7XG4gICAgICAgIHQgPSBrZXlTY2hlZHVsZVtrc1Jvd107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0ID0ga2V5U2NoZWR1bGVba3NSb3cgLSA0XTtcbiAgICAgIH1cblxuICAgICAgaWYgKGludktzUm93IDwgNCB8fCBrc1JvdyA8PSA0KSB7XG4gICAgICAgIGludktleVNjaGVkdWxlW2ludktzUm93XSA9IHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnZLZXlTY2hlZHVsZVtpbnZLc1Jvd10gPSBpbnZTdWJNaXgwW3Nib3hbdCA+Pj4gMjRdXSBeIGludlN1Yk1peDFbc2JveFsodCA+Pj4gMTYpICYgMHhmZl1dIF4gaW52U3ViTWl4MltzYm94Wyh0ID4+PiA4KSAmIDB4ZmZdXSBeIGludlN1Yk1peDNbc2JveFt0ICYgMHhmZl1dO1xuICAgICAgfVxuXG4gICAgICBpbnZLZXlTY2hlZHVsZVtpbnZLc1Jvd10gPSBpbnZLZXlTY2hlZHVsZVtpbnZLc1Jvd10gPj4+IDA7XG4gICAgfVxuICB9XG5cbiAgLy8gQWRkaW5nIHRoaXMgYXMgYSBtZXRob2QgZ3JlYXRseSBpbXByb3ZlcyBwZXJmb3JtYW5jZS5cbiAgbmV0d29ya1RvSG9zdE9yZGVyU3dhcCh3b3JkKSB7XG4gICAgcmV0dXJuICh3b3JkIDw8IDI0KSB8ICgod29yZCAmIDB4ZmYwMCkgPDwgOCkgfCAoKHdvcmQgJiAweGZmMDAwMCkgPj4gOCkgfCAod29yZCA+Pj4gMjQpO1xuICB9XG5cbiAgZGVjcnlwdChpbnB1dEFycmF5QnVmZmVyLCBvZmZzZXQsIGFlc0lWKSB7XG4gICAgbGV0IG5Sb3VuZHMgPSB0aGlzLmtleVNpemUgKyA2O1xuICAgIGxldCBpbnZLZXlTY2hlZHVsZSA9IHRoaXMuaW52S2V5U2NoZWR1bGU7XG4gICAgbGV0IGludlNCT1ggPSB0aGlzLmludlNCb3g7XG5cbiAgICBsZXQgaW52U3ViTWl4MCA9IHRoaXMuaW52U3ViTWl4WzBdO1xuICAgIGxldCBpbnZTdWJNaXgxID0gdGhpcy5pbnZTdWJNaXhbMV07XG4gICAgbGV0IGludlN1Yk1peDIgPSB0aGlzLmludlN1Yk1peFsyXTtcbiAgICBsZXQgaW52U3ViTWl4MyA9IHRoaXMuaW52U3ViTWl4WzNdO1xuXG4gICAgbGV0IGluaXRWZWN0b3IgPSB0aGlzLnVpbnQ4QXJyYXlUb1VpbnQzMkFycmF5XyhhZXNJVik7XG4gICAgbGV0IGluaXRWZWN0b3IwID0gaW5pdFZlY3RvclswXTtcbiAgICBsZXQgaW5pdFZlY3RvcjEgPSBpbml0VmVjdG9yWzFdO1xuICAgIGxldCBpbml0VmVjdG9yMiA9IGluaXRWZWN0b3JbMl07XG4gICAgbGV0IGluaXRWZWN0b3IzID0gaW5pdFZlY3RvclszXTtcblxuICAgIGxldCBpbnB1dEludDMyID0gbmV3IEludDMyQXJyYXkoaW5wdXRBcnJheUJ1ZmZlcik7XG4gICAgbGV0IG91dHB1dEludDMyID0gbmV3IEludDMyQXJyYXkoaW5wdXRJbnQzMi5sZW5ndGgpO1xuXG4gICAgbGV0IHQwLCB0MSwgdDIsIHQzO1xuICAgIGxldCBzMCwgczEsIHMyLCBzMztcbiAgICBsZXQgaW5wdXRXb3JkczAsIGlucHV0V29yZHMxLCBpbnB1dFdvcmRzMiwgaW5wdXRXb3JkczM7XG5cbiAgICB2YXIga3NSb3csIGk7XG5cbiAgICB3aGlsZSAob2Zmc2V0IDwgaW5wdXRJbnQzMi5sZW5ndGgpIHtcbiAgICAgIGlucHV0V29yZHMwID0gdGhpcy5uZXR3b3JrVG9Ib3N0T3JkZXJTd2FwKGlucHV0SW50MzJbb2Zmc2V0XSk7XG4gICAgICBpbnB1dFdvcmRzMSA9IHRoaXMubmV0d29ya1RvSG9zdE9yZGVyU3dhcChpbnB1dEludDMyW29mZnNldCArIDFdKTtcbiAgICAgIGlucHV0V29yZHMyID0gdGhpcy5uZXR3b3JrVG9Ib3N0T3JkZXJTd2FwKGlucHV0SW50MzJbb2Zmc2V0ICsgMl0pO1xuICAgICAgaW5wdXRXb3JkczMgPSB0aGlzLm5ldHdvcmtUb0hvc3RPcmRlclN3YXAoaW5wdXRJbnQzMltvZmZzZXQgKyAzXSk7XG5cbiAgICAgIHMwID0gaW5wdXRXb3JkczAgXiBpbnZLZXlTY2hlZHVsZVswXTtcbiAgICAgIHMxID0gaW5wdXRXb3JkczMgXiBpbnZLZXlTY2hlZHVsZVsxXTtcbiAgICAgIHMyID0gaW5wdXRXb3JkczIgXiBpbnZLZXlTY2hlZHVsZVsyXTtcbiAgICAgIHMzID0gaW5wdXRXb3JkczEgXiBpbnZLZXlTY2hlZHVsZVszXTtcblxuICAgICAga3NSb3cgPSA0O1xuXG4gICAgICAvLyBJdGVyYXRlIHRocm91Z2ggdGhlIHJvdW5kcyBvZiBkZWNyeXB0aW9uXG4gICAgICBmb3IgKGkgPSAxOyBpIDwgblJvdW5kczsgaSsrKSB7XG4gICAgICAgIHQwID0gaW52U3ViTWl4MFtzMCA+Pj4gMjRdIF4gaW52U3ViTWl4MVsoczEgPj4gMTYpICYgMHhmZl0gXiBpbnZTdWJNaXgyWyhzMiA+PiA4KSAmIDB4ZmZdIF4gaW52U3ViTWl4M1tzMyAmIDB4ZmZdIF4gaW52S2V5U2NoZWR1bGVba3NSb3ddO1xuICAgICAgICB0MSA9IGludlN1Yk1peDBbczEgPj4+IDI0XSBeIGludlN1Yk1peDFbKHMyID4+IDE2KSAmIDB4ZmZdIF4gaW52U3ViTWl4MlsoczMgPj4gOCkgJiAweGZmXSBeIGludlN1Yk1peDNbczAgJiAweGZmXSBeIGludktleVNjaGVkdWxlW2tzUm93ICsgMV07XG4gICAgICAgIHQyID0gaW52U3ViTWl4MFtzMiA+Pj4gMjRdIF4gaW52U3ViTWl4MVsoczMgPj4gMTYpICYgMHhmZl0gXiBpbnZTdWJNaXgyWyhzMCA+PiA4KSAmIDB4ZmZdIF4gaW52U3ViTWl4M1tzMSAmIDB4ZmZdIF4gaW52S2V5U2NoZWR1bGVba3NSb3cgKyAyXTtcbiAgICAgICAgdDMgPSBpbnZTdWJNaXgwW3MzID4+PiAyNF0gXiBpbnZTdWJNaXgxWyhzMCA+PiAxNikgJiAweGZmXSBeIGludlN1Yk1peDJbKHMxID4+IDgpICYgMHhmZl0gXiBpbnZTdWJNaXgzW3MyICYgMHhmZl0gXiBpbnZLZXlTY2hlZHVsZVtrc1JvdyArIDNdO1xuICAgICAgICAvLyBVcGRhdGUgc3RhdGVcbiAgICAgICAgczAgPSB0MDtcbiAgICAgICAgczEgPSB0MTtcbiAgICAgICAgczIgPSB0MjtcbiAgICAgICAgczMgPSB0MztcblxuICAgICAgICBrc1JvdyA9IGtzUm93ICsgNDtcbiAgICAgIH1cblxuICAgICAgLy8gU2hpZnQgcm93cywgc3ViIGJ5dGVzLCBhZGQgcm91bmQga2V5XG4gICAgICB0MCA9ICgoaW52U0JPWFtzMCA+Pj4gMjRdIDw8IDI0KSBeIChpbnZTQk9YWyhzMSA+PiAxNikgJiAweGZmXSA8PCAxNikgXiAoaW52U0JPWFsoczIgPj4gOCkgJiAweGZmXSA8PCA4KSBeIGludlNCT1hbczMgJiAweGZmXSkgXiBpbnZLZXlTY2hlZHVsZVtrc1Jvd107XG4gICAgICB0MSA9ICgoaW52U0JPWFtzMSA+Pj4gMjRdIDw8IDI0KSBeIChpbnZTQk9YWyhzMiA+PiAxNikgJiAweGZmXSA8PCAxNikgXiAoaW52U0JPWFsoczMgPj4gOCkgJiAweGZmXSA8PCA4KSBeIGludlNCT1hbczAgJiAweGZmXSkgXiBpbnZLZXlTY2hlZHVsZVtrc1JvdyArIDFdO1xuICAgICAgdDIgPSAoKGludlNCT1hbczIgPj4+IDI0XSA8PCAyNCkgXiAoaW52U0JPWFsoczMgPj4gMTYpICYgMHhmZl0gPDwgMTYpIF4gKGludlNCT1hbKHMwID4+IDgpICYgMHhmZl0gPDwgOCkgXiBpbnZTQk9YW3MxICYgMHhmZl0pIF4gaW52S2V5U2NoZWR1bGVba3NSb3cgKyAyXTtcbiAgICAgIHQzID0gKChpbnZTQk9YW3MzID4+PiAyNF0gPDwgMjQpIF4gKGludlNCT1hbKHMwID4+IDE2KSAmIDB4ZmZdIDw8IDE2KSBeIChpbnZTQk9YWyhzMSA+PiA4KSAmIDB4ZmZdIDw8IDgpIF4gaW52U0JPWFtzMiAmIDB4ZmZdKSBeIGludktleVNjaGVkdWxlW2tzUm93ICsgM107XG4gICAgICBrc1JvdyA9IGtzUm93ICsgMztcblxuICAgICAgLy8gV3JpdGVcbiAgICAgIG91dHB1dEludDMyW29mZnNldF0gPSB0aGlzLm5ldHdvcmtUb0hvc3RPcmRlclN3YXAodDAgXiBpbml0VmVjdG9yMCk7XG4gICAgICBvdXRwdXRJbnQzMltvZmZzZXQgKyAxXSA9IHRoaXMubmV0d29ya1RvSG9zdE9yZGVyU3dhcCh0MyBeIGluaXRWZWN0b3IxKTtcbiAgICAgIG91dHB1dEludDMyW29mZnNldCArIDJdID0gdGhpcy5uZXR3b3JrVG9Ib3N0T3JkZXJTd2FwKHQyIF4gaW5pdFZlY3RvcjIpO1xuICAgICAgb3V0cHV0SW50MzJbb2Zmc2V0ICsgM10gPSB0aGlzLm5ldHdvcmtUb0hvc3RPcmRlclN3YXAodDEgXiBpbml0VmVjdG9yMyk7XG5cbiAgICAgIC8vIHJlc2V0IGluaXRWZWN0b3IgdG8gbGFzdCA0IHVuc2lnbmVkIGludFxuICAgICAgaW5pdFZlY3RvcjAgPSBpbnB1dFdvcmRzMDtcbiAgICAgIGluaXRWZWN0b3IxID0gaW5wdXRXb3JkczE7XG4gICAgICBpbml0VmVjdG9yMiA9IGlucHV0V29yZHMyO1xuICAgICAgaW5pdFZlY3RvcjMgPSBpbnB1dFdvcmRzMztcblxuICAgICAgb2Zmc2V0ID0gb2Zmc2V0ICsgNDtcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0cHV0SW50MzIuYnVmZmVyO1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmtleSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmtleVNpemUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5rc1Jvd3MgPSB1bmRlZmluZWQ7XG5cbiAgICB0aGlzLnNCb3ggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5pbnZTQm94ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuc3ViTWl4ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuaW52U3ViTWl4ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMua2V5U2NoZWR1bGUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5pbnZLZXlTY2hlZHVsZSA9IHVuZGVmaW5lZDtcblxuICAgIHRoaXMucmNvbiA9IHVuZGVmaW5lZDtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBBRVNEZWNyeXB0b3I7XG4iLCJpbXBvcnQgQUVTQ3J5cHRvIGZyb20gJy4vYWVzLWNyeXB0byc7XG5pbXBvcnQgRmFzdEFFU0tleSBmcm9tICcuL2Zhc3QtYWVzLWtleSc7XG5pbXBvcnQgQUVTRGVjcnlwdG9yIGZyb20gJy4vYWVzLWRlY3J5cHRvcic7XG5cbmltcG9ydCB7RXJyb3JUeXBlcywgRXJyb3JEZXRhaWxzfSBmcm9tICcuLi9lcnJvcnMnO1xuaW1wb3J0IHtsb2dnZXJ9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XG5cbmNsYXNzIERlY3J5cHRlciB7XG4gIGNvbnN0cnVjdG9yKGhscykge1xuICAgIHRoaXMuaGxzID0gaGxzO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBicm93c2VyQ3J5cHRvID0gd2luZG93ID8gd2luZG93LmNyeXB0byA6IGNyeXB0bztcbiAgICAgIHRoaXMuc3VidGxlID0gYnJvd3NlckNyeXB0by5zdWJ0bGUgfHwgYnJvd3NlckNyeXB0by53ZWJraXRTdWJ0bGU7XG4gICAgfSBjYXRjaCAoZSkge31cblxuICAgIHRoaXMuZGlzYWJsZVdlYkNyeXB0byA9ICF0aGlzLnN1cHBvcnRzV2ViQ3J5cHRvKCk7XG4gIH1cblxuICBzdXBwb3J0c1dlYkNyeXB0bygpIHtcbiAgICByZXR1cm4gdGhpcy5zdWJ0bGUgJiYgd2luZG93LmxvY2F0aW9uLnByb3RvY29sID09PSAnaHR0cHM6JztcbiAgfVxuXG4gIGRlY3J5cHQoZGF0YSwga2V5LCBpdiwgY2FsbGJhY2spIHtcbiAgICBpZiAodGhpcy5kaXNhYmxlV2ViQ3J5cHRvICYmIHRoaXMuaGxzLmNvbmZpZy5lbmFibGVTb2Z0d2FyZUFFUykge1xuICAgICAgbG9nZ2VyLmxvZygnZGVjcnlwdGluZyBieSBKYXZhU2NyaXB0IEltcGxlbWVudGF0aW9uJyk7XG4gICAgICBpZiAoIXRoaXMuZGVjcnlwdG9yKSB7XG4gICAgICAgIHRoaXMuZGVjcnlwdG9yID0gbmV3IEFFU0RlY3J5cHRvcigpO1xuICAgICAgfVxuICAgICAgdGhpcy5kZWNyeXB0b3IuZXhwYW5kS2V5KGtleSk7XG4gICAgICBjYWxsYmFjayh0aGlzLmRlY3J5cHRvci5kZWNyeXB0KGRhdGEsIDAsIGl2KSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgbG9nZ2VyLmxvZygnZGVjcnlwdGluZyBieSBXZWJDcnlwdG8gQVBJJyk7XG4gICAgICBjb25zdCBzdWJ0bGUgPSB0aGlzLnN1YnRsZTtcbiAgICAgIGlmICh0aGlzLmtleSAhPT0ga2V5KSB7XG4gICAgICAgIHRoaXMua2V5ID0ga2V5O1xuICAgICAgICB0aGlzLmZhc3RBZXNLZXkgPSBuZXcgRmFzdEFFU0tleShzdWJ0bGUsa2V5KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5mYXN0QWVzS2V5LmV4cGFuZEtleSgpLlxuICAgICAgICB0aGVuKChhZXNLZXkpID0+IHtcbiAgICAgICAgICAvLyBkZWNyeXB0IHVzaW5nIHdlYiBjcnlwdG9cbiAgICAgICAgICBsZXQgY3J5cHRvID0gbmV3IEFFU0NyeXB0byhzdWJ0bGUsaXYpO1xuICAgICAgICAgIGNyeXB0by5kZWNyeXB0KGRhdGEsIGFlc0tleSkuXG4gICAgICAgICAgICB0aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgY2FsbGJhY2socmVzdWx0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KS5cbiAgICAgICAgY2F0Y2ggKChlcnIpID0+IHtcbiAgICAgICAgICB0aGlzLm9uV2ViQ3J5cHRvRXJyb3IoZXJyLCBkYXRhLCBrZXksIGl2LCBjYWxsYmFjayk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIG9uV2ViQ3J5cHRvRXJyb3IoZXJyLCBkYXRhLCBrZXksIGl2LCBjYWxsYmFjaykge1xuICAgIGxldCBobHMgPSB0aGlzLmhscztcbiAgICBpZiAoaGxzLmNvbmZpZy5lbmFibGVTb2Z0d2FyZUFFUykge1xuICAgICAgbG9nZ2VyLmxvZygnZGlzYWJsaW5nIHRvIHVzZSBXZWJDcnlwdG8gQVBJJyk7XG4gICAgICB0aGlzLmRpc2FibGVXZWJDcnlwdG8gPSB0cnVlO1xuICAgICAgdGhpcy5kZWNyeXB0KGRhdGEsIGtleSwgaXYsIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBsb2dnZXIuZXJyb3IoYGRlY3J5cHRpbmcgZXJyb3IgOiAke2Vyci5tZXNzYWdlfWApO1xuICAgICAgaGxzLnRyaWdnZXIoRXZlbnQuRVJST1IsIHt0eXBlIDogRXJyb3JUeXBlcy5NRURJQV9FUlJPUiwgZGV0YWlscyA6IEVycm9yRGV0YWlscy5GUkFHX0RFQ1JZUFRfRVJST1IsIGZhdGFsIDogdHJ1ZSwgcmVhc29uIDogZXJyLm1lc3NhZ2V9KTtcbiAgICB9XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIGxldCBkZWNyeXB0b3IgPSB0aGlzLmRlY3J5cHRvcjtcbiAgICBpZiAoZGVjcnlwdG9yKSB7XG4gICAgICBkZWNyeXB0b3IuZGVzdHJveSgpO1xuICAgICAgdGhpcy5kZWNyeXB0b3IgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IERlY3J5cHRlcjtcbiIsImNsYXNzIEZhc3RBRVNLZXkge1xuICBjb25zdHJ1Y3RvcihzdWJ0bGUsa2V5KSB7XG4gICAgdGhpcy5zdWJ0bGUgPSBzdWJ0bGU7XG4gICAgdGhpcy5rZXkgPSBrZXk7XG4gIH1cblxuICBleHBhbmRLZXkoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3VidGxlLmltcG9ydEtleSgncmF3JywgdGhpcy5rZXksIHtuYW1lOiAnQUVTLUNCQyd9LCBmYWxzZSwgWydlbmNyeXB0JywgJ2RlY3J5cHQnXSk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgRmFzdEFFU0tleTtcbiIsIi8qKlxuICogQUFDIGRlbXV4ZXJcbiAqL1xuaW1wb3J0IEFEVFMgZnJvbSAnLi9hZHRzJztcbmltcG9ydCB7bG9nZ2VyfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xuaW1wb3J0IElEMyBmcm9tICcuLi9kZW11eC9pZDMnO1xuXG4gY2xhc3MgQUFDRGVtdXhlciB7XG5cbiAgY29uc3RydWN0b3Iob2JzZXJ2ZXIsIGlkLCByZW11eGVyQ2xhc3MsIGNvbmZpZywgdHlwZVN1cHBvcnRlZCkge1xuICAgIHRoaXMub2JzZXJ2ZXIgPSBvYnNlcnZlcjtcbiAgICB0aGlzLmlkID0gaWQ7XG4gICAgdGhpcy5yZW11eGVyQ2xhc3MgPSByZW11eGVyQ2xhc3M7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgdGhpcy5yZW11eGVyID0gbmV3IHRoaXMucmVtdXhlckNsYXNzKG9ic2VydmVyLGlkLCBjb25maWcsIHR5cGVTdXBwb3J0ZWQpO1xuICAgIC8vIGlkID09PSAnbWFpbicgd2hlbiB0aGUgZGVtdXhlciBpcyB1c2VkIHRvIHBsYXkgYW4gYXVkaW8gb25seSBzdHJlYW0gYW5kIHJlcXVpcmVzIEFBQyBmaWxlcyBwbGFjZWQgYmFjay10by1iYWNrIGluIHRoZSBvcmRlciB0aGV5IGFyZSByZWNlaXZlZC5cbiAgICAvLyBpZCA9PT0gJ2F1ZGlvJyB3aGVuIHRoZSBkZW11eGVyIGlzIHVzZWQgZm9yIG11bHRpdHJhY2sgYXVkaW8gYW5kIHJlcXVpcmVzIHRoZSB1c2Ugb2YgdGltZXN0YW1wcyB0byBzeW5jIGF1ZGlvIHdpdGggdmlkZW8uXG4gICAgdGhpcy51c2VUaW1lU3RhbXAgPSBpZCA9PT0gJ2F1ZGlvJztcbiAgICB0aGlzLmluc2VydERpc2NvbnRpbnVpdHkoKTtcbiAgfVxuXG4gIGluc2VydERpc2NvbnRpbnVpdHkoKSB7XG4gICAgdGhpcy5fYWFjVHJhY2sgPSB7Y29udGFpbmVyIDogJ2F1ZGlvL2FkdHMnLCB0eXBlOiAnYXVkaW8nLCBpZCA6LTEsIHNlcXVlbmNlTnVtYmVyOiAwLCBpc0FBQyA6IHRydWUgLCBzYW1wbGVzIDogW10sIGxlbiA6IDB9O1xuICB9XG5cbiAgLy8gU291cmNlIGZvciBwcm9iZSBpbmZvIC0gaHR0cHM6Ly93aWtpLm11bHRpbWVkaWEuY3gvaW5kZXgucGhwP3RpdGxlPUFEVFNcbiAgc3RhdGljIHByb2JlKGRhdGEpIHtcbiAgICB2YXIgaWQzID0gbmV3IElEMyhkYXRhKSwgb2Zmc2V0LCBsZW47XG4gICAgZm9yICggb2Zmc2V0ID0gaWQzLmxlbmd0aCB8fCAwLCBsZW4gPSBkYXRhLmxlbmd0aDsgb2Zmc2V0IDwgbGVuIC0gMTsgb2Zmc2V0KyspIHtcbiAgICAgIC8vIEFEVFMgSGVhZGVyIGlzIHwgMTExMSAxMTExIHwgMTExMSBYMDBYIHwgd2hlcmUgWCBjYW4gYmUgZWl0aGVyIDAgb3IgMVxuICAgICAgaWYgKChkYXRhW29mZnNldF0gPT09IDB4ZmYpICYmIChkYXRhW29mZnNldCsxXSAmIDB4ZjYpID09PSAweGYwKSB7XG4gICAgICAgIC8vbG9nZ2VyLmxvZygnQURUUyBzeW5jIHdvcmQgZm91bmQgIScpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gZmVlZCBpbmNvbWluZyBkYXRhIHRvIHRoZSBmcm9udCBvZiB0aGUgcGFyc2luZyBwaXBlbGluZVxuICBwdXNoKGRhdGEsIGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWMsIHRpbWVPZmZzZXQsIGNjLCBsZXZlbCwgc24sIGR1cmF0aW9uLGFjY3VyYXRlVGltZU9mZnNldCwgZGVmYXVsdEluaXRQVFMpIHtcbiAgICB2YXIgdHJhY2ssXG4gICAgICAgIGlkMyA9IG5ldyBJRDMoZGF0YSksXG4gICAgICAgIHB0cywgY29uZmlnLCBmcmFtZUxlbmd0aCwgZnJhbWVEdXJhdGlvbiwgZnJhbWVJbmRleCwgb2Zmc2V0LCBoZWFkZXJMZW5ndGgsIHN0YW1wLCBsZW4sIGFhY1NhbXBsZTtcblxuICAgIC8vIFVzZSBJRDMgVGltZXN0YW1wIGlmIG5lZWRlZCwgYXMgaW4gdjQgYXVkaW8gdHJhY2tzLiAgT3RoZXJ3aXNlLCBjb25jYXQgQUFDIGF1ZGlvIGluIHRoZSBvcmRlciBpdCBjb21lcyBpbi5cbiAgICBwdHMgPSAodGhpcy51c2VUaW1lU3RhbXApID8gOTAgKiBpZDMudGltZVN0YW1wIDogdGltZU9mZnNldCAqIDkwMDAwO1xuXG4gICAgbGV0IGNvbnRpZ3VvdXMgPSBmYWxzZTtcbiAgICBpZiAoY2MgIT09IHRoaXMubGFzdENDKSB7XG4gICAgICBsb2dnZXIubG9nKGAke3RoaXMuaWR9IGRpc2NvbnRpbnVpdHkgZGV0ZWN0ZWRgKTtcbiAgICAgIHRoaXMubGFzdENDID0gY2M7XG4gICAgICB0aGlzLmluc2VydERpc2NvbnRpbnVpdHkoKTtcbiAgICAgIHRoaXMucmVtdXhlci5zd2l0Y2hMZXZlbCgpO1xuICAgICAgdGhpcy5yZW11eGVyLmluc2VydERpc2NvbnRpbnVpdHkoKTtcbiAgICB9IGVsc2UgaWYgKGxldmVsICE9PSB0aGlzLmxhc3RMZXZlbCkge1xuICAgICAgbG9nZ2VyLmxvZygnYXVkaW8gdHJhY2sgc3dpdGNoIGRldGVjdGVkJyk7XG4gICAgICB0aGlzLmxhc3RMZXZlbCA9IGxldmVsO1xuICAgICAgdGhpcy5yZW11eGVyLnN3aXRjaExldmVsKCk7XG4gICAgICB0aGlzLmluc2VydERpc2NvbnRpbnVpdHkoKTtcbiAgICB9IGVsc2UgaWYgKHNuID09PSAodGhpcy5sYXN0U04rMSkpIHtcbiAgICAgIGNvbnRpZ3VvdXMgPSB0cnVlO1xuICAgIH1cbiAgICB0cmFjayA9IHRoaXMuX2FhY1RyYWNrO1xuICAgIHRoaXMubGFzdFNOID0gc247XG4gICAgdGhpcy5sYXN0TGV2ZWwgPSBsZXZlbDtcblxuICAgIC8vIExvb2sgZm9yIEFEVFMgaGVhZGVyIHwgMTExMSAxMTExIHwgMTExMSBYMDBYIHwgd2hlcmUgWCBjYW4gYmUgZWl0aGVyIDAgb3IgMVxuICAgIGZvciAob2Zmc2V0ID0gaWQzLmxlbmd0aCB8fCAwLCBsZW4gPSBkYXRhLmxlbmd0aDsgb2Zmc2V0IDwgbGVuIC0gMTsgb2Zmc2V0KyspIHtcbiAgICAgIGlmICgoZGF0YVtvZmZzZXRdID09PSAweGZmKSAmJiAoZGF0YVtvZmZzZXQrMV0gJiAweGY2KSA9PT0gMHhmMCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXRyYWNrLmF1ZGlvc2FtcGxlcmF0ZSkge1xuICAgICAgY29uZmlnID0gQURUUy5nZXRBdWRpb0NvbmZpZyh0aGlzLm9ic2VydmVyLGRhdGEsIG9mZnNldCwgYXVkaW9Db2RlYyk7XG4gICAgICB0cmFjay5jb25maWcgPSBjb25maWcuY29uZmlnO1xuICAgICAgdHJhY2suYXVkaW9zYW1wbGVyYXRlID0gY29uZmlnLnNhbXBsZXJhdGU7XG4gICAgICB0cmFjay5jaGFubmVsQ291bnQgPSBjb25maWcuY2hhbm5lbENvdW50O1xuICAgICAgdHJhY2suY29kZWMgPSBjb25maWcuY29kZWM7XG4gICAgICB0cmFjay5kdXJhdGlvbiA9IGR1cmF0aW9uO1xuICAgICAgbG9nZ2VyLmxvZyhgcGFyc2VkIGNvZGVjOiR7dHJhY2suY29kZWN9LHJhdGU6JHtjb25maWcuc2FtcGxlcmF0ZX0sbmIgY2hhbm5lbDoke2NvbmZpZy5jaGFubmVsQ291bnR9YCk7XG4gICAgfVxuICAgIGZyYW1lSW5kZXggPSAwO1xuICAgIGZyYW1lRHVyYXRpb24gPSAxMDI0ICogOTAwMDAgLyB0cmFjay5hdWRpb3NhbXBsZXJhdGU7XG4gICAgd2hpbGUgKChvZmZzZXQgKyA1KSA8IGxlbikge1xuICAgICAgLy8gVGhlIHByb3RlY3Rpb24gc2tpcCBiaXQgdGVsbHMgdXMgaWYgd2UgaGF2ZSAyIGJ5dGVzIG9mIENSQyBkYXRhIGF0IHRoZSBlbmQgb2YgdGhlIEFEVFMgaGVhZGVyXG4gICAgICBoZWFkZXJMZW5ndGggPSAoISEoZGF0YVtvZmZzZXQgKyAxXSAmIDB4MDEpID8gNyA6IDkpO1xuICAgICAgLy8gcmV0cmlldmUgZnJhbWUgc2l6ZVxuICAgICAgZnJhbWVMZW5ndGggPSAoKGRhdGFbb2Zmc2V0ICsgM10gJiAweDAzKSA8PCAxMSkgfFxuICAgICAgICAgICAgICAgICAgICAgKGRhdGFbb2Zmc2V0ICsgNF0gPDwgMykgfFxuICAgICAgICAgICAgICAgICAgICAoKGRhdGFbb2Zmc2V0ICsgNV0gJiAweEUwKSA+Pj4gNSk7XG4gICAgICBmcmFtZUxlbmd0aCAgLT0gaGVhZGVyTGVuZ3RoO1xuICAgICAgLy9zdGFtcCA9IHBlcy5wdHM7XG5cbiAgICAgIGlmICgoZnJhbWVMZW5ndGggPiAwKSAmJiAoKG9mZnNldCArIGhlYWRlckxlbmd0aCArIGZyYW1lTGVuZ3RoKSA8PSBsZW4pKSB7XG4gICAgICAgIHN0YW1wID0gcHRzICsgZnJhbWVJbmRleCAqIGZyYW1lRHVyYXRpb247XG4gICAgICAgIC8vbG9nZ2VyLmxvZyhgQUFDIGZyYW1lLCBvZmZzZXQvbGVuZ3RoL3RvdGFsL3B0czoke29mZnNldCtoZWFkZXJMZW5ndGh9LyR7ZnJhbWVMZW5ndGh9LyR7ZGF0YS5ieXRlTGVuZ3RofS8keyhzdGFtcC85MCkudG9GaXhlZCgwKX1gKTtcbiAgICAgICAgYWFjU2FtcGxlID0ge3VuaXQ6IGRhdGEuc3ViYXJyYXkob2Zmc2V0ICsgaGVhZGVyTGVuZ3RoLCBvZmZzZXQgKyBoZWFkZXJMZW5ndGggKyBmcmFtZUxlbmd0aCksIHB0czogc3RhbXAsIGR0czogc3RhbXB9O1xuICAgICAgICB0cmFjay5zYW1wbGVzLnB1c2goYWFjU2FtcGxlKTtcbiAgICAgICAgdHJhY2subGVuICs9IGZyYW1lTGVuZ3RoO1xuICAgICAgICBvZmZzZXQgKz0gZnJhbWVMZW5ndGggKyBoZWFkZXJMZW5ndGg7XG4gICAgICAgIGZyYW1lSW5kZXgrKztcbiAgICAgICAgLy8gbG9vayBmb3IgQURUUyBoZWFkZXIgKDB4RkZGeClcbiAgICAgICAgZm9yICggOyBvZmZzZXQgPCAobGVuIC0gMSk7IG9mZnNldCsrKSB7XG4gICAgICAgICAgaWYgKChkYXRhW29mZnNldF0gPT09IDB4ZmYpICYmICgoZGF0YVtvZmZzZXQgKyAxXSAmIDB4ZjApID09PSAweGYwKSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgaWQzVHJhY2sgPSAoaWQzLnBheWxvYWQpID8geyBzYW1wbGVzIDogWyB7IHB0czogcHRzLCBkdHMgOiBwdHMsIHVuaXQgOiBpZDMucGF5bG9hZH0gXSB9IDogeyBzYW1wbGVzOiBbXSB9O1xuICAgIHRoaXMucmVtdXhlci5yZW11eChsZXZlbCwgc24sIGNjLCB0aGlzLl9hYWNUcmFjaywge3NhbXBsZXMgOiBbXX0sIGlkM1RyYWNrLCB7IHNhbXBsZXM6IFtdIH0sIHRpbWVPZmZzZXQsIGNvbnRpZ3VvdXMsYWNjdXJhdGVUaW1lT2Zmc2V0LCBkZWZhdWx0SW5pdFBUUyk7XG4gIH1cblxuICBkZXN0cm95KCkge1xuICB9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgQUFDRGVtdXhlcjtcbiIsIi8qKlxuICogIEFEVFMgcGFyc2VyIGhlbHBlclxuICovXG5pbXBvcnQge2xvZ2dlcn0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcbmltcG9ydCB7RXJyb3JUeXBlcywgRXJyb3JEZXRhaWxzfSBmcm9tICcuLi9lcnJvcnMnO1xuXG4gY2xhc3MgQURUUyB7XG5cbiAgc3RhdGljIGdldEF1ZGlvQ29uZmlnKG9ic2VydmVyLCBkYXRhLCBvZmZzZXQsIGF1ZGlvQ29kZWMpIHtcbiAgICB2YXIgYWR0c09iamVjdFR5cGUsIC8vIDppbnRcbiAgICAgICAgYWR0c1NhbXBsZWluZ0luZGV4LCAvLyA6aW50XG4gICAgICAgIGFkdHNFeHRlbnNpb25TYW1wbGVpbmdJbmRleCwgLy8gOmludFxuICAgICAgICBhZHRzQ2hhbmVsQ29uZmlnLCAvLyA6aW50XG4gICAgICAgIGNvbmZpZyxcbiAgICAgICAgdXNlckFnZW50ID0gbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLFxuICAgICAgICBhZHRzU2FtcGxlaW5nUmF0ZXMgPSBbXG4gICAgICAgICAgICA5NjAwMCwgODgyMDAsXG4gICAgICAgICAgICA2NDAwMCwgNDgwMDAsXG4gICAgICAgICAgICA0NDEwMCwgMzIwMDAsXG4gICAgICAgICAgICAyNDAwMCwgMjIwNTAsXG4gICAgICAgICAgICAxNjAwMCwgMTIwMDAsXG4gICAgICAgICAgICAxMTAyNSwgODAwMCxcbiAgICAgICAgICAgIDczNTBdO1xuICAgIC8vIGJ5dGUgMlxuICAgIGFkdHNPYmplY3RUeXBlID0gKChkYXRhW29mZnNldCArIDJdICYgMHhDMCkgPj4+IDYpICsgMTtcbiAgICBhZHRzU2FtcGxlaW5nSW5kZXggPSAoKGRhdGFbb2Zmc2V0ICsgMl0gJiAweDNDKSA+Pj4gMik7XG4gICAgaWYoYWR0c1NhbXBsZWluZ0luZGV4ID4gYWR0c1NhbXBsZWluZ1JhdGVzLmxlbmd0aC0xKSB7XG4gICAgICBvYnNlcnZlci50cmlnZ2VyKEV2ZW50LkVSUk9SLCB7dHlwZTogRXJyb3JUeXBlcy5NRURJQV9FUlJPUiwgZGV0YWlsczogRXJyb3JEZXRhaWxzLkZSQUdfUEFSU0lOR19FUlJPUiwgZmF0YWw6IHRydWUsIHJlYXNvbjogYGludmFsaWQgQURUUyBzYW1wbGluZyBpbmRleDoke2FkdHNTYW1wbGVpbmdJbmRleH1gfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGFkdHNDaGFuZWxDb25maWcgPSAoKGRhdGFbb2Zmc2V0ICsgMl0gJiAweDAxKSA8PCAyKTtcbiAgICAvLyBieXRlIDNcbiAgICBhZHRzQ2hhbmVsQ29uZmlnIHw9ICgoZGF0YVtvZmZzZXQgKyAzXSAmIDB4QzApID4+PiA2KTtcbiAgICBsb2dnZXIubG9nKGBtYW5pZmVzdCBjb2RlYzoke2F1ZGlvQ29kZWN9LEFEVFMgZGF0YTp0eXBlOiR7YWR0c09iamVjdFR5cGV9LHNhbXBsZWluZ0luZGV4OiR7YWR0c1NhbXBsZWluZ0luZGV4fVske2FkdHNTYW1wbGVpbmdSYXRlc1thZHRzU2FtcGxlaW5nSW5kZXhdfUh6XSxjaGFubmVsQ29uZmlnOiR7YWR0c0NoYW5lbENvbmZpZ31gKTtcbiAgICAvLyBmaXJlZm94L09wZXJhOiBmcmVxIGxlc3MgdGhhbiAyNGtIeiA9IEFBQyBTQlIgKEhFLUFBQylcbiAgICBpZiAoL2ZpcmVmb3h8T1BSL2kudGVzdCh1c2VyQWdlbnQpKSB7XG4gICAgICBpZiAoYWR0c1NhbXBsZWluZ0luZGV4ID49IDYpIHtcbiAgICAgICAgYWR0c09iamVjdFR5cGUgPSA1O1xuICAgICAgICBjb25maWcgPSBuZXcgQXJyYXkoNCk7XG4gICAgICAgIC8vIEhFLUFBQyB1c2VzIFNCUiAoU3BlY3RyYWwgQmFuZCBSZXBsaWNhdGlvbikgLCBoaWdoIGZyZXF1ZW5jaWVzIGFyZSBjb25zdHJ1Y3RlZCBmcm9tIGxvdyBmcmVxdWVuY2llc1xuICAgICAgICAvLyB0aGVyZSBpcyBhIGZhY3RvciAyIGJldHdlZW4gZnJhbWUgc2FtcGxlIHJhdGUgYW5kIG91dHB1dCBzYW1wbGUgcmF0ZVxuICAgICAgICAvLyBtdWx0aXBseSBmcmVxdWVuY3kgYnkgMiAoc2VlIHRhYmxlIGJlbG93LCBlcXVpdmFsZW50IHRvIHN1YnN0cmFjdCAzKVxuICAgICAgICBhZHRzRXh0ZW5zaW9uU2FtcGxlaW5nSW5kZXggPSBhZHRzU2FtcGxlaW5nSW5kZXggLSAzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWR0c09iamVjdFR5cGUgPSAyO1xuICAgICAgICBjb25maWcgPSBuZXcgQXJyYXkoMik7XG4gICAgICAgIGFkdHNFeHRlbnNpb25TYW1wbGVpbmdJbmRleCA9IGFkdHNTYW1wbGVpbmdJbmRleDtcbiAgICAgIH1cbiAgICAgIC8vIEFuZHJvaWQgOiBhbHdheXMgdXNlIEFBQ1xuICAgIH0gZWxzZSBpZiAodXNlckFnZW50LmluZGV4T2YoJ2FuZHJvaWQnKSAhPT0gLTEpIHtcbiAgICAgIGFkdHNPYmplY3RUeXBlID0gMjtcbiAgICAgIGNvbmZpZyA9IG5ldyBBcnJheSgyKTtcbiAgICAgIGFkdHNFeHRlbnNpb25TYW1wbGVpbmdJbmRleCA9IGFkdHNTYW1wbGVpbmdJbmRleDtcbiAgICB9IGVsc2Uge1xuICAgICAgLyogIGZvciBvdGhlciBicm93c2VycyAoQ2hyb21lL1ZpdmFsZGkgLi4uKVxuICAgICAgICAgIGFsd2F5cyBmb3JjZSBhdWRpbyB0eXBlIHRvIGJlIEhFLUFBQyBTQlIsIGFzIHNvbWUgYnJvd3NlcnMgZG8gbm90IHN1cHBvcnQgYXVkaW8gY29kZWMgc3dpdGNoIHByb3Blcmx5IChsaWtlIENocm9tZSAuLi4pXG4gICAgICAqL1xuICAgICAgYWR0c09iamVjdFR5cGUgPSA1O1xuICAgICAgY29uZmlnID0gbmV3IEFycmF5KDQpO1xuICAgICAgLy8gaWYgKG1hbmlmZXN0IGNvZGVjIGlzIEhFLUFBQyBvciBIRS1BQUN2MikgT1IgKG1hbmlmZXN0IGNvZGVjIG5vdCBzcGVjaWZpZWQgQU5EIGZyZXF1ZW5jeSBsZXNzIHRoYW4gMjRrSHopXG4gICAgICBpZiAoKGF1ZGlvQ29kZWMgJiYgKChhdWRpb0NvZGVjLmluZGV4T2YoJ21wNGEuNDAuMjknKSAhPT0gLTEpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgIChhdWRpb0NvZGVjLmluZGV4T2YoJ21wNGEuNDAuNScpICE9PSAtMSkpKSB8fFxuICAgICAgICAgICghYXVkaW9Db2RlYyAmJiBhZHRzU2FtcGxlaW5nSW5kZXggPj0gNikpIHtcbiAgICAgICAgLy8gSEUtQUFDIHVzZXMgU0JSIChTcGVjdHJhbCBCYW5kIFJlcGxpY2F0aW9uKSAsIGhpZ2ggZnJlcXVlbmNpZXMgYXJlIGNvbnN0cnVjdGVkIGZyb20gbG93IGZyZXF1ZW5jaWVzXG4gICAgICAgIC8vIHRoZXJlIGlzIGEgZmFjdG9yIDIgYmV0d2VlbiBmcmFtZSBzYW1wbGUgcmF0ZSBhbmQgb3V0cHV0IHNhbXBsZSByYXRlXG4gICAgICAgIC8vIG11bHRpcGx5IGZyZXF1ZW5jeSBieSAyIChzZWUgdGFibGUgYmVsb3csIGVxdWl2YWxlbnQgdG8gc3Vic3RyYWN0IDMpXG4gICAgICAgIGFkdHNFeHRlbnNpb25TYW1wbGVpbmdJbmRleCA9IGFkdHNTYW1wbGVpbmdJbmRleCAtIDM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBpZiAobWFuaWZlc3QgY29kZWMgaXMgQUFDKSBBTkQgKGZyZXF1ZW5jeSBsZXNzIHRoYW4gMjRrSHogQU5EIG5iIGNoYW5uZWwgaXMgMSkgT1IgKG1hbmlmZXN0IGNvZGVjIG5vdCBzcGVjaWZpZWQgYW5kIG1vbm8gYXVkaW8pXG4gICAgICAgIC8vIENocm9tZSBmYWlscyB0byBwbGF5IGJhY2sgd2l0aCBsb3cgZnJlcXVlbmN5IEFBQyBMQyBtb25vIHdoZW4gaW5pdGlhbGl6ZWQgd2l0aCBIRS1BQUMuICBUaGlzIGlzIG5vdCBhIHByb2JsZW0gd2l0aCBzdGVyZW8uXG4gICAgICAgIGlmIChhdWRpb0NvZGVjICYmIGF1ZGlvQ29kZWMuaW5kZXhPZignbXA0YS40MC4yJykgIT09IC0xICYmIChhZHRzU2FtcGxlaW5nSW5kZXggPj0gNiAmJiBhZHRzQ2hhbmVsQ29uZmlnID09PSAxKSB8fFxuICAgICAgICAgICAgKCFhdWRpb0NvZGVjICYmIGFkdHNDaGFuZWxDb25maWcgPT09IDEpKSB7XG4gICAgICAgICAgYWR0c09iamVjdFR5cGUgPSAyO1xuICAgICAgICAgIGNvbmZpZyA9IG5ldyBBcnJheSgyKTtcbiAgICAgICAgfVxuICAgICAgICBhZHRzRXh0ZW5zaW9uU2FtcGxlaW5nSW5kZXggPSBhZHRzU2FtcGxlaW5nSW5kZXg7XG4gICAgICB9XG4gICAgfVxuICAgIC8qIHJlZmVyIHRvIGh0dHA6Ly93aWtpLm11bHRpbWVkaWEuY3gvaW5kZXgucGhwP3RpdGxlPU1QRUctNF9BdWRpbyNBdWRpb19TcGVjaWZpY19Db25maWdcbiAgICAgICAgSVNPIDE0NDk2LTMgKEFBQykucGRmIC0gVGFibGUgMS4xMyDigJQgU3ludGF4IG9mIEF1ZGlvU3BlY2lmaWNDb25maWcoKVxuICAgICAgQXVkaW8gUHJvZmlsZSAvIEF1ZGlvIE9iamVjdCBUeXBlXG4gICAgICAwOiBOdWxsXG4gICAgICAxOiBBQUMgTWFpblxuICAgICAgMjogQUFDIExDIChMb3cgQ29tcGxleGl0eSlcbiAgICAgIDM6IEFBQyBTU1IgKFNjYWxhYmxlIFNhbXBsZSBSYXRlKVxuICAgICAgNDogQUFDIExUUCAoTG9uZyBUZXJtIFByZWRpY3Rpb24pXG4gICAgICA1OiBTQlIgKFNwZWN0cmFsIEJhbmQgUmVwbGljYXRpb24pXG4gICAgICA2OiBBQUMgU2NhbGFibGVcbiAgICAgc2FtcGxpbmcgZnJlcVxuICAgICAgMDogOTYwMDAgSHpcbiAgICAgIDE6IDg4MjAwIEh6XG4gICAgICAyOiA2NDAwMCBIelxuICAgICAgMzogNDgwMDAgSHpcbiAgICAgIDQ6IDQ0MTAwIEh6XG4gICAgICA1OiAzMjAwMCBIelxuICAgICAgNjogMjQwMDAgSHpcbiAgICAgIDc6IDIyMDUwIEh6XG4gICAgICA4OiAxNjAwMCBIelxuICAgICAgOTogMTIwMDAgSHpcbiAgICAgIDEwOiAxMTAyNSBIelxuICAgICAgMTE6IDgwMDAgSHpcbiAgICAgIDEyOiA3MzUwIEh6XG4gICAgICAxMzogUmVzZXJ2ZWRcbiAgICAgIDE0OiBSZXNlcnZlZFxuICAgICAgMTU6IGZyZXF1ZW5jeSBpcyB3cml0dGVuIGV4cGxpY3RseVxuICAgICAgQ2hhbm5lbCBDb25maWd1cmF0aW9uc1xuICAgICAgVGhlc2UgYXJlIHRoZSBjaGFubmVsIGNvbmZpZ3VyYXRpb25zOlxuICAgICAgMDogRGVmaW5lZCBpbiBBT1QgU3BlY2lmYyBDb25maWdcbiAgICAgIDE6IDEgY2hhbm5lbDogZnJvbnQtY2VudGVyXG4gICAgICAyOiAyIGNoYW5uZWxzOiBmcm9udC1sZWZ0LCBmcm9udC1yaWdodFxuICAgICovXG4gICAgLy8gYXVkaW9PYmplY3RUeXBlID0gcHJvZmlsZSA9PiBwcm9maWxlLCB0aGUgTVBFRy00IEF1ZGlvIE9iamVjdCBUeXBlIG1pbnVzIDFcbiAgICBjb25maWdbMF0gPSBhZHRzT2JqZWN0VHlwZSA8PCAzO1xuICAgIC8vIHNhbXBsaW5nRnJlcXVlbmN5SW5kZXhcbiAgICBjb25maWdbMF0gfD0gKGFkdHNTYW1wbGVpbmdJbmRleCAmIDB4MEUpID4+IDE7XG4gICAgY29uZmlnWzFdIHw9IChhZHRzU2FtcGxlaW5nSW5kZXggJiAweDAxKSA8PCA3O1xuICAgIC8vIGNoYW5uZWxDb25maWd1cmF0aW9uXG4gICAgY29uZmlnWzFdIHw9IGFkdHNDaGFuZWxDb25maWcgPDwgMztcbiAgICBpZiAoYWR0c09iamVjdFR5cGUgPT09IDUpIHtcbiAgICAgIC8vIGFkdHNFeHRlbnNpb25TYW1wbGVpbmdJbmRleFxuICAgICAgY29uZmlnWzFdIHw9IChhZHRzRXh0ZW5zaW9uU2FtcGxlaW5nSW5kZXggJiAweDBFKSA+PiAxO1xuICAgICAgY29uZmlnWzJdID0gKGFkdHNFeHRlbnNpb25TYW1wbGVpbmdJbmRleCAmIDB4MDEpIDw8IDc7XG4gICAgICAvLyBhZHRzT2JqZWN0VHlwZSAoZm9yY2UgdG8gMiwgY2hyb21lIGlzIGNoZWNraW5nIHRoYXQgb2JqZWN0IHR5cGUgaXMgbGVzcyB0aGFuIDUgPz8/XG4gICAgICAvLyAgICBodHRwczovL2Nocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjLmdpdC8rL21hc3Rlci9tZWRpYS9mb3JtYXRzL21wNC9hYWMuY2NcbiAgICAgIGNvbmZpZ1syXSB8PSAyIDw8IDI7XG4gICAgICBjb25maWdbM10gPSAwO1xuICAgIH1cbiAgICByZXR1cm4ge2NvbmZpZzogY29uZmlnLCBzYW1wbGVyYXRlOiBhZHRzU2FtcGxlaW5nUmF0ZXNbYWR0c1NhbXBsZWluZ0luZGV4XSwgY2hhbm5lbENvdW50OiBhZHRzQ2hhbmVsQ29uZmlnLCBjb2RlYzogKCdtcDRhLjQwLicgKyBhZHRzT2JqZWN0VHlwZSl9O1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEFEVFM7XG4iLCIvKiAgaW5saW5lIGRlbXV4ZXIuXG4gKiAgIHByb2JlIGZyYWdtZW50cyBhbmQgaW5zdGFudGlhdGUgYXBwcm9wcmlhdGUgZGVtdXhlciBkZXBlbmRpbmcgb24gY29udGVudCB0eXBlIChUU0RlbXV4ZXIsIEFBQ0RlbXV4ZXIsIC4uLilcbiAqL1xuXG5pbXBvcnQgRXZlbnQgZnJvbSAnLi4vZXZlbnRzJztcbmltcG9ydCB7RXJyb3JUeXBlcywgRXJyb3JEZXRhaWxzfSBmcm9tICcuLi9lcnJvcnMnO1xuaW1wb3J0IEFBQ0RlbXV4ZXIgZnJvbSAnLi4vZGVtdXgvYWFjZGVtdXhlcic7XG5pbXBvcnQgVFNEZW11eGVyIGZyb20gJy4uL2RlbXV4L3RzZGVtdXhlcic7XG5pbXBvcnQgTVA0UmVtdXhlciBmcm9tICcuLi9yZW11eC9tcDQtcmVtdXhlcic7XG5pbXBvcnQgUGFzc1Rocm91Z2hSZW11eGVyIGZyb20gJy4uL3JlbXV4L3Bhc3N0aHJvdWdoLXJlbXV4ZXInO1xuXG5jbGFzcyBEZW11eGVySW5saW5lIHtcblxuICBjb25zdHJ1Y3RvcihobHMsaWQsIHR5cGVTdXBwb3J0ZWQsIGNvbmZpZz1udWxsKSB7XG4gICAgdGhpcy5obHMgPSBobHM7XG4gICAgdGhpcy5pZCA9IGlkO1xuICAgIHRoaXMuY29uZmlnID0gdGhpcy5obHMuY29uZmlnIHx8IGNvbmZpZztcbiAgICB0aGlzLnR5cGVTdXBwb3J0ZWQgPSB0eXBlU3VwcG9ydGVkO1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICB2YXIgZGVtdXhlciA9IHRoaXMuZGVtdXhlcjtcbiAgICBpZiAoZGVtdXhlcikge1xuICAgICAgZGVtdXhlci5kZXN0cm95KCk7XG4gICAgfVxuICB9XG5cbiAgcHVzaChkYXRhLCBhdWRpb0NvZGVjLCB2aWRlb0NvZGVjLCB0aW1lT2Zmc2V0LCBjYywgbGV2ZWwsIHNuLCBkdXJhdGlvbixhY2N1cmF0ZVRpbWVPZmZzZXQsZGVmYXVsdEluaXRQVFMpIHtcbiAgICB2YXIgZGVtdXhlciA9IHRoaXMuZGVtdXhlcjtcbiAgICBpZiAoIWRlbXV4ZXIgfHzCoFxuICAgICAgIC8vIGluIGNhc2Ugb2YgY29udGludWl0eSBjaGFuZ2UsIHdlIG1pZ2h0IHN3aXRjaCBmcm9tIGNvbnRlbnQgdHlwZSAoQUFDIGNvbnRhaW5lciB0byBUUyBjb250YWluZXIgZm9yIGV4YW1wbGUpXG4gICAgICAgLy8gc28gbGV0J3MgY2hlY2sgdGhhdCBjdXJyZW50IGRlbXV4ZXIgaXMgc3RpbGwgdmFsaWRcbiAgICAgICAgKGNjICE9PSB0aGlzLmNjICYmICFkZW11eGVyLnByb2JlKGRhdGEpKSkge1xuICAgICAgbGV0IGhscyA9IHRoaXMuaGxzLFxuICAgICAgICAgIGlkID0gdGhpcy5pZCxcbiAgICAgICAgICBjb25maWcgPSB0aGlzLmNvbmZpZyxcbiAgICAgICAgICB0eXBlU3VwcG9ydGVkID0gdGhpcy50eXBlU3VwcG9ydGVkO1xuICAgICAgLy8gcHJvYmUgZm9yIGNvbnRlbnQgdHlwZVxuICAgICAgaWYgKFRTRGVtdXhlci5wcm9iZShkYXRhKSkge1xuICAgICAgICBpZiAodGhpcy50eXBlU3VwcG9ydGVkLm1wMnQgPT09IHRydWUpIHtcbiAgICAgICAgICBkZW11eGVyID0gbmV3IFRTRGVtdXhlcihobHMsIGlkLCBQYXNzVGhyb3VnaFJlbXV4ZXIsIGNvbmZpZywgdHlwZVN1cHBvcnRlZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVtdXhlciA9IG5ldyBUU0RlbXV4ZXIoaGxzLCBpZCwgTVA0UmVtdXhlciwgY29uZmlnLCB0eXBlU3VwcG9ydGVkKTtcbiAgICAgICAgfVxuICAgICAgICBkZW11eGVyLnByb2JlID0gVFNEZW11eGVyLnByb2JlO1xuICAgICAgfSBlbHNlIGlmKEFBQ0RlbXV4ZXIucHJvYmUoZGF0YSkpIHtcbiAgICAgICAgZGVtdXhlciA9IG5ldyBBQUNEZW11eGVyKGhscywgaWQsIE1QNFJlbXV4ZXIsIGNvbmZpZywgdHlwZVN1cHBvcnRlZCk7XG4gICAgICAgIGRlbXV4ZXIucHJvYmUgPSBBQUNEZW11eGVyLnByb2JlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnQuRVJST1IsIHt0eXBlIDogRXJyb3JUeXBlcy5NRURJQV9FUlJPUiwgaWQgOiBpZCwgZGV0YWlsczogRXJyb3JEZXRhaWxzLkZSQUdfUEFSU0lOR19FUlJPUiwgZmF0YWw6IHRydWUsIHJlYXNvbjogJ25vIGRlbXV4IG1hdGNoaW5nIHdpdGggY29udGVudCBmb3VuZCd9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5kZW11eGVyID0gZGVtdXhlcjtcbiAgICB9XG4gICAgZGVtdXhlci5wdXNoKGRhdGEsYXVkaW9Db2RlYyx2aWRlb0NvZGVjLHRpbWVPZmZzZXQsY2MsbGV2ZWwsc24sZHVyYXRpb24sYWNjdXJhdGVUaW1lT2Zmc2V0LGRlZmF1bHRJbml0UFRTKTtcbiAgICB0aGlzLmNjID0gY2M7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgRGVtdXhlcklubGluZTtcbiIsIi8qIGRlbXV4ZXIgd2ViIHdvcmtlci5cbiAqICAtIGxpc3RlbiB0byB3b3JrZXIgbWVzc2FnZSwgYW5kIHRyaWdnZXIgRGVtdXhlcklubGluZSB1cG9uIHJlY2VwdGlvbiBvZiBGcmFnbWVudHMuXG4gKiAgLSBwcm92aWRlcyBNUDQgQm94ZXMgYmFjayB0byBtYWluIHRocmVhZCB1c2luZyBbdHJhbnNmZXJhYmxlIG9iamVjdHNdKGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL3dlYi91cGRhdGVzLzIwMTEvMTIvVHJhbnNmZXJhYmxlLU9iamVjdHMtTGlnaHRuaW5nLUZhc3QpIGluIG9yZGVyIHRvIG1pbmltaXplIG1lc3NhZ2UgcGFzc2luZyBvdmVyaGVhZC5cbiAqL1xuXG4gaW1wb3J0IERlbXV4ZXJJbmxpbmUgZnJvbSAnLi4vZGVtdXgvZGVtdXhlci1pbmxpbmUnO1xuIGltcG9ydCBFdmVudCBmcm9tICcuLi9ldmVudHMnO1xuIGltcG9ydCB7ZW5hYmxlTG9nc30gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcbiBpbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gJ2V2ZW50cyc7XG5cbnZhciBEZW11eGVyV29ya2VyID0gZnVuY3Rpb24gKHNlbGYpIHtcbiAgLy8gb2JzZXJ2ZXIgc2V0dXBcbiAgdmFyIG9ic2VydmVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICBvYnNlcnZlci50cmlnZ2VyID0gZnVuY3Rpb24gdHJpZ2dlciAoZXZlbnQsIC4uLmRhdGEpIHtcbiAgICBvYnNlcnZlci5lbWl0KGV2ZW50LCBldmVudCwgLi4uZGF0YSk7XG4gIH07XG5cbiAgb2JzZXJ2ZXIub2ZmID0gZnVuY3Rpb24gb2ZmIChldmVudCwgLi4uZGF0YSkge1xuICAgIG9ic2VydmVyLnJlbW92ZUxpc3RlbmVyKGV2ZW50LCAuLi5kYXRhKTtcbiAgfTtcblxuICB2YXIgZm9yd2FyZE1lc3NhZ2UgPSBmdW5jdGlvbihldixkYXRhKSB7XG4gICAgc2VsZi5wb3N0TWVzc2FnZSh7ZXZlbnQ6IGV2LCBkYXRhOmRhdGEgfSk7XG4gIH07XG5cbiAgc2VsZi5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgZnVuY3Rpb24gKGV2KSB7XG4gICAgdmFyIGRhdGEgPSBldi5kYXRhO1xuICAgIC8vY29uc29sZS5sb2coJ2RlbXV4ZXIgY21kOicgKyBkYXRhLmNtZCk7XG4gICAgc3dpdGNoIChkYXRhLmNtZCkge1xuICAgICAgY2FzZSAnaW5pdCc6XG4gICAgICAgIGxldCBjb25maWcgPSBKU09OLnBhcnNlKGRhdGEuY29uZmlnKTtcbiAgICAgICAgc2VsZi5kZW11eGVyID0gbmV3IERlbXV4ZXJJbmxpbmUob2JzZXJ2ZXIsIGRhdGEuaWQsIGRhdGEudHlwZVN1cHBvcnRlZCwgY29uZmlnKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBlbmFibGVMb2dzKGNvbmZpZy5kZWJ1ZyA9PT0gdHJ1ZSk7XG4gICAgICAgIH0gY2F0Y2goZXJyKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKCdkZW11eGVyV29ya2VyOiB1bmFibGUgdG8gZW5hYmxlIGxvZ3MnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzaWduYWwgZW5kIG9mIHdvcmtlciBpbml0XG4gICAgICAgIGZvcndhcmRNZXNzYWdlKCdpbml0JyxudWxsKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdkZW11eCc6XG4gICAgICAgIHNlbGYuZGVtdXhlci5wdXNoKG5ldyBVaW50OEFycmF5KGRhdGEuZGF0YSksIGRhdGEuYXVkaW9Db2RlYywgZGF0YS52aWRlb0NvZGVjLCBkYXRhLnRpbWVPZmZzZXQsIGRhdGEuY2MsIGRhdGEubGV2ZWwsIGRhdGEuc24sIGRhdGEuZHVyYXRpb24sZGF0YS5hY2N1cmF0ZVRpbWVPZmZzZXQsZGF0YS5kZWZhdWx0SW5pdFBUUyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9KTtcblxuICAvLyBmb3J3YXJkIGV2ZW50cyB0byBtYWluIHRocmVhZFxuICBvYnNlcnZlci5vbihFdmVudC5GUkFHX1BBUlNJTkdfSU5JVF9TRUdNRU5ULCBmb3J3YXJkTWVzc2FnZSk7XG4gIG9ic2VydmVyLm9uKEV2ZW50LkZSQUdfUEFSU0VELCBmb3J3YXJkTWVzc2FnZSk7XG4gIG9ic2VydmVyLm9uKEV2ZW50LkVSUk9SLCBmb3J3YXJkTWVzc2FnZSk7XG4gIG9ic2VydmVyLm9uKEV2ZW50LkZSQUdfUEFSU0lOR19NRVRBREFUQSwgZm9yd2FyZE1lc3NhZ2UpO1xuICBvYnNlcnZlci5vbihFdmVudC5GUkFHX1BBUlNJTkdfVVNFUkRBVEEsIGZvcndhcmRNZXNzYWdlKTtcbiAgb2JzZXJ2ZXIub24oRXZlbnQuSU5JVF9QVFNfRk9VTkQsIGZvcndhcmRNZXNzYWdlKTtcblxuICAvLyBzcGVjaWFsIGNhc2UgZm9yIEZSQUdfUEFSU0lOR19EQVRBOiBwYXNzIGRhdGExL2RhdGEyIGFzIHRyYW5zZmVyYWJsZSBvYmplY3QgKG5vIGNvcHkpXG4gIG9ic2VydmVyLm9uKEV2ZW50LkZSQUdfUEFSU0lOR19EQVRBLCBmdW5jdGlvbihldiwgZGF0YSkge1xuICAgIGxldCBkYXRhMSA9IGRhdGEuZGF0YTEuYnVmZmVyLCBkYXRhMiA9IGRhdGEuZGF0YTIuYnVmZmVyO1xuICAgIC8vIHJlbW92ZSBkYXRhMSBhbmQgZGF0YTIgcmVmZXJlbmNlIGZyb20gZGF0YSB0byBhdm9pZCBjb3B5aW5nIHRoZW0gLi4uXG4gICAgZGVsZXRlIGRhdGEuZGF0YTE7XG4gICAgZGVsZXRlIGRhdGEuZGF0YTI7XG4gICAgc2VsZi5wb3N0TWVzc2FnZSh7ZXZlbnQ6IGV2LCBkYXRhOmRhdGEgLCBkYXRhMSA6IGRhdGExLCBkYXRhMiA6IGRhdGEyfSxbZGF0YTEsIGRhdGEyXSk7XG4gIH0pO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgRGVtdXhlcldvcmtlcjtcblxuIiwiaW1wb3J0IEV2ZW50IGZyb20gJy4uL2V2ZW50cyc7XG5pbXBvcnQgRGVtdXhlcklubGluZSBmcm9tICcuLi9kZW11eC9kZW11eGVyLWlubGluZSc7XG5pbXBvcnQgRGVtdXhlcldvcmtlciBmcm9tICcuLi9kZW11eC9kZW11eGVyLXdvcmtlcic7XG5pbXBvcnQge2xvZ2dlcn0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcbmltcG9ydCBEZWNyeXB0ZXIgZnJvbSAnLi4vY3J5cHQvZGVjcnlwdGVyJztcbmltcG9ydCB7RXJyb3JUeXBlcywgRXJyb3JEZXRhaWxzfSBmcm9tICcuLi9lcnJvcnMnO1xuXG5jbGFzcyBEZW11eGVyIHtcblxuICBjb25zdHJ1Y3RvcihobHMsIGlkKSB7XG4gICAgdGhpcy5obHMgPSBobHM7XG4gICAgdGhpcy5pZCA9IGlkO1xuICAgIHZhciB0eXBlU3VwcG9ydGVkID0ge1xuICAgICAgbXA0IDogTWVkaWFTb3VyY2UuaXNUeXBlU3VwcG9ydGVkKCd2aWRlby9tcDQnKSxcbiAgICAgIG1wMnQgOiBobHMuY29uZmlnLmVuYWJsZU1QMlRQYXNzVGhyb3VnaCAmJiBNZWRpYVNvdXJjZS5pc1R5cGVTdXBwb3J0ZWQoJ3ZpZGVvL21wMnQnKSxcbiAgICAgIG1wZWc6IE1lZGlhU291cmNlLmlzVHlwZVN1cHBvcnRlZCgnYXVkaW8vbXBlZycpLFxuICAgICAgbXAzOiBNZWRpYVNvdXJjZS5pc1R5cGVTdXBwb3J0ZWQoJ2F1ZGlvL21wNDsgY29kZWNzPVwibXAzXCInKVxuICAgIH07XG4gICAgaWYgKGhscy5jb25maWcuZW5hYmxlV29ya2VyICYmICh0eXBlb2YoV29ya2VyKSAhPT0gJ3VuZGVmaW5lZCcpKSB7XG4gICAgICAgIGxvZ2dlci5sb2coJ2RlbXV4aW5nIGluIHdlYndvcmtlcicpO1xuICAgICAgICBsZXQgdztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBsZXQgd29yayA9IHJlcXVpcmUoJ3dlYndvcmtpZnknKTtcbiAgICAgICAgICB3ID0gdGhpcy53ID0gd29yayhEZW11eGVyV29ya2VyKTtcbiAgICAgICAgICB0aGlzLm9ud21zZyA9IHRoaXMub25Xb3JrZXJNZXNzYWdlLmJpbmQodGhpcyk7XG4gICAgICAgICAgdy5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgdGhpcy5vbndtc2cpO1xuICAgICAgICAgIHcub25lcnJvciA9IGZ1bmN0aW9uKGV2ZW50KSB7IGhscy50cmlnZ2VyKEV2ZW50LkVSUk9SLCB7dHlwZTogRXJyb3JUeXBlcy5PVEhFUl9FUlJPUiwgZGV0YWlsczogRXJyb3JEZXRhaWxzLklOVEVSTkFMX0VYQ0VQVElPTiwgZmF0YWw6IHRydWUsIGV2ZW50IDogJ2RlbXV4ZXJXb3JrZXInLCBlcnIgOiB7IG1lc3NhZ2UgOiBldmVudC5tZXNzYWdlICsgJyAoJyArIGV2ZW50LmZpbGVuYW1lICsgJzonICsgZXZlbnQubGluZW5vICsgJyknIH19KTt9O1xuICAgICAgICAgIHcucG9zdE1lc3NhZ2Uoe2NtZDogJ2luaXQnLCB0eXBlU3VwcG9ydGVkIDogdHlwZVN1cHBvcnRlZCwgaWQgOiBpZCwgY29uZmlnOiBKU09OLnN0cmluZ2lmeShobHMuY29uZmlnKX0pO1xuICAgICAgICB9IGNhdGNoKGVycikge1xuICAgICAgICAgIGxvZ2dlci5lcnJvcignZXJyb3Igd2hpbGUgaW5pdGlhbGl6aW5nIERlbXV4ZXJXb3JrZXIsIGZhbGxiYWNrIG9uIERlbXV4ZXJJbmxpbmUnKTtcbiAgICAgICAgICBpZiAodykge1xuICAgICAgICAgICAgLy8gcmV2b2tlIHRoZSBPYmplY3QgVVJMIHRoYXQgd2FzIHVzZWQgdG8gY3JlYXRlIGRlbXV4ZXIgd29ya2VyLCBzbyBhcyBub3QgdG8gbGVhayBpdFxuICAgICAgICAgICAgVVJMLnJldm9rZU9iamVjdFVSTCh3Lm9iamVjdFVSTCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuZGVtdXhlciA9IG5ldyBEZW11eGVySW5saW5lKGhscyxpZCx0eXBlU3VwcG9ydGVkKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5kZW11eGVyID0gbmV3IERlbXV4ZXJJbmxpbmUoaGxzLGlkLHR5cGVTdXBwb3J0ZWQpO1xuICAgICAgfVxuICAgICAgdGhpcy5kZW11eEluaXRpYWxpemVkID0gdHJ1ZTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgbGV0IHcgPSB0aGlzLnc7XG4gICAgaWYgKHcpIHtcbiAgICAgIHcucmVtb3ZlRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIHRoaXMub253bXNnKTtcbiAgICAgIHcudGVybWluYXRlKCk7XG4gICAgICB0aGlzLncgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgZGVtdXhlciA9IHRoaXMuZGVtdXhlcjtcbiAgICAgIGlmIChkZW11eGVyKSB7XG4gICAgICAgIGRlbXV4ZXIuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLmRlbXV4ZXIgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgZGVjcnlwdGVyID0gdGhpcy5kZWNyeXB0ZXI7XG4gICAgaWYgKGRlY3J5cHRlcikge1xuICAgICAgZGVjcnlwdGVyLmRlc3Ryb3koKTtcbiAgICAgIHRoaXMuZGVjcnlwdGVyID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICBwdXNoRGVjcnlwdGVkKGRhdGEsIGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWMsIHRpbWVPZmZzZXQsIGNjLCBsZXZlbCwgc24sIGR1cmF0aW9uLGFjY3VyYXRlVGltZU9mZnNldCxkZWZhdWx0SW5pdFBUUykge1xuICAgIGxldCB3ID0gdGhpcy53O1xuICAgIGlmICh3KSB7XG4gICAgICAvLyBwb3N0IGZyYWdtZW50IHBheWxvYWQgYXMgdHJhbnNmZXJhYmxlIG9iamVjdHMgKG5vIGNvcHkpXG4gICAgICB3LnBvc3RNZXNzYWdlKHtjbWQ6ICdkZW11eCcsIGRhdGE6IGRhdGEsIGF1ZGlvQ29kZWM6IGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWM6IHZpZGVvQ29kZWMsIHRpbWVPZmZzZXQ6IHRpbWVPZmZzZXQsIGNjOiBjYywgbGV2ZWw6IGxldmVsLCBzbiA6IHNuLCBkdXJhdGlvbjogZHVyYXRpb24sIGFjY3VyYXRlVGltZU9mZnNldCA6IGFjY3VyYXRlVGltZU9mZnNldCwgZGVmYXVsdEluaXRQVFMgOiBkZWZhdWx0SW5pdFBUUyB9LCBbZGF0YV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgZGVtdXhlciA9IHRoaXMuZGVtdXhlcjtcbiAgICAgIGlmIChkZW11eGVyKSB7XG4gICAgICAgIGRlbXV4ZXIucHVzaChuZXcgVWludDhBcnJheShkYXRhKSwgYXVkaW9Db2RlYywgdmlkZW9Db2RlYywgdGltZU9mZnNldCwgY2MsIGxldmVsLCBzbiwgZHVyYXRpb24sYWNjdXJhdGVUaW1lT2Zmc2V0LGRlZmF1bHRJbml0UFRTKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwdXNoKGRhdGEsIGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWMsIHRpbWVPZmZzZXQsIGNjLCBsZXZlbCwgc24sIGR1cmF0aW9uLCBkZWNyeXB0ZGF0YSxhY2N1cmF0ZVRpbWVPZmZzZXQsZGVmYXVsdEluaXRQVFMpIHtcbiAgICBpZiAoKGRhdGEuYnl0ZUxlbmd0aCA+IDApICYmIChkZWNyeXB0ZGF0YSAhPSBudWxsKSAmJiAoZGVjcnlwdGRhdGEua2V5ICE9IG51bGwpICYmIChkZWNyeXB0ZGF0YS5tZXRob2QgPT09ICdBRVMtMTI4JykpIHtcbiAgICAgIGlmICh0aGlzLmRlY3J5cHRlciA9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuZGVjcnlwdGVyID0gbmV3IERlY3J5cHRlcih0aGlzLmhscyk7XG4gICAgICB9XG4gICAgICB2YXIgbG9jYWx0aGlzID0gdGhpcztcbiAgICAgIHZhciBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIHRoaXMuZGVjcnlwdGVyLmRlY3J5cHQoZGF0YSwgZGVjcnlwdGRhdGEua2V5LmJ1ZmZlciwgZGVjcnlwdGRhdGEuaXYuYnVmZmVyLCBmdW5jdGlvbiAoZGVjcnlwdGVkRGF0YSkge1xuICAgICAgICBsb2NhbHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuRlJBR19ERUNSWVBURUQsIHsgbGV2ZWwgOiBsZXZlbCwgc24gOiBzbiwgc3RhdHM6IHsgdHN0YXJ0OiBzdGFydFRpbWUsIHRkZWNyeXB0OiBwZXJmb3JtYW5jZS5ub3coKSB9IH0pO1xuICAgICAgICBsb2NhbHRoaXMucHVzaERlY3J5cHRlZChkZWNyeXB0ZWREYXRhLCBhdWRpb0NvZGVjLCB2aWRlb0NvZGVjLCB0aW1lT2Zmc2V0LCBjYywgbGV2ZWwsIHNuLCBkdXJhdGlvbiwgYWNjdXJhdGVUaW1lT2Zmc2V0LGRlZmF1bHRJbml0UFRTKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnB1c2hEZWNyeXB0ZWQoZGF0YSwgYXVkaW9Db2RlYywgdmlkZW9Db2RlYywgdGltZU9mZnNldCwgY2MsIGxldmVsLCBzbiwgZHVyYXRpb24sYWNjdXJhdGVUaW1lT2Zmc2V0LGRlZmF1bHRJbml0UFRTKTtcbiAgICB9XG4gIH1cblxuICBvbldvcmtlck1lc3NhZ2UoZXYpIHtcbiAgICBsZXQgZGF0YSA9IGV2LmRhdGEsXG4gICAgICAgIGhscyA9IHRoaXMuaGxzO1xuICAgIC8vY29uc29sZS5sb2coJ29uV29ya2VyTWVzc2FnZTonICsgZGF0YS5ldmVudCk7XG4gICAgc3dpdGNoKGRhdGEuZXZlbnQpIHtcbiAgICAgIGNhc2UgJ2luaXQnOlxuICAgICAgICAvLyByZXZva2UgdGhlIE9iamVjdCBVUkwgdGhhdCB3YXMgdXNlZCB0byBjcmVhdGUgZGVtdXhlciB3b3JrZXIsIHNvIGFzIG5vdCB0byBsZWFrIGl0XG4gICAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwodGhpcy53Lm9iamVjdFVSTCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgLy8gc3BlY2lhbCBjYXNlIGZvciBGUkFHX1BBUlNJTkdfREFUQTogZGF0YTEgYW5kIGRhdGEyIGFyZSB0cmFuc2ZlcmFibGUgb2JqZWN0c1xuICAgICAgY2FzZSBFdmVudC5GUkFHX1BBUlNJTkdfREFUQTpcbiAgICAgICAgZGF0YS5kYXRhLmRhdGExID0gbmV3IFVpbnQ4QXJyYXkoZGF0YS5kYXRhMSk7XG4gICAgICAgIGRhdGEuZGF0YS5kYXRhMiA9IG5ldyBVaW50OEFycmF5KGRhdGEuZGF0YTIpO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBobHMudHJpZ2dlcihkYXRhLmV2ZW50LCBkYXRhLmRhdGEpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgRGVtdXhlcjtcblxuIiwiLyoqXG4gKiBQYXJzZXIgZm9yIGV4cG9uZW50aWFsIEdvbG9tYiBjb2RlcywgYSB2YXJpYWJsZS1iaXR3aWR0aCBudW1iZXIgZW5jb2Rpbmcgc2NoZW1lIHVzZWQgYnkgaDI2NC5cbiovXG5cbmltcG9ydCB7bG9nZ2VyfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xuXG5jbGFzcyBFeHBHb2xvbWIge1xuXG4gIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIC8vIHRoZSBudW1iZXIgb2YgYnl0ZXMgbGVmdCB0byBleGFtaW5lIGluIHRoaXMuZGF0YVxuICAgIHRoaXMuYnl0ZXNBdmFpbGFibGUgPSBkYXRhLmJ5dGVMZW5ndGg7XG4gICAgLy8gdGhlIGN1cnJlbnQgd29yZCBiZWluZyBleGFtaW5lZFxuICAgIHRoaXMud29yZCA9IDA7IC8vIDp1aW50XG4gICAgLy8gdGhlIG51bWJlciBvZiBiaXRzIGxlZnQgdG8gZXhhbWluZSBpbiB0aGUgY3VycmVudCB3b3JkXG4gICAgdGhpcy5iaXRzQXZhaWxhYmxlID0gMDsgLy8gOnVpbnRcbiAgfVxuXG4gIC8vICgpOnZvaWRcbiAgbG9hZFdvcmQoKSB7XG4gICAgdmFyXG4gICAgICBkYXRhID0gdGhpcy5kYXRhLFxuICAgICAgYnl0ZXNBdmFpbGFibGUgPSB0aGlzLmJ5dGVzQXZhaWxhYmxlLFxuICAgICAgcG9zaXRpb24gPSBkYXRhLmJ5dGVMZW5ndGggLSBieXRlc0F2YWlsYWJsZSxcbiAgICAgIHdvcmtpbmdCeXRlcyA9IG5ldyBVaW50OEFycmF5KDQpLFxuICAgICAgYXZhaWxhYmxlQnl0ZXMgPSBNYXRoLm1pbig0LCBieXRlc0F2YWlsYWJsZSk7XG4gICAgaWYgKGF2YWlsYWJsZUJ5dGVzID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vIGJ5dGVzIGF2YWlsYWJsZScpO1xuICAgIH1cbiAgICB3b3JraW5nQnl0ZXMuc2V0KGRhdGEuc3ViYXJyYXkocG9zaXRpb24sIHBvc2l0aW9uICsgYXZhaWxhYmxlQnl0ZXMpKTtcbiAgICB0aGlzLndvcmQgPSBuZXcgRGF0YVZpZXcod29ya2luZ0J5dGVzLmJ1ZmZlcikuZ2V0VWludDMyKDApO1xuICAgIC8vIHRyYWNrIHRoZSBhbW91bnQgb2YgdGhpcy5kYXRhIHRoYXQgaGFzIGJlZW4gcHJvY2Vzc2VkXG4gICAgdGhpcy5iaXRzQXZhaWxhYmxlID0gYXZhaWxhYmxlQnl0ZXMgKiA4O1xuICAgIHRoaXMuYnl0ZXNBdmFpbGFibGUgLT0gYXZhaWxhYmxlQnl0ZXM7XG4gIH1cblxuICAvLyAoY291bnQ6aW50KTp2b2lkXG4gIHNraXBCaXRzKGNvdW50KSB7XG4gICAgdmFyIHNraXBCeXRlczsgLy8gOmludFxuICAgIGlmICh0aGlzLmJpdHNBdmFpbGFibGUgPiBjb3VudCkge1xuICAgICAgdGhpcy53b3JkIDw8PSBjb3VudDtcbiAgICAgIHRoaXMuYml0c0F2YWlsYWJsZSAtPSBjb3VudDtcbiAgICB9IGVsc2Uge1xuICAgICAgY291bnQgLT0gdGhpcy5iaXRzQXZhaWxhYmxlO1xuICAgICAgc2tpcEJ5dGVzID0gY291bnQgPj4gMztcbiAgICAgIGNvdW50IC09IChza2lwQnl0ZXMgPj4gMyk7XG4gICAgICB0aGlzLmJ5dGVzQXZhaWxhYmxlIC09IHNraXBCeXRlcztcbiAgICAgIHRoaXMubG9hZFdvcmQoKTtcbiAgICAgIHRoaXMud29yZCA8PD0gY291bnQ7XG4gICAgICB0aGlzLmJpdHNBdmFpbGFibGUgLT0gY291bnQ7XG4gICAgfVxuICB9XG5cbiAgLy8gKHNpemU6aW50KTp1aW50XG4gIHJlYWRCaXRzKHNpemUpIHtcbiAgICB2YXJcbiAgICAgIGJpdHMgPSBNYXRoLm1pbih0aGlzLmJpdHNBdmFpbGFibGUsIHNpemUpLCAvLyA6dWludFxuICAgICAgdmFsdSA9IHRoaXMud29yZCA+Pj4gKDMyIC0gYml0cyk7IC8vIDp1aW50XG4gICAgaWYgKHNpemUgPiAzMikge1xuICAgICAgbG9nZ2VyLmVycm9yKCdDYW5ub3QgcmVhZCBtb3JlIHRoYW4gMzIgYml0cyBhdCBhIHRpbWUnKTtcbiAgICB9XG4gICAgdGhpcy5iaXRzQXZhaWxhYmxlIC09IGJpdHM7XG4gICAgaWYgKHRoaXMuYml0c0F2YWlsYWJsZSA+IDApIHtcbiAgICAgIHRoaXMud29yZCA8PD0gYml0cztcbiAgICB9IGVsc2UgaWYgKHRoaXMuYnl0ZXNBdmFpbGFibGUgPiAwKSB7XG4gICAgICB0aGlzLmxvYWRXb3JkKCk7XG4gICAgfVxuICAgIGJpdHMgPSBzaXplIC0gYml0cztcbiAgICBpZiAoYml0cyA+IDAgJiYgdGhpcy5iaXRzQXZhaWxhYmxlKSB7XG4gICAgICByZXR1cm4gdmFsdSA8PCBiaXRzIHwgdGhpcy5yZWFkQml0cyhiaXRzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHZhbHU7XG4gICAgfVxuICB9XG5cbiAgLy8gKCk6dWludFxuICBza2lwTFooKSB7XG4gICAgdmFyIGxlYWRpbmdaZXJvQ291bnQ7IC8vIDp1aW50XG4gICAgZm9yIChsZWFkaW5nWmVyb0NvdW50ID0gMDsgbGVhZGluZ1plcm9Db3VudCA8IHRoaXMuYml0c0F2YWlsYWJsZTsgKytsZWFkaW5nWmVyb0NvdW50KSB7XG4gICAgICBpZiAoMCAhPT0gKHRoaXMud29yZCAmICgweDgwMDAwMDAwID4+PiBsZWFkaW5nWmVyb0NvdW50KSkpIHtcbiAgICAgICAgLy8gdGhlIGZpcnN0IGJpdCBvZiB3b3JraW5nIHdvcmQgaXMgMVxuICAgICAgICB0aGlzLndvcmQgPDw9IGxlYWRpbmdaZXJvQ291bnQ7XG4gICAgICAgIHRoaXMuYml0c0F2YWlsYWJsZSAtPSBsZWFkaW5nWmVyb0NvdW50O1xuICAgICAgICByZXR1cm4gbGVhZGluZ1plcm9Db3VudDtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gd2UgZXhoYXVzdGVkIHdvcmQgYW5kIHN0aWxsIGhhdmUgbm90IGZvdW5kIGEgMVxuICAgIHRoaXMubG9hZFdvcmQoKTtcbiAgICByZXR1cm4gbGVhZGluZ1plcm9Db3VudCArIHRoaXMuc2tpcExaKCk7XG4gIH1cblxuICAvLyAoKTp2b2lkXG4gIHNraXBVRUcoKSB7XG4gICAgdGhpcy5za2lwQml0cygxICsgdGhpcy5za2lwTFooKSk7XG4gIH1cblxuICAvLyAoKTp2b2lkXG4gIHNraXBFRygpIHtcbiAgICB0aGlzLnNraXBCaXRzKDEgKyB0aGlzLnNraXBMWigpKTtcbiAgfVxuXG4gIC8vICgpOnVpbnRcbiAgcmVhZFVFRygpIHtcbiAgICB2YXIgY2x6ID0gdGhpcy5za2lwTFooKTsgLy8gOnVpbnRcbiAgICByZXR1cm4gdGhpcy5yZWFkQml0cyhjbHogKyAxKSAtIDE7XG4gIH1cblxuICAvLyAoKTppbnRcbiAgcmVhZEVHKCkge1xuICAgIHZhciB2YWx1ID0gdGhpcy5yZWFkVUVHKCk7IC8vIDppbnRcbiAgICBpZiAoMHgwMSAmIHZhbHUpIHtcbiAgICAgIC8vIHRoZSBudW1iZXIgaXMgb2RkIGlmIHRoZSBsb3cgb3JkZXIgYml0IGlzIHNldFxuICAgICAgcmV0dXJuICgxICsgdmFsdSkgPj4+IDE7IC8vIGFkZCAxIHRvIG1ha2UgaXQgZXZlbiwgYW5kIGRpdmlkZSBieSAyXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAtMSAqICh2YWx1ID4+PiAxKTsgLy8gZGl2aWRlIGJ5IHR3byB0aGVuIG1ha2UgaXQgbmVnYXRpdmVcbiAgICB9XG4gIH1cblxuICAvLyBTb21lIGNvbnZlbmllbmNlIGZ1bmN0aW9uc1xuICAvLyA6Qm9vbGVhblxuICByZWFkQm9vbGVhbigpIHtcbiAgICByZXR1cm4gMSA9PT0gdGhpcy5yZWFkQml0cygxKTtcbiAgfVxuXG4gIC8vICgpOmludFxuICByZWFkVUJ5dGUoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVhZEJpdHMoOCk7XG4gIH1cblxuICAvLyAoKTppbnRcbiAgcmVhZFVTaG9ydCgpIHtcbiAgICByZXR1cm4gdGhpcy5yZWFkQml0cygxNik7XG4gIH1cbiAgICAvLyAoKTppbnRcbiAgcmVhZFVJbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVhZEJpdHMoMzIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkdmFuY2UgdGhlIEV4cEdvbG9tYiBkZWNvZGVyIHBhc3QgYSBzY2FsaW5nIGxpc3QuIFRoZSBzY2FsaW5nXG4gICAqIGxpc3QgaXMgb3B0aW9uYWxseSB0cmFuc21pdHRlZCBhcyBwYXJ0IG9mIGEgc2VxdWVuY2UgcGFyYW1ldGVyXG4gICAqIHNldCBhbmQgaXMgbm90IHJlbGV2YW50IHRvIHRyYW5zbXV4aW5nLlxuICAgKiBAcGFyYW0gY291bnQge251bWJlcn0gdGhlIG51bWJlciBvZiBlbnRyaWVzIGluIHRoaXMgc2NhbGluZyBsaXN0XG4gICAqIEBzZWUgUmVjb21tZW5kYXRpb24gSVRVLVQgSC4yNjQsIFNlY3Rpb24gNy4zLjIuMS4xLjFcbiAgICovXG4gIHNraXBTY2FsaW5nTGlzdChjb3VudCkge1xuICAgIHZhclxuICAgICAgbGFzdFNjYWxlID0gOCxcbiAgICAgIG5leHRTY2FsZSA9IDgsXG4gICAgICBqLFxuICAgICAgZGVsdGFTY2FsZTtcbiAgICBmb3IgKGogPSAwOyBqIDwgY291bnQ7IGorKykge1xuICAgICAgaWYgKG5leHRTY2FsZSAhPT0gMCkge1xuICAgICAgICBkZWx0YVNjYWxlID0gdGhpcy5yZWFkRUcoKTtcbiAgICAgICAgbmV4dFNjYWxlID0gKGxhc3RTY2FsZSArIGRlbHRhU2NhbGUgKyAyNTYpICUgMjU2O1xuICAgICAgfVxuICAgICAgbGFzdFNjYWxlID0gKG5leHRTY2FsZSA9PT0gMCkgPyBsYXN0U2NhbGUgOiBuZXh0U2NhbGU7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlYWQgYSBzZXF1ZW5jZSBwYXJhbWV0ZXIgc2V0IGFuZCByZXR1cm4gc29tZSBpbnRlcmVzdGluZyB2aWRlb1xuICAgKiBwcm9wZXJ0aWVzLiBBIHNlcXVlbmNlIHBhcmFtZXRlciBzZXQgaXMgdGhlIEgyNjQgbWV0YWRhdGEgdGhhdFxuICAgKiBkZXNjcmliZXMgdGhlIHByb3BlcnRpZXMgb2YgdXBjb21pbmcgdmlkZW8gZnJhbWVzLlxuICAgKiBAcGFyYW0gZGF0YSB7VWludDhBcnJheX0gdGhlIGJ5dGVzIG9mIGEgc2VxdWVuY2UgcGFyYW1ldGVyIHNldFxuICAgKiBAcmV0dXJuIHtvYmplY3R9IGFuIG9iamVjdCB3aXRoIGNvbmZpZ3VyYXRpb24gcGFyc2VkIGZyb20gdGhlXG4gICAqIHNlcXVlbmNlIHBhcmFtZXRlciBzZXQsIGluY2x1ZGluZyB0aGUgZGltZW5zaW9ucyBvZiB0aGVcbiAgICogYXNzb2NpYXRlZCB2aWRlbyBmcmFtZXMuXG4gICAqL1xuICByZWFkU1BTKCkge1xuICAgIHZhclxuICAgICAgZnJhbWVDcm9wTGVmdE9mZnNldCA9IDAsXG4gICAgICBmcmFtZUNyb3BSaWdodE9mZnNldCA9IDAsXG4gICAgICBmcmFtZUNyb3BUb3BPZmZzZXQgPSAwLFxuICAgICAgZnJhbWVDcm9wQm90dG9tT2Zmc2V0ID0gMCxcbiAgICAgIHNhclNjYWxlID0gMSxcbiAgICAgIHByb2ZpbGVJZGMscHJvZmlsZUNvbXBhdCxsZXZlbElkYyxcbiAgICAgIG51bVJlZkZyYW1lc0luUGljT3JkZXJDbnRDeWNsZSwgcGljV2lkdGhJbk1ic01pbnVzMSxcbiAgICAgIHBpY0hlaWdodEluTWFwVW5pdHNNaW51czEsXG4gICAgICBmcmFtZU1ic09ubHlGbGFnLFxuICAgICAgc2NhbGluZ0xpc3RDb3VudCxcbiAgICAgIGksXG4gICAgICByZWFkVUJ5dGUgPSB0aGlzLnJlYWRVQnl0ZS5iaW5kKHRoaXMpLFxuICAgICAgcmVhZEJpdHMgPSB0aGlzLnJlYWRCaXRzLmJpbmQodGhpcyksXG4gICAgICByZWFkVUVHID0gdGhpcy5yZWFkVUVHLmJpbmQodGhpcyksXG4gICAgICByZWFkQm9vbGVhbiA9IHRoaXMucmVhZEJvb2xlYW4uYmluZCh0aGlzKSxcbiAgICAgIHNraXBCaXRzID0gdGhpcy5za2lwQml0cy5iaW5kKHRoaXMpLFxuICAgICAgc2tpcEVHID0gdGhpcy5za2lwRUcuYmluZCh0aGlzKSxcbiAgICAgIHNraXBVRUcgPSB0aGlzLnNraXBVRUcuYmluZCh0aGlzKSxcbiAgICAgIHNraXBTY2FsaW5nTGlzdCA9IHRoaXMuc2tpcFNjYWxpbmdMaXN0LmJpbmQodGhpcyk7XG5cbiAgICByZWFkVUJ5dGUoKTtcbiAgICBwcm9maWxlSWRjID0gcmVhZFVCeXRlKCk7IC8vIHByb2ZpbGVfaWRjXG4gICAgcHJvZmlsZUNvbXBhdCA9IHJlYWRCaXRzKDUpOyAvLyBjb25zdHJhaW50X3NldFswLTRdX2ZsYWcsIHUoNSlcbiAgICBza2lwQml0cygzKTsgLy8gcmVzZXJ2ZWRfemVyb18zYml0cyB1KDMpLFxuICAgIGxldmVsSWRjID0gcmVhZFVCeXRlKCk7IC8vbGV2ZWxfaWRjIHUoOClcbiAgICBza2lwVUVHKCk7IC8vIHNlcV9wYXJhbWV0ZXJfc2V0X2lkXG4gICAgLy8gc29tZSBwcm9maWxlcyBoYXZlIG1vcmUgb3B0aW9uYWwgZGF0YSB3ZSBkb24ndCBuZWVkXG4gICAgaWYgKHByb2ZpbGVJZGMgPT09IDEwMCB8fFxuICAgICAgICBwcm9maWxlSWRjID09PSAxMTAgfHxcbiAgICAgICAgcHJvZmlsZUlkYyA9PT0gMTIyIHx8XG4gICAgICAgIHByb2ZpbGVJZGMgPT09IDI0NCB8fFxuICAgICAgICBwcm9maWxlSWRjID09PSA0NCAgfHxcbiAgICAgICAgcHJvZmlsZUlkYyA9PT0gODMgIHx8XG4gICAgICAgIHByb2ZpbGVJZGMgPT09IDg2ICB8fFxuICAgICAgICBwcm9maWxlSWRjID09PSAxMTggfHxcbiAgICAgICAgcHJvZmlsZUlkYyA9PT0gMTI4KSB7XG4gICAgICB2YXIgY2hyb21hRm9ybWF0SWRjID0gcmVhZFVFRygpO1xuICAgICAgaWYgKGNocm9tYUZvcm1hdElkYyA9PT0gMykge1xuICAgICAgICBza2lwQml0cygxKTsgLy8gc2VwYXJhdGVfY29sb3VyX3BsYW5lX2ZsYWdcbiAgICAgIH1cbiAgICAgIHNraXBVRUcoKTsgLy8gYml0X2RlcHRoX2x1bWFfbWludXM4XG4gICAgICBza2lwVUVHKCk7IC8vIGJpdF9kZXB0aF9jaHJvbWFfbWludXM4XG4gICAgICBza2lwQml0cygxKTsgLy8gcXBwcmltZV95X3plcm9fdHJhbnNmb3JtX2J5cGFzc19mbGFnXG4gICAgICBpZiAocmVhZEJvb2xlYW4oKSkgeyAvLyBzZXFfc2NhbGluZ19tYXRyaXhfcHJlc2VudF9mbGFnXG4gICAgICAgIHNjYWxpbmdMaXN0Q291bnQgPSAoY2hyb21hRm9ybWF0SWRjICE9PSAzKSA/IDggOiAxMjtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHNjYWxpbmdMaXN0Q291bnQ7IGkrKykge1xuICAgICAgICAgIGlmIChyZWFkQm9vbGVhbigpKSB7IC8vIHNlcV9zY2FsaW5nX2xpc3RfcHJlc2VudF9mbGFnWyBpIF1cbiAgICAgICAgICAgIGlmIChpIDwgNikge1xuICAgICAgICAgICAgICBza2lwU2NhbGluZ0xpc3QoMTYpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc2tpcFNjYWxpbmdMaXN0KDY0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgc2tpcFVFRygpOyAvLyBsb2cyX21heF9mcmFtZV9udW1fbWludXM0XG4gICAgdmFyIHBpY09yZGVyQ250VHlwZSA9IHJlYWRVRUcoKTtcbiAgICBpZiAocGljT3JkZXJDbnRUeXBlID09PSAwKSB7XG4gICAgICByZWFkVUVHKCk7IC8vbG9nMl9tYXhfcGljX29yZGVyX2NudF9sc2JfbWludXM0XG4gICAgfSBlbHNlIGlmIChwaWNPcmRlckNudFR5cGUgPT09IDEpIHtcbiAgICAgIHNraXBCaXRzKDEpOyAvLyBkZWx0YV9waWNfb3JkZXJfYWx3YXlzX3plcm9fZmxhZ1xuICAgICAgc2tpcEVHKCk7IC8vIG9mZnNldF9mb3Jfbm9uX3JlZl9waWNcbiAgICAgIHNraXBFRygpOyAvLyBvZmZzZXRfZm9yX3RvcF90b19ib3R0b21fZmllbGRcbiAgICAgIG51bVJlZkZyYW1lc0luUGljT3JkZXJDbnRDeWNsZSA9IHJlYWRVRUcoKTtcbiAgICAgIGZvcihpID0gMDsgaSA8IG51bVJlZkZyYW1lc0luUGljT3JkZXJDbnRDeWNsZTsgaSsrKSB7XG4gICAgICAgIHNraXBFRygpOyAvLyBvZmZzZXRfZm9yX3JlZl9mcmFtZVsgaSBdXG4gICAgICB9XG4gICAgfVxuICAgIHNraXBVRUcoKTsgLy8gbWF4X251bV9yZWZfZnJhbWVzXG4gICAgc2tpcEJpdHMoMSk7IC8vIGdhcHNfaW5fZnJhbWVfbnVtX3ZhbHVlX2FsbG93ZWRfZmxhZ1xuICAgIHBpY1dpZHRoSW5NYnNNaW51czEgPSByZWFkVUVHKCk7XG4gICAgcGljSGVpZ2h0SW5NYXBVbml0c01pbnVzMSA9IHJlYWRVRUcoKTtcbiAgICBmcmFtZU1ic09ubHlGbGFnID0gcmVhZEJpdHMoMSk7XG4gICAgaWYgKGZyYW1lTWJzT25seUZsYWcgPT09IDApIHtcbiAgICAgIHNraXBCaXRzKDEpOyAvLyBtYl9hZGFwdGl2ZV9mcmFtZV9maWVsZF9mbGFnXG4gICAgfVxuICAgIHNraXBCaXRzKDEpOyAvLyBkaXJlY3RfOHg4X2luZmVyZW5jZV9mbGFnXG4gICAgaWYgKHJlYWRCb29sZWFuKCkpIHsgLy8gZnJhbWVfY3JvcHBpbmdfZmxhZ1xuICAgICAgZnJhbWVDcm9wTGVmdE9mZnNldCA9IHJlYWRVRUcoKTtcbiAgICAgIGZyYW1lQ3JvcFJpZ2h0T2Zmc2V0ID0gcmVhZFVFRygpO1xuICAgICAgZnJhbWVDcm9wVG9wT2Zmc2V0ID0gcmVhZFVFRygpO1xuICAgICAgZnJhbWVDcm9wQm90dG9tT2Zmc2V0ID0gcmVhZFVFRygpO1xuICAgIH1cbiAgICBpZiAocmVhZEJvb2xlYW4oKSkge1xuICAgICAgLy8gdnVpX3BhcmFtZXRlcnNfcHJlc2VudF9mbGFnXG4gICAgICBpZiAocmVhZEJvb2xlYW4oKSkge1xuICAgICAgICAvLyBhc3BlY3RfcmF0aW9faW5mb19wcmVzZW50X2ZsYWdcbiAgICAgICAgbGV0IHNhclJhdGlvO1xuICAgICAgICBjb25zdCBhc3BlY3RSYXRpb0lkYyA9IHJlYWRVQnl0ZSgpO1xuICAgICAgICBzd2l0Y2ggKGFzcGVjdFJhdGlvSWRjKSB7XG4gICAgICAgICAgY2FzZSAxOiBzYXJSYXRpbyA9IFsxLDFdOyBicmVhaztcbiAgICAgICAgICBjYXNlIDI6IHNhclJhdGlvID0gWzEyLDExXTsgYnJlYWs7XG4gICAgICAgICAgY2FzZSAzOiBzYXJSYXRpbyA9IFsxMCwxMV07IGJyZWFrO1xuICAgICAgICAgIGNhc2UgNDogc2FyUmF0aW8gPSBbMTYsMTFdOyBicmVhaztcbiAgICAgICAgICBjYXNlIDU6IHNhclJhdGlvID0gWzQwLDMzXTsgYnJlYWs7XG4gICAgICAgICAgY2FzZSA2OiBzYXJSYXRpbyA9IFsyNCwxMV07IGJyZWFrO1xuICAgICAgICAgIGNhc2UgNzogc2FyUmF0aW8gPSBbMjAsMTFdOyBicmVhaztcbiAgICAgICAgICBjYXNlIDg6IHNhclJhdGlvID0gWzMyLDExXTsgYnJlYWs7XG4gICAgICAgICAgY2FzZSA5OiBzYXJSYXRpbyA9IFs4MCwzM107IGJyZWFrO1xuICAgICAgICAgIGNhc2UgMTA6IHNhclJhdGlvID0gWzE4LDExXTsgYnJlYWs7XG4gICAgICAgICAgY2FzZSAxMTogc2FyUmF0aW8gPSBbMTUsMTFdOyBicmVhaztcbiAgICAgICAgICBjYXNlIDEyOiBzYXJSYXRpbyA9IFs2NCwzM107IGJyZWFrO1xuICAgICAgICAgIGNhc2UgMTM6IHNhclJhdGlvID0gWzE2MCw5OV07IGJyZWFrO1xuICAgICAgICAgIGNhc2UgMTQ6IHNhclJhdGlvID0gWzQsM107IGJyZWFrO1xuICAgICAgICAgIGNhc2UgMTU6IHNhclJhdGlvID0gWzMsMl07IGJyZWFrO1xuICAgICAgICAgIGNhc2UgMTY6IHNhclJhdGlvID0gWzIsMV07IGJyZWFrO1xuICAgICAgICAgIGNhc2UgMjU1OiB7XG4gICAgICAgICAgICBzYXJSYXRpbyA9IFtyZWFkVUJ5dGUoKSA8PCA4IHwgcmVhZFVCeXRlKCksIHJlYWRVQnl0ZSgpIDw8IDggfCByZWFkVUJ5dGUoKV07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNhclJhdGlvKSB7XG4gICAgICAgICAgc2FyU2NhbGUgPSBzYXJSYXRpb1swXSAvIHNhclJhdGlvWzFdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB3aWR0aDogTWF0aC5jZWlsKCgoKHBpY1dpZHRoSW5NYnNNaW51czEgKyAxKSAqIDE2KSAtIGZyYW1lQ3JvcExlZnRPZmZzZXQgKiAyIC0gZnJhbWVDcm9wUmlnaHRPZmZzZXQgKiAyKSAqIHNhclNjYWxlKSxcbiAgICAgIGhlaWdodDogKCgyIC0gZnJhbWVNYnNPbmx5RmxhZykgKiAocGljSGVpZ2h0SW5NYXBVbml0c01pbnVzMSArIDEpICogMTYpIC0gKChmcmFtZU1ic09ubHlGbGFnPyAyIDogNCkgKiAoZnJhbWVDcm9wVG9wT2Zmc2V0ICsgZnJhbWVDcm9wQm90dG9tT2Zmc2V0KSlcbiAgICB9O1xuICB9XG5cbiAgcmVhZFNsaWNlVHlwZSgpIHtcbiAgICAvLyBza2lwIE5BTHUgdHlwZVxuICAgIHRoaXMucmVhZFVCeXRlKCk7XG4gICAgLy8gZGlzY2FyZCBmaXJzdF9tYl9pbl9zbGljZVxuICAgIHRoaXMucmVhZFVFRygpO1xuICAgIC8vIHJldHVybiBzbGljZV90eXBlXG4gICAgcmV0dXJuIHRoaXMucmVhZFVFRygpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEV4cEdvbG9tYjtcbiIsIi8qKlxuICogSUQzIHBhcnNlclxuICovXG5pbXBvcnQge2xvZ2dlcn0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcbi8vaW1wb3J0IEhleCBmcm9tICcuLi91dGlscy9oZXgnO1xuXG4gY2xhc3MgSUQzIHtcblxuICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgdGhpcy5faGFzVGltZVN0YW1wID0gZmFsc2U7XG4gICAgdmFyIG9mZnNldCA9IDAsIGJ5dGUxLGJ5dGUyLGJ5dGUzLGJ5dGU0LHRhZ1NpemUsZW5kUG9zLGhlYWRlcixsZW47XG4gICAgICBkbyB7XG4gICAgICAgIGhlYWRlciA9IHRoaXMucmVhZFVURihkYXRhLG9mZnNldCwzKTtcbiAgICAgICAgb2Zmc2V0Kz0zO1xuICAgICAgICAgIC8vIGZpcnN0IGNoZWNrIGZvciBJRDMgaGVhZGVyXG4gICAgICAgICAgaWYgKGhlYWRlciA9PT0gJ0lEMycpIHtcbiAgICAgICAgICAgICAgLy8gc2tpcCAyNCBiaXRzXG4gICAgICAgICAgICAgIG9mZnNldCArPSAzO1xuICAgICAgICAgICAgICAvLyByZXRyaWV2ZSB0YWcocykgbGVuZ3RoXG4gICAgICAgICAgICAgIGJ5dGUxID0gZGF0YVtvZmZzZXQrK10gJiAweDdmO1xuICAgICAgICAgICAgICBieXRlMiA9IGRhdGFbb2Zmc2V0KytdICYgMHg3ZjtcbiAgICAgICAgICAgICAgYnl0ZTMgPSBkYXRhW29mZnNldCsrXSAmIDB4N2Y7XG4gICAgICAgICAgICAgIGJ5dGU0ID0gZGF0YVtvZmZzZXQrK10gJiAweDdmO1xuICAgICAgICAgICAgICB0YWdTaXplID0gKGJ5dGUxIDw8IDIxKSArIChieXRlMiA8PCAxNCkgKyAoYnl0ZTMgPDwgNykgKyBieXRlNDtcbiAgICAgICAgICAgICAgZW5kUG9zID0gb2Zmc2V0ICsgdGFnU2l6ZTtcbiAgICAgICAgICAgICAgLy9sb2dnZXIubG9nKGBJRDMgdGFnIGZvdW5kLCBzaXplL2VuZDogJHt0YWdTaXplfS8ke2VuZFBvc31gKTtcblxuICAgICAgICAgICAgICAvLyByZWFkIElEMyB0YWdzXG4gICAgICAgICAgICAgIHRoaXMuX3BhcnNlSUQzRnJhbWVzKGRhdGEsIG9mZnNldCxlbmRQb3MpO1xuICAgICAgICAgICAgICBvZmZzZXQgPSBlbmRQb3M7XG4gICAgICAgICAgfSBlbHNlIGlmIChoZWFkZXIgPT09ICczREknKSB7XG4gICAgICAgICAgICAgIC8vIGh0dHA6Ly9pZDMub3JnL2lkM3YyLjQuMC1zdHJ1Y3R1cmUgY2hhcHRlciAzLjQuICAgSUQzdjIgZm9vdGVyXG4gICAgICAgICAgICAgIG9mZnNldCArPSA3O1xuICAgICAgICAgICAgICAgICAgbG9nZ2VyLmxvZyhgM0RJIGZvb3RlciBmb3VuZCwgZW5kOiAke29mZnNldH1gKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBvZmZzZXQgLT0gMztcbiAgICAgICAgICAgICAgbGVuID0gb2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgaWYgKGxlbikge1xuICAgICAgICAgICAgICAgICAgICAgIC8vbG9nZ2VyLmxvZyhgSUQzIGxlbjogJHtsZW59YCk7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmhhc1RpbWVTdGFtcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIud2FybignSUQzIHRhZyBmb3VuZCwgYnV0IG5vIHRpbWVzdGFtcCcpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9sZW5ndGggPSBsZW47XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGF5bG9hZCA9IGRhdGEuc3ViYXJyYXkoMCxsZW4pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgfSB3aGlsZSAodHJ1ZSk7XG4gIH1cblxuICByZWFkVVRGKGRhdGEsc3RhcnQsbGVuKSB7XG5cbiAgICB2YXIgcmVzdWx0ID0gJycsb2Zmc2V0ID0gc3RhcnQsIGVuZCA9IHN0YXJ0ICsgbGVuO1xuICAgIGRvIHtcbiAgICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGRhdGFbb2Zmc2V0KytdKTtcbiAgICB9IHdoaWxlKG9mZnNldCA8IGVuZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIF9wYXJzZUlEM0ZyYW1lcyhkYXRhLG9mZnNldCxlbmRQb3MpIHtcbiAgICB2YXIgdGFnSWQsdGFnTGVuLHRhZ1N0YXJ0LHRhZ0ZsYWdzLHRpbWVzdGFtcDtcbiAgICB3aGlsZShvZmZzZXQgKyA4IDw9IGVuZFBvcykge1xuICAgICAgdGFnSWQgPSB0aGlzLnJlYWRVVEYoZGF0YSxvZmZzZXQsNCk7XG4gICAgICBvZmZzZXQgKz00O1xuXG4gICAgICB0YWdMZW4gPSBkYXRhW29mZnNldCsrXSA8PCAyNCArXG4gICAgICAgICAgICAgICAgZGF0YVtvZmZzZXQrK10gPDwgMTYgK1xuICAgICAgICAgICAgICAgIGRhdGFbb2Zmc2V0KytdIDw8IDggK1xuICAgICAgICAgICAgICAgIGRhdGFbb2Zmc2V0KytdO1xuXG4gICAgICB0YWdGbGFncyA9IGRhdGFbb2Zmc2V0KytdIDw8IDggK1xuICAgICAgICAgICAgICAgICAgZGF0YVtvZmZzZXQrK107XG5cbiAgICAgIHRhZ1N0YXJ0ID0gb2Zmc2V0O1xuICAgICAgLy9sb2dnZXIubG9nKFwiSUQzIHRhZyBpZDpcIiArIHRhZ0lkKTtcbiAgICAgIHN3aXRjaCh0YWdJZCkge1xuICAgICAgICBjYXNlICdQUklWJzpcbiAgICAgICAgICAgIC8vbG9nZ2VyLmxvZygncGFyc2UgZnJhbWU6JyArIEhleC5oZXhEdW1wKGRhdGEuc3ViYXJyYXkob2Zmc2V0LGVuZFBvcykpKTtcbiAgICAgICAgICAgIC8vIG93bmVyIHNob3VsZCBiZSBcImNvbS5hcHBsZS5zdHJlYW1pbmcudHJhbnNwb3J0U3RyZWFtVGltZXN0YW1wXCJcbiAgICAgICAgICAgIGlmICh0aGlzLnJlYWRVVEYoZGF0YSxvZmZzZXQsNDQpID09PSAnY29tLmFwcGxlLnN0cmVhbWluZy50cmFuc3BvcnRTdHJlYW1UaW1lc3RhbXAnKSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0Kz00NDtcbiAgICAgICAgICAgICAgICAvLyBzbWVsbGluZyBldmVuIGJldHRlciAhIHdlIGZvdW5kIHRoZSByaWdodCBkZXNjcmlwdG9yXG4gICAgICAgICAgICAgICAgLy8gc2tpcCBudWxsIGNoYXJhY3RlciAoc3RyaW5nIGVuZCkgKyAzIGZpcnN0IGJ5dGVzXG4gICAgICAgICAgICAgICAgb2Zmc2V0Kz0gNDtcblxuICAgICAgICAgICAgICAgIC8vIHRpbWVzdGFtcCBpcyAzMyBiaXQgZXhwcmVzc2VkIGFzIGEgYmlnLWVuZGlhbiBlaWdodC1vY3RldCBudW1iZXIsIHdpdGggdGhlIHVwcGVyIDMxIGJpdHMgc2V0IHRvIHplcm8uXG4gICAgICAgICAgICAgICAgdmFyIHB0czMzQml0ICA9IGRhdGFbb2Zmc2V0KytdICYgMHgxO1xuICAgICAgICAgICAgICAgIHRoaXMuX2hhc1RpbWVTdGFtcCA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICB0aW1lc3RhbXAgPSAoKGRhdGFbb2Zmc2V0KytdIDw8IDIzKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIChkYXRhW29mZnNldCsrXSA8PCAxNSkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZGF0YVtvZmZzZXQrK10gPDwgIDcpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVtvZmZzZXQrK10pIC80NTtcblxuICAgICAgICAgICAgICAgIGlmIChwdHMzM0JpdCkge1xuICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXAgICArPSA0NzcyMTg1OC44NDsgLy8gMl4zMiAvIDkwXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRpbWVzdGFtcCA9IE1hdGgucm91bmQodGltZXN0YW1wKTtcbiAgICAgICAgICAgICAgICBsb2dnZXIudHJhY2UoYElEMyB0aW1lc3RhbXAgZm91bmQ6ICR7dGltZXN0YW1wfWApO1xuICAgICAgICAgICAgICAgIHRoaXMuX3RpbWVTdGFtcCA9IHRpbWVzdGFtcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZ2V0IGhhc1RpbWVTdGFtcCgpIHtcbiAgICByZXR1cm4gdGhpcy5faGFzVGltZVN0YW1wO1xuICB9XG5cbiAgZ2V0IHRpbWVTdGFtcCgpIHtcbiAgICByZXR1cm4gdGhpcy5fdGltZVN0YW1wO1xuICB9XG5cbiAgZ2V0IGxlbmd0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5fbGVuZ3RoO1xuICB9XG5cbiAgZ2V0IHBheWxvYWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BheWxvYWQ7XG4gIH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBJRDM7XG5cbiIsIi8qKlxuICogaGlnaGx5IG9wdGltaXplZCBUUyBkZW11eGVyOlxuICogcGFyc2UgUEFULCBQTVRcbiAqIGV4dHJhY3QgUEVTIHBhY2tldCBmcm9tIGF1ZGlvIGFuZCB2aWRlbyBQSURzXG4gKiBleHRyYWN0IEFWQy9IMjY0IE5BTCB1bml0cyBhbmQgQUFDL0FEVFMgc2FtcGxlcyBmcm9tIFBFUyBwYWNrZXRcbiAqIHRyaWdnZXIgdGhlIHJlbXV4ZXIgdXBvbiBwYXJzaW5nIGNvbXBsZXRpb25cbiAqIGl0IGFsc28gdHJpZXMgdG8gd29ya2Fyb3VuZCBhcyBiZXN0IGFzIGl0IGNhbiBhdWRpbyBjb2RlYyBzd2l0Y2ggKEhFLUFBQyB0byBBQUMgYW5kIHZpY2UgdmVyc2EpLCB3aXRob3V0IGhhdmluZyB0byByZXN0YXJ0IHRoZSBNZWRpYVNvdXJjZS5cbiAqIGl0IGFsc28gY29udHJvbHMgdGhlIHJlbXV4aW5nIHByb2Nlc3MgOlxuICogdXBvbiBkaXNjb250aW51aXR5IG9yIGxldmVsIHN3aXRjaCBkZXRlY3Rpb24sIGl0IHdpbGwgYWxzbyBub3RpZmllcyB0aGUgcmVtdXhlciBzbyB0aGF0IGl0IGNhbiByZXNldCBpdHMgc3RhdGUuXG4qL1xuXG4gaW1wb3J0IEFEVFMgZnJvbSAnLi9hZHRzJztcbiBpbXBvcnQgRXZlbnQgZnJvbSAnLi4vZXZlbnRzJztcbiBpbXBvcnQgRXhwR29sb21iIGZyb20gJy4vZXhwLWdvbG9tYic7XG4vLyBpbXBvcnQgSGV4IGZyb20gJy4uL3V0aWxzL2hleCc7XG4gaW1wb3J0IHtsb2dnZXJ9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XG4gaW1wb3J0IHtFcnJvclR5cGVzLCBFcnJvckRldGFpbHN9IGZyb20gJy4uL2Vycm9ycyc7XG5cbiBjbGFzcyBUU0RlbXV4ZXIge1xuXG4gIGNvbnN0cnVjdG9yKG9ic2VydmVyLCBpZCwgcmVtdXhlckNsYXNzLCBjb25maWcsIHR5cGVTdXBwb3J0ZWQpIHtcbiAgICB0aGlzLm9ic2VydmVyID0gb2JzZXJ2ZXI7XG4gICAgdGhpcy5pZCA9IGlkO1xuICAgIHRoaXMucmVtdXhlckNsYXNzID0gcmVtdXhlckNsYXNzO1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgIHRoaXMudHlwZVN1cHBvcnRlZCA9IHR5cGVTdXBwb3J0ZWQ7XG4gICAgdGhpcy5sYXN0Q0MgPSAwO1xuICAgIHRoaXMucmVtdXhlciA9IG5ldyB0aGlzLnJlbXV4ZXJDbGFzcyhvYnNlcnZlciwgaWQsIGNvbmZpZywgdHlwZVN1cHBvcnRlZCk7XG4gIH1cblxuICBzdGF0aWMgcHJvYmUoZGF0YSkge1xuICAgIC8vIGEgVFMgZnJhZ21lbnQgc2hvdWxkIGNvbnRhaW4gYXQgbGVhc3QgMyBUUyBwYWNrZXRzLCBhIFBBVCwgYSBQTVQsIGFuZCBvbmUgUElELCBlYWNoIHN0YXJ0aW5nIHdpdGggMHg0N1xuICAgIGlmIChkYXRhLmxlbmd0aCA+PSAzKjE4OCAmJiBkYXRhWzBdID09PSAweDQ3ICYmIGRhdGFbMTg4XSA9PT0gMHg0NyAmJiBkYXRhWzIqMTg4XSA9PT0gMHg0Nykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBzd2l0Y2hMZXZlbCgpIHtcbiAgICB0aGlzLnBtdFBhcnNlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3BtdElkID0gLTE7XG4gICAgdGhpcy5fYXZjVHJhY2sgPSB7Y29udGFpbmVyIDogJ3ZpZGVvL21wMnQnLCB0eXBlOiAndmlkZW8nLCBpZCA6LTEsIHNlcXVlbmNlTnVtYmVyOiAwLCBzYW1wbGVzIDogW10sIGxlbiA6IDAsIGRyb3BwZWQgOiAwfTtcbiAgICB0aGlzLl9hdWRpb1RyYWNrID0ge2NvbnRhaW5lciA6ICd2aWRlby9tcDJ0JywgdHlwZTogJ2F1ZGlvJywgaWQgOi0xLCBzZXF1ZW5jZU51bWJlcjogMCwgc2FtcGxlcyA6IFtdLCBsZW4gOiAwLCBpc0FBQzogdHJ1ZX07XG4gICAgdGhpcy5faWQzVHJhY2sgPSB7dHlwZTogJ2lkMycsIGlkIDotMSwgc2VxdWVuY2VOdW1iZXI6IDAsIHNhbXBsZXMgOiBbXSwgbGVuIDogMH07XG4gICAgdGhpcy5fdHh0VHJhY2sgPSB7dHlwZTogJ3RleHQnLCBpZDogLTEsIHNlcXVlbmNlTnVtYmVyOiAwLCBzYW1wbGVzIDogW10sIGxlbiA6IDB9O1xuICAgIC8vIGZsdXNoIGFueSBwYXJ0aWFsIGNvbnRlbnRcbiAgICB0aGlzLmFhY092ZXJGbG93ID0gbnVsbDtcbiAgICB0aGlzLmFhY0xhc3RQVFMgPSBudWxsO1xuICAgIHRoaXMuYXZjU2FtcGxlID0gbnVsbDtcbiAgICB0aGlzLnJlbXV4ZXIuc3dpdGNoTGV2ZWwoKTtcbiAgfVxuXG4gIGluc2VydERpc2NvbnRpbnVpdHkoKSB7XG4gICAgdGhpcy5zd2l0Y2hMZXZlbCgpO1xuICAgIHRoaXMucmVtdXhlci5pbnNlcnREaXNjb250aW51aXR5KCk7XG4gIH1cblxuICAvLyBmZWVkIGluY29taW5nIGRhdGEgdG8gdGhlIGZyb250IG9mIHRoZSBwYXJzaW5nIHBpcGVsaW5lXG4gIHB1c2goZGF0YSwgYXVkaW9Db2RlYywgdmlkZW9Db2RlYywgdGltZU9mZnNldCwgY2MsIGxldmVsLCBzbiwgZHVyYXRpb24sYWNjdXJhdGVUaW1lT2Zmc2V0LGRlZmF1bHRJbml0UFRTKSB7XG4gICAgdmFyIHN0YXJ0LCBsZW4gPSBkYXRhLmxlbmd0aCwgc3R0LCBwaWQsIGF0Ziwgb2Zmc2V0LHBlcyxcbiAgICAgICAgY29kZWNzT25seSA9IHRoaXMucmVtdXhlci5wYXNzdGhyb3VnaCxcbiAgICAgICAgdW5rbm93blBJRHMgPSBmYWxzZTtcblxuICAgIHRoaXMuYXVkaW9Db2RlYyA9IGF1ZGlvQ29kZWM7XG4gICAgdGhpcy52aWRlb0NvZGVjID0gdmlkZW9Db2RlYztcbiAgICB0aGlzLl9kdXJhdGlvbiA9IGR1cmF0aW9uO1xuICAgIHRoaXMuY29udGlndW91cyA9IGZhbHNlO1xuICAgIHRoaXMuYWNjdXJhdGVUaW1lT2Zmc2V0ID0gYWNjdXJhdGVUaW1lT2Zmc2V0O1xuICAgIGlmIChjYyAhPT0gdGhpcy5sYXN0Q0MpIHtcbiAgICAgIGxvZ2dlci5sb2coJ2Rpc2NvbnRpbnVpdHkgZGV0ZWN0ZWQnKTtcbiAgICAgIHRoaXMuaW5zZXJ0RGlzY29udGludWl0eSgpO1xuICAgICAgdGhpcy5sYXN0Q0MgPSBjYztcbiAgICB9XG4gICAgaWYgKGxldmVsICE9PSB0aGlzLmxhc3RMZXZlbCkge1xuICAgICAgbG9nZ2VyLmxvZygnbGV2ZWwgc3dpdGNoIGRldGVjdGVkJyk7XG4gICAgICB0aGlzLnN3aXRjaExldmVsKCk7XG4gICAgICB0aGlzLmxhc3RMZXZlbCA9IGxldmVsO1xuICAgIH0gZWxzZSBpZiAoc24gPT09ICh0aGlzLmxhc3RTTisxKSkge1xuICAgICAgdGhpcy5jb250aWd1b3VzID0gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy5sYXN0U04gPSBzbjtcblxuICAgIHZhciBwbXRQYXJzZWQgPSB0aGlzLnBtdFBhcnNlZCxcbiAgICAgICAgYXZjVHJhY2sgPSB0aGlzLl9hdmNUcmFjayxcbiAgICAgICAgYXVkaW9UcmFjayA9IHRoaXMuX2F1ZGlvVHJhY2ssXG4gICAgICAgIGlkM1RyYWNrID0gdGhpcy5faWQzVHJhY2ssXG4gICAgICAgIGF2Y0lkID0gYXZjVHJhY2suaWQsXG4gICAgICAgIGF1ZGlvSWQgPSBhdWRpb1RyYWNrLmlkLFxuICAgICAgICBpZDNJZCA9IGlkM1RyYWNrLmlkLFxuICAgICAgICBwbXRJZCA9IHRoaXMuX3BtdElkLFxuICAgICAgICBhdmNEYXRhID0gYXZjVHJhY2sucGVzRGF0YSxcbiAgICAgICAgYXVkaW9EYXRhID0gYXVkaW9UcmFjay5wZXNEYXRhLFxuICAgICAgICBpZDNEYXRhID0gaWQzVHJhY2sucGVzRGF0YSxcbiAgICAgICAgcGFyc2VQQVQgPSB0aGlzLl9wYXJzZVBBVCxcbiAgICAgICAgcGFyc2VQTVQgPSB0aGlzLl9wYXJzZVBNVCxcbiAgICAgICAgcGFyc2VQRVMgPSB0aGlzLl9wYXJzZVBFUyxcbiAgICAgICAgcGFyc2VBVkNQRVMgPSB0aGlzLl9wYXJzZUFWQ1BFUy5iaW5kKHRoaXMpLFxuICAgICAgICBwYXJzZUFBQ1BFUyA9IHRoaXMuX3BhcnNlQUFDUEVTLmJpbmQodGhpcyksXG4gICAgICAgIHBhcnNlTVBFR1BFUyA9IHRoaXMuX3BhcnNlTVBFR1BFUy5iaW5kKHRoaXMpLFxuICAgICAgICBwYXJzZUlEM1BFUyAgPSB0aGlzLl9wYXJzZUlEM1BFUy5iaW5kKHRoaXMpO1xuXG4gICAgLy8gZG9uJ3QgcGFyc2UgbGFzdCBUUyBwYWNrZXQgaWYgaW5jb21wbGV0ZVxuICAgIGxlbiAtPSBsZW4gJSAxODg7XG4gICAgLy8gbG9vcCB0aHJvdWdoIFRTIHBhY2tldHNcbiAgICBmb3IgKHN0YXJ0ID0gMDsgc3RhcnQgPCBsZW47IHN0YXJ0ICs9IDE4OCkge1xuICAgICAgaWYgKGRhdGFbc3RhcnRdID09PSAweDQ3KSB7XG4gICAgICAgIHN0dCA9ICEhKGRhdGFbc3RhcnQgKyAxXSAmIDB4NDApO1xuICAgICAgICAvLyBwaWQgaXMgYSAxMy1iaXQgZmllbGQgc3RhcnRpbmcgYXQgdGhlIGxhc3QgYml0IG9mIFRTWzFdXG4gICAgICAgIHBpZCA9ICgoZGF0YVtzdGFydCArIDFdICYgMHgxZikgPDwgOCkgKyBkYXRhW3N0YXJ0ICsgMl07XG4gICAgICAgIGF0ZiA9IChkYXRhW3N0YXJ0ICsgM10gJiAweDMwKSA+PiA0O1xuICAgICAgICAvLyBpZiBhbiBhZGFwdGlvbiBmaWVsZCBpcyBwcmVzZW50LCBpdHMgbGVuZ3RoIGlzIHNwZWNpZmllZCBieSB0aGUgZmlmdGggYnl0ZSBvZiB0aGUgVFMgcGFja2V0IGhlYWRlci5cbiAgICAgICAgaWYgKGF0ZiA+IDEpIHtcbiAgICAgICAgICBvZmZzZXQgPSBzdGFydCArIDUgKyBkYXRhW3N0YXJ0ICsgNF07XG4gICAgICAgICAgLy8gY29udGludWUgaWYgdGhlcmUgaXMgb25seSBhZGFwdGF0aW9uIGZpZWxkXG4gICAgICAgICAgaWYgKG9mZnNldCA9PT0gKHN0YXJ0ICsgMTg4KSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9mZnNldCA9IHN0YXJ0ICsgNDtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2gocGlkKSB7XG4gICAgICAgICAgY2FzZSBhdmNJZDpcbiAgICAgICAgICAgIGlmIChzdHQpIHtcbiAgICAgICAgICAgICAgaWYgKGF2Y0RhdGEgJiYgKHBlcyA9IHBhcnNlUEVTKGF2Y0RhdGEpKSkge1xuICAgICAgICAgICAgICAgIHBhcnNlQVZDUEVTKHBlcyxmYWxzZSk7XG4gICAgICAgICAgICAgICAgaWYgKGNvZGVjc09ubHkpIHtcbiAgICAgICAgICAgICAgICAgIC8vIGlmIHdlIGhhdmUgdmlkZW8gY29kZWMgaW5mbyBBTkRcbiAgICAgICAgICAgICAgICAgIC8vIGlmIGF1ZGlvIFBJRCBpcyB1bmRlZmluZWQgT1IgaWYgd2UgaGF2ZSBhdWRpbyBjb2RlYyBpbmZvLFxuICAgICAgICAgICAgICAgICAgLy8gd2UgaGF2ZSBhbGwgY29kZWMgaW5mbyAhXG4gICAgICAgICAgICAgICAgICBpZiAoYXZjVHJhY2suY29kZWMgJiYgKGF1ZGlvSWQgPT09IC0xIHx8IGF1ZGlvVHJhY2suY29kZWMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVtdXgobGV2ZWwsc24sY2MsZGF0YSx0aW1lT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBhdmNEYXRhID0ge2RhdGE6IFtdLCBzaXplOiAwfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhdmNEYXRhKSB7XG4gICAgICAgICAgICAgIGF2Y0RhdGEuZGF0YS5wdXNoKGRhdGEuc3ViYXJyYXkob2Zmc2V0LCBzdGFydCArIDE4OCkpO1xuICAgICAgICAgICAgICBhdmNEYXRhLnNpemUgKz0gc3RhcnQgKyAxODggLSBvZmZzZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIGF1ZGlvSWQ6XG4gICAgICAgICAgICBpZiAoc3R0KSB7XG4gICAgICAgICAgICAgIGlmIChhdWRpb0RhdGEgJiYgKHBlcyA9IHBhcnNlUEVTKGF1ZGlvRGF0YSkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGF1ZGlvVHJhY2suaXNBQUMpIHtcbiAgICAgICAgICAgICAgICAgIHBhcnNlQUFDUEVTKHBlcyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHBhcnNlTVBFR1BFUyhwZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY29kZWNzT25seSkge1xuICAgICAgICAgICAgICAgICAgLy8gaGVyZSB3ZSBub3cgdGhhdCB3ZSBoYXZlIGF1ZGlvIGNvZGVjIGluZm9cbiAgICAgICAgICAgICAgICAgIC8vIGlmIHZpZGVvIFBJRCBpcyB1bmRlZmluZWQgT1IgaWYgd2UgaGF2ZSB2aWRlbyBjb2RlYyBpbmZvLFxuICAgICAgICAgICAgICAgICAgLy8gd2UgaGF2ZSBhbGwgY29kZWMgaW5mb3MgIVxuICAgICAgICAgICAgICAgICAgaWYgKGF1ZGlvVHJhY2suY29kZWMgJiYgKGF2Y0lkID09PSAtMSB8fCBhdmNUcmFjay5jb2RlYykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW11eChsZXZlbCxzbixjYyxkYXRhLHRpbWVPZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGF1ZGlvRGF0YSA9IHtkYXRhOiBbXSwgc2l6ZTogMH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYXVkaW9EYXRhKSB7XG4gICAgICAgICAgICAgIGF1ZGlvRGF0YS5kYXRhLnB1c2goZGF0YS5zdWJhcnJheShvZmZzZXQsIHN0YXJ0ICsgMTg4KSk7XG4gICAgICAgICAgICAgIGF1ZGlvRGF0YS5zaXplICs9IHN0YXJ0ICsgMTg4IC0gb2Zmc2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBpZDNJZDpcbiAgICAgICAgICAgIGlmIChzdHQpIHtcbiAgICAgICAgICAgICAgaWYgKGlkM0RhdGEgJiYgKHBlcyA9IHBhcnNlUEVTKGlkM0RhdGEpKSkge1xuICAgICAgICAgICAgICAgIHBhcnNlSUQzUEVTKHBlcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWQzRGF0YSA9IHtkYXRhOiBbXSwgc2l6ZTogMH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaWQzRGF0YSkge1xuICAgICAgICAgICAgICBpZDNEYXRhLmRhdGEucHVzaChkYXRhLnN1YmFycmF5KG9mZnNldCwgc3RhcnQgKyAxODgpKTtcbiAgICAgICAgICAgICAgaWQzRGF0YS5zaXplICs9IHN0YXJ0ICsgMTg4IC0gb2Zmc2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgaWYgKHN0dCkge1xuICAgICAgICAgICAgICBvZmZzZXQgKz0gZGF0YVtvZmZzZXRdICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBtdElkID0gdGhpcy5fcG10SWQgPSBwYXJzZVBBVChkYXRhLCBvZmZzZXQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBwbXRJZDpcbiAgICAgICAgICAgIGlmIChzdHQpIHtcbiAgICAgICAgICAgICAgb2Zmc2V0ICs9IGRhdGFbb2Zmc2V0XSArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcGFyc2VkUElEcyA9IHBhcnNlUE1UKGRhdGEsIG9mZnNldCwgdGhpcy50eXBlU3VwcG9ydGVkLm1wZWcgPT09IHRydWUgfHwgdGhpcy50eXBlU3VwcG9ydGVkLm1wMyA9PT0gdHJ1ZSk7XG5cbiAgICAgICAgICAgIC8vIG9ubHkgdXBkYXRlIHRyYWNrIGlkIGlmIHRyYWNrIFBJRCBmb3VuZCB3aGlsZSBwYXJzaW5nIFBNVFxuICAgICAgICAgICAgLy8gdGhpcyBpcyB0byBhdm9pZCByZXNldHRpbmcgdGhlIFBJRCB0byAtMSBpbiBjYXNlXG4gICAgICAgICAgICAvLyB0cmFjayBQSUQgdHJhbnNpZW50bHkgZGlzYXBwZWFycyBmcm9tIHRoZSBzdHJlYW1cbiAgICAgICAgICAgIC8vIHRoaXMgY291bGQgaGFwcGVuIGluIGNhc2Ugb2YgdHJhbnNpZW50IG1pc3NpbmcgYXVkaW8gc2FtcGxlcyBmb3IgZXhhbXBsZVxuICAgICAgICAgICAgYXZjSWQgPSBwYXJzZWRQSURzLmF2YztcbiAgICAgICAgICAgIGlmIChhdmNJZCA+IDApIHtcbiAgICAgICAgICAgICAgYXZjVHJhY2suaWQgPSBhdmNJZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF1ZGlvSWQgPSBwYXJzZWRQSURzLmF1ZGlvO1xuICAgICAgICAgICAgaWYgKGF1ZGlvSWQgPiAwKSB7XG4gICAgICAgICAgICAgIGF1ZGlvVHJhY2suaWQgPSBhdWRpb0lkO1xuICAgICAgICAgICAgICBhdWRpb1RyYWNrLmlzQUFDID0gcGFyc2VkUElEcy5pc0FBQztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlkM0lkID0gcGFyc2VkUElEcy5pZDM7XG4gICAgICAgICAgICBpZiAoaWQzSWQgPiAwKSB7XG4gICAgICAgICAgICAgIGlkM1RyYWNrLmlkID0gaWQzSWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodW5rbm93blBJRHMgJiYgIXBtdFBhcnNlZCkge1xuICAgICAgICAgICAgICBsb2dnZXIubG9nKCdyZXBhcnNlIGZyb20gYmVnaW5uaW5nJyk7XG4gICAgICAgICAgICAgIHVua25vd25QSURzID0gZmFsc2U7XG4gICAgICAgICAgICAgIC8vIHdlIHNldCBpdCB0byAtMTg4LCB0aGUgKz0gMTg4IGluIHRoZSBmb3IgbG9vcCB3aWxsIHJlc2V0IHN0YXJ0IHRvIDBcbiAgICAgICAgICAgICAgc3RhcnQgPSAtMTg4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG10UGFyc2VkID0gdGhpcy5wbXRQYXJzZWQgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAxNzpcbiAgICAgICAgICBjYXNlIDB4MWZmZjpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB1bmtub3duUElEcyA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5vYnNlcnZlci50cmlnZ2VyKEV2ZW50LkVSUk9SLCB7dHlwZSA6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsIGlkIDogdGhpcy5pZCwgZGV0YWlsczogRXJyb3JEZXRhaWxzLkZSQUdfUEFSU0lOR19FUlJPUiwgZmF0YWw6IGZhbHNlLCByZWFzb246ICdUUyBwYWNrZXQgZGlkIG5vdCBzdGFydCB3aXRoIDB4NDcnfSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIHRyeSB0byBwYXJzZSBsYXN0IFBFUyBwYWNrZXRzXG4gICAgaWYgKGF2Y0RhdGEgJiYgKHBlcyA9IHBhcnNlUEVTKGF2Y0RhdGEpKSkge1xuICAgICAgcGFyc2VBVkNQRVMocGVzLHRydWUpO1xuICAgICAgYXZjVHJhY2sucGVzRGF0YSA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGVpdGhlciBhdmNEYXRhIG51bGwgb3IgUEVTIHRydW5jYXRlZCwga2VlcCBpdCBmb3IgbmV4dCBmcmFnIHBhcnNpbmdcbiAgICAgIGF2Y1RyYWNrLnBlc0RhdGEgPSBhdmNEYXRhO1xuICAgIH1cblxuICAgIGlmIChhdWRpb0RhdGEgJiYgKHBlcyA9IHBhcnNlUEVTKGF1ZGlvRGF0YSkpKSB7XG4gICAgICBpZiAoYXVkaW9UcmFjay5pc0FBQykge1xuICAgICAgICBwYXJzZUFBQ1BFUyhwZXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFyc2VNUEVHUEVTKHBlcyk7XG4gICAgICB9XG4gICAgICBhdWRpb1RyYWNrLnBlc0RhdGEgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoYXVkaW9EYXRhICYmIGF1ZGlvRGF0YS5zaXplKSB7XG4gICAgICAgIGxvZ2dlci5sb2coJ2xhc3QgQUFDIFBFUyBwYWNrZXQgdHJ1bmNhdGVkLG1pZ2h0IG92ZXJsYXAgYmV0d2VlbiBmcmFnbWVudHMnKTtcbiAgICAgIH1cbiAgICAgLy8gZWl0aGVyIGF1ZGlvRGF0YSBudWxsIG9yIFBFUyB0cnVuY2F0ZWQsIGtlZXAgaXQgZm9yIG5leHQgZnJhZyBwYXJzaW5nXG4gICAgICBhdWRpb1RyYWNrLnBlc0RhdGEgPSBhdWRpb0RhdGE7XG4gICAgfVxuXG4gICAgaWYgKGlkM0RhdGEgJiYgKHBlcyA9IHBhcnNlUEVTKGlkM0RhdGEpKSkge1xuICAgICAgcGFyc2VJRDNQRVMocGVzKTtcbiAgICAgIGlkM1RyYWNrLnBlc0RhdGEgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBlaXRoZXIgaWQzRGF0YSBudWxsIG9yIFBFUyB0cnVuY2F0ZWQsIGtlZXAgaXQgZm9yIG5leHQgZnJhZyBwYXJzaW5nXG4gICAgICBpZDNUcmFjay5wZXNEYXRhID0gaWQzRGF0YTtcbiAgICB9XG4gICAgdGhpcy5yZW11eChsZXZlbCxzbixjYyxudWxsLHRpbWVPZmZzZXQsZGVmYXVsdEluaXRQVFMpO1xuICB9XG5cbiAgcmVtdXgobGV2ZWwsIHNuLCBjYywgZGF0YSwgdGltZU9mZnNldCxkZWZhdWx0SW5pdFBUUykge1xuICAgIGxldCBhdmNUcmFjayA9IHRoaXMuX2F2Y1RyYWNrLCBzYW1wbGVzID0gYXZjVHJhY2suc2FtcGxlcywgbmJOYWx1ID0gMCwgbmFsdUxlbiA9IDA7XG5cbiAgICAvLyBjb21wdXRlIHRvdGFsL2F2YyBzYW1wbGUgbGVuZ3RoIGFuZCBuYiBvZiBOQUwgdW5pdHNcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNhbXBsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCBzYW1wbGUgPSBzYW1wbGVzW2ldLCB1bml0cyA9IHNhbXBsZS51bml0cy51bml0cywgbmJVbml0cyA9IHVuaXRzLmxlbmd0aCwgc2FtcGxlTGVuID0gMDtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbmJVbml0czsgaisrKSB7XG4gICAgICAgIHNhbXBsZUxlbiArPSB1bml0c1tqXS5kYXRhLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIG5hbHVMZW4gKz0gc2FtcGxlTGVuO1xuICAgICAgbmJOYWx1ICs9IG5iVW5pdHM7XG4gICAgICBzYW1wbGUubGVuZ3RoID0gc2FtcGxlTGVuO1xuICAgIH1cbiAgICBhdmNUcmFjay5sZW4gPSBuYWx1TGVuO1xuICAgIGF2Y1RyYWNrLm5iTmFsdSA9IG5iTmFsdTtcbiAgICB0aGlzLnJlbXV4ZXIucmVtdXgobGV2ZWwsIHNuLCBjYywgdGhpcy5fYXVkaW9UcmFjaywgdGhpcy5fYXZjVHJhY2ssIHRoaXMuX2lkM1RyYWNrLCB0aGlzLl90eHRUcmFjaywgdGltZU9mZnNldCwgdGhpcy5jb250aWd1b3VzLCB0aGlzLmFjY3VyYXRlVGltZU9mZnNldCwgZGVmYXVsdEluaXRQVFMsIGRhdGEpO1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnN3aXRjaExldmVsKCk7XG4gICAgdGhpcy5faW5pdFBUUyA9IHRoaXMuX2luaXREVFMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fZHVyYXRpb24gPSAwO1xuICB9XG5cbiAgX3BhcnNlUEFUKGRhdGEsIG9mZnNldCkge1xuICAgIC8vIHNraXAgdGhlIFBTSSBoZWFkZXIgYW5kIHBhcnNlIHRoZSBmaXJzdCBQTVQgZW50cnlcbiAgICByZXR1cm4gKGRhdGFbb2Zmc2V0ICsgMTBdICYgMHgxRikgPDwgOCB8IGRhdGFbb2Zmc2V0ICsgMTFdO1xuICAgIC8vbG9nZ2VyLmxvZygnUE1UIFBJRDonICArIHRoaXMuX3BtdElkKTtcbiAgfVxuXG4gIF9wYXJzZVBNVChkYXRhLCBvZmZzZXQsIG1wZWdTdXBwb3J0ZWQpIHtcbiAgICB2YXIgc2VjdGlvbkxlbmd0aCwgdGFibGVFbmQsIHByb2dyYW1JbmZvTGVuZ3RoLCBwaWQsIHJlc3VsdCA9IHsgYXVkaW8gOiAtMSwgYXZjIDogLTEsIGlkMyA6IC0xLCBpc0FBQyA6IHRydWV9O1xuICAgIHNlY3Rpb25MZW5ndGggPSAoZGF0YVtvZmZzZXQgKyAxXSAmIDB4MGYpIDw8IDggfCBkYXRhW29mZnNldCArIDJdO1xuICAgIHRhYmxlRW5kID0gb2Zmc2V0ICsgMyArIHNlY3Rpb25MZW5ndGggLSA0O1xuICAgIC8vIHRvIGRldGVybWluZSB3aGVyZSB0aGUgdGFibGUgaXMsIHdlIGhhdmUgdG8gZmlndXJlIG91dCBob3dcbiAgICAvLyBsb25nIHRoZSBwcm9ncmFtIGluZm8gZGVzY3JpcHRvcnMgYXJlXG4gICAgcHJvZ3JhbUluZm9MZW5ndGggPSAoZGF0YVtvZmZzZXQgKyAxMF0gJiAweDBmKSA8PCA4IHwgZGF0YVtvZmZzZXQgKyAxMV07XG4gICAgLy8gYWR2YW5jZSB0aGUgb2Zmc2V0IHRvIHRoZSBmaXJzdCBlbnRyeSBpbiB0aGUgbWFwcGluZyB0YWJsZVxuICAgIG9mZnNldCArPSAxMiArIHByb2dyYW1JbmZvTGVuZ3RoO1xuICAgIHdoaWxlIChvZmZzZXQgPCB0YWJsZUVuZCkge1xuICAgICAgcGlkID0gKGRhdGFbb2Zmc2V0ICsgMV0gJiAweDFGKSA8PCA4IHwgZGF0YVtvZmZzZXQgKyAyXTtcbiAgICAgIHN3aXRjaChkYXRhW29mZnNldF0pIHtcbiAgICAgICAgLy8gSVNPL0lFQyAxMzgxOC03IEFEVFMgQUFDIChNUEVHLTIgbG93ZXIgYml0LXJhdGUgYXVkaW8pXG4gICAgICAgIGNhc2UgMHgwZjpcbiAgICAgICAgICAvL2xvZ2dlci5sb2coJ0FBQyBQSUQ6JyAgKyBwaWQpO1xuICAgICAgICAgIGlmIChyZXN1bHQuYXVkaW8gPT09IC0xKSB7XG4gICAgICAgICAgICByZXN1bHQuYXVkaW8gPSBwaWQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBQYWNrZXRpemVkIG1ldGFkYXRhIChJRDMpXG4gICAgICAgIGNhc2UgMHgxNTpcbiAgICAgICAgICAvL2xvZ2dlci5sb2coJ0lEMyBQSUQ6JyAgKyBwaWQpO1xuICAgICAgICAgIGlmIChyZXN1bHQuaWQzID09PSAtMSkge1xuICAgICAgICAgICAgcmVzdWx0LmlkMyA9IHBpZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIElUVS1UIFJlYy4gSC4yNjQgYW5kIElTTy9JRUMgMTQ0OTYtMTAgKGxvd2VyIGJpdC1yYXRlIHZpZGVvKVxuICAgICAgICBjYXNlIDB4MWI6XG4gICAgICAgICAgLy9sb2dnZXIubG9nKCdBVkMgUElEOicgICsgcGlkKTtcbiAgICAgICAgICBpZiAocmVzdWx0LmF2YyA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJlc3VsdC5hdmMgPSBwaWQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBJU08vSUVDIDExMTcyLTMgKE1QRUctMSBhdWRpbylcbiAgICAgICAgLy8gb3IgSVNPL0lFQyAxMzgxOC0zIChNUEVHLTIgaGFsdmVkIHNhbXBsZSByYXRlIGF1ZGlvKVxuICAgICAgICBjYXNlIDB4MDM6XG4gICAgICAgIGNhc2UgMHgwNDpcbiAgICAgICAgICAvL2xvZ2dlci5sb2coJ01QRUcgUElEOicgICsgcGlkKTtcbiAgICAgICAgICBpZiAoIW1wZWdTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgIGxvZ2dlci5sb2coJ01QRUcgYXVkaW8gZm91bmQsIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBicm93c2VyIGZvciBub3cnKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHJlc3VsdC5hdWRpbyA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJlc3VsdC5hdWRpbyA9IHBpZDtcbiAgICAgICAgICAgIHJlc3VsdC5pc0FBQyA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAweDI0OlxuICAgICAgICAgIGxvZ2dlci53YXJuKCdIRVZDIHN0cmVhbSB0eXBlIGZvdW5kLCBub3Qgc3VwcG9ydGVkIGZvciBub3cnKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBsb2dnZXIubG9nKCd1bmtvd24gc3RyZWFtIHR5cGU6JyAgKyBkYXRhW29mZnNldF0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgLy8gbW92ZSB0byB0aGUgbmV4dCB0YWJsZSBlbnRyeVxuICAgICAgLy8gc2tpcCBwYXN0IHRoZSBlbGVtZW50YXJ5IHN0cmVhbSBkZXNjcmlwdG9ycywgaWYgcHJlc2VudFxuICAgICAgb2Zmc2V0ICs9ICgoZGF0YVtvZmZzZXQgKyAzXSAmIDB4MEYpIDw8IDggfCBkYXRhW29mZnNldCArIDRdKSArIDU7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBfcGFyc2VQRVMoc3RyZWFtKSB7XG4gICAgdmFyIGkgPSAwLCBmcmFnLCBwZXNGbGFncywgcGVzUHJlZml4LCBwZXNMZW4sIHBlc0hkckxlbiwgcGVzRGF0YSwgcGVzUHRzLCBwZXNEdHMsIHBheWxvYWRTdGFydE9mZnNldCwgZGF0YSA9IHN0cmVhbS5kYXRhO1xuICAgIC8vIHNhZmV0eSBjaGVja1xuICAgIGlmICghc3RyZWFtIHx8IHN0cmVhbS5zaXplID09PSAwKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyB3ZSBtaWdodCBuZWVkIHVwIHRvIDE5IGJ5dGVzIHRvIHJlYWQgUEVTIGhlYWRlclxuICAgIC8vIGlmIGZpcnN0IGNodW5rIG9mIGRhdGEgaXMgbGVzcyB0aGFuIDE5IGJ5dGVzLCBsZXQncyBtZXJnZSBpdCB3aXRoIGZvbGxvd2luZyBvbmVzIHVudGlsIHdlIGdldCAxOSBieXRlc1xuICAgIC8vIHVzdWFsbHkgb25seSBvbmUgbWVyZ2UgaXMgbmVlZGVkIChhbmQgdGhpcyBpcyByYXJlIC4uLilcbiAgICB3aGlsZShkYXRhWzBdLmxlbmd0aCA8IDE5ICYmIGRhdGEubGVuZ3RoID4gMSkge1xuICAgICAgbGV0IG5ld0RhdGEgPSBuZXcgVWludDhBcnJheShkYXRhWzBdLmxlbmd0aCArIGRhdGFbMV0ubGVuZ3RoKTtcbiAgICAgIG5ld0RhdGEuc2V0KGRhdGFbMF0pO1xuICAgICAgbmV3RGF0YS5zZXQoZGF0YVsxXSwgZGF0YVswXS5sZW5ndGgpO1xuICAgICAgZGF0YVswXSA9IG5ld0RhdGE7XG4gICAgICBkYXRhLnNwbGljZSgxLDEpO1xuICAgIH1cbiAgICAvL3JldHJpZXZlIFBUUy9EVFMgZnJvbSBmaXJzdCBmcmFnbWVudFxuICAgIGZyYWcgPSBkYXRhWzBdO1xuICAgIHBlc1ByZWZpeCA9IChmcmFnWzBdIDw8IDE2KSArIChmcmFnWzFdIDw8IDgpICsgZnJhZ1syXTtcbiAgICBpZiAocGVzUHJlZml4ID09PSAxKSB7XG4gICAgICBwZXNMZW4gPSAoZnJhZ1s0XSA8PCA4KSArIGZyYWdbNV07XG4gICAgICAvLyBpZiBQRVMgcGFyc2VkIGxlbmd0aCBpcyBub3QgemVybyBhbmQgZ3JlYXRlciB0aGFuIHRvdGFsIHJlY2VpdmVkIGxlbmd0aCwgc3RvcCBwYXJzaW5nLiBQRVMgbWlnaHQgYmUgdHJ1bmNhdGVkXG4gICAgICAvLyBtaW51cyA2IDogUEVTIGhlYWRlciBzaXplXG4gICAgICBpZiAocGVzTGVuICYmIHBlc0xlbiA+IHN0cmVhbS5zaXplIC0gNikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHBlc0ZsYWdzID0gZnJhZ1s3XTtcbiAgICAgIGlmIChwZXNGbGFncyAmIDB4QzApIHtcbiAgICAgICAgLyogUEVTIGhlYWRlciBkZXNjcmliZWQgaGVyZSA6IGh0dHA6Ly9kdmQuc291cmNlZm9yZ2UubmV0L2R2ZGluZm8vcGVzLWhkci5odG1sXG4gICAgICAgICAgICBhcyBQVFMgLyBEVFMgaXMgMzMgYml0IHdlIGNhbm5vdCB1c2UgYml0d2lzZSBvcGVyYXRvciBpbiBKUyxcbiAgICAgICAgICAgIGFzIEJpdHdpc2Ugb3BlcmF0b3JzIHRyZWF0IHRoZWlyIG9wZXJhbmRzIGFzIGEgc2VxdWVuY2Ugb2YgMzIgYml0cyAqL1xuICAgICAgICBwZXNQdHMgPSAoZnJhZ1s5XSAmIDB4MEUpICogNTM2ODcwOTEyICsvLyAxIDw8IDI5XG4gICAgICAgICAgKGZyYWdbMTBdICYgMHhGRikgKiA0MTk0MzA0ICsvLyAxIDw8IDIyXG4gICAgICAgICAgKGZyYWdbMTFdICYgMHhGRSkgKiAxNjM4NCArLy8gMSA8PCAxNFxuICAgICAgICAgIChmcmFnWzEyXSAmIDB4RkYpICogMTI4ICsvLyAxIDw8IDdcbiAgICAgICAgICAoZnJhZ1sxM10gJiAweEZFKSAvIDI7XG4gICAgICAgICAgLy8gY2hlY2sgaWYgZ3JlYXRlciB0aGFuIDJeMzIgLTFcbiAgICAgICAgICBpZiAocGVzUHRzID4gNDI5NDk2NzI5NSkge1xuICAgICAgICAgICAgLy8gZGVjcmVtZW50IDJeMzNcbiAgICAgICAgICAgIHBlc1B0cyAtPSA4NTg5OTM0NTkyO1xuICAgICAgICAgIH1cbiAgICAgICAgaWYgKHBlc0ZsYWdzICYgMHg0MCkge1xuICAgICAgICAgIHBlc0R0cyA9IChmcmFnWzE0XSAmIDB4MEUgKSAqIDUzNjg3MDkxMiArLy8gMSA8PCAyOVxuICAgICAgICAgICAgKGZyYWdbMTVdICYgMHhGRiApICogNDE5NDMwNCArLy8gMSA8PCAyMlxuICAgICAgICAgICAgKGZyYWdbMTZdICYgMHhGRSApICogMTYzODQgKy8vIDEgPDwgMTRcbiAgICAgICAgICAgIChmcmFnWzE3XSAmIDB4RkYgKSAqIDEyOCArLy8gMSA8PCA3XG4gICAgICAgICAgICAoZnJhZ1sxOF0gJiAweEZFICkgLyAyO1xuICAgICAgICAgIC8vIGNoZWNrIGlmIGdyZWF0ZXIgdGhhbiAyXjMyIC0xXG4gICAgICAgICAgaWYgKHBlc0R0cyA+IDQyOTQ5NjcyOTUpIHtcbiAgICAgICAgICAgIC8vIGRlY3JlbWVudCAyXjMzXG4gICAgICAgICAgICBwZXNEdHMgLT0gODU4OTkzNDU5MjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHBlc1B0cyAtIHBlc0R0cyA+IDYwKjkwMDAwKSB7XG4gICAgICAgICAgICBsb2dnZXIud2FybihgJHtNYXRoLnJvdW5kKChwZXNQdHMgLSBwZXNEdHMpLzkwMDAwKX1zIGRlbHRhIGJldHdlZW4gUFRTIGFuZCBEVFMsIGFsaWduIHRoZW1gKTtcbiAgICAgICAgICAgIHBlc1B0cyA9IHBlc0R0cztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGVzRHRzID0gcGVzUHRzO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBwZXNIZHJMZW4gPSBmcmFnWzhdO1xuICAgICAgLy8gOSBieXRlcyA6IDYgYnl0ZXMgZm9yIFBFUyBoZWFkZXIgKyAzIGJ5dGVzIGZvciBQRVMgZXh0ZW5zaW9uXG4gICAgICBwYXlsb2FkU3RhcnRPZmZzZXQgPSBwZXNIZHJMZW4gKyA5O1xuXG4gICAgICBzdHJlYW0uc2l6ZSAtPSBwYXlsb2FkU3RhcnRPZmZzZXQ7XG4gICAgICAvL3JlYXNzZW1ibGUgUEVTIHBhY2tldFxuICAgICAgcGVzRGF0YSA9IG5ldyBVaW50OEFycmF5KHN0cmVhbS5zaXplKTtcbiAgICAgIGZvciggbGV0IGogPSAwLCBkYXRhTGVuID0gZGF0YS5sZW5ndGg7IGogPCBkYXRhTGVuIDsgaisrKSB7XG4gICAgICAgIGZyYWcgPSBkYXRhW2pdO1xuICAgICAgICBsZXQgbGVuID0gZnJhZy5ieXRlTGVuZ3RoO1xuICAgICAgICBpZiAocGF5bG9hZFN0YXJ0T2Zmc2V0KSB7XG4gICAgICAgICAgaWYgKHBheWxvYWRTdGFydE9mZnNldCA+IGxlbikge1xuICAgICAgICAgICAgLy8gdHJpbSBmdWxsIGZyYWcgaWYgUEVTIGhlYWRlciBiaWdnZXIgdGhhbiBmcmFnXG4gICAgICAgICAgICBwYXlsb2FkU3RhcnRPZmZzZXQtPWxlbjtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyB0cmltIHBhcnRpYWwgZnJhZyBpZiBQRVMgaGVhZGVyIHNtYWxsZXIgdGhhbiBmcmFnXG4gICAgICAgICAgICBmcmFnID0gZnJhZy5zdWJhcnJheShwYXlsb2FkU3RhcnRPZmZzZXQpO1xuICAgICAgICAgICAgbGVuLT1wYXlsb2FkU3RhcnRPZmZzZXQ7XG4gICAgICAgICAgICBwYXlsb2FkU3RhcnRPZmZzZXQgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwZXNEYXRhLnNldChmcmFnLCBpKTtcbiAgICAgICAgaSs9bGVuO1xuICAgICAgfVxuICAgICAgaWYgKHBlc0xlbikge1xuICAgICAgICAvLyBwYXlsb2FkIHNpemUgOiByZW1vdmUgUEVTIGhlYWRlciArIFBFUyBleHRlbnNpb25cbiAgICAgICAgcGVzTGVuIC09IHBlc0hkckxlbiszO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtkYXRhOiBwZXNEYXRhLCBwdHM6IHBlc1B0cywgZHRzOiBwZXNEdHMsIGxlbjogcGVzTGVufTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgcHVzaEFjY2VzVW5pdChhdmNTYW1wbGUsYXZjVHJhY2spIHtcbiAgICBpZiAoYXZjU2FtcGxlLnVuaXRzLnVuaXRzLmxlbmd0aCAmJiBhdmNTYW1wbGUuZnJhbWUpIHtcbiAgICAgIC8vIG9ubHkgcHVzaCBBVkMgc2FtcGxlIGlmIHN0YXJ0aW5nIHdpdGggYSBrZXlmcmFtZSBpcyBub3QgbWFuZGF0b3J5IE9SXG4gICAgICAvLyAgICBpZiBrZXlmcmFtZSBhbHJlYWR5IGZvdW5kIGluIHRoaXMgZnJhZ21lbnQgT1JcbiAgICAgIC8vICAgICAgIGtleWZyYW1lIGZvdW5kIGluIGxhc3QgZnJhZ21lbnQgKHRyYWNrLnNwcykgQU5EXG4gICAgICAvLyAgICAgICAgICBzYW1wbGVzIGFscmVhZHkgYXBwZW5kZWQgKHdlIGFscmVhZHkgZm91bmQgYSBrZXlmcmFtZSBpbiB0aGlzIGZyYWdtZW50KSBPUiBmcmFnbWVudCBpcyBjb250aWd1b3VzXG4gICAgICBpZiAoIXRoaXMuY29uZmlnLmZvcmNlS2V5RnJhbWVPbkRpc2NvbnRpbnVpdHkgfHxcbiAgICAgICAgICBhdmNTYW1wbGUua2V5ID09PSB0cnVlIHx8XG4gICAgICAgICAgKGF2Y1RyYWNrLnNwcyAmJiAoYXZjVHJhY2suc2FtcGxlcy5sZW5ndGggfHwgdGhpcy5jb250aWd1b3VzKSkpIHtcbiAgICAgICAgYXZjVHJhY2suc2FtcGxlcy5wdXNoKGF2Y1NhbXBsZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBkcm9wcGVkIHNhbXBsZXMsIHRyYWNrIGl0XG4gICAgICAgIGF2Y1RyYWNrLmRyb3BwZWQrKztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYoYXZjU2FtcGxlLmRlYnVnLmxlbmd0aCkge1xuICAgICAgbG9nZ2VyLmxvZyhhdmNTYW1wbGUucHRzICsgJy8nICsgYXZjU2FtcGxlLmR0cyArICc6JyArIGF2Y1NhbXBsZS5kZWJ1ZyArICcsJyArIGF2Y1NhbXBsZS51bml0cy5sZW5ndGgpO1xuICAgIH1cbiAgfVxuXG4gIF9wYXJzZUFWQ1BFUyhwZXMsbGFzdCkge1xuICAgIC8vbG9nZ2VyLmxvZygncGFyc2UgbmV3IFBFUycpO1xuICAgIHZhciB0cmFjayA9IHRoaXMuX2F2Y1RyYWNrLFxuICAgICAgICB1bml0cyA9IHRoaXMuX3BhcnNlQVZDTkFMdShwZXMuZGF0YSksXG4gICAgICAgIGRlYnVnID0gZmFsc2UsXG4gICAgICAgIGV4cEdvbG9tYkRlY29kZXIsXG4gICAgICAgIGF2Y1NhbXBsZSA9IHRoaXMuYXZjU2FtcGxlLFxuICAgICAgICBwdXNoLFxuICAgICAgICBpO1xuICAgIC8vZnJlZSBwZXMuZGF0YSB0byBzYXZlIHVwIHNvbWUgbWVtb3J5XG4gICAgcGVzLmRhdGEgPSBudWxsO1xuXG4gICAgdW5pdHMuZm9yRWFjaCh1bml0ID0+IHtcbiAgICAgIHN3aXRjaCh1bml0LnR5cGUpIHtcbiAgICAgICAgLy9ORFJcbiAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgcHVzaCA9IHRydWU7XG4gICAgICAgICAgIGlmKGRlYnVnICYmIGF2Y1NhbXBsZSkge1xuICAgICAgICAgICAgYXZjU2FtcGxlLmRlYnVnICs9ICdORFIgJztcbiAgICAgICAgICAgfVxuICAgICAgICAgICBhdmNTYW1wbGUuZnJhbWUgPSB0cnVlO1xuICAgICAgICAgICAvLyByZXRyaWV2ZSBzbGljZSB0eXBlIGJ5IHBhcnNpbmcgYmVnaW5uaW5nIG9mIE5BTCB1bml0IChmb2xsb3cgSDI2NCBzcGVjLCBzbGljZV9oZWFkZXIgZGVmaW5pdGlvbikgdG8gZGV0ZWN0IGtleWZyYW1lIGVtYmVkZGVkIGluIE5EUlxuICAgICAgICAgICBsZXQgZGF0YSA9IHVuaXQuZGF0YTtcbiAgICAgICAgICAgaWYgKGRhdGEubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgIGxldCBzbGljZVR5cGUgPSBuZXcgRXhwR29sb21iKGRhdGEpLnJlYWRTbGljZVR5cGUoKTtcbiAgICAgICAgICAgICAvLyAyIDogSSBzbGljZSwgNCA6IFNJIHNsaWNlLCA3IDogSSBzbGljZSwgOTogU0kgc2xpY2VcbiAgICAgICAgICAgICAvLyBTSSBzbGljZSA6IEEgc2xpY2UgdGhhdCBpcyBjb2RlZCB1c2luZyBpbnRyYSBwcmVkaWN0aW9uIG9ubHkgYW5kIHVzaW5nIHF1YW50aXNhdGlvbiBvZiB0aGUgcHJlZGljdGlvbiBzYW1wbGVzLlxuICAgICAgICAgICAgIC8vIEFuIFNJIHNsaWNlIGNhbiBiZSBjb2RlZCBzdWNoIHRoYXQgaXRzIGRlY29kZWQgc2FtcGxlcyBjYW4gYmUgY29uc3RydWN0ZWQgaWRlbnRpY2FsbHkgdG8gYW4gU1Agc2xpY2UuXG4gICAgICAgICAgICAgLy8gSSBzbGljZTogQSBzbGljZSB0aGF0IGlzIG5vdCBhbiBTSSBzbGljZSB0aGF0IGlzIGRlY29kZWQgdXNpbmcgaW50cmEgcHJlZGljdGlvbiBvbmx5LlxuICAgICAgICAgICAgIC8vaWYgKHNsaWNlVHlwZSA9PT0gMiB8fCBzbGljZVR5cGUgPT09IDcpIHtcbiAgICAgICAgICAgICBpZiAoc2xpY2VUeXBlID09PSAyIHx8IHNsaWNlVHlwZSA9PT0gNCB8fCBzbGljZVR5cGUgPT09IDcgfHwgc2xpY2VUeXBlID09PSA5KSB7XG4gICAgICAgICAgICAgICAgYXZjU2FtcGxlLmtleSA9IHRydWU7XG4gICAgICAgICAgICAgfVxuICAgICAgICAgICB9XG4gICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvL0lEUlxuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgcHVzaCA9IHRydWU7XG4gICAgICAgICAgLy8gaGFuZGxlIFBFUyBub3Qgc3RhcnRpbmcgd2l0aCBBVURcbiAgICAgICAgICBpZiAoIWF2Y1NhbXBsZSkge1xuICAgICAgICAgICAgYXZjU2FtcGxlID0gdGhpcy5hdmNTYW1wbGUgPSB0aGlzLl9jcmVhdGVBVkNTYW1wbGUodHJ1ZSxwZXMucHRzLHBlcy5kdHMsJycpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZihkZWJ1Zykge1xuICAgICAgICAgICAgYXZjU2FtcGxlLmRlYnVnICs9ICdJRFIgJztcbiAgICAgICAgICB9XG4gICAgICAgICAgYXZjU2FtcGxlLmtleSA9IHRydWU7XG4gICAgICAgICAgYXZjU2FtcGxlLmZyYW1lID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgLy9TRUlcbiAgICAgICAgY2FzZSA2OlxuICAgICAgICAgIHB1c2ggPSB0cnVlO1xuICAgICAgICAgIGlmKGRlYnVnICYmIGF2Y1NhbXBsZSkge1xuICAgICAgICAgICAgYXZjU2FtcGxlLmRlYnVnICs9ICdTRUkgJztcbiAgICAgICAgICB9XG4gICAgICAgICAgZXhwR29sb21iRGVjb2RlciA9IG5ldyBFeHBHb2xvbWIodGhpcy5kaXNjYXJkRVBCKHVuaXQuZGF0YSkpO1xuXG4gICAgICAgICAgLy8gc2tpcCBmcmFtZVR5cGVcbiAgICAgICAgICBleHBHb2xvbWJEZWNvZGVyLnJlYWRVQnl0ZSgpO1xuXG4gICAgICAgICAgdmFyIHBheWxvYWRUeXBlID0gMDtcbiAgICAgICAgICB2YXIgcGF5bG9hZFNpemUgPSAwO1xuICAgICAgICAgIHZhciBlbmRPZkNhcHRpb25zID0gZmFsc2U7XG4gICAgICAgICAgdmFyIGIgPSAwO1xuXG4gICAgICAgICAgd2hpbGUgKCFlbmRPZkNhcHRpb25zICYmIGV4cEdvbG9tYkRlY29kZXIuYnl0ZXNBdmFpbGFibGUgPiAxKSB7XG4gICAgICAgICAgICBwYXlsb2FkVHlwZSA9IDA7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgYiA9IGV4cEdvbG9tYkRlY29kZXIucmVhZFVCeXRlKCk7XG4gICAgICAgICAgICAgICAgcGF5bG9hZFR5cGUgKz0gYjtcbiAgICAgICAgICAgIH0gd2hpbGUgKGIgPT09IDB4RkYpO1xuXG4gICAgICAgICAgICAvLyBQYXJzZSBwYXlsb2FkIHNpemUuXG4gICAgICAgICAgICBwYXlsb2FkU2l6ZSA9IDA7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgYiA9IGV4cEdvbG9tYkRlY29kZXIucmVhZFVCeXRlKCk7XG4gICAgICAgICAgICAgICAgcGF5bG9hZFNpemUgKz0gYjtcbiAgICAgICAgICAgIH0gd2hpbGUgKGIgPT09IDB4RkYpO1xuXG4gICAgICAgICAgICAvLyBUT0RPOiB0aGVyZSBjYW4gYmUgbW9yZSB0aGFuIG9uZSBwYXlsb2FkIGluIGFuIFNFSSBwYWNrZXQuLi5cbiAgICAgICAgICAgIC8vIFRPRE86IG5lZWQgdG8gcmVhZCB0eXBlIGFuZCBzaXplIGluIGEgd2hpbGUgbG9vcCB0byBnZXQgdGhlbSBhbGxcbiAgICAgICAgICAgIGlmIChwYXlsb2FkVHlwZSA9PT0gNCAmJiBleHBHb2xvbWJEZWNvZGVyLmJ5dGVzQXZhaWxhYmxlICE9PSAwKSB7XG5cbiAgICAgICAgICAgICAgZW5kT2ZDYXB0aW9ucyA9IHRydWU7XG5cbiAgICAgICAgICAgICAgdmFyIGNvdW50cnlDb2RlID0gZXhwR29sb21iRGVjb2Rlci5yZWFkVUJ5dGUoKTtcblxuICAgICAgICAgICAgICBpZiAoY291bnRyeUNvZGUgPT09IDE4MSkge1xuICAgICAgICAgICAgICAgIHZhciBwcm92aWRlckNvZGUgPSBleHBHb2xvbWJEZWNvZGVyLnJlYWRVU2hvcnQoKTtcblxuICAgICAgICAgICAgICAgIGlmIChwcm92aWRlckNvZGUgPT09IDQ5KSB7XG4gICAgICAgICAgICAgICAgICB2YXIgdXNlclN0cnVjdHVyZSA9IGV4cEdvbG9tYkRlY29kZXIucmVhZFVJbnQoKTtcblxuICAgICAgICAgICAgICAgICAgaWYgKHVzZXJTdHJ1Y3R1cmUgPT09IDB4NDc0MTM5MzQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHVzZXJEYXRhVHlwZSA9IGV4cEdvbG9tYkRlY29kZXIucmVhZFVCeXRlKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gUmF3IENFQS02MDggYnl0ZXMgd3JhcHBlZCBpbiBDRUEtNzA4IHBhY2tldFxuICAgICAgICAgICAgICAgICAgICBpZiAodXNlckRhdGFUeXBlID09PSAzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIGZpcnN0Qnl0ZSA9IGV4cEdvbG9tYkRlY29kZXIucmVhZFVCeXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIHNlY29uZEJ5dGUgPSBleHBHb2xvbWJEZWNvZGVyLnJlYWRVQnl0ZSgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgdmFyIHRvdGFsQ0NzID0gMzEgJiBmaXJzdEJ5dGU7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIGJ5dGVBcnJheSA9IFtmaXJzdEJ5dGUsIHNlY29uZEJ5dGVdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHRvdGFsQ0NzOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIDMgYnl0ZXMgcGVyIENDXG4gICAgICAgICAgICAgICAgICAgICAgICBieXRlQXJyYXkucHVzaChleHBHb2xvbWJEZWNvZGVyLnJlYWRVQnl0ZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ5dGVBcnJheS5wdXNoKGV4cEdvbG9tYkRlY29kZXIucmVhZFVCeXRlKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnl0ZUFycmF5LnB1c2goZXhwR29sb21iRGVjb2Rlci5yZWFkVUJ5dGUoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5zZXJ0U2FtcGxlSW5PcmRlcih0aGlzLl90eHRUcmFjay5zYW1wbGVzLCB7IHR5cGU6IDMsIHB0czogcGVzLnB0cywgYnl0ZXM6IGJ5dGVBcnJheSB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocGF5bG9hZFNpemUgPCBleHBHb2xvbWJEZWNvZGVyLmJ5dGVzQXZhaWxhYmxlKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpPHBheWxvYWRTaXplOyBpKyspXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBleHBHb2xvbWJEZWNvZGVyLnJlYWRVQnl0ZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvL1NQU1xuICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgcHVzaCA9IHRydWU7XG4gICAgICAgICAgaWYoZGVidWcgJiYgYXZjU2FtcGxlKSB7XG4gICAgICAgICAgICBhdmNTYW1wbGUuZGVidWcgKz0gJ1NQUyAnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZighdHJhY2suc3BzKSB7XG4gICAgICAgICAgICBleHBHb2xvbWJEZWNvZGVyID0gbmV3IEV4cEdvbG9tYih1bml0LmRhdGEpO1xuICAgICAgICAgICAgdmFyIGNvbmZpZyA9IGV4cEdvbG9tYkRlY29kZXIucmVhZFNQUygpO1xuICAgICAgICAgICAgdHJhY2sud2lkdGggPSBjb25maWcud2lkdGg7XG4gICAgICAgICAgICB0cmFjay5oZWlnaHQgPSBjb25maWcuaGVpZ2h0O1xuICAgICAgICAgICAgdHJhY2suc3BzID0gW3VuaXQuZGF0YV07XG4gICAgICAgICAgICB0cmFjay5kdXJhdGlvbiA9IHRoaXMuX2R1cmF0aW9uO1xuICAgICAgICAgICAgdmFyIGNvZGVjYXJyYXkgPSB1bml0LmRhdGEuc3ViYXJyYXkoMSwgNCk7XG4gICAgICAgICAgICB2YXIgY29kZWNzdHJpbmcgPSAnYXZjMS4nO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IDM7IGkrKykge1xuICAgICAgICAgICAgICB2YXIgaCA9IGNvZGVjYXJyYXlbaV0udG9TdHJpbmcoMTYpO1xuICAgICAgICAgICAgICBpZiAoaC5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICAgICAgaCA9ICcwJyArIGg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29kZWNzdHJpbmcgKz0gaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyYWNrLmNvZGVjID0gY29kZWNzdHJpbmc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvL1BQU1xuICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgcHVzaCA9IHRydWU7XG4gICAgICAgICAgaWYoZGVidWcgJiYgYXZjU2FtcGxlKSB7XG4gICAgICAgICAgICBhdmNTYW1wbGUuZGVidWcgKz0gJ1BQUyAnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXRyYWNrLnBwcykge1xuICAgICAgICAgICAgdHJhY2sucHBzID0gW3VuaXQuZGF0YV07XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBBVURcbiAgICAgICAgY2FzZSA5OlxuICAgICAgICAgIHB1c2ggPSBmYWxzZTtcbiAgICAgICAgICBpZiAoYXZjU2FtcGxlKSB7XG4gICAgICAgICAgICB0aGlzLnB1c2hBY2Nlc1VuaXQoYXZjU2FtcGxlLHRyYWNrKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYXZjU2FtcGxlID0gdGhpcy5hdmNTYW1wbGUgPSB0aGlzLl9jcmVhdGVBVkNTYW1wbGUoZmFsc2UscGVzLnB0cyxwZXMuZHRzLGRlYnVnID8gJ0FVRCAnOiAnJyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIEZpbGxlciBEYXRhXG4gICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgcHVzaCA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHB1c2ggPSBmYWxzZTtcbiAgICAgICAgICBpZiAoYXZjU2FtcGxlKSB7XG4gICAgICAgICAgICBhdmNTYW1wbGUuZGVidWcgKz0gJ3Vua25vd24gTkFMICcgKyB1bml0LnR5cGUgKyAnICc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYoYXZjU2FtcGxlICYmIHB1c2gpIHtcbiAgICAgICAgbGV0IHVuaXRzID0gYXZjU2FtcGxlLnVuaXRzO1xuICAgICAgICB1bml0cy51bml0cy5wdXNoKHVuaXQpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIC8vIGlmIGxhc3QgUEVTIHBhY2tldCwgcHVzaCBzYW1wbGVzXG4gICAgaWYgKGxhc3QgJiYgYXZjU2FtcGxlKSB7XG4gICAgICB0aGlzLnB1c2hBY2Nlc1VuaXQoYXZjU2FtcGxlLHRyYWNrKTtcbiAgICAgIHRoaXMuYXZjU2FtcGxlID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICBfY3JlYXRlQVZDU2FtcGxlKGtleSxwdHMsZHRzLGRlYnVnKSB7XG4gICAgcmV0dXJuIHsga2V5IDoga2V5LCBwdHMgOiBwdHMsIGR0cyA6IGR0cywgdW5pdHMgOiB7IHVuaXRzIDogW10sIGxlbmd0aCA6IDB9LCBkZWJ1ZyA6IGRlYnVnfTtcbiAgfVxuXG4gIF9pbnNlcnRTYW1wbGVJbk9yZGVyKGFyciwgZGF0YSkge1xuICAgIHZhciBsZW4gPSBhcnIubGVuZ3RoO1xuICAgIGlmIChsZW4gPiAwKSB7XG4gICAgICBpZiAoZGF0YS5wdHMgPj0gYXJyW2xlbi0xXS5wdHMpXG4gICAgICB7XG4gICAgICAgIGFyci5wdXNoKGRhdGEpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGZvciAodmFyIHBvcyA9IGxlbiAtIDE7IHBvcyA+PSAwOyBwb3MtLSkge1xuICAgICAgICAgIGlmIChkYXRhLnB0cyA8IGFycltwb3NdLnB0cykge1xuICAgICAgICAgICAgYXJyLnNwbGljZShwb3MsIDAsIGRhdGEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgYXJyLnB1c2goZGF0YSk7XG4gICAgfVxuICB9XG5cbiAgX2dldExhc3ROYWxVbml0KCkge1xuICAgIGxldCBhdmNTYW1wbGUgPSB0aGlzLmF2Y1NhbXBsZSwgbGFzdFVuaXQ7XG4gICAgLy8gdHJ5IHRvIGZhbGxiYWNrIHRvIHByZXZpb3VzIHNhbXBsZSBpZiBjdXJyZW50IG9uZSBpcyBlbXB0eVxuICAgIGlmICghYXZjU2FtcGxlIHx8IGF2Y1NhbXBsZS51bml0cy51bml0cy5sZW5ndGggPT09IDApIHtcbiAgICAgIGxldCB0cmFjayA9IHRoaXMuX2F2Y1RyYWNrLCBzYW1wbGVzID0gdHJhY2suc2FtcGxlcztcbiAgICAgIGF2Y1NhbXBsZSA9IHNhbXBsZXNbc2FtcGxlcy5sZW5ndGgtMV07XG4gICAgfVxuICAgIGlmIChhdmNTYW1wbGUpIHtcbiAgICAgIGxldCB1bml0cyA9IGF2Y1NhbXBsZS51bml0cy51bml0cztcbiAgICAgIGxhc3RVbml0ID0gdW5pdHNbdW5pdHMubGVuZ3RoIC0gMV07XG4gICAgfVxuICAgIHJldHVybiBsYXN0VW5pdDtcbiAgfVxuXG4gIF9wYXJzZUFWQ05BTHUoYXJyYXkpIHtcbiAgICB2YXIgaSA9IDAsIGxlbiA9IGFycmF5LmJ5dGVMZW5ndGgsIHZhbHVlLCBvdmVyZmxvdywgdHJhY2sgPSB0aGlzLl9hdmNUcmFjaywgc3RhdGUgPSB0cmFjay5uYWx1U3RhdGUgfHwgMCwgbGFzdFN0YXRlID0gc3RhdGU7XG4gICAgdmFyIHVuaXRzID0gW10sIHVuaXQsIHVuaXRUeXBlLCBsYXN0VW5pdFN0YXJ0ID0gLTEsIGxhc3RVbml0VHlwZTtcbiAgICAvL2xvZ2dlci5sb2coJ1BFUzonICsgSGV4LmhleER1bXAoYXJyYXkpKTtcblxuICAgIGlmIChzdGF0ZSA9PT0gLTEpIHtcbiAgICAvLyBzcGVjaWFsIHVzZSBjYXNlIHdoZXJlIHdlIGZvdW5kIDMgb3IgNC1ieXRlIHN0YXJ0IGNvZGVzIGV4YWN0bHkgYXQgdGhlIGVuZCBvZiBwcmV2aW91cyBQRVMgcGFja2V0XG4gICAgICBsYXN0VW5pdFN0YXJ0ID0gMDtcbiAgICAgIC8vIE5BTHUgdHlwZSBpcyB2YWx1ZSByZWFkIGZyb20gb2Zmc2V0IDBcbiAgICAgIGxhc3RVbml0VHlwZSA9IGFycmF5WzBdICYgMHgxZjtcbiAgICAgIHN0YXRlID0gMDtcbiAgICAgIGkgPSAxO1xuICAgIH1cblxuICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICB2YWx1ZSA9IGFycmF5W2krK107XG4gICAgICAvLyBvcHRpbWl6YXRpb24uIHN0YXRlIDAgYW5kIDEgYXJlIHRoZSBwcmVkb21pbmFudCBjYXNlLiBsZXQncyBoYW5kbGUgdGhlbSBvdXRzaWRlIG9mIHRoZSBzd2l0Y2gvY2FzZVxuICAgICAgaWYgKCFzdGF0ZSkge1xuICAgICAgICBzdGF0ZSA9IHZhbHVlID8gMCA6IDE7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXRlID09PSAxKSB7XG4gICAgICAgIHN0YXRlID0gdmFsdWUgPyAwIDogMjtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICAvLyBoZXJlIHdlIGhhdmUgc3RhdGUgZWl0aGVyIGVxdWFsIHRvIDIgb3IgM1xuICAgICAgaWYoIXZhbHVlKSB7XG4gICAgICAgIHN0YXRlID0gMztcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT09IDEpIHtcbiAgICAgICAgaWYgKGxhc3RVbml0U3RhcnQgPj0wKSB7XG4gICAgICAgICAgdW5pdCA9IHtkYXRhOiBhcnJheS5zdWJhcnJheShsYXN0VW5pdFN0YXJ0LCBpIC0gc3RhdGUgLSAxKSwgdHlwZTogbGFzdFVuaXRUeXBlfTtcbiAgICAgICAgICAvL2xvZ2dlci5sb2coJ3B1c2hpbmcgTkFMVSwgdHlwZS9zaXplOicgKyB1bml0LnR5cGUgKyAnLycgKyB1bml0LmRhdGEuYnl0ZUxlbmd0aCk7XG4gICAgICAgICAgdW5pdHMucHVzaCh1bml0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBsYXN0VW5pdFN0YXJ0IGlzIHVuZGVmaW5lZCA9PiB0aGlzIGlzIHRoZSBmaXJzdCBzdGFydCBjb2RlIGZvdW5kIGluIHRoaXMgUEVTIHBhY2tldFxuICAgICAgICAgIC8vIGZpcnN0IGNoZWNrIGlmIHN0YXJ0IGNvZGUgZGVsaW1pdGVyIGlzIG92ZXJsYXBwaW5nIGJldHdlZW4gMiBQRVMgcGFja2V0cyxcbiAgICAgICAgICAvLyBpZSBpdCBzdGFydGVkIGluIGxhc3QgcGFja2V0IChsYXN0U3RhdGUgbm90IHplcm8pXG4gICAgICAgICAgLy8gYW5kIGVuZGVkIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhpcyBQRVMgcGFja2V0IChpIDw9IDQgLSBsYXN0U3RhdGUpXG4gICAgICAgICAgbGV0IGxhc3RVbml0ID0gdGhpcy5fZ2V0TGFzdE5hbFVuaXQoKTtcbiAgICAgICAgICBpZiAobGFzdFVuaXQpIHtcbiAgICAgICAgICAgIGlmKGxhc3RTdGF0ZSAmJiAgKGkgPD0gNCAtIGxhc3RTdGF0ZSkpIHtcbiAgICAgICAgICAgICAgLy8gc3RhcnQgZGVsaW1pdGVyIG92ZXJsYXBwaW5nIGJldHdlZW4gUEVTIHBhY2tldHNcbiAgICAgICAgICAgICAgLy8gc3RyaXAgc3RhcnQgZGVsaW1pdGVyIGJ5dGVzIGZyb20gdGhlIGVuZCBvZiBsYXN0IE5BTCB1bml0XG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgbGFzdFVuaXQgaGFkIGEgc3RhdGUgZGlmZmVyZW50IGZyb20gemVyb1xuICAgICAgICAgICAgICBpZiAobGFzdFVuaXQuc3RhdGUpIHtcbiAgICAgICAgICAgICAgICAvLyBzdHJpcCBsYXN0IGJ5dGVzXG4gICAgICAgICAgICAgICAgbGFzdFVuaXQuZGF0YSA9IGxhc3RVbml0LmRhdGEuc3ViYXJyYXkoMCxsYXN0VW5pdC5kYXRhLmJ5dGVMZW5ndGggLSBsYXN0U3RhdGUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiBOQUwgdW5pdHMgYXJlIG5vdCBzdGFydGluZyByaWdodCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBQRVMgcGFja2V0LCBwdXNoIHByZWNlZGluZyBkYXRhIGludG8gcHJldmlvdXMgTkFMIHVuaXQuXG4gICAgICAgICAgICBvdmVyZmxvdyAgPSBpIC0gc3RhdGUgLSAxO1xuICAgICAgICAgICAgaWYgKG92ZXJmbG93ID4gMCkge1xuICAgICAgICAgICAgICAvL2xvZ2dlci5sb2coJ2ZpcnN0IE5BTFUgZm91bmQgd2l0aCBvdmVyZmxvdzonICsgb3ZlcmZsb3cpO1xuICAgICAgICAgICAgICBsZXQgdG1wID0gbmV3IFVpbnQ4QXJyYXkobGFzdFVuaXQuZGF0YS5ieXRlTGVuZ3RoICsgb3ZlcmZsb3cpO1xuICAgICAgICAgICAgICB0bXAuc2V0KGxhc3RVbml0LmRhdGEsIDApO1xuICAgICAgICAgICAgICB0bXAuc2V0KGFycmF5LnN1YmFycmF5KDAsIG92ZXJmbG93KSwgbGFzdFVuaXQuZGF0YS5ieXRlTGVuZ3RoKTtcbiAgICAgICAgICAgICAgbGFzdFVuaXQuZGF0YSA9IHRtcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gY2hlY2sgaWYgd2UgY2FuIHJlYWQgdW5pdCB0eXBlXG4gICAgICAgIGlmIChpIDwgbGVuKSB7XG4gICAgICAgICAgdW5pdFR5cGUgPSBhcnJheVtpXSAmIDB4MWY7XG4gICAgICAgICAgLy9sb2dnZXIubG9nKCdmaW5kIE5BTFUgQCBvZmZzZXQ6JyArIGkgKyAnLHR5cGU6JyArIHVuaXRUeXBlKTtcbiAgICAgICAgICBsYXN0VW5pdFN0YXJ0ID0gaTtcbiAgICAgICAgICBsYXN0VW5pdFR5cGUgPSB1bml0VHlwZTtcbiAgICAgICAgICBzdGF0ZSA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gbm90IGVub3VnaCBieXRlIHRvIHJlYWQgdW5pdCB0eXBlLiBsZXQncyByZWFkIGl0IG9uIG5leHQgUEVTIHBhcnNpbmdcbiAgICAgICAgICBzdGF0ZSA9IC0xO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZSA9IDA7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChsYXN0VW5pdFN0YXJ0ID49MCAmJiBzdGF0ZSA+PTApIHtcbiAgICAgIHVuaXQgPSB7ZGF0YTogYXJyYXkuc3ViYXJyYXkobGFzdFVuaXRTdGFydCwgbGVuKSwgdHlwZTogbGFzdFVuaXRUeXBlLCBzdGF0ZSA6IHN0YXRlfTtcbiAgICAgIHVuaXRzLnB1c2godW5pdCk7XG4gICAgICAvL2xvZ2dlci5sb2coJ3B1c2hpbmcgTkFMVSwgdHlwZS9zaXplL3N0YXRlOicgKyB1bml0LnR5cGUgKyAnLycgKyB1bml0LmRhdGEuYnl0ZUxlbmd0aCArICcvJyArIHN0YXRlKTtcbiAgICB9XG4gICAgLy8gbm8gTkFMdSBmb3VuZFxuICAgIGlmICh1bml0cy5sZW5ndGggPT09IDApIHtcbiAgICAgIC8vIGFwcGVuZCBwZXMuZGF0YSB0byBwcmV2aW91cyBOQUwgdW5pdFxuICAgICAgbGV0ICBsYXN0VW5pdCA9IHRoaXMuX2dldExhc3ROYWxVbml0KCk7XG4gICAgICBpZiAobGFzdFVuaXQpIHtcbiAgICAgICAgbGV0IHRtcCA9IG5ldyBVaW50OEFycmF5KGxhc3RVbml0LmRhdGEuYnl0ZUxlbmd0aCArIGFycmF5LmJ5dGVMZW5ndGgpO1xuICAgICAgICB0bXAuc2V0KGxhc3RVbml0LmRhdGEsIDApO1xuICAgICAgICB0bXAuc2V0KGFycmF5LCBsYXN0VW5pdC5kYXRhLmJ5dGVMZW5ndGgpO1xuICAgICAgICBsYXN0VW5pdC5kYXRhID0gdG1wO1xuICAgICAgfVxuICAgIH1cbiAgICB0cmFjay5uYWx1U3RhdGUgPSBzdGF0ZTtcbiAgICByZXR1cm4gdW5pdHM7XG4gIH1cblxuICAvKipcbiAgICogcmVtb3ZlIEVtdWxhdGlvbiBQcmV2ZW50aW9uIGJ5dGVzIGZyb20gYSBSQlNQXG4gICAqL1xuICBkaXNjYXJkRVBCKGRhdGEpIHtcbiAgICB2YXIgbGVuZ3RoID0gZGF0YS5ieXRlTGVuZ3RoLFxuICAgICAgICBFUEJQb3NpdGlvbnMgPSBbXSxcbiAgICAgICAgaSA9IDEsXG4gICAgICAgIG5ld0xlbmd0aCwgbmV3RGF0YTtcblxuICAgIC8vIEZpbmQgYWxsIGBFbXVsYXRpb24gUHJldmVudGlvbiBCeXRlc2BcbiAgICB3aGlsZSAoaSA8IGxlbmd0aCAtIDIpIHtcbiAgICAgIGlmIChkYXRhW2ldID09PSAwICYmXG4gICAgICAgICAgZGF0YVtpICsgMV0gPT09IDAgJiZcbiAgICAgICAgICBkYXRhW2kgKyAyXSA9PT0gMHgwMykge1xuICAgICAgICBFUEJQb3NpdGlvbnMucHVzaChpICsgMik7XG4gICAgICAgIGkgKz0gMjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGkrKztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiBubyBFbXVsYXRpb24gUHJldmVudGlvbiBCeXRlcyB3ZXJlIGZvdW5kIGp1c3QgcmV0dXJuIHRoZSBvcmlnaW5hbFxuICAgIC8vIGFycmF5XG4gICAgaWYgKEVQQlBvc2l0aW9ucy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cblxuICAgIC8vIENyZWF0ZSBhIG5ldyBhcnJheSB0byBob2xkIHRoZSBOQUwgdW5pdCBkYXRhXG4gICAgbmV3TGVuZ3RoID0gbGVuZ3RoIC0gRVBCUG9zaXRpb25zLmxlbmd0aDtcbiAgICBuZXdEYXRhID0gbmV3IFVpbnQ4QXJyYXkobmV3TGVuZ3RoKTtcbiAgICB2YXIgc291cmNlSW5kZXggPSAwO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IG5ld0xlbmd0aDsgc291cmNlSW5kZXgrKywgaSsrKSB7XG4gICAgICBpZiAoc291cmNlSW5kZXggPT09IEVQQlBvc2l0aW9uc1swXSkge1xuICAgICAgICAvLyBTa2lwIHRoaXMgYnl0ZVxuICAgICAgICBzb3VyY2VJbmRleCsrO1xuICAgICAgICAvLyBSZW1vdmUgdGhpcyBwb3NpdGlvbiBpbmRleFxuICAgICAgICBFUEJQb3NpdGlvbnMuc2hpZnQoKTtcbiAgICAgIH1cbiAgICAgIG5ld0RhdGFbaV0gPSBkYXRhW3NvdXJjZUluZGV4XTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld0RhdGE7XG4gIH1cblxuICBfcGFyc2VBQUNQRVMocGVzKSB7XG4gICAgdmFyIHRyYWNrID0gdGhpcy5fYXVkaW9UcmFjayxcbiAgICAgICAgZGF0YSA9IHBlcy5kYXRhLFxuICAgICAgICBwdHMgPSBwZXMucHRzLFxuICAgICAgICBzdGFydE9mZnNldCA9IDAsXG4gICAgICAgIGFhY092ZXJGbG93ID0gdGhpcy5hYWNPdmVyRmxvdyxcbiAgICAgICAgYWFjTGFzdFBUUyA9IHRoaXMuYWFjTGFzdFBUUyxcbiAgICAgICAgY29uZmlnLCBmcmFtZUxlbmd0aCwgZnJhbWVEdXJhdGlvbiwgZnJhbWVJbmRleCwgb2Zmc2V0LCBoZWFkZXJMZW5ndGgsIHN0YW1wLCBsZW4sIGFhY1NhbXBsZTtcbiAgICBpZiAoYWFjT3ZlckZsb3cpIHtcbiAgICAgIHZhciB0bXAgPSBuZXcgVWludDhBcnJheShhYWNPdmVyRmxvdy5ieXRlTGVuZ3RoICsgZGF0YS5ieXRlTGVuZ3RoKTtcbiAgICAgIHRtcC5zZXQoYWFjT3ZlckZsb3csIDApO1xuICAgICAgdG1wLnNldChkYXRhLCBhYWNPdmVyRmxvdy5ieXRlTGVuZ3RoKTtcbiAgICAgIC8vbG9nZ2VyLmxvZyhgQUFDOiBhcHBlbmQgb3ZlcmZsb3dpbmcgJHthYWNPdmVyRmxvdy5ieXRlTGVuZ3RofSBieXRlcyB0byBiZWdpbm5pbmcgb2YgbmV3IFBFU2ApO1xuICAgICAgZGF0YSA9IHRtcDtcbiAgICB9XG4gICAgLy8gbG9vayBmb3IgQURUUyBoZWFkZXIgKDB4RkZGeClcbiAgICBmb3IgKG9mZnNldCA9IHN0YXJ0T2Zmc2V0LCBsZW4gPSBkYXRhLmxlbmd0aDsgb2Zmc2V0IDwgbGVuIC0gMTsgb2Zmc2V0KyspIHtcbiAgICAgIGlmICgoZGF0YVtvZmZzZXRdID09PSAweGZmKSAmJiAoZGF0YVtvZmZzZXQrMV0gJiAweGYwKSA9PT0gMHhmMCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gaWYgQURUUyBoZWFkZXIgZG9lcyBub3Qgc3RhcnQgc3RyYWlnaHQgZnJvbSB0aGUgYmVnaW5uaW5nIG9mIHRoZSBQRVMgcGF5bG9hZCwgcmFpc2UgYW4gZXJyb3JcbiAgICBpZiAob2Zmc2V0KSB7XG4gICAgICB2YXIgcmVhc29uLCBmYXRhbDtcbiAgICAgIGlmIChvZmZzZXQgPCBsZW4gLSAxKSB7XG4gICAgICAgIHJlYXNvbiA9IGBBQUMgUEVTIGRpZCBub3Qgc3RhcnQgd2l0aCBBRFRTIGhlYWRlcixvZmZzZXQ6JHtvZmZzZXR9YDtcbiAgICAgICAgZmF0YWwgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlYXNvbiA9ICdubyBBRFRTIGhlYWRlciBmb3VuZCBpbiBBQUMgUEVTJztcbiAgICAgICAgZmF0YWwgPSB0cnVlO1xuICAgICAgfVxuICAgICAgbG9nZ2VyLndhcm4oYHBhcnNpbmcgZXJyb3I6JHtyZWFzb259YCk7XG4gICAgICB0aGlzLm9ic2VydmVyLnRyaWdnZXIoRXZlbnQuRVJST1IsIHt0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLCBpZCA6IHRoaXMuaWQsIGRldGFpbHM6IEVycm9yRGV0YWlscy5GUkFHX1BBUlNJTkdfRVJST1IsIGZhdGFsOiBmYXRhbCwgcmVhc29uOiByZWFzb259KTtcbiAgICAgIGlmIChmYXRhbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghdHJhY2suYXVkaW9zYW1wbGVyYXRlKSB7XG4gICAgICBjb25maWcgPSBBRFRTLmdldEF1ZGlvQ29uZmlnKHRoaXMub2JzZXJ2ZXIsZGF0YSwgb2Zmc2V0LCB0aGlzLmF1ZGlvQ29kZWMpO1xuICAgICAgdHJhY2suY29uZmlnID0gY29uZmlnLmNvbmZpZztcbiAgICAgIHRyYWNrLmF1ZGlvc2FtcGxlcmF0ZSA9IGNvbmZpZy5zYW1wbGVyYXRlO1xuICAgICAgdHJhY2suY2hhbm5lbENvdW50ID0gY29uZmlnLmNoYW5uZWxDb3VudDtcbiAgICAgIHRyYWNrLmNvZGVjID0gY29uZmlnLmNvZGVjO1xuICAgICAgdHJhY2suZHVyYXRpb24gPSB0aGlzLl9kdXJhdGlvbjtcbiAgICAgIGxvZ2dlci5sb2coYHBhcnNlZCBjb2RlYzoke3RyYWNrLmNvZGVjfSxyYXRlOiR7Y29uZmlnLnNhbXBsZXJhdGV9LG5iIGNoYW5uZWw6JHtjb25maWcuY2hhbm5lbENvdW50fWApO1xuICAgIH1cbiAgICBmcmFtZUluZGV4ID0gMDtcbiAgICBmcmFtZUR1cmF0aW9uID0gMTAyNCAqIDkwMDAwIC8gdHJhY2suYXVkaW9zYW1wbGVyYXRlO1xuXG4gICAgLy8gaWYgbGFzdCBBQUMgZnJhbWUgaXMgb3ZlcmZsb3dpbmcsIHdlIHNob3VsZCBlbnN1cmUgdGltZXN0YW1wcyBhcmUgY29udGlndW91czpcbiAgICAvLyBmaXJzdCBzYW1wbGUgUFRTIHNob3VsZCBiZSBlcXVhbCB0byBsYXN0IHNhbXBsZSBQVFMgKyBmcmFtZUR1cmF0aW9uXG4gICAgaWYoYWFjT3ZlckZsb3cgJiYgYWFjTGFzdFBUUykge1xuICAgICAgdmFyIG5ld1BUUyA9IGFhY0xhc3RQVFMrZnJhbWVEdXJhdGlvbjtcbiAgICAgIGlmKE1hdGguYWJzKG5ld1BUUy1wdHMpID4gMSkge1xuICAgICAgICBsb2dnZXIubG9nKGBBQUM6IGFsaWduIFBUUyBmb3Igb3ZlcmxhcHBpbmcgZnJhbWVzIGJ5ICR7TWF0aC5yb3VuZCgobmV3UFRTLXB0cykvOTApfWApO1xuICAgICAgICBwdHM9bmV3UFRTO1xuICAgICAgfVxuICAgIH1cblxuICAgIHdoaWxlICgob2Zmc2V0ICsgNSkgPCBsZW4pIHtcbiAgICAgIC8vIFRoZSBwcm90ZWN0aW9uIHNraXAgYml0IHRlbGxzIHVzIGlmIHdlIGhhdmUgMiBieXRlcyBvZiBDUkMgZGF0YSBhdCB0aGUgZW5kIG9mIHRoZSBBRFRTIGhlYWRlclxuICAgICAgaGVhZGVyTGVuZ3RoID0gKCEhKGRhdGFbb2Zmc2V0ICsgMV0gJiAweDAxKSA/IDcgOiA5KTtcbiAgICAgIC8vIHJldHJpZXZlIGZyYW1lIHNpemVcbiAgICAgIGZyYW1lTGVuZ3RoID0gKChkYXRhW29mZnNldCArIDNdICYgMHgwMykgPDwgMTEpIHxcbiAgICAgICAgICAgICAgICAgICAgIChkYXRhW29mZnNldCArIDRdIDw8IDMpIHxcbiAgICAgICAgICAgICAgICAgICAgKChkYXRhW29mZnNldCArIDVdICYgMHhFMCkgPj4+IDUpO1xuICAgICAgZnJhbWVMZW5ndGggIC09IGhlYWRlckxlbmd0aDtcbiAgICAgIC8vc3RhbXAgPSBwZXMucHRzO1xuXG4gICAgICBpZiAoKGZyYW1lTGVuZ3RoID4gMCkgJiYgKChvZmZzZXQgKyBoZWFkZXJMZW5ndGggKyBmcmFtZUxlbmd0aCkgPD0gbGVuKSkge1xuICAgICAgICBzdGFtcCA9IHB0cyArIGZyYW1lSW5kZXggKiBmcmFtZUR1cmF0aW9uO1xuICAgICAgICAvL2xvZ2dlci5sb2coYEFBQyBmcmFtZSwgb2Zmc2V0L2xlbmd0aC90b3RhbC9wdHM6JHtvZmZzZXQraGVhZGVyTGVuZ3RofS8ke2ZyYW1lTGVuZ3RofS8ke2RhdGEuYnl0ZUxlbmd0aH0vJHsoc3RhbXAvOTApLnRvRml4ZWQoMCl9YCk7XG4gICAgICAgIGFhY1NhbXBsZSA9IHt1bml0OiBkYXRhLnN1YmFycmF5KG9mZnNldCArIGhlYWRlckxlbmd0aCwgb2Zmc2V0ICsgaGVhZGVyTGVuZ3RoICsgZnJhbWVMZW5ndGgpLCBwdHM6IHN0YW1wLCBkdHM6IHN0YW1wfTtcbiAgICAgICAgdHJhY2suc2FtcGxlcy5wdXNoKGFhY1NhbXBsZSk7XG4gICAgICAgIHRyYWNrLmxlbiArPSBmcmFtZUxlbmd0aDtcbiAgICAgICAgb2Zmc2V0ICs9IGZyYW1lTGVuZ3RoICsgaGVhZGVyTGVuZ3RoO1xuICAgICAgICBmcmFtZUluZGV4Kys7XG4gICAgICAgIC8vIGxvb2sgZm9yIEFEVFMgaGVhZGVyICgweEZGRngpXG4gICAgICAgIGZvciAoIDsgb2Zmc2V0IDwgKGxlbiAtIDEpOyBvZmZzZXQrKykge1xuICAgICAgICAgIGlmICgoZGF0YVtvZmZzZXRdID09PSAweGZmKSAmJiAoKGRhdGFbb2Zmc2V0ICsgMV0gJiAweGYwKSA9PT0gMHhmMCkpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvZmZzZXQgPCBsZW4pIHtcbiAgICAgIGFhY092ZXJGbG93ID0gZGF0YS5zdWJhcnJheShvZmZzZXQsIGxlbik7XG4gICAgICAvL2xvZ2dlci5sb2coYEFBQzogb3ZlcmZsb3cgZGV0ZWN0ZWQ6JHtsZW4tb2Zmc2V0fWApO1xuICAgIH0gZWxzZSB7XG4gICAgICBhYWNPdmVyRmxvdyA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMuYWFjT3ZlckZsb3cgPSBhYWNPdmVyRmxvdztcbiAgICB0aGlzLmFhY0xhc3RQVFMgPSBzdGFtcDtcbiAgfVxuXG4gIF9wYXJzZU1QRUdQRVMocGVzKSB7XG4gICAgdmFyIGRhdGEgPSBwZXMuZGF0YTtcbiAgICB2YXIgcHRzID0gcGVzLnB0cztcbiAgICB2YXIgbGVuZ3RoID0gZGF0YS5sZW5ndGg7XG4gICAgdmFyIGZyYW1lSW5kZXggPSAwO1xuICAgIHZhciBvZmZzZXQgPSAwO1xuICAgIHZhciBwYXJzZWQ7XG5cbiAgICB3aGlsZSAob2Zmc2V0IDwgbGVuZ3RoICYmXG4gICAgICAgIChwYXJzZWQgPSB0aGlzLl9wYXJzZU1wZWcoZGF0YSwgb2Zmc2V0LCBsZW5ndGgsIGZyYW1lSW5kZXgrKywgcHRzKSkgPiAwKSB7XG4gICAgICAgIG9mZnNldCArPSBwYXJzZWQ7XG4gICAgfVxuICB9XG5cbiAgX29uTXBlZ0ZyYW1lKGRhdGEsIGJpdFJhdGUsIHNhbXBsZVJhdGUsIGNoYW5uZWxDb3VudCwgZnJhbWVJbmRleCwgcHRzKSB7XG4gICAgdmFyIGZyYW1lRHVyYXRpb24gPSAoMTE1MiAvIHNhbXBsZVJhdGUpICogMTAwMDtcbiAgICB2YXIgc3RhbXAgPSBwdHMgKyBmcmFtZUluZGV4ICogZnJhbWVEdXJhdGlvbjtcbiAgICB2YXIgdHJhY2sgPSB0aGlzLl9hdWRpb1RyYWNrO1xuXG4gICAgdHJhY2suY29uZmlnID0gW107XG4gICAgdHJhY2suY2hhbm5lbENvdW50ID0gY2hhbm5lbENvdW50O1xuICAgIHRyYWNrLmF1ZGlvc2FtcGxlcmF0ZSA9IHNhbXBsZVJhdGU7XG4gICAgdHJhY2suZHVyYXRpb24gPSB0aGlzLl9kdXJhdGlvbjtcbiAgICB0cmFjay5zYW1wbGVzLnB1c2goe3VuaXQ6IGRhdGEsIHB0czogc3RhbXAsIGR0czogc3RhbXB9KTtcbiAgICB0cmFjay5sZW4gKz0gZGF0YS5sZW5ndGg7XG4gIH1cblxuICBfb25NcGVnTm9pc2UoZGF0YSkge1xuICAgIGxvZ2dlci53YXJuKCdtcGVnIGF1ZGlvIGhhcyBub2lzZTogJyArIGRhdGEubGVuZ3RoICsgJyBieXRlcycpO1xuICB9XG5cbiAgX3BhcnNlTXBlZyhkYXRhLCBzdGFydCwgZW5kLCBmcmFtZUluZGV4LCBwdHMpIHtcbiAgICB2YXIgQml0cmF0ZXNNYXAgPSBbXG4gICAgICAgIDMyLCA2NCwgOTYsIDEyOCwgMTYwLCAxOTIsIDIyNCwgMjU2LCAyODgsIDMyMCwgMzUyLCAzODQsIDQxNiwgNDQ4LFxuICAgICAgICAzMiwgNDgsIDU2LCA2NCwgODAsIDk2LCAxMTIsIDEyOCwgMTYwLCAxOTIsIDIyNCwgMjU2LCAzMjAsIDM4NCxcbiAgICAgICAgMzIsIDQwLCA0OCwgNTYsIDY0LCA4MCwgOTYsIDExMiwgMTI4LCAxNjAsIDE5MiwgMjI0LCAyNTYsIDMyMCxcbiAgICAgICAgMzIsIDQ4LCA1NiwgNjQsIDgwLCA5NiwgMTEyLCAxMjgsIDE0NCwgMTYwLCAxNzYsIDE5MiwgMjI0LCAyNTYsXG4gICAgICAgIDgsIDE2LCAyNCwgMzIsIDQwLCA0OCwgNTYsIDY0LCA4MCwgOTYsIDExMiwgMTI4LCAxNDQsIDE2MF07XG4gICAgdmFyIFNhbXBsaW5nUmF0ZU1hcCA9IFs0NDEwMCwgNDgwMDAsIDMyMDAwLCAyMjA1MCwgMjQwMDAsIDE2MDAwLCAxMTAyNSwgMTIwMDAsIDgwMDBdO1xuXG4gICAgaWYgKHN0YXJ0ICsgMiA+IGVuZCkge1xuICAgICAgICByZXR1cm4gLTE7IC8vIHdlIG5lZWQgYXQgbGVhc3QgMiBieXRlcyB0byBkZXRlY3Qgc3luYyBwYXR0ZXJuXG4gICAgfVxuICAgIGlmIChkYXRhW3N0YXJ0XSA9PT0gMHhGRiB8fCAoZGF0YVtzdGFydCArIDFdICYgMHhFMCkgPT09IDB4RTApIHtcbiAgICAgICAgLy8gVXNpbmcgaHR0cDovL3d3dy5kYXRhdm95YWdlLmNvbS9tcGdzY3JpcHQvbXBlZ2hkci5odG0gYXMgYSByZWZlcmVuY2VcbiAgICAgICAgaWYgKHN0YXJ0ICsgMjQgPiBlbmQpIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaGVhZGVyQiA9IChkYXRhW3N0YXJ0ICsgMV0gPj4gMykgJiAzO1xuICAgICAgICB2YXIgaGVhZGVyQyA9IChkYXRhW3N0YXJ0ICsgMV0gPj4gMSkgJiAzO1xuICAgICAgICB2YXIgaGVhZGVyRSA9IChkYXRhW3N0YXJ0ICsgMl0gPj4gNCkgJiAxNTtcbiAgICAgICAgdmFyIGhlYWRlckYgPSAoZGF0YVtzdGFydCArIDJdID4+IDIpICYgMztcbiAgICAgICAgdmFyIGhlYWRlckcgPSAhIShkYXRhW3N0YXJ0ICsgMl0gJiAyKTtcbiAgICAgICAgaWYgKGhlYWRlckIgIT09IDEgJiYgaGVhZGVyRSAhPT0gMCAmJiBoZWFkZXJFICE9PSAxNSAmJiBoZWFkZXJGICE9PSAzKSB7XG4gICAgICAgICAgICB2YXIgY29sdW1uSW5CaXRyYXRlcyA9IGhlYWRlckIgPT09IDMgPyAoMyAtIGhlYWRlckMpIDogKGhlYWRlckMgPT09IDMgPyAzIDogNCk7XG4gICAgICAgICAgICB2YXIgYml0UmF0ZSA9IEJpdHJhdGVzTWFwW2NvbHVtbkluQml0cmF0ZXMgKiAxNCArIGhlYWRlckUgLSAxXSAqIDEwMDA7XG4gICAgICAgICAgICB2YXIgY29sdW1uSW5TYW1wbGVSYXRlcyA9IGhlYWRlckIgPT09IDMgPyAwIDogaGVhZGVyQiA9PT0gMiA/IDEgOiAyO1xuICAgICAgICAgICAgdmFyIHNhbXBsZVJhdGUgPSBTYW1wbGluZ1JhdGVNYXBbY29sdW1uSW5TYW1wbGVSYXRlcyAqIDMgKyBoZWFkZXJGXTtcbiAgICAgICAgICAgIHZhciBwYWRkaW5nID0gaGVhZGVyRyA/IDEgOiAwO1xuICAgICAgICAgICAgdmFyIGNoYW5uZWxDb3VudCA9IGRhdGFbc3RhcnQgKyAzXSA+PiA2ID09PSAzID8gMSA6IDI7IC8vIElmIGJpdHMgb2YgY2hhbm5lbCBtb2RlIGFyZSBgMTFgIHRoZW4gaXQgaXMgYSBzaW5nbGUgY2hhbm5lbCAoTW9ubylcbiAgICAgICAgICAgIHZhciBmcmFtZUxlbmd0aCA9IGhlYWRlckMgPT09IDMgP1xuICAgICAgICAgICAgICAgICgoaGVhZGVyQiA9PT0gMyA/IDEyIDogNikgKiBiaXRSYXRlIC8gc2FtcGxlUmF0ZSArIHBhZGRpbmcpIDw8IDIgOlxuICAgICAgICAgICAgICAgICgoaGVhZGVyQiA9PT0gMyA/IDE0NCA6IDcyKSAqIGJpdFJhdGUgLyBzYW1wbGVSYXRlICsgcGFkZGluZykgfCAwO1xuICAgICAgICAgICAgaWYgKHN0YXJ0ICsgZnJhbWVMZW5ndGggPiBlbmQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fb25NcGVnRnJhbWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9vbk1wZWdGcmFtZShkYXRhLnN1YmFycmF5KHN0YXJ0LCBzdGFydCArIGZyYW1lTGVuZ3RoKSwgYml0UmF0ZSwgc2FtcGxlUmF0ZSwgY2hhbm5lbENvdW50LCBmcmFtZUluZGV4LCBwdHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZyYW1lTGVuZ3RoO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIG5vaXNlIG9yIElEMywgdHJ5aW5nIHRvIHNraXBcbiAgICB2YXIgb2Zmc2V0ID0gc3RhcnQgKyAyO1xuICAgIHdoaWxlIChvZmZzZXQgPCBlbmQpIHtcbiAgICAgICAgaWYgKGRhdGFbb2Zmc2V0IC0gMV0gPT09IDB4RkYgJiYgKGRhdGFbb2Zmc2V0XSAmIDB4RTApID09PSAweEUwKSB7XG4gICAgICAgICAgICAvLyBzeW5jIHBhdHRlcm4gaXMgZm91bmRcbiAgICAgICAgICAgIGlmICh0aGlzLl9vbk1wZWdOb2lzZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX29uTXBlZ05vaXNlKGRhdGEuc3ViYXJyYXkoc3RhcnQsIG9mZnNldCAtIDEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvZmZzZXQgLSBzdGFydCAtIDE7XG4gICAgICAgIH1cbiAgICAgICAgb2Zmc2V0Kys7XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIF9wYXJzZUlEM1BFUyhwZXMpIHtcbiAgICB0aGlzLl9pZDNUcmFjay5zYW1wbGVzLnB1c2gocGVzKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBUU0RlbXV4ZXI7XG4iLCJleHBvcnQgY29uc3QgRXJyb3JUeXBlcyA9IHtcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBuZXR3b3JrIGVycm9yIChsb2FkaW5nIGVycm9yIC8gdGltZW91dCAuLi4pXG4gIE5FVFdPUktfRVJST1I6ICduZXR3b3JrRXJyb3InLFxuICAvLyBJZGVudGlmaWVyIGZvciBhIG1lZGlhIEVycm9yICh2aWRlby9wYXJzaW5nL21lZGlhc291cmNlIGVycm9yKVxuICBNRURJQV9FUlJPUjogJ21lZGlhRXJyb3InLFxuICAvLyBJZGVudGlmaWVyIGZvciBhIG11eCBFcnJvciAoZGVtdXhpbmcvcmVtdXhpbmcpXG4gIE1VWF9FUlJPUjogJ211eEVycm9yJyxcbiAgLy8gSWRlbnRpZmllciBmb3IgYWxsIG90aGVyIGVycm9yc1xuICBPVEhFUl9FUlJPUjogJ290aGVyRXJyb3InXG59O1xuXG5leHBvcnQgY29uc3QgRXJyb3JEZXRhaWxzID0ge1xuICAvLyBJZGVudGlmaWVyIGZvciBhIG1hbmlmZXN0IGxvYWQgZXJyb3IgLSBkYXRhOiB7IHVybCA6IGZhdWx0eSBVUkwsIHJlc3BvbnNlIDogeyBjb2RlOiBlcnJvciBjb2RlLCB0ZXh0OiBlcnJvciB0ZXh0IH19XG4gIE1BTklGRVNUX0xPQURfRVJST1I6ICdtYW5pZmVzdExvYWRFcnJvcicsXG4gIC8vIElkZW50aWZpZXIgZm9yIGEgbWFuaWZlc3QgbG9hZCB0aW1lb3V0IC0gZGF0YTogeyB1cmwgOiBmYXVsdHkgVVJMLCByZXNwb25zZSA6IHsgY29kZTogZXJyb3IgY29kZSwgdGV4dDogZXJyb3IgdGV4dCB9fVxuICBNQU5JRkVTVF9MT0FEX1RJTUVPVVQ6ICdtYW5pZmVzdExvYWRUaW1lT3V0JyxcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBtYW5pZmVzdCBwYXJzaW5nIGVycm9yIC0gZGF0YTogeyB1cmwgOiBmYXVsdHkgVVJMLCByZWFzb24gOiBlcnJvciByZWFzb259XG4gIE1BTklGRVNUX1BBUlNJTkdfRVJST1I6ICdtYW5pZmVzdFBhcnNpbmdFcnJvcicsXG4gIC8vIElkZW50aWZpZXIgZm9yIGEgbWFuaWZlc3Qgd2l0aCBvbmx5IGluY29tcGF0aWJsZSBjb2RlY3MgZXJyb3IgLSBkYXRhOiB7IHVybCA6IGZhdWx0eSBVUkwsIHJlYXNvbiA6IGVycm9yIHJlYXNvbn1cbiAgTUFOSUZFU1RfSU5DT01QQVRJQkxFX0NPREVDU19FUlJPUjogJ21hbmlmZXN0SW5jb21wYXRpYmxlQ29kZWNzRXJyb3InLFxuICAvL1xuICBNQU5JRkVTVF9FTVBUWV9FUlJPUjogJ21hbmlmZXN0RW1wdHlFcnJvcicsXG4gIC8vIElkZW50aWZpZXIgZm9yIGEgbGV2ZWwgbG9hZCBlcnJvciAtIGRhdGE6IHsgdXJsIDogZmF1bHR5IFVSTCwgcmVzcG9uc2UgOiB7IGNvZGU6IGVycm9yIGNvZGUsIHRleHQ6IGVycm9yIHRleHQgfX1cbiAgTEVWRUxfTE9BRF9FUlJPUjogJ2xldmVsTG9hZEVycm9yJyxcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBsZXZlbCBsb2FkIHRpbWVvdXQgLSBkYXRhOiB7IHVybCA6IGZhdWx0eSBVUkwsIHJlc3BvbnNlIDogeyBjb2RlOiBlcnJvciBjb2RlLCB0ZXh0OiBlcnJvciB0ZXh0IH19XG4gIExFVkVMX0xPQURfVElNRU9VVDogJ2xldmVsTG9hZFRpbWVPdXQnLFxuICAvLyBJZGVudGlmaWVyIGZvciBhIGxldmVsIHN3aXRjaCBlcnJvciAtIGRhdGE6IHsgbGV2ZWwgOiBmYXVsdHkgbGV2ZWwgSWQsIGV2ZW50IDogZXJyb3IgZGVzY3JpcHRpb259XG4gIExFVkVMX1NXSVRDSF9FUlJPUjogJ2xldmVsU3dpdGNoRXJyb3InLFxuICAvLyBJZGVudGlmaWVyIGZvciBhbiBhdWRpbyB0cmFjayBsb2FkIGVycm9yIC0gZGF0YTogeyB1cmwgOiBmYXVsdHkgVVJMLCByZXNwb25zZSA6IHsgY29kZTogZXJyb3IgY29kZSwgdGV4dDogZXJyb3IgdGV4dCB9fVxuICBBVURJT19UUkFDS19MT0FEX0VSUk9SOiAnYXVkaW9UcmFja0xvYWRFcnJvcicsXG4gIC8vIElkZW50aWZpZXIgZm9yIGFuIGF1ZGlvIHRyYWNrIGxvYWQgdGltZW91dCAtIGRhdGE6IHsgdXJsIDogZmF1bHR5IFVSTCwgcmVzcG9uc2UgOiB7IGNvZGU6IGVycm9yIGNvZGUsIHRleHQ6IGVycm9yIHRleHQgfX1cbiAgQVVESU9fVFJBQ0tfTE9BRF9USU1FT1VUOiAnYXVkaW9UcmFja0xvYWRUaW1lT3V0JyxcbiAgLy8gSWRlbnRpZmllciBmb3IgZnJhZ21lbnQgbG9hZCBlcnJvciAtIGRhdGE6IHsgZnJhZyA6IGZyYWdtZW50IG9iamVjdCwgcmVzcG9uc2UgOiB7IGNvZGU6IGVycm9yIGNvZGUsIHRleHQ6IGVycm9yIHRleHQgfX1cbiAgRlJBR19MT0FEX0VSUk9SOiAnZnJhZ0xvYWRFcnJvcicsXG4gIC8vIElkZW50aWZpZXIgZm9yIGZyYWdtZW50IGxvb3AgbG9hZGluZyBlcnJvciAtIGRhdGE6IHsgZnJhZyA6IGZyYWdtZW50IG9iamVjdH1cbiAgRlJBR19MT09QX0xPQURJTkdfRVJST1I6ICdmcmFnTG9vcExvYWRpbmdFcnJvcicsXG4gIC8vIElkZW50aWZpZXIgZm9yIGZyYWdtZW50IGxvYWQgdGltZW91dCBlcnJvciAtIGRhdGE6IHsgZnJhZyA6IGZyYWdtZW50IG9iamVjdH1cbiAgRlJBR19MT0FEX1RJTUVPVVQ6ICdmcmFnTG9hZFRpbWVPdXQnLFxuICAvLyBJZGVudGlmaWVyIGZvciBhIGZyYWdtZW50IGRlY3J5cHRpb24gZXJyb3IgZXZlbnQgLSBkYXRhOiBwYXJzaW5nIGVycm9yIGRlc2NyaXB0aW9uXG4gIEZSQUdfREVDUllQVF9FUlJPUjogJ2ZyYWdEZWNyeXB0RXJyb3InLFxuICAvLyBJZGVudGlmaWVyIGZvciBhIGZyYWdtZW50IHBhcnNpbmcgZXJyb3IgZXZlbnQgLSBkYXRhOiB7IGlkIDogZGVtdXhlciBJZCwgcmVhc29uIDogcGFyc2luZyBlcnJvciBkZXNjcmlwdGlvbiB9XG4gIC8vIHdpbGwgYmUgcmVuYW1lZCBERU1VWF9QQVJTSU5HX0VSUk9SIGFuZCBzd2l0Y2hlZCB0byBNVVhfRVJST1IgaW4gdGhlIG5leHQgbWFqb3IgcmVsZWFzZVxuICBGUkFHX1BBUlNJTkdfRVJST1I6ICdmcmFnUGFyc2luZ0Vycm9yJyxcbiAgLy8gSWRlbnRpZmllciBmb3IgYSByZW11eCBhbGxvYyBlcnJvciBldmVudCAtIGRhdGE6IHsgaWQgOiBkZW11eGVyIElkLCBieXRlcyA6IG5iIG9mIGJ5dGVzIG9uIHdoaWNoIGFsbG9jYXRpb24gZmFpbGVkICwgcmVhc29uIDogZXJyb3IgdGV4dCB9XG4gIFJFTVVYX0FMTE9DX0VSUk9SIDogJ3JlbXV4QWxsb2NFcnJvcicsXG4gIC8vIElkZW50aWZpZXIgZm9yIGRlY3J5cHQga2V5IGxvYWQgZXJyb3IgLSBkYXRhOiB7IGZyYWcgOiBmcmFnbWVudCBvYmplY3QsIHJlc3BvbnNlIDogeyBjb2RlOiBlcnJvciBjb2RlLCB0ZXh0OiBlcnJvciB0ZXh0IH19XG4gIEtFWV9MT0FEX0VSUk9SOiAna2V5TG9hZEVycm9yJyxcbiAgLy8gSWRlbnRpZmllciBmb3IgZGVjcnlwdCBrZXkgbG9hZCB0aW1lb3V0IGVycm9yIC0gZGF0YTogeyBmcmFnIDogZnJhZ21lbnQgb2JqZWN0fVxuICBLRVlfTE9BRF9USU1FT1VUOiAna2V5TG9hZFRpbWVPdXQnLFxuICAvLyBUcmlnZ2VyZWQgd2hlbiBhbiBleGNlcHRpb24gb2NjdXJzIHdoaWxlIGFkZGluZyBhIHNvdXJjZUJ1ZmZlciB0byBNZWRpYVNvdXJjZSAtIGRhdGEgOiB7ICBlcnIgOiBleGNlcHRpb24gLCBtaW1lVHlwZSA6IG1pbWVUeXBlIH1cbiAgQlVGRkVSX0FERF9DT0RFQ19FUlJPUjogJ2J1ZmZlckFkZENvZGVjRXJyb3InLFxuICAvLyBJZGVudGlmaWVyIGZvciBhIGJ1ZmZlciBhcHBlbmQgZXJyb3IgLSBkYXRhOiBhcHBlbmQgZXJyb3IgZGVzY3JpcHRpb25cbiAgQlVGRkVSX0FQUEVORF9FUlJPUjogJ2J1ZmZlckFwcGVuZEVycm9yJyxcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBidWZmZXIgYXBwZW5kaW5nIGVycm9yIGV2ZW50IC0gZGF0YTogYXBwZW5kaW5nIGVycm9yIGRlc2NyaXB0aW9uXG4gIEJVRkZFUl9BUFBFTkRJTkdfRVJST1I6ICdidWZmZXJBcHBlbmRpbmdFcnJvcicsXG4gIC8vIElkZW50aWZpZXIgZm9yIGEgYnVmZmVyIHN0YWxsZWQgZXJyb3IgZXZlbnRcbiAgQlVGRkVSX1NUQUxMRURfRVJST1I6ICdidWZmZXJTdGFsbGVkRXJyb3InLFxuICAvLyBJZGVudGlmaWVyIGZvciBhIGJ1ZmZlciBmdWxsIGV2ZW50XG4gIEJVRkZFUl9GVUxMX0VSUk9SOiAnYnVmZmVyRnVsbEVycm9yJyxcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBidWZmZXIgc2VlayBvdmVyIGhvbGUgZXZlbnRcbiAgQlVGRkVSX1NFRUtfT1ZFUl9IT0xFOiAnYnVmZmVyU2Vla092ZXJIb2xlJyxcbiAgLy8gSWRlbnRpZmllciBmb3IgYW4gaW50ZXJuYWwgZXhjZXB0aW9uIGhhcHBlbmluZyBpbnNpZGUgaGxzLmpzIHdoaWxlIGhhbmRsaW5nIGFuIGV2ZW50XG4gIElOVEVSTkFMX0VYQ0VQVElPTjogJ2ludGVybmFsRXhjZXB0aW9uJyxcbiAgLy8gTWFsZm9ybWVkIFdlYlZUVCBjb250ZW50c1xuICBXRUJWVFRfRVhDRVBUSU9OOiAnd2ViVlRURXhjZXB0aW9uJ1xufTtcbiIsIi8qXG4qXG4qIEFsbCBvYmplY3RzIGluIHRoZSBldmVudCBoYW5kbGluZyBjaGFpbiBzaG91bGQgaW5oZXJpdCBmcm9tIHRoaXMgY2xhc3NcbipcbiovXG5cbmltcG9ydCB7bG9nZ2VyfSBmcm9tICcuL3V0aWxzL2xvZ2dlcic7XG5pbXBvcnQge0Vycm9yVHlwZXMsIEVycm9yRGV0YWlsc30gZnJvbSAnLi9lcnJvcnMnO1xuaW1wb3J0IEV2ZW50IGZyb20gJy4vZXZlbnRzJztcblxuY2xhc3MgRXZlbnRIYW5kbGVyIHtcblxuICBjb25zdHJ1Y3RvcihobHMsIC4uLmV2ZW50cykge1xuICAgIHRoaXMuaGxzID0gaGxzO1xuICAgIHRoaXMub25FdmVudCA9IHRoaXMub25FdmVudC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuaGFuZGxlZEV2ZW50cyA9IGV2ZW50cztcbiAgICB0aGlzLnVzZUdlbmVyaWNIYW5kbGVyID0gdHJ1ZTtcblxuICAgIHRoaXMucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy51bnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gIH1cblxuICBpc0V2ZW50SGFuZGxlcigpIHtcbiAgICByZXR1cm4gdHlwZW9mIHRoaXMuaGFuZGxlZEV2ZW50cyA9PT0gJ29iamVjdCcgJiYgdGhpcy5oYW5kbGVkRXZlbnRzLmxlbmd0aCAmJiB0eXBlb2YgdGhpcy5vbkV2ZW50ID09PSAnZnVuY3Rpb24nO1xuICB9XG5cbiAgcmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgaWYgKHRoaXMuaXNFdmVudEhhbmRsZXIoKSkge1xuICAgICAgdGhpcy5oYW5kbGVkRXZlbnRzLmZvckVhY2goZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50ID09PSAnaGxzRXZlbnRHZW5lcmljJykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRm9yYmlkZGVuIGV2ZW50IG5hbWU6ICcgKyBldmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5obHMub24oZXZlbnQsIHRoaXMub25FdmVudCk7XG4gICAgICB9LmJpbmQodGhpcykpO1xuICAgIH1cbiAgfVxuXG4gIHVucmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgaWYgKHRoaXMuaXNFdmVudEhhbmRsZXIoKSkge1xuICAgICAgdGhpcy5oYW5kbGVkRXZlbnRzLmZvckVhY2goZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgdGhpcy5obHMub2ZmKGV2ZW50LCB0aGlzLm9uRXZlbnQpO1xuICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogYXJndW1lbnRzOiBldmVudCAoc3RyaW5nKSwgZGF0YSAoYW55KVxuICAgKi9cbiAgb25FdmVudChldmVudCwgZGF0YSkge1xuICAgIHRoaXMub25FdmVudEdlbmVyaWMoZXZlbnQsIGRhdGEpO1xuICB9XG5cbiAgb25FdmVudEdlbmVyaWMoZXZlbnQsIGRhdGEpIHtcbiAgICB2YXIgZXZlbnRUb0Z1bmN0aW9uID0gZnVuY3Rpb24oZXZlbnQsIGRhdGEpIHtcbiAgICAgIHZhciBmdW5jTmFtZSA9ICdvbicgKyBldmVudC5yZXBsYWNlKCdobHMnLCAnJyk7XG4gICAgICBpZiAodHlwZW9mIHRoaXNbZnVuY05hbWVdICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRXZlbnQgJHtldmVudH0gaGFzIG5vIGdlbmVyaWMgaGFuZGxlciBpbiB0aGlzICR7dGhpcy5jb25zdHJ1Y3Rvci5uYW1lfSBjbGFzcyAodHJpZWQgJHtmdW5jTmFtZX0pYCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpc1tmdW5jTmFtZV0uYmluZCh0aGlzLCBkYXRhKTtcbiAgICB9O1xuICAgIHRyeSB7XG4gICAgICBldmVudFRvRnVuY3Rpb24uY2FsbCh0aGlzLCBldmVudCwgZGF0YSkuY2FsbCgpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgbG9nZ2VyLmVycm9yKGBpbnRlcm5hbCBlcnJvciBoYXBwZW5lZCB3aGlsZSBwcm9jZXNzaW5nICR7ZXZlbnR9OiR7ZXJyLm1lc3NhZ2V9YCk7XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkVSUk9SLCB7dHlwZTogRXJyb3JUeXBlcy5PVEhFUl9FUlJPUiwgZGV0YWlsczogRXJyb3JEZXRhaWxzLklOVEVSTkFMX0VYQ0VQVElPTiwgZmF0YWw6IGZhbHNlLCBldmVudCA6IGV2ZW50LCBlcnIgOiBlcnJ9KTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgRXZlbnRIYW5kbGVyO1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8vIGZpcmVkIGJlZm9yZSBNZWRpYVNvdXJjZSBpcyBhdHRhY2hpbmcgdG8gbWVkaWEgZWxlbWVudCAtIGRhdGE6IHsgbWVkaWEgfVxuICBNRURJQV9BVFRBQ0hJTkc6ICdobHNNZWRpYUF0dGFjaGluZycsXG4gIC8vIGZpcmVkIHdoZW4gTWVkaWFTb3VyY2UgaGFzIGJlZW4gc3VjY2VzZnVsbHkgYXR0YWNoZWQgdG8gbWVkaWEgZWxlbWVudCAtIGRhdGE6IHsgfVxuICBNRURJQV9BVFRBQ0hFRDogJ2hsc01lZGlhQXR0YWNoZWQnLFxuICAvLyBmaXJlZCBiZWZvcmUgZGV0YWNoaW5nIE1lZGlhU291cmNlIGZyb20gbWVkaWEgZWxlbWVudCAtIGRhdGE6IHsgfVxuICBNRURJQV9ERVRBQ0hJTkc6ICdobHNNZWRpYURldGFjaGluZycsXG4gIC8vIGZpcmVkIHdoZW4gTWVkaWFTb3VyY2UgaGFzIGJlZW4gZGV0YWNoZWQgZnJvbSBtZWRpYSBlbGVtZW50IC0gZGF0YTogeyB9XG4gIE1FRElBX0RFVEFDSEVEOiAnaGxzTWVkaWFEZXRhY2hlZCcsXG4gIC8vIGZpcmVkIHdoZW4gd2UgYnVmZmVyIGlzIGdvaW5nIHRvIGJlIHJlc2V0dGVkXG4gIEJVRkZFUl9SRVNFVDogJ2hsc0J1ZmZlclJlc2V0JyxcbiAgLy8gZmlyZWQgd2hlbiB3ZSBrbm93IGFib3V0IHRoZSBjb2RlY3MgdGhhdCB3ZSBuZWVkIGJ1ZmZlcnMgZm9yIHRvIHB1c2ggaW50byAtIGRhdGE6IHt0cmFja3MgOiB7IGNvbnRhaW5lciwgY29kZWMsIGxldmVsQ29kZWMsIGluaXRTZWdtZW50LCBtZXRhZGF0YSB9fVxuICBCVUZGRVJfQ09ERUNTOiAnaGxzQnVmZmVyQ29kZWNzJyxcbiAgLy8gZmlyZWQgd2hlbiBzb3VyY2VidWZmZXJzIGhhdmUgYmVlbiBjcmVhdGVkIGRhdGE6IHsgdHJhY2tzIDogdHJhY2tzfVxuICBCVUZGRVJfQ1JFQVRFRDogJ2hsc0J1ZmZlckNyZWF0ZWQnLFxuICAvLyBmaXJlZCB3aGVuIHdlIGFwcGVuZCBhIHNlZ21lbnQgdG8gdGhlIGJ1ZmZlciAtIGRhdGE6IHsgc2VnbWVudDogc2VnbWVudCBvYmplY3QgfVxuICBCVUZGRVJfQVBQRU5ESU5HOiAnaGxzQnVmZmVyQXBwZW5kaW5nJyxcbiAgLy8gZmlyZWQgd2hlbiB3ZSBhcmUgZG9uZSB3aXRoIGFwcGVuZGluZyBhIG1lZGlhIHNlZ21lbnQgdG8gdGhlIGJ1ZmZlciBkYXRhIDogeyBwYXJlbnQgOiBzZWdtZW50IHBhcmVudCB0aGF0IHRyaWdnZXJlZCBCVUZGRVJfQVBQRU5ESU5HICwgcGVuZGluZyA6IG5iIG9mIHNlZ21lbnRzIHdhaXRpbmcgZm9yIGFwcGVuZGluZyBmb3IgdGhpcyBzZWdtZW50IHBhcmVudH1cbiAgQlVGRkVSX0FQUEVOREVEOiAnaGxzQnVmZmVyQXBwZW5kZWQnLFxuICAvLyBmaXJlZCB3aGVuIHRoZSBzdHJlYW0gaXMgZmluaXNoZWQgYW5kIHdlIHdhbnQgdG8gbm90aWZ5IHRoZSBtZWRpYSBidWZmZXIgdGhhdCB0aGVyZSB3aWxsIGJlIG5vIG1vcmUgZGF0YVxuICBCVUZGRVJfRU9TOiAnaGxzQnVmZmVyRW9zJyxcbiAgLy8gZmlyZWQgd2hlbiB0aGUgbWVkaWEgYnVmZmVyIHNob3VsZCBiZSBmbHVzaGVkIC0gZGF0YSB7c3RhcnRPZmZzZXQsIGVuZE9mZnNldH1cbiAgQlVGRkVSX0ZMVVNISU5HOiAnaGxzQnVmZmVyRmx1c2hpbmcnLFxuICAvLyBmaXJlZCB3aGVuIHRoZSBtZWRpYSBoYXMgYmVlbiBmbHVzaGVkXG4gIEJVRkZFUl9GTFVTSEVEOiAnaGxzQnVmZmVyRmx1c2hlZCcsXG4gIC8vIGZpcmVkIHRvIHNpZ25hbCB0aGF0IGEgbWFuaWZlc3QgbG9hZGluZyBzdGFydHMgLSBkYXRhOiB7IHVybCA6IG1hbmlmZXN0VVJMfVxuICBNQU5JRkVTVF9MT0FESU5HOiAnaGxzTWFuaWZlc3RMb2FkaW5nJyxcbiAgLy8gZmlyZWQgYWZ0ZXIgbWFuaWZlc3QgaGFzIGJlZW4gbG9hZGVkIC0gZGF0YTogeyBsZXZlbHMgOiBbYXZhaWxhYmxlIHF1YWxpdHkgbGV2ZWxzXSAsIGF1ZGlvVHJhY2tzIDogWyBhdmFpbGFibGUgYXVkaW8gdHJhY2tzXSwgdXJsIDogbWFuaWZlc3RVUkwsIHN0YXRzIDogeyB0cmVxdWVzdCwgdGZpcnN0LCB0bG9hZCwgbXRpbWV9fVxuICBNQU5JRkVTVF9MT0FERUQ6ICdobHNNYW5pZmVzdExvYWRlZCcsXG4gIC8vIGZpcmVkIGFmdGVyIG1hbmlmZXN0IGhhcyBiZWVuIHBhcnNlZCAtIGRhdGE6IHsgbGV2ZWxzIDogW2F2YWlsYWJsZSBxdWFsaXR5IGxldmVsc10gLCBmaXJzdExldmVsIDogaW5kZXggb2YgZmlyc3QgcXVhbGl0eSBsZXZlbCBhcHBlYXJpbmcgaW4gTWFuaWZlc3R9XG4gIE1BTklGRVNUX1BBUlNFRDogJ2hsc01hbmlmZXN0UGFyc2VkJyxcbiAgLy8gZmlyZWQgd2hlbiBhIGxldmVsIHBsYXlsaXN0IGxvYWRpbmcgc3RhcnRzIC0gZGF0YTogeyB1cmwgOiBsZXZlbCBVUkwgIGxldmVsIDogaWQgb2YgbGV2ZWwgYmVpbmcgbG9hZGVkfVxuICBMRVZFTF9MT0FESU5HOiAnaGxzTGV2ZWxMb2FkaW5nJyxcbiAgLy8gZmlyZWQgd2hlbiBhIGxldmVsIHBsYXlsaXN0IGxvYWRpbmcgZmluaXNoZXMgLSBkYXRhOiB7IGRldGFpbHMgOiBsZXZlbERldGFpbHMgb2JqZWN0LCBsZXZlbCA6IGlkIG9mIGxvYWRlZCBsZXZlbCwgc3RhdHMgOiB7IHRyZXF1ZXN0LCB0Zmlyc3QsIHRsb2FkLCBtdGltZX0gfVxuICBMRVZFTF9MT0FERUQ6ICdobHNMZXZlbExvYWRlZCcsXG4gIC8vIGZpcmVkIHdoZW4gYSBsZXZlbCdzIGRldGFpbHMgaGF2ZSBiZWVuIHVwZGF0ZWQgYmFzZWQgb24gcHJldmlvdXMgZGV0YWlscywgYWZ0ZXIgaXQgaGFzIGJlZW4gbG9hZGVkLiAtIGRhdGE6IHsgZGV0YWlscyA6IGxldmVsRGV0YWlscyBvYmplY3QsIGxldmVsIDogaWQgb2YgdXBkYXRlZCBsZXZlbCB9XG4gIExFVkVMX1VQREFURUQ6ICdobHNMZXZlbFVwZGF0ZWQnLFxuICAvLyBmaXJlZCB3aGVuIGEgbGV2ZWwncyBQVFMgaW5mb3JtYXRpb24gaGFzIGJlZW4gdXBkYXRlZCBhZnRlciBwYXJzaW5nIGEgZnJhZ21lbnQgLSBkYXRhOiB7IGRldGFpbHMgOiBsZXZlbERldGFpbHMgb2JqZWN0LCBsZXZlbCA6IGlkIG9mIHVwZGF0ZWQgbGV2ZWwsIGRyaWZ0OiBQVFMgZHJpZnQgb2JzZXJ2ZWQgd2hlbiBwYXJzaW5nIGxhc3QgZnJhZ21lbnQgfVxuICBMRVZFTF9QVFNfVVBEQVRFRDogJ2hsc0xldmVsUHRzVXBkYXRlZCcsXG4gIC8vIGZpcmVkIHdoZW4gYSBsZXZlbCBzd2l0Y2ggaXMgcmVxdWVzdGVkIC0gZGF0YTogeyBsZXZlbCA6IGlkIG9mIG5ldyBsZXZlbCB9XG4gIExFVkVMX1NXSVRDSDogJ2hsc0xldmVsU3dpdGNoJyxcbiAgLy8gZmlyZWQgdG8gbm90aWZ5IHRoYXQgYXVkaW8gdHJhY2sgbGlzdHMgaGFzIGJlZW4gdXBkYXRlZCBkYXRhOiB7IGF1ZGlvVHJhY2tzIDogYXVkaW9UcmFja3N9XG4gIExFVkVMX1JFTU9WRUQ6ICdobHNMZXZlbFJlbW92ZWQnLFxuICAvLyBmaXJlZCB3aGVuIGEgbGV2ZWwgc2hvdWxkIG5vIGxvbmdlciBiZSB1c2VkXG4gIEFVRElPX1RSQUNLU19VUERBVEVEOiAnaGxzQXVkaW9UcmFja3NVcGRhdGVkJyxcbiAgLy8gZmlyZWQgd2hlbiBhbiBhdWRpbyB0cmFjayBzd2l0Y2ggb2NjdXJzIC0gZGF0YTogeyAgaWQgOiBhdWRpbyB0cmFjayBpZH0gLy8gZGVwcmVjYXRlZFxuICBBVURJT19UUkFDS19TV0lUQ0g6ICdobHNBdWRpb1RyYWNrU3dpdGNoJyxcbiAgLy8gZmlyZWQgd2hlbiBhbiBhdWRpbyB0cmFjayBzd2l0Y2hpbmcgaXMgcmVxdWVzdGVkIC0gZGF0YTogeyAgaWQgOiBhdWRpbyB0cmFjayBpZH1cbiAgQVVESU9fVFJBQ0tfU1dJVENISU5HOiAnaGxzQXVkaW9UcmFja1N3aXRjaGluZycsXG4gIC8vIGZpcmVkIHdoZW4gYW4gYXVkaW8gdHJhY2sgc3dpdGNoIGFjdHVhbGx5IG9jY3VycyAtIGRhdGE6IHsgIGlkIDogYXVkaW8gdHJhY2sgaWR9XG4gIEFVRElPX1RSQUNLX1NXSVRDSEVEOiAnaGxzQXVkaW9UcmFja1N3aXRjaGVkJyxcbiAgLy8gZmlyZWQgd2hlbiBhbiBhdWRpbyB0cmFjayBsb2FkaW5nIHN0YXJ0cyAtIGRhdGE6IHsgdXJsIDogYXVkaW8gdHJhY2sgVVJMICBpZCA6IGF1ZGlvIHRyYWNrIGlkfVxuICBBVURJT19UUkFDS19MT0FESU5HOiAnaGxzQXVkaW9UcmFja0xvYWRpbmcnLFxuICAvLyBmaXJlZCB3aGVuIGFuIGF1ZGlvIHRyYWNrIGxvYWRpbmcgIGZpbmlzaGVzIC0gZGF0YTogeyBkZXRhaWxzIDogbGV2ZWxEZXRhaWxzIG9iamVjdCwgaWQgOiBhdWRpbyB0cmFjayBpZCwgc3RhdHMgOiB7IHRyZXF1ZXN0LCB0Zmlyc3QsIHRsb2FkLCBtdGltZX0gfVxuICBBVURJT19UUkFDS19MT0FERUQ6ICdobHNBdWRpb1RyYWNrTG9hZGVkJyxcbiAgLy8gZmlyZWQgdG8gbm90aWZ5IHRoYXQgc3VidGl0bGUgdHJhY2sgbGlzdHMgaGFzIGJlZW4gdXBkYXRlZCBkYXRhOiB7IHN1YnRpdGxlVHJhY2tzIDogc3VidGl0bGVUcmFja3N9XG4gIFNVQlRJVExFX1RSQUNLU19VUERBVEVEOiAnaGxzU3VidGl0bGVUcmFja3NVcGRhdGVkJyxcbiAgLy8gZmlyZWQgd2hlbiBhbiBzdWJ0aXRsZSB0cmFjayBzd2l0Y2ggb2NjdXJzIC0gZGF0YTogeyAgaWQgOiBzdWJ0aXRsZSB0cmFjayBpZH1cbiAgU1VCVElUTEVfVFJBQ0tfU1dJVENIOiAnaGxzU3VidGl0bGVUcmFja1N3aXRjaCcsXG4gIC8vIGZpcmVkIHdoZW4gYW4gc3VidGl0bGUgdHJhY2sgbG9hZGluZyBzdGFydHMgLSBkYXRhOiB7IHVybCA6IHN1YnRpdGxlIHRyYWNrIFVSTCAgaWQgOiBzdWJ0aXRsZSB0cmFjayBpZH1cbiAgU1VCVElUTEVfVFJBQ0tfTE9BRElORzogJ2hsc1N1YnRpdGxlVHJhY2tMb2FkaW5nJyxcbiAgLy8gZmlyZWQgd2hlbiBhbiBzdWJ0aXRsZSB0cmFjayBsb2FkaW5nICBmaW5pc2hlcyAtIGRhdGE6IHsgZGV0YWlscyA6IGxldmVsRGV0YWlscyBvYmplY3QsIGlkIDogc3VidGl0bGUgdHJhY2sgaWQsIHN0YXRzIDogeyB0cmVxdWVzdCwgdGZpcnN0LCB0bG9hZCwgbXRpbWV9IH1cbiAgU1VCVElUTEVfVFJBQ0tfTE9BREVEOiAnaGxzU3VidGl0bGVUcmFja0xvYWRlZCcsXG4gIC8vIGZpcmVkIHdoZW4gYSBzdWJ0aXRsZSBmcmFnbWVudCBoYXMgYmVlbiBwcm9jZXNzZWQgLSBkYXRhOiB7IHN1Y2Nlc3MgOiBib29sZWFuLCBmcmFnIDogdGhlIHByb2Nlc3NlZCBmcmFnfVxuICBTVUJUSVRMRV9GUkFHX1BST0NFU1NFRDogJ2hsc1N1YnRpdGxlRnJhZ1Byb2Nlc3NlZCcsXG4gIC8vIGZpcmVkIHdoZW4gdGhlIGZpcnN0IHRpbWVzdGFtcCBpcyBmb3VuZC4gVXNlZCBmb3Igc3luY2hyb25pc2luZyBXZWJWVFQgc3VidGl0bGVzLlxuICBJTklUX1BUU19GT1VORDogJ2hsc0luaXRQdHNGb3VuZCcsXG4gIC8vIGZpcmVkIHdoZW4gYSBmcmFnbWVudCBsb2FkaW5nIHN0YXJ0cyAtIGRhdGE6IHsgZnJhZyA6IGZyYWdtZW50IG9iamVjdH1cbiAgRlJBR19MT0FESU5HOiAnaGxzRnJhZ0xvYWRpbmcnLFxuICAvLyBmaXJlZCB3aGVuIGEgZnJhZ21lbnQgbG9hZGluZyBpcyBwcm9ncmVzc2luZyAtIGRhdGE6IHsgZnJhZyA6IGZyYWdtZW50IG9iamVjdCwgeyB0cmVxdWVzdCwgdGZpcnN0LCBsb2FkZWR9fVxuICBGUkFHX0xPQURfUFJPR1JFU1M6ICdobHNGcmFnTG9hZFByb2dyZXNzJyxcbiAgLy8gSWRlbnRpZmllciBmb3IgZnJhZ21lbnQgbG9hZCBhYm9ydGluZyBmb3IgZW1lcmdlbmN5IHN3aXRjaCBkb3duIC0gZGF0YToge2ZyYWcgOiBmcmFnbWVudCBvYmplY3R9XG4gIEZSQUdfTE9BRF9FTUVSR0VOQ1lfQUJPUlRFRDogJ2hsc0ZyYWdMb2FkRW1lcmdlbmN5QWJvcnRlZCcsXG4gIC8vIGZpcmVkIHdoZW4gYSBmcmFnbWVudCBsb2FkaW5nIGlzIGNvbXBsZXRlZCAtIGRhdGE6IHsgZnJhZyA6IGZyYWdtZW50IG9iamVjdCwgcGF5bG9hZCA6IGZyYWdtZW50IHBheWxvYWQsIHN0YXRzIDogeyB0cmVxdWVzdCwgdGZpcnN0LCB0bG9hZCwgbGVuZ3RofX1cbiAgRlJBR19MT0FERUQ6ICdobHNGcmFnTG9hZGVkJyxcbiAgLy8gZmlyZWQgd2hlbiBhIGZyYWdtZW50IGhhcyBzdGFydGVkIGRlY3J5cHRpbmcgLSBkYXRhOiB7IGxldmVsIDogbGV2ZWxJZCwgc24gOiBzZXF1ZW5jZSBudW1iZXIgfVxuICBGUkFHX0RFQ1JZUFRfU1RBUlRFRDogJ2hsc0ZyYWdEZWNyeXB0U3RhcnRlZCcsXG4gIC8vIGZpcmVkIHdoZW4gYSBmcmFnbWVudCBoYXMgZmluaXNoZWQgZGVjcnlwdGluZyAtIGRhdGE6IHsgbGV2ZWwgOiBsZXZlbElkLCBzbiA6IHNlcXVlbmNlIG51bWJlciB9XG4gIEZSQUdfREVDUllQVEVEOiAnaGxzRnJhZ0RlY3J5cHRlZCcsXG4gIC8vIGZpcmVkIHdoZW4gSW5pdCBTZWdtZW50IGhhcyBiZWVuIGV4dHJhY3RlZCBmcm9tIGZyYWdtZW50IC0gZGF0YTogeyBpZCA6IGRlbXV4ZXIgaWQsIGxldmVsIDogbGV2ZWxJZCwgc24gOiBzZXF1ZW5jZSBudW1iZXIsIG1vb3YgOiBtb292IE1QNCBib3gsIGNvZGVjcyA6IGNvZGVjcyBmb3VuZCB3aGlsZSBwYXJzaW5nIGZyYWdtZW50fVxuICBGUkFHX1BBUlNJTkdfSU5JVF9TRUdNRU5UOiAnaGxzRnJhZ1BhcnNpbmdJbml0U2VnbWVudCcsXG4gIC8vIGZpcmVkIHdoZW4gcGFyc2luZyBzZWkgdGV4dCBpcyBjb21wbGV0ZWQgLSBkYXRhOiB7IGlkIDogZGVtdXhlciBpZCwgLCBsZXZlbCA6IGxldmVsSWQsIHNuIDogc2VxdWVuY2UgbnVtYmVyLCBzYW1wbGVzIDogWyBzZWkgc2FtcGxlcyBwZXMgXSB9XG4gIEZSQUdfUEFSU0lOR19VU0VSREFUQTogJ2hsc0ZyYWdQYXJzaW5nVXNlcmRhdGEnLFxuICAvLyBmaXJlZCB3aGVuIHBhcnNpbmcgaWQzIGlzIGNvbXBsZXRlZCAtIGRhdGE6IHsgaWQgOiBkZW11eGVyIGlkLCAsIGxldmVsIDogbGV2ZWxJZCwgc24gOiBzZXF1ZW5jZSBudW1iZXIsIHNhbXBsZXMgOiBbIGlkMyBzYW1wbGVzIHBlcyBdIH1cbiAgRlJBR19QQVJTSU5HX01FVEFEQVRBOiAnaGxzRnJhZ1BhcnNpbmdNZXRhZGF0YScsXG4gIC8vIGZpcmVkIHdoZW4gZGF0YSBoYXZlIGJlZW4gZXh0cmFjdGVkIGZyb20gZnJhZ21lbnQgLSBkYXRhOiB7IGlkIDogZGVtdXhlciBpZCwgbGV2ZWwgOiBsZXZlbElkLCBzbiA6IHNlcXVlbmNlIG51bWJlciwgZGF0YTEgOiBtb29mIE1QNCBib3ggb3IgVFMgZnJhZ21lbnRzLCBkYXRhMiA6IG1kYXQgTVA0IGJveCBvciBudWxsfVxuICBGUkFHX1BBUlNJTkdfREFUQTogJ2hsc0ZyYWdQYXJzaW5nRGF0YScsXG4gIC8vIGZpcmVkIHdoZW4gZnJhZ21lbnQgcGFyc2luZyBpcyBjb21wbGV0ZWQgLSBkYXRhOiB7IGlkIDogZGVtdXhlciBpZDsgbGV2ZWwgOiBsZXZlbElkLCBzbiA6IHNlcXVlbmNlIG51bWJlciwgfVxuICBGUkFHX1BBUlNFRDogJ2hsc0ZyYWdQYXJzZWQnLFxuICAvLyBmaXJlZCB3aGVuIGZyYWdtZW50IHJlbXV4ZWQgTVA0IGJveGVzIGhhdmUgYWxsIGJlZW4gYXBwZW5kZWQgaW50byBTb3VyY2VCdWZmZXIgLSBkYXRhOiB7IGlkIDogZGVtdXhlciBpZCxmcmFnIDogZnJhZ21lbnQgb2JqZWN0LCBzdGF0cyA6IHsgdHJlcXVlc3QsIHRmaXJzdCwgdGxvYWQsIHRwYXJzZWQsIHRidWZmZXJlZCwgbGVuZ3RofSB9XG4gIEZSQUdfQlVGRkVSRUQ6ICdobHNGcmFnQnVmZmVyZWQnLFxuICAvLyBmaXJlZCB3aGVuIGZyYWdtZW50IG1hdGNoaW5nIHdpdGggY3VycmVudCBtZWRpYSBwb3NpdGlvbiBpcyBjaGFuZ2luZyAtIGRhdGEgOiB7IGlkIDogZGVtdXhlciBpZCwgZnJhZyA6IGZyYWdtZW50IG9iamVjdCB9XG4gIEZSQUdfQ0hBTkdFRDogJ2hsc0ZyYWdDaGFuZ2VkJyxcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBGUFMgZHJvcCBldmVudCAtIGRhdGE6IHtjdXJlbnREcm9wcGVkLCBjdXJyZW50RGVjb2RlZCwgdG90YWxEcm9wcGVkRnJhbWVzfVxuICBGUFNfRFJPUDogJ2hsc0Zwc0Ryb3AnLFxuICAvL3RyaWdnZXJlZCB3aGVuIEZQUyBkcm9wIHRyaWdnZXJzIGF1dG8gbGV2ZWwgY2FwcGluZyAtIGRhdGE6IHtsZXZlbCwgZHJvcHBlZGxldmVsfVxuICBGUFNfRFJPUF9MRVZFTF9DQVBQSU5HOiAnaGxzRnBzRHJvcExldmVsQ2FwcGluZycsXG4gIC8vIElkZW50aWZpZXIgZm9yIGFuIGVycm9yIGV2ZW50IC0gZGF0YTogeyB0eXBlIDogZXJyb3IgdHlwZSwgZGV0YWlscyA6IGVycm9yIGRldGFpbHMsIGZhdGFsIDogaWYgdHJ1ZSwgaGxzLmpzIGNhbm5vdC93aWxsIG5vdCB0cnkgdG8gcmVjb3ZlciwgaWYgZmFsc2UsIGhscy5qcyB3aWxsIHRyeSB0byByZWNvdmVyLG90aGVyIGVycm9yIHNwZWNpZmljIGRhdGF9XG4gIEVSUk9SOiAnaGxzRXJyb3InLFxuICAvLyBmaXJlZCB3aGVuIGhscy5qcyBpbnN0YW5jZSBzdGFydHMgZGVzdHJveWluZy4gRGlmZmVyZW50IGZyb20gTUVESUFfREVUQUNIRUQgYXMgb25lIGNvdWxkIHdhbnQgdG8gZGV0YWNoIGFuZCByZWF0dGFjaCBhIG1lZGlhIHRvIHRoZSBpbnN0YW5jZSBvZiBobHMuanMgdG8gaGFuZGxlIG1pZC1yb2xscyBmb3IgZXhhbXBsZVxuICBERVNUUk9ZSU5HOiAnaGxzRGVzdHJveWluZycsXG4gIC8vIGZpcmVkIHdoZW4gYSBkZWNyeXB0IGtleSBsb2FkaW5nIHN0YXJ0cyAtIGRhdGE6IHsgZnJhZyA6IGZyYWdtZW50IG9iamVjdH1cbiAgS0VZX0xPQURJTkc6ICdobHNLZXlMb2FkaW5nJyxcbiAgLy8gZmlyZWQgd2hlbiBhIGRlY3J5cHQga2V5IGxvYWRpbmcgaXMgY29tcGxldGVkIC0gZGF0YTogeyBmcmFnIDogZnJhZ21lbnQgb2JqZWN0LCBwYXlsb2FkIDoga2V5IHBheWxvYWQsIHN0YXRzIDogeyB0cmVxdWVzdCwgdGZpcnN0LCB0bG9hZCwgbGVuZ3RofX1cbiAgS0VZX0xPQURFRDogJ2hsc0tleUxvYWRlZCcsXG4gIC8vIGZpcmVkIHVwb24gc3RyZWFtIGNvbnRyb2xsZXIgc3RhdGUgdHJhbnNpdGlvbnMgLSBkYXRhOiB7cHJldmlvdXNTdGF0ZSwgbmV4dFN0YXRlfVxuICBTVFJFQU1fU1RBVEVfVFJBTlNJVElPTjogJ2hsc1N0cmVhbVN0YXRlVHJhbnNpdGlvbidcbn07XG4iLCIvKipcbiAqICBBQUMgaGVscGVyXG4gKi9cblxuY2xhc3MgQUFDIHtcbiAgc3RhdGljIGdldFNpbGVudEZyYW1lKGNoYW5uZWxDb3VudCkge1xuICAgIGlmIChjaGFubmVsQ291bnQgPT09IDEpIHtcbiAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShbMHgwMCwgMHhjOCwgMHgwMCwgMHg4MCwgMHgyMywgMHg4MF0pO1xuICAgIH0gZWxzZSBpZiAoY2hhbm5lbENvdW50ID09PSAyKSB7XG4gICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzB4MjEsIDB4MDAsIDB4NDksIDB4OTAsIDB4MDIsIDB4MTksIDB4MDAsIDB4MjMsIDB4ODBdKTtcbiAgICB9IGVsc2UgaWYgKGNoYW5uZWxDb3VudCA9PT0gMykge1xuICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFsweDAwLCAweGM4LCAweDAwLCAweDgwLCAweDIwLCAweDg0LCAweDAxLCAweDI2LCAweDQwLCAweDA4LCAweDY0LCAweDAwLCAweDhlXSk7XG4gICAgfSBlbHNlIGlmIChjaGFubmVsQ291bnQgPT09IDQpIHtcbiAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShbMHgwMCwgMHhjOCwgMHgwMCwgMHg4MCwgMHgyMCwgMHg4NCwgMHgwMSwgMHgyNiwgMHg0MCwgMHgwOCwgMHg2NCwgMHgwMCwgMHg4MCwgMHgyYywgMHg4MCwgMHgwOCwgMHgwMiwgMHgzOF0pO1xuICAgIH0gZWxzZSBpZiAoY2hhbm5lbENvdW50ID09PSA1KSB7XG4gICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzB4MDAsIDB4YzgsIDB4MDAsIDB4ODAsIDB4MjAsIDB4ODQsIDB4MDEsIDB4MjYsIDB4NDAsIDB4MDgsIDB4NjQsIDB4MDAsIDB4ODIsIDB4MzAsIDB4MDQsIDB4OTksIDB4MDAsIDB4MjEsIDB4OTAsIDB4MDIsIDB4MzhdKTtcbiAgICB9IGVsc2UgaWYgKGNoYW5uZWxDb3VudCA9PT0gNikge1xuICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFsweDAwLCAweGM4LCAweDAwLCAweDgwLCAweDIwLCAweDg0LCAweDAxLCAweDI2LCAweDQwLCAweDA4LCAweDY0LCAweDAwLCAweDgyLCAweDMwLCAweDA0LCAweDk5LCAweDAwLCAweDIxLCAweDkwLCAweDAyLCAweDAwLCAweGIyLCAweDAwLCAweDIwLCAweDA4LCAweGUwXSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEFBQztcbiIsIi8qKlxuICogQnVmZmVyIEhlbHBlciBjbGFzcywgcHJvdmlkaW5nIG1ldGhvZHMgZGVhbGluZyBidWZmZXIgbGVuZ3RoIHJldHJpZXZhbFxuKi9cblxuXG5jbGFzcyBCdWZmZXJIZWxwZXIge1xuXG5cbiAgc3RhdGljIGlzQnVmZmVyZWQobWVkaWEscG9zaXRpb24pIHtcbiAgICBpZiAobWVkaWEpIHtcbiAgICAgIGxldCBidWZmZXJlZCA9IG1lZGlhLmJ1ZmZlcmVkO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBidWZmZXJlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAocG9zaXRpb24gPj0gYnVmZmVyZWQuc3RhcnQoaSkgJiYgcG9zaXRpb24gPD0gYnVmZmVyZWQuZW5kKGkpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgc3RhdGljIGJ1ZmZlckluZm8obWVkaWEsIHBvcyxtYXhIb2xlRHVyYXRpb24pIHtcbiAgICBpZiAobWVkaWEpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciB2YnVmZmVyZWQgPSBtZWRpYS5idWZmZXJlZCwgYnVmZmVyZWQgPSBbXSwgaTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHZidWZmZXJlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGJ1ZmZlcmVkLnB1c2goe3N0YXJ0OiB2YnVmZmVyZWQuc3RhcnQoaSksIGVuZDogdmJ1ZmZlcmVkLmVuZChpKX0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlcmVkSW5mbyhidWZmZXJlZCwgcG9zLCBtYXhIb2xlRHVyYXRpb24pO1xuICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgIHJldHVybiB7bGVuOiAwLCBzdGFydDogMCwgZW5kOiAwLCBuZXh0U3RhcnQgOiB1bmRlZmluZWR9IDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHtsZW46IDAsIHN0YXJ0OiAwLCBlbmQ6IDAsIG5leHRTdGFydCA6IHVuZGVmaW5lZH0gO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBidWZmZXJlZEluZm8oYnVmZmVyZWQscG9zLG1heEhvbGVEdXJhdGlvbikge1xuICAgIHZhciBidWZmZXJlZDIgPSBbXSxcbiAgICAgICAgLy8gYnVmZmVyU3RhcnQgYW5kIGJ1ZmZlckVuZCBhcmUgYnVmZmVyIGJvdW5kYXJpZXMgYXJvdW5kIGN1cnJlbnQgdmlkZW8gcG9zaXRpb25cbiAgICAgICAgYnVmZmVyTGVuLGJ1ZmZlclN0YXJ0LCBidWZmZXJFbmQsYnVmZmVyU3RhcnROZXh0LGk7XG4gICAgLy8gc29ydCBvbiBidWZmZXIuc3RhcnQvc21hbGxlciBlbmQgKElFIGRvZXMgbm90IGFsd2F5cyByZXR1cm4gc29ydGVkIGJ1ZmZlcmVkIHJhbmdlKVxuICAgIGJ1ZmZlcmVkLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHZhciBkaWZmID0gYS5zdGFydCAtIGIuc3RhcnQ7XG4gICAgICBpZiAoZGlmZikge1xuICAgICAgICByZXR1cm4gZGlmZjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBiLmVuZCAtIGEuZW5kO1xuICAgICAgfVxuICAgIH0pO1xuICAgIC8vIHRoZXJlIG1pZ2h0IGJlIHNvbWUgc21hbGwgaG9sZXMgYmV0d2VlbiBidWZmZXIgdGltZSByYW5nZVxuICAgIC8vIGNvbnNpZGVyIHRoYXQgaG9sZXMgc21hbGxlciB0aGFuIG1heEhvbGVEdXJhdGlvbiBhcmUgaXJyZWxldmFudCBhbmQgYnVpbGQgYW5vdGhlclxuICAgIC8vIGJ1ZmZlciB0aW1lIHJhbmdlIHJlcHJlc2VudGF0aW9ucyB0aGF0IGRpc2NhcmRzIHRob3NlIGhvbGVzXG4gICAgZm9yIChpID0gMDsgaSA8IGJ1ZmZlcmVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYnVmMmxlbiA9IGJ1ZmZlcmVkMi5sZW5ndGg7XG4gICAgICBpZihidWYybGVuKSB7XG4gICAgICAgIHZhciBidWYyZW5kID0gYnVmZmVyZWQyW2J1ZjJsZW4gLSAxXS5lbmQ7XG4gICAgICAgIC8vIGlmIHNtYWxsIGhvbGUgKHZhbHVlIGJldHdlZW4gMCBvciBtYXhIb2xlRHVyYXRpb24gKSBvciBvdmVybGFwcGluZyAobmVnYXRpdmUpXG4gICAgICAgIGlmKChidWZmZXJlZFtpXS5zdGFydCAtIGJ1ZjJlbmQpIDwgbWF4SG9sZUR1cmF0aW9uKSB7XG4gICAgICAgICAgLy8gbWVyZ2Ugb3ZlcmxhcHBpbmcgdGltZSByYW5nZXNcbiAgICAgICAgICAvLyB1cGRhdGUgbGFzdFJhbmdlLmVuZCBvbmx5IGlmIHNtYWxsZXIgdGhhbiBpdGVtLmVuZFxuICAgICAgICAgIC8vIGUuZy4gIFsgMSwgMTVdIHdpdGggIFsgMiw4XSA9PiBbIDEsMTVdIChubyBuZWVkIHRvIG1vZGlmeSBsYXN0UmFuZ2UuZW5kKVxuICAgICAgICAgIC8vIHdoZXJlYXMgWyAxLCA4XSB3aXRoICBbIDIsMTVdID0+IFsgMSwxNV0gKCBsYXN0UmFuZ2Ugc2hvdWxkIHN3aXRjaCBmcm9tIFsxLDhdIHRvIFsxLDE1XSlcbiAgICAgICAgICBpZihidWZmZXJlZFtpXS5lbmQgPiBidWYyZW5kKSB7XG4gICAgICAgICAgICBidWZmZXJlZDJbYnVmMmxlbiAtIDFdLmVuZCA9IGJ1ZmZlcmVkW2ldLmVuZDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gYmlnIGhvbGVcbiAgICAgICAgICBidWZmZXJlZDIucHVzaChidWZmZXJlZFtpXSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGZpcnN0IHZhbHVlXG4gICAgICAgIGJ1ZmZlcmVkMi5wdXNoKGJ1ZmZlcmVkW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChpID0gMCwgYnVmZmVyTGVuID0gMCwgYnVmZmVyU3RhcnQgPSBidWZmZXJFbmQgPSBwb3M7IGkgPCBidWZmZXJlZDIubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzdGFydCA9ICBidWZmZXJlZDJbaV0uc3RhcnQsXG4gICAgICAgICAgZW5kID0gYnVmZmVyZWQyW2ldLmVuZDtcbiAgICAgIC8vbG9nZ2VyLmxvZygnYnVmIHN0YXJ0L2VuZDonICsgYnVmZmVyZWQuc3RhcnQoaSkgKyAnLycgKyBidWZmZXJlZC5lbmQoaSkpO1xuICAgICAgaWYgKChwb3MgKyBtYXhIb2xlRHVyYXRpb24pID49IHN0YXJ0ICYmIHBvcyA8IGVuZCkge1xuICAgICAgICAvLyBwbGF5IHBvc2l0aW9uIGlzIGluc2lkZSB0aGlzIGJ1ZmZlciBUaW1lUmFuZ2UsIHJldHJpZXZlIGVuZCBvZiBidWZmZXIgcG9zaXRpb24gYW5kIGJ1ZmZlciBsZW5ndGhcbiAgICAgICAgYnVmZmVyU3RhcnQgPSBzdGFydDtcbiAgICAgICAgYnVmZmVyRW5kID0gZW5kO1xuICAgICAgICBidWZmZXJMZW4gPSBidWZmZXJFbmQgLSBwb3M7XG4gICAgICB9IGVsc2UgaWYgKChwb3MgKyBtYXhIb2xlRHVyYXRpb24pIDwgc3RhcnQpIHtcbiAgICAgICAgYnVmZmVyU3RhcnROZXh0ID0gc3RhcnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge2xlbjogYnVmZmVyTGVuLCBzdGFydDogYnVmZmVyU3RhcnQgfHwgMCwgZW5kOiBidWZmZXJFbmQgfHwgMCwgbmV4dFN0YXJ0IDogYnVmZmVyU3RhcnROZXh0fTtcbiAgfVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IEJ1ZmZlckhlbHBlcjtcbiIsIi8qKlxuICogTGV2ZWwgSGVscGVyIGNsYXNzLCBwcm92aWRpbmcgbWV0aG9kcyBkZWFsaW5nIHdpdGggcGxheWxpc3Qgc2xpZGluZyBhbmQgZHJpZnRcbiovXG5cbmltcG9ydCB7bG9nZ2VyfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xuXG5jbGFzcyBMZXZlbEhlbHBlciB7XG5cbiAgc3RhdGljIG1lcmdlRGV0YWlscyhvbGREZXRhaWxzLG5ld0RldGFpbHMpIHtcbiAgICB2YXIgc3RhcnQgPSBNYXRoLm1heChvbGREZXRhaWxzLnN0YXJ0U04sbmV3RGV0YWlscy5zdGFydFNOKS1uZXdEZXRhaWxzLnN0YXJ0U04sXG4gICAgICAgIGVuZCA9IE1hdGgubWluKG9sZERldGFpbHMuZW5kU04sbmV3RGV0YWlscy5lbmRTTiktbmV3RGV0YWlscy5zdGFydFNOLFxuICAgICAgICBkZWx0YSA9IG5ld0RldGFpbHMuc3RhcnRTTiAtIG9sZERldGFpbHMuc3RhcnRTTixcbiAgICAgICAgb2xkZnJhZ21lbnRzID0gb2xkRGV0YWlscy5mcmFnbWVudHMsXG4gICAgICAgIG5ld2ZyYWdtZW50cyA9IG5ld0RldGFpbHMuZnJhZ21lbnRzLFxuICAgICAgICBjY09mZnNldCA9MCxcbiAgICAgICAgUFRTRnJhZztcblxuICAgIC8vIGNoZWNrIGlmIG9sZC9uZXcgcGxheWxpc3RzIGhhdmUgZnJhZ21lbnRzIGluIGNvbW1vblxuICAgIGlmICggZW5kIDwgc3RhcnQpIHtcbiAgICAgIG5ld0RldGFpbHMuUFRTS25vd24gPSBmYWxzZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gbG9vcCB0aHJvdWdoIG92ZXJsYXBwaW5nIFNOIGFuZCB1cGRhdGUgc3RhcnRQVFMgLCBjYywgYW5kIGR1cmF0aW9uIGlmIGFueSBmb3VuZFxuICAgIGZvcih2YXIgaSA9IHN0YXJ0IDsgaSA8PSBlbmQgOyBpKyspIHtcbiAgICAgIHZhciBvbGRGcmFnID0gb2xkZnJhZ21lbnRzW2RlbHRhK2ldLFxuICAgICAgICAgIG5ld0ZyYWcgPSBuZXdmcmFnbWVudHNbaV07XG4gICAgICBpZiAobmV3RnJhZyAmJiBvbGRGcmFnKSB7XG4gICAgICAgIGNjT2Zmc2V0ID0gb2xkRnJhZy5jYyAtIG5ld0ZyYWcuY2M7XG4gICAgICAgIGlmICghaXNOYU4ob2xkRnJhZy5zdGFydFBUUykpIHtcbiAgICAgICAgICBuZXdGcmFnLnN0YXJ0ID0gbmV3RnJhZy5zdGFydFBUUyA9IG9sZEZyYWcuc3RhcnRQVFM7XG4gICAgICAgICAgbmV3RnJhZy5lbmRQVFMgPSBvbGRGcmFnLmVuZFBUUztcbiAgICAgICAgICBuZXdGcmFnLmR1cmF0aW9uID0gb2xkRnJhZy5kdXJhdGlvbjtcbiAgICAgICAgICBQVFNGcmFnID0gbmV3RnJhZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmKGNjT2Zmc2V0KSB7XG4gICAgICBsb2dnZXIubG9nKGBkaXNjb250aW51aXR5IHNsaWRpbmcgZnJvbSBwbGF5bGlzdCwgdGFrZSBkcmlmdCBpbnRvIGFjY291bnRgKTtcbiAgICAgIGZvcihpID0gMCA7IGkgPCBuZXdmcmFnbWVudHMubGVuZ3RoIDsgaSsrKSB7XG4gICAgICAgIG5ld2ZyYWdtZW50c1tpXS5jYyArPSBjY09mZnNldDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBpZiBhdCBsZWFzdCBvbmUgZnJhZ21lbnQgY29udGFpbnMgUFRTIGluZm8sIHJlY29tcHV0ZSBQVFMgaW5mb3JtYXRpb24gZm9yIGFsbCBmcmFnbWVudHNcbiAgICBpZihQVFNGcmFnKSB7XG4gICAgICBMZXZlbEhlbHBlci51cGRhdGVGcmFnUFRTRFRTKG5ld0RldGFpbHMsUFRTRnJhZy5zbixQVFNGcmFnLnN0YXJ0UFRTLFBUU0ZyYWcuZW5kUFRTLFBUU0ZyYWcuc3RhcnREVFMsUFRTRnJhZy5lbmREVFMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBlbnN1cmUgdGhhdCBkZWx0YSBpcyB3aXRoaW4gb2xkZnJhZ21lbnRzIHJhbmdlXG4gICAgICAvLyBhbHNvIGFkanVzdCBzbGlkaW5nIGluIGNhc2UgZGVsdGEgaXMgMCAod2UgY291bGQgaGF2ZSBvbGQ9WzUwLTYwXSBhbmQgbmV3PW9sZD1bNTAtNjFdKVxuICAgICAgLy8gaW4gdGhhdCBjYXNlIHdlIGFsc28gbmVlZCB0byBhZGp1c3Qgc3RhcnQgb2Zmc2V0IG9mIGFsbCBmcmFnbWVudHNcbiAgICAgIGlmIChkZWx0YSA+PSAwICYmIGRlbHRhIDwgb2xkZnJhZ21lbnRzLmxlbmd0aCkge1xuICAgICAgICAvLyBhZGp1c3Qgc3RhcnQgYnkgc2xpZGluZyBvZmZzZXRcbiAgICAgICAgdmFyIHNsaWRpbmcgPSBvbGRmcmFnbWVudHNbZGVsdGFdLnN0YXJ0O1xuICAgICAgICBmb3IoaSA9IDAgOyBpIDwgbmV3ZnJhZ21lbnRzLmxlbmd0aCA7IGkrKykge1xuICAgICAgICAgIG5ld2ZyYWdtZW50c1tpXS5zdGFydCArPSBzbGlkaW5nO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGlmIHdlIGFyZSBoZXJlLCBpdCBtZWFucyB3ZSBoYXZlIGZyYWdtZW50cyBvdmVybGFwcGluZyBiZXR3ZWVuXG4gICAgLy8gb2xkIGFuZCBuZXcgbGV2ZWwuIHJlbGlhYmxlIFBUUyBpbmZvIGlzIHRodXMgcmVseWluZyBvbiBvbGQgbGV2ZWxcbiAgICBuZXdEZXRhaWxzLlBUU0tub3duID0gb2xkRGV0YWlscy5QVFNLbm93bjtcbiAgICByZXR1cm47XG4gIH1cblxuICBzdGF0aWMgdXBkYXRlRnJhZ1BUU0RUUyhkZXRhaWxzLHNuLHN0YXJ0UFRTLGVuZFBUUyxzdGFydERUUyxlbmREVFMpIHtcbiAgICB2YXIgZnJhZ0lkeCwgZnJhZ21lbnRzLCBmcmFnLCBpO1xuICAgIC8vIGV4aXQgaWYgc24gb3V0IG9mIHJhbmdlXG4gICAgaWYgKCFkZXRhaWxzIHx8IHNuIDwgZGV0YWlscy5zdGFydFNOIHx8IHNuID4gZGV0YWlscy5lbmRTTikge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGZyYWdJZHggPSBzbiAtIGRldGFpbHMuc3RhcnRTTjtcbiAgICBmcmFnbWVudHMgPSBkZXRhaWxzLmZyYWdtZW50cztcbiAgICBmcmFnID0gZnJhZ21lbnRzW2ZyYWdJZHhdO1xuICAgIGlmKCFpc05hTihmcmFnLnN0YXJ0UFRTKSkge1xuICAgICAgLy8gZGVsdGEgUFRTIGJldHdlZW4gYXVkaW8gYW5kIHZpZGVvXG4gICAgICBsZXQgZGVsdGFQVFMgPSBNYXRoLmFicyhmcmFnLnN0YXJ0UFRTLXN0YXJ0UFRTKTtcbiAgICAgIGlmIChpc05hTihmcmFnLmRlbHRhUFRTKSkge1xuICAgICAgICBmcmFnLmRlbHRhUFRTID0gZGVsdGFQVFM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmcmFnLmRlbHRhUFRTID0gTWF0aC5tYXgoZGVsdGFQVFMsZnJhZy5kZWx0YVBUUyk7XG4gICAgICB9XG4gICAgICBzdGFydFBUUyA9IE1hdGgubWluKHN0YXJ0UFRTLGZyYWcuc3RhcnRQVFMpO1xuICAgICAgZW5kUFRTID0gTWF0aC5tYXgoZW5kUFRTLCBmcmFnLmVuZFBUUyk7XG4gICAgICBzdGFydERUUyA9IE1hdGgubWluKHN0YXJ0RFRTLGZyYWcuc3RhcnREVFMpO1xuICAgICAgZW5kRFRTID0gTWF0aC5tYXgoZW5kRFRTLCBmcmFnLmVuZERUUyk7XG4gICAgfVxuXG4gICAgdmFyIGRyaWZ0ID0gc3RhcnRQVFMgLSBmcmFnLnN0YXJ0O1xuXG4gICAgZnJhZy5zdGFydCA9IGZyYWcuc3RhcnRQVFMgPSBzdGFydFBUUztcbiAgICBmcmFnLmVuZFBUUyA9IGVuZFBUUztcbiAgICBmcmFnLnN0YXJ0RFRTID0gc3RhcnREVFM7XG4gICAgZnJhZy5lbmREVFMgPSBlbmREVFM7XG4gICAgZnJhZy5kdXJhdGlvbiA9IGVuZFBUUyAtIHN0YXJ0UFRTO1xuICAgIC8vIGFkanVzdCBmcmFnbWVudCBQVFMvZHVyYXRpb24gZnJvbSBzZXFudW0tMSB0byBmcmFnIDBcbiAgICBmb3IoaSA9IGZyYWdJZHggOyBpID4gMCA7IGktLSkge1xuICAgICAgTGV2ZWxIZWxwZXIudXBkYXRlUFRTKGZyYWdtZW50cyxpLGktMSk7XG4gICAgfVxuXG4gICAgLy8gYWRqdXN0IGZyYWdtZW50IFBUUy9kdXJhdGlvbiBmcm9tIHNlcW51bSB0byBsYXN0IGZyYWdcbiAgICBmb3IoaSA9IGZyYWdJZHggOyBpIDwgZnJhZ21lbnRzLmxlbmd0aCAtIDEgOyBpKyspIHtcbiAgICAgIExldmVsSGVscGVyLnVwZGF0ZVBUUyhmcmFnbWVudHMsaSxpKzEpO1xuICAgIH1cbiAgICBkZXRhaWxzLlBUU0tub3duID0gdHJ1ZTtcbiAgICAvL2xvZ2dlci5sb2coYCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhZyBzdGFydC9lbmQ6JHtzdGFydFBUUy50b0ZpeGVkKDMpfS8ke2VuZFBUUy50b0ZpeGVkKDMpfWApO1xuXG4gICAgcmV0dXJuIGRyaWZ0O1xuICB9XG5cbiAgc3RhdGljIHVwZGF0ZVBUUyhmcmFnbWVudHMsZnJvbUlkeCwgdG9JZHgpIHtcbiAgICB2YXIgZnJhZ0Zyb20gPSBmcmFnbWVudHNbZnJvbUlkeF0sZnJhZ1RvID0gZnJhZ21lbnRzW3RvSWR4XSwgZnJhZ1RvUFRTID0gZnJhZ1RvLnN0YXJ0UFRTO1xuICAgIC8vIGlmIHdlIGtub3cgc3RhcnRQVFNbdG9JZHhdXG4gICAgaWYoIWlzTmFOKGZyYWdUb1BUUykpIHtcbiAgICAgIC8vIHVwZGF0ZSBmcmFnbWVudCBkdXJhdGlvbi5cbiAgICAgIC8vIGl0IGhlbHBzIHRvIGZpeCBkcmlmdHMgYmV0d2VlbiBwbGF5bGlzdCByZXBvcnRlZCBkdXJhdGlvbiBhbmQgZnJhZ21lbnQgcmVhbCBkdXJhdGlvblxuICAgICAgaWYgKHRvSWR4ID4gZnJvbUlkeCkge1xuICAgICAgICBmcmFnRnJvbS5kdXJhdGlvbiA9IGZyYWdUb1BUUy1mcmFnRnJvbS5zdGFydDtcbiAgICAgICAgaWYoZnJhZ0Zyb20uZHVyYXRpb24gPCAwKSB7XG4gICAgICAgICAgbG9nZ2VyLndhcm4oYG5lZ2F0aXZlIGR1cmF0aW9uIGNvbXB1dGVkIGZvciBmcmFnICR7ZnJhZ0Zyb20uc259LGxldmVsICR7ZnJhZ0Zyb20ubGV2ZWx9LCB0aGVyZSBzaG91bGQgYmUgc29tZSBkdXJhdGlvbiBkcmlmdCBiZXR3ZWVuIHBsYXlsaXN0IGFuZCBmcmFnbWVudCFgKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZnJhZ1RvLmR1cmF0aW9uID0gZnJhZ0Zyb20uc3RhcnQgLSBmcmFnVG9QVFM7XG4gICAgICAgIGlmKGZyYWdUby5kdXJhdGlvbiA8IDApIHtcbiAgICAgICAgICBsb2dnZXIud2FybihgbmVnYXRpdmUgZHVyYXRpb24gY29tcHV0ZWQgZm9yIGZyYWcgJHtmcmFnVG8uc259LGxldmVsICR7ZnJhZ1RvLmxldmVsfSwgdGhlcmUgc2hvdWxkIGJlIHNvbWUgZHVyYXRpb24gZHJpZnQgYmV0d2VlbiBwbGF5bGlzdCBhbmQgZnJhZ21lbnQhYCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gd2UgZG9udCBrbm93IHN0YXJ0UFRTW3RvSWR4XVxuICAgICAgaWYgKHRvSWR4ID4gZnJvbUlkeCkge1xuICAgICAgICBmcmFnVG8uc3RhcnQgPSBmcmFnRnJvbS5zdGFydCArIGZyYWdGcm9tLmR1cmF0aW9uO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZnJhZ1RvLnN0YXJ0ID0gZnJhZ0Zyb20uc3RhcnQgLSBmcmFnVG8uZHVyYXRpb247XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IExldmVsSGVscGVyO1xuIiwiLyoqXG4gKiBITFMgaW50ZXJmYWNlXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IEV2ZW50IGZyb20gJy4vZXZlbnRzJztcbmltcG9ydCB7RXJyb3JUeXBlcywgRXJyb3JEZXRhaWxzfSBmcm9tICcuL2Vycm9ycyc7XG5pbXBvcnQgUGxheWxpc3RMb2FkZXIgZnJvbSAnLi9sb2FkZXIvcGxheWxpc3QtbG9hZGVyJztcbmltcG9ydCBGcmFnbWVudExvYWRlciBmcm9tICcuL2xvYWRlci9mcmFnbWVudC1sb2FkZXInO1xuaW1wb3J0IEFickNvbnRyb2xsZXIgZnJvbSAgICAnLi9jb250cm9sbGVyL2Fici1jb250cm9sbGVyJztcbmltcG9ydCBCdWZmZXJDb250cm9sbGVyIGZyb20gICcuL2NvbnRyb2xsZXIvYnVmZmVyLWNvbnRyb2xsZXInO1xuaW1wb3J0IENhcExldmVsQ29udHJvbGxlciBmcm9tICAnLi9jb250cm9sbGVyL2NhcC1sZXZlbC1jb250cm9sbGVyJztcbmltcG9ydCBBdWRpb1N0cmVhbUNvbnRyb2xsZXIgZnJvbSAgJy4vY29udHJvbGxlci9hdWRpby1zdHJlYW0tY29udHJvbGxlcic7XG5pbXBvcnQgU3VidGl0bGVTdHJlYW1Db250cm9sbGVyIGZyb20gICcuL2NvbnRyb2xsZXIvc3VidGl0bGUtc3RyZWFtLWNvbnRyb2xsZXInO1xuaW1wb3J0IFN0cmVhbUNvbnRyb2xsZXIgZnJvbSAgJy4vY29udHJvbGxlci9zdHJlYW0tY29udHJvbGxlcic7XG5pbXBvcnQgTGV2ZWxDb250cm9sbGVyIGZyb20gICcuL2NvbnRyb2xsZXIvbGV2ZWwtY29udHJvbGxlcic7XG5pbXBvcnQgVGltZWxpbmVDb250cm9sbGVyIGZyb20gJy4vY29udHJvbGxlci90aW1lbGluZS1jb250cm9sbGVyJztcbmltcG9ydCBGUFNDb250cm9sbGVyIGZyb20gJy4vY29udHJvbGxlci9mcHMtY29udHJvbGxlcic7XG5pbXBvcnQgQXVkaW9UcmFja0NvbnRyb2xsZXIgZnJvbSAnLi9jb250cm9sbGVyL2F1ZGlvLXRyYWNrLWNvbnRyb2xsZXInO1xuaW1wb3J0IFN1YnRpdGxlVHJhY2tDb250cm9sbGVyIGZyb20gJy4vY29udHJvbGxlci9zdWJ0aXRsZS10cmFjay1jb250cm9sbGVyJztcbmltcG9ydCB7bG9nZ2VyLCBlbmFibGVMb2dzfSBmcm9tICcuL3V0aWxzL2xvZ2dlcic7XG4vL2ltcG9ydCBGZXRjaExvYWRlciBmcm9tICcuL3V0aWxzL2ZldGNoLWxvYWRlcic7XG5pbXBvcnQgWGhyTG9hZGVyIGZyb20gJy4vdXRpbHMveGhyLWxvYWRlcic7XG5pbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gJ2V2ZW50cyc7XG5pbXBvcnQgS2V5TG9hZGVyIGZyb20gJy4vbG9hZGVyL2tleS1sb2FkZXInO1xuaW1wb3J0IEN1ZXMgZnJvbSAnLi91dGlscy9jdWVzJztcblxuY2xhc3MgSGxzIHtcblxuICBzdGF0aWMgZ2V0IHZlcnNpb24oKSB7XG4gICAgLy8gcmVwbGFjZWQgd2l0aCBicm93c2VyaWZ5LXZlcnNpb25pZnkgdHJhbnNmb3JtXG4gICAgcmV0dXJuICdfX1ZFUlNJT05fXyc7XG4gIH1cblxuICBzdGF0aWMgaXNTdXBwb3J0ZWQoKSB7XG4gICAgd2luZG93Lk1lZGlhU291cmNlID0gd2luZG93Lk1lZGlhU291cmNlIHx8IHdpbmRvdy5XZWJLaXRNZWRpYVNvdXJjZTtcbiAgICByZXR1cm4gKHdpbmRvdy5NZWRpYVNvdXJjZSAmJlxuICAgICAgICAgICAgdHlwZW9mIHdpbmRvdy5NZWRpYVNvdXJjZS5pc1R5cGVTdXBwb3J0ZWQgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgICAgIHdpbmRvdy5NZWRpYVNvdXJjZS5pc1R5cGVTdXBwb3J0ZWQoJ3ZpZGVvL21wNDsgY29kZWNzPVwiYXZjMS40MkUwMUUsbXA0YS40MC4yXCInKSk7XG4gIH1cblxuICBzdGF0aWMgZ2V0IEV2ZW50cygpIHtcbiAgICByZXR1cm4gRXZlbnQ7XG4gIH1cblxuICBzdGF0aWMgZ2V0IEVycm9yVHlwZXMoKSB7XG4gICAgcmV0dXJuIEVycm9yVHlwZXM7XG4gIH1cblxuICBzdGF0aWMgZ2V0IEVycm9yRGV0YWlscygpIHtcbiAgICByZXR1cm4gRXJyb3JEZXRhaWxzO1xuICB9XG5cbiAgc3RhdGljIGdldCBEZWZhdWx0Q29uZmlnKCkge1xuICAgIGlmKCFIbHMuZGVmYXVsdENvbmZpZykge1xuICAgICAgIEhscy5kZWZhdWx0Q29uZmlnID0ge1xuICAgICAgICAgIGF1dG9TdGFydExvYWQ6IHRydWUsXG4gICAgICAgICAgc3RhcnRQb3NpdGlvbjogLTEsXG4gICAgICAgICAgZGVmYXVsdEF1ZGlvQ29kZWM6IHVuZGVmaW5lZCxcbiAgICAgICAgICBkZWJ1ZzogZmFsc2UsXG4gICAgICAgICAgY2FwTGV2ZWxPbkZQU0Ryb3A6IGZhbHNlLFxuICAgICAgICAgIGNhcExldmVsVG9QbGF5ZXJTaXplOiBmYWxzZSxcbiAgICAgICAgICBpbml0aWFsTGl2ZU1hbmlmZXN0U2l6ZTogMSxcbiAgICAgICAgICBtYXhCdWZmZXJMZW5ndGg6IDMwLFxuICAgICAgICAgIG1heEJ1ZmZlclNpemU6IDYwICogMTAwMCAqIDEwMDAsXG4gICAgICAgICAgbWF4QnVmZmVySG9sZTogMC41LFxuICAgICAgICAgIG1heFNlZWtIb2xlOiAyLFxuICAgICAgICAgIHNlZWtIb2xlTnVkZ2VEdXJhdGlvbjogMC4wMSxcbiAgICAgICAgICBzdGFsbGVkSW5CdWZmZXJlZE51ZGdlVGhyZXNob2xkOiAxMCxcbiAgICAgICAgICBtYXhGcmFnTG9va1VwVG9sZXJhbmNlOiAwLjIsXG4gICAgICAgICAgbGl2ZVN5bmNEdXJhdGlvbkNvdW50OjMsXG4gICAgICAgICAgbGl2ZU1heExhdGVuY3lEdXJhdGlvbkNvdW50OiBJbmZpbml0eSxcbiAgICAgICAgICBsaXZlU3luY0R1cmF0aW9uOiB1bmRlZmluZWQsXG4gICAgICAgICAgbGl2ZU1heExhdGVuY3lEdXJhdGlvbjogdW5kZWZpbmVkLFxuICAgICAgICAgIG1heE1heEJ1ZmZlckxlbmd0aDogNjAwLFxuICAgICAgICAgIGVuYWJsZVdvcmtlcjogdHJ1ZSxcbiAgICAgICAgICBlbmFibGVTb2Z0d2FyZUFFUzogdHJ1ZSxcbiAgICAgICAgICBtYW5pZmVzdExvYWRpbmdUaW1lT3V0OiAxMDAwMCxcbiAgICAgICAgICBtYW5pZmVzdExvYWRpbmdNYXhSZXRyeTogMSxcbiAgICAgICAgICBtYW5pZmVzdExvYWRpbmdSZXRyeURlbGF5OiAxMDAwLFxuICAgICAgICAgIG1hbmlmZXN0TG9hZGluZ01heFJldHJ5VGltZW91dDogNjQwMDAsXG4gICAgICAgICAgc3RhcnRMZXZlbDogdW5kZWZpbmVkLFxuICAgICAgICAgIGxldmVsTG9hZGluZ1RpbWVPdXQ6IDEwMDAwLFxuICAgICAgICAgIGxldmVsTG9hZGluZ01heFJldHJ5OiA0LFxuICAgICAgICAgIGxldmVsTG9hZGluZ1JldHJ5RGVsYXk6IDEwMDAsXG4gICAgICAgICAgbGV2ZWxMb2FkaW5nTWF4UmV0cnlUaW1lb3V0OiA2NDAwMCxcbiAgICAgICAgICBmcmFnTG9hZGluZ1RpbWVPdXQ6IDIwMDAwLFxuICAgICAgICAgIGZyYWdMb2FkaW5nTWF4UmV0cnk6IDYsXG4gICAgICAgICAgZnJhZ0xvYWRpbmdSZXRyeURlbGF5OiAxMDAwLFxuICAgICAgICAgIGZyYWdMb2FkaW5nTWF4UmV0cnlUaW1lb3V0OiA2NDAwMCxcbiAgICAgICAgICBmcmFnTG9hZGluZ0xvb3BUaHJlc2hvbGQ6IDMsXG4gICAgICAgICAgc3RhcnRGcmFnUHJlZmV0Y2g6IGZhbHNlLFxuICAgICAgICAgIGZwc0Ryb3BwZWRNb25pdG9yaW5nUGVyaW9kOiA1MDAwLFxuICAgICAgICAgIGZwc0Ryb3BwZWRNb25pdG9yaW5nVGhyZXNob2xkOiAwLjIsXG4gICAgICAgICAgYXBwZW5kRXJyb3JNYXhSZXRyeTogMyxcbiAgICAgICAgICBsb2FkZXI6IFhockxvYWRlcixcbiAgICAgICAgICAvL2xvYWRlcjogRmV0Y2hMb2FkZXIsXG4gICAgICAgICAgZkxvYWRlcjogdW5kZWZpbmVkLFxuICAgICAgICAgIHBMb2FkZXI6IHVuZGVmaW5lZCxcbiAgICAgICAgICB4aHJTZXR1cDogdW5kZWZpbmVkLFxuICAgICAgICAgIGZldGNoU2V0dXA6IHVuZGVmaW5lZCxcbiAgICAgICAgICBhYnJDb250cm9sbGVyOiBBYnJDb250cm9sbGVyLFxuICAgICAgICAgIGJ1ZmZlckNvbnRyb2xsZXI6IEJ1ZmZlckNvbnRyb2xsZXIsXG4gICAgICAgICAgY2FwTGV2ZWxDb250cm9sbGVyOiBDYXBMZXZlbENvbnRyb2xsZXIsXG4gICAgICAgICAgZnBzQ29udHJvbGxlcjogRlBTQ29udHJvbGxlcixcbiAgICAgICAgICBzdHJlYW1Db250cm9sbGVyOiBTdHJlYW1Db250cm9sbGVyLFxuICAgICAgICAgIGF1ZGlvU3RyZWFtQ29udHJvbGxlcjogQXVkaW9TdHJlYW1Db250cm9sbGVyLFxuICAgICAgICAgIHN1YnRpdGxlU3RyZWFtQ29udHJvbGxlcjogU3VidGl0bGVTdHJlYW1Db250cm9sbGVyLFxuICAgICAgICAgIHRpbWVsaW5lQ29udHJvbGxlcjogVGltZWxpbmVDb250cm9sbGVyLFxuICAgICAgICAgIGN1ZUhhbmRsZXI6IEN1ZXMsXG4gICAgICAgICAgZW5hYmxlQ0VBNzA4Q2FwdGlvbnM6IHRydWUsXG4gICAgICAgICAgZW5hYmxlV2ViVlRUOiB0cnVlLFxuICAgICAgICAgIGVuYWJsZU1QMlRQYXNzVGhyb3VnaDogZmFsc2UsXG4gICAgICAgICAgc3RyZXRjaFNob3J0VmlkZW9UcmFjazogZmFsc2UsXG4gICAgICAgICAgZm9yY2VLZXlGcmFtZU9uRGlzY29udGludWl0eTogdHJ1ZSxcbiAgICAgICAgICBhYnJFd21hRmFzdExpdmU6IDMsXG4gICAgICAgICAgYWJyRXdtYVNsb3dMaXZlOiA5LFxuICAgICAgICAgIGFickV3bWFGYXN0Vm9EOiAzLFxuICAgICAgICAgIGFickV3bWFTbG93Vm9EOiA5LFxuICAgICAgICAgIGFickV3bWFEZWZhdWx0RXN0aW1hdGU6IDVlNSwgLy8gNTAwIGticHNcbiAgICAgICAgICBhYnJCYW5kV2lkdGhGYWN0b3IgOiAwLjk1LFxuICAgICAgICAgIGFickJhbmRXaWR0aFVwRmFjdG9yIDogMC43LFxuICAgICAgICAgIG1heFN0YXJ2YXRpb25EZWxheSA6IDQsXG4gICAgICAgICAgbWF4TG9hZGluZ0RlbGF5IDogNCxcbiAgICAgICAgICBtaW5BdXRvQml0cmF0ZTogMFxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gSGxzLmRlZmF1bHRDb25maWc7XG4gIH1cblxuICBzdGF0aWMgc2V0IERlZmF1bHRDb25maWcoZGVmYXVsdENvbmZpZykge1xuICAgIEhscy5kZWZhdWx0Q29uZmlnID0gZGVmYXVsdENvbmZpZztcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKGNvbmZpZyA9IHt9KSB7XG4gICAgdmFyIGRlZmF1bHRDb25maWcgPSBIbHMuRGVmYXVsdENvbmZpZztcblxuICAgIGlmICgoY29uZmlnLmxpdmVTeW5jRHVyYXRpb25Db3VudCB8fCBjb25maWcubGl2ZU1heExhdGVuY3lEdXJhdGlvbkNvdW50KSAmJiAoY29uZmlnLmxpdmVTeW5jRHVyYXRpb24gfHwgY29uZmlnLmxpdmVNYXhMYXRlbmN5RHVyYXRpb24pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lsbGVnYWwgaGxzLmpzIGNvbmZpZzogZG9uXFwndCBtaXggdXAgbGl2ZVN5bmNEdXJhdGlvbkNvdW50L2xpdmVNYXhMYXRlbmN5RHVyYXRpb25Db3VudCBhbmQgbGl2ZVN5bmNEdXJhdGlvbi9saXZlTWF4TGF0ZW5jeUR1cmF0aW9uJyk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgcHJvcCBpbiBkZWZhdWx0Q29uZmlnKSB7XG4gICAgICAgIGlmIChwcm9wIGluIGNvbmZpZykgeyBjb250aW51ZTsgfVxuICAgICAgICBjb25maWdbcHJvcF0gPSBkZWZhdWx0Q29uZmlnW3Byb3BdO1xuICAgIH1cblxuICAgIGlmIChjb25maWcubGl2ZU1heExhdGVuY3lEdXJhdGlvbkNvdW50ICE9PSB1bmRlZmluZWQgJiYgY29uZmlnLmxpdmVNYXhMYXRlbmN5RHVyYXRpb25Db3VudCA8PSBjb25maWcubGl2ZVN5bmNEdXJhdGlvbkNvdW50KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lsbGVnYWwgaGxzLmpzIGNvbmZpZzogXCJsaXZlTWF4TGF0ZW5jeUR1cmF0aW9uQ291bnRcIiBtdXN0IGJlIGd0IFwibGl2ZVN5bmNEdXJhdGlvbkNvdW50XCInKTtcbiAgICB9XG5cbiAgICBpZiAoY29uZmlnLmxpdmVNYXhMYXRlbmN5RHVyYXRpb24gIT09IHVuZGVmaW5lZCAmJiAoY29uZmlnLmxpdmVNYXhMYXRlbmN5RHVyYXRpb24gPD0gY29uZmlnLmxpdmVTeW5jRHVyYXRpb24gfHwgY29uZmlnLmxpdmVTeW5jRHVyYXRpb24gPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSWxsZWdhbCBobHMuanMgY29uZmlnOiBcImxpdmVNYXhMYXRlbmN5RHVyYXRpb25cIiBtdXN0IGJlIGd0IFwibGl2ZVN5bmNEdXJhdGlvblwiJyk7XG4gICAgfVxuXG4gICAgZW5hYmxlTG9ncyhjb25maWcuZGVidWcpO1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgIC8vIG9ic2VydmVyIHNldHVwXG4gICAgdmFyIG9ic2VydmVyID0gdGhpcy5vYnNlcnZlciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICBvYnNlcnZlci50cmlnZ2VyID0gZnVuY3Rpb24gdHJpZ2dlciAoZXZlbnQsIC4uLmRhdGEpIHtcbiAgICAgIG9ic2VydmVyLmVtaXQoZXZlbnQsIGV2ZW50LCAuLi5kYXRhKTtcbiAgICB9O1xuXG4gICAgb2JzZXJ2ZXIub2ZmID0gZnVuY3Rpb24gb2ZmIChldmVudCwgLi4uZGF0YSkge1xuICAgICAgb2JzZXJ2ZXIucmVtb3ZlTGlzdGVuZXIoZXZlbnQsIC4uLmRhdGEpO1xuICAgIH07XG4gICAgdGhpcy5vbiA9IG9ic2VydmVyLm9uLmJpbmQob2JzZXJ2ZXIpO1xuICAgIHRoaXMub2ZmID0gb2JzZXJ2ZXIub2ZmLmJpbmQob2JzZXJ2ZXIpO1xuICAgIHRoaXMudHJpZ2dlciA9IG9ic2VydmVyLnRyaWdnZXIuYmluZChvYnNlcnZlcik7XG4gICAgdGhpcy5wbGF5bGlzdExvYWRlciA9IG5ldyBQbGF5bGlzdExvYWRlcih0aGlzKTtcbiAgICB0aGlzLmZyYWdtZW50TG9hZGVyID0gbmV3IEZyYWdtZW50TG9hZGVyKHRoaXMpO1xuICAgIHRoaXMubGV2ZWxDb250cm9sbGVyID0gbmV3IExldmVsQ29udHJvbGxlcih0aGlzKTtcbiAgICB0aGlzLmFickNvbnRyb2xsZXIgPSBuZXcgY29uZmlnLmFickNvbnRyb2xsZXIodGhpcyk7XG4gICAgdGhpcy5idWZmZXJDb250cm9sbGVyID0gbmV3IGNvbmZpZy5idWZmZXJDb250cm9sbGVyKHRoaXMpO1xuICAgIHRoaXMuY2FwTGV2ZWxDb250cm9sbGVyID0gbmV3IGNvbmZpZy5jYXBMZXZlbENvbnRyb2xsZXIodGhpcyk7XG4gICAgdGhpcy5mcHNDb250cm9sbGVyID0gbmV3IGNvbmZpZy5mcHNDb250cm9sbGVyKHRoaXMpO1xuICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlciA9IG5ldyBjb25maWcuc3RyZWFtQ29udHJvbGxlcih0aGlzKTtcbiAgICB0aGlzLmF1ZGlvU3RyZWFtQ29udHJvbGxlciA9IG5ldyBjb25maWcuYXVkaW9TdHJlYW1Db250cm9sbGVyKHRoaXMpO1xuICAgIHRoaXMuc3VidGl0bGVTdHJlYW1Db250cm9sbGVyID0gbmV3IGNvbmZpZy5zdWJ0aXRsZVN0cmVhbUNvbnRyb2xsZXIodGhpcyk7XG4gICAgdGhpcy50aW1lbGluZUNvbnRyb2xsZXIgPSBuZXcgY29uZmlnLnRpbWVsaW5lQ29udHJvbGxlcih0aGlzKTtcbiAgICB0aGlzLmF1ZGlvVHJhY2tDb250cm9sbGVyID0gbmV3IEF1ZGlvVHJhY2tDb250cm9sbGVyKHRoaXMpO1xuICAgIHRoaXMuc3VidGl0bGVUcmFja0NvbnRyb2xsZXIgPSBuZXcgU3VidGl0bGVUcmFja0NvbnRyb2xsZXIodGhpcyk7XG4gICAgdGhpcy5rZXlMb2FkZXIgPSBuZXcgS2V5TG9hZGVyKHRoaXMpO1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICBsb2dnZXIubG9nKCdkZXN0cm95Jyk7XG4gICAgdGhpcy50cmlnZ2VyKEV2ZW50LkRFU1RST1lJTkcpO1xuICAgIHRoaXMuZGV0YWNoTWVkaWEoKTtcbiAgICB0aGlzLnBsYXlsaXN0TG9hZGVyLmRlc3Ryb3koKTtcbiAgICB0aGlzLmZyYWdtZW50TG9hZGVyLmRlc3Ryb3koKTtcbiAgICB0aGlzLmxldmVsQ29udHJvbGxlci5kZXN0cm95KCk7XG4gICAgdGhpcy5hYnJDb250cm9sbGVyLmRlc3Ryb3koKTtcbiAgICB0aGlzLmJ1ZmZlckNvbnRyb2xsZXIuZGVzdHJveSgpO1xuICAgIHRoaXMuY2FwTGV2ZWxDb250cm9sbGVyLmRlc3Ryb3koKTtcbiAgICB0aGlzLmZwc0NvbnRyb2xsZXIuZGVzdHJveSgpO1xuICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlci5kZXN0cm95KCk7XG4gICAgdGhpcy5hdWRpb1N0cmVhbUNvbnRyb2xsZXIuZGVzdHJveSgpO1xuICAgIHRoaXMuc3VidGl0bGVTdHJlYW1Db250cm9sbGVyLmRlc3Ryb3koKTtcbiAgICB0aGlzLnRpbWVsaW5lQ29udHJvbGxlci5kZXN0cm95KCk7XG4gICAgdGhpcy5hdWRpb1RyYWNrQ29udHJvbGxlci5kZXN0cm95KCk7XG4gICAgdGhpcy5zdWJ0aXRsZVRyYWNrQ29udHJvbGxlci5kZXN0cm95KCk7XG4gICAgdGhpcy5rZXlMb2FkZXIuZGVzdHJveSgpO1xuICAgIHRoaXMudXJsID0gbnVsbDtcbiAgICB0aGlzLm9ic2VydmVyLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICB9XG5cbiAgYXR0YWNoTWVkaWEobWVkaWEpIHtcbiAgICBsb2dnZXIubG9nKCdhdHRhY2hNZWRpYScpO1xuICAgIHRoaXMubWVkaWEgPSBtZWRpYTtcbiAgICB0aGlzLnRyaWdnZXIoRXZlbnQuTUVESUFfQVRUQUNISU5HLCB7bWVkaWE6IG1lZGlhfSk7XG4gIH1cblxuICBkZXRhY2hNZWRpYSgpIHtcbiAgICBsb2dnZXIubG9nKCdkZXRhY2hNZWRpYScpO1xuICAgIHRoaXMudHJpZ2dlcihFdmVudC5NRURJQV9ERVRBQ0hJTkcpO1xuICAgIHRoaXMubWVkaWEgPSBudWxsO1xuICB9XG5cbiAgbG9hZFNvdXJjZSh1cmwpIHtcbiAgICBsb2dnZXIubG9nKGBsb2FkU291cmNlOiR7dXJsfWApO1xuICAgIHRoaXMudXJsID0gdXJsO1xuICAgIC8vIHdoZW4gYXR0YWNoaW5nIHRvIGEgc291cmNlIFVSTCwgdHJpZ2dlciBhIHBsYXlsaXN0IGxvYWRcbiAgICB0aGlzLnRyaWdnZXIoRXZlbnQuTUFOSUZFU1RfTE9BRElORywge3VybDogdXJsfSk7XG4gIH1cblxuICBzdGFydExvYWQoc3RhcnRQb3NpdGlvbj0tMSkge1xuICAgIGxvZ2dlci5sb2coYHN0YXJ0TG9hZCgke3N0YXJ0UG9zaXRpb259KWApO1xuICAgIHRoaXMubGV2ZWxDb250cm9sbGVyLnN0YXJ0TG9hZCgpO1xuICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlci5zdGFydExvYWQoc3RhcnRQb3NpdGlvbik7XG4gICAgdGhpcy5hdWRpb1N0cmVhbUNvbnRyb2xsZXIuc3RhcnRMb2FkKHN0YXJ0UG9zaXRpb24pO1xuICB9XG5cbiAgc3RvcExvYWQoKSB7XG4gICAgbG9nZ2VyLmxvZygnc3RvcExvYWQnKTtcbiAgICB0aGlzLmxldmVsQ29udHJvbGxlci5zdG9wTG9hZCgpO1xuICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlci5zdG9wTG9hZCgpO1xuICAgIHRoaXMuYXVkaW9TdHJlYW1Db250cm9sbGVyLnN0b3BMb2FkKCk7XG4gIH1cblxuICBzd2FwQXVkaW9Db2RlYygpIHtcbiAgICBsb2dnZXIubG9nKCdzd2FwQXVkaW9Db2RlYycpO1xuICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlci5zd2FwQXVkaW9Db2RlYygpO1xuICB9XG5cbiAgcmVjb3Zlck1lZGlhRXJyb3IoKSB7XG4gICAgbG9nZ2VyLmxvZygncmVjb3Zlck1lZGlhRXJyb3InKTtcbiAgICB2YXIgbWVkaWEgPSB0aGlzLm1lZGlhO1xuICAgIHRoaXMuZGV0YWNoTWVkaWEoKTtcbiAgICB0aGlzLmF0dGFjaE1lZGlhKG1lZGlhKTtcbiAgfVxuXG4gIHVwZGF0ZVNpemUoKSB7XG4gICAgbG9nZ2VyLmxvZygndXBkYXRlU2l6ZScpO1xuICAgIGlmICh0aGlzLmNvbmZpZy5jYXBMZXZlbFRvUGxheWVyU2l6ZSkge1xuICAgICAgdGhpcy5jYXBMZXZlbENvbnRyb2xsZXIuZGV0ZWN0UGxheWVyU2l6ZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBSZXR1cm4gYWxsIHF1YWxpdHkgbGV2ZWxzICoqL1xuICBnZXQgbGV2ZWxzKCkge1xuICAgIHJldHVybiB0aGlzLmxldmVsQ29udHJvbGxlci5sZXZlbHM7XG4gIH1cblxuICAvKiogUmV0dXJuIGN1cnJlbnQgcGxheWJhY2sgcXVhbGl0eSBsZXZlbCAqKi9cbiAgZ2V0IGN1cnJlbnRMZXZlbCgpIHtcbiAgICByZXR1cm4gdGhpcy5zdHJlYW1Db250cm9sbGVyLmN1cnJlbnRMZXZlbDtcbiAgfVxuXG4gIC8qIHNldCBxdWFsaXR5IGxldmVsIGltbWVkaWF0ZWx5ICgtMSBmb3IgYXV0b21hdGljIGxldmVsIHNlbGVjdGlvbikgKi9cbiAgc2V0IGN1cnJlbnRMZXZlbChuZXdMZXZlbCkge1xuICAgIGxvZ2dlci5sb2coYHNldCBjdXJyZW50TGV2ZWw6JHtuZXdMZXZlbH1gKTtcbiAgICB0aGlzLmxvYWRMZXZlbCA9IG5ld0xldmVsO1xuICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlci5pbW1lZGlhdGVMZXZlbFN3aXRjaCgpO1xuICB9XG5cbiAgLyoqIFJldHVybiBuZXh0IHBsYXliYWNrIHF1YWxpdHkgbGV2ZWwgKHF1YWxpdHkgbGV2ZWwgb2YgbmV4dCBmcmFnbWVudCkgKiovXG4gIGdldCBuZXh0TGV2ZWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RyZWFtQ29udHJvbGxlci5uZXh0TGV2ZWw7XG4gIH1cblxuICAvKiBzZXQgcXVhbGl0eSBsZXZlbCBmb3IgbmV4dCBmcmFnbWVudCAoLTEgZm9yIGF1dG9tYXRpYyBsZXZlbCBzZWxlY3Rpb24pICovXG4gIHNldCBuZXh0TGV2ZWwobmV3TGV2ZWwpIHtcbiAgICBsb2dnZXIubG9nKGBzZXQgbmV4dExldmVsOiR7bmV3TGV2ZWx9YCk7XG4gICAgdGhpcy5sZXZlbENvbnRyb2xsZXIubWFudWFsTGV2ZWwgPSBuZXdMZXZlbDtcbiAgICB0aGlzLnN0cmVhbUNvbnRyb2xsZXIubmV4dExldmVsU3dpdGNoKCk7XG4gIH1cblxuICAvKiogUmV0dXJuIHRoZSBxdWFsaXR5IGxldmVsIG9mIGN1cnJlbnQvbGFzdCBsb2FkZWQgZnJhZ21lbnQgKiovXG4gIGdldCBsb2FkTGV2ZWwoKSB7XG4gICAgcmV0dXJuIHRoaXMubGV2ZWxDb250cm9sbGVyLmxldmVsO1xuICB9XG5cbiAgLyogc2V0IHF1YWxpdHkgbGV2ZWwgZm9yIGN1cnJlbnQvbmV4dCBsb2FkZWQgZnJhZ21lbnQgKC0xIGZvciBhdXRvbWF0aWMgbGV2ZWwgc2VsZWN0aW9uKSAqL1xuICBzZXQgbG9hZExldmVsKG5ld0xldmVsKSB7XG4gICAgbG9nZ2VyLmxvZyhgc2V0IGxvYWRMZXZlbDoke25ld0xldmVsfWApO1xuICAgIHRoaXMubGV2ZWxDb250cm9sbGVyLm1hbnVhbExldmVsID0gbmV3TGV2ZWw7XG4gIH1cblxuICAvKiogUmV0dXJuIHRoZSBxdWFsaXR5IGxldmVsIG9mIG5leHQgbG9hZGVkIGZyYWdtZW50ICoqL1xuICBnZXQgbmV4dExvYWRMZXZlbCgpIHtcbiAgICByZXR1cm4gdGhpcy5sZXZlbENvbnRyb2xsZXIubmV4dExvYWRMZXZlbDtcbiAgfVxuXG4gIC8qKiBzZXQgcXVhbGl0eSBsZXZlbCBvZiBuZXh0IGxvYWRlZCBmcmFnbWVudCAqKi9cbiAgc2V0IG5leHRMb2FkTGV2ZWwobGV2ZWwpIHtcbiAgICB0aGlzLmxldmVsQ29udHJvbGxlci5uZXh0TG9hZExldmVsID0gbGV2ZWw7XG4gIH1cblxuICAvKiogUmV0dXJuIGZpcnN0IGxldmVsIChpbmRleCBvZiBmaXJzdCBsZXZlbCByZWZlcmVuY2VkIGluIG1hbmlmZXN0KVxuICAqKi9cbiAgZ2V0IGZpcnN0TGV2ZWwoKSB7XG4gICAgcmV0dXJuIE1hdGgubWF4KHRoaXMubGV2ZWxDb250cm9sbGVyLmZpcnN0TGV2ZWwsIHRoaXMuYWJyQ29udHJvbGxlci5taW5BdXRvTGV2ZWwpO1xuICB9XG5cbiAgLyoqIHNldCBmaXJzdCBsZXZlbCAoaW5kZXggb2YgZmlyc3QgbGV2ZWwgcmVmZXJlbmNlZCBpbiBtYW5pZmVzdClcbiAgKiovXG4gIHNldCBmaXJzdExldmVsKG5ld0xldmVsKSB7XG4gICAgbG9nZ2VyLmxvZyhgc2V0IGZpcnN0TGV2ZWw6JHtuZXdMZXZlbH1gKTtcbiAgICB0aGlzLmxldmVsQ29udHJvbGxlci5maXJzdExldmVsID0gbmV3TGV2ZWw7XG4gIH1cblxuICAvKiogUmV0dXJuIHN0YXJ0IGxldmVsIChsZXZlbCBvZiBmaXJzdCBmcmFnbWVudCB0aGF0IHdpbGwgYmUgcGxheWVkIGJhY2spXG4gICAgICBpZiBub3Qgb3ZlcnJpZGVkIGJ5IHVzZXIsIGZpcnN0IGxldmVsIGFwcGVhcmluZyBpbiBtYW5pZmVzdCB3aWxsIGJlIHVzZWQgYXMgc3RhcnQgbGV2ZWxcbiAgICAgIGlmIC0xIDogYXV0b21hdGljIHN0YXJ0IGxldmVsIHNlbGVjdGlvbiwgcGxheWJhY2sgd2lsbCBzdGFydCBmcm9tIGxldmVsIG1hdGNoaW5nIGRvd25sb2FkIGJhbmR3aWR0aCAoZGV0ZXJtaW5lZCBmcm9tIGRvd25sb2FkIG9mIGZpcnN0IHNlZ21lbnQpXG4gICoqL1xuICBnZXQgc3RhcnRMZXZlbCgpIHtcbiAgICByZXR1cm4gdGhpcy5sZXZlbENvbnRyb2xsZXIuc3RhcnRMZXZlbDtcbiAgfVxuXG4gIC8qKiBzZXQgIHN0YXJ0IGxldmVsIChsZXZlbCBvZiBmaXJzdCBmcmFnbWVudCB0aGF0IHdpbGwgYmUgcGxheWVkIGJhY2spXG4gICAgICBpZiBub3Qgb3ZlcnJpZGVkIGJ5IHVzZXIsIGZpcnN0IGxldmVsIGFwcGVhcmluZyBpbiBtYW5pZmVzdCB3aWxsIGJlIHVzZWQgYXMgc3RhcnQgbGV2ZWxcbiAgICAgIGlmIC0xIDogYXV0b21hdGljIHN0YXJ0IGxldmVsIHNlbGVjdGlvbiwgcGxheWJhY2sgd2lsbCBzdGFydCBmcm9tIGxldmVsIG1hdGNoaW5nIGRvd25sb2FkIGJhbmR3aWR0aCAoZGV0ZXJtaW5lZCBmcm9tIGRvd25sb2FkIG9mIGZpcnN0IHNlZ21lbnQpXG4gICoqL1xuICBzZXQgc3RhcnRMZXZlbChuZXdMZXZlbCkge1xuICAgIGxvZ2dlci5sb2coYHNldCBzdGFydExldmVsOiR7bmV3TGV2ZWx9YCk7XG4gICAgdGhpcy5sZXZlbENvbnRyb2xsZXIuc3RhcnRMZXZlbCA9IG5ld0xldmVsO1xuICB9XG5cbiAgLyoqIFJldHVybiB0aGUgY2FwcGluZy9tYXggbGV2ZWwgdmFsdWUgdGhhdCBjb3VsZCBiZSB1c2VkIGJ5IGF1dG9tYXRpYyBsZXZlbCBzZWxlY3Rpb24gYWxnb3JpdGhtICoqL1xuICBnZXQgYXV0b0xldmVsQ2FwcGluZygpIHtcbiAgICByZXR1cm4gdGhpcy5hYnJDb250cm9sbGVyLmF1dG9MZXZlbENhcHBpbmc7XG4gIH1cblxuICAvKiogc2V0IHRoZSBjYXBwaW5nL21heCBsZXZlbCB2YWx1ZSB0aGF0IGNvdWxkIGJlIHVzZWQgYnkgYXV0b21hdGljIGxldmVsIHNlbGVjdGlvbiBhbGdvcml0aG0gKiovXG4gIHNldCBhdXRvTGV2ZWxDYXBwaW5nKG5ld0xldmVsKSB7XG4gICAgbG9nZ2VyLmxvZyhgc2V0IGF1dG9MZXZlbENhcHBpbmc6JHtuZXdMZXZlbH1gKTtcbiAgICB0aGlzLmFickNvbnRyb2xsZXIuYXV0b0xldmVsQ2FwcGluZyA9IG5ld0xldmVsO1xuICB9XG5cbiAgLyogY2hlY2sgaWYgd2UgYXJlIGluIGF1dG9tYXRpYyBsZXZlbCBzZWxlY3Rpb24gbW9kZSAqL1xuICBnZXQgYXV0b0xldmVsRW5hYmxlZCgpIHtcbiAgICByZXR1cm4gKHRoaXMubGV2ZWxDb250cm9sbGVyLm1hbnVhbExldmVsID09PSAtMSk7XG4gIH1cblxuICAvKiByZXR1cm4gbWFudWFsIGxldmVsICovXG4gIGdldCBtYW51YWxMZXZlbCgpIHtcbiAgICByZXR1cm4gdGhpcy5sZXZlbENvbnRyb2xsZXIubWFudWFsTGV2ZWw7XG4gIH1cblxuICAvKiogZ2V0IGFsdGVybmF0ZSBhdWRpbyB0cmFja3MgbGlzdCBmcm9tIHBsYXlsaXN0ICoqL1xuICBnZXQgYXVkaW9UcmFja3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXVkaW9UcmFja0NvbnRyb2xsZXIuYXVkaW9UcmFja3M7XG4gIH1cblxuICAvKiogZ2V0IGluZGV4IG9mIHRoZSBzZWxlY3RlZCBhdWRpbyB0cmFjayAoaW5kZXggaW4gYXVkaW8gdHJhY2sgbGlzdHMpICoqL1xuICBnZXQgYXVkaW9UcmFjaygpIHtcbiAgIHJldHVybiB0aGlzLmF1ZGlvVHJhY2tDb250cm9sbGVyLmF1ZGlvVHJhY2s7XG4gIH1cblxuICAvKiogc2VsZWN0IGFuIGF1ZGlvIHRyYWNrLCBiYXNlZCBvbiBpdHMgaW5kZXggaW4gYXVkaW8gdHJhY2sgbGlzdHMqKi9cbiAgc2V0IGF1ZGlvVHJhY2soYXVkaW9UcmFja0lkKSB7XG4gICAgdGhpcy5hdWRpb1RyYWNrQ29udHJvbGxlci5hdWRpb1RyYWNrID0gYXVkaW9UcmFja0lkO1xuICB9XG5cbiAgZ2V0IGxpdmVTeW5jUG9zaXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RyZWFtQ29udHJvbGxlci5saXZlU3luY1Bvc2l0aW9uO1xuICB9XG5cbiAgLyoqIGdldCBhbHRlcm5hdGUgc3VidGl0bGUgdHJhY2tzIGxpc3QgZnJvbSBwbGF5bGlzdCAqKi9cbiAgZ2V0IHN1YnRpdGxlVHJhY2tzKCkge1xuICAgIHJldHVybiB0aGlzLnN1YnRpdGxlVHJhY2tDb250cm9sbGVyLnN1YnRpdGxlVHJhY2tzO1xuICB9XG5cbiAgLyoqIGdldCBpbmRleCBvZiB0aGUgc2VsZWN0ZWQgc3VidGl0bGUgdHJhY2sgKGluZGV4IGluIHN1YnRpdGxlIHRyYWNrIGxpc3RzKSAqKi9cbiAgZ2V0IHN1YnRpdGxlVHJhY2soKSB7XG4gICByZXR1cm4gdGhpcy5zdWJ0aXRsZVRyYWNrQ29udHJvbGxlci5zdWJ0aXRsZVRyYWNrO1xuICB9XG5cbiAgLyoqIHNlbGVjdCBhbiBzdWJ0aXRsZSB0cmFjaywgYmFzZWQgb24gaXRzIGluZGV4IGluIHN1YnRpdGxlIHRyYWNrIGxpc3RzKiovXG4gIHNldCBzdWJ0aXRsZVRyYWNrKHN1YnRpdGxlVHJhY2tJZCkge1xuICAgIHRoaXMuc3VidGl0bGVUcmFja0NvbnRyb2xsZXIuc3VidGl0bGVUcmFjayA9IHN1YnRpdGxlVHJhY2tJZDtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBIbHM7XG4iLCIvLyBUaGlzIGlzIG1vc3RseSBmb3Igc3VwcG9ydCBvZiB0aGUgZXM2IG1vZHVsZSBleHBvcnRcbi8vIHN5bnRheCB3aXRoIHRoZSBiYWJlbCBjb21waWxlciwgaXQgbG9va3MgbGlrZSBpdCBkb2VzbnQgc3VwcG9ydFxuLy8gZnVuY3Rpb24gZXhwb3J0cyBsaWtlIHdlIGFyZSB1c2VkIHRvIGluIG5vZGUvY29tbW9uanNcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9obHMuanMnKS5kZWZhdWx0O1xuIiwiLypcbiAqIEZyYWdtZW50IExvYWRlclxuKi9cblxuaW1wb3J0IEV2ZW50IGZyb20gJy4uL2V2ZW50cyc7XG5pbXBvcnQgRXZlbnRIYW5kbGVyIGZyb20gJy4uL2V2ZW50LWhhbmRsZXInO1xuaW1wb3J0IHtFcnJvclR5cGVzLCBFcnJvckRldGFpbHN9IGZyb20gJy4uL2Vycm9ycyc7XG5pbXBvcnQge2xvZ2dlcn0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcblxuY2xhc3MgRnJhZ21lbnRMb2FkZXIgZXh0ZW5kcyBFdmVudEhhbmRsZXIge1xuXG4gIGNvbnN0cnVjdG9yKGhscykge1xuICAgIHN1cGVyKGhscywgRXZlbnQuRlJBR19MT0FESU5HKTtcbiAgICB0aGlzLmxvYWRlcnMgPSB7fTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgbGV0IGxvYWRlcnMgPSB0aGlzLmxvYWRlcnM7XG4gICAgZm9yIChsZXQgbG9hZGVyTmFtZSBpbiBsb2FkZXJzKSB7XG4gICAgICBsZXQgbG9hZGVyID0gbG9hZGVyc1tsb2FkZXJOYW1lXTtcbiAgICAgIGlmIChsb2FkZXIpIHtcbiAgICAgICAgbG9hZGVyLmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5sb2FkZXJzID0ge307XG4gICAgRXZlbnRIYW5kbGVyLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XG4gIH1cblxuICBvbkZyYWdMb2FkaW5nKGRhdGEpIHtcbiAgICBsZXQgZnJhZyA9IGRhdGEuZnJhZyxcbiAgICAgICAgdHlwZSA9IGZyYWcudHlwZSxcbiAgICAgICAgbG9hZGVyID0gdGhpcy5sb2FkZXJzW3R5cGVdLFxuICAgICAgICBjb25maWcgPSB0aGlzLmhscy5jb25maWc7XG5cbiAgICBmcmFnLmxvYWRlZCA9IDA7XG4gICAgaWYgKGxvYWRlcikge1xuICAgICAgbG9nZ2VyLndhcm4oYGFib3J0IHByZXZpb3VzIGZyYWdtZW50IGxvYWRlciBmb3IgdHlwZToke3R5cGV9YCk7XG4gICAgICBsb2FkZXIuYWJvcnQoKTtcbiAgICB9XG4gICAgbG9hZGVyICA9IHRoaXMubG9hZGVyc1t0eXBlXSA9IGZyYWcubG9hZGVyID0gdHlwZW9mKGNvbmZpZy5mTG9hZGVyKSAhPT0gJ3VuZGVmaW5lZCcgPyBuZXcgY29uZmlnLmZMb2FkZXIoY29uZmlnKSA6IG5ldyBjb25maWcubG9hZGVyKGNvbmZpZyk7XG5cbiAgICBsZXQgbG9hZGVyQ29udGV4dCwgbG9hZGVyQ29uZmlnLCBsb2FkZXJDYWxsYmFja3M7XG4gICAgbG9hZGVyQ29udGV4dCA9IHsgdXJsIDogZnJhZy51cmwsIGZyYWcgOiBmcmFnLCByZXNwb25zZVR5cGUgOiAnYXJyYXlidWZmZXInLCBwcm9ncmVzc0RhdGEgOiBmYWxzZX07XG4gICAgbGV0IHN0YXJ0ID0gZnJhZy5ieXRlUmFuZ2VTdGFydE9mZnNldCwgZW5kID0gZnJhZy5ieXRlUmFuZ2VFbmRPZmZzZXQ7XG4gICAgaWYgKCFpc05hTihzdGFydCkgJiYgIWlzTmFOKGVuZCkpIHtcbiAgICAgIGxvYWRlckNvbnRleHQucmFuZ2VTdGFydCA9IHN0YXJ0O1xuICAgICAgbG9hZGVyQ29udGV4dC5yYW5nZUVuZCA9IGVuZDtcbiAgICB9XG4gICAgbG9hZGVyQ29uZmlnID0geyB0aW1lb3V0IDogY29uZmlnLmZyYWdMb2FkaW5nVGltZU91dCwgbWF4UmV0cnkgOiAwICwgcmV0cnlEZWxheSA6IDAsIG1heFJldHJ5RGVsYXkgOiBjb25maWcuZnJhZ0xvYWRpbmdNYXhSZXRyeVRpbWVvdXR9O1xuICAgIGxvYWRlckNhbGxiYWNrcyA9IHsgb25TdWNjZXNzIDogdGhpcy5sb2Fkc3VjY2Vzcy5iaW5kKHRoaXMpLCBvbkVycm9yIDp0aGlzLmxvYWRlcnJvci5iaW5kKHRoaXMpLCBvblRpbWVvdXQgOiB0aGlzLmxvYWR0aW1lb3V0LmJpbmQodGhpcyksIG9uUHJvZ3Jlc3M6IHRoaXMubG9hZHByb2dyZXNzLmJpbmQodGhpcyl9O1xuICAgIGxvYWRlci5sb2FkKGxvYWRlckNvbnRleHQsbG9hZGVyQ29uZmlnLGxvYWRlckNhbGxiYWNrcyk7XG4gIH1cblxuICBsb2Fkc3VjY2VzcyhyZXNwb25zZSwgc3RhdHMsIGNvbnRleHQpIHtcbiAgICBsZXQgcGF5bG9hZCA9IHJlc3BvbnNlLmRhdGEsIGZyYWcgPSBjb250ZXh0LmZyYWc7XG4gICAgLy8gZGV0YWNoIGZyYWdtZW50IGxvYWRlciBvbiBsb2FkIHN1Y2Nlc3NcbiAgICBmcmFnLmxvYWRlciA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmxvYWRlcnNbZnJhZy50eXBlXSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkZSQUdfTE9BREVELCB7cGF5bG9hZDogcGF5bG9hZCwgZnJhZzogZnJhZywgc3RhdHM6IHN0YXRzfSk7XG4gIH1cblxuICBsb2FkZXJyb3IocmVzcG9uc2UsIGNvbnRleHQpIHtcbiAgICBsZXQgbG9hZGVyID0gY29udGV4dC5sb2FkZXI7XG4gICAgaWYgKGxvYWRlcikge1xuICAgICAgbG9hZGVyLmFib3J0KCk7XG4gICAgfVxuICAgIHRoaXMubG9hZGVyc1tjb250ZXh0LnR5cGVdID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuRVJST1IsIHt0eXBlOiBFcnJvclR5cGVzLk5FVFdPUktfRVJST1IsIGRldGFpbHM6IEVycm9yRGV0YWlscy5GUkFHX0xPQURfRVJST1IsIGZhdGFsOiBmYWxzZSwgZnJhZzogY29udGV4dC5mcmFnLCByZXNwb25zZTogcmVzcG9uc2V9KTtcbiAgfVxuXG4gIGxvYWR0aW1lb3V0KHN0YXRzLCBjb250ZXh0KSB7XG4gICAgbGV0IGxvYWRlciA9IGNvbnRleHQubG9hZGVyO1xuICAgIGlmIChsb2FkZXIpIHtcbiAgICAgIGxvYWRlci5hYm9ydCgpO1xuICAgIH1cbiAgICB0aGlzLmxvYWRlcnNbY29udGV4dC50eXBlXSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkVSUk9SLCB7dHlwZTogRXJyb3JUeXBlcy5ORVRXT1JLX0VSUk9SLCBkZXRhaWxzOiBFcnJvckRldGFpbHMuRlJBR19MT0FEX1RJTUVPVVQsIGZhdGFsOiBmYWxzZSwgZnJhZzogY29udGV4dC5mcmFnfSk7XG4gIH1cblxuICAvLyBkYXRhIHdpbGwgYmUgdXNlZCBmb3IgcHJvZ3Jlc3NpdmUgcGFyc2luZ1xuICBsb2FkcHJvZ3Jlc3Moc3RhdHMsIGNvbnRleHQsIGRhdGEpIHsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG4gICAgbGV0IGZyYWcgPSBjb250ZXh0LmZyYWc7XG4gICAgZnJhZy5sb2FkZWQgPSBzdGF0cy5sb2FkZWQ7XG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5GUkFHX0xPQURfUFJPR1JFU1MsIHtmcmFnOiBmcmFnLCBzdGF0czogc3RhdHN9KTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBGcmFnbWVudExvYWRlcjtcbiIsIi8qXG4gKiBEZWNyeXB0IGtleSBMb2FkZXJcbiovXG5cbmltcG9ydCBFdmVudCBmcm9tICcuLi9ldmVudHMnO1xuaW1wb3J0IEV2ZW50SGFuZGxlciBmcm9tICcuLi9ldmVudC1oYW5kbGVyJztcbmltcG9ydCB7RXJyb3JUeXBlcywgRXJyb3JEZXRhaWxzfSBmcm9tICcuLi9lcnJvcnMnO1xuaW1wb3J0IHtsb2dnZXJ9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XG5cbmNsYXNzIEtleUxvYWRlciBleHRlbmRzIEV2ZW50SGFuZGxlciB7XG5cbiAgY29uc3RydWN0b3IoaGxzKSB7XG4gICAgc3VwZXIoaGxzLCBFdmVudC5LRVlfTE9BRElORyk7XG4gICAgdGhpcy5sb2FkZXJzID0ge307XG4gICAgdGhpcy5kZWNyeXB0a2V5ID0gbnVsbDtcbiAgICB0aGlzLmRlY3J5cHR1cmwgPSBudWxsO1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICBmb3IgKGxldCBsb2FkZXJOYW1lIGluIHRoaXMubG9hZGVycykge1xuICAgICAgbGV0IGxvYWRlciA9IHRoaXMubG9hZGVyc1tsb2FkZXJOYW1lXTtcbiAgICAgIGlmIChsb2FkZXIpIHtcbiAgICAgICAgbG9hZGVyLmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5sb2FkZXJzID0ge307XG4gICAgRXZlbnRIYW5kbGVyLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XG4gIH1cblxuICBvbktleUxvYWRpbmcoZGF0YSkge1xuICAgIGxldCBmcmFnID0gZGF0YS5mcmFnLFxuICAgICAgICB0eXBlID0gZnJhZy50eXBlLFxuICAgICAgICBsb2FkZXIgPSB0aGlzLmxvYWRlcnNbdHlwZV0sXG4gICAgICAgIGRlY3J5cHRkYXRhID0gZnJhZy5kZWNyeXB0ZGF0YSxcbiAgICAgICAgdXJpID0gZGVjcnlwdGRhdGEudXJpO1xuICAgICAgICAvLyBpZiB1cmkgaXMgZGlmZmVyZW50IGZyb20gcHJldmlvdXMgb25lIG9yIGlmIGRlY3J5cHQga2V5IG5vdCByZXRyaWV2ZWQgeWV0XG4gICAgICBpZiAodXJpICE9PSB0aGlzLmRlY3J5cHR1cmwgfHwgdGhpcy5kZWNyeXB0a2V5ID09PSBudWxsKSB7XG4gICAgICAgIGxldCBjb25maWcgPSB0aGlzLmhscy5jb25maWc7XG5cbiAgICAgICAgaWYgKGxvYWRlcikge1xuICAgICAgICAgIGxvZ2dlci53YXJuKGBhYm9ydCBwcmV2aW91cyBrZXkgbG9hZGVyIGZvciB0eXBlOiR7dHlwZX1gKTtcbiAgICAgICAgICBsb2FkZXIuYWJvcnQoKTtcbiAgICAgICAgfVxuICAgICAgICBmcmFnLmxvYWRlciA9IHRoaXMubG9hZGVyc1t0eXBlXSA9IG5ldyBjb25maWcubG9hZGVyKGNvbmZpZyk7XG4gICAgICAgIHRoaXMuZGVjcnlwdHVybCA9IHVyaTtcbiAgICAgICAgdGhpcy5kZWNyeXB0a2V5ID0gbnVsbDtcblxuICAgICAgICBsZXQgbG9hZGVyQ29udGV4dCwgbG9hZGVyQ29uZmlnLCBsb2FkZXJDYWxsYmFja3M7XG4gICAgICAgIGxvYWRlckNvbnRleHQgPSB7IHVybCA6IHVyaSwgZnJhZyA6IGZyYWcsIHJlc3BvbnNlVHlwZSA6ICdhcnJheWJ1ZmZlcid9O1xuICAgICAgICBsb2FkZXJDb25maWcgPSB7IHRpbWVvdXQgOiBjb25maWcuZnJhZ0xvYWRpbmdUaW1lT3V0LCBtYXhSZXRyeSA6IGNvbmZpZy5mcmFnTG9hZGluZ01heFJldHJ5ICwgcmV0cnlEZWxheSA6IGNvbmZpZy5mcmFnTG9hZGluZ1JldHJ5RGVsYXksIG1heFJldHJ5RGVsYXkgOiBjb25maWcuZnJhZ0xvYWRpbmdNYXhSZXRyeVRpbWVvdXR9O1xuICAgICAgICBsb2FkZXJDYWxsYmFja3MgPSB7IG9uU3VjY2VzcyA6IHRoaXMubG9hZHN1Y2Nlc3MuYmluZCh0aGlzKSwgb25FcnJvciA6dGhpcy5sb2FkZXJyb3IuYmluZCh0aGlzKSwgb25UaW1lb3V0IDogdGhpcy5sb2FkdGltZW91dC5iaW5kKHRoaXMpfTtcbiAgICAgICAgZnJhZy5sb2FkZXIubG9hZChsb2FkZXJDb250ZXh0LGxvYWRlckNvbmZpZyxsb2FkZXJDYWxsYmFja3MpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmRlY3J5cHRrZXkpIHtcbiAgICAgICAgLy8gd2UgYWxyZWFkeSBsb2FkZWQgdGhpcyBrZXksIHJldHVybiBpdFxuICAgICAgICBkZWNyeXB0ZGF0YS5rZXkgPSB0aGlzLmRlY3J5cHRrZXk7XG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuS0VZX0xPQURFRCwge2ZyYWc6IGZyYWd9KTtcbiAgICAgIH1cbiAgfVxuXG4gIGxvYWRzdWNjZXNzKHJlc3BvbnNlLCBzdGF0cywgY29udGV4dCkge1xuICAgIGxldCBmcmFnID0gY29udGV4dC5mcmFnO1xuICAgIHRoaXMuZGVjcnlwdGtleSA9IGZyYWcuZGVjcnlwdGRhdGEua2V5ID0gbmV3IFVpbnQ4QXJyYXkocmVzcG9uc2UuZGF0YSk7XG4gICAgLy8gZGV0YWNoIGZyYWdtZW50IGxvYWRlciBvbiBsb2FkIHN1Y2Nlc3NcbiAgICBmcmFnLmxvYWRlciA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmxvYWRlcnNbZnJhZy50eXBlXSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LktFWV9MT0FERUQsIHtmcmFnOiBmcmFnfSk7XG4gIH1cblxuICBsb2FkZXJyb3IocmVzcG9uc2UsIGNvbnRleHQpIHtcbiAgICBsZXQgZnJhZyA9IGNvbnRleHQuZnJhZyxcbiAgICAgICAgbG9hZGVyID0gZnJhZy5sb2FkZXI7XG4gICAgaWYgKGxvYWRlcikge1xuICAgICAgbG9hZGVyLmFib3J0KCk7XG4gICAgfVxuICAgIHRoaXMubG9hZGVyc1tjb250ZXh0LnR5cGVdID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuRVJST1IsIHt0eXBlOiBFcnJvclR5cGVzLk5FVFdPUktfRVJST1IsIGRldGFpbHM6IEVycm9yRGV0YWlscy5LRVlfTE9BRF9FUlJPUiwgZmF0YWw6IGZhbHNlLCBmcmFnOiBmcmFnLCByZXNwb25zZTogcmVzcG9uc2V9KTtcbiAgfVxuXG4gIGxvYWR0aW1lb3V0KHN0YXRzLCBjb250ZXh0KSB7XG4gICAgbGV0IGZyYWcgPSBjb250ZXh0LmZyYWcsXG4gICAgICAgIGxvYWRlciA9IGZyYWcubG9hZGVyO1xuICAgIGlmIChsb2FkZXIpIHtcbiAgICAgIGxvYWRlci5hYm9ydCgpO1xuICAgIH1cbiAgICB0aGlzLmxvYWRlcnNbY29udGV4dC50eXBlXSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkVSUk9SLCB7dHlwZTogRXJyb3JUeXBlcy5ORVRXT1JLX0VSUk9SLCBkZXRhaWxzOiBFcnJvckRldGFpbHMuS0VZX0xPQURfVElNRU9VVCwgZmF0YWw6IGZhbHNlLCBmcmFnOiBmcmFnfSk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgS2V5TG9hZGVyO1xuIiwiLyoqXG4gKiBQbGF5bGlzdCBMb2FkZXJcbiovXG5cbmltcG9ydCBVUkxUb29sa2l0IGZyb20gJ3VybC10b29sa2l0JztcbmltcG9ydCBFdmVudCBmcm9tICcuLi9ldmVudHMnO1xuaW1wb3J0IEV2ZW50SGFuZGxlciBmcm9tICcuLi9ldmVudC1oYW5kbGVyJztcbmltcG9ydCB7RXJyb3JUeXBlcywgRXJyb3JEZXRhaWxzfSBmcm9tICcuLi9lcnJvcnMnO1xuaW1wb3J0IEF0dHJMaXN0IGZyb20gJy4uL3V0aWxzL2F0dHItbGlzdCc7XG5pbXBvcnQge2xvZ2dlcn0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcblxuLy8gaHR0cHM6Ly9yZWdleDEwMS5jb20gaXMgeW91ciBmcmllbmRcbmNvbnN0IE1BU1RFUl9QTEFZTElTVF9SRUdFWCA9IC8jRVhULVgtU1RSRUFNLUlORjooW15cXG5cXHJdKilbXFxyXFxuXSsoW15cXHJcXG5dKykvZztcbmNvbnN0IE1BU1RFUl9QTEFZTElTVF9NRURJQV9SRUdFWCA9IC8jRVhULVgtTUVESUE6KC4qKS9nO1xuY29uc3QgTEVWRUxfUExBWUxJU1RfUkVHRVhfRkFTVCA9IC8jRVhUSU5GOiAqKFteLF0rKSw/KC4qKXwoPyEjKShcXFMuKyl8I0VYVC1YLUJZVEVSQU5HRTogKiguKyl8I0VYVC1YLVBST0dSQU0tREFURS1USU1FOiguKyl8Iy4qL2c7XG5jb25zdCBMRVZFTF9QTEFZTElTVF9SRUdFWF9TTE9XID0gLyg/Oig/OiMoRVhUTTNVKSl8KD86I0VYVC1YLShQTEFZTElTVC1UWVBFKTooLispKXwoPzojRVhULVgtKE1FRElBLVNFUVVFTkNFKTogKihcXGQrKSl8KD86I0VYVC1YLShUQVJHRVREVVJBVElPTik6ICooXFxkKykpfCg/OiNFWFQtWC0oS0VZKTooLispKXwoPzojRVhULVgtKFNUQVJUKTooLispKXwoPzojRVhULVgtKEVORExJU1QpKXwoPzojRVhULVgtKERJU0NPTlRJTlVJVFktU0VRKVVFTkNFOihcXGQrKSl8KD86I0VYVC1YLShESVMpQ09OVElOVUlUWSkpfCg/OiNFWFQtWC0oVkVSU0lPTik6KFxcZCspKXwoPzooIykoLiopOiguKikpfCg/OigjKSguKikpKD86LiopXFxyP1xcbj8vO1xuXG5jbGFzcyBMZXZlbEtleSB7XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5tZXRob2QgPSBudWxsO1xuICAgIHRoaXMua2V5ID0gbnVsbDtcbiAgICB0aGlzLml2ID0gbnVsbDtcbiAgICB0aGlzLl91cmkgPSBudWxsO1xuICB9XG5cbiAgZ2V0IHVyaSgpIHtcbiAgICBpZiAoIXRoaXMuX3VyaSAmJiB0aGlzLnJlbHVyaSkge1xuICAgICAgdGhpcy5fdXJpID0gVVJMVG9vbGtpdC5idWlsZEFic29sdXRlVVJMKHRoaXMuYmFzZXVyaSwgdGhpcy5yZWx1cmkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fdXJpO1xuICB9XG5cbn1cblxuY2xhc3MgRnJhZ21lbnQge1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX3VybCA9IG51bGw7XG4gICAgdGhpcy5fYnl0ZVJhbmdlID0gbnVsbDtcbiAgICB0aGlzLl9kZWNyeXB0ZGF0YSA9IG51bGw7XG4gIH1cblxuICBnZXQgdXJsKCkge1xuICAgIGlmICghdGhpcy5fdXJsICYmIHRoaXMucmVsdXJsKSB7XG4gICAgICB0aGlzLl91cmwgPSBVUkxUb29sa2l0LmJ1aWxkQWJzb2x1dGVVUkwodGhpcy5iYXNldXJsLCB0aGlzLnJlbHVybCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl91cmw7XG4gIH1cblxuICBzZXQgdXJsKHZhbHVlKSB7XG4gICAgdGhpcy5fdXJsID0gdmFsdWU7XG4gIH1cblxuICBnZXQgcHJvZ3JhbURhdGVUaW1lKCkge1xuICAgIGlmICghdGhpcy5fcHJvZ3JhbURhdGVUaW1lICYmIHRoaXMucmF3UHJvZ3JhbURhdGVUaW1lKSB7XG4gICAgICB0aGlzLl9wcm9ncmFtRGF0ZVRpbWUgPSBuZXcgRGF0ZShEYXRlLnBhcnNlKHRoaXMucmF3UHJvZ3JhbURhdGVUaW1lKSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9wcm9ncmFtRGF0ZVRpbWU7XG4gIH1cblxuICBnZXQgYnl0ZVJhbmdlKCkge1xuICAgIGlmICghdGhpcy5fYnl0ZVJhbmdlKSB7XG4gICAgICB0aGlzLl9ieXRlUmFuZ2UgPSBbXTtcbiAgICAgIGlmICh0aGlzLnJhd0J5dGVSYW5nZSkge1xuICAgICAgICBjb25zdCBwYXJhbXMgPSB0aGlzLnJhd0J5dGVSYW5nZS5zcGxpdCgnQCcsIDIpO1xuICAgICAgICBpZiAocGFyYW1zLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIHRoaXMuX2J5dGVSYW5nZVswXSA9IHRoaXMucHJldkZyYWcgPyB0aGlzLnByZXZGcmFnLmJ5dGVSYW5nZUVuZE9mZnNldCA6IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fYnl0ZVJhbmdlWzBdID0gcGFyc2VJbnQocGFyYW1zWzFdKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9ieXRlUmFuZ2VbMV0gPSBwYXJzZUludChwYXJhbXNbMF0pICsgdGhpcy5fYnl0ZVJhbmdlWzBdO1xuICAgICAgICB0aGlzLnByZXZGcmFnID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2J5dGVSYW5nZTtcbiAgfVxuXG4gIGdldCBieXRlUmFuZ2VTdGFydE9mZnNldCgpIHtcbiAgICByZXR1cm4gdGhpcy5ieXRlUmFuZ2VbMF07XG4gIH1cblxuICBnZXQgYnl0ZVJhbmdlRW5kT2Zmc2V0KCkge1xuICAgIHJldHVybiB0aGlzLmJ5dGVSYW5nZVsxXTtcbiAgfVxuXG4gIGdldCBkZWNyeXB0ZGF0YSgpIHtcbiAgICBpZiAoIXRoaXMuX2RlY3J5cHRkYXRhKSB7XG4gICAgICB0aGlzLl9kZWNyeXB0ZGF0YSA9IHRoaXMuZnJhZ21lbnREZWNyeXB0ZGF0YUZyb21MZXZlbGtleSh0aGlzLmxldmVsa2V5LCB0aGlzLnNuKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2RlY3J5cHRkYXRhO1xuICB9XG5cbiAgLyoqXG4gICAqIFV0aWxpdHkgbWV0aG9kIGZvciBwYXJzZUxldmVsUGxheWxpc3QgdG8gY3JlYXRlIGFuIGluaXRpYWxpemF0aW9uIHZlY3RvciBmb3IgYSBnaXZlbiBzZWdtZW50XG4gICAqIEByZXR1cm5zIHtVaW50OEFycmF5fVxuICAgKi9cbiAgY3JlYXRlSW5pdGlhbGl6YXRpb25WZWN0b3Ioc2VnbWVudE51bWJlcikge1xuICAgIHZhciB1aW50OFZpZXcgPSBuZXcgVWludDhBcnJheSgxNik7XG5cbiAgICBmb3IgKHZhciBpID0gMTI7IGkgPCAxNjsgaSsrKSB7XG4gICAgICB1aW50OFZpZXdbaV0gPSAoc2VnbWVudE51bWJlciA+PiA4ICogKDE1IC0gaSkpICYgMHhmZjtcbiAgICB9XG5cbiAgICByZXR1cm4gdWludDhWaWV3O1xuICB9XG5cbiAgLyoqXG4gICAqIFV0aWxpdHkgbWV0aG9kIGZvciBwYXJzZUxldmVsUGxheWxpc3QgdG8gZ2V0IGEgZnJhZ21lbnQncyBkZWNyeXB0aW9uIGRhdGEgZnJvbSB0aGUgY3VycmVudGx5IHBhcnNlZCBlbmNyeXB0aW9uIGtleSBkYXRhXG4gICAqIEBwYXJhbSBsZXZlbGtleSAtIGEgcGxheWxpc3QncyBlbmNyeXB0aW9uIGluZm9cbiAgICogQHBhcmFtIHNlZ21lbnROdW1iZXIgLSB0aGUgZnJhZ21lbnQncyBzZWdtZW50IG51bWJlclxuICAgKiBAcmV0dXJucyB7Kn0gLSBhbiBvYmplY3QgdG8gYmUgYXBwbGllZCBhcyBhIGZyYWdtZW50J3MgZGVjcnlwdGRhdGFcbiAgICovXG4gIGZyYWdtZW50RGVjcnlwdGRhdGFGcm9tTGV2ZWxrZXkobGV2ZWxrZXksIHNlZ21lbnROdW1iZXIpIHtcbiAgICB2YXIgZGVjcnlwdGRhdGEgPSBsZXZlbGtleTtcblxuICAgIGlmIChsZXZlbGtleSAmJiBsZXZlbGtleS5tZXRob2QgJiYgbGV2ZWxrZXkudXJpICYmICFsZXZlbGtleS5pdikge1xuICAgICAgZGVjcnlwdGRhdGEgPSBPYmplY3QuYXNzaWduKG5ldyBMZXZlbEtleSgpLCB0aGlzLmNsb25lT2JqKGxldmVsa2V5KSk7XG4gICAgICBkZWNyeXB0ZGF0YS5pdiA9IHRoaXMuY3JlYXRlSW5pdGlhbGl6YXRpb25WZWN0b3Ioc2VnbWVudE51bWJlcik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlY3J5cHRkYXRhO1xuICB9XG5cbiAgY2xvbmVPYmoob2JqKSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkob2JqKSk7XG4gIH1cbn1cblxuY2xhc3MgUGxheWxpc3RMb2FkZXIgZXh0ZW5kcyBFdmVudEhhbmRsZXIge1xuXG4gIGNvbnN0cnVjdG9yKGhscykge1xuICAgIHN1cGVyKGhscyxcbiAgICAgIEV2ZW50Lk1BTklGRVNUX0xPQURJTkcsXG4gICAgICBFdmVudC5MRVZFTF9MT0FESU5HLFxuICAgICAgRXZlbnQuQVVESU9fVFJBQ0tfTE9BRElORyxcbiAgICAgIEV2ZW50LlNVQlRJVExFX1RSQUNLX0xPQURJTkcpO1xuICAgIHRoaXMubG9hZGVycyA9IHt9O1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICBmb3IgKGxldCBsb2FkZXJOYW1lIGluIHRoaXMubG9hZGVycykge1xuICAgICAgbGV0IGxvYWRlciA9IHRoaXMubG9hZGVyc1tsb2FkZXJOYW1lXTtcbiAgICAgIGlmIChsb2FkZXIpIHtcbiAgICAgICAgbG9hZGVyLmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5sb2FkZXJzID0ge307XG4gICAgRXZlbnRIYW5kbGVyLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XG4gIH1cblxuICBvbk1hbmlmZXN0TG9hZGluZyhkYXRhKSB7XG4gICAgdGhpcy5sb2FkKGRhdGEudXJsLCB7IHR5cGUgOiAnbWFuaWZlc3QnfSk7XG4gIH1cblxuICBvbkxldmVsTG9hZGluZyhkYXRhKSB7XG4gICAgdGhpcy5sb2FkKGRhdGEudXJsLCB7IHR5cGUgOiAnbGV2ZWwnLCBsZXZlbCA6IGRhdGEubGV2ZWwsIGlkIDogZGF0YS5pZH0pO1xuICB9XG5cbiAgb25BdWRpb1RyYWNrTG9hZGluZyhkYXRhKSB7XG4gICAgdGhpcy5sb2FkKGRhdGEudXJsLCB7IHR5cGUgOiAnYXVkaW9UcmFjaycsIGlkIDogZGF0YS5pZH0pO1xuICB9XG5cbiAgb25TdWJ0aXRsZVRyYWNrTG9hZGluZyhkYXRhKSB7XG4gICAgdGhpcy5sb2FkKGRhdGEudXJsLCB7IHR5cGUgOiAnc3VidGl0bGVUcmFjaycsIGlkIDogZGF0YS5pZH0pO1xuICB9XG5cbiAgbG9hZCh1cmwsIGNvbnRleHQpIHtcbiAgICBsZXQgbG9hZGVyID0gdGhpcy5sb2FkZXJzW2NvbnRleHQudHlwZV07XG4gICAgaWYgKGxvYWRlcikge1xuICAgICAgbGV0IGxvYWRlckNvbnRleHQgPSBsb2FkZXIuY29udGV4dDtcbiAgICAgIGlmIChsb2FkZXJDb250ZXh0ICYmIGxvYWRlckNvbnRleHQudXJsID09PSB1cmwpIHtcbiAgICAgICAgbG9nZ2VyLnRyYWNlKGBwbGF5bGlzdCByZXF1ZXN0IG9uZ29pbmdgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbG9nZ2VyLndhcm4oYGFib3J0IHByZXZpb3VzIGxvYWRlciBmb3IgdHlwZToke2NvbnRleHQudHlwZX1gKTtcbiAgICAgICAgbG9hZGVyLmFib3J0KCk7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBjb25maWcgPSB0aGlzLmhscy5jb25maWcsXG4gICAgICAgIHJldHJ5LFxuICAgICAgICB0aW1lb3V0LFxuICAgICAgICByZXRyeURlbGF5LFxuICAgICAgICBtYXhSZXRyeURlbGF5O1xuICAgIGlmKGNvbnRleHQudHlwZSA9PT0gJ21hbmlmZXN0Jykge1xuICAgICAgcmV0cnkgPSBjb25maWcubWFuaWZlc3RMb2FkaW5nTWF4UmV0cnk7XG4gICAgICB0aW1lb3V0ID0gY29uZmlnLm1hbmlmZXN0TG9hZGluZ1RpbWVPdXQ7XG4gICAgICByZXRyeURlbGF5ID0gY29uZmlnLm1hbmlmZXN0TG9hZGluZ1JldHJ5RGVsYXk7XG4gICAgICBtYXhSZXRyeURlbGF5ID0gY29uZmlnLm1hbmlmZXN0TG9hZGluZ01heFJldHJ5VGltZW91dDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0cnkgPSBjb25maWcubGV2ZWxMb2FkaW5nTWF4UmV0cnk7XG4gICAgICB0aW1lb3V0ID0gY29uZmlnLmxldmVsTG9hZGluZ1RpbWVPdXQ7XG4gICAgICByZXRyeURlbGF5ID0gY29uZmlnLmxldmVsTG9hZGluZ1JldHJ5RGVsYXk7XG4gICAgICBtYXhSZXRyeURlbGF5ID0gY29uZmlnLmxldmVsTG9hZGluZ01heFJldHJ5VGltZW91dDtcbiAgICAgIGxvZ2dlci5sb2coYGxvYWRpbmcgcGxheWxpc3QgZm9yICR7Y29udGV4dC50eXBlfSAke2NvbnRleHQubGV2ZWwgfHwgY29udGV4dC5pZH1gKTtcbiAgICB9XG4gICAgbG9hZGVyICA9IHRoaXMubG9hZGVyc1tjb250ZXh0LnR5cGVdID0gY29udGV4dC5sb2FkZXIgPSB0eXBlb2YoY29uZmlnLnBMb2FkZXIpICE9PSAndW5kZWZpbmVkJyA/IG5ldyBjb25maWcucExvYWRlcihjb25maWcpIDogbmV3IGNvbmZpZy5sb2FkZXIoY29uZmlnKTtcbiAgICBjb250ZXh0LnVybCA9IHVybDtcbiAgICBjb250ZXh0LnJlc3BvbnNlVHlwZSA9ICcnO1xuXG4gICAgbGV0IGxvYWRlckNvbmZpZywgbG9hZGVyQ2FsbGJhY2tzO1xuICAgIGxvYWRlckNvbmZpZyA9IHsgdGltZW91dCA6IHRpbWVvdXQsIG1heFJldHJ5IDogcmV0cnkgLCByZXRyeURlbGF5IDogcmV0cnlEZWxheSwgbWF4UmV0cnlEZWxheSA6IG1heFJldHJ5RGVsYXl9O1xuICAgIGxvYWRlckNhbGxiYWNrcyA9IHsgb25TdWNjZXNzIDogdGhpcy5sb2Fkc3VjY2Vzcy5iaW5kKHRoaXMpLCBvbkVycm9yIDp0aGlzLmxvYWRlcnJvci5iaW5kKHRoaXMpLCBvblRpbWVvdXQgOiB0aGlzLmxvYWR0aW1lb3V0LmJpbmQodGhpcyl9O1xuICAgIGxvYWRlci5sb2FkKGNvbnRleHQsbG9hZGVyQ29uZmlnLGxvYWRlckNhbGxiYWNrcyk7XG4gIH1cblxuICByZXNvbHZlKHVybCwgYmFzZVVybCkge1xuICAgIHJldHVybiBVUkxUb29sa2l0LmJ1aWxkQWJzb2x1dGVVUkwoYmFzZVVybCwgdXJsKTtcbiAgfVxuXG4gIHBhcnNlTWFzdGVyUGxheWxpc3Qoc3RyaW5nLCBiYXNldXJsKSB7XG4gICAgbGV0IGxldmVscyA9IFtdLCByZXN1bHQ7XG4gICAgTUFTVEVSX1BMQVlMSVNUX1JFR0VYLmxhc3RJbmRleCA9IDA7XG4gICAgd2hpbGUgKChyZXN1bHQgPSBNQVNURVJfUExBWUxJU1RfUkVHRVguZXhlYyhzdHJpbmcpKSAhPSBudWxsKXtcbiAgICAgIGNvbnN0IGxldmVsID0ge307XG5cbiAgICAgIHZhciBhdHRycyA9IGxldmVsLmF0dHJzID0gbmV3IEF0dHJMaXN0KHJlc3VsdFsxXSk7XG4gICAgICBsZXZlbC51cmwgPSB0aGlzLnJlc29sdmUocmVzdWx0WzJdLCBiYXNldXJsKTtcblxuICAgICAgdmFyIHJlc29sdXRpb24gPSBhdHRycy5kZWNpbWFsUmVzb2x1dGlvbignUkVTT0xVVElPTicpO1xuICAgICAgaWYocmVzb2x1dGlvbikge1xuICAgICAgICBsZXZlbC53aWR0aCA9IHJlc29sdXRpb24ud2lkdGg7XG4gICAgICAgIGxldmVsLmhlaWdodCA9IHJlc29sdXRpb24uaGVpZ2h0O1xuICAgICAgfVxuICAgICAgbGV2ZWwuYml0cmF0ZSA9IGF0dHJzLmRlY2ltYWxJbnRlZ2VyKCdBVkVSQUdFLUJBTkRXSURUSCcpIHx8IGF0dHJzLmRlY2ltYWxJbnRlZ2VyKCdCQU5EV0lEVEgnKTtcbiAgICAgIGxldmVsLm5hbWUgPSBhdHRycy5OQU1FO1xuXG4gICAgICB2YXIgY29kZWNzID0gYXR0cnMuQ09ERUNTO1xuICAgICAgaWYoY29kZWNzKSB7XG4gICAgICAgIGNvZGVjcyA9IGNvZGVjcy5zcGxpdCgvWyAsXSsvKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2RlY3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBjb2RlYyA9IGNvZGVjc1tpXTtcbiAgICAgICAgICBpZiAoY29kZWMuaW5kZXhPZignYXZjMScpICE9PSAtMSkge1xuICAgICAgICAgICAgbGV2ZWwudmlkZW9Db2RlYyA9IHRoaXMuYXZjMXRvYXZjb3RpKGNvZGVjKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV2ZWwuYXVkaW9Db2RlYyA9IGNvZGVjO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBsZXZlbHMucHVzaChsZXZlbCk7XG4gICAgfVxuICAgIHJldHVybiBsZXZlbHM7XG4gIH1cblxuICBwYXJzZU1hc3RlclBsYXlsaXN0TWVkaWEoc3RyaW5nLCBiYXNldXJsLCB0eXBlKSB7XG4gICAgbGV0IHJlc3VsdCwgbWVkaWFzID0gW10sIGlkID0gMDtcbiAgICBNQVNURVJfUExBWUxJU1RfTUVESUFfUkVHRVgubGFzdEluZGV4ID0gMDtcbiAgICB3aGlsZSAoKHJlc3VsdCA9IE1BU1RFUl9QTEFZTElTVF9NRURJQV9SRUdFWC5leGVjKHN0cmluZykpICE9IG51bGwpe1xuICAgICAgY29uc3QgbWVkaWEgPSB7fTtcbiAgICAgIHZhciBhdHRycyA9IG5ldyBBdHRyTGlzdChyZXN1bHRbMV0pO1xuICAgICAgaWYoYXR0cnMuVFlQRSA9PT0gdHlwZSkge1xuICAgICAgICBtZWRpYS5ncm91cElkID0gYXR0cnNbJ0dST1VQLUlEJ107XG4gICAgICAgIG1lZGlhLm5hbWUgPSBhdHRycy5OQU1FO1xuICAgICAgICBtZWRpYS50eXBlID0gdHlwZTtcbiAgICAgICAgbWVkaWEuZGVmYXVsdCA9IChhdHRycy5ERUZBVUxUID09PSAnWUVTJyk7XG4gICAgICAgIG1lZGlhLmF1dG9zZWxlY3QgPSAoYXR0cnMuQVVUT1NFTEVDVCA9PT0gJ1lFUycpO1xuICAgICAgICBtZWRpYS5mb3JjZWQgPSAoYXR0cnMuRk9SQ0VEID09PSAnWUVTJyk7XG4gICAgICAgIGlmIChhdHRycy5VUkkpIHtcbiAgICAgICAgICBtZWRpYS51cmwgPSB0aGlzLnJlc29sdmUoYXR0cnMuVVJJLCBiYXNldXJsKTtcbiAgICAgICAgfVxuICAgICAgICBtZWRpYS5sYW5nID0gYXR0cnMuTEFOR1VBR0U7XG4gICAgICAgIGlmKCFtZWRpYS5uYW1lKSB7XG4gICAgICAgICAgICBtZWRpYS5uYW1lID0gbWVkaWEubGFuZztcbiAgICAgICAgfVxuICAgICAgICBtZWRpYS5pZCA9IGlkKys7XG4gICAgICAgIG1lZGlhcy5wdXNoKG1lZGlhKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1lZGlhcztcbiAgfVxuXG4gIGF2YzF0b2F2Y290aShjb2RlYykge1xuICAgIHZhciByZXN1bHQsIGF2Y2RhdGEgPSBjb2RlYy5zcGxpdCgnLicpO1xuICAgIGlmIChhdmNkYXRhLmxlbmd0aCA+IDIpIHtcbiAgICAgIHJlc3VsdCA9IGF2Y2RhdGEuc2hpZnQoKSArICcuJztcbiAgICAgIHJlc3VsdCArPSBwYXJzZUludChhdmNkYXRhLnNoaWZ0KCkpLnRvU3RyaW5nKDE2KTtcbiAgICAgIHJlc3VsdCArPSAoJzAwMCcgKyBwYXJzZUludChhdmNkYXRhLnNoaWZ0KCkpLnRvU3RyaW5nKDE2KSkuc3Vic3RyKC00KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gY29kZWM7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBwYXJzZUxldmVsUGxheWxpc3Qoc3RyaW5nLCBiYXNldXJsLCBpZCwgdHlwZSkge1xuICAgIHZhciBjdXJyZW50U04gPSAwLFxuICAgICAgICB0b3RhbGR1cmF0aW9uID0gMCxcbiAgICAgICAgbGV2ZWwgPSB7dHlwZTogbnVsbCwgdmVyc2lvbjogbnVsbCwgdXJsOiBiYXNldXJsLCBmcmFnbWVudHM6IFtdLCBsaXZlOiB0cnVlLCBzdGFydFNOOiAwfSxcbiAgICAgICAgbGV2ZWxrZXkgPSBuZXcgTGV2ZWxLZXkoKSxcbiAgICAgICAgY2MgPSAwLFxuICAgICAgICBwcmV2RnJhZyA9IG51bGwsXG4gICAgICAgIGZyYWcgPSBuZXcgRnJhZ21lbnQoKSxcbiAgICAgICAgcmVzdWx0LFxuICAgICAgICBpO1xuXG4gICAgZnJhZy50YWdMaXN0ID0gW107XG5cbiAgICBMRVZFTF9QTEFZTElTVF9SRUdFWF9GQVNULmxhc3RJbmRleCA9IDA7XG5cbiAgICB3aGlsZSAoKHJlc3VsdCA9IExFVkVMX1BMQVlMSVNUX1JFR0VYX0ZBU1QuZXhlYyhzdHJpbmcpKSAhPT0gbnVsbCkge1xuICAgICAgY29uc3QgZHVyYXRpb24gPSByZXN1bHRbMV07XG4gICAgICBpZiAoZHVyYXRpb24pIHsgLy8gSU5GXG4gICAgICAgIGZyYWcuZHVyYXRpb24gPSBwYXJzZUZsb2F0KGR1cmF0aW9uKTtcbiAgICAgICAgY29uc3QgdGl0bGUgPSByZXN1bHRbMl07XG4gICAgICAgIGZyYWcudGl0bGUgPSB0aXRsZSA/IHRpdGxlIDogbnVsbDtcbiAgICAgICAgZnJhZy50YWdMaXN0LnB1c2godGl0bGUgPyBbICdJTkYnLGR1cmF0aW9uLHRpdGxlIF0gOiBbICdJTkYnLGR1cmF0aW9uIF0pO1xuICAgICAgfSBlbHNlIGlmIChyZXN1bHRbM10pIHsgLy8gdXJsXG4gICAgICAgIGlmICghaXNOYU4oZnJhZy5kdXJhdGlvbikpIHtcbiAgICAgICAgICBjb25zdCBzbiA9IGN1cnJlbnRTTisrO1xuICAgICAgICAgIGZyYWcudHlwZSA9IHR5cGU7XG4gICAgICAgICAgZnJhZy5wcmV2RnJhZyA9IHByZXZGcmFnO1xuICAgICAgICAgIGZyYWcuc3RhcnQgPSB0b3RhbGR1cmF0aW9uO1xuICAgICAgICAgIGZyYWcubGV2ZWxrZXkgPSBsZXZlbGtleTtcbiAgICAgICAgICBmcmFnLnNuID0gc247XG4gICAgICAgICAgZnJhZy5sZXZlbCA9IGlkO1xuICAgICAgICAgIGZyYWcuY2MgPSBjYztcbiAgICAgICAgICBmcmFnLmJhc2V1cmwgPSBiYXNldXJsO1xuICAgICAgICAgIGZyYWcucmVsdXJsID0gcmVzdWx0WzNdO1xuXG4gICAgICAgICAgbGV2ZWwuZnJhZ21lbnRzLnB1c2goZnJhZyk7XG4gICAgICAgICAgcHJldkZyYWcgPSBmcmFnO1xuICAgICAgICAgIHRvdGFsZHVyYXRpb24gKz0gZnJhZy5kdXJhdGlvbjtcblxuICAgICAgICAgIGZyYWcgPSBuZXcgRnJhZ21lbnQoKTtcbiAgICAgICAgICBmcmFnLnRhZ0xpc3QgPSBbXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChyZXN1bHRbNF0pIHsgLy8gWC1CWVRFUkFOR0VcbiAgICAgICAgZnJhZy5yYXdCeXRlUmFuZ2UgPSByZXN1bHRbNF07XG4gICAgICB9IGVsc2UgaWYgKHJlc3VsdFs1XSkgeyAvLyBQUk9HUkFNLURBVEUtVElNRVxuICAgICAgICBmcmFnLnJhd1Byb2dyYW1EYXRlVGltZSA9IHJlc3VsdFs1XTtcbiAgICAgICAgZnJhZy50YWdMaXN0LnB1c2goWydQUk9HUkFNLURBVEUtVElNRScsIHJlc3VsdFs1XV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0WzBdLm1hdGNoKExFVkVMX1BMQVlMSVNUX1JFR0VYX1NMT1cpO1xuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgcmVzdWx0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKHJlc3VsdFtpXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB2YWx1ZTEgPSByZXN1bHRbaSsxXTtcbiAgICAgICAgY29uc3QgdmFsdWUyID0gcmVzdWx0W2krMl07XG5cbiAgICAgICAgc3dpdGNoIChyZXN1bHRbaV0pIHtcbiAgICAgICAgICBjYXNlICcjJzpcbiAgICAgICAgICAgIGZyYWcudGFnTGlzdC5wdXNoKHZhbHVlMiA/IFsgdmFsdWUxLHZhbHVlMiBdIDogWyB2YWx1ZTEgXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdQTEFZTElTVC1UWVBFJzpcbiAgICAgICAgICAgIGxldmVsLnR5cGUgPSB2YWx1ZTEudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ01FRElBLVNFUVVFTkNFJzpcbiAgICAgICAgICAgIGN1cnJlbnRTTiA9IGxldmVsLnN0YXJ0U04gPSBwYXJzZUludCh2YWx1ZTEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnVEFSR0VURFVSQVRJT04nOlxuICAgICAgICAgICAgbGV2ZWwudGFyZ2V0ZHVyYXRpb24gPSBwYXJzZUZsb2F0KHZhbHVlMSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdWRVJTSU9OJzpcbiAgICAgICAgICAgIGxldmVsLnZlcnNpb24gPSBwYXJzZUludCh2YWx1ZTEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnRVhUTTNVJzpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ0VORExJU1QnOlxuICAgICAgICAgICAgbGV2ZWwubGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnRElTJzpcbiAgICAgICAgICAgIGNjKys7XG4gICAgICAgICAgICBmcmFnLnRhZ0xpc3QucHVzaChbJ0RJUyddKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ0RJU0NPTlRJTlVJVFktU0VRJzpcbiAgICAgICAgICAgIGNjID0gcGFyc2VJbnQodmFsdWUxKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ0tFWSc6XG4gICAgICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvZHJhZnQtcGFudG9zLWh0dHAtbGl2ZS1zdHJlYW1pbmctMDgjc2VjdGlvbi0zLjQuNFxuICAgICAgICAgICAgdmFyIGRlY3J5cHRwYXJhbXMgPSB2YWx1ZTE7XG4gICAgICAgICAgICB2YXIga2V5QXR0cnMgPSBuZXcgQXR0ckxpc3QoZGVjcnlwdHBhcmFtcyk7XG4gICAgICAgICAgICB2YXIgZGVjcnlwdG1ldGhvZCA9IGtleUF0dHJzLmVudW1lcmF0ZWRTdHJpbmcoJ01FVEhPRCcpLFxuICAgICAgICAgICAgICAgIGRlY3J5cHR1cmkgPSBrZXlBdHRycy5VUkksXG4gICAgICAgICAgICAgICAgZGVjcnlwdGl2ID0ga2V5QXR0cnMuaGV4YWRlY2ltYWxJbnRlZ2VyKCdJVicpO1xuICAgICAgICAgICAgaWYgKGRlY3J5cHRtZXRob2QpIHtcbiAgICAgICAgICAgICAgbGV2ZWxrZXkgPSBuZXcgTGV2ZWxLZXkoKTtcbiAgICAgICAgICAgICAgaWYgKChkZWNyeXB0dXJpKSAmJiAoZGVjcnlwdG1ldGhvZCA9PT0gJ0FFUy0xMjgnKSkge1xuICAgICAgICAgICAgICAgIGxldmVsa2V5Lm1ldGhvZCA9IGRlY3J5cHRtZXRob2Q7XG4gICAgICAgICAgICAgICAgLy8gVVJJIHRvIGdldCB0aGUga2V5XG4gICAgICAgICAgICAgICAgbGV2ZWxrZXkuYmFzZXVyaSA9IGJhc2V1cmw7XG4gICAgICAgICAgICAgICAgbGV2ZWxrZXkucmVsdXJpID0gZGVjcnlwdHVyaTtcbiAgICAgICAgICAgICAgICBsZXZlbGtleS5rZXkgPSBudWxsO1xuICAgICAgICAgICAgICAgIC8vIEluaXRpYWxpemF0aW9uIFZlY3RvciAoSVYpXG4gICAgICAgICAgICAgICAgbGV2ZWxrZXkuaXYgPSBkZWNyeXB0aXY7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ1NUQVJUJzpcbiAgICAgICAgICAgIGxldCBzdGFydFBhcmFtcyA9IHZhbHVlMTtcbiAgICAgICAgICAgIGxldCBzdGFydEF0dHJzID0gbmV3IEF0dHJMaXN0KHN0YXJ0UGFyYW1zKTtcbiAgICAgICAgICAgIGxldCBzdGFydFRpbWVPZmZzZXQgPSBzdGFydEF0dHJzLmRlY2ltYWxGbG9hdGluZ1BvaW50KCdUSU1FLU9GRlNFVCcpO1xuICAgICAgICAgICAgLy9USU1FLU9GRlNFVCBjYW4gYmUgMFxuICAgICAgICAgICAgaWYgKCAhaXNOYU4oc3RhcnRUaW1lT2Zmc2V0KSApIHtcbiAgICAgICAgICAgICAgbGV2ZWwuc3RhcnRUaW1lT2Zmc2V0ID0gc3RhcnRUaW1lT2Zmc2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKGBsaW5lIHBhcnNlZCBidXQgbm90IGhhbmRsZWQ6ICR7cmVzdWx0fWApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZnJhZyA9IHByZXZGcmFnO1xuICAgIC8vbG9nZ2VyLmxvZygnZm91bmQgJyArIGxldmVsLmZyYWdtZW50cy5sZW5ndGggKyAnIGZyYWdtZW50cycpO1xuICAgIGlmKGZyYWcgJiYgIWZyYWcucmVsdXJsKSB7XG4gICAgICBsZXZlbC5mcmFnbWVudHMucG9wKCk7XG4gICAgICB0b3RhbGR1cmF0aW9uLT1mcmFnLmR1cmF0aW9uO1xuICAgIH1cbiAgICBsZXZlbC50b3RhbGR1cmF0aW9uID0gdG90YWxkdXJhdGlvbjtcbiAgICBsZXZlbC5hdmVyYWdldGFyZ2V0ZHVyYXRpb24gPSB0b3RhbGR1cmF0aW9uIC8gbGV2ZWwuZnJhZ21lbnRzLmxlbmd0aDtcbiAgICBsZXZlbC5lbmRTTiA9IGN1cnJlbnRTTiAtIDE7XG4gICAgcmV0dXJuIGxldmVsO1xuICB9XG5cbiAgbG9hZHN1Y2Nlc3MocmVzcG9uc2UsIHN0YXRzLCBjb250ZXh0KSB7XG4gICAgdmFyIHN0cmluZyA9IHJlc3BvbnNlLmRhdGEsXG4gICAgICAgIHVybCA9IHJlc3BvbnNlLnVybCxcbiAgICAgICAgdHlwZSA9IGNvbnRleHQudHlwZSxcbiAgICAgICAgaWQgPSBjb250ZXh0LmlkLFxuICAgICAgICBsZXZlbCA9IGNvbnRleHQubGV2ZWwsXG4gICAgICAgIGhscyA9IHRoaXMuaGxzO1xuXG4gICAgdGhpcy5sb2FkZXJzW3R5cGVdID0gdW5kZWZpbmVkO1xuICAgIC8vIHJlc3BvbnNlVVJMIG5vdCBzdXBwb3J0ZWQgb24gc29tZSBicm93c2VycyAoaXQgaXMgdXNlZCB0byBkZXRlY3QgVVJMIHJlZGlyZWN0aW9uKVxuICAgIC8vIGRhdGEtdXJpIG1vZGUgYWxzbyBub3Qgc3VwcG9ydGVkIChidXQgbm8gbmVlZCB0byBkZXRlY3QgcmVkaXJlY3Rpb24pXG4gICAgaWYgKHVybCA9PT0gdW5kZWZpbmVkIHx8IHVybC5pbmRleE9mKCdkYXRhOicpID09PSAwKSB7XG4gICAgICAvLyBmYWxsYmFjayB0byBpbml0aWFsIFVSTFxuICAgICAgdXJsID0gY29udGV4dC51cmw7XG4gICAgfVxuICAgIHN0YXRzLnRsb2FkID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgLy9zdGF0cy5tdGltZSA9IG5ldyBEYXRlKHRhcmdldC5nZXRSZXNwb25zZUhlYWRlcignTGFzdC1Nb2RpZmllZCcpKTtcbiAgICBpZiAoc3RyaW5nLmluZGV4T2YoJyNFWFRNM1UnKSA9PT0gMCkge1xuICAgICAgaWYgKHN0cmluZy5pbmRleE9mKCcjRVhUSU5GOicpID4gMCkge1xuICAgICAgICBsZXQgaXNMZXZlbCA9ICh0eXBlICE9PSAnYXVkaW9UcmFjaycgJiYgdHlwZSAhPT0gJ3N1YnRpdGxlVHJhY2snKSxcbiAgICAgICAgICAgIGxldmVsRGV0YWlscyA9IHRoaXMucGFyc2VMZXZlbFBsYXlsaXN0KHN0cmluZywgdXJsLCBsZXZlbCB8fCBpZCB8fCAwLCAodHlwZSA9PT0gJ2F1ZGlvVHJhY2snID8gJ2F1ZGlvJyA6ICh0eXBlID09PSAnc3VidGl0bGVUcmFjaycgPyAnc3VidGl0bGUnIDogJ21haW4nKSApKTtcbiAgICAgICAgaWYgKHR5cGUgPT09ICdtYW5pZmVzdCcpIHtcbiAgICAgICAgLy8gZmlyc3QgcmVxdWVzdCwgc3RyZWFtIG1hbmlmZXN0IChubyBtYXN0ZXIgcGxheWxpc3QpLCBmaXJlIG1hbmlmZXN0IGxvYWRlZCBldmVudCB3aXRoIGxldmVsIGRldGFpbHNcbiAgICAgICAgICBobHMudHJpZ2dlcihFdmVudC5NQU5JRkVTVF9MT0FERUQsIHtsZXZlbHM6IFt7dXJsOiB1cmwsIGRldGFpbHMgOiBsZXZlbERldGFpbHN9XSwgYXVkaW9UcmFja3MgOiBbXSwgdXJsOiB1cmwsIHN0YXRzOiBzdGF0c30pO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRzLnRwYXJzZWQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgaWYgKGxldmVsRGV0YWlscy50YXJnZXRkdXJhdGlvbikge1xuICAgICAgICAgIGlmIChpc0xldmVsKSB7XG4gICAgICAgICAgICBobHMudHJpZ2dlcihFdmVudC5MRVZFTF9MT0FERUQsIHtkZXRhaWxzOiBsZXZlbERldGFpbHMsIGxldmVsOiBsZXZlbCB8fCAwLCBpZDogaWQgfHwgMCwgc3RhdHM6IHN0YXRzfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0eXBlID09PSAnYXVkaW9UcmFjaycpIHtcbiAgICAgICAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnQuQVVESU9fVFJBQ0tfTE9BREVELCB7ZGV0YWlsczogbGV2ZWxEZXRhaWxzLCBpZDogaWQsIHN0YXRzOiBzdGF0c30pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gJ3N1YnRpdGxlVHJhY2snKSB7XG4gICAgICAgICAgICAgIGhscy50cmlnZ2VyKEV2ZW50LlNVQlRJVExFX1RSQUNLX0xPQURFRCwge2RldGFpbHM6IGxldmVsRGV0YWlscywgaWQ6IGlkLCBzdGF0czogc3RhdHN9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnQuRVJST1IsIHt0eXBlOiBFcnJvclR5cGVzLk5FVFdPUktfRVJST1IsIGRldGFpbHM6IEVycm9yRGV0YWlscy5NQU5JRkVTVF9QQVJTSU5HX0VSUk9SLCBmYXRhbDogdHJ1ZSwgdXJsOiB1cmwsIHJlYXNvbjogJ2ludmFsaWQgdGFyZ2V0ZHVyYXRpb24nfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBsZXZlbHMgPSB0aGlzLnBhcnNlTWFzdGVyUGxheWxpc3Qoc3RyaW5nLCB1cmwpO1xuICAgICAgICAvLyBtdWx0aSBsZXZlbCBwbGF5bGlzdCwgcGFyc2UgbGV2ZWwgaW5mb1xuICAgICAgICBpZiAobGV2ZWxzLmxlbmd0aCkge1xuICAgICAgICAgIGxldCBhdWRpb1RyYWNrcyA9IHRoaXMucGFyc2VNYXN0ZXJQbGF5bGlzdE1lZGlhKHN0cmluZywgdXJsLCAnQVVESU8nKTtcbiAgICAgICAgICBsZXQgc3VidGl0bGVzID0gdGhpcy5wYXJzZU1hc3RlclBsYXlsaXN0TWVkaWEoc3RyaW5nLCB1cmwsICdTVUJUSVRMRVMnKTtcbiAgICAgICAgICBpZiAoYXVkaW9UcmFja3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBjaGVjayBpZiB3ZSBoYXZlIGZvdW5kIGFuIGF1ZGlvIHRyYWNrIGVtYmVkZGVkIGluIG1haW4gcGxheWxpc3QgKGF1ZGlvIHRyYWNrIHdpdGhvdXQgVVJJIGF0dHJpYnV0ZSlcbiAgICAgICAgICAgIGxldCBlbWJlZGRlZEF1ZGlvRm91bmQgPSBmYWxzZTtcbiAgICAgICAgICAgIGF1ZGlvVHJhY2tzLmZvckVhY2goYXVkaW9UcmFjayA9PiB7XG4gICAgICAgICAgICAgIGlmKCFhdWRpb1RyYWNrLnVybCkge1xuICAgICAgICAgICAgICAgIGVtYmVkZGVkQXVkaW9Gb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gaWYgbm8gZW1iZWRkZWQgYXVkaW8gdHJhY2sgZGVmaW5lZCwgYnV0IGF1ZGlvIGNvZGVjIHNpZ25hbGVkIGluIHF1YWxpdHkgbGV2ZWwsIHdlIG5lZWQgdG8gc2lnbmFsIHRoaXMgbWFpbiBhdWRpbyB0cmFja1xuICAgICAgICAgICAgLy8gdGhpcyBjb3VsZCBoYXBwZW4gd2l0aCBwbGF5bGlzdHMgd2l0aCBhbHQgYXVkaW8gcmVuZGl0aW9uIGluIHdoaWNoIHF1YWxpdHkgbGV2ZWxzIChtYWluKSBjb250YWlucyBib3RoIGF1ZGlvK3ZpZGVvLiBidXQgd2l0aCBtaXhlZCBhdWRpbyB0cmFjayBub3Qgc2lnbmFsZWRcbiAgICAgICAgICAgIGlmIChlbWJlZGRlZEF1ZGlvRm91bmQgPT09IGZhbHNlICYmIGxldmVsc1swXS5hdWRpb0NvZGVjICYmICFsZXZlbHNbMF0uYXR0cnMuQVVESU8pIHtcbiAgICAgICAgICAgICAgbG9nZ2VyLmxvZygnYXVkaW8gY29kZWMgc2lnbmFsZWQgaW4gcXVhbGl0eSBsZXZlbCwgYnV0IG5vIGVtYmVkZGVkIGF1ZGlvIHRyYWNrIHNpZ25hbGVkLCBjcmVhdGUgb25lJyk7XG4gICAgICAgICAgICAgIGF1ZGlvVHJhY2tzLnVuc2hpZnQoeyB0eXBlIDogJ21haW4nLCBuYW1lIDogJ21haW4nfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGhscy50cmlnZ2VyKEV2ZW50Lk1BTklGRVNUX0xPQURFRCwge2xldmVscywgYXVkaW9UcmFja3MsIHN1YnRpdGxlcywgdXJsLCBzdGF0c30pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGhscy50cmlnZ2VyKEV2ZW50LkVSUk9SLCB7dHlwZTogRXJyb3JUeXBlcy5ORVRXT1JLX0VSUk9SLCBkZXRhaWxzOiBFcnJvckRldGFpbHMuTUFOSUZFU1RfRU1QVFlfRVJST1IsIGZhdGFsOiBmYWxzZSwgdXJsOiB1cmwsIHJlYXNvbjogJ25vIGxldmVsIGZvdW5kIGluIG1hbmlmZXN0JywgY29udGV4dCB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBobHMudHJpZ2dlcihFdmVudC5FUlJPUiwge3R5cGU6IEVycm9yVHlwZXMuTkVUV09SS19FUlJPUiwgZGV0YWlsczogRXJyb3JEZXRhaWxzLk1BTklGRVNUX1BBUlNJTkdfRVJST1IsIGZhdGFsOiB0cnVlLCB1cmw6IHVybCwgcmVhc29uOiAnbm8gRVhUTTNVIGRlbGltaXRlcid9KTtcbiAgICB9XG4gIH1cblxuICBsb2FkZXJyb3IocmVzcG9uc2UsIGNvbnRleHQpIHtcbiAgICB2YXIgZGV0YWlscywgZmF0YWwsbG9hZGVyID0gY29udGV4dC5sb2FkZXI7XG4gICAgc3dpdGNoKGNvbnRleHQudHlwZSkge1xuICAgICAgY2FzZSAnbWFuaWZlc3QnOlxuICAgICAgICBkZXRhaWxzID0gRXJyb3JEZXRhaWxzLk1BTklGRVNUX0xPQURfRVJST1I7XG4gICAgICAgIGZhdGFsID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdsZXZlbCc6XG4gICAgICAgIGRldGFpbHMgPSBFcnJvckRldGFpbHMuTEVWRUxfTE9BRF9FUlJPUjtcbiAgICAgICAgZmF0YWwgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdhdWRpb1RyYWNrJzpcbiAgICAgICAgZGV0YWlscyA9IEVycm9yRGV0YWlscy5BVURJT19UUkFDS19MT0FEX0VSUk9SO1xuICAgICAgICBmYXRhbCA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKGxvYWRlcikge1xuICAgICAgbG9hZGVyLmFib3J0KCk7XG4gICAgICB0aGlzLmxvYWRlcnNbY29udGV4dC50eXBlXSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5FUlJPUiwge3R5cGU6IEVycm9yVHlwZXMuTkVUV09SS19FUlJPUiwgZGV0YWlsczogZGV0YWlscywgZmF0YWw6IGZhdGFsLCB1cmw6IGNvbnRleHQudXJsLCBsb2FkZXI6IGxvYWRlciwgcmVzcG9uc2U6IHJlc3BvbnNlLCBjb250ZXh0IDogY29udGV4dH0pO1xuICB9XG5cbiAgbG9hZHRpbWVvdXQoc3RhdHMsIGNvbnRleHQpIHtcbiAgICB2YXIgZGV0YWlscywgZmF0YWwsIGxvYWRlciA9IGNvbnRleHQubG9hZGVyO1xuICAgIHN3aXRjaChjb250ZXh0LnR5cGUpIHtcbiAgICAgIGNhc2UgJ21hbmlmZXN0JzpcbiAgICAgICAgZGV0YWlscyA9IEVycm9yRGV0YWlscy5NQU5JRkVTVF9MT0FEX1RJTUVPVVQ7XG4gICAgICAgIGZhdGFsID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdsZXZlbCc6XG4gICAgICAgIGRldGFpbHMgPSBFcnJvckRldGFpbHMuTEVWRUxfTE9BRF9USU1FT1VUO1xuICAgICAgICBmYXRhbCA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2F1ZGlvVHJhY2snOlxuICAgICAgICBkZXRhaWxzID0gRXJyb3JEZXRhaWxzLkFVRElPX1RSQUNLX0xPQURfVElNRU9VVDtcbiAgICAgICAgZmF0YWwgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmIChsb2FkZXIpIHtcbiAgICAgIGxvYWRlci5hYm9ydCgpO1xuICAgICAgdGhpcy5sb2FkZXJzW2NvbnRleHQudHlwZV0gPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuRVJST1IsIHt0eXBlOiBFcnJvclR5cGVzLk5FVFdPUktfRVJST1IsIGRldGFpbHM6IGRldGFpbHMsIGZhdGFsOiBmYXRhbCwgdXJsOiBjb250ZXh0LnVybCwgbG9hZGVyOiBsb2FkZXIsIGNvbnRleHQgOiBjb250ZXh0fSk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgUGxheWxpc3RMb2FkZXI7XG4iLCIvKipcbiAqIEdlbmVyYXRlIE1QNCBCb3hcbiovXG5cbi8vaW1wb3J0IEhleCBmcm9tICcuLi91dGlscy9oZXgnO1xuY2xhc3MgTVA0IHtcbiAgc3RhdGljIGluaXQoKSB7XG4gICAgTVA0LnR5cGVzID0ge1xuICAgICAgYXZjMTogW10sIC8vIGNvZGluZ25hbWVcbiAgICAgIGF2Y0M6IFtdLFxuICAgICAgYnRydDogW10sXG4gICAgICBkaW5mOiBbXSxcbiAgICAgIGRyZWY6IFtdLFxuICAgICAgZXNkczogW10sXG4gICAgICBmdHlwOiBbXSxcbiAgICAgIGhkbHI6IFtdLFxuICAgICAgbWRhdDogW10sXG4gICAgICBtZGhkOiBbXSxcbiAgICAgIG1kaWE6IFtdLFxuICAgICAgbWZoZDogW10sXG4gICAgICBtaW5mOiBbXSxcbiAgICAgIG1vb2Y6IFtdLFxuICAgICAgbW9vdjogW10sXG4gICAgICBtcDRhOiBbXSxcbiAgICAgICcubXAzJzogW10sXG4gICAgICBtdmV4OiBbXSxcbiAgICAgIG12aGQ6IFtdLFxuICAgICAgc2R0cDogW10sXG4gICAgICBzdGJsOiBbXSxcbiAgICAgIHN0Y286IFtdLFxuICAgICAgc3RzYzogW10sXG4gICAgICBzdHNkOiBbXSxcbiAgICAgIHN0c3o6IFtdLFxuICAgICAgc3R0czogW10sXG4gICAgICB0ZmR0OiBbXSxcbiAgICAgIHRmaGQ6IFtdLFxuICAgICAgdHJhZjogW10sXG4gICAgICB0cmFrOiBbXSxcbiAgICAgIHRydW46IFtdLFxuICAgICAgdHJleDogW10sXG4gICAgICB0a2hkOiBbXSxcbiAgICAgIHZtaGQ6IFtdLFxuICAgICAgc21oZDogW11cbiAgICB9O1xuXG4gICAgdmFyIGk7XG4gICAgZm9yIChpIGluIE1QNC50eXBlcykge1xuICAgICAgaWYgKE1QNC50eXBlcy5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICBNUDQudHlwZXNbaV0gPSBbXG4gICAgICAgICAgaS5jaGFyQ29kZUF0KDApLFxuICAgICAgICAgIGkuY2hhckNvZGVBdCgxKSxcbiAgICAgICAgICBpLmNoYXJDb2RlQXQoMiksXG4gICAgICAgICAgaS5jaGFyQ29kZUF0KDMpXG4gICAgICAgIF07XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHZpZGVvSGRsciA9IG5ldyBVaW50OEFycmF5KFtcbiAgICAgIDB4MDAsIC8vIHZlcnNpb24gMFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gZmxhZ3NcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHByZV9kZWZpbmVkXG4gICAgICAweDc2LCAweDY5LCAweDY0LCAweDY1LCAvLyBoYW5kbGVyX3R5cGU6ICd2aWRlJ1xuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxuICAgICAgMHg1NiwgMHg2OSwgMHg2NCwgMHg2NSxcbiAgICAgIDB4NmYsIDB4NDgsIDB4NjEsIDB4NmUsXG4gICAgICAweDY0LCAweDZjLCAweDY1LCAweDcyLCAweDAwIC8vIG5hbWU6ICdWaWRlb0hhbmRsZXInXG4gICAgXSk7XG5cbiAgICB2YXIgYXVkaW9IZGxyID0gbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgMHgwMCwgLy8gdmVyc2lvbiAwXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAvLyBmbGFnc1xuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcHJlX2RlZmluZWRcbiAgICAgIDB4NzMsIDB4NmYsIDB4NzUsIDB4NmUsIC8vIGhhbmRsZXJfdHlwZTogJ3NvdW4nXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgICAweDUzLCAweDZmLCAweDc1LCAweDZlLFxuICAgICAgMHg2NCwgMHg0OCwgMHg2MSwgMHg2ZSxcbiAgICAgIDB4NjQsIDB4NmMsIDB4NjUsIDB4NzIsIDB4MDAgLy8gbmFtZTogJ1NvdW5kSGFuZGxlcidcbiAgICBdKTtcblxuICAgIE1QNC5IRExSX1RZUEVTID0ge1xuICAgICAgJ3ZpZGVvJzogdmlkZW9IZGxyLFxuICAgICAgJ2F1ZGlvJzogYXVkaW9IZGxyXG4gICAgfTtcblxuICAgIHZhciBkcmVmID0gbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgMHgwMCwgLy8gdmVyc2lvbiAwXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAvLyBmbGFnc1xuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMSwgLy8gZW50cnlfY291bnRcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MGMsIC8vIGVudHJ5X3NpemVcbiAgICAgIDB4NzUsIDB4NzIsIDB4NmMsIDB4MjAsIC8vICd1cmwnIHR5cGVcbiAgICAgIDB4MDAsIC8vIHZlcnNpb24gMFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMSAvLyBlbnRyeV9mbGFnc1xuICAgIF0pO1xuXG4gICAgdmFyIHN0Y28gPSBuZXcgVWludDhBcnJheShbXG4gICAgICAweDAwLCAvLyB2ZXJzaW9uXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAvLyBmbGFnc1xuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCAvLyBlbnRyeV9jb3VudFxuICAgIF0pO1xuXG4gICAgTVA0LlNUVFMgPSBNUDQuU1RTQyA9IE1QNC5TVENPID0gc3RjbztcblxuICAgIE1QNC5TVFNaID0gbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgMHgwMCwgLy8gdmVyc2lvblxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gZmxhZ3NcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHNhbXBsZV9zaXplXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyBzYW1wbGVfY291bnRcbiAgICBdKTtcbiAgICBNUDQuVk1IRCA9IG5ldyBVaW50OEFycmF5KFtcbiAgICAgIDB4MDAsIC8vIHZlcnNpb25cbiAgICAgIDB4MDAsIDB4MDAsIDB4MDEsIC8vIGZsYWdzXG4gICAgICAweDAwLCAweDAwLCAvLyBncmFwaGljc21vZGVcbiAgICAgIDB4MDAsIDB4MDAsXG4gICAgICAweDAwLCAweDAwLFxuICAgICAgMHgwMCwgMHgwMCAvLyBvcGNvbG9yXG4gICAgXSk7XG4gICAgTVA0LlNNSEQgPSBuZXcgVWludDhBcnJheShbXG4gICAgICAweDAwLCAvLyB2ZXJzaW9uXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAvLyBmbGFnc1xuICAgICAgMHgwMCwgMHgwMCwgLy8gYmFsYW5jZVxuICAgICAgMHgwMCwgMHgwMCAvLyByZXNlcnZlZFxuICAgIF0pO1xuXG4gICAgTVA0LlNUU0QgPSBuZXcgVWludDhBcnJheShbXG4gICAgICAweDAwLCAvLyB2ZXJzaW9uIDBcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGZsYWdzXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAxXSk7Ly8gZW50cnlfY291bnRcblxuICAgIHZhciBtYWpvckJyYW5kID0gbmV3IFVpbnQ4QXJyYXkoWzEwNSwxMTUsMTExLDEwOV0pOyAvLyBpc29tXG4gICAgdmFyIGF2YzFCcmFuZCA9IG5ldyBVaW50OEFycmF5KFs5NywxMTgsOTksNDldKTsgLy8gYXZjMVxuICAgIHZhciBtaW5vclZlcnNpb24gPSBuZXcgVWludDhBcnJheShbMCwgMCwgMCwgMV0pO1xuXG4gICAgTVA0LkZUWVAgPSBNUDQuYm94KE1QNC50eXBlcy5mdHlwLCBtYWpvckJyYW5kLCBtaW5vclZlcnNpb24sIG1ham9yQnJhbmQsIGF2YzFCcmFuZCk7XG4gICAgTVA0LkRJTkYgPSBNUDQuYm94KE1QNC50eXBlcy5kaW5mLCBNUDQuYm94KE1QNC50eXBlcy5kcmVmLCBkcmVmKSk7XG4gIH1cblxuICBzdGF0aWMgYm94KHR5cGUpIHtcbiAgdmFyXG4gICAgcGF5bG9hZCA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSksXG4gICAgc2l6ZSA9IDgsXG4gICAgaSA9IHBheWxvYWQubGVuZ3RoLFxuICAgIGxlbiA9IGksXG4gICAgcmVzdWx0O1xuICAgIC8vIGNhbGN1bGF0ZSB0aGUgdG90YWwgc2l6ZSB3ZSBuZWVkIHRvIGFsbG9jYXRlXG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgc2l6ZSArPSBwYXlsb2FkW2ldLmJ5dGVMZW5ndGg7XG4gICAgfVxuICAgIHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KHNpemUpO1xuICAgIHJlc3VsdFswXSA9IChzaXplID4+IDI0KSAmIDB4ZmY7XG4gICAgcmVzdWx0WzFdID0gKHNpemUgPj4gMTYpICYgMHhmZjtcbiAgICByZXN1bHRbMl0gPSAoc2l6ZSA+PiA4KSAmIDB4ZmY7XG4gICAgcmVzdWx0WzNdID0gc2l6ZSAgJiAweGZmO1xuICAgIHJlc3VsdC5zZXQodHlwZSwgNCk7XG4gICAgLy8gY29weSB0aGUgcGF5bG9hZCBpbnRvIHRoZSByZXN1bHRcbiAgICBmb3IgKGkgPSAwLCBzaXplID0gODsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAvLyBjb3B5IHBheWxvYWRbaV0gYXJyYXkgQCBvZmZzZXQgc2l6ZVxuICAgICAgcmVzdWx0LnNldChwYXlsb2FkW2ldLCBzaXplKTtcbiAgICAgIHNpemUgKz0gcGF5bG9hZFtpXS5ieXRlTGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgc3RhdGljIGhkbHIodHlwZSkge1xuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5oZGxyLCBNUDQuSERMUl9UWVBFU1t0eXBlXSk7XG4gIH1cblxuICBzdGF0aWMgbWRhdChkYXRhKSB7XG4gICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLm1kYXQsIGRhdGEpO1xuICB9XG5cbiAgc3RhdGljIG1kaGQodGltZXNjYWxlLCBkdXJhdGlvbikge1xuICAgIGR1cmF0aW9uICo9IHRpbWVzY2FsZTtcbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMubWRoZCwgbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgMHgwMCwgLy8gdmVyc2lvbiAwXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAvLyBmbGFnc1xuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMiwgLy8gY3JlYXRpb25fdGltZVxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMywgLy8gbW9kaWZpY2F0aW9uX3RpbWVcbiAgICAgICh0aW1lc2NhbGUgPj4gMjQpICYgMHhGRixcbiAgICAgICh0aW1lc2NhbGUgPj4gMTYpICYgMHhGRixcbiAgICAgICh0aW1lc2NhbGUgPj4gIDgpICYgMHhGRixcbiAgICAgIHRpbWVzY2FsZSAmIDB4RkYsIC8vIHRpbWVzY2FsZVxuICAgICAgKGR1cmF0aW9uID4+IDI0KSxcbiAgICAgIChkdXJhdGlvbiA+PiAxNikgJiAweEZGLFxuICAgICAgKGR1cmF0aW9uID4+ICA4KSAmIDB4RkYsXG4gICAgICBkdXJhdGlvbiAmIDB4RkYsIC8vIGR1cmF0aW9uXG4gICAgICAweDU1LCAweGM0LCAvLyAndW5kJyBsYW5ndWFnZSAodW5kZXRlcm1pbmVkKVxuICAgICAgMHgwMCwgMHgwMFxuICAgIF0pKTtcbiAgfVxuXG4gIHN0YXRpYyBtZGlhKHRyYWNrKSB7XG4gICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLm1kaWEsIE1QNC5tZGhkKHRyYWNrLnRpbWVzY2FsZSwgdHJhY2suZHVyYXRpb24pLCBNUDQuaGRscih0cmFjay50eXBlKSwgTVA0Lm1pbmYodHJhY2spKTtcbiAgfVxuXG4gIHN0YXRpYyBtZmhkKHNlcXVlbmNlTnVtYmVyKSB7XG4gICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLm1maGQsIG5ldyBVaW50OEFycmF5KFtcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAvLyBmbGFnc1xuICAgICAgKHNlcXVlbmNlTnVtYmVyID4+IDI0KSxcbiAgICAgIChzZXF1ZW5jZU51bWJlciA+PiAxNikgJiAweEZGLFxuICAgICAgKHNlcXVlbmNlTnVtYmVyID4+ICA4KSAmIDB4RkYsXG4gICAgICBzZXF1ZW5jZU51bWJlciAmIDB4RkYsIC8vIHNlcXVlbmNlX251bWJlclxuICAgIF0pKTtcbiAgfVxuXG4gIHN0YXRpYyBtaW5mKHRyYWNrKSB7XG4gICAgaWYgKHRyYWNrLnR5cGUgPT09ICdhdWRpbycpIHtcbiAgICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5taW5mLCBNUDQuYm94KE1QNC50eXBlcy5zbWhkLCBNUDQuU01IRCksIE1QNC5ESU5GLCBNUDQuc3RibCh0cmFjaykpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMubWluZiwgTVA0LmJveChNUDQudHlwZXMudm1oZCwgTVA0LlZNSEQpLCBNUDQuRElORiwgTVA0LnN0YmwodHJhY2spKTtcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgbW9vZihzbiwgYmFzZU1lZGlhRGVjb2RlVGltZSwgdHJhY2spIHtcbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMubW9vZiwgTVA0Lm1maGQoc24pLCBNUDQudHJhZih0cmFjayxiYXNlTWVkaWFEZWNvZGVUaW1lKSk7XG4gIH1cbi8qKlxuICogQHBhcmFtIHRyYWNrcy4uLiAob3B0aW9uYWwpIHthcnJheX0gdGhlIHRyYWNrcyBhc3NvY2lhdGVkIHdpdGggdGhpcyBtb3ZpZVxuICovXG4gIHN0YXRpYyBtb292KHRyYWNrcykge1xuICAgIHZhclxuICAgICAgaSA9IHRyYWNrcy5sZW5ndGgsXG4gICAgICBib3hlcyA9IFtdO1xuXG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgYm94ZXNbaV0gPSBNUDQudHJhayh0cmFja3NbaV0pO1xuICAgIH1cblxuICAgIHJldHVybiBNUDQuYm94LmFwcGx5KG51bGwsIFtNUDQudHlwZXMubW9vdiwgTVA0Lm12aGQodHJhY2tzWzBdLnRpbWVzY2FsZSwgdHJhY2tzWzBdLmR1cmF0aW9uKV0uY29uY2F0KGJveGVzKS5jb25jYXQoTVA0Lm12ZXgodHJhY2tzKSkpO1xuICB9XG5cbiAgc3RhdGljIG12ZXgodHJhY2tzKSB7XG4gICAgdmFyXG4gICAgICBpID0gdHJhY2tzLmxlbmd0aCxcbiAgICAgIGJveGVzID0gW107XG5cbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBib3hlc1tpXSA9IE1QNC50cmV4KHRyYWNrc1tpXSk7XG4gICAgfVxuICAgIHJldHVybiBNUDQuYm94LmFwcGx5KG51bGwsIFtNUDQudHlwZXMubXZleF0uY29uY2F0KGJveGVzKSk7XG4gIH1cblxuICBzdGF0aWMgbXZoZCh0aW1lc2NhbGUsZHVyYXRpb24pIHtcbiAgICBkdXJhdGlvbio9dGltZXNjYWxlO1xuICAgIHZhclxuICAgICAgYnl0ZXMgPSBuZXcgVWludDhBcnJheShbXG4gICAgICAgIDB4MDAsIC8vIHZlcnNpb24gMFxuICAgICAgICAweDAwLCAweDAwLCAweDAwLCAvLyBmbGFnc1xuICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAxLCAvLyBjcmVhdGlvbl90aW1lXG4gICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDIsIC8vIG1vZGlmaWNhdGlvbl90aW1lXG4gICAgICAgICh0aW1lc2NhbGUgPj4gMjQpICYgMHhGRixcbiAgICAgICAgKHRpbWVzY2FsZSA+PiAxNikgJiAweEZGLFxuICAgICAgICAodGltZXNjYWxlID4+ICA4KSAmIDB4RkYsXG4gICAgICAgIHRpbWVzY2FsZSAmIDB4RkYsIC8vIHRpbWVzY2FsZVxuICAgICAgICAoZHVyYXRpb24gPj4gMjQpICYgMHhGRixcbiAgICAgICAgKGR1cmF0aW9uID4+IDE2KSAmIDB4RkYsXG4gICAgICAgIChkdXJhdGlvbiA+PiAgOCkgJiAweEZGLFxuICAgICAgICBkdXJhdGlvbiAmIDB4RkYsIC8vIGR1cmF0aW9uXG4gICAgICAgIDB4MDAsIDB4MDEsIDB4MDAsIDB4MDAsIC8vIDEuMCByYXRlXG4gICAgICAgIDB4MDEsIDB4MDAsIC8vIDEuMCB2b2x1bWVcbiAgICAgICAgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAgICAgMHgwMCwgMHgwMSwgMHgwMCwgMHgwMCxcbiAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgICAgMHgwMCwgMHgwMSwgMHgwMCwgMHgwMCxcbiAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgICAgMHg0MCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gdHJhbnNmb3JtYXRpb246IHVuaXR5IG1hdHJpeFxuICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyBwcmVfZGVmaW5lZFxuICAgICAgICAweGZmLCAweGZmLCAweGZmLCAweGZmIC8vIG5leHRfdHJhY2tfSURcbiAgICAgIF0pO1xuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5tdmhkLCBieXRlcyk7XG4gIH1cblxuICBzdGF0aWMgc2R0cCh0cmFjaykge1xuICAgIHZhclxuICAgICAgc2FtcGxlcyA9IHRyYWNrLnNhbXBsZXMgfHwgW10sXG4gICAgICBieXRlcyA9IG5ldyBVaW50OEFycmF5KDQgKyBzYW1wbGVzLmxlbmd0aCksXG4gICAgICBmbGFncyxcbiAgICAgIGk7XG4gICAgLy8gbGVhdmUgdGhlIGZ1bGwgYm94IGhlYWRlciAoNCBieXRlcykgYWxsIHplcm9cbiAgICAvLyB3cml0ZSB0aGUgc2FtcGxlIHRhYmxlXG4gICAgZm9yIChpID0gMDsgaSA8IHNhbXBsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGZsYWdzID0gc2FtcGxlc1tpXS5mbGFncztcbiAgICAgIGJ5dGVzW2kgKyA0XSA9IChmbGFncy5kZXBlbmRzT24gPDwgNCkgfFxuICAgICAgICAoZmxhZ3MuaXNEZXBlbmRlZE9uIDw8IDIpIHxcbiAgICAgICAgKGZsYWdzLmhhc1JlZHVuZGFuY3kpO1xuICAgIH1cblxuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5zZHRwLCBieXRlcyk7XG4gIH1cblxuICBzdGF0aWMgc3RibCh0cmFjaykge1xuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5zdGJsLCBNUDQuc3RzZCh0cmFjayksIE1QNC5ib3goTVA0LnR5cGVzLnN0dHMsIE1QNC5TVFRTKSwgTVA0LmJveChNUDQudHlwZXMuc3RzYywgTVA0LlNUU0MpLCBNUDQuYm94KE1QNC50eXBlcy5zdHN6LCBNUDQuU1RTWiksIE1QNC5ib3goTVA0LnR5cGVzLnN0Y28sIE1QNC5TVENPKSk7XG4gIH1cblxuICBzdGF0aWMgYXZjMSh0cmFjaykge1xuICAgIHZhciBzcHMgPSBbXSwgcHBzID0gW10sIGksIGRhdGEsIGxlbjtcbiAgICAvLyBhc3NlbWJsZSB0aGUgU1BTc1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHRyYWNrLnNwcy5sZW5ndGg7IGkrKykge1xuICAgICAgZGF0YSA9IHRyYWNrLnNwc1tpXTtcbiAgICAgIGxlbiA9IGRhdGEuYnl0ZUxlbmd0aDtcbiAgICAgIHNwcy5wdXNoKChsZW4gPj4+IDgpICYgMHhGRik7XG4gICAgICBzcHMucHVzaCgobGVuICYgMHhGRikpO1xuICAgICAgc3BzID0gc3BzLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChkYXRhKSk7IC8vIFNQU1xuICAgIH1cblxuICAgIC8vIGFzc2VtYmxlIHRoZSBQUFNzXG4gICAgZm9yIChpID0gMDsgaSA8IHRyYWNrLnBwcy5sZW5ndGg7IGkrKykge1xuICAgICAgZGF0YSA9IHRyYWNrLnBwc1tpXTtcbiAgICAgIGxlbiA9IGRhdGEuYnl0ZUxlbmd0aDtcbiAgICAgIHBwcy5wdXNoKChsZW4gPj4+IDgpICYgMHhGRik7XG4gICAgICBwcHMucHVzaCgobGVuICYgMHhGRikpO1xuICAgICAgcHBzID0gcHBzLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChkYXRhKSk7XG4gICAgfVxuXG4gICAgdmFyIGF2Y2MgPSBNUDQuYm94KE1QNC50eXBlcy5hdmNDLCBuZXcgVWludDhBcnJheShbXG4gICAgICAgICAgICAweDAxLCAgIC8vIHZlcnNpb25cbiAgICAgICAgICAgIHNwc1szXSwgLy8gcHJvZmlsZVxuICAgICAgICAgICAgc3BzWzRdLCAvLyBwcm9maWxlIGNvbXBhdFxuICAgICAgICAgICAgc3BzWzVdLCAvLyBsZXZlbFxuICAgICAgICAgICAgMHhmYyB8IDMsIC8vIGxlbmd0aFNpemVNaW51c09uZSwgaGFyZC1jb2RlZCB0byA0IGJ5dGVzXG4gICAgICAgICAgICAweEUwIHwgdHJhY2suc3BzLmxlbmd0aCAvLyAzYml0IHJlc2VydmVkICgxMTEpICsgbnVtT2ZTZXF1ZW5jZVBhcmFtZXRlclNldHNcbiAgICAgICAgICBdLmNvbmNhdChzcHMpLmNvbmNhdChbXG4gICAgICAgICAgICB0cmFjay5wcHMubGVuZ3RoIC8vIG51bU9mUGljdHVyZVBhcmFtZXRlclNldHNcbiAgICAgICAgICBdKS5jb25jYXQocHBzKSkpLCAvLyBcIlBQU1wiXG4gICAgICAgIHdpZHRoID0gdHJhY2sud2lkdGgsXG4gICAgICAgIGhlaWdodCA9IHRyYWNrLmhlaWdodDtcbiAgICAvL2NvbnNvbGUubG9nKCdhdmNjOicgKyBIZXguaGV4RHVtcChhdmNjKSk7XG4gICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLmF2YzEsIG5ldyBVaW50OEFycmF5KFtcbiAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAgICAgMHgwMCwgMHgwMSwgLy8gZGF0YV9yZWZlcmVuY2VfaW5kZXhcbiAgICAgICAgMHgwMCwgMHgwMCwgLy8gcHJlX2RlZmluZWRcbiAgICAgICAgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcHJlX2RlZmluZWRcbiAgICAgICAgKHdpZHRoID4+IDgpICYgMHhGRixcbiAgICAgICAgd2lkdGggJiAweGZmLCAvLyB3aWR0aFxuICAgICAgICAoaGVpZ2h0ID4+IDgpICYgMHhGRixcbiAgICAgICAgaGVpZ2h0ICYgMHhmZiwgLy8gaGVpZ2h0XG4gICAgICAgIDB4MDAsIDB4NDgsIDB4MDAsIDB4MDAsIC8vIGhvcml6cmVzb2x1dGlvblxuICAgICAgICAweDAwLCAweDQ4LCAweDAwLCAweDAwLCAvLyB2ZXJ0cmVzb2x1dGlvblxuICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxuICAgICAgICAweDAwLCAweDAxLCAvLyBmcmFtZV9jb3VudFxuICAgICAgICAweDEyLFxuICAgICAgICAweDY0LCAweDYxLCAweDY5LCAweDZDLCAvL2RhaWx5bW90aW9uL2hscy5qc1xuICAgICAgICAweDc5LCAweDZELCAweDZGLCAweDc0LFxuICAgICAgICAweDY5LCAweDZGLCAweDZFLCAweDJGLFxuICAgICAgICAweDY4LCAweDZDLCAweDczLCAweDJFLFxuICAgICAgICAweDZBLCAweDczLCAweDAwLCAweDAwLFxuICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgICAweDAwLCAweDAwLCAweDAwLCAvLyBjb21wcmVzc29ybmFtZVxuICAgICAgICAweDAwLCAweDE4LCAgIC8vIGRlcHRoID0gMjRcbiAgICAgICAgMHgxMSwgMHgxMV0pLCAvLyBwcmVfZGVmaW5lZCA9IC0xXG4gICAgICAgICAgYXZjYyxcbiAgICAgICAgICBNUDQuYm94KE1QNC50eXBlcy5idHJ0LCBuZXcgVWludDhBcnJheShbXG4gICAgICAgICAgICAweDAwLCAweDFjLCAweDljLCAweDgwLCAvLyBidWZmZXJTaXplREJcbiAgICAgICAgICAgIDB4MDAsIDB4MmQsIDB4YzYsIDB4YzAsIC8vIG1heEJpdHJhdGVcbiAgICAgICAgICAgIDB4MDAsIDB4MmQsIDB4YzYsIDB4YzBdKSkgLy8gYXZnQml0cmF0ZVxuICAgICAgICAgICk7XG4gIH1cblxuICBzdGF0aWMgZXNkcyh0cmFjaykge1xuICAgIHZhciBjb25maWdsZW4gPSB0cmFjay5jb25maWcubGVuZ3RoO1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShbXG4gICAgICAweDAwLCAvLyB2ZXJzaW9uIDBcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGZsYWdzXG5cbiAgICAgIDB4MDMsIC8vIGRlc2NyaXB0b3JfdHlwZVxuICAgICAgMHgxNytjb25maWdsZW4sIC8vIGxlbmd0aFxuICAgICAgMHgwMCwgMHgwMSwgLy9lc19pZFxuICAgICAgMHgwMCwgLy8gc3RyZWFtX3ByaW9yaXR5XG5cbiAgICAgIDB4MDQsIC8vIGRlc2NyaXB0b3JfdHlwZVxuICAgICAgMHgwZitjb25maWdsZW4sIC8vIGxlbmd0aFxuICAgICAgMHg0MCwgLy9jb2RlYyA6IG1wZWc0X2F1ZGlvXG4gICAgICAweDE1LCAvLyBzdHJlYW1fdHlwZVxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gYnVmZmVyX3NpemVcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIG1heEJpdHJhdGVcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGF2Z0JpdHJhdGVcblxuICAgICAgMHgwNSAvLyBkZXNjcmlwdG9yX3R5cGVcbiAgICAgIF0uY29uY2F0KFtjb25maWdsZW5dKS5jb25jYXQodHJhY2suY29uZmlnKS5jb25jYXQoWzB4MDYsIDB4MDEsIDB4MDJdKSk7IC8vIEdBU3BlY2lmaWNDb25maWcpKTsgLy8gbGVuZ3RoICsgYXVkaW8gY29uZmlnIGRlc2NyaXB0b3JcbiAgfVxuXG4gIHN0YXRpYyBtcDRhKHRyYWNrKSB7XG4gICAgdmFyIGF1ZGlvc2FtcGxlcmF0ZSA9IHRyYWNrLmF1ZGlvc2FtcGxlcmF0ZTtcbiAgICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5tcDRhLCBuZXcgVWludDhBcnJheShbXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAgIDB4MDAsIDB4MDEsIC8vIGRhdGFfcmVmZXJlbmNlX2luZGV4XG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAgIDB4MDAsIHRyYWNrLmNoYW5uZWxDb3VudCwgLy8gY2hhbm5lbGNvdW50XG4gICAgICAweDAwLCAweDEwLCAvLyBzYW1wbGVTaXplOjE2Yml0c1xuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWQyXG4gICAgICAoYXVkaW9zYW1wbGVyYXRlID4+IDgpICYgMHhGRixcbiAgICAgIGF1ZGlvc2FtcGxlcmF0ZSAmIDB4ZmYsIC8vXG4gICAgICAweDAwLCAweDAwXSksXG4gICAgICBNUDQuYm94KE1QNC50eXBlcy5lc2RzLCBNUDQuZXNkcyh0cmFjaykpKTtcbiAgfVxuXG4gIHN0YXRpYyBtcDModHJhY2spIHtcbiAgICB2YXIgYXVkaW9zYW1wbGVyYXRlID0gdHJhY2suYXVkaW9zYW1wbGVyYXRlO1xuICAgICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzWycubXAzJ10sIG5ldyBVaW50OEFycmF5KFtcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxuICAgICAgMHgwMCwgMHgwMSwgLy8gZGF0YV9yZWZlcmVuY2VfaW5kZXhcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxuICAgICAgMHgwMCwgdHJhY2suY2hhbm5lbENvdW50LCAvLyBjaGFubmVsY291bnRcbiAgICAgIDB4MDAsIDB4MTAsIC8vIHNhbXBsZVNpemU6MTZiaXRzXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZDJcbiAgICAgIChhdWRpb3NhbXBsZXJhdGUgPj4gOCkgJiAweEZGLFxuICAgICAgYXVkaW9zYW1wbGVyYXRlICYgMHhmZiwgLy9cbiAgICAgIDB4MDAsIDB4MDBdKSk7XG4gIH1cblxuICBzdGF0aWMgc3RzZCh0cmFjaykge1xuICAgIGlmICh0cmFjay50eXBlID09PSAnYXVkaW8nKSB7XG4gICAgICBpZiAoIXRyYWNrLmlzQUFDICYmIHRyYWNrLmNvZGVjID09PSAnbXAzJykge1xuICAgICAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMuc3RzZCwgTVA0LlNUU0QsIE1QNC5tcDModHJhY2spKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5zdHNkLCBNUDQuU1RTRCwgTVA0Lm1wNGEodHJhY2spKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLnN0c2QsIE1QNC5TVFNELCBNUDQuYXZjMSh0cmFjaykpO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyB0a2hkKHRyYWNrKSB7XG4gICAgdmFyIGlkID0gdHJhY2suaWQsXG4gICAgICAgIGR1cmF0aW9uID0gdHJhY2suZHVyYXRpb24qdHJhY2sudGltZXNjYWxlLFxuICAgICAgICB3aWR0aCA9IHRyYWNrLndpZHRoLFxuICAgICAgICBoZWlnaHQgPSB0cmFjay5oZWlnaHQ7XG4gICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLnRraGQsIG5ldyBVaW50OEFycmF5KFtcbiAgICAgIDB4MDAsIC8vIHZlcnNpb24gMFxuICAgICAgMHgwMCwgMHgwMCwgMHgwNywgLy8gZmxhZ3NcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGNyZWF0aW9uX3RpbWVcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIG1vZGlmaWNhdGlvbl90aW1lXG4gICAgICAoaWQgPj4gMjQpICYgMHhGRixcbiAgICAgIChpZCA+PiAxNikgJiAweEZGLFxuICAgICAgKGlkID4+IDgpICYgMHhGRixcbiAgICAgIGlkICYgMHhGRiwgLy8gdHJhY2tfSURcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgICAoZHVyYXRpb24gPj4gMjQpLFxuICAgICAgKGR1cmF0aW9uID4+IDE2KSAmIDB4RkYsXG4gICAgICAoZHVyYXRpb24gPj4gIDgpICYgMHhGRixcbiAgICAgIGR1cmF0aW9uICYgMHhGRiwgLy8gZHVyYXRpb25cbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxuICAgICAgMHgwMCwgMHgwMCwgLy8gbGF5ZXJcbiAgICAgIDB4MDAsIDB4MDAsIC8vIGFsdGVybmF0ZV9ncm91cFxuICAgICAgMHgwMCwgMHgwMCwgLy8gbm9uLWF1ZGlvIHRyYWNrIHZvbHVtZVxuICAgICAgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAgIDB4MDAsIDB4MDEsIDB4MDAsIDB4MDAsXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAweDAwLCAweDAxLCAweDAwLCAweDAwLFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgMHg0MCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gdHJhbnNmb3JtYXRpb246IHVuaXR5IG1hdHJpeFxuICAgICAgKHdpZHRoID4+IDgpICYgMHhGRixcbiAgICAgIHdpZHRoICYgMHhGRixcbiAgICAgIDB4MDAsIDB4MDAsIC8vIHdpZHRoXG4gICAgICAoaGVpZ2h0ID4+IDgpICYgMHhGRixcbiAgICAgIGhlaWdodCAmIDB4RkYsXG4gICAgICAweDAwLCAweDAwIC8vIGhlaWdodFxuICAgIF0pKTtcbiAgfVxuXG4gIHN0YXRpYyB0cmFmKHRyYWNrLGJhc2VNZWRpYURlY29kZVRpbWUpIHtcbiAgICB2YXIgc2FtcGxlRGVwZW5kZW5jeVRhYmxlID0gTVA0LnNkdHAodHJhY2spLFxuICAgICAgICBpZCA9IHRyYWNrLmlkO1xuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy50cmFmLFxuICAgICAgICAgICAgICAgTVA0LmJveChNUDQudHlwZXMudGZoZCwgbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgICAgICAgICAgICAweDAwLCAvLyB2ZXJzaW9uIDBcbiAgICAgICAgICAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gZmxhZ3NcbiAgICAgICAgICAgICAgICAgKGlkID4+IDI0KSxcbiAgICAgICAgICAgICAgICAgKGlkID4+IDE2KSAmIDBYRkYsXG4gICAgICAgICAgICAgICAgIChpZCA+PiA4KSAmIDBYRkYsXG4gICAgICAgICAgICAgICAgIChpZCAmIDB4RkYpIC8vIHRyYWNrX0lEXG4gICAgICAgICAgICAgICBdKSksXG4gICAgICAgICAgICAgICBNUDQuYm94KE1QNC50eXBlcy50ZmR0LCBuZXcgVWludDhBcnJheShbXG4gICAgICAgICAgICAgICAgIDB4MDAsIC8vIHZlcnNpb24gMFxuICAgICAgICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLCAvLyBmbGFnc1xuICAgICAgICAgICAgICAgICAoYmFzZU1lZGlhRGVjb2RlVGltZSA+PjI0KSxcbiAgICAgICAgICAgICAgICAgKGJhc2VNZWRpYURlY29kZVRpbWUgPj4gMTYpICYgMFhGRixcbiAgICAgICAgICAgICAgICAgKGJhc2VNZWRpYURlY29kZVRpbWUgPj4gOCkgJiAwWEZGLFxuICAgICAgICAgICAgICAgICAoYmFzZU1lZGlhRGVjb2RlVGltZSAmIDB4RkYpIC8vIGJhc2VNZWRpYURlY29kZVRpbWVcbiAgICAgICAgICAgICAgIF0pKSxcbiAgICAgICAgICAgICAgIE1QNC50cnVuKHRyYWNrLFxuICAgICAgICAgICAgICAgICAgICBzYW1wbGVEZXBlbmRlbmN5VGFibGUubGVuZ3RoICtcbiAgICAgICAgICAgICAgICAgICAgMTYgKyAvLyB0ZmhkXG4gICAgICAgICAgICAgICAgICAgIDE2ICsgLy8gdGZkdFxuICAgICAgICAgICAgICAgICAgICA4ICsgIC8vIHRyYWYgaGVhZGVyXG4gICAgICAgICAgICAgICAgICAgIDE2ICsgLy8gbWZoZFxuICAgICAgICAgICAgICAgICAgICA4ICsgIC8vIG1vb2YgaGVhZGVyXG4gICAgICAgICAgICAgICAgICAgIDgpLCAgLy8gbWRhdCBoZWFkZXJcbiAgICAgICAgICAgICAgIHNhbXBsZURlcGVuZGVuY3lUYWJsZSk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSB0cmFjayBib3guXG4gICAqIEBwYXJhbSB0cmFjayB7b2JqZWN0fSBhIHRyYWNrIGRlZmluaXRpb25cbiAgICogQHJldHVybiB7VWludDhBcnJheX0gdGhlIHRyYWNrIGJveFxuICAgKi9cbiAgc3RhdGljIHRyYWsodHJhY2spIHtcbiAgICB0cmFjay5kdXJhdGlvbiA9IHRyYWNrLmR1cmF0aW9uIHx8IDB4ZmZmZmZmZmY7XG4gICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLnRyYWssIE1QNC50a2hkKHRyYWNrKSwgTVA0Lm1kaWEodHJhY2spKTtcbiAgfVxuXG4gIHN0YXRpYyB0cmV4KHRyYWNrKSB7XG4gICAgdmFyIGlkID0gdHJhY2suaWQ7XG4gICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLnRyZXgsIG5ldyBVaW50OEFycmF5KFtcbiAgICAgIDB4MDAsIC8vIHZlcnNpb24gMFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gZmxhZ3NcbiAgICAgKGlkID4+IDI0KSxcbiAgICAgKGlkID4+IDE2KSAmIDBYRkYsXG4gICAgIChpZCA+PiA4KSAmIDBYRkYsXG4gICAgIChpZCAmIDB4RkYpLCAvLyB0cmFja19JRFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMSwgLy8gZGVmYXVsdF9zYW1wbGVfZGVzY3JpcHRpb25faW5kZXhcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGRlZmF1bHRfc2FtcGxlX2R1cmF0aW9uXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyBkZWZhdWx0X3NhbXBsZV9zaXplXG4gICAgICAweDAwLCAweDAxLCAweDAwLCAweDAxIC8vIGRlZmF1bHRfc2FtcGxlX2ZsYWdzXG4gICAgXSkpO1xuICB9XG5cbiAgc3RhdGljIHRydW4odHJhY2ssIG9mZnNldCkge1xuICAgIHZhciBzYW1wbGVzPSB0cmFjay5zYW1wbGVzIHx8IFtdLFxuICAgICAgICBsZW4gPSBzYW1wbGVzLmxlbmd0aCxcbiAgICAgICAgYXJyYXlsZW4gPSAxMiArICgxNiAqIGxlbiksXG4gICAgICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlsZW4pLFxuICAgICAgICBpLHNhbXBsZSxkdXJhdGlvbixzaXplLGZsYWdzLGN0cztcbiAgICBvZmZzZXQgKz0gOCArIGFycmF5bGVuO1xuICAgIGFycmF5LnNldChbXG4gICAgICAweDAwLCAvLyB2ZXJzaW9uIDBcbiAgICAgIDB4MDAsIDB4MGYsIDB4MDEsIC8vIGZsYWdzXG4gICAgICAobGVuID4+PiAyNCkgJiAweEZGLFxuICAgICAgKGxlbiA+Pj4gMTYpICYgMHhGRixcbiAgICAgIChsZW4gPj4+IDgpICYgMHhGRixcbiAgICAgIGxlbiAmIDB4RkYsIC8vIHNhbXBsZV9jb3VudFxuICAgICAgKG9mZnNldCA+Pj4gMjQpICYgMHhGRixcbiAgICAgIChvZmZzZXQgPj4+IDE2KSAmIDB4RkYsXG4gICAgICAob2Zmc2V0ID4+PiA4KSAmIDB4RkYsXG4gICAgICBvZmZzZXQgJiAweEZGIC8vIGRhdGFfb2Zmc2V0XG4gICAgXSwwKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHNhbXBsZSA9IHNhbXBsZXNbaV07XG4gICAgICBkdXJhdGlvbiA9IHNhbXBsZS5kdXJhdGlvbjtcbiAgICAgIHNpemUgPSBzYW1wbGUuc2l6ZTtcbiAgICAgIGZsYWdzID0gc2FtcGxlLmZsYWdzO1xuICAgICAgY3RzID0gc2FtcGxlLmN0cztcbiAgICAgIGFycmF5LnNldChbXG4gICAgICAgIChkdXJhdGlvbiA+Pj4gMjQpICYgMHhGRixcbiAgICAgICAgKGR1cmF0aW9uID4+PiAxNikgJiAweEZGLFxuICAgICAgICAoZHVyYXRpb24gPj4+IDgpICYgMHhGRixcbiAgICAgICAgZHVyYXRpb24gJiAweEZGLCAvLyBzYW1wbGVfZHVyYXRpb25cbiAgICAgICAgKHNpemUgPj4+IDI0KSAmIDB4RkYsXG4gICAgICAgIChzaXplID4+PiAxNikgJiAweEZGLFxuICAgICAgICAoc2l6ZSA+Pj4gOCkgJiAweEZGLFxuICAgICAgICBzaXplICYgMHhGRiwgLy8gc2FtcGxlX3NpemVcbiAgICAgICAgKGZsYWdzLmlzTGVhZGluZyA8PCAyKSB8IGZsYWdzLmRlcGVuZHNPbixcbiAgICAgICAgKGZsYWdzLmlzRGVwZW5kZWRPbiA8PCA2KSB8XG4gICAgICAgICAgKGZsYWdzLmhhc1JlZHVuZGFuY3kgPDwgNCkgfFxuICAgICAgICAgIChmbGFncy5wYWRkaW5nVmFsdWUgPDwgMSkgfFxuICAgICAgICAgIGZsYWdzLmlzTm9uU3luYyxcbiAgICAgICAgZmxhZ3MuZGVncmFkUHJpbyAmIDB4RjAgPDwgOCxcbiAgICAgICAgZmxhZ3MuZGVncmFkUHJpbyAmIDB4MEYsIC8vIHNhbXBsZV9mbGFnc1xuICAgICAgICAoY3RzID4+PiAyNCkgJiAweEZGLFxuICAgICAgICAoY3RzID4+PiAxNikgJiAweEZGLFxuICAgICAgICAoY3RzID4+PiA4KSAmIDB4RkYsXG4gICAgICAgIGN0cyAmIDB4RkYgLy8gc2FtcGxlX2NvbXBvc2l0aW9uX3RpbWVfb2Zmc2V0XG4gICAgICBdLDEyKzE2KmkpO1xuICAgIH1cbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMudHJ1biwgYXJyYXkpO1xuICB9XG5cbiAgc3RhdGljIGluaXRTZWdtZW50KHRyYWNrcykge1xuICAgIGlmICghTVA0LnR5cGVzKSB7XG4gICAgICBNUDQuaW5pdCgpO1xuICAgIH1cbiAgICB2YXIgbW92aWUgPSBNUDQubW9vdih0cmFja3MpLCByZXN1bHQ7XG4gICAgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoTVA0LkZUWVAuYnl0ZUxlbmd0aCArIG1vdmllLmJ5dGVMZW5ndGgpO1xuICAgIHJlc3VsdC5zZXQoTVA0LkZUWVApO1xuICAgIHJlc3VsdC5zZXQobW92aWUsIE1QNC5GVFlQLmJ5dGVMZW5ndGgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTVA0O1xuIiwiLyoqXG4gKiBmTVA0IHJlbXV4ZXJcbiovXG5cblxuaW1wb3J0IEFBQyBmcm9tICcuLi9oZWxwZXIvYWFjJztcbmltcG9ydCBFdmVudCBmcm9tICcuLi9ldmVudHMnO1xuaW1wb3J0IHtsb2dnZXJ9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XG5pbXBvcnQgTVA0IGZyb20gJy4uL3JlbXV4L21wNC1nZW5lcmF0b3InO1xuaW1wb3J0IHtFcnJvclR5cGVzLCBFcnJvckRldGFpbHN9IGZyb20gJy4uL2Vycm9ycyc7XG5cbmNsYXNzIE1QNFJlbXV4ZXIge1xuICBjb25zdHJ1Y3RvcihvYnNlcnZlciwgaWQsIGNvbmZpZywgdHlwZVN1cHBvcnRlZCkge1xuICAgIHRoaXMub2JzZXJ2ZXIgPSBvYnNlcnZlcjtcbiAgICB0aGlzLmlkID0gaWQ7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgdGhpcy50eXBlU3VwcG9ydGVkID0gdHlwZVN1cHBvcnRlZDtcbiAgICB0aGlzLklTR2VuZXJhdGVkID0gZmFsc2U7XG4gICAgdGhpcy5QRVMyTVA0U0NBTEVGQUNUT1IgPSA0O1xuICAgIHRoaXMuUEVTX1RJTUVTQ0FMRSA9IDkwMDAwO1xuICAgIHRoaXMuTVA0X1RJTUVTQ0FMRSA9IHRoaXMuUEVTX1RJTUVTQ0FMRSAvIHRoaXMuUEVTMk1QNFNDQUxFRkFDVE9SO1xuICB9XG5cbiAgZ2V0IHBhc3N0aHJvdWdoKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gIH1cblxuICBpbnNlcnREaXNjb250aW51aXR5KCkge1xuICAgIHRoaXMuX2luaXRQVFMgPSB0aGlzLl9pbml0RFRTID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgc3dpdGNoTGV2ZWwoKSB7XG4gICAgdGhpcy5JU0dlbmVyYXRlZCA9IGZhbHNlO1xuICB9XG5cbiAgcmVtdXgobGV2ZWwsc24sY2MsYXVkaW9UcmFjayx2aWRlb1RyYWNrLGlkM1RyYWNrLHRleHRUcmFjayx0aW1lT2Zmc2V0LCBjb250aWd1b3VzLGFjY3VyYXRlVGltZU9mZnNldCxkZWZhdWx0SW5pdFBUUykge1xuICAgIHRoaXMubGV2ZWwgPSBsZXZlbDtcbiAgICB0aGlzLnNuID0gc247XG4gICAgLy8gZ2VuZXJhdGUgSW5pdCBTZWdtZW50IGlmIG5lZWRlZFxuICAgIGlmICghdGhpcy5JU0dlbmVyYXRlZCkge1xuICAgICAgdGhpcy5nZW5lcmF0ZUlTKGF1ZGlvVHJhY2ssdmlkZW9UcmFjayx0aW1lT2Zmc2V0LGNjKTtcbiAgICB9XG5cbiAgICBpZigoZGVmYXVsdEluaXRQVFMhPT1udWxsKSl7XG4gICAgICB0aGlzLl9pbml0UFRTPXRoaXMuX2luaXREVFM9IGRlZmF1bHRJbml0UFRTO1xuICAgIH1cblxuICAgIGlmICh0aGlzLklTR2VuZXJhdGVkKSB7XG4gICAgICAvLyBQdXJwb3NlZnVsbHkgcmVtdXhpbmcgYXVkaW8gYmVmb3JlIHZpZGVvLCBzbyB0aGF0IHJlbXV4VmlkZW8gY2FuIHVzZSBuZXh0QXVkaW9QdHMsIHdoaWNoIGlzXG4gICAgICAvLyBjYWxjdWxhdGVkIGluIHJlbXV4QXVkaW8uXG4gICAgICAvL2xvZ2dlci5sb2coJ25iIEFBQyBzYW1wbGVzOicgKyBhdWRpb1RyYWNrLnNhbXBsZXMubGVuZ3RoKTtcbiAgICAgIGlmIChhdWRpb1RyYWNrLnNhbXBsZXMubGVuZ3RoKSB7XG4gICAgICAgIGxldCBhdWRpb0RhdGEgPSB0aGlzLnJlbXV4QXVkaW8oYXVkaW9UcmFjayx0aW1lT2Zmc2V0LGNvbnRpZ3VvdXMsYWNjdXJhdGVUaW1lT2Zmc2V0KTtcbiAgICAgICAgLy9sb2dnZXIubG9nKCduYiBBVkMgc2FtcGxlczonICsgdmlkZW9UcmFjay5zYW1wbGVzLmxlbmd0aCk7XG4gICAgICAgIGlmICh2aWRlb1RyYWNrLnNhbXBsZXMubGVuZ3RoKSB7XG4gICAgICAgICAgbGV0IGF1ZGlvVHJhY2tMZW5ndGg7XG4gICAgICAgICAgaWYgKGF1ZGlvRGF0YSkge1xuICAgICAgICAgICAgYXVkaW9UcmFja0xlbmd0aCA9IGF1ZGlvRGF0YS5lbmRQVFMgLSBhdWRpb0RhdGEuc3RhcnRQVFM7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMucmVtdXhWaWRlbyh2aWRlb1RyYWNrLHRpbWVPZmZzZXQsY29udGlndW91cyxhdWRpb1RyYWNrTGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IHZpZGVvRGF0YTtcbiAgICAgICAgLy9sb2dnZXIubG9nKCduYiBBVkMgc2FtcGxlczonICsgdmlkZW9UcmFjay5zYW1wbGVzLmxlbmd0aCk7XG4gICAgICAgIGlmICh2aWRlb1RyYWNrLnNhbXBsZXMubGVuZ3RoKSB7XG4gICAgICAgICAgdmlkZW9EYXRhID0gdGhpcy5yZW11eFZpZGVvKHZpZGVvVHJhY2ssdGltZU9mZnNldCxjb250aWd1b3VzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmlkZW9EYXRhICYmIGF1ZGlvVHJhY2suY29kZWMpIHtcbiAgICAgICAgICB0aGlzLnJlbXV4RW1wdHlBdWRpbyhhdWRpb1RyYWNrLCB0aW1lT2Zmc2V0LCBjb250aWd1b3VzLCB2aWRlb0RhdGEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vbG9nZ2VyLmxvZygnbmIgSUQzIHNhbXBsZXM6JyArIGF1ZGlvVHJhY2suc2FtcGxlcy5sZW5ndGgpO1xuICAgIGlmIChpZDNUcmFjay5zYW1wbGVzLmxlbmd0aCkge1xuICAgICAgdGhpcy5yZW11eElEMyhpZDNUcmFjayx0aW1lT2Zmc2V0KTtcbiAgICB9XG4gICAgLy9sb2dnZXIubG9nKCduYiBJRDMgc2FtcGxlczonICsgYXVkaW9UcmFjay5zYW1wbGVzLmxlbmd0aCk7XG4gICAgaWYgKHRleHRUcmFjay5zYW1wbGVzLmxlbmd0aCkge1xuICAgICAgdGhpcy5yZW11eFRleHQodGV4dFRyYWNrLHRpbWVPZmZzZXQpO1xuICAgIH1cbiAgICAvL25vdGlmeSBlbmQgb2YgcGFyc2luZ1xuICAgIHRoaXMub2JzZXJ2ZXIudHJpZ2dlcihFdmVudC5GUkFHX1BBUlNFRCwgeyBpZCA6IHRoaXMuaWQgLCBsZXZlbCA6IHRoaXMubGV2ZWwsIHNuIDogdGhpcy5zbn0pO1xuICB9XG5cbiAgZ2VuZXJhdGVJUyhhdWRpb1RyYWNrLHZpZGVvVHJhY2ssdGltZU9mZnNldCxjYykge1xuICAgIHZhciBvYnNlcnZlciA9IHRoaXMub2JzZXJ2ZXIsXG4gICAgICAgIGF1ZGlvU2FtcGxlcyA9IGF1ZGlvVHJhY2suc2FtcGxlcyxcbiAgICAgICAgdmlkZW9TYW1wbGVzID0gdmlkZW9UcmFjay5zYW1wbGVzLFxuICAgICAgICBwZXNUaW1lU2NhbGUgPSB0aGlzLlBFU19USU1FU0NBTEUsXG4gICAgICAgIHR5cGVTdXBwb3J0ZWQgPSB0aGlzLnR5cGVTdXBwb3J0ZWQsXG4gICAgICAgIGNvbnRhaW5lciA9ICdhdWRpby9tcDQnLFxuICAgICAgICB0cmFja3MgPSB7fSxcbiAgICAgICAgZGF0YSA9IHsgaWQgOiB0aGlzLmlkLCBsZXZlbCA6IHRoaXMubGV2ZWwsIHNuIDogdGhpcy5zbiwgdHJhY2tzIDogdHJhY2tzLCB1bmlxdWUgOiBmYWxzZSB9LFxuICAgICAgICBjb21wdXRlUFRTRFRTID0gKHRoaXMuX2luaXRQVFMgPT09IHVuZGVmaW5lZCksXG4gICAgICAgIGluaXRQVFMsIGluaXREVFM7XG5cbiAgICBpZiAoY29tcHV0ZVBUU0RUUykge1xuICAgICAgaW5pdFBUUyA9IGluaXREVFMgPSBJbmZpbml0eTtcbiAgICB9XG4gICAgaWYgKGF1ZGlvVHJhY2suY29uZmlnICYmIGF1ZGlvU2FtcGxlcy5sZW5ndGgpIHtcbiAgICAgIGF1ZGlvVHJhY2sudGltZXNjYWxlID0gYXVkaW9UcmFjay5hdWRpb3NhbXBsZXJhdGU7XG4gICAgICAvLyBNUDQgZHVyYXRpb24gKHRyYWNrIGR1cmF0aW9uIGluIHNlY29uZHMgbXVsdGlwbGllZCBieSB0aW1lc2NhbGUpIGlzIGNvZGVkIG9uIDMyIGJpdHNcbiAgICAgIC8vIHdlIGtub3cgdGhhdCBlYWNoIEFBQyBzYW1wbGUgY29udGFpbnMgMTAyNCBmcmFtZXMuLi4uXG4gICAgICAvLyBpbiBvcmRlciB0byBhdm9pZCBvdmVyZmxvd2luZyB0aGUgMzIgYml0IGNvdW50ZXIgZm9yIGxhcmdlIGR1cmF0aW9uLCB3ZSB1c2Ugc21hbGxlciB0aW1lc2NhbGUgKHRpbWVzY2FsZS9nY2QpXG4gICAgICAvLyB3ZSBqdXN0IG5lZWQgdG8gZW5zdXJlIHRoYXQgQUFDIHNhbXBsZSBkdXJhdGlvbiB3aWxsIHN0aWxsIGJlIGFuIGludGVnZXIgKHdpbGwgYmUgMTAyNC9nY2QpXG4gICAgICBpZiAoYXVkaW9UcmFjay50aW1lc2NhbGUgKiBhdWRpb1RyYWNrLmR1cmF0aW9uID4gTWF0aC5wb3coMiwgMzIpKSB7XG4gICAgICAgIGxldCBncmVhdGVzdENvbW1vbkRpdmlzb3IgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgICAgICBpZiAoICEgYikge1xuICAgICAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGdyZWF0ZXN0Q29tbW9uRGl2aXNvcihiLCBhICUgYik7XG4gICAgICAgIH07XG4gICAgICAgIGF1ZGlvVHJhY2sudGltZXNjYWxlID0gYXVkaW9UcmFjay5hdWRpb3NhbXBsZXJhdGUgLyBncmVhdGVzdENvbW1vbkRpdmlzb3IoYXVkaW9UcmFjay5hdWRpb3NhbXBsZXJhdGUsKGF1ZGlvVHJhY2suaXNBQUMgPyAxMDI0IDogMTE1MikpO1xuICAgICAgfVxuICAgICAgbG9nZ2VyLmxvZyAoJ2F1ZGlvIG1wNCB0aW1lc2NhbGUgOicrIGF1ZGlvVHJhY2sudGltZXNjYWxlKTtcbiAgICAgIGlmICghYXVkaW9UcmFjay5pc0FBQykge1xuICAgICAgICBpZiAodHlwZVN1cHBvcnRlZC5tcGVnKSB7IC8vIENocm9tZSBhbmQgU2FmYXJpXG4gICAgICAgICAgY29udGFpbmVyID0gJ2F1ZGlvL21wZWcnO1xuICAgICAgICAgIGF1ZGlvVHJhY2suY29kZWMgPSAnJztcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlU3VwcG9ydGVkLm1wMykgeyAvLyBGaXJlZm94XG4gICAgICAgICAgYXVkaW9UcmFjay5jb2RlYyA9ICdtcDMnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0cmFja3MuYXVkaW8gPSB7XG4gICAgICAgIGNvbnRhaW5lciA6IGNvbnRhaW5lcixcbiAgICAgICAgY29kZWMgOiAgYXVkaW9UcmFjay5jb2RlYyxcbiAgICAgICAgaW5pdFNlZ21lbnQgOiAhYXVkaW9UcmFjay5pc0FBQyAmJiB0eXBlU3VwcG9ydGVkLm1wZWcgPyBuZXcgVWludDhBcnJheSgpIDogTVA0LmluaXRTZWdtZW50KFthdWRpb1RyYWNrXSksXG4gICAgICAgIG1ldGFkYXRhIDoge1xuICAgICAgICAgIGNoYW5uZWxDb3VudCA6IGF1ZGlvVHJhY2suY2hhbm5lbENvdW50XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBpZiAoY29tcHV0ZVBUU0RUUykge1xuICAgICAgICAvLyByZW1lbWJlciBmaXJzdCBQVFMgb2YgdGhpcyBkZW11eGluZyBjb250ZXh0LiBmb3IgYXVkaW8sIFBUUyA9IERUU1xuICAgICAgICBpbml0UFRTID0gaW5pdERUUyA9IGF1ZGlvU2FtcGxlc1swXS5wdHMgLSBwZXNUaW1lU2NhbGUgKiB0aW1lT2Zmc2V0O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh2aWRlb1RyYWNrLnNwcyAmJiB2aWRlb1RyYWNrLnBwcyAmJiB2aWRlb1NhbXBsZXMubGVuZ3RoKSB7XG4gICAgICB2aWRlb1RyYWNrLnRpbWVzY2FsZSA9IHRoaXMuTVA0X1RJTUVTQ0FMRTtcbiAgICAgIHRyYWNrcy52aWRlbyA9IHtcbiAgICAgICAgY29udGFpbmVyIDogJ3ZpZGVvL21wNCcsXG4gICAgICAgIGNvZGVjIDogIHZpZGVvVHJhY2suY29kZWMsXG4gICAgICAgIGluaXRTZWdtZW50IDogTVA0LmluaXRTZWdtZW50KFt2aWRlb1RyYWNrXSksXG4gICAgICAgIG1ldGFkYXRhIDoge1xuICAgICAgICAgIHdpZHRoIDogdmlkZW9UcmFjay53aWR0aCxcbiAgICAgICAgICBoZWlnaHQgOiB2aWRlb1RyYWNrLmhlaWdodFxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgaWYgKGNvbXB1dGVQVFNEVFMpIHtcbiAgICAgICAgaW5pdFBUUyA9IE1hdGgubWluKGluaXRQVFMsdmlkZW9TYW1wbGVzWzBdLnB0cyAtIHBlc1RpbWVTY2FsZSAqIHRpbWVPZmZzZXQpO1xuICAgICAgICBpbml0RFRTID0gTWF0aC5taW4oaW5pdERUUyx2aWRlb1NhbXBsZXNbMF0uZHRzIC0gcGVzVGltZVNjYWxlICogdGltZU9mZnNldCk7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXIudHJpZ2dlcihFdmVudC5JTklUX1BUU19GT1VORCwge2luaXRQVFN9KTtcbiAgICAgICAgdGhpcy5vYnNlcnZlci50cmlnZ2VyKEV2ZW50LklOSVRfUFRTX0ZPVU5ELCB7IGlkOiB0aGlzLmlkLCBpbml0UFRTOiBpbml0UFRTLCBjYzogY2N9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZihPYmplY3Qua2V5cyh0cmFja3MpLmxlbmd0aCkge1xuICAgICAgb2JzZXJ2ZXIudHJpZ2dlcihFdmVudC5GUkFHX1BBUlNJTkdfSU5JVF9TRUdNRU5ULGRhdGEpO1xuICAgICAgdGhpcy5JU0dlbmVyYXRlZCA9IHRydWU7XG4gICAgICBpZiAoY29tcHV0ZVBUU0RUUykge1xuICAgICAgICB0aGlzLl9pbml0UFRTID0gaW5pdFBUUztcbiAgICAgICAgdGhpcy5faW5pdERUUyA9IGluaXREVFM7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG9ic2VydmVyLnRyaWdnZXIoRXZlbnQuRVJST1IsIHt0eXBlIDogRXJyb3JUeXBlcy5NRURJQV9FUlJPUiwgaWQgOiB0aGlzLmlkLCBkZXRhaWxzOiBFcnJvckRldGFpbHMuRlJBR19QQVJTSU5HX0VSUk9SLCBmYXRhbDogZmFsc2UsIHJlYXNvbjogJ25vIGF1ZGlvL3ZpZGVvIHNhbXBsZXMgZm91bmQnfSk7XG4gICAgfVxuICB9XG5cbiAgcmVtdXhWaWRlbyh0cmFjaywgdGltZU9mZnNldCwgY29udGlndW91cywgYXVkaW9UcmFja0xlbmd0aCkge1xuICAgIHZhciBvZmZzZXQgPSA4LFxuICAgICAgICBwZXNUaW1lU2NhbGUgPSB0aGlzLlBFU19USU1FU0NBTEUsXG4gICAgICAgIHBlczJtcDRTY2FsZUZhY3RvciA9IHRoaXMuUEVTMk1QNFNDQUxFRkFDVE9SLFxuICAgICAgICBtcDRTYW1wbGVEdXJhdGlvbixcbiAgICAgICAgbWRhdCwgbW9vZixcbiAgICAgICAgZmlyc3RQVFMsIGZpcnN0RFRTLFxuICAgICAgICBuZXh0RFRTLFxuICAgICAgICBsYXN0UFRTLCBsYXN0RFRTLFxuICAgICAgICBpbnB1dFNhbXBsZXMgPSB0cmFjay5zYW1wbGVzLFxuICAgICAgICBvdXRwdXRTYW1wbGVzID0gW10sXG4gICAgICAgIG5iU2FtcGxlcyA9IGlucHV0U2FtcGxlcy5sZW5ndGgsXG4gICAgICAgIHB0c05vcm1hbGl6ZSA9IHRoaXMuX1BUU05vcm1hbGl6ZSxcbiAgICAgICAgaW5pdERUUyA9IHRoaXMuX2luaXREVFM7XG5cbiAgLy8gZm9yIChsZXQgaSA9IDA7IGkgPCB0cmFjay5zYW1wbGVzLmxlbmd0aDsgaSsrKSB7XG4gIC8vICAgbGV0IGF2Y1NhbXBsZSA9IHRyYWNrLnNhbXBsZXNbaV07XG4gIC8vICAgbGV0IHVuaXRzID0gYXZjU2FtcGxlLnVuaXRzLnVuaXRzO1xuICAvLyAgIGxldCB1bml0c1N0cmluZyA9ICcnO1xuICAvLyAgIGZvciAobGV0IGogPSAwOyBqIDwgdW5pdHMubGVuZ3RoIDsgaisrKSB7XG4gIC8vICAgICB1bml0c1N0cmluZyArPSB1bml0c1tqXS50eXBlICsgJywnO1xuICAvLyAgICAgaWYgKHVuaXRzW2pdLmRhdGEubGVuZ3RoIDwgNTAwKSB7XG4gIC8vICAgICAgIHVuaXRzU3RyaW5nICs9IEhleC5oZXhEdW1wKHVuaXRzW2pdLmRhdGEpO1xuICAvLyAgICAgfVxuICAvLyAgIH1cbiAgLy8gICBsb2dnZXIubG9nKGF2Y1NhbXBsZS5wdHMgKyAnLycgKyBhdmNTYW1wbGUuZHRzICsgJywnICsgdW5pdHNTdHJpbmcgKyBhdmNTYW1wbGUudW5pdHMubGVuZ3RoKTtcbiAgLy8gfVxuXG4gICAgLy8gc29ydCB2aWRlbyBzYW1wbGVzIGJ5IERUUyBvcmRlclxuICAgIGlucHV0U2FtcGxlcy5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgIHJldHVybiAoYS5kdHMtYi5kdHMpO1xuICAgIH0pO1xuXG4gICAgLy8gaGFuZGxlIGJyb2tlbiBzdHJlYW1zIHdpdGggUFRTIDwgRFRTLCB0b2xlcmFuY2UgdXAgMjAwbXMgKDE4MDAwIGluIDkwa0h6IHRpbWVzY2FsZSlcbiAgICBsZXQgUFRTRFRTc2hpZnQgPSBpbnB1dFNhbXBsZXMucmVkdWNlKCAocHJldiwgY3VycikgPT4gTWF0aC5tYXgoTWF0aC5taW4ocHJldixjdXJyLnB0cy1jdXJyLmR0cyksLTE4MDAwKSwwKTtcbiAgICBpZiAoUFRTRFRTc2hpZnQgPCAwKSB7XG4gICAgICBsb2dnZXIud2FybihgUFRTIDwgRFRTIGRldGVjdGVkIGluIHZpZGVvIHNhbXBsZXMsIHNoaWZ0aW5nIERUUyBieSAke01hdGgucm91bmQoUFRTRFRTc2hpZnQvOTApfSBtcyB0byBvdmVyY29tZSB0aGlzIGlzc3VlYCk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0U2FtcGxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpbnB1dFNhbXBsZXNbaV0uZHRzICs9IFBUU0RUU3NoaWZ0O1xuICAgICAgfVxuICAgIH1cblxuICAvLyBQVFMgaXMgY29kZWQgb24gMzNiaXRzLCBhbmQgY2FuIGxvb3AgZnJvbSAtMl4zMiB0byAyXjMyXG4gIC8vIHB0c05vcm1hbGl6ZSB3aWxsIG1ha2UgUFRTL0RUUyB2YWx1ZSBtb25vdG9uaWMsIHdlIHVzZSBsYXN0IGtub3duIERUUyB2YWx1ZSBhcyByZWZlcmVuY2UgdmFsdWVcbiAgIGxldCBuZXh0QXZjRHRzO1xuICAgLy8gY29udGlndW91cyBmcmFnbWVudHMgYXJlIGNvbnNlY3V0aXZlIGZyYWdtZW50cyBmcm9tIHNhbWUgcXVhbGl0eSBsZXZlbCAoc2FtZSBsZXZlbCwgbmV3IFNOID0gb2xkIFNOICsgMSlcbiAgICBpZiAoY29udGlndW91cykge1xuICAgICAgLy8gaWYgcGFyc2VkIGZyYWdtZW50IGlzIGNvbnRpZ3VvdXMgd2l0aCBsYXN0IG9uZSwgbGV0J3MgdXNlIGxhc3QgRFRTIHZhbHVlIGFzIHJlZmVyZW5jZVxuICAgICAgbmV4dEF2Y0R0cyA9IHRoaXMubmV4dEF2Y0R0cztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaWYgbm90IGNvbnRpZ3VvdXMsIGxldCdzIHVzZSB0YXJnZXQgdGltZU9mZnNldFxuICAgICAgbmV4dEF2Y0R0cyA9IHRpbWVPZmZzZXQqcGVzVGltZVNjYWxlO1xuICAgIH1cblxuICAgIC8vIGNvbXB1dGUgZmlyc3QgRFRTIGFuZCBsYXN0IERUUywgbm9ybWFsaXplIHRoZW0gYWdhaW5zdCByZWZlcmVuY2UgdmFsdWVcbiAgICBsZXQgc2FtcGxlID0gaW5wdXRTYW1wbGVzWzBdO1xuICAgIGZpcnN0RFRTID0gIE1hdGgubWF4KHB0c05vcm1hbGl6ZShzYW1wbGUuZHRzIC0gaW5pdERUUyxuZXh0QXZjRHRzKSwwKTtcbiAgICBmaXJzdFBUUyA9ICBNYXRoLm1heChwdHNOb3JtYWxpemUoc2FtcGxlLnB0cyAtIGluaXREVFMsbmV4dEF2Y0R0cyksMCk7XG5cbiAgICAvLyBjaGVjayB0aW1lc3RhbXAgY29udGludWl0eSBhY2Nyb3NzIGNvbnNlY3V0aXZlIGZyYWdtZW50cyAodGhpcyBpcyB0byByZW1vdmUgaW50ZXItZnJhZ21lbnQgZ2FwL2hvbGUpXG4gICAgbGV0IGRlbHRhID0gTWF0aC5yb3VuZCgoZmlyc3REVFMgLSBuZXh0QXZjRHRzKSAvIDkwKTtcbiAgICAvLyBpZiBmcmFnbWVudCBhcmUgY29udGlndW91cywgZGV0ZWN0IGhvbGUvb3ZlcmxhcHBpbmcgYmV0d2VlbiBmcmFnbWVudHNcbiAgICBpZiAoY29udGlndW91cykge1xuICAgICAgaWYgKGRlbHRhKSB7XG4gICAgICAgIGlmIChkZWx0YSA+IDEpIHtcbiAgICAgICAgICBsb2dnZXIubG9nKGBBVkM6JHtkZWx0YX0gbXMgaG9sZSBiZXR3ZWVuIGZyYWdtZW50cyBkZXRlY3RlZCxmaWxsaW5nIGl0YCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZGVsdGEgPCAtMSkge1xuICAgICAgICAgIGxvZ2dlci5sb2coYEFWQzokeygtZGVsdGEpfSBtcyBvdmVybGFwcGluZyBiZXR3ZWVuIGZyYWdtZW50cyBkZXRlY3RlZGApO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJlbW92ZSBob2xlL2dhcCA6IHNldCBEVFMgdG8gbmV4dCBleHBlY3RlZCBEVFNcbiAgICAgICAgZmlyc3REVFMgPSBuZXh0QXZjRHRzO1xuICAgICAgICBpbnB1dFNhbXBsZXNbMF0uZHRzID0gZmlyc3REVFMgKyBpbml0RFRTO1xuICAgICAgICAvLyBvZmZzZXQgUFRTIGFzIHdlbGwsIGVuc3VyZSB0aGF0IFBUUyBpcyBzbWFsbGVyIG9yIGVxdWFsIHRoYW4gbmV3IERUU1xuICAgICAgICBmaXJzdFBUUyA9IE1hdGgubWF4KGZpcnN0UFRTIC0gZGVsdGEsIG5leHRBdmNEdHMpO1xuICAgICAgICBpbnB1dFNhbXBsZXNbMF0ucHRzID0gZmlyc3RQVFMgKyBpbml0RFRTO1xuICAgICAgICBsb2dnZXIubG9nKGBWaWRlby9QVFMvRFRTIGFkanVzdGVkOiAke01hdGgucm91bmQoZmlyc3RQVFMvOTApfS8ke01hdGgucm91bmQoZmlyc3REVFMvOTApfSxkZWx0YToke2RlbHRhfSBtc2ApO1xuICAgICAgfVxuICAgIH1cbiAgICBuZXh0RFRTID0gZmlyc3REVFM7XG5cbiAgICAvLyBjb21wdXRlIGxhc3RQVFMvbGFzdERUU1xuICAgIHNhbXBsZSA9IGlucHV0U2FtcGxlc1tpbnB1dFNhbXBsZXMubGVuZ3RoLTFdO1xuICAgIGxhc3REVFMgPSBNYXRoLm1heChwdHNOb3JtYWxpemUoc2FtcGxlLmR0cyAtIGluaXREVFMsbmV4dEF2Y0R0cykgLDApO1xuICAgIGxhc3RQVFMgPSBNYXRoLm1heChwdHNOb3JtYWxpemUoc2FtcGxlLnB0cyAtIGluaXREVFMsbmV4dEF2Y0R0cykgLDApO1xuICAgIGxhc3RQVFMgPSBNYXRoLm1heChsYXN0UFRTLCBsYXN0RFRTKTtcblxuICAgIGxldCB2ZW5kb3IgPSBuYXZpZ2F0b3IudmVuZG9yLCB1c2VyQWdlbnQgPSBuYXZpZ2F0b3IudXNlckFnZW50LFxuICAgICAgICBpc1NhZmFyaSA9IHZlbmRvciAmJiB2ZW5kb3IuaW5kZXhPZignQXBwbGUnKSA+IC0xICYmIHVzZXJBZ2VudCAmJiAhdXNlckFnZW50Lm1hdGNoKCdDcmlPUycpO1xuXG4gICAgICAvLyBvbiBTYWZhcmkgbGV0J3Mgc2lnbmFsIHRoZSBzYW1lIHNhbXBsZSBkdXJhdGlvbiBmb3IgYWxsIHNhbXBsZXNcbiAgICAgIC8vIHNhbXBsZSBkdXJhdGlvbiAoYXMgZXhwZWN0ZWQgYnkgdHJ1biBNUDQgYm94ZXMpLCBzaG91bGQgYmUgdGhlIGRlbHRhIGJldHdlZW4gc2FtcGxlIERUU1xuICAgICAgLy8gc2V0IHRoaXMgY29uc3RhbnQgZHVyYXRpb24gYXMgYmVpbmcgdGhlIGF2ZyBkZWx0YSBiZXR3ZWVuIGNvbnNlY3V0aXZlIERUUy5cbiAgICBpZiAoaXNTYWZhcmkpIHtcbiAgICAgIG1wNFNhbXBsZUR1cmF0aW9uID0gTWF0aC5yb3VuZCgobGFzdERUUy1maXJzdERUUykvKHBlczJtcDRTY2FsZUZhY3RvciooaW5wdXRTYW1wbGVzLmxlbmd0aC0xKSkpO1xuICAgIH1cblxuICAgIC8vIG5vcm1hbGl6ZSBhbGwgUFRTL0RUUyBub3cgLi4uXG4gICAgZm9yIChsZXQgaSA9IDAgOyBpIDwgbmJTYW1wbGVzOyBpKyspIHtcbiAgICAgIGxldCBzYW1wbGUgPSBpbnB1dFNhbXBsZXNbaV07XG4gICAgICBpZiAoaXNTYWZhcmkpIHtcbiAgICAgICAgLy8gc2FtcGxlIERUUyBpcyBjb21wdXRlZCB1c2luZyBhIGNvbnN0YW50IGRlY29kaW5nIG9mZnNldCAobXA0U2FtcGxlRHVyYXRpb24pIGJldHdlZW4gc2FtcGxlc1xuICAgICAgICBzYW1wbGUuZHRzID0gZmlyc3REVFMgKyBpKnBlczJtcDRTY2FsZUZhY3RvciptcDRTYW1wbGVEdXJhdGlvbjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGVuc3VyZSBzYW1wbGUgbW9ub3RvbmljIERUU1xuICAgICAgICBzYW1wbGUuZHRzID0gTWF0aC5tYXgocHRzTm9ybWFsaXplKHNhbXBsZS5kdHMgLSBpbml0RFRTLCBuZXh0QXZjRHRzKSxmaXJzdERUUyk7XG4gICAgICAgIC8vIGVuc3VyZSBkdHMgaXMgYSBtdWx0aXBsZSBvZiBzY2FsZSBmYWN0b3IgdG8gYXZvaWQgcm91bmRpbmcgaXNzdWVzXG4gICAgICAgIHNhbXBsZS5kdHMgPSBNYXRoLnJvdW5kKHNhbXBsZS5kdHMvcGVzMm1wNFNjYWxlRmFjdG9yKSpwZXMybXA0U2NhbGVGYWN0b3I7XG4gICAgICB9XG4gICAgICAvLyB3ZSBub3JtYWxpemUgUFRTIGFnYWluc3QgbmV4dEF2Y0R0cywgd2UgYWxzbyBzdWJzdHJhY3QgaW5pdERUUyAoc29tZSBzdHJlYW1zIGRvbid0IHN0YXJ0IEAgUFRTIE8pXG4gICAgICAvLyBhbmQgd2UgZW5zdXJlIHRoYXQgY29tcHV0ZWQgdmFsdWUgaXMgZ3JlYXRlciBvciBlcXVhbCB0aGFuIHNhbXBsZSBEVFNcbiAgICAgIHNhbXBsZS5wdHMgPSBNYXRoLm1heChwdHNOb3JtYWxpemUoc2FtcGxlLnB0cyAtIGluaXREVFMsbmV4dEF2Y0R0cykgLCBzYW1wbGUuZHRzKTtcbiAgICAgIC8vIGVuc3VyZSBwdHMgaXMgYSBtdWx0aXBsZSBvZiBzY2FsZSBmYWN0b3IgdG8gYXZvaWQgcm91bmRpbmcgaXNzdWVzXG4gICAgICBzYW1wbGUucHRzID0gTWF0aC5yb3VuZChzYW1wbGUucHRzL3BlczJtcDRTY2FsZUZhY3RvcikqcGVzMm1wNFNjYWxlRmFjdG9yO1xuICAgIH1cblxuICAgIC8qIGNvbmNhdGVuYXRlIHRoZSB2aWRlbyBkYXRhIGFuZCBjb25zdHJ1Y3QgdGhlIG1kYXQgaW4gcGxhY2VcbiAgICAgIChuZWVkIDggbW9yZSBieXRlcyB0byBmaWxsIGxlbmd0aCBhbmQgbXBkYXQgdHlwZSkgKi9cbiAgICBsZXQgbWRhdFNpemUgPSB0cmFjay5sZW4gKyAoNCAqIHRyYWNrLm5iTmFsdSkgKyA4O1xuICAgIHRyeSB7XG4gICAgICBtZGF0ID0gbmV3IFVpbnQ4QXJyYXkobWRhdFNpemUpO1xuICAgIH0gY2F0Y2goZXJyKSB7XG4gICAgICB0aGlzLm9ic2VydmVyLnRyaWdnZXIoRXZlbnQuRVJST1IsIHt0eXBlIDogRXJyb3JUeXBlcy5NVVhfRVJST1IsIGxldmVsOiB0aGlzLmxldmVsLCBpZCA6IHRoaXMuaWQsIGRldGFpbHM6IEVycm9yRGV0YWlscy5SRU1VWF9BTExPQ19FUlJPUiwgZmF0YWw6IGZhbHNlLCBieXRlcyA6IG1kYXRTaXplLCByZWFzb246IGBmYWlsIGFsbG9jYXRpbmcgdmlkZW8gbWRhdCAke21kYXRTaXplfWB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IHZpZXcgPSBuZXcgRGF0YVZpZXcobWRhdC5idWZmZXIpO1xuICAgIHZpZXcuc2V0VWludDMyKDAsIG1kYXRTaXplKTtcbiAgICBtZGF0LnNldChNUDQudHlwZXMubWRhdCwgNCk7XG5cbiAgICBmb3IgKGxldCBpID0gMCA7IGkgPCBuYlNhbXBsZXM7IGkrKykge1xuICAgICAgbGV0IGF2Y1NhbXBsZSA9IGlucHV0U2FtcGxlc1tpXSxcbiAgICAgICAgICBhdmNTYW1wbGVVbml0cyA9IGF2Y1NhbXBsZS51bml0cy51bml0cyxcbiAgICAgICAgICBtcDRTYW1wbGVMZW5ndGggPSAwLFxuICAgICAgICAgIGNvbXBvc2l0aW9uVGltZU9mZnNldDtcbiAgICAgIC8vIGNvbnZlcnQgTkFMVSBiaXRzdHJlYW0gdG8gTVA0IGZvcm1hdCAocHJlcGVuZCBOQUxVIHdpdGggc2l6ZSBmaWVsZClcbiAgICAgIGZvcihsZXQgaiA9IDAsIG5iVW5pdHMgPSBhdmNTYW1wbGVVbml0cy5sZW5ndGg7IGogPCBuYlVuaXRzIDsgaisrKSB7XG4gICAgICAgIGxldCB1bml0ID0gYXZjU2FtcGxlVW5pdHNbal0sXG4gICAgICAgICAgICB1bml0RGF0YSA9IHVuaXQuZGF0YSxcbiAgICAgICAgICAgIHVuaXREYXRhTGVuID0gdW5pdC5kYXRhLmJ5dGVMZW5ndGg7XG4gICAgICAgIHZpZXcuc2V0VWludDMyKG9mZnNldCwgdW5pdERhdGFMZW4pO1xuICAgICAgICBvZmZzZXQgKz0gNDtcbiAgICAgICAgbWRhdC5zZXQodW5pdERhdGEsIG9mZnNldCk7XG4gICAgICAgIG9mZnNldCArPSB1bml0RGF0YUxlbjtcbiAgICAgICAgbXA0U2FtcGxlTGVuZ3RoICs9IDQgKyB1bml0RGF0YUxlbjtcbiAgICAgIH1cblxuICAgICAgaWYoIWlzU2FmYXJpKSB7XG4gICAgICAgIC8vIGV4cGVjdGVkIHNhbXBsZSBkdXJhdGlvbiBpcyB0aGUgRGVjb2RpbmcgVGltZXN0YW1wIGRpZmYgb2YgY29uc2VjdXRpdmUgc2FtcGxlc1xuICAgICAgICBpZiAoaSA8IG5iU2FtcGxlcyAtIDEpIHtcbiAgICAgICAgICBtcDRTYW1wbGVEdXJhdGlvbiA9IGlucHV0U2FtcGxlc1tpKzFdLmR0cyAtIGF2Y1NhbXBsZS5kdHM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGV0IGNvbmZpZyA9IHRoaXMuY29uZmlnLFxuICAgICAgICAgICAgICBsYXN0RnJhbWVEdXJhdGlvbiA9IGF2Y1NhbXBsZS5kdHMgLSBpbnB1dFNhbXBsZXNbaSA+IDAgPyBpLTEgOiBpXS5kdHM7XG4gICAgICAgICAgaWYgKGNvbmZpZy5zdHJldGNoU2hvcnRWaWRlb1RyYWNrKSB7XG4gICAgICAgICAgICAvLyBJbiBzb21lIGNhc2VzLCBhIHNlZ21lbnQncyBhdWRpbyB0cmFjayBkdXJhdGlvbiBtYXkgZXhjZWVkIHRoZSB2aWRlbyB0cmFjayBkdXJhdGlvbi5cbiAgICAgICAgICAgIC8vIFNpbmNlIHdlJ3ZlIGFscmVhZHkgcmVtdXhlZCBhdWRpbywgYW5kIHdlIGtub3cgaG93IGxvbmcgdGhlIGF1ZGlvIHRyYWNrIGlzLCB3ZSBsb29rIHRvXG4gICAgICAgICAgICAvLyBzZWUgaWYgdGhlIGRlbHRhIHRvIHRoZSBuZXh0IHNlZ21lbnQgaXMgbG9uZ2VyIHRoYW4gdGhlIG1pbmltdW0gb2YgbWF4QnVmZmVySG9sZSBhbmRcbiAgICAgICAgICAgIC8vIG1heFNlZWtIb2xlLiBJZiBzbywgcGxheWJhY2sgd291bGQgcG90ZW50aWFsbHkgZ2V0IHN0dWNrLCBzbyB3ZSBhcnRpZmljaWFsbHkgaW5mbGF0ZVxuICAgICAgICAgICAgLy8gdGhlIGR1cmF0aW9uIG9mIHRoZSBsYXN0IGZyYW1lIHRvIG1pbmltaXplIGFueSBwb3RlbnRpYWwgZ2FwIGJldHdlZW4gc2VnbWVudHMuXG4gICAgICAgICAgICBsZXQgbWF4QnVmZmVySG9sZSA9IGNvbmZpZy5tYXhCdWZmZXJIb2xlLFxuICAgICAgICAgICAgICAgIG1heFNlZWtIb2xlID0gY29uZmlnLm1heFNlZWtIb2xlLFxuICAgICAgICAgICAgICAgIGdhcFRvbGVyYW5jZSA9IE1hdGguZmxvb3IoTWF0aC5taW4obWF4QnVmZmVySG9sZSwgbWF4U2Vla0hvbGUpICogcGVzVGltZVNjYWxlKSxcbiAgICAgICAgICAgICAgICBkZWx0YVRvRnJhbWVFbmQgPSAoYXVkaW9UcmFja0xlbmd0aCA/IGZpcnN0UFRTICsgYXVkaW9UcmFja0xlbmd0aCAqIHBlc1RpbWVTY2FsZSA6IHRoaXMubmV4dEF1ZGlvUHRzKSAtIGF2Y1NhbXBsZS5wdHM7XG4gICAgICAgICAgICBpZiAoZGVsdGFUb0ZyYW1lRW5kID4gZ2FwVG9sZXJhbmNlKSB7XG4gICAgICAgICAgICAgIC8vIFdlIHN1YnRyYWN0IGxhc3RGcmFtZUR1cmF0aW9uIGZyb20gZGVsdGFUb0ZyYW1lRW5kIHRvIHRyeSB0byBwcmV2ZW50IGFueSB2aWRlb1xuICAgICAgICAgICAgICAvLyBmcmFtZSBvdmVybGFwLiBtYXhCdWZmZXJIb2xlL21heFNlZWtIb2xlIHNob3VsZCBiZSA+PiBsYXN0RnJhbWVEdXJhdGlvbiBhbnl3YXkuXG4gICAgICAgICAgICAgIG1wNFNhbXBsZUR1cmF0aW9uID0gZGVsdGFUb0ZyYW1lRW5kIC0gbGFzdEZyYW1lRHVyYXRpb247XG4gICAgICAgICAgICAgIGlmIChtcDRTYW1wbGVEdXJhdGlvbiA8IDApIHtcbiAgICAgICAgICAgICAgICBtcDRTYW1wbGVEdXJhdGlvbiA9IGxhc3RGcmFtZUR1cmF0aW9uO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGxvZ2dlci5sb2coYEl0IGlzIGFwcHJveGltYXRlbHkgJHtkZWx0YVRvRnJhbWVFbmQvOTB9IG1zIHRvIHRoZSBuZXh0IHNlZ21lbnQ7IHVzaW5nIGR1cmF0aW9uICR7bXA0U2FtcGxlRHVyYXRpb24vOTB9IG1zIGZvciB0aGUgbGFzdCB2aWRlbyBmcmFtZS5gKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG1wNFNhbXBsZUR1cmF0aW9uID0gbGFzdEZyYW1lRHVyYXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1wNFNhbXBsZUR1cmF0aW9uID0gbGFzdEZyYW1lRHVyYXRpb247XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG1wNFNhbXBsZUR1cmF0aW9uIC89IHBlczJtcDRTY2FsZUZhY3RvcjtcbiAgICAgICAgY29tcG9zaXRpb25UaW1lT2Zmc2V0ID0gTWF0aC5yb3VuZCgoYXZjU2FtcGxlLnB0cyAtIGF2Y1NhbXBsZS5kdHMpIC8gcGVzMm1wNFNjYWxlRmFjdG9yKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbXBvc2l0aW9uVGltZU9mZnNldCA9IE1hdGgubWF4KDAsbXA0U2FtcGxlRHVyYXRpb24qTWF0aC5yb3VuZCgoYXZjU2FtcGxlLnB0cyAtIGF2Y1NhbXBsZS5kdHMpLyhwZXMybXA0U2NhbGVGYWN0b3IqbXA0U2FtcGxlRHVyYXRpb24pKSk7XG4gICAgICB9XG5cblxuICAgICAgLy9jb25zb2xlLmxvZygnUFRTL0RUUy9pbml0RFRTL25vcm1QVFMvbm9ybURUUy9yZWxhdGl2ZSBQVFMgOiAke2F2Y1NhbXBsZS5wdHN9LyR7YXZjU2FtcGxlLmR0c30vJHtpbml0RFRTfS8ke3B0c25vcm19LyR7ZHRzbm9ybX0vJHsoYXZjU2FtcGxlLnB0cy80Mjk0OTY3Mjk2KS50b0ZpeGVkKDMpfScpO1xuICAgICAgb3V0cHV0U2FtcGxlcy5wdXNoKHtcbiAgICAgICAgc2l6ZTogbXA0U2FtcGxlTGVuZ3RoLFxuICAgICAgICAgLy8gY29uc3RhbnQgZHVyYXRpb25cbiAgICAgICAgZHVyYXRpb246IG1wNFNhbXBsZUR1cmF0aW9uLFxuICAgICAgICBjdHM6IGNvbXBvc2l0aW9uVGltZU9mZnNldCxcbiAgICAgICAgZmxhZ3M6IHtcbiAgICAgICAgICBpc0xlYWRpbmc6IDAsXG4gICAgICAgICAgaXNEZXBlbmRlZE9uOiAwLFxuICAgICAgICAgIGhhc1JlZHVuZGFuY3k6IDAsXG4gICAgICAgICAgZGVncmFkUHJpbzogMCxcbiAgICAgICAgICBkZXBlbmRzT24gOiBhdmNTYW1wbGUua2V5ID8gMiA6IDEsXG4gICAgICAgICAgaXNOb25TeW5jIDogYXZjU2FtcGxlLmtleSA/IDAgOiAxXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBuZXh0IEFWQyBzYW1wbGUgRFRTIHNob3VsZCBiZSBlcXVhbCB0byBsYXN0IHNhbXBsZSBEVFMgKyBsYXN0IHNhbXBsZSBkdXJhdGlvbiAoaW4gUEVTIHRpbWVzY2FsZSlcbiAgICB0aGlzLm5leHRBdmNEdHMgPSBsYXN0RFRTICsgbXA0U2FtcGxlRHVyYXRpb24qcGVzMm1wNFNjYWxlRmFjdG9yO1xuICAgIGxldCBkcm9wcGVkID0gdHJhY2suZHJvcHBlZDtcbiAgICB0cmFjay5sZW4gPSAwO1xuICAgIHRyYWNrLm5iTmFsdSA9IDA7XG4gICAgdHJhY2suZHJvcHBlZCA9IDA7XG4gICAgaWYob3V0cHV0U2FtcGxlcy5sZW5ndGggJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ2Nocm9tZScpID4gLTEpIHtcbiAgICAgIGxldCBmbGFncyA9IG91dHB1dFNhbXBsZXNbMF0uZmxhZ3M7XG4gICAgLy8gY2hyb21lIHdvcmthcm91bmQsIG1hcmsgZmlyc3Qgc2FtcGxlIGFzIGJlaW5nIGEgUmFuZG9tIEFjY2VzcyBQb2ludCB0byBhdm9pZCBzb3VyY2VidWZmZXIgYXBwZW5kIGlzc3VlXG4gICAgLy8gaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTIyOTQxMlxuICAgICAgZmxhZ3MuZGVwZW5kc09uID0gMjtcbiAgICAgIGZsYWdzLmlzTm9uU3luYyA9IDA7XG4gICAgfVxuICAgIHRyYWNrLnNhbXBsZXMgPSBvdXRwdXRTYW1wbGVzO1xuICAgIG1vb2YgPSBNUDQubW9vZih0cmFjay5zZXF1ZW5jZU51bWJlcisrLCBmaXJzdERUUyAvIHBlczJtcDRTY2FsZUZhY3RvciwgdHJhY2spO1xuICAgIHRyYWNrLnNhbXBsZXMgPSBbXTtcblxuICAgIGxldCBkYXRhID0ge1xuICAgICAgaWQgOiB0aGlzLmlkLFxuICAgICAgbGV2ZWwgOiB0aGlzLmxldmVsLFxuICAgICAgc24gOiB0aGlzLnNuLFxuICAgICAgZGF0YTE6IG1vb2YsXG4gICAgICBkYXRhMjogbWRhdCxcbiAgICAgIHN0YXJ0UFRTOiBmaXJzdFBUUyAvIHBlc1RpbWVTY2FsZSxcbiAgICAgIGVuZFBUUzogKGxhc3RQVFMgKyBwZXMybXA0U2NhbGVGYWN0b3IgKiBtcDRTYW1wbGVEdXJhdGlvbikgLyBwZXNUaW1lU2NhbGUsXG4gICAgICBzdGFydERUUzogZmlyc3REVFMgLyBwZXNUaW1lU2NhbGUsXG4gICAgICBlbmREVFM6IHRoaXMubmV4dEF2Y0R0cyAvIHBlc1RpbWVTY2FsZSxcbiAgICAgIHR5cGU6ICd2aWRlbycsXG4gICAgICBuYjogb3V0cHV0U2FtcGxlcy5sZW5ndGgsXG4gICAgICBkcm9wcGVkIDogZHJvcHBlZFxuICAgIH07XG4gICAgdGhpcy5vYnNlcnZlci50cmlnZ2VyKEV2ZW50LkZSQUdfUEFSU0lOR19EQVRBLCBkYXRhKTtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIHJlbXV4QXVkaW8odHJhY2ssIHRpbWVPZmZzZXQsIGNvbnRpZ3VvdXMsYWNjdXJhdGVUaW1lT2Zmc2V0KSB7XG4gICAgY29uc3QgcGVzVGltZVNjYWxlID0gdGhpcy5QRVNfVElNRVNDQUxFLFxuICAgICAgICAgIG1wNHRpbWVTY2FsZSA9IHRyYWNrLnRpbWVzY2FsZSxcbiAgICAgICAgICBwZXMybXA0U2NhbGVGYWN0b3IgPSBwZXNUaW1lU2NhbGUvbXA0dGltZVNjYWxlLFxuICAgICAgICAgIGV4cGVjdGVkU2FtcGxlRHVyYXRpb24gPSB0cmFjay50aW1lc2NhbGUgKiAodHJhY2suaXNBQUMgPyAxMDI0IDogMTE1MikgLyB0cmFjay5hdWRpb3NhbXBsZXJhdGUsXG4gICAgICAgICAgcGVzRnJhbWVEdXJhdGlvbiA9IGV4cGVjdGVkU2FtcGxlRHVyYXRpb24gKiBwZXMybXA0U2NhbGVGYWN0b3IsXG4gICAgICAgICAgcHRzTm9ybWFsaXplID0gdGhpcy5fUFRTTm9ybWFsaXplLFxuICAgICAgICAgIGluaXREVFMgPSB0aGlzLl9pbml0RFRTLFxuICAgICAgICAgIHJhd01QRUcgPSAhdHJhY2suaXNBQUMgJiYgdGhpcy50eXBlU3VwcG9ydGVkLm1wZWc7XG5cbiAgICB2YXIgdmlldyxcbiAgICAgICAgb2Zmc2V0ID0gcmF3TVBFRyA/IDAgOiA4LFxuICAgICAgICBhdWRpb1NhbXBsZSwgbXA0U2FtcGxlLFxuICAgICAgICB1bml0LFxuICAgICAgICBtZGF0LCBtb29mLFxuICAgICAgICBmaXJzdFBUUywgZmlyc3REVFMsIGxhc3REVFMsXG4gICAgICAgIHB0cywgZHRzLCBwdHNub3JtLCBkdHNub3JtLFxuICAgICAgICBvdXRwdXRTYW1wbGVzID0gW10sXG4gICAgICAgIGlucHV0U2FtcGxlcyA9IFtdLFxuICAgICAgICBmaWxsRnJhbWUsIG5ld1N0YW1wLFxuICAgICAgICBuZXh0QXVkaW9QdHM7XG5cbiAgICB0cmFjay5zYW1wbGVzLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgcmV0dXJuIChhLnB0cy1iLnB0cyk7XG4gICAgfSk7XG4gICAgaW5wdXRTYW1wbGVzID0gdHJhY2suc2FtcGxlcztcblxuICAgIC8vIGZvciBhdWRpbyBzYW1wbGVzLCBhbHNvIGNvbnNpZGVyIGNvbnNlY3V0aXZlIGZyYWdtZW50cyBhcyBiZWluZyBjb250aWd1b3VzIChldmVuIGlmIGEgbGV2ZWwgc3dpdGNoIG9jY3VycyksXG4gICAgLy8gZm9yIHNha2Ugb2YgY2xhcml0eTpcbiAgICAvLyBjb25zZWN1dGl2ZSBmcmFnbWVudHMgYXJlIGZyYWdzIHdpdGhcbiAgICAvLyAgLSBsZXNzIHRoYW4gMTAwbXMgZ2FwcyBiZXR3ZWVuIG5ldyB0aW1lIG9mZnNldCBhbmQgbmV4dCBleHBlY3RlZCBQVFMgT1JcbiAgICAvLyAgLSBsZXNzIHRoYW4gMjAgYXVkaW8gZnJhbWVzIGRpc3RhbmNlXG4gICAgLy8gY29udGlndW91cyBmcmFnbWVudHMgYXJlIGNvbnNlY3V0aXZlIGZyYWdtZW50cyBmcm9tIHNhbWUgcXVhbGl0eSBsZXZlbCAoc2FtZSBsZXZlbCwgbmV3IFNOID0gb2xkIFNOICsgMSlcbiAgICAvLyB0aGlzIGhlbHBzIGVuc3VyaW5nIGF1ZGlvIGNvbnRpbnVpdHlcbiAgICAvLyBhbmQgdGhpcyBhbHNvIGF2b2lkcyBhdWRpbyBnbGl0Y2hlcy9jdXQgd2hlbiBzd2l0Y2hpbmcgcXVhbGl0eSwgb3IgcmVwb3J0aW5nIHdyb25nIGR1cmF0aW9uIG9uIGZpcnN0IGF1ZGlvIGZyYW1lXG5cbiAgICBuZXh0QXVkaW9QdHMgPSB0aGlzLm5leHRBdWRpb1B0cztcbiAgICBjb250aWd1b3VzIHw9IChpbnB1dFNhbXBsZXMubGVuZ3RoICYmIG5leHRBdWRpb1B0cyAmJlxuICAgICAgICAgICAgICAgICAgIChNYXRoLmFicyh0aW1lT2Zmc2V0LW5leHRBdWRpb1B0cy9wZXNUaW1lU2NhbGUpIDwgMC4xIHx8XG4gICAgICAgICAgICAgICAgICAgIE1hdGguYWJzKChpbnB1dFNhbXBsZXNbMF0ucHRzLW5leHRBdWRpb1B0cy10aGlzLl9pbml0RFRTKSkgPCAyMCpwZXNGcmFtZUR1cmF0aW9uKVxuICAgICAgICAgICAgICAgICAgICApO1xuXG4gICAgaWYgKCFjb250aWd1b3VzKSB7XG4gICAgICAvLyBpZiBmcmFnbWVudHMgYXJlIG5vdCBjb250aWd1b3VzLCBsZXQncyB1c2UgdGltZU9mZnNldCB0byBjb21wdXRlIG5leHQgQXVkaW8gUFRTXG4gICAgICBuZXh0QXVkaW9QdHMgPSB0aW1lT2Zmc2V0KnBlc1RpbWVTY2FsZTtcbiAgICB9XG4gICAgLy8gSWYgdGhlIGF1ZGlvIHRyYWNrIGlzIG1pc3Npbmcgc2FtcGxlcywgdGhlIGZyYW1lcyBzZWVtIHRvIGdldCBcImxlZnQtc2hpZnRlZFwiIHdpdGhpbiB0aGVcbiAgICAvLyByZXN1bHRpbmcgbXA0IHNlZ21lbnQsIGNhdXNpbmcgc3luYyBpc3N1ZXMgYW5kIGxlYXZpbmcgZ2FwcyBhdCB0aGUgZW5kIG9mIHRoZSBhdWRpbyBzZWdtZW50LlxuICAgIC8vIEluIGFuIGVmZm9ydCB0byBwcmV2ZW50IHRoaXMgZnJvbSBoYXBwZW5pbmcsIHdlIGluamVjdCBmcmFtZXMgaGVyZSB3aGVyZSB0aGVyZSBhcmUgZ2Fwcy5cbiAgICAvLyBXaGVuIHBvc3NpYmxlLCB3ZSBpbmplY3QgYSBzaWxlbnQgZnJhbWU7IHdoZW4gdGhhdCdzIG5vdCBwb3NzaWJsZSwgd2UgZHVwbGljYXRlIHRoZSBsYXN0XG4gICAgLy8gZnJhbWUuXG5cbiAgICAvLyBvbmx5IGluamVjdC9kcm9wIGF1ZGlvIGZyYW1lcyBpbiBjYXNlIHRpbWUgb2Zmc2V0IGlzIGFjY3VyYXRlXG4gICAgaWYgKGFjY3VyYXRlVGltZU9mZnNldCAmJiB0cmFjay5pc0FBQykge1xuICAgICAgZm9yIChsZXQgaSA9IDAsIG5leHRQdHNOb3JtID0gbmV4dEF1ZGlvUHRzOyBpIDwgaW5wdXRTYW1wbGVzLmxlbmd0aDsgKSB7XG4gICAgICAgIC8vIEZpcnN0LCBsZXQncyBzZWUgaG93IGZhciBvZmYgdGhpcyBmcmFtZSBpcyBmcm9tIHdoZXJlIHdlIGV4cGVjdCBpdCB0byBiZVxuICAgICAgICB2YXIgc2FtcGxlID0gaW5wdXRTYW1wbGVzW2ldLFxuICAgICAgICAgICAgcHRzTm9ybSA9IHB0c05vcm1hbGl6ZShzYW1wbGUucHRzIC0gaW5pdERUUywgbmV4dEF1ZGlvUHRzKSxcbiAgICAgICAgICAgIGRlbHRhID0gcHRzTm9ybSAtIG5leHRQdHNOb3JtO1xuXG4gICAgICAgIC8vIElmIHdlJ3JlIG92ZXJsYXBwaW5nIGJ5IG1vcmUgdGhhbiBhIGR1cmF0aW9uLCBkcm9wIHRoaXMgc2FtcGxlXG4gICAgICAgIGlmIChkZWx0YSA8PSAtcGVzRnJhbWVEdXJhdGlvbikge1xuICAgICAgICAgIGxvZ2dlci53YXJuKGBEcm9wcGluZyAxIGF1ZGlvIGZyYW1lIEAgJHtNYXRoLnJvdW5kKG5leHRQdHNOb3JtLzkwKS8xMDAwfXMgZHVlIHRvICR7TWF0aC5yb3VuZChNYXRoLmFicyhkZWx0YSAvIDkwKSl9IG1zIG92ZXJsYXAuYCk7XG4gICAgICAgICAgaW5wdXRTYW1wbGVzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICB0cmFjay5sZW4gLT0gc2FtcGxlLnVuaXQubGVuZ3RoO1xuICAgICAgICAgIC8vIERvbid0IHRvdWNoIG5leHRQdHNOb3JtIG9yIGlcbiAgICAgICAgfVxuICAgICAgICAvLyBPdGhlcndpc2UsIGlmIHdlJ3JlIG1vcmUgdGhhbiBhIGZyYW1lIGF3YXkgZnJvbSB3aGVyZSB3ZSBzaG91bGQgYmUsIGluc2VydCBtaXNzaW5nIGZyYW1lc1xuICAgICAgICBlbHNlIGlmIChkZWx0YSA+PSBwZXNGcmFtZUR1cmF0aW9uKSB7XG4gICAgICAgICAgdmFyIG1pc3NpbmcgPSBNYXRoLnJvdW5kKGRlbHRhIC8gcGVzRnJhbWVEdXJhdGlvbik7XG4gICAgICAgICAgbG9nZ2VyLndhcm4oYEluamVjdGluZyAke21pc3Npbmd9IGF1ZGlvIGZyYW1lIEAgJHtNYXRoLnJvdW5kKG5leHRQdHNOb3JtLzkwKS8xMDAwfXMgZHVlIHRvICR7TWF0aC5yb3VuZChkZWx0YSAvIDkwKX0gbXMgZ2FwLmApO1xuICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWlzc2luZzsgaisrKSB7XG4gICAgICAgICAgICBuZXdTdGFtcCA9IG5leHRQdHNOb3JtICsgaW5pdERUUztcbiAgICAgICAgICAgIG5ld1N0YW1wID0gTWF0aC5tYXgobmV3U3RhbXAsIGluaXREVFMpO1xuICAgICAgICAgICAgZmlsbEZyYW1lID0gQUFDLmdldFNpbGVudEZyYW1lKHRyYWNrLmNoYW5uZWxDb3VudCk7XG4gICAgICAgICAgICBpZiAoIWZpbGxGcmFtZSkge1xuICAgICAgICAgICAgICBsb2dnZXIubG9nKCdVbmFibGUgdG8gZ2V0IHNpbGVudCBmcmFtZSBmb3IgZ2l2ZW4gYXVkaW8gY29kZWM7IGR1cGxpY2F0aW5nIGxhc3QgZnJhbWUgaW5zdGVhZC4nKTtcbiAgICAgICAgICAgICAgZmlsbEZyYW1lID0gc2FtcGxlLnVuaXQuc3ViYXJyYXkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlucHV0U2FtcGxlcy5zcGxpY2UoaSwgMCwge3VuaXQ6IGZpbGxGcmFtZSwgcHRzOiBuZXdTdGFtcCwgZHRzOiBuZXdTdGFtcH0pO1xuICAgICAgICAgICAgdHJhY2subGVuICs9IGZpbGxGcmFtZS5sZW5ndGg7XG4gICAgICAgICAgICBuZXh0UHRzTm9ybSArPSBwZXNGcmFtZUR1cmF0aW9uO1xuICAgICAgICAgICAgaSArPSAxO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIEFkanVzdCBzYW1wbGUgdG8gbmV4dCBleHBlY3RlZCBwdHNcbiAgICAgICAgICBzYW1wbGUucHRzID0gc2FtcGxlLmR0cyA9IG5leHRQdHNOb3JtICsgaW5pdERUUztcbiAgICAgICAgICBuZXh0UHRzTm9ybSArPSBwZXNGcmFtZUR1cmF0aW9uO1xuICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgfVxuICAgICAgICAvLyBPdGhlcndpc2UsIHdlJ3JlIHdpdGhpbiBoYWxmIGEgZnJhbWUgZHVyYXRpb24sIHNvIGp1c3QgYWRqdXN0IHB0c1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBpZiAoTWF0aC5hYnMoZGVsdGEpID4gKDAuMSAqIHBlc0ZyYW1lRHVyYXRpb24pKSB7XG4gICAgICAgICAgICAvL2xvZ2dlci5sb2coYEludmFsaWQgZnJhbWUgZGVsdGEgJHtNYXRoLnJvdW5kKHB0c05vcm0gLSBuZXh0UHRzTm9ybSArIHBlc0ZyYW1lRHVyYXRpb24pfSBhdCBQVFMgJHtNYXRoLnJvdW5kKHB0c05vcm0gLyA5MCl9IChzaG91bGQgYmUgJHtNYXRoLnJvdW5kKHBlc0ZyYW1lRHVyYXRpb24pfSkuYCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5leHRQdHNOb3JtICs9IHBlc0ZyYW1lRHVyYXRpb247XG4gICAgICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICAgIHNhbXBsZS5wdHMgPSBzYW1wbGUuZHRzID0gaW5pdERUUyArIG5leHRBdWRpb1B0cztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2FtcGxlLnB0cyA9IHNhbXBsZS5kdHMgPSBpbnB1dFNhbXBsZXNbaSAtIDFdLnB0cyArIHBlc0ZyYW1lRHVyYXRpb247XG4gICAgICAgICAgfVxuICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuXG4gICAgZm9yIChsZXQgaiA9MCAsIG5iU2FtcGxlcyA9IGlucHV0U2FtcGxlcy5sZW5ndGg7IGogPCBuYlNhbXBsZXMgOyBqKyspIHtcbiAgICAgIGF1ZGlvU2FtcGxlID0gaW5wdXRTYW1wbGVzW2pdO1xuICAgICAgdW5pdCA9IGF1ZGlvU2FtcGxlLnVuaXQ7XG4gICAgICBwdHMgPSBhdWRpb1NhbXBsZS5wdHMgLSBpbml0RFRTO1xuICAgICAgZHRzID0gYXVkaW9TYW1wbGUuZHRzIC0gaW5pdERUUztcbiAgICAgIC8vbG9nZ2VyLmxvZyhgQXVkaW8vUFRTOiR7TWF0aC5yb3VuZChwdHMvOTApfWApO1xuICAgICAgLy8gaWYgbm90IGZpcnN0IHNhbXBsZVxuICAgICAgaWYgKGxhc3REVFMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwdHNub3JtID0gcHRzTm9ybWFsaXplKHB0cywgbGFzdERUUyk7XG4gICAgICAgIGR0c25vcm0gPSBwdHNOb3JtYWxpemUoZHRzLCBsYXN0RFRTKTtcbiAgICAgICAgbXA0U2FtcGxlLmR1cmF0aW9uID0gTWF0aC5yb3VuZCgoZHRzbm9ybSAtIGxhc3REVFMpIC8gcGVzMm1wNFNjYWxlRmFjdG9yKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHB0c25vcm0gPSBwdHNOb3JtYWxpemUocHRzLCBuZXh0QXVkaW9QdHMpO1xuICAgICAgICBkdHNub3JtID0gcHRzTm9ybWFsaXplKGR0cywgbmV4dEF1ZGlvUHRzKTtcbiAgICAgICAgbGV0IGRlbHRhID0gTWF0aC5yb3VuZCgxMDAwICogKHB0c25vcm0gLSBuZXh0QXVkaW9QdHMpIC8gcGVzVGltZVNjYWxlKSxcbiAgICAgICAgICAgIG51bU1pc3NpbmdGcmFtZXMgPSAwO1xuICAgICAgICAvLyBpZiBmcmFnbWVudCBhcmUgY29udGlndW91cywgZGV0ZWN0IGhvbGUvb3ZlcmxhcHBpbmcgYmV0d2VlbiBmcmFnbWVudHNcbiAgICAgICAgLy8gY29udGlndW91cyBmcmFnbWVudHMgYXJlIGNvbnNlY3V0aXZlIGZyYWdtZW50cyBmcm9tIHNhbWUgcXVhbGl0eSBsZXZlbCAoc2FtZSBsZXZlbCwgbmV3IFNOID0gb2xkIFNOICsgMSlcbiAgICAgICAgaWYgKGNvbnRpZ3VvdXMgJiYgdHJhY2suaXNBQUMpIHtcbiAgICAgICAgICAvLyBsb2cgZGVsdGFcbiAgICAgICAgICBpZiAoZGVsdGEpIHtcbiAgICAgICAgICAgIGlmIChkZWx0YSA+IDApIHtcbiAgICAgICAgICAgICAgbnVtTWlzc2luZ0ZyYW1lcyA9IE1hdGgucm91bmQoKHB0c25vcm0gLSBuZXh0QXVkaW9QdHMpIC8gcGVzRnJhbWVEdXJhdGlvbik7XG4gICAgICAgICAgICAgIGxvZ2dlci5sb2coYCR7ZGVsdGF9IG1zIGhvbGUgYmV0d2VlbiBBQUMgc2FtcGxlcyBkZXRlY3RlZCxmaWxsaW5nIGl0YCk7XG4gICAgICAgICAgICAgIGlmIChudW1NaXNzaW5nRnJhbWVzID4gMCkge1xuICAgICAgICAgICAgICAgIGZpbGxGcmFtZSA9IEFBQy5nZXRTaWxlbnRGcmFtZSh0cmFjay5jaGFubmVsQ291bnQpO1xuICAgICAgICAgICAgICAgIGlmICghZmlsbEZyYW1lKSB7XG4gICAgICAgICAgICAgICAgICBmaWxsRnJhbWUgPSB1bml0LnN1YmFycmF5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRyYWNrLmxlbiArPSBudW1NaXNzaW5nRnJhbWVzICogZmlsbEZyYW1lLmxlbmd0aDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyBpZiB3ZSBoYXZlIGZyYW1lIG92ZXJsYXAsIG92ZXJsYXBwaW5nIGZvciBtb3JlIHRoYW4gaGFsZiBhIGZyYW1lIGR1cmFpb25cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZGVsdGEgPCAtMTIpIHtcbiAgICAgICAgICAgICAgLy8gZHJvcCBvdmVybGFwcGluZyBhdWRpbyBmcmFtZXMuLi4gYnJvd3NlciB3aWxsIGRlYWwgd2l0aCBpdFxuICAgICAgICAgICAgICBsb2dnZXIubG9nKGAkeygtZGVsdGEpfSBtcyBvdmVybGFwcGluZyBiZXR3ZWVuIEFBQyBzYW1wbGVzIGRldGVjdGVkLCBkcm9wIGZyYW1lYCk7XG4gICAgICAgICAgICAgIHRyYWNrLmxlbiAtPSB1bml0LmJ5dGVMZW5ndGg7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gc2V0IFBUUy9EVFMgdG8gZXhwZWN0ZWQgUFRTL0RUU1xuICAgICAgICAgICAgcHRzbm9ybSA9IGR0c25vcm0gPSBuZXh0QXVkaW9QdHM7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHJlbWVtYmVyIGZpcnN0IFBUUyBvZiBvdXIgYXVkaW9TYW1wbGVzLCBlbnN1cmUgdmFsdWUgaXMgcG9zaXRpdmVcbiAgICAgICAgZmlyc3RQVFMgPSBNYXRoLm1heCgwLCBwdHNub3JtKTtcbiAgICAgICAgZmlyc3REVFMgPSBNYXRoLm1heCgwLCBkdHNub3JtKTtcbiAgICAgICAgaWYodHJhY2subGVuID4gMCkge1xuICAgICAgICAgIC8qIGNvbmNhdGVuYXRlIHRoZSBhdWRpbyBkYXRhIGFuZCBjb25zdHJ1Y3QgdGhlIG1kYXQgaW4gcGxhY2VcbiAgICAgICAgICAgIChuZWVkIDggbW9yZSBieXRlcyB0byBmaWxsIGxlbmd0aCBhbmQgbWRhdCB0eXBlKSAqL1xuXG5cbiAgICAgICAgICBsZXQgbWRhdFNpemUgPSByYXdNUEVHID8gdHJhY2subGVuIDogdHJhY2subGVuICsgODtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgbWRhdCA9IG5ldyBVaW50OEFycmF5KG1kYXRTaXplKTtcbiAgICAgICAgICB9IGNhdGNoKGVycikge1xuICAgICAgICAgICAgdGhpcy5vYnNlcnZlci50cmlnZ2VyKEV2ZW50LkVSUk9SLCB7dHlwZSA6IEVycm9yVHlwZXMuTVVYX0VSUk9SLCBsZXZlbDogdGhpcy5sZXZlbCwgaWQgOiB0aGlzLmlkLCBkZXRhaWxzOiBFcnJvckRldGFpbHMuUkVNVVhfQUxMT0NfRVJST1IsIGZhdGFsOiBmYWxzZSwgYnl0ZXMgOiBtZGF0U2l6ZSwgcmVhc29uOiBgZmFpbCBhbGxvY2F0aW5nIGF1ZGlvIG1kYXQgJHttZGF0U2l6ZX1gfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghcmF3TVBFRykge1xuICAgICAgICAgICAgdmlldyA9IG5ldyBEYXRhVmlldyhtZGF0LmJ1ZmZlcik7XG4gICAgICAgICAgICB2aWV3LnNldFVpbnQzMigwLCBtZGF0U2l6ZSk7XG4gICAgICAgICAgICBtZGF0LnNldChNUDQudHlwZXMubWRhdCwgNCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIG5vIGF1ZGlvIHNhbXBsZXNcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1NaXNzaW5nRnJhbWVzOyBpKyspIHtcbiAgICAgICAgICBuZXdTdGFtcCA9IHB0c25vcm0gLSAobnVtTWlzc2luZ0ZyYW1lcyAtIGkpICogcGVzRnJhbWVEdXJhdGlvbjtcbiAgICAgICAgICBmaWxsRnJhbWUgPSBBQUMuZ2V0U2lsZW50RnJhbWUodHJhY2suY2hhbm5lbENvdW50KTtcbiAgICAgICAgICBpZiAoIWZpbGxGcmFtZSkge1xuICAgICAgICAgICAgbG9nZ2VyLmxvZygnVW5hYmxlIHRvIGdldCBzaWxlbnQgZnJhbWUgZm9yIGdpdmVuIGF1ZGlvIGNvZGVjOyBkdXBsaWNhdGluZyB0aGlzIGZyYW1lIGluc3RlYWQuJyk7XG4gICAgICAgICAgICBmaWxsRnJhbWUgPSB1bml0LnN1YmFycmF5KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG1kYXQuc2V0KGZpbGxGcmFtZSwgb2Zmc2V0KTtcbiAgICAgICAgICBvZmZzZXQgKz0gZmlsbEZyYW1lLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgbXA0U2FtcGxlID0ge1xuICAgICAgICAgICAgc2l6ZTogZmlsbEZyYW1lLmJ5dGVMZW5ndGgsXG4gICAgICAgICAgICBjdHM6IDAsXG4gICAgICAgICAgICBkdXJhdGlvbjogMTAyNCxcbiAgICAgICAgICAgIGZsYWdzOiB7XG4gICAgICAgICAgICAgIGlzTGVhZGluZzogMCxcbiAgICAgICAgICAgICAgaXNEZXBlbmRlZE9uOiAwLFxuICAgICAgICAgICAgICBoYXNSZWR1bmRhbmN5OiAwLFxuICAgICAgICAgICAgICBkZWdyYWRQcmlvOiAwLFxuICAgICAgICAgICAgICBkZXBlbmRzT246IDEsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICBvdXRwdXRTYW1wbGVzLnB1c2gobXA0U2FtcGxlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbWRhdC5zZXQodW5pdCwgb2Zmc2V0KTtcbiAgICAgIGxldCB1bml0TGVuID0gdW5pdC5ieXRlTGVuZ3RoO1xuICAgICAgb2Zmc2V0ICs9IHVuaXRMZW47XG4gICAgICAvL2NvbnNvbGUubG9nKCdQVFMvRFRTL2luaXREVFMvbm9ybVBUUy9ub3JtRFRTL3JlbGF0aXZlIFBUUyA6ICR7YXVkaW9TYW1wbGUucHRzfS8ke2F1ZGlvU2FtcGxlLmR0c30vJHtpbml0RFRTfS8ke3B0c25vcm19LyR7ZHRzbm9ybX0vJHsoYXVkaW9TYW1wbGUucHRzLzQyOTQ5NjcyOTYpLnRvRml4ZWQoMyl9Jyk7XG4gICAgICBtcDRTYW1wbGUgPSB7XG4gICAgICAgIHNpemU6IHVuaXRMZW4sXG4gICAgICAgIGN0czogMCxcbiAgICAgICAgZHVyYXRpb246IDAsXG4gICAgICAgIGZsYWdzOiB7XG4gICAgICAgICAgaXNMZWFkaW5nOiAwLFxuICAgICAgICAgIGlzRGVwZW5kZWRPbjogMCxcbiAgICAgICAgICBoYXNSZWR1bmRhbmN5OiAwLFxuICAgICAgICAgIGRlZ3JhZFByaW86IDAsXG4gICAgICAgICAgZGVwZW5kc09uOiAxLFxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgb3V0cHV0U2FtcGxlcy5wdXNoKG1wNFNhbXBsZSk7XG4gICAgICBsYXN0RFRTID0gZHRzbm9ybTtcbiAgICB9XG4gICAgdmFyIGxhc3RTYW1wbGVEdXJhdGlvbiA9IDA7XG4gICAgdmFyIG5iU2FtcGxlcyA9IG91dHB1dFNhbXBsZXMubGVuZ3RoO1xuICAgIC8vc2V0IGxhc3Qgc2FtcGxlIGR1cmF0aW9uIGFzIGJlaW5nIGlkZW50aWNhbCB0byBwcmV2aW91cyBzYW1wbGVcbiAgICBpZiAobmJTYW1wbGVzID49IDIpIHtcbiAgICAgIGxhc3RTYW1wbGVEdXJhdGlvbiA9IG91dHB1dFNhbXBsZXNbbmJTYW1wbGVzIC0gMl0uZHVyYXRpb247XG4gICAgICBtcDRTYW1wbGUuZHVyYXRpb24gPSBsYXN0U2FtcGxlRHVyYXRpb247XG4gICAgfVxuICAgIGlmIChuYlNhbXBsZXMpIHtcbiAgICAgIC8vIG5leHQgYXVkaW8gc2FtcGxlIFBUUyBzaG91bGQgYmUgZXF1YWwgdG8gbGFzdCBzYW1wbGUgUFRTICsgZHVyYXRpb25cbiAgICAgIHRoaXMubmV4dEF1ZGlvUHRzID0gcHRzbm9ybSArIHBlczJtcDRTY2FsZUZhY3RvciAqIGxhc3RTYW1wbGVEdXJhdGlvbjtcbiAgICAgIC8vbG9nZ2VyLmxvZygnQXVkaW8vUFRTL1BUU2VuZDonICsgYXVkaW9TYW1wbGUucHRzLnRvRml4ZWQoMCkgKyAnLycgKyB0aGlzLm5leHRBYWNEdHMudG9GaXhlZCgwKSk7XG4gICAgICB0cmFjay5sZW4gPSAwO1xuICAgICAgdHJhY2suc2FtcGxlcyA9IG91dHB1dFNhbXBsZXM7XG4gICAgICBpZiAocmF3TVBFRykge1xuICAgICAgICBtb29mID0gbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1vb2YgPSBNUDQubW9vZih0cmFjay5zZXF1ZW5jZU51bWJlcisrLCBmaXJzdERUUyAvIHBlczJtcDRTY2FsZUZhY3RvciwgdHJhY2spO1xuICAgICAgfVxuICAgICAgdHJhY2suc2FtcGxlcyA9IFtdO1xuICAgICAgbGV0IGF1ZGlvRGF0YSA9IHtcbiAgICAgICAgaWQgOiB0aGlzLmlkLFxuICAgICAgICBsZXZlbCA6IHRoaXMubGV2ZWwsXG4gICAgICAgIHNuIDogdGhpcy5zbixcbiAgICAgICAgZGF0YTE6IG1vb2YsXG4gICAgICAgIGRhdGEyOiBtZGF0LFxuICAgICAgICBzdGFydFBUUzogZmlyc3RQVFMgLyBwZXNUaW1lU2NhbGUsXG4gICAgICAgIGVuZFBUUzogdGhpcy5uZXh0QXVkaW9QdHMgLyBwZXNUaW1lU2NhbGUsXG4gICAgICAgIHN0YXJ0RFRTOiBmaXJzdERUUyAvIHBlc1RpbWVTY2FsZSxcbiAgICAgICAgZW5kRFRTOiAoZHRzbm9ybSArIHBlczJtcDRTY2FsZUZhY3RvciAqIGxhc3RTYW1wbGVEdXJhdGlvbikgLyBwZXNUaW1lU2NhbGUsXG4gICAgICAgIHR5cGU6ICdhdWRpbycsXG4gICAgICAgIG5iOiBuYlNhbXBsZXNcbiAgICAgIH07XG4gICAgICB0aGlzLm9ic2VydmVyLnRyaWdnZXIoRXZlbnQuRlJBR19QQVJTSU5HX0RBVEEsIGF1ZGlvRGF0YSk7XG4gICAgICByZXR1cm4gYXVkaW9EYXRhO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJlbXV4RW1wdHlBdWRpbyh0cmFjaywgdGltZU9mZnNldCwgY29udGlndW91cywgdmlkZW9EYXRhKSB7XG4gICAgbGV0IHBlc1RpbWVTY2FsZSA9IHRoaXMuUEVTX1RJTUVTQ0FMRSxcbiAgICAgICAgbXA0dGltZVNjYWxlID0gdHJhY2sudGltZXNjYWxlID8gdHJhY2sudGltZXNjYWxlIDogdHJhY2suYXVkaW9zYW1wbGVyYXRlLFxuICAgICAgICBwZXMybXA0U2NhbGVGYWN0b3IgPSBwZXNUaW1lU2NhbGUvbXA0dGltZVNjYWxlLFxuICAgICAgICBuZXh0QXVkaW9QdHMgPSB0aGlzLm5leHRBdWRpb1B0cyxcblxuICAgICAgICAvLyBzeW5jIHdpdGggdmlkZW8ncyB0aW1lc3RhbXBcbiAgICAgICAgc3RhcnREVFMgPSAobmV4dEF1ZGlvUHRzICE9PSB1bmRlZmluZWQgPyBuZXh0QXVkaW9QdHMgOiB2aWRlb0RhdGEuc3RhcnREVFMgKiBwZXNUaW1lU2NhbGUpICsgdGhpcy5faW5pdERUUyxcbiAgICAgICAgZW5kRFRTID0gdmlkZW9EYXRhLmVuZERUUyAqIHBlc1RpbWVTY2FsZSArIHRoaXMuX2luaXREVFMsXG4gICAgICAgIC8vIG9uZSBzYW1wbGUncyBkdXJhdGlvbiB2YWx1ZVxuICAgICAgICBzYW1wbGVEdXJhdGlvbiA9IDEwMjQsXG4gICAgICAgIGZyYW1lRHVyYXRpb24gPSBwZXMybXA0U2NhbGVGYWN0b3IgKiBzYW1wbGVEdXJhdGlvbixcblxuICAgICAgICAvLyBzYW1wbGVzIGNvdW50IG9mIHRoaXMgc2VnbWVudCdzIGR1cmF0aW9uXG4gICAgICAgIG5iU2FtcGxlcyA9IE1hdGguY2VpbCgoZW5kRFRTIC0gc3RhcnREVFMpIC8gZnJhbWVEdXJhdGlvbiksXG5cbiAgICAgICAgLy8gc2lsZW50IGZyYW1lXG4gICAgICAgIHNpbGVudEZyYW1lID0gQUFDLmdldFNpbGVudEZyYW1lKHRyYWNrLmNoYW5uZWxDb3VudCk7XG5cbiAgICAgICAgbG9nZ2VyLndhcm4oJ3JlbXV4IGVtcHR5IEF1ZGlvJyk7XG4gICAgLy8gQ2FuJ3QgcmVtdXggaWYgd2UgY2FuJ3QgZ2VuZXJhdGUgYSBzaWxlbnQgZnJhbWUuLi5cbiAgICBpZiAoIXNpbGVudEZyYW1lKSB7XG4gICAgICBsb2dnZXIudHJhY2UoJ1VuYWJsZSB0byByZW11eEVtcHR5QXVkaW8gc2luY2Ugd2Ugd2VyZSB1bmFibGUgdG8gZ2V0IGEgc2lsZW50IGZyYW1lIGZvciBnaXZlbiBhdWRpbyBjb2RlYyEnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgc2FtcGxlcyA9IFtdO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBuYlNhbXBsZXM7IGkrKykge1xuICAgICAgdmFyIHN0YW1wID0gc3RhcnREVFMgKyBpICogZnJhbWVEdXJhdGlvbjtcbiAgICAgIHNhbXBsZXMucHVzaCh7dW5pdDogc2lsZW50RnJhbWUsIHB0czogc3RhbXAsIGR0czogc3RhbXB9KTtcbiAgICAgIHRyYWNrLmxlbiArPSBzaWxlbnRGcmFtZS5sZW5ndGg7XG4gICAgfVxuICAgIHRyYWNrLnNhbXBsZXMgPSBzYW1wbGVzO1xuXG4gICAgdGhpcy5yZW11eEF1ZGlvKHRyYWNrLCB0aW1lT2Zmc2V0LCBjb250aWd1b3VzKTtcbiAgfVxuXG4gIHJlbXV4SUQzKHRyYWNrLHRpbWVPZmZzZXQpIHtcbiAgICB2YXIgbGVuZ3RoID0gdHJhY2suc2FtcGxlcy5sZW5ndGgsIHNhbXBsZTtcbiAgICAvLyBjb25zdW1lIHNhbXBsZXNcbiAgICBpZihsZW5ndGgpIHtcbiAgICAgIGZvcih2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICBzYW1wbGUgPSB0cmFjay5zYW1wbGVzW2luZGV4XTtcbiAgICAgICAgLy8gc2V0dGluZyBpZDMgcHRzLCBkdHMgdG8gcmVsYXRpdmUgdGltZVxuICAgICAgICAvLyB1c2luZyB0aGlzLl9pbml0UFRTIGFuZCB0aGlzLl9pbml0RFRTIHRvIGNhbGN1bGF0ZSByZWxhdGl2ZSB0aW1lXG4gICAgICAgIHNhbXBsZS5wdHMgPSAoKHNhbXBsZS5wdHMgLSB0aGlzLl9pbml0UFRTKSAvIHRoaXMuUEVTX1RJTUVTQ0FMRSk7XG4gICAgICAgIHNhbXBsZS5kdHMgPSAoKHNhbXBsZS5kdHMgLSB0aGlzLl9pbml0RFRTKSAvIHRoaXMuUEVTX1RJTUVTQ0FMRSk7XG4gICAgICB9XG4gICAgICB0aGlzLm9ic2VydmVyLnRyaWdnZXIoRXZlbnQuRlJBR19QQVJTSU5HX01FVEFEQVRBLCB7XG4gICAgICAgIGlkIDogdGhpcy5pZCxcbiAgICAgICAgbGV2ZWwgOiB0aGlzLmxldmVsLFxuICAgICAgICBzbiA6IHRoaXMuc24sXG4gICAgICAgIHNhbXBsZXM6dHJhY2suc2FtcGxlc1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdHJhY2suc2FtcGxlcyA9IFtdO1xuICAgIHRpbWVPZmZzZXQgPSB0aW1lT2Zmc2V0O1xuICB9XG5cbiAgcmVtdXhUZXh0KHRyYWNrLHRpbWVPZmZzZXQpIHtcbiAgICB0cmFjay5zYW1wbGVzLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgcmV0dXJuIChhLnB0cy1iLnB0cyk7XG4gICAgfSk7XG5cbiAgICB2YXIgbGVuZ3RoID0gdHJhY2suc2FtcGxlcy5sZW5ndGgsIHNhbXBsZTtcbiAgICAvLyBjb25zdW1lIHNhbXBsZXNcbiAgICBpZihsZW5ndGgpIHtcbiAgICAgIGZvcih2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICBzYW1wbGUgPSB0cmFjay5zYW1wbGVzW2luZGV4XTtcbiAgICAgICAgLy8gc2V0dGluZyB0ZXh0IHB0cywgZHRzIHRvIHJlbGF0aXZlIHRpbWVcbiAgICAgICAgLy8gdXNpbmcgdGhpcy5faW5pdFBUUyBhbmQgdGhpcy5faW5pdERUUyB0byBjYWxjdWxhdGUgcmVsYXRpdmUgdGltZVxuICAgICAgICBzYW1wbGUucHRzID0gKChzYW1wbGUucHRzIC0gdGhpcy5faW5pdFBUUykgLyB0aGlzLlBFU19USU1FU0NBTEUpO1xuICAgICAgfVxuICAgICAgdGhpcy5vYnNlcnZlci50cmlnZ2VyKEV2ZW50LkZSQUdfUEFSU0lOR19VU0VSREFUQSwge1xuICAgICAgICBpZCA6IHRoaXMuaWQsXG4gICAgICAgIGxldmVsIDogdGhpcy5sZXZlbCxcbiAgICAgICAgc24gOiB0aGlzLnNuLFxuICAgICAgICBzYW1wbGVzOnRyYWNrLnNhbXBsZXNcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRyYWNrLnNhbXBsZXMgPSBbXTtcbiAgICB0aW1lT2Zmc2V0ID0gdGltZU9mZnNldDtcbiAgfVxuXG4gIF9QVFNOb3JtYWxpemUodmFsdWUsIHJlZmVyZW5jZSkge1xuICAgIHZhciBvZmZzZXQ7XG4gICAgaWYgKHJlZmVyZW5jZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGlmIChyZWZlcmVuY2UgPCB2YWx1ZSkge1xuICAgICAgLy8gLSAyXjMzXG4gICAgICBvZmZzZXQgPSAtODU4OTkzNDU5MjtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gKyAyXjMzXG4gICAgICBvZmZzZXQgPSA4NTg5OTM0NTkyO1xuICAgIH1cbiAgICAvKiBQVFMgaXMgMzNiaXQgKGZyb20gMCB0byAyXjMzIC0xKVxuICAgICAgaWYgZGlmZiBiZXR3ZWVuIHZhbHVlIGFuZCByZWZlcmVuY2UgaXMgYmlnZ2VyIHRoYW4gaGFsZiBvZiB0aGUgYW1wbGl0dWRlICgyXjMyKSB0aGVuIGl0IG1lYW5zIHRoYXRcbiAgICAgIFBUUyBsb29waW5nIG9jY3VyZWQuIGZpbGwgdGhlIGdhcCAqL1xuICAgIHdoaWxlIChNYXRoLmFicyh2YWx1ZSAtIHJlZmVyZW5jZSkgPiA0Mjk0OTY3Mjk2KSB7XG4gICAgICAgIHZhbHVlICs9IG9mZnNldDtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgTVA0UmVtdXhlcjtcbiIsIi8qKlxuICogcGFzc3Rocm91Z2ggcmVtdXhlclxuKi9cbmltcG9ydCBFdmVudCBmcm9tICcuLi9ldmVudHMnO1xuXG5jbGFzcyBQYXNzVGhyb3VnaFJlbXV4ZXIge1xuICBjb25zdHJ1Y3RvcihvYnNlcnZlcixpZCkge1xuICAgIHRoaXMub2JzZXJ2ZXIgPSBvYnNlcnZlcjtcbiAgICB0aGlzLmlkID0gaWQ7XG4gICAgdGhpcy5JU0dlbmVyYXRlZCA9IGZhbHNlO1xuICB9XG5cbiAgZ2V0IHBhc3N0aHJvdWdoKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgfVxuXG4gIGluc2VydERpc2NvbnRpbnVpdHkoKSB7XG4gIH1cblxuICBzd2l0Y2hMZXZlbCgpIHtcbiAgICB0aGlzLklTR2VuZXJhdGVkID0gZmFsc2U7XG4gIH1cblxuICByZW11eChhdWRpb1RyYWNrLHZpZGVvVHJhY2ssaWQzVHJhY2ssdGV4dFRyYWNrLHRpbWVPZmZzZXQscmF3RGF0YSkge1xuICAgIHZhciBvYnNlcnZlciA9IHRoaXMub2JzZXJ2ZXI7XG4gICAgLy8gZ2VuZXJhdGUgSW5pdCBTZWdtZW50IGlmIG5lZWRlZFxuICAgIGlmICghdGhpcy5JU0dlbmVyYXRlZCkge1xuICAgICAgdmFyIHRyYWNrcyA9IHt9LFxuICAgICAgICAgIGRhdGEgPSB7IGlkIDogdGhpcy5pZCwgdHJhY2tzIDogdHJhY2tzLCB1bmlxdWUgOiB0cnVlIH0sXG4gICAgICAgICAgdHJhY2sgPSB2aWRlb1RyYWNrLFxuICAgICAgICAgIGNvZGVjID0gdHJhY2suY29kZWM7XG5cbiAgICAgIGlmIChjb2RlYykge1xuICAgICAgICBkYXRhLnRyYWNrcy52aWRlbyA9IHtcbiAgICAgICAgICBjb250YWluZXIgOiB0cmFjay5jb250YWluZXIsXG4gICAgICAgICAgY29kZWMgOiAgY29kZWMsXG4gICAgICAgICAgbWV0YWRhdGEgOiB7XG4gICAgICAgICAgICB3aWR0aCA6IHRyYWNrLndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0IDogdHJhY2suaGVpZ2h0XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICB0cmFjayA9IGF1ZGlvVHJhY2s7XG4gICAgICBjb2RlYyA9IHRyYWNrLmNvZGVjO1xuICAgICAgaWYgKGNvZGVjKSB7XG4gICAgICAgIGRhdGEudHJhY2tzLmF1ZGlvID0ge1xuICAgICAgICAgIGNvbnRhaW5lciA6IHRyYWNrLmNvbnRhaW5lcixcbiAgICAgICAgICBjb2RlYyA6ICBjb2RlYyxcbiAgICAgICAgICBtZXRhZGF0YSA6IHtcbiAgICAgICAgICAgIGNoYW5uZWxDb3VudCA6IHRyYWNrLmNoYW5uZWxDb3VudFxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHRoaXMuSVNHZW5lcmF0ZWQgPSB0cnVlO1xuICAgICAgb2JzZXJ2ZXIudHJpZ2dlcihFdmVudC5GUkFHX1BBUlNJTkdfSU5JVF9TRUdNRU5ULGRhdGEpO1xuICAgIH1cbiAgICBvYnNlcnZlci50cmlnZ2VyKEV2ZW50LkZSQUdfUEFSU0lOR19EQVRBLCB7XG4gICAgICBpZCA6IHRoaXMuaWQsXG4gICAgICBkYXRhMTogcmF3RGF0YSxcbiAgICAgIHN0YXJ0UFRTOiB0aW1lT2Zmc2V0LFxuICAgICAgc3RhcnREVFM6IHRpbWVPZmZzZXQsXG4gICAgICB0eXBlOiAnYXVkaW92aWRlbycsXG4gICAgICBuYjogMSxcbiAgICAgIGRyb3BwZWQgOiAwXG4gICAgfSk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgUGFzc1Rocm91Z2hSZW11eGVyO1xuIiwiY29uc3QgREVDSU1BTF9SRVNPTFVUSU9OX1JFR0VYID0gL14oXFxkKyl4KFxcZCspJC87XG5jb25zdCBBVFRSX0xJU1RfUkVHRVggPSAvXFxzKiguKz8pXFxzKj0oKD86XFxcIi4qP1xcXCIpfC4qPykoPzosfCQpL2c7XG5cbi8vIGFkYXB0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20va2Fub25naWwvbm9kZS1tM3U4cGFyc2UvYmxvYi9tYXN0ZXIvYXR0cmxpc3QuanNcbmNsYXNzIEF0dHJMaXN0IHtcblxuICBjb25zdHJ1Y3RvcihhdHRycykge1xuICAgIGlmICh0eXBlb2YgYXR0cnMgPT09ICdzdHJpbmcnKSB7XG4gICAgICBhdHRycyA9IEF0dHJMaXN0LnBhcnNlQXR0ckxpc3QoYXR0cnMpO1xuICAgIH1cbiAgICBmb3IodmFyIGF0dHIgaW4gYXR0cnMpe1xuICAgICAgaWYoYXR0cnMuaGFzT3duUHJvcGVydHkoYXR0cikpIHtcbiAgICAgICAgdGhpc1thdHRyXSA9IGF0dHJzW2F0dHJdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGRlY2ltYWxJbnRlZ2VyKGF0dHJOYW1lKSB7XG4gICAgY29uc3QgaW50VmFsdWUgPSBwYXJzZUludCh0aGlzW2F0dHJOYW1lXSwgMTApO1xuICAgIGlmIChpbnRWYWx1ZSA+IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKSB7XG4gICAgICByZXR1cm4gSW5maW5pdHk7XG4gICAgfVxuICAgIHJldHVybiBpbnRWYWx1ZTtcbiAgfVxuXG4gIGhleGFkZWNpbWFsSW50ZWdlcihhdHRyTmFtZSkge1xuICAgIGlmKHRoaXNbYXR0ck5hbWVdKSB7XG4gICAgICBsZXQgc3RyaW5nVmFsdWUgPSAodGhpc1thdHRyTmFtZV0gfHwgJzB4Jykuc2xpY2UoMik7XG4gICAgICBzdHJpbmdWYWx1ZSA9ICgoc3RyaW5nVmFsdWUubGVuZ3RoICYgMSkgPyAnMCcgOiAnJykgKyBzdHJpbmdWYWx1ZTtcblxuICAgICAgY29uc3QgdmFsdWUgPSBuZXcgVWludDhBcnJheShzdHJpbmdWYWx1ZS5sZW5ndGggLyAyKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyaW5nVmFsdWUubGVuZ3RoIC8gMjsgaSsrKSB7XG4gICAgICAgIHZhbHVlW2ldID0gcGFyc2VJbnQoc3RyaW5nVmFsdWUuc2xpY2UoaSAqIDIsIGkgKiAyICsgMiksIDE2KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgaGV4YWRlY2ltYWxJbnRlZ2VyQXNOdW1iZXIoYXR0ck5hbWUpIHtcbiAgICBjb25zdCBpbnRWYWx1ZSA9IHBhcnNlSW50KHRoaXNbYXR0ck5hbWVdLCAxNik7XG4gICAgaWYgKGludFZhbHVlID4gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpIHtcbiAgICAgIHJldHVybiBJbmZpbml0eTtcbiAgICB9XG4gICAgcmV0dXJuIGludFZhbHVlO1xuICB9XG5cbiAgZGVjaW1hbEZsb2F0aW5nUG9pbnQoYXR0ck5hbWUpIHtcbiAgICByZXR1cm4gcGFyc2VGbG9hdCh0aGlzW2F0dHJOYW1lXSk7XG4gIH1cblxuICBlbnVtZXJhdGVkU3RyaW5nKGF0dHJOYW1lKSB7XG4gICAgcmV0dXJuIHRoaXNbYXR0ck5hbWVdO1xuICB9XG5cbiAgZGVjaW1hbFJlc29sdXRpb24oYXR0ck5hbWUpIHtcbiAgICBjb25zdCByZXMgPSBERUNJTUFMX1JFU09MVVRJT05fUkVHRVguZXhlYyh0aGlzW2F0dHJOYW1lXSk7XG4gICAgaWYgKHJlcyA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHdpZHRoOiBwYXJzZUludChyZXNbMV0sIDEwKSxcbiAgICAgIGhlaWdodDogcGFyc2VJbnQocmVzWzJdLCAxMClcbiAgICB9O1xuICB9XG5cbiAgc3RhdGljIHBhcnNlQXR0ckxpc3QoaW5wdXQpIHtcbiAgICB2YXIgbWF0Y2gsIGF0dHJzID0ge307XG4gICAgQVRUUl9MSVNUX1JFR0VYLmxhc3RJbmRleCA9IDA7XG4gICAgd2hpbGUgKChtYXRjaCA9IEFUVFJfTElTVF9SRUdFWC5leGVjKGlucHV0KSkgIT09IG51bGwpIHtcbiAgICAgIHZhciB2YWx1ZSA9IG1hdGNoWzJdLCBxdW90ZSA9ICdcIic7XG5cbiAgICAgIGlmICh2YWx1ZS5pbmRleE9mKHF1b3RlKSA9PT0gMCAmJlxuICAgICAgICAgIHZhbHVlLmxhc3RJbmRleE9mKHF1b3RlKSA9PT0gKHZhbHVlLmxlbmd0aC0xKSkge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnNsaWNlKDEsIC0xKTtcbiAgICAgIH1cbiAgICAgIGF0dHJzW21hdGNoWzFdXSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gYXR0cnM7XG4gIH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBBdHRyTGlzdDtcbiIsInZhciBCaW5hcnlTZWFyY2ggPSB7XG4gICAgLyoqXG4gICAgICogU2VhcmNoZXMgZm9yIGFuIGl0ZW0gaW4gYW4gYXJyYXkgd2hpY2ggbWF0Y2hlcyBhIGNlcnRhaW4gY29uZGl0aW9uLlxuICAgICAqIFRoaXMgcmVxdWlyZXMgdGhlIGNvbmRpdGlvbiB0byBvbmx5IG1hdGNoIG9uZSBpdGVtIGluIHRoZSBhcnJheSxcbiAgICAgKiBhbmQgZm9yIHRoZSBhcnJheSB0byBiZSBvcmRlcmVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgYXJyYXkgdG8gc2VhcmNoLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbXBhcmlzb25GdW5jdGlvblxuICAgICAqICAgICAgQ2FsbGVkIGFuZCBwcm92aWRlZCBhIGNhbmRpZGF0ZSBpdGVtIGFzIHRoZSBmaXJzdCBhcmd1bWVudC5cbiAgICAgKiAgICAgIFNob3VsZCByZXR1cm46XG4gICAgICogICAgICAgICAgPiAtMSBpZiB0aGUgaXRlbSBzaG91bGQgYmUgbG9jYXRlZCBhdCBhIGxvd2VyIGluZGV4IHRoYW4gdGhlIHByb3ZpZGVkIGl0ZW0uXG4gICAgICogICAgICAgICAgPiAxIGlmIHRoZSBpdGVtIHNob3VsZCBiZSBsb2NhdGVkIGF0IGEgaGlnaGVyIGluZGV4IHRoYW4gdGhlIHByb3ZpZGVkIGl0ZW0uXG4gICAgICogICAgICAgICAgPiAwIGlmIHRoZSBpdGVtIGlzIHRoZSBpdGVtIHlvdSdyZSBsb29raW5nIGZvci5cbiAgICAgKlxuICAgICAqIEByZXR1cm4geyp9IFRoZSBvYmplY3QgaWYgaXQgaXMgZm91bmQgb3IgbnVsbCBvdGhlcndpc2UuXG4gICAgICovXG4gICAgc2VhcmNoOiBmdW5jdGlvbihsaXN0LCBjb21wYXJpc29uRnVuY3Rpb24pIHtcbiAgICAgICAgdmFyIG1pbkluZGV4ID0gMDtcbiAgICAgICAgdmFyIG1heEluZGV4ID0gbGlzdC5sZW5ndGggLSAxO1xuICAgICAgICB2YXIgY3VycmVudEluZGV4ID0gbnVsbDtcbiAgICAgICAgdmFyIGN1cnJlbnRFbGVtZW50ID0gbnVsbDtcbiAgICAgXG4gICAgICAgIHdoaWxlIChtaW5JbmRleCA8PSBtYXhJbmRleCkge1xuICAgICAgICAgICAgY3VycmVudEluZGV4ID0gKG1pbkluZGV4ICsgbWF4SW5kZXgpIC8gMiB8IDA7XG4gICAgICAgICAgICBjdXJyZW50RWxlbWVudCA9IGxpc3RbY3VycmVudEluZGV4XTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIGNvbXBhcmlzb25SZXN1bHQgPSBjb21wYXJpc29uRnVuY3Rpb24oY3VycmVudEVsZW1lbnQpO1xuICAgICAgICAgICAgaWYgKGNvbXBhcmlzb25SZXN1bHQgPiAwKSB7XG4gICAgICAgICAgICAgICAgbWluSW5kZXggPSBjdXJyZW50SW5kZXggKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY29tcGFyaXNvblJlc3VsdCA8IDApIHtcbiAgICAgICAgICAgICAgICBtYXhJbmRleCA9IGN1cnJlbnRJbmRleCAtIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3VycmVudEVsZW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQmluYXJ5U2VhcmNoO1xuIiwiLyoqXG4gKlxuICogVGhpcyBjb2RlIHdhcyBwb3J0ZWQgZnJvbSB0aGUgZGFzaC5qcyBwcm9qZWN0IGF0OlxuICogICBodHRwczovL2dpdGh1Yi5jb20vRGFzaC1JbmR1c3RyeS1Gb3J1bS9kYXNoLmpzL2Jsb2IvZGV2ZWxvcG1lbnQvZXh0ZXJuYWxzL2NlYTYwOC1wYXJzZXIuanNcbiAqICAgaHR0cHM6Ly9naXRodWIuY29tL0Rhc2gtSW5kdXN0cnktRm9ydW0vZGFzaC5qcy9jb21taXQvODI2OWIyNmE3NjFlMDg1M2JiMjFkNzg3ODBlZDk0NTE0NGVjZGQ0ZCNkaWZmLTcxYmMyOTVhMmQ2YjZiNzA5M2ExZDMyOTBkNTNhNGIyXG4gKlxuICogVGhlIG9yaWdpbmFsIGNvcHlyaWdodCBhcHBlYXJzIGJlbG93OlxuICpcbiAqIFRoZSBjb3B5cmlnaHQgaW4gdGhpcyBzb2Z0d2FyZSBpcyBiZWluZyBtYWRlIGF2YWlsYWJsZSB1bmRlciB0aGUgQlNEIExpY2Vuc2UsXG4gKiBpbmNsdWRlZCBiZWxvdy4gVGhpcyBzb2Z0d2FyZSBtYXkgYmUgc3ViamVjdCB0byBvdGhlciB0aGlyZCBwYXJ0eSBhbmQgY29udHJpYnV0b3JcbiAqIHJpZ2h0cywgaW5jbHVkaW5nIHBhdGVudCByaWdodHMsIGFuZCBubyBzdWNoIHJpZ2h0cyBhcmUgZ3JhbnRlZCB1bmRlciB0aGlzIGxpY2Vuc2UuXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1LTIwMTYsIERBU0ggSW5kdXN0cnkgRm9ydW0uXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dCBtb2RpZmljYXRpb24sXG4gKiBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG4gKiAgMS4gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzXG4gKiAgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gKiAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXG4gKiAgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3JcbiAqICBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuICogIDIuIE5laXRoZXIgdGhlIG5hbWUgb2YgRGFzaCBJbmR1c3RyeSBGb3J1bSBub3IgdGhlIG5hbWVzIG9mIGl0c1xuICogIGNvbnRyaWJ1dG9ycyBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmVcbiAqICB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cbiAqXG4gKiAgVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBBUyBJUyBBTkQgQU5ZXG4gKiAgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRFxuICogIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC5cbiAqICBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIEhPTERFUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULFxuICogIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVRcbiAqICBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SXG4gKiAgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksXG4gKiAgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKVxuICogIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFXG4gKiAgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4gKi9cbiAgICAvKipcbiAgICAgKiAgRXhjZXB0aW9ucyBmcm9tIHJlZ3VsYXIgQVNDSUkuIENvZGVQb2ludHMgYXJlIG1hcHBlZCB0byBVVEYtMTYgY29kZXNcbiAgICAgKi9cblxudmFyIHNwZWNpYWxDZWE2MDhDaGFyc0NvZGVzID0ge1xuICAgIDB4MmEgOiAweGUxLCAvLyBsb3dlcmNhc2UgYSwgYWN1dGUgYWNjZW50XG4gICAgMHg1YyA6IDB4ZTksIC8vIGxvd2VyY2FzZSBlLCBhY3V0ZSBhY2NlbnRcbiAgICAweDVlIDogMHhlZCwgLy8gbG93ZXJjYXNlIGksIGFjdXRlIGFjY2VudFxuICAgIDB4NWYgOiAweGYzLCAvLyBsb3dlcmNhc2UgbywgYWN1dGUgYWNjZW50XG4gICAgMHg2MCA6IDB4ZmEsIC8vIGxvd2VyY2FzZSB1LCBhY3V0ZSBhY2NlbnRcbiAgICAweDdiIDogMHhlNywgLy8gbG93ZXJjYXNlIGMgd2l0aCBjZWRpbGxhXG4gICAgMHg3YyA6IDB4ZjcsIC8vIGRpdmlzaW9uIHN5bWJvbFxuICAgIDB4N2QgOiAweGQxLCAvLyB1cHBlcmNhc2UgTiB0aWxkZVxuICAgIDB4N2UgOiAweGYxLCAvLyBsb3dlcmNhc2UgbiB0aWxkZVxuICAgIDB4N2YgOiAweDI1ODgsIC8vIEZ1bGwgYmxvY2tcbiAgICAvLyBUSElTIEJMT0NLIElOQ0xVREVTIFRIRSAxNiBFWFRFTkRFRCAoVFdPLUJZVEUpIExJTkUgMjEgQ0hBUkFDVEVSU1xuICAgIC8vIFRIQVQgQ09NRSBGUk9NIEhJIEJZVEU9MHgxMSBBTkQgTE9XIEJFVFdFRU4gMHgzMCBBTkQgMHgzRlxuICAgIC8vIFRISVMgTUVBTlMgVEhBVCBcXHg1MCBNVVNUIEJFIEFEREVEIFRPIFRIRSBWQUxVRVNcbiAgICAweDgwIDogMHhhZSwgLy8gUmVnaXN0ZXJlZCBzeW1ib2wgKFIpXG4gICAgMHg4MSA6IDB4YjAsIC8vIGRlZ3JlZSBzaWduXG4gICAgMHg4MiA6IDB4YmQsIC8vIDEvMiBzeW1ib2xcbiAgICAweDgzIDogMHhiZiwgLy8gSW52ZXJ0ZWQgKG9wZW4pIHF1ZXN0aW9uIG1hcmtcbiAgICAweDg0IDogMHgyMTIyLCAvLyBUcmFkZW1hcmsgc3ltYm9sIChUTSlcbiAgICAweDg1IDogMHhhMiwgLy8gQ2VudHMgc3ltYm9sXG4gICAgMHg4NiA6IDB4YTMsIC8vIFBvdW5kcyBzdGVybGluZ1xuICAgIDB4ODcgOiAweDI2NmEsIC8vIE11c2ljIDgndGggbm90ZVxuICAgIDB4ODggOiAweGUwLCAvLyBsb3dlcmNhc2UgYSwgZ3JhdmUgYWNjZW50XG4gICAgMHg4OSA6IDB4MjAsIC8vIHRyYW5zcGFyZW50IHNwYWNlIChyZWd1bGFyKVxuICAgIDB4OGEgOiAweGU4LCAvLyBsb3dlcmNhc2UgZSwgZ3JhdmUgYWNjZW50XG4gICAgMHg4YiA6IDB4ZTIsIC8vIGxvd2VyY2FzZSBhLCBjaXJjdW1mbGV4IGFjY2VudFxuICAgIDB4OGMgOiAweGVhLCAvLyBsb3dlcmNhc2UgZSwgY2lyY3VtZmxleCBhY2NlbnRcbiAgICAweDhkIDogMHhlZSwgLy8gbG93ZXJjYXNlIGksIGNpcmN1bWZsZXggYWNjZW50XG4gICAgMHg4ZSA6IDB4ZjQsIC8vIGxvd2VyY2FzZSBvLCBjaXJjdW1mbGV4IGFjY2VudFxuICAgIDB4OGYgOiAweGZiLCAvLyBsb3dlcmNhc2UgdSwgY2lyY3VtZmxleCBhY2NlbnRcbiAgICAvLyBUSElTIEJMT0NLIElOQ0xVREVTIFRIRSAzMiBFWFRFTkRFRCAoVFdPLUJZVEUpIExJTkUgMjEgQ0hBUkFDVEVSU1xuICAgIC8vIFRIQVQgQ09NRSBGUk9NIEhJIEJZVEU9MHgxMiBBTkQgTE9XIEJFVFdFRU4gMHgyMCBBTkQgMHgzRlxuICAgIDB4OTAgOiAweGMxLCAvLyBjYXBpdGFsIGxldHRlciBBIHdpdGggYWN1dGVcbiAgICAweDkxIDogMHhjOSwgLy8gY2FwaXRhbCBsZXR0ZXIgRSB3aXRoIGFjdXRlXG4gICAgMHg5MiA6IDB4ZDMsIC8vIGNhcGl0YWwgbGV0dGVyIE8gd2l0aCBhY3V0ZVxuICAgIDB4OTMgOiAweGRhLCAvLyBjYXBpdGFsIGxldHRlciBVIHdpdGggYWN1dGVcbiAgICAweDk0IDogMHhkYywgLy8gY2FwaXRhbCBsZXR0ZXIgVSB3aXRoIGRpYXJlc2lzXG4gICAgMHg5NSA6IDB4ZmMsIC8vIGxvd2VyY2FzZSBsZXR0ZXIgVSB3aXRoIGRpYWVyZXNpc1xuICAgIDB4OTYgOiAweDIwMTgsIC8vIG9wZW5pbmcgc2luZ2xlIHF1b3RlXG4gICAgMHg5NyA6IDB4YTEsIC8vIGludmVydGVkIGV4Y2xhbWF0aW9uIG1hcmtcbiAgICAweDk4IDogMHgyYSwgLy8gYXN0ZXJpc2tcbiAgICAweDk5IDogMHgyMDE5LCAvLyBjbG9zaW5nIHNpbmdsZSBxdW90ZVxuICAgIDB4OWEgOiAweDI1MDEsIC8vIGJveCBkcmF3aW5ncyBoZWF2eSBob3Jpem9udGFsXG4gICAgMHg5YiA6IDB4YTksIC8vIGNvcHlyaWdodCBzaWduXG4gICAgMHg5YyA6IDB4MjEyMCwgLy8gU2VydmljZSBtYXJrXG4gICAgMHg5ZCA6IDB4MjAyMiwgLy8gKHJvdW5kKSBidWxsZXRcbiAgICAweDllIDogMHgyMDFjLCAvLyBMZWZ0IGRvdWJsZSBxdW90YXRpb24gbWFya1xuICAgIDB4OWYgOiAweDIwMWQsIC8vIFJpZ2h0IGRvdWJsZSBxdW90YXRpb24gbWFya1xuICAgIDB4YTAgOiAweGMwLCAvLyB1cHBlcmNhc2UgQSwgZ3JhdmUgYWNjZW50XG4gICAgMHhhMSA6IDB4YzIsIC8vIHVwcGVyY2FzZSBBLCBjaXJjdW1mbGV4XG4gICAgMHhhMiA6IDB4YzcsIC8vIHVwcGVyY2FzZSBDIHdpdGggY2VkaWxsYVxuICAgIDB4YTMgOiAweGM4LCAvLyB1cHBlcmNhc2UgRSwgZ3JhdmUgYWNjZW50XG4gICAgMHhhNCA6IDB4Y2EsIC8vIHVwcGVyY2FzZSBFLCBjaXJjdW1mbGV4XG4gICAgMHhhNSA6IDB4Y2IsIC8vIGNhcGl0YWwgbGV0dGVyIEUgd2l0aCBkaWFyZXNpc1xuICAgIDB4YTYgOiAweGViLCAvLyBsb3dlcmNhc2UgbGV0dGVyIGUgd2l0aCBkaWFyZXNpc1xuICAgIDB4YTcgOiAweGNlLCAvLyB1cHBlcmNhc2UgSSwgY2lyY3VtZmxleFxuICAgIDB4YTggOiAweGNmLCAvLyB1cHBlcmNhc2UgSSwgd2l0aCBkaWFyZXNpc1xuICAgIDB4YTkgOiAweGVmLCAvLyBsb3dlcmNhc2UgaSwgd2l0aCBkaWFyZXNpc1xuICAgIDB4YWEgOiAweGQ0LCAvLyB1cHBlcmNhc2UgTywgY2lyY3VtZmxleFxuICAgIDB4YWIgOiAweGQ5LCAvLyB1cHBlcmNhc2UgVSwgZ3JhdmUgYWNjZW50XG4gICAgMHhhYyA6IDB4ZjksIC8vIGxvd2VyY2FzZSB1LCBncmF2ZSBhY2NlbnRcbiAgICAweGFkIDogMHhkYiwgLy8gdXBwZXJjYXNlIFUsIGNpcmN1bWZsZXhcbiAgICAweGFlIDogMHhhYiwgLy8gbGVmdC1wb2ludGluZyBkb3VibGUgYW5nbGUgcXVvdGF0aW9uIG1hcmtcbiAgICAweGFmIDogMHhiYiwgLy8gcmlnaHQtcG9pbnRpbmcgZG91YmxlIGFuZ2xlIHF1b3RhdGlvbiBtYXJrXG4gICAgLy8gVEhJUyBCTE9DSyBJTkNMVURFUyBUSEUgMzIgRVhURU5ERUQgKFRXTy1CWVRFKSBMSU5FIDIxIENIQVJBQ1RFUlNcbiAgICAvLyBUSEFUIENPTUUgRlJPTSBISSBCWVRFPTB4MTMgQU5EIExPVyBCRVRXRUVOIDB4MjAgQU5EIDB4M0ZcbiAgICAweGIwIDogMHhjMywgLy8gVXBwZXJjYXNlIEEsIHRpbGRlXG4gICAgMHhiMSA6IDB4ZTMsIC8vIExvd2VyY2FzZSBhLCB0aWxkZVxuICAgIDB4YjIgOiAweGNkLCAvLyBVcHBlcmNhc2UgSSwgYWN1dGUgYWNjZW50XG4gICAgMHhiMyA6IDB4Y2MsIC8vIFVwcGVyY2FzZSBJLCBncmF2ZSBhY2NlbnRcbiAgICAweGI0IDogMHhlYywgLy8gTG93ZXJjYXNlIGksIGdyYXZlIGFjY2VudFxuICAgIDB4YjUgOiAweGQyLCAvLyBVcHBlcmNhc2UgTywgZ3JhdmUgYWNjZW50XG4gICAgMHhiNiA6IDB4ZjIsIC8vIExvd2VyY2FzZSBvLCBncmF2ZSBhY2NlbnRcbiAgICAweGI3IDogMHhkNSwgLy8gVXBwZXJjYXNlIE8sIHRpbGRlXG4gICAgMHhiOCA6IDB4ZjUsIC8vIExvd2VyY2FzZSBvLCB0aWxkZVxuICAgIDB4YjkgOiAweDdiLCAvLyBPcGVuIGN1cmx5IGJyYWNlXG4gICAgMHhiYSA6IDB4N2QsIC8vIENsb3NpbmcgY3VybHkgYnJhY2VcbiAgICAweGJiIDogMHg1YywgLy8gQmFja3NsYXNoXG4gICAgMHhiYyA6IDB4NWUsIC8vIENhcmV0XG4gICAgMHhiZCA6IDB4NWYsIC8vIFVuZGVyc2NvcmVcbiAgICAweGJlIDogMHg3YywgLy8gUGlwZSAodmVydGljYWwgbGluZSlcbiAgICAweGJmIDogMHgyMjNjLCAvLyBUaWxkZSBvcGVyYXRvclxuICAgIDB4YzAgOiAweGM0LCAvLyBVcHBlcmNhc2UgQSwgdW1sYXV0XG4gICAgMHhjMSA6IDB4ZTQsIC8vIExvd2VyY2FzZSBBLCB1bWxhdXRcbiAgICAweGMyIDogMHhkNiwgLy8gVXBwZXJjYXNlIE8sIHVtbGF1dFxuICAgIDB4YzMgOiAweGY2LCAvLyBMb3dlcmNhc2UgbywgdW1sYXV0XG4gICAgMHhjNCA6IDB4ZGYsIC8vIEVzc3pldHQgKHNoYXJwIFMpXG4gICAgMHhjNSA6IDB4YTUsIC8vIFllbiBzeW1ib2xcbiAgICAweGM2IDogMHhhNCwgLy8gR2VuZXJpYyBjdXJyZW5jeSBzaWduXG4gICAgMHhjNyA6IDB4MjUwMywgLy8gQm94IGRyYXdpbmdzIGhlYXZ5IHZlcnRpY2FsXG4gICAgMHhjOCA6IDB4YzUsIC8vIFVwcGVyY2FzZSBBLCByaW5nXG4gICAgMHhjOSA6IDB4ZTUsIC8vIExvd2VyY2FzZSBBLCByaW5nXG4gICAgMHhjYSA6IDB4ZDgsIC8vIFVwcGVyY2FzZSBPLCBzdHJva2VcbiAgICAweGNiIDogMHhmOCwgLy8gTG93ZXJjYXNlIG8sIHN0cm9rXG4gICAgMHhjYyA6IDB4MjUwZiwgLy8gQm94IGRyYXdpbmdzIGhlYXZ5IGRvd24gYW5kIHJpZ2h0XG4gICAgMHhjZCA6IDB4MjUxMywgLy8gQm94IGRyYXdpbmdzIGhlYXZ5IGRvd24gYW5kIGxlZnRcbiAgICAweGNlIDogMHgyNTE3LCAvLyBCb3ggZHJhd2luZ3MgaGVhdnkgdXAgYW5kIHJpZ2h0XG4gICAgMHhjZiA6IDB4MjUxYiAvLyBCb3ggZHJhd2luZ3MgaGVhdnkgdXAgYW5kIGxlZnRcbn07XG5cbi8qKlxuICogVXRpbHNcbiAqL1xudmFyIGdldENoYXJGb3JCeXRlID0gZnVuY3Rpb24oYnl0ZSkge1xuICAgIHZhciBjaGFyQ29kZSA9IGJ5dGU7XG4gICAgaWYgKHNwZWNpYWxDZWE2MDhDaGFyc0NvZGVzLmhhc093blByb3BlcnR5KGJ5dGUpKSB7XG4gICAgICAgIGNoYXJDb2RlID0gc3BlY2lhbENlYTYwOENoYXJzQ29kZXNbYnl0ZV07XG4gICAgfVxuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoYXJDb2RlKTtcbn07XG5cbnZhciBOUl9ST1dTID0gMTUsXG4gICAgTlJfQ09MUyA9IDEwMDtcbi8vIFRhYmxlcyB0byBsb29rIHVwIHJvdyBmcm9tIFBBQyBkYXRhXG52YXIgcm93c0xvd0NoMSA9IHsweDExIDogMSwgMHgxMiA6IDMsIDB4MTUgOiA1LCAweDE2IDogNywgMHgxNyA6IDksIDB4MTAgOiAxMSwgMHgxMyA6IDEyLCAweDE0IDogMTR9O1xudmFyIHJvd3NIaWdoQ2gxID0gezB4MTEgOiAyLCAweDEyIDogNCwgMHgxNSA6IDYsIDB4MTYgOiA4LCAweDE3IDogMTAsIDB4MTMgOiAxMywgMHgxNCA6IDE1fTtcbnZhciByb3dzTG93Q2gyID0gezB4MTkgOiAxLCAweDFBIDogMywgMHgxRCA6IDUsIDB4MUUgOiA3LCAweDFGIDogOSwgMHgxOCA6IDExLCAweDFCIDogMTIsIDB4MUMgOiAxNH07XG52YXIgcm93c0hpZ2hDaDIgPSB7MHgxOSA6IDIsIDB4MUEgOiA0LCAweDFEIDogNiwgMHgxRSA6IDgsIDB4MUYgOiAxMCwgMHgxQiA6IDEzLCAweDFDIDogMTV9O1xuXG52YXIgYmFja2dyb3VuZENvbG9ycyA9IFsnd2hpdGUnLCAnZ3JlZW4nLCAnYmx1ZScsICdjeWFuJywgJ3JlZCcsICd5ZWxsb3cnLCAnbWFnZW50YScsICdibGFjaycsICd0cmFuc3BhcmVudCddO1xuXG4vKipcbiAqIFNpbXBsZSBsb2dnZXIgY2xhc3MgdG8gYmUgYWJsZSB0byB3cml0ZSB3aXRoIHRpbWUtc3RhbXBzIGFuZCBmaWx0ZXIgb24gbGV2ZWwuXG4gKi9cbnZhciBsb2dnZXIgPSB7XG4gICAgdmVyYm9zZUZpbHRlciA6IHsnREFUQScgOiAzLCAnREVCVUcnIDogMywgJ0lORk8nIDogMiwgJ1dBUk5JTkcnIDogMiwgJ1RFWFQnIDogMSwgJ0VSUk9SJyA6IDB9LFxuICAgIHRpbWUgOiBudWxsLFxuICAgIHZlcmJvc2VMZXZlbCA6IDAsIC8vIE9ubHkgd3JpdGUgZXJyb3JzXG4gICAgc2V0VGltZSA6IGZ1bmN0aW9uKG5ld1RpbWUpIHtcbiAgICAgICAgdGhpcy50aW1lID0gbmV3VGltZTtcbiAgICB9LFxuICAgIGxvZyA6IGZ1bmN0aW9uKHNldmVyaXR5LCBtc2cpIHtcbiAgICAgICAgdmFyIG1pbkxldmVsID0gdGhpcy52ZXJib3NlRmlsdGVyW3NldmVyaXR5XTtcbiAgICAgICAgaWYgKHRoaXMudmVyYm9zZUxldmVsID49IG1pbkxldmVsKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyh0aGlzLnRpbWUudG9GaXhlZCgzKSArICcgWycgKyBzZXZlcml0eSArICddICcgKyBtc2cpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxudmFyIG51bUFycmF5VG9IZXhBcnJheSA9IGZ1bmN0aW9uKG51bUFycmF5KSB7XG4gICAgdmFyIGhleEFycmF5ID0gW107XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBudW1BcnJheS5sZW5ndGg7IGorKykge1xuICAgICAgICBoZXhBcnJheS5wdXNoKG51bUFycmF5W2pdLnRvU3RyaW5nKDE2KSk7XG4gICAgfVxuICAgIHJldHVybiBoZXhBcnJheTtcbn07XG5cbmNsYXNzIFBlblN0YXRlIHtcblxuICAgIGNvbnN0cnVjdG9yKGZvcmVncm91bmQsIHVuZGVybGluZSwgaXRhbGljcywgYmFja2dyb3VuZCwgZmxhc2gpIHtcbiAgICAgICAgdGhpcy5mb3JlZ3JvdW5kID0gZm9yZWdyb3VuZCB8fCAnd2hpdGUnO1xuICAgICAgICB0aGlzLnVuZGVybGluZSA9IHVuZGVybGluZSB8fCBmYWxzZTtcbiAgICAgICAgdGhpcy5pdGFsaWNzID0gaXRhbGljcyB8fCBmYWxzZTtcbiAgICAgICAgdGhpcy5iYWNrZ3JvdW5kID0gYmFja2dyb3VuZCB8fCAnYmxhY2snO1xuICAgICAgICB0aGlzLmZsYXNoID0gZmxhc2ggfHwgZmFsc2U7XG4gICAgfVxuXG4gICAgcmVzZXQoKSB7XG4gICAgICAgIHRoaXMuZm9yZWdyb3VuZCA9ICd3aGl0ZSc7XG4gICAgICAgIHRoaXMudW5kZXJsaW5lID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXRhbGljcyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmJhY2tncm91bmQgPSAnYmxhY2snO1xuICAgICAgICB0aGlzLmZsYXNoID0gZmFsc2U7XG4gICAgfVxuXG4gICAgc2V0U3R5bGVzKHN0eWxlcykge1xuICAgICAgICB2YXIgYXR0cmlicyA9IFsnZm9yZWdyb3VuZCcsICd1bmRlcmxpbmUnLCAnaXRhbGljcycsICdiYWNrZ3JvdW5kJywgJ2ZsYXNoJ107XG4gICAgICAgIGZvciAodmFyIGkgPSAwIDsgaSA8IGF0dHJpYnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBzdHlsZSA9IGF0dHJpYnNbaV07XG4gICAgICAgICAgICBpZiAoc3R5bGVzLmhhc093blByb3BlcnR5KHN0eWxlKSkge1xuICAgICAgICAgICAgICAgIHRoaXNbc3R5bGVdID0gc3R5bGVzW3N0eWxlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlzRGVmYXVsdCgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmZvcmVncm91bmQgPT09ICd3aGl0ZScgJiYgIXRoaXMudW5kZXJsaW5lICYmICF0aGlzLml0YWxpY3MgJiZcbiAgICAgICAgICAgICAgICB0aGlzLmJhY2tncm91bmQgPT09ICdibGFjaycgJiYgIXRoaXMuZmxhc2gpO1xuICAgIH1cblxuICAgIGVxdWFscyhvdGhlcikge1xuICAgICAgICByZXR1cm4gKCAodGhpcy5mb3JlZ3JvdW5kID09PSBvdGhlci5mb3JlZ3JvdW5kKSAmJlxuICAgICAgICAgICAgICAgICAodGhpcy51bmRlcmxpbmUgPT09IG90aGVyLnVuZGVybGluZSkgJiZcbiAgICAgICAgICAgICAgICAgKHRoaXMuaXRhbGljcyA9PT0gb3RoZXIuaXRhbGljcykgJiZcbiAgICAgICAgICAgICAgICAgKHRoaXMuYmFja2dyb3VuZCA9PT0gb3RoZXIuYmFja2dyb3VuZCkgJiZcbiAgICAgICAgICAgICAgICAgKHRoaXMuZmxhc2ggPT09IG90aGVyLmZsYXNoKSApO1xuICAgIH1cblxuICAgIGNvcHkobmV3UGVuU3RhdGUpIHtcbiAgICAgICAgdGhpcy5mb3JlZ3JvdW5kID0gbmV3UGVuU3RhdGUuZm9yZWdyb3VuZDtcbiAgICAgICAgdGhpcy51bmRlcmxpbmUgPSBuZXdQZW5TdGF0ZS51bmRlcmxpbmU7XG4gICAgICAgIHRoaXMuaXRhbGljcyA9IG5ld1BlblN0YXRlLml0YWxpY3M7XG4gICAgICAgIHRoaXMuYmFja2dyb3VuZCA9IG5ld1BlblN0YXRlLmJhY2tncm91bmQ7XG4gICAgICAgIHRoaXMuZmxhc2ggPSBuZXdQZW5TdGF0ZS5mbGFzaDtcbiAgICB9XG5cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuICgnY29sb3I9JyArIHRoaXMuZm9yZWdyb3VuZCArICcsIHVuZGVybGluZT0nICsgdGhpcy51bmRlcmxpbmUgKyAnLCBpdGFsaWNzPScgKyB0aGlzLml0YWxpY3MgK1xuICAgICAgICAgICAgJywgYmFja2dyb3VuZD0nICsgdGhpcy5iYWNrZ3JvdW5kICsgJywgZmxhc2g9JyArIHRoaXMuZmxhc2gpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBVbmljb2RlIGNoYXJhY3RlciB3aXRoIHN0eWxpbmcgYW5kIGJhY2tncm91bmQuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuY2xhc3MgU3R5bGVkVW5pY29kZUNoYXJcbntcblxuICAgIGNvbnN0cnVjdG9yKHVjaGFyLCBmb3JlZ3JvdW5kLCB1bmRlcmxpbmUsIGl0YWxpY3MsIGJhY2tncm91bmQsIGZsYXNoKSB7XG4gICAgICAgIHRoaXMudWNoYXIgPSB1Y2hhciB8fCAnICc7IC8vIHVuaWNvZGUgY2hhcmFjdGVyXG4gICAgICAgIHRoaXMucGVuU3RhdGUgPSBuZXcgUGVuU3RhdGUoZm9yZWdyb3VuZCwgdW5kZXJsaW5lLGl0YWxpY3MsIGJhY2tncm91bmQsIGZsYXNoKTtcbiAgICB9XG5cbiAgICByZXNldCgpIHtcbiAgICAgICAgdGhpcy51Y2hhciA9ICcgJztcbiAgICAgICAgdGhpcy5wZW5TdGF0ZS5yZXNldCgpO1xuICAgIH1cblxuICAgIHNldENoYXIodWNoYXIsIG5ld1BlblN0YXRlKSB7XG4gICAgICAgIHRoaXMudWNoYXIgPSB1Y2hhcjtcbiAgICAgICAgdGhpcy5wZW5TdGF0ZS5jb3B5KG5ld1BlblN0YXRlKTtcbiAgICB9XG5cbiAgICBzZXRQZW5TdGF0ZShuZXdQZW5TdGF0ZSkge1xuICAgICAgICB0aGlzLnBlblN0YXRlLmNvcHkobmV3UGVuU3RhdGUpO1xuICAgIH1cblxuICAgIGVxdWFscyhvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy51Y2hhciA9PT0gb3RoZXIudWNoYXIgJiYgdGhpcy5wZW5TdGF0ZS5lcXVhbHMob3RoZXIucGVuU3RhdGUpO1xuICAgIH1cblxuICAgIGNvcHkobmV3Q2hhcikge1xuICAgICAgICB0aGlzLnVjaGFyID0gbmV3Q2hhci51Y2hhcjtcbiAgICAgICAgdGhpcy5wZW5TdGF0ZS5jb3B5KG5ld0NoYXIucGVuU3RhdGUpO1xuICAgIH1cblxuICAgIGlzRW1wdHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnVjaGFyID09PSAnICcgJiYgdGhpcy5wZW5TdGF0ZS5pc0RlZmF1bHQoKTtcbiAgICB9XG59XG5cbi8qKlxuICogQ0VBLTYwOCByb3cgY29uc2lzdGluZyBvZiBOUl9DT0xTIGluc3RhbmNlcyBvZiBTdHlsZWRVbmljb2RlQ2hhci5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5jbGFzcyBSb3cge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmNoYXJzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwIDsgaSA8IE5SX0NPTFMgOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuY2hhcnMucHVzaChuZXcgU3R5bGVkVW5pY29kZUNoYXIoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICB0aGlzLmN1cnJQZW5TdGF0ZSA9IG5ldyBQZW5TdGF0ZSgpO1xuICAgIH1cblxuICAgIGVxdWFscyhvdGhlcikge1xuICAgICAgICB2YXIgZXF1YWwgPSB0cnVlO1xuICAgICAgICBmb3IgKHZhciBpID0gMCA7IGkgPCBOUl9DT0xTOyBpICsrKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuY2hhcnNbaV0uZXF1YWxzKG90aGVyLmNoYXJzW2ldKSkge1xuICAgICAgICAgICAgICAgIGVxdWFsID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVxdWFsO1xuICAgIH1cblxuICAgIGNvcHkob3RoZXIpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAgOyBpIDwgTlJfQ09MUzsgaSArKykge1xuICAgICAgICAgICAgdGhpcy5jaGFyc1tpXS5jb3B5KG90aGVyLmNoYXJzW2ldKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlzRW1wdHkoKSB7XG4gICAgICAgIHZhciBlbXB0eSA9IHRydWU7XG4gICAgICAgIGZvciAodmFyIGkgPSAwIDsgaSA8IE5SX0NPTFM7IGkgKyspIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5jaGFyc1tpXS5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgICAgICBlbXB0eSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbXB0eTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiAgU2V0IHRoZSBjdXJzb3IgdG8gYSB2YWxpZCBjb2x1bW4uXG4gICAgICovXG4gICAgc2V0Q3Vyc29yKGFic1Bvcykge1xuICAgICAgICBpZiAodGhpcy5wb3MgIT09IGFic1Bvcykge1xuICAgICAgICAgICAgdGhpcy5wb3MgPSBhYnNQb3M7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucG9zIDwgMCkge1xuICAgICAgICAgICAgbG9nZ2VyLmxvZygnRVJST1InLCAnTmVnYXRpdmUgY3Vyc29yIHBvc2l0aW9uICcgKyB0aGlzLnBvcyk7XG4gICAgICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5wb3MgPiBOUl9DT0xTKSB7XG4gICAgICAgICAgICBsb2dnZXIubG9nKCdFUlJPUicsICdUb28gbGFyZ2UgY3Vyc29yIHBvc2l0aW9uICcgKyB0aGlzLnBvcyk7XG4gICAgICAgICAgICB0aGlzLnBvcyA9IE5SX0NPTFM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNb3ZlIHRoZSBjdXJzb3IgcmVsYXRpdmUgdG8gY3VycmVudCBwb3NpdGlvbi5cbiAgICAgKi9cbiAgICBtb3ZlQ3Vyc29yKHJlbFBvcykge1xuICAgICAgICB2YXIgbmV3UG9zID0gdGhpcy5wb3MgKyByZWxQb3M7XG4gICAgICAgIGlmIChyZWxQb3MgPiAxKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5wb3MrMTsgaSA8IG5ld1BvcysxIDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGFyc1tpXS5zZXRQZW5TdGF0ZSh0aGlzLmN1cnJQZW5TdGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRDdXJzb3IobmV3UG9zKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBCYWNrc3BhY2UsIG1vdmUgb25lIHN0ZXAgYmFjayBhbmQgY2xlYXIgY2hhcmFjdGVyLlxuICAgICAqL1xuICAgIGJhY2tTcGFjZSgpIHtcbiAgICAgICAgdGhpcy5tb3ZlQ3Vyc29yKC0xKTtcbiAgICAgICAgdGhpcy5jaGFyc1t0aGlzLnBvc10uc2V0Q2hhcignICcsIHRoaXMuY3VyclBlblN0YXRlKTtcbiAgICB9XG5cbiAgICBpbnNlcnRDaGFyKGJ5dGUpIHtcbiAgICAgICAgaWYgKGJ5dGUgPj0gMHg5MCkgeyAvL0V4dGVuZGVkIGNoYXJcbiAgICAgICAgICAgIHRoaXMuYmFja1NwYWNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNoYXIgPSBnZXRDaGFyRm9yQnl0ZShieXRlKTtcbiAgICAgICAgaWYgKHRoaXMucG9zID49IE5SX0NPTFMpIHtcbiAgICAgICAgICAgIGxvZ2dlci5sb2coJ1dBUk5JTkcnLCAnQ2Fubm90IGluc2VydCAnICsgYnl0ZS50b1N0cmluZygxNikgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJyAoJyArIGNoYXIgKyAnKSBhdCBwb3NpdGlvbiAnICsgdGhpcy5wb3MgKyAnLiBTa2lwcGluZyBpdCEnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNoYXJzW3RoaXMucG9zXS5zZXRDaGFyKGNoYXIsIHRoaXMuY3VyclBlblN0YXRlKTtcbiAgICAgICAgdGhpcy5tb3ZlQ3Vyc29yKDEpO1xuICAgIH1cblxuICAgIGNsZWFyRnJvbVBvcyhzdGFydFBvcykge1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgZm9yIChpID0gc3RhcnRQb3MgOyBpIDwgTlJfQ09MUyA7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5jaGFyc1tpXS5yZXNldCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY2xlYXIoKSB7XG4gICAgICAgIHRoaXMuY2xlYXJGcm9tUG9zKDApO1xuICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgIHRoaXMuY3VyclBlblN0YXRlLnJlc2V0KCk7XG4gICAgfVxuXG4gICAgY2xlYXJUb0VuZE9mUm93KCkge1xuICAgICAgICB0aGlzLmNsZWFyRnJvbVBvcyh0aGlzLnBvcyk7XG4gICAgfVxuXG4gICAgZ2V0VGV4dFN0cmluZygpIHtcbiAgICAgICAgdmFyIGNoYXJzID0gW107XG4gICAgICAgIHZhciBlbXB0eSA9IHRydWU7XG4gICAgICAgIGZvciAodmFyIGkgPSAwIDsgaSA8IE5SX0NPTFMgOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjaGFyID0gdGhpcy5jaGFyc1tpXS51Y2hhcjtcbiAgICAgICAgICAgIGlmIChjaGFyICE9PSAnICcpIHtcbiAgICAgICAgICAgICAgICBlbXB0eSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hhcnMucHVzaChjaGFyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW1wdHkpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBjaGFycy5qb2luKCcnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNldFBlblN0eWxlcyhzdHlsZXMpIHtcbiAgICAgICAgdGhpcy5jdXJyUGVuU3RhdGUuc2V0U3R5bGVzKHN0eWxlcyk7XG4gICAgICAgIHZhciBjdXJyQ2hhciA9IHRoaXMuY2hhcnNbdGhpcy5wb3NdO1xuICAgICAgICBjdXJyQ2hhci5zZXRQZW5TdGF0ZSh0aGlzLmN1cnJQZW5TdGF0ZSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEtlZXAgYSBDRUEtNjA4IHNjcmVlbiBvZiAzMngxNSBzdHlsZWQgY2hhcmFjdGVyc1xuICogQGNvbnN0cnVjdG9yXG4qL1xuY2xhc3MgQ2FwdGlvblNjcmVlbiB7XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5yb3dzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwIDsgaSA8ICBOUl9ST1dTOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMucm93cy5wdXNoKG5ldyBSb3coKSk7IC8vIE5vdGUgdGhhdCB3ZSB1c2UgemVyby1iYXNlZCBudW1iZXJpbmcgKDAtMTQpXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jdXJyUm93ID0gTlJfUk9XUyAtIDE7XG4gICAgICAgIHRoaXMubnJSb2xsVXBSb3dzID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgIH1cblxuICAgIHJlc2V0KCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMCA7IGkgPCBOUl9ST1dTIDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLnJvd3NbaV0uY2xlYXIoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmN1cnJSb3cgPSBOUl9ST1dTIC0gMTtcbiAgICB9XG5cbiAgICBlcXVhbHMob3RoZXIpIHtcbiAgICAgICAgdmFyIGVxdWFsID0gdHJ1ZTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAgOyBpIDwgTlJfUk9XUyA7IGkrKykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnJvd3NbaV0uZXF1YWxzKG90aGVyLnJvd3NbaV0pKSB7XG4gICAgICAgICAgICAgICAgZXF1YWwgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXF1YWw7XG4gICAgfVxuXG4gICAgY29weShvdGhlcikge1xuICAgICAgICBmb3IgKHZhciBpID0gMCA7IGkgPCBOUl9ST1dTIDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLnJvd3NbaV0uY29weShvdGhlci5yb3dzW2ldKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlzRW1wdHkoKSB7XG4gICAgICAgIHZhciBlbXB0eSA9IHRydWU7XG4gICAgICAgIGZvciAodmFyIGkgPSAwIDsgaSA8IE5SX1JPV1MgOyBpKyspIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5yb3dzW2ldLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgICAgIGVtcHR5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVtcHR5O1xuICAgIH1cblxuICAgIGJhY2tTcGFjZSgpIHtcbiAgICAgICAgdmFyIHJvdyA9IHRoaXMucm93c1t0aGlzLmN1cnJSb3ddO1xuICAgICAgICByb3cuYmFja1NwYWNlKCk7XG4gICAgfVxuXG4gICAgY2xlYXJUb0VuZE9mUm93KCkge1xuICAgICAgICB2YXIgcm93ID0gdGhpcy5yb3dzW3RoaXMuY3VyclJvd107XG4gICAgICAgIHJvdy5jbGVhclRvRW5kT2ZSb3coKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnNlcnQgYSBjaGFyYWN0ZXIgKHdpdGhvdXQgc3R5bGluZykgaW4gdGhlIGN1cnJlbnQgcm93LlxuICAgICAqL1xuICAgIGluc2VydENoYXIoY2hhcikge1xuICAgICAgICB2YXIgcm93ID0gdGhpcy5yb3dzW3RoaXMuY3VyclJvd107XG4gICAgICAgIHJvdy5pbnNlcnRDaGFyKGNoYXIpO1xuICAgIH1cblxuICAgIHNldFBlbihzdHlsZXMpIHtcbiAgICAgICAgdmFyIHJvdyA9IHRoaXMucm93c1t0aGlzLmN1cnJSb3ddO1xuICAgICAgICByb3cuc2V0UGVuU3R5bGVzKHN0eWxlcyk7XG4gICAgfVxuXG4gICAgbW92ZUN1cnNvcihyZWxQb3MpIHtcbiAgICAgICAgdmFyIHJvdyA9IHRoaXMucm93c1t0aGlzLmN1cnJSb3ddO1xuICAgICAgICByb3cubW92ZUN1cnNvcihyZWxQb3MpO1xuICAgIH1cblxuICAgIHNldEN1cnNvcihhYnNQb3MpIHtcbiAgICAgICAgbG9nZ2VyLmxvZygnSU5GTycsICdzZXRDdXJzb3I6ICcgKyBhYnNQb3MpO1xuICAgICAgICB2YXIgcm93ID0gdGhpcy5yb3dzW3RoaXMuY3VyclJvd107XG4gICAgICAgIHJvdy5zZXRDdXJzb3IoYWJzUG9zKTtcbiAgICB9XG5cbiAgICBzZXRQQUMocGFjRGF0YSwgbGFzdE91dHB1dFNjcmVlbikge1xuICAgICAgICBsb2dnZXIubG9nKCdJTkZPJywgJ3BhY0RhdGEgPSAnICsgSlNPTi5zdHJpbmdpZnkocGFjRGF0YSkpO1xuICAgICAgICB2YXIgbmV3Um93ID0gcGFjRGF0YS5yb3cgLSAxO1xuICAgICAgICBpZiAodGhpcy5uclJvbGxVcFJvd3MgICYmIG5ld1JvdyA8IHRoaXMubnJSb2xsVXBSb3dzIC0gMSkge1xuICAgICAgICAgICAgICAgIG5ld1JvdyA9IHRoaXMubnJSb2xsVXBSb3dzLTE7XG4gICAgICAgIH1cblxuICAgICAgICAvL01ha2Ugc3VyZSB0aGlzIG9ubHkgYWZmZWN0cyBSb2xsLXVwIENhcHRpb25zIGJ5IGNoZWNraW5nIHRoaXMubnJSb2xsVXBSb3dzXG4gICAgICAgIGlmICh0aGlzLm5yUm9sbFVwUm93cyAmJiB0aGlzLmN1cnJSb3cgIT09IG5ld1Jvdykge1xuICAgICAgICAgIC8vY2xlYXIgYWxsIHJvd3MgZmlyc3RcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IE5SX1JPV1M7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5yb3dzW2ldLmNsZWFyKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy9Db3B5IHRoaXMubnJSb2xsVXBSb3dzIHJvd3MgZnJvbSBsYXN0T3V0cHV0U2NyZWVuIGFuZCBwbGFjZSBpdCBpbiB0aGUgbmV3Um93IGxvY2F0aW9uXG4gICAgICAgICAgLy90b3BSb3dJbmRleCAtIHRoZSBzdGFydCBvZiByb3dzIHRvIGNvcHkgKGluY2x1c2l2ZSBpbmRleClcbiAgICAgICAgICB2YXIgdG9wUm93SW5kZXggPSB0aGlzLmN1cnJSb3cgKyAxIC0gKHRoaXMubnJSb2xsVXBSb3dzKTtcbiAgICAgICAgICAvL1dlIG9ubHkgY29weSBpZiB0aGUgbGFzdCBwb3NpdGlvbiB3YXMgYWxyZWFkeSBzaG93bi5cbiAgICAgICAgICAvL1dlIHVzZSB0aGUgY3VlU3RhcnRUaW1lIHZhbHVlIHRvIGNoZWNrIHRoaXMuXG4gICAgICAgICAgdmFyIHByZXZMaW5lVGltZSA9IGxhc3RPdXRwdXRTY3JlZW4ucm93c1t0b3BSb3dJbmRleF0uY3VlU3RhcnRUaW1lO1xuICAgICAgICAgIGlmKHByZXZMaW5lVGltZSAmJiBwcmV2TGluZVRpbWUgPCBsb2dnZXIudGltZSkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm5yUm9sbFVwUm93czsgaSsrKSB7XG4gICAgICAgICAgICAgIHRoaXMucm93c1tuZXdSb3ctdGhpcy5uclJvbGxVcFJvd3MraSsxXS5jb3B5KGxhc3RPdXRwdXRTY3JlZW4ucm93c1t0b3BSb3dJbmRleCtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jdXJyUm93ID0gbmV3Um93O1xuICAgICAgICB2YXIgcm93ID0gdGhpcy5yb3dzW3RoaXMuY3VyclJvd107XG4gICAgICAgIGlmIChwYWNEYXRhLmluZGVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIGluZGVudCA9IHBhY0RhdGEuaW5kZW50O1xuICAgICAgICAgICAgdmFyIHByZXZQb3MgPSBNYXRoLm1heChpbmRlbnQtMSwgMCk7XG4gICAgICAgICAgICByb3cuc2V0Q3Vyc29yKHBhY0RhdGEuaW5kZW50KTtcbiAgICAgICAgICAgIHBhY0RhdGEuY29sb3IgPSByb3cuY2hhcnNbcHJldlBvc10ucGVuU3RhdGUuZm9yZWdyb3VuZDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3R5bGVzID0ge2ZvcmVncm91bmQgOiBwYWNEYXRhLmNvbG9yLCB1bmRlcmxpbmUgOiBwYWNEYXRhLnVuZGVybGluZSwgaXRhbGljcyA6IHBhY0RhdGEuaXRhbGljcywgYmFja2dyb3VuZCA6ICdibGFjaycsIGZsYXNoIDogZmFsc2V9O1xuICAgICAgICB0aGlzLnNldFBlbihzdHlsZXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCBiYWNrZ3JvdW5kL2V4dHJhIGZvcmVncm91bmQsIGJ1dCBmaXJzdCBkbyBiYWNrX3NwYWNlLCBhbmQgdGhlbiBpbnNlcnQgc3BhY2UgKGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5KS5cbiAgICAgKi9cbiAgICBzZXRCa2dEYXRhKGJrZ0RhdGEpIHtcblxuICAgICAgICBsb2dnZXIubG9nKCdJTkZPJywgJ2JrZ0RhdGEgPSAnICsgSlNPTi5zdHJpbmdpZnkoYmtnRGF0YSkpO1xuICAgICAgICB0aGlzLmJhY2tTcGFjZSgpO1xuICAgICAgICB0aGlzLnNldFBlbihia2dEYXRhKTtcbiAgICAgICAgdGhpcy5pbnNlcnRDaGFyKDB4MjApOyAvL1NwYWNlXG4gICAgfVxuXG4gICAgc2V0Um9sbFVwUm93cyhuclJvd3MpIHtcbiAgICAgICAgdGhpcy5uclJvbGxVcFJvd3MgPSBuclJvd3M7XG4gICAgfVxuXG4gICAgcm9sbFVwKCkge1xuICAgICAgICBpZiAodGhpcy5uclJvbGxVcFJvd3MgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGxvZ2dlci5sb2coJ0RFQlVHJywgJ3JvbGxfdXAgYnV0IG5yUm9sbFVwUm93cyBub3Qgc2V0IHlldCcpO1xuICAgICAgICAgICAgcmV0dXJuOyAvL05vdCBwcm9wZXJseSBzZXR1cFxuICAgICAgICB9XG4gICAgICAgIGxvZ2dlci5sb2coJ1RFWFQnLCB0aGlzLmdldERpc3BsYXlUZXh0KCkpO1xuICAgICAgICB2YXIgdG9wUm93SW5kZXggPSB0aGlzLmN1cnJSb3cgKyAxIC0gdGhpcy5uclJvbGxVcFJvd3M7XG4gICAgICAgIHZhciB0b3BSb3cgPSB0aGlzLnJvd3Muc3BsaWNlKHRvcFJvd0luZGV4LCAxKVswXTtcbiAgICAgICAgdG9wUm93LmNsZWFyKCk7XG4gICAgICAgIHRoaXMucm93cy5zcGxpY2UodGhpcy5jdXJyUm93LCAwLCB0b3BSb3cpO1xuICAgICAgICBsb2dnZXIubG9nKCdJTkZPJywgJ1JvbGxpbmcgdXAnKTtcbiAgICAgICAgLy9sb2dnZXIubG9nKCdURVhUJywgdGhpcy5nZXRfZGlzcGxheV90ZXh0KCkpXG4gICAgfVxuXG4gICAvKipcbiAgICAqIEdldCBhbGwgbm9uLWVtcHR5IHJvd3Mgd2l0aCBhcyB1bmljb2RlIHRleHQuXG4gICAgKi9cbiAgICBnZXREaXNwbGF5VGV4dChhc09uZVJvdykge1xuICAgICAgICBhc09uZVJvdyA9IGFzT25lUm93IHx8IGZhbHNlO1xuICAgICAgICB2YXIgZGlzcGxheVRleHQgPSBbXTtcbiAgICAgICAgdmFyIHRleHQgPSAnJztcbiAgICAgICAgdmFyIHJvd05yID0gLTE7XG4gICAgICAgIGZvciAodmFyIGkgPSAwIDsgaSA8IE5SX1JPV1MgOyBpKyspIHtcbiAgICAgICAgICAgIHZhciByb3dUZXh0ID0gdGhpcy5yb3dzW2ldLmdldFRleHRTdHJpbmcoKTtcbiAgICAgICAgICAgIGlmIChyb3dUZXh0KSB7XG4gICAgICAgICAgICAgICAgcm93TnIgPSBpKzE7XG4gICAgICAgICAgICAgICAgaWYgKGFzT25lUm93KSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXlUZXh0LnB1c2goJ1JvdyAnICsgcm93TnIgKyAnOiBcXCcnICsgcm93VGV4dCArICdcXCcnKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5VGV4dC5wdXNoKHJvd1RleHQudHJpbSgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRpc3BsYXlUZXh0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGlmIChhc09uZVJvdykge1xuICAgICAgICAgICAgICAgIHRleHQgPSAnWycgKyBkaXNwbGF5VGV4dC5qb2luKCcgfCAnKSArICddJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGV4dCA9IGRpc3BsYXlUZXh0LmpvaW4oJ1xcbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cblxuICAgIGdldFRleHRBbmRGb3JtYXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvd3M7XG4gICAgfVxufVxuXG4vL3ZhciBtb2RlcyA9IFsnTU9ERV9ST0xMLVVQJywgJ01PREVfUE9QLU9OJywgJ01PREVfUEFJTlQtT04nLCAnTU9ERV9URVhUJ107XG5cbmNsYXNzIENlYTYwOENoYW5uZWxcbntcbiAgICBjb25zdHJ1Y3RvcihjaGFubmVsTnVtYmVyLCBvdXRwdXRGaWx0ZXIpIHtcblxuICAgICAgICB0aGlzLmNoTnIgPSBjaGFubmVsTnVtYmVyO1xuICAgICAgICB0aGlzLm91dHB1dEZpbHRlciA9IG91dHB1dEZpbHRlcjtcbiAgICAgICAgdGhpcy5tb2RlID0gbnVsbDtcbiAgICAgICAgdGhpcy52ZXJib3NlID0gMDtcbiAgICAgICAgdGhpcy5kaXNwbGF5ZWRNZW1vcnkgPSBuZXcgQ2FwdGlvblNjcmVlbigpO1xuICAgICAgICB0aGlzLm5vbkRpc3BsYXllZE1lbW9yeSA9IG5ldyBDYXB0aW9uU2NyZWVuKCk7XG4gICAgICAgIHRoaXMubGFzdE91dHB1dFNjcmVlbiA9IG5ldyBDYXB0aW9uU2NyZWVuKCk7XG4gICAgICAgIHRoaXMuY3VyclJvbGxVcFJvdyA9IHRoaXMuZGlzcGxheWVkTWVtb3J5LnJvd3NbTlJfUk9XUy0xXTtcbiAgICAgICAgdGhpcy53cml0ZVNjcmVlbiA9IHRoaXMuZGlzcGxheWVkTWVtb3J5O1xuICAgICAgICB0aGlzLm1vZGUgPSBudWxsO1xuICAgICAgICB0aGlzLmN1ZVN0YXJ0VGltZSA9IG51bGw7IC8vIEtlZXBzIHRyYWNrIG9mIHdoZXJlIGEgY3VlIHN0YXJ0ZWQuXG4gICAgfVxuXG4gICAgcmVzZXQoKSB7XG4gICAgICAgIHRoaXMubW9kZSA9IG51bGw7XG4gICAgICAgIHRoaXMuZGlzcGxheWVkTWVtb3J5LnJlc2V0KCk7XG4gICAgICAgIHRoaXMubm9uRGlzcGxheWVkTWVtb3J5LnJlc2V0KCk7XG4gICAgICAgIHRoaXMubGFzdE91dHB1dFNjcmVlbi5yZXNldCgpO1xuICAgICAgICB0aGlzLmN1cnJSb2xsVXBSb3cgPSB0aGlzLmRpc3BsYXllZE1lbW9yeS5yb3dzW05SX1JPV1MtMV07XG4gICAgICAgIHRoaXMud3JpdGVTY3JlZW4gPSB0aGlzLmRpc3BsYXllZE1lbW9yeTtcbiAgICAgICAgdGhpcy5tb2RlID0gbnVsbDtcbiAgICAgICAgdGhpcy5jdWVTdGFydFRpbWUgPSBudWxsO1xuICAgICAgICB0aGlzLmxhc3RDdWVFbmRUaW1lID0gbnVsbDtcbiAgICB9XG5cbiAgICBnZXRIYW5kbGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vdXRwdXRGaWx0ZXI7XG4gICAgfVxuXG4gICAgc2V0SGFuZGxlcihuZXdIYW5kbGVyKSB7XG4gICAgICAgIHRoaXMub3V0cHV0RmlsdGVyID0gbmV3SGFuZGxlcjtcbiAgICB9XG5cbiAgICBzZXRQQUMocGFjRGF0YSkge1xuICAgICAgICB0aGlzLndyaXRlU2NyZWVuLnNldFBBQyhwYWNEYXRhLCB0aGlzLmxhc3RPdXRwdXRTY3JlZW4pO1xuICAgIH1cblxuICAgIHNldEJrZ0RhdGEoYmtnRGF0YSkge1xuICAgICAgICB0aGlzLndyaXRlU2NyZWVuLnNldEJrZ0RhdGEoYmtnRGF0YSk7XG4gICAgfVxuXG4gICAgc2V0TW9kZShuZXdNb2RlKSB7XG4gICAgICAgIGlmIChuZXdNb2RlID09PSB0aGlzLm1vZGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1vZGUgPSBuZXdNb2RlO1xuICAgICAgICBsb2dnZXIubG9nKCdJTkZPJywgJ01PREU9JyArIG5ld01vZGUpO1xuICAgICAgICBpZiAodGhpcy5tb2RlID09PSAnTU9ERV9QT1AtT04nKSB7XG4gICAgICAgICAgICB0aGlzLndyaXRlU2NyZWVuID0gdGhpcy5ub25EaXNwbGF5ZWRNZW1vcnk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLndyaXRlU2NyZWVuID0gdGhpcy5kaXNwbGF5ZWRNZW1vcnk7XG4gICAgICAgICAgICB0aGlzLndyaXRlU2NyZWVuLnJlc2V0KCk7XG4gICAgICAgICAgICB0aGlzLmxhc3RPdXRwdXRTY3JlZW4ucmVzZXQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5tb2RlICE9PSAnTU9ERV9ST0xMLVVQJykge1xuICAgICAgICAgICAgdGhpcy5kaXNwbGF5ZWRNZW1vcnkubnJSb2xsVXBSb3dzID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMubm9uRGlzcGxheWVkTWVtb3J5Lm5yUm9sbFVwUm93cyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tb2RlID0gbmV3TW9kZTtcbiAgICB9XG5cbiAgICBpbnNlcnRDaGFycyhjaGFycykge1xuICAgICAgICBmb3IgKHZhciBpID0gMCA7IGkgPCBjaGFycy5sZW5ndGggOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMud3JpdGVTY3JlZW4uaW5zZXJ0Q2hhcihjaGFyc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNjcmVlbiA9IHRoaXMud3JpdGVTY3JlZW4gPT09IHRoaXMuZGlzcGxheWVkTWVtb3J5ID8gJ0RJU1AnIDogJ05PTl9ESVNQJztcbiAgICAgICAgbG9nZ2VyLmxvZygnSU5GTycsIHNjcmVlbiArICc6ICcgKyB0aGlzLndyaXRlU2NyZWVuLmdldERpc3BsYXlUZXh0KHRydWUpKTtcbiAgICAgICAgaWYgKHRoaXMubW9kZSA9PT0gJ01PREVfUEFJTlQtT04nIHx8IHRoaXMubW9kZSA9PT0gJ01PREVfUk9MTC1VUCcpIHtcbiAgICAgICAgICAgIGxvZ2dlci5sb2coJ1RFWFQnLCAnRElTUExBWUVEOiAnICsgdGhpcy5kaXNwbGF5ZWRNZW1vcnkuZ2V0RGlzcGxheVRleHQodHJ1ZSkpO1xuICAgICAgICAgICAgdGhpcy5vdXRwdXREYXRhVXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjY1JDTCgpIHsgLy8gUmVzdW1lIENhcHRpb24gTG9hZGluZyAoc3dpdGNoIG1vZGUgdG8gUG9wIE9uKVxuICAgICAgICBsb2dnZXIubG9nKCdJTkZPJywgJ1JDTCAtIFJlc3VtZSBDYXB0aW9uIExvYWRpbmcnKTtcbiAgICAgICAgdGhpcy5zZXRNb2RlKCdNT0RFX1BPUC1PTicpO1xuICAgIH1cblxuICAgIGNjQlMoKSB7IC8vIEJhY2tTcGFjZVxuICAgICAgICBsb2dnZXIubG9nKCdJTkZPJywgJ0JTIC0gQmFja1NwYWNlJyk7XG4gICAgICAgIGlmICh0aGlzLm1vZGUgPT09ICdNT0RFX1RFWFQnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53cml0ZVNjcmVlbi5iYWNrU3BhY2UoKTtcbiAgICAgICAgaWYgKHRoaXMud3JpdGVTY3JlZW4gPT09IHRoaXMuZGlzcGxheWVkTWVtb3J5KSB7XG4gICAgICAgICAgICB0aGlzLm91dHB1dERhdGFVcGRhdGUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNjQU9GKCkgeyAvLyBSZXNlcnZlZCAoZm9ybWVybHkgQWxhcm0gT2ZmKVxuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY2NBT04oKSB7IC8vIFJlc2VydmVkIChmb3JtZXJseSBBbGFybSBPbilcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNjREVSKCkgeyAvLyBEZWxldGUgdG8gRW5kIG9mIFJvd1xuICAgICAgICBsb2dnZXIubG9nKCdJTkZPJywgJ0RFUi0gRGVsZXRlIHRvIEVuZCBvZiBSb3cnKTtcbiAgICAgICAgdGhpcy53cml0ZVNjcmVlbi5jbGVhclRvRW5kT2ZSb3coKTtcbiAgICAgICAgdGhpcy5vdXRwdXREYXRhVXBkYXRlKCk7XG4gICAgfVxuXG4gICAgY2NSVShuclJvd3MpIHsgLy9Sb2xsLVVwIENhcHRpb25zLTIsMyxvciA0IFJvd3NcbiAgICAgICAgbG9nZ2VyLmxvZygnSU5GTycsICdSVSgnICsgbnJSb3dzICsnKSAtIFJvbGwgVXAnKTtcbiAgICAgICAgdGhpcy53cml0ZVNjcmVlbiA9IHRoaXMuZGlzcGxheWVkTWVtb3J5O1xuICAgICAgICB0aGlzLnNldE1vZGUoJ01PREVfUk9MTC1VUCcpO1xuICAgICAgICB0aGlzLndyaXRlU2NyZWVuLnNldFJvbGxVcFJvd3MobnJSb3dzKTtcbiAgICB9XG5cbiAgICBjY0ZPTigpIHsgLy9GbGFzaCBPblxuICAgICAgICBsb2dnZXIubG9nKCdJTkZPJywgJ0ZPTiAtIEZsYXNoIE9uJyk7XG4gICAgICAgIHRoaXMud3JpdGVTY3JlZW4uc2V0UGVuKHtmbGFzaCA6IHRydWV9KTtcbiAgICB9XG5cbiAgICBjY1JEQygpIHsgLy8gUmVzdW1lIERpcmVjdCBDYXB0aW9uaW5nIChzd2l0Y2ggbW9kZSB0byBQYWludE9uKVxuICAgICAgICBsb2dnZXIubG9nKCdJTkZPJywgJ1JEQyAtIFJlc3VtZSBEaXJlY3QgQ2FwdGlvbmluZycpO1xuICAgICAgICB0aGlzLnNldE1vZGUoJ01PREVfUEFJTlQtT04nKTtcbiAgICB9XG5cbiAgICBjY1RSKCkgeyAvLyBUZXh0IFJlc3RhcnQgaW4gdGV4dCBtb2RlIChub3Qgc3VwcG9ydGVkLCBob3dldmVyKVxuICAgICAgICBsb2dnZXIubG9nKCdJTkZPJywgJ1RSJyk7XG4gICAgICAgIHRoaXMuc2V0TW9kZSgnTU9ERV9URVhUJyk7XG4gICAgfVxuXG4gICAgY2NSVEQoKSB7IC8vIFJlc3VtZSBUZXh0IERpc3BsYXkgaW4gVGV4dCBtb2RlIChub3Qgc3VwcG9ydGVkLCBob3dldmVyKVxuICAgICAgICBsb2dnZXIubG9nKCdJTkZPJywgJ1JURCcpO1xuICAgICAgICB0aGlzLnNldE1vZGUoJ01PREVfVEVYVCcpO1xuICAgIH1cblxuICAgIGNjRURNKCkgeyAvLyBFcmFzZSBEaXNwbGF5ZWQgTWVtb3J5XG4gICAgICAgIGxvZ2dlci5sb2coJ0lORk8nLCAnRURNIC0gRXJhc2UgRGlzcGxheWVkIE1lbW9yeScpO1xuICAgICAgICB0aGlzLmRpc3BsYXllZE1lbW9yeS5yZXNldCgpO1xuICAgICAgICB0aGlzLm91dHB1dERhdGFVcGRhdGUoKTtcbiAgICB9XG5cbiAgICBjY0NSKCkgeyAvLyBDYXJyaWFnZSBSZXR1cm5cbiAgICAgICAgbG9nZ2VyLmxvZygnQ1IgLSBDYXJyaWFnZSBSZXR1cm4nKTtcbiAgICAgICAgdGhpcy53cml0ZVNjcmVlbi5yb2xsVXAoKTtcbiAgICAgICAgdGhpcy5vdXRwdXREYXRhVXBkYXRlKCk7XG4gICAgfVxuXG4gICAgY2NFTk0oKSB7IC8vRXJhc2UgTm9uLURpc3BsYXllZCBNZW1vcnlcbiAgICAgICAgbG9nZ2VyLmxvZygnSU5GTycsICdFTk0gLSBFcmFzZSBOb24tZGlzcGxheWVkIE1lbW9yeScpO1xuICAgICAgICB0aGlzLm5vbkRpc3BsYXllZE1lbW9yeS5yZXNldCgpO1xuICAgIH1cblxuICAgIGNjRU9DKCkgeyAvL0VuZCBvZiBDYXB0aW9uIChGbGlwIE1lbW9yaWVzKVxuICAgICAgICBsb2dnZXIubG9nKCdJTkZPJywgJ0VPQyAtIEVuZCBPZiBDYXB0aW9uJyk7XG4gICAgICAgIGlmICh0aGlzLm1vZGUgPT09ICdNT0RFX1BPUC1PTicpIHtcbiAgICAgICAgICAgIHZhciB0bXAgPSB0aGlzLmRpc3BsYXllZE1lbW9yeTtcbiAgICAgICAgICAgIHRoaXMuZGlzcGxheWVkTWVtb3J5ID0gdGhpcy5ub25EaXNwbGF5ZWRNZW1vcnk7XG4gICAgICAgICAgICB0aGlzLm5vbkRpc3BsYXllZE1lbW9yeSA9IHRtcDtcbiAgICAgICAgICAgIHRoaXMud3JpdGVTY3JlZW4gPSB0aGlzLm5vbkRpc3BsYXllZE1lbW9yeTtcbiAgICAgICAgICAgIGxvZ2dlci5sb2coJ1RFWFQnLCAnRElTUDogJyArIHRoaXMuZGlzcGxheWVkTWVtb3J5LmdldERpc3BsYXlUZXh0KCkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3V0cHV0RGF0YVVwZGF0ZSgpO1xuICAgIH1cblxuICAgIGNjVE8obnJDb2xzKSB7IC8vIFRhYiBPZmZzZXQgMSwyLCBvciAzIGNvbHVtbnNcbiAgICAgICAgbG9nZ2VyLmxvZygnSU5GTycsICdUTygnICsgbnJDb2xzICsgJykgLSBUYWIgT2Zmc2V0Jyk7XG4gICAgICAgIHRoaXMud3JpdGVTY3JlZW4ubW92ZUN1cnNvcihuckNvbHMpO1xuICAgIH1cblxuICAgIGNjTUlEUk9XKHNlY29uZEJ5dGUpIHsgLy8gUGFyc2UgTUlEUk9XIGNvbW1hbmRcbiAgICAgICAgdmFyIHN0eWxlcyA9IHtmbGFzaCA6IGZhbHNlfTtcbiAgICAgICAgc3R5bGVzLnVuZGVybGluZSA9IHNlY29uZEJ5dGUgJSAyID09PSAxO1xuICAgICAgICBzdHlsZXMuaXRhbGljcyA9IHNlY29uZEJ5dGUgPj0gMHgyZTtcbiAgICAgICAgaWYgKCFzdHlsZXMuaXRhbGljcykge1xuICAgICAgICAgICAgdmFyIGNvbG9ySW5kZXggPSBNYXRoLmZsb29yKHNlY29uZEJ5dGUvMikgLSAweDEwO1xuICAgICAgICAgICAgdmFyIGNvbG9ycyA9IFsnd2hpdGUnLCAnZ3JlZW4nLCAnYmx1ZScsICdjeWFuJywgJ3JlZCcsICd5ZWxsb3cnLCAnbWFnZW50YSddO1xuICAgICAgICAgICAgc3R5bGVzLmZvcmVncm91bmQgPSBjb2xvcnNbY29sb3JJbmRleF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdHlsZXMuZm9yZWdyb3VuZCA9ICd3aGl0ZSc7XG4gICAgICAgIH1cbiAgICAgICAgbG9nZ2VyLmxvZygnSU5GTycsICdNSURST1c6ICcgKyBKU09OLnN0cmluZ2lmeShzdHlsZXMpKTtcbiAgICAgICAgdGhpcy53cml0ZVNjcmVlbi5zZXRQZW4oc3R5bGVzKTtcbiAgICB9XG5cbiAgICBvdXRwdXREYXRhVXBkYXRlKCkge1xuICAgICAgICB2YXIgdCA9IGxvZ2dlci50aW1lO1xuICAgICAgICBpZiAodCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm91dHB1dEZpbHRlcikge1xuICAgICAgICAgICAgaWYgKHRoaXMub3V0cHV0RmlsdGVyLnVwZGF0ZURhdGEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm91dHB1dEZpbHRlci51cGRhdGVEYXRhKHQsIHRoaXMuZGlzcGxheWVkTWVtb3J5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmN1ZVN0YXJ0VGltZSA9PT0gbnVsbCAmJiAhdGhpcy5kaXNwbGF5ZWRNZW1vcnkuaXNFbXB0eSgpKSB7IC8vIFN0YXJ0IG9mIGEgbmV3IGN1ZVxuICAgICAgICAgICAgICAgIHRoaXMuY3VlU3RhcnRUaW1lID0gdDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmRpc3BsYXllZE1lbW9yeS5lcXVhbHModGhpcy5sYXN0T3V0cHV0U2NyZWVuKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5vdXRwdXRGaWx0ZXIubmV3Q3VlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm91dHB1dEZpbHRlci5uZXdDdWUodGhpcy5jdWVTdGFydFRpbWUsIHQsIHRoaXMubGFzdE91dHB1dFNjcmVlbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdWVTdGFydFRpbWUgPSB0aGlzLmRpc3BsYXllZE1lbW9yeS5pc0VtcHR5KCkgPyBudWxsIDogdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmxhc3RPdXRwdXRTY3JlZW4uY29weSh0aGlzLmRpc3BsYXllZE1lbW9yeSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjdWVTcGxpdEF0VGltZSh0KSB7XG4gICAgICAgIGlmICh0aGlzLm91dHB1dEZpbHRlcikge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmRpc3BsYXllZE1lbW9yeS5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vdXRwdXRGaWx0ZXIubmV3Q3VlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3V0cHV0RmlsdGVyLm5ld0N1ZSh0aGlzLmN1ZVN0YXJ0VGltZSwgdCwgdGhpcy5kaXNwbGF5ZWRNZW1vcnkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmN1ZVN0YXJ0VGltZSA9IHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNsYXNzIENlYTYwOFBhcnNlciB7XG5cbiAgICBjb25zdHJ1Y3RvcihmaWVsZCwgb3V0MSwgb3V0Mikge1xuICAgICAgICB0aGlzLmZpZWxkID0gZmllbGQgfHwgMTtcbiAgICAgICAgdGhpcy5vdXRwdXRzID0gW291dDEsIG91dDJdO1xuICAgICAgICB0aGlzLmNoYW5uZWxzID0gW25ldyBDZWE2MDhDaGFubmVsKDEsIG91dDEpLCBuZXcgQ2VhNjA4Q2hhbm5lbCgyLCBvdXQyKV07XG4gICAgICAgIHRoaXMuY3VyckNoTnIgPSAtMTsgLy8gV2lsbCBiZSAxIG9yIDJcbiAgICAgICAgdGhpcy5sYXN0Q21kQSA9IG51bGw7IC8vIEZpcnN0IGJ5dGUgb2YgbGFzdCBjb21tYW5kXG4gICAgICAgIHRoaXMubGFzdENtZEIgPSBudWxsOyAvLyBTZWNvbmQgYnl0ZSBvZiBsYXN0IGNvbW1hbmRcbiAgICAgICAgdGhpcy5idWZmZXJlZERhdGEgPSBbXTtcbiAgICAgICAgdGhpcy5zdGFydFRpbWUgPSBudWxsO1xuICAgICAgICB0aGlzLmxhc3RUaW1lID0gbnVsbDtcbiAgICAgICAgdGhpcy5kYXRhQ291bnRlcnMgPSB7J3BhZGRpbmcnIDogMCwgJ2NoYXInIDogMCwgJ2NtZCcgOiAwLCAnb3RoZXInIDogMH07XG4gICAgfVxuXG4gICAgZ2V0SGFuZGxlcihpbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGFubmVsc1tpbmRleF0uZ2V0SGFuZGxlcigpO1xuICAgIH1cblxuICAgIHNldEhhbmRsZXIoaW5kZXgsIG5ld0hhbmRsZXIpIHtcbiAgICAgICAgdGhpcy5jaGFubmVsc1tpbmRleF0uc2V0SGFuZGxlcihuZXdIYW5kbGVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGQgZGF0YSBmb3IgdGltZSB0IGluIGZvcm1zIG9mIGxpc3Qgb2YgYnl0ZXMgKHVuc2lnbmVkIGludHMpLiBUaGUgYnl0ZXMgYXJlIHRyZWF0ZWQgYXMgcGFpcnMuXG4gICAgICovXG4gICAgYWRkRGF0YSh0LCBieXRlTGlzdCkge1xuICAgICAgICB2YXIgY21kRm91bmQsIGEsIGIsXG4gICAgICAgIGNoYXJzRm91bmQgPSBmYWxzZTtcblxuICAgICAgICB0aGlzLmxhc3RUaW1lID0gdDtcbiAgICAgICAgbG9nZ2VyLnNldFRpbWUodCk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAgOyBpIDwgYnl0ZUxpc3QubGVuZ3RoIDsgaSs9Mikge1xuICAgICAgICAgICAgYSA9IGJ5dGVMaXN0W2ldICYgMHg3ZjtcbiAgICAgICAgICAgIGIgPSBieXRlTGlzdFtpKzFdICYgMHg3ZjtcbiAgICAgICAgICAgIGlmIChhID09PSAwICYmIGIgPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGFDb3VudGVycy5wYWRkaW5nICs9IDI7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxvZ2dlci5sb2coJ0RBVEEnLCAnWycgKyBudW1BcnJheVRvSGV4QXJyYXkoW2J5dGVMaXN0W2ldLCBieXRlTGlzdFtpKzFdXSkgKyddIC0+ICgnICsgbnVtQXJyYXlUb0hleEFycmF5KFthLCBiXSkgKyAnKScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY21kRm91bmQgPSB0aGlzLnBhcnNlQ21kKGEsIGIpO1xuICAgICAgICAgICAgaWYgKCFjbWRGb3VuZCkge1xuICAgICAgICAgICAgICAgIGNtZEZvdW5kID0gdGhpcy5wYXJzZU1pZHJvdyhhLCBiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghY21kRm91bmQpIHtcbiAgICAgICAgICAgICAgICBjbWRGb3VuZCA9IHRoaXMucGFyc2VQQUMoYSwgYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWNtZEZvdW5kKSB7XG4gICAgICAgICAgICAgICAgY21kRm91bmQgPSB0aGlzLnBhcnNlQmFja2dyb3VuZEF0dHJpYnV0ZXMoYSwgYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWNtZEZvdW5kKSB7XG4gICAgICAgICAgICAgICAgY2hhcnNGb3VuZCA9IHRoaXMucGFyc2VDaGFycyhhLCBiKTtcbiAgICAgICAgICAgICAgICBpZiAoY2hhcnNGb3VuZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jdXJyQ2hOciAmJiB0aGlzLmN1cnJDaE5yID49MCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNoYW5uZWwgPSB0aGlzLmNoYW5uZWxzW3RoaXMuY3VyckNoTnItMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFubmVsLmluc2VydENoYXJzKGNoYXJzRm91bmQpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmxvZygnV0FSTklORycsICdObyBjaGFubmVsIGZvdW5kIHlldC4gVEVYVC1NT0RFPycpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNtZEZvdW5kKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhQ291bnRlcnMuY21kICs9IDI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNoYXJzRm91bmQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGFDb3VudGVycy5jaGFyICs9IDI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZGF0YUNvdW50ZXJzLm90aGVyICs9IDI7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmxvZygnV0FSTklORycsICdDb3VsZG5cXCd0IHBhcnNlIGNsZWFuZWQgZGF0YSAnICsgbnVtQXJyYXlUb0hleEFycmF5KFthLCBiXSkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICcgb3JpZzogJyArIG51bUFycmF5VG9IZXhBcnJheShbYnl0ZUxpc3RbaV0sIGJ5dGVMaXN0W2krMV1dKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXJzZSBDb21tYW5kLlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSBUZWxscyBpZiBhIGNvbW1hbmQgd2FzIGZvdW5kXG4gICAgICovXG4gICAgcGFyc2VDbWQoYSwgYikge1xuICAgICAgICB2YXIgY2hOciA9IG51bGw7XG5cbiAgICAgICAgdmFyIGNvbmQxID0gKGEgPT09IDB4MTQgfHwgYSA9PT0gMHgxQykgJiYgKDB4MjAgPD0gYiAmJiBiIDw9IDB4MkYpO1xuICAgICAgICB2YXIgY29uZDIgPSAoYSA9PT0gMHgxNyB8fCBhID09PSAweDFGKSAmJiAoMHgyMSA8PSBiICYmIGIgPD0gMHgyMyk7XG4gICAgICAgIGlmICghKGNvbmQxIHx8IGNvbmQyKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGEgPT09IHRoaXMubGFzdENtZEEgJiYgYiA9PT0gdGhpcy5sYXN0Q21kQikge1xuICAgICAgICAgICAgdGhpcy5sYXN0Q21kQSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmxhc3RDbWRCID0gbnVsbDsgLy8gUmVwZWF0ZWQgY29tbWFuZHMgYXJlIGRyb3BwZWQgKG9uY2UpXG4gICAgICAgICAgICBsb2dnZXIubG9nKCdERUJVRycsICdSZXBlYXRlZCBjb21tYW5kICgnICsgbnVtQXJyYXlUb0hleEFycmF5KFthLCBiXSkgKyAnKSBpcyBkcm9wcGVkJyk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhID09PSAweDE0IHx8IGEgPT09IDB4MTcpIHtcbiAgICAgICAgICAgIGNoTnIgPSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2hOciA9IDI7IC8vIChhID09PSAweDFDIHx8IGE9PT0gMHgxZilcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjaGFubmVsID0gdGhpcy5jaGFubmVsc1tjaE5yIC0gMV07XG5cbiAgICAgICAgaWYgKGEgPT09IDB4MTQgfHwgYSA9PT0gMHgxQykge1xuICAgICAgICAgICAgaWYgKGIgPT09IDB4MjApIHtcbiAgICAgICAgICAgICAgICBjaGFubmVsLmNjUkNMKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGIgPT09IDB4MjEpIHtcbiAgICAgICAgICAgICAgICBjaGFubmVsLmNjQlMoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyMikge1xuICAgICAgICAgICAgICAgIGNoYW5uZWwuY2NBT0YoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyMykge1xuICAgICAgICAgICAgICAgIGNoYW5uZWwuY2NBT04oKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyNCkge1xuICAgICAgICAgICAgICAgIGNoYW5uZWwuY2NERVIoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyNSkge1xuICAgICAgICAgICAgICAgIGNoYW5uZWwuY2NSVSgyKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyNikge1xuICAgICAgICAgICAgICAgIGNoYW5uZWwuY2NSVSgzKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyNykge1xuICAgICAgICAgICAgICAgIGNoYW5uZWwuY2NSVSg0KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyOCkge1xuICAgICAgICAgICAgICAgIGNoYW5uZWwuY2NGT04oKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyOSkge1xuICAgICAgICAgICAgICAgIGNoYW5uZWwuY2NSREMoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyQSkge1xuICAgICAgICAgICAgICAgIGNoYW5uZWwuY2NUUigpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChiID09PSAweDJCKSB7XG4gICAgICAgICAgICAgICAgY2hhbm5lbC5jY1JURCgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChiID09PSAweDJDKSB7XG4gICAgICAgICAgICAgICAgY2hhbm5lbC5jY0VETSgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChiID09PSAweDJEKSB7XG4gICAgICAgICAgICAgICAgY2hhbm5lbC5jY0NSKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGIgPT09IDB4MkUpIHtcbiAgICAgICAgICAgICAgICBjaGFubmVsLmNjRU5NKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGIgPT09IDB4MkYpIHtcbiAgICAgICAgICAgICAgICBjaGFubmVsLmNjRU9DKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7IC8vYSA9PSAweDE3IHx8IGEgPT0gMHgxRlxuICAgICAgICAgICAgY2hhbm5lbC5jY1RPKGIgLSAweDIwKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxhc3RDbWRBID0gYTtcbiAgICAgICAgdGhpcy5sYXN0Q21kQiA9IGI7XG4gICAgICAgIHRoaXMuY3VyckNoTnIgPSBjaE5yO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXJzZSBtaWRyb3cgc3R5bGluZyBjb21tYW5kXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgcGFyc2VNaWRyb3coYSwgYikge1xuICAgICAgICB2YXIgY2hOciA9IG51bGw7XG5cbiAgICAgICAgaWYgKCAoKGEgPT09IDB4MTEpIHx8IChhID09PSAweDE5KSkgJiYgMHgyMCA8PSBiICYmIGIgPD0gMHgyZikge1xuICAgICAgICAgICAgaWYgKGEgPT09IDB4MTEpIHtcbiAgICAgICAgICAgICAgICBjaE5yID0gMTtcbiAgICAgICAgICAgIH0gZWxzZSAge1xuICAgICAgICAgICAgICAgIGNoTnIgPSAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNoTnIgIT09IHRoaXMuY3VyckNoTnIpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIubG9nKCdFUlJPUicsICdNaXNtYXRjaCBjaGFubmVsIGluIG1pZHJvdyBwYXJzaW5nJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGNoYW5uZWwgPSB0aGlzLmNoYW5uZWxzW2NoTnItMV07XG4gICAgICAgICAgICBjaGFubmVsLmNjTUlEUk9XKGIpO1xuICAgICAgICAgICAgbG9nZ2VyLmxvZygnREVCVUcnLCAnTUlEUk9XICgnICsgbnVtQXJyYXlUb0hleEFycmF5KFthLCBiXSkgKyAnKScpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXJzZSBQcmVhYmxlIEFjY2VzcyBDb2RlcyAoVGFibGUgNTMpLlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSBUZWxscyBpZiBQQUMgZm91bmRcbiAgICAgKi9cbiAgICBwYXJzZVBBQyhhLCBiKSB7XG5cbiAgICAgICB2YXIgY2hOciA9IG51bGw7XG4gICAgICAgdmFyIHJvdyA9IG51bGw7XG5cbiAgICAgICAgdmFyIGNhc2UxID0gKCgweDExIDw9IGEgICYmIGEgPD0gMHgxNykgfHwgKDB4MTkgPD0gYSAmJiBhIDw9IDB4MUYpKSAmJiAoMHg0MCA8PSBiICYmIGIgPD0gMHg3Rik7XG4gICAgICAgIHZhciBjYXNlMiA9IChhID09PSAweDEwIHx8IGEgPT09IDB4MTgpICYmICgweDQwIDw9IGIgJiYgYiA8PSAweDVGKTtcbiAgICAgICAgaWYgKCEgKGNhc2UxIHx8IGNhc2UyKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGEgPT09IHRoaXMubGFzdENtZEEgJiYgYiA9PT0gdGhpcy5sYXN0Q21kQikge1xuICAgICAgICAgICAgdGhpcy5sYXN0Q21kQSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmxhc3RDbWRCID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiB0cnVlOyAvLyBSZXBlYXRlZCBjb21tYW5kcyBhcmUgZHJvcHBlZCAob25jZSlcbiAgICAgICAgfVxuXG4gICAgICAgIGNoTnIgPSAoYSA8PSAweDE3KSA/IDEgOiAyO1xuXG4gICAgICAgIGlmICgweDQwIDw9IGIgJiYgYiA8PSAweDVGKSB7XG4gICAgICAgICAgICByb3cgPSAoY2hOciA9PT0gMSkgPyByb3dzTG93Q2gxW2FdIDogcm93c0xvd0NoMlthXTtcbiAgICAgICAgfSBlbHNlIHsgLy8gMHg2MCA8PSBiIDw9IDB4N0ZcbiAgICAgICAgICAgIHJvdyA9IChjaE5yID09PSAxKSA/IHJvd3NIaWdoQ2gxW2FdIDogcm93c0hpZ2hDaDJbYV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBhY0RhdGEgPSB0aGlzLmludGVycHJldFBBQyhyb3csIGIpO1xuICAgICAgICB2YXIgY2hhbm5lbCA9IHRoaXMuY2hhbm5lbHNbY2hOci0xXTtcbiAgICAgICAgY2hhbm5lbC5zZXRQQUMocGFjRGF0YSk7XG4gICAgICAgIHRoaXMubGFzdENtZEEgPSBhO1xuICAgICAgICB0aGlzLmxhc3RDbWRCID0gYjtcbiAgICAgICAgdGhpcy5jdXJyQ2hOciA9IGNoTnI7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEludGVycHJldCB0aGUgc2Vjb25kIGJ5dGUgb2YgdGhlIHBhYywgYW5kIHJldHVybiB0aGUgaW5mb3JtYXRpb24uXG4gICAgICogQHJldHVybnMge09iamVjdH0gcGFjRGF0YSB3aXRoIHN0eWxlIHBhcmFtZXRlcnMuXG4gICAgICovXG4gICAgaW50ZXJwcmV0UEFDKHJvdywgYnl0ZSkge1xuICAgICAgICB2YXIgcGFjSW5kZXggPSBieXRlO1xuICAgICAgICB2YXIgcGFjRGF0YSA9IHtjb2xvciA6IG51bGwsIGl0YWxpY3MgOiBmYWxzZSwgaW5kZW50IDogbnVsbCwgdW5kZXJsaW5lIDogZmFsc2UsIHJvdyA6IHJvd307XG5cbiAgICAgICAgaWYgKGJ5dGUgPiAweDVGKSB7XG4gICAgICAgICAgICBwYWNJbmRleCA9IGJ5dGUgLSAweDYwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFjSW5kZXggPSBieXRlIC0gMHg0MDtcbiAgICAgICAgfVxuICAgICAgICBwYWNEYXRhLnVuZGVybGluZSA9IChwYWNJbmRleCAmIDEpID09PSAxO1xuICAgICAgICBpZiAocGFjSW5kZXggPD0gMHhkKSB7XG4gICAgICAgICAgICBwYWNEYXRhLmNvbG9yID0gWyd3aGl0ZScsICdncmVlbicsICdibHVlJywgJ2N5YW4nLCAncmVkJywgJ3llbGxvdycsICdtYWdlbnRhJywgJ3doaXRlJ11bTWF0aC5mbG9vcihwYWNJbmRleC8yKV07XG4gICAgICAgIH0gZWxzZSBpZiAocGFjSW5kZXggPD0gMHhmKSB7XG4gICAgICAgICAgICBwYWNEYXRhLml0YWxpY3MgPSB0cnVlO1xuICAgICAgICAgICAgcGFjRGF0YS5jb2xvciA9ICd3aGl0ZSc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYWNEYXRhLmluZGVudCA9IChNYXRoLmZsb29yKChwYWNJbmRleC0weDEwKS8yKSkqNDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFjRGF0YTsgLy8gTm90ZSB0aGF0IHJvdyBoYXMgemVybyBvZmZzZXQuIFRoZSBzcGVjIHVzZXMgMS5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXJzZSBjaGFyYWN0ZXJzLlxuICAgICAqIEByZXR1cm5zIEFuIGFycmF5IHdpdGggMSB0byAyIGNvZGVzIGNvcnJlc3BvbmRpbmcgdG8gY2hhcnMsIGlmIGZvdW5kLiBudWxsIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBwYXJzZUNoYXJzKGEsIGIpIHtcblxuICAgICAgIHZhciAgY2hhbm5lbE5yID0gbnVsbCxcbiAgICAgICAgICAgIGNoYXJDb2RlcyA9IG51bGwsXG4gICAgICAgICAgICBjaGFyQ29kZTEgPSBudWxsO1xuXG4gICAgICAgIGlmIChhID49IDB4MTkpIHtcbiAgICAgICAgICAgIGNoYW5uZWxOciA9IDI7XG4gICAgICAgICAgICBjaGFyQ29kZTEgPSBhIC0gODtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNoYW5uZWxOciA9IDE7XG4gICAgICAgICAgICBjaGFyQ29kZTEgPSBhO1xuICAgICAgICB9XG4gICAgICAgIGlmICgweDExIDw9IGNoYXJDb2RlMSAmJiBjaGFyQ29kZTEgPD0gMHgxMykge1xuICAgICAgICAgICAgLy8gU3BlY2lhbCBjaGFyYWN0ZXJcbiAgICAgICAgICAgIHZhciBvbmVDb2RlID0gYjtcbiAgICAgICAgICAgIGlmIChjaGFyQ29kZTEgPT09IDB4MTEpIHtcbiAgICAgICAgICAgICAgICBvbmVDb2RlID0gYiArIDB4NTA7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNoYXJDb2RlMSA9PT0gMHgxMikge1xuICAgICAgICAgICAgICAgIG9uZUNvZGUgPSBiICsgMHg3MDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb25lQ29kZSA9IGIgKyAweDkwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9nZ2VyLmxvZygnSU5GTycsICdTcGVjaWFsIGNoYXIgXFwnJyArIGdldENoYXJGb3JCeXRlKG9uZUNvZGUpICsgJ1xcJyBpbiBjaGFubmVsICcgKyBjaGFubmVsTnIpO1xuICAgICAgICAgICAgY2hhckNvZGVzID0gW29uZUNvZGVdO1xuICAgICAgICB9IGVsc2UgaWYgKDB4MjAgPD0gYSAmJiBhIDw9IDB4N2YpIHtcbiAgICAgICAgICAgIGNoYXJDb2RlcyA9IChiID09PSAwKSA/IFthXSA6IFthLCBiXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhckNvZGVzKSB7XG4gICAgICAgICAgICB2YXIgaGV4Q29kZXMgPSBudW1BcnJheVRvSGV4QXJyYXkoY2hhckNvZGVzKTtcbiAgICAgICAgICAgIGxvZ2dlci5sb2coJ0RFQlVHJywgJ0NoYXIgY29kZXMgPSAgJyArIGhleENvZGVzLmpvaW4oJywnKSk7XG4gICAgICAgICAgICB0aGlzLmxhc3RDbWRBID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMubGFzdENtZEIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaGFyQ29kZXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiBQYXJzZSBleHRlbmRlZCBiYWNrZ3JvdW5kIGF0dHJpYnV0ZXMgYXMgd2VsbCBhcyBuZXcgZm9yZWdyb3VuZCBjb2xvciBibGFjay5cbiAgICAqIEByZXR1cm5ze0Jvb2xlYW59IFRlbGxzIGlmIGJhY2tncm91bmQgYXR0cmlidXRlcyBhcmUgZm91bmRcbiAgICAqL1xuICAgIHBhcnNlQmFja2dyb3VuZEF0dHJpYnV0ZXMoYSwgYikge1xuICAgICAgIHZhciAgYmtnRGF0YSxcbiAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgY2hOcixcbiAgICAgICAgICAgIGNoYW5uZWw7XG5cbiAgICAgICAgdmFyIGNhc2UxID0gKGEgPT09IDB4MTAgfHwgYSA9PT0gMHgxOCkgJiYgKDB4MjAgPD0gYiAmJiBiIDw9IDB4MmYpO1xuICAgICAgICB2YXIgY2FzZTIgPSAoYSA9PT0gMHgxNyB8fCBhID09PSAweDFmKSAmJiAoMHgyZCA8PWIgJiYgYiA8PSAweDJmKTtcbiAgICAgICAgaWYgKCEoY2FzZTEgfHwgY2FzZTIpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgYmtnRGF0YSA9IHt9O1xuICAgICAgICBpZiAoYSAgPT09IDB4MTAgfHwgYSA9PT0gMHgxOCkge1xuICAgICAgICAgICAgaW5kZXggPSBNYXRoLmZsb29yKChiLTB4MjApLzIpO1xuICAgICAgICAgICAgYmtnRGF0YS5iYWNrZ3JvdW5kID0gYmFja2dyb3VuZENvbG9yc1tpbmRleF07XG4gICAgICAgICAgICBpZiAoYiAlIDIgPT09IDEpIHtcbiAgICAgICAgICAgICAgICBia2dEYXRhLmJhY2tncm91bmQgPSBia2dEYXRhLmJhY2tncm91bmQgKyAnX3NlbWknO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGIgPT09IDB4MmQpIHtcbiAgICAgICAgICAgIGJrZ0RhdGEuYmFja2dyb3VuZCA9ICd0cmFuc3BhcmVudCc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBia2dEYXRhLmZvcmVncm91bmQgPSAnYmxhY2snO1xuICAgICAgICAgICAgaWYgKGIgPT09IDB4MmYpIHtcbiAgICAgICAgICAgICAgICBia2dEYXRhLnVuZGVybGluZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2hOciA9IChhIDwgMHgxOCkgPyAxIDogMjtcbiAgICAgICAgY2hhbm5lbCA9IHRoaXMuY2hhbm5lbHNbY2hOci0xXTtcbiAgICAgICAgY2hhbm5lbC5zZXRCa2dEYXRhKGJrZ0RhdGEpO1xuICAgICAgICB0aGlzLmxhc3RDbWRBID0gbnVsbDtcbiAgICAgICAgdGhpcy5sYXN0Q21kQiA9IG51bGw7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlc2V0IHN0YXRlIG9mIHBhcnNlciBhbmQgaXRzIGNoYW5uZWxzLlxuICAgICAqL1xuICAgIHJlc2V0KCkge1xuICAgICAgICBmb3IgKHZhciBpPTAgOyBpIDwgdGhpcy5jaGFubmVscy5sZW5ndGggOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNoYW5uZWxzW2ldKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGFubmVsc1tpXS5yZXNldCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMubGFzdENtZEEgPSBudWxsO1xuICAgICAgICB0aGlzLmxhc3RDbWRCID0gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyIHRoZSBnZW5lcmF0aW9uIG9mIGEgY3VlLCBhbmQgdGhlIHN0YXJ0IG9mIGEgbmV3IG9uZSBpZiBkaXNwbGF5U2NyZWVucyBhcmUgbm90IGVtcHR5LlxuICAgICAqL1xuICAgIGN1ZVNwbGl0QXRUaW1lKHQpIHtcbiAgICAgICAgZm9yICh2YXIgaT0wIDsgaSA8IHRoaXMuY2hhbm5lbHMubGVuZ3RoIDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jaGFubmVsc1tpXSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2hhbm5lbHNbaV0uY3VlU3BsaXRBdFRpbWUodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IENlYTYwOFBhcnNlcjtcbiIsImltcG9ydCB7IGZpeExpbmVCcmVha3MgfSBmcm9tICcuL3Z0dHBhcnNlcic7XG5cbmNvbnN0IEN1ZXMgPSB7XG5cbiAgbmV3Q3VlOiBmdW5jdGlvbih0cmFjaywgc3RhcnRUaW1lLCBlbmRUaW1lLCBjYXB0aW9uU2NyZWVuKSB7XG4gICAgdmFyIHJvdztcbiAgICB2YXIgY3VlO1xuICAgIHZhciBpbmRlbnRpbmc7XG4gICAgdmFyIGluZGVudDtcbiAgICB2YXIgdGV4dDtcbiAgICB2YXIgVlRUQ3VlID0gd2luZG93LlZUVEN1ZSB8fCB3aW5kb3cuVGV4dFRyYWNrQ3VlO1xuXG4gICAgZm9yICh2YXIgcj0wOyByPGNhcHRpb25TY3JlZW4ucm93cy5sZW5ndGg7IHIrKylcbiAgICB7XG4gICAgICByb3cgPSBjYXB0aW9uU2NyZWVuLnJvd3Nbcl07XG4gICAgICBpbmRlbnRpbmcgPSB0cnVlO1xuICAgICAgaW5kZW50ID0gMDtcbiAgICAgIHRleHQgPSAnJztcblxuICAgICAgaWYgKCFyb3cuaXNFbXB0eSgpKVxuICAgICAge1xuICAgICAgICBmb3IgKHZhciBjPTA7IGM8cm93LmNoYXJzLmxlbmd0aDsgYysrKVxuICAgICAgICB7XG4gICAgICAgICAgaWYgKHJvdy5jaGFyc1tjXS51Y2hhci5tYXRjaCgvXFxzLykgJiYgaW5kZW50aW5nKVxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGluZGVudCsrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlXG4gICAgICAgICAge1xuICAgICAgICAgICAgdGV4dCArPSByb3cuY2hhcnNbY10udWNoYXI7XG4gICAgICAgICAgICBpbmRlbnRpbmcgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy9UbyBiZSB1c2VkIGZvciBjbGVhbmluZy11cCBvcnBoYW5lZCByb2xsLXVwIGNhcHRpb25zXG4gICAgICAgIHJvdy5jdWVTdGFydFRpbWUgPSBzdGFydFRpbWU7XG4gICAgICAgIGN1ZSA9IG5ldyBWVFRDdWUoc3RhcnRUaW1lLCBlbmRUaW1lLCBmaXhMaW5lQnJlYWtzKHRleHQudHJpbSgpKSk7XG5cbiAgICAgICAgaWYgKGluZGVudCA+PSAxNilcbiAgICAgICAge1xuICAgICAgICAgIGluZGVudC0tO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgIGluZGVudCsrO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVlRUQ3VlLmxpbmUgZ2V0J3MgZmxha2V5IHdoZW4gdXNpbmcgY29udHJvbHMsIHNvIGxldCdzIG5vdyBpbmNsdWRlIGxpbmUgMTMmMTRcbiAgICAgICAgLy8gYWxzbywgZHJvcCBsaW5lIDEgc2luY2UgaXQncyB0byBjbG9zZSB0byB0aGUgdG9wXG4gICAgICAgIGlmIChuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9GaXJlZm94XFwvLykpXG4gICAgICAgIHtcbiAgICAgICAgICBjdWUubGluZSA9IHIgKyAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgIGN1ZS5saW5lID0gKHIgPiA3ID8gciAtIDIgOiByICsgMSk7XG4gICAgICAgIH1cbiAgICAgICAgY3VlLmFsaWduID0gJ2xlZnQnO1xuICAgICAgICAvLyBDbGFtcCB0aGUgcG9zaXRpb24gYmV0d2VlbiAwIGFuZCAxMDAgLSBpZiBvdXQgb2YgdGhlc2UgYm91bmRzLCBGaXJlZm94IHRocm93cyBhbiBleGNlcHRpb24gYW5kIGNhcHRpb25zIGJyZWFrXG4gICAgICAgIGN1ZS5wb3NpdGlvbiA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEwMCwgMTAwICogKGluZGVudCAvIDMyKSArIChuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9GaXJlZm94XFwvLykgPyA1MCA6IDApKSk7XG4gICAgICAgIHRyYWNrLmFkZEN1ZShjdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEN1ZXM7XG4iLCIvKlxuICogY29tcHV0ZSBhbiBFeHBvbmVudGlhbCBXZWlnaHRlZCBtb3ZpbmcgYXZlcmFnZVxuICogLSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Nb3ZpbmdfYXZlcmFnZSNFeHBvbmVudGlhbF9tb3ZpbmdfYXZlcmFnZVxuICogIC0gaGVhdmlseSBpbnNwaXJlZCBmcm9tIHNoYWthLXBsYXllclxuICovXG5cbmNsYXNzIEVXTUEge1xuXG4gLy8gIEFib3V0IGhhbGYgb2YgdGhlIGVzdGltYXRlZCB2YWx1ZSB3aWxsIGJlIGZyb20gdGhlIGxhc3QgfGhhbGZMaWZlfCBzYW1wbGVzIGJ5IHdlaWdodC5cbiAgY29uc3RydWN0b3IoaGFsZkxpZmUpIHtcbiAgICAvLyBMYXJnZXIgdmFsdWVzIG9mIGFscGhhIGV4cGlyZSBoaXN0b3JpY2FsIGRhdGEgbW9yZSBzbG93bHkuXG4gICAgdGhpcy5hbHBoYV8gPSBoYWxmTGlmZSA/IE1hdGguZXhwKE1hdGgubG9nKDAuNSkgLyBoYWxmTGlmZSkgOiAwO1xuICAgIHRoaXMuZXN0aW1hdGVfID0gMDtcbiAgICB0aGlzLnRvdGFsV2VpZ2h0XyA9IDA7XG4gIH1cblxuICBzYW1wbGUod2VpZ2h0LHZhbHVlKSB7XG4gICAgdmFyIGFkakFscGhhID0gTWF0aC5wb3codGhpcy5hbHBoYV8sIHdlaWdodCk7XG4gICAgdGhpcy5lc3RpbWF0ZV8gPSB2YWx1ZSAqICgxIC0gYWRqQWxwaGEpICsgYWRqQWxwaGEgKiB0aGlzLmVzdGltYXRlXztcbiAgICB0aGlzLnRvdGFsV2VpZ2h0XyArPSB3ZWlnaHQ7XG4gIH1cblxuICBnZXRUb3RhbFdlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy50b3RhbFdlaWdodF87XG4gIH1cblxuICBnZXRFc3RpbWF0ZSgpIHtcbiAgICBpZiAodGhpcy5hbHBoYV8pIHtcbiAgICAgIHZhciB6ZXJvRmFjdG9yID0gMSAtIE1hdGgucG93KHRoaXMuYWxwaGFfLCB0aGlzLnRvdGFsV2VpZ2h0Xyk7XG4gICAgICByZXR1cm4gdGhpcy5lc3RpbWF0ZV8gLyB6ZXJvRmFjdG9yO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5lc3RpbWF0ZV87XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEVXTUE7XG4iLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5jb25zdCBmYWtlTG9nZ2VyID0ge1xuICB0cmFjZTogbm9vcCxcbiAgZGVidWc6IG5vb3AsXG4gIGxvZzogbm9vcCxcbiAgd2Fybjogbm9vcCxcbiAgaW5mbzogbm9vcCxcbiAgZXJyb3I6IG5vb3Bcbn07XG5cbmxldCBleHBvcnRlZExvZ2dlciA9IGZha2VMb2dnZXI7XG5cbi8qZ2xvYmFscyBzZWxmOiBmYWxzZSAqL1xuXG4vL2xldCBsYXN0Q2FsbFRpbWU7XG4vLyBmdW5jdGlvbiBmb3JtYXRNc2dXaXRoVGltZUluZm8odHlwZSwgbXNnKSB7XG4vLyAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4vLyAgIGNvbnN0IGRpZmYgPSBsYXN0Q2FsbFRpbWUgPyAnKycgKyAobm93IC0gbGFzdENhbGxUaW1lKSA6ICcwJztcbi8vICAgbGFzdENhbGxUaW1lID0gbm93O1xuLy8gICBtc2cgPSAobmV3IERhdGUobm93KSkudG9JU09TdHJpbmcoKSArICcgfCBbJyArICB0eXBlICsgJ10gPiAnICsgbXNnICsgJyAoICcgKyBkaWZmICsgJyBtcyApJztcbi8vICAgcmV0dXJuIG1zZztcbi8vIH1cblxuZnVuY3Rpb24gZm9ybWF0TXNnKHR5cGUsIG1zZykge1xuICBtc2cgPSAnWycgKyAgdHlwZSArICddID4gJyArIG1zZztcbiAgcmV0dXJuIG1zZztcbn1cblxuZnVuY3Rpb24gY29uc29sZVByaW50Rm4odHlwZSkge1xuICBjb25zdCBmdW5jID0gc2VsZi5jb25zb2xlW3R5cGVdO1xuICBpZiAoZnVuYykge1xuICAgIHJldHVybiBmdW5jdGlvbiguLi5hcmdzKSB7XG4gICAgICBpZihhcmdzWzBdKSB7XG4gICAgICAgIGFyZ3NbMF0gPSBmb3JtYXRNc2codHlwZSwgYXJnc1swXSk7XG4gICAgICB9XG4gICAgICBmdW5jLmFwcGx5KHNlbGYuY29uc29sZSwgYXJncyk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gbm9vcDtcbn1cblxuZnVuY3Rpb24gZXhwb3J0TG9nZ2VyRnVuY3Rpb25zKGRlYnVnQ29uZmlnLCAuLi5mdW5jdGlvbnMpIHtcbiAgZnVuY3Rpb25zLmZvckVhY2goZnVuY3Rpb24odHlwZSkge1xuICAgIGV4cG9ydGVkTG9nZ2VyW3R5cGVdID0gZGVidWdDb25maWdbdHlwZV0gPyBkZWJ1Z0NvbmZpZ1t0eXBlXS5iaW5kKGRlYnVnQ29uZmlnKSA6IGNvbnNvbGVQcmludEZuKHR5cGUpO1xuICB9KTtcbn1cblxuZXhwb3J0IHZhciBlbmFibGVMb2dzID0gZnVuY3Rpb24oZGVidWdDb25maWcpIHtcbiAgaWYgKGRlYnVnQ29uZmlnID09PSB0cnVlIHx8IHR5cGVvZiBkZWJ1Z0NvbmZpZyA9PT0gJ29iamVjdCcpIHtcbiAgICBleHBvcnRMb2dnZXJGdW5jdGlvbnMoZGVidWdDb25maWcsXG4gICAgICAvLyBSZW1vdmUgb3V0IGZyb20gbGlzdCBoZXJlIHRvIGhhcmQtZGlzYWJsZSBhIGxvZy1sZXZlbFxuICAgICAgLy8ndHJhY2UnLFxuICAgICAgJ2RlYnVnJyxcbiAgICAgICdsb2cnLFxuICAgICAgJ2luZm8nLFxuICAgICAgJ3dhcm4nLFxuICAgICAgJ2Vycm9yJ1xuICAgICk7XG4gICAgLy8gU29tZSBicm93c2VycyBkb24ndCBhbGxvdyB0byB1c2UgYmluZCBvbiBjb25zb2xlIG9iamVjdCBhbnl3YXlcbiAgICAvLyBmYWxsYmFjayB0byBkZWZhdWx0IGlmIG5lZWRlZFxuICAgIHRyeSB7XG4gICAgIGV4cG9ydGVkTG9nZ2VyLmxvZygpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGV4cG9ydGVkTG9nZ2VyID0gZmFrZUxvZ2dlcjtcbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgZXhwb3J0ZWRMb2dnZXIgPSBmYWtlTG9nZ2VyO1xuICB9XG59O1xuXG5leHBvcnQgdmFyIGxvZ2dlciA9IGV4cG9ydGVkTG9nZ2VyO1xuIiwiLyoqXG4gKiAgVGltZVJhbmdlcyB0byBzdHJpbmcgaGVscGVyXG4gKi9cblxuY2xhc3MgVGltZVJhbmdlcyB7XG4gIHN0YXRpYyB0b1N0cmluZyhyKSB7XG4gICAgdmFyIGxvZyA9ICcnLCBsZW4gPSByLmxlbmd0aDtcbiAgICBmb3IgKHZhciBpPTA7IGk8bGVuOyBpKyspIHtcbiAgICAgIGxvZyArPSAnWycgKyByLnN0YXJ0KGkpLnRvRml4ZWQoMykgKyAnLCcgKyByLmVuZChpKS50b0ZpeGVkKDMpICsgJ10nO1xuICAgIH1cbiAgICByZXR1cm4gbG9nO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFRpbWVSYW5nZXM7XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzIHZ0dC5qcyBDb250cmlidXRvcnNcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmV4cG9ydCBkZWZhdWx0IChmdW5jdGlvbigpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5WVFRDdWUpIHtcbiAgICByZXR1cm4gd2luZG93LlZUVEN1ZTtcbiAgfVxuXG4gIHZhciBhdXRvS2V5d29yZCA9ICdhdXRvJztcbiAgdmFyIGRpcmVjdGlvblNldHRpbmcgPSB7XG4gICAgJyc6IHRydWUsXG4gICAgbHI6IHRydWUsXG4gICAgcmw6IHRydWVcbiAgfTtcbiAgdmFyIGFsaWduU2V0dGluZyA9IHtcbiAgICBzdGFydDogdHJ1ZSxcbiAgICBtaWRkbGU6IHRydWUsXG4gICAgZW5kOiB0cnVlLFxuICAgIGxlZnQ6IHRydWUsXG4gICAgcmlnaHQ6IHRydWVcbiAgfTtcblxuICBmdW5jdGlvbiBmaW5kRGlyZWN0aW9uU2V0dGluZyh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciBkaXIgPSBkaXJlY3Rpb25TZXR0aW5nW3ZhbHVlLnRvTG93ZXJDYXNlKCldO1xuICAgIHJldHVybiBkaXIgPyB2YWx1ZS50b0xvd2VyQ2FzZSgpIDogZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBmaW5kQWxpZ25TZXR0aW5nKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIGFsaWduID0gYWxpZ25TZXR0aW5nW3ZhbHVlLnRvTG93ZXJDYXNlKCldO1xuICAgIHJldHVybiBhbGlnbiA/IHZhbHVlLnRvTG93ZXJDYXNlKCkgOiBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGV4dGVuZChvYmopIHtcbiAgICB2YXIgaSA9IDE7XG4gICAgZm9yICg7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjb2JqID0gYXJndW1lbnRzW2ldO1xuICAgICAgZm9yICh2YXIgcCBpbiBjb2JqKSB7XG4gICAgICAgIG9ialtwXSA9IGNvYmpbcF07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIGZ1bmN0aW9uIFZUVEN1ZShzdGFydFRpbWUsIGVuZFRpbWUsIHRleHQpIHtcbiAgICB2YXIgY3VlID0gdGhpcztcbiAgICB2YXIgaXNJRTggPSAoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHJldHVybiAoL01TSUVcXHM4XFwuMC8pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gICAgfSkoKTtcbiAgICB2YXIgYmFzZU9iaiA9IHt9O1xuXG4gICAgaWYgKGlzSUU4KSB7XG4gICAgICBjdWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjdXN0b20nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYmFzZU9iai5lbnVtZXJhYmxlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTaGltIGltcGxlbWVudGF0aW9uIHNwZWNpZmljIHByb3BlcnRpZXMuIFRoZXNlIHByb3BlcnRpZXMgYXJlIG5vdCBpblxuICAgICAqIHRoZSBzcGVjLlxuICAgICAqL1xuXG4gICAgLy8gTGV0cyB1cyBrbm93IHdoZW4gdGhlIFZUVEN1ZSdzIGRhdGEgaGFzIGNoYW5nZWQgaW4gc3VjaCBhIHdheSB0aGF0IHdlIG5lZWRcbiAgICAvLyB0byByZWNvbXB1dGUgaXRzIGRpc3BsYXkgc3RhdGUuIFRoaXMgbGV0cyB1cyBjb21wdXRlIGl0cyBkaXNwbGF5IHN0YXRlXG4gICAgLy8gbGF6aWx5LlxuICAgIGN1ZS5oYXNCZWVuUmVzZXQgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIFZUVEN1ZSBhbmQgVGV4dFRyYWNrQ3VlIHByb3BlcnRpZXNcbiAgICAgKiBodHRwOi8vZGV2LnczLm9yZy9odG1sNS93ZWJ2dHQvI3Z0dGN1ZS1pbnRlcmZhY2VcbiAgICAgKi9cblxuICAgIHZhciBfaWQgPSAnJztcbiAgICB2YXIgX3BhdXNlT25FeGl0ID0gZmFsc2U7XG4gICAgdmFyIF9zdGFydFRpbWUgPSBzdGFydFRpbWU7XG4gICAgdmFyIF9lbmRUaW1lID0gZW5kVGltZTtcbiAgICB2YXIgX3RleHQgPSB0ZXh0O1xuICAgIHZhciBfcmVnaW9uID0gbnVsbDtcbiAgICB2YXIgX3ZlcnRpY2FsID0gJyc7XG4gICAgdmFyIF9zbmFwVG9MaW5lcyA9IHRydWU7XG4gICAgdmFyIF9saW5lID0gJ2F1dG8nO1xuICAgIHZhciBfbGluZUFsaWduID0gJ3N0YXJ0JztcbiAgICB2YXIgX3Bvc2l0aW9uID0gNTA7XG4gICAgdmFyIF9wb3NpdGlvbkFsaWduID0gJ21pZGRsZSc7XG4gICAgdmFyIF9zaXplID0gNTA7XG4gICAgdmFyIF9hbGlnbiA9ICdtaWRkbGUnO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSwgJ2lkJywgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9pZDtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBfaWQgPSAnJyArIHZhbHVlO1xuICAgICAgfVxuICAgIH0pKTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsICdwYXVzZU9uRXhpdCcsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfcGF1c2VPbkV4aXQ7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgX3BhdXNlT25FeGl0ID0gISF2YWx1ZTtcbiAgICAgIH1cbiAgICB9KSk7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLCAnc3RhcnRUaW1lJywgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9zdGFydFRpbWU7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdTdGFydCB0aW1lIG11c3QgYmUgc2V0IHRvIGEgbnVtYmVyLicpO1xuICAgICAgICB9XG4gICAgICAgIF9zdGFydFRpbWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5oYXNCZWVuUmVzZXQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pKTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsICdlbmRUaW1lJywgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9lbmRUaW1lO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRW5kIHRpbWUgbXVzdCBiZSBzZXQgdG8gYSBudW1iZXIuJyk7XG4gICAgICAgIH1cbiAgICAgICAgX2VuZFRpbWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5oYXNCZWVuUmVzZXQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pKTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsICd0ZXh0JywgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90ZXh0O1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIF90ZXh0ID0gJycgKyB2YWx1ZTtcbiAgICAgICAgdGhpcy5oYXNCZWVuUmVzZXQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pKTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsICdyZWdpb24nLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3JlZ2lvbjtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBfcmVnaW9uID0gdmFsdWU7XG4gICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSk7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLCAndmVydGljYWwnLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3ZlcnRpY2FsO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBzZXR0aW5nID0gZmluZERpcmVjdGlvblNldHRpbmcodmFsdWUpO1xuICAgICAgICAvLyBIYXZlIHRvIGNoZWNrIGZvciBmYWxzZSBiZWNhdXNlIHRoZSBzZXR0aW5nIGFuIGJlIGFuIGVtcHR5IHN0cmluZy5cbiAgICAgICAgaWYgKHNldHRpbmcgPT09IGZhbHNlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdBbiBpbnZhbGlkIG9yIGlsbGVnYWwgc3RyaW5nIHdhcyBzcGVjaWZpZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgX3ZlcnRpY2FsID0gc2V0dGluZztcbiAgICAgICAgdGhpcy5oYXNCZWVuUmVzZXQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pKTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsICdzbmFwVG9MaW5lcycsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfc25hcFRvTGluZXM7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgX3NuYXBUb0xpbmVzID0gISF2YWx1ZTtcbiAgICAgICAgdGhpcy5oYXNCZWVuUmVzZXQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pKTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsICdsaW5lJywgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9saW5lO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInICYmIHZhbHVlICE9PSBhdXRvS2V5d29yZCkge1xuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignQW4gaW52YWxpZCBudW1iZXIgb3IgaWxsZWdhbCBzdHJpbmcgd2FzIHNwZWNpZmllZC4nKTtcbiAgICAgICAgfVxuICAgICAgICBfbGluZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XG4gICAgICB9XG4gICAgfSkpO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSwgJ2xpbmVBbGlnbicsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfbGluZUFsaWduO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBzZXR0aW5nID0gZmluZEFsaWduU2V0dGluZyh2YWx1ZSk7XG4gICAgICAgIGlmICghc2V0dGluZykge1xuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignQW4gaW52YWxpZCBvciBpbGxlZ2FsIHN0cmluZyB3YXMgc3BlY2lmaWVkLicpO1xuICAgICAgICB9XG4gICAgICAgIF9saW5lQWxpZ24gPSBzZXR0aW5nO1xuICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XG4gICAgICB9XG4gICAgfSkpO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSwgJ3Bvc2l0aW9uJywgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9wb3NpdGlvbjtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPCAwIHx8IHZhbHVlID4gMTAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQb3NpdGlvbiBtdXN0IGJlIGJldHdlZW4gMCBhbmQgMTAwLicpO1xuICAgICAgICB9XG4gICAgICAgIF9wb3NpdGlvbiA9IHZhbHVlO1xuICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XG4gICAgICB9XG4gICAgfSkpO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSwgJ3Bvc2l0aW9uQWxpZ24nLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3Bvc2l0aW9uQWxpZ247XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIHNldHRpbmcgPSBmaW5kQWxpZ25TZXR0aW5nKHZhbHVlKTtcbiAgICAgICAgaWYgKCFzZXR0aW5nKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdBbiBpbnZhbGlkIG9yIGlsbGVnYWwgc3RyaW5nIHdhcyBzcGVjaWZpZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgX3Bvc2l0aW9uQWxpZ24gPSBzZXR0aW5nO1xuICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XG4gICAgICB9XG4gICAgfSkpO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSwgJ3NpemUnLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3NpemU7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlIDwgMCB8fCB2YWx1ZSA+IDEwMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU2l6ZSBtdXN0IGJlIGJldHdlZW4gMCBhbmQgMTAwLicpO1xuICAgICAgICB9XG4gICAgICAgIF9zaXplID0gdmFsdWU7XG4gICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSk7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLCAnYWxpZ24nLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX2FsaWduO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBzZXR0aW5nID0gZmluZEFsaWduU2V0dGluZyh2YWx1ZSk7XG4gICAgICAgIGlmICghc2V0dGluZykge1xuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignQW4gaW52YWxpZCBvciBpbGxlZ2FsIHN0cmluZyB3YXMgc3BlY2lmaWVkLicpO1xuICAgICAgICB9XG4gICAgICAgIF9hbGlnbiA9IHNldHRpbmc7XG4gICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSk7XG5cbiAgICAvKipcbiAgICAgKiBPdGhlciA8dHJhY2s+IHNwZWMgZGVmaW5lZCBwcm9wZXJ0aWVzXG4gICAgICovXG5cbiAgICAvLyBodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS90aGUtdmlkZW8tZWxlbWVudC5odG1sI3RleHQtdHJhY2stY3VlLWRpc3BsYXktc3RhdGVcbiAgICBjdWUuZGlzcGxheVN0YXRlID0gdW5kZWZpbmVkO1xuXG4gICAgaWYgKGlzSUU4KSB7XG4gICAgICByZXR1cm4gY3VlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBWVFRDdWUgbWV0aG9kc1xuICAgKi9cblxuICBWVFRDdWUucHJvdG90eXBlLmdldEN1ZUFzSFRNTCA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBBc3N1bWUgV2ViVlRULmNvbnZlcnRDdWVUb0RPTVRyZWUgaXMgb24gdGhlIGdsb2JhbC5cbiAgICB2YXIgV2ViVlRUID0gd2luZG93LldlYlZUVDtcbiAgICByZXR1cm4gV2ViVlRULmNvbnZlcnRDdWVUb0RPTVRyZWUod2luZG93LCB0aGlzLnRleHQpO1xuICB9O1xuXG4gIHJldHVybiBWVFRDdWU7XG59KSgpO1xuIiwiLypcbiAqIFNvdXJjZTogaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvdnR0LmpzL2Jsb2IvbWFzdGVyL2Rpc3QvdnR0LmpzI0wxNzE2XG4gKi9cblxuaW1wb3J0IFZUVEN1ZSBmcm9tICcuL3Z0dGN1ZSc7XG5cbmNvbnN0IFN0cmluZ0RlY29kZXIgPSBmdW5jdGlvbiBTdHJpbmdEZWNvZGVyKCkge1xuICByZXR1cm4ge1xuICAgIGRlY29kZTogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgZGF0YSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFcnJvciAtIGV4cGVjdGVkIHN0cmluZyBkYXRhLicpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChlbmNvZGVVUklDb21wb25lbnQoZGF0YSkpO1xuICAgICAgICB9LFxuICAgIH07XG4gIH07XG5cbmZ1bmN0aW9uIFZUVFBhcnNlcigpIHtcbiAgICB0aGlzLndpbmRvdyA9IHdpbmRvdztcbiAgICB0aGlzLnN0YXRlID0gJ0lOSVRJQUwnO1xuICAgIHRoaXMuYnVmZmVyID0gJyc7XG4gICAgdGhpcy5kZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIoKTtcbiAgICB0aGlzLnJlZ2lvbkxpc3QgPSBbXTtcbn1cblxuXG4vLyBUcnkgdG8gcGFyc2UgaW5wdXQgYXMgYSB0aW1lIHN0YW1wLlxuZnVuY3Rpb24gcGFyc2VUaW1lU3RhbXAoaW5wdXQpIHtcblxuICBmdW5jdGlvbiBjb21wdXRlU2Vjb25kcyhoLCBtLCBzLCBmKSB7XG4gICAgcmV0dXJuIChoIHwgMCkgKiAzNjAwICsgKG0gfCAwKSAqIDYwICsgKHMgfCAwKSArIChmIHwgMCkgLyAxMDAwO1xuICB9XG5cbiAgdmFyIG0gPSBpbnB1dC5tYXRjaCgvXihcXGQrKTooXFxkezJ9KSg6XFxkezJ9KT9cXC4oXFxkezN9KS8pO1xuICBpZiAoIW0pIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmIChtWzNdKSB7XG4gICAgLy8gVGltZXN0YW1wIHRha2VzIHRoZSBmb3JtIG9mIFtob3Vyc106W21pbnV0ZXNdOltzZWNvbmRzXS5bbWlsbGlzZWNvbmRzXVxuICAgIHJldHVybiBjb21wdXRlU2Vjb25kcyhtWzFdLCBtWzJdLCBtWzNdLnJlcGxhY2UoJzonLCAnJyksIG1bNF0pO1xuICB9IGVsc2UgaWYgKG1bMV0gPiA1OSkge1xuICAgIC8vIFRpbWVzdGFtcCB0YWtlcyB0aGUgZm9ybSBvZiBbaG91cnNdOlttaW51dGVzXS5bbWlsbGlzZWNvbmRzXVxuICAgIC8vIEZpcnN0IHBvc2l0aW9uIGlzIGhvdXJzIGFzIGl0J3Mgb3ZlciA1OS5cbiAgICByZXR1cm4gY29tcHV0ZVNlY29uZHMobVsxXSwgbVsyXSwgMCwgbVs0XSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gVGltZXN0YW1wIHRha2VzIHRoZSBmb3JtIG9mIFttaW51dGVzXTpbc2Vjb25kc10uW21pbGxpc2Vjb25kc11cbiAgICByZXR1cm4gY29tcHV0ZVNlY29uZHMoMCwgbVsxXSwgbVsyXSwgbVs0XSk7XG4gIH1cbn1cblxuLy8gQSBzZXR0aW5ncyBvYmplY3QgaG9sZHMga2V5L3ZhbHVlIHBhaXJzIGFuZCB3aWxsIGlnbm9yZSBhbnl0aGluZyBidXQgdGhlIGZpcnN0XG4vLyBhc3NpZ25tZW50IHRvIGEgc3BlY2lmaWMga2V5LlxuZnVuY3Rpb24gU2V0dGluZ3MoKSB7XG4gIHRoaXMudmFsdWVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbn1cblxuU2V0dGluZ3MucHJvdG90eXBlID0ge1xuICAvLyBPbmx5IGFjY2VwdCB0aGUgZmlyc3QgYXNzaWdubWVudCB0byBhbnkga2V5LlxuICBzZXQ6IGZ1bmN0aW9uKGssIHYpIHtcbiAgICBpZiAoIXRoaXMuZ2V0KGspICYmIHYgIT09ICcnKSB7XG4gICAgICB0aGlzLnZhbHVlc1trXSA9IHY7XG4gICAgfVxuICB9LFxuICAvLyBSZXR1cm4gdGhlIHZhbHVlIGZvciBhIGtleSwgb3IgYSBkZWZhdWx0IHZhbHVlLlxuICAvLyBJZiAnZGVmYXVsdEtleScgaXMgcGFzc2VkIHRoZW4gJ2RmbHQnIGlzIGFzc3VtZWQgdG8gYmUgYW4gb2JqZWN0IHdpdGhcbiAgLy8gYSBudW1iZXIgb2YgcG9zc2libGUgZGVmYXVsdCB2YWx1ZXMgYXMgcHJvcGVydGllcyB3aGVyZSAnZGVmYXVsdEtleScgaXNcbiAgLy8gdGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdGhhdCB3aWxsIGJlIGNob3Nlbjsgb3RoZXJ3aXNlIGl0J3MgYXNzdW1lZCB0byBiZVxuICAvLyBhIHNpbmdsZSB2YWx1ZS5cbiAgZ2V0OiBmdW5jdGlvbihrLCBkZmx0LCBkZWZhdWx0S2V5KSB7XG4gICAgaWYgKGRlZmF1bHRLZXkpIHtcbiAgICAgIHJldHVybiB0aGlzLmhhcyhrKSA/IHRoaXMudmFsdWVzW2tdIDogZGZsdFtkZWZhdWx0S2V5XTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuaGFzKGspID8gdGhpcy52YWx1ZXNba10gOiBkZmx0O1xuICB9LFxuICAvLyBDaGVjayB3aGV0aGVyIHdlIGhhdmUgYSB2YWx1ZSBmb3IgYSBrZXkuXG4gIGhhczogZnVuY3Rpb24oaykge1xuICAgIHJldHVybiBrIGluIHRoaXMudmFsdWVzO1xuICB9LFxuICAvLyBBY2NlcHQgYSBzZXR0aW5nIGlmIGl0cyBvbmUgb2YgdGhlIGdpdmVuIGFsdGVybmF0aXZlcy5cbiAgYWx0OiBmdW5jdGlvbihrLCB2LCBhKSB7XG4gICAgZm9yICh2YXIgbiA9IDA7IG4gPCBhLmxlbmd0aDsgKytuKSB7XG4gICAgICBpZiAodiA9PT0gYVtuXSkge1xuICAgICAgICB0aGlzLnNldChrLCB2KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICAvLyBBY2NlcHQgYSBzZXR0aW5nIGlmIGl0cyBhIHZhbGlkIChzaWduZWQpIGludGVnZXIuXG4gIGludGVnZXI6IGZ1bmN0aW9uKGssIHYpIHtcbiAgICBpZiAoL14tP1xcZCskLy50ZXN0KHYpKSB7IC8vIGludGVnZXJcbiAgICAgIHRoaXMuc2V0KGssIHBhcnNlSW50KHYsIDEwKSk7XG4gICAgfVxuICB9LFxuICAvLyBBY2NlcHQgYSBzZXR0aW5nIGlmIGl0cyBhIHZhbGlkIHBlcmNlbnRhZ2UuXG4gIHBlcmNlbnQ6IGZ1bmN0aW9uKGssIHYpIHtcbiAgICB2YXIgbTtcbiAgICBpZiAoKG0gPSB2Lm1hdGNoKC9eKFtcXGRdezEsM30pKFxcLltcXGRdKik/JSQvKSkpIHtcbiAgICAgIHYgPSBwYXJzZUZsb2F0KHYpO1xuICAgICAgaWYgKHYgPj0gMCAmJiB2IDw9IDEwMCkge1xuICAgICAgICB0aGlzLnNldChrLCB2KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxuLy8gSGVscGVyIGZ1bmN0aW9uIHRvIHBhcnNlIGlucHV0IGludG8gZ3JvdXBzIHNlcGFyYXRlZCBieSAnZ3JvdXBEZWxpbScsIGFuZFxuLy8gaW50ZXJwcmV0ZSBlYWNoIGdyb3VwIGFzIGEga2V5L3ZhbHVlIHBhaXIgc2VwYXJhdGVkIGJ5ICdrZXlWYWx1ZURlbGltJy5cbmZ1bmN0aW9uIHBhcnNlT3B0aW9ucyhpbnB1dCwgY2FsbGJhY2ssIGtleVZhbHVlRGVsaW0sIGdyb3VwRGVsaW0pIHtcbiAgdmFyIGdyb3VwcyA9IGdyb3VwRGVsaW0gPyBpbnB1dC5zcGxpdChncm91cERlbGltKSA6IFtpbnB1dF07XG4gIGZvciAodmFyIGkgaW4gZ3JvdXBzKSB7XG4gICAgaWYgKHR5cGVvZiBncm91cHNbaV0gIT09ICdzdHJpbmcnKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdmFyIGt2ID0gZ3JvdXBzW2ldLnNwbGl0KGtleVZhbHVlRGVsaW0pO1xuICAgIGlmIChrdi5sZW5ndGggIT09IDIpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB2YXIgayA9IGt2WzBdO1xuICAgIHZhciB2ID0ga3ZbMV07XG4gICAgY2FsbGJhY2soaywgdik7XG4gIH1cbn1cblxudmFyIGRlZmF1bHRzID0gbmV3IFZUVEN1ZSgwLCAwLCAwKTtcbi8vICdtaWRkbGUnIHdhcyBjaGFuZ2VkIHRvICdjZW50ZXInIGluIHRoZSBzcGVjOiBodHRwczovL2dpdGh1Yi5jb20vdzNjL3dlYnZ0dC9wdWxsLzI0NFxuLy8gQ2hyb21lIGFuZCBTYWZhcmkgZG9uJ3QgeWV0IHN1cHBvcnQgdGhpcyBjaGFuZ2UsIGJ1dCBGRiBkb2VzXG52YXIgY2VudGVyID0gZGVmYXVsdHMuYWxpZ24gPT09ICdtaWRkbGUnID8gJ21pZGRsZScgOiAnY2VudGVyJztcblxuZnVuY3Rpb24gcGFyc2VDdWUoaW5wdXQsIGN1ZSwgcmVnaW9uTGlzdCkge1xuICAvLyBSZW1lbWJlciB0aGUgb3JpZ2luYWwgaW5wdXQgaWYgd2UgbmVlZCB0byB0aHJvdyBhbiBlcnJvci5cbiAgdmFyIG9JbnB1dCA9IGlucHV0O1xuICAvLyA0LjEgV2ViVlRUIHRpbWVzdGFtcFxuICBmdW5jdGlvbiBjb25zdW1lVGltZVN0YW1wKCkge1xuICAgIHZhciB0cyA9IHBhcnNlVGltZVN0YW1wKGlucHV0KTtcbiAgICBpZiAodHMgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTWFsZm9ybWVkIHRpbWVzdGFtcDogJyArIG9JbnB1dCk7XG4gICAgfVxuICAgIC8vIFJlbW92ZSB0aW1lIHN0YW1wIGZyb20gaW5wdXQuXG4gICAgaW5wdXQgPSBpbnB1dC5yZXBsYWNlKC9eW15cXHNhLXpBLVotXSsvLCAnJyk7XG4gICAgcmV0dXJuIHRzO1xuICB9XG5cbiAgLy8gNC40LjIgV2ViVlRUIGN1ZSBzZXR0aW5nc1xuICBmdW5jdGlvbiBjb25zdW1lQ3VlU2V0dGluZ3MoaW5wdXQsIGN1ZSkge1xuICAgIHZhciBzZXR0aW5ncyA9IG5ldyBTZXR0aW5ncygpO1xuXG4gICAgcGFyc2VPcHRpb25zKGlucHV0LCBmdW5jdGlvbihrLCB2KSB7XG4gICAgICBzd2l0Y2ggKGspIHtcbiAgICAgICAgY2FzZSAncmVnaW9uJzpcbiAgICAgICAgICAvLyBGaW5kIHRoZSBsYXN0IHJlZ2lvbiB3ZSBwYXJzZWQgd2l0aCB0aGUgc2FtZSByZWdpb24gaWQuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IHJlZ2lvbkxpc3QubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGlmIChyZWdpb25MaXN0W2ldLmlkID09PSB2KSB7XG4gICAgICAgICAgICAgIHNldHRpbmdzLnNldChrLCByZWdpb25MaXN0W2ldLnJlZ2lvbik7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAndmVydGljYWwnOlxuICAgICAgICAgIHNldHRpbmdzLmFsdChrLCB2LCBbJ3JsJywgJ2xyJ10pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdsaW5lJzpcbiAgICAgICAgICB2YXIgdmFscyA9IHYuc3BsaXQoJywnKSxcbiAgICAgICAgICAgIHZhbHMwID0gdmFsc1swXTtcbiAgICAgICAgICBzZXR0aW5ncy5pbnRlZ2VyKGssIHZhbHMwKTtcbiAgICAgICAgICBpZiAoc2V0dGluZ3MucGVyY2VudChrLCB2YWxzMCkpIHtcbiAgICAgICAgICAgIHNldHRpbmdzLnNldCgnc25hcFRvTGluZXMnLCBmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNldHRpbmdzLmFsdChrLCB2YWxzMCwgWydhdXRvJ10pO1xuICAgICAgICAgIGlmICh2YWxzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgc2V0dGluZ3MuYWx0KCdsaW5lQWxpZ24nLCB2YWxzWzFdLCBbJ3N0YXJ0JywgY2VudGVyLCAnZW5kJ10pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAncG9zaXRpb24nOlxuICAgICAgICAgIHZhbHMgPSB2LnNwbGl0KCcsJyk7XG4gICAgICAgICAgc2V0dGluZ3MucGVyY2VudChrLCB2YWxzWzBdKTtcbiAgICAgICAgICBpZiAodmFscy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgIHNldHRpbmdzLmFsdCgncG9zaXRpb25BbGlnbicsIHZhbHNbMV0sIFsnc3RhcnQnLCBjZW50ZXIsICdlbmQnLCAnbGluZS1sZWZ0JywgJ2xpbmUtcmlnaHQnLCAnYXV0byddKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3NpemUnOlxuICAgICAgICAgIHNldHRpbmdzLnBlcmNlbnQoaywgdik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2FsaWduJzpcbiAgICAgICAgICBzZXR0aW5ncy5hbHQoaywgdiwgWydzdGFydCcsIGNlbnRlciwgJ2VuZCcsICdsZWZ0JywgJ3JpZ2h0J10pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0sIC86LywgL1xccy8pO1xuXG4gICAgLy8gQXBwbHkgZGVmYXVsdCB2YWx1ZXMgZm9yIGFueSBtaXNzaW5nIGZpZWxkcy5cbiAgICBjdWUucmVnaW9uID0gc2V0dGluZ3MuZ2V0KCdyZWdpb24nLCBudWxsKTtcbiAgICBjdWUudmVydGljYWwgPSBzZXR0aW5ncy5nZXQoJ3ZlcnRpY2FsJywgJycpO1xuICAgIHZhciBsaW5lID0gc2V0dGluZ3MuZ2V0KCdsaW5lJywgJ2F1dG8nKTtcbiAgICBpZiAobGluZSA9PT0gJ2F1dG8nICYmIGRlZmF1bHRzLmxpbmUgPT09IC0xKSB7XG4gICAgICAvLyBzZXQgbnVtZXJpYyBsaW5lIG51bWJlciBmb3IgU2FmYXJpXG4gICAgICBsaW5lID0gLTE7XG4gICAgfVxuICAgIGN1ZS5saW5lID0gbGluZTtcbiAgICBjdWUubGluZUFsaWduID0gc2V0dGluZ3MuZ2V0KCdsaW5lQWxpZ24nLCAnc3RhcnQnKTtcbiAgICBjdWUuc25hcFRvTGluZXMgPSBzZXR0aW5ncy5nZXQoJ3NuYXBUb0xpbmVzJywgdHJ1ZSk7XG4gICAgY3VlLnNpemUgPSBzZXR0aW5ncy5nZXQoJ3NpemUnLCAxMDApO1xuICAgIGN1ZS5hbGlnbiA9IHNldHRpbmdzLmdldCgnYWxpZ24nLCBjZW50ZXIpO1xuICAgIHZhciBwb3NpdGlvbiA9IHNldHRpbmdzLmdldCgncG9zaXRpb24nLCAnYXV0bycpO1xuICAgIGlmIChwb3NpdGlvbiA9PT0gJ2F1dG8nICYmIGRlZmF1bHRzLnBvc2l0aW9uID09PSA1MCkge1xuICAgICAgLy8gc2V0IG51bWVyaWMgcG9zaXRpb24gZm9yIFNhZmFyaVxuICAgICAgcG9zaXRpb24gPSBjdWUuYWxpZ24gPT09ICdzdGFydCcgfHwgY3VlLmFsaWduID09PSAnbGVmdCcgPyAwIDogY3VlLmFsaWduID09PSAnZW5kJyB8fCBjdWUuYWxpZ24gPT09ICdyaWdodCcgPyAxMDAgOiA1MDtcbiAgICB9XG4gICAgY3VlLnBvc2l0aW9uID0gcG9zaXRpb247XG4gIH1cblxuICBmdW5jdGlvbiBza2lwV2hpdGVzcGFjZSgpIHtcbiAgICBpbnB1dCA9IGlucHV0LnJlcGxhY2UoL15cXHMrLywgJycpO1xuICB9XG5cbiAgLy8gNC4xIFdlYlZUVCBjdWUgdGltaW5ncy5cbiAgc2tpcFdoaXRlc3BhY2UoKTtcbiAgY3VlLnN0YXJ0VGltZSA9IGNvbnN1bWVUaW1lU3RhbXAoKTsgICAvLyAoMSkgY29sbGVjdCBjdWUgc3RhcnQgdGltZVxuICBza2lwV2hpdGVzcGFjZSgpO1xuICBpZiAoaW5wdXQuc3Vic3RyKDAsIDMpICE9PSAnLS0+JykgeyAgICAgLy8gKDMpIG5leHQgY2hhcmFjdGVycyBtdXN0IG1hdGNoICctLT4nXG4gICAgdGhyb3cgbmV3IEVycm9yKCdNYWxmb3JtZWQgdGltZSBzdGFtcCAodGltZSBzdGFtcHMgbXVzdCBiZSBzZXBhcmF0ZWQgYnkgXFwnLS0+XFwnKTogJyArXG4gICAgICBvSW5wdXQpO1xuICB9XG4gIGlucHV0ID0gaW5wdXQuc3Vic3RyKDMpO1xuICBza2lwV2hpdGVzcGFjZSgpO1xuICBjdWUuZW5kVGltZSA9IGNvbnN1bWVUaW1lU3RhbXAoKTsgICAgIC8vICg1KSBjb2xsZWN0IGN1ZSBlbmQgdGltZVxuXG4gIC8vIDQuMSBXZWJWVFQgY3VlIHNldHRpbmdzIGxpc3QuXG4gIHNraXBXaGl0ZXNwYWNlKCk7XG4gIGNvbnN1bWVDdWVTZXR0aW5ncyhpbnB1dCwgY3VlKTtcbn1cblxuZnVuY3Rpb24gZml4TGluZUJyZWFrcyhpbnB1dCkge1xuICByZXR1cm4gaW5wdXQucmVwbGFjZSgvPGJyKD86IFxcLyk/Pi9naSwgJ1xcbicpO1xufVxuXG5WVFRQYXJzZXIucHJvdG90eXBlID0ge1xuICBwYXJzZTogZnVuY3Rpb24oZGF0YSkge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIC8vIElmIHRoZXJlIGlzIG5vIGRhdGEgdGhlbiB3ZSB3b24ndCBkZWNvZGUgaXQsIGJ1dCB3aWxsIGp1c3QgdHJ5IHRvIHBhcnNlXG4gICAgLy8gd2hhdGV2ZXIgaXMgaW4gYnVmZmVyIGFscmVhZHkuIFRoaXMgbWF5IG9jY3VyIGluIGNpcmN1bXN0YW5jZXMsIGZvclxuICAgIC8vIGV4YW1wbGUgd2hlbiBmbHVzaCgpIGlzIGNhbGxlZC5cbiAgICBpZiAoZGF0YSkge1xuICAgICAgLy8gVHJ5IHRvIGRlY29kZSB0aGUgZGF0YSB0aGF0IHdlIHJlY2VpdmVkLlxuICAgICAgc2VsZi5idWZmZXIgKz0gc2VsZi5kZWNvZGVyLmRlY29kZShkYXRhLCB7c3RyZWFtOiB0cnVlfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29sbGVjdE5leHRMaW5lKCkge1xuICAgICAgdmFyIGJ1ZmZlciA9IHNlbGYuYnVmZmVyO1xuICAgICAgdmFyIHBvcyA9IDA7XG5cbiAgICAgIGJ1ZmZlciA9IGZpeExpbmVCcmVha3MoYnVmZmVyKTtcblxuICAgICAgd2hpbGUgKHBvcyA8IGJ1ZmZlci5sZW5ndGggJiYgYnVmZmVyW3Bvc10gIT09ICdcXHInICYmIGJ1ZmZlcltwb3NdICE9PSAnXFxuJykge1xuICAgICAgICArK3BvcztcbiAgICAgIH1cbiAgICAgIHZhciBsaW5lID0gYnVmZmVyLnN1YnN0cigwLCBwb3MpO1xuICAgICAgLy8gQWR2YW5jZSB0aGUgYnVmZmVyIGVhcmx5IGluIGNhc2Ugd2UgZmFpbCBiZWxvdy5cbiAgICAgIGlmIChidWZmZXJbcG9zXSA9PT0gJ1xccicpIHtcbiAgICAgICAgKytwb3M7XG4gICAgICB9XG4gICAgICBpZiAoYnVmZmVyW3Bvc10gPT09ICdcXG4nKSB7XG4gICAgICAgICsrcG9zO1xuICAgICAgfVxuICAgICAgc2VsZi5idWZmZXIgPSBidWZmZXIuc3Vic3RyKHBvcyk7XG4gICAgICByZXR1cm4gbGluZTtcbiAgICB9XG5cbiAgICAvLyAzLjIgV2ViVlRUIG1ldGFkYXRhIGhlYWRlciBzeW50YXhcbiAgICBmdW5jdGlvbiBwYXJzZUhlYWRlcihpbnB1dCkge1xuICAgICAgcGFyc2VPcHRpb25zKGlucHV0LCBmdW5jdGlvbihrLCB2KSB7XG4gICAgICAgIHN3aXRjaCAoaykge1xuICAgICAgICAgIGNhc2UgJ1JlZ2lvbic6XG4gICAgICAgICAgICAvLyAzLjMgV2ViVlRUIHJlZ2lvbiBtZXRhZGF0YSBoZWFkZXIgc3ludGF4XG4gICAgICAgICAgICBjb25zb2xlLmxvZygncGFyc2UgcmVnaW9uJywgdik7XG4gICAgICAgICAgICAvL3BhcnNlUmVnaW9uKHYpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0sIC86Lyk7XG4gICAgfVxuXG4gICAgLy8gNS4xIFdlYlZUVCBmaWxlIHBhcnNpbmcuXG4gICAgdHJ5IHtcbiAgICAgIHZhciBsaW5lO1xuICAgICAgaWYgKHNlbGYuc3RhdGUgPT09ICdJTklUSUFMJykge1xuICAgICAgICAvLyBXZSBjYW4ndCBzdGFydCBwYXJzaW5nIHVudGlsIHdlIGhhdmUgdGhlIGZpcnN0IGxpbmUuXG4gICAgICAgIGlmICghL1xcclxcbnxcXG4vLnRlc3Qoc2VsZi5idWZmZXIpKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBsaW5lID0gY29sbGVjdE5leHRMaW5lKCk7XG5cbiAgICAgICAgdmFyIG0gPSBsaW5lLm1hdGNoKC9eV0VCVlRUKFsgXFx0XS4qKT8kLyk7XG4gICAgICAgIGlmICghbSB8fCAhbVswXSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWFsZm9ybWVkIFdlYlZUVCBzaWduYXR1cmUuJyk7XG4gICAgICAgIH1cblxuICAgICAgICBzZWxmLnN0YXRlID0gJ0hFQURFUic7XG4gICAgICB9XG5cbiAgICAgIHZhciBhbHJlYWR5Q29sbGVjdGVkTGluZSA9IGZhbHNlO1xuICAgICAgd2hpbGUgKHNlbGYuYnVmZmVyKSB7XG4gICAgICAgIC8vIFdlIGNhbid0IHBhcnNlIGEgbGluZSB1bnRpbCB3ZSBoYXZlIHRoZSBmdWxsIGxpbmUuXG4gICAgICAgIGlmICghL1xcclxcbnxcXG4vLnRlc3Qoc2VsZi5idWZmZXIpKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWFscmVhZHlDb2xsZWN0ZWRMaW5lKSB7XG4gICAgICAgICAgbGluZSA9IGNvbGxlY3ROZXh0TGluZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFscmVhZHlDb2xsZWN0ZWRMaW5lID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBzd2l0Y2ggKHNlbGYuc3RhdGUpIHtcbiAgICAgICAgICBjYXNlICdIRUFERVInOlxuICAgICAgICAgICAgLy8gMTMtMTggLSBBbGxvdyBhIGhlYWRlciAobWV0YWRhdGEpIHVuZGVyIHRoZSBXRUJWVFQgbGluZS5cbiAgICAgICAgICAgIGlmICgvOi8udGVzdChsaW5lKSkge1xuICAgICAgICAgICAgICBwYXJzZUhlYWRlcihsaW5lKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIWxpbmUpIHtcbiAgICAgICAgICAgICAgLy8gQW4gZW1wdHkgbGluZSB0ZXJtaW5hdGVzIHRoZSBoZWFkZXIgYW5kIHN0YXJ0cyB0aGUgYm9keSAoY3VlcykuXG4gICAgICAgICAgICAgIHNlbGYuc3RhdGUgPSAnSUQnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgY2FzZSAnTk9URSc6XG4gICAgICAgICAgICAvLyBJZ25vcmUgTk9URSBibG9ja3MuXG4gICAgICAgICAgICBpZiAoIWxpbmUpIHtcbiAgICAgICAgICAgICAgc2VsZi5zdGF0ZSA9ICdJRCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICBjYXNlICdJRCc6XG4gICAgICAgICAgICAvLyBDaGVjayBmb3IgdGhlIHN0YXJ0IG9mIE5PVEUgYmxvY2tzLlxuICAgICAgICAgICAgaWYgKC9eTk9URSgkfFsgXFx0XSkvLnRlc3QobGluZSkpIHtcbiAgICAgICAgICAgICAgc2VsZi5zdGF0ZSA9ICdOT1RFJztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyAxOS0yOSAtIEFsbG93IGFueSBudW1iZXIgb2YgbGluZSB0ZXJtaW5hdG9ycywgdGhlbiBpbml0aWFsaXplIG5ldyBjdWUgdmFsdWVzLlxuICAgICAgICAgICAgaWYgKCFsaW5lKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZi5jdWUgPSBuZXcgVlRUQ3VlKDAsIDAsICcnKTtcbiAgICAgICAgICAgIHNlbGYuc3RhdGUgPSAnQ1VFJztcbiAgICAgICAgICAgIC8vIDMwLTM5IC0gQ2hlY2sgaWYgc2VsZiBsaW5lIGNvbnRhaW5zIGFuIG9wdGlvbmFsIGlkZW50aWZpZXIgb3IgdGltaW5nIGRhdGEuXG4gICAgICAgICAgICBpZiAobGluZS5pbmRleE9mKCctLT4nKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgc2VsZi5jdWUuaWQgPSBsaW5lO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAvLyBQcm9jZXNzIGxpbmUgYXMgc3RhcnQgb2YgYSBjdWUuXG4gICAgICAgICAgLypmYWxscyB0aHJvdWdoKi9cbiAgICAgICAgICBjYXNlICdDVUUnOlxuICAgICAgICAgICAgLy8gNDAgLSBDb2xsZWN0IGN1ZSB0aW1pbmdzIGFuZCBzZXR0aW5ncy5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHBhcnNlQ3VlKGxpbmUsIHNlbGYuY3VlLCBzZWxmLnJlZ2lvbkxpc3QpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAvLyBJbiBjYXNlIG9mIGFuIGVycm9yIGlnbm9yZSByZXN0IG9mIHRoZSBjdWUuXG4gICAgICAgICAgICAgIHNlbGYuY3VlID0gbnVsbDtcbiAgICAgICAgICAgICAgc2VsZi5zdGF0ZSA9ICdCQURDVUUnO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGYuc3RhdGUgPSAnQ1VFVEVYVCc7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICBjYXNlICdDVUVURVhUJzpcbiAgICAgICAgICAgIHZhciBoYXNTdWJzdHJpbmcgPSBsaW5lLmluZGV4T2YoJy0tPicpICE9PSAtMTtcbiAgICAgICAgICAgIC8vIDM0IC0gSWYgd2UgaGF2ZSBhbiBlbXB0eSBsaW5lIHRoZW4gcmVwb3J0IHRoZSBjdWUuXG4gICAgICAgICAgICAvLyAzNSAtIElmIHdlIGhhdmUgdGhlIHNwZWNpYWwgc3Vic3RyaW5nICctLT4nIHRoZW4gcmVwb3J0IHRoZSBjdWUsXG4gICAgICAgICAgICAvLyBidXQgZG8gbm90IGNvbGxlY3QgdGhlIGxpbmUgYXMgd2UgbmVlZCB0byBwcm9jZXNzIHRoZSBjdXJyZW50XG4gICAgICAgICAgICAvLyBvbmUgYXMgYSBuZXcgY3VlLlxuICAgICAgICAgICAgaWYgKCFsaW5lIHx8IGhhc1N1YnN0cmluZyAmJiAoYWxyZWFkeUNvbGxlY3RlZExpbmUgPSB0cnVlKSkge1xuICAgICAgICAgICAgICAvLyBXZSBhcmUgZG9uZSBwYXJzaW5nIHNlbGYgY3VlLlxuICAgICAgICAgICAgICBpZiAoc2VsZi5vbmN1ZSkge1xuICAgICAgICAgICAgICAgIHNlbGYub25jdWUoc2VsZi5jdWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHNlbGYuY3VlID0gbnVsbDtcbiAgICAgICAgICAgICAgc2VsZi5zdGF0ZSA9ICdJRCc7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlbGYuY3VlLnRleHQpIHtcbiAgICAgICAgICAgICAgc2VsZi5jdWUudGV4dCArPSAnXFxuJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGYuY3VlLnRleHQgKz0gbGluZTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIGNhc2UgJ0JBRENVRSc6IC8vIEJBRENVRVxuICAgICAgICAgICAgLy8gNTQtNjIgLSBDb2xsZWN0IGFuZCBkaXNjYXJkIHRoZSByZW1haW5pbmcgY3VlLlxuICAgICAgICAgICAgaWYgKCFsaW5lKSB7XG4gICAgICAgICAgICAgIHNlbGYuc3RhdGUgPSAnSUQnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG5cbiAgICAgIC8vIElmIHdlIGFyZSBjdXJyZW50bHkgcGFyc2luZyBhIGN1ZSwgcmVwb3J0IHdoYXQgd2UgaGF2ZS5cbiAgICAgIGlmIChzZWxmLnN0YXRlID09PSAnQ1VFVEVYVCcgJiYgc2VsZi5jdWUgJiYgc2VsZi5vbmN1ZSkge1xuICAgICAgICBzZWxmLm9uY3VlKHNlbGYuY3VlKTtcbiAgICAgIH1cbiAgICAgIHNlbGYuY3VlID0gbnVsbDtcbiAgICAgIC8vIEVudGVyIEJBRFdFQlZUVCBzdGF0ZSBpZiBoZWFkZXIgd2FzIG5vdCBwYXJzZWQgY29ycmVjdGx5IG90aGVyd2lzZVxuICAgICAgLy8gYW5vdGhlciBleGNlcHRpb24gb2NjdXJyZWQgc28gZW50ZXIgQkFEQ1VFIHN0YXRlLlxuICAgICAgc2VsZi5zdGF0ZSA9IHNlbGYuc3RhdGUgPT09ICdJTklUSUFMJyA/ICdCQURXRUJWVFQnIDogJ0JBRENVRSc7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBmbHVzaDogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRyeSB7XG4gICAgICAvLyBGaW5pc2ggZGVjb2RpbmcgdGhlIHN0cmVhbS5cbiAgICAgIHNlbGYuYnVmZmVyICs9IHNlbGYuZGVjb2Rlci5kZWNvZGUoKTtcbiAgICAgIC8vIFN5bnRoZXNpemUgdGhlIGVuZCBvZiB0aGUgY3VycmVudCBjdWUgb3IgcmVnaW9uLlxuICAgICAgaWYgKHNlbGYuY3VlIHx8IHNlbGYuc3RhdGUgPT09ICdIRUFERVInKSB7XG4gICAgICAgIHNlbGYuYnVmZmVyICs9ICdcXG5cXG4nO1xuICAgICAgICBzZWxmLnBhcnNlKCk7XG4gICAgICB9XG4gICAgICAvLyBJZiB3ZSd2ZSBmbHVzaGVkLCBwYXJzZWQsIGFuZCB3ZSdyZSBzdGlsbCBvbiB0aGUgSU5JVElBTCBzdGF0ZSB0aGVuXG4gICAgICAvLyB0aGF0IG1lYW5zIHdlIGRvbid0IGhhdmUgZW5vdWdoIG9mIHRoZSBzdHJlYW0gdG8gcGFyc2UgdGhlIGZpcnN0XG4gICAgICAvLyBsaW5lLlxuICAgICAgaWYgKHNlbGYuc3RhdGUgPT09ICdJTklUSUFMJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01hbGZvcm1lZCBXZWJWVFQgc2lnbmF0dXJlLicpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IGU7XG4gICAgfVxuICAgIGlmIChzZWxmLm9uZmx1c2gpIHtcbiAgICAgIHNlbGYub25mbHVzaCgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxufTtcblxuZXhwb3J0IHsgZml4TGluZUJyZWFrcyB9O1xuXG5leHBvcnQgZGVmYXVsdCBWVFRQYXJzZXI7XG4iLCJpbXBvcnQgVlRUUGFyc2VyIGZyb20gJy4vdnR0cGFyc2VyJztcblxuY29uc3QgY3VlU3RyaW5nMm1pbGxpcyA9IGZ1bmN0aW9uKHRpbWVTdHJpbmcpIHtcbiAgICBsZXQgdHMgPSBwYXJzZUludCh0aW1lU3RyaW5nLnN1YnN0cigtMykpO1xuICAgIGxldCBzZWNzID0gcGFyc2VJbnQodGltZVN0cmluZy5zdWJzdHIoLTYsMikpO1xuICAgIGxldCBtaW5zID0gcGFyc2VJbnQodGltZVN0cmluZy5zdWJzdHIoLTksMikpO1xuICAgIGxldCBob3VycyA9IHRpbWVTdHJpbmcubGVuZ3RoID4gOSA/IHBhcnNlSW50KHRpbWVTdHJpbmcuc3Vic3RyKDAsIHRpbWVTdHJpbmcuaW5kZXhPZignOicpKSkgOiAwO1xuXG4gICAgaWYgKGlzTmFOKHRzKSB8fCBpc05hTihzZWNzKSB8fCBpc05hTihtaW5zKSB8fCBpc05hTihob3VycykpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIHRzICs9IDEwMDAgKiBzZWNzO1xuICAgIHRzICs9IDYwKjEwMDAgKiBtaW5zO1xuICAgIHRzICs9IDYwKjYwKjEwMDAgKiBob3VycztcblxuICAgIHJldHVybiB0cztcbn07XG5cbmNvbnN0IGNhbGN1bGF0ZU9mZnNldCA9IGZ1bmN0aW9uKHZ0dENDcywgY2MsIHByZXNlbnRhdGlvblRpbWUpIHtcbiAgICBsZXQgY3VyckNDID0gdnR0Q0NzW2NjXTtcbiAgICBsZXQgcHJldkNDID0gdnR0Q0NzW2N1cnJDQy5wcmV2Q0NdO1xuXG4gICAgLy8gVGhpcyBpcyB0aGUgZmlyc3QgZGlzY29udGludWl0eSBvciBjdWVzIGhhdmUgYmVlbiBwcm9jZXNzZWQgc2luY2UgdGhlIGxhc3QgZGlzY29udGludWl0eVxuICAgIC8vIE9mZnNldCA9IGN1cnJlbnQgZGlzY29udGludWl0eSB0aW1lXG4gICAgaWYgKCFwcmV2Q0MgfHwgKCFwcmV2Q0MubmV3ICYmIGN1cnJDQy5uZXcpKSB7XG4gICAgICAgIHZ0dENDcy5jY09mZnNldCA9IHZ0dENDcy5wcmVzZW50YXRpb25PZmZzZXQgPSBjdXJyQ0Muc3RhcnQ7XG4gICAgICAgIGN1cnJDQy5uZXcgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFRoZXJlIGhhdmUgYmVlbiBkaXNjb250aW51aXRpZXMgc2luY2UgY3VlcyB3ZXJlIGxhc3QgcGFyc2VkLlxuICAgIC8vIE9mZnNldCA9IHRpbWUgZWxhcHNlZFxuICAgIHdoaWxlIChwcmV2Q0MgJiYgcHJldkNDLm5ldykge1xuICAgICAgICB2dHRDQ3MuY2NPZmZzZXQgKz0gY3VyckNDLnN0YXJ0IC0gcHJldkNDLnN0YXJ0O1xuICAgICAgICBjdXJyQ0MubmV3ID0gZmFsc2U7XG4gICAgICAgIGN1cnJDQyA9IHByZXZDQztcbiAgICAgICAgcHJldkNDID0gdnR0Q0NzW2N1cnJDQy5wcmV2Q0NdO1xuICAgIH1cblxuICAgIHZ0dENDcy5wcmVzZW50YXRpb25PZmZzZXQgPSBwcmVzZW50YXRpb25UaW1lO1xufTtcblxuY29uc3QgV2ViVlRUUGFyc2VyID0ge1xuICAgIHBhcnNlOiBmdW5jdGlvbih2dHRCeXRlQXJyYXksIHN5bmNQVFMsIHZ0dENDcywgY2MsIGNhbGxCYWNrLCBlcnJvckNhbGxCYWNrKSB7XG4gICAgICAgIC8vIENvbnZlcnQgYnl0ZUFycmF5IGludG8gc3RyaW5nLCByZXBsYWNpbmcgYW55IHNvbWV3aGF0IGV4b3RpYyBsaW5lZmVlZHMgd2l0aCBcIlxcblwiLCB0aGVuIHNwbGl0IG9uIHRoYXQgY2hhcmFjdGVyLlxuICAgICAgICBsZXQgcmUgPSAvXFxyXFxufFxcblxccnxcXG58XFxyL2c7XG4gICAgICAgIGxldCB2dHRMaW5lcyA9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgbmV3IFVpbnQ4QXJyYXkodnR0Qnl0ZUFycmF5KSkudHJpbSgpLnJlcGxhY2UocmUsICdcXG4nKS5zcGxpdCgnXFxuJyk7XG4gICAgICAgIGxldCBjdWVUaW1lID0gJzAwOjAwLjAwMCc7XG4gICAgICAgIGxldCBtcGVnVHMgPSAwO1xuICAgICAgICBsZXQgbG9jYWxUaW1lID0gMDtcbiAgICAgICAgbGV0IHByZXNlbnRhdGlvblRpbWUgPSAwO1xuICAgICAgICBsZXQgY3VlcyA9IFtdO1xuICAgICAgICBsZXQgcGFyc2luZ0Vycm9yO1xuICAgICAgICBsZXQgaW5IZWFkZXIgPSB0cnVlO1xuICAgICAgICAvLyBsZXQgVlRUQ3VlID0gVlRUQ3VlIHx8IHdpbmRvdy5UZXh0VHJhY2tDdWU7XG5cbiAgICAgICAgLy8gQ3JlYXRlIHBhcnNlciBvYmplY3QgdXNpbmcgVlRUQ3VlIHdpdGggVGV4dFRyYWNrQ3VlIGZhbGxiYWNrIG9uIGNlcnRhaW4gYnJvd3NlcnMuXG4gICAgICAgIGxldCBwYXJzZXIgPSBuZXcgVlRUUGFyc2VyKCk7XG5cbiAgICAgICAgcGFyc2VyLm9uY3VlID0gZnVuY3Rpb24oY3VlKSB7XG4gICAgICAgICAgICAvLyBBZGp1c3QgY3VlIHRpbWluZzsgY2xhbXAgY3VlcyB0byBzdGFydCBubyBlYXJsaWVyIHRoYW4gLSBhbmQgZHJvcCBjdWVzIHRoYXQgZG9uJ3QgZW5kIGFmdGVyIC0gMCBvbiB0aW1lbGluZS5cbiAgICAgICAgICAgIGxldCBjdXJyQ0MgPSB2dHRDQ3NbY2NdO1xuICAgICAgICAgICAgbGV0IGN1ZU9mZnNldCA9IHZ0dENDcy5jY09mZnNldDtcblxuICAgICAgICAgICAgLy8gVXBkYXRlIG9mZnNldHMgZm9yIG5ldyBkaXNjb250aW51aXRpZXNcbiAgICAgICAgICAgIGlmIChjdXJyQ0MgJiYgY3VyckNDLm5ldykge1xuICAgICAgICAgICAgICAgIGlmIChsb2NhbFRpbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2hlbiBsb2NhbCB0aW1lIGlzIHByb3ZpZGVkLCBvZmZzZXQgPSBkaXNjb250aW51aXR5IHN0YXJ0IHRpbWUgLSBsb2NhbCB0aW1lXG4gICAgICAgICAgICAgICAgICAgIGN1ZU9mZnNldCA9IHZ0dENDcy5jY09mZnNldCA9IGN1cnJDQy5zdGFydDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjYWxjdWxhdGVPZmZzZXQodnR0Q0NzLCBjYywgcHJlc2VudGF0aW9uVGltZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocHJlc2VudGF0aW9uVGltZSAmJiAhbG9jYWxUaW1lKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgaGF2ZSBNUEVHVFMgYnV0IG5vIExPQ0FMIHRpbWUsIG9mZnNldCA9IHByZXNlbnRhdGlvbiB0aW1lICsgZGlzY29udGludWl0eSBvZmZzZXRcbiAgICAgICAgICAgICAgICBjdWVPZmZzZXQgPSBwcmVzZW50YXRpb25UaW1lICsgdnR0Q0NzLmNjT2Zmc2V0IC0gdnR0Q0NzLnByZXNlbnRhdGlvbk9mZnNldDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY3VlLnN0YXJ0VGltZSArPSBjdWVPZmZzZXQgLSBsb2NhbFRpbWU7XG4gICAgICAgICAgICBjdWUuZW5kVGltZSArPSBjdWVPZmZzZXQgLSBsb2NhbFRpbWU7XG5cbiAgICAgICAgICAgIC8vIEZpeCBlbmNvZGluZyBvZiBzcGVjaWFsIGNoYXJhY3RlcnMuIFRPRE86IFRlc3Qgd2l0aCBhbGwgc29ydHMgb2Ygd2VpcmQgY2hhcmFjdGVycy5cbiAgICAgICAgICAgIGN1ZS50ZXh0ID0gZGVjb2RlVVJJQ29tcG9uZW50KGVzY2FwZShjdWUudGV4dCkpO1xuICAgICAgICAgICAgaWYgKGN1ZS5lbmRUaW1lID4gMCkge1xuICAgICAgICAgICAgICBjdWVzLnB1c2goY3VlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBwYXJzZXIub25wYXJzaW5nZXJyb3IgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBwYXJzaW5nRXJyb3IgPSBlO1xuICAgICAgICB9O1xuXG4gICAgICAgIHBhcnNlci5vbmZsdXNoID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAocGFyc2luZ0Vycm9yICYmIGVycm9yQ2FsbEJhY2spIHtcbiAgICAgICAgICAgICAgICBlcnJvckNhbGxCYWNrKHBhcnNpbmdFcnJvcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FsbEJhY2soY3Vlcyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gR28gdGhyb3VnaCBjb250ZW50cyBsaW5lIGJ5IGxpbmUuXG4gICAgICAgIHZ0dExpbmVzLmZvckVhY2gobGluZSA9PiB7XG4gICAgICAgICAgICBpZiAoaW5IZWFkZXIpIHtcbiAgICAgICAgICAgICAgICAvLyBMb29rIGZvciBYLVRJTUVTVEFNUC1NQVAgaW4gaGVhZGVyLlxuICAgICAgICAgICAgICAgIGlmIChsaW5lLnN0YXJ0c1dpdGgoJ1gtVElNRVNUQU1QLU1BUD0nKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBPbmNlIGZvdW5kLCBubyBtb3JlIGFyZSBhbGxvd2VkIGFueXdheSwgc28gc3RvcCBzZWFyY2hpbmcuXG4gICAgICAgICAgICAgICAgICAgIGluSGVhZGVyID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIC8vIEV4dHJhY3QgTE9DQUwgYW5kIE1QRUdUUy5cbiAgICAgICAgICAgICAgICAgICAgbGluZS5zdWJzdHIoMTYpLnNwbGl0KCcsJykuZm9yRWFjaCh0aW1lc3RhbXAgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRpbWVzdGFtcC5zdGFydHNXaXRoKCdMT0NBTDonKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjdWVUaW1lID0gdGltZXN0YW1wLnN1YnN0cig2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGltZXN0YW1wLnN0YXJ0c1dpdGgoJ01QRUdUUzonKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBtcGVnVHMgPSBwYXJzZUludCh0aW1lc3RhbXAuc3Vic3RyKDcpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDYWxjdWxhdGUgc3VidGl0bGUgb2Zmc2V0IGluIG1pbGxpc2Vjb25kcy5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHN5bmMgUFRTIGlzIGxlc3MgdGhhbiB6ZXJvLCB3ZSBoYXZlIGEgMzMtYml0IHdyYXBhcm91bmQsIHdoaWNoIGlzIGZpeGVkIGJ5IGFkZGluZyAyXjMzID0gODU4OTkzNDU5Mi5cbiAgICAgICAgICAgICAgICAgICAgICAgIHN5bmNQVFMgPSBzeW5jUFRTIDwgMCA/IHN5bmNQVFMgKyA4NTg5OTM0NTkyIDogc3luY1BUUztcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkanVzdCBNUEVHVFMgYnkgc3luYyBQVFMuXG4gICAgICAgICAgICAgICAgICAgICAgICBtcGVnVHMgLT0gc3luY1BUUztcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvbnZlcnQgY3VlIHRpbWUgdG8gc2Vjb25kc1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxUaW1lID0gY3VlU3RyaW5nMm1pbGxpcyhjdWVUaW1lKSAvIDEwMDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDb252ZXJ0IE1QRUdUUyB0byBzZWNvbmRzIGZyb20gOTBrSHouXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVzZW50YXRpb25UaW1lID0gbXBlZ1RzIC8gOTAwMDA7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsb2NhbFRpbWUgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2luZ0Vycm9yID0gbmV3IEVycm9yKGBNYWxmb3JtZWQgWC1USU1FU1RBTVAtTUFQOiAke2xpbmV9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2goZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2luZ0Vycm9yID0gbmV3IEVycm9yKGBNYWxmb3JtZWQgWC1USU1FU1RBTVAtTUFQOiAke2xpbmV9YCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gUmV0dXJuIHdpdGhvdXQgcGFyc2luZyBYLVRJTUVTVEFNUC1NQVAgbGluZS5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobGluZSA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICAgIGluSGVhZGVyID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUGFyc2UgbGluZSBieSBkZWZhdWx0LlxuICAgICAgICAgICAgcGFyc2VyLnBhcnNlKGxpbmUrJ1xcbicpO1xuICAgICAgICB9KTtcblxuICAgICAgICBwYXJzZXIuZmx1c2goKTtcbiAgICB9XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gV2ViVlRUUGFyc2VyO1xuIiwiLyoqXG4gKiBYSFIgYmFzZWQgbG9nZ2VyXG4qL1xuXG5pbXBvcnQge2xvZ2dlcn0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcblxuY2xhc3MgWGhyTG9hZGVyIHtcblxuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICBpZiAoY29uZmlnICYmIGNvbmZpZy54aHJTZXR1cCkge1xuICAgICAgdGhpcy54aHJTZXR1cCA9IGNvbmZpZy54aHJTZXR1cDtcbiAgICB9XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuYWJvcnQoKTtcbiAgICB0aGlzLmxvYWRlciA9IG51bGw7XG4gIH1cblxuICBhYm9ydCgpIHtcbiAgICB2YXIgbG9hZGVyID0gdGhpcy5sb2FkZXI7XG4gICAgaWYgKGxvYWRlciAmJiBsb2FkZXIucmVhZHlTdGF0ZSAhPT0gNCkge1xuICAgICAgdGhpcy5zdGF0cy5hYm9ydGVkID0gdHJ1ZTtcbiAgICAgIGxvYWRlci5hYm9ydCgpO1xuICAgIH1cblxuICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGhpcy5yZXF1ZXN0VGltZW91dCk7XG4gICAgdGhpcy5yZXF1ZXN0VGltZW91dCA9IG51bGw7XG4gICAgd2luZG93LmNsZWFyVGltZW91dCh0aGlzLnJldHJ5VGltZW91dCk7XG4gICAgdGhpcy5yZXRyeVRpbWVvdXQgPSBudWxsO1xuICB9XG5cbiAgbG9hZChjb250ZXh0LCBjb25maWcsIGNhbGxiYWNrcykge1xuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgdGhpcy5jYWxsYmFja3MgPSBjYWxsYmFja3M7XG4gICAgdGhpcy5zdGF0cyA9IHt0cmVxdWVzdDogcGVyZm9ybWFuY2Uubm93KCksIHJldHJ5OiAwfTtcbiAgICB0aGlzLnJldHJ5RGVsYXkgPSBjb25maWcucmV0cnlEZWxheTtcbiAgICB0aGlzLmxvYWRJbnRlcm5hbCgpO1xuICB9XG5cbiAgbG9hZEludGVybmFsKCkge1xuICAgIHZhciB4aHIsIGNvbnRleHQgPSB0aGlzLmNvbnRleHQ7XG5cbiAgICBpZiAodHlwZW9mIFhEb21haW5SZXF1ZXN0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgIHhociA9IHRoaXMubG9hZGVyID0gbmV3IFhEb21haW5SZXF1ZXN0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICB4aHIgPSB0aGlzLmxvYWRlciA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgIH1cblxuICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSB0aGlzLnJlYWR5c3RhdGVjaGFuZ2UuYmluZCh0aGlzKTtcbiAgICB4aHIub25wcm9ncmVzcyA9IHRoaXMubG9hZHByb2dyZXNzLmJpbmQodGhpcyk7XG5cbiAgICB4aHIub3BlbignR0VUJywgY29udGV4dC51cmwsIHRydWUpO1xuXG4gICAgaWYgKGNvbnRleHQucmFuZ2VFbmQpIHtcbiAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdSYW5nZScsJ2J5dGVzPScgKyBjb250ZXh0LnJhbmdlU3RhcnQgKyAnLScgKyAoY29udGV4dC5yYW5nZUVuZC0xKSk7XG4gICAgfVxuICAgIHhoci5yZXNwb25zZVR5cGUgPSBjb250ZXh0LnJlc3BvbnNlVHlwZTtcbiAgICBsZXQgc3RhdHMgPSB0aGlzLnN0YXRzO1xuICAgIHN0YXRzLnRmaXJzdCA9IDA7XG4gICAgc3RhdHMubG9hZGVkID0gMDtcbiAgICBpZiAodGhpcy54aHJTZXR1cCkge1xuICAgICAgdGhpcy54aHJTZXR1cCh4aHIsIGNvbnRleHQudXJsKTtcbiAgICB9XG4gICAgLy8gc2V0dXAgdGltZW91dCBiZWZvcmUgd2UgcGVyZm9ybSByZXF1ZXN0XG4gICAgdGhpcy5yZXF1ZXN0VGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KHRoaXMubG9hZHRpbWVvdXQuYmluZCh0aGlzKSwgdGhpcy5jb25maWcudGltZW91dCk7XG4gICAgeGhyLnNlbmQoKTtcbiAgfVxuXG4gIHJlYWR5c3RhdGVjaGFuZ2UoZXZlbnQpIHtcbiAgICB2YXIgeGhyID0gZXZlbnQuY3VycmVudFRhcmdldCxcbiAgICAgICAgcmVhZHlTdGF0ZSA9IHhoci5yZWFkeVN0YXRlLFxuICAgICAgICBzdGF0cyA9IHRoaXMuc3RhdHMsXG4gICAgICAgIGNvbnRleHQgPSB0aGlzLmNvbnRleHQsXG4gICAgICAgIGNvbmZpZyA9IHRoaXMuY29uZmlnO1xuXG4gICAgLy8gZG9uJ3QgcHJvY2VlZCBpZiB4aHIgaGFzIGJlZW4gYWJvcnRlZFxuICAgIGlmIChzdGF0cy5hYm9ydGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gaW4gYW55IGNhc2UgY2xlYXIgdGhlIGN1cnJlbnQgeGhycyB0aW1lb3V0XG4gICAgd2luZG93LmNsZWFyVGltZW91dCh0aGlzLnJlcXVlc3RUaW1lb3V0KTtcblxuICAgIC8vIEhFQURFUlNfUkVDRUlWRURcbiAgICBpZiAocmVhZHlTdGF0ZSA+PTIpIHtcbiAgICAgIGlmIChzdGF0cy50Zmlyc3QgPT09IDApIHtcbiAgICAgICAgc3RhdHMudGZpcnN0ID0gTWF0aC5tYXgocGVyZm9ybWFuY2Uubm93KCksIHN0YXRzLnRyZXF1ZXN0KTtcbiAgICAgICAgLy8gcmVzZXQgdGltZW91dCB0byB0b3RhbCB0aW1lb3V0IGR1cmF0aW9uIG1pbnVzIHRoZSB0aW1lIGl0IHRvb2sgdG8gcmVjZWl2ZSBoZWFkZXJzXG4gICAgICAgIHRoaXMucmVxdWVzdFRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dCh0aGlzLmxvYWR0aW1lb3V0LmJpbmQodGhpcyksIGNvbmZpZy50aW1lb3V0IC0gKHN0YXRzLnRmaXJzdC1zdGF0cy50cmVxdWVzdCkpO1xuICAgICAgfVxuICAgICAgaWYgKHJlYWR5U3RhdGUgPT09IDQpIHtcbiAgICAgICAgbGV0IHN0YXR1cyA9IHhoci5zdGF0dXM7XG4gICAgICAgIC8vIGh0dHAgc3RhdHVzIGJldHdlZW4gMjAwIHRvIDI5OSBhcmUgYWxsIHN1Y2Nlc3NmdWxcbiAgICAgICAgaWYgKHN0YXR1cyA+PSAyMDAgJiYgc3RhdHVzIDwgMzAwKSAge1xuICAgICAgICAgIHN0YXRzLnRsb2FkID0gTWF0aC5tYXgoc3RhdHMudGZpcnN0LHBlcmZvcm1hbmNlLm5vdygpKTtcbiAgICAgICAgICBsZXQgZGF0YSxsZW47XG4gICAgICAgICAgaWYgKGNvbnRleHQucmVzcG9uc2VUeXBlID09PSAnYXJyYXlidWZmZXInKSB7XG4gICAgICAgICAgICBkYXRhID0geGhyLnJlc3BvbnNlO1xuICAgICAgICAgICAgbGVuID0gZGF0YS5ieXRlTGVuZ3RoO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkYXRhID0geGhyLnJlc3BvbnNlVGV4dDtcbiAgICAgICAgICAgIGxlbiA9IGRhdGEubGVuZ3RoO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzdGF0cy5sb2FkZWQgPSBzdGF0cy50b3RhbCA9IGxlbjtcbiAgICAgICAgICBsZXQgcmVzcG9uc2UgPSB7IHVybCA6IHhoci5yZXNwb25zZVVSTCwgZGF0YSA6IGRhdGEgfTtcbiAgICAgICAgICB0aGlzLmNhbGxiYWNrcy5vblN1Y2Nlc3MocmVzcG9uc2UsIHN0YXRzLCBjb250ZXh0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGlmIG1heCBuYiBvZiByZXRyaWVzIHJlYWNoZWQgb3IgaWYgaHR0cCBzdGF0dXMgYmV0d2VlbiA0MDAgYW5kIDQ5OSAoc3VjaCBlcnJvciBjYW5ub3QgYmUgcmVjb3ZlcmVkLCByZXRyeWluZyBpcyB1c2VsZXNzKSwgcmV0dXJuIGVycm9yXG4gICAgICAgICAgaWYgKHN0YXRzLnJldHJ5ID49IGNvbmZpZy5tYXhSZXRyeSB8fCAoc3RhdHVzID49IDQwMCAmJiBzdGF0dXMgPCA0OTkpKSB7XG4gICAgICAgICAgICBsb2dnZXIuZXJyb3IoYCR7c3RhdHVzfSB3aGlsZSBsb2FkaW5nICR7Y29udGV4dC51cmx9YCApO1xuICAgICAgICAgICAgdGhpcy5jYWxsYmFja3Mub25FcnJvcih7IGNvZGUgOiBzdGF0dXMsIHRleHQgOiB4aHIuc3RhdHVzVGV4dH0sIGNvbnRleHQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyByZXRyeVxuICAgICAgICAgICAgbG9nZ2VyLndhcm4oYCR7c3RhdHVzfSB3aGlsZSBsb2FkaW5nICR7Y29udGV4dC51cmx9LCByZXRyeWluZyBpbiAke3RoaXMucmV0cnlEZWxheX0uLi5gKTtcbiAgICAgICAgICAgIC8vIGFib3J0cyBhbmQgcmVzZXRzIGludGVybmFsIHN0YXRlXG4gICAgICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIC8vIHNjaGVkdWxlIHJldHJ5XG4gICAgICAgICAgICB0aGlzLnJldHJ5VGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KHRoaXMubG9hZEludGVybmFsLmJpbmQodGhpcyksIHRoaXMucmV0cnlEZWxheSk7XG4gICAgICAgICAgICAvLyBzZXQgZXhwb25lbnRpYWwgYmFja29mZlxuICAgICAgICAgICAgdGhpcy5yZXRyeURlbGF5ID0gTWF0aC5taW4oMiAqIHRoaXMucmV0cnlEZWxheSwgY29uZmlnLm1heFJldHJ5RGVsYXkpO1xuICAgICAgICAgICAgc3RhdHMucmV0cnkrKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBsb2FkdGltZW91dCgpIHtcbiAgICBsb2dnZXIud2FybihgdGltZW91dCB3aGlsZSBsb2FkaW5nICR7dGhpcy5jb250ZXh0LnVybH1gICk7XG4gICAgdGhpcy5jYWxsYmFja3Mub25UaW1lb3V0KHRoaXMuc3RhdHMsIHRoaXMuY29udGV4dCk7XG4gIH1cblxuICBsb2FkcHJvZ3Jlc3MoZXZlbnQpIHtcbiAgICB2YXIgc3RhdHMgPSB0aGlzLnN0YXRzO1xuICAgIHN0YXRzLmxvYWRlZCA9IGV2ZW50LmxvYWRlZDtcbiAgICBpZiAoZXZlbnQubGVuZ3RoQ29tcHV0YWJsZSkge1xuICAgICAgc3RhdHMudG90YWwgPSBldmVudC50b3RhbDtcbiAgICB9XG4gICAgbGV0IG9uUHJvZ3Jlc3MgPSB0aGlzLmNhbGxiYWNrcy5vblByb2dyZXNzO1xuICAgIGlmIChvblByb2dyZXNzKSB7XG4gICAgICAvLyBsYXN0IGFyZ3MgaXMgdG8gcHJvdmlkZSBvbiBwcm9ncmVzcyBkYXRhXG4gICAgICBvblByb2dyZXNzKHN0YXRzLCB0aGlzLmNvbnRleHQsIG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBYaHJMb2FkZXI7XG4iXX0=
