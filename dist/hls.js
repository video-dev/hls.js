(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.Hls = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      } else {
        // At least give some kind of context to the user
        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
        err.context = er;
        throw err;
      }
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    args = Array.prototype.slice.call(arguments, 1);
    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else if (listeners) {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.prototype.listenerCount = function(type) {
  if (this._events) {
    var evlistener = this._events[type];

    if (isFunction(evlistener))
      return 1;
    else if (evlistener)
      return evlistener.length;
  }
  return 0;
};

EventEmitter.listenerCount = function(emitter, type) {
  return emitter.listenerCount(type);
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],2:[function(require,module,exports){
/* jshint ignore:start */
(function(root) { 
/* jshint ignore:end */

  var HASH_SPLIT = /^([^#]*)(.*)$/;
  var QUERY_SPLIT = /^([^\?]*)(.*)$/;
  var DOMAIN_SPLIT = /^(((?:[a-z]+:)?\/\/)?[^:\/]+(?::[0-9]+)?)?(\/?.*)$/i;

  var URLToolkit = {
    // build an absolute URL from a relative one using the provided baseURL
    // if relativeURL is an absolute URL it will be returned as is.
    buildAbsoluteURL: function(baseURL, relativeURL) {
      // remove any remaining space and CRLF
      relativeURL = relativeURL.trim();
      if (/^[a-z]+:/i.test(relativeURL)) {
        // complete url, not relative
        return relativeURL;
      }

      var relativeURLQuery = null;
      var relativeURLHash = null;

      var relativeURLHashSplit = HASH_SPLIT.exec(relativeURL);
      if (relativeURLHashSplit) {
        relativeURLHash = relativeURLHashSplit[2];
        relativeURL = relativeURLHashSplit[1];
      }
      var relativeURLQuerySplit = QUERY_SPLIT.exec(relativeURL);
      if (relativeURLQuerySplit) {
        relativeURLQuery = relativeURLQuerySplit[2];
        relativeURL = relativeURLQuerySplit[1];
      }

      var baseURLHashSplit = HASH_SPLIT.exec(baseURL);
      if (baseURLHashSplit) {
        baseURL = baseURLHashSplit[1];
      }
      var baseURLQuerySplit = QUERY_SPLIT.exec(baseURL);
      if (baseURLQuerySplit) {
        baseURL = baseURLQuerySplit[1];
      }

      var baseURLDomainSplit = DOMAIN_SPLIT.exec(baseURL);
      if (!baseURLDomainSplit) {
        throw new Error('Error trying to parse base URL.');
      }
      
      // e.g. 'http://', 'https://', '//', ''
      var baseURLProtocol = baseURLDomainSplit[2] || '//'; // if there is no protocol default to '//'
      // e.g. 'http://example.com', '//example.com', 'example.com', ''
      var baseURLProtocolDomain = baseURLDomainSplit[1] || '';
      // e.g. '/a/b/c/playlist.m3u8', 'a/b/c/playlist.m3u8'
      var baseURLPath = baseURLDomainSplit[3];
      if (baseURLPath.indexOf('/') !== 0 && baseURLProtocolDomain !== '') {
        // this handles a base url of http://example.com (missing last slash)
        baseURLPath = '/'+baseURLPath;
      }

      var builtURL = null;
      if (/^\/\//.test(relativeURL)) {
        // relative url starts wth '//' so copy protocol
        builtURL = baseURLProtocol+URLToolkit.buildAbsolutePath('', relativeURL.substring(2));
      }
      else if (/^\//.test(relativeURL)) {
        // relative url starts with '/' so start from root of domain
        builtURL = baseURLProtocolDomain+'/'+URLToolkit.buildAbsolutePath('', relativeURL.substring(1));
      }
      else {
        builtURL = URLToolkit.buildAbsolutePath(baseURLProtocolDomain+baseURLPath, relativeURL);
      }

      // put the query and hash parts back
      if (relativeURLQuery) {
        builtURL += relativeURLQuery;
      }
      if (relativeURLHash) {
        builtURL += relativeURLHash;
      }
      return builtURL;
    },

    // build an absolute path using the provided basePath
    // adapted from https://developer.mozilla.org/en-US/docs/Web/API/document/cookie#Using_relative_URLs_in_the_path_parameter
    // this does not handle the case where relativePath is "/" or "//". These cases should be handled outside this.
    buildAbsolutePath: function(basePath, relativePath) {
      var sRelPath = relativePath;
      var nUpLn, sDir = '', sPath = basePath.replace(/[^\/]*$/, sRelPath.replace(/(\/|^)(?:\.?\/+)+/g, '$1'));
      for (var nEnd, nStart = 0; nEnd = sPath.indexOf('/../', nStart), nEnd > -1; nStart = nEnd + nUpLn) {
        nUpLn = /^\/(?:\.\.\/)*/.exec(sPath.slice(nEnd))[0].length;
        sDir = (sDir + sPath.substring(nStart, nEnd)).replace(new RegExp('(?:\\\/+[^\\\/]*){0,' + ((nUpLn - 1) / 3) + '}$'), '/');
      }
      return sDir + sPath.substr(nStart);
    }
  };

/* jshint ignore:start */
  if(typeof exports === 'object' && typeof module === 'object')
    module.exports = URLToolkit;
  else if(typeof define === 'function' && define.amd)
    define([], function() { return URLToolkit; });
  else if(typeof exports === 'object')
    exports["URLToolkit"] = URLToolkit;
  else
    root["URLToolkit"] = URLToolkit;
})(this);
/* jshint ignore:end */

},{}],3:[function(require,module,exports){
var bundleFn = arguments[3];
var sources = arguments[4];
var cache = arguments[5];

var stringify = JSON.stringify;

module.exports = function (fn, options) {
    var wkey;
    var cacheKeys = Object.keys(cache);

    for (var i = 0, l = cacheKeys.length; i < l; i++) {
        var key = cacheKeys[i];
        var exp = cache[key].exports;
        // Using babel as a transpiler to use esmodule, the export will always
        // be an object with the default export as a property of it. To ensure
        // the existing api and babel esmodule exports are both supported we
        // check for both
        if (exp === fn || exp && exp.default === fn) {
            wkey = key;
            break;
        }
    }

    if (!wkey) {
        wkey = Math.floor(Math.pow(16, 8) * Math.random()).toString(16);
        var wcache = {};
        for (var i = 0, l = cacheKeys.length; i < l; i++) {
            var key = cacheKeys[i];
            wcache[key] = key;
        }
        sources[wkey] = [
            Function(['require','module','exports'], '(' + fn + ')(self)'),
            wcache
        ];
    }
    var skey = Math.floor(Math.pow(16, 8) * Math.random()).toString(16);

    var scache = {}; scache[wkey] = wkey;
    sources[skey] = [
        Function(['require'], (
            // try to call default if defined to also support babel esmodule
            // exports
            'var f = require(' + stringify(wkey) + ');' +
            '(f.default ? f.default : f)(self);'
        )),
        scache
    ];

    var workerSources = {};
    resolveSources(skey);

    function resolveSources(key) {
        workerSources[key] = true;

        for (var depPath in sources[key][1]) {
            var depKey = sources[key][1][depPath];
            if (!workerSources[depKey]) {
                resolveSources(depKey);
            }
        }
    }

    var src = '(' + bundleFn + ')({'
        + Object.keys(workerSources).map(function (key) {
            return stringify(key) + ':['
                + sources[key][0]
                + ',' + stringify(sources[key][1]) + ']'
            ;
        }).join(',')
        + '},{},[' + stringify(skey) + '])'
    ;

    var URL = window.URL || window.webkitURL || window.mozURL || window.msURL;

    var blob = new Blob([src], { type: 'text/javascript' });
    if (options && options.bare) { return blob; }
    var workerUrl = URL.createObjectURL(blob);
    var worker = new Worker(workerUrl);
    worker.objectURL = workerUrl;
    return worker;
};

},{}],4:[function(require,module,exports){
/**
 * HLS config
 */
'use strict';

Object.defineProperty(exports, "__esModule", {
      value: true
});
exports.hlsDefaultConfig = undefined;

var _abrController = require('./controller/abr-controller');

var _abrController2 = _interopRequireDefault(_abrController);

var _bufferController = require('./controller/buffer-controller');

var _bufferController2 = _interopRequireDefault(_bufferController);

var _capLevelController = require('./controller/cap-level-controller');

var _capLevelController2 = _interopRequireDefault(_capLevelController);

var _fpsController = require('./controller/fps-controller');

var _fpsController2 = _interopRequireDefault(_fpsController);

var _xhrLoader = require('./utils/xhr-loader');

var _xhrLoader2 = _interopRequireDefault(_xhrLoader);

var _audioTrackController = require('./controller/audio-track-controller');

var _audioTrackController2 = _interopRequireDefault(_audioTrackController);

var _audioStreamController = require('./controller/audio-stream-controller');

var _audioStreamController2 = _interopRequireDefault(_audioStreamController);

var _cues = require('./utils/cues');

var _cues2 = _interopRequireDefault(_cues);

var _timelineController = require('./controller/timeline-controller');

var _timelineController2 = _interopRequireDefault(_timelineController);

var _subtitleTrackController = require('./controller/subtitle-track-controller');

var _subtitleTrackController2 = _interopRequireDefault(_subtitleTrackController);

var _subtitleStreamController = require('./controller/subtitle-stream-controller');

var _subtitleStreamController2 = _interopRequireDefault(_subtitleStreamController);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

//#endif

//#endif

//#if subtitle

//import FetchLoader from './utils/fetch-loader';
//#if altaudio
var hlsDefaultConfig = exports.hlsDefaultConfig = {
      autoStartLoad: true, // used by stream-controller
      startPosition: -1, // used by stream-controller
      defaultAudioCodec: undefined, // used by stream-controller
      debug: false, // used by logger
      capLevelOnFPSDrop: false, // used by fps-controller
      capLevelToPlayerSize: false, // used by cap-level-controller
      initialLiveManifestSize: 1, // used by stream-controller
      maxBufferLength: 30, // used by stream-controller
      maxBufferSize: 60 * 1000 * 1000, // used by stream-controller
      maxBufferHole: 0.5, // used by stream-controller
      maxSeekHole: 2, // used by stream-controller
      lowBufferWatchdogPeriod: 0.5, // used by stream-controller
      highBufferWatchdogPeriod: 3, // used by stream-controller
      nudgeOffset: 0.1, // used by stream-controller
      nudgeMaxRetry: 3, // used by stream-controller
      maxFragLookUpTolerance: 0.2, // used by stream-controller
      liveSyncDurationCount: 3, // used by stream-controller
      liveMaxLatencyDurationCount: Infinity, // used by stream-controller
      liveSyncDuration: undefined, // used by stream-controller
      liveMaxLatencyDuration: undefined, // used by stream-controller
      maxMaxBufferLength: 600, // used by stream-controller
      enableWorker: true, // used by demuxer
      enableSoftwareAES: true, // used by decrypter
      manifestLoadingTimeOut: 10000, // used by playlist-loader
      manifestLoadingMaxRetry: 1, // used by playlist-loader
      manifestLoadingRetryDelay: 1000, // used by playlist-loader
      manifestLoadingMaxRetryTimeout: 64000, // used by playlist-loader
      startLevel: undefined, // used by level-controller
      levelLoadingTimeOut: 10000, // used by playlist-loader
      levelLoadingMaxRetry: 4, // used by playlist-loader
      levelLoadingRetryDelay: 1000, // used by playlist-loader
      levelLoadingMaxRetryTimeout: 64000, // used by playlist-loader
      fragLoadingTimeOut: 20000, // used by fragment-loader
      fragLoadingMaxRetry: 6, // used by fragment-loader
      fragLoadingRetryDelay: 1000, // used by fragment-loader
      fragLoadingMaxRetryTimeout: 64000, // used by fragment-loader
      fragLoadingLoopThreshold: 3, // used by stream-controller
      startFragPrefetch: false, // used by stream-controller
      fpsDroppedMonitoringPeriod: 5000, // used by fps-controller
      fpsDroppedMonitoringThreshold: 0.2, // used by fps-controller
      appendErrorMaxRetry: 3, // used by buffer-controller
      loader: _xhrLoader2.default,
      //loader: FetchLoader,
      fLoader: undefined,
      pLoader: undefined,
      xhrSetup: undefined,
      fetchSetup: undefined,
      abrController: _abrController2.default,
      bufferController: _bufferController2.default,
      capLevelController: _capLevelController2.default,
      fpsController: _fpsController2.default,
      //#if altaudio
      audioStreamController: _audioStreamController2.default,
      audioTrackController: _audioTrackController2.default,
      //#endif
      //#if subtitle
      subtitleStreamController: _subtitleStreamController2.default,
      subtitleTrackController: _subtitleTrackController2.default,
      timelineController: _timelineController2.default,
      cueHandler: _cues2.default,
      enableCEA708Captions: true, // used by timeline-controller
      enableWebVTT: true, // used by timeline-controller
      captionsTextTrack1Label: 'English', // used by timeline-controller
      captionsTextTrack1LanguageCode: 'en', // used by timeline-controller
      captionsTextTrack2Label: 'Spanish', // used by timeline-controller
      captionsTextTrack2LanguageCode: 'es', // used by timeline-controller
      //#endif
      stretchShortVideoTrack: false, // used by mp4-remuxer
      forceKeyFrameOnDiscontinuity: true, // used by ts-demuxer
      abrEwmaFastLive: 3, // used by abr-controller
      abrEwmaSlowLive: 9, // used by abr-controller
      abrEwmaFastVoD: 3, // used by abr-controller
      abrEwmaSlowVoD: 9, // used by abr-controller
      abrEwmaDefaultEstimate: 5e5, // 500 kbps  // used by abr-controller
      abrBandWidthFactor: 0.95, // used by abr-controller
      abrBandWidthUpFactor: 0.7, // used by abr-controller
      abrMaxWithRealBitrate: false, // used by abr-controller
      maxStarvationDelay: 4, // used by abr-controller
      maxLoadingDelay: 4, // used by abr-controller
      minAutoBitrate: 0 // used by hls
};

},{"./controller/abr-controller":5,"./controller/audio-stream-controller":6,"./controller/audio-track-controller":7,"./controller/buffer-controller":8,"./controller/cap-level-controller":9,"./controller/fps-controller":10,"./controller/subtitle-stream-controller":13,"./controller/subtitle-track-controller":14,"./controller/timeline-controller":15,"./utils/cues":47,"./utils/xhr-loader":56}],5:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _eventHandler = require('../event-handler');

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _bufferHelper = require('../helper/buffer-helper');

var _bufferHelper2 = _interopRequireDefault(_bufferHelper);

var _errors = require('../errors');

var _logger = require('../utils/logger');

var _ewmaBandwidthEstimator = require('../utils/ewma-bandwidth-estimator');

var _ewmaBandwidthEstimator2 = _interopRequireDefault(_ewmaBandwidthEstimator);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * simple ABR Controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *  - compute next level based on last fragment bw heuristics
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *  - implement an abandon rules triggered if we have less than 2 frag buffered and if computed bw shows that we risk buffer stalling
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

var AbrController = function (_EventHandler) {
  _inherits(AbrController, _EventHandler);

  function AbrController(hls) {
    _classCallCheck(this, AbrController);

    var _this = _possibleConstructorReturn(this, (AbrController.__proto__ || Object.getPrototypeOf(AbrController)).call(this, hls, _events2.default.FRAG_LOADING, _events2.default.FRAG_LOADED, _events2.default.FRAG_BUFFERED, _events2.default.ERROR));

    _this.lastLoadedFragLevel = 0;
    _this._nextAutoLevel = -1;
    _this.hls = hls;
    _this.onCheck = _this._abandonRulesCheck.bind(_this);
    return _this;
  }

  _createClass(AbrController, [{
    key: 'destroy',
    value: function destroy() {
      this.clearTimer();
      _eventHandler2.default.prototype.destroy.call(this);
    }
  }, {
    key: 'onFragLoading',
    value: function onFragLoading(data) {
      var frag = data.frag;
      if (frag.type === 'main') {
        if (!this.timer) {
          this.timer = setInterval(this.onCheck, 100);
        }
        // lazy init of bw Estimator, rationale is that we use different params for Live/VoD
        // so we need to wait for stream manifest / playlist type to instantiate it.
        if (!this._bwEstimator) {
          var hls = this.hls,
              level = data.frag.level,
              isLive = hls.levels[level].details.live,
              config = hls.config,
              ewmaFast = void 0,
              ewmaSlow = void 0;

          if (isLive) {
            ewmaFast = config.abrEwmaFastLive;
            ewmaSlow = config.abrEwmaSlowLive;
          } else {
            ewmaFast = config.abrEwmaFastVoD;
            ewmaSlow = config.abrEwmaSlowVoD;
          }
          this._bwEstimator = new _ewmaBandwidthEstimator2.default(hls, ewmaSlow, ewmaFast, config.abrEwmaDefaultEstimate);
        }
        this.fragCurrent = frag;
      }
    }
  }, {
    key: '_abandonRulesCheck',
    value: function _abandonRulesCheck() {
      /*
        monitor fragment retrieval time...
        we compute expected time of arrival of the complete fragment.
        we compare it to expected time of buffer starvation
      */
      var hls = this.hls,
          v = hls.media,
          frag = this.fragCurrent,
          loader = frag.loader,
          minAutoLevel = hls.minAutoLevel;

      // if loader has been destroyed or loading has been aborted, stop timer and return
      if (!loader || loader.stats && loader.stats.aborted) {
        _logger.logger.warn('frag loader destroy or aborted, disarm abandonRules');
        this.clearTimer();
        return;
      }
      var stats = loader.stats;
      /* only monitor frag retrieval time if
      (video not paused OR first fragment being loaded(ready state === HAVE_NOTHING = 0)) AND autoswitching enabled AND not lowest level (=> means that we have several levels) */
      if (v && (!v.paused && v.playbackRate !== 0 || !v.readyState) && frag.autoLevel && frag.level) {
        var requestDelay = performance.now() - stats.trequest,
            playbackRate = Math.abs(v.playbackRate);
        // monitor fragment load progress after half of expected fragment duration,to stabilize bitrate
        if (requestDelay > 500 * frag.duration / playbackRate) {
          var levels = hls.levels,
              loadRate = Math.max(1, stats.bw ? stats.bw / 8 : stats.loaded * 1000 / requestDelay),
              // byte/s; at least 1 byte/s to avoid division by zero
          // compute expected fragment length using frag duration and level bitrate. also ensure that expected len is gte than already loaded size
          level = levels[frag.level],
              levelBitrate = level.realBitrate ? Math.max(level.realBitrate, level.bitrate) : level.bitrate,
              expectedLen = stats.total ? stats.total : Math.max(stats.loaded, Math.round(frag.duration * levelBitrate / 8)),
              pos = v.currentTime,
              fragLoadedDelay = (expectedLen - stats.loaded) / loadRate,
              bufferStarvationDelay = (_bufferHelper2.default.bufferInfo(v, pos, hls.config.maxBufferHole).end - pos) / playbackRate;
          // consider emergency switch down only if we have less than 2 frag buffered AND
          // time to finish loading current fragment is bigger than buffer starvation delay
          // ie if we risk buffer starvation if bw does not increase quickly
          if (bufferStarvationDelay < 2 * frag.duration / playbackRate && fragLoadedDelay > bufferStarvationDelay) {
            var fragLevelNextLoadedDelay = void 0,
                nextLoadLevel = void 0;
            // lets iterate through lower level and try to find the biggest one that could avoid rebuffering
            // we start from current level - 1 and we step down , until we find a matching level
            for (nextLoadLevel = frag.level - 1; nextLoadLevel > minAutoLevel; nextLoadLevel--) {
              // compute time to load next fragment at lower level
              // 0.8 : consider only 80% of current bw to be conservative
              // 8 = bits per byte (bps/Bps)
              var levelNextBitrate = levels[nextLoadLevel].realBitrate ? Math.max(levels[nextLoadLevel].realBitrate, levels[nextLoadLevel].bitrate) : levels[nextLoadLevel].bitrate;
              fragLevelNextLoadedDelay = frag.duration * levelNextBitrate / (8 * 0.8 * loadRate);
              if (fragLevelNextLoadedDelay < bufferStarvationDelay) {
                // we found a lower level that be rebuffering free with current estimated bw !
                break;
              }
            }
            // only emergency switch down if it takes less time to load new fragment at lowest level instead
            // of finishing loading current one ...
            if (fragLevelNextLoadedDelay < fragLoadedDelay) {
              _logger.logger.warn('loading too slow, abort fragment loading and switch to level ' + nextLoadLevel + ':fragLoadedDelay[' + nextLoadLevel + ']<fragLoadedDelay[' + (frag.level - 1) + '];bufferStarvationDelay:' + fragLevelNextLoadedDelay.toFixed(1) + '<' + fragLoadedDelay.toFixed(1) + ':' + bufferStarvationDelay.toFixed(1));
              // force next load level in auto mode
              hls.nextLoadLevel = nextLoadLevel;
              // update bw estimate for this fragment before cancelling load (this will help reducing the bw)
              this._bwEstimator.sample(requestDelay, stats.loaded);
              //abort fragment loading
              loader.abort();
              // stop abandon rules timer
              this.clearTimer();
              hls.trigger(_events2.default.FRAG_LOAD_EMERGENCY_ABORTED, { frag: frag, stats: stats });
            }
          }
        }
      }
    }
  }, {
    key: 'onFragLoaded',
    value: function onFragLoaded(data) {
      var frag = data.frag;
      if (frag.type === 'main' && !isNaN(frag.sn)) {
        // stop monitoring bw once frag loaded
        this.clearTimer();
        // store level id after successful fragment load
        this.lastLoadedFragLevel = frag.level;
        // reset forced auto level value so that next level will be selected
        this._nextAutoLevel = -1;

        // compute level average bitrate
        if (this.hls.config.abrMaxWithRealBitrate) {
          var level = this.hls.levels[frag.level];
          var loadedBytes = (level.loaded ? level.loaded.bytes : 0) + data.stats.loaded;
          var loadedDuration = (level.loaded ? level.loaded.duration : 0) + data.frag.duration;
          level.loaded = { bytes: loadedBytes, duration: loadedDuration };
          level.realBitrate = Math.round(8 * loadedBytes / loadedDuration);
        }
        // if fragment has been loaded to perform a bitrate test,
        if (data.frag.bitrateTest) {
          var stats = data.stats;
          stats.tparsed = stats.tbuffered = stats.tload;
          this.onFragBuffered(data);
        }
      }
    }
  }, {
    key: 'onFragBuffered',
    value: function onFragBuffered(data) {
      var stats = data.stats,
          frag = data.frag;
      // only update stats on first frag buffering
      // if same frag is loaded multiple times, it might be in browser cache, and loaded quickly
      // and leading to wrong bw estimation
      // on bitrate test, also only update stats once (if tload = tbuffered == on FRAG_LOADED)
      if (stats.aborted !== true && frag.loadCounter === 1 && frag.type === 'main' && !isNaN(frag.sn) && (!frag.bitrateTest || stats.tload === stats.tbuffered)) {
        // use tparsed-trequest instead of tbuffered-trequest to compute fragLoadingProcessing; rationale is that  buffer appending only happens once media is attached
        // in case we use config.startFragPrefetch while media is not attached yet, fragment might be parsed while media not attached yet, but it will only be buffered on media attached
        // as a consequence it could happen really late in the process. meaning that appending duration might appears huge ... leading to underestimated throughput estimation
        var fragLoadingProcessingMs = stats.tparsed - stats.trequest;
        _logger.logger.log('latency/loading/parsing/append/kbps:' + Math.round(stats.tfirst - stats.trequest) + '/' + Math.round(stats.tload - stats.tfirst) + '/' + Math.round(stats.tparsed - stats.tload) + '/' + Math.round(stats.tbuffered - stats.tparsed) + '/' + Math.round(8 * stats.loaded / (stats.tbuffered - stats.trequest)));
        this._bwEstimator.sample(fragLoadingProcessingMs, stats.loaded);
        // if fragment has been loaded to perform a bitrate test, (hls.startLevel = -1), store bitrate test delay duration
        if (frag.bitrateTest) {
          this.bitrateTestDelay = fragLoadingProcessingMs / 1000;
        } else {
          this.bitrateTestDelay = 0;
        }
      }
    }
  }, {
    key: 'onError',
    value: function onError(data) {
      // stop timer in case of frag loading error
      switch (data.details) {
        case _errors.ErrorDetails.FRAG_LOAD_ERROR:
        case _errors.ErrorDetails.FRAG_LOAD_TIMEOUT:
          this.clearTimer();
          break;
        default:
          break;
      }
    }
  }, {
    key: 'clearTimer',
    value: function clearTimer() {
      if (this.timer) {
        clearInterval(this.timer);
        this.timer = null;
      }
    }

    // return next auto level

  }, {
    key: '_findBestLevel',
    value: function _findBestLevel(currentLevel, currentFragDuration, currentBw, minAutoLevel, maxAutoLevel, maxFetchDuration, bwFactor, bwUpFactor, levels) {
      for (var i = maxAutoLevel; i >= minAutoLevel; i--) {
        var levelInfo = levels[i],
            levelDetails = levelInfo.details,
            avgDuration = levelDetails ? levelDetails.totalduration / levelDetails.fragments.length : currentFragDuration,
            live = levelDetails ? levelDetails.live : false,
            adjustedbw = void 0;
        // follow algorithm captured from stagefright :
        // https://android.googlesource.com/platform/frameworks/av/+/master/media/libstagefright/httplive/LiveSession.cpp
        // Pick the highest bandwidth stream below or equal to estimated bandwidth.
        // consider only 80% of the available bandwidth, but if we are switching up,
        // be even more conservative (70%) to avoid overestimating and immediately
        // switching back.
        if (i <= currentLevel) {
          adjustedbw = bwFactor * currentBw;
        } else {
          adjustedbw = bwUpFactor * currentBw;
        }
        var bitrate = levels[i].realBitrate ? Math.max(levels[i].realBitrate, levels[i].bitrate) : levels[i].bitrate,
            fetchDuration = bitrate * avgDuration / adjustedbw;

        _logger.logger.trace('level/adjustedbw/bitrate/avgDuration/maxFetchDuration/fetchDuration: ' + i + '/' + Math.round(adjustedbw) + '/' + bitrate + '/' + avgDuration + '/' + maxFetchDuration + '/' + fetchDuration);
        // if adjusted bw is greater than level bitrate AND
        if (adjustedbw > bitrate && (
        // fragment fetchDuration unknown OR live stream OR fragment fetchDuration less than max allowed fetch duration, then this level matches
        // we don't account for max Fetch Duration for live streams, this is to avoid switching down when near the edge of live sliding window ...
        !fetchDuration || live || fetchDuration < maxFetchDuration)) {
          // as we are looping from highest to lowest, this will return the best achievable quality level

          return i;
        }
      }
      // not enough time budget even with quality level 0 ... rebuffering might happen
      return -1;
    }
  }, {
    key: 'nextAutoLevel',
    get: function get() {
      var forcedAutoLevel = this._nextAutoLevel;
      var bwEstimator = this._bwEstimator;
      // in case next auto level has been forced, and bw not available or not reliable, return forced value
      if (forcedAutoLevel !== -1 && (!bwEstimator || !bwEstimator.canEstimate())) {
        return forcedAutoLevel;
      }
      // compute next level using ABR logic
      var nextABRAutoLevel = this._nextABRAutoLevel;
      // if forced auto level has been defined, use it to cap ABR computed quality level
      if (forcedAutoLevel !== -1) {
        nextABRAutoLevel = Math.min(forcedAutoLevel, nextABRAutoLevel);
      }
      return nextABRAutoLevel;
    },
    set: function set(nextLevel) {
      this._nextAutoLevel = nextLevel;
    }
  }, {
    key: '_nextABRAutoLevel',
    get: function get() {
      var hls = this.hls,
          maxAutoLevel = hls.maxAutoLevel,
          levels = hls.levels,
          config = hls.config,
          minAutoLevel = hls.minAutoLevel;
      var v = hls.media,
          currentLevel = this.lastLoadedFragLevel,
          currentFragDuration = this.fragCurrent ? this.fragCurrent.duration : 0,
          pos = v ? v.currentTime : 0,

      // playbackRate is the absolute value of the playback rate; if v.playbackRate is 0, we use 1 to load as
      // if we're playing back at the normal rate.
      playbackRate = v && v.playbackRate !== 0 ? Math.abs(v.playbackRate) : 1.0,
          avgbw = this._bwEstimator ? this._bwEstimator.getEstimate() : config.abrEwmaDefaultEstimate,

      // bufferStarvationDelay is the wall-clock time left until the playback buffer is exhausted.
      bufferStarvationDelay = (_bufferHelper2.default.bufferInfo(v, pos, config.maxBufferHole).end - pos) / playbackRate;

      // First, look to see if we can find a level matching with our avg bandwidth AND that could also guarantee no rebuffering at all
      var bestLevel = this._findBestLevel(currentLevel, currentFragDuration, avgbw, minAutoLevel, maxAutoLevel, bufferStarvationDelay, config.abrBandWidthFactor, config.abrBandWidthUpFactor, levels);
      if (bestLevel >= 0) {
        return bestLevel;
      } else {
        _logger.logger.trace('rebuffering expected to happen, lets try to find a quality level minimizing the rebuffering');
        // not possible to get rid of rebuffering ... let's try to find level that will guarantee less than maxStarvationDelay of rebuffering
        // if no matching level found, logic will return 0
        var maxStarvationDelay = currentFragDuration ? Math.min(currentFragDuration, config.maxStarvationDelay) : config.maxStarvationDelay,
            bwFactor = config.abrBandWidthFactor,
            bwUpFactor = config.abrBandWidthUpFactor;
        if (bufferStarvationDelay === 0) {
          // in case buffer is empty, let's check if previous fragment was loaded to perform a bitrate test
          var bitrateTestDelay = this.bitrateTestDelay;
          if (bitrateTestDelay) {
            // if it is the case, then we need to adjust our max starvation delay using maxLoadingDelay config value
            // max video loading delay used in  automatic start level selection :
            // in that mode ABR controller will ensure that video loading time (ie the time to fetch the first fragment at lowest quality level +
            // the time to fetch the fragment at the appropriate quality level is less than ```maxLoadingDelay``` )
            // cap maxLoadingDelay and ensure it is not bigger 'than bitrate test' frag duration
            var maxLoadingDelay = currentFragDuration ? Math.min(currentFragDuration, config.maxLoadingDelay) : config.maxLoadingDelay;
            maxStarvationDelay = maxLoadingDelay - bitrateTestDelay;
            _logger.logger.trace('bitrate test took ' + Math.round(1000 * bitrateTestDelay) + 'ms, set first fragment max fetchDuration to ' + Math.round(1000 * maxStarvationDelay) + ' ms');
            // don't use conservative factor on bitrate test
            bwFactor = bwUpFactor = 1;
          }
        }
        bestLevel = this._findBestLevel(currentLevel, currentFragDuration, avgbw, minAutoLevel, maxAutoLevel, bufferStarvationDelay + maxStarvationDelay, bwFactor, bwUpFactor, levels);
        return Math.max(bestLevel, 0);
      }
    }
  }]);

  return AbrController;
}(_eventHandler2.default);

exports.default = AbrController;

},{"../errors":30,"../event-handler":31,"../events":32,"../helper/buffer-helper":34,"../utils/ewma-bandwidth-estimator":49,"../utils/logger":51}],6:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _binarySearch = require('../utils/binary-search');

var _binarySearch2 = _interopRequireDefault(_binarySearch);

var _bufferHelper = require('../helper/buffer-helper');

var _bufferHelper2 = _interopRequireDefault(_bufferHelper);

var _demuxer = require('../demux/demuxer');

var _demuxer2 = _interopRequireDefault(_demuxer);

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _eventHandler = require('../event-handler');

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _levelHelper = require('../helper/level-helper');

var _levelHelper2 = _interopRequireDefault(_levelHelper);

var _timeRanges = require('../utils/timeRanges');

var _timeRanges2 = _interopRequireDefault(_timeRanges);

var _errors = require('../errors');

var _logger = require('../utils/logger');

var _discontinuities = require('../utils/discontinuities');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Audio Stream Controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

var State = {
  STOPPED: 'STOPPED',
  STARTING: 'STARTING',
  IDLE: 'IDLE',
  PAUSED: 'PAUSED',
  KEY_LOADING: 'KEY_LOADING',
  FRAG_LOADING: 'FRAG_LOADING',
  FRAG_LOADING_WAITING_RETRY: 'FRAG_LOADING_WAITING_RETRY',
  WAITING_TRACK: 'WAITING_TRACK',
  PARSING: 'PARSING',
  PARSED: 'PARSED',
  BUFFER_FLUSHING: 'BUFFER_FLUSHING',
  ENDED: 'ENDED',
  ERROR: 'ERROR',
  WAITING_INIT_PTS: 'WAITING_INIT_PTS'
};

var AudioStreamController = function (_EventHandler) {
  _inherits(AudioStreamController, _EventHandler);

  function AudioStreamController(hls) {
    _classCallCheck(this, AudioStreamController);

    var _this = _possibleConstructorReturn(this, (AudioStreamController.__proto__ || Object.getPrototypeOf(AudioStreamController)).call(this, hls, _events2.default.MEDIA_ATTACHED, _events2.default.MEDIA_DETACHING, _events2.default.AUDIO_TRACKS_UPDATED, _events2.default.AUDIO_TRACK_SWITCHING, _events2.default.AUDIO_TRACK_LOADED, _events2.default.KEY_LOADED, _events2.default.FRAG_LOADED, _events2.default.FRAG_PARSING_INIT_SEGMENT, _events2.default.FRAG_PARSING_DATA, _events2.default.FRAG_PARSED, _events2.default.ERROR, _events2.default.BUFFER_CREATED, _events2.default.BUFFER_APPENDED, _events2.default.BUFFER_FLUSHED, _events2.default.INIT_PTS_FOUND));

    _this.config = hls.config;
    _this.audioCodecSwap = false;
    _this.ticks = 0;
    _this._state = State.STOPPED;
    _this.ontick = _this.tick.bind(_this);
    _this.initPTS = [];
    _this.waitingFragment = null;
    _this.videoTrackCC = null;
    return _this;
  }

  _createClass(AudioStreamController, [{
    key: 'destroy',
    value: function destroy() {
      this.stopLoad();
      if (this.timer) {
        clearInterval(this.timer);
        this.timer = null;
      }
      _eventHandler2.default.prototype.destroy.call(this);
      this.state = State.STOPPED;
    }

    //Signal that video PTS was found

  }, {
    key: 'onInitPtsFound',
    value: function onInitPtsFound(data) {
      var demuxerId = data.id,
          cc = data.frag.cc,
          initPTS = data.initPTS;
      if (demuxerId === 'main') {
        //Always update the new INIT PTS
        //Can change due level switch
        this.initPTS[cc] = initPTS;
        this.videoTrackCC = cc;
        _logger.logger.log('InitPTS for cc:' + cc + ' found from video track:' + initPTS);

        //If we are waiting we need to demux/remux the waiting frag
        //With the new initPTS
        if (this.state === State.WAITING_INIT_PTS) {
          _logger.logger.log('sending pending audio frag to demuxer');
          this.state = State.FRAG_LOADING;
          //We have audio frag waiting or video pts
          //Let process it
          this.onFragLoaded(this.waitingFragment);
          //Lets clean the waiting frag
          this.waitingFragment = null;
        }
      }
    }
  }, {
    key: 'startLoad',
    value: function startLoad(startPosition) {
      if (this.tracks) {
        var lastCurrentTime = this.lastCurrentTime;
        this.stopLoad();
        if (!this.timer) {
          this.timer = setInterval(this.ontick, 100);
        }
        this.fragLoadError = 0;
        if (lastCurrentTime > 0 && startPosition === -1) {
          _logger.logger.log('audio:override startPosition with lastCurrentTime @' + lastCurrentTime.toFixed(3));
          this.state = State.IDLE;
        } else {
          this.lastCurrentTime = this.startPosition ? this.startPosition : startPosition;
          this.state = State.STARTING;
        }
        this.nextLoadPosition = this.startPosition = this.lastCurrentTime;
        this.tick();
      } else {
        this.startPosition = startPosition;
        this.state = State.STOPPED;
      }
    }
  }, {
    key: 'stopLoad',
    value: function stopLoad() {
      var frag = this.fragCurrent;
      if (frag) {
        if (frag.loader) {
          frag.loader.abort();
        }
        this.fragCurrent = null;
      }
      this.fragPrevious = null;
      if (this.demuxer) {
        this.demuxer.destroy();
        this.demuxer = null;
      }
      this.state = State.STOPPED;
    }
  }, {
    key: 'tick',
    value: function tick() {
      this.ticks++;
      if (this.ticks === 1) {
        this.doTick();
        if (this.ticks > 1) {
          setTimeout(this.tick, 1);
        }
        this.ticks = 0;
      }
    }
  }, {
    key: 'doTick',
    value: function doTick() {
      var _this2 = this;

      var pos,
          track,
          trackDetails,
          hls = this.hls,
          config = hls.config;
      //logger.log('audioStream:' + this.state);
      var now;
      var retryDate;
      var isSeeking;

      var _ret = function () {
        switch (_this2.state) {
          case State.ERROR:
          //don't do anything in error state to avoid breaking further ...
          case State.PAUSED:
          //don't do anything in paused state either ...
          case State.BUFFER_FLUSHING:
            break;
          case State.STARTING:
            _this2.state = State.WAITING_TRACK;
            _this2.loadedmetadata = false;
            break;
          case State.IDLE:
            var tracks = _this2.tracks;
            // audio tracks not received => exit loop
            if (!tracks) {
              break;
            }
            // if video not attached AND
            // start fragment already requested OR start frag prefetch disable
            // exit loop
            // => if media not attached but start frag prefetch is enabled and start frag not requested yet, we will not exit loop
            if (!_this2.media && (_this2.startFragRequested || !config.startFragPrefetch)) {
              break;
            }
            // determine next candidate fragment to be loaded, based on current position and
            //  end of buffer position
            // if we have not yet loaded any fragment, start loading from start position
            if (_this2.loadedmetadata) {
              pos = _this2.media.currentTime;
            } else if (_this2.nextLoadPosition) {
              pos = _this2.nextLoadPosition;
            } else {
              pos = 0;
            }

            var media = _this2.mediaBuffer ? _this2.mediaBuffer : _this2.media,
                bufferInfo = _bufferHelper2.default.bufferInfo(media, pos, config.maxBufferHole),
                bufferLen = bufferInfo.len,
                bufferEnd = bufferInfo.end,
                fragPrevious = _this2.fragPrevious,
                maxBufLen = config.maxMaxBufferLength,
                audioSwitch = _this2.audioSwitch,
                trackId = _this2.trackId;

            // if buffer length is less than maxBufLen try to load a new fragment
            if ((bufferLen < maxBufLen || audioSwitch) && trackId < tracks.length) {
              trackDetails = tracks[trackId].details;
              // if track info not retrieved yet, switch state and wait for track retrieval
              if (typeof trackDetails === 'undefined') {
                _this2.state = State.WAITING_TRACK;
                break;
              }

              // we just got done loading the final fragment, check if we need to finalize media stream
              if (!audioSwitch && !trackDetails.live && fragPrevious && fragPrevious.sn === trackDetails.endSN) {
                // if we are not seeking or if we are seeking but everything (almost) til the end is buffered, let's signal eos
                // we don't compare exactly media.duration === bufferInfo.end as there could be some subtle media duration difference when switching
                // between different renditions. using half frag duration should help cope with these cases.
                if (!_this2.media.seeking || _this2.media.duration - bufferEnd < fragPrevious.duration / 2) {
                  // Finalize the media stream
                  _this2.hls.trigger(_events2.default.BUFFER_EOS, { type: 'audio' });
                  _this2.state = State.ENDED;
                  break;
                }
              }

              // find fragment index, contiguous with end of buffer position
              var fragments = trackDetails.fragments,
                  fragLen = fragments.length,
                  start = fragments[0].start,
                  end = fragments[fragLen - 1].start + fragments[fragLen - 1].duration,
                  frag = void 0;

              // When switching audio track, reload audio as close as possible to currentTime
              if (audioSwitch) {
                if (trackDetails.live && !trackDetails.PTSKnown) {
                  _logger.logger.log('switching audiotrack, live stream, unknown PTS,load first fragment');
                  bufferEnd = 0;
                } else {
                  bufferEnd = pos;
                  // if currentTime (pos) is less than alt audio playlist start time, it means that alt audio is ahead of currentTime
                  if (trackDetails.PTSKnown && pos < start) {
                    // if everything is buffered from pos to start or if audio buffer upfront, let's seek to start
                    if (bufferInfo.end > start || bufferInfo.nextStart) {
                      _logger.logger.log('alt audio track ahead of main track, seek to start of alt audio track');
                      _this2.media.currentTime = start + 0.05;
                    } else {
                      return {
                        v: void 0
                      };
                    }
                  }
                }
              }
              if (trackDetails.initSegment && !trackDetails.initSegment.data) {
                frag = trackDetails.initSegment;
              }
              // if bufferEnd before start of playlist, load first fragment
              else if (bufferEnd <= start) {
                  frag = fragments[0];
                  if (_this2.videoTrackCC !== null && frag.cc !== _this2.videoTrackCC) {
                    // Ensure we find a fragment which matches the continuity of the video track
                    frag = (0, _discontinuities.findFragWithCC)(fragments, _this2.videoTrackCC);
                  }
                  if (trackDetails.live && frag.loadIdx && frag.loadIdx === _this2.fragLoadIdx) {
                    // we just loaded this first fragment, and we are still lagging behind the start of the live playlist
                    // let's force seek to start
                    var nextBuffered = bufferInfo.nextStart ? bufferInfo.nextStart : start;
                    _logger.logger.log('no alt audio available @currentTime:' + _this2.media.currentTime + ', seeking @' + (nextBuffered + 0.05));
                    _this2.media.currentTime = nextBuffered + 0.05;
                    return {
                      v: void 0
                    };
                  }
                } else {
                  (function () {
                    var foundFrag = void 0;
                    var maxFragLookUpTolerance = config.maxFragLookUpTolerance;
                    var fragNext = fragPrevious ? fragments[fragPrevious.sn - fragments[0].sn + 1] : undefined;
                    var fragmentWithinToleranceTest = function fragmentWithinToleranceTest(candidate) {
                      // offset should be within fragment boundary - config.maxFragLookUpTolerance
                      // this is to cope with situations like
                      // bufferEnd = 9.991
                      // frag[] : [0,10]
                      // frag[1] : [10,20]
                      // bufferEnd is within frag[0] range ... although what we are expecting is to return frag[1] here
                      //              frag start               frag start+duration
                      //                  |-----------------------------|
                      //              <--->                         <--->
                      //  ...--------><-----------------------------><---------....
                      // previous frag         matching fragment         next frag
                      //  return -1             return 0                 return 1
                      //logger.log(`level/sn/start/end/bufEnd:${level}/${candidate.sn}/${candidate.start}/${(candidate.start+candidate.duration)}/${bufferEnd}`);
                      // Set the lookup tolerance to be small enough to detect the current segment - ensures we don't skip over very small segments
                      var candidateLookupTolerance = Math.min(maxFragLookUpTolerance, candidate.duration);
                      if (candidate.start + candidate.duration - candidateLookupTolerance <= bufferEnd) {
                        return 1;
                      } // if maxFragLookUpTolerance will have negative value then don't return -1 for first element
                      else if (candidate.start - candidateLookupTolerance > bufferEnd && candidate.start) {
                          return -1;
                        }
                      return 0;
                    };

                    if (bufferEnd < end) {
                      if (bufferEnd > end - maxFragLookUpTolerance) {
                        maxFragLookUpTolerance = 0;
                      }
                      // Prefer the next fragment if it's within tolerance
                      if (fragNext && !fragmentWithinToleranceTest(fragNext)) {
                        foundFrag = fragNext;
                      } else {
                        foundFrag = _binarySearch2.default.search(fragments, fragmentWithinToleranceTest);
                      }
                    } else {
                      // reach end of playlist
                      foundFrag = fragments[fragLen - 1];
                    }
                    if (foundFrag) {
                      frag = foundFrag;
                      start = foundFrag.start;
                      //logger.log('find SN matching with pos:' +  bufferEnd + ':' + frag.sn);
                      if (fragPrevious && frag.level === fragPrevious.level && frag.sn === fragPrevious.sn) {
                        if (frag.sn < trackDetails.endSN) {
                          frag = fragments[frag.sn + 1 - trackDetails.startSN];
                          _logger.logger.log('SN just loaded, load next one: ' + frag.sn);
                        } else {
                          frag = null;
                        }
                      }
                    }
                  })();
                }
              if (frag) {
                //logger.log('      loading frag ' + i +',pos/bufEnd:' + pos.toFixed(3) + '/' + bufferEnd.toFixed(3));
                if (frag.decryptdata && frag.decryptdata.uri != null && frag.decryptdata.key == null) {
                  _logger.logger.log('Loading key for ' + frag.sn + ' of [' + trackDetails.startSN + ' ,' + trackDetails.endSN + '],track ' + trackId);
                  _this2.state = State.KEY_LOADING;
                  hls.trigger(_events2.default.KEY_LOADING, { frag: frag });
                } else {
                  _logger.logger.log('Loading ' + frag.sn + ', cc: ' + frag.cc + ' of [' + trackDetails.startSN + ' ,' + trackDetails.endSN + '],track ' + trackId + ', currentTime:' + pos + ',bufferEnd:' + bufferEnd.toFixed(3));
                  // ensure that we are not reloading the same fragments in loop ...
                  if (_this2.fragLoadIdx !== undefined) {
                    _this2.fragLoadIdx++;
                  } else {
                    _this2.fragLoadIdx = 0;
                  }
                  if (frag.loadCounter) {
                    frag.loadCounter++;
                    var maxThreshold = config.fragLoadingLoopThreshold;
                    // if this frag has already been loaded 3 times, and if it has been reloaded recently
                    if (frag.loadCounter > maxThreshold && Math.abs(_this2.fragLoadIdx - frag.loadIdx) < maxThreshold) {
                      hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.FRAG_LOOP_LOADING_ERROR, fatal: false, frag: frag });
                      return {
                        v: void 0
                      };
                    }
                  } else {
                    frag.loadCounter = 1;
                  }
                  frag.loadIdx = _this2.fragLoadIdx;
                  _this2.fragCurrent = frag;
                  _this2.startFragRequested = true;
                  if (!isNaN(frag.sn)) {
                    _this2.nextLoadPosition = frag.start + frag.duration;
                  }
                  hls.trigger(_events2.default.FRAG_LOADING, { frag: frag });
                  _this2.state = State.FRAG_LOADING;
                }
              }
            }
            break;
          case State.WAITING_TRACK:
            track = _this2.tracks[_this2.trackId];
            // check if playlist is already loaded
            if (track && track.details) {
              _this2.state = State.IDLE;
            }
            break;
          case State.FRAG_LOADING_WAITING_RETRY:
            now = performance.now();
            retryDate = _this2.retryDate;

            media = _this2.media;
            isSeeking = media && media.seeking;
            // if current time is gt than retryDate, or if media seeking let's switch to IDLE state to retry loading

            if (!retryDate || now >= retryDate || isSeeking) {
              _logger.logger.log('audioStreamController: retryDate reached, switch back to IDLE state');
              _this2.state = State.IDLE;
            }
            break;
          case State.WAITING_INIT_PTS:
            if (_this2.initPTS[_this2.videoTrackCC] === undefined) {
              break;
            }

            // Ensure we don't get stuck in the WAITING_INIT_PTS state if the waiting frag CC doesn't match any initPTS
            var waitingFrag = _this2.waitingFragment;
            if (waitingFrag) {
              var waitingFragCC = waitingFrag.frag.cc;
              if (_this2.videoTrackCC !== waitingFragCC) {
                _logger.logger.warn('Waiting fragment CC (' + waitingFragCC + ') does not match video track CC (' + _this2.videoTrackCC + ')');
                _this2.waitingFragment = null;
                _this2.state = State.IDLE;
              } else {
                _this2.onFragLoaded(_this2.waitingFragment);
                _this2.state = State.FRAG_LOADING;
                _this2.waitingFragment = null;
              }
            } else {
              _this2.state = State.IDLE;
            }

            break;
          case State.STOPPED:
          case State.FRAG_LOADING:
          case State.PARSING:
          case State.PARSED:
          case State.ENDED:
            break;
          default:
            break;
        }
      }();

      if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object") return _ret.v;
    }
  }, {
    key: 'onMediaAttached',
    value: function onMediaAttached(data) {
      var media = this.media = this.mediaBuffer = data.media;
      this.onvseeking = this.onMediaSeeking.bind(this);
      this.onvended = this.onMediaEnded.bind(this);
      media.addEventListener('seeking', this.onvseeking);
      media.addEventListener('ended', this.onvended);
      var config = this.config;
      if (this.tracks && config.autoStartLoad) {
        this.startLoad(config.startPosition);
      }
    }
  }, {
    key: 'onMediaDetaching',
    value: function onMediaDetaching() {
      var media = this.media;
      if (media && media.ended) {
        _logger.logger.log('MSE detaching and video ended, reset startPosition');
        this.startPosition = this.lastCurrentTime = 0;
      }

      // reset fragment loading counter on MSE detaching to avoid reporting FRAG_LOOP_LOADING_ERROR after error recovery
      var tracks = this.tracks;
      if (tracks) {
        // reset fragment load counter
        tracks.forEach(function (track) {
          if (track.details) {
            track.details.fragments.forEach(function (fragment) {
              fragment.loadCounter = undefined;
            });
          }
        });
      }
      // remove video listeners
      if (media) {
        media.removeEventListener('seeking', this.onvseeking);
        media.removeEventListener('ended', this.onvended);
        this.onvseeking = this.onvseeked = this.onvended = null;
      }
      this.media = this.mediaBuffer = null;
      this.loadedmetadata = false;
      this.stopLoad();
    }
  }, {
    key: 'onMediaSeeking',
    value: function onMediaSeeking() {
      if (this.state === State.ENDED) {
        // switch to IDLE state to check for potential new fragment
        this.state = State.IDLE;
      }
      if (this.media) {
        this.lastCurrentTime = this.media.currentTime;
      }
      // avoid reporting fragment loop loading error in case user is seeking several times on same position
      if (this.fragLoadIdx !== undefined) {
        this.fragLoadIdx += 2 * this.config.fragLoadingLoopThreshold;
      }
      // tick to speed up processing
      this.tick();
    }
  }, {
    key: 'onMediaEnded',
    value: function onMediaEnded() {
      // reset startPosition and lastCurrentTime to restart playback @ stream beginning
      this.startPosition = this.lastCurrentTime = 0;
    }
  }, {
    key: 'onAudioTracksUpdated',
    value: function onAudioTracksUpdated(data) {
      _logger.logger.log('audio tracks updated');
      this.tracks = data.audioTracks;
    }
  }, {
    key: 'onAudioTrackSwitching',
    value: function onAudioTrackSwitching(data) {
      // if any URL found on new audio track, it is an alternate audio track
      var altAudio = !!data.url;
      this.trackId = data.id;
      this.state = State.IDLE;

      this.fragCurrent = null;
      this.state = State.PAUSED;
      this.waitingFragment = null;
      // destroy useless demuxer when switching audio to main
      if (!altAudio) {
        if (this.demuxer) {
          this.demuxer.destroy();
          this.demuxer = null;
        }
      } else {
        // switching to audio track, start timer if not already started
        if (!this.timer) {
          this.timer = setInterval(this.ontick, 100);
        }
      }

      //should we switch tracks ?
      if (altAudio) {
        this.audioSwitch = true;
        //main audio track are handled by stream-controller, just do something if switching to alt audio track
        this.state = State.IDLE;
        // increase fragment load Index to avoid frag loop loading error after buffer flush
        if (this.fragLoadIdx !== undefined) {
          this.fragLoadIdx += 2 * this.config.fragLoadingLoopThreshold;
        }
      }
      this.tick();
    }
  }, {
    key: 'onAudioTrackLoaded',
    value: function onAudioTrackLoaded(data) {
      var newDetails = data.details,
          trackId = data.id,
          track = this.tracks[trackId],
          duration = newDetails.totalduration,
          sliding = 0;

      _logger.logger.log('track ' + trackId + ' loaded [' + newDetails.startSN + ',' + newDetails.endSN + '],duration:' + duration);

      if (newDetails.live) {
        var curDetails = track.details;
        if (curDetails && newDetails.fragments.length > 0) {
          // we already have details for that level, merge them
          _levelHelper2.default.mergeDetails(curDetails, newDetails);
          sliding = newDetails.fragments[0].start;
          // TODO
          //this.liveSyncPosition = this.computeLivePosition(sliding, curDetails);
          if (newDetails.PTSKnown) {
            _logger.logger.log('live audio playlist sliding:' + sliding.toFixed(3));
          } else {
            _logger.logger.log('live audio playlist - outdated PTS, unknown sliding');
          }
        } else {
          newDetails.PTSKnown = false;
          _logger.logger.log('live audio playlist - first load, unknown sliding');
        }
      } else {
        newDetails.PTSKnown = false;
      }
      track.details = newDetails;

      // compute start position
      if (!this.startFragRequested) {
        // compute start position if set to -1. use it straight away if value is defined
        if (this.startPosition === -1) {
          // first, check if start time offset has been set in playlist, if yes, use this value
          var startTimeOffset = newDetails.startTimeOffset;
          if (!isNaN(startTimeOffset)) {
            _logger.logger.log('start time offset found in playlist, adjust startPosition to ' + startTimeOffset);
            this.startPosition = startTimeOffset;
          } else {
            this.startPosition = 0;
          }
        }
        this.nextLoadPosition = this.startPosition;
      }
      // only switch batck to IDLE state if we were waiting for track to start downloading a new fragment
      if (this.state === State.WAITING_TRACK) {
        this.state = State.IDLE;
      }
      //trigger handler right now
      this.tick();
    }
  }, {
    key: 'onKeyLoaded',
    value: function onKeyLoaded() {
      if (this.state === State.KEY_LOADING) {
        this.state = State.IDLE;
        this.tick();
      }
    }
  }, {
    key: 'onFragLoaded',
    value: function onFragLoaded(data) {
      var fragCurrent = this.fragCurrent,
          fragLoaded = data.frag;
      if (this.state === State.FRAG_LOADING && fragCurrent && fragLoaded.type === 'audio' && fragLoaded.level === fragCurrent.level && fragLoaded.sn === fragCurrent.sn) {
        var track = this.tracks[this.trackId],
            details = track.details,
            duration = details.totalduration,
            trackId = fragCurrent.level,
            sn = fragCurrent.sn,
            cc = fragCurrent.cc,
            audioCodec = this.config.defaultAudioCodec || track.audioCodec || 'mp4a.40.2',
            stats = this.stats = data.stats;
        if (sn === 'initSegment') {
          this.state = State.IDLE;

          stats.tparsed = stats.tbuffered = performance.now();
          details.initSegment.data = data.payload;
          this.hls.trigger(_events2.default.FRAG_BUFFERED, { stats: stats, frag: fragCurrent, id: 'audio' });
          this.tick();
        } else {
          this.state = State.PARSING;
          // transmux the MPEG-TS data to ISO-BMFF segments
          this.appended = false;
          if (!this.demuxer) {
            this.demuxer = new _demuxer2.default(this.hls, 'audio');
          }
          //Check if we have video initPTS
          // If not we need to wait for it
          var initPTS = this.initPTS[cc];
          var initSegmentData = details.initSegment ? details.initSegment.data : [];
          if (initSegmentData || initPTS !== undefined) {
            this.pendingBuffering = true;
            _logger.logger.log('Demuxing ' + sn + ' of [' + details.startSN + ' ,' + details.endSN + '],track ' + trackId);
            // time Offset is accurate if level PTS is known, or if playlist is not sliding (not live)
            var accurateTimeOffset = false; //details.PTSKnown || !details.live;
            this.demuxer.push(data.payload, initSegmentData, audioCodec, null, fragCurrent, duration, accurateTimeOffset, initPTS);
          } else {
            _logger.logger.log('unknown video PTS for continuity counter ' + cc + ', waiting for video PTS before demuxing audio frag ' + sn + ' of [' + details.startSN + ' ,' + details.endSN + '],track ' + trackId);
            this.waitingFragment = data;
            this.state = State.WAITING_INIT_PTS;
          }
        }
      }
      this.fragLoadError = 0;
    }
  }, {
    key: 'onFragParsingInitSegment',
    value: function onFragParsingInitSegment(data) {
      var fragCurrent = this.fragCurrent;
      var fragNew = data.frag;
      if (fragCurrent && data.id === 'audio' && fragNew.sn === fragCurrent.sn && fragNew.level === fragCurrent.level && this.state === State.PARSING) {
        var tracks = data.tracks,
            track = void 0;

        // delete any video track found on audio demuxer
        if (tracks.video) {
          delete tracks.video;
        }

        // include levelCodec in audio and video tracks
        track = tracks.audio;
        if (track) {
          track.levelCodec = 'mp4a.40.2';
          track.id = data.id;
          this.hls.trigger(_events2.default.BUFFER_CODECS, tracks);
          _logger.logger.log('audio track:audio,container:' + track.container + ',codecs[level/parsed]=[' + track.levelCodec + '/' + track.codec + ']');
          var initSegment = track.initSegment;
          if (initSegment) {
            var appendObj = { type: 'audio', data: initSegment, parent: 'audio', content: 'initSegment' };
            if (this.audioSwitch) {
              this.pendingData = [appendObj];
            } else {
              this.appended = true;
              // arm pending Buffering flag before appending a segment
              this.pendingBuffering = true;
              this.hls.trigger(_events2.default.BUFFER_APPENDING, appendObj);
            }
          }
          //trigger handler right now
          this.tick();
        }
      }
    }
  }, {
    key: 'onFragParsingData',
    value: function onFragParsingData(data) {
      var _this3 = this;

      var fragCurrent = this.fragCurrent;
      var fragNew = data.frag;
      if (fragCurrent && data.id === 'audio' && data.type === 'audio' && fragNew.sn === fragCurrent.sn && fragNew.level === fragCurrent.level && this.state === State.PARSING) {
        (function () {
          var trackId = _this3.trackId,
              track = _this3.tracks[trackId],
              hls = _this3.hls;

          if (isNaN(data.endPTS)) {
            data.endPTS = data.startPTS + fragCurrent.duration;
            data.endDTS = data.startDTS + fragCurrent.duration;
          }

          _logger.logger.log('parsed ' + data.type + ',PTS:[' + data.startPTS.toFixed(3) + ',' + data.endPTS.toFixed(3) + '],DTS:[' + data.startDTS.toFixed(3) + '/' + data.endDTS.toFixed(3) + '],nb:' + data.nb);
          _levelHelper2.default.updateFragPTSDTS(track.details, fragCurrent.sn, data.startPTS, data.endPTS);

          var audioSwitch = _this3.audioSwitch,
              media = _this3.media,
              appendOnBufferFlush = false;
          //Only flush audio from old audio tracks when PTS is known on new audio track
          if (audioSwitch && media) {
            if (media.readyState) {
              var currentTime = media.currentTime;
              _logger.logger.log('switching audio track : currentTime:' + currentTime);
              if (currentTime >= data.startPTS) {
                _logger.logger.log('switching audio track : flushing all audio');
                _this3.state = State.BUFFER_FLUSHING;
                hls.trigger(_events2.default.BUFFER_FLUSHING, { startOffset: 0, endOffset: Number.POSITIVE_INFINITY, type: 'audio' });
                appendOnBufferFlush = true;
                //Lets announce that the initial audio track switch flush occur
                _this3.audioSwitch = false;
                hls.trigger(_events2.default.AUDIO_TRACK_SWITCHED, { id: trackId });
              }
            } else {
              //Lets announce that the initial audio track switch flush occur
              _this3.audioSwitch = false;
              hls.trigger(_events2.default.AUDIO_TRACK_SWITCHED, { id: trackId });
            }
          }

          var pendingData = _this3.pendingData;
          if (!_this3.audioSwitch) {
            [data.data1, data.data2].forEach(function (buffer) {
              if (buffer && buffer.length) {
                pendingData.push({ type: data.type, data: buffer, parent: 'audio', content: 'data' });
              }
            });
            if (!appendOnBufferFlush && pendingData.length) {
              pendingData.forEach(function (appendObj) {
                // only append in PARSING state (rationale is that an appending error could happen synchronously on first segment appending)
                // in that case it is useless to append following segments
                if (_this3.state === State.PARSING) {
                  // arm pending Buffering flag before appending a segment
                  _this3.pendingBuffering = true;
                  _this3.hls.trigger(_events2.default.BUFFER_APPENDING, appendObj);
                }
              });
              _this3.pendingData = [];
              _this3.appended = true;
            }
          }
          //trigger handler right now
          _this3.tick();
        })();
      }
    }
  }, {
    key: 'onFragParsed',
    value: function onFragParsed(data) {
      var fragCurrent = this.fragCurrent;
      var fragNew = data.frag;
      if (fragCurrent && data.id === 'audio' && fragNew.sn === fragCurrent.sn && fragNew.level === fragCurrent.level && this.state === State.PARSING) {
        this.stats.tparsed = performance.now();
        this.state = State.PARSED;
        this._checkAppendedParsed();
      }
    }
  }, {
    key: 'onBufferCreated',
    value: function onBufferCreated(data) {
      var audioTrack = data.tracks.audio;
      if (audioTrack) {
        this.mediaBuffer = audioTrack.buffer;
        this.loadedmetadata = true;
      }
    }
  }, {
    key: 'onBufferAppended',
    value: function onBufferAppended(data) {
      if (data.parent === 'audio') {
        var state = this.state;
        if (state === State.PARSING || state === State.PARSED) {
          // check if all buffers have been appended
          this.pendingBuffering = data.pending > 0;
          this._checkAppendedParsed();
        }
      }
    }
  }, {
    key: '_checkAppendedParsed',
    value: function _checkAppendedParsed() {
      //trigger handler right now
      if (this.state === State.PARSED && (!this.appended || !this.pendingBuffering)) {
        var frag = this.fragCurrent,
            stats = this.stats,
            hls = this.hls;
        if (frag) {
          this.fragPrevious = frag;
          stats.tbuffered = performance.now();
          hls.trigger(_events2.default.FRAG_BUFFERED, { stats: stats, frag: frag, id: 'audio' });
          var media = this.mediaBuffer ? this.mediaBuffer : this.media;
          _logger.logger.log('audio buffered : ' + _timeRanges2.default.toString(media.buffered));
          if (this.audioSwitch && this.appended) {
            this.audioSwitch = false;
            hls.trigger(_events2.default.AUDIO_TRACK_SWITCHED, { id: this.trackId });
          }
          this.state = State.IDLE;
        }
        this.tick();
      }
    }
  }, {
    key: 'onError',
    value: function onError(data) {
      var frag = data.frag;
      // don't handle frag error not related to audio fragment
      if (frag && frag.type !== 'audio') {
        return;
      }
      switch (data.details) {
        case _errors.ErrorDetails.FRAG_LOAD_ERROR:
        case _errors.ErrorDetails.FRAG_LOAD_TIMEOUT:
          if (!data.fatal) {
            var loadError = this.fragLoadError;
            if (loadError) {
              loadError++;
            } else {
              loadError = 1;
            }
            var config = this.config;
            if (loadError <= config.fragLoadingMaxRetry) {
              this.fragLoadError = loadError;
              // reset load counter to avoid frag loop loading error
              frag.loadCounter = 0;
              // exponential backoff capped to config.fragLoadingMaxRetryTimeout
              var delay = Math.min(Math.pow(2, loadError - 1) * config.fragLoadingRetryDelay, config.fragLoadingMaxRetryTimeout);
              _logger.logger.warn('audioStreamController: frag loading failed, retry in ' + delay + ' ms');
              this.retryDate = performance.now() + delay;
              // retry loading state
              this.state = State.FRAG_LOADING_WAITING_RETRY;
            } else {
              _logger.logger.error('audioStreamController: ' + data.details + ' reaches max retry, redispatch as fatal ...');
              // switch error to fatal
              data.fatal = true;
              this.state = State.ERROR;
            }
          }
          break;
        case _errors.ErrorDetails.FRAG_LOOP_LOADING_ERROR:
        case _errors.ErrorDetails.AUDIO_TRACK_LOAD_ERROR:
        case _errors.ErrorDetails.AUDIO_TRACK_LOAD_TIMEOUT:
        case _errors.ErrorDetails.KEY_LOAD_ERROR:
        case _errors.ErrorDetails.KEY_LOAD_TIMEOUT:
          //  when in ERROR state, don't switch back to IDLE state in case a non-fatal error is received
          if (this.state !== State.ERROR) {
            // if fatal error, stop processing, otherwise move to IDLE to retry loading
            this.state = data.fatal ? State.ERROR : State.IDLE;
            _logger.logger.warn('audioStreamController: ' + data.details + ' while loading frag,switch to ' + this.state + ' state ...');
          }
          break;
        case _errors.ErrorDetails.BUFFER_FULL_ERROR:
          // if in appending state
          if (data.parent === 'audio' && (this.state === State.PARSING || this.state === State.PARSED)) {
            var media = this.mediaBuffer,
                currentTime = this.media.currentTime,
                mediaBuffered = media && _bufferHelper2.default.isBuffered(media, currentTime) && _bufferHelper2.default.isBuffered(media, currentTime + 0.5);
            // reduce max buf len if current position is buffered
            if (mediaBuffered) {
              var _config = this.config;
              if (_config.maxMaxBufferLength >= _config.maxBufferLength) {
                // reduce max buffer length as it might be too high. we do this to avoid loop flushing ...
                _config.maxMaxBufferLength /= 2;
                _logger.logger.warn('audio:reduce max buffer length to ' + _config.maxMaxBufferLength + 's');
                // increase fragment load Index to avoid frag loop loading error after buffer flush
                this.fragLoadIdx += 2 * _config.fragLoadingLoopThreshold;
              }
              this.state = State.IDLE;
            } else {
              // current position is not buffered, but browser is still complaining about buffer full error
              // this happens on IE/Edge, refer to https://github.com/video-dev/hls.js/pull/708
              // in that case flush the whole audio buffer to recover
              _logger.logger.warn('buffer full error also media.currentTime is not buffered, flush audio buffer');
              this.fragCurrent = null;
              // flush everything
              this.state = State.BUFFER_FLUSHING;
              this.hls.trigger(_events2.default.BUFFER_FLUSHING, { startOffset: 0, endOffset: Number.POSITIVE_INFINITY, type: 'audio' });
            }
          }
          break;
        default:
          break;
      }
    }
  }, {
    key: 'onBufferFlushed',
    value: function onBufferFlushed() {
      var _this4 = this;

      var pendingData = this.pendingData;
      if (pendingData && pendingData.length) {
        _logger.logger.log('appending pending audio data on Buffer Flushed');
        pendingData.forEach(function (appendObj) {
          _this4.hls.trigger(_events2.default.BUFFER_APPENDING, appendObj);
        });
        this.appended = true;
        this.pendingData = [];
        this.state = State.PARSED;
      } else {
        // move to IDLE once flush complete. this should trigger new fragment loading
        this.state = State.IDLE;
        // reset reference to frag
        this.fragPrevious = null;
        this.tick();
      }
    }
  }, {
    key: 'state',
    set: function set(nextState) {
      if (this.state !== nextState) {
        var previousState = this.state;
        this._state = nextState;
        _logger.logger.log('audio stream:' + previousState + '->' + nextState);
      }
    },
    get: function get() {
      return this._state;
    }
  }]);

  return AudioStreamController;
}(_eventHandler2.default);

exports.default = AudioStreamController;

},{"../demux/demuxer":24,"../errors":30,"../event-handler":31,"../events":32,"../helper/buffer-helper":34,"../helper/level-helper":35,"../utils/binary-search":45,"../utils/discontinuities":48,"../utils/logger":51,"../utils/timeRanges":52}],7:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _eventHandler = require('../event-handler');

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _logger = require('../utils/logger');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * audio track controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

var AudioTrackController = function (_EventHandler) {
  _inherits(AudioTrackController, _EventHandler);

  function AudioTrackController(hls) {
    _classCallCheck(this, AudioTrackController);

    var _this = _possibleConstructorReturn(this, (AudioTrackController.__proto__ || Object.getPrototypeOf(AudioTrackController)).call(this, hls, _events2.default.MANIFEST_LOADING, _events2.default.MANIFEST_LOADED, _events2.default.AUDIO_TRACK_LOADED));

    _this.ticks = 0;
    _this.ontick = _this.tick.bind(_this);
    return _this;
  }

  _createClass(AudioTrackController, [{
    key: 'destroy',
    value: function destroy() {
      _eventHandler2.default.prototype.destroy.call(this);
    }
  }, {
    key: 'tick',
    value: function tick() {
      this.ticks++;
      if (this.ticks === 1) {
        this.doTick();
        if (this.ticks > 1) {
          setTimeout(this.tick, 1);
        }
        this.ticks = 0;
      }
    }
  }, {
    key: 'doTick',
    value: function doTick() {
      this.updateTrack(this.trackId);
    }
  }, {
    key: 'onManifestLoading',
    value: function onManifestLoading() {
      // reset audio tracks on manifest loading
      this.tracks = [];
      this.trackId = -1;
    }
  }, {
    key: 'onManifestLoaded',
    value: function onManifestLoaded(data) {
      var _this2 = this;

      var tracks = data.audioTracks || [];
      var defaultFound = false;
      this.tracks = tracks;
      this.hls.trigger(_events2.default.AUDIO_TRACKS_UPDATED, { audioTracks: tracks });
      // loop through available audio tracks and autoselect default if needed
      var id = 0;
      tracks.forEach(function (track) {
        if (track.default) {
          _this2.audioTrack = id;
          defaultFound = true;
          return;
        }
        id++;
      });
      if (defaultFound === false && tracks.length) {
        _logger.logger.log('no default audio track defined, use first audio track as default');
        this.audioTrack = 0;
      }
    }
  }, {
    key: 'onAudioTrackLoaded',
    value: function onAudioTrackLoaded(data) {
      if (data.id < this.tracks.length) {
        _logger.logger.log('audioTrack ' + data.id + ' loaded');
        this.tracks[data.id].details = data.details;
        // check if current playlist is a live playlist
        if (data.details.live && !this.timer) {
          // if live playlist we will have to reload it periodically
          // set reload period to playlist target duration
          this.timer = setInterval(this.ontick, 1000 * data.details.targetduration);
        }
        if (!data.details.live && this.timer) {
          // playlist is not live and timer is armed : stopping it
          clearInterval(this.timer);
          this.timer = null;
        }
      }
    }

    /** get alternate audio tracks list from playlist **/

  }, {
    key: 'setAudioTrackInternal',
    value: function setAudioTrackInternal(newId) {
      // check if level idx is valid
      if (newId >= 0 && newId < this.tracks.length) {
        // stopping live reloading timer if any
        if (this.timer) {
          clearInterval(this.timer);
          this.timer = null;
        }
        this.trackId = newId;
        _logger.logger.log('switching to audioTrack ' + newId);
        var audioTrack = this.tracks[newId],
            hls = this.hls,
            type = audioTrack.type,
            url = audioTrack.url,
            eventObj = { id: newId, type: type, url: url };
        // keep AUDIO_TRACK_SWITCH for legacy reason
        hls.trigger(_events2.default.AUDIO_TRACK_SWITCH, eventObj);
        hls.trigger(_events2.default.AUDIO_TRACK_SWITCHING, eventObj);
        // check if we need to load playlist for this audio Track
        var details = audioTrack.details;
        if (url && (details === undefined || details.live === true)) {
          // track not retrieved yet, or live playlist we need to (re)load it
          _logger.logger.log('(re)loading playlist for audioTrack ' + newId);
          hls.trigger(_events2.default.AUDIO_TRACK_LOADING, { url: url, id: newId });
        }
      }
    }
  }, {
    key: 'updateTrack',
    value: function updateTrack(newId) {
      // check if level idx is valid
      if (newId >= 0 && newId < this.tracks.length) {
        // stopping live reloading timer if any
        if (this.timer) {
          clearInterval(this.timer);
          this.timer = null;
        }
        this.trackId = newId;
        _logger.logger.log('updating audioTrack ' + newId);
        var audioTrack = this.tracks[newId],
            url = audioTrack.url;
        // check if we need to load playlist for this audio Track
        var details = audioTrack.details;
        if (url && (details === undefined || details.live === true)) {
          // track not retrieved yet, or live playlist we need to (re)load it
          _logger.logger.log('(re)loading playlist for audioTrack ' + newId);
          this.hls.trigger(_events2.default.AUDIO_TRACK_LOADING, { url: url, id: newId });
        }
      }
    }
  }, {
    key: 'audioTracks',
    get: function get() {
      return this.tracks;
    }

    /** get index of the selected audio track (index in audio track lists) **/

  }, {
    key: 'audioTrack',
    get: function get() {
      return this.trackId;
    }

    /** select an audio track, based on its index in audio track lists**/
    ,
    set: function set(audioTrackId) {
      if (this.trackId !== audioTrackId || this.tracks[audioTrackId].details === undefined) {
        this.setAudioTrackInternal(audioTrackId);
      }
    }
  }]);

  return AudioTrackController;
}(_eventHandler2.default);

exports.default = AudioTrackController;

},{"../event-handler":31,"../events":32,"../utils/logger":51}],8:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _eventHandler = require('../event-handler');

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _logger = require('../utils/logger');

var _errors = require('../errors');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Buffer Controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

var BufferController = function (_EventHandler) {
  _inherits(BufferController, _EventHandler);

  function BufferController(hls) {
    _classCallCheck(this, BufferController);

    // the value that we have set mediasource.duration to
    // (the actual duration may be tweaked slighly by the browser)
    var _this = _possibleConstructorReturn(this, (BufferController.__proto__ || Object.getPrototypeOf(BufferController)).call(this, hls, _events2.default.MEDIA_ATTACHING, _events2.default.MEDIA_DETACHING, _events2.default.MANIFEST_PARSED, _events2.default.BUFFER_RESET, _events2.default.BUFFER_APPENDING, _events2.default.BUFFER_CODECS, _events2.default.BUFFER_EOS, _events2.default.BUFFER_FLUSHING, _events2.default.LEVEL_PTS_UPDATED, _events2.default.LEVEL_UPDATED));

    _this._msDuration = null;
    // the value that we want to set mediaSource.duration to
    _this._levelDuration = null;

    // Source Buffer listeners
    _this.onsbue = _this.onSBUpdateEnd.bind(_this);
    _this.onsbe = _this.onSBUpdateError.bind(_this);
    _this.pendingTracks = {};
    _this.tracks = {};
    return _this;
  }

  _createClass(BufferController, [{
    key: 'destroy',
    value: function destroy() {
      _eventHandler2.default.prototype.destroy.call(this);
    }
  }, {
    key: 'onLevelPtsUpdated',
    value: function onLevelPtsUpdated(data) {
      var type = data.type;
      var audioTrack = this.tracks.audio;

      // Adjusting `SourceBuffer.timestampOffset` (desired point in the timeline where the next frames should be appended)
      // in Chrome browser when we detect MPEG audio container and time delta between level PTS and `SourceBuffer.timestampOffset`
      // is greater than 100ms (this is enough to handle seek for VOD or level change for LIVE videos). At the time of change we issue
      // `SourceBuffer.abort()` and adjusting `SourceBuffer.timestampOffset` if `SourceBuffer.updating` is false or awaiting `updateend`
      // event if SB is in updating state.
      // More info here: https://github.com/video-dev/hls.js/issues/332#issuecomment-257986486

      if (type === 'audio' && audioTrack && audioTrack.container === 'audio/mpeg') {
        // Chrome audio mp3 track
        var audioBuffer = this.sourceBuffer.audio;
        var delta = Math.abs(audioBuffer.timestampOffset - data.start);

        // adjust timestamp offset if time delta is greater than 100ms
        if (delta > 0.1) {
          var updating = audioBuffer.updating;

          try {
            audioBuffer.abort();
          } catch (err) {
            updating = true;
            _logger.logger.warn('can not abort audio buffer: ' + err);
          }

          if (!updating) {
            _logger.logger.warn('change mpeg audio timestamp offset from ' + audioBuffer.timestampOffset + ' to ' + data.start);
            audioBuffer.timestampOffset = data.start;
          } else {
            this.audioTimestampOffset = data.start;
          }
        }
      }
    }
  }, {
    key: 'onManifestParsed',
    value: function onManifestParsed(data) {
      var audioExpected = data.audio,
          videoExpected = data.video,
          sourceBufferNb = 0;
      // in case of alt audio 2 BUFFER_CODECS events will be triggered, one per stream controller
      // sourcebuffers will be created all at once when the expected nb of tracks will be reached
      // in case alt audio is not used, only one BUFFER_CODEC event will be fired from main stream controller
      // it will contain the expected nb of source buffers, no need to compute it
      if (data.altAudio && (audioExpected || videoExpected)) {
        sourceBufferNb = (audioExpected ? 1 : 0) + (videoExpected ? 1 : 0);
        _logger.logger.log(sourceBufferNb + ' sourceBuffer(s) expected');
      }
      this.sourceBufferNb = sourceBufferNb;
    }
  }, {
    key: 'onMediaAttaching',
    value: function onMediaAttaching(data) {
      var media = this.media = data.media;
      if (media) {
        // setup the media source
        var ms = this.mediaSource = new MediaSource();
        //Media Source listeners
        this.onmso = this.onMediaSourceOpen.bind(this);
        this.onmse = this.onMediaSourceEnded.bind(this);
        this.onmsc = this.onMediaSourceClose.bind(this);
        ms.addEventListener('sourceopen', this.onmso);
        ms.addEventListener('sourceended', this.onmse);
        ms.addEventListener('sourceclose', this.onmsc);
        // link video and media Source
        media.src = URL.createObjectURL(ms);
      }
    }
  }, {
    key: 'onMediaDetaching',
    value: function onMediaDetaching() {
      _logger.logger.log('media source detaching');
      var ms = this.mediaSource;
      if (ms) {
        if (ms.readyState === 'open') {
          try {
            // endOfStream could trigger exception if any sourcebuffer is in updating state
            // we don't really care about checking sourcebuffer state here,
            // as we are anyway detaching the MediaSource
            // let's just avoid this exception to propagate
            ms.endOfStream();
          } catch (err) {
            _logger.logger.warn('onMediaDetaching:' + err.message + ' while calling endOfStream');
          }
        }
        ms.removeEventListener('sourceopen', this.onmso);
        ms.removeEventListener('sourceended', this.onmse);
        ms.removeEventListener('sourceclose', this.onmsc);

        // Detach properly the MediaSource from the HTMLMediaElement as
        // suggested in https://github.com/w3c/media-source/issues/53.
        if (this.media) {
          URL.revokeObjectURL(this.media.src);
          this.media.removeAttribute('src');
          this.media.load();
        }

        this.mediaSource = null;
        this.media = null;
        this.pendingTracks = {};
        this.tracks = {};
        this.sourceBuffer = {};
        this.flushRange = [];
        this.segments = [];
        this.appended = 0;
      }
      this.onmso = this.onmse = this.onmsc = null;
      this.hls.trigger(_events2.default.MEDIA_DETACHED);
    }
  }, {
    key: 'onMediaSourceOpen',
    value: function onMediaSourceOpen() {
      _logger.logger.log('media source opened');
      this.hls.trigger(_events2.default.MEDIA_ATTACHED, { media: this.media });
      var mediaSource = this.mediaSource;
      if (mediaSource) {
        // once received, don't listen anymore to sourceopen event
        mediaSource.removeEventListener('sourceopen', this.onmso);
      }
      this.checkPendingTracks();
    }
  }, {
    key: 'checkPendingTracks',
    value: function checkPendingTracks() {
      // if any buffer codecs pending, check if we have enough to create sourceBuffers
      var pendingTracks = this.pendingTracks,
          pendingTracksNb = Object.keys(pendingTracks).length;
      // if any pending tracks and (if nb of pending tracks gt or equal than expected nb or if unknown expected nb)
      if (pendingTracksNb && (this.sourceBufferNb <= pendingTracksNb || this.sourceBufferNb === 0)) {
        // ok, let's create them now !
        this.createSourceBuffers(pendingTracks);
        this.pendingTracks = {};
        // append any pending segments now !
        this.doAppending();
      }
    }
  }, {
    key: 'onMediaSourceClose',
    value: function onMediaSourceClose() {
      _logger.logger.log('media source closed');
    }
  }, {
    key: 'onMediaSourceEnded',
    value: function onMediaSourceEnded() {
      _logger.logger.log('media source ended');
    }
  }, {
    key: 'onSBUpdateEnd',
    value: function onSBUpdateEnd() {
      // update timestampOffset
      if (this.audioTimestampOffset) {
        var audioBuffer = this.sourceBuffer.audio;
        _logger.logger.warn('change mpeg audio timestamp offset from ' + audioBuffer.timestampOffset + ' to ' + this.audioTimestampOffset);
        audioBuffer.timestampOffset = this.audioTimestampOffset;
        delete this.audioTimestampOffset;
      }

      if (this._needsFlush) {
        this.doFlush();
      }

      if (this._needsEos) {
        this.checkEos();
      }
      this.appending = false;
      var parent = this.parent;
      // count nb of pending segments waiting for appending on this sourcebuffer
      var pending = this.segments.reduce(function (counter, segment) {
        return segment.parent === parent ? counter + 1 : counter;
      }, 0);
      this.hls.trigger(_events2.default.BUFFER_APPENDED, { parent: parent, pending: pending });

      // don't append in flushing mode
      if (!this._needsFlush) {
        this.doAppending();
      }

      this.updateMediaElementDuration();
    }
  }, {
    key: 'onSBUpdateError',
    value: function onSBUpdateError(event) {
      _logger.logger.error('sourceBuffer error:', event);
      // according to http://www.w3.org/TR/media-source/#sourcebuffer-append-error
      // this error might not always be fatal (it is fatal if decode error is set, in that case
      // it will be followed by a mediaElement error ...)
      this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.BUFFER_APPENDING_ERROR, fatal: false });
      // we don't need to do more than that, as accordin to the spec, updateend will be fired just after
    }
  }, {
    key: 'onBufferReset',
    value: function onBufferReset() {
      var sourceBuffer = this.sourceBuffer;
      for (var type in sourceBuffer) {
        var sb = sourceBuffer[type];
        try {
          this.mediaSource.removeSourceBuffer(sb);
          sb.removeEventListener('updateend', this.onsbue);
          sb.removeEventListener('error', this.onsbe);
        } catch (err) {}
      }
      this.sourceBuffer = {};
      this.flushRange = [];
      this.segments = [];
      this.appended = 0;
    }
  }, {
    key: 'onBufferCodecs',
    value: function onBufferCodecs(tracks) {
      // if source buffer(s) not created yet, appended buffer tracks in this.pendingTracks
      // if sourcebuffers already created, do nothing ...
      if (Object.keys(this.sourceBuffer).length === 0) {
        for (var trackName in tracks) {
          this.pendingTracks[trackName] = tracks[trackName];
        }
        var mediaSource = this.mediaSource;
        if (mediaSource && mediaSource.readyState === 'open') {
          // try to create sourcebuffers if mediasource opened
          this.checkPendingTracks();
        }
      }
    }
  }, {
    key: 'createSourceBuffers',
    value: function createSourceBuffers(tracks) {
      var sourceBuffer = this.sourceBuffer,
          mediaSource = this.mediaSource;

      for (var trackName in tracks) {
        if (!sourceBuffer[trackName]) {
          var track = tracks[trackName];
          // use levelCodec as first priority
          var codec = track.levelCodec || track.codec;
          var mimeType = track.container + ';codecs=' + codec;
          _logger.logger.log('creating sourceBuffer(' + mimeType + ')');
          try {
            var sb = sourceBuffer[trackName] = mediaSource.addSourceBuffer(mimeType);
            sb.addEventListener('updateend', this.onsbue);
            sb.addEventListener('error', this.onsbe);
            this.tracks[trackName] = { codec: codec, container: track.container };
            track.buffer = sb;
          } catch (err) {
            _logger.logger.error('error while trying to add sourceBuffer:' + err.message);
            this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.BUFFER_ADD_CODEC_ERROR, fatal: false, err: err, mimeType: mimeType });
          }
        }
      }
      this.hls.trigger(_events2.default.BUFFER_CREATED, { tracks: tracks });
    }
  }, {
    key: 'onBufferAppending',
    value: function onBufferAppending(data) {
      if (!this._needsFlush) {
        if (!this.segments) {
          this.segments = [data];
        } else {
          this.segments.push(data);
        }
        this.doAppending();
      }
    }
  }, {
    key: 'onBufferAppendFail',
    value: function onBufferAppendFail(data) {
      _logger.logger.error('sourceBuffer error:', data.event);
      // according to http://www.w3.org/TR/media-source/#sourcebuffer-append-error
      // this error might not always be fatal (it is fatal if decode error is set, in that case
      // it will be followed by a mediaElement error ...)
      this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.BUFFER_APPENDING_ERROR, fatal: false });
    }

    // on BUFFER_EOS mark matching sourcebuffer(s) as ended and trigger checkEos()

  }, {
    key: 'onBufferEos',
    value: function onBufferEos(data) {
      var sb = this.sourceBuffer;
      var dataType = data.type;
      for (var type in sb) {
        if (!dataType || type === dataType) {
          if (!sb[type].ended) {
            sb[type].ended = true;
            _logger.logger.log(type + ' sourceBuffer now EOS');
          }
        }
      }
      this.checkEos();
    }

    // if all source buffers are marked as ended, signal endOfStream() to MediaSource.

  }, {
    key: 'checkEos',
    value: function checkEos() {
      var sb = this.sourceBuffer,
          mediaSource = this.mediaSource;
      if (!mediaSource || mediaSource.readyState !== 'open') {
        this._needsEos = false;
        return;
      }
      for (var type in sb) {
        var sbobj = sb[type];
        if (!sbobj.ended) {
          return;
        }
        if (sbobj.updating) {
          this._needsEos = true;
          return;
        }
      }
      _logger.logger.log('all media data available, signal endOfStream() to MediaSource and stop loading fragment');
      //Notify the media element that it now has all of the media data
      try {
        mediaSource.endOfStream();
      } catch (e) {
        _logger.logger.warn('exception while calling mediaSource.endOfStream()');
      }
      this._needsEos = false;
    }
  }, {
    key: 'onBufferFlushing',
    value: function onBufferFlushing(data) {
      this.flushRange.push({ start: data.startOffset, end: data.endOffset, type: data.type });
      // attempt flush immediatly
      this.flushBufferCounter = 0;
      this.doFlush();
    }
  }, {
    key: 'onLevelUpdated',
    value: function onLevelUpdated(event) {
      var details = event.details;
      if (details.fragments.length === 0) {
        return;
      }
      this._levelDuration = details.totalduration + details.fragments[0].start;
      this.updateMediaElementDuration();
    }

    // https://github.com/video-dev/hls.js/issues/355

  }, {
    key: 'updateMediaElementDuration',
    value: function updateMediaElementDuration() {
      var media = this.media,
          mediaSource = this.mediaSource,
          sourceBuffer = this.sourceBuffer,
          levelDuration = this._levelDuration;
      if (levelDuration === null || !media || !mediaSource || !sourceBuffer || media.readyState === 0 || mediaSource.readyState !== 'open') {
        return;
      }
      for (var type in sourceBuffer) {
        if (sourceBuffer[type].updating) {
          // can't set duration whilst a buffer is updating
          return;
        }
      }
      if (this._msDuration === null) {
        // initialise to the value that the media source is reporting
        this._msDuration = mediaSource.duration;
      }
      var duration = media.duration;
      // levelDuration was the last value we set.
      // not using mediaSource.duration as the browser may tweak this value
      // only update mediasource duration if its value increase, this is to avoid
      // flushing already buffered portion when switching between quality level
      if (levelDuration > this._msDuration && levelDuration > duration || duration === Infinity || isNaN(duration)) {
        _logger.logger.log('Updating mediasource duration to ' + levelDuration.toFixed(3));
        this._msDuration = mediaSource.duration = levelDuration;
      }
    }
  }, {
    key: 'doFlush',
    value: function doFlush() {
      // loop through all buffer ranges to flush
      while (this.flushRange.length) {
        var range = this.flushRange[0];
        // flushBuffer will abort any buffer append in progress and flush Audio/Video Buffer
        if (this.flushBuffer(range.start, range.end, range.type)) {
          // range flushed, remove from flush array
          this.flushRange.shift();
          this.flushBufferCounter = 0;
        } else {
          this._needsFlush = true;
          // avoid looping, wait for SB update end to retrigger a flush
          return;
        }
      }
      if (this.flushRange.length === 0) {
        // everything flushed
        this._needsFlush = false;

        // let's recompute this.appended, which is used to avoid flush looping
        var appended = 0;
        var sourceBuffer = this.sourceBuffer;
        try {
          for (var type in sourceBuffer) {
            appended += sourceBuffer[type].buffered.length;
          }
        } catch (error) {
          // error could be thrown while accessing buffered, in case sourcebuffer has already been removed from MediaSource
          // this is harmess at this stage, catch this to avoid reporting an internal exception
          _logger.logger.error('error while accessing sourceBuffer.buffered');
        }
        this.appended = appended;
        this.hls.trigger(_events2.default.BUFFER_FLUSHED);
      }
    }
  }, {
    key: 'doAppending',
    value: function doAppending() {
      var hls = this.hls,
          sourceBuffer = this.sourceBuffer,
          segments = this.segments;
      if (Object.keys(sourceBuffer).length) {
        if (this.media.error) {
          this.segments = [];
          _logger.logger.error('trying to append although a media error occured, flush segment and abort');
          return;
        }
        if (this.appending) {
          //logger.log(`sb appending in progress`);
          return;
        }
        if (segments && segments.length) {
          var segment = segments.shift();
          try {
            var type = segment.type,
                sb = sourceBuffer[type];
            if (sb) {
              if (!sb.updating) {
                // reset sourceBuffer ended flag before appending segment
                sb.ended = false;
                //logger.log(`appending ${segment.content} ${type} SB, size:${segment.data.length}, ${segment.parent}`);
                this.parent = segment.parent;
                sb.appendBuffer(segment.data);
                this.appendError = 0;
                this.appended++;
                this.appending = true;
              } else {
                segments.unshift(segment);
              }
            } else {
              // in case we don't have any source buffer matching with this segment type,
              // it means that Mediasource fails to create sourcebuffer
              // discard this segment, and trigger update end
              this.onSBUpdateEnd();
            }
          } catch (err) {
            // in case any error occured while appending, put back segment in segments table
            _logger.logger.error('error while trying to append buffer:' + err.message);
            segments.unshift(segment);
            var event = { type: _errors.ErrorTypes.MEDIA_ERROR, parent: segment.parent };
            if (err.code !== 22) {
              if (this.appendError) {
                this.appendError++;
              } else {
                this.appendError = 1;
              }
              event.details = _errors.ErrorDetails.BUFFER_APPEND_ERROR;
              /* with UHD content, we could get loop of quota exceeded error until
                browser is able to evict some data from sourcebuffer. retrying help recovering this
              */
              if (this.appendError > hls.config.appendErrorMaxRetry) {
                _logger.logger.log('fail ' + hls.config.appendErrorMaxRetry + ' times to append segment in sourceBuffer');
                segments = [];
                event.fatal = true;
                hls.trigger(_events2.default.ERROR, event);
                return;
              } else {
                event.fatal = false;
                hls.trigger(_events2.default.ERROR, event);
              }
            } else {
              // QuotaExceededError: http://www.w3.org/TR/html5/infrastructure.html#quotaexceedederror
              // let's stop appending any segments, and report BUFFER_FULL_ERROR error
              this.segments = [];
              event.details = _errors.ErrorDetails.BUFFER_FULL_ERROR;
              event.fatal = false;
              hls.trigger(_events2.default.ERROR, event);
              return;
            }
          }
        }
      }
    }

    /*
      flush specified buffered range,
      return true once range has been flushed.
      as sourceBuffer.remove() is asynchronous, flushBuffer will be retriggered on sourceBuffer update end
    */

  }, {
    key: 'flushBuffer',
    value: function flushBuffer(startOffset, endOffset, typeIn) {
      var sb,
          i,
          bufStart,
          bufEnd,
          flushStart,
          flushEnd,
          sourceBuffer = this.sourceBuffer;
      if (Object.keys(sourceBuffer).length) {
        _logger.logger.log('flushBuffer,pos/start/end: ' + this.media.currentTime.toFixed(3) + '/' + startOffset + '/' + endOffset);
        // safeguard to avoid infinite looping : don't try to flush more than the nb of appended segments
        if (this.flushBufferCounter < this.appended) {
          for (var type in sourceBuffer) {
            // check if sourcebuffer type is defined (typeIn): if yes, let's only flush this one
            // if no, let's flush all sourcebuffers
            if (typeIn && type !== typeIn) {
              continue;
            }
            sb = sourceBuffer[type];
            // we are going to flush buffer, mark source buffer as 'not ended'
            sb.ended = false;
            if (!sb.updating) {
              try {
                for (i = 0; i < sb.buffered.length; i++) {
                  bufStart = sb.buffered.start(i);
                  bufEnd = sb.buffered.end(i);
                  // workaround firefox not able to properly flush multiple buffered range.
                  if (navigator.userAgent.toLowerCase().indexOf('firefox') !== -1 && endOffset === Number.POSITIVE_INFINITY) {
                    flushStart = startOffset;
                    flushEnd = endOffset;
                  } else {
                    flushStart = Math.max(bufStart, startOffset);
                    flushEnd = Math.min(bufEnd, endOffset);
                  }
                  /* sometimes sourcebuffer.remove() does not flush
                     the exact expected time range.
                     to avoid rounding issues/infinite loop,
                     only flush buffer range of length greater than 500ms.
                  */
                  if (Math.min(flushEnd, bufEnd) - flushStart > 0.5) {
                    this.flushBufferCounter++;
                    _logger.logger.log('flush ' + type + ' [' + flushStart + ',' + flushEnd + '], of [' + bufStart + ',' + bufEnd + '], pos:' + this.media.currentTime);
                    sb.remove(flushStart, flushEnd);
                    return false;
                  }
                }
              } catch (e) {
                _logger.logger.warn('exception while accessing sourcebuffer, it might have been removed from MediaSource');
              }
            } else {
              //logger.log('abort ' + type + ' append in progress');
              // this will abort any appending in progress
              //sb.abort();
              _logger.logger.warn('cannot flush, sb updating in progress');
              return false;
            }
          }
        } else {
          _logger.logger.warn('abort flushing too many retries');
        }
        _logger.logger.log('buffer flushed');
      }
      // everything flushed !
      return true;
    }
  }]);

  return BufferController;
}(_eventHandler2.default);

exports.default = BufferController;

},{"../errors":30,"../event-handler":31,"../events":32,"../utils/logger":51}],9:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _eventHandler = require('../event-handler');

var _eventHandler2 = _interopRequireDefault(_eventHandler);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * cap stream level to media size dimension controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

var CapLevelController = function (_EventHandler) {
  _inherits(CapLevelController, _EventHandler);

  function CapLevelController(hls) {
    _classCallCheck(this, CapLevelController);

    return _possibleConstructorReturn(this, (CapLevelController.__proto__ || Object.getPrototypeOf(CapLevelController)).call(this, hls, _events2.default.FPS_DROP_LEVEL_CAPPING, _events2.default.MEDIA_ATTACHING, _events2.default.MANIFEST_PARSED));
  }

  _createClass(CapLevelController, [{
    key: 'destroy',
    value: function destroy() {
      if (this.hls.config.capLevelToPlayerSize) {
        this.media = this.restrictedLevels = null;
        this.autoLevelCapping = Number.POSITIVE_INFINITY;
        if (this.timer) {
          this.timer = clearInterval(this.timer);
        }
      }
    }
  }, {
    key: 'onFpsDropLevelCapping',
    value: function onFpsDropLevelCapping(data) {
      if (!this.restrictedLevels) {
        this.restrictedLevels = [];
      }
      if (!this.isLevelRestricted(data.droppedLevel)) {
        this.restrictedLevels.push(data.droppedLevel);
      }
    }
  }, {
    key: 'onMediaAttaching',
    value: function onMediaAttaching(data) {
      this.media = data.media instanceof HTMLVideoElement ? data.media : null;
    }
  }, {
    key: 'onManifestParsed',
    value: function onManifestParsed(data) {
      var hls = this.hls;
      if (hls.config.capLevelToPlayerSize) {
        this.autoLevelCapping = Number.POSITIVE_INFINITY;
        this.levels = data.levels;
        hls.firstLevel = this.getMaxLevel(data.firstLevel);
        clearInterval(this.timer);
        this.timer = setInterval(this.detectPlayerSize.bind(this), 1000);
        this.detectPlayerSize();
      }
    }
  }, {
    key: 'detectPlayerSize',
    value: function detectPlayerSize() {
      if (this.media) {
        var levelsLength = this.levels ? this.levels.length : 0;
        if (levelsLength) {
          var hls = this.hls;
          hls.autoLevelCapping = this.getMaxLevel(levelsLength - 1);
          if (hls.autoLevelCapping > this.autoLevelCapping) {
            // if auto level capping has a higher value for the previous one, flush the buffer using nextLevelSwitch
            // usually happen when the user go to the fullscreen mode.
            hls.streamController.nextLevelSwitch();
          }
          this.autoLevelCapping = hls.autoLevelCapping;
        }
      }
    }

    /*
    * returns level should be the one with the dimensions equal or greater than the media (player) dimensions (so the video will be downscaled)
    */

  }, {
    key: 'getMaxLevel',
    value: function getMaxLevel(capLevelIndex) {
      var result = 0,
          i = void 0,
          level = void 0,
          mWidth = this.mediaWidth,
          mHeight = this.mediaHeight,
          lWidth = 0,
          lHeight = 0;

      for (i = 0; i <= capLevelIndex; i++) {
        level = this.levels[i];
        if (this.isLevelRestricted(i)) {
          break;
        }
        result = i;
        lWidth = level.width;
        lHeight = level.height;
        if (mWidth <= lWidth || mHeight <= lHeight) {
          break;
        }
      }
      return result;
    }
  }, {
    key: 'isLevelRestricted',
    value: function isLevelRestricted(level) {
      return this.restrictedLevels && this.restrictedLevels.indexOf(level) !== -1 ? true : false;
    }
  }, {
    key: 'contentScaleFactor',
    get: function get() {
      var pixelRatio = 1;
      try {
        pixelRatio = window.devicePixelRatio;
      } catch (e) {}
      return pixelRatio;
    }
  }, {
    key: 'mediaWidth',
    get: function get() {
      var width = void 0;
      var media = this.media;
      if (media) {
        width = media.width || media.clientWidth || media.offsetWidth;
        width *= this.contentScaleFactor;
      }
      return width;
    }
  }, {
    key: 'mediaHeight',
    get: function get() {
      var height = void 0;
      var media = this.media;
      if (media) {
        height = media.height || media.clientHeight || media.offsetHeight;
        height *= this.contentScaleFactor;
      }
      return height;
    }
  }]);

  return CapLevelController;
}(_eventHandler2.default);

exports.default = CapLevelController;

},{"../event-handler":31,"../events":32}],10:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _eventHandler = require('../event-handler');

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _logger = require('../utils/logger');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * FPS Controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

var FPSController = function (_EventHandler) {
  _inherits(FPSController, _EventHandler);

  function FPSController(hls) {
    _classCallCheck(this, FPSController);

    return _possibleConstructorReturn(this, (FPSController.__proto__ || Object.getPrototypeOf(FPSController)).call(this, hls, _events2.default.MEDIA_ATTACHING));
  }

  _createClass(FPSController, [{
    key: 'destroy',
    value: function destroy() {
      if (this.timer) {
        clearInterval(this.timer);
      }
      this.isVideoPlaybackQualityAvailable = false;
    }
  }, {
    key: 'onMediaAttaching',
    value: function onMediaAttaching(data) {
      var config = this.hls.config;
      if (config.capLevelOnFPSDrop) {
        var video = this.video = data.media instanceof HTMLVideoElement ? data.media : null;
        if (typeof video.getVideoPlaybackQuality === 'function') {
          this.isVideoPlaybackQualityAvailable = true;
        }
        clearInterval(this.timer);
        this.timer = setInterval(this.checkFPSInterval.bind(this), config.fpsDroppedMonitoringPeriod);
      }
    }
  }, {
    key: 'checkFPS',
    value: function checkFPS(video, decodedFrames, droppedFrames) {
      var currentTime = performance.now();
      if (decodedFrames) {
        if (this.lastTime) {
          var currentPeriod = currentTime - this.lastTime,
              currentDropped = droppedFrames - this.lastDroppedFrames,
              currentDecoded = decodedFrames - this.lastDecodedFrames,
              droppedFPS = 1000 * currentDropped / currentPeriod,
              hls = this.hls;
          hls.trigger(_events2.default.FPS_DROP, { currentDropped: currentDropped, currentDecoded: currentDecoded, totalDroppedFrames: droppedFrames });
          if (droppedFPS > 0) {
            //logger.log('checkFPS : droppedFPS/decodedFPS:' + droppedFPS/(1000 * currentDecoded / currentPeriod));
            if (currentDropped > hls.config.fpsDroppedMonitoringThreshold * currentDecoded) {
              var currentLevel = hls.currentLevel;
              _logger.logger.warn('drop FPS ratio greater than max allowed value for currentLevel: ' + currentLevel);
              if (currentLevel > 0 && (hls.autoLevelCapping === -1 || hls.autoLevelCapping >= currentLevel)) {
                currentLevel = currentLevel - 1;
                hls.trigger(_events2.default.FPS_DROP_LEVEL_CAPPING, { level: currentLevel, droppedLevel: hls.currentLevel });
                hls.autoLevelCapping = currentLevel;
                hls.streamController.nextLevelSwitch();
              }
            }
          }
        }
        this.lastTime = currentTime;
        this.lastDroppedFrames = droppedFrames;
        this.lastDecodedFrames = decodedFrames;
      }
    }
  }, {
    key: 'checkFPSInterval',
    value: function checkFPSInterval() {
      var video = this.video;
      if (video) {
        if (this.isVideoPlaybackQualityAvailable) {
          var videoPlaybackQuality = video.getVideoPlaybackQuality();
          this.checkFPS(video, videoPlaybackQuality.totalVideoFrames, videoPlaybackQuality.droppedVideoFrames);
        } else {
          this.checkFPS(video, video.webkitDecodedFrameCount, video.webkitDroppedFrameCount);
        }
      }
    }
  }]);

  return FPSController;
}(_eventHandler2.default);

exports.default = FPSController;

},{"../event-handler":31,"../events":32,"../utils/logger":51}],11:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _eventHandler = require('../event-handler');

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _logger = require('../utils/logger');

var _errors = require('../errors');

var _bufferHelper = require('../helper/buffer-helper');

var _bufferHelper2 = _interopRequireDefault(_bufferHelper);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Level Controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

var LevelController = function (_EventHandler) {
  _inherits(LevelController, _EventHandler);

  function LevelController(hls) {
    _classCallCheck(this, LevelController);

    var _this = _possibleConstructorReturn(this, (LevelController.__proto__ || Object.getPrototypeOf(LevelController)).call(this, hls, _events2.default.MANIFEST_LOADED, _events2.default.LEVEL_LOADED, _events2.default.FRAG_LOADED, _events2.default.ERROR));

    _this.ontick = _this.tick.bind(_this);
    _this._manualLevel = -1;
    return _this;
  }

  _createClass(LevelController, [{
    key: 'destroy',
    value: function destroy() {
      if (this.timer) {
        clearTimeout(this.timer);
        this.timer = null;
      }
      this._manualLevel = -1;
    }
  }, {
    key: 'startLoad',
    value: function startLoad() {
      this.canload = true;
      var levels = this._levels;
      // clean up live level details to force reload them, and reset load errors
      if (levels) {
        levels.forEach(function (level) {
          level.loadError = 0;
          var levelDetails = level.details;
          if (levelDetails && levelDetails.live) {
            level.details = undefined;
          }
        });
      }
      // speed up live playlist refresh if timer exists
      if (this.timer) {
        this.tick();
      }
    }
  }, {
    key: 'stopLoad',
    value: function stopLoad() {
      this.canload = false;
    }
  }, {
    key: 'onManifestLoaded',
    value: function onManifestLoaded(data) {
      var levels0 = [],
          levels = [],
          bitrateStart,
          bitrateSet = {},
          videoCodecFound = false,
          audioCodecFound = false,
          hls = this.hls,
          brokenmp4inmp3 = /chrome|firefox/.test(navigator.userAgent.toLowerCase()),
          checkSupported = function checkSupported(type, codec) {
        return MediaSource.isTypeSupported(type + '/mp4;codecs=' + codec);
      };

      // regroup redundant level together
      data.levels.forEach(function (level) {
        if (level.videoCodec) {
          videoCodecFound = true;
        }
        // erase audio codec info if browser does not support mp4a.40.34. demuxer will autodetect codec and fallback to mpeg/audio
        if (brokenmp4inmp3 && level.audioCodec && level.audioCodec.indexOf('mp4a.40.34') !== -1) {
          level.audioCodec = undefined;
        }
        if (level.audioCodec || level.attrs && level.attrs.AUDIO) {
          audioCodecFound = true;
        }
        var redundantLevelId = bitrateSet[level.bitrate];
        if (redundantLevelId === undefined) {
          bitrateSet[level.bitrate] = levels0.length;
          level.url = [level.url];
          level.urlId = 0;
          levels0.push(level);
        } else {
          levels0[redundantLevelId].url.push(level.url);
        }
      });

      // remove audio-only level if we also have levels with audio+video codecs signalled
      if (videoCodecFound && audioCodecFound) {
        levels0.forEach(function (level) {
          if (level.videoCodec) {
            levels.push(level);
          }
        });
      } else {
        levels = levels0;
      }
      // only keep level with supported audio/video codecs
      levels = levels.filter(function (level) {
        var audioCodec = level.audioCodec,
            videoCodec = level.videoCodec;
        return (!audioCodec || checkSupported('audio', audioCodec)) && (!videoCodec || checkSupported('video', videoCodec));
      });

      if (levels.length) {
        // start bitrate is the first bitrate of the manifest
        bitrateStart = levels[0].bitrate;
        // sort level on bitrate
        levels.sort(function (a, b) {
          return a.bitrate - b.bitrate;
        });
        this._levels = levels;
        // find index of first level in sorted levels
        for (var i = 0; i < levels.length; i++) {
          if (levels[i].bitrate === bitrateStart) {
            this._firstLevel = i;
            _logger.logger.log('manifest loaded,' + levels.length + ' level(s) found, first bitrate:' + bitrateStart);
            break;
          }
        }
        hls.trigger(_events2.default.MANIFEST_PARSED, { levels: levels, firstLevel: this._firstLevel, stats: data.stats, audio: audioCodecFound, video: videoCodecFound, altAudio: data.audioTracks.length > 0 });
      } else {
        hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.MANIFEST_INCOMPATIBLE_CODECS_ERROR, fatal: true, url: hls.url, reason: 'no level with compatible codecs found in manifest' });
      }
      return;
    }
  }, {
    key: 'setLevelInternal',
    value: function setLevelInternal(newLevel) {
      var levels = this._levels;
      var hls = this.hls;
      // check if level idx is valid
      if (newLevel >= 0 && newLevel < levels.length) {
        // stopping live reloading timer if any
        if (this.timer) {
          clearTimeout(this.timer);
          this.timer = null;
        }
        if (this._level !== newLevel) {
          _logger.logger.log('switching to level ' + newLevel);
          this._level = newLevel;
          var levelProperties = levels[newLevel];
          levelProperties.level = newLevel;
          // LEVEL_SWITCH to be deprecated in next major release
          hls.trigger(_events2.default.LEVEL_SWITCH, levelProperties);
          hls.trigger(_events2.default.LEVEL_SWITCHING, levelProperties);
        }
        var level = levels[newLevel],
            levelDetails = level.details;
        // check if we need to load playlist for this level
        if (!levelDetails || levelDetails.live === true) {
          // level not retrieved yet, or live playlist we need to (re)load it
          var urlId = level.urlId;
          hls.trigger(_events2.default.LEVEL_LOADING, { url: level.url[urlId], level: newLevel, id: urlId });
        }
      } else {
        // invalid level id given, trigger error
        hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.OTHER_ERROR, details: _errors.ErrorDetails.LEVEL_SWITCH_ERROR, level: newLevel, fatal: false, reason: 'invalid level idx' });
      }
    }
  }, {
    key: 'onError',
    value: function onError(data) {
      if (data.fatal) {
        return;
      }

      var details = data.details,
          hls = this.hls,
          levelId = void 0,
          level = void 0,
          levelError = false;
      var removeLevel = false;
      // try to recover not fatal errors
      switch (details) {
        case _errors.ErrorDetails.FRAG_LOAD_ERROR:
        case _errors.ErrorDetails.FRAG_LOAD_TIMEOUT:
        case _errors.ErrorDetails.FRAG_LOOP_LOADING_ERROR:
        case _errors.ErrorDetails.KEY_LOAD_ERROR:
        case _errors.ErrorDetails.KEY_LOAD_TIMEOUT:
          levelId = data.frag.level;
          break;
        case _errors.ErrorDetails.LEVEL_LOAD_ERROR:
        case _errors.ErrorDetails.LEVEL_LOAD_TIMEOUT:
          levelId = data.context.level;
          levelError = true;
          break;
        case _errors.ErrorDetails.REMUX_ALLOC_ERROR:
          levelId = data.level;
          break;
        case _errors.ErrorDetails.MANIFEST_EMPTY_ERROR:
          levelId = data.context.level;
          levelError = true;
          removeLevel = true;
          break;
        default:
          break;
      }
      /* try to switch to a redundant stream if any available.
       * if no redundant stream available, emergency switch down (if in auto mode and current level not 0)
       * otherwise, we cannot recover this network error ...
       */
      if (levelId !== undefined) {
        level = this._levels[levelId];
        if (!level.loadError) {
          level.loadError = 1;
        } else {
          level.loadError++;
        }
        // if any redundant streams available and if we haven't try them all (level.loadError is reseted on successful frag/level load.
        // if level.loadError reaches nbRedundantLevel it means that we tried them all, no hope  => let's switch down
        var nbRedundantLevel = level.url.length;
        if (nbRedundantLevel > 1 && level.loadError < nbRedundantLevel) {
          level.urlId = (level.urlId + 1) % nbRedundantLevel;
          level.details = undefined;
          _logger.logger.warn('level controller,' + details + ' for level ' + levelId + ': switching to redundant stream id ' + level.urlId);
        } else {
          if (removeLevel) {
            _logger.logger.warn('Bad level encountered, removing & forcing to auto mode');
            this._levels = this.levels.filter(function (l, index) {
              return index !== levelId;
            });
            hls.currentLevel = -1;
            hls.trigger(_events2.default.LEVEL_REMOVED, { level: levelId });
          }
          // we could try to recover if in auto mode and current level not lowest level (0)
          var recoverable = this._manualLevel === -1 && levelId;
          if (recoverable) {
            _logger.logger.warn('level controller,' + details + ': switch-down for next fragment');
            hls.nextAutoLevel = Math.max(0, levelId - 1);
          } else if (level && level.details && level.details.live) {
            _logger.logger.warn('level controller,' + details + ' on live stream, discard');
            if (levelError) {
              // reset this._level so that another call to set level() will retrigger a frag load
              this._level = undefined;
            }
            // other errors are handled by stream controller
          } else if (details === _errors.ErrorDetails.LEVEL_LOAD_ERROR || details === _errors.ErrorDetails.LEVEL_LOAD_TIMEOUT) {
            var media = hls.media,

            // 0.5 : tolerance needed as some browsers stalls playback before reaching buffered end
            mediaBuffered = media && _bufferHelper2.default.isBuffered(media, media.currentTime) && _bufferHelper2.default.isBuffered(media, media.currentTime + 0.5);
            if (mediaBuffered) {
              var retryDelay = hls.config.levelLoadingRetryDelay;
              _logger.logger.warn('level controller,' + details + ', but media buffered, retry in ' + retryDelay + 'ms');
              this.timer = setTimeout(this.ontick, retryDelay);
            } else {
              _logger.logger.error('cannot recover ' + details + ' error');
              this._level = undefined;
              // stopping live reloading timer if any
              if (this.timer) {
                clearTimeout(this.timer);
                this.timer = null;
              }
              // switch error to fatal
              data.fatal = true;
            }
          }
        }
      }
    }

    // reset level load error counter on successful frag loaded

  }, {
    key: 'onFragLoaded',
    value: function onFragLoaded(data) {
      var fragLoaded = data.frag;
      if (fragLoaded && fragLoaded.type === 'main') {
        var level = this._levels[fragLoaded.level];
        if (level) {
          level.loadError = 0;
        }
      }
    }
  }, {
    key: 'onLevelLoaded',
    value: function onLevelLoaded(data) {
      var levelId = data.level;
      // only process level loaded events matching with expected level
      if (levelId === this._level) {
        var curLevel = this._levels[levelId];
        // reset level load error counter on successful level loaded
        curLevel.loadError = 0;
        var newDetails = data.details;
        // if current playlist is a live playlist, arm a timer to reload it
        if (newDetails.live) {
          var reloadInterval = 1000 * (newDetails.averagetargetduration ? newDetails.averagetargetduration : newDetails.targetduration),
              _curLevel = this._levels[data.level],
              curDetails = _curLevel.details;
          if (curDetails && newDetails.endSN === curDetails.endSN) {
            // follow HLS Spec, If the client reloads a Playlist file and finds that it has not
            // changed then it MUST wait for a period of one-half the target
            // duration before retrying.
            reloadInterval /= 2;
            _logger.logger.log('same live playlist, reload twice faster');
          }
          // decrement reloadInterval with level loading delay
          reloadInterval -= performance.now() - data.stats.trequest;
          // in any case, don't reload more than every second
          reloadInterval = Math.max(1000, Math.round(reloadInterval));
          _logger.logger.log('live playlist, reload in ' + reloadInterval + ' ms');
          this.timer = setTimeout(this.ontick, reloadInterval);
        } else {
          this.timer = null;
        }
      }
    }
  }, {
    key: 'tick',
    value: function tick() {
      var levelId = this._level;
      if (levelId !== undefined && this.canload) {
        var level = this._levels[levelId];
        if (level && level.url) {
          var urlId = level.urlId;
          this.hls.trigger(_events2.default.LEVEL_LOADING, { url: level.url[urlId], level: levelId, id: urlId });
        }
      }
    }
  }, {
    key: 'levels',
    get: function get() {
      return this._levels;
    }
  }, {
    key: 'level',
    get: function get() {
      return this._level;
    },
    set: function set(newLevel) {
      var levels = this._levels;
      if (levels && levels.length > newLevel) {
        if (this._level !== newLevel || levels[newLevel].details === undefined) {
          this.setLevelInternal(newLevel);
        }
      }
    }
  }, {
    key: 'manualLevel',
    get: function get() {
      return this._manualLevel;
    },
    set: function set(newLevel) {
      this._manualLevel = newLevel;
      if (this._startLevel === undefined) {
        this._startLevel = newLevel;
      }
      if (newLevel !== -1) {
        this.level = newLevel;
      }
    }
  }, {
    key: 'firstLevel',
    get: function get() {
      return this._firstLevel;
    },
    set: function set(newLevel) {
      this._firstLevel = newLevel;
    }
  }, {
    key: 'startLevel',
    get: function get() {
      // hls.startLevel takes precedence over config.startLevel
      // if none of these values are defined, fallback on this._firstLevel (first quality level appearing in variant manifest)
      if (this._startLevel === undefined) {
        var configStartLevel = this.hls.config.startLevel;
        if (configStartLevel !== undefined) {
          return configStartLevel;
        } else {
          return this._firstLevel;
        }
      } else {
        return this._startLevel;
      }
    },
    set: function set(newLevel) {
      this._startLevel = newLevel;
    }
  }, {
    key: 'nextLoadLevel',
    get: function get() {
      if (this._manualLevel !== -1) {
        return this._manualLevel;
      } else {
        return this.hls.nextAutoLevel;
      }
    },
    set: function set(nextLevel) {
      this.level = nextLevel;
      if (this._manualLevel === -1) {
        this.hls.nextAutoLevel = nextLevel;
      }
    }
  }]);

  return LevelController;
}(_eventHandler2.default);

exports.default = LevelController;

},{"../errors":30,"../event-handler":31,"../events":32,"../helper/buffer-helper":34,"../utils/logger":51}],12:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _binarySearch = require('../utils/binary-search');

var _binarySearch2 = _interopRequireDefault(_binarySearch);

var _bufferHelper = require('../helper/buffer-helper');

var _bufferHelper2 = _interopRequireDefault(_bufferHelper);

var _demuxer = require('../demux/demuxer');

var _demuxer2 = _interopRequireDefault(_demuxer);

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _eventHandler = require('../event-handler');

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _levelHelper = require('../helper/level-helper');

var _levelHelper2 = _interopRequireDefault(_levelHelper);

var _timeRanges = require('../utils/timeRanges');

var _timeRanges2 = _interopRequireDefault(_timeRanges);

var _errors = require('../errors');

var _logger = require('../utils/logger');

var _discontinuities = require('../utils/discontinuities');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Stream Controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

var State = {
  STOPPED: 'STOPPED',
  IDLE: 'IDLE',
  KEY_LOADING: 'KEY_LOADING',
  FRAG_LOADING: 'FRAG_LOADING',
  FRAG_LOADING_WAITING_RETRY: 'FRAG_LOADING_WAITING_RETRY',
  WAITING_LEVEL: 'WAITING_LEVEL',
  PARSING: 'PARSING',
  PARSED: 'PARSED',
  BUFFER_FLUSHING: 'BUFFER_FLUSHING',
  ENDED: 'ENDED',
  ERROR: 'ERROR'
};

var StreamController = function (_EventHandler) {
  _inherits(StreamController, _EventHandler);

  function StreamController(hls) {
    _classCallCheck(this, StreamController);

    var _this = _possibleConstructorReturn(this, (StreamController.__proto__ || Object.getPrototypeOf(StreamController)).call(this, hls, _events2.default.MEDIA_ATTACHED, _events2.default.MEDIA_DETACHING, _events2.default.MANIFEST_LOADING, _events2.default.MANIFEST_PARSED, _events2.default.LEVEL_LOADED, _events2.default.KEY_LOADED, _events2.default.FRAG_LOADED, _events2.default.FRAG_LOAD_EMERGENCY_ABORTED, _events2.default.FRAG_PARSING_INIT_SEGMENT, _events2.default.FRAG_PARSING_DATA, _events2.default.FRAG_PARSED, _events2.default.ERROR, _events2.default.AUDIO_TRACK_SWITCHING, _events2.default.AUDIO_TRACK_SWITCHED, _events2.default.BUFFER_CREATED, _events2.default.BUFFER_APPENDED, _events2.default.BUFFER_FLUSHED, _events2.default.LEVEL_REMOVED));

    _this.config = hls.config;
    _this.audioCodecSwap = false;
    _this.ticks = 0;
    _this._state = State.STOPPED;
    _this.ontick = _this.tick.bind(_this);
    return _this;
  }

  _createClass(StreamController, [{
    key: 'destroy',
    value: function destroy() {
      this.stopLoad();
      if (this.timer) {
        clearInterval(this.timer);
        this.timer = null;
      }
      _eventHandler2.default.prototype.destroy.call(this);
      this.state = State.STOPPED;
    }
  }, {
    key: 'startLoad',
    value: function startLoad(startPosition) {
      if (this.levels) {
        var lastCurrentTime = this.lastCurrentTime,
            hls = this.hls;
        this.stopLoad();
        if (!this.timer) {
          this.timer = setInterval(this.ontick, 100);
        }
        this.level = -1;
        this.fragLoadError = 0;
        if (!this.startFragRequested) {
          // determine load level
          var startLevel = hls.startLevel;
          if (startLevel === -1) {
            // -1 : guess start Level by doing a bitrate test by loading first fragment of lowest quality level
            startLevel = 0;
            this.bitrateTest = true;
          }
          // set new level to playlist loader : this will trigger start level load
          // hls.nextLoadLevel remains until it is set to a new value or until a new frag is successfully loaded
          this.level = hls.nextLoadLevel = startLevel;
          this.loadedmetadata = false;
        }
        // if startPosition undefined but lastCurrentTime set, set startPosition to last currentTime
        if (lastCurrentTime > 0 && startPosition === -1) {
          _logger.logger.log('override startPosition with lastCurrentTime @' + lastCurrentTime.toFixed(3));
          startPosition = lastCurrentTime;
        }
        this.state = State.IDLE;
        this.nextLoadPosition = this.startPosition = this.lastCurrentTime = startPosition;
        this.tick();
      } else {
        this.forceStartLoad = true;
        this.state = State.STOPPED;
      }
    }
  }, {
    key: 'stopLoad',
    value: function stopLoad() {
      var frag = this.fragCurrent;
      if (frag) {
        if (frag.loader) {
          frag.loader.abort();
        }
        this.fragCurrent = null;
      }
      this.fragPrevious = null;
      if (this.demuxer) {
        this.demuxer.destroy();
        this.demuxer = null;
      }
      this.state = State.STOPPED;
      this.forceStartLoad = false;
    }
  }, {
    key: 'tick',
    value: function tick() {
      this.ticks++;
      if (this.ticks === 1) {
        this.doTick();
        if (this.ticks > 1) {
          setTimeout(this.tick, 1);
        }
        this.ticks = 0;
      }
    }
  }, {
    key: 'doTick',
    value: function doTick() {
      switch (this.state) {
        case State.ERROR:
          //don't do anything in error state to avoid breaking further ...
          break;
        case State.BUFFER_FLUSHING:
          // in buffer flushing state, reset fragLoadError counter
          this.fragLoadError = 0;
          break;
        case State.IDLE:
          // when this returns false there was an error and we shall return immediatly
          // from current tick
          if (!this._doTickIdle()) {
            return;
          }
          break;
        case State.WAITING_LEVEL:
          var level = this.levels[this.level];
          // check if playlist is already loaded
          if (level && level.details) {
            this.state = State.IDLE;
          }
          break;
        case State.FRAG_LOADING_WAITING_RETRY:
          var now = performance.now();
          var retryDate = this.retryDate;
          // if current time is gt than retryDate, or if media seeking let's switch to IDLE state to retry loading
          if (!retryDate || now >= retryDate || this.media && this.media.seeking) {
            _logger.logger.log('mediaController: retryDate reached, switch back to IDLE state');
            this.state = State.IDLE;
          }
          break;
        case State.ERROR:
        case State.STOPPED:
        case State.FRAG_LOADING:
        case State.PARSING:
        case State.PARSED:
        case State.ENDED:
          break;
        default:
          break;
      }
      // check buffer
      this._checkBuffer();
      // check/update current fragment
      this._checkFragmentChanged();
    }

    // Ironically the "idle" state is the on we do the most logic in it seems ....
    // NOTE: Maybe we could rather schedule a check for buffer length after half of the currently
    //       played segment, or on pause/play/seek instead of naively checking every 100ms?

  }, {
    key: '_doTickIdle',
    value: function _doTickIdle() {
      var hls = this.hls,
          config = hls.config,
          media = this.media;

      // if video not attached AND
      // start fragment already requested OR start frag prefetch disable
      // exit loop
      // => if start level loaded and media not attached but start frag prefetch is enabled and start frag not requested yet, we will not exit loop
      if (this.levelLastLoaded !== undefined && !media && (this.startFragRequested || !config.startFragPrefetch)) {
        return true;
      }

      // if we have not yet loaded any fragment, start loading from start position
      var pos = 0;
      if (this.loadedmetadata) {
        pos = media.currentTime;
      } else if (this.nextLoadPosition) {
        pos = this.nextLoadPosition;
      }

      // determine next load level
      var level = hls.nextLoadLevel,
          levelInfo = this.levels[level],
          levelBitrate = levelInfo.bitrate,
          maxBufLen = void 0;

      // compute max Buffer Length that we could get from this load level, based on level bitrate. don't buffer more than 60 MB and more than 30s
      if (levelBitrate) {
        maxBufLen = Math.max(8 * config.maxBufferSize / levelBitrate, config.maxBufferLength);
      } else {
        maxBufLen = config.maxBufferLength;
      }
      maxBufLen = Math.min(maxBufLen, config.maxMaxBufferLength);

      // determine next candidate fragment to be loaded, based on current position and end of buffer position
      // ensure up to `config.maxMaxBufferLength` of buffer upfront

      var bufferInfo = _bufferHelper2.default.bufferInfo(this.mediaBuffer ? this.mediaBuffer : media, pos, config.maxBufferHole),
          bufferLen = bufferInfo.len;
      // Stay idle if we are still with buffer margins
      if (bufferLen >= maxBufLen) {
        return true;
      }

      // if buffer length is less than maxBufLen try to load a new fragment ...
      _logger.logger.trace('buffer length of ' + bufferLen.toFixed(3) + ' is below max of ' + maxBufLen.toFixed(3) + '. checking for more payload ...');

      // set next load level : this will trigger a playlist load if needed
      this.level = hls.nextLoadLevel = level;

      var levelDetails = levelInfo.details;
      // if level info not retrieved yet, switch state and wait for level retrieval
      // if live playlist, ensure that new playlist has been refreshed to avoid loading/try to load
      // a useless and outdated fragment (that might even introduce load error if it is already out of the live playlist)
      if (typeof levelDetails === 'undefined' || levelDetails.live && this.levelLastLoaded !== level) {
        this.state = State.WAITING_LEVEL;
        return true;
      }

      // we just got done loading the final fragment, check if we need to finalize media stream
      var fragPrevious = this.fragPrevious;
      if (!levelDetails.live && fragPrevious && fragPrevious.sn === levelDetails.endSN) {
        // fragPrevious is last fragment. retrieve level duration using last frag start offset + duration
        // real duration might be lower than initial duration if there are drifts between real frag duration and playlist signaling
        var duration = Math.min(media.duration, fragPrevious.start + fragPrevious.duration);
        // if everything (almost) til the end is buffered, let's signal eos
        // we don't compare exactly media.duration === bufferInfo.end as there could be some subtle media duration difference
        // using half frag duration should help cope with these cases.
        // also cope with almost zero last frag duration (max last frag duration with 200ms) refer to https://github.com/video-dev/hls.js/pull/657
        if (duration - Math.max(bufferInfo.end, fragPrevious.start) <= Math.max(0.2, fragPrevious.duration / 2)) {
          // Finalize the media stream
          var data = {};
          if (this.altAudio) {
            data.type = 'video';
          }
          this.hls.trigger(_events2.default.BUFFER_EOS, data);
          this.state = State.ENDED;
          return true;
        }
      }

      // if we have the levelDetails for the selected variant, lets continue enrichen our stream (load keys/fragments or trigger EOS, etc..)
      return this._fetchPayloadOrEos(pos, bufferInfo, levelDetails);
    }
  }, {
    key: '_fetchPayloadOrEos',
    value: function _fetchPayloadOrEos(pos, bufferInfo, levelDetails) {
      var fragPrevious = this.fragPrevious,
          level = this.level,
          fragments = levelDetails.fragments,
          fragLen = fragments.length;

      // empty playlist
      if (fragLen === 0) {
        return false;
      }

      // find fragment index, contiguous with end of buffer position
      var start = fragments[0].start,
          end = fragments[fragLen - 1].start + fragments[fragLen - 1].duration,
          bufferEnd = bufferInfo.end,
          frag = void 0;

      if (levelDetails.initSegment && !levelDetails.initSegment.data) {
        frag = levelDetails.initSegment;
      } else {
        // in case of live playlist we need to ensure that requested position is not located before playlist start
        if (levelDetails.live) {
          var initialLiveManifestSize = this.config.initialLiveManifestSize;
          if (fragLen < initialLiveManifestSize) {
            _logger.logger.warn('Can not start playback of a level, reason: not enough fragments ' + fragLen + ' < ' + initialLiveManifestSize);
            return false;
          }

          frag = this._ensureFragmentAtLivePoint(levelDetails, bufferEnd, start, end, fragPrevious, fragments, fragLen);
          // if it explicitely returns null don't load any fragment and exit function now
          if (frag === null) {
            return false;
          }
        } else {
          // VoD playlist: if bufferEnd before start of playlist, load first fragment
          if (bufferEnd < start) {
            frag = fragments[0];
          }
        }
      }
      if (!frag) {
        frag = this._findFragment(start, fragPrevious, fragLen, fragments, bufferEnd, end, levelDetails);
      }
      if (frag) {
        return this._loadFragmentOrKey(frag, level, levelDetails, pos, bufferEnd);
      }
      return true;
    }
  }, {
    key: '_ensureFragmentAtLivePoint',
    value: function _ensureFragmentAtLivePoint(levelDetails, bufferEnd, start, end, fragPrevious, fragments, fragLen) {
      var config = this.hls.config,
          media = this.media;

      var frag = void 0;

      // check if requested position is within seekable boundaries :
      //logger.log(`start/pos/bufEnd/seeking:${start.toFixed(3)}/${pos.toFixed(3)}/${bufferEnd.toFixed(3)}/${this.media.seeking}`);
      var maxLatency = config.liveMaxLatencyDuration !== undefined ? config.liveMaxLatencyDuration : config.liveMaxLatencyDurationCount * levelDetails.targetduration;

      if (bufferEnd < Math.max(start - config.maxFragLookUpTolerance, end - maxLatency)) {
        var liveSyncPosition = this.liveSyncPosition = this.computeLivePosition(start, levelDetails);
        _logger.logger.log('buffer end: ' + bufferEnd.toFixed(3) + ' is located too far from the end of live sliding playlist, reset currentTime to : ' + liveSyncPosition.toFixed(3));
        bufferEnd = liveSyncPosition;
        if (media && media.readyState && media.duration > liveSyncPosition) {
          media.currentTime = liveSyncPosition;
        }
      }

      // if end of buffer greater than live edge, don't load any fragment
      // this could happen if live playlist intermittently slides in the past.
      // level 1 loaded [182580161,182580167]
      // level 1 loaded [182580162,182580169]
      // Loading 182580168 of [182580162 ,182580169],level 1 ..
      // Loading 182580169 of [182580162 ,182580169],level 1 ..
      // level 1 loaded [182580162,182580168] <============= here we should have bufferEnd > end. in that case break to avoid reloading 182580168
      // level 1 loaded [182580164,182580171]
      //
      // don't return null in case media not loaded yet (readystate === 0)
      if (levelDetails.PTSKnown && bufferEnd > end && media && media.readyState) {
        return null;
      }

      if (this.startFragRequested && !levelDetails.PTSKnown) {
        /* we are switching level on live playlist, but we don't have any PTS info for that quality level ...
           try to load frag matching with next SN.
           even if SN are not synchronized between playlists, loading this frag will help us
           compute playlist sliding and find the right one after in case it was not the right consecutive one */
        if (fragPrevious) {
          var targetSN = fragPrevious.sn + 1;
          var targetCC = fragPrevious.cc + 1;
          if (targetSN >= levelDetails.startSN && targetSN <= levelDetails.endSN) {
            frag = fragments[targetSN - levelDetails.startSN];
            _logger.logger.log('live playlist, switching playlist, load frag with next SN: ' + frag.sn);
          } else if (targetCC >= levelDetails.startCC && targetCC <= levelDetails.endCC) {
            frag = (0, _discontinuities.findFirstFragWithCC)(fragments, targetCC);
            _logger.logger.log('Live playlist switch, cannot find frag with target SN. Loading frag with next CC: ' + frag.cc);
          }
        }
        if (!frag) {
          /* we have no idea about which fragment should be loaded.
             so let's load mid fragment. it will help computing playlist sliding and find the right one
          */
          frag = fragments[Math.min(fragLen - 1, Math.round(fragLen / 2))];
          _logger.logger.log('live playlist, switching playlist, unknown, load middle frag : ' + frag.sn);
        }
      }
      return frag;
    }
  }, {
    key: '_findFragment',
    value: function _findFragment(start, fragPrevious, fragLen, fragments, bufferEnd, end, levelDetails) {
      var config = this.hls.config;
      var frag = void 0;
      var foundFrag = void 0;
      var maxFragLookUpTolerance = config.maxFragLookUpTolerance;
      var fragNext = fragPrevious ? fragments[fragPrevious.sn - fragments[0].sn + 1] : undefined;
      var fragmentWithinToleranceTest = function fragmentWithinToleranceTest(candidate) {
        // offset should be within fragment boundary - config.maxFragLookUpTolerance
        // this is to cope with situations like
        // bufferEnd = 9.991
        // frag[] : [0,10]
        // frag[1] : [10,20]
        // bufferEnd is within frag[0] range ... although what we are expecting is to return frag[1] here
        //              frag start               frag start+duration
        //                  |-----------------------------|
        //              <--->                         <--->
        //  ...--------><-----------------------------><---------....
        // previous frag         matching fragment         next frag
        //  return -1             return 0                 return 1
        //logger.log(`level/sn/start/end/bufEnd:${level}/${candidate.sn}/${candidate.start}/${(candidate.start+candidate.duration)}/${bufferEnd}`);
        // Set the lookup tolerance to be small enough to detect the current segment - ensures we don't skip over very small segments
        var candidateLookupTolerance = Math.min(maxFragLookUpTolerance, candidate.duration);
        if (candidate.start + candidate.duration - candidateLookupTolerance <= bufferEnd) {
          return 1;
        } // if maxFragLookUpTolerance will have negative value then don't return -1 for first element
        else if (candidate.start - candidateLookupTolerance > bufferEnd && candidate.start) {
            return -1;
          }
        return 0;
      };

      if (bufferEnd < end) {
        if (bufferEnd > end - maxFragLookUpTolerance) {
          maxFragLookUpTolerance = 0;
        }
        // Prefer the next fragment if it's within tolerance
        if (fragNext && !fragmentWithinToleranceTest(fragNext)) {
          foundFrag = fragNext;
        } else {
          foundFrag = _binarySearch2.default.search(fragments, fragmentWithinToleranceTest);
        }
      } else {
        // reach end of playlist
        foundFrag = fragments[fragLen - 1];
      }
      if (foundFrag) {
        frag = foundFrag;
        var curSNIdx = frag.sn - levelDetails.startSN;
        var sameLevel = fragPrevious && frag.level === fragPrevious.level;
        var prevFrag = fragments[curSNIdx - 1];
        var nextFrag = fragments[curSNIdx + 1];
        //logger.log('find SN matching with pos:' +  bufferEnd + ':' + frag.sn);
        if (sameLevel && frag.sn === fragPrevious.sn) {
          if (frag.sn < levelDetails.endSN) {
            var deltaPTS = fragPrevious.deltaPTS;
            // if there is a significant delta between audio and video, larger than max allowed hole,
            // and if previous remuxed fragment did not start with a keyframe. (fragPrevious.dropped)
            // let's try to load previous fragment again to get last keyframe
            // then we will reload again current fragment (that way we should be able to fill the buffer hole ...)
            if (deltaPTS && deltaPTS > config.maxBufferHole && fragPrevious.dropped && curSNIdx && !frag.backtracked) {
              frag = prevFrag;
              _logger.logger.warn('SN just loaded, with large PTS gap between audio and video, maybe frag is not starting with a keyframe ? load previous one to try to overcome this');
              // decrement previous frag load counter to avoid frag loop loading error when next fragment will get reloaded
              fragPrevious.loadCounter--;
            } else {
              frag = nextFrag;
              _logger.logger.log('SN just loaded, load next one: ' + frag.sn);
            }
          } else {
            frag = null;
          }
        } else if (frag.dropped && !sameLevel) {
          // Only backtrack a max of 1 consecutive fragment to prevent sliding back too far when little or no frags start with keyframes
          if (nextFrag && nextFrag.backtracked) {
            _logger.logger.warn('Already backtracked from fragment ' + (curSNIdx + 1) + ', will not backtrack to fragment ' + curSNIdx + '. Loading fragment ' + (curSNIdx + 1));
            frag = nextFrag;
          } else {
            // If a fragment has dropped frames and it's in a different level/sequence, load the previous fragment to try and find the keyframe
            // Reset the dropped count now since it won't be reset until we parse the fragment again, which prevents infinite backtracking on the same segment
            _logger.logger.warn('Loaded fragment with dropped frames, backtracking 1 segment to find a keyframe');
            frag.dropped = 0;
            if (prevFrag) {
              if (prevFrag.loadCounter) {
                prevFrag.loadCounter--;
              }
              frag = prevFrag;
            } else {
              frag = null;
            }
          }
        }
      }
      return frag;
    }
  }, {
    key: '_loadFragmentOrKey',
    value: function _loadFragmentOrKey(frag, level, levelDetails, pos, bufferEnd) {
      var hls = this.hls,
          config = hls.config;

      //logger.log('loading frag ' + i +',pos/bufEnd:' + pos.toFixed(3) + '/' + bufferEnd.toFixed(3));
      if (frag.decryptdata && frag.decryptdata.uri != null && frag.decryptdata.key == null) {
        _logger.logger.log('Loading key for ' + frag.sn + ' of [' + levelDetails.startSN + ' ,' + levelDetails.endSN + '],level ' + level);
        this.state = State.KEY_LOADING;
        hls.trigger(_events2.default.KEY_LOADING, { frag: frag });
      } else {
        _logger.logger.log('Loading ' + frag.sn + ' of [' + levelDetails.startSN + ' ,' + levelDetails.endSN + '],level ' + level + ', currentTime:' + pos.toFixed(3) + ',bufferEnd:' + bufferEnd);
        // ensure that we are not reloading the same fragments in loop ...
        if (this.fragLoadIdx !== undefined) {
          this.fragLoadIdx++;
        } else {
          this.fragLoadIdx = 0;
        }
        if (frag.loadCounter) {
          frag.loadCounter++;
          var maxThreshold = config.fragLoadingLoopThreshold;
          // if this frag has already been loaded 3 times, and if it has been reloaded recently
          if (frag.loadCounter > maxThreshold && Math.abs(this.fragLoadIdx - frag.loadIdx) < maxThreshold) {
            hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.FRAG_LOOP_LOADING_ERROR, fatal: false, frag: frag });
            return false;
          }
        } else {
          frag.loadCounter = 1;
        }
        frag.loadIdx = this.fragLoadIdx;
        this.fragCurrent = frag;
        this.startFragRequested = true;
        if (!isNaN(frag.sn)) {
          this.nextLoadPosition = frag.start + frag.duration;
        }
        frag.autoLevel = hls.autoLevelEnabled;
        frag.bitrateTest = this.bitrateTest;
        hls.trigger(_events2.default.FRAG_LOADING, { frag: frag });
        // lazy demuxer init, as this could take some time ... do it during frag loading
        if (!this.demuxer) {
          this.demuxer = new _demuxer2.default(hls, 'main');
        }
        this.state = State.FRAG_LOADING;
        return true;
      }
    }
  }, {
    key: 'getBufferedFrag',
    value: function getBufferedFrag(position) {
      return _binarySearch2.default.search(this._bufferedFrags, function (frag) {
        if (position < frag.startPTS) {
          return -1;
        } else if (position > frag.endPTS) {
          return 1;
        }
        return 0;
      });
    }
  }, {
    key: 'followingBufferedFrag',
    value: function followingBufferedFrag(frag) {
      if (frag) {
        // try to get range of next fragment (500ms after this range)
        return this.getBufferedFrag(frag.endPTS + 0.5);
      }
      return null;
    }
  }, {
    key: '_checkFragmentChanged',
    value: function _checkFragmentChanged() {
      var fragPlayingCurrent,
          currentTime,
          video = this.media;
      if (video && video.readyState && video.seeking === false) {
        currentTime = video.currentTime;
        /* if video element is in seeked state, currentTime can only increase.
          (assuming that playback rate is positive ...)
          As sometimes currentTime jumps back to zero after a
          media decode error, check this, to avoid seeking back to
          wrong position after a media decode error
        */
        if (currentTime > video.playbackRate * this.lastCurrentTime) {
          this.lastCurrentTime = currentTime;
        }
        if (_bufferHelper2.default.isBuffered(video, currentTime)) {
          fragPlayingCurrent = this.getBufferedFrag(currentTime);
        } else if (_bufferHelper2.default.isBuffered(video, currentTime + 0.1)) {
          /* ensure that FRAG_CHANGED event is triggered at startup,
            when first video frame is displayed and playback is paused.
            add a tolerance of 100ms, in case current position is not buffered,
            check if current pos+100ms is buffered and use that buffer range
            for FRAG_CHANGED event reporting */
          fragPlayingCurrent = this.getBufferedFrag(currentTime + 0.1);
        }
        if (fragPlayingCurrent) {
          var fragPlaying = fragPlayingCurrent;
          if (fragPlaying !== this.fragPlaying) {
            this.hls.trigger(_events2.default.FRAG_CHANGED, { frag: fragPlaying });
            var fragPlayingLevel = fragPlaying.level;
            if (!this.fragPlaying || this.fragPlaying.level !== fragPlayingLevel) {
              this.hls.trigger(_events2.default.LEVEL_SWITCHED, { level: fragPlayingLevel });
            }
            this.fragPlaying = fragPlaying;
          }
        }
      }
    }

    /*
      on immediate level switch :
       - pause playback if playing
       - cancel any pending load request
       - and trigger a buffer flush
    */

  }, {
    key: 'immediateLevelSwitch',
    value: function immediateLevelSwitch() {
      _logger.logger.log('immediateLevelSwitch');
      if (!this.immediateSwitch) {
        this.immediateSwitch = true;
        var media = this.media,
            previouslyPaused = void 0;
        if (media) {
          previouslyPaused = media.paused;
          media.pause();
        } else {
          // don't restart playback after instant level switch in case media not attached
          previouslyPaused = true;
        }
        this.previouslyPaused = previouslyPaused;
      }
      var fragCurrent = this.fragCurrent;
      if (fragCurrent && fragCurrent.loader) {
        fragCurrent.loader.abort();
      }
      this.fragCurrent = null;
      // increase fragment load Index to avoid frag loop loading error after buffer flush
      this.fragLoadIdx += 2 * this.config.fragLoadingLoopThreshold;
      // flush everything
      this.flushMainBuffer(0, Number.POSITIVE_INFINITY);
    }

    /*
       on immediate level switch end, after new fragment has been buffered :
        - nudge video decoder by slightly adjusting video currentTime (if currentTime buffered)
        - resume the playback if needed
    */

  }, {
    key: 'immediateLevelSwitchEnd',
    value: function immediateLevelSwitchEnd() {
      var media = this.media;
      if (media && media.buffered.length) {
        this.immediateSwitch = false;
        if (_bufferHelper2.default.isBuffered(media, media.currentTime)) {
          // only nudge if currentTime is buffered
          media.currentTime -= 0.0001;
        }
        if (!this.previouslyPaused) {
          media.play();
        }
      }
    }
  }, {
    key: 'nextLevelSwitch',
    value: function nextLevelSwitch() {
      /* try to switch ASAP without breaking video playback :
         in order to ensure smooth but quick level switching,
        we need to find the next flushable buffer range
        we should take into account new segment fetch time
      */
      var media = this.media;
      // ensure that media is defined and that metadata are available (to retrieve currentTime)
      if (media && media.readyState) {
        var fetchdelay = void 0,
            fragPlayingCurrent = void 0,
            nextBufferedFrag = void 0;
        // increase fragment load Index to avoid frag loop loading error after buffer flush
        this.fragLoadIdx += 2 * this.config.fragLoadingLoopThreshold;
        fragPlayingCurrent = this.getBufferedFrag(media.currentTime);
        if (fragPlayingCurrent && fragPlayingCurrent.startPTS > 1) {
          // flush buffer preceding current fragment (flush until current fragment start offset)
          // minus 1s to avoid video freezing, that could happen if we flush keyframe of current video ...
          this.flushMainBuffer(0, fragPlayingCurrent.startPTS - 1);
        }
        if (!media.paused) {
          // add a safety delay of 1s
          var nextLevelId = this.hls.nextLoadLevel,
              nextLevel = this.levels[nextLevelId],
              fragLastKbps = this.fragLastKbps;
          if (fragLastKbps && this.fragCurrent) {
            fetchdelay = this.fragCurrent.duration * nextLevel.bitrate / (1000 * fragLastKbps) + 1;
          } else {
            fetchdelay = 0;
          }
        } else {
          fetchdelay = 0;
        }
        //logger.log('fetchdelay:'+fetchdelay);
        // find buffer range that will be reached once new fragment will be fetched
        nextBufferedFrag = this.getBufferedFrag(media.currentTime + fetchdelay);
        if (nextBufferedFrag) {
          // we can flush buffer range following this one without stalling playback
          nextBufferedFrag = this.followingBufferedFrag(nextBufferedFrag);
          if (nextBufferedFrag) {
            // if we are here, we can also cancel any loading/demuxing in progress, as they are useless
            var fragCurrent = this.fragCurrent;
            if (fragCurrent && fragCurrent.loader) {
              fragCurrent.loader.abort();
            }
            this.fragCurrent = null;
            // flush position is the start position of this new buffer
            this.flushMainBuffer(nextBufferedFrag.startPTS, Number.POSITIVE_INFINITY);
          }
        }
      }
    }
  }, {
    key: 'flushMainBuffer',
    value: function flushMainBuffer(startOffset, endOffset) {
      this.state = State.BUFFER_FLUSHING;
      var flushScope = { startOffset: startOffset, endOffset: endOffset };
      // if alternate audio tracks are used, only flush video, otherwise flush everything
      if (this.altAudio) {
        flushScope.type = 'video';
      }
      this.hls.trigger(_events2.default.BUFFER_FLUSHING, flushScope);
    }
  }, {
    key: 'onMediaAttached',
    value: function onMediaAttached(data) {
      var media = this.media = this.mediaBuffer = data.media;
      this.onvseeking = this.onMediaSeeking.bind(this);
      this.onvseeked = this.onMediaSeeked.bind(this);
      this.onvended = this.onMediaEnded.bind(this);
      media.addEventListener('seeking', this.onvseeking);
      media.addEventListener('seeked', this.onvseeked);
      media.addEventListener('ended', this.onvended);
      var config = this.config;
      if (this.levels && config.autoStartLoad) {
        this.hls.startLoad(config.startPosition);
      }
    }
  }, {
    key: 'onMediaDetaching',
    value: function onMediaDetaching() {
      var media = this.media;
      if (media && media.ended) {
        _logger.logger.log('MSE detaching and video ended, reset startPosition');
        this.startPosition = this.lastCurrentTime = 0;
      }

      // reset fragment loading counter on MSE detaching to avoid reporting FRAG_LOOP_LOADING_ERROR after error recovery
      var levels = this.levels;
      if (levels) {
        // reset fragment load counter
        levels.forEach(function (level) {
          if (level.details) {
            level.details.fragments.forEach(function (fragment) {
              fragment.loadCounter = undefined;
              fragment.backtracked = undefined;
            });
          }
        });
      }
      // remove video listeners
      if (media) {
        media.removeEventListener('seeking', this.onvseeking);
        media.removeEventListener('seeked', this.onvseeked);
        media.removeEventListener('ended', this.onvended);
        this.onvseeking = this.onvseeked = this.onvended = null;
      }
      this.media = this.mediaBuffer = null;
      this.loadedmetadata = false;
      this.stopLoad();
    }
  }, {
    key: 'onMediaSeeking',
    value: function onMediaSeeking() {
      var media = this.media,
          currentTime = media ? media.currentTime : undefined,
          config = this.config;
      _logger.logger.log('media seeking to ' + currentTime.toFixed(3));
      if (this.state === State.FRAG_LOADING) {
        var mediaBuffer = this.mediaBuffer ? this.mediaBuffer : media;
        var bufferInfo = _bufferHelper2.default.bufferInfo(mediaBuffer, currentTime, this.config.maxBufferHole),
            fragCurrent = this.fragCurrent;
        // check if we are seeking to a unbuffered area AND if frag loading is in progress
        if (bufferInfo.len === 0 && fragCurrent) {
          var tolerance = config.maxFragLookUpTolerance,
              fragStartOffset = fragCurrent.start - tolerance,
              fragEndOffset = fragCurrent.start + fragCurrent.duration + tolerance;
          // check if we seek position will be out of currently loaded frag range : if out cancel frag load, if in, don't do anything
          if (currentTime < fragStartOffset || currentTime > fragEndOffset) {
            if (fragCurrent.loader) {
              _logger.logger.log('seeking outside of buffer while fragment load in progress, cancel fragment load');
              fragCurrent.loader.abort();
            }
            this.fragCurrent = null;
            this.fragPrevious = null;
            // switch to IDLE state to load new fragment
            this.state = State.IDLE;
          } else {
            _logger.logger.log('seeking outside of buffer but within currently loaded fragment range');
          }
        }
      } else if (this.state === State.ENDED) {
        // switch to IDLE state to check for potential new fragment
        this.state = State.IDLE;
      }
      if (media) {
        this.lastCurrentTime = currentTime;
      }
      // avoid reporting fragment loop loading error in case user is seeking several times on same position
      if (this.state !== State.FRAG_LOADING && this.fragLoadIdx !== undefined) {
        this.fragLoadIdx += 2 * config.fragLoadingLoopThreshold;
      }
      // in case seeking occurs although no media buffered, adjust startPosition and nextLoadPosition to seek target
      if (!this.loadedmetadata) {
        this.nextLoadPosition = this.startPosition = currentTime;
      }
      // tick to speed up processing
      this.tick();
    }
  }, {
    key: 'onMediaSeeked',
    value: function onMediaSeeked() {
      _logger.logger.log('media seeked to ' + this.media.currentTime.toFixed(3));
      // tick to speed up FRAGMENT_PLAYING triggering
      this.tick();
    }
  }, {
    key: 'onMediaEnded',
    value: function onMediaEnded() {
      _logger.logger.log('media ended');
      // reset startPosition and lastCurrentTime to restart playback @ stream beginning
      this.startPosition = this.lastCurrentTime = 0;
    }
  }, {
    key: 'onManifestLoading',
    value: function onManifestLoading() {
      // reset buffer on manifest loading
      _logger.logger.log('trigger BUFFER_RESET');
      this.hls.trigger(_events2.default.BUFFER_RESET);
      this._bufferedFrags = [];
      this.stalled = false;
      this.startPosition = this.lastCurrentTime = 0;
    }
  }, {
    key: 'onManifestParsed',
    value: function onManifestParsed(data) {
      var aac = false,
          heaac = false,
          codec;
      data.levels.forEach(function (level) {
        // detect if we have different kind of audio codecs used amongst playlists
        codec = level.audioCodec;
        if (codec) {
          if (codec.indexOf('mp4a.40.2') !== -1) {
            aac = true;
          }
          if (codec.indexOf('mp4a.40.5') !== -1) {
            heaac = true;
          }
        }
      });
      this.audioCodecSwitch = aac && heaac;
      if (this.audioCodecSwitch) {
        _logger.logger.log('both AAC/HE-AAC audio found in levels; declaring level codec as HE-AAC');
      }
      this.levels = data.levels;
      this.startLevelLoaded = false;
      this.startFragRequested = false;
      var config = this.config;
      if (config.autoStartLoad || this.forceStartLoad) {
        this.hls.startLoad(config.startPosition);
      }
    }
  }, {
    key: 'onLevelLoaded',
    value: function onLevelLoaded(data) {
      var newDetails = data.details;
      var newLevelId = data.level;
      var lastLevel = this.levels[this.levelLastLoaded];
      var curLevel = this.levels[newLevelId];
      var duration = newDetails.totalduration;
      var sliding = 0;

      _logger.logger.log('level ' + newLevelId + ' loaded [' + newDetails.startSN + ',' + newDetails.endSN + '], cc [' + newDetails.startCC + ', ' + newDetails.endCC + '] duration:' + duration);

      if (newDetails.live) {
        var curDetails = curLevel.details;
        if (curDetails && newDetails.fragments.length > 0) {
          // we already have details for that level, merge them
          _levelHelper2.default.mergeDetails(curDetails, newDetails);
          sliding = newDetails.fragments[0].start;
          this.liveSyncPosition = this.computeLivePosition(sliding, curDetails);
          if (newDetails.PTSKnown) {
            _logger.logger.log('live playlist sliding:' + sliding.toFixed(3));
          } else {
            _logger.logger.log('live playlist - outdated PTS, unknown sliding');
            (0, _discontinuities.alignDiscontinuities)(this.fragPrevious, lastLevel, newDetails);
          }
        } else {
          _logger.logger.log('live playlist - first load, unknown sliding');
          newDetails.PTSKnown = false;
          (0, _discontinuities.alignDiscontinuities)(this.fragPrevious, lastLevel, newDetails);
        }
      } else {
        newDetails.PTSKnown = false;
      }
      // override level info
      this.levelLastLoaded = newLevelId;
      curLevel.details = newDetails;
      this.hls.trigger(_events2.default.LEVEL_UPDATED, { details: newDetails, level: newLevelId });

      if (this.startFragRequested === false) {
        // compute start position if set to -1. use it straight away if value is defined
        if (this.startPosition === -1 || this.lastCurrentTime === -1) {
          // first, check if start time offset has been set in playlist, if yes, use this value
          var startTimeOffset = newDetails.startTimeOffset;
          if (!isNaN(startTimeOffset)) {
            if (startTimeOffset < 0) {
              _logger.logger.log('negative start time offset ' + startTimeOffset + ', count from end of last fragment');
              startTimeOffset = sliding + duration + startTimeOffset;
            }
            _logger.logger.log('start time offset found in playlist, adjust startPosition to ' + startTimeOffset);
            this.startPosition = startTimeOffset;
          } else {
            // if live playlist, set start position to be fragment N-this.config.liveSyncDurationCount (usually 3)
            if (newDetails.live) {
              this.startPosition = this.computeLivePosition(sliding, newDetails);
              _logger.logger.log('configure startPosition to ' + this.startPosition);
            } else {
              this.startPosition = 0;
            }
          }
          this.lastCurrentTime = this.startPosition;
        }
        this.nextLoadPosition = this.startPosition;
      }
      // only switch batck to IDLE state if we were waiting for level to start downloading a new fragment
      if (this.state === State.WAITING_LEVEL) {
        this.state = State.IDLE;
      }
      //trigger handler right now
      this.tick();
    }
  }, {
    key: 'onKeyLoaded',
    value: function onKeyLoaded() {
      if (this.state === State.KEY_LOADING) {
        this.state = State.IDLE;
        this.tick();
      }
    }
  }, {
    key: 'onFragLoaded',
    value: function onFragLoaded(data) {
      var fragCurrent = this.fragCurrent,
          fragLoaded = data.frag;
      if (this.state === State.FRAG_LOADING && fragCurrent && fragLoaded.type === 'main' && fragLoaded.level === fragCurrent.level && fragLoaded.sn === fragCurrent.sn) {
        var stats = data.stats,
            currentLevel = this.levels[fragCurrent.level],
            details = currentLevel.details;
        _logger.logger.log('Loaded  ' + fragCurrent.sn + ' of [' + details.startSN + ' ,' + details.endSN + '],level ' + fragCurrent.level);
        // reset frag bitrate test in any case after frag loaded event
        this.bitrateTest = false;
        this.stats = stats;
        // if this frag was loaded to perform a bitrate test AND if hls.nextLoadLevel is greater than 0
        // then this means that we should be able to load a fragment at a higher quality level
        if (fragLoaded.bitrateTest === true && this.hls.nextLoadLevel) {
          // switch back to IDLE state ... we just loaded a fragment to determine adequate start bitrate and initialize autoswitch algo
          this.state = State.IDLE;
          this.startFragRequested = false;
          stats.tparsed = stats.tbuffered = performance.now();
          this.hls.trigger(_events2.default.FRAG_BUFFERED, { stats: stats, frag: fragCurrent, id: 'main' });
          this.tick();
        } else if (fragLoaded.sn === 'initSegment') {
          this.state = State.IDLE;
          stats.tparsed = stats.tbuffered = performance.now();
          details.initSegment.data = data.payload;
          this.hls.trigger(_events2.default.FRAG_BUFFERED, { stats: stats, frag: fragCurrent, id: 'main' });
          this.tick();
        } else {
          this.state = State.PARSING;
          // transmux the MPEG-TS data to ISO-BMFF segments
          var duration = details.totalduration,
              level = fragCurrent.level,
              sn = fragCurrent.sn,
              audioCodec = this.config.defaultAudioCodec || currentLevel.audioCodec;
          if (this.audioCodecSwap) {
            _logger.logger.log('swapping playlist audio codec');
            if (audioCodec === undefined) {
              audioCodec = this.lastAudioCodec;
            }
            if (audioCodec) {
              if (audioCodec.indexOf('mp4a.40.5') !== -1) {
                audioCodec = 'mp4a.40.2';
              } else {
                audioCodec = 'mp4a.40.5';
              }
            }
          }
          this.pendingBuffering = true;
          this.appended = false;
          _logger.logger.log('Parsing ' + sn + ' of [' + details.startSN + ' ,' + details.endSN + '],level ' + level + ', cc ' + fragCurrent.cc);
          var demuxer = this.demuxer;
          if (!demuxer) {
            demuxer = this.demuxer = new _demuxer2.default(this.hls, 'main');
          }
          // time Offset is accurate if level PTS is known, or if playlist is not sliding (not live) and if media is not seeking (this is to overcome potential timestamp drifts between playlists and fragments)
          var media = this.media;
          var mediaSeeking = media && media.seeking;
          var accurateTimeOffset = !mediaSeeking && (details.PTSKnown || !details.live);
          var initSegmentData = details.initSegment ? details.initSegment.data : [];
          demuxer.push(data.payload, initSegmentData, audioCodec, currentLevel.videoCodec, fragCurrent, duration, accurateTimeOffset, undefined);
        }
      }
      this.fragLoadError = 0;
    }
  }, {
    key: 'onFragParsingInitSegment',
    value: function onFragParsingInitSegment(data) {
      var fragCurrent = this.fragCurrent;
      var fragNew = data.frag;
      if (fragCurrent && data.id === 'main' && fragNew.sn === fragCurrent.sn && fragNew.level === fragCurrent.level && this.state === State.PARSING) {
        var tracks = data.tracks,
            trackName,
            track;

        // if audio track is expected to come from audio stream controller, discard any coming from main
        if (tracks.audio && this.altAudio) {
          delete tracks.audio;
        }
        // include levelCodec in audio and video tracks
        track = tracks.audio;
        if (track) {
          var audioCodec = this.levels[this.level].audioCodec,
              ua = navigator.userAgent.toLowerCase();
          if (audioCodec && this.audioCodecSwap) {
            _logger.logger.log('swapping playlist audio codec');
            if (audioCodec.indexOf('mp4a.40.5') !== -1) {
              audioCodec = 'mp4a.40.2';
            } else {
              audioCodec = 'mp4a.40.5';
            }
          }
          // in case AAC and HE-AAC audio codecs are signalled in manifest
          // force HE-AAC , as it seems that most browsers prefers that way,
          // except for mono streams OR on FF
          // these conditions might need to be reviewed ...
          if (this.audioCodecSwitch) {
            // don't force HE-AAC if mono stream
            if (track.metadata.channelCount !== 1 &&
            // don't force HE-AAC if firefox
            ua.indexOf('firefox') === -1) {
              audioCodec = 'mp4a.40.5';
            }
          }
          // HE-AAC is broken on Android, always signal audio codec as AAC even if variant manifest states otherwise
          if (ua.indexOf('android') !== -1 && track.container !== 'audio/mpeg') {
            // Exclude mpeg audio
            audioCodec = 'mp4a.40.2';
            _logger.logger.log('Android: force audio codec to ' + audioCodec);
          }
          track.levelCodec = audioCodec;
          track.id = data.id;
        }
        track = tracks.video;
        if (track) {
          track.levelCodec = this.levels[this.level].videoCodec;
          track.id = data.id;
        }
        this.hls.trigger(_events2.default.BUFFER_CODECS, tracks);
        // loop through tracks that are going to be provided to bufferController
        for (trackName in tracks) {
          track = tracks[trackName];
          _logger.logger.log('main track:' + trackName + ',container:' + track.container + ',codecs[level/parsed]=[' + track.levelCodec + '/' + track.codec + ']');
          var initSegment = track.initSegment;
          if (initSegment) {
            this.appended = true;
            // arm pending Buffering flag before appending a segment
            this.pendingBuffering = true;
            this.hls.trigger(_events2.default.BUFFER_APPENDING, { type: trackName, data: initSegment, parent: 'main', content: 'initSegment' });
          }
        }
        //trigger handler right now
        this.tick();
      }
    }
  }, {
    key: 'onFragParsingData',
    value: function onFragParsingData(data) {
      var _this2 = this;

      var fragCurrent = this.fragCurrent;
      var fragNew = data.frag;
      if (fragCurrent && data.id === 'main' && fragNew.sn === fragCurrent.sn && fragNew.level === fragCurrent.level && !(data.type === 'audio' && this.altAudio) && // filter out main audio if audio track is loaded through audio stream controller
      this.state === State.PARSING) {
        var level = this.levels[this.level],
            frag = fragCurrent;
        if (isNaN(data.endPTS)) {
          data.endPTS = data.startPTS + fragCurrent.duration;
          data.endDTS = data.startDTS + fragCurrent.duration;
        }

        _logger.logger.log('Parsed ' + data.type + ',PTS:[' + data.startPTS.toFixed(3) + ',' + data.endPTS.toFixed(3) + '],DTS:[' + data.startDTS.toFixed(3) + '/' + data.endDTS.toFixed(3) + '],nb:' + data.nb + ',dropped:' + (data.dropped || 0));

        // Detect gaps in a fragment  and try to fix it by finding a keyframe in the previous fragment (see _findFragments)
        if (data.type === 'video') {
          frag.dropped = data.dropped;
          if (frag.dropped) {
            if (!frag.backtracked) {
              // Return back to the IDLE state without appending to buffer
              // Causes findFragments to backtrack a segment and find the keyframe
              // Audio fragments arriving before video sets the nextLoadPosition, causing _findFragments to skip the backtracked fragment
              frag.backtracked = true;
              this.nextLoadPosition = data.startPTS;
              this.state = State.IDLE;
              this.tick();
              return;
            } else {
              _logger.logger.warn('Already backtracked on this fragment, appending with the gap');
            }
          } else {
            // Only reset the backtracked flag if we've loaded the frag without any dropped frames
            frag.backtracked = false;
          }
        }

        var drift = _levelHelper2.default.updateFragPTSDTS(level.details, frag.sn, data.startPTS, data.endPTS, data.startDTS, data.endDTS),
            hls = this.hls;
        hls.trigger(_events2.default.LEVEL_PTS_UPDATED, { details: level.details, level: this.level, drift: drift, type: data.type, start: data.startPTS, end: data.endPTS });

        // has remuxer dropped video frames located before first keyframe ?
        [data.data1, data.data2].forEach(function (buffer) {
          // only append in PARSING state (rationale is that an appending error could happen synchronously on first segment appending)
          // in that case it is useless to append following segments
          if (buffer && buffer.length && _this2.state === State.PARSING) {
            _this2.appended = true;
            // arm pending Buffering flag before appending a segment
            _this2.pendingBuffering = true;
            hls.trigger(_events2.default.BUFFER_APPENDING, { type: data.type, data: buffer, parent: 'main', content: 'data' });
          }
        });
        //trigger handler right now
        this.tick();
      }
    }
  }, {
    key: 'onFragParsed',
    value: function onFragParsed(data) {
      var fragCurrent = this.fragCurrent;
      var fragNew = data.frag;
      if (fragCurrent && data.id === 'main' && fragNew.sn === fragCurrent.sn && fragNew.level === fragCurrent.level && this.state === State.PARSING) {
        this.stats.tparsed = performance.now();
        this.state = State.PARSED;
        this._checkAppendedParsed();
      }
    }
  }, {
    key: 'onAudioTrackSwitching',
    value: function onAudioTrackSwitching(data) {
      // if any URL found on new audio track, it is an alternate audio track
      var altAudio = !!data.url,
          trackId = data.id;
      // if we switch on main audio, ensure that main fragment scheduling is synced with media.buffered
      // don't do anything if we switch to alt audio: audio stream controller is handling it.
      // we will just have to change buffer scheduling on audioTrackSwitched
      if (!altAudio) {
        if (this.mediaBuffer !== this.media) {
          _logger.logger.log('switching on main audio, use media.buffered to schedule main fragment loading');
          this.mediaBuffer = this.media;
          var fragCurrent = this.fragCurrent;
          // we need to refill audio buffer from main: cancel any frag loading to speed up audio switch
          if (fragCurrent.loader) {
            _logger.logger.log('switching to main audio track, cancel main fragment load');
            fragCurrent.loader.abort();
          }
          this.fragCurrent = null;
          this.fragPrevious = null;
          // destroy demuxer to force init segment generation (following audio switch)
          if (this.demuxer) {
            this.demuxer.destroy();
            this.demuxer = null;
          }
          // switch to IDLE state to load new fragment
          this.state = State.IDLE;
        }
        var hls = this.hls;
        // switching to main audio, flush all audio and trigger track switched
        hls.trigger(_events2.default.BUFFER_FLUSHING, { startOffset: 0, endOffset: Number.POSITIVE_INFINITY, type: 'audio' });
        hls.trigger(_events2.default.AUDIO_TRACK_SWITCHED, { id: trackId });
        this.altAudio = false;
      }
    }
  }, {
    key: 'onAudioTrackSwitched',
    value: function onAudioTrackSwitched(data) {
      var trackId = data.id,
          altAudio = !!this.hls.audioTracks[trackId].url;
      if (altAudio) {
        var videoBuffer = this.videoBuffer;
        // if we switched on alternate audio, ensure that main fragment scheduling is synced with video sourcebuffer buffered
        if (videoBuffer && this.mediaBuffer !== videoBuffer) {
          _logger.logger.log('switching on alternate audio, use video.buffered to schedule main fragment loading');
          this.mediaBuffer = videoBuffer;
        }
      }
      this.altAudio = altAudio;
      this.tick();
    }
  }, {
    key: 'onBufferCreated',
    value: function onBufferCreated(data) {
      var tracks = data.tracks,
          mediaTrack = void 0,
          name = void 0,
          alternate = false;
      for (var type in tracks) {
        var track = tracks[type];
        if (track.id === 'main') {
          name = type;
          mediaTrack = track;
          // keep video source buffer reference
          if (type === 'video') {
            this.videoBuffer = tracks[type].buffer;
          }
        } else {
          alternate = true;
        }
      }
      if (alternate && mediaTrack) {
        _logger.logger.log('alternate track found, use ' + name + '.buffered to schedule main fragment loading');
        this.mediaBuffer = mediaTrack.buffer;
      } else {
        this.mediaBuffer = this.media;
      }
    }
  }, {
    key: 'onBufferAppended',
    value: function onBufferAppended(data) {
      if (data.parent === 'main') {
        var state = this.state;
        if (state === State.PARSING || state === State.PARSED) {
          // check if all buffers have been appended
          this.pendingBuffering = data.pending > 0;
          this._checkAppendedParsed();
        }
      }
    }
  }, {
    key: '_checkAppendedParsed',
    value: function _checkAppendedParsed() {
      var _this3 = this;

      //trigger handler right now
      if (this.state === State.PARSED && (!this.appended || !this.pendingBuffering)) {
        var frag = this.fragCurrent;
        if (frag) {
          (function () {
            var media = _this3.mediaBuffer ? _this3.mediaBuffer : _this3.media;
            _logger.logger.log('main buffered : ' + _timeRanges2.default.toString(media.buffered));
            // filter fragments potentially evicted from buffer. this is to avoid memleak on live streams
            var bufferedFrags = _this3._bufferedFrags.filter(function (frag) {
              return _bufferHelper2.default.isBuffered(media, (frag.startPTS + frag.endPTS) / 2);
            });
            // push new range
            bufferedFrags.push(frag);
            // sort frags, as we use BinarySearch for lookup in getBufferedFrag ...
            _this3._bufferedFrags = bufferedFrags.sort(function (a, b) {
              return a.startPTS - b.startPTS;
            });
            _this3.fragPrevious = frag;
            var stats = _this3.stats;
            stats.tbuffered = performance.now();
            // we should get rid of this.fragLastKbps
            _this3.fragLastKbps = Math.round(8 * stats.total / (stats.tbuffered - stats.tfirst));
            _this3.hls.trigger(_events2.default.FRAG_BUFFERED, { stats: stats, frag: frag, id: 'main' });
            _this3.state = State.IDLE;
          })();
        }
        this.tick();
      }
    }
  }, {
    key: 'onError',
    value: function onError(data) {
      var frag = data.frag || this.fragCurrent;
      // don't handle frag error not related to main fragment
      if (frag && frag.type !== 'main') {
        return;
      }
      var media = this.media,

      // 0.5 : tolerance needed as some browsers stalls playback before reaching buffered end
      mediaBuffered = media && _bufferHelper2.default.isBuffered(media, media.currentTime) && _bufferHelper2.default.isBuffered(media, media.currentTime + 0.5);
      switch (data.details) {
        case _errors.ErrorDetails.FRAG_LOAD_ERROR:
        case _errors.ErrorDetails.FRAG_LOAD_TIMEOUT:
        case _errors.ErrorDetails.KEY_LOAD_ERROR:
        case _errors.ErrorDetails.KEY_LOAD_TIMEOUT:
          if (!data.fatal) {
            var loadError = this.fragLoadError;
            if (loadError) {
              loadError++;
            } else {
              loadError = 1;
            }
            var config = this.config;
            // keep retrying / don't raise fatal network error if current position is buffered or if in automode with current level not 0
            if (loadError <= config.fragLoadingMaxRetry || mediaBuffered || frag.autoLevel && frag.level) {
              this.fragLoadError = loadError;
              // reset load counter to avoid frag loop loading error
              frag.loadCounter = 0;
              // exponential backoff capped to config.fragLoadingMaxRetryTimeout
              var delay = Math.min(Math.pow(2, loadError - 1) * config.fragLoadingRetryDelay, config.fragLoadingMaxRetryTimeout);
              _logger.logger.warn('mediaController: frag loading failed, retry in ' + delay + ' ms');
              this.retryDate = performance.now() + delay;
              // retry loading state
              // if loadedmetadata is not set, it means that we are emergency switch down on first frag
              // in that case, reset startFragRequested flag
              if (!this.loadedmetadata) {
                this.startFragRequested = false;
                this.nextLoadPosition = this.startPosition;
              }
              this.state = State.FRAG_LOADING_WAITING_RETRY;
            } else {
              _logger.logger.error('mediaController: ' + data.details + ' reaches max retry, redispatch as fatal ...');
              // switch error to fatal
              data.fatal = true;
              this.state = State.ERROR;
            }
          }
          break;
        case _errors.ErrorDetails.FRAG_LOOP_LOADING_ERROR:
          if (!data.fatal) {
            // if buffer is not empty
            if (mediaBuffered) {
              // try to reduce max buffer length : rationale is that we could get
              // frag loop loading error because of buffer eviction
              this._reduceMaxBufferLength(frag.duration);
              this.state = State.IDLE;
            } else {
              // buffer empty. report as fatal if in manual mode or if lowest level.
              // level controller takes care of emergency switch down logic
              if (!frag.autoLevel || frag.level === 0) {
                // switch error to fatal
                data.fatal = true;
                this.state = State.ERROR;
              }
            }
          }
          break;
        case _errors.ErrorDetails.LEVEL_LOAD_ERROR:
        case _errors.ErrorDetails.LEVEL_LOAD_TIMEOUT:
          if (this.state !== State.ERROR) {
            if (data.fatal) {
              // if fatal error, stop processing
              this.state = State.ERROR;
              _logger.logger.warn('streamController: ' + data.details + ',switch to ' + this.state + ' state ...');
            } else {
              // in cas of non fatal error while waiting level load to be completed, switch back to IDLE
              if (this.state === State.WAITING_LEVEL) {
                this.state = State.IDLE;
              }
            }
          }
          break;
        case _errors.ErrorDetails.BUFFER_FULL_ERROR:
          // if in appending state
          if (data.parent === 'main' && (this.state === State.PARSING || this.state === State.PARSED)) {
            // reduce max buf len if current position is buffered
            if (mediaBuffered) {
              this._reduceMaxBufferLength(this.config.maxBufferLength);
              this.state = State.IDLE;
            } else {
              // current position is not buffered, but browser is still complaining about buffer full error
              // this happens on IE/Edge, refer to https://github.com/video-dev/hls.js/pull/708
              // in that case flush the whole buffer to recover
              _logger.logger.warn('buffer full error also media.currentTime is not buffered, flush everything');
              this.fragCurrent = null;
              // flush everything
              this.flushMainBuffer(0, Number.POSITIVE_INFINITY);
            }
          }
          break;
        default:
          break;
      }
    }
  }, {
    key: '_reduceMaxBufferLength',
    value: function _reduceMaxBufferLength(minLength) {
      var config = this.config;
      if (config.maxMaxBufferLength >= minLength) {
        // reduce max buffer length as it might be too high. we do this to avoid loop flushing ...
        config.maxMaxBufferLength /= 2;
        _logger.logger.warn('main:reduce max buffer length to ' + config.maxMaxBufferLength + 's');
        // increase fragment load Index to avoid frag loop loading error after buffer flush
        this.fragLoadIdx += 2 * config.fragLoadingLoopThreshold;
      }
    }
  }, {
    key: '_checkBuffer',
    value: function _checkBuffer() {
      var media = this.media;
      // if ready state different from HAVE_NOTHING (numeric value 0), we are allowed to seek
      if (media && media.readyState) {
        var currentTime = media.currentTime,
            mediaBuffer = this.mediaBuffer ? this.mediaBuffer : media,
            buffered = mediaBuffer.buffered;
        // adjust currentTime to start position on loaded metadata
        if (!this.loadedmetadata && buffered.length) {
          this.loadedmetadata = true;
          // only adjust currentTime if different from startPosition or if startPosition not buffered
          // at that stage, there should be only one buffered range, as we reach that code after first fragment has been buffered
          var startPosition = media.seeking ? currentTime : this.startPosition,
              startPositionBuffered = _bufferHelper2.default.isBuffered(mediaBuffer, startPosition);
          // if currentTime not matching with expected startPosition or startPosition not buffered
          if (currentTime !== startPosition || !startPositionBuffered) {
            _logger.logger.log('target start position:' + startPosition);
            // if startPosition not buffered, let's seek to buffered.start(0)
            if (!startPositionBuffered) {
              startPosition = buffered.start(0);
              _logger.logger.log('target start position not buffered, seek to buffered.start(0) ' + startPosition);
            }
            _logger.logger.log('adjust currentTime from ' + currentTime + ' to ' + startPosition);
            media.currentTime = startPosition;
          }
        } else if (this.immediateSwitch) {
          this.immediateLevelSwitchEnd();
        } else {
          var bufferInfo = _bufferHelper2.default.bufferInfo(media, currentTime, 0),
              expectedPlaying = !(media.paused || // not playing when media is paused
          media.ended || // not playing when media is ended
          media.buffered.length === 0),
              // not playing if nothing buffered
          jumpThreshold = 0.5,
              // tolerance needed as some browsers stalls playback before reaching buffered range end
          playheadMoving = currentTime !== this.lastCurrentTime,
              config = this.config;

          if (playheadMoving) {
            // played moving, but was previously stalled => now not stuck anymore
            if (this.stallReported) {
              _logger.logger.warn('playback not stuck anymore @' + currentTime + ', after ' + Math.round(performance.now() - this.stalled) + 'ms');
              this.stallReported = false;
            }
            this.stalled = undefined;
            this.nudgeRetry = 0;
          } else {
            // playhead not moving
            if (expectedPlaying) {
              // playhead not moving BUT media expected to play
              var tnow = performance.now();
              var hls = this.hls;
              if (!this.stalled) {
                // stall just detected, store current time
                this.stalled = tnow;
                this.stallReported = false;
              } else {
                // playback already stalled, check stalling duration
                // if stalling for more than a given threshold, let's try to recover
                var stalledDuration = tnow - this.stalled;
                var bufferLen = bufferInfo.len;
                var nudgeRetry = this.nudgeRetry || 0;
                // have we reached stall deadline ?
                if (bufferLen <= jumpThreshold && stalledDuration > config.lowBufferWatchdogPeriod * 1000) {
                  // report stalled error once
                  if (!this.stallReported) {
                    this.stallReported = true;
                    _logger.logger.warn('playback stalling in low buffer @' + currentTime);
                    hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.BUFFER_STALLED_ERROR, fatal: false, buffer: bufferLen });
                  }
                  // if buffer len is below threshold, try to jump to start of next buffer range if close
                  // no buffer available @ currentTime, check if next buffer is close (within a config.maxSeekHole second range)
                  var nextBufferStart = bufferInfo.nextStart,
                      delta = nextBufferStart - currentTime;
                  if (nextBufferStart && delta < config.maxSeekHole && delta > 0) {
                    this.nudgeRetry = ++nudgeRetry;
                    var nudgeOffset = nudgeRetry * config.nudgeOffset;
                    // next buffer is close ! adjust currentTime to nextBufferStart
                    // this will ensure effective video decoding
                    _logger.logger.log('adjust currentTime from ' + media.currentTime + ' to next buffered @ ' + nextBufferStart + ' + nudge ' + nudgeOffset);
                    media.currentTime = nextBufferStart + nudgeOffset;
                    // reset stalled so to rearm watchdog timer
                    this.stalled = undefined;
                    hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.BUFFER_SEEK_OVER_HOLE, fatal: false, hole: nextBufferStart + nudgeOffset - currentTime });
                  }
                } else if (bufferLen > jumpThreshold && stalledDuration > config.highBufferWatchdogPeriod * 1000) {
                  // report stalled error once
                  if (!this.stallReported) {
                    this.stallReported = true;
                    _logger.logger.warn('playback stalling in high buffer @' + currentTime);
                    hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.BUFFER_STALLED_ERROR, fatal: false, buffer: bufferLen });
                  }
                  // reset stalled so to rearm watchdog timer
                  this.stalled = undefined;
                  this.nudgeRetry = ++nudgeRetry;
                  if (nudgeRetry < config.nudgeMaxRetry) {
                    var _currentTime = media.currentTime;
                    var targetTime = _currentTime + nudgeRetry * config.nudgeOffset;
                    _logger.logger.log('adjust currentTime from ' + _currentTime + ' to ' + targetTime);
                    // playback stalled in buffered area ... let's nudge currentTime to try to overcome this
                    media.currentTime = targetTime;
                    hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.BUFFER_NUDGE_ON_STALL, fatal: false });
                  } else {
                    _logger.logger.error('still stuck in high buffer @' + currentTime + ' after ' + config.nudgeMaxRetry + ', raise fatal error');
                    hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.BUFFER_STALLED_ERROR, fatal: true });
                  }
                }
              }
            }
          }
        }
      }
    }
  }, {
    key: 'onFragLoadEmergencyAborted',
    value: function onFragLoadEmergencyAborted() {
      this.state = State.IDLE;
      // if loadedmetadata is not set, it means that we are emergency switch down on first frag
      // in that case, reset startFragRequested flag
      if (!this.loadedmetadata) {
        this.startFragRequested = false;
        this.nextLoadPosition = this.startPosition;
      }
      this.tick();
    }
  }, {
    key: 'onBufferFlushed',
    value: function onBufferFlushed() {
      /* after successful buffer flushing, filter flushed fragments from bufferedFrags
        use mediaBuffered instead of media (so that we will check against video.buffered ranges in case of alt audio track)
      */
      var media = this.mediaBuffer ? this.mediaBuffer : this.media;
      this._bufferedFrags = this._bufferedFrags.filter(function (frag) {
        return _bufferHelper2.default.isBuffered(media, (frag.startPTS + frag.endPTS) / 2);
      });

      // increase fragment load Index to avoid frag loop loading error after buffer flush
      this.fragLoadIdx += 2 * this.config.fragLoadingLoopThreshold;
      // move to IDLE once flush complete. this should trigger new fragment loading
      this.state = State.IDLE;
      // reset reference to frag
      this.fragPrevious = null;
    }
  }, {
    key: 'onLevelRemoved',
    value: function onLevelRemoved(data) {
      this.levels = this.levels.filter(function (level, index) {
        return index !== data.level;
      });
    }
  }, {
    key: 'swapAudioCodec',
    value: function swapAudioCodec() {
      this.audioCodecSwap = !this.audioCodecSwap;
    }
  }, {
    key: 'computeLivePosition',
    value: function computeLivePosition(sliding, levelDetails) {
      var targetLatency = this.config.liveSyncDuration !== undefined ? this.config.liveSyncDuration : this.config.liveSyncDurationCount * levelDetails.targetduration;
      return sliding + Math.max(0, levelDetails.totalduration - targetLatency);
    }
  }, {
    key: 'state',
    set: function set(nextState) {
      if (this.state !== nextState) {
        var previousState = this.state;
        this._state = nextState;
        _logger.logger.log('main stream:' + previousState + '->' + nextState);
        this.hls.trigger(_events2.default.STREAM_STATE_TRANSITION, { previousState: previousState, nextState: nextState });
      }
    },
    get: function get() {
      return this._state;
    }
  }, {
    key: 'currentLevel',
    get: function get() {
      var media = this.media;
      if (media) {
        var frag = this.getBufferedFrag(media.currentTime);
        if (frag) {
          return frag.level;
        }
      }
      return -1;
    }
  }, {
    key: 'nextBufferedFrag',
    get: function get() {
      var media = this.media;
      if (media) {
        // first get end range of current fragment
        return this.followingBufferedFrag(this.getBufferedFrag(media.currentTime));
      } else {
        return null;
      }
    }
  }, {
    key: 'nextLevel',
    get: function get() {
      var frag = this.nextBufferedFrag;
      if (frag) {
        return frag.level;
      } else {
        return -1;
      }
    }
  }, {
    key: 'liveSyncPosition',
    get: function get() {
      return this._liveSyncPosition;
    },
    set: function set(value) {
      this._liveSyncPosition = value;
    }
  }]);

  return StreamController;
}(_eventHandler2.default);

exports.default = StreamController;

},{"../demux/demuxer":24,"../errors":30,"../event-handler":31,"../events":32,"../helper/buffer-helper":34,"../helper/level-helper":35,"../utils/binary-search":45,"../utils/discontinuities":48,"../utils/logger":51,"../utils/timeRanges":52}],13:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _eventHandler = require('../event-handler');

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _logger = require('../utils/logger');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Subtitle Stream Controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

var SubtitleStreamController = function (_EventHandler) {
  _inherits(SubtitleStreamController, _EventHandler);

  function SubtitleStreamController(hls) {
    _classCallCheck(this, SubtitleStreamController);

    var _this = _possibleConstructorReturn(this, (SubtitleStreamController.__proto__ || Object.getPrototypeOf(SubtitleStreamController)).call(this, hls, _events2.default.ERROR, _events2.default.SUBTITLE_TRACKS_UPDATED, _events2.default.SUBTITLE_TRACK_SWITCH, _events2.default.SUBTITLE_TRACK_LOADED, _events2.default.SUBTITLE_FRAG_PROCESSED));

    _this.config = hls.config;
    _this.vttFragSNsProcessed = {};
    _this.vttFragQueues = undefined;
    _this.currentlyProcessing = null;
    _this.currentTrackId = -1;
    return _this;
  }

  _createClass(SubtitleStreamController, [{
    key: 'destroy',
    value: function destroy() {
      _eventHandler2.default.prototype.destroy.call(this);
    }

    // Remove all queued items and create a new, empty queue for each track.

  }, {
    key: 'clearVttFragQueues',
    value: function clearVttFragQueues() {
      var _this2 = this;

      this.vttFragQueues = {};
      this.tracks.forEach(function (track) {
        _this2.vttFragQueues[track.id] = [];
      });
    }

    // If no frag is being processed and queue isn't empty, initiate processing of next frag in line.

  }, {
    key: 'nextFrag',
    value: function nextFrag() {
      if (this.currentlyProcessing === null && this.currentTrackId > -1 && this.vttFragQueues[this.currentTrackId].length) {
        var frag = this.currentlyProcessing = this.vttFragQueues[this.currentTrackId].shift();
        this.hls.trigger(_events2.default.FRAG_LOADING, { frag: frag });
      }
    }

    // When fragment has finished processing, add sn to list of completed if successful.

  }, {
    key: 'onSubtitleFragProcessed',
    value: function onSubtitleFragProcessed(data) {
      if (data.success) {
        this.vttFragSNsProcessed[data.frag.trackId].push(data.frag.sn);
      }
      this.currentlyProcessing = null;
      this.nextFrag();
    }

    // If something goes wrong, procede to next frag, if we were processing one.

  }, {
    key: 'onError',
    value: function onError(data) {
      var frag = data.frag;
      // don't handle frag error not related to subtitle fragment
      if (frag && frag.type !== 'subtitle') {
        return;
      }
      if (this.currentlyProcessing) {
        this.currentlyProcessing = null;
        this.nextFrag();
      }
    }

    // Got all new subtitle tracks.

  }, {
    key: 'onSubtitleTracksUpdated',
    value: function onSubtitleTracksUpdated(data) {
      var _this3 = this;

      _logger.logger.log('subtitle tracks updated');
      this.tracks = data.subtitleTracks;
      this.clearVttFragQueues();
      this.vttFragSNsProcessed = {};
      this.tracks.forEach(function (track) {
        _this3.vttFragSNsProcessed[track.id] = [];
      });
    }
  }, {
    key: 'onSubtitleTrackSwitch',
    value: function onSubtitleTrackSwitch(data) {
      this.currentTrackId = data.id;
      this.clearVttFragQueues();
    }

    // Got a new set of subtitle fragments.

  }, {
    key: 'onSubtitleTrackLoaded',
    value: function onSubtitleTrackLoaded(data) {
      var processedFragSNs = this.vttFragSNsProcessed[data.id],
          fragQueue = this.vttFragQueues[data.id],
          currentFragSN = !!this.currentlyProcessing ? this.currentlyProcessing.sn : -1;

      var alreadyProcessed = function alreadyProcessed(frag) {
        return processedFragSNs.indexOf(frag.sn) > -1;
      };

      var alreadyInQueue = function alreadyInQueue(frag) {
        return fragQueue.some(function (fragInQueue) {
          return fragInQueue.sn === frag.sn;
        });
      };

      // Add all fragments that haven't been, aren't currently being and aren't waiting to be processed, to queue.
      data.details.fragments.forEach(function (frag) {
        if (!(alreadyProcessed(frag) || frag.sn === currentFragSN || alreadyInQueue(frag))) {
          // Frags don't know their subtitle track ID, so let's just add that...
          frag.trackId = data.id;
          fragQueue.push(frag);
        }
      });

      this.nextFrag();
    }
  }]);

  return SubtitleStreamController;
}(_eventHandler2.default);

exports.default = SubtitleStreamController;

},{"../event-handler":31,"../events":32,"../utils/logger":51}],14:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _eventHandler = require('../event-handler');

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _logger = require('../utils/logger');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * audio track controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

var SubtitleTrackController = function (_EventHandler) {
  _inherits(SubtitleTrackController, _EventHandler);

  function SubtitleTrackController(hls) {
    _classCallCheck(this, SubtitleTrackController);

    var _this = _possibleConstructorReturn(this, (SubtitleTrackController.__proto__ || Object.getPrototypeOf(SubtitleTrackController)).call(this, hls, _events2.default.MEDIA_ATTACHED, _events2.default.MEDIA_DETACHING, _events2.default.MANIFEST_LOADING, _events2.default.MANIFEST_LOADED, _events2.default.SUBTITLE_TRACK_LOADED));

    _this.tracks = [];
    _this.trackId = -1;
    _this.media = undefined;
    return _this;
  }

  _createClass(SubtitleTrackController, [{
    key: 'destroy',
    value: function destroy() {
      _eventHandler2.default.prototype.destroy.call(this);
    }

    // Listen for subtitle track change, then extract the current track ID.

  }, {
    key: 'onMediaAttached',
    value: function onMediaAttached(data) {
      var _this2 = this;

      this.media = data.media;
      if (!this.media) {
        return;
      }

      this.media.textTracks.addEventListener('change', function () {
        // Media is undefined when switching streams via loadSource()
        if (!_this2.media) {
          return;
        }

        var trackId = -1;
        var tracks = _this2.media.textTracks;
        for (var id = 0; id < tracks.length; id++) {
          if (tracks[id].mode === 'showing') {
            trackId = id;
          }
        }
        // Setting current subtitleTrack will invoke code.
        _this2.subtitleTrack = trackId;
      });
    }
  }, {
    key: 'onMediaDetaching',
    value: function onMediaDetaching() {
      // TODO: Remove event listeners.
      this.media = undefined;
    }

    // Reset subtitle tracks on manifest loading

  }, {
    key: 'onManifestLoading',
    value: function onManifestLoading() {
      this.tracks = [];
      this.trackId = -1;
    }

    // Fired whenever a new manifest is loaded.

  }, {
    key: 'onManifestLoaded',
    value: function onManifestLoaded(data) {
      var _this3 = this;

      var tracks = data.subtitles || [];
      var defaultFound = false;
      this.tracks = tracks;
      this.trackId = -1;
      this.hls.trigger(_events2.default.SUBTITLE_TRACKS_UPDATED, { subtitleTracks: tracks });

      // loop through available subtitle tracks and autoselect default if needed
      // TODO: improve selection logic to handle forced, etc
      tracks.forEach(function (track) {
        if (track.default) {
          _this3.subtitleTrack = track.id;
          defaultFound = true;
        }
      });
    }

    // Trigger subtitle track playlist reload.

  }, {
    key: 'onTick',
    value: function onTick() {
      var trackId = this.trackId;
      var subtitleTrack = this.tracks[trackId];
      if (!subtitleTrack) {
        return;
      }

      var details = subtitleTrack.details;
      // check if we need to load playlist for this subtitle Track
      if (details === undefined || details.live === true) {
        // track not retrieved yet, or live playlist we need to (re)load it
        _logger.logger.log('(re)loading playlist for subtitle track ' + trackId);
        this.hls.trigger(_events2.default.SUBTITLE_TRACK_LOADING, { url: subtitleTrack.url, id: trackId });
      }
    }
  }, {
    key: 'onSubtitleTrackLoaded',
    value: function onSubtitleTrackLoaded(data) {
      var _this4 = this;

      if (data.id < this.tracks.length) {
        _logger.logger.log('subtitle track ' + data.id + ' loaded');
        this.tracks[data.id].details = data.details;
        // check if current playlist is a live playlist
        if (data.details.live && !this.timer) {
          // if live playlist we will have to reload it periodically
          // set reload period to playlist target duration
          this.timer = setInterval(function () {
            _this4.onTick();
          }, 1000 * data.details.targetduration, this);
        }
        if (!data.details.live && this.timer) {
          // playlist is not live and timer is armed : stopping it
          clearInterval(this.timer);
          this.timer = null;
        }
      }
    }

    /** get alternate subtitle tracks list from playlist **/

  }, {
    key: 'setSubtitleTrackInternal',
    value: function setSubtitleTrackInternal(newId) {
      // check if level idx is valid
      if (newId >= 0 && newId < this.tracks.length) {
        // stopping live reloading timer if any
        if (this.timer) {
          clearInterval(this.timer);
          this.timer = null;
        }
        this.trackId = newId;
        _logger.logger.log('switching to subtitle track ' + newId);
        var subtitleTrack = this.tracks[newId];
        this.hls.trigger(_events2.default.SUBTITLE_TRACK_SWITCH, { id: newId });
        // check if we need to load playlist for this subtitle Track
        var details = subtitleTrack.details;
        if (details === undefined || details.live === true) {
          // track not retrieved yet, or live playlist we need to (re)load it
          _logger.logger.log('(re)loading playlist for subtitle track ' + newId);
          this.hls.trigger(_events2.default.SUBTITLE_TRACK_LOADING, { url: subtitleTrack.url, id: newId });
        }
      }
    }
  }, {
    key: 'subtitleTracks',
    get: function get() {
      return this.tracks;
    }

    /** get index of the selected subtitle track (index in subtitle track lists) **/

  }, {
    key: 'subtitleTrack',
    get: function get() {
      return this.trackId;
    }

    /** select a subtitle track, based on its index in subtitle track lists**/
    ,
    set: function set(subtitleTrackId) {
      if (this.trackId !== subtitleTrackId) {
        // || this.tracks[subtitleTrackId].details === undefined) {
        this.setSubtitleTrackInternal(subtitleTrackId);
      }
    }
  }]);

  return SubtitleTrackController;
}(_eventHandler2.default);

exports.default = SubtitleTrackController;

},{"../event-handler":31,"../events":32,"../utils/logger":51}],15:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _eventHandler = require('../event-handler');

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _cea608Parser = require('../utils/cea-608-parser');

var _cea608Parser2 = _interopRequireDefault(_cea608Parser);

var _webvttParser = require('../utils/webvtt-parser');

var _webvttParser2 = _interopRequireDefault(_webvttParser);

var _logger = require('../utils/logger');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Timeline Controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

function clearCurrentCues(track) {
  if (track && track.cues) {
    while (track.cues.length > 0) {
      track.removeCue(track.cues[0]);
    }
  }
}

function reuseVttTextTrack(inUseTrack, manifestTrack) {
  return inUseTrack && (!inUseTrack._id || /^subtitle/.test(inUseTrack._id)) && inUseTrack.label === manifestTrack.name && !(inUseTrack.textTrack1 || inUseTrack.textTrack2);
}

function intersection(x1, x2, y1, y2) {
  return Math.min(x2, y2) - Math.max(x1, y1);
}

var TimelineController = function (_EventHandler) {
  _inherits(TimelineController, _EventHandler);

  function TimelineController(hls) {
    _classCallCheck(this, TimelineController);

    var _this = _possibleConstructorReturn(this, (TimelineController.__proto__ || Object.getPrototypeOf(TimelineController)).call(this, hls, _events2.default.MEDIA_ATTACHING, _events2.default.MEDIA_DETACHING, _events2.default.FRAG_PARSING_USERDATA, _events2.default.MANIFEST_LOADING, _events2.default.MANIFEST_LOADED, _events2.default.FRAG_LOADED, _events2.default.LEVEL_SWITCHING, _events2.default.INIT_PTS_FOUND));

    _this.hls = hls;
    _this.config = hls.config;
    _this.enabled = true;
    _this.Cues = hls.config.cueHandler;
    _this.textTracks = [];
    _this.tracks = [];
    _this.unparsedVttFrags = [];
    _this.initPTS = undefined;
    _this.cueRanges = [];
    _this.manifestCaptionsLabels = {};

    if (_this.config.enableCEA708Captions) {
      var self = _this;
      var captionsLabels = _this.manifestCaptionsLabels;
      var sendAddTrackEvent = function sendAddTrackEvent(track, media) {
        var e = null;
        try {
          e = new window.Event('addtrack');
        } catch (err) {
          //for IE11
          e = document.createEvent('Event');
          e.initEvent('addtrack', false, false);
        }
        e.track = track;
        media.dispatchEvent(e);
      };

      var channel1 = {
        'newCue': function newCue(startTime, endTime, screen) {
          if (!self.textTrack1) {
            //Enable reuse of existing text track.
            var existingTrack1 = self.getExistingTrack('1');
            if (!existingTrack1) {
              self.textTrack1 = self.createTextTrack('captions', captionsLabels.captionsTextTrack1Label, captionsLabels.captionsTextTrack1LanguageCode);
              self.textTrack1.textTrack1 = true;
            } else {
              self.textTrack1 = existingTrack1;
              clearCurrentCues(self.textTrack1);

              sendAddTrackEvent(self.textTrack1, self.media);
            }
          }
          self.addCues('textTrack1', startTime, endTime, screen);
        }
      };

      var channel2 = {
        'newCue': function newCue(startTime, endTime, screen) {
          if (!self.textTrack2) {
            //Enable reuse of existing text track.
            var existingTrack2 = self.getExistingTrack('2');
            if (!existingTrack2) {
              self.textTrack2 = self.createTextTrack('captions', captionsLabels.captionsTextTrack2Label, captionsLabels.captionsTextTrack2LanguageCode);
              self.textTrack2.textTrack2 = true;
            } else {
              self.textTrack2 = existingTrack2;
              clearCurrentCues(self.textTrack2);

              sendAddTrackEvent(self.textTrack2, self.media);
            }
          }
          self.addCues('textTrack2', startTime, endTime, screen);
        }
      };

      _this.cea608Parser = new _cea608Parser2.default(0, channel1, channel2);
    }
    return _this;
  }

  _createClass(TimelineController, [{
    key: 'addCues',
    value: function addCues(channel, startTime, endTime, screen) {
      // skip cues which overlap more than 50% with previously parsed time ranges
      var ranges = this.cueRanges;
      var merged = false;
      for (var i = ranges.length; i--;) {
        var cueRange = ranges[i];
        var overlap = intersection(cueRange[0], cueRange[1], startTime, endTime);
        if (overlap >= 0) {
          cueRange[0] = Math.min(cueRange[0], startTime);
          cueRange[1] = Math.max(cueRange[1], endTime);
          merged = true;
          if (overlap / (endTime - startTime) > 0.5) {
            return;
          }
        }
      }
      if (!merged) {
        ranges.push([startTime, endTime]);
      }
      this.Cues.newCue(this[channel], startTime, endTime, screen);
    }

    // Triggered when an initial PTS is found; used for synchronisation of WebVTT.

  }, {
    key: 'onInitPtsFound',
    value: function onInitPtsFound(data) {
      var _this2 = this;

      if (typeof this.initPTS === 'undefined') {
        this.initPTS = data.initPTS;
      }

      // Due to asynchrony, initial PTS may arrive later than the first VTT fragments are loaded.
      // Parse any unparsed fragments upon receiving the initial PTS.
      if (this.unparsedVttFrags.length) {
        this.unparsedVttFrags.forEach(function (frag) {
          _this2.onFragLoaded(frag);
        });
        this.unparsedVttFrags = [];
      }
    }
  }, {
    key: 'getExistingTrack',
    value: function getExistingTrack(channelNumber) {
      var media = this.media;
      if (media) {
        for (var i = 0; i < media.textTracks.length; i++) {
          var textTrack = media.textTracks[i];
          var propName = 'textTrack' + channelNumber;
          if (textTrack[propName] === true) {
            return textTrack;
          }
        }
      }
      return null;
    }
  }, {
    key: 'createTextTrack',
    value: function createTextTrack(kind, label, lang) {
      var media = this.media;
      if (media) {
        return media.addTextTrack(kind, label, lang);
      }
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      _eventHandler2.default.prototype.destroy.call(this);
    }
  }, {
    key: 'onMediaAttaching',
    value: function onMediaAttaching(data) {
      this.media = data.media;
    }
  }, {
    key: 'onMediaDetaching',
    value: function onMediaDetaching() {
      clearCurrentCues(this.textTrack1);
      clearCurrentCues(this.textTrack2);
    }
  }, {
    key: 'onManifestLoading',
    value: function onManifestLoading() {
      this.lastSn = -1; // Detect discontiguity in fragment parsing
      this.prevCC = -1;
      this.vttCCs = { ccOffset: 0, presentationOffset: 0 }; // Detect discontinuity in subtitle manifests

      // clear outdated subtitles
      var media = this.media;
      if (media) {
        var textTracks = media.textTracks;
        if (textTracks) {
          for (var i = 0; i < textTracks.length; i++) {
            clearCurrentCues(textTracks[i]);
          }
        }
      }
    }
  }, {
    key: 'onManifestLoaded',
    value: function onManifestLoaded(data) {
      var _this3 = this;

      this.textTracks = [];
      this.unparsedVttFrags = this.unparsedVttFrags || [];
      this.initPTS = undefined;
      this.cueRanges = [];
      var captionsLabels = this.manifestCaptionsLabels;

      captionsLabels.captionsTextTrack1Label = 'Unknown CC';
      captionsLabels.captionsTextTrack1LanguageCode = 'en';
      captionsLabels.captionsTextTrack2Label = 'Unknown CC';
      captionsLabels.captionsTextTrack2LanguageCode = 'es';

      if (this.config.enableWebVTT) {
        (function () {
          _this3.tracks = data.subtitles || [];
          var inUseTracks = _this3.media ? _this3.media.textTracks : [];

          _this3.tracks.forEach(function (track, index) {
            var textTrack = void 0;
            if (index < inUseTracks.length) {
              var inUseTrack = inUseTracks[index];
              // Reuse tracks with the same label, but do not reuse 608/708 tracks
              if (reuseVttTextTrack(inUseTrack, track)) {
                textTrack = inUseTrack;
              }
            }
            if (!textTrack) {
              textTrack = _this3.createTextTrack('subtitles', track.name, track.lang);
            }
            textTrack.mode = track.default ? 'showing' : 'hidden';
            _this3.textTracks.push(textTrack);
          });
        })();
      }

      if (this.config.enableCEA708Captions && data.captions) {
        (function () {
          var index = void 0;
          var instreamIdMatch = void 0;

          data.captions.forEach(function (captionsTrack) {
            instreamIdMatch = /(?:CC|SERVICE)([1-2])/.exec(captionsTrack.instreamId);

            if (!instreamIdMatch) {
              return;
            }

            index = instreamIdMatch[1];
            captionsLabels['captionsTextTrack' + index + 'Label'] = captionsTrack.name;

            if (captionsTrack.lang) {
              // optional attribute
              captionsLabels['captionsTextTrack' + index + 'LanguageCode'] = captionsTrack.lang;
            }
          });
        })();
      }
    }
  }, {
    key: 'onLevelSwitching',
    value: function onLevelSwitching() {
      this.enabled = this.hls.currentLevel.closedCaptions !== 'NONE';
    }
  }, {
    key: 'onFragLoaded',
    value: function onFragLoaded(data) {
      var _this4 = this;

      var frag = data.frag,
          payload = data.payload;
      if (frag.type === 'main') {
        var sn = frag.sn;
        // if this frag isn't contiguous, clear the parser so cues with bad start/end times aren't added to the textTrack
        if (sn !== this.lastSn + 1) {
          this.cea608Parser.reset();
        }
        this.lastSn = sn;
      }
      // If fragment is subtitle type, parse as WebVTT.
      else if (frag.type === 'subtitle') {
          if (payload.byteLength) {
            var _ret3 = function () {
              // We need an initial synchronisation PTS. Store fragments as long as none has arrived.
              if (typeof _this4.initPTS === 'undefined') {
                _this4.unparsedVttFrags.push(data);
                return {
                  v: void 0
                };
              }
              var vttCCs = _this4.vttCCs;
              if (!vttCCs[frag.cc]) {
                vttCCs[frag.cc] = { start: frag.start, prevCC: _this4.prevCC, new: true };
                _this4.prevCC = frag.cc;
              }
              var textTracks = _this4.textTracks,
                  hls = _this4.hls;

              // Parse the WebVTT file contents.
              _webvttParser2.default.parse(payload, _this4.initPTS, vttCCs, frag.cc, function (cues) {
                // Add cues and trigger event with success true.
                cues.forEach(function (cue) {
                  textTracks[frag.trackId].addCue(cue);
                });
                hls.trigger(_events2.default.SUBTITLE_FRAG_PROCESSED, { success: true, frag: frag });
              }, function (e) {
                // Something went wrong while parsing. Trigger event with success false.
                _logger.logger.log('Failed to parse VTT cue: ' + e);
                hls.trigger(_events2.default.SUBTITLE_FRAG_PROCESSED, { success: false, frag: frag });
              });
            }();

            if ((typeof _ret3 === 'undefined' ? 'undefined' : _typeof(_ret3)) === "object") return _ret3.v;
          } else {
            // In case there is no payload, finish unsuccessfully.
            this.hls.trigger(_events2.default.SUBTITLE_FRAG_PROCESSED, { success: false, frag: frag });
          }
        }
    }
  }, {
    key: 'onFragParsingUserdata',
    value: function onFragParsingUserdata(data) {
      // push all of the CEA-708 messages into the interpreter
      // immediately. It will create the proper timestamps based on our PTS value
      if (this.enabled && this.config.enableCEA708Captions) {
        for (var i = 0; i < data.samples.length; i++) {
          var ccdatas = this.extractCea608Data(data.samples[i].bytes);
          this.cea608Parser.addData(data.samples[i].pts, ccdatas);
        }
      }
    }
  }, {
    key: 'extractCea608Data',
    value: function extractCea608Data(byteArray) {
      var count = byteArray[0] & 31;
      var position = 2;
      var tmpByte, ccbyte1, ccbyte2, ccValid, ccType;
      var actualCCBytes = [];

      for (var j = 0; j < count; j++) {
        tmpByte = byteArray[position++];
        ccbyte1 = 0x7F & byteArray[position++];
        ccbyte2 = 0x7F & byteArray[position++];
        ccValid = (4 & tmpByte) !== 0;
        ccType = 3 & tmpByte;

        if (ccbyte1 === 0 && ccbyte2 === 0) {
          continue;
        }

        if (ccValid) {
          if (ccType === 0) // || ccType === 1
            {
              actualCCBytes.push(ccbyte1);
              actualCCBytes.push(ccbyte2);
            }
        }
      }
      return actualCCBytes;
    }
  }]);

  return TimelineController;
}(_eventHandler2.default);

exports.default = TimelineController;

},{"../event-handler":31,"../events":32,"../utils/cea-608-parser":46,"../utils/logger":51,"../utils/webvtt-parser":55}],16:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var AESCrypto = function () {
  function AESCrypto(subtle, iv) {
    _classCallCheck(this, AESCrypto);

    this.subtle = subtle;
    this.aesIV = iv;
  }

  _createClass(AESCrypto, [{
    key: 'decrypt',
    value: function decrypt(data, key) {
      return this.subtle.decrypt({ name: 'AES-CBC', iv: this.aesIV }, key, data);
    }
  }]);

  return AESCrypto;
}();

exports.default = AESCrypto;

},{}],17:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var AESDecryptor = function () {
  function AESDecryptor() {
    _classCallCheck(this, AESDecryptor);

    // Static after running initTable
    this.rcon = [0x0, 0x1, 0x2, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];
    this.subMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)];
    this.invSubMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)];
    this.sBox = new Uint32Array(256);
    this.invSBox = new Uint32Array(256);

    // Changes during runtime
    this.key = new Uint32Array(0);

    this.initTable();
  }

  // Using view.getUint32() also swaps the byte order.


  _createClass(AESDecryptor, [{
    key: 'uint8ArrayToUint32Array_',
    value: function uint8ArrayToUint32Array_(arrayBuffer) {
      var view = new DataView(arrayBuffer);
      var newArray = new Uint32Array(4);
      for (var i = 0; i < 4; i++) {
        newArray[i] = view.getUint32(i * 4);
      }
      return newArray;
    }
  }, {
    key: 'initTable',
    value: function initTable() {
      var sBox = this.sBox;
      var invSBox = this.invSBox;
      var subMix = this.subMix;
      var subMix0 = subMix[0];
      var subMix1 = subMix[1];
      var subMix2 = subMix[2];
      var subMix3 = subMix[3];
      var invSubMix = this.invSubMix;
      var invSubMix0 = invSubMix[0];
      var invSubMix1 = invSubMix[1];
      var invSubMix2 = invSubMix[2];
      var invSubMix3 = invSubMix[3];

      var d = new Uint32Array(256);
      var x = 0;
      var xi = 0;
      var i = 0;
      for (i = 0; i < 256; i++) {
        if (i < 128) {
          d[i] = i << 1;
        } else {
          d[i] = i << 1 ^ 0x11b;
        }
      }

      for (i = 0; i < 256; i++) {
        var sx = xi ^ xi << 1 ^ xi << 2 ^ xi << 3 ^ xi << 4;
        sx = sx >>> 8 ^ sx & 0xff ^ 0x63;
        sBox[x] = sx;
        invSBox[sx] = x;

        // Compute multiplication
        var x2 = d[x];
        var x4 = d[x2];
        var x8 = d[x4];

        // Compute sub/invSub bytes, mix columns tables
        var t = d[sx] * 0x101 ^ sx * 0x1010100;
        subMix0[x] = t << 24 | t >>> 8;
        subMix1[x] = t << 16 | t >>> 16;
        subMix2[x] = t << 8 | t >>> 24;
        subMix3[x] = t;

        // Compute inv sub bytes, inv mix columns tables
        t = x8 * 0x1010101 ^ x4 * 0x10001 ^ x2 * 0x101 ^ x * 0x1010100;
        invSubMix0[sx] = t << 24 | t >>> 8;
        invSubMix1[sx] = t << 16 | t >>> 16;
        invSubMix2[sx] = t << 8 | t >>> 24;
        invSubMix3[sx] = t;

        // Compute next counter
        if (!x) {
          x = xi = 1;
        } else {
          x = x2 ^ d[d[d[x8 ^ x2]]];
          xi ^= d[d[xi]];
        }
      }
    }
  }, {
    key: 'expandKey',
    value: function expandKey(keyBuffer) {
      // convert keyBuffer to Uint32Array
      var key = this.uint8ArrayToUint32Array_(keyBuffer);
      var sameKey = true;
      var offset = 0;

      while (offset < key.length && sameKey) {
        sameKey = key[offset] === this.key[offset];
        offset++;
      }

      if (sameKey) {
        return;
      }

      this.key = key;
      var keySize = this.keySize = key.length;

      if (keySize !== 4 && keySize !== 6 && keySize !== 8) {
        throw new Error('Invalid aes key size=' + keySize);
      }

      var ksRows = this.ksRows = (keySize + 6 + 1) * 4;
      var ksRow = void 0;
      var invKsRow = void 0;

      var keySchedule = this.keySchedule = new Uint32Array(ksRows);
      var invKeySchedule = this.invKeySchedule = new Uint32Array(ksRows);
      var sbox = this.sBox;
      var rcon = this.rcon;

      var invSubMix = this.invSubMix;
      var invSubMix0 = invSubMix[0];
      var invSubMix1 = invSubMix[1];
      var invSubMix2 = invSubMix[2];
      var invSubMix3 = invSubMix[3];

      var prev = void 0;
      var t = void 0;

      for (ksRow = 0; ksRow < ksRows; ksRow++) {
        if (ksRow < keySize) {
          prev = keySchedule[ksRow] = key[ksRow];
          continue;
        }
        t = prev;

        if (ksRow % keySize === 0) {
          // Rot word
          t = t << 8 | t >>> 24;

          // Sub word
          t = sbox[t >>> 24] << 24 | sbox[t >>> 16 & 0xff] << 16 | sbox[t >>> 8 & 0xff] << 8 | sbox[t & 0xff];

          // Mix Rcon
          t ^= rcon[ksRow / keySize | 0] << 24;
        } else if (keySize > 6 && ksRow % keySize === 4) {
          // Sub word
          t = sbox[t >>> 24] << 24 | sbox[t >>> 16 & 0xff] << 16 | sbox[t >>> 8 & 0xff] << 8 | sbox[t & 0xff];
        }

        keySchedule[ksRow] = prev = (keySchedule[ksRow - keySize] ^ t) >>> 0;
      }

      for (invKsRow = 0; invKsRow < ksRows; invKsRow++) {
        ksRow = ksRows - invKsRow;
        if (invKsRow & 3) {
          t = keySchedule[ksRow];
        } else {
          t = keySchedule[ksRow - 4];
        }

        if (invKsRow < 4 || ksRow <= 4) {
          invKeySchedule[invKsRow] = t;
        } else {
          invKeySchedule[invKsRow] = invSubMix0[sbox[t >>> 24]] ^ invSubMix1[sbox[t >>> 16 & 0xff]] ^ invSubMix2[sbox[t >>> 8 & 0xff]] ^ invSubMix3[sbox[t & 0xff]];
        }

        invKeySchedule[invKsRow] = invKeySchedule[invKsRow] >>> 0;
      }
    }

    // Adding this as a method greatly improves performance.

  }, {
    key: 'networkToHostOrderSwap',
    value: function networkToHostOrderSwap(word) {
      return word << 24 | (word & 0xff00) << 8 | (word & 0xff0000) >> 8 | word >>> 24;
    }
  }, {
    key: 'decrypt',
    value: function decrypt(inputArrayBuffer, offset, aesIV) {
      var nRounds = this.keySize + 6;
      var invKeySchedule = this.invKeySchedule;
      var invSBOX = this.invSBox;

      var invSubMix = this.invSubMix;
      var invSubMix0 = invSubMix[0];
      var invSubMix1 = invSubMix[1];
      var invSubMix2 = invSubMix[2];
      var invSubMix3 = invSubMix[3];

      var initVector = this.uint8ArrayToUint32Array_(aesIV);
      var initVector0 = initVector[0];
      var initVector1 = initVector[1];
      var initVector2 = initVector[2];
      var initVector3 = initVector[3];

      var inputInt32 = new Int32Array(inputArrayBuffer);
      var outputInt32 = new Int32Array(inputInt32.length);

      var t0 = void 0,
          t1 = void 0,
          t2 = void 0,
          t3 = void 0;
      var s0 = void 0,
          s1 = void 0,
          s2 = void 0,
          s3 = void 0;
      var inputWords0 = void 0,
          inputWords1 = void 0,
          inputWords2 = void 0,
          inputWords3 = void 0;

      var ksRow, i;
      var swapWord = this.networkToHostOrderSwap;

      while (offset < inputInt32.length) {
        inputWords0 = swapWord(inputInt32[offset]);
        inputWords1 = swapWord(inputInt32[offset + 1]);
        inputWords2 = swapWord(inputInt32[offset + 2]);
        inputWords3 = swapWord(inputInt32[offset + 3]);

        s0 = inputWords0 ^ invKeySchedule[0];
        s1 = inputWords3 ^ invKeySchedule[1];
        s2 = inputWords2 ^ invKeySchedule[2];
        s3 = inputWords1 ^ invKeySchedule[3];

        ksRow = 4;

        // Iterate through the rounds of decryption
        for (i = 1; i < nRounds; i++) {
          t0 = invSubMix0[s0 >>> 24] ^ invSubMix1[s1 >> 16 & 0xff] ^ invSubMix2[s2 >> 8 & 0xff] ^ invSubMix3[s3 & 0xff] ^ invKeySchedule[ksRow];
          t1 = invSubMix0[s1 >>> 24] ^ invSubMix1[s2 >> 16 & 0xff] ^ invSubMix2[s3 >> 8 & 0xff] ^ invSubMix3[s0 & 0xff] ^ invKeySchedule[ksRow + 1];
          t2 = invSubMix0[s2 >>> 24] ^ invSubMix1[s3 >> 16 & 0xff] ^ invSubMix2[s0 >> 8 & 0xff] ^ invSubMix3[s1 & 0xff] ^ invKeySchedule[ksRow + 2];
          t3 = invSubMix0[s3 >>> 24] ^ invSubMix1[s0 >> 16 & 0xff] ^ invSubMix2[s1 >> 8 & 0xff] ^ invSubMix3[s2 & 0xff] ^ invKeySchedule[ksRow + 3];
          // Update state
          s0 = t0;
          s1 = t1;
          s2 = t2;
          s3 = t3;

          ksRow = ksRow + 4;
        }

        // Shift rows, sub bytes, add round key
        t0 = invSBOX[s0 >>> 24] << 24 ^ invSBOX[s1 >> 16 & 0xff] << 16 ^ invSBOX[s2 >> 8 & 0xff] << 8 ^ invSBOX[s3 & 0xff] ^ invKeySchedule[ksRow];
        t1 = invSBOX[s1 >>> 24] << 24 ^ invSBOX[s2 >> 16 & 0xff] << 16 ^ invSBOX[s3 >> 8 & 0xff] << 8 ^ invSBOX[s0 & 0xff] ^ invKeySchedule[ksRow + 1];
        t2 = invSBOX[s2 >>> 24] << 24 ^ invSBOX[s3 >> 16 & 0xff] << 16 ^ invSBOX[s0 >> 8 & 0xff] << 8 ^ invSBOX[s1 & 0xff] ^ invKeySchedule[ksRow + 2];
        t3 = invSBOX[s3 >>> 24] << 24 ^ invSBOX[s0 >> 16 & 0xff] << 16 ^ invSBOX[s1 >> 8 & 0xff] << 8 ^ invSBOX[s2 & 0xff] ^ invKeySchedule[ksRow + 3];
        ksRow = ksRow + 3;

        // Write
        outputInt32[offset] = swapWord(t0 ^ initVector0);
        outputInt32[offset + 1] = swapWord(t3 ^ initVector1);
        outputInt32[offset + 2] = swapWord(t2 ^ initVector2);
        outputInt32[offset + 3] = swapWord(t1 ^ initVector3);

        // reset initVector to last 4 unsigned int
        initVector0 = inputWords0;
        initVector1 = inputWords1;
        initVector2 = inputWords2;
        initVector3 = inputWords3;

        offset = offset + 4;
      }

      return outputInt32.buffer;
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      this.key = undefined;
      this.keySize = undefined;
      this.ksRows = undefined;

      this.sBox = undefined;
      this.invSBox = undefined;
      this.subMix = undefined;
      this.invSubMix = undefined;
      this.keySchedule = undefined;
      this.invKeySchedule = undefined;

      this.rcon = undefined;
    }
  }]);

  return AESDecryptor;
}();

exports.default = AESDecryptor;

},{}],18:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _aesCrypto = require('./aes-crypto');

var _aesCrypto2 = _interopRequireDefault(_aesCrypto);

var _fastAesKey = require('./fast-aes-key');

var _fastAesKey2 = _interopRequireDefault(_fastAesKey);

var _aesDecryptor = require('./aes-decryptor');

var _aesDecryptor2 = _interopRequireDefault(_aesDecryptor);

var _errors = require('../errors');

var _logger = require('../utils/logger');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/*globals self: false */

var Decrypter = function () {
  function Decrypter(observer, config) {
    _classCallCheck(this, Decrypter);

    this.observer = observer;
    this.config = config;
    this.logEnabled = true;
    try {
      var browserCrypto = crypto ? crypto : self.crypto;
      this.subtle = browserCrypto.subtle || browserCrypto.webkitSubtle;
    } catch (e) {}
    this.disableWebCrypto = !this.subtle;
  }

  _createClass(Decrypter, [{
    key: 'isSync',
    value: function isSync() {
      return this.disableWebCrypto && this.config.enableSoftwareAES;
    }
  }, {
    key: 'decrypt',
    value: function decrypt(data, key, iv, callback) {
      var _this = this;

      if (this.disableWebCrypto && this.config.enableSoftwareAES) {
        if (this.logEnabled) {
          _logger.logger.log('JS AES decrypt');
          this.logEnabled = false;
        }
        var decryptor = this.decryptor;
        if (!decryptor) {
          this.decryptor = decryptor = new _aesDecryptor2.default();
        }
        decryptor.expandKey(key);
        callback(decryptor.decrypt(data, 0, iv));
      } else {
        (function () {
          if (_this.logEnabled) {
            _logger.logger.log('WebCrypto AES decrypt');
            _this.logEnabled = false;
          }
          var subtle = _this.subtle;
          if (_this.key !== key) {
            _this.key = key;
            _this.fastAesKey = new _fastAesKey2.default(subtle, key);
          }

          _this.fastAesKey.expandKey().then(function (aesKey) {
            // decrypt using web crypto
            var crypto = new _aesCrypto2.default(subtle, iv);
            crypto.decrypt(data, aesKey).catch(function (err) {
              _this.onWebCryptoError(err, data, key, iv, callback);
            }).then(function (result) {
              callback(result);
            });
          }).catch(function (err) {
            _this.onWebCryptoError(err, data, key, iv, callback);
          });
        })();
      }
    }
  }, {
    key: 'onWebCryptoError',
    value: function onWebCryptoError(err, data, key, iv, callback) {
      if (this.config.enableSoftwareAES) {
        _logger.logger.log('WebCrypto Error, disable WebCrypto API');
        this.disableWebCrypto = true;
        this.logEnabled = true;
        this.decrypt(data, key, iv, callback);
      } else {
        _logger.logger.error('decrypting error : ' + err.message);
        this.observer.trigger(Event.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.FRAG_DECRYPT_ERROR, fatal: true, reason: err.message });
      }
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      var decryptor = this.decryptor;
      if (decryptor) {
        decryptor.destroy();
        this.decryptor = undefined;
      }
    }
  }]);

  return Decrypter;
}();

exports.default = Decrypter;

},{"../errors":30,"../utils/logger":51,"./aes-crypto":16,"./aes-decryptor":17,"./fast-aes-key":19}],19:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var FastAESKey = function () {
  function FastAESKey(subtle, key) {
    _classCallCheck(this, FastAESKey);

    this.subtle = subtle;
    this.key = key;
  }

  _createClass(FastAESKey, [{
    key: 'expandKey',
    value: function expandKey() {
      return this.subtle.importKey('raw', this.key, { name: 'AES-CBC' }, false, ['encrypt', 'decrypt']);
    }
  }]);

  return FastAESKey;
}();

exports.default = FastAESKey;

},{}],20:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * AAC demuxer
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */


var _adts = require('./adts');

var _adts2 = _interopRequireDefault(_adts);

var _logger = require('../utils/logger');

var _id = require('../demux/id3');

var _id2 = _interopRequireDefault(_id);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var AACDemuxer = function () {
  function AACDemuxer(observer, remuxer, config) {
    _classCallCheck(this, AACDemuxer);

    this.observer = observer;
    this.config = config;
    this.remuxer = remuxer;
  }

  _createClass(AACDemuxer, [{
    key: 'resetInitSegment',
    value: function resetInitSegment(initSegment, audioCodec, videoCodec, duration) {
      this._aacTrack = { container: 'audio/adts', type: 'audio', id: -1, sequenceNumber: 0, isAAC: true, samples: [], len: 0, manifestCodec: audioCodec, duration: duration, inputTimeScale: 90000 };
    }
  }, {
    key: 'resetTimeStamp',
    value: function resetTimeStamp() {}

    // Source for probe info - https://wiki.multimedia.cx/index.php?title=ADTS

  }, {
    key: 'append',


    // feed incoming data to the front of the parsing pipeline
    value: function append(data, timeOffset, contiguous, accurateTimeOffset) {
      var track,
          id3 = new _id2.default(data),
          pts,
          config,
          frameLength,
          frameDuration,
          frameIndex,
          offset,
          headerLength,
          stamp,
          len,
          aacSample;

      // Use ID3 Timestamp if needed, as in v4 audio tracks.  Otherwise, concat AAC audio in the order it comes in.
      pts = id3.timeStamp ? 90 * id3.timeStamp : timeOffset * 90000;

      track = this._aacTrack;

      // Look for ADTS header | 1111 1111 | 1111 X00X | where X can be either 0 or 1
      for (offset = id3.length || 0, len = data.length; offset < len - 1; offset++) {
        if (data[offset] === 0xff && (data[offset + 1] & 0xf6) === 0xf0) {
          break;
        }
      }

      if (!track.samplerate) {
        config = _adts2.default.getAudioConfig(this.observer, data, offset, track.manifestCodec);
        track.config = config.config;
        track.samplerate = config.samplerate;
        track.channelCount = config.channelCount;
        track.codec = config.codec;
        _logger.logger.log('parsed codec:' + track.codec + ',rate:' + config.samplerate + ',nb channel:' + config.channelCount);
      }
      frameIndex = 0;
      frameDuration = 1024 * 90000 / track.samplerate;
      while (offset + 5 < len) {
        // The protection skip bit tells us if we have 2 bytes of CRC data at the end of the ADTS header
        headerLength = !!(data[offset + 1] & 0x01) ? 7 : 9;
        // retrieve frame size
        frameLength = (data[offset + 3] & 0x03) << 11 | data[offset + 4] << 3 | (data[offset + 5] & 0xE0) >>> 5;
        frameLength -= headerLength;
        //stamp = pes.pts;

        if (frameLength > 0 && offset + headerLength + frameLength <= len) {
          stamp = pts + frameIndex * frameDuration;
          //logger.log(`AAC frame, offset/length/total/pts:${offset+headerLength}/${frameLength}/${data.byteLength}/${(stamp/90).toFixed(0)}`);
          aacSample = { unit: data.subarray(offset + headerLength, offset + headerLength + frameLength), pts: stamp, dts: stamp };
          track.samples.push(aacSample);
          track.len += frameLength;
          offset += frameLength + headerLength;
          frameIndex++;
          // look for ADTS header (0xFFFx)
          for (; offset < len - 1; offset++) {
            if (data[offset] === 0xff && (data[offset + 1] & 0xf0) === 0xf0) {
              break;
            }
          }
        } else {
          break;
        }
      }
      var id3Track = id3.payload ? { samples: [{ pts: pts, dts: pts, unit: id3.payload }], inputTimeScale: 90000 } : { samples: [] };
      this.remuxer.remux(track, { samples: [] }, id3Track, { samples: [] }, timeOffset, contiguous, accurateTimeOffset);
    }
  }, {
    key: 'destroy',
    value: function destroy() {}
  }], [{
    key: 'probe',
    value: function probe(data) {
      var id3 = new _id2.default(data),
          offset,
          len;
      for (offset = id3.length || 0, len = data.length; offset < len - 1; offset++) {
        // ADTS Header is | 1111 1111 | 1111 X00X | where X can be either 0 or 1
        if (data[offset] === 0xff && (data[offset + 1] & 0xf6) === 0xf0) {
          //logger.log('ADTS sync word found !');
          return true;
        }
      }
      return false;
    }
  }]);

  return AACDemuxer;
}();

exports.default = AACDemuxer;

},{"../demux/id3":26,"../utils/logger":51,"./adts":21}],21:[function(require,module,exports){
'use strict';

var _logger = require('../utils/logger');

var _errors = require('../errors');

/**
 *  ADTS parser helper
 */
var ADTS = {
  getAudioConfig: function getAudioConfig(observer, data, offset, audioCodec) {
    var adtsObjectType,
        // :int
    adtsSampleingIndex,
        // :int
    adtsExtensionSampleingIndex,
        // :int
    adtsChanelConfig,
        // :int
    config,
        userAgent = navigator.userAgent.toLowerCase(),
        manifestCodec = audioCodec,
        adtsSampleingRates = [96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050, 16000, 12000, 11025, 8000, 7350];
    // byte 2
    adtsObjectType = ((data[offset + 2] & 0xC0) >>> 6) + 1;
    adtsSampleingIndex = (data[offset + 2] & 0x3C) >>> 2;
    if (adtsSampleingIndex > adtsSampleingRates.length - 1) {
      observer.trigger(Event.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.FRAG_PARSING_ERROR, fatal: true, reason: 'invalid ADTS sampling index:' + adtsSampleingIndex });
      return;
    }
    adtsChanelConfig = (data[offset + 2] & 0x01) << 2;
    // byte 3
    adtsChanelConfig |= (data[offset + 3] & 0xC0) >>> 6;
    _logger.logger.log('manifest codec:' + audioCodec + ',ADTS data:type:' + adtsObjectType + ',sampleingIndex:' + adtsSampleingIndex + '[' + adtsSampleingRates[adtsSampleingIndex] + 'Hz],channelConfig:' + adtsChanelConfig);
    // firefox: freq less than 24kHz = AAC SBR (HE-AAC)
    if (/firefox/i.test(userAgent)) {
      if (adtsSampleingIndex >= 6) {
        adtsObjectType = 5;
        config = new Array(4);
        // HE-AAC uses SBR (Spectral Band Replication) , high frequencies are constructed from low frequencies
        // there is a factor 2 between frame sample rate and output sample rate
        // multiply frequency by 2 (see table below, equivalent to substract 3)
        adtsExtensionSampleingIndex = adtsSampleingIndex - 3;
      } else {
        adtsObjectType = 2;
        config = new Array(2);
        adtsExtensionSampleingIndex = adtsSampleingIndex;
      }
      // Android : always use AAC
    } else if (userAgent.indexOf('android') !== -1) {
      adtsObjectType = 2;
      config = new Array(2);
      adtsExtensionSampleingIndex = adtsSampleingIndex;
    } else {
      /*  for other browsers (Chrome/Vivaldi/Opera ...)
          always force audio type to be HE-AAC SBR, as some browsers do not support audio codec switch properly (like Chrome ...)
      */
      adtsObjectType = 5;
      config = new Array(4);
      // if (manifest codec is HE-AAC or HE-AACv2) OR (manifest codec not specified AND frequency less than 24kHz)
      if (audioCodec && (audioCodec.indexOf('mp4a.40.29') !== -1 || audioCodec.indexOf('mp4a.40.5') !== -1) || !audioCodec && adtsSampleingIndex >= 6) {
        // HE-AAC uses SBR (Spectral Band Replication) , high frequencies are constructed from low frequencies
        // there is a factor 2 between frame sample rate and output sample rate
        // multiply frequency by 2 (see table below, equivalent to substract 3)
        adtsExtensionSampleingIndex = adtsSampleingIndex - 3;
      } else {
        // if (manifest codec is AAC) AND (frequency less than 24kHz AND nb channel is 1) OR (manifest codec not specified and mono audio)
        // Chrome fails to play back with low frequency AAC LC mono when initialized with HE-AAC.  This is not a problem with stereo.
        if (audioCodec && audioCodec.indexOf('mp4a.40.2') !== -1 && adtsSampleingIndex >= 6 && adtsChanelConfig === 1 || !audioCodec && adtsChanelConfig === 1) {
          adtsObjectType = 2;
          config = new Array(2);
        }
        adtsExtensionSampleingIndex = adtsSampleingIndex;
      }
    }
    /* refer to http://wiki.multimedia.cx/index.php?title=MPEG-4_Audio#Audio_Specific_Config
        ISO 14496-3 (AAC).pdf - Table 1.13  Syntax of AudioSpecificConfig()
      Audio Profile / Audio Object Type
      0: Null
      1: AAC Main
      2: AAC LC (Low Complexity)
      3: AAC SSR (Scalable Sample Rate)
      4: AAC LTP (Long Term Prediction)
      5: SBR (Spectral Band Replication)
      6: AAC Scalable
     sampling freq
      0: 96000 Hz
      1: 88200 Hz
      2: 64000 Hz
      3: 48000 Hz
      4: 44100 Hz
      5: 32000 Hz
      6: 24000 Hz
      7: 22050 Hz
      8: 16000 Hz
      9: 12000 Hz
      10: 11025 Hz
      11: 8000 Hz
      12: 7350 Hz
      13: Reserved
      14: Reserved
      15: frequency is written explictly
      Channel Configurations
      These are the channel configurations:
      0: Defined in AOT Specifc Config
      1: 1 channel: front-center
      2: 2 channels: front-left, front-right
    */
    // audioObjectType = profile => profile, the MPEG-4 Audio Object Type minus 1
    config[0] = adtsObjectType << 3;
    // samplingFrequencyIndex
    config[0] |= (adtsSampleingIndex & 0x0E) >> 1;
    config[1] |= (adtsSampleingIndex & 0x01) << 7;
    // channelConfiguration
    config[1] |= adtsChanelConfig << 3;
    if (adtsObjectType === 5) {
      // adtsExtensionSampleingIndex
      config[1] |= (adtsExtensionSampleingIndex & 0x0E) >> 1;
      config[2] = (adtsExtensionSampleingIndex & 0x01) << 7;
      // adtsObjectType (force to 2, chrome is checking that object type is less than 5 ???
      //    https://chromium.googlesource.com/chromium/src.git/+/master/media/formats/mp4/aac.cc
      config[2] |= 2 << 2;
      config[3] = 0;
    }
    return { config: config, samplerate: adtsSampleingRates[adtsSampleingIndex], channelCount: adtsChanelConfig, codec: 'mp4a.40.' + adtsObjectType, manifestCodec: manifestCodec };
  }
};

module.exports = ADTS;

},{"../errors":30,"../utils/logger":51}],22:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*  inline demuxer.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *   probe fragments and instantiate appropriate demuxer depending on content type (TSDemuxer, AACDemuxer, ...)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _errors = require('../errors');

var _decrypter = require('../crypt/decrypter');

var _decrypter2 = _interopRequireDefault(_decrypter);

var _aacdemuxer = require('../demux/aacdemuxer');

var _aacdemuxer2 = _interopRequireDefault(_aacdemuxer);

var _mp4demuxer = require('../demux/mp4demuxer');

var _mp4demuxer2 = _interopRequireDefault(_mp4demuxer);

var _tsdemuxer = require('../demux/tsdemuxer');

var _tsdemuxer2 = _interopRequireDefault(_tsdemuxer);

var _mp4Remuxer = require('../remux/mp4-remuxer');

var _mp4Remuxer2 = _interopRequireDefault(_mp4Remuxer);

var _passthroughRemuxer = require('../remux/passthrough-remuxer');

var _passthroughRemuxer2 = _interopRequireDefault(_passthroughRemuxer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var DemuxerInline = function () {
  function DemuxerInline(observer, typeSupported, config, vendor) {
    _classCallCheck(this, DemuxerInline);

    this.observer = observer;
    this.typeSupported = typeSupported;
    this.config = config;
    this.vendor = vendor;
  }

  _createClass(DemuxerInline, [{
    key: 'destroy',
    value: function destroy() {
      var demuxer = this.demuxer;
      if (demuxer) {
        demuxer.destroy();
      }
    }
  }, {
    key: 'push',
    value: function push(data, decryptdata, initSegment, audioCodec, videoCodec, timeOffset, discontinuity, trackSwitch, contiguous, duration, accurateTimeOffset, defaultInitPTS) {
      if (data.byteLength > 0 && decryptdata != null && decryptdata.key != null && decryptdata.method === 'AES-128') {
        var decrypter = this.decrypter;
        if (decrypter == null) {
          decrypter = this.decrypter = new _decrypter2.default(this.observer, this.config);
        }
        var localthis = this;
        // performance.now() not available on WebWorker, at least on Safari Desktop
        var startTime;
        try {
          startTime = performance.now();
        } catch (error) {
          startTime = Date.now();
        }
        decrypter.decrypt(data, decryptdata.key.buffer, decryptdata.iv.buffer, function (decryptedData) {
          var endTime;
          try {
            endTime = performance.now();
          } catch (error) {
            endTime = Date.now();
          }
          localthis.observer.trigger(_events2.default.FRAG_DECRYPTED, { stats: { tstart: startTime, tdecrypt: endTime } });
          localthis.pushDecrypted(new Uint8Array(decryptedData), decryptdata, new Uint8Array(initSegment), audioCodec, videoCodec, timeOffset, discontinuity, trackSwitch, contiguous, duration, accurateTimeOffset, defaultInitPTS);
        });
      } else {
        this.pushDecrypted(new Uint8Array(data), decryptdata, new Uint8Array(initSegment), audioCodec, videoCodec, timeOffset, discontinuity, trackSwitch, contiguous, duration, accurateTimeOffset, defaultInitPTS);
      }
    }
  }, {
    key: 'pushDecrypted',
    value: function pushDecrypted(data, decryptdata, initSegment, audioCodec, videoCodec, timeOffset, discontinuity, trackSwitch, contiguous, duration, accurateTimeOffset, defaultInitPTS) {
      var demuxer = this.demuxer;
      if (!demuxer ||
      // in case of continuity change, we might switch from content type (AAC container to TS container for example)
      // so let's check that current demuxer is still valid
      discontinuity && !this.probe(data)) {
        var observer = this.observer;
        var typeSupported = this.typeSupported;
        var config = this.config;
        var muxConfig = [{ demux: _tsdemuxer2.default, remux: _mp4Remuxer2.default }, { demux: _aacdemuxer2.default, remux: _mp4Remuxer2.default }, { demux: _mp4demuxer2.default, remux: _passthroughRemuxer2.default }];

        // probe for content type
        for (var i in muxConfig) {
          var mux = muxConfig[i];
          var probe = mux.demux.probe;
          if (probe(data)) {
            var _remuxer = this.remuxer = new mux.remux(observer, config, typeSupported, this.vendor);
            demuxer = new mux.demux(observer, _remuxer, config, typeSupported);
            this.probe = probe;
            break;
          }
        }
        if (!demuxer) {
          observer.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.FRAG_PARSING_ERROR, fatal: true, reason: 'no demux matching with content found' });
          return;
        }
        this.demuxer = demuxer;
      }
      var remuxer = this.remuxer;

      if (discontinuity || trackSwitch) {
        demuxer.resetInitSegment(initSegment, audioCodec, videoCodec, duration);
        remuxer.resetInitSegment();
      }
      if (discontinuity) {
        demuxer.resetTimeStamp();
        remuxer.resetTimeStamp(defaultInitPTS);
      }
      if (typeof demuxer.setDecryptData === 'function') {
        demuxer.setDecryptData(decryptdata);
      }
      demuxer.append(data, timeOffset, contiguous, accurateTimeOffset);
    }
  }]);

  return DemuxerInline;
}();

exports.default = DemuxerInline;

},{"../crypt/decrypter":18,"../demux/aacdemuxer":20,"../demux/mp4demuxer":27,"../demux/tsdemuxer":29,"../errors":30,"../events":32,"../remux/mp4-remuxer":42,"../remux/passthrough-remuxer":43}],23:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _demuxerInline = require('../demux/demuxer-inline');

var _demuxerInline2 = _interopRequireDefault(_demuxerInline);

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _logger = require('../utils/logger');

var _events3 = require('events');

var _events4 = _interopRequireDefault(_events3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* demuxer web worker.
 *  - listen to worker message, and trigger DemuxerInline upon reception of Fragments.
 *  - provides MP4 Boxes back to main thread using [transferable objects](https://developers.google.com/web/updates/2011/12/Transferable-Objects-Lightning-Fast) in order to minimize message passing overhead.
 */

var DemuxerWorker = function DemuxerWorker(self) {
  // observer setup
  var observer = new _events4.default();
  observer.trigger = function trigger(event) {
    for (var _len = arguments.length, data = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      data[_key - 1] = arguments[_key];
    }

    observer.emit.apply(observer, [event, event].concat(data));
  };

  observer.off = function off(event) {
    for (var _len2 = arguments.length, data = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      data[_key2 - 1] = arguments[_key2];
    }

    observer.removeListener.apply(observer, [event].concat(data));
  };

  var forwardMessage = function forwardMessage(ev, data) {
    self.postMessage({ event: ev, data: data });
  };

  self.addEventListener('message', function (ev) {
    var data = ev.data;
    //console.log('demuxer cmd:' + data.cmd);
    switch (data.cmd) {
      case 'init':
        var config = JSON.parse(data.config);
        self.demuxer = new _demuxerInline2.default(observer, data.typeSupported, config, data.vendor);
        try {
          (0, _logger.enableLogs)(config.debug === true);
        } catch (err) {
          console.warn('demuxerWorker: unable to enable logs');
        }
        // signal end of worker init
        forwardMessage('init', null);
        break;
      case 'demux':
        self.demuxer.push(data.data, data.decryptdata, data.initSegment, data.audioCodec, data.videoCodec, data.timeOffset, data.discontinuity, data.trackSwitch, data.contiguous, data.duration, data.accurateTimeOffset, data.defaultInitPTS);
        break;
      default:
        break;
    }
  });

  // forward events to main thread
  observer.on(_events2.default.FRAG_DECRYPTED, forwardMessage);
  observer.on(_events2.default.FRAG_PARSING_INIT_SEGMENT, forwardMessage);
  observer.on(_events2.default.FRAG_PARSED, forwardMessage);
  observer.on(_events2.default.ERROR, forwardMessage);
  observer.on(_events2.default.FRAG_PARSING_METADATA, forwardMessage);
  observer.on(_events2.default.FRAG_PARSING_USERDATA, forwardMessage);
  observer.on(_events2.default.INIT_PTS_FOUND, forwardMessage);

  // special case for FRAG_PARSING_DATA: pass data1/data2 as transferable object (no copy)
  observer.on(_events2.default.FRAG_PARSING_DATA, function (ev, data) {
    var transferable = [];
    var message = { event: ev, data: data };
    if (data.data1) {
      message.data1 = data.data1.buffer;
      transferable.push(data.data1.buffer);
      delete data.data1;
    }
    if (data.data2) {
      message.data2 = data.data2.buffer;
      transferable.push(data.data2.buffer);
      delete data.data2;
    }
    self.postMessage(message, transferable);
  });
};

exports.default = DemuxerWorker;

},{"../demux/demuxer-inline":22,"../events":32,"../utils/logger":51,"events":1}],24:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _demuxerInline = require('../demux/demuxer-inline');

var _demuxerInline2 = _interopRequireDefault(_demuxerInline);

var _demuxerWorker = require('../demux/demuxer-worker');

var _demuxerWorker2 = _interopRequireDefault(_demuxerWorker);

var _logger = require('../utils/logger');

var _errors = require('../errors');

var _events3 = require('events');

var _events4 = _interopRequireDefault(_events3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Demuxer = function () {
  function Demuxer(hls, id) {
    _classCallCheck(this, Demuxer);

    this.hls = hls;
    this.id = id;
    // observer setup
    var observer = this.observer = new _events4.default();
    var config = hls.config;
    observer.trigger = function trigger(event) {
      for (var _len = arguments.length, data = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        data[_key - 1] = arguments[_key];
      }

      observer.emit.apply(observer, [event, event].concat(data));
    };

    observer.off = function off(event) {
      for (var _len2 = arguments.length, data = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        data[_key2 - 1] = arguments[_key2];
      }

      observer.removeListener.apply(observer, [event].concat(data));
    };

    var forwardMessage = function (ev, data) {
      data = data || {};
      data.frag = this.frag;
      data.id = this.id;
      hls.trigger(ev, data);
    }.bind(this);

    // forward events to main thread
    observer.on(_events2.default.FRAG_DECRYPTED, forwardMessage);
    observer.on(_events2.default.FRAG_PARSING_INIT_SEGMENT, forwardMessage);
    observer.on(_events2.default.FRAG_PARSING_DATA, forwardMessage);
    observer.on(_events2.default.FRAG_PARSED, forwardMessage);
    observer.on(_events2.default.ERROR, forwardMessage);
    observer.on(_events2.default.FRAG_PARSING_METADATA, forwardMessage);
    observer.on(_events2.default.FRAG_PARSING_USERDATA, forwardMessage);
    observer.on(_events2.default.INIT_PTS_FOUND, forwardMessage);

    var typeSupported = {
      mp4: MediaSource.isTypeSupported('video/mp4'),
      mpeg: MediaSource.isTypeSupported('audio/mpeg'),
      mp3: MediaSource.isTypeSupported('audio/mp4; codecs="mp3"')
    };
    // navigator.vendor is not always available in Web Worker
    // refer to https://developer.mozilla.org/en-US/docs/Web/API/WorkerGlobalScope/navigator
    var vendor = navigator.vendor;
    if (config.enableWorker && typeof Worker !== 'undefined') {
      _logger.logger.log('demuxing in webworker');
      var w = void 0;
      try {
        var work = require('webworkify');
        w = this.w = work(_demuxerWorker2.default);
        this.onwmsg = this.onWorkerMessage.bind(this);
        w.addEventListener('message', this.onwmsg);
        w.onerror = function (event) {
          hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.OTHER_ERROR, details: _errors.ErrorDetails.INTERNAL_EXCEPTION, fatal: true, event: 'demuxerWorker', err: { message: event.message + ' (' + event.filename + ':' + event.lineno + ')' } });
        };
        w.postMessage({ cmd: 'init', typeSupported: typeSupported, vendor: vendor, id: id, config: JSON.stringify(config) });
      } catch (err) {
        _logger.logger.error('error while initializing DemuxerWorker, fallback on DemuxerInline');
        if (w) {
          // revoke the Object URL that was used to create demuxer worker, so as not to leak it
          URL.revokeObjectURL(w.objectURL);
        }
        this.demuxer = new _demuxerInline2.default(observer, typeSupported, config, vendor);
        this.w = undefined;
      }
    } else {
      this.demuxer = new _demuxerInline2.default(observer, typeSupported, config, vendor);
    }
  }

  _createClass(Demuxer, [{
    key: 'destroy',
    value: function destroy() {
      var w = this.w;
      if (w) {
        w.removeEventListener('message', this.onwmsg);
        w.terminate();
        this.w = null;
      } else {
        var demuxer = this.demuxer;
        if (demuxer) {
          demuxer.destroy();
          this.demuxer = null;
        }
      }
      var observer = this.observer;
      if (observer) {
        observer.removeAllListeners();
        this.observer = null;
      }
    }
  }, {
    key: 'push',
    value: function push(data, initSegment, audioCodec, videoCodec, frag, duration, accurateTimeOffset, defaultInitPTS) {
      var w = this.w;
      var timeOffset = !isNaN(frag.startDTS) ? frag.startDTS : frag.start;
      var decryptdata = frag.decryptdata;
      var lastFrag = this.frag;
      var discontinuity = !(lastFrag && frag.cc === lastFrag.cc);
      var trackSwitch = !(lastFrag && frag.level === lastFrag.level);
      var nextSN = lastFrag && frag.sn === lastFrag.sn + 1;
      var contiguous = !trackSwitch && nextSN;
      if (discontinuity) {
        _logger.logger.log(this.id + ':discontinuity detected');
      }
      if (trackSwitch) {
        _logger.logger.log(this.id + ':switch detected');
      }
      this.frag = frag;
      if (w) {
        // post fragment payload as transferable objects (no copy)
        w.postMessage({ cmd: 'demux', data: data, decryptdata: decryptdata, initSegment: initSegment, audioCodec: audioCodec, videoCodec: videoCodec, timeOffset: timeOffset, discontinuity: discontinuity, trackSwitch: trackSwitch, contiguous: contiguous, duration: duration, accurateTimeOffset: accurateTimeOffset, defaultInitPTS: defaultInitPTS }, [data]);
      } else {
        var demuxer = this.demuxer;
        if (demuxer) {
          demuxer.push(data, decryptdata, initSegment, audioCodec, videoCodec, timeOffset, discontinuity, trackSwitch, contiguous, duration, accurateTimeOffset, defaultInitPTS);
        }
      }
    }
  }, {
    key: 'onWorkerMessage',
    value: function onWorkerMessage(ev) {
      var data = ev.data,
          hls = this.hls;
      //console.log('onWorkerMessage:' + data.event);
      switch (data.event) {
        case 'init':
          // revoke the Object URL that was used to create demuxer worker, so as not to leak it
          URL.revokeObjectURL(this.w.objectURL);
          break;
        // special case for FRAG_PARSING_DATA: data1 and data2 are transferable objects
        case _events2.default.FRAG_PARSING_DATA:
          data.data.data1 = new Uint8Array(data.data1);
          if (data.data2) {
            data.data.data2 = new Uint8Array(data.data2);
          }
        /* falls through */
        default:
          data.data = data.data || {};
          data.data.frag = this.frag;
          data.data.id = this.id;
          hls.trigger(data.event, data.data);
          break;
      }
    }
  }]);

  return Demuxer;
}();

exports.default = Demuxer;

},{"../demux/demuxer-inline":22,"../demux/demuxer-worker":23,"../errors":30,"../events":32,"../utils/logger":51,"events":1,"webworkify":3}],25:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Parser for exponential Golomb codes, a variable-bitwidth number encoding scheme used by h264.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */

var _logger = require('../utils/logger');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ExpGolomb = function () {
  function ExpGolomb(data) {
    _classCallCheck(this, ExpGolomb);

    this.data = data;
    // the number of bytes left to examine in this.data
    this.bytesAvailable = data.byteLength;
    // the current word being examined
    this.word = 0; // :uint
    // the number of bits left to examine in the current word
    this.bitsAvailable = 0; // :uint
  }

  // ():void


  _createClass(ExpGolomb, [{
    key: 'loadWord',
    value: function loadWord() {
      var data = this.data,
          bytesAvailable = this.bytesAvailable,
          position = data.byteLength - bytesAvailable,
          workingBytes = new Uint8Array(4),
          availableBytes = Math.min(4, bytesAvailable);
      if (availableBytes === 0) {
        throw new Error('no bytes available');
      }
      workingBytes.set(data.subarray(position, position + availableBytes));
      this.word = new DataView(workingBytes.buffer).getUint32(0);
      // track the amount of this.data that has been processed
      this.bitsAvailable = availableBytes * 8;
      this.bytesAvailable -= availableBytes;
    }

    // (count:int):void

  }, {
    key: 'skipBits',
    value: function skipBits(count) {
      var skipBytes; // :int
      if (this.bitsAvailable > count) {
        this.word <<= count;
        this.bitsAvailable -= count;
      } else {
        count -= this.bitsAvailable;
        skipBytes = count >> 3;
        count -= skipBytes >> 3;
        this.bytesAvailable -= skipBytes;
        this.loadWord();
        this.word <<= count;
        this.bitsAvailable -= count;
      }
    }

    // (size:int):uint

  }, {
    key: 'readBits',
    value: function readBits(size) {
      var bits = Math.min(this.bitsAvailable, size),
          // :uint
      valu = this.word >>> 32 - bits; // :uint
      if (size > 32) {
        _logger.logger.error('Cannot read more than 32 bits at a time');
      }
      this.bitsAvailable -= bits;
      if (this.bitsAvailable > 0) {
        this.word <<= bits;
      } else if (this.bytesAvailable > 0) {
        this.loadWord();
      }
      bits = size - bits;
      if (bits > 0 && this.bitsAvailable) {
        return valu << bits | this.readBits(bits);
      } else {
        return valu;
      }
    }

    // ():uint

  }, {
    key: 'skipLZ',
    value: function skipLZ() {
      var leadingZeroCount; // :uint
      for (leadingZeroCount = 0; leadingZeroCount < this.bitsAvailable; ++leadingZeroCount) {
        if (0 !== (this.word & 0x80000000 >>> leadingZeroCount)) {
          // the first bit of working word is 1
          this.word <<= leadingZeroCount;
          this.bitsAvailable -= leadingZeroCount;
          return leadingZeroCount;
        }
      }
      // we exhausted word and still have not found a 1
      this.loadWord();
      return leadingZeroCount + this.skipLZ();
    }

    // ():void

  }, {
    key: 'skipUEG',
    value: function skipUEG() {
      this.skipBits(1 + this.skipLZ());
    }

    // ():void

  }, {
    key: 'skipEG',
    value: function skipEG() {
      this.skipBits(1 + this.skipLZ());
    }

    // ():uint

  }, {
    key: 'readUEG',
    value: function readUEG() {
      var clz = this.skipLZ(); // :uint
      return this.readBits(clz + 1) - 1;
    }

    // ():int

  }, {
    key: 'readEG',
    value: function readEG() {
      var valu = this.readUEG(); // :int
      if (0x01 & valu) {
        // the number is odd if the low order bit is set
        return 1 + valu >>> 1; // add 1 to make it even, and divide by 2
      } else {
        return -1 * (valu >>> 1); // divide by two then make it negative
      }
    }

    // Some convenience functions
    // :Boolean

  }, {
    key: 'readBoolean',
    value: function readBoolean() {
      return 1 === this.readBits(1);
    }

    // ():int

  }, {
    key: 'readUByte',
    value: function readUByte() {
      return this.readBits(8);
    }

    // ():int

  }, {
    key: 'readUShort',
    value: function readUShort() {
      return this.readBits(16);
    }
    // ():int

  }, {
    key: 'readUInt',
    value: function readUInt() {
      return this.readBits(32);
    }

    /**
     * Advance the ExpGolomb decoder past a scaling list. The scaling
     * list is optionally transmitted as part of a sequence parameter
     * set and is not relevant to transmuxing.
     * @param count {number} the number of entries in this scaling list
     * @see Recommendation ITU-T H.264, Section 7.3.2.1.1.1
     */

  }, {
    key: 'skipScalingList',
    value: function skipScalingList(count) {
      var lastScale = 8,
          nextScale = 8,
          j,
          deltaScale;
      for (j = 0; j < count; j++) {
        if (nextScale !== 0) {
          deltaScale = this.readEG();
          nextScale = (lastScale + deltaScale + 256) % 256;
        }
        lastScale = nextScale === 0 ? lastScale : nextScale;
      }
    }

    /**
     * Read a sequence parameter set and return some interesting video
     * properties. A sequence parameter set is the H264 metadata that
     * describes the properties of upcoming video frames.
     * @param data {Uint8Array} the bytes of a sequence parameter set
     * @return {object} an object with configuration parsed from the
     * sequence parameter set, including the dimensions of the
     * associated video frames.
     */

  }, {
    key: 'readSPS',
    value: function readSPS() {
      var frameCropLeftOffset = 0,
          frameCropRightOffset = 0,
          frameCropTopOffset = 0,
          frameCropBottomOffset = 0,
          profileIdc,
          profileCompat,
          levelIdc,
          numRefFramesInPicOrderCntCycle,
          picWidthInMbsMinus1,
          picHeightInMapUnitsMinus1,
          frameMbsOnlyFlag,
          scalingListCount,
          i,
          readUByte = this.readUByte.bind(this),
          readBits = this.readBits.bind(this),
          readUEG = this.readUEG.bind(this),
          readBoolean = this.readBoolean.bind(this),
          skipBits = this.skipBits.bind(this),
          skipEG = this.skipEG.bind(this),
          skipUEG = this.skipUEG.bind(this),
          skipScalingList = this.skipScalingList.bind(this);

      readUByte();
      profileIdc = readUByte(); // profile_idc
      profileCompat = readBits(5); // constraint_set[0-4]_flag, u(5)
      skipBits(3); // reserved_zero_3bits u(3),
      levelIdc = readUByte(); //level_idc u(8)
      skipUEG(); // seq_parameter_set_id
      // some profiles have more optional data we don't need
      if (profileIdc === 100 || profileIdc === 110 || profileIdc === 122 || profileIdc === 244 || profileIdc === 44 || profileIdc === 83 || profileIdc === 86 || profileIdc === 118 || profileIdc === 128) {
        var chromaFormatIdc = readUEG();
        if (chromaFormatIdc === 3) {
          skipBits(1); // separate_colour_plane_flag
        }
        skipUEG(); // bit_depth_luma_minus8
        skipUEG(); // bit_depth_chroma_minus8
        skipBits(1); // qpprime_y_zero_transform_bypass_flag
        if (readBoolean()) {
          // seq_scaling_matrix_present_flag
          scalingListCount = chromaFormatIdc !== 3 ? 8 : 12;
          for (i = 0; i < scalingListCount; i++) {
            if (readBoolean()) {
              // seq_scaling_list_present_flag[ i ]
              if (i < 6) {
                skipScalingList(16);
              } else {
                skipScalingList(64);
              }
            }
          }
        }
      }
      skipUEG(); // log2_max_frame_num_minus4
      var picOrderCntType = readUEG();
      if (picOrderCntType === 0) {
        readUEG(); //log2_max_pic_order_cnt_lsb_minus4
      } else if (picOrderCntType === 1) {
        skipBits(1); // delta_pic_order_always_zero_flag
        skipEG(); // offset_for_non_ref_pic
        skipEG(); // offset_for_top_to_bottom_field
        numRefFramesInPicOrderCntCycle = readUEG();
        for (i = 0; i < numRefFramesInPicOrderCntCycle; i++) {
          skipEG(); // offset_for_ref_frame[ i ]
        }
      }
      skipUEG(); // max_num_ref_frames
      skipBits(1); // gaps_in_frame_num_value_allowed_flag
      picWidthInMbsMinus1 = readUEG();
      picHeightInMapUnitsMinus1 = readUEG();
      frameMbsOnlyFlag = readBits(1);
      if (frameMbsOnlyFlag === 0) {
        skipBits(1); // mb_adaptive_frame_field_flag
      }
      skipBits(1); // direct_8x8_inference_flag
      if (readBoolean()) {
        // frame_cropping_flag
        frameCropLeftOffset = readUEG();
        frameCropRightOffset = readUEG();
        frameCropTopOffset = readUEG();
        frameCropBottomOffset = readUEG();
      }
      var pixelRatio = [1, 1];
      if (readBoolean()) {
        // vui_parameters_present_flag
        if (readBoolean()) {
          // aspect_ratio_info_present_flag
          var aspectRatioIdc = readUByte();
          switch (aspectRatioIdc) {
            case 1:
              pixelRatio = [1, 1];break;
            case 2:
              pixelRatio = [12, 11];break;
            case 3:
              pixelRatio = [10, 11];break;
            case 4:
              pixelRatio = [16, 11];break;
            case 5:
              pixelRatio = [40, 33];break;
            case 6:
              pixelRatio = [24, 11];break;
            case 7:
              pixelRatio = [20, 11];break;
            case 8:
              pixelRatio = [32, 11];break;
            case 9:
              pixelRatio = [80, 33];break;
            case 10:
              pixelRatio = [18, 11];break;
            case 11:
              pixelRatio = [15, 11];break;
            case 12:
              pixelRatio = [64, 33];break;
            case 13:
              pixelRatio = [160, 99];break;
            case 14:
              pixelRatio = [4, 3];break;
            case 15:
              pixelRatio = [3, 2];break;
            case 16:
              pixelRatio = [2, 1];break;
            case 255:
              {
                pixelRatio = [readUByte() << 8 | readUByte(), readUByte() << 8 | readUByte()];
                break;
              }
          }
        }
      }
      return {
        width: Math.ceil((picWidthInMbsMinus1 + 1) * 16 - frameCropLeftOffset * 2 - frameCropRightOffset * 2),
        height: (2 - frameMbsOnlyFlag) * (picHeightInMapUnitsMinus1 + 1) * 16 - (frameMbsOnlyFlag ? 2 : 4) * (frameCropTopOffset + frameCropBottomOffset),
        pixelRatio: pixelRatio
      };
    }
  }, {
    key: 'readSliceType',
    value: function readSliceType() {
      // skip NALu type
      this.readUByte();
      // discard first_mb_in_slice
      this.readUEG();
      // return slice_type
      return this.readUEG();
    }
  }]);

  return ExpGolomb;
}();

exports.default = ExpGolomb;

},{"../utils/logger":51}],26:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * ID3 parser
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */


var _logger = require('../utils/logger');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

//import Hex from '../utils/hex';

var ID3 = function () {
  function ID3(data) {
    _classCallCheck(this, ID3);

    this._hasTimeStamp = false;
    var offset = 0,
        byte1,
        byte2,
        byte3,
        byte4,
        tagSize,
        endPos,
        header,
        len;
    do {
      header = this.readUTF(data, offset, 3);
      offset += 3;
      // first check for ID3 header
      if (header === 'ID3') {
        // skip 24 bits
        offset += 3;
        // retrieve tag(s) length
        byte1 = data[offset++] & 0x7f;
        byte2 = data[offset++] & 0x7f;
        byte3 = data[offset++] & 0x7f;
        byte4 = data[offset++] & 0x7f;
        tagSize = (byte1 << 21) + (byte2 << 14) + (byte3 << 7) + byte4;
        endPos = offset + tagSize;
        //logger.log(`ID3 tag found, size/end: ${tagSize}/${endPos}`);

        // read ID3 tags
        this._parseID3Frames(data, offset, endPos);
        offset = endPos;
      } else if (header === '3DI') {
        // http://id3.org/id3v2.4.0-structure chapter 3.4.   ID3v2 footer
        offset += 7;
        _logger.logger.log('3DI footer found, end: ' + offset);
      } else {
        offset -= 3;
        len = offset;
        if (len) {
          //logger.log(`ID3 len: ${len}`);
          if (!this.hasTimeStamp) {
            _logger.logger.warn('ID3 tag found, but no timestamp');
          }
          this._length = len;
          this._payload = data.subarray(0, len);
        }
        return;
      }
    } while (true);
  }

  _createClass(ID3, [{
    key: 'readUTF',
    value: function readUTF(data, start, len) {

      var result = '',
          offset = start,
          end = start + len;
      do {
        result += String.fromCharCode(data[offset++]);
      } while (offset < end);
      return result;
    }
  }, {
    key: '_parseID3Frames',
    value: function _parseID3Frames(data, offset, endPos) {
      var tagId, tagLen, tagStart, tagFlags, timestamp;
      while (offset + 8 <= endPos) {
        tagId = this.readUTF(data, offset, 4);
        offset += 4;

        tagLen = data[offset++] << 24 + data[offset++] << 16 + data[offset++] << 8 + data[offset++];

        tagFlags = data[offset++] << 8 + data[offset++];

        tagStart = offset;
        //logger.log("ID3 tag id:" + tagId);
        switch (tagId) {
          case 'PRIV':
            //logger.log('parse frame:' + Hex.hexDump(data.subarray(offset,endPos)));
            // owner should be "com.apple.streaming.transportStreamTimestamp"
            if (this.readUTF(data, offset, 44) === 'com.apple.streaming.transportStreamTimestamp') {
              offset += 44;
              // smelling even better ! we found the right descriptor
              // skip null character (string end) + 3 first bytes
              offset += 4;

              // timestamp is 33 bit expressed as a big-endian eight-octet number, with the upper 31 bits set to zero.
              var pts33Bit = data[offset++] & 0x1;
              this._hasTimeStamp = true;

              timestamp = ((data[offset++] << 23) + (data[offset++] << 15) + (data[offset++] << 7) + data[offset++]) / 45;

              if (pts33Bit) {
                timestamp += 47721858.84; // 2^32 / 90
              }
              timestamp = Math.round(timestamp);
              _logger.logger.trace('ID3 timestamp found: ' + timestamp);
              this._timeStamp = timestamp;
            }
            break;
          default:
            break;
        }
      }
    }
  }, {
    key: 'hasTimeStamp',
    get: function get() {
      return this._hasTimeStamp;
    }
  }, {
    key: 'timeStamp',
    get: function get() {
      return this._timeStamp;
    }
  }, {
    key: 'length',
    get: function get() {
      return this._length;
    }
  }, {
    key: 'payload',
    get: function get() {
      return this._payload;
    }
  }]);

  return ID3;
}();

exports.default = ID3;

},{"../utils/logger":51}],27:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * MP4 demuxer
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */
//import {logger} from '../utils/logger';


var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var MP4Demuxer = function () {
  function MP4Demuxer(observer, remuxer) {
    _classCallCheck(this, MP4Demuxer);

    this.observer = observer;
    this.remuxer = remuxer;
  }

  _createClass(MP4Demuxer, [{
    key: 'resetTimeStamp',
    value: function resetTimeStamp() {}
  }, {
    key: 'resetInitSegment',
    value: function resetInitSegment(initSegment, audioCodec, videoCodec, duration) {
      //jshint unused:false
      var initData = this.initData = MP4Demuxer.parseInitSegment(initSegment);
      var tracks = {};
      if (initData.audio) {
        tracks.audio = { container: 'audio/mp4', codec: audioCodec, initSegment: initSegment };
      }
      if (initData.video) {
        tracks.video = { container: 'video/mp4', codec: videoCodec, initSegment: initSegment };
      }
      this.observer.trigger(_events2.default.FRAG_PARSING_INIT_SEGMENT, { tracks: tracks });
    }
  }, {
    key: 'append',


    // feed incoming data to the front of the parsing pipeline
    value: function append(data, timeOffset, contiguous, accurateTimeOffset) {
      var initData = this.initData;
      var startDTS = MP4Demuxer.startDTS(initData, data);
      this.remuxer.remux(initData.audio, initData.video, null, null, startDTS, contiguous, accurateTimeOffset, data);
    }
  }, {
    key: 'destroy',
    value: function destroy() {}
  }], [{
    key: 'probe',
    value: function probe(data) {
      if (data.length >= 8) {
        var dataType = MP4Demuxer.bin2str(data.subarray(4, 8));
        return ['moof', 'ftyp', 'styp'].indexOf(dataType) >= 0;
      }
      return false;
    }
  }, {
    key: 'bin2str',
    value: function bin2str(buffer) {
      return String.fromCharCode.apply(null, buffer);
    }

    // Find the data for a box specified by its path

  }, {
    key: 'findBox',
    value: function findBox(data, path) {
      var results = [],
          i,
          size,
          type,
          end,
          subresults;

      if (!path.length) {
        // short-circuit the search for empty paths
        return null;
      }

      for (i = 0; i < data.byteLength;) {
        size = data[i] << 24;
        size |= data[i + 1] << 16;
        size |= data[i + 2] << 8;
        size |= data[i + 3];

        type = MP4Demuxer.bin2str(data.subarray(i + 4, i + 8));

        end = size > 1 ? i + size : data.byteLength;

        if (type === path[0]) {
          if (path.length === 1) {
            // this is the end of the path and we've found the box we were
            // looking for
            results.push(data.subarray(i + 8, end));
          } else {
            // recursively search for the next box along the path
            subresults = MP4Demuxer.findBox(data.subarray(i + 8, end), path.slice(1));
            if (subresults.length) {
              results = results.concat(subresults);
            }
          }
        }
        i = end;
      }

      // we've finished searching all of data
      return results;
    }

    /**
     * Parses an MP4 initialization segment and extracts stream type and
     * timescale values for any declared tracks. Timescale values indicate the
     * number of clock ticks per second to assume for time-based values
     * elsewhere in the MP4.
     *
     * To determine the start time of an MP4, you need two pieces of
     * information: the timescale unit and the earliest base media decode
     * time. Multiple timescales can be specified within an MP4 but the
     * base media decode time is always expressed in the timescale from
     * the media header box for the track:
     * ```
     * moov > trak > mdia > mdhd.timescale
     * moov > trak > mdia > hdlr
     * ```
     * @param init {Uint8Array} the bytes of the init segment
     * @return {object} a hash of track type to timescale values or null if
     * the init segment is malformed.
     */

  }, {
    key: 'parseInitSegment',
    value: function parseInitSegment(initSegment) {
      var result = [];
      var traks = MP4Demuxer.findBox(initSegment, ['moov', 'trak']);

      traks.forEach(function (trak) {
        var tkhd = MP4Demuxer.findBox(trak, ['tkhd'])[0];
        if (tkhd) {
          var version = tkhd[0];
          var index = version === 0 ? 12 : 20;
          var trackId = tkhd[index] << 24 | tkhd[index + 1] << 16 | tkhd[index + 2] << 8 | tkhd[index + 3];

          trackId = trackId < 0 ? 4294967296 + trackId : trackId;

          var mdhd = MP4Demuxer.findBox(trak, ['mdia', 'mdhd'])[0];
          if (mdhd) {
            version = mdhd[0];
            index = version === 0 ? 12 : 20;
            var timescale = mdhd[index] << 24 | mdhd[index + 1] << 16 | mdhd[index + 2] << 8 | mdhd[index + 3];

            var hdlr = MP4Demuxer.findBox(trak, ['mdia', 'hdlr'])[0];
            if (hdlr) {
              var hdlrType = MP4Demuxer.bin2str(hdlr.subarray(8, 12));
              var type = { 'soun': 'audio', 'vide': 'video' }[hdlrType];
              if (type) {
                result[trackId] = { timescale: timescale, type: type };
                result[type] = { timescale: timescale, id: trackId };
              }
            }
          }
        }
      });
      return result;
    }

    /**
     * Determine the base media decode start time, in seconds, for an MP4
     * fragment. If multiple fragments are specified, the earliest time is
     * returned.
     *
     * The base media decode time can be parsed from track fragment
     * metadata:
     * ```
     * moof > traf > tfdt.baseMediaDecodeTime
     * ```
     * It requires the timescale value from the mdhd to interpret.
     *
     * @param timescale {object} a hash of track ids to timescale values.
     * @return {number} the earliest base media decode start time for the
     * fragment, in seconds
     */

  }, {
    key: 'startDTS',
    value: function startDTS(initData, fragment) {
      var trafs, baseTimes, result;

      // we need info from two childrend of each track fragment box
      trafs = MP4Demuxer.findBox(fragment, ['moof', 'traf']);

      // determine the start times for each track
      baseTimes = [].concat.apply([], trafs.map(function (traf) {
        return MP4Demuxer.findBox(traf, ['tfhd']).map(function (tfhd) {
          var id, scale, baseTime;

          // get the track id from the tfhd
          id = tfhd[4] << 24 | tfhd[5] << 16 | tfhd[6] << 8 | tfhd[7];
          // assume a 90kHz clock if no timescale was specified
          scale = initData[id].timescale || 90e3;

          // get the base media decode time from the tfdt
          baseTime = MP4Demuxer.findBox(traf, ['tfdt']).map(function (tfdt) {
            var version, result;

            version = tfdt[0];
            result = tfdt[4] << 24 | tfdt[5] << 16 | tfdt[6] << 8 | tfdt[7];
            if (version === 1) {
              result *= Math.pow(2, 32);
              result += tfdt[8] << 24 | tfdt[9] << 16 | tfdt[10] << 8 | tfdt[11];
            }
            return result;
          })[0];
          baseTime = baseTime || Infinity;

          // convert base time to seconds
          return baseTime / scale;
        });
      }));

      // return the minimum
      result = Math.min.apply(null, baseTimes);
      return isFinite(result) ? result : 0;
    }
  }]);

  return MP4Demuxer;
}();

exports.default = MP4Demuxer;

},{"../events":32}],28:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * SAMPLE-AES decrypter
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */

var _decrypter = require('../crypt/decrypter');

var _decrypter2 = _interopRequireDefault(_decrypter);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var SampleAesDecrypter = function () {
  function SampleAesDecrypter(observer, config, decryptdata, discardEPB) {
    _classCallCheck(this, SampleAesDecrypter);

    this.decryptdata = decryptdata;
    this.discardEPB = discardEPB;
    this.decrypter = new _decrypter2.default(observer, config);
  }

  _createClass(SampleAesDecrypter, [{
    key: 'decryptBuffer',
    value: function decryptBuffer(encryptedData, callback) {
      this.decrypter.decrypt(encryptedData, this.decryptdata.key.buffer, this.decryptdata.iv.buffer, callback);
    }

    // AAC - encrypt all full 16 bytes blocks starting from offset 16

  }, {
    key: 'decryptAacSample',
    value: function decryptAacSample(samples, sampleIndex, callback, sync) {
      var curUnit = samples[sampleIndex].unit;
      var encryptedData = curUnit.subarray(16, curUnit.length - curUnit.length % 16);
      var encryptedBuffer = encryptedData.buffer.slice(encryptedData.byteOffset, encryptedData.byteOffset + encryptedData.length);

      var localthis = this;
      this.decryptBuffer(encryptedBuffer, function (decryptedData) {
        decryptedData = new Uint8Array(decryptedData);
        curUnit.set(decryptedData, 16);

        if (!sync) {
          localthis.decryptAacSamples(samples, sampleIndex + 1, callback);
        }
      });
    }
  }, {
    key: 'decryptAacSamples',
    value: function decryptAacSamples(samples, sampleIndex, callback) {
      for (;; sampleIndex++) {
        if (sampleIndex >= samples.length) {
          callback();
          return;
        }

        if (samples[sampleIndex].unit.length < 32) {
          continue;
        }

        var sync = this.decrypter.isSync();

        this.decryptAacSample(samples, sampleIndex, callback, sync);

        if (!sync) {
          return;
        }
      }
    }

    // AVC - encrypt one 16 bytes block out of ten, starting from offset 32

  }, {
    key: 'getAvcEncryptedData',
    value: function getAvcEncryptedData(decodedData) {
      var encryptedDataLen = Math.floor((decodedData.length - 48) / 160) * 16 + 16;
      var encryptedData = new Int8Array(encryptedDataLen);
      var outputPos = 0;
      for (var inputPos = 32; inputPos <= decodedData.length - 16; inputPos += 160, outputPos += 16) {
        encryptedData.set(decodedData.subarray(inputPos, inputPos + 16), outputPos);
      }
      return encryptedData;
    }
  }, {
    key: 'getAvcDecryptedUnit',
    value: function getAvcDecryptedUnit(decodedData, decryptedData) {
      decryptedData = new Uint8Array(decryptedData);
      var inputPos = 0;
      for (var outputPos = 32; outputPos <= decodedData.length - 16; outputPos += 160, inputPos += 16) {
        decodedData.set(decryptedData.subarray(inputPos, inputPos + 16), outputPos);
      }
      return decodedData;
    }
  }, {
    key: 'decryptAvcSample',
    value: function decryptAvcSample(samples, sampleIndex, unitIndex, callback, curUnit, sync) {
      var decodedData = this.discardEPB(curUnit.data);
      var encryptedData = this.getAvcEncryptedData(decodedData);
      var localthis = this;

      this.decryptBuffer(encryptedData.buffer, function (decryptedData) {
        curUnit.data = localthis.getAvcDecryptedUnit(decodedData, decryptedData);

        if (!sync) {
          localthis.decryptAvcSamples(samples, sampleIndex, unitIndex + 1, callback);
        }
      });
    }
  }, {
    key: 'decryptAvcSamples',
    value: function decryptAvcSamples(samples, sampleIndex, unitIndex, callback) {
      for (;; sampleIndex++, unitIndex = 0) {
        if (sampleIndex >= samples.length) {
          callback();
          return;
        }

        var curUnits = samples[sampleIndex].units;
        for (;; unitIndex++) {
          if (unitIndex >= curUnits.length) {
            break;
          }

          var curUnit = curUnits[unitIndex];
          if (curUnit.length <= 48 || curUnit.type !== 1 && curUnit.type !== 5) {
            continue;
          }

          var sync = this.decrypter.isSync();

          this.decryptAvcSample(samples, sampleIndex, unitIndex, callback, curUnit, sync);

          if (!sync) {
            return;
          }
        }
      }
    }
  }]);

  return SampleAesDecrypter;
}();

exports.default = SampleAesDecrypter;

},{"../crypt/decrypter":18}],29:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * highly optimized TS demuxer:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * parse PAT, PMT
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * extract PES packet from audio and video PIDs
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * extract AVC/H264 NAL units and AAC/ADTS samples from PES packet
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * trigger the remuxer upon parsing completion
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * it also tries to workaround as best as it can audio codec switch (HE-AAC to AAC and vice versa), without having to restart the MediaSource.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * it also controls the remuxing process :
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * upon discontinuity or level switch detection, it will also notifies the remuxer so that it can reset its state.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */

// import Hex from '../utils/hex';


var _adts = require('./adts');

var _adts2 = _interopRequireDefault(_adts);

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _expGolomb = require('./exp-golomb');

var _expGolomb2 = _interopRequireDefault(_expGolomb);

var _sampleAes = require('./sample-aes');

var _sampleAes2 = _interopRequireDefault(_sampleAes);

var _logger = require('../utils/logger');

var _errors = require('../errors');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var TSDemuxer = function () {
  function TSDemuxer(observer, remuxer, config, typeSupported) {
    _classCallCheck(this, TSDemuxer);

    this.observer = observer;
    this.config = config;
    this.typeSupported = typeSupported;
    this.remuxer = remuxer;
    this.sampleAes = null;
  }

  _createClass(TSDemuxer, [{
    key: 'setDecryptData',
    value: function setDecryptData(decryptdata) {
      if (decryptdata != null && decryptdata.key != null && decryptdata.method === 'SAMPLE-AES') {
        this.sampleAes = new _sampleAes2.default(this.observer, this.config, decryptdata, this.discardEPB);
      } else {
        this.sampleAes = null;
      }
    }
  }, {
    key: 'resetInitSegment',
    value: function resetInitSegment(initSegment, audioCodec, videoCodec, duration) {
      this.pmtParsed = false;
      this._pmtId = -1;
      this._avcTrack = { container: 'video/mp2t', type: 'video', id: -1, inputTimeScale: 90000, sequenceNumber: 0, samples: [], len: 0, dropped: 0 };
      this._audioTrack = { container: 'video/mp2t', type: 'audio', id: -1, inputTimeScale: 90000, sequenceNumber: 0, samples: [], len: 0, isAAC: true };
      this._id3Track = { type: 'id3', id: -1, inputTimeScale: 90000, sequenceNumber: 0, samples: [], len: 0 };
      this._txtTrack = { type: 'text', id: -1, inputTimeScale: 90000, sequenceNumber: 0, samples: [], len: 0 };
      // flush any partial content
      this.aacOverFlow = null;
      this.aacLastPTS = null;
      this.avcSample = null;
      this.audioCodec = audioCodec;
      this.videoCodec = videoCodec;
      this._duration = duration;
    }
  }, {
    key: 'resetTimeStamp',
    value: function resetTimeStamp() {}

    // feed incoming data to the front of the parsing pipeline

  }, {
    key: 'append',
    value: function append(data, timeOffset, contiguous, accurateTimeOffset) {
      var start,
          len = data.length,
          stt,
          pid,
          atf,
          offset,
          pes,
          unknownPIDs = false;
      this.contiguous = contiguous;
      var pmtParsed = this.pmtParsed,
          avcTrack = this._avcTrack,
          audioTrack = this._audioTrack,
          id3Track = this._id3Track,
          avcId = avcTrack.id,
          audioId = audioTrack.id,
          id3Id = id3Track.id,
          pmtId = this._pmtId,
          avcData = avcTrack.pesData,
          audioData = audioTrack.pesData,
          id3Data = id3Track.pesData,
          parsePAT = this._parsePAT,
          parsePMT = this._parsePMT,
          parsePES = this._parsePES,
          parseAVCPES = this._parseAVCPES.bind(this),
          parseAACPES = this._parseAACPES.bind(this),
          parseMPEGPES = this._parseMPEGPES.bind(this),
          parseID3PES = this._parseID3PES.bind(this);

      // don't parse last TS packet if incomplete
      len -= len % 188;
      // loop through TS packets
      for (start = 0; start < len; start += 188) {
        if (data[start] === 0x47) {
          stt = !!(data[start + 1] & 0x40);
          // pid is a 13-bit field starting at the last bit of TS[1]
          pid = ((data[start + 1] & 0x1f) << 8) + data[start + 2];
          atf = (data[start + 3] & 0x30) >> 4;
          // if an adaption field is present, its length is specified by the fifth byte of the TS packet header.
          if (atf > 1) {
            offset = start + 5 + data[start + 4];
            // continue if there is only adaptation field
            if (offset === start + 188) {
              continue;
            }
          } else {
            offset = start + 4;
          }
          switch (pid) {
            case avcId:
              if (stt) {
                if (avcData && (pes = parsePES(avcData))) {
                  parseAVCPES(pes, false);
                }
                avcData = { data: [], size: 0 };
              }
              if (avcData) {
                avcData.data.push(data.subarray(offset, start + 188));
                avcData.size += start + 188 - offset;
              }
              break;
            case audioId:
              if (stt) {
                if (audioData && (pes = parsePES(audioData))) {
                  if (audioTrack.isAAC) {
                    parseAACPES(pes);
                  } else {
                    parseMPEGPES(pes);
                  }
                }
                audioData = { data: [], size: 0 };
              }
              if (audioData) {
                audioData.data.push(data.subarray(offset, start + 188));
                audioData.size += start + 188 - offset;
              }
              break;
            case id3Id:
              if (stt) {
                if (id3Data && (pes = parsePES(id3Data))) {
                  parseID3PES(pes);
                }
                id3Data = { data: [], size: 0 };
              }
              if (id3Data) {
                id3Data.data.push(data.subarray(offset, start + 188));
                id3Data.size += start + 188 - offset;
              }
              break;
            case 0:
              if (stt) {
                offset += data[offset] + 1;
              }
              pmtId = this._pmtId = parsePAT(data, offset);
              break;
            case pmtId:
              if (stt) {
                offset += data[offset] + 1;
              }
              var parsedPIDs = parsePMT(data, offset, this.typeSupported.mpeg === true || this.typeSupported.mp3 === true, this.sampleAes != null);

              // only update track id if track PID found while parsing PMT
              // this is to avoid resetting the PID to -1 in case
              // track PID transiently disappears from the stream
              // this could happen in case of transient missing audio samples for example
              avcId = parsedPIDs.avc;
              if (avcId > 0) {
                avcTrack.id = avcId;
              }
              audioId = parsedPIDs.audio;
              if (audioId > 0) {
                audioTrack.id = audioId;
                audioTrack.isAAC = parsedPIDs.isAAC;
              }
              id3Id = parsedPIDs.id3;
              if (id3Id > 0) {
                id3Track.id = id3Id;
              }
              if (unknownPIDs && !pmtParsed) {
                _logger.logger.log('reparse from beginning');
                unknownPIDs = false;
                // we set it to -188, the += 188 in the for loop will reset start to 0
                start = -188;
              }
              pmtParsed = this.pmtParsed = true;
              break;
            case 17:
            case 0x1fff:
              break;
            default:
              unknownPIDs = true;
              break;
          }
        } else {
          this.observer.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.FRAG_PARSING_ERROR, fatal: false, reason: 'TS packet did not start with 0x47' });
        }
      }
      // try to parse last PES packets
      if (avcData && (pes = parsePES(avcData))) {
        parseAVCPES(pes, true);
        avcTrack.pesData = null;
      } else {
        // either avcData null or PES truncated, keep it for next frag parsing
        avcTrack.pesData = avcData;
      }

      if (audioData && (pes = parsePES(audioData))) {
        if (audioTrack.isAAC) {
          parseAACPES(pes);
        } else {
          parseMPEGPES(pes);
        }
        audioTrack.pesData = null;
      } else {
        if (audioData && audioData.size) {
          _logger.logger.log('last AAC PES packet truncated,might overlap between fragments');
        }
        // either audioData null or PES truncated, keep it for next frag parsing
        audioTrack.pesData = audioData;
      }

      if (id3Data && (pes = parsePES(id3Data))) {
        parseID3PES(pes);
        id3Track.pesData = null;
      } else {
        // either id3Data null or PES truncated, keep it for next frag parsing
        id3Track.pesData = id3Data;
      }

      if (this.sampleAes == null) {
        this.remuxer.remux(audioTrack, avcTrack, id3Track, this._txtTrack, timeOffset, contiguous, accurateTimeOffset);
      } else {
        this.decryptAndRemux(audioTrack, avcTrack, id3Track, this._txtTrack, timeOffset, contiguous, accurateTimeOffset);
      }
    }
  }, {
    key: 'decryptAndRemux',
    value: function decryptAndRemux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset) {
      var _this = this;

      if (audioTrack.samples && audioTrack.isAAC) {
        (function () {
          var localthis = _this;
          _this.sampleAes.decryptAacSamples(audioTrack.samples, 0, function () {
            localthis.decryptAndRemuxAvc(audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset);
          });
        })();
      } else {
        this.decryptAndRemuxAvc(audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset);
      }
    }
  }, {
    key: 'decryptAndRemuxAvc',
    value: function decryptAndRemuxAvc(audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset) {
      var _this2 = this;

      if (videoTrack.samples) {
        (function () {
          var localthis = _this2;
          _this2.sampleAes.decryptAvcSamples(videoTrack.samples, 0, 0, function () {
            localthis.remuxer.remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset);
          });
        })();
      } else {
        this.remuxer.remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset);
      }
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      this._initPTS = this._initDTS = undefined;
      this._duration = 0;
    }
  }, {
    key: '_parsePAT',
    value: function _parsePAT(data, offset) {
      // skip the PSI header and parse the first PMT entry
      return (data[offset + 10] & 0x1F) << 8 | data[offset + 11];
      //logger.log('PMT PID:'  + this._pmtId);
    }
  }, {
    key: '_parsePMT',
    value: function _parsePMT(data, offset, mpegSupported, isSampleAes) {
      var sectionLength,
          tableEnd,
          programInfoLength,
          pid,
          result = { audio: -1, avc: -1, id3: -1, isAAC: true };
      sectionLength = (data[offset + 1] & 0x0f) << 8 | data[offset + 2];
      tableEnd = offset + 3 + sectionLength - 4;
      // to determine where the table is, we have to figure out how
      // long the program info descriptors are
      programInfoLength = (data[offset + 10] & 0x0f) << 8 | data[offset + 11];
      // advance the offset to the first entry in the mapping table
      offset += 12 + programInfoLength;
      while (offset < tableEnd) {
        pid = (data[offset + 1] & 0x1F) << 8 | data[offset + 2];
        switch (data[offset]) {
          case 0xcf:
            // SAMPLE-AES AAC
            if (!isSampleAes) {
              _logger.logger.log('unkown stream type:' + data[offset]);
              break;
            }
          /* falls through */

          // ISO/IEC 13818-7 ADTS AAC (MPEG-2 lower bit-rate audio)
          case 0x0f:
            //logger.log('AAC PID:'  + pid);
            if (result.audio === -1) {
              result.audio = pid;
            }
            break;

          // Packetized metadata (ID3)
          case 0x15:
            //logger.log('ID3 PID:'  + pid);
            if (result.id3 === -1) {
              result.id3 = pid;
            }
            break;

          case 0xdb:
            // SAMPLE-AES AVC
            if (!isSampleAes) {
              _logger.logger.log('unkown stream type:' + data[offset]);
              break;
            }
          /* falls through */

          // ITU-T Rec. H.264 and ISO/IEC 14496-10 (lower bit-rate video)
          case 0x1b:
            //logger.log('AVC PID:'  + pid);
            if (result.avc === -1) {
              result.avc = pid;
            }
            break;

          // ISO/IEC 11172-3 (MPEG-1 audio)
          // or ISO/IEC 13818-3 (MPEG-2 halved sample rate audio)
          case 0x03:
          case 0x04:
            //logger.log('MPEG PID:'  + pid);
            if (!mpegSupported) {
              _logger.logger.log('MPEG audio found, not supported in this browser for now');
            } else if (result.audio === -1) {
              result.audio = pid;
              result.isAAC = false;
            }
            break;

          case 0x24:
            _logger.logger.warn('HEVC stream type found, not supported for now');
            break;

          default:
            _logger.logger.log('unkown stream type:' + data[offset]);
            break;
        }
        // move to the next table entry
        // skip past the elementary stream descriptors, if present
        offset += ((data[offset + 3] & 0x0F) << 8 | data[offset + 4]) + 5;
      }
      return result;
    }
  }, {
    key: '_parsePES',
    value: function _parsePES(stream) {
      var i = 0,
          frag,
          pesFlags,
          pesPrefix,
          pesLen,
          pesHdrLen,
          pesData,
          pesPts,
          pesDts,
          payloadStartOffset,
          data = stream.data;
      // safety check
      if (!stream || stream.size === 0) {
        return null;
      }

      // we might need up to 19 bytes to read PES header
      // if first chunk of data is less than 19 bytes, let's merge it with following ones until we get 19 bytes
      // usually only one merge is needed (and this is rare ...)
      while (data[0].length < 19 && data.length > 1) {
        var newData = new Uint8Array(data[0].length + data[1].length);
        newData.set(data[0]);
        newData.set(data[1], data[0].length);
        data[0] = newData;
        data.splice(1, 1);
      }
      //retrieve PTS/DTS from first fragment
      frag = data[0];
      pesPrefix = (frag[0] << 16) + (frag[1] << 8) + frag[2];
      if (pesPrefix === 1) {
        pesLen = (frag[4] << 8) + frag[5];
        // if PES parsed length is not zero and greater than total received length, stop parsing. PES might be truncated
        // minus 6 : PES header size
        if (pesLen && pesLen > stream.size - 6) {
          return null;
        }
        pesFlags = frag[7];
        if (pesFlags & 0xC0) {
          /* PES header described here : http://dvd.sourceforge.net/dvdinfo/pes-hdr.html
              as PTS / DTS is 33 bit we cannot use bitwise operator in JS,
              as Bitwise operators treat their operands as a sequence of 32 bits */
          pesPts = (frag[9] & 0x0E) * 536870912 + // 1 << 29
          (frag[10] & 0xFF) * 4194304 + // 1 << 22
          (frag[11] & 0xFE) * 16384 + // 1 << 14
          (frag[12] & 0xFF) * 128 + // 1 << 7
          (frag[13] & 0xFE) / 2;
          // check if greater than 2^32 -1
          if (pesPts > 4294967295) {
            // decrement 2^33
            pesPts -= 8589934592;
          }
          if (pesFlags & 0x40) {
            pesDts = (frag[14] & 0x0E) * 536870912 + // 1 << 29
            (frag[15] & 0xFF) * 4194304 + // 1 << 22
            (frag[16] & 0xFE) * 16384 + // 1 << 14
            (frag[17] & 0xFF) * 128 + // 1 << 7
            (frag[18] & 0xFE) / 2;
            // check if greater than 2^32 -1
            if (pesDts > 4294967295) {
              // decrement 2^33
              pesDts -= 8589934592;
            }
            if (pesPts - pesDts > 60 * 90000) {
              _logger.logger.warn(Math.round((pesPts - pesDts) / 90000) + 's delta between PTS and DTS, align them');
              pesPts = pesDts;
            }
          } else {
            pesDts = pesPts;
          }
        }
        pesHdrLen = frag[8];
        // 9 bytes : 6 bytes for PES header + 3 bytes for PES extension
        payloadStartOffset = pesHdrLen + 9;

        stream.size -= payloadStartOffset;
        //reassemble PES packet
        pesData = new Uint8Array(stream.size);
        for (var j = 0, dataLen = data.length; j < dataLen; j++) {
          frag = data[j];
          var len = frag.byteLength;
          if (payloadStartOffset) {
            if (payloadStartOffset > len) {
              // trim full frag if PES header bigger than frag
              payloadStartOffset -= len;
              continue;
            } else {
              // trim partial frag if PES header smaller than frag
              frag = frag.subarray(payloadStartOffset);
              len -= payloadStartOffset;
              payloadStartOffset = 0;
            }
          }
          pesData.set(frag, i);
          i += len;
        }
        if (pesLen) {
          // payload size : remove PES header + PES extension
          pesLen -= pesHdrLen + 3;
        }
        return { data: pesData, pts: pesPts, dts: pesDts, len: pesLen };
      } else {
        return null;
      }
    }
  }, {
    key: 'pushAccesUnit',
    value: function pushAccesUnit(avcSample, avcTrack) {
      if (avcSample.units.length && avcSample.frame) {
        var samples = avcTrack.samples;
        var nbSamples = samples.length;
        // only push AVC sample if starting with a keyframe is not mandatory OR
        //    if keyframe already found in this fragment OR
        //       keyframe found in last fragment (track.sps) AND
        //          samples already appended (we already found a keyframe in this fragment) OR fragment is contiguous
        if (!this.config.forceKeyFrameOnDiscontinuity || avcSample.key === true || avcTrack.sps && (nbSamples || this.contiguous)) {
          avcSample.id = nbSamples;
          samples.push(avcSample);
        } else {
          // dropped samples, track it
          avcTrack.dropped++;
        }
      }
      if (avcSample.debug.length) {
        _logger.logger.log(avcSample.pts + '/' + avcSample.dts + ':' + avcSample.debug);
      }
    }
  }, {
    key: '_parseAVCPES',
    value: function _parseAVCPES(pes, last) {
      var _this3 = this;

      //logger.log('parse new PES');
      var track = this._avcTrack,
          units = this._parseAVCNALu(pes.data),
          debug = false,
          expGolombDecoder,
          avcSample = this.avcSample,
          push,
          i;
      //free pes.data to save up some memory
      pes.data = null;

      units.forEach(function (unit) {
        switch (unit.type) {
          //NDR
          case 1:
            push = true;
            if (debug && avcSample) {
              avcSample.debug += 'NDR ';
            }
            avcSample.frame = true;
            // retrieve slice type by parsing beginning of NAL unit (follow H264 spec, slice_header definition) to detect keyframe embedded in NDR
            var data = unit.data;
            if (data.length > 4) {
              var sliceType = new _expGolomb2.default(data).readSliceType();
              // 2 : I slice, 4 : SI slice, 7 : I slice, 9: SI slice
              // SI slice : A slice that is coded using intra prediction only and using quantisation of the prediction samples.
              // An SI slice can be coded such that its decoded samples can be constructed identically to an SP slice.
              // I slice: A slice that is not an SI slice that is decoded using intra prediction only.
              //if (sliceType === 2 || sliceType === 7) {
              if (sliceType === 2 || sliceType === 4 || sliceType === 7 || sliceType === 9) {
                avcSample.key = true;
              }
            }
            break;
          //IDR
          case 5:
            push = true;
            // handle PES not starting with AUD
            if (!avcSample) {
              avcSample = _this3.avcSample = _this3._createAVCSample(true, pes.pts, pes.dts, '');
            }
            if (debug) {
              avcSample.debug += 'IDR ';
            }
            avcSample.key = true;
            avcSample.frame = true;
            break;
          //SEI
          case 6:
            push = true;
            if (debug && avcSample) {
              avcSample.debug += 'SEI ';
            }
            expGolombDecoder = new _expGolomb2.default(_this3.discardEPB(unit.data));

            // skip frameType
            expGolombDecoder.readUByte();

            var payloadType = 0;
            var payloadSize = 0;
            var endOfCaptions = false;
            var b = 0;

            while (!endOfCaptions && expGolombDecoder.bytesAvailable > 1) {
              payloadType = 0;
              do {
                b = expGolombDecoder.readUByte();
                payloadType += b;
              } while (b === 0xFF);

              // Parse payload size.
              payloadSize = 0;
              do {
                b = expGolombDecoder.readUByte();
                payloadSize += b;
              } while (b === 0xFF);

              // TODO: there can be more than one payload in an SEI packet...
              // TODO: need to read type and size in a while loop to get them all
              if (payloadType === 4 && expGolombDecoder.bytesAvailable !== 0) {

                endOfCaptions = true;

                var countryCode = expGolombDecoder.readUByte();

                if (countryCode === 181) {
                  var providerCode = expGolombDecoder.readUShort();

                  if (providerCode === 49) {
                    var userStructure = expGolombDecoder.readUInt();

                    if (userStructure === 0x47413934) {
                      var userDataType = expGolombDecoder.readUByte();

                      // Raw CEA-608 bytes wrapped in CEA-708 packet
                      if (userDataType === 3) {
                        var firstByte = expGolombDecoder.readUByte();
                        var secondByte = expGolombDecoder.readUByte();

                        var totalCCs = 31 & firstByte;
                        var byteArray = [firstByte, secondByte];

                        for (i = 0; i < totalCCs; i++) {
                          // 3 bytes per CC
                          byteArray.push(expGolombDecoder.readUByte());
                          byteArray.push(expGolombDecoder.readUByte());
                          byteArray.push(expGolombDecoder.readUByte());
                        }

                        _this3._insertSampleInOrder(_this3._txtTrack.samples, { type: 3, pts: pes.pts, bytes: byteArray });
                      }
                    }
                  }
                }
              } else if (payloadSize < expGolombDecoder.bytesAvailable) {
                for (i = 0; i < payloadSize; i++) {
                  expGolombDecoder.readUByte();
                }
              }
            }
            break;
          //SPS
          case 7:
            push = true;
            if (debug && avcSample) {
              avcSample.debug += 'SPS ';
            }
            if (!track.sps) {
              expGolombDecoder = new _expGolomb2.default(unit.data);
              var config = expGolombDecoder.readSPS();
              track.width = config.width;
              track.height = config.height;
              track.pixelRatio = config.pixelRatio;
              track.sps = [unit.data];
              track.duration = _this3._duration;
              var codecarray = unit.data.subarray(1, 4);
              var codecstring = 'avc1.';
              for (i = 0; i < 3; i++) {
                var h = codecarray[i].toString(16);
                if (h.length < 2) {
                  h = '0' + h;
                }
                codecstring += h;
              }
              track.codec = codecstring;
            }
            break;
          //PPS
          case 8:
            push = true;
            if (debug && avcSample) {
              avcSample.debug += 'PPS ';
            }
            if (!track.pps) {
              track.pps = [unit.data];
            }
            break;
          // AUD
          case 9:
            push = false;
            if (avcSample) {
              _this3.pushAccesUnit(avcSample, track);
            }
            avcSample = _this3.avcSample = _this3._createAVCSample(false, pes.pts, pes.dts, debug ? 'AUD ' : '');
            break;
          // Filler Data
          case 12:
            push = false;
            break;
          default:
            push = false;
            if (avcSample) {
              avcSample.debug += 'unknown NAL ' + unit.type + ' ';
            }
            break;
        }
        if (avcSample && push) {
          var _units = avcSample.units;
          _units.push(unit);
        }
      });
      // if last PES packet, push samples
      if (last && avcSample) {
        this.pushAccesUnit(avcSample, track);
        this.avcSample = null;
      }
    }
  }, {
    key: '_createAVCSample',
    value: function _createAVCSample(key, pts, dts, debug) {
      return { key: key, pts: pts, dts: dts, units: [], debug: debug };
    }
  }, {
    key: '_insertSampleInOrder',
    value: function _insertSampleInOrder(arr, data) {
      var len = arr.length;
      if (len > 0) {
        if (data.pts >= arr[len - 1].pts) {
          arr.push(data);
        } else {
          for (var pos = len - 1; pos >= 0; pos--) {
            if (data.pts < arr[pos].pts) {
              arr.splice(pos, 0, data);
              break;
            }
          }
        }
      } else {
        arr.push(data);
      }
    }
  }, {
    key: '_getLastNalUnit',
    value: function _getLastNalUnit() {
      var avcSample = this.avcSample,
          lastUnit = void 0;
      // try to fallback to previous sample if current one is empty
      if (!avcSample || avcSample.units.length === 0) {
        var track = this._avcTrack,
            samples = track.samples;
        avcSample = samples[samples.length - 1];
      }
      if (avcSample) {
        var units = avcSample.units;
        lastUnit = units[units.length - 1];
      }
      return lastUnit;
    }
  }, {
    key: '_parseAVCNALu',
    value: function _parseAVCNALu(array) {
      var i = 0,
          len = array.byteLength,
          value,
          overflow,
          track = this._avcTrack,
          state = track.naluState || 0,
          lastState = state;
      var units = [],
          unit,
          unitType,
          lastUnitStart = -1,
          lastUnitType;
      //logger.log('PES:' + Hex.hexDump(array));

      if (state === -1) {
        // special use case where we found 3 or 4-byte start codes exactly at the end of previous PES packet
        lastUnitStart = 0;
        // NALu type is value read from offset 0
        lastUnitType = array[0] & 0x1f;
        state = 0;
        i = 1;
      }

      while (i < len) {
        value = array[i++];
        // optimization. state 0 and 1 are the predominant case. let's handle them outside of the switch/case
        if (!state) {
          state = value ? 0 : 1;
          continue;
        }
        if (state === 1) {
          state = value ? 0 : 2;
          continue;
        }
        // here we have state either equal to 2 or 3
        if (!value) {
          state = 3;
        } else if (value === 1) {
          if (lastUnitStart >= 0) {
            unit = { data: array.subarray(lastUnitStart, i - state - 1), type: lastUnitType };
            //logger.log('pushing NALU, type/size:' + unit.type + '/' + unit.data.byteLength);
            units.push(unit);
          } else {
            // lastUnitStart is undefined => this is the first start code found in this PES packet
            // first check if start code delimiter is overlapping between 2 PES packets,
            // ie it started in last packet (lastState not zero)
            // and ended at the beginning of this PES packet (i <= 4 - lastState)
            var lastUnit = this._getLastNalUnit();
            if (lastUnit) {
              if (lastState && i <= 4 - lastState) {
                // start delimiter overlapping between PES packets
                // strip start delimiter bytes from the end of last NAL unit
                // check if lastUnit had a state different from zero
                if (lastUnit.state) {
                  // strip last bytes
                  lastUnit.data = lastUnit.data.subarray(0, lastUnit.data.byteLength - lastState);
                }
              }
              // If NAL units are not starting right at the beginning of the PES packet, push preceding data into previous NAL unit.
              overflow = i - state - 1;
              if (overflow > 0) {
                //logger.log('first NALU found with overflow:' + overflow);
                var tmp = new Uint8Array(lastUnit.data.byteLength + overflow);
                tmp.set(lastUnit.data, 0);
                tmp.set(array.subarray(0, overflow), lastUnit.data.byteLength);
                lastUnit.data = tmp;
              }
            }
          }
          // check if we can read unit type
          if (i < len) {
            unitType = array[i] & 0x1f;
            //logger.log('find NALU @ offset:' + i + ',type:' + unitType);
            lastUnitStart = i;
            lastUnitType = unitType;
            state = 0;
          } else {
            // not enough byte to read unit type. let's read it on next PES parsing
            state = -1;
          }
        } else {
          state = 0;
        }
      }
      if (lastUnitStart >= 0 && state >= 0) {
        unit = { data: array.subarray(lastUnitStart, len), type: lastUnitType, state: state };
        units.push(unit);
        //logger.log('pushing NALU, type/size/state:' + unit.type + '/' + unit.data.byteLength + '/' + state);
      }
      // no NALu found
      if (units.length === 0) {
        // append pes.data to previous NAL unit
        var _lastUnit = this._getLastNalUnit();
        if (_lastUnit) {
          var _tmp = new Uint8Array(_lastUnit.data.byteLength + array.byteLength);
          _tmp.set(_lastUnit.data, 0);
          _tmp.set(array, _lastUnit.data.byteLength);
          _lastUnit.data = _tmp;
        }
      }
      track.naluState = state;
      return units;
    }

    /**
     * remove Emulation Prevention bytes from a RBSP
     */

  }, {
    key: 'discardEPB',
    value: function discardEPB(data) {
      var length = data.byteLength,
          EPBPositions = [],
          i = 1,
          newLength,
          newData;

      // Find all `Emulation Prevention Bytes`
      while (i < length - 2) {
        if (data[i] === 0 && data[i + 1] === 0 && data[i + 2] === 0x03) {
          EPBPositions.push(i + 2);
          i += 2;
        } else {
          i++;
        }
      }

      // If no Emulation Prevention Bytes were found just return the original
      // array
      if (EPBPositions.length === 0) {
        return data;
      }

      // Create a new array to hold the NAL unit data
      newLength = length - EPBPositions.length;
      newData = new Uint8Array(newLength);
      var sourceIndex = 0;

      for (i = 0; i < newLength; sourceIndex++, i++) {
        if (sourceIndex === EPBPositions[0]) {
          // Skip this byte
          sourceIndex++;
          // Remove this position index
          EPBPositions.shift();
        }
        newData[i] = data[sourceIndex];
      }
      return newData;
    }
  }, {
    key: '_parseAACPES',
    value: function _parseAACPES(pes) {
      var track = this._audioTrack,
          data = pes.data,
          pts = pes.pts,
          startOffset = 0,
          aacOverFlow = this.aacOverFlow,
          aacLastPTS = this.aacLastPTS,
          config,
          frameLength,
          frameDuration,
          frameIndex,
          offset,
          headerLength,
          stamp,
          len,
          aacSample;
      if (aacOverFlow) {
        var tmp = new Uint8Array(aacOverFlow.byteLength + data.byteLength);
        tmp.set(aacOverFlow, 0);
        tmp.set(data, aacOverFlow.byteLength);
        //logger.log(`AAC: append overflowing ${aacOverFlow.byteLength} bytes to beginning of new PES`);
        data = tmp;
      }
      // look for ADTS header (0xFFFx)
      for (offset = startOffset, len = data.length; offset < len - 1; offset++) {
        if (data[offset] === 0xff && (data[offset + 1] & 0xf0) === 0xf0) {
          break;
        }
      }
      // if ADTS header does not start straight from the beginning of the PES payload, raise an error
      if (offset) {
        var reason, fatal;
        if (offset < len - 1) {
          reason = 'AAC PES did not start with ADTS header,offset:' + offset;
          fatal = false;
        } else {
          reason = 'no ADTS header found in AAC PES';
          fatal = true;
        }
        _logger.logger.warn('parsing error:' + reason);
        this.observer.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.FRAG_PARSING_ERROR, fatal: fatal, reason: reason });
        if (fatal) {
          return;
        }
      }
      if (!track.samplerate) {
        var audioCodec = this.audioCodec;
        config = _adts2.default.getAudioConfig(this.observer, data, offset, audioCodec);
        track.config = config.config;
        track.samplerate = config.samplerate;
        track.channelCount = config.channelCount;
        track.codec = config.codec;
        track.manifestCodec = config.manifestCodec;
        track.duration = this._duration;
        _logger.logger.log('parsed codec:' + track.codec + ',rate:' + config.samplerate + ',nb channel:' + config.channelCount);
      }
      frameIndex = 0;
      frameDuration = 1024 * 90000 / track.samplerate;

      // if last AAC frame is overflowing, we should ensure timestamps are contiguous:
      // first sample PTS should be equal to last sample PTS + frameDuration
      if (aacOverFlow && aacLastPTS) {
        var newPTS = aacLastPTS + frameDuration;
        if (Math.abs(newPTS - pts) > 1) {
          _logger.logger.log('AAC: align PTS for overlapping frames by ' + Math.round((newPTS - pts) / 90));
          pts = newPTS;
        }
      }

      while (offset + 5 < len) {
        // The protection skip bit tells us if we have 2 bytes of CRC data at the end of the ADTS header
        headerLength = !!(data[offset + 1] & 0x01) ? 7 : 9;
        // retrieve frame size
        frameLength = (data[offset + 3] & 0x03) << 11 | data[offset + 4] << 3 | (data[offset + 5] & 0xE0) >>> 5;
        frameLength -= headerLength;
        //stamp = pes.pts;

        if (frameLength > 0 && offset + headerLength + frameLength <= len) {
          stamp = pts + frameIndex * frameDuration;
          //logger.log(`AAC frame, offset/length/total/pts:${offset+headerLength}/${frameLength}/${data.byteLength}/${(stamp/90).toFixed(0)}`);
          aacSample = { unit: data.subarray(offset + headerLength, offset + headerLength + frameLength), pts: stamp, dts: stamp };
          track.samples.push(aacSample);
          track.len += frameLength;
          offset += frameLength + headerLength;
          frameIndex++;
          // look for ADTS header (0xFFFx)
          for (; offset < len - 1; offset++) {
            if (data[offset] === 0xff && (data[offset + 1] & 0xf0) === 0xf0) {
              break;
            }
          }
        } else {
          break;
        }
      }
      if (offset < len) {
        aacOverFlow = data.subarray(offset, len);
        //logger.log(`AAC: overflow detected:${len-offset}`);
      } else {
        aacOverFlow = null;
      }
      this.aacOverFlow = aacOverFlow;
      this.aacLastPTS = stamp;
    }
  }, {
    key: '_parseMPEGPES',
    value: function _parseMPEGPES(pes) {
      var data = pes.data;
      var pts = pes.pts;
      var length = data.length;
      var frameIndex = 0;
      var offset = 0;
      var parsed;

      while (offset < length && (parsed = this._parseMpeg(data, offset, length, frameIndex++, pts)) > 0) {
        offset += parsed;
      }
    }
  }, {
    key: '_onMpegFrame',
    value: function _onMpegFrame(data, bitRate, sampleRate, channelCount, frameIndex, pts) {
      var frameDuration = 1152 / sampleRate * 1000;
      var stamp = pts + frameIndex * frameDuration;
      var track = this._audioTrack;

      track.config = [];
      track.channelCount = channelCount;
      track.samplerate = sampleRate;
      track.duration = this._duration;
      track.samples.push({ unit: data, pts: stamp, dts: stamp });
      track.len += data.length;
    }
  }, {
    key: '_onMpegNoise',
    value: function _onMpegNoise(data) {
      _logger.logger.warn('mpeg audio has noise: ' + data.length + ' bytes');
    }
  }, {
    key: '_parseMpeg',
    value: function _parseMpeg(data, start, end, frameIndex, pts) {
      var BitratesMap = [32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448, 32, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 32, 48, 56, 64, 80, 96, 112, 128, 144, 160, 176, 192, 224, 256, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160];
      var SamplingRateMap = [44100, 48000, 32000, 22050, 24000, 16000, 11025, 12000, 8000];

      if (start + 2 > end) {
        return -1; // we need at least 2 bytes to detect sync pattern
      }
      if (data[start] === 0xFF || (data[start + 1] & 0xE0) === 0xE0) {
        // Using http://www.datavoyage.com/mpgscript/mpeghdr.htm as a reference
        if (start + 24 > end) {
          return -1;
        }
        var headerB = data[start + 1] >> 3 & 3;
        var headerC = data[start + 1] >> 1 & 3;
        var headerE = data[start + 2] >> 4 & 15;
        var headerF = data[start + 2] >> 2 & 3;
        var headerG = !!(data[start + 2] & 2);
        if (headerB !== 1 && headerE !== 0 && headerE !== 15 && headerF !== 3) {
          var columnInBitrates = headerB === 3 ? 3 - headerC : headerC === 3 ? 3 : 4;
          var bitRate = BitratesMap[columnInBitrates * 14 + headerE - 1] * 1000;
          var columnInSampleRates = headerB === 3 ? 0 : headerB === 2 ? 1 : 2;
          var sampleRate = SamplingRateMap[columnInSampleRates * 3 + headerF];
          var padding = headerG ? 1 : 0;
          var channelCount = data[start + 3] >> 6 === 3 ? 1 : 2; // If bits of channel mode are `11` then it is a single channel (Mono)
          var frameLength = headerC === 3 ? (headerB === 3 ? 12 : 6) * bitRate / sampleRate + padding << 2 : (headerB === 3 ? 144 : 72) * bitRate / sampleRate + padding | 0;
          if (start + frameLength > end) {
            return -1;
          }
          if (this._onMpegFrame) {
            this._onMpegFrame(data.subarray(start, start + frameLength), bitRate, sampleRate, channelCount, frameIndex, pts);
          }
          return frameLength;
        }
      }
      // noise or ID3, trying to skip
      var offset = start + 2;
      while (offset < end) {
        if (data[offset - 1] === 0xFF && (data[offset] & 0xE0) === 0xE0) {
          // sync pattern is found
          if (this._onMpegNoise) {
            this._onMpegNoise(data.subarray(start, offset - 1));
          }
          return offset - start - 1;
        }
        offset++;
      }
      return -1;
    }
  }, {
    key: '_parseID3PES',
    value: function _parseID3PES(pes) {
      this._id3Track.samples.push(pes);
    }
  }], [{
    key: 'probe',
    value: function probe(data) {
      // a TS fragment should contain at least 3 TS packets, a PAT, a PMT, and one PID, each starting with 0x47
      if (data.length >= 3 * 188 && data[0] === 0x47 && data[188] === 0x47 && data[2 * 188] === 0x47) {
        return true;
      } else {
        return false;
      }
    }
  }]);

  return TSDemuxer;
}();

exports.default = TSDemuxer;

},{"../errors":30,"../events":32,"../utils/logger":51,"./adts":21,"./exp-golomb":25,"./sample-aes":28}],30:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
var ErrorTypes = exports.ErrorTypes = {
  // Identifier for a network error (loading error / timeout ...)
  NETWORK_ERROR: 'networkError',
  // Identifier for a media Error (video/parsing/mediasource error)
  MEDIA_ERROR: 'mediaError',
  // Identifier for a mux Error (demuxing/remuxing)
  MUX_ERROR: 'muxError',
  // Identifier for all other errors
  OTHER_ERROR: 'otherError'
};

var ErrorDetails = exports.ErrorDetails = {
  // Identifier for a manifest load error - data: { url : faulty URL, response : { code: error code, text: error text }}
  MANIFEST_LOAD_ERROR: 'manifestLoadError',
  // Identifier for a manifest load timeout - data: { url : faulty URL, response : { code: error code, text: error text }}
  MANIFEST_LOAD_TIMEOUT: 'manifestLoadTimeOut',
  // Identifier for a manifest parsing error - data: { url : faulty URL, reason : error reason}
  MANIFEST_PARSING_ERROR: 'manifestParsingError',
  // Identifier for a manifest with only incompatible codecs error - data: { url : faulty URL, reason : error reason}
  MANIFEST_INCOMPATIBLE_CODECS_ERROR: 'manifestIncompatibleCodecsError',
  //
  MANIFEST_EMPTY_ERROR: 'manifestEmptyError',
  // Identifier for a level load error - data: { url : faulty URL, response : { code: error code, text: error text }}
  LEVEL_LOAD_ERROR: 'levelLoadError',
  // Identifier for a level load timeout - data: { url : faulty URL, response : { code: error code, text: error text }}
  LEVEL_LOAD_TIMEOUT: 'levelLoadTimeOut',
  // Identifier for a level switch error - data: { level : faulty level Id, event : error description}
  LEVEL_SWITCH_ERROR: 'levelSwitchError',
  // Identifier for an audio track load error - data: { url : faulty URL, response : { code: error code, text: error text }}
  AUDIO_TRACK_LOAD_ERROR: 'audioTrackLoadError',
  // Identifier for an audio track load timeout - data: { url : faulty URL, response : { code: error code, text: error text }}
  AUDIO_TRACK_LOAD_TIMEOUT: 'audioTrackLoadTimeOut',
  // Identifier for fragment load error - data: { frag : fragment object, response : { code: error code, text: error text }}
  FRAG_LOAD_ERROR: 'fragLoadError',
  // Identifier for fragment loop loading error - data: { frag : fragment object}
  FRAG_LOOP_LOADING_ERROR: 'fragLoopLoadingError',
  // Identifier for fragment load timeout error - data: { frag : fragment object}
  FRAG_LOAD_TIMEOUT: 'fragLoadTimeOut',
  // Identifier for a fragment decryption error event - data: {id : demuxer Id,frag: fragment object, reason : parsing error description }
  FRAG_DECRYPT_ERROR: 'fragDecryptError',
  // Identifier for a fragment parsing error event - data: { id : demuxer Id, reason : parsing error description }
  // will be renamed DEMUX_PARSING_ERROR and switched to MUX_ERROR in the next major release
  FRAG_PARSING_ERROR: 'fragParsingError',
  // Identifier for a remux alloc error event - data: { id : demuxer Id, frag : fragment object, bytes : nb of bytes on which allocation failed , reason : error text }
  REMUX_ALLOC_ERROR: 'remuxAllocError',
  // Identifier for decrypt key load error - data: { frag : fragment object, response : { code: error code, text: error text }}
  KEY_LOAD_ERROR: 'keyLoadError',
  // Identifier for decrypt key load timeout error - data: { frag : fragment object}
  KEY_LOAD_TIMEOUT: 'keyLoadTimeOut',
  // Triggered when an exception occurs while adding a sourceBuffer to MediaSource - data : {  err : exception , mimeType : mimeType }
  BUFFER_ADD_CODEC_ERROR: 'bufferAddCodecError',
  // Identifier for a buffer append error - data: append error description
  BUFFER_APPEND_ERROR: 'bufferAppendError',
  // Identifier for a buffer appending error event - data: appending error description
  BUFFER_APPENDING_ERROR: 'bufferAppendingError',
  // Identifier for a buffer stalled error event
  BUFFER_STALLED_ERROR: 'bufferStalledError',
  // Identifier for a buffer full event
  BUFFER_FULL_ERROR: 'bufferFullError',
  // Identifier for a buffer seek over hole event
  BUFFER_SEEK_OVER_HOLE: 'bufferSeekOverHole',
  // Identifier for a buffer nudge on stall (playback is stuck although currentTime is in a buffered area)
  BUFFER_NUDGE_ON_STALL: 'bufferNudgeOnStall',
  // Identifier for an internal exception happening inside hls.js while handling an event
  INTERNAL_EXCEPTION: 'internalException',
  // Malformed WebVTT contents
  WEBVTT_EXCEPTION: 'webVTTException'
};

},{}],31:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     * All objects in the event handling chain should inherit from this class
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */

var _logger = require('./utils/logger');

var _errors = require('./errors');

var _events = require('./events');

var _events2 = _interopRequireDefault(_events);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var EventHandler = function () {
  function EventHandler(hls) {
    _classCallCheck(this, EventHandler);

    this.hls = hls;
    this.onEvent = this.onEvent.bind(this);

    for (var _len = arguments.length, events = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      events[_key - 1] = arguments[_key];
    }

    this.handledEvents = events;
    this.useGenericHandler = true;

    this.registerListeners();
  }

  _createClass(EventHandler, [{
    key: 'destroy',
    value: function destroy() {
      this.unregisterListeners();
    }
  }, {
    key: 'isEventHandler',
    value: function isEventHandler() {
      return _typeof(this.handledEvents) === 'object' && this.handledEvents.length && typeof this.onEvent === 'function';
    }
  }, {
    key: 'registerListeners',
    value: function registerListeners() {
      if (this.isEventHandler()) {
        this.handledEvents.forEach(function (event) {
          if (event === 'hlsEventGeneric') {
            throw new Error('Forbidden event name: ' + event);
          }
          this.hls.on(event, this.onEvent);
        }.bind(this));
      }
    }
  }, {
    key: 'unregisterListeners',
    value: function unregisterListeners() {
      if (this.isEventHandler()) {
        this.handledEvents.forEach(function (event) {
          this.hls.off(event, this.onEvent);
        }.bind(this));
      }
    }

    /**
     * arguments: event (string), data (any)
     */

  }, {
    key: 'onEvent',
    value: function onEvent(event, data) {
      this.onEventGeneric(event, data);
    }
  }, {
    key: 'onEventGeneric',
    value: function onEventGeneric(event, data) {
      var eventToFunction = function eventToFunction(event, data) {
        var funcName = 'on' + event.replace('hls', '');
        if (typeof this[funcName] !== 'function') {
          throw new Error('Event ' + event + ' has no generic handler in this ' + this.constructor.name + ' class (tried ' + funcName + ')');
        }
        return this[funcName].bind(this, data);
      };
      try {
        eventToFunction.call(this, event, data).call();
      } catch (err) {
        _logger.logger.error('internal error happened while processing ' + event + ':' + err.message);
        this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.OTHER_ERROR, details: _errors.ErrorDetails.INTERNAL_EXCEPTION, fatal: false, event: event, err: err });
      }
    }
  }]);

  return EventHandler;
}();

exports.default = EventHandler;

},{"./errors":30,"./events":32,"./utils/logger":51}],32:[function(require,module,exports){
'use strict';

module.exports = {
  // fired before MediaSource is attaching to media element - data: { media }
  MEDIA_ATTACHING: 'hlsMediaAttaching',
  // fired when MediaSource has been succesfully attached to media element - data: { }
  MEDIA_ATTACHED: 'hlsMediaAttached',
  // fired before detaching MediaSource from media element - data: { }
  MEDIA_DETACHING: 'hlsMediaDetaching',
  // fired when MediaSource has been detached from media element - data: { }
  MEDIA_DETACHED: 'hlsMediaDetached',
  // fired when we buffer is going to be resetted
  BUFFER_RESET: 'hlsBufferReset',
  // fired when we know about the codecs that we need buffers for to push into - data: {tracks : { container, codec, levelCodec, initSegment, metadata }}
  BUFFER_CODECS: 'hlsBufferCodecs',
  // fired when sourcebuffers have been created data: { tracks : tracks}
  BUFFER_CREATED: 'hlsBufferCreated',
  // fired when we append a segment to the buffer - data: { segment: segment object }
  BUFFER_APPENDING: 'hlsBufferAppending',
  // fired when we are done with appending a media segment to the buffer data : { parent : segment parent that triggered BUFFER_APPENDING , pending : nb of segments waiting for appending for this segment parent}
  BUFFER_APPENDED: 'hlsBufferAppended',
  // fired when the stream is finished and we want to notify the media buffer that there will be no more data
  BUFFER_EOS: 'hlsBufferEos',
  // fired when the media buffer should be flushed - data {startOffset, endOffset}
  BUFFER_FLUSHING: 'hlsBufferFlushing',
  // fired when the media has been flushed
  BUFFER_FLUSHED: 'hlsBufferFlushed',
  // fired to signal that a manifest loading starts - data: { url : manifestURL}
  MANIFEST_LOADING: 'hlsManifestLoading',
  // fired after manifest has been loaded - data: { levels : [available quality levels] , audioTracks : [ available audio tracks], url : manifestURL, stats : { trequest, tfirst, tload, mtime}}
  MANIFEST_LOADED: 'hlsManifestLoaded',
  // fired after manifest has been parsed - data: { levels : [available quality levels] , firstLevel : index of first quality level appearing in Manifest}
  MANIFEST_PARSED: 'hlsManifestParsed',
  // fired when a level switch is requested - data: { level : id of new level } // deprecated in favor LEVEL_SWITCHING
  LEVEL_SWITCH: 'hlsLevelSwitch',
  // fired when a level switch is requested - data: { level : id of new level }
  LEVEL_SWITCHING: 'hlsLevelSwitching',
  // fired when a level switch is effective - data: { level : id of new level }
  LEVEL_SWITCHED: 'hlsLevelSwitched',
  // fired when a level playlist loading starts - data: { url : level URL  level : id of level being loaded}
  LEVEL_LOADING: 'hlsLevelLoading',
  // fired when a level playlist loading finishes - data: { details : levelDetails object, level : id of loaded level, stats : { trequest, tfirst, tload, mtime} }
  LEVEL_LOADED: 'hlsLevelLoaded',
  // fired when a level's details have been updated based on previous details, after it has been loaded. - data: { details : levelDetails object, level : id of updated level }
  LEVEL_UPDATED: 'hlsLevelUpdated',
  // fired when a level's PTS information has been updated after parsing a fragment - data: { details : levelDetails object, level : id of updated level, drift: PTS drift observed when parsing last fragment }
  LEVEL_PTS_UPDATED: 'hlsLevelPtsUpdated',
  // fired to notify that audio track lists has been updated data: { audioTracks : audioTracks}
  LEVEL_REMOVED: 'hlsLevelRemoved',
  // fired when a level should no longer be used
  AUDIO_TRACKS_UPDATED: 'hlsAudioTracksUpdated',
  // fired when an audio track switch occurs - data: {  id : audio track id} // deprecated in favor AUDIO_TRACK_SWITCHING
  AUDIO_TRACK_SWITCH: 'hlsAudioTrackSwitch',
  // fired when an audio track switching is requested - data: {  id : audio track id}
  AUDIO_TRACK_SWITCHING: 'hlsAudioTrackSwitching',
  // fired when an audio track switch actually occurs - data: {  id : audio track id}
  AUDIO_TRACK_SWITCHED: 'hlsAudioTrackSwitched',
  // fired when an audio track loading starts - data: { url : audio track URL  id : audio track id}
  AUDIO_TRACK_LOADING: 'hlsAudioTrackLoading',
  // fired when an audio track loading  finishes - data: { details : levelDetails object, id : audio track id, stats : { trequest, tfirst, tload, mtime} }
  AUDIO_TRACK_LOADED: 'hlsAudioTrackLoaded',
  // fired to notify that subtitle track lists has been updated data: { subtitleTracks : subtitleTracks}
  SUBTITLE_TRACKS_UPDATED: 'hlsSubtitleTracksUpdated',
  // fired when an subtitle track switch occurs - data: {  id : subtitle track id}
  SUBTITLE_TRACK_SWITCH: 'hlsSubtitleTrackSwitch',
  // fired when an subtitle track loading starts - data: { url : subtitle track URL  id : subtitle track id}
  SUBTITLE_TRACK_LOADING: 'hlsSubtitleTrackLoading',
  // fired when an subtitle track loading  finishes - data: { details : levelDetails object, id : subtitle track id, stats : { trequest, tfirst, tload, mtime} }
  SUBTITLE_TRACK_LOADED: 'hlsSubtitleTrackLoaded',
  // fired when a subtitle fragment has been processed - data: { success : boolean, frag : the processed frag}
  SUBTITLE_FRAG_PROCESSED: 'hlsSubtitleFragProcessed',
  // fired when the first timestamp is found. - data: { id : demuxer id, initPTS: initPTS , frag : fragment object}
  INIT_PTS_FOUND: 'hlsInitPtsFound',
  // fired when a fragment loading starts - data: { frag : fragment object}
  FRAG_LOADING: 'hlsFragLoading',
  // fired when a fragment loading is progressing - data: { frag : fragment object, { trequest, tfirst, loaded}}
  FRAG_LOAD_PROGRESS: 'hlsFragLoadProgress',
  // Identifier for fragment load aborting for emergency switch down - data: {frag : fragment object}
  FRAG_LOAD_EMERGENCY_ABORTED: 'hlsFragLoadEmergencyAborted',
  // fired when a fragment loading is completed - data: { frag : fragment object, payload : fragment payload, stats : { trequest, tfirst, tload, length}}
  FRAG_LOADED: 'hlsFragLoaded',
  // fired when a fragment has started decrypting - data: { level : levelId, sn : sequence number }
  FRAG_DECRYPT_STARTED: 'hlsFragDecryptStarted',
  // fired when a fragment has finished decrypting - data: { id : demuxer id, frag: fragment object, stats : {tstart,tdecrypt} }
  FRAG_DECRYPTED: 'hlsFragDecrypted',
  // fired when Init Segment has been extracted from fragment - data: { id : demuxer id, frag: fragment object, moov : moov MP4 box, codecs : codecs found while parsing fragment}
  FRAG_PARSING_INIT_SEGMENT: 'hlsFragParsingInitSegment',
  // fired when parsing sei text is completed - data: { id : demuxer id, , frag: fragment object, samples : [ sei samples pes ] }
  FRAG_PARSING_USERDATA: 'hlsFragParsingUserdata',
  // fired when parsing id3 is completed - data: { id : demuxer id, frag: fragment object, samples : [ id3 samples pes ] }
  FRAG_PARSING_METADATA: 'hlsFragParsingMetadata',
  // fired when data have been extracted from fragment - data: { id : demuxer id, frag: fragment object, data1 : moof MP4 box or TS fragments, data2 : mdat MP4 box or null}
  FRAG_PARSING_DATA: 'hlsFragParsingData',
  // fired when fragment parsing is completed - data: { id : demuxer id,frag: fragment object }
  FRAG_PARSED: 'hlsFragParsed',
  // fired when fragment remuxed MP4 boxes have all been appended into SourceBuffer - data: { id : demuxer id,frag : fragment object, stats : { trequest, tfirst, tload, tparsed, tbuffered, length} }
  FRAG_BUFFERED: 'hlsFragBuffered',
  // fired when fragment matching with current media position is changing - data : { id : demuxer id, frag : fragment object }
  FRAG_CHANGED: 'hlsFragChanged',
  // Identifier for a FPS drop event - data: {curentDropped, currentDecoded, totalDroppedFrames}
  FPS_DROP: 'hlsFpsDrop',
  //triggered when FPS drop triggers auto level capping - data: {level, droppedlevel}
  FPS_DROP_LEVEL_CAPPING: 'hlsFpsDropLevelCapping',
  // Identifier for an error event - data: { type : error type, details : error details, fatal : if true, hls.js cannot/will not try to recover, if false, hls.js will try to recover,other error specific data}
  ERROR: 'hlsError',
  // fired when hls.js instance starts destroying. Different from MEDIA_DETACHED as one could want to detach and reattach a media to the instance of hls.js to handle mid-rolls for example
  DESTROYING: 'hlsDestroying',
  // fired when a decrypt key loading starts - data: { frag : fragment object}
  KEY_LOADING: 'hlsKeyLoading',
  // fired when a decrypt key loading is completed - data: { frag : fragment object, payload : key payload, stats : { trequest, tfirst, tload, length}}
  KEY_LOADED: 'hlsKeyLoaded',
  // fired upon stream controller state transitions - data: {previousState, nextState}
  STREAM_STATE_TRANSITION: 'hlsStreamStateTransition'
};

},{}],33:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 *  AAC helper
 */

var AAC = function () {
  function AAC() {
    _classCallCheck(this, AAC);
  }

  _createClass(AAC, null, [{
    key: 'getSilentFrame',
    value: function getSilentFrame(codec, channelCount) {
      switch (codec) {
        case 'mp4a.40.2':
          if (channelCount === 1) {
            return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x23, 0x80]);
          } else if (channelCount === 2) {
            return new Uint8Array([0x21, 0x00, 0x49, 0x90, 0x02, 0x19, 0x00, 0x23, 0x80]);
          } else if (channelCount === 3) {
            return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x8e]);
          } else if (channelCount === 4) {
            return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x80, 0x2c, 0x80, 0x08, 0x02, 0x38]);
          } else if (channelCount === 5) {
            return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x82, 0x30, 0x04, 0x99, 0x00, 0x21, 0x90, 0x02, 0x38]);
          } else if (channelCount === 6) {
            return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x82, 0x30, 0x04, 0x99, 0x00, 0x21, 0x90, 0x02, 0x00, 0xb2, 0x00, 0x20, 0x08, 0xe0]);
          }
          break;
        // handle HE-AAC below (mp4a.40.5 / mp4a.40.29)
        default:
          if (channelCount === 1) {
            // ffmpeg -y -f lavfi -i "aevalsrc=0:d=0.05" -c:a libfdk_aac -profile:a aac_he -b:a 4k output.aac && hexdump -v -e '16/1 "0x%x," "\n"' -v output.aac
            return new Uint8Array([0x1, 0x40, 0x22, 0x80, 0xa3, 0x4e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0, 0x0, 0x1c, 0x6, 0xf1, 0xc1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5e]);
          } else if (channelCount === 2) {
            // ffmpeg -y -f lavfi -i "aevalsrc=0|0:d=0.05" -c:a libfdk_aac -profile:a aac_he_v2 -b:a 4k output.aac && hexdump -v -e '16/1 "0x%x," "\n"' -v output.aac
            return new Uint8Array([0x1, 0x40, 0x22, 0x80, 0xa3, 0x5e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0, 0x0, 0x0, 0x95, 0x0, 0x6, 0xf1, 0xa1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5e]);
          } else if (channelCount === 3) {
            // ffmpeg -y -f lavfi -i "aevalsrc=0|0|0:d=0.05" -c:a libfdk_aac -profile:a aac_he_v2 -b:a 4k output.aac && hexdump -v -e '16/1 "0x%x," "\n"' -v output.aac
            return new Uint8Array([0x1, 0x40, 0x22, 0x80, 0xa3, 0x5e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0, 0x0, 0x0, 0x95, 0x0, 0x6, 0xf1, 0xa1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5e]);
          }
          break;
      }
      return null;
    }
  }]);

  return AAC;
}();

exports.default = AAC;

},{}],34:[function(require,module,exports){
"use strict";

/**
 * Buffer Helper utils, providing methods dealing buffer length retrieval
*/

var BufferHelper = {
  isBuffered: function isBuffered(media, position) {
    if (media) {
      var buffered = media.buffered;
      for (var i = 0; i < buffered.length; i++) {
        if (position >= buffered.start(i) && position <= buffered.end(i)) {
          return true;
        }
      }
    }
    return false;
  },

  bufferInfo: function bufferInfo(media, pos, maxHoleDuration) {
    if (media) {
      try {
        var vbuffered = media.buffered,
            buffered = [],
            i;
        for (i = 0; i < vbuffered.length; i++) {
          buffered.push({ start: vbuffered.start(i), end: vbuffered.end(i) });
        }
        return this.bufferedInfo(buffered, pos, maxHoleDuration);
      } catch (e) {
        return { len: 0, start: 0, end: 0, nextStart: undefined };
      }
    } else {
      return { len: 0, start: pos, end: pos, nextStart: undefined };
    }
  },

  bufferedInfo: function bufferedInfo(buffered, pos, maxHoleDuration) {
    var buffered2 = [],

    // bufferStart and bufferEnd are buffer boundaries around current video position
    bufferLen,
        bufferStart,
        bufferEnd,
        bufferStartNext,
        i;
    // sort on buffer.start/smaller end (IE does not always return sorted buffered range)
    buffered.sort(function (a, b) {
      var diff = a.start - b.start;
      if (diff) {
        return diff;
      } else {
        return b.end - a.end;
      }
    });
    // there might be some small holes between buffer time range
    // consider that holes smaller than maxHoleDuration are irrelevant and build another
    // buffer time range representations that discards those holes
    for (i = 0; i < buffered.length; i++) {
      var buf2len = buffered2.length;
      if (buf2len) {
        var buf2end = buffered2[buf2len - 1].end;
        // if small hole (value between 0 or maxHoleDuration ) or overlapping (negative)
        if (buffered[i].start - buf2end < maxHoleDuration) {
          // merge overlapping time ranges
          // update lastRange.end only if smaller than item.end
          // e.g.  [ 1, 15] with  [ 2,8] => [ 1,15] (no need to modify lastRange.end)
          // whereas [ 1, 8] with  [ 2,15] => [ 1,15] ( lastRange should switch from [1,8] to [1,15])
          if (buffered[i].end > buf2end) {
            buffered2[buf2len - 1].end = buffered[i].end;
          }
        } else {
          // big hole
          buffered2.push(buffered[i]);
        }
      } else {
        // first value
        buffered2.push(buffered[i]);
      }
    }
    for (i = 0, bufferLen = 0, bufferStart = bufferEnd = pos; i < buffered2.length; i++) {
      var start = buffered2[i].start,
          end = buffered2[i].end;
      //logger.log('buf start/end:' + buffered.start(i) + '/' + buffered.end(i));
      if (pos + maxHoleDuration >= start && pos < end) {
        // play position is inside this buffer TimeRange, retrieve end of buffer position and buffer length
        bufferStart = start;
        bufferEnd = end;
        bufferLen = bufferEnd - pos;
      } else if (pos + maxHoleDuration < start) {
        bufferStartNext = start;
        break;
      }
    }
    return { len: bufferLen, start: bufferStart || 0, end: bufferEnd || 0, nextStart: bufferStartNext };
  }
};

module.exports = BufferHelper;

},{}],35:[function(require,module,exports){
'use strict';

var _logger = require('../utils/logger');

var LevelHelper = {

  mergeDetails: function mergeDetails(oldDetails, newDetails) {
    var start = Math.max(oldDetails.startSN, newDetails.startSN) - newDetails.startSN,
        end = Math.min(oldDetails.endSN, newDetails.endSN) - newDetails.startSN,
        delta = newDetails.startSN - oldDetails.startSN,
        oldfragments = oldDetails.fragments,
        newfragments = newDetails.fragments,
        ccOffset = 0,
        PTSFrag;

    // check if old/new playlists have fragments in common
    if (end < start) {
      newDetails.PTSKnown = false;
      return;
    }
    // loop through overlapping SN and update startPTS , cc, and duration if any found
    for (var i = start; i <= end; i++) {
      var oldFrag = oldfragments[delta + i],
          newFrag = newfragments[i];
      if (newFrag && oldFrag) {
        ccOffset = oldFrag.cc - newFrag.cc;
        if (!isNaN(oldFrag.startPTS)) {
          newFrag.start = newFrag.startPTS = oldFrag.startPTS;
          newFrag.endPTS = oldFrag.endPTS;
          newFrag.duration = oldFrag.duration;
          PTSFrag = newFrag;
        }
      }
    }

    if (ccOffset) {
      _logger.logger.log('discontinuity sliding from playlist, take drift into account');
      for (i = 0; i < newfragments.length; i++) {
        newfragments[i].cc += ccOffset;
      }
    }

    // if at least one fragment contains PTS info, recompute PTS information for all fragments
    if (PTSFrag) {
      LevelHelper.updateFragPTSDTS(newDetails, PTSFrag.sn, PTSFrag.startPTS, PTSFrag.endPTS, PTSFrag.startDTS, PTSFrag.endDTS);
    } else {
      // ensure that delta is within oldfragments range
      // also adjust sliding in case delta is 0 (we could have old=[50-60] and new=old=[50-61])
      // in that case we also need to adjust start offset of all fragments
      if (delta >= 0 && delta < oldfragments.length) {
        // adjust start by sliding offset
        var sliding = oldfragments[delta].start;
        for (i = 0; i < newfragments.length; i++) {
          newfragments[i].start += sliding;
        }
      }
    }
    // if we are here, it means we have fragments overlapping between
    // old and new level. reliable PTS info is thus relying on old level
    newDetails.PTSKnown = oldDetails.PTSKnown;
    return;
  },

  updateFragPTSDTS: function updateFragPTSDTS(details, sn, startPTS, endPTS, startDTS, endDTS) {
    var fragIdx, fragments, frag, i;
    // exit if sn out of range
    if (!details || sn < details.startSN || sn > details.endSN) {
      return 0;
    }
    fragIdx = sn - details.startSN;
    fragments = details.fragments;
    frag = fragments[fragIdx];
    if (!isNaN(frag.startPTS)) {
      // delta PTS between audio and video
      var deltaPTS = Math.abs(frag.startPTS - startPTS);
      if (isNaN(frag.deltaPTS)) {
        frag.deltaPTS = deltaPTS;
      } else {
        frag.deltaPTS = Math.max(deltaPTS, frag.deltaPTS);
      }
      startPTS = Math.min(startPTS, frag.startPTS);
      endPTS = Math.max(endPTS, frag.endPTS);
      startDTS = Math.min(startDTS, frag.startDTS);
      endDTS = Math.max(endDTS, frag.endDTS);
    }

    var drift = startPTS - frag.start;

    frag.start = frag.startPTS = startPTS;
    frag.endPTS = endPTS;
    frag.startDTS = startDTS;
    frag.endDTS = endDTS;
    frag.duration = endPTS - startPTS;
    // adjust fragment PTS/duration from seqnum-1 to frag 0
    for (i = fragIdx; i > 0; i--) {
      LevelHelper.updatePTS(fragments, i, i - 1);
    }

    // adjust fragment PTS/duration from seqnum to last frag
    for (i = fragIdx; i < fragments.length - 1; i++) {
      LevelHelper.updatePTS(fragments, i, i + 1);
    }
    details.PTSKnown = true;
    //logger.log(`                                            frag start/end:${startPTS.toFixed(3)}/${endPTS.toFixed(3)}`);

    return drift;
  },

  updatePTS: function updatePTS(fragments, fromIdx, toIdx) {
    var fragFrom = fragments[fromIdx],
        fragTo = fragments[toIdx],
        fragToPTS = fragTo.startPTS;
    // if we know startPTS[toIdx]
    if (!isNaN(fragToPTS)) {
      // update fragment duration.
      // it helps to fix drifts between playlist reported duration and fragment real duration
      if (toIdx > fromIdx) {
        fragFrom.duration = fragToPTS - fragFrom.start;
        if (fragFrom.duration < 0) {
          _logger.logger.warn('negative duration computed for frag ' + fragFrom.sn + ',level ' + fragFrom.level + ', there should be some duration drift between playlist and fragment!');
        }
      } else {
        fragTo.duration = fragFrom.start - fragToPTS;
        if (fragTo.duration < 0) {
          _logger.logger.warn('negative duration computed for frag ' + fragTo.sn + ',level ' + fragTo.level + ', there should be some duration drift between playlist and fragment!');
        }
      }
    } else {
      // we dont know startPTS[toIdx]
      if (toIdx > fromIdx) {
        fragTo.start = fragFrom.start + fragFrom.duration;
      } else {
        fragTo.start = Math.max(fragFrom.start - fragTo.duration, 0);
      }
    }
  }
}; /**
    * Level Helper class, providing methods dealing with playlist sliding and drift
   */

module.exports = LevelHelper;

},{"../utils/logger":51}],36:[function(require,module,exports){
/**
 * HLS interface
 */
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _urlToolkit = require('url-toolkit');

var _urlToolkit2 = _interopRequireDefault(_urlToolkit);

var _events = require('./events');

var _events2 = _interopRequireDefault(_events);

var _errors = require('./errors');

var _playlistLoader = require('./loader/playlist-loader');

var _playlistLoader2 = _interopRequireDefault(_playlistLoader);

var _fragmentLoader = require('./loader/fragment-loader');

var _fragmentLoader2 = _interopRequireDefault(_fragmentLoader);

var _keyLoader = require('./loader/key-loader');

var _keyLoader2 = _interopRequireDefault(_keyLoader);

var _streamController = require('./controller/stream-controller');

var _streamController2 = _interopRequireDefault(_streamController);

var _levelController = require('./controller/level-controller');

var _levelController2 = _interopRequireDefault(_levelController);

var _logger = require('./utils/logger');

var _events3 = require('events');

var _events4 = _interopRequireDefault(_events3);

var _config = require('./config');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Hls = function () {
  _createClass(Hls, null, [{
    key: 'isSupported',
    value: function isSupported() {
      window.MediaSource = window.MediaSource || window.WebKitMediaSource;
      return window.MediaSource && typeof window.MediaSource.isTypeSupported === 'function' && window.MediaSource.isTypeSupported('video/mp4; codecs="avc1.42E01E,mp4a.40.2"');
    }
  }, {
    key: 'version',
    get: function get() {
      // replaced with browserify-versionify transform
      return '__VERSION__';
    }
  }, {
    key: 'Events',
    get: function get() {
      return _events2.default;
    }
  }, {
    key: 'ErrorTypes',
    get: function get() {
      return _errors.ErrorTypes;
    }
  }, {
    key: 'ErrorDetails',
    get: function get() {
      return _errors.ErrorDetails;
    }
  }, {
    key: 'DefaultConfig',
    get: function get() {
      if (!Hls.defaultConfig) {
        return _config.hlsDefaultConfig;
      }
      return Hls.defaultConfig;
    },
    set: function set(defaultConfig) {
      Hls.defaultConfig = defaultConfig;
    }
  }]);

  function Hls() {
    var _this = this;

    var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, Hls);

    var defaultConfig = Hls.DefaultConfig;

    if ((config.liveSyncDurationCount || config.liveMaxLatencyDurationCount) && (config.liveSyncDuration || config.liveMaxLatencyDuration)) {
      throw new Error('Illegal hls.js config: don\'t mix up liveSyncDurationCount/liveMaxLatencyDurationCount and liveSyncDuration/liveMaxLatencyDuration');
    }

    for (var prop in defaultConfig) {
      if (prop in config) {
        continue;
      }
      config[prop] = defaultConfig[prop];
    }

    if (config.liveMaxLatencyDurationCount !== undefined && config.liveMaxLatencyDurationCount <= config.liveSyncDurationCount) {
      throw new Error('Illegal hls.js config: "liveMaxLatencyDurationCount" must be gt "liveSyncDurationCount"');
    }

    if (config.liveMaxLatencyDuration !== undefined && (config.liveMaxLatencyDuration <= config.liveSyncDuration || config.liveSyncDuration === undefined)) {
      throw new Error('Illegal hls.js config: "liveMaxLatencyDuration" must be gt "liveSyncDuration"');
    }

    (0, _logger.enableLogs)(config.debug);
    this.config = config;
    this._autoLevelCapping = -1;
    // observer setup
    var observer = this.observer = new _events4.default();
    observer.trigger = function trigger(event) {
      for (var _len = arguments.length, data = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        data[_key - 1] = arguments[_key];
      }

      observer.emit.apply(observer, [event, event].concat(data));
    };

    observer.off = function off(event) {
      for (var _len2 = arguments.length, data = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        data[_key2 - 1] = arguments[_key2];
      }

      observer.removeListener.apply(observer, [event].concat(data));
    };
    this.on = observer.on.bind(observer);
    this.off = observer.off.bind(observer);
    this.trigger = observer.trigger.bind(observer);

    // core controllers and network loaders
    var abrController = this.abrController = new config.abrController(this);
    var bufferController = new config.bufferController(this);
    var capLevelController = new config.capLevelController(this);
    var fpsController = new config.fpsController(this);
    var playListLoader = new _playlistLoader2.default(this);
    var fragmentLoader = new _fragmentLoader2.default(this);
    var keyLoader = new _keyLoader2.default(this);

    // network controllers
    var levelController = this.levelController = new _levelController2.default(this);
    var streamController = this.streamController = new _streamController2.default(this);
    var networkControllers = [levelController, streamController];

    // optional audio stream controller
    var Controller = config.audioStreamController;
    if (Controller) {
      networkControllers.push(new Controller(this));
    }
    this.networkControllers = networkControllers;

    var coreComponents = [playListLoader, fragmentLoader, keyLoader, abrController, bufferController, capLevelController, fpsController];

    // optional audio track and subtitle controller
    Controller = config.audioTrackController;
    if (Controller) {
      var audioTrackController = new Controller(this);
      this.audioTrackController = audioTrackController;
      coreComponents.push(audioTrackController);
    }

    Controller = config.subtitleTrackController;
    if (Controller) {
      var subtitleTrackController = new Controller(this);
      this.subtitleTrackController = subtitleTrackController;
      coreComponents.push(subtitleTrackController);
    }

    // optional subtitle controller
    [config.subtitleStreamController, config.timelineController].forEach(function (Controller) {
      if (Controller) {
        coreComponents.push(new Controller(_this));
      }
    });
    this.coreComponents = coreComponents;
  }

  _createClass(Hls, [{
    key: 'destroy',
    value: function destroy() {
      _logger.logger.log('destroy');
      this.trigger(_events2.default.DESTROYING);
      this.detachMedia();
      this.coreComponents.concat(this.networkControllers).forEach(function (component) {
        component.destroy();
      });
      this.url = null;
      this.observer.removeAllListeners();
      this._autoLevelCapping = -1;
    }
  }, {
    key: 'attachMedia',
    value: function attachMedia(media) {
      _logger.logger.log('attachMedia');
      this.media = media;
      this.trigger(_events2.default.MEDIA_ATTACHING, { media: media });
    }
  }, {
    key: 'detachMedia',
    value: function detachMedia() {
      _logger.logger.log('detachMedia');
      this.trigger(_events2.default.MEDIA_DETACHING);
      this.media = null;
    }
  }, {
    key: 'loadSource',
    value: function loadSource(url) {
      url = _urlToolkit2.default.buildAbsoluteURL(window.location.href, url, { alwaysNormalize: true });
      _logger.logger.log('loadSource:' + url);
      this.url = url;
      // when attaching to a source URL, trigger a playlist load
      this.trigger(_events2.default.MANIFEST_LOADING, { url: url });
    }
  }, {
    key: 'startLoad',
    value: function startLoad() {
      var startPosition = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : -1;

      _logger.logger.log('startLoad(' + startPosition + ')');
      this.networkControllers.forEach(function (controller) {
        controller.startLoad(startPosition);
      });
    }
  }, {
    key: 'stopLoad',
    value: function stopLoad() {
      _logger.logger.log('stopLoad');
      this.networkControllers.forEach(function (controller) {
        controller.stopLoad();
      });
    }
  }, {
    key: 'swapAudioCodec',
    value: function swapAudioCodec() {
      _logger.logger.log('swapAudioCodec');
      this.streamController.swapAudioCodec();
    }
  }, {
    key: 'recoverMediaError',
    value: function recoverMediaError() {
      _logger.logger.log('recoverMediaError');
      var media = this.media;
      this.detachMedia();
      this.attachMedia(media);
    }

    /** Return all quality levels **/

  }, {
    key: 'levels',
    get: function get() {
      return this.levelController.levels;
    }

    /** Return current playback quality level **/

  }, {
    key: 'currentLevel',
    get: function get() {
      return this.streamController.currentLevel;
    }

    /* set quality level immediately (-1 for automatic level selection) */
    ,
    set: function set(newLevel) {
      _logger.logger.log('set currentLevel:' + newLevel);
      this.loadLevel = newLevel;
      this.streamController.immediateLevelSwitch();
    }

    /** Return next playback quality level (quality level of next fragment) **/

  }, {
    key: 'nextLevel',
    get: function get() {
      return this.streamController.nextLevel;
    }

    /* set quality level for next fragment (-1 for automatic level selection) */
    ,
    set: function set(newLevel) {
      _logger.logger.log('set nextLevel:' + newLevel);
      this.levelController.manualLevel = newLevel;
      this.streamController.nextLevelSwitch();
    }

    /** Return the quality level of current/last loaded fragment **/

  }, {
    key: 'loadLevel',
    get: function get() {
      return this.levelController.level;
    }

    /* set quality level for current/next loaded fragment (-1 for automatic level selection) */
    ,
    set: function set(newLevel) {
      _logger.logger.log('set loadLevel:' + newLevel);
      this.levelController.manualLevel = newLevel;
    }

    /** Return the quality level of next loaded fragment **/

  }, {
    key: 'nextLoadLevel',
    get: function get() {
      return this.levelController.nextLoadLevel;
    }

    /** set quality level of next loaded fragment **/
    ,
    set: function set(level) {
      this.levelController.nextLoadLevel = level;
    }

    /** Return first level (index of first level referenced in manifest)
    **/

  }, {
    key: 'firstLevel',
    get: function get() {
      return Math.max(this.levelController.firstLevel, this.minAutoLevel);
    }

    /** set first level (index of first level referenced in manifest)
    **/
    ,
    set: function set(newLevel) {
      _logger.logger.log('set firstLevel:' + newLevel);
      this.levelController.firstLevel = newLevel;
    }

    /** Return start level (level of first fragment that will be played back)
        if not overrided by user, first level appearing in manifest will be used as start level
        if -1 : automatic start level selection, playback will start from level matching download bandwidth (determined from download of first segment)
    **/

  }, {
    key: 'startLevel',
    get: function get() {
      return this.levelController.startLevel;
    }

    /** set  start level (level of first fragment that will be played back)
        if not overrided by user, first level appearing in manifest will be used as start level
        if -1 : automatic start level selection, playback will start from level matching download bandwidth (determined from download of first segment)
    **/
    ,
    set: function set(newLevel) {
      _logger.logger.log('set startLevel:' + newLevel);
      var hls = this;
      // if not in automatic start level detection, ensure startLevel is greater than minAutoLevel
      if (newLevel !== -1) {
        newLevel = Math.max(newLevel, hls.minAutoLevel);
      }
      hls.levelController.startLevel = newLevel;
    }

    /** Return the capping/max level value that could be used by automatic level selection algorithm **/

  }, {
    key: 'autoLevelCapping',
    get: function get() {
      return this._autoLevelCapping;
    }

    /** set the capping/max level value that could be used by automatic level selection algorithm **/
    ,
    set: function set(newLevel) {
      _logger.logger.log('set autoLevelCapping:' + newLevel);
      this._autoLevelCapping = newLevel;
    }

    /* check if we are in automatic level selection mode */

  }, {
    key: 'autoLevelEnabled',
    get: function get() {
      return this.levelController.manualLevel === -1;
    }

    /* return manual level */

  }, {
    key: 'manualLevel',
    get: function get() {
      return this.levelController.manualLevel;
    }

    /* return min level selectable in auto mode according to config.minAutoBitrate */

  }, {
    key: 'minAutoLevel',
    get: function get() {
      var hls = this,
          levels = hls.levels,
          minAutoBitrate = hls.config.minAutoBitrate,
          len = levels ? levels.length : 0;
      for (var i = 0; i < len; i++) {
        var levelNextBitrate = levels[i].realBitrate ? Math.max(levels[i].realBitrate, levels[i].bitrate) : levels[i].bitrate;
        if (levelNextBitrate > minAutoBitrate) {
          return i;
        }
      }
      return 0;
    }

    /* return max level selectable in auto mode according to autoLevelCapping */

  }, {
    key: 'maxAutoLevel',
    get: function get() {
      var hls = this;
      var levels = hls.levels;
      var autoLevelCapping = hls.autoLevelCapping;
      var maxAutoLevel = void 0;
      if (autoLevelCapping === -1 && levels && levels.length) {
        maxAutoLevel = levels.length - 1;
      } else {
        maxAutoLevel = autoLevelCapping;
      }
      return maxAutoLevel;
    }

    // return next auto level

  }, {
    key: 'nextAutoLevel',
    get: function get() {
      var hls = this;
      // ensure next auto level is between  min and max auto level
      return Math.min(Math.max(hls.abrController.nextAutoLevel, hls.minAutoLevel), hls.maxAutoLevel);
    }

    // this setter is used to force next auto level
    // this is useful to force a switch down in auto mode : in case of load error on level N, hls.js can set nextAutoLevel to N-1 for example)
    // forced value is valid for one fragment. upon succesful frag loading at forced level, this value will be resetted to -1 by ABR controller
    ,
    set: function set(nextLevel) {
      var hls = this;
      hls.abrController.nextAutoLevel = Math.max(hls.minAutoLevel, nextLevel);
    }

    /** get alternate audio tracks list from playlist **/

  }, {
    key: 'audioTracks',
    get: function get() {
      var audioTrackController = this.audioTrackController;
      return audioTrackController ? audioTrackController.audioTracks : [];
    }

    /** get index of the selected audio track (index in audio track lists) **/

  }, {
    key: 'audioTrack',
    get: function get() {
      var audioTrackController = this.audioTrackController;
      return audioTrackController ? audioTrackController.audioTrack : -1;
    }

    /** select an audio track, based on its index in audio track lists**/
    ,
    set: function set(audioTrackId) {
      var audioTrackController = this.audioTrackController;
      if (audioTrackController) {
        audioTrackController.audioTrack = audioTrackId;
      }
    }
  }, {
    key: 'liveSyncPosition',
    get: function get() {
      return this.streamController.liveSyncPosition;
    }

    /** get alternate subtitle tracks list from playlist **/

  }, {
    key: 'subtitleTracks',
    get: function get() {
      var subtitleTrackController = this.subtitleTrackController;
      return subtitleTrackController ? subtitleTrackController.subtitleTracks : [];
    }

    /** get index of the selected subtitle track (index in subtitle track lists) **/

  }, {
    key: 'subtitleTrack',
    get: function get() {
      var subtitleTrackController = this.subtitleTrackController;
      return subtitleTrackController ? subtitleTrackController.subtitleTrack : -1;
    }

    /** select an subtitle track, based on its index in subtitle track lists**/
    ,
    set: function set(subtitleTrackId) {
      var subtitleTrackController = this.subtitleTrackController;
      if (subtitleTrackController) {
        subtitleTrackController.subtitleTrack = subtitleTrackId;
      }
    }
  }]);

  return Hls;
}();

exports.default = Hls;

},{"./config":4,"./controller/level-controller":11,"./controller/stream-controller":12,"./errors":30,"./events":32,"./loader/fragment-loader":38,"./loader/key-loader":39,"./loader/playlist-loader":40,"./utils/logger":51,"events":1,"url-toolkit":2}],37:[function(require,module,exports){
'use strict';

// This is mostly for support of the es6 module export
// syntax with the babel compiler, it looks like it doesnt support
// function exports like we are used to in node/commonjs
module.exports = require('./hls.js').default;

},{"./hls.js":36}],38:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _eventHandler = require('../event-handler');

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _errors = require('../errors');

var _logger = require('../utils/logger');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Fragment Loader
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

var FragmentLoader = function (_EventHandler) {
  _inherits(FragmentLoader, _EventHandler);

  function FragmentLoader(hls) {
    _classCallCheck(this, FragmentLoader);

    var _this = _possibleConstructorReturn(this, (FragmentLoader.__proto__ || Object.getPrototypeOf(FragmentLoader)).call(this, hls, _events2.default.FRAG_LOADING));

    _this.loaders = {};
    return _this;
  }

  _createClass(FragmentLoader, [{
    key: 'destroy',
    value: function destroy() {
      var loaders = this.loaders;
      for (var loaderName in loaders) {
        var loader = loaders[loaderName];
        if (loader) {
          loader.destroy();
        }
      }
      this.loaders = {};
      _eventHandler2.default.prototype.destroy.call(this);
    }
  }, {
    key: 'onFragLoading',
    value: function onFragLoading(data) {
      var frag = data.frag,
          type = frag.type,
          loader = this.loaders[type],
          config = this.hls.config;

      frag.loaded = 0;
      if (loader) {
        _logger.logger.warn('abort previous fragment loader for type:' + type);
        loader.abort();
      }
      loader = this.loaders[type] = frag.loader = typeof config.fLoader !== 'undefined' ? new config.fLoader(config) : new config.loader(config);

      var loaderContext = void 0,
          loaderConfig = void 0,
          loaderCallbacks = void 0;
      loaderContext = { url: frag.url, frag: frag, responseType: 'arraybuffer', progressData: false };
      var start = frag.byteRangeStartOffset,
          end = frag.byteRangeEndOffset;
      if (!isNaN(start) && !isNaN(end)) {
        loaderContext.rangeStart = start;
        loaderContext.rangeEnd = end;
      }
      loaderConfig = { timeout: config.fragLoadingTimeOut, maxRetry: 0, retryDelay: 0, maxRetryDelay: config.fragLoadingMaxRetryTimeout };
      loaderCallbacks = { onSuccess: this.loadsuccess.bind(this), onError: this.loaderror.bind(this), onTimeout: this.loadtimeout.bind(this), onProgress: this.loadprogress.bind(this) };
      loader.load(loaderContext, loaderConfig, loaderCallbacks);
    }
  }, {
    key: 'loadsuccess',
    value: function loadsuccess(response, stats, context) {
      var payload = response.data,
          frag = context.frag;
      // detach fragment loader on load success
      frag.loader = undefined;
      this.loaders[frag.type] = undefined;
      this.hls.trigger(_events2.default.FRAG_LOADED, { payload: payload, frag: frag, stats: stats });
    }
  }, {
    key: 'loaderror',
    value: function loaderror(response, context) {
      var loader = context.loader;
      if (loader) {
        loader.abort();
      }
      this.loaders[context.type] = undefined;
      this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.NETWORK_ERROR, details: _errors.ErrorDetails.FRAG_LOAD_ERROR, fatal: false, frag: context.frag, response: response });
    }
  }, {
    key: 'loadtimeout',
    value: function loadtimeout(stats, context) {
      var loader = context.loader;
      if (loader) {
        loader.abort();
      }
      this.loaders[context.type] = undefined;
      this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.NETWORK_ERROR, details: _errors.ErrorDetails.FRAG_LOAD_TIMEOUT, fatal: false, frag: context.frag });
    }

    // data will be used for progressive parsing

  }, {
    key: 'loadprogress',
    value: function loadprogress(stats, context, data) {
      // jshint ignore:line
      var frag = context.frag;
      frag.loaded = stats.loaded;
      this.hls.trigger(_events2.default.FRAG_LOAD_PROGRESS, { frag: frag, stats: stats });
    }
  }]);

  return FragmentLoader;
}(_eventHandler2.default);

exports.default = FragmentLoader;

},{"../errors":30,"../event-handler":31,"../events":32,"../utils/logger":51}],39:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _eventHandler = require('../event-handler');

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _errors = require('../errors');

var _logger = require('../utils/logger');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Decrypt key Loader
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

var KeyLoader = function (_EventHandler) {
  _inherits(KeyLoader, _EventHandler);

  function KeyLoader(hls) {
    _classCallCheck(this, KeyLoader);

    var _this = _possibleConstructorReturn(this, (KeyLoader.__proto__ || Object.getPrototypeOf(KeyLoader)).call(this, hls, _events2.default.KEY_LOADING));

    _this.loaders = {};
    _this.decryptkey = null;
    _this.decrypturl = null;
    return _this;
  }

  _createClass(KeyLoader, [{
    key: 'destroy',
    value: function destroy() {
      for (var loaderName in this.loaders) {
        var loader = this.loaders[loaderName];
        if (loader) {
          loader.destroy();
        }
      }
      this.loaders = {};
      _eventHandler2.default.prototype.destroy.call(this);
    }
  }, {
    key: 'onKeyLoading',
    value: function onKeyLoading(data) {
      var frag = data.frag,
          type = frag.type,
          loader = this.loaders[type],
          decryptdata = frag.decryptdata,
          uri = decryptdata.uri;
      // if uri is different from previous one or if decrypt key not retrieved yet
      if (uri !== this.decrypturl || this.decryptkey === null) {
        var config = this.hls.config;

        if (loader) {
          _logger.logger.warn('abort previous key loader for type:' + type);
          loader.abort();
        }
        frag.loader = this.loaders[type] = new config.loader(config);
        this.decrypturl = uri;
        this.decryptkey = null;

        var loaderContext = void 0,
            loaderConfig = void 0,
            loaderCallbacks = void 0;
        loaderContext = { url: uri, frag: frag, responseType: 'arraybuffer' };
        loaderConfig = { timeout: config.fragLoadingTimeOut, maxRetry: config.fragLoadingMaxRetry, retryDelay: config.fragLoadingRetryDelay, maxRetryDelay: config.fragLoadingMaxRetryTimeout };
        loaderCallbacks = { onSuccess: this.loadsuccess.bind(this), onError: this.loaderror.bind(this), onTimeout: this.loadtimeout.bind(this) };
        frag.loader.load(loaderContext, loaderConfig, loaderCallbacks);
      } else if (this.decryptkey) {
        // we already loaded this key, return it
        decryptdata.key = this.decryptkey;
        this.hls.trigger(_events2.default.KEY_LOADED, { frag: frag });
      }
    }
  }, {
    key: 'loadsuccess',
    value: function loadsuccess(response, stats, context) {
      var frag = context.frag;
      this.decryptkey = frag.decryptdata.key = new Uint8Array(response.data);
      // detach fragment loader on load success
      frag.loader = undefined;
      this.loaders[frag.type] = undefined;
      this.hls.trigger(_events2.default.KEY_LOADED, { frag: frag });
    }
  }, {
    key: 'loaderror',
    value: function loaderror(response, context) {
      var frag = context.frag,
          loader = frag.loader;
      if (loader) {
        loader.abort();
      }
      this.loaders[context.type] = undefined;
      this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.NETWORK_ERROR, details: _errors.ErrorDetails.KEY_LOAD_ERROR, fatal: false, frag: frag, response: response });
    }
  }, {
    key: 'loadtimeout',
    value: function loadtimeout(stats, context) {
      var frag = context.frag,
          loader = frag.loader;
      if (loader) {
        loader.abort();
      }
      this.loaders[context.type] = undefined;
      this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.NETWORK_ERROR, details: _errors.ErrorDetails.KEY_LOAD_TIMEOUT, fatal: false, frag: frag });
    }
  }]);

  return KeyLoader;
}(_eventHandler2.default);

exports.default = KeyLoader;

},{"../errors":30,"../event-handler":31,"../events":32,"../utils/logger":51}],40:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Playlist Loader
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */

var _urlToolkit = require('url-toolkit');

var _urlToolkit2 = _interopRequireDefault(_urlToolkit);

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _eventHandler = require('../event-handler');

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _errors = require('../errors');

var _attrList = require('../utils/attr-list');

var _attrList2 = _interopRequireDefault(_attrList);

var _logger = require('../utils/logger');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// https://regex101.com is your friend
var MASTER_PLAYLIST_REGEX = /#EXT-X-STREAM-INF:([^\n\r]*)[\r\n]+([^\r\n]+)/g;
var MASTER_PLAYLIST_MEDIA_REGEX = /#EXT-X-MEDIA:(.*)/g;
var LEVEL_PLAYLIST_REGEX_FAST = /#EXTINF:(\d*(?:\.\d+)?)(?:,(.*))?|(?!#)(\S.+)|#EXT-X-BYTERANGE: *(.+)|#EXT-X-PROGRAM-DATE-TIME:(.+)|#.*/g;
var LEVEL_PLAYLIST_REGEX_SLOW = /(?:(?:#(EXTM3U))|(?:#EXT-X-(PLAYLIST-TYPE):(.+))|(?:#EXT-X-(MEDIA-SEQUENCE): *(\d+))|(?:#EXT-X-(TARGETDURATION): *(\d+))|(?:#EXT-X-(KEY):(.+))|(?:#EXT-X-(START):(.+))|(?:#EXT-X-(ENDLIST))|(?:#EXT-X-(DISCONTINUITY-SEQ)UENCE:(\d+))|(?:#EXT-X-(DIS)CONTINUITY))|(?:#EXT-X-(VERSION):(\d+))|(?:#EXT-X-(MAP):(.+))|(?:(#)(.*):(.*))|(?:(#)(.*))(?:.*)\r?\n?/;

var LevelKey = function () {
  function LevelKey() {
    _classCallCheck(this, LevelKey);

    this.method = null;
    this.key = null;
    this.iv = null;
    this._uri = null;
  }

  _createClass(LevelKey, [{
    key: 'uri',
    get: function get() {
      if (!this._uri && this.reluri) {
        this._uri = _urlToolkit2.default.buildAbsoluteURL(this.baseuri, this.reluri, { alwaysNormalize: true });
      }
      return this._uri;
    }
  }]);

  return LevelKey;
}();

var Fragment = function () {
  function Fragment() {
    _classCallCheck(this, Fragment);

    this._url = null;
    this._byteRange = null;
    this._decryptdata = null;
    this.tagList = [];
  }

  _createClass(Fragment, [{
    key: 'createInitializationVector',


    /**
     * Utility method for parseLevelPlaylist to create an initialization vector for a given segment
     * @returns {Uint8Array}
     */
    value: function createInitializationVector(segmentNumber) {
      var uint8View = new Uint8Array(16);

      for (var i = 12; i < 16; i++) {
        uint8View[i] = segmentNumber >> 8 * (15 - i) & 0xff;
      }

      return uint8View;
    }

    /**
     * Utility method for parseLevelPlaylist to get a fragment's decryption data from the currently parsed encryption key data
     * @param levelkey - a playlist's encryption info
     * @param segmentNumber - the fragment's segment number
     * @returns {*} - an object to be applied as a fragment's decryptdata
     */

  }, {
    key: 'fragmentDecryptdataFromLevelkey',
    value: function fragmentDecryptdataFromLevelkey(levelkey, segmentNumber) {
      var decryptdata = levelkey;

      if (levelkey && levelkey.method && levelkey.uri && !levelkey.iv) {
        decryptdata = new LevelKey();
        decryptdata.method = levelkey.method;
        decryptdata.baseuri = levelkey.baseuri;
        decryptdata.reluri = levelkey.reluri;
        decryptdata.iv = this.createInitializationVector(segmentNumber);
      }

      return decryptdata;
    }
  }, {
    key: 'cloneObj',
    value: function cloneObj(obj) {
      return JSON.parse(JSON.stringify(obj));
    }
  }, {
    key: 'url',
    get: function get() {
      if (!this._url && this.relurl) {
        this._url = _urlToolkit2.default.buildAbsoluteURL(this.baseurl, this.relurl, { alwaysNormalize: true });
      }
      return this._url;
    },
    set: function set(value) {
      this._url = value;
    }
  }, {
    key: 'programDateTime',
    get: function get() {
      if (!this._programDateTime && this.rawProgramDateTime) {
        this._programDateTime = new Date(Date.parse(this.rawProgramDateTime));
      }
      return this._programDateTime;
    }
  }, {
    key: 'byteRange',
    get: function get() {
      if (!this._byteRange) {
        var byteRange = this._byteRange = [];
        if (this.rawByteRange) {
          var params = this.rawByteRange.split('@', 2);
          if (params.length === 1) {
            var lastByteRangeEndOffset = this.lastByteRangeEndOffset;
            byteRange[0] = lastByteRangeEndOffset ? lastByteRangeEndOffset : 0;
          } else {
            byteRange[0] = parseInt(params[1]);
          }
          byteRange[1] = parseInt(params[0]) + byteRange[0];
        }
      }
      return this._byteRange;
    }
  }, {
    key: 'byteRangeStartOffset',
    get: function get() {
      return this.byteRange[0];
    }
  }, {
    key: 'byteRangeEndOffset',
    get: function get() {
      return this.byteRange[1];
    }
  }, {
    key: 'decryptdata',
    get: function get() {
      if (!this._decryptdata) {
        this._decryptdata = this.fragmentDecryptdataFromLevelkey(this.levelkey, this.sn);
      }
      return this._decryptdata;
    }
  }]);

  return Fragment;
}();

var PlaylistLoader = function (_EventHandler) {
  _inherits(PlaylistLoader, _EventHandler);

  function PlaylistLoader(hls) {
    _classCallCheck(this, PlaylistLoader);

    var _this = _possibleConstructorReturn(this, (PlaylistLoader.__proto__ || Object.getPrototypeOf(PlaylistLoader)).call(this, hls, _events2.default.MANIFEST_LOADING, _events2.default.LEVEL_LOADING, _events2.default.AUDIO_TRACK_LOADING, _events2.default.SUBTITLE_TRACK_LOADING));

    _this.loaders = {};
    return _this;
  }

  _createClass(PlaylistLoader, [{
    key: 'destroy',
    value: function destroy() {
      for (var loaderName in this.loaders) {
        var loader = this.loaders[loaderName];
        if (loader) {
          loader.destroy();
        }
      }
      this.loaders = {};
      _eventHandler2.default.prototype.destroy.call(this);
    }
  }, {
    key: 'onManifestLoading',
    value: function onManifestLoading(data) {
      this.load(data.url, { type: 'manifest' });
    }
  }, {
    key: 'onLevelLoading',
    value: function onLevelLoading(data) {
      this.load(data.url, { type: 'level', level: data.level, id: data.id });
    }
  }, {
    key: 'onAudioTrackLoading',
    value: function onAudioTrackLoading(data) {
      this.load(data.url, { type: 'audioTrack', id: data.id });
    }
  }, {
    key: 'onSubtitleTrackLoading',
    value: function onSubtitleTrackLoading(data) {
      this.load(data.url, { type: 'subtitleTrack', id: data.id });
    }
  }, {
    key: 'load',
    value: function load(url, context) {
      var loader = this.loaders[context.type];
      if (loader) {
        var loaderContext = loader.context;
        if (loaderContext && loaderContext.url === url) {
          _logger.logger.trace('playlist request ongoing');
          return;
        } else {
          _logger.logger.warn('abort previous loader for type:' + context.type);
          loader.abort();
        }
      }
      var config = this.hls.config,
          retry = void 0,
          timeout = void 0,
          retryDelay = void 0,
          maxRetryDelay = void 0;
      if (context.type === 'manifest') {
        retry = config.manifestLoadingMaxRetry;
        timeout = config.manifestLoadingTimeOut;
        retryDelay = config.manifestLoadingRetryDelay;
        maxRetryDelay = config.manifestLoadingMaxRetryTimeout;
      } else {
        retry = config.levelLoadingMaxRetry;
        timeout = config.levelLoadingTimeOut;
        retryDelay = config.levelLoadingRetryDelay;
        maxRetryDelay = config.levelLoadingMaxRetryTimeout;
        _logger.logger.log('loading playlist for ' + context.type + ' ' + (context.level || context.id));
      }
      loader = this.loaders[context.type] = context.loader = typeof config.pLoader !== 'undefined' ? new config.pLoader(config) : new config.loader(config);
      context.url = url;
      context.responseType = '';

      var loaderConfig = void 0,
          loaderCallbacks = void 0;
      loaderConfig = { timeout: timeout, maxRetry: retry, retryDelay: retryDelay, maxRetryDelay: maxRetryDelay };
      loaderCallbacks = { onSuccess: this.loadsuccess.bind(this), onError: this.loaderror.bind(this), onTimeout: this.loadtimeout.bind(this) };
      loader.load(context, loaderConfig, loaderCallbacks);
    }
  }, {
    key: 'resolve',
    value: function resolve(url, baseUrl) {
      return _urlToolkit2.default.buildAbsoluteURL(baseUrl, url, { alwaysNormalize: true });
    }
  }, {
    key: 'parseMasterPlaylist',
    value: function parseMasterPlaylist(string, baseurl) {
      var levels = [],
          result = void 0;
      MASTER_PLAYLIST_REGEX.lastIndex = 0;
      while ((result = MASTER_PLAYLIST_REGEX.exec(string)) != null) {
        var level = {};

        var attrs = level.attrs = new _attrList2.default(result[1]);
        level.url = this.resolve(result[2], baseurl);

        var resolution = attrs.decimalResolution('RESOLUTION');
        if (resolution) {
          level.width = resolution.width;
          level.height = resolution.height;
        }
        level.bitrate = attrs.decimalInteger('AVERAGE-BANDWIDTH') || attrs.decimalInteger('BANDWIDTH');
        level.name = attrs.NAME;

        var codecs = attrs.CODECS;
        if (codecs) {
          codecs = codecs.split(/[ ,]+/);
          for (var i = 0; i < codecs.length; i++) {
            var codec = codecs[i];
            if (codec.indexOf('avc1') !== -1) {
              level.videoCodec = this.avc1toavcoti(codec);
            } else {
              level.audioCodec = codec;
            }
          }
        }

        levels.push(level);
      }
      return levels;
    }
  }, {
    key: 'parseMasterPlaylistMedia',
    value: function parseMasterPlaylistMedia(string, baseurl, type) {
      var result = void 0,
          medias = [],
          id = 0;
      MASTER_PLAYLIST_MEDIA_REGEX.lastIndex = 0;
      while ((result = MASTER_PLAYLIST_MEDIA_REGEX.exec(string)) != null) {
        var media = {};
        var attrs = new _attrList2.default(result[1]);
        if (attrs.TYPE === type) {
          media.groupId = attrs['GROUP-ID'];
          media.instreamId = attrs['INSTREAM-ID'];
          media.name = attrs.NAME;
          media.type = type;
          media.default = attrs.DEFAULT === 'YES';
          media.autoselect = attrs.AUTOSELECT === 'YES';
          media.forced = attrs.FORCED === 'YES';
          if (attrs.URI) {
            media.url = this.resolve(attrs.URI, baseurl);
          }
          media.lang = attrs.LANGUAGE;
          if (!media.name) {
            media.name = media.lang;
          }
          media.id = id++;
          medias.push(media);
        }
      }
      return medias;
    }
  }, {
    key: 'avc1toavcoti',
    value: function avc1toavcoti(codec) {
      var result,
          avcdata = codec.split('.');
      if (avcdata.length > 2) {
        result = avcdata.shift() + '.';
        result += parseInt(avcdata.shift()).toString(16);
        result += ('000' + parseInt(avcdata.shift()).toString(16)).substr(-4);
      } else {
        result = codec;
      }
      return result;
    }
  }, {
    key: 'parseLevelPlaylist',
    value: function parseLevelPlaylist(string, baseurl, id, type) {
      var currentSN = 0,
          totalduration = 0,
          level = { type: null, version: null, url: baseurl, fragments: [], live: true, startSN: 0 },
          levelkey = new LevelKey(),
          cc = 0,
          prevFrag = null,
          frag = new Fragment(),
          result,
          i;

      LEVEL_PLAYLIST_REGEX_FAST.lastIndex = 0;

      while ((result = LEVEL_PLAYLIST_REGEX_FAST.exec(string)) !== null) {
        var duration = result[1];
        if (duration) {
          // INF
          frag.duration = parseFloat(duration);
          // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939
          var title = (' ' + result[2]).slice(1);
          frag.title = title ? title : null;
          frag.tagList.push(title ? ['INF', duration, title] : ['INF', duration]);
        } else if (result[3]) {
          // url
          if (!isNaN(frag.duration)) {
            var sn = currentSN++;
            frag.type = type;
            frag.start = totalduration;
            frag.levelkey = levelkey;
            frag.sn = sn;
            frag.level = id;
            frag.cc = cc;
            frag.baseurl = baseurl;
            // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939
            frag.relurl = (' ' + result[3]).slice(1);

            level.fragments.push(frag);
            prevFrag = frag;
            totalduration += frag.duration;

            frag = new Fragment();
          }
        } else if (result[4]) {
          // X-BYTERANGE
          frag.rawByteRange = (' ' + result[4]).slice(1);
          if (prevFrag) {
            var lastByteRangeEndOffset = prevFrag.byteRangeEndOffset;
            if (lastByteRangeEndOffset) {
              frag.lastByteRangeEndOffset = lastByteRangeEndOffset;
            }
          }
        } else if (result[5]) {
          // PROGRAM-DATE-TIME
          // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939
          frag.rawProgramDateTime = (' ' + result[5]).slice(1);
          frag.tagList.push(['PROGRAM-DATE-TIME', frag.rawProgramDateTime]);
        } else {
          result = result[0].match(LEVEL_PLAYLIST_REGEX_SLOW);
          for (i = 1; i < result.length; i++) {
            if (result[i] !== undefined) {
              break;
            }
          }

          // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939
          var value1 = (' ' + result[i + 1]).slice(1);
          var value2 = (' ' + result[i + 2]).slice(1);

          switch (result[i]) {
            case '#':
              frag.tagList.push(value2 ? [value1, value2] : [value1]);
              break;
            case 'PLAYLIST-TYPE':
              level.type = value1.toUpperCase();
              break;
            case 'MEDIA-SEQUENCE':
              currentSN = level.startSN = parseInt(value1);
              break;
            case 'TARGETDURATION':
              level.targetduration = parseFloat(value1);
              break;
            case 'VERSION':
              level.version = parseInt(value1);
              break;
            case 'EXTM3U':
              break;
            case 'ENDLIST':
              level.live = false;
              break;
            case 'DIS':
              cc++;
              frag.tagList.push(['DIS']);
              break;
            case 'DISCONTINUITY-SEQ':
              cc = parseInt(value1);
              break;
            case 'KEY':
              // https://tools.ietf.org/html/draft-pantos-http-live-streaming-08#section-3.4.4
              var decryptparams = value1;
              var keyAttrs = new _attrList2.default(decryptparams);
              var decryptmethod = keyAttrs.enumeratedString('METHOD'),
                  decrypturi = keyAttrs.URI,
                  decryptiv = keyAttrs.hexadecimalInteger('IV');
              if (decryptmethod) {
                levelkey = new LevelKey();
                if (decrypturi && ['AES-128', 'SAMPLE-AES'].indexOf(decryptmethod) >= 0) {
                  levelkey.method = decryptmethod;
                  // URI to get the key
                  levelkey.baseuri = baseurl;
                  levelkey.reluri = decrypturi;
                  levelkey.key = null;
                  // Initialization Vector (IV)
                  levelkey.iv = decryptiv;
                }
              }
              break;
            case 'START':
              var startParams = value1;
              var startAttrs = new _attrList2.default(startParams);
              var startTimeOffset = startAttrs.decimalFloatingPoint('TIME-OFFSET');
              //TIME-OFFSET can be 0
              if (!isNaN(startTimeOffset)) {
                level.startTimeOffset = startTimeOffset;
              }
              break;
            case 'MAP':
              var mapAttrs = new _attrList2.default(value1);
              frag.relurl = mapAttrs.URI;
              frag.rawByteRange = mapAttrs.BYTERANGE;
              frag.baseurl = baseurl;
              frag.level = id;
              frag.type = type;
              frag.sn = 'initSegment';
              level.initSegment = frag;
              frag = new Fragment();
              break;
            default:
              _logger.logger.warn('line parsed but not handled: ' + result);
              break;
          }
        }
      }
      frag = prevFrag;
      //logger.log('found ' + level.fragments.length + ' fragments');
      if (frag && !frag.relurl) {
        level.fragments.pop();
        totalduration -= frag.duration;
      }
      level.totalduration = totalduration;
      level.averagetargetduration = totalduration / level.fragments.length;
      level.endSN = currentSN - 1;
      level.startCC = level.fragments[0] ? level.fragments[0].cc : 0;
      level.endCC = cc;
      return level;
    }
  }, {
    key: 'loadsuccess',
    value: function loadsuccess(response, stats, context) {
      var string = response.data,
          url = response.url,
          type = context.type,
          id = context.id,
          level = context.level,
          hls = this.hls;

      this.loaders[type] = undefined;
      // responseURL not supported on some browsers (it is used to detect URL redirection)
      // data-uri mode also not supported (but no need to detect redirection)
      if (url === undefined || url.indexOf('data:') === 0) {
        // fallback to initial URL
        url = context.url;
      }
      stats.tload = performance.now();
      //stats.mtime = new Date(target.getResponseHeader('Last-Modified'));
      if (string.indexOf('#EXTM3U') === 0) {
        if (string.indexOf('#EXTINF:') > 0) {
          var isLevel = type !== 'audioTrack' && type !== 'subtitleTrack',
              levelId = !isNaN(level) ? level : !isNaN(id) ? id : 0,
              levelDetails = this.parseLevelPlaylist(string, url, levelId, type === 'audioTrack' ? 'audio' : type === 'subtitleTrack' ? 'subtitle' : 'main');
          levelDetails.tload = stats.tload;
          if (type === 'manifest') {
            // first request, stream manifest (no master playlist), fire manifest loaded event with level details
            hls.trigger(_events2.default.MANIFEST_LOADED, { levels: [{ url: url, details: levelDetails }], audioTracks: [], url: url, stats: stats });
          }
          stats.tparsed = performance.now();
          if (levelDetails.targetduration) {
            if (isLevel) {
              hls.trigger(_events2.default.LEVEL_LOADED, { details: levelDetails, level: level || 0, id: id || 0, stats: stats });
            } else {
              if (type === 'audioTrack') {
                hls.trigger(_events2.default.AUDIO_TRACK_LOADED, { details: levelDetails, id: id, stats: stats });
              } else if (type === 'subtitleTrack') {
                hls.trigger(_events2.default.SUBTITLE_TRACK_LOADED, { details: levelDetails, id: id, stats: stats });
              }
            }
          } else {
            hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.NETWORK_ERROR, details: _errors.ErrorDetails.MANIFEST_PARSING_ERROR, fatal: true, url: url, reason: 'invalid targetduration' });
          }
        } else {
          var levels = this.parseMasterPlaylist(string, url);
          // multi level playlist, parse level info
          if (levels.length) {
            var audioTracks = this.parseMasterPlaylistMedia(string, url, 'AUDIO');
            var subtitles = this.parseMasterPlaylistMedia(string, url, 'SUBTITLES');
            var captions = this.parseMasterPlaylistMedia(string, url, 'CLOSED-CAPTIONS');
            if (audioTracks.length) {
              // check if we have found an audio track embedded in main playlist (audio track without URI attribute)
              var embeddedAudioFound = false;
              audioTracks.forEach(function (audioTrack) {
                if (!audioTrack.url) {
                  embeddedAudioFound = true;
                }
              });
              // if no embedded audio track defined, but audio codec signaled in quality level, we need to signal this main audio track
              // this could happen with playlists with alt audio rendition in which quality levels (main) contains both audio+video. but with mixed audio track not signaled
              if (embeddedAudioFound === false && levels[0].audioCodec && !levels[0].attrs.AUDIO) {
                _logger.logger.log('audio codec signaled in quality level, but no embedded audio track signaled, create one');
                audioTracks.unshift({ type: 'main', name: 'main' });
              }
            }
            hls.trigger(_events2.default.MANIFEST_LOADED, { levels: levels, audioTracks: audioTracks, subtitles: subtitles, captions: captions, url: url, stats: stats });
          } else {
            if (type === 'manifest') {
              hls.trigger(_events2.default.ERROR, {
                type: _errors.ErrorTypes.NETWORK_ERROR,
                details: _errors.ErrorDetails.MANIFEST_PARSING_ERROR,
                fatal: true,
                url: url,
                reason: 'no level found in manifest'
              });
            } else {
              hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.NETWORK_ERROR, details: _errors.ErrorDetails.MANIFEST_EMPTY_ERROR, fatal: false, url: url, reason: 'no level found in manifest', context: context });
            }
          }
        }
      } else {
        hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.NETWORK_ERROR, details: _errors.ErrorDetails.MANIFEST_PARSING_ERROR, fatal: true, url: url, reason: 'no EXTM3U delimiter' });
      }
    }
  }, {
    key: 'loaderror',
    value: function loaderror(response, context) {
      var details,
          fatal,
          loader = context.loader;
      switch (context.type) {
        case 'manifest':
          details = _errors.ErrorDetails.MANIFEST_LOAD_ERROR;
          fatal = true;
          break;
        case 'level':
          details = _errors.ErrorDetails.LEVEL_LOAD_ERROR;
          fatal = false;
          break;
        case 'audioTrack':
          details = _errors.ErrorDetails.AUDIO_TRACK_LOAD_ERROR;
          fatal = false;
          break;
      }
      if (loader) {
        loader.abort();
        this.loaders[context.type] = undefined;
      }
      this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.NETWORK_ERROR, details: details, fatal: fatal, url: context.url, loader: loader, response: response, context: context });
    }
  }, {
    key: 'loadtimeout',
    value: function loadtimeout(stats, context) {
      var details,
          fatal,
          loader = context.loader;
      switch (context.type) {
        case 'manifest':
          details = _errors.ErrorDetails.MANIFEST_LOAD_TIMEOUT;
          fatal = true;
          break;
        case 'level':
          details = _errors.ErrorDetails.LEVEL_LOAD_TIMEOUT;
          fatal = false;
          break;
        case 'audioTrack':
          details = _errors.ErrorDetails.AUDIO_TRACK_LOAD_TIMEOUT;
          fatal = false;
          break;
      }
      if (loader) {
        loader.abort();
        this.loaders[context.type] = undefined;
      }
      this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.NETWORK_ERROR, details: details, fatal: fatal, url: context.url, loader: loader, context: context });
    }
  }]);

  return PlaylistLoader;
}(_eventHandler2.default);

exports.default = PlaylistLoader;

},{"../errors":30,"../event-handler":31,"../events":32,"../utils/attr-list":44,"../utils/logger":51,"url-toolkit":2}],41:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Generate MP4 Box
*/

//import Hex from '../utils/hex';

var UINT32_MAX = Math.pow(2, 32) - 1;

var MP4 = function () {
  function MP4() {
    _classCallCheck(this, MP4);
  }

  _createClass(MP4, null, [{
    key: 'init',
    value: function init() {
      MP4.types = {
        avc1: [], // codingname
        avcC: [],
        btrt: [],
        dinf: [],
        dref: [],
        esds: [],
        ftyp: [],
        hdlr: [],
        mdat: [],
        mdhd: [],
        mdia: [],
        mfhd: [],
        minf: [],
        moof: [],
        moov: [],
        mp4a: [],
        '.mp3': [],
        mvex: [],
        mvhd: [],
        pasp: [],
        sdtp: [],
        stbl: [],
        stco: [],
        stsc: [],
        stsd: [],
        stsz: [],
        stts: [],
        tfdt: [],
        tfhd: [],
        traf: [],
        trak: [],
        trun: [],
        trex: [],
        tkhd: [],
        vmhd: [],
        smhd: []
      };

      var i;
      for (i in MP4.types) {
        if (MP4.types.hasOwnProperty(i)) {
          MP4.types[i] = [i.charCodeAt(0), i.charCodeAt(1), i.charCodeAt(2), i.charCodeAt(3)];
        }
      }

      var videoHdlr = new Uint8Array([0x00, // version 0
      0x00, 0x00, 0x00, // flags
      0x00, 0x00, 0x00, 0x00, // pre_defined
      0x76, 0x69, 0x64, 0x65, // handler_type: 'vide'
      0x00, 0x00, 0x00, 0x00, // reserved
      0x00, 0x00, 0x00, 0x00, // reserved
      0x00, 0x00, 0x00, 0x00, // reserved
      0x56, 0x69, 0x64, 0x65, 0x6f, 0x48, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'VideoHandler'
      ]);

      var audioHdlr = new Uint8Array([0x00, // version 0
      0x00, 0x00, 0x00, // flags
      0x00, 0x00, 0x00, 0x00, // pre_defined
      0x73, 0x6f, 0x75, 0x6e, // handler_type: 'soun'
      0x00, 0x00, 0x00, 0x00, // reserved
      0x00, 0x00, 0x00, 0x00, // reserved
      0x00, 0x00, 0x00, 0x00, // reserved
      0x53, 0x6f, 0x75, 0x6e, 0x64, 0x48, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'SoundHandler'
      ]);

      MP4.HDLR_TYPES = {
        'video': videoHdlr,
        'audio': audioHdlr
      };

      var dref = new Uint8Array([0x00, // version 0
      0x00, 0x00, 0x00, // flags
      0x00, 0x00, 0x00, 0x01, // entry_count
      0x00, 0x00, 0x00, 0x0c, // entry_size
      0x75, 0x72, 0x6c, 0x20, // 'url' type
      0x00, // version 0
      0x00, 0x00, 0x01 // entry_flags
      ]);

      var stco = new Uint8Array([0x00, // version
      0x00, 0x00, 0x00, // flags
      0x00, 0x00, 0x00, 0x00 // entry_count
      ]);

      MP4.STTS = MP4.STSC = MP4.STCO = stco;

      MP4.STSZ = new Uint8Array([0x00, // version
      0x00, 0x00, 0x00, // flags
      0x00, 0x00, 0x00, 0x00, // sample_size
      0x00, 0x00, 0x00, 0x00]);
      MP4.VMHD = new Uint8Array([0x00, // version
      0x00, 0x00, 0x01, // flags
      0x00, 0x00, // graphicsmode
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00 // opcolor
      ]);
      MP4.SMHD = new Uint8Array([0x00, // version
      0x00, 0x00, 0x00, // flags
      0x00, 0x00, // balance
      0x00, 0x00 // reserved
      ]);

      MP4.STSD = new Uint8Array([0x00, // version 0
      0x00, 0x00, 0x00, // flags
      0x00, 0x00, 0x00, 0x01]); // entry_count

      var majorBrand = new Uint8Array([105, 115, 111, 109]); // isom
      var avc1Brand = new Uint8Array([97, 118, 99, 49]); // avc1
      var minorVersion = new Uint8Array([0, 0, 0, 1]);

      MP4.FTYP = MP4.box(MP4.types.ftyp, majorBrand, minorVersion, majorBrand, avc1Brand);
      MP4.DINF = MP4.box(MP4.types.dinf, MP4.box(MP4.types.dref, dref));
    }
  }, {
    key: 'box',
    value: function box(type) {
      var payload = Array.prototype.slice.call(arguments, 1),
          size = 8,
          i = payload.length,
          len = i,
          result;
      // calculate the total size we need to allocate
      while (i--) {
        size += payload[i].byteLength;
      }
      result = new Uint8Array(size);
      result[0] = size >> 24 & 0xff;
      result[1] = size >> 16 & 0xff;
      result[2] = size >> 8 & 0xff;
      result[3] = size & 0xff;
      result.set(type, 4);
      // copy the payload into the result
      for (i = 0, size = 8; i < len; i++) {
        // copy payload[i] array @ offset size
        result.set(payload[i], size);
        size += payload[i].byteLength;
      }
      return result;
    }
  }, {
    key: 'hdlr',
    value: function hdlr(type) {
      return MP4.box(MP4.types.hdlr, MP4.HDLR_TYPES[type]);
    }
  }, {
    key: 'mdat',
    value: function mdat(data) {
      return MP4.box(MP4.types.mdat, data);
    }
  }, {
    key: 'mdhd',
    value: function mdhd(timescale, duration) {
      duration *= timescale;
      var upperWordDuration = Math.floor(duration / (UINT32_MAX + 1));
      var lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));
      return MP4.box(MP4.types.mdhd, new Uint8Array([0x01, // version 1
      0x00, 0x00, 0x00, // flags
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // creation_time
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, // modification_time
      timescale >> 24 & 0xFF, timescale >> 16 & 0xFF, timescale >> 8 & 0xFF, timescale & 0xFF, // timescale
      upperWordDuration >> 24, upperWordDuration >> 16 & 0xFF, upperWordDuration >> 8 & 0xFF, upperWordDuration & 0xFF, lowerWordDuration >> 24, lowerWordDuration >> 16 & 0xFF, lowerWordDuration >> 8 & 0xFF, lowerWordDuration & 0xFF, 0x55, 0xc4, // 'und' language (undetermined)
      0x00, 0x00]));
    }
  }, {
    key: 'mdia',
    value: function mdia(track) {
      return MP4.box(MP4.types.mdia, MP4.mdhd(track.timescale, track.duration), MP4.hdlr(track.type), MP4.minf(track));
    }
  }, {
    key: 'mfhd',
    value: function mfhd(sequenceNumber) {
      return MP4.box(MP4.types.mfhd, new Uint8Array([0x00, 0x00, 0x00, 0x00, // flags
      sequenceNumber >> 24, sequenceNumber >> 16 & 0xFF, sequenceNumber >> 8 & 0xFF, sequenceNumber & 0xFF]));
    }
  }, {
    key: 'minf',
    value: function minf(track) {
      if (track.type === 'audio') {
        return MP4.box(MP4.types.minf, MP4.box(MP4.types.smhd, MP4.SMHD), MP4.DINF, MP4.stbl(track));
      } else {
        return MP4.box(MP4.types.minf, MP4.box(MP4.types.vmhd, MP4.VMHD), MP4.DINF, MP4.stbl(track));
      }
    }
  }, {
    key: 'moof',
    value: function moof(sn, baseMediaDecodeTime, track) {
      return MP4.box(MP4.types.moof, MP4.mfhd(sn), MP4.traf(track, baseMediaDecodeTime));
    }
    /**
     * @param tracks... (optional) {array} the tracks associated with this movie
     */

  }, {
    key: 'moov',
    value: function moov(tracks) {
      var i = tracks.length,
          boxes = [];

      while (i--) {
        boxes[i] = MP4.trak(tracks[i]);
      }

      return MP4.box.apply(null, [MP4.types.moov, MP4.mvhd(tracks[0].timescale, tracks[0].duration)].concat(boxes).concat(MP4.mvex(tracks)));
    }
  }, {
    key: 'mvex',
    value: function mvex(tracks) {
      var i = tracks.length,
          boxes = [];

      while (i--) {
        boxes[i] = MP4.trex(tracks[i]);
      }
      return MP4.box.apply(null, [MP4.types.mvex].concat(boxes));
    }
  }, {
    key: 'mvhd',
    value: function mvhd(timescale, duration) {
      duration *= timescale;
      var upperWordDuration = Math.floor(duration / (UINT32_MAX + 1));
      var lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));
      var bytes = new Uint8Array([0x01, // version 1
      0x00, 0x00, 0x00, // flags
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // creation_time
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, // modification_time
      timescale >> 24 & 0xFF, timescale >> 16 & 0xFF, timescale >> 8 & 0xFF, timescale & 0xFF, // timescale
      upperWordDuration >> 24, upperWordDuration >> 16 & 0xFF, upperWordDuration >> 8 & 0xFF, upperWordDuration & 0xFF, lowerWordDuration >> 24, lowerWordDuration >> 16 & 0xFF, lowerWordDuration >> 8 & 0xFF, lowerWordDuration & 0xFF, 0x00, 0x01, 0x00, 0x00, // 1.0 rate
      0x01, 0x00, // 1.0 volume
      0x00, 0x00, // reserved
      0x00, 0x00, 0x00, 0x00, // reserved
      0x00, 0x00, 0x00, 0x00, // reserved
      0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, // transformation: unity matrix
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // pre_defined
      0xff, 0xff, 0xff, 0xff // next_track_ID
      ]);
      return MP4.box(MP4.types.mvhd, bytes);
    }
  }, {
    key: 'sdtp',
    value: function sdtp(track) {
      var samples = track.samples || [],
          bytes = new Uint8Array(4 + samples.length),
          flags,
          i;
      // leave the full box header (4 bytes) all zero
      // write the sample table
      for (i = 0; i < samples.length; i++) {
        flags = samples[i].flags;
        bytes[i + 4] = flags.dependsOn << 4 | flags.isDependedOn << 2 | flags.hasRedundancy;
      }

      return MP4.box(MP4.types.sdtp, bytes);
    }
  }, {
    key: 'stbl',
    value: function stbl(track) {
      return MP4.box(MP4.types.stbl, MP4.stsd(track), MP4.box(MP4.types.stts, MP4.STTS), MP4.box(MP4.types.stsc, MP4.STSC), MP4.box(MP4.types.stsz, MP4.STSZ), MP4.box(MP4.types.stco, MP4.STCO));
    }
  }, {
    key: 'avc1',
    value: function avc1(track) {
      var sps = [],
          pps = [],
          i,
          data,
          len;
      // assemble the SPSs

      for (i = 0; i < track.sps.length; i++) {
        data = track.sps[i];
        len = data.byteLength;
        sps.push(len >>> 8 & 0xFF);
        sps.push(len & 0xFF);
        sps = sps.concat(Array.prototype.slice.call(data)); // SPS
      }

      // assemble the PPSs
      for (i = 0; i < track.pps.length; i++) {
        data = track.pps[i];
        len = data.byteLength;
        pps.push(len >>> 8 & 0xFF);
        pps.push(len & 0xFF);
        pps = pps.concat(Array.prototype.slice.call(data));
      }

      var avcc = MP4.box(MP4.types.avcC, new Uint8Array([0x01, // version
      sps[3], // profile
      sps[4], // profile compat
      sps[5], // level
      0xfc | 3, // lengthSizeMinusOne, hard-coded to 4 bytes
      0xE0 | track.sps.length // 3bit reserved (111) + numOfSequenceParameterSets
      ].concat(sps).concat([track.pps.length // numOfPictureParameterSets
      ]).concat(pps))),
          // "PPS"
      width = track.width,
          height = track.height,
          hSpacing = track.pixelRatio[0],
          vSpacing = track.pixelRatio[1];
      //console.log('avcc:' + Hex.hexDump(avcc));
      return MP4.box(MP4.types.avc1, new Uint8Array([0x00, 0x00, 0x00, // reserved
      0x00, 0x00, 0x00, // reserved
      0x00, 0x01, // data_reference_index
      0x00, 0x00, // pre_defined
      0x00, 0x00, // reserved
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // pre_defined
      width >> 8 & 0xFF, width & 0xff, // width
      height >> 8 & 0xFF, height & 0xff, // height
      0x00, 0x48, 0x00, 0x00, // horizresolution
      0x00, 0x48, 0x00, 0x00, // vertresolution
      0x00, 0x00, 0x00, 0x00, // reserved
      0x00, 0x01, // frame_count
      0x12, 0x64, 0x61, 0x69, 0x6C, //dailymotion/hls.js
      0x79, 0x6D, 0x6F, 0x74, 0x69, 0x6F, 0x6E, 0x2F, 0x68, 0x6C, 0x73, 0x2E, 0x6A, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // compressorname
      0x00, 0x18, // depth = 24
      0x11, 0x11]), // pre_defined = -1
      avcc, MP4.box(MP4.types.btrt, new Uint8Array([0x00, 0x1c, 0x9c, 0x80, // bufferSizeDB
      0x00, 0x2d, 0xc6, 0xc0, // maxBitrate
      0x00, 0x2d, 0xc6, 0xc0])), // avgBitrate
      MP4.box(MP4.types.pasp, new Uint8Array([hSpacing >> 24, // hSpacing
      hSpacing >> 16 & 0xFF, hSpacing >> 8 & 0xFF, hSpacing & 0xFF, vSpacing >> 24, // vSpacing
      vSpacing >> 16 & 0xFF, vSpacing >> 8 & 0xFF, vSpacing & 0xFF])));
    }
  }, {
    key: 'esds',
    value: function esds(track) {
      var configlen = track.config.length;
      return new Uint8Array([0x00, // version 0
      0x00, 0x00, 0x00, // flags

      0x03, // descriptor_type
      0x17 + configlen, // length
      0x00, 0x01, //es_id
      0x00, // stream_priority

      0x04, // descriptor_type
      0x0f + configlen, // length
      0x40, //codec : mpeg4_audio
      0x15, // stream_type
      0x00, 0x00, 0x00, // buffer_size
      0x00, 0x00, 0x00, 0x00, // maxBitrate
      0x00, 0x00, 0x00, 0x00, // avgBitrate

      0x05 // descriptor_type
      ].concat([configlen]).concat(track.config).concat([0x06, 0x01, 0x02])); // GASpecificConfig)); // length + audio config descriptor
    }
  }, {
    key: 'mp4a',
    value: function mp4a(track) {
      var samplerate = track.samplerate;
      return MP4.box(MP4.types.mp4a, new Uint8Array([0x00, 0x00, 0x00, // reserved
      0x00, 0x00, 0x00, // reserved
      0x00, 0x01, // data_reference_index
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // reserved
      0x00, track.channelCount, // channelcount
      0x00, 0x10, // sampleSize:16bits
      0x00, 0x00, 0x00, 0x00, // reserved2
      samplerate >> 8 & 0xFF, samplerate & 0xff, //
      0x00, 0x00]), MP4.box(MP4.types.esds, MP4.esds(track)));
    }
  }, {
    key: 'mp3',
    value: function mp3(track) {
      var samplerate = track.samplerate;
      return MP4.box(MP4.types['.mp3'], new Uint8Array([0x00, 0x00, 0x00, // reserved
      0x00, 0x00, 0x00, // reserved
      0x00, 0x01, // data_reference_index
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // reserved
      0x00, track.channelCount, // channelcount
      0x00, 0x10, // sampleSize:16bits
      0x00, 0x00, 0x00, 0x00, // reserved2
      samplerate >> 8 & 0xFF, samplerate & 0xff, //
      0x00, 0x00]));
    }
  }, {
    key: 'stsd',
    value: function stsd(track) {
      if (track.type === 'audio') {
        if (!track.isAAC && track.codec === 'mp3') {
          return MP4.box(MP4.types.stsd, MP4.STSD, MP4.mp3(track));
        }
        return MP4.box(MP4.types.stsd, MP4.STSD, MP4.mp4a(track));
      } else {
        return MP4.box(MP4.types.stsd, MP4.STSD, MP4.avc1(track));
      }
    }
  }, {
    key: 'tkhd',
    value: function tkhd(track) {
      var id = track.id,
          duration = track.duration * track.timescale,
          width = track.width,
          height = track.height,
          upperWordDuration = Math.floor(duration / (UINT32_MAX + 1)),
          lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));
      return MP4.box(MP4.types.tkhd, new Uint8Array([0x01, // version 1
      0x00, 0x00, 0x07, // flags
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // creation_time
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, // modification_time
      id >> 24 & 0xFF, id >> 16 & 0xFF, id >> 8 & 0xFF, id & 0xFF, // track_ID
      0x00, 0x00, 0x00, 0x00, // reserved
      upperWordDuration >> 24, upperWordDuration >> 16 & 0xFF, upperWordDuration >> 8 & 0xFF, upperWordDuration & 0xFF, lowerWordDuration >> 24, lowerWordDuration >> 16 & 0xFF, lowerWordDuration >> 8 & 0xFF, lowerWordDuration & 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // reserved
      0x00, 0x00, // layer
      0x00, 0x00, // alternate_group
      0x00, 0x00, // non-audio track volume
      0x00, 0x00, // reserved
      0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, // transformation: unity matrix
      width >> 8 & 0xFF, width & 0xFF, 0x00, 0x00, // width
      height >> 8 & 0xFF, height & 0xFF, 0x00, 0x00 // height
      ]));
    }
  }, {
    key: 'traf',
    value: function traf(track, baseMediaDecodeTime) {
      var sampleDependencyTable = MP4.sdtp(track),
          id = track.id,
          upperWordBaseMediaDecodeTime = Math.floor(baseMediaDecodeTime / (UINT32_MAX + 1)),
          lowerWordBaseMediaDecodeTime = Math.floor(baseMediaDecodeTime % (UINT32_MAX + 1));
      return MP4.box(MP4.types.traf, MP4.box(MP4.types.tfhd, new Uint8Array([0x00, // version 0
      0x00, 0x00, 0x00, // flags
      id >> 24, id >> 16 & 0XFF, id >> 8 & 0XFF, id & 0xFF])), MP4.box(MP4.types.tfdt, new Uint8Array([0x01, // version 1
      0x00, 0x00, 0x00, // flags
      upperWordBaseMediaDecodeTime >> 24, upperWordBaseMediaDecodeTime >> 16 & 0XFF, upperWordBaseMediaDecodeTime >> 8 & 0XFF, upperWordBaseMediaDecodeTime & 0xFF, lowerWordBaseMediaDecodeTime >> 24, lowerWordBaseMediaDecodeTime >> 16 & 0XFF, lowerWordBaseMediaDecodeTime >> 8 & 0XFF, lowerWordBaseMediaDecodeTime & 0xFF])), MP4.trun(track, sampleDependencyTable.length + 16 + // tfhd
      20 + // tfdt
      8 + // traf header
      16 + // mfhd
      8 + // moof header
      8), // mdat header
      sampleDependencyTable);
    }

    /**
     * Generate a track box.
     * @param track {object} a track definition
     * @return {Uint8Array} the track box
     */

  }, {
    key: 'trak',
    value: function trak(track) {
      track.duration = track.duration || 0xffffffff;
      return MP4.box(MP4.types.trak, MP4.tkhd(track), MP4.mdia(track));
    }
  }, {
    key: 'trex',
    value: function trex(track) {
      var id = track.id;
      return MP4.box(MP4.types.trex, new Uint8Array([0x00, // version 0
      0x00, 0x00, 0x00, // flags
      id >> 24, id >> 16 & 0XFF, id >> 8 & 0XFF, id & 0xFF, // track_ID
      0x00, 0x00, 0x00, 0x01, // default_sample_description_index
      0x00, 0x00, 0x00, 0x00, // default_sample_duration
      0x00, 0x00, 0x00, 0x00, // default_sample_size
      0x00, 0x01, 0x00, 0x01 // default_sample_flags
      ]));
    }
  }, {
    key: 'trun',
    value: function trun(track, offset) {
      var samples = track.samples || [],
          len = samples.length,
          arraylen = 12 + 16 * len,
          array = new Uint8Array(arraylen),
          i,
          sample,
          duration,
          size,
          flags,
          cts;
      offset += 8 + arraylen;
      array.set([0x00, // version 0
      0x00, 0x0f, 0x01, // flags
      len >>> 24 & 0xFF, len >>> 16 & 0xFF, len >>> 8 & 0xFF, len & 0xFF, // sample_count
      offset >>> 24 & 0xFF, offset >>> 16 & 0xFF, offset >>> 8 & 0xFF, offset & 0xFF // data_offset
      ], 0);
      for (i = 0; i < len; i++) {
        sample = samples[i];
        duration = sample.duration;
        size = sample.size;
        flags = sample.flags;
        cts = sample.cts;
        array.set([duration >>> 24 & 0xFF, duration >>> 16 & 0xFF, duration >>> 8 & 0xFF, duration & 0xFF, // sample_duration
        size >>> 24 & 0xFF, size >>> 16 & 0xFF, size >>> 8 & 0xFF, size & 0xFF, // sample_size
        flags.isLeading << 2 | flags.dependsOn, flags.isDependedOn << 6 | flags.hasRedundancy << 4 | flags.paddingValue << 1 | flags.isNonSync, flags.degradPrio & 0xF0 << 8, flags.degradPrio & 0x0F, // sample_flags
        cts >>> 24 & 0xFF, cts >>> 16 & 0xFF, cts >>> 8 & 0xFF, cts & 0xFF // sample_composition_time_offset
        ], 12 + 16 * i);
      }
      return MP4.box(MP4.types.trun, array);
    }
  }, {
    key: 'initSegment',
    value: function initSegment(tracks) {
      if (!MP4.types) {
        MP4.init();
      }
      var movie = MP4.moov(tracks),
          result;
      result = new Uint8Array(MP4.FTYP.byteLength + movie.byteLength);
      result.set(MP4.FTYP);
      result.set(movie, MP4.FTYP.byteLength);
      return result;
    }
  }]);

  return MP4;
}();

exports.default = MP4;

},{}],42:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * fMP4 remuxer
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */

var _aac = require('../helper/aac');

var _aac2 = _interopRequireDefault(_aac);

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _logger = require('../utils/logger');

var _mp4Generator = require('../remux/mp4-generator');

var _mp4Generator2 = _interopRequireDefault(_mp4Generator);

var _errors = require('../errors');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var MP4Remuxer = function () {
  function MP4Remuxer(observer, config, typeSupported, vendor) {
    _classCallCheck(this, MP4Remuxer);

    this.observer = observer;
    this.config = config;
    this.typeSupported = typeSupported;
    var userAgent = navigator.userAgent;
    this.isSafari = vendor && vendor.indexOf('Apple') > -1 && userAgent && !userAgent.match('CriOS');
    this.ISGenerated = false;
  }

  _createClass(MP4Remuxer, [{
    key: 'destroy',
    value: function destroy() {}
  }, {
    key: 'resetTimeStamp',
    value: function resetTimeStamp(defaultTimeStamp) {
      this._initPTS = this._initDTS = defaultTimeStamp;
    }
  }, {
    key: 'resetInitSegment',
    value: function resetInitSegment() {
      this.ISGenerated = false;
    }
  }, {
    key: 'remux',
    value: function remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset) {
      // generate Init Segment if needed
      if (!this.ISGenerated) {
        this.generateIS(audioTrack, videoTrack, timeOffset);
      }

      if (this.ISGenerated) {
        // Purposefully remuxing audio before video, so that remuxVideo can use nextAudioPts, which is
        // calculated in remuxAudio.
        //logger.log('nb AAC samples:' + audioTrack.samples.length);
        if (audioTrack.samples.length) {
          var audioData = this.remuxAudio(audioTrack, timeOffset, contiguous, accurateTimeOffset);
          //logger.log('nb AVC samples:' + videoTrack.samples.length);
          if (videoTrack.samples.length) {
            var audioTrackLength = void 0;
            if (audioData) {
              audioTrackLength = audioData.endPTS - audioData.startPTS;
            }
            this.remuxVideo(videoTrack, timeOffset, contiguous, audioTrackLength);
          }
        } else {
          var videoData = void 0;
          //logger.log('nb AVC samples:' + videoTrack.samples.length);
          if (videoTrack.samples.length) {
            videoData = this.remuxVideo(videoTrack, timeOffset, contiguous);
          }
          if (videoData && audioTrack.codec) {
            this.remuxEmptyAudio(audioTrack, timeOffset, contiguous, videoData);
          }
        }
      }
      //logger.log('nb ID3 samples:' + audioTrack.samples.length);
      if (id3Track.samples.length) {
        this.remuxID3(id3Track, timeOffset);
      }
      //logger.log('nb ID3 samples:' + audioTrack.samples.length);
      if (textTrack.samples.length) {
        this.remuxText(textTrack, timeOffset);
      }
      //notify end of parsing
      this.observer.trigger(_events2.default.FRAG_PARSED);
    }
  }, {
    key: 'generateIS',
    value: function generateIS(audioTrack, videoTrack, timeOffset) {
      var observer = this.observer,
          audioSamples = audioTrack.samples,
          videoSamples = videoTrack.samples,
          typeSupported = this.typeSupported,
          container = 'audio/mp4',
          tracks = {},
          data = { tracks: tracks },
          computePTSDTS = this._initPTS === undefined,
          initPTS,
          initDTS;

      if (computePTSDTS) {
        initPTS = initDTS = Infinity;
      }
      if (audioTrack.config && audioSamples.length) {
        // let's use audio sampling rate as MP4 time scale.
        // rationale is that there is a integer nb of audio frames per audio sample (1024 for AAC)
        // using audio sampling rate here helps having an integer MP4 frame duration
        // this avoids potential rounding issue and AV sync issue
        audioTrack.timescale = audioTrack.samplerate;
        _logger.logger.log('audio sampling rate : ' + audioTrack.samplerate);
        if (!audioTrack.isAAC) {
          if (typeSupported.mpeg) {
            // Chrome and Safari
            container = 'audio/mpeg';
            audioTrack.codec = '';
          } else if (typeSupported.mp3) {
            // Firefox
            audioTrack.codec = 'mp3';
          }
        }
        tracks.audio = {
          container: container,
          codec: audioTrack.codec,
          initSegment: !audioTrack.isAAC && typeSupported.mpeg ? new Uint8Array() : _mp4Generator2.default.initSegment([audioTrack]),
          metadata: {
            channelCount: audioTrack.channelCount
          }
        };
        if (computePTSDTS) {
          // remember first PTS of this demuxing context. for audio, PTS = DTS
          initPTS = initDTS = audioSamples[0].pts - audioTrack.inputTimeScale * timeOffset;
        }
      }

      if (videoTrack.sps && videoTrack.pps && videoSamples.length) {
        // let's use input time scale as MP4 video timescale
        // we use input time scale straight away to avoid rounding issues on frame duration / cts computation
        var inputTimeScale = videoTrack.inputTimeScale;
        videoTrack.timescale = inputTimeScale;
        tracks.video = {
          container: 'video/mp4',
          codec: videoTrack.codec,
          initSegment: _mp4Generator2.default.initSegment([videoTrack]),
          metadata: {
            width: videoTrack.width,
            height: videoTrack.height
          }
        };
        if (computePTSDTS) {
          initPTS = Math.min(initPTS, videoSamples[0].pts - inputTimeScale * timeOffset);
          initDTS = Math.min(initDTS, videoSamples[0].dts - inputTimeScale * timeOffset);
          this.observer.trigger(_events2.default.INIT_PTS_FOUND, { initPTS: initPTS });
        }
      }

      if (Object.keys(tracks).length) {
        observer.trigger(_events2.default.FRAG_PARSING_INIT_SEGMENT, data);
        this.ISGenerated = true;
        if (computePTSDTS) {
          this._initPTS = initPTS;
          this._initDTS = initDTS;
        }
      } else {
        observer.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.FRAG_PARSING_ERROR, fatal: false, reason: 'no audio/video samples found' });
      }
    }
  }, {
    key: 'remuxVideo',
    value: function remuxVideo(track, timeOffset, contiguous, audioTrackLength) {
      var offset = 8,
          timeScale = track.timescale,
          mp4SampleDuration,
          mdat,
          moof,
          firstPTS,
          firstDTS,
          nextDTS,
          lastPTS,
          lastDTS,
          inputSamples = track.samples,
          outputSamples = [],
          nbSamples = inputSamples.length,
          ptsNormalize = this._PTSNormalize,
          initDTS = this._initDTS;

      // for (let i = 0; i < track.samples.length; i++) {
      //   let avcSample = track.samples[i];
      //   let units = avcSample.units;
      //   let unitsString = '';
      //   for (let j = 0; j < units.length ; j++) {
      //     unitsString += units[j].type + ',';
      //     if (units[j].data.length < 500) {
      //       unitsString += Hex.hexDump(units[j].data);
      //     }
      //   }
      //   logger.log(avcSample.pts + '/' + avcSample.dts + ',' + unitsString + avcSample.units.length);
      // }

      // sort video samples by DTS then PTS then demux id order
      inputSamples.sort(function (a, b) {
        var deltadts = a.dts - b.dts;
        var deltapts = a.pts - b.pts;
        return deltadts ? deltadts : deltapts ? deltapts : a.id - b.id;
      });

      // handle broken streams with PTS < DTS, tolerance up 200ms (18000 in 90kHz timescale)
      var PTSDTSshift = inputSamples.reduce(function (prev, curr) {
        return Math.max(Math.min(prev, curr.pts - curr.dts), -18000);
      }, 0);
      if (PTSDTSshift < 0) {
        _logger.logger.warn('PTS < DTS detected in video samples, shifting DTS by ' + Math.round(PTSDTSshift / 90) + ' ms to overcome this issue');
        for (var i = 0; i < inputSamples.length; i++) {
          inputSamples[i].dts += PTSDTSshift;
        }
      }

      // PTS is coded on 33bits, and can loop from -2^32 to 2^32
      // ptsNormalize will make PTS/DTS value monotonic, we use last known DTS value as reference value
      var nextAvcDts = void 0;
      // contiguous fragments are consecutive fragments from same quality level (same level, new SN = old SN + 1)
      if (contiguous) {
        // if parsed fragment is contiguous with last one, let's use last DTS value as reference
        nextAvcDts = this.nextAvcDts;
      } else {
        // if not contiguous, let's use target timeOffset
        nextAvcDts = timeOffset * timeScale;
      }

      // compute first DTS and last DTS, normalize them against reference value
      var sample = inputSamples[0];
      firstDTS = Math.max(ptsNormalize(sample.dts - initDTS, nextAvcDts), 0);
      firstPTS = Math.max(ptsNormalize(sample.pts - initDTS, nextAvcDts), 0);

      // check timestamp continuity accross consecutive fragments (this is to remove inter-fragment gap/hole)
      var delta = Math.round((firstDTS - nextAvcDts) / 90);
      // if fragment are contiguous, detect hole/overlapping between fragments
      if (contiguous) {
        if (delta) {
          if (delta > 1) {
            _logger.logger.log('AVC:' + delta + ' ms hole between fragments detected,filling it');
          } else if (delta < -1) {
            _logger.logger.log('AVC:' + -delta + ' ms overlapping between fragments detected');
          }
          // remove hole/gap : set DTS to next expected DTS
          firstDTS = nextAvcDts;
          inputSamples[0].dts = firstDTS + initDTS;
          // offset PTS as well, ensure that PTS is smaller or equal than new DTS
          firstPTS = Math.max(firstPTS - delta, nextAvcDts);
          inputSamples[0].pts = firstPTS + initDTS;
          _logger.logger.log('Video/PTS/DTS adjusted: ' + Math.round(firstPTS / 90) + '/' + Math.round(firstDTS / 90) + ',delta:' + delta + ' ms');
        }
      }
      nextDTS = firstDTS;

      // compute lastPTS/lastDTS
      sample = inputSamples[inputSamples.length - 1];
      lastDTS = Math.max(ptsNormalize(sample.dts - initDTS, nextAvcDts), 0);
      lastPTS = Math.max(ptsNormalize(sample.pts - initDTS, nextAvcDts), 0);
      lastPTS = Math.max(lastPTS, lastDTS);

      var isSafari = this.isSafari;
      // on Safari let's signal the same sample duration for all samples
      // sample duration (as expected by trun MP4 boxes), should be the delta between sample DTS
      // set this constant duration as being the avg delta between consecutive DTS.
      if (isSafari) {
        mp4SampleDuration = Math.round((lastDTS - firstDTS) / (inputSamples.length - 1));
      }

      var nbNalu = 0,
          naluLen = 0;
      for (var _i = 0; _i < nbSamples; _i++) {
        // compute total/avc sample length and nb of NAL units
        var _sample = inputSamples[_i],
            units = _sample.units,
            nbUnits = units.length,
            sampleLen = 0;
        for (var j = 0; j < nbUnits; j++) {
          sampleLen += units[j].data.length;
        }
        naluLen += sampleLen;
        nbNalu += nbUnits;
        _sample.length = sampleLen;

        // normalize PTS/DTS
        if (isSafari) {
          // sample DTS is computed using a constant decoding offset (mp4SampleDuration) between samples
          _sample.dts = firstDTS + _i * mp4SampleDuration;
        } else {
          // ensure sample monotonic DTS
          _sample.dts = Math.max(ptsNormalize(_sample.dts - initDTS, nextAvcDts), firstDTS);
        }
        // we normalize PTS against nextAvcDts, we also substract initDTS (some streams don't start @ PTS O)
        // and we ensure that computed value is greater or equal than sample DTS
        _sample.pts = Math.max(ptsNormalize(_sample.pts - initDTS, nextAvcDts), _sample.dts);
      }

      /* concatenate the video data and construct the mdat in place
        (need 8 more bytes to fill length and mpdat type) */
      var mdatSize = naluLen + 4 * nbNalu + 8;
      try {
        mdat = new Uint8Array(mdatSize);
      } catch (err) {
        this.observer.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MUX_ERROR, details: _errors.ErrorDetails.REMUX_ALLOC_ERROR, fatal: false, bytes: mdatSize, reason: 'fail allocating video mdat ' + mdatSize });
        return;
      }
      var view = new DataView(mdat.buffer);
      view.setUint32(0, mdatSize);
      mdat.set(_mp4Generator2.default.types.mdat, 4);

      for (var _i2 = 0; _i2 < nbSamples; _i2++) {
        var avcSample = inputSamples[_i2],
            avcSampleUnits = avcSample.units,
            mp4SampleLength = 0,
            compositionTimeOffset = void 0;
        // convert NALU bitstream to MP4 format (prepend NALU with size field)
        for (var _j = 0, _nbUnits = avcSampleUnits.length; _j < _nbUnits; _j++) {
          var unit = avcSampleUnits[_j],
              unitData = unit.data,
              unitDataLen = unit.data.byteLength;
          view.setUint32(offset, unitDataLen);
          offset += 4;
          mdat.set(unitData, offset);
          offset += unitDataLen;
          mp4SampleLength += 4 + unitDataLen;
        }

        if (!isSafari) {
          // expected sample duration is the Decoding Timestamp diff of consecutive samples
          if (_i2 < nbSamples - 1) {
            mp4SampleDuration = inputSamples[_i2 + 1].dts - avcSample.dts;
          } else {
            var config = this.config,
                lastFrameDuration = avcSample.dts - inputSamples[_i2 > 0 ? _i2 - 1 : _i2].dts;
            if (config.stretchShortVideoTrack) {
              // In some cases, a segment's audio track duration may exceed the video track duration.
              // Since we've already remuxed audio, and we know how long the audio track is, we look to
              // see if the delta to the next segment is longer than the minimum of maxBufferHole and
              // maxSeekHole. If so, playback would potentially get stuck, so we artificially inflate
              // the duration of the last frame to minimize any potential gap between segments.
              var maxBufferHole = config.maxBufferHole,
                  maxSeekHole = config.maxSeekHole,
                  gapTolerance = Math.floor(Math.min(maxBufferHole, maxSeekHole) * timeScale),
                  deltaToFrameEnd = (audioTrackLength ? firstPTS + audioTrackLength * timeScale : this.nextAudioPts) - avcSample.pts;
              if (deltaToFrameEnd > gapTolerance) {
                // We subtract lastFrameDuration from deltaToFrameEnd to try to prevent any video
                // frame overlap. maxBufferHole/maxSeekHole should be >> lastFrameDuration anyway.
                mp4SampleDuration = deltaToFrameEnd - lastFrameDuration;
                if (mp4SampleDuration < 0) {
                  mp4SampleDuration = lastFrameDuration;
                }
                _logger.logger.log('It is approximately ' + deltaToFrameEnd / 90 + ' ms to the next segment; using duration ' + mp4SampleDuration / 90 + ' ms for the last video frame.');
              } else {
                mp4SampleDuration = lastFrameDuration;
              }
            } else {
              mp4SampleDuration = lastFrameDuration;
            }
          }
          compositionTimeOffset = Math.round(avcSample.pts - avcSample.dts);
        } else {
          compositionTimeOffset = Math.max(0, mp4SampleDuration * Math.round((avcSample.pts - avcSample.dts) / mp4SampleDuration));
        }

        //console.log('PTS/DTS/initDTS/normPTS/normDTS/relative PTS : ${avcSample.pts}/${avcSample.dts}/${initDTS}/${ptsnorm}/${dtsnorm}/${(avcSample.pts/4294967296).toFixed(3)}');
        outputSamples.push({
          size: mp4SampleLength,
          // constant duration
          duration: mp4SampleDuration,
          cts: compositionTimeOffset,
          flags: {
            isLeading: 0,
            isDependedOn: 0,
            hasRedundancy: 0,
            degradPrio: 0,
            dependsOn: avcSample.key ? 2 : 1,
            isNonSync: avcSample.key ? 0 : 1
          }
        });
      }
      // next AVC sample DTS should be equal to last sample DTS + last sample duration (in PES timescale)
      this.nextAvcDts = lastDTS + mp4SampleDuration;
      var dropped = track.dropped;
      track.len = 0;
      track.nbNalu = 0;
      track.dropped = 0;
      if (outputSamples.length && navigator.userAgent.toLowerCase().indexOf('chrome') > -1) {
        var flags = outputSamples[0].flags;
        // chrome workaround, mark first sample as being a Random Access Point to avoid sourcebuffer append issue
        // https://code.google.com/p/chromium/issues/detail?id=229412
        flags.dependsOn = 2;
        flags.isNonSync = 0;
      }
      track.samples = outputSamples;
      moof = _mp4Generator2.default.moof(track.sequenceNumber++, firstDTS, track);
      track.samples = [];

      var data = {
        data1: moof,
        data2: mdat,
        startPTS: firstPTS / timeScale,
        endPTS: (lastPTS + mp4SampleDuration) / timeScale,
        startDTS: firstDTS / timeScale,
        endDTS: this.nextAvcDts / timeScale,
        type: 'video',
        nb: outputSamples.length,
        dropped: dropped
      };
      this.observer.trigger(_events2.default.FRAG_PARSING_DATA, data);
      return data;
    }
  }, {
    key: 'remuxAudio',
    value: function remuxAudio(track, timeOffset, contiguous, accurateTimeOffset) {
      var inputTimeScale = track.inputTimeScale,
          mp4timeScale = track.timescale,
          scaleFactor = inputTimeScale / mp4timeScale,
          mp4SampleDuration = track.isAAC ? 1024 : 1152,
          inputSampleDuration = mp4SampleDuration * scaleFactor,
          ptsNormalize = this._PTSNormalize,
          initDTS = this._initDTS,
          rawMPEG = !track.isAAC && this.typeSupported.mpeg;

      var view,
          offset = rawMPEG ? 0 : 8,
          audioSample,
          mp4Sample,
          unit,
          mdat,
          moof,
          firstPTS,
          firstDTS,
          lastDTS,
          pts,
          dts,
          ptsnorm,
          dtsnorm,
          outputSamples = [],
          inputSamples = [],
          fillFrame,
          newStamp,
          nextAudioPts;

      track.samples.sort(function (a, b) {
        return a.pts - b.pts;
      });
      inputSamples = track.samples;

      // for audio samples, also consider consecutive fragments as being contiguous (even if a level switch occurs),
      // for sake of clarity:
      // consecutive fragments are frags with
      //  - less than 100ms gaps between new time offset and next expected PTS OR
      //  - less than 20 audio frames distance
      // contiguous fragments are consecutive fragments from same quality level (same level, new SN = old SN + 1)
      // this helps ensuring audio continuity
      // and this also avoids audio glitches/cut when switching quality, or reporting wrong duration on first audio frame

      nextAudioPts = this.nextAudioPts;
      contiguous |= inputSamples.length && nextAudioPts && (Math.abs(timeOffset - nextAudioPts / inputTimeScale) < 0.1 || Math.abs(inputSamples[0].pts - nextAudioPts - initDTS) < 20 * inputSampleDuration);

      if (!contiguous) {
        // if fragments are not contiguous, let's use timeOffset to compute next Audio PTS
        nextAudioPts = timeOffset * inputTimeScale;
      }
      // If the audio track is missing samples, the frames seem to get "left-shifted" within the
      // resulting mp4 segment, causing sync issues and leaving gaps at the end of the audio segment.
      // In an effort to prevent this from happening, we inject frames here where there are gaps.
      // When possible, we inject a silent frame; when that's not possible, we duplicate the last
      // frame.

      // only inject/drop audio frames in case time offset is accurate
      if (accurateTimeOffset && track.isAAC) {
        for (var i = 0, nextPtsNorm = nextAudioPts; i < inputSamples.length;) {
          // First, let's see how far off this frame is from where we expect it to be
          var sample = inputSamples[i],
              ptsNorm = ptsNormalize(sample.pts - initDTS, nextAudioPts),
              delta = ptsNorm - nextPtsNorm;

          // If we're overlapping by more than a duration, drop this sample
          if (delta <= -inputSampleDuration) {
            _logger.logger.warn('Dropping 1 audio frame @ ' + (nextPtsNorm / inputTimeScale).toFixed(3) + 's due to ' + Math.abs(1000 * delta / inputTimeScale) + ' ms overlap.');
            inputSamples.splice(i, 1);
            track.len -= sample.unit.length;
            // Don't touch nextPtsNorm or i
          }

          // Insert missing frames if:
          // 1: We're more than one frame away
          // 2: Not more than # of samples away
          // 3: currentTime (aka nextPtsNorm) is not 0
          else if (delta >= inputSampleDuration && delta <= inputSamples.length * inputSampleDuration && nextPtsNorm) {
              var missing = Math.round(delta / inputSampleDuration);
              _logger.logger.warn('Injecting ' + missing + ' audio frame @ ' + (nextPtsNorm / inputTimeScale).toFixed(3) + 's due to ' + 1000 * delta / inputTimeScale + ' ms gap.');
              for (var j = 0; j < missing; j++) {
                newStamp = nextPtsNorm + initDTS;
                newStamp = Math.max(newStamp, initDTS);
                fillFrame = _aac2.default.getSilentFrame(track.manifestCodec || track.codec, track.channelCount);
                if (!fillFrame) {
                  _logger.logger.log('Unable to get silent frame for given audio codec; duplicating last frame instead.');
                  fillFrame = sample.unit.subarray();
                }
                inputSamples.splice(i, 0, { unit: fillFrame, pts: newStamp, dts: newStamp });
                track.len += fillFrame.length;
                nextPtsNorm += inputSampleDuration;
                i += 1;
              }

              // Adjust sample to next expected pts
              sample.pts = sample.dts = nextPtsNorm + initDTS;
              nextPtsNorm += inputSampleDuration;
              i += 1;
            }
            // Otherwise, just adjust pts
            else {
                if (Math.abs(delta) > 0.1 * inputSampleDuration) {
                  // logger.log(`Invalid frame delta ${Math.round(ptsNorm - nextPtsNorm + inputSampleDuration)} at PTS ${Math.round(ptsNorm / 90)} (should be ${Math.round(inputSampleDuration)}).`);
                }
                nextPtsNorm += inputSampleDuration;
                if (i === 0) {
                  sample.pts = sample.dts = initDTS + nextAudioPts;
                } else {
                  sample.pts = sample.dts = inputSamples[i - 1].pts + inputSampleDuration;
                }
                i += 1;
              }
        }
      }

      for (var _j2 = 0, _nbSamples = inputSamples.length; _j2 < _nbSamples; _j2++) {
        audioSample = inputSamples[_j2];
        unit = audioSample.unit;
        pts = audioSample.pts - initDTS;
        dts = audioSample.dts - initDTS;
        //logger.log(`Audio/PTS:${Math.round(pts/90)}`);
        // if not first sample
        if (lastDTS !== undefined) {
          ptsnorm = ptsNormalize(pts, lastDTS);
          dtsnorm = ptsNormalize(dts, lastDTS);
          mp4Sample.duration = Math.round((dtsnorm - lastDTS) / scaleFactor);
        } else {
          ptsnorm = ptsNormalize(pts, nextAudioPts);
          dtsnorm = ptsNormalize(dts, nextAudioPts);
          var _delta = Math.round(1000 * (ptsnorm - nextAudioPts) / inputTimeScale),
              numMissingFrames = 0;
          // if fragment are contiguous, detect hole/overlapping between fragments
          // contiguous fragments are consecutive fragments from same quality level (same level, new SN = old SN + 1)
          if (contiguous && track.isAAC) {
            // log delta
            if (_delta) {
              if (_delta > 0) {
                numMissingFrames = Math.round((ptsnorm - nextAudioPts) / inputSampleDuration);
                _logger.logger.log(_delta + ' ms hole between AAC samples detected,filling it');
                if (numMissingFrames > 0) {
                  fillFrame = _aac2.default.getSilentFrame(track.manifestCodec || track.codec, track.channelCount);
                  if (!fillFrame) {
                    fillFrame = unit.subarray();
                  }
                  track.len += numMissingFrames * fillFrame.length;
                }
                // if we have frame overlap, overlapping for more than half a frame duraion
              } else if (_delta < -12) {
                // drop overlapping audio frames... browser will deal with it
                _logger.logger.log(-_delta + ' ms overlapping between AAC samples detected, drop frame');
                track.len -= unit.byteLength;
                continue;
              }
              // set PTS/DTS to expected PTS/DTS
              ptsnorm = dtsnorm = nextAudioPts;
            }
          }
          // remember first PTS of our audioSamples, ensure value is positive
          firstPTS = Math.max(0, ptsnorm);
          firstDTS = Math.max(0, dtsnorm);
          if (track.len > 0) {
            /* concatenate the audio data and construct the mdat in place
              (need 8 more bytes to fill length and mdat type) */

            var mdatSize = rawMPEG ? track.len : track.len + 8;
            try {
              mdat = new Uint8Array(mdatSize);
            } catch (err) {
              this.observer.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MUX_ERROR, details: _errors.ErrorDetails.REMUX_ALLOC_ERROR, fatal: false, bytes: mdatSize, reason: 'fail allocating audio mdat ' + mdatSize });
              return;
            }
            if (!rawMPEG) {
              view = new DataView(mdat.buffer);
              view.setUint32(0, mdatSize);
              mdat.set(_mp4Generator2.default.types.mdat, 4);
            }
          } else {
            // no audio samples
            return;
          }
          for (var _i3 = 0; _i3 < numMissingFrames; _i3++) {
            newStamp = ptsnorm - (numMissingFrames - _i3) * inputSampleDuration;
            fillFrame = _aac2.default.getSilentFrame(track.manifestCodec || track.codec, track.channelCount);
            if (!fillFrame) {
              _logger.logger.log('Unable to get silent frame for given audio codec; duplicating this frame instead.');
              fillFrame = unit.subarray();
            }
            mdat.set(fillFrame, offset);
            offset += fillFrame.byteLength;
            mp4Sample = {
              size: fillFrame.byteLength,
              cts: 0,
              duration: 1024,
              flags: {
                isLeading: 0,
                isDependedOn: 0,
                hasRedundancy: 0,
                degradPrio: 0,
                dependsOn: 1
              }
            };
            outputSamples.push(mp4Sample);
          }
        }
        mdat.set(unit, offset);
        var unitLen = unit.byteLength;
        offset += unitLen;
        //console.log('PTS/DTS/initDTS/normPTS/normDTS/relative PTS : ${audioSample.pts}/${audioSample.dts}/${initDTS}/${ptsnorm}/${dtsnorm}/${(audioSample.pts/4294967296).toFixed(3)}');
        mp4Sample = {
          size: unitLen,
          cts: 0,
          duration: 0,
          flags: {
            isLeading: 0,
            isDependedOn: 0,
            hasRedundancy: 0,
            degradPrio: 0,
            dependsOn: 1
          }
        };
        outputSamples.push(mp4Sample);
        lastDTS = dtsnorm;
      }
      var lastSampleDuration = 0;
      var nbSamples = outputSamples.length;
      //set last sample duration as being identical to previous sample
      if (nbSamples >= 2) {
        lastSampleDuration = outputSamples[nbSamples - 2].duration;
        mp4Sample.duration = lastSampleDuration;
      }
      if (nbSamples) {
        // next audio sample PTS should be equal to last sample PTS + duration
        this.nextAudioPts = ptsnorm + scaleFactor * lastSampleDuration;
        //logger.log('Audio/PTS/PTSend:' + audioSample.pts.toFixed(0) + '/' + this.nextAacDts.toFixed(0));
        track.len = 0;
        track.samples = outputSamples;
        if (rawMPEG) {
          moof = new Uint8Array();
        } else {
          moof = _mp4Generator2.default.moof(track.sequenceNumber++, firstDTS / scaleFactor, track);
        }
        track.samples = [];
        var audioData = {
          data1: moof,
          data2: mdat,
          startPTS: firstPTS / inputTimeScale,
          endPTS: this.nextAudioPts / inputTimeScale,
          startDTS: firstDTS / inputTimeScale,
          endDTS: (dtsnorm + scaleFactor * lastSampleDuration) / inputTimeScale,
          type: 'audio',
          nb: nbSamples
        };
        this.observer.trigger(_events2.default.FRAG_PARSING_DATA, audioData);
        return audioData;
      }
      return null;
    }
  }, {
    key: 'remuxEmptyAudio',
    value: function remuxEmptyAudio(track, timeOffset, contiguous, videoData) {
      var inputTimeScale = track.inputTimeScale,
          mp4timeScale = track.samplerate ? track.samplerate : inputTimeScale,
          scaleFactor = inputTimeScale / mp4timeScale,
          nextAudioPts = this.nextAudioPts,


      // sync with video's timestamp
      startDTS = (nextAudioPts !== undefined ? nextAudioPts : videoData.startDTS * inputTimeScale) + this._initDTS,
          endDTS = videoData.endDTS * inputTimeScale + this._initDTS,

      // one sample's duration value
      sampleDuration = 1024,
          frameDuration = scaleFactor * sampleDuration,


      // samples count of this segment's duration
      nbSamples = Math.ceil((endDTS - startDTS) / frameDuration),


      // silent frame
      silentFrame = _aac2.default.getSilentFrame(track.manifestCodec || track.codec, track.channelCount);

      _logger.logger.warn('remux empty Audio');
      // Can't remux if we can't generate a silent frame...
      if (!silentFrame) {
        _logger.logger.trace('Unable to remuxEmptyAudio since we were unable to get a silent frame for given audio codec!');
        return;
      }

      var samples = [];
      for (var i = 0; i < nbSamples; i++) {
        var stamp = startDTS + i * frameDuration;
        samples.push({ unit: silentFrame, pts: stamp, dts: stamp });
        track.len += silentFrame.length;
      }
      track.samples = samples;

      this.remuxAudio(track, timeOffset, contiguous);
    }
  }, {
    key: 'remuxID3',
    value: function remuxID3(track, timeOffset) {
      var length = track.samples.length,
          sample;
      var inputTimeScale = track.inputTimeScale;
      var initPTS = this._initPTS;
      var initDTS = this._initDTS;
      // consume samples
      if (length) {
        for (var index = 0; index < length; index++) {
          sample = track.samples[index];
          // setting id3 pts, dts to relative time
          // using this._initPTS and this._initDTS to calculate relative time
          sample.pts = (sample.pts - initPTS) / inputTimeScale;
          sample.dts = (sample.dts - initDTS) / inputTimeScale;
        }
        this.observer.trigger(_events2.default.FRAG_PARSING_METADATA, {
          samples: track.samples
        });
      }

      track.samples = [];
      timeOffset = timeOffset;
    }
  }, {
    key: 'remuxText',
    value: function remuxText(track, timeOffset) {
      track.samples.sort(function (a, b) {
        return a.pts - b.pts;
      });

      var length = track.samples.length,
          sample;
      var inputTimeScale = track.inputTimeScale;
      var initPTS = this._initPTS;
      // consume samples
      if (length) {
        for (var index = 0; index < length; index++) {
          sample = track.samples[index];
          // setting text pts, dts to relative time
          // using this._initPTS and this._initDTS to calculate relative time
          sample.pts = (sample.pts - initPTS) / inputTimeScale;
        }
        this.observer.trigger(_events2.default.FRAG_PARSING_USERDATA, {
          samples: track.samples
        });
      }

      track.samples = [];
      timeOffset = timeOffset;
    }
  }, {
    key: '_PTSNormalize',
    value: function _PTSNormalize(value, reference) {
      var offset;
      if (reference === undefined) {
        return value;
      }
      if (reference < value) {
        // - 2^33
        offset = -8589934592;
      } else {
        // + 2^33
        offset = 8589934592;
      }
      /* PTS is 33bit (from 0 to 2^33 -1)
        if diff between value and reference is bigger than half of the amplitude (2^32) then it means that
        PTS looping occured. fill the gap */
      while (Math.abs(value - reference) > 4294967296) {
        value += offset;
      }
      return value;
    }
  }]);

  return MP4Remuxer;
}();

exports.default = MP4Remuxer;

},{"../errors":30,"../events":32,"../helper/aac":33,"../remux/mp4-generator":41,"../utils/logger":51}],43:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * passthrough remuxer
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */


var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var PassThroughRemuxer = function () {
  function PassThroughRemuxer(observer) {
    _classCallCheck(this, PassThroughRemuxer);

    this.observer = observer;
  }

  _createClass(PassThroughRemuxer, [{
    key: 'destroy',
    value: function destroy() {}
  }, {
    key: 'resetTimeStamp',
    value: function resetTimeStamp() {}
  }, {
    key: 'resetInitSegment',
    value: function resetInitSegment() {}
  }, {
    key: 'remux',
    value: function remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset, rawData) {
      var observer = this.observer;
      var streamType = '';
      if (audioTrack) {
        streamType += 'audio';
      }
      if (videoTrack) {
        streamType += 'video';
      }
      observer.trigger(_events2.default.FRAG_PARSING_DATA, {
        data1: rawData,
        startPTS: timeOffset,
        startDTS: timeOffset,
        type: streamType,
        nb: 1,
        dropped: 0
      });
      //notify end of parsing
      observer.trigger(_events2.default.FRAG_PARSED);
    }
  }]);

  return PassThroughRemuxer;
}();

exports.default = PassThroughRemuxer;

},{"../events":32}],44:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var DECIMAL_RESOLUTION_REGEX = /^(\d+)x(\d+)$/;
var ATTR_LIST_REGEX = /\s*(.+?)\s*=((?:\".*?\")|.*?)(?:,|$)/g;

// adapted from https://github.com/kanongil/node-m3u8parse/blob/master/attrlist.js

var AttrList = function () {
  function AttrList(attrs) {
    _classCallCheck(this, AttrList);

    if (typeof attrs === 'string') {
      attrs = AttrList.parseAttrList(attrs);
    }
    for (var attr in attrs) {
      if (attrs.hasOwnProperty(attr)) {
        this[attr] = attrs[attr];
      }
    }
  }

  _createClass(AttrList, [{
    key: 'decimalInteger',
    value: function decimalInteger(attrName) {
      var intValue = parseInt(this[attrName], 10);
      if (intValue > Number.MAX_SAFE_INTEGER) {
        return Infinity;
      }
      return intValue;
    }
  }, {
    key: 'hexadecimalInteger',
    value: function hexadecimalInteger(attrName) {
      if (this[attrName]) {
        var stringValue = (this[attrName] || '0x').slice(2);
        stringValue = (stringValue.length & 1 ? '0' : '') + stringValue;

        var value = new Uint8Array(stringValue.length / 2);
        for (var i = 0; i < stringValue.length / 2; i++) {
          value[i] = parseInt(stringValue.slice(i * 2, i * 2 + 2), 16);
        }
        return value;
      } else {
        return null;
      }
    }
  }, {
    key: 'hexadecimalIntegerAsNumber',
    value: function hexadecimalIntegerAsNumber(attrName) {
      var intValue = parseInt(this[attrName], 16);
      if (intValue > Number.MAX_SAFE_INTEGER) {
        return Infinity;
      }
      return intValue;
    }
  }, {
    key: 'decimalFloatingPoint',
    value: function decimalFloatingPoint(attrName) {
      return parseFloat(this[attrName]);
    }
  }, {
    key: 'enumeratedString',
    value: function enumeratedString(attrName) {
      return this[attrName];
    }
  }, {
    key: 'decimalResolution',
    value: function decimalResolution(attrName) {
      var res = DECIMAL_RESOLUTION_REGEX.exec(this[attrName]);
      if (res === null) {
        return undefined;
      }
      return {
        width: parseInt(res[1], 10),
        height: parseInt(res[2], 10)
      };
    }
  }], [{
    key: 'parseAttrList',
    value: function parseAttrList(input) {
      var match,
          attrs = {};
      ATTR_LIST_REGEX.lastIndex = 0;
      while ((match = ATTR_LIST_REGEX.exec(input)) !== null) {
        var value = match[2],
            quote = '"';

        if (value.indexOf(quote) === 0 && value.lastIndexOf(quote) === value.length - 1) {
          value = value.slice(1, -1);
        }
        attrs[match[1]] = value;
      }
      return attrs;
    }
  }]);

  return AttrList;
}();

exports.default = AttrList;

},{}],45:[function(require,module,exports){
"use strict";

var BinarySearch = {
    /**
     * Searches for an item in an array which matches a certain condition.
     * This requires the condition to only match one item in the array,
     * and for the array to be ordered.
     *
     * @param {Array} list The array to search.
     * @param {Function} comparisonFunction
     *      Called and provided a candidate item as the first argument.
     *      Should return:
     *          > -1 if the item should be located at a lower index than the provided item.
     *          > 1 if the item should be located at a higher index than the provided item.
     *          > 0 if the item is the item you're looking for.
     *
     * @return {*} The object if it is found or null otherwise.
     */
    search: function search(list, comparisonFunction) {
        var minIndex = 0;
        var maxIndex = list.length - 1;
        var currentIndex = null;
        var currentElement = null;

        while (minIndex <= maxIndex) {
            currentIndex = (minIndex + maxIndex) / 2 | 0;
            currentElement = list[currentIndex];

            var comparisonResult = comparisonFunction(currentElement);
            if (comparisonResult > 0) {
                minIndex = currentIndex + 1;
            } else if (comparisonResult < 0) {
                maxIndex = currentIndex - 1;
            } else {
                return currentElement;
            }
        }

        return null;
    }
};

module.exports = BinarySearch;

},{}],46:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 *
 * This code was ported from the dash.js project at:
 *   https://github.com/Dash-Industry-Forum/dash.js/blob/development/externals/cea608-parser.js
 *   https://github.com/Dash-Industry-Forum/dash.js/commit/8269b26a761e0853bb21d78780ed945144ecdd4d#diff-71bc295a2d6b6b7093a1d3290d53a4b2
 *
 * The original copyright appears below:
 *
 * The copyright in this software is being made available under the BSD License,
 * included below. This software may be subject to other third party and contributor
 * rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2015-2016, DASH Industry Forum.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *  1. Redistributions of source code must retain the above copyright notice, this
 *  list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *  this list of conditions and the following disclaimer in the documentation and/or
 *  other materials provided with the distribution.
 *  2. Neither the name of Dash Industry Forum nor the names of its
 *  contributors may be used to endorse or promote products derived from this software
 *  without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY
 *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 *  POSSIBILITY OF SUCH DAMAGE.
 */
/**
 *  Exceptions from regular ASCII. CodePoints are mapped to UTF-16 codes
 */

var specialCea608CharsCodes = {
    0x2a: 0xe1, // lowercase a, acute accent
    0x5c: 0xe9, // lowercase e, acute accent
    0x5e: 0xed, // lowercase i, acute accent
    0x5f: 0xf3, // lowercase o, acute accent
    0x60: 0xfa, // lowercase u, acute accent
    0x7b: 0xe7, // lowercase c with cedilla
    0x7c: 0xf7, // division symbol
    0x7d: 0xd1, // uppercase N tilde
    0x7e: 0xf1, // lowercase n tilde
    0x7f: 0x2588, // Full block
    // THIS BLOCK INCLUDES THE 16 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS
    // THAT COME FROM HI BYTE=0x11 AND LOW BETWEEN 0x30 AND 0x3F
    // THIS MEANS THAT \x50 MUST BE ADDED TO THE VALUES
    0x80: 0xae, // Registered symbol (R)
    0x81: 0xb0, // degree sign
    0x82: 0xbd, // 1/2 symbol
    0x83: 0xbf, // Inverted (open) question mark
    0x84: 0x2122, // Trademark symbol (TM)
    0x85: 0xa2, // Cents symbol
    0x86: 0xa3, // Pounds sterling
    0x87: 0x266a, // Music 8'th note
    0x88: 0xe0, // lowercase a, grave accent
    0x89: 0x20, // transparent space (regular)
    0x8a: 0xe8, // lowercase e, grave accent
    0x8b: 0xe2, // lowercase a, circumflex accent
    0x8c: 0xea, // lowercase e, circumflex accent
    0x8d: 0xee, // lowercase i, circumflex accent
    0x8e: 0xf4, // lowercase o, circumflex accent
    0x8f: 0xfb, // lowercase u, circumflex accent
    // THIS BLOCK INCLUDES THE 32 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS
    // THAT COME FROM HI BYTE=0x12 AND LOW BETWEEN 0x20 AND 0x3F
    0x90: 0xc1, // capital letter A with acute
    0x91: 0xc9, // capital letter E with acute
    0x92: 0xd3, // capital letter O with acute
    0x93: 0xda, // capital letter U with acute
    0x94: 0xdc, // capital letter U with diaresis
    0x95: 0xfc, // lowercase letter U with diaeresis
    0x96: 0x2018, // opening single quote
    0x97: 0xa1, // inverted exclamation mark
    0x98: 0x2a, // asterisk
    0x99: 0x2019, // closing single quote
    0x9a: 0x2501, // box drawings heavy horizontal
    0x9b: 0xa9, // copyright sign
    0x9c: 0x2120, // Service mark
    0x9d: 0x2022, // (round) bullet
    0x9e: 0x201c, // Left double quotation mark
    0x9f: 0x201d, // Right double quotation mark
    0xa0: 0xc0, // uppercase A, grave accent
    0xa1: 0xc2, // uppercase A, circumflex
    0xa2: 0xc7, // uppercase C with cedilla
    0xa3: 0xc8, // uppercase E, grave accent
    0xa4: 0xca, // uppercase E, circumflex
    0xa5: 0xcb, // capital letter E with diaresis
    0xa6: 0xeb, // lowercase letter e with diaresis
    0xa7: 0xce, // uppercase I, circumflex
    0xa8: 0xcf, // uppercase I, with diaresis
    0xa9: 0xef, // lowercase i, with diaresis
    0xaa: 0xd4, // uppercase O, circumflex
    0xab: 0xd9, // uppercase U, grave accent
    0xac: 0xf9, // lowercase u, grave accent
    0xad: 0xdb, // uppercase U, circumflex
    0xae: 0xab, // left-pointing double angle quotation mark
    0xaf: 0xbb, // right-pointing double angle quotation mark
    // THIS BLOCK INCLUDES THE 32 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS
    // THAT COME FROM HI BYTE=0x13 AND LOW BETWEEN 0x20 AND 0x3F
    0xb0: 0xc3, // Uppercase A, tilde
    0xb1: 0xe3, // Lowercase a, tilde
    0xb2: 0xcd, // Uppercase I, acute accent
    0xb3: 0xcc, // Uppercase I, grave accent
    0xb4: 0xec, // Lowercase i, grave accent
    0xb5: 0xd2, // Uppercase O, grave accent
    0xb6: 0xf2, // Lowercase o, grave accent
    0xb7: 0xd5, // Uppercase O, tilde
    0xb8: 0xf5, // Lowercase o, tilde
    0xb9: 0x7b, // Open curly brace
    0xba: 0x7d, // Closing curly brace
    0xbb: 0x5c, // Backslash
    0xbc: 0x5e, // Caret
    0xbd: 0x5f, // Underscore
    0xbe: 0x7c, // Pipe (vertical line)
    0xbf: 0x223c, // Tilde operator
    0xc0: 0xc4, // Uppercase A, umlaut
    0xc1: 0xe4, // Lowercase A, umlaut
    0xc2: 0xd6, // Uppercase O, umlaut
    0xc3: 0xf6, // Lowercase o, umlaut
    0xc4: 0xdf, // Esszett (sharp S)
    0xc5: 0xa5, // Yen symbol
    0xc6: 0xa4, // Generic currency sign
    0xc7: 0x2503, // Box drawings heavy vertical
    0xc8: 0xc5, // Uppercase A, ring
    0xc9: 0xe5, // Lowercase A, ring
    0xca: 0xd8, // Uppercase O, stroke
    0xcb: 0xf8, // Lowercase o, strok
    0xcc: 0x250f, // Box drawings heavy down and right
    0xcd: 0x2513, // Box drawings heavy down and left
    0xce: 0x2517, // Box drawings heavy up and right
    0xcf: 0x251b // Box drawings heavy up and left
};

/**
 * Utils
 */
var getCharForByte = function getCharForByte(byte) {
    var charCode = byte;
    if (specialCea608CharsCodes.hasOwnProperty(byte)) {
        charCode = specialCea608CharsCodes[byte];
    }
    return String.fromCharCode(charCode);
};

var NR_ROWS = 15,
    NR_COLS = 100;
// Tables to look up row from PAC data
var rowsLowCh1 = { 0x11: 1, 0x12: 3, 0x15: 5, 0x16: 7, 0x17: 9, 0x10: 11, 0x13: 12, 0x14: 14 };
var rowsHighCh1 = { 0x11: 2, 0x12: 4, 0x15: 6, 0x16: 8, 0x17: 10, 0x13: 13, 0x14: 15 };
var rowsLowCh2 = { 0x19: 1, 0x1A: 3, 0x1D: 5, 0x1E: 7, 0x1F: 9, 0x18: 11, 0x1B: 12, 0x1C: 14 };
var rowsHighCh2 = { 0x19: 2, 0x1A: 4, 0x1D: 6, 0x1E: 8, 0x1F: 10, 0x1B: 13, 0x1C: 15 };

var backgroundColors = ['white', 'green', 'blue', 'cyan', 'red', 'yellow', 'magenta', 'black', 'transparent'];

/**
 * Simple logger class to be able to write with time-stamps and filter on level.
 */
var logger = {
    verboseFilter: { 'DATA': 3, 'DEBUG': 3, 'INFO': 2, 'WARNING': 2, 'TEXT': 1, 'ERROR': 0 },
    time: null,
    verboseLevel: 0, // Only write errors
    setTime: function setTime(newTime) {
        this.time = newTime;
    },
    log: function log(severity, msg) {
        var minLevel = this.verboseFilter[severity];
        if (this.verboseLevel >= minLevel) {
            console.log(this.time.toFixed(3) + ' [' + severity + '] ' + msg);
        }
    }
};

var numArrayToHexArray = function numArrayToHexArray(numArray) {
    var hexArray = [];
    for (var j = 0; j < numArray.length; j++) {
        hexArray.push(numArray[j].toString(16));
    }
    return hexArray;
};

var PenState = function () {
    function PenState(foreground, underline, italics, background, flash) {
        _classCallCheck(this, PenState);

        this.foreground = foreground || 'white';
        this.underline = underline || false;
        this.italics = italics || false;
        this.background = background || 'black';
        this.flash = flash || false;
    }

    _createClass(PenState, [{
        key: 'reset',
        value: function reset() {
            this.foreground = 'white';
            this.underline = false;
            this.italics = false;
            this.background = 'black';
            this.flash = false;
        }
    }, {
        key: 'setStyles',
        value: function setStyles(styles) {
            var attribs = ['foreground', 'underline', 'italics', 'background', 'flash'];
            for (var i = 0; i < attribs.length; i++) {
                var style = attribs[i];
                if (styles.hasOwnProperty(style)) {
                    this[style] = styles[style];
                }
            }
        }
    }, {
        key: 'isDefault',
        value: function isDefault() {
            return this.foreground === 'white' && !this.underline && !this.italics && this.background === 'black' && !this.flash;
        }
    }, {
        key: 'equals',
        value: function equals(other) {
            return this.foreground === other.foreground && this.underline === other.underline && this.italics === other.italics && this.background === other.background && this.flash === other.flash;
        }
    }, {
        key: 'copy',
        value: function copy(newPenState) {
            this.foreground = newPenState.foreground;
            this.underline = newPenState.underline;
            this.italics = newPenState.italics;
            this.background = newPenState.background;
            this.flash = newPenState.flash;
        }
    }, {
        key: 'toString',
        value: function toString() {
            return 'color=' + this.foreground + ', underline=' + this.underline + ', italics=' + this.italics + ', background=' + this.background + ', flash=' + this.flash;
        }
    }]);

    return PenState;
}();

/**
 * Unicode character with styling and background.
 * @constructor
 */


var StyledUnicodeChar = function () {
    function StyledUnicodeChar(uchar, foreground, underline, italics, background, flash) {
        _classCallCheck(this, StyledUnicodeChar);

        this.uchar = uchar || ' '; // unicode character
        this.penState = new PenState(foreground, underline, italics, background, flash);
    }

    _createClass(StyledUnicodeChar, [{
        key: 'reset',
        value: function reset() {
            this.uchar = ' ';
            this.penState.reset();
        }
    }, {
        key: 'setChar',
        value: function setChar(uchar, newPenState) {
            this.uchar = uchar;
            this.penState.copy(newPenState);
        }
    }, {
        key: 'setPenState',
        value: function setPenState(newPenState) {
            this.penState.copy(newPenState);
        }
    }, {
        key: 'equals',
        value: function equals(other) {
            return this.uchar === other.uchar && this.penState.equals(other.penState);
        }
    }, {
        key: 'copy',
        value: function copy(newChar) {
            this.uchar = newChar.uchar;
            this.penState.copy(newChar.penState);
        }
    }, {
        key: 'isEmpty',
        value: function isEmpty() {
            return this.uchar === ' ' && this.penState.isDefault();
        }
    }]);

    return StyledUnicodeChar;
}();

/**
 * CEA-608 row consisting of NR_COLS instances of StyledUnicodeChar.
 * @constructor
 */


var Row = function () {
    function Row() {
        _classCallCheck(this, Row);

        this.chars = [];
        for (var i = 0; i < NR_COLS; i++) {
            this.chars.push(new StyledUnicodeChar());
        }
        this.pos = 0;
        this.currPenState = new PenState();
    }

    _createClass(Row, [{
        key: 'equals',
        value: function equals(other) {
            var equal = true;
            for (var i = 0; i < NR_COLS; i++) {
                if (!this.chars[i].equals(other.chars[i])) {
                    equal = false;
                    break;
                }
            }
            return equal;
        }
    }, {
        key: 'copy',
        value: function copy(other) {
            for (var i = 0; i < NR_COLS; i++) {
                this.chars[i].copy(other.chars[i]);
            }
        }
    }, {
        key: 'isEmpty',
        value: function isEmpty() {
            var empty = true;
            for (var i = 0; i < NR_COLS; i++) {
                if (!this.chars[i].isEmpty()) {
                    empty = false;
                    break;
                }
            }
            return empty;
        }

        /**
         *  Set the cursor to a valid column.
         */

    }, {
        key: 'setCursor',
        value: function setCursor(absPos) {
            if (this.pos !== absPos) {
                this.pos = absPos;
            }
            if (this.pos < 0) {
                logger.log('ERROR', 'Negative cursor position ' + this.pos);
                this.pos = 0;
            } else if (this.pos > NR_COLS) {
                logger.log('ERROR', 'Too large cursor position ' + this.pos);
                this.pos = NR_COLS;
            }
        }

        /**
         * Move the cursor relative to current position.
         */

    }, {
        key: 'moveCursor',
        value: function moveCursor(relPos) {
            var newPos = this.pos + relPos;
            if (relPos > 1) {
                for (var i = this.pos + 1; i < newPos + 1; i++) {
                    this.chars[i].setPenState(this.currPenState);
                }
            }
            this.setCursor(newPos);
        }

        /**
         * Backspace, move one step back and clear character.
         */

    }, {
        key: 'backSpace',
        value: function backSpace() {
            this.moveCursor(-1);
            this.chars[this.pos].setChar(' ', this.currPenState);
        }
    }, {
        key: 'insertChar',
        value: function insertChar(byte) {
            if (byte >= 0x90) {
                //Extended char
                this.backSpace();
            }
            var char = getCharForByte(byte);
            if (this.pos >= NR_COLS) {
                logger.log('WARNING', 'Cannot insert ' + byte.toString(16) + ' (' + char + ') at position ' + this.pos + '. Skipping it!');
                return;
            }
            this.chars[this.pos].setChar(char, this.currPenState);
            this.moveCursor(1);
        }
    }, {
        key: 'clearFromPos',
        value: function clearFromPos(startPos) {
            var i;
            for (i = startPos; i < NR_COLS; i++) {
                this.chars[i].reset();
            }
        }
    }, {
        key: 'clear',
        value: function clear() {
            this.clearFromPos(0);
            this.pos = 0;
            this.currPenState.reset();
        }
    }, {
        key: 'clearToEndOfRow',
        value: function clearToEndOfRow() {
            this.clearFromPos(this.pos);
        }
    }, {
        key: 'getTextString',
        value: function getTextString() {
            var chars = [];
            var empty = true;
            for (var i = 0; i < NR_COLS; i++) {
                var char = this.chars[i].uchar;
                if (char !== ' ') {
                    empty = false;
                }
                chars.push(char);
            }
            if (empty) {
                return '';
            } else {
                return chars.join('');
            }
        }
    }, {
        key: 'setPenStyles',
        value: function setPenStyles(styles) {
            this.currPenState.setStyles(styles);
            var currChar = this.chars[this.pos];
            currChar.setPenState(this.currPenState);
        }
    }]);

    return Row;
}();

/**
 * Keep a CEA-608 screen of 32x15 styled characters
 * @constructor
*/


var CaptionScreen = function () {
    function CaptionScreen() {
        _classCallCheck(this, CaptionScreen);

        this.rows = [];
        for (var i = 0; i < NR_ROWS; i++) {
            this.rows.push(new Row()); // Note that we use zero-based numbering (0-14)
        }
        this.currRow = NR_ROWS - 1;
        this.nrRollUpRows = null;
        this.reset();
    }

    _createClass(CaptionScreen, [{
        key: 'reset',
        value: function reset() {
            for (var i = 0; i < NR_ROWS; i++) {
                this.rows[i].clear();
            }
            this.currRow = NR_ROWS - 1;
        }
    }, {
        key: 'equals',
        value: function equals(other) {
            var equal = true;
            for (var i = 0; i < NR_ROWS; i++) {
                if (!this.rows[i].equals(other.rows[i])) {
                    equal = false;
                    break;
                }
            }
            return equal;
        }
    }, {
        key: 'copy',
        value: function copy(other) {
            for (var i = 0; i < NR_ROWS; i++) {
                this.rows[i].copy(other.rows[i]);
            }
        }
    }, {
        key: 'isEmpty',
        value: function isEmpty() {
            var empty = true;
            for (var i = 0; i < NR_ROWS; i++) {
                if (!this.rows[i].isEmpty()) {
                    empty = false;
                    break;
                }
            }
            return empty;
        }
    }, {
        key: 'backSpace',
        value: function backSpace() {
            var row = this.rows[this.currRow];
            row.backSpace();
        }
    }, {
        key: 'clearToEndOfRow',
        value: function clearToEndOfRow() {
            var row = this.rows[this.currRow];
            row.clearToEndOfRow();
        }

        /**
         * Insert a character (without styling) in the current row.
         */

    }, {
        key: 'insertChar',
        value: function insertChar(char) {
            var row = this.rows[this.currRow];
            row.insertChar(char);
        }
    }, {
        key: 'setPen',
        value: function setPen(styles) {
            var row = this.rows[this.currRow];
            row.setPenStyles(styles);
        }
    }, {
        key: 'moveCursor',
        value: function moveCursor(relPos) {
            var row = this.rows[this.currRow];
            row.moveCursor(relPos);
        }
    }, {
        key: 'setCursor',
        value: function setCursor(absPos) {
            logger.log('INFO', 'setCursor: ' + absPos);
            var row = this.rows[this.currRow];
            row.setCursor(absPos);
        }
    }, {
        key: 'setPAC',
        value: function setPAC(pacData) {
            logger.log('INFO', 'pacData = ' + JSON.stringify(pacData));
            var newRow = pacData.row - 1;
            if (this.nrRollUpRows && newRow < this.nrRollUpRows - 1) {
                newRow = this.nrRollUpRows - 1;
            }

            //Make sure this only affects Roll-up Captions by checking this.nrRollUpRows
            if (this.nrRollUpRows && this.currRow !== newRow) {
                //clear all rows first
                for (var i = 0; i < NR_ROWS; i++) {
                    this.rows[i].clear();
                }

                //Copy this.nrRollUpRows rows from lastOutputScreen and place it in the newRow location
                //topRowIndex - the start of rows to copy (inclusive index)
                var topRowIndex = this.currRow + 1 - this.nrRollUpRows;
                //We only copy if the last position was already shown.
                //We use the cueStartTime value to check this.
                var lastOutputScreen = this.lastOutputScreen;
                if (lastOutputScreen) {
                    var prevLineTime = lastOutputScreen.rows[topRowIndex].cueStartTime;
                    if (prevLineTime && prevLineTime < logger.time) {
                        for (var _i = 0; _i < this.nrRollUpRows; _i++) {
                            this.rows[newRow - this.nrRollUpRows + _i + 1].copy(lastOutputScreen.rows[topRowIndex + _i]);
                        }
                    }
                }
            }

            this.currRow = newRow;
            var row = this.rows[this.currRow];
            if (pacData.indent !== null) {
                var indent = pacData.indent;
                var prevPos = Math.max(indent - 1, 0);
                row.setCursor(pacData.indent);
                pacData.color = row.chars[prevPos].penState.foreground;
            }
            var styles = { foreground: pacData.color, underline: pacData.underline, italics: pacData.italics, background: 'black', flash: false };
            this.setPen(styles);
        }

        /**
         * Set background/extra foreground, but first do back_space, and then insert space (backwards compatibility).
         */

    }, {
        key: 'setBkgData',
        value: function setBkgData(bkgData) {

            logger.log('INFO', 'bkgData = ' + JSON.stringify(bkgData));
            this.backSpace();
            this.setPen(bkgData);
            this.insertChar(0x20); //Space
        }
    }, {
        key: 'setRollUpRows',
        value: function setRollUpRows(nrRows) {
            this.nrRollUpRows = nrRows;
        }
    }, {
        key: 'rollUp',
        value: function rollUp() {
            if (this.nrRollUpRows === null) {
                logger.log('DEBUG', 'roll_up but nrRollUpRows not set yet');
                return; //Not properly setup
            }
            logger.log('TEXT', this.getDisplayText());
            var topRowIndex = this.currRow + 1 - this.nrRollUpRows;
            var topRow = this.rows.splice(topRowIndex, 1)[0];
            topRow.clear();
            this.rows.splice(this.currRow, 0, topRow);
            logger.log('INFO', 'Rolling up');
            //logger.log('TEXT', this.get_display_text())
        }

        /**
         * Get all non-empty rows with as unicode text.
         */

    }, {
        key: 'getDisplayText',
        value: function getDisplayText(asOneRow) {
            asOneRow = asOneRow || false;
            var displayText = [];
            var text = '';
            var rowNr = -1;
            for (var i = 0; i < NR_ROWS; i++) {
                var rowText = this.rows[i].getTextString();
                if (rowText) {
                    rowNr = i + 1;
                    if (asOneRow) {
                        displayText.push('Row ' + rowNr + ': \'' + rowText + '\'');
                    } else {
                        displayText.push(rowText.trim());
                    }
                }
            }
            if (displayText.length > 0) {
                if (asOneRow) {
                    text = '[' + displayText.join(' | ') + ']';
                } else {
                    text = displayText.join('\n');
                }
            }
            return text;
        }
    }, {
        key: 'getTextAndFormat',
        value: function getTextAndFormat() {
            return this.rows;
        }
    }]);

    return CaptionScreen;
}();

//var modes = ['MODE_ROLL-UP', 'MODE_POP-ON', 'MODE_PAINT-ON', 'MODE_TEXT'];

var Cea608Channel = function () {
    function Cea608Channel(channelNumber, outputFilter) {
        _classCallCheck(this, Cea608Channel);

        this.chNr = channelNumber;
        this.outputFilter = outputFilter;
        this.mode = null;
        this.verbose = 0;
        this.displayedMemory = new CaptionScreen();
        this.nonDisplayedMemory = new CaptionScreen();
        this.lastOutputScreen = new CaptionScreen();
        this.currRollUpRow = this.displayedMemory.rows[NR_ROWS - 1];
        this.writeScreen = this.displayedMemory;
        this.mode = null;
        this.cueStartTime = null; // Keeps track of where a cue started.
    }

    _createClass(Cea608Channel, [{
        key: 'reset',
        value: function reset() {
            this.mode = null;
            this.displayedMemory.reset();
            this.nonDisplayedMemory.reset();
            this.lastOutputScreen.reset();
            this.currRollUpRow = this.displayedMemory.rows[NR_ROWS - 1];
            this.writeScreen = this.displayedMemory;
            this.mode = null;
            this.cueStartTime = null;
            this.lastCueEndTime = null;
        }
    }, {
        key: 'getHandler',
        value: function getHandler() {
            return this.outputFilter;
        }
    }, {
        key: 'setHandler',
        value: function setHandler(newHandler) {
            this.outputFilter = newHandler;
        }
    }, {
        key: 'setPAC',
        value: function setPAC(pacData) {
            this.writeScreen.setPAC(pacData);
        }
    }, {
        key: 'setBkgData',
        value: function setBkgData(bkgData) {
            this.writeScreen.setBkgData(bkgData);
        }
    }, {
        key: 'setMode',
        value: function setMode(newMode) {
            if (newMode === this.mode) {
                return;
            }
            this.mode = newMode;
            logger.log('INFO', 'MODE=' + newMode);
            if (this.mode === 'MODE_POP-ON') {
                this.writeScreen = this.nonDisplayedMemory;
            } else {
                this.writeScreen = this.displayedMemory;
                this.writeScreen.reset();
            }
            if (this.mode !== 'MODE_ROLL-UP') {
                this.displayedMemory.nrRollUpRows = null;
                this.nonDisplayedMemory.nrRollUpRows = null;
            }
            this.mode = newMode;
        }
    }, {
        key: 'insertChars',
        value: function insertChars(chars) {
            for (var i = 0; i < chars.length; i++) {
                this.writeScreen.insertChar(chars[i]);
            }
            var screen = this.writeScreen === this.displayedMemory ? 'DISP' : 'NON_DISP';
            logger.log('INFO', screen + ': ' + this.writeScreen.getDisplayText(true));
            if (this.mode === 'MODE_PAINT-ON' || this.mode === 'MODE_ROLL-UP') {
                logger.log('TEXT', 'DISPLAYED: ' + this.displayedMemory.getDisplayText(true));
                this.outputDataUpdate();
            }
        }
    }, {
        key: 'ccRCL',
        value: function ccRCL() {
            // Resume Caption Loading (switch mode to Pop On)
            logger.log('INFO', 'RCL - Resume Caption Loading');
            this.setMode('MODE_POP-ON');
        }
    }, {
        key: 'ccBS',
        value: function ccBS() {
            // BackSpace
            logger.log('INFO', 'BS - BackSpace');
            if (this.mode === 'MODE_TEXT') {
                return;
            }
            this.writeScreen.backSpace();
            if (this.writeScreen === this.displayedMemory) {
                this.outputDataUpdate();
            }
        }
    }, {
        key: 'ccAOF',
        value: function ccAOF() {
            // Reserved (formerly Alarm Off)
            return;
        }
    }, {
        key: 'ccAON',
        value: function ccAON() {
            // Reserved (formerly Alarm On)
            return;
        }
    }, {
        key: 'ccDER',
        value: function ccDER() {
            // Delete to End of Row
            logger.log('INFO', 'DER- Delete to End of Row');
            this.writeScreen.clearToEndOfRow();
            this.outputDataUpdate();
        }
    }, {
        key: 'ccRU',
        value: function ccRU(nrRows) {
            //Roll-Up Captions-2,3,or 4 Rows
            logger.log('INFO', 'RU(' + nrRows + ') - Roll Up');
            this.writeScreen = this.displayedMemory;
            this.setMode('MODE_ROLL-UP');
            this.writeScreen.setRollUpRows(nrRows);
        }
    }, {
        key: 'ccFON',
        value: function ccFON() {
            //Flash On
            logger.log('INFO', 'FON - Flash On');
            this.writeScreen.setPen({ flash: true });
        }
    }, {
        key: 'ccRDC',
        value: function ccRDC() {
            // Resume Direct Captioning (switch mode to PaintOn)
            logger.log('INFO', 'RDC - Resume Direct Captioning');
            this.setMode('MODE_PAINT-ON');
        }
    }, {
        key: 'ccTR',
        value: function ccTR() {
            // Text Restart in text mode (not supported, however)
            logger.log('INFO', 'TR');
            this.setMode('MODE_TEXT');
        }
    }, {
        key: 'ccRTD',
        value: function ccRTD() {
            // Resume Text Display in Text mode (not supported, however)
            logger.log('INFO', 'RTD');
            this.setMode('MODE_TEXT');
        }
    }, {
        key: 'ccEDM',
        value: function ccEDM() {
            // Erase Displayed Memory
            logger.log('INFO', 'EDM - Erase Displayed Memory');
            this.displayedMemory.reset();
            this.outputDataUpdate();
        }
    }, {
        key: 'ccCR',
        value: function ccCR() {
            // Carriage Return
            logger.log('CR - Carriage Return');
            this.writeScreen.rollUp();
            this.outputDataUpdate();
        }
    }, {
        key: 'ccENM',
        value: function ccENM() {
            //Erase Non-Displayed Memory
            logger.log('INFO', 'ENM - Erase Non-displayed Memory');
            this.nonDisplayedMemory.reset();
        }
    }, {
        key: 'ccEOC',
        value: function ccEOC() {
            //End of Caption (Flip Memories)
            logger.log('INFO', 'EOC - End Of Caption');
            if (this.mode === 'MODE_POP-ON') {
                var tmp = this.displayedMemory;
                this.displayedMemory = this.nonDisplayedMemory;
                this.nonDisplayedMemory = tmp;
                this.writeScreen = this.nonDisplayedMemory;
                logger.log('TEXT', 'DISP: ' + this.displayedMemory.getDisplayText());
            }
            this.outputDataUpdate();
        }
    }, {
        key: 'ccTO',
        value: function ccTO(nrCols) {
            // Tab Offset 1,2, or 3 columns
            logger.log('INFO', 'TO(' + nrCols + ') - Tab Offset');
            this.writeScreen.moveCursor(nrCols);
        }
    }, {
        key: 'ccMIDROW',
        value: function ccMIDROW(secondByte) {
            // Parse MIDROW command
            var styles = { flash: false };
            styles.underline = secondByte % 2 === 1;
            styles.italics = secondByte >= 0x2e;
            if (!styles.italics) {
                var colorIndex = Math.floor(secondByte / 2) - 0x10;
                var colors = ['white', 'green', 'blue', 'cyan', 'red', 'yellow', 'magenta'];
                styles.foreground = colors[colorIndex];
            } else {
                styles.foreground = 'white';
            }
            logger.log('INFO', 'MIDROW: ' + JSON.stringify(styles));
            this.writeScreen.setPen(styles);
        }
    }, {
        key: 'outputDataUpdate',
        value: function outputDataUpdate() {
            var t = logger.time;
            if (t === null) {
                return;
            }
            if (this.outputFilter) {
                if (this.outputFilter.updateData) {
                    this.outputFilter.updateData(t, this.displayedMemory);
                }
                if (this.cueStartTime === null && !this.displayedMemory.isEmpty()) {
                    // Start of a new cue
                    this.cueStartTime = t;
                } else {
                    if (!this.displayedMemory.equals(this.lastOutputScreen)) {
                        if (this.outputFilter.newCue) {
                            this.outputFilter.newCue(this.cueStartTime, t, this.lastOutputScreen);
                        }
                        this.cueStartTime = this.displayedMemory.isEmpty() ? null : t;
                    }
                }
                this.lastOutputScreen.copy(this.displayedMemory);
            }
        }
    }, {
        key: 'cueSplitAtTime',
        value: function cueSplitAtTime(t) {
            if (this.outputFilter) {
                if (!this.displayedMemory.isEmpty()) {
                    if (this.outputFilter.newCue) {
                        this.outputFilter.newCue(this.cueStartTime, t, this.displayedMemory);
                    }
                    this.cueStartTime = t;
                }
            }
        }
    }]);

    return Cea608Channel;
}();

var Cea608Parser = function () {
    function Cea608Parser(field, out1, out2) {
        _classCallCheck(this, Cea608Parser);

        this.field = field || 1;
        this.outputs = [out1, out2];
        this.channels = [new Cea608Channel(1, out1), new Cea608Channel(2, out2)];
        this.currChNr = -1; // Will be 1 or 2
        this.lastCmdA = null; // First byte of last command
        this.lastCmdB = null; // Second byte of last command
        this.bufferedData = [];
        this.startTime = null;
        this.lastTime = null;
        this.dataCounters = { 'padding': 0, 'char': 0, 'cmd': 0, 'other': 0 };
    }

    _createClass(Cea608Parser, [{
        key: 'getHandler',
        value: function getHandler(index) {
            return this.channels[index].getHandler();
        }
    }, {
        key: 'setHandler',
        value: function setHandler(index, newHandler) {
            this.channels[index].setHandler(newHandler);
        }

        /**
         * Add data for time t in forms of list of bytes (unsigned ints). The bytes are treated as pairs.
         */

    }, {
        key: 'addData',
        value: function addData(t, byteList) {
            var cmdFound,
                a,
                b,
                charsFound = false;

            this.lastTime = t;
            logger.setTime(t);

            for (var i = 0; i < byteList.length; i += 2) {
                a = byteList[i] & 0x7f;
                b = byteList[i + 1] & 0x7f;
                if (a === 0 && b === 0) {
                    this.dataCounters.padding += 2;
                    continue;
                } else {
                    logger.log('DATA', '[' + numArrayToHexArray([byteList[i], byteList[i + 1]]) + '] -> (' + numArrayToHexArray([a, b]) + ')');
                }
                cmdFound = this.parseCmd(a, b);
                if (!cmdFound) {
                    cmdFound = this.parseMidrow(a, b);
                }
                if (!cmdFound) {
                    cmdFound = this.parsePAC(a, b);
                }
                if (!cmdFound) {
                    cmdFound = this.parseBackgroundAttributes(a, b);
                }
                if (!cmdFound) {
                    charsFound = this.parseChars(a, b);
                    if (charsFound) {
                        if (this.currChNr && this.currChNr >= 0) {
                            var channel = this.channels[this.currChNr - 1];
                            channel.insertChars(charsFound);
                        } else {
                            logger.log('WARNING', 'No channel found yet. TEXT-MODE?');
                        }
                    }
                }
                if (cmdFound) {
                    this.dataCounters.cmd += 2;
                } else if (charsFound) {
                    this.dataCounters.char += 2;
                } else {
                    this.dataCounters.other += 2;
                    logger.log('WARNING', 'Couldn\'t parse cleaned data ' + numArrayToHexArray([a, b]) + ' orig: ' + numArrayToHexArray([byteList[i], byteList[i + 1]]));
                }
            }
        }

        /**
         * Parse Command.
         * @returns {Boolean} Tells if a command was found
         */

    }, {
        key: 'parseCmd',
        value: function parseCmd(a, b) {
            var chNr = null;

            var cond1 = (a === 0x14 || a === 0x1C) && 0x20 <= b && b <= 0x2F;
            var cond2 = (a === 0x17 || a === 0x1F) && 0x21 <= b && b <= 0x23;
            if (!(cond1 || cond2)) {
                return false;
            }

            if (a === this.lastCmdA && b === this.lastCmdB) {
                this.lastCmdA = null;
                this.lastCmdB = null; // Repeated commands are dropped (once)
                logger.log('DEBUG', 'Repeated command (' + numArrayToHexArray([a, b]) + ') is dropped');
                return true;
            }

            if (a === 0x14 || a === 0x17) {
                chNr = 1;
            } else {
                chNr = 2; // (a === 0x1C || a=== 0x1f)
            }

            var channel = this.channels[chNr - 1];

            if (a === 0x14 || a === 0x1C) {
                if (b === 0x20) {
                    channel.ccRCL();
                } else if (b === 0x21) {
                    channel.ccBS();
                } else if (b === 0x22) {
                    channel.ccAOF();
                } else if (b === 0x23) {
                    channel.ccAON();
                } else if (b === 0x24) {
                    channel.ccDER();
                } else if (b === 0x25) {
                    channel.ccRU(2);
                } else if (b === 0x26) {
                    channel.ccRU(3);
                } else if (b === 0x27) {
                    channel.ccRU(4);
                } else if (b === 0x28) {
                    channel.ccFON();
                } else if (b === 0x29) {
                    channel.ccRDC();
                } else if (b === 0x2A) {
                    channel.ccTR();
                } else if (b === 0x2B) {
                    channel.ccRTD();
                } else if (b === 0x2C) {
                    channel.ccEDM();
                } else if (b === 0x2D) {
                    channel.ccCR();
                } else if (b === 0x2E) {
                    channel.ccENM();
                } else if (b === 0x2F) {
                    channel.ccEOC();
                }
            } else {
                //a == 0x17 || a == 0x1F
                channel.ccTO(b - 0x20);
            }
            this.lastCmdA = a;
            this.lastCmdB = b;
            this.currChNr = chNr;
            return true;
        }

        /**
         * Parse midrow styling command
         * @returns {Boolean}
         */

    }, {
        key: 'parseMidrow',
        value: function parseMidrow(a, b) {
            var chNr = null;

            if ((a === 0x11 || a === 0x19) && 0x20 <= b && b <= 0x2f) {
                if (a === 0x11) {
                    chNr = 1;
                } else {
                    chNr = 2;
                }
                if (chNr !== this.currChNr) {
                    logger.log('ERROR', 'Mismatch channel in midrow parsing');
                    return false;
                }
                var channel = this.channels[chNr - 1];
                channel.ccMIDROW(b);
                logger.log('DEBUG', 'MIDROW (' + numArrayToHexArray([a, b]) + ')');
                return true;
            }
            return false;
        }
        /**
         * Parse Preable Access Codes (Table 53).
         * @returns {Boolean} Tells if PAC found
         */

    }, {
        key: 'parsePAC',
        value: function parsePAC(a, b) {

            var chNr = null;
            var row = null;

            var case1 = (0x11 <= a && a <= 0x17 || 0x19 <= a && a <= 0x1F) && 0x40 <= b && b <= 0x7F;
            var case2 = (a === 0x10 || a === 0x18) && 0x40 <= b && b <= 0x5F;
            if (!(case1 || case2)) {
                return false;
            }

            if (a === this.lastCmdA && b === this.lastCmdB) {
                this.lastCmdA = null;
                this.lastCmdB = null;
                return true; // Repeated commands are dropped (once)
            }

            chNr = a <= 0x17 ? 1 : 2;

            if (0x40 <= b && b <= 0x5F) {
                row = chNr === 1 ? rowsLowCh1[a] : rowsLowCh2[a];
            } else {
                // 0x60 <= b <= 0x7F
                row = chNr === 1 ? rowsHighCh1[a] : rowsHighCh2[a];
            }
            var pacData = this.interpretPAC(row, b);
            var channel = this.channels[chNr - 1];
            channel.setPAC(pacData);
            this.lastCmdA = a;
            this.lastCmdB = b;
            this.currChNr = chNr;
            return true;
        }

        /**
         * Interpret the second byte of the pac, and return the information.
         * @returns {Object} pacData with style parameters.
         */

    }, {
        key: 'interpretPAC',
        value: function interpretPAC(row, byte) {
            var pacIndex = byte;
            var pacData = { color: null, italics: false, indent: null, underline: false, row: row };

            if (byte > 0x5F) {
                pacIndex = byte - 0x60;
            } else {
                pacIndex = byte - 0x40;
            }
            pacData.underline = (pacIndex & 1) === 1;
            if (pacIndex <= 0xd) {
                pacData.color = ['white', 'green', 'blue', 'cyan', 'red', 'yellow', 'magenta', 'white'][Math.floor(pacIndex / 2)];
            } else if (pacIndex <= 0xf) {
                pacData.italics = true;
                pacData.color = 'white';
            } else {
                pacData.indent = Math.floor((pacIndex - 0x10) / 2) * 4;
            }
            return pacData; // Note that row has zero offset. The spec uses 1.
        }

        /**
         * Parse characters.
         * @returns An array with 1 to 2 codes corresponding to chars, if found. null otherwise.
         */

    }, {
        key: 'parseChars',
        value: function parseChars(a, b) {

            var channelNr = null,
                charCodes = null,
                charCode1 = null;

            if (a >= 0x19) {
                channelNr = 2;
                charCode1 = a - 8;
            } else {
                channelNr = 1;
                charCode1 = a;
            }
            if (0x11 <= charCode1 && charCode1 <= 0x13) {
                // Special character
                var oneCode = b;
                if (charCode1 === 0x11) {
                    oneCode = b + 0x50;
                } else if (charCode1 === 0x12) {
                    oneCode = b + 0x70;
                } else {
                    oneCode = b + 0x90;
                }
                logger.log('INFO', 'Special char \'' + getCharForByte(oneCode) + '\' in channel ' + channelNr);
                charCodes = [oneCode];
            } else if (0x20 <= a && a <= 0x7f) {
                charCodes = b === 0 ? [a] : [a, b];
            }
            if (charCodes) {
                var hexCodes = numArrayToHexArray(charCodes);
                logger.log('DEBUG', 'Char codes =  ' + hexCodes.join(','));
                this.lastCmdA = null;
                this.lastCmdB = null;
            }
            return charCodes;
        }

        /**
        * Parse extended background attributes as well as new foreground color black.
        * @returns{Boolean} Tells if background attributes are found
        */

    }, {
        key: 'parseBackgroundAttributes',
        value: function parseBackgroundAttributes(a, b) {
            var bkgData, index, chNr, channel;

            var case1 = (a === 0x10 || a === 0x18) && 0x20 <= b && b <= 0x2f;
            var case2 = (a === 0x17 || a === 0x1f) && 0x2d <= b && b <= 0x2f;
            if (!(case1 || case2)) {
                return false;
            }
            bkgData = {};
            if (a === 0x10 || a === 0x18) {
                index = Math.floor((b - 0x20) / 2);
                bkgData.background = backgroundColors[index];
                if (b % 2 === 1) {
                    bkgData.background = bkgData.background + '_semi';
                }
            } else if (b === 0x2d) {
                bkgData.background = 'transparent';
            } else {
                bkgData.foreground = 'black';
                if (b === 0x2f) {
                    bkgData.underline = true;
                }
            }
            chNr = a < 0x18 ? 1 : 2;
            channel = this.channels[chNr - 1];
            channel.setBkgData(bkgData);
            this.lastCmdA = null;
            this.lastCmdB = null;
            return true;
        }

        /**
         * Reset state of parser and its channels.
         */

    }, {
        key: 'reset',
        value: function reset() {
            for (var i = 0; i < this.channels.length; i++) {
                if (this.channels[i]) {
                    this.channels[i].reset();
                }
            }
            this.lastCmdA = null;
            this.lastCmdB = null;
        }

        /**
         * Trigger the generation of a cue, and the start of a new one if displayScreens are not empty.
         */

    }, {
        key: 'cueSplitAtTime',
        value: function cueSplitAtTime(t) {
            for (var i = 0; i < this.channels.length; i++) {
                if (this.channels[i]) {
                    this.channels[i].cueSplitAtTime(t);
                }
            }
        }
    }]);

    return Cea608Parser;
}();

exports.default = Cea608Parser;

},{}],47:[function(require,module,exports){
'use strict';

var _vttparser = require('./vttparser');

var Cues = {

  newCue: function newCue(track, startTime, endTime, captionScreen) {
    var row;
    var cue;
    var indenting;
    var indent;
    var text;
    var VTTCue = window.VTTCue || window.TextTrackCue;

    for (var r = 0; r < captionScreen.rows.length; r++) {
      row = captionScreen.rows[r];
      indenting = true;
      indent = 0;
      text = '';

      if (!row.isEmpty()) {
        for (var c = 0; c < row.chars.length; c++) {
          if (row.chars[c].uchar.match(/\s/) && indenting) {
            indent++;
          } else {
            text += row.chars[c].uchar;
            indenting = false;
          }
        }
        //To be used for cleaning-up orphaned roll-up captions
        row.cueStartTime = startTime;

        // Give a slight bump to the endTime if it's equal to startTime to avoid a SyntaxError in IE
        if (startTime === endTime) {
          endTime += 0.0001;
        }

        cue = new VTTCue(startTime, endTime, (0, _vttparser.fixLineBreaks)(text.trim()));

        if (indent >= 16) {
          indent--;
        } else {
          indent++;
        }

        // VTTCue.line get's flakey when using controls, so let's now include line 13&14
        // also, drop line 1 since it's to close to the top
        if (navigator.userAgent.match(/Firefox\//)) {
          cue.line = r + 1;
        } else {
          cue.line = r > 7 ? r - 2 : r + 1;
        }
        cue.align = 'left';
        // Clamp the position between 0 and 100 - if out of these bounds, Firefox throws an exception and captions break
        cue.position = Math.max(0, Math.min(100, 100 * (indent / 32) + (navigator.userAgent.match(/Firefox\//) ? 50 : 0)));
        track.addCue(cue);
      }
    }
  }

};

module.exports = Cues;

},{"./vttparser":54}],48:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.findFirstFragWithCC = findFirstFragWithCC;
exports.findFragWithCC = findFragWithCC;
exports.shouldAlignOnDiscontinuities = shouldAlignOnDiscontinuities;
exports.findDiscontinuousReferenceFrag = findDiscontinuousReferenceFrag;
exports.adjustPtsByReferenceFrag = adjustPtsByReferenceFrag;
exports.alignDiscontinuities = alignDiscontinuities;

var _binarySearch = require('./binary-search');

var _binarySearch2 = _interopRequireDefault(_binarySearch);

var _logger = require('../utils/logger');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function findFirstFragWithCC(fragments, cc) {
  var firstFrag = null;

  for (var i = 0; i < fragments.length; i += 1) {
    var currentFrag = fragments[i];
    if (currentFrag && currentFrag.cc === cc) {
      firstFrag = currentFrag;
      break;
    }
  }

  return firstFrag;
}

function findFragWithCC(fragments, CC) {
  return _binarySearch2.default.search(fragments, function (candidate) {
    if (candidate.cc < CC) {
      return 1;
    } else if (candidate.cc > CC) {
      return -1;
    } else {
      return 0;
    }
  });
}

function shouldAlignOnDiscontinuities(lastFrag, lastLevel, details) {
  var shouldAlign = false;
  if (lastLevel && lastLevel.details && details) {
    if (details.endCC > details.startCC || lastFrag && lastFrag.cc < details.startCC) {
      shouldAlign = true;
    }
  }
  return shouldAlign;
}

// Find the first frag in the previous level which matches the CC of the first frag of the new level
function findDiscontinuousReferenceFrag(prevDetails, curDetails) {
  var prevFrags = prevDetails.fragments;
  var curFrags = curDetails.fragments;

  if (!curFrags.length || !prevFrags.length) {
    _logger.logger.log('No fragments to align');
    return;
  }

  var prevStartFrag = findFirstFragWithCC(prevFrags, curFrags[0].cc);

  if (!prevStartFrag || prevStartFrag && !prevStartFrag.startPTS) {
    _logger.logger.log('No frag in previous level to align on');
    return;
  }

  return prevStartFrag;
}

function adjustPtsByReferenceFrag(referenceFrag, details) {
  if (!referenceFrag) {
    return;
  }

  details.fragments.forEach(function (frag, index) {
    if (frag) {
      frag.duration = referenceFrag.duration;
      frag.end = frag.endPTS = referenceFrag.endPTS + frag.duration * index;
      frag.start = frag.startPTS = referenceFrag.startPTS + frag.start;
    }
  });
  details.PTSKnown = true;
}

// If a change in CC is detected, the PTS can no longer be relied upon
// Attempt to align the level by using the last level - find the last frag matching the current CC and use it's PTS
// as a reference
function alignDiscontinuities(lastFrag, lastLevel, details) {
  if (shouldAlignOnDiscontinuities(lastFrag, lastLevel, details)) {
    _logger.logger.log('Adjusting PTS using last level due to CC increase within current level');
    var referenceFrag = findDiscontinuousReferenceFrag(lastLevel.details, details);
    adjustPtsByReferenceFrag(referenceFrag, details);
  }
}

},{"../utils/logger":51,"./binary-search":45}],49:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * EWMA Bandwidth Estimator
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *  - heavily inspired from shaka-player
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Tracks bandwidth samples and estimates available bandwidth.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Based on the minimum of two exponentially-weighted moving averages with
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * different half-lives.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */

var _ewma = require('../utils/ewma');

var _ewma2 = _interopRequireDefault(_ewma);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var EwmaBandWidthEstimator = function () {
  function EwmaBandWidthEstimator(hls, slow, fast, defaultEstimate) {
    _classCallCheck(this, EwmaBandWidthEstimator);

    this.hls = hls;
    this.defaultEstimate_ = defaultEstimate;
    this.minWeight_ = 0.001;
    this.minDelayMs_ = 50;
    this.slow_ = new _ewma2.default(slow);
    this.fast_ = new _ewma2.default(fast);
  }

  _createClass(EwmaBandWidthEstimator, [{
    key: 'sample',
    value: function sample(durationMs, numBytes) {
      durationMs = Math.max(durationMs, this.minDelayMs_);
      var bandwidth = 8000 * numBytes / durationMs,

      //console.log('instant bw:'+ Math.round(bandwidth));
      // we weight sample using loading duration....
      weight = durationMs / 1000;
      this.fast_.sample(weight, bandwidth);
      this.slow_.sample(weight, bandwidth);
    }
  }, {
    key: 'canEstimate',
    value: function canEstimate() {
      var fast = this.fast_;
      return fast && fast.getTotalWeight() >= this.minWeight_;
    }
  }, {
    key: 'getEstimate',
    value: function getEstimate() {
      if (this.canEstimate()) {
        //console.log('slow estimate:'+ Math.round(this.slow_.getEstimate()));
        //console.log('fast estimate:'+ Math.round(this.fast_.getEstimate()));
        // Take the minimum of these two estimates.  This should have the effect of
        // adapting down quickly, but up more slowly.
        return Math.min(this.fast_.getEstimate(), this.slow_.getEstimate());
      } else {
        return this.defaultEstimate_;
      }
    }
  }, {
    key: 'destroy',
    value: function destroy() {}
  }]);

  return EwmaBandWidthEstimator;
}();

exports.default = EwmaBandWidthEstimator;

},{"../utils/ewma":50}],50:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/*
 * compute an Exponential Weighted moving average
 * - https://en.wikipedia.org/wiki/Moving_average#Exponential_moving_average
 *  - heavily inspired from shaka-player
 */

var EWMA = function () {

  //  About half of the estimated value will be from the last |halfLife| samples by weight.
  function EWMA(halfLife) {
    _classCallCheck(this, EWMA);

    // Larger values of alpha expire historical data more slowly.
    this.alpha_ = halfLife ? Math.exp(Math.log(0.5) / halfLife) : 0;
    this.estimate_ = 0;
    this.totalWeight_ = 0;
  }

  _createClass(EWMA, [{
    key: "sample",
    value: function sample(weight, value) {
      var adjAlpha = Math.pow(this.alpha_, weight);
      this.estimate_ = value * (1 - adjAlpha) + adjAlpha * this.estimate_;
      this.totalWeight_ += weight;
    }
  }, {
    key: "getTotalWeight",
    value: function getTotalWeight() {
      return this.totalWeight_;
    }
  }, {
    key: "getEstimate",
    value: function getEstimate() {
      if (this.alpha_) {
        var zeroFactor = 1 - Math.pow(this.alpha_, this.totalWeight_);
        return this.estimate_ / zeroFactor;
      } else {
        return this.estimate_;
      }
    }
  }]);

  return EWMA;
}();

exports.default = EWMA;

},{}],51:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function noop() {}

var fakeLogger = {
  trace: noop,
  debug: noop,
  log: noop,
  warn: noop,
  info: noop,
  error: noop
};

var exportedLogger = fakeLogger;

/*globals self: false */

//let lastCallTime;
// function formatMsgWithTimeInfo(type, msg) {
//   const now = Date.now();
//   const diff = lastCallTime ? '+' + (now - lastCallTime) : '0';
//   lastCallTime = now;
//   msg = (new Date(now)).toISOString() + ' | [' +  type + '] > ' + msg + ' ( ' + diff + ' ms )';
//   return msg;
// }

function formatMsg(type, msg) {
  msg = '[' + type + '] > ' + msg;
  return msg;
}

function consolePrintFn(type) {
  var func = self.console[type];
  if (func) {
    return function () {
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      if (args[0]) {
        args[0] = formatMsg(type, args[0]);
      }
      func.apply(self.console, args);
    };
  }
  return noop;
}

function exportLoggerFunctions(debugConfig) {
  for (var _len2 = arguments.length, functions = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    functions[_key2 - 1] = arguments[_key2];
  }

  functions.forEach(function (type) {
    exportedLogger[type] = debugConfig[type] ? debugConfig[type].bind(debugConfig) : consolePrintFn(type);
  });
}

var enableLogs = exports.enableLogs = function enableLogs(debugConfig) {
  if (debugConfig === true || (typeof debugConfig === 'undefined' ? 'undefined' : _typeof(debugConfig)) === 'object') {
    exportLoggerFunctions(debugConfig,
    // Remove out from list here to hard-disable a log-level
    //'trace',
    'debug', 'log', 'info', 'warn', 'error');
    // Some browsers don't allow to use bind on console object anyway
    // fallback to default if needed
    try {
      exportedLogger.log();
    } catch (e) {
      exportedLogger = fakeLogger;
    }
  } else {
    exportedLogger = fakeLogger;
  }
};

var logger = exports.logger = exportedLogger;

},{}],52:[function(require,module,exports){
'use strict';

/**
 *  TimeRanges to string helper
 */

var TimeRanges = {
  toString: function toString(r) {
    var log = '',
        len = r.length;
    for (var i = 0; i < len; i++) {
      log += '[' + r.start(i).toFixed(3) + ',' + r.end(i).toFixed(3) + ']';
    }
    return log;
  }
};

module.exports = TimeRanges;

},{}],53:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

/**
 * Copyright 2013 vtt.js Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

exports.default = function () {
  if (typeof window !== 'undefined' && window.VTTCue) {
    return window.VTTCue;
  }

  var autoKeyword = 'auto';
  var directionSetting = {
    '': true,
    lr: true,
    rl: true
  };
  var alignSetting = {
    start: true,
    middle: true,
    end: true,
    left: true,
    right: true
  };

  function findDirectionSetting(value) {
    if (typeof value !== 'string') {
      return false;
    }
    var dir = directionSetting[value.toLowerCase()];
    return dir ? value.toLowerCase() : false;
  }

  function findAlignSetting(value) {
    if (typeof value !== 'string') {
      return false;
    }
    var align = alignSetting[value.toLowerCase()];
    return align ? value.toLowerCase() : false;
  }

  function extend(obj) {
    var i = 1;
    for (; i < arguments.length; i++) {
      var cobj = arguments[i];
      for (var p in cobj) {
        obj[p] = cobj[p];
      }
    }

    return obj;
  }

  function VTTCue(startTime, endTime, text) {
    var cue = this;
    var isIE8 = function () {
      if (typeof navigator === 'undefined') {
        return;
      }
      return (/MSIE\s8\.0/.test(navigator.userAgent)
      );
    }();
    var baseObj = {};

    if (isIE8) {
      cue = document.createElement('custom');
    } else {
      baseObj.enumerable = true;
    }

    /**
     * Shim implementation specific properties. These properties are not in
     * the spec.
     */

    // Lets us know when the VTTCue's data has changed in such a way that we need
    // to recompute its display state. This lets us compute its display state
    // lazily.
    cue.hasBeenReset = false;

    /**
     * VTTCue and TextTrackCue properties
     * http://dev.w3.org/html5/webvtt/#vttcue-interface
     */

    var _id = '';
    var _pauseOnExit = false;
    var _startTime = startTime;
    var _endTime = endTime;
    var _text = text;
    var _region = null;
    var _vertical = '';
    var _snapToLines = true;
    var _line = 'auto';
    var _lineAlign = 'start';
    var _position = 50;
    var _positionAlign = 'middle';
    var _size = 50;
    var _align = 'middle';

    Object.defineProperty(cue, 'id', extend({}, baseObj, {
      get: function get() {
        return _id;
      },
      set: function set(value) {
        _id = '' + value;
      }
    }));

    Object.defineProperty(cue, 'pauseOnExit', extend({}, baseObj, {
      get: function get() {
        return _pauseOnExit;
      },
      set: function set(value) {
        _pauseOnExit = !!value;
      }
    }));

    Object.defineProperty(cue, 'startTime', extend({}, baseObj, {
      get: function get() {
        return _startTime;
      },
      set: function set(value) {
        if (typeof value !== 'number') {
          throw new TypeError('Start time must be set to a number.');
        }
        _startTime = value;
        this.hasBeenReset = true;
      }
    }));

    Object.defineProperty(cue, 'endTime', extend({}, baseObj, {
      get: function get() {
        return _endTime;
      },
      set: function set(value) {
        if (typeof value !== 'number') {
          throw new TypeError('End time must be set to a number.');
        }
        _endTime = value;
        this.hasBeenReset = true;
      }
    }));

    Object.defineProperty(cue, 'text', extend({}, baseObj, {
      get: function get() {
        return _text;
      },
      set: function set(value) {
        _text = '' + value;
        this.hasBeenReset = true;
      }
    }));

    Object.defineProperty(cue, 'region', extend({}, baseObj, {
      get: function get() {
        return _region;
      },
      set: function set(value) {
        _region = value;
        this.hasBeenReset = true;
      }
    }));

    Object.defineProperty(cue, 'vertical', extend({}, baseObj, {
      get: function get() {
        return _vertical;
      },
      set: function set(value) {
        var setting = findDirectionSetting(value);
        // Have to check for false because the setting an be an empty string.
        if (setting === false) {
          throw new SyntaxError('An invalid or illegal string was specified.');
        }
        _vertical = setting;
        this.hasBeenReset = true;
      }
    }));

    Object.defineProperty(cue, 'snapToLines', extend({}, baseObj, {
      get: function get() {
        return _snapToLines;
      },
      set: function set(value) {
        _snapToLines = !!value;
        this.hasBeenReset = true;
      }
    }));

    Object.defineProperty(cue, 'line', extend({}, baseObj, {
      get: function get() {
        return _line;
      },
      set: function set(value) {
        if (typeof value !== 'number' && value !== autoKeyword) {
          throw new SyntaxError('An invalid number or illegal string was specified.');
        }
        _line = value;
        this.hasBeenReset = true;
      }
    }));

    Object.defineProperty(cue, 'lineAlign', extend({}, baseObj, {
      get: function get() {
        return _lineAlign;
      },
      set: function set(value) {
        var setting = findAlignSetting(value);
        if (!setting) {
          throw new SyntaxError('An invalid or illegal string was specified.');
        }
        _lineAlign = setting;
        this.hasBeenReset = true;
      }
    }));

    Object.defineProperty(cue, 'position', extend({}, baseObj, {
      get: function get() {
        return _position;
      },
      set: function set(value) {
        if (value < 0 || value > 100) {
          throw new Error('Position must be between 0 and 100.');
        }
        _position = value;
        this.hasBeenReset = true;
      }
    }));

    Object.defineProperty(cue, 'positionAlign', extend({}, baseObj, {
      get: function get() {
        return _positionAlign;
      },
      set: function set(value) {
        var setting = findAlignSetting(value);
        if (!setting) {
          throw new SyntaxError('An invalid or illegal string was specified.');
        }
        _positionAlign = setting;
        this.hasBeenReset = true;
      }
    }));

    Object.defineProperty(cue, 'size', extend({}, baseObj, {
      get: function get() {
        return _size;
      },
      set: function set(value) {
        if (value < 0 || value > 100) {
          throw new Error('Size must be between 0 and 100.');
        }
        _size = value;
        this.hasBeenReset = true;
      }
    }));

    Object.defineProperty(cue, 'align', extend({}, baseObj, {
      get: function get() {
        return _align;
      },
      set: function set(value) {
        var setting = findAlignSetting(value);
        if (!setting) {
          throw new SyntaxError('An invalid or illegal string was specified.');
        }
        _align = setting;
        this.hasBeenReset = true;
      }
    }));

    /**
     * Other <track> spec defined properties
     */

    // http://www.whatwg.org/specs/web-apps/current-work/multipage/the-video-element.html#text-track-cue-display-state
    cue.displayState = undefined;

    if (isIE8) {
      return cue;
    }
  }

  /**
   * VTTCue methods
   */

  VTTCue.prototype.getCueAsHTML = function () {
    // Assume WebVTT.convertCueToDOMTree is on the global.
    var WebVTT = window.WebVTT;
    return WebVTT.convertCueToDOMTree(window, this.text);
  };

  return VTTCue;
}();

},{}],54:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fixLineBreaks = undefined;

var _vttcue = require('./vttcue');

var _vttcue2 = _interopRequireDefault(_vttcue);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var StringDecoder = function StringDecoder() {
  return {
    decode: function decode(data) {
      if (!data) {
        return '';
      }
      if (typeof data !== 'string') {
        throw new Error('Error - expected string data.');
      }
      return decodeURIComponent(encodeURIComponent(data));
    }
  };
}; /*
    * Source: https://github.com/mozilla/vtt.js/blob/master/dist/vtt.js#L1716
    */

function VTTParser() {
  this.window = window;
  this.state = 'INITIAL';
  this.buffer = '';
  this.decoder = new StringDecoder();
  this.regionList = [];
}

// Try to parse input as a time stamp.
function parseTimeStamp(input) {

  function computeSeconds(h, m, s, f) {
    return (h | 0) * 3600 + (m | 0) * 60 + (s | 0) + (f | 0) / 1000;
  }

  var m = input.match(/^(\d+):(\d{2})(:\d{2})?\.(\d{3})/);
  if (!m) {
    return null;
  }

  if (m[3]) {
    // Timestamp takes the form of [hours]:[minutes]:[seconds].[milliseconds]
    return computeSeconds(m[1], m[2], m[3].replace(':', ''), m[4]);
  } else if (m[1] > 59) {
    // Timestamp takes the form of [hours]:[minutes].[milliseconds]
    // First position is hours as it's over 59.
    return computeSeconds(m[1], m[2], 0, m[4]);
  } else {
    // Timestamp takes the form of [minutes]:[seconds].[milliseconds]
    return computeSeconds(0, m[1], m[2], m[4]);
  }
}

// A settings object holds key/value pairs and will ignore anything but the first
// assignment to a specific key.
function Settings() {
  this.values = Object.create(null);
}

Settings.prototype = {
  // Only accept the first assignment to any key.
  set: function set(k, v) {
    if (!this.get(k) && v !== '') {
      this.values[k] = v;
    }
  },
  // Return the value for a key, or a default value.
  // If 'defaultKey' is passed then 'dflt' is assumed to be an object with
  // a number of possible default values as properties where 'defaultKey' is
  // the key of the property that will be chosen; otherwise it's assumed to be
  // a single value.
  get: function get(k, dflt, defaultKey) {
    if (defaultKey) {
      return this.has(k) ? this.values[k] : dflt[defaultKey];
    }
    return this.has(k) ? this.values[k] : dflt;
  },
  // Check whether we have a value for a key.
  has: function has(k) {
    return k in this.values;
  },
  // Accept a setting if its one of the given alternatives.
  alt: function alt(k, v, a) {
    for (var n = 0; n < a.length; ++n) {
      if (v === a[n]) {
        this.set(k, v);
        break;
      }
    }
  },
  // Accept a setting if its a valid (signed) integer.
  integer: function integer(k, v) {
    if (/^-?\d+$/.test(v)) {
      // integer
      this.set(k, parseInt(v, 10));
    }
  },
  // Accept a setting if its a valid percentage.
  percent: function percent(k, v) {
    var m;
    if (m = v.match(/^([\d]{1,3})(\.[\d]*)?%$/)) {
      v = parseFloat(v);
      if (v >= 0 && v <= 100) {
        this.set(k, v);
        return true;
      }
    }
    return false;
  }
};

// Helper function to parse input into groups separated by 'groupDelim', and
// interprete each group as a key/value pair separated by 'keyValueDelim'.
function parseOptions(input, callback, keyValueDelim, groupDelim) {
  var groups = groupDelim ? input.split(groupDelim) : [input];
  for (var i in groups) {
    if (typeof groups[i] !== 'string') {
      continue;
    }
    var kv = groups[i].split(keyValueDelim);
    if (kv.length !== 2) {
      continue;
    }
    var k = kv[0];
    var v = kv[1];
    callback(k, v);
  }
}

var defaults = new _vttcue2.default(0, 0, 0);
// 'middle' was changed to 'center' in the spec: https://github.com/w3c/webvtt/pull/244
// Chrome and Safari don't yet support this change, but FF does
var center = defaults.align === 'middle' ? 'middle' : 'center';

function parseCue(input, cue, regionList) {
  // Remember the original input if we need to throw an error.
  var oInput = input;
  // 4.1 WebVTT timestamp
  function consumeTimeStamp() {
    var ts = parseTimeStamp(input);
    if (ts === null) {
      throw new Error('Malformed timestamp: ' + oInput);
    }
    // Remove time stamp from input.
    input = input.replace(/^[^\sa-zA-Z-]+/, '');
    return ts;
  }

  // 4.4.2 WebVTT cue settings
  function consumeCueSettings(input, cue) {
    var settings = new Settings();

    parseOptions(input, function (k, v) {
      switch (k) {
        case 'region':
          // Find the last region we parsed with the same region id.
          for (var i = regionList.length - 1; i >= 0; i--) {
            if (regionList[i].id === v) {
              settings.set(k, regionList[i].region);
              break;
            }
          }
          break;
        case 'vertical':
          settings.alt(k, v, ['rl', 'lr']);
          break;
        case 'line':
          var vals = v.split(','),
              vals0 = vals[0];
          settings.integer(k, vals0);
          if (settings.percent(k, vals0)) {
            settings.set('snapToLines', false);
          }
          settings.alt(k, vals0, ['auto']);
          if (vals.length === 2) {
            settings.alt('lineAlign', vals[1], ['start', center, 'end']);
          }
          break;
        case 'position':
          vals = v.split(',');
          settings.percent(k, vals[0]);
          if (vals.length === 2) {
            settings.alt('positionAlign', vals[1], ['start', center, 'end', 'line-left', 'line-right', 'auto']);
          }
          break;
        case 'size':
          settings.percent(k, v);
          break;
        case 'align':
          settings.alt(k, v, ['start', center, 'end', 'left', 'right']);
          break;
      }
    }, /:/, /\s/);

    // Apply default values for any missing fields.
    cue.region = settings.get('region', null);
    cue.vertical = settings.get('vertical', '');
    var line = settings.get('line', 'auto');
    if (line === 'auto' && defaults.line === -1) {
      // set numeric line number for Safari
      line = -1;
    }
    cue.line = line;
    cue.lineAlign = settings.get('lineAlign', 'start');
    cue.snapToLines = settings.get('snapToLines', true);
    cue.size = settings.get('size', 100);
    cue.align = settings.get('align', center);
    var position = settings.get('position', 'auto');
    if (position === 'auto' && defaults.position === 50) {
      // set numeric position for Safari
      position = cue.align === 'start' || cue.align === 'left' ? 0 : cue.align === 'end' || cue.align === 'right' ? 100 : 50;
    }
    cue.position = position;
  }

  function skipWhitespace() {
    input = input.replace(/^\s+/, '');
  }

  // 4.1 WebVTT cue timings.
  skipWhitespace();
  cue.startTime = consumeTimeStamp(); // (1) collect cue start time
  skipWhitespace();
  if (input.substr(0, 3) !== '-->') {
    // (3) next characters must match '-->'
    throw new Error('Malformed time stamp (time stamps must be separated by \'-->\'): ' + oInput);
  }
  input = input.substr(3);
  skipWhitespace();
  cue.endTime = consumeTimeStamp(); // (5) collect cue end time

  // 4.1 WebVTT cue settings list.
  skipWhitespace();
  consumeCueSettings(input, cue);
}

function fixLineBreaks(input) {
  return input.replace(/<br(?: \/)?>/gi, '\n');
}

VTTParser.prototype = {
  parse: function parse(data) {
    var self = this;

    // If there is no data then we won't decode it, but will just try to parse
    // whatever is in buffer already. This may occur in circumstances, for
    // example when flush() is called.
    if (data) {
      // Try to decode the data that we received.
      self.buffer += self.decoder.decode(data, { stream: true });
    }

    function collectNextLine() {
      var buffer = self.buffer;
      var pos = 0;

      buffer = fixLineBreaks(buffer);

      while (pos < buffer.length && buffer[pos] !== '\r' && buffer[pos] !== '\n') {
        ++pos;
      }
      var line = buffer.substr(0, pos);
      // Advance the buffer early in case we fail below.
      if (buffer[pos] === '\r') {
        ++pos;
      }
      if (buffer[pos] === '\n') {
        ++pos;
      }
      self.buffer = buffer.substr(pos);
      return line;
    }

    // 3.2 WebVTT metadata header syntax
    function parseHeader(input) {
      parseOptions(input, function (k, v) {
        switch (k) {
          case 'Region':
            // 3.3 WebVTT region metadata header syntax
            console.log('parse region', v);
            //parseRegion(v);
            break;
        }
      }, /:/);
    }

    // 5.1 WebVTT file parsing.
    try {
      var line;
      if (self.state === 'INITIAL') {
        // We can't start parsing until we have the first line.
        if (!/\r\n|\n/.test(self.buffer)) {
          return this;
        }

        line = collectNextLine();

        var m = line.match(/^WEBVTT([ \t].*)?$/);
        if (!m || !m[0]) {
          throw new Error('Malformed WebVTT signature.');
        }

        self.state = 'HEADER';
      }

      var alreadyCollectedLine = false;
      while (self.buffer) {
        // We can't parse a line until we have the full line.
        if (!/\r\n|\n/.test(self.buffer)) {
          return this;
        }

        if (!alreadyCollectedLine) {
          line = collectNextLine();
        } else {
          alreadyCollectedLine = false;
        }

        switch (self.state) {
          case 'HEADER':
            // 13-18 - Allow a header (metadata) under the WEBVTT line.
            if (/:/.test(line)) {
              parseHeader(line);
            } else if (!line) {
              // An empty line terminates the header and starts the body (cues).
              self.state = 'ID';
            }
            continue;
          case 'NOTE':
            // Ignore NOTE blocks.
            if (!line) {
              self.state = 'ID';
            }
            continue;
          case 'ID':
            // Check for the start of NOTE blocks.
            if (/^NOTE($|[ \t])/.test(line)) {
              self.state = 'NOTE';
              break;
            }
            // 19-29 - Allow any number of line terminators, then initialize new cue values.
            if (!line) {
              continue;
            }
            self.cue = new _vttcue2.default(0, 0, '');
            self.state = 'CUE';
            // 30-39 - Check if self line contains an optional identifier or timing data.
            if (line.indexOf('-->') === -1) {
              self.cue.id = line;
              continue;
            }
          // Process line as start of a cue.
          /*falls through*/
          case 'CUE':
            // 40 - Collect cue timings and settings.
            try {
              parseCue(line, self.cue, self.regionList);
            } catch (e) {
              // In case of an error ignore rest of the cue.
              self.cue = null;
              self.state = 'BADCUE';
              continue;
            }
            self.state = 'CUETEXT';
            continue;
          case 'CUETEXT':
            var hasSubstring = line.indexOf('-->') !== -1;
            // 34 - If we have an empty line then report the cue.
            // 35 - If we have the special substring '-->' then report the cue,
            // but do not collect the line as we need to process the current
            // one as a new cue.
            if (!line || hasSubstring && (alreadyCollectedLine = true)) {
              // We are done parsing self cue.
              if (self.oncue) {
                self.oncue(self.cue);
              }
              self.cue = null;
              self.state = 'ID';
              continue;
            }
            if (self.cue.text) {
              self.cue.text += '\n';
            }
            self.cue.text += line;
            continue;
          case 'BADCUE':
            // BADCUE
            // 54-62 - Collect and discard the remaining cue.
            if (!line) {
              self.state = 'ID';
            }
            continue;
        }
      }
    } catch (e) {

      // If we are currently parsing a cue, report what we have.
      if (self.state === 'CUETEXT' && self.cue && self.oncue) {
        self.oncue(self.cue);
      }
      self.cue = null;
      // Enter BADWEBVTT state if header was not parsed correctly otherwise
      // another exception occurred so enter BADCUE state.
      self.state = self.state === 'INITIAL' ? 'BADWEBVTT' : 'BADCUE';
    }
    return this;
  },
  flush: function flush() {
    var self = this;
    try {
      // Finish decoding the stream.
      self.buffer += self.decoder.decode();
      // Synthesize the end of the current cue or region.
      if (self.cue || self.state === 'HEADER') {
        self.buffer += '\n\n';
        self.parse();
      }
      // If we've flushed, parsed, and we're still on the INITIAL state then
      // that means we don't have enough of the stream to parse the first
      // line.
      if (self.state === 'INITIAL') {
        throw new Error('Malformed WebVTT signature.');
      }
    } catch (e) {
      throw e;
    }
    if (self.onflush) {
      self.onflush();
    }
    return this;
  }
};

exports.fixLineBreaks = fixLineBreaks;
exports.default = VTTParser;

},{"./vttcue":53}],55:[function(require,module,exports){
'use strict';

var _vttparser = require('./vttparser');

var _vttparser2 = _interopRequireDefault(_vttparser);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// String.prototype.startsWith is not supported in IE11
var startsWith = function startsWith(inputString, searchString, position) {
    return inputString.substr(position || 0, searchString.length) === searchString;
};

var cueString2millis = function cueString2millis(timeString) {
    var ts = parseInt(timeString.substr(-3));
    var secs = parseInt(timeString.substr(-6, 2));
    var mins = parseInt(timeString.substr(-9, 2));
    var hours = timeString.length > 9 ? parseInt(timeString.substr(0, timeString.indexOf(':'))) : 0;

    if (isNaN(ts) || isNaN(secs) || isNaN(mins) || isNaN(hours)) {
        return -1;
    }

    ts += 1000 * secs;
    ts += 60 * 1000 * mins;
    ts += 60 * 60 * 1000 * hours;

    return ts;
};

var calculateOffset = function calculateOffset(vttCCs, cc, presentationTime) {
    var currCC = vttCCs[cc];
    var prevCC = vttCCs[currCC.prevCC];

    // This is the first discontinuity or cues have been processed since the last discontinuity
    // Offset = current discontinuity time
    if (!prevCC || !prevCC.new && currCC.new) {
        vttCCs.ccOffset = vttCCs.presentationOffset = currCC.start;
        currCC.new = false;
        return;
    }

    // There have been discontinuities since cues were last parsed.
    // Offset = time elapsed
    while (prevCC && prevCC.new) {
        vttCCs.ccOffset += currCC.start - prevCC.start;
        currCC.new = false;
        currCC = prevCC;
        prevCC = vttCCs[currCC.prevCC];
    }

    vttCCs.presentationOffset = presentationTime;
};

var WebVTTParser = {
    parse: function parse(vttByteArray, syncPTS, vttCCs, cc, callBack, errorCallBack) {
        // Convert byteArray into string, replacing any somewhat exotic linefeeds with "\n", then split on that character.
        var re = /\r\n|\n\r|\n|\r/g;
        var vttLines = String.fromCharCode.apply(null, new Uint8Array(vttByteArray)).trim().replace(re, '\n').split('\n');
        var cueTime = '00:00.000';
        var mpegTs = 0;
        var localTime = 0;
        var presentationTime = 0;
        var cues = [];
        var parsingError = void 0;
        var inHeader = true;
        // let VTTCue = VTTCue || window.TextTrackCue;

        // Create parser object using VTTCue with TextTrackCue fallback on certain browsers.
        var parser = new _vttparser2.default();

        parser.oncue = function (cue) {
            // Adjust cue timing; clamp cues to start no earlier than - and drop cues that don't end after - 0 on timeline.
            var currCC = vttCCs[cc];
            var cueOffset = vttCCs.ccOffset;

            // Update offsets for new discontinuities
            if (currCC && currCC.new) {
                if (localTime) {
                    // When local time is provided, offset = discontinuity start time - local time
                    cueOffset = vttCCs.ccOffset = currCC.start;
                } else {
                    calculateOffset(vttCCs, cc, presentationTime);
                }
            }

            if (presentationTime && !localTime) {
                // If we have MPEGTS but no LOCAL time, offset = presentation time + discontinuity offset
                cueOffset = presentationTime + vttCCs.ccOffset - vttCCs.presentationOffset;
            }

            cue.startTime += cueOffset - localTime;
            cue.endTime += cueOffset - localTime;

            // Fix encoding of special characters. TODO: Test with all sorts of weird characters.
            cue.text = decodeURIComponent(escape(cue.text));
            if (cue.endTime > 0) {
                cues.push(cue);
            }
        };

        parser.onparsingerror = function (e) {
            parsingError = e;
        };

        parser.onflush = function () {
            if (parsingError && errorCallBack) {
                errorCallBack(parsingError);
                return;
            }
            callBack(cues);
        };

        // Go through contents line by line.
        vttLines.forEach(function (line) {
            if (inHeader) {
                // Look for X-TIMESTAMP-MAP in header.
                if (startsWith(line, 'X-TIMESTAMP-MAP=')) {
                    // Once found, no more are allowed anyway, so stop searching.
                    inHeader = false;
                    // Extract LOCAL and MPEGTS.
                    line.substr(16).split(',').forEach(function (timestamp) {
                        if (startsWith(timestamp, 'LOCAL:')) {
                            cueTime = timestamp.substr(6);
                        } else if (startsWith(timestamp, 'MPEGTS:')) {
                            mpegTs = parseInt(timestamp.substr(7));
                        }
                    });
                    try {
                        // Calculate subtitle offset in milliseconds.
                        // If sync PTS is less than zero, we have a 33-bit wraparound, which is fixed by adding 2^33 = 8589934592.
                        syncPTS = syncPTS < 0 ? syncPTS + 8589934592 : syncPTS;
                        // Adjust MPEGTS by sync PTS.
                        mpegTs -= syncPTS;
                        // Convert cue time to seconds
                        localTime = cueString2millis(cueTime) / 1000;
                        // Convert MPEGTS to seconds from 90kHz.
                        presentationTime = mpegTs / 90000;

                        if (localTime === -1) {
                            parsingError = new Error('Malformed X-TIMESTAMP-MAP: ' + line);
                        }
                    } catch (e) {
                        parsingError = new Error('Malformed X-TIMESTAMP-MAP: ' + line);
                    }
                    // Return without parsing X-TIMESTAMP-MAP line.
                    return;
                } else if (line === '') {
                    inHeader = false;
                }
            }
            // Parse line by default.
            parser.parse(line + '\n');
        });

        parser.flush();
    }
};

module.exports = WebVTTParser;

},{"./vttparser":54}],56:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * XHR based logger
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */

var _logger = require('../utils/logger');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var XhrLoader = function () {
  function XhrLoader(config) {
    _classCallCheck(this, XhrLoader);

    if (config && config.xhrSetup) {
      this.xhrSetup = config.xhrSetup;
    }
  }

  _createClass(XhrLoader, [{
    key: 'destroy',
    value: function destroy() {
      this.abort();
      this.loader = null;
    }
  }, {
    key: 'abort',
    value: function abort() {
      var loader = this.loader;
      if (loader && loader.readyState !== 4) {
        this.stats.aborted = true;
        loader.abort();
      }

      window.clearTimeout(this.requestTimeout);
      this.requestTimeout = null;
      window.clearTimeout(this.retryTimeout);
      this.retryTimeout = null;
    }
  }, {
    key: 'load',
    value: function load(context, config, callbacks) {
      this.context = context;
      this.config = config;
      this.callbacks = callbacks;
      this.stats = { trequest: performance.now(), retry: 0 };
      this.retryDelay = config.retryDelay;
      this.loadInternal();
    }
  }, {
    key: 'loadInternal',
    value: function loadInternal() {
      var xhr,
          context = this.context;

      if (typeof XDomainRequest !== 'undefined') {
        xhr = this.loader = new XDomainRequest();
      } else {
        xhr = this.loader = new XMLHttpRequest();
      }
      var stats = this.stats;
      stats.tfirst = 0;
      stats.loaded = 0;
      var xhrSetup = this.xhrSetup;

      try {
        if (xhrSetup) {
          try {
            xhrSetup(xhr, context.url);
          } catch (e) {
            // fix xhrSetup: (xhr, url) => {xhr.setRequestHeader("Content-Language", "test");}
            // not working, as xhr.setRequestHeader expects xhr.readyState === OPEN
            xhr.open('GET', context.url, true);
            xhrSetup(xhr, context.url);
          }
        }
        if (!xhr.readyState) {
          xhr.open('GET', context.url, true);
        }
      } catch (e) {
        // IE11 throws an exception on xhr.open if attempting to access an HTTP resource over HTTPS
        this.callbacks.onError({ code: xhr.status, text: e.message }, context);
        return;
      }

      if (context.rangeEnd) {
        xhr.setRequestHeader('Range', 'bytes=' + context.rangeStart + '-' + (context.rangeEnd - 1));
      }
      xhr.onreadystatechange = this.readystatechange.bind(this);
      xhr.onprogress = this.loadprogress.bind(this);
      xhr.responseType = context.responseType;

      // setup timeout before we perform request
      this.requestTimeout = window.setTimeout(this.loadtimeout.bind(this), this.config.timeout);
      xhr.send();
    }
  }, {
    key: 'readystatechange',
    value: function readystatechange(event) {
      var xhr = event.currentTarget,
          readyState = xhr.readyState,
          stats = this.stats,
          context = this.context,
          config = this.config;

      // don't proceed if xhr has been aborted
      if (stats.aborted) {
        return;
      }

      // >= HEADERS_RECEIVED
      if (readyState >= 2) {
        // clear xhr timeout and rearm it if readyState less than 4
        window.clearTimeout(this.requestTimeout);
        if (stats.tfirst === 0) {
          stats.tfirst = Math.max(performance.now(), stats.trequest);
        }
        if (readyState === 4) {
          var status = xhr.status;
          // http status between 200 to 299 are all successful
          if (status >= 200 && status < 300) {
            stats.tload = Math.max(stats.tfirst, performance.now());
            var data = void 0,
                len = void 0;
            if (context.responseType === 'arraybuffer') {
              data = xhr.response;
              len = data.byteLength;
            } else {
              data = xhr.responseText;
              len = data.length;
            }
            stats.loaded = stats.total = len;
            var response = { url: xhr.responseURL, data: data };
            this.callbacks.onSuccess(response, stats, context);
          } else {
            // if max nb of retries reached or if http status between 400 and 499 (such error cannot be recovered, retrying is useless), return error
            if (stats.retry >= config.maxRetry || status >= 400 && status < 499) {
              _logger.logger.error(status + ' while loading ' + context.url);
              this.callbacks.onError({ code: status, text: xhr.statusText }, context);
            } else {
              // retry
              _logger.logger.warn(status + ' while loading ' + context.url + ', retrying in ' + this.retryDelay + '...');
              // aborts and resets internal state
              this.destroy();
              // schedule retry
              this.retryTimeout = window.setTimeout(this.loadInternal.bind(this), this.retryDelay);
              // set exponential backoff
              this.retryDelay = Math.min(2 * this.retryDelay, config.maxRetryDelay);
              stats.retry++;
            }
          }
        } else {
          // readyState >= 2 AND readyState !==4 (readyState = HEADERS_RECEIVED || LOADING) rearm timeout as xhr not finished yet
          this.requestTimeout = window.setTimeout(this.loadtimeout.bind(this), config.timeout);
        }
      }
    }
  }, {
    key: 'loadtimeout',
    value: function loadtimeout() {
      _logger.logger.warn('timeout while loading ' + this.context.url);
      this.callbacks.onTimeout(this.stats, this.context);
    }
  }, {
    key: 'loadprogress',
    value: function loadprogress(event) {
      var stats = this.stats;
      stats.loaded = event.loaded;
      if (event.lengthComputable) {
        stats.total = event.total;
      }
      var onProgress = this.callbacks.onProgress;
      if (onProgress) {
        // last args is to provide on progress data
        onProgress(stats, this.context, null);
      }
    }
  }]);

  return XhrLoader;
}();

exports.default = XhrLoader;

},{"../utils/logger":51}]},{},[37])(37)
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvZXZlbnRzL2V2ZW50cy5qcyIsIm5vZGVfbW9kdWxlcy91cmwtdG9vbGtpdC9zcmMvdXJsLXRvb2xraXQuanMiLCJub2RlX21vZHVsZXMvd2Vid29ya2lmeS9pbmRleC5qcyIsInNyYy9jb25maWcuanMiLCJzcmMvY29udHJvbGxlci9hYnItY29udHJvbGxlci5qcyIsInNyYy9jb250cm9sbGVyL2F1ZGlvLXN0cmVhbS1jb250cm9sbGVyLmpzIiwic3JjL2NvbnRyb2xsZXIvYXVkaW8tdHJhY2stY29udHJvbGxlci5qcyIsInNyYy9jb250cm9sbGVyL2J1ZmZlci1jb250cm9sbGVyLmpzIiwic3JjL2NvbnRyb2xsZXIvY2FwLWxldmVsLWNvbnRyb2xsZXIuanMiLCJzcmMvY29udHJvbGxlci9mcHMtY29udHJvbGxlci5qcyIsInNyYy9jb250cm9sbGVyL2xldmVsLWNvbnRyb2xsZXIuanMiLCJzcmMvY29udHJvbGxlci9zdHJlYW0tY29udHJvbGxlci5qcyIsInNyYy9jb250cm9sbGVyL3N1YnRpdGxlLXN0cmVhbS1jb250cm9sbGVyLmpzIiwic3JjL2NvbnRyb2xsZXIvc3VidGl0bGUtdHJhY2stY29udHJvbGxlci5qcyIsInNyYy9jb250cm9sbGVyL3RpbWVsaW5lLWNvbnRyb2xsZXIuanMiLCJzcmMvY3J5cHQvYWVzLWNyeXB0by5qcyIsInNyYy9jcnlwdC9hZXMtZGVjcnlwdG9yLmpzIiwic3JjL2NyeXB0L2RlY3J5cHRlci5qcyIsInNyYy9jcnlwdC9mYXN0LWFlcy1rZXkuanMiLCJzcmMvZGVtdXgvYWFjZGVtdXhlci5qcyIsInNyYy9kZW11eC9hZHRzLmpzIiwic3JjL2RlbXV4L2RlbXV4ZXItaW5saW5lLmpzIiwic3JjL2RlbXV4L2RlbXV4ZXItd29ya2VyLmpzIiwic3JjL2RlbXV4L2RlbXV4ZXIuanMiLCJzcmMvZGVtdXgvZXhwLWdvbG9tYi5qcyIsInNyYy9kZW11eC9pZDMuanMiLCJzcmMvZGVtdXgvbXA0ZGVtdXhlci5qcyIsInNyYy9kZW11eC9zYW1wbGUtYWVzLmpzIiwic3JjL2RlbXV4L3RzZGVtdXhlci5qcyIsInNyYy9lcnJvcnMuanMiLCJzcmMvZXZlbnQtaGFuZGxlci5qcyIsInNyYy9ldmVudHMuanMiLCJzcmMvaGVscGVyL2FhYy5qcyIsInNyYy9oZWxwZXIvYnVmZmVyLWhlbHBlci5qcyIsInNyYy9oZWxwZXIvbGV2ZWwtaGVscGVyLmpzIiwic3JjL2hscy5qcyIsInNyYy9pbmRleC5qcyIsInNyYy9sb2FkZXIvZnJhZ21lbnQtbG9hZGVyLmpzIiwic3JjL2xvYWRlci9rZXktbG9hZGVyLmpzIiwic3JjL2xvYWRlci9wbGF5bGlzdC1sb2FkZXIuanMiLCJzcmMvcmVtdXgvbXA0LWdlbmVyYXRvci5qcyIsInNyYy9yZW11eC9tcDQtcmVtdXhlci5qcyIsInNyYy9yZW11eC9wYXNzdGhyb3VnaC1yZW11eGVyLmpzIiwic3JjL3V0aWxzL2F0dHItbGlzdC5qcyIsInNyYy91dGlscy9iaW5hcnktc2VhcmNoLmpzIiwic3JjL3V0aWxzL2NlYS02MDgtcGFyc2VyLmpzIiwic3JjL3V0aWxzL2N1ZXMuanMiLCJzcmMvdXRpbHMvZGlzY29udGludWl0aWVzLmpzIiwic3JjL3V0aWxzL2V3bWEtYmFuZHdpZHRoLWVzdGltYXRvci5qcyIsInNyYy91dGlscy9ld21hLmpzIiwic3JjL3V0aWxzL2xvZ2dlci5qcyIsInNyYy91dGlscy90aW1lUmFuZ2VzLmpzIiwic3JjL3V0aWxzL3Z0dGN1ZS5qcyIsInNyYy91dGlscy92dHRwYXJzZXIuanMiLCJzcmMvdXRpbHMvd2VidnR0LXBhcnNlci5qcyIsInNyYy91dGlscy94aHItbG9hZGVyLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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MUIsY0FBTSxLQUFOLEdBQWMsTUFBTSxLQUFwQjtBQUNEO0FBQ0QsVUFBSSxhQUFhLEtBQUssU0FBTCxDQUFlLFVBQWhDO0FBQ0EsVUFBSSxVQUFKLEVBQWdCO0FBQ2Q7QUFDQSxtQkFBVyxLQUFYLEVBQWtCLEtBQUssT0FBdkIsRUFBZ0MsSUFBaEM7QUFDRDtBQUNGOzs7Ozs7a0JBR1ksUyIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICB0aGlzLl9ldmVudHMgPSB0aGlzLl9ldmVudHMgfHwge307XG4gIHRoaXMuX21heExpc3RlbmVycyA9IHRoaXMuX21heExpc3RlbmVycyB8fCB1bmRlZmluZWQ7XG59XG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC4xMC54XG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHMgPSB1bmRlZmluZWQ7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9tYXhMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG5cbi8vIEJ5IGRlZmF1bHQgRXZlbnRFbWl0dGVycyB3aWxsIHByaW50IGEgd2FybmluZyBpZiBtb3JlIHRoYW4gMTAgbGlzdGVuZXJzIGFyZVxuLy8gYWRkZWQgdG8gaXQuIFRoaXMgaXMgYSB1c2VmdWwgZGVmYXVsdCB3aGljaCBoZWxwcyBmaW5kaW5nIG1lbW9yeSBsZWFrcy5cbkV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzID0gMTA7XG5cbi8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93c1xuLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnNldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uKG4pIHtcbiAgaWYgKCFpc051bWJlcihuKSB8fCBuIDwgMCB8fCBpc05hTihuKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ24gbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicpO1xuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSBuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIGVyLCBoYW5kbGVyLCBsZW4sIGFyZ3MsIGksIGxpc3RlbmVycztcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcblxuICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXG4gIGlmICh0eXBlID09PSAnZXJyb3InKSB7XG4gICAgaWYgKCF0aGlzLl9ldmVudHMuZXJyb3IgfHxcbiAgICAgICAgKGlzT2JqZWN0KHRoaXMuX2V2ZW50cy5lcnJvcikgJiYgIXRoaXMuX2V2ZW50cy5lcnJvci5sZW5ndGgpKSB7XG4gICAgICBlciA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQXQgbGVhc3QgZ2l2ZSBzb21lIGtpbmQgb2YgY29udGV4dCB0byB0aGUgdXNlclxuICAgICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdVbmNhdWdodCwgdW5zcGVjaWZpZWQgXCJlcnJvclwiIGV2ZW50LiAoJyArIGVyICsgJyknKTtcbiAgICAgICAgZXJyLmNvbnRleHQgPSBlcjtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGhhbmRsZXIgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgaWYgKGlzVW5kZWZpbmVkKGhhbmRsZXIpKVxuICAgIHJldHVybiBmYWxzZTtcblxuICBpZiAoaXNGdW5jdGlvbihoYW5kbGVyKSkge1xuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgLy8gZmFzdCBjYXNlc1xuICAgICAgY2FzZSAxOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgLy8gc2xvd2VyXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgaGFuZGxlci5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QoaGFuZGxlcikpIHtcbiAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICBsaXN0ZW5lcnMgPSBoYW5kbGVyLnNsaWNlKCk7XG4gICAgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspXG4gICAgICBsaXN0ZW5lcnNbaV0uYXBwbHkodGhpcywgYXJncyk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgbTtcblxuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgdGhpcy5fZXZlbnRzID0ge307XG5cbiAgLy8gVG8gYXZvaWQgcmVjdXJzaW9uIGluIHRoZSBjYXNlIHRoYXQgdHlwZSA9PT0gXCJuZXdMaXN0ZW5lclwiISBCZWZvcmVcbiAgLy8gYWRkaW5nIGl0IHRvIHRoZSBsaXN0ZW5lcnMsIGZpcnN0IGVtaXQgXCJuZXdMaXN0ZW5lclwiLlxuICBpZiAodGhpcy5fZXZlbnRzLm5ld0xpc3RlbmVyKVxuICAgIHRoaXMuZW1pdCgnbmV3TGlzdGVuZXInLCB0eXBlLFxuICAgICAgICAgICAgICBpc0Z1bmN0aW9uKGxpc3RlbmVyLmxpc3RlbmVyKSA/XG4gICAgICAgICAgICAgIGxpc3RlbmVyLmxpc3RlbmVyIDogbGlzdGVuZXIpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIC8vIE9wdGltaXplIHRoZSBjYXNlIG9mIG9uZSBsaXN0ZW5lci4gRG9uJ3QgbmVlZCB0aGUgZXh0cmEgYXJyYXkgb2JqZWN0LlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IGxpc3RlbmVyO1xuICBlbHNlIGlmIChpc09iamVjdCh0aGlzLl9ldmVudHNbdHlwZV0pKVxuICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZ290IGFuIGFycmF5LCBqdXN0IGFwcGVuZC5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0ucHVzaChsaXN0ZW5lcik7XG4gIGVsc2VcbiAgICAvLyBBZGRpbmcgdGhlIHNlY29uZCBlbGVtZW50LCBuZWVkIHRvIGNoYW5nZSB0byBhcnJheS5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBbdGhpcy5fZXZlbnRzW3R5cGVdLCBsaXN0ZW5lcl07XG5cbiAgLy8gQ2hlY2sgZm9yIGxpc3RlbmVyIGxlYWtcbiAgaWYgKGlzT2JqZWN0KHRoaXMuX2V2ZW50c1t0eXBlXSkgJiYgIXRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQpIHtcbiAgICBpZiAoIWlzVW5kZWZpbmVkKHRoaXMuX21heExpc3RlbmVycykpIHtcbiAgICAgIG0gPSB0aGlzLl9tYXhMaXN0ZW5lcnM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycztcbiAgICB9XG5cbiAgICBpZiAobSAmJiBtID4gMCAmJiB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoID4gbSkge1xuICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCA9IHRydWU7XG4gICAgICBjb25zb2xlLmVycm9yKCcobm9kZSkgd2FybmluZzogcG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2xlYWsgZGV0ZWN0ZWQuICVkIGxpc3RlbmVycyBhZGRlZC4gJyArXG4gICAgICAgICAgICAgICAgICAgICdVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byBpbmNyZWFzZSBsaW1pdC4nLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoKTtcbiAgICAgIGlmICh0eXBlb2YgY29uc29sZS50cmFjZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBub3Qgc3VwcG9ydGVkIGluIElFIDEwXG4gICAgICAgIGNvbnNvbGUudHJhY2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgdmFyIGZpcmVkID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gZygpIHtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGcpO1xuXG4gICAgaWYgKCFmaXJlZCkge1xuICAgICAgZmlyZWQgPSB0cnVlO1xuICAgICAgbGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cblxuICBnLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gIHRoaXMub24odHlwZSwgZyk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBlbWl0cyBhICdyZW1vdmVMaXN0ZW5lcicgZXZlbnQgaWZmIHRoZSBsaXN0ZW5lciB3YXMgcmVtb3ZlZFxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBsaXN0LCBwb3NpdGlvbiwgbGVuZ3RoLCBpO1xuXG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIGxpc3QgPSB0aGlzLl9ldmVudHNbdHlwZV07XG4gIGxlbmd0aCA9IGxpc3QubGVuZ3RoO1xuICBwb3NpdGlvbiA9IC0xO1xuXG4gIGlmIChsaXN0ID09PSBsaXN0ZW5lciB8fFxuICAgICAgKGlzRnVuY3Rpb24obGlzdC5saXN0ZW5lcikgJiYgbGlzdC5saXN0ZW5lciA9PT0gbGlzdGVuZXIpKSB7XG4gICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICBpZiAodGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3RlbmVyKTtcblxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGxpc3QpKSB7XG4gICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gPiAwOykge1xuICAgICAgaWYgKGxpc3RbaV0gPT09IGxpc3RlbmVyIHx8XG4gICAgICAgICAgKGxpc3RbaV0ubGlzdGVuZXIgJiYgbGlzdFtpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpKSB7XG4gICAgICAgIHBvc2l0aW9uID0gaTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBvc2l0aW9uIDwgMClcbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgaWYgKGxpc3QubGVuZ3RoID09PSAxKSB7XG4gICAgICBsaXN0Lmxlbmd0aCA9IDA7XG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaXN0LnNwbGljZShwb3NpdGlvbiwgMSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0ZW5lcik7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIga2V5LCBsaXN0ZW5lcnM7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgLy8gbm90IGxpc3RlbmluZyBmb3IgcmVtb3ZlTGlzdGVuZXIsIG5vIG5lZWQgdG8gZW1pdFxuICBpZiAoIXRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcikge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKVxuICAgICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgZWxzZSBpZiAodGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIGVtaXQgcmVtb3ZlTGlzdGVuZXIgZm9yIGFsbCBsaXN0ZW5lcnMgb24gYWxsIGV2ZW50c1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIGZvciAoa2V5IGluIHRoaXMuX2V2ZW50cykge1xuICAgICAgaWYgKGtleSA9PT0gJ3JlbW92ZUxpc3RlbmVyJykgY29udGludWU7XG4gICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhrZXkpO1xuICAgIH1cbiAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygncmVtb3ZlTGlzdGVuZXInKTtcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICBpZiAoaXNGdW5jdGlvbihsaXN0ZW5lcnMpKSB7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnMpO1xuICB9IGVsc2UgaWYgKGxpc3RlbmVycykge1xuICAgIC8vIExJRk8gb3JkZXJcbiAgICB3aGlsZSAobGlzdGVuZXJzLmxlbmd0aClcbiAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzW2xpc3RlbmVycy5sZW5ndGggLSAxXSk7XG4gIH1cbiAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIgcmV0O1xuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIHJldCA9IFtdO1xuICBlbHNlIGlmIChpc0Z1bmN0aW9uKHRoaXMuX2V2ZW50c1t0eXBlXSkpXG4gICAgcmV0ID0gW3RoaXMuX2V2ZW50c1t0eXBlXV07XG4gIGVsc2VcbiAgICByZXQgPSB0aGlzLl9ldmVudHNbdHlwZV0uc2xpY2UoKTtcbiAgcmV0dXJuIHJldDtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgaWYgKHRoaXMuX2V2ZW50cykge1xuICAgIHZhciBldmxpc3RlbmVyID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gICAgaWYgKGlzRnVuY3Rpb24oZXZsaXN0ZW5lcikpXG4gICAgICByZXR1cm4gMTtcbiAgICBlbHNlIGlmIChldmxpc3RlbmVyKVxuICAgICAgcmV0dXJuIGV2bGlzdGVuZXIubGVuZ3RoO1xuICB9XG4gIHJldHVybiAwO1xufTtcblxuRXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XG4gIHJldHVybiBlbWl0dGVyLmxpc3RlbmVyQ291bnQodHlwZSk7XG59O1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG4iLCIvKiBqc2hpbnQgaWdub3JlOnN0YXJ0ICovXHJcbihmdW5jdGlvbihyb290KSB7IFxyXG4vKiBqc2hpbnQgaWdub3JlOmVuZCAqL1xyXG5cclxuICB2YXIgSEFTSF9TUExJVCA9IC9eKFteI10qKSguKikkLztcclxuICB2YXIgUVVFUllfU1BMSVQgPSAvXihbXlxcP10qKSguKikkLztcclxuICB2YXIgRE9NQUlOX1NQTElUID0gL14oKCg/OlthLXpdKzopP1xcL1xcLyk/W146XFwvXSsoPzo6WzAtOV0rKT8pPyhcXC8/LiopJC9pO1xyXG5cclxuICB2YXIgVVJMVG9vbGtpdCA9IHtcclxuICAgIC8vIGJ1aWxkIGFuIGFic29sdXRlIFVSTCBmcm9tIGEgcmVsYXRpdmUgb25lIHVzaW5nIHRoZSBwcm92aWRlZCBiYXNlVVJMXHJcbiAgICAvLyBpZiByZWxhdGl2ZVVSTCBpcyBhbiBhYnNvbHV0ZSBVUkwgaXQgd2lsbCBiZSByZXR1cm5lZCBhcyBpcy5cclxuICAgIGJ1aWxkQWJzb2x1dGVVUkw6IGZ1bmN0aW9uKGJhc2VVUkwsIHJlbGF0aXZlVVJMKSB7XHJcbiAgICAgIC8vIHJlbW92ZSBhbnkgcmVtYWluaW5nIHNwYWNlIGFuZCBDUkxGXHJcbiAgICAgIHJlbGF0aXZlVVJMID0gcmVsYXRpdmVVUkwudHJpbSgpO1xyXG4gICAgICBpZiAoL15bYS16XSs6L2kudGVzdChyZWxhdGl2ZVVSTCkpIHtcclxuICAgICAgICAvLyBjb21wbGV0ZSB1cmwsIG5vdCByZWxhdGl2ZVxyXG4gICAgICAgIHJldHVybiByZWxhdGl2ZVVSTDtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIHJlbGF0aXZlVVJMUXVlcnkgPSBudWxsO1xyXG4gICAgICB2YXIgcmVsYXRpdmVVUkxIYXNoID0gbnVsbDtcclxuXHJcbiAgICAgIHZhciByZWxhdGl2ZVVSTEhhc2hTcGxpdCA9IEhBU0hfU1BMSVQuZXhlYyhyZWxhdGl2ZVVSTCk7XHJcbiAgICAgIGlmIChyZWxhdGl2ZVVSTEhhc2hTcGxpdCkge1xyXG4gICAgICAgIHJlbGF0aXZlVVJMSGFzaCA9IHJlbGF0aXZlVVJMSGFzaFNwbGl0WzJdO1xyXG4gICAgICAgIHJlbGF0aXZlVVJMID0gcmVsYXRpdmVVUkxIYXNoU3BsaXRbMV07XHJcbiAgICAgIH1cclxuICAgICAgdmFyIHJlbGF0aXZlVVJMUXVlcnlTcGxpdCA9IFFVRVJZX1NQTElULmV4ZWMocmVsYXRpdmVVUkwpO1xyXG4gICAgICBpZiAocmVsYXRpdmVVUkxRdWVyeVNwbGl0KSB7XHJcbiAgICAgICAgcmVsYXRpdmVVUkxRdWVyeSA9IHJlbGF0aXZlVVJMUXVlcnlTcGxpdFsyXTtcclxuICAgICAgICByZWxhdGl2ZVVSTCA9IHJlbGF0aXZlVVJMUXVlcnlTcGxpdFsxXTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIGJhc2VVUkxIYXNoU3BsaXQgPSBIQVNIX1NQTElULmV4ZWMoYmFzZVVSTCk7XHJcbiAgICAgIGlmIChiYXNlVVJMSGFzaFNwbGl0KSB7XHJcbiAgICAgICAgYmFzZVVSTCA9IGJhc2VVUkxIYXNoU3BsaXRbMV07XHJcbiAgICAgIH1cclxuICAgICAgdmFyIGJhc2VVUkxRdWVyeVNwbGl0ID0gUVVFUllfU1BMSVQuZXhlYyhiYXNlVVJMKTtcclxuICAgICAgaWYgKGJhc2VVUkxRdWVyeVNwbGl0KSB7XHJcbiAgICAgICAgYmFzZVVSTCA9IGJhc2VVUkxRdWVyeVNwbGl0WzFdO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgYmFzZVVSTERvbWFpblNwbGl0ID0gRE9NQUlOX1NQTElULmV4ZWMoYmFzZVVSTCk7XHJcbiAgICAgIGlmICghYmFzZVVSTERvbWFpblNwbGl0KSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFcnJvciB0cnlpbmcgdG8gcGFyc2UgYmFzZSBVUkwuJyk7XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIC8vIGUuZy4gJ2h0dHA6Ly8nLCAnaHR0cHM6Ly8nLCAnLy8nLCAnJ1xyXG4gICAgICB2YXIgYmFzZVVSTFByb3RvY29sID0gYmFzZVVSTERvbWFpblNwbGl0WzJdIHx8ICcvLyc7IC8vIGlmIHRoZXJlIGlzIG5vIHByb3RvY29sIGRlZmF1bHQgdG8gJy8vJ1xyXG4gICAgICAvLyBlLmcuICdodHRwOi8vZXhhbXBsZS5jb20nLCAnLy9leGFtcGxlLmNvbScsICdleGFtcGxlLmNvbScsICcnXHJcbiAgICAgIHZhciBiYXNlVVJMUHJvdG9jb2xEb21haW4gPSBiYXNlVVJMRG9tYWluU3BsaXRbMV0gfHwgJyc7XHJcbiAgICAgIC8vIGUuZy4gJy9hL2IvYy9wbGF5bGlzdC5tM3U4JywgJ2EvYi9jL3BsYXlsaXN0Lm0zdTgnXHJcbiAgICAgIHZhciBiYXNlVVJMUGF0aCA9IGJhc2VVUkxEb21haW5TcGxpdFszXTtcclxuICAgICAgaWYgKGJhc2VVUkxQYXRoLmluZGV4T2YoJy8nKSAhPT0gMCAmJiBiYXNlVVJMUHJvdG9jb2xEb21haW4gIT09ICcnKSB7XHJcbiAgICAgICAgLy8gdGhpcyBoYW5kbGVzIGEgYmFzZSB1cmwgb2YgaHR0cDovL2V4YW1wbGUuY29tIChtaXNzaW5nIGxhc3Qgc2xhc2gpXHJcbiAgICAgICAgYmFzZVVSTFBhdGggPSAnLycrYmFzZVVSTFBhdGg7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciBidWlsdFVSTCA9IG51bGw7XHJcbiAgICAgIGlmICgvXlxcL1xcLy8udGVzdChyZWxhdGl2ZVVSTCkpIHtcclxuICAgICAgICAvLyByZWxhdGl2ZSB1cmwgc3RhcnRzIHd0aCAnLy8nIHNvIGNvcHkgcHJvdG9jb2xcclxuICAgICAgICBidWlsdFVSTCA9IGJhc2VVUkxQcm90b2NvbCtVUkxUb29sa2l0LmJ1aWxkQWJzb2x1dGVQYXRoKCcnLCByZWxhdGl2ZVVSTC5zdWJzdHJpbmcoMikpO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2UgaWYgKC9eXFwvLy50ZXN0KHJlbGF0aXZlVVJMKSkge1xyXG4gICAgICAgIC8vIHJlbGF0aXZlIHVybCBzdGFydHMgd2l0aCAnLycgc28gc3RhcnQgZnJvbSByb290IG9mIGRvbWFpblxyXG4gICAgICAgIGJ1aWx0VVJMID0gYmFzZVVSTFByb3RvY29sRG9tYWluKycvJytVUkxUb29sa2l0LmJ1aWxkQWJzb2x1dGVQYXRoKCcnLCByZWxhdGl2ZVVSTC5zdWJzdHJpbmcoMSkpO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgIGJ1aWx0VVJMID0gVVJMVG9vbGtpdC5idWlsZEFic29sdXRlUGF0aChiYXNlVVJMUHJvdG9jb2xEb21haW4rYmFzZVVSTFBhdGgsIHJlbGF0aXZlVVJMKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gcHV0IHRoZSBxdWVyeSBhbmQgaGFzaCBwYXJ0cyBiYWNrXHJcbiAgICAgIGlmIChyZWxhdGl2ZVVSTFF1ZXJ5KSB7XHJcbiAgICAgICAgYnVpbHRVUkwgKz0gcmVsYXRpdmVVUkxRdWVyeTtcclxuICAgICAgfVxyXG4gICAgICBpZiAocmVsYXRpdmVVUkxIYXNoKSB7XHJcbiAgICAgICAgYnVpbHRVUkwgKz0gcmVsYXRpdmVVUkxIYXNoO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBidWlsdFVSTDtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gYnVpbGQgYW4gYWJzb2x1dGUgcGF0aCB1c2luZyB0aGUgcHJvdmlkZWQgYmFzZVBhdGhcclxuICAgIC8vIGFkYXB0ZWQgZnJvbSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvZG9jdW1lbnQvY29va2llI1VzaW5nX3JlbGF0aXZlX1VSTHNfaW5fdGhlX3BhdGhfcGFyYW1ldGVyXHJcbiAgICAvLyB0aGlzIGRvZXMgbm90IGhhbmRsZSB0aGUgY2FzZSB3aGVyZSByZWxhdGl2ZVBhdGggaXMgXCIvXCIgb3IgXCIvL1wiLiBUaGVzZSBjYXNlcyBzaG91bGQgYmUgaGFuZGxlZCBvdXRzaWRlIHRoaXMuXHJcbiAgICBidWlsZEFic29sdXRlUGF0aDogZnVuY3Rpb24oYmFzZVBhdGgsIHJlbGF0aXZlUGF0aCkge1xyXG4gICAgICB2YXIgc1JlbFBhdGggPSByZWxhdGl2ZVBhdGg7XHJcbiAgICAgIHZhciBuVXBMbiwgc0RpciA9ICcnLCBzUGF0aCA9IGJhc2VQYXRoLnJlcGxhY2UoL1teXFwvXSokLywgc1JlbFBhdGgucmVwbGFjZSgvKFxcL3xeKSg/OlxcLj9cXC8rKSsvZywgJyQxJykpO1xyXG4gICAgICBmb3IgKHZhciBuRW5kLCBuU3RhcnQgPSAwOyBuRW5kID0gc1BhdGguaW5kZXhPZignLy4uLycsIG5TdGFydCksIG5FbmQgPiAtMTsgblN0YXJ0ID0gbkVuZCArIG5VcExuKSB7XHJcbiAgICAgICAgblVwTG4gPSAvXlxcLyg/OlxcLlxcLlxcLykqLy5leGVjKHNQYXRoLnNsaWNlKG5FbmQpKVswXS5sZW5ndGg7XHJcbiAgICAgICAgc0RpciA9IChzRGlyICsgc1BhdGguc3Vic3RyaW5nKG5TdGFydCwgbkVuZCkpLnJlcGxhY2UobmV3IFJlZ0V4cCgnKD86XFxcXFxcLytbXlxcXFxcXC9dKil7MCwnICsgKChuVXBMbiAtIDEpIC8gMykgKyAnfSQnKSwgJy8nKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gc0RpciArIHNQYXRoLnN1YnN0cihuU3RhcnQpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4vKiBqc2hpbnQgaWdub3JlOnN0YXJ0ICovXHJcbiAgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBVUkxUb29sa2l0O1xyXG4gIGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxyXG4gICAgZGVmaW5lKFtdLCBmdW5jdGlvbigpIHsgcmV0dXJuIFVSTFRvb2xraXQ7IH0pO1xyXG4gIGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxyXG4gICAgZXhwb3J0c1tcIlVSTFRvb2xraXRcIl0gPSBVUkxUb29sa2l0O1xyXG4gIGVsc2VcclxuICAgIHJvb3RbXCJVUkxUb29sa2l0XCJdID0gVVJMVG9vbGtpdDtcclxufSkodGhpcyk7XHJcbi8qIGpzaGludCBpZ25vcmU6ZW5kICovXHJcbiIsInZhciBidW5kbGVGbiA9IGFyZ3VtZW50c1szXTtcbnZhciBzb3VyY2VzID0gYXJndW1lbnRzWzRdO1xudmFyIGNhY2hlID0gYXJndW1lbnRzWzVdO1xuXG52YXIgc3RyaW5naWZ5ID0gSlNPTi5zdHJpbmdpZnk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGZuLCBvcHRpb25zKSB7XG4gICAgdmFyIHdrZXk7XG4gICAgdmFyIGNhY2hlS2V5cyA9IE9iamVjdC5rZXlzKGNhY2hlKTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2FjaGVLZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIga2V5ID0gY2FjaGVLZXlzW2ldO1xuICAgICAgICB2YXIgZXhwID0gY2FjaGVba2V5XS5leHBvcnRzO1xuICAgICAgICAvLyBVc2luZyBiYWJlbCBhcyBhIHRyYW5zcGlsZXIgdG8gdXNlIGVzbW9kdWxlLCB0aGUgZXhwb3J0IHdpbGwgYWx3YXlzXG4gICAgICAgIC8vIGJlIGFuIG9iamVjdCB3aXRoIHRoZSBkZWZhdWx0IGV4cG9ydCBhcyBhIHByb3BlcnR5IG9mIGl0LiBUbyBlbnN1cmVcbiAgICAgICAgLy8gdGhlIGV4aXN0aW5nIGFwaSBhbmQgYmFiZWwgZXNtb2R1bGUgZXhwb3J0cyBhcmUgYm90aCBzdXBwb3J0ZWQgd2VcbiAgICAgICAgLy8gY2hlY2sgZm9yIGJvdGhcbiAgICAgICAgaWYgKGV4cCA9PT0gZm4gfHwgZXhwICYmIGV4cC5kZWZhdWx0ID09PSBmbikge1xuICAgICAgICAgICAgd2tleSA9IGtleTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCF3a2V5KSB7XG4gICAgICAgIHdrZXkgPSBNYXRoLmZsb29yKE1hdGgucG93KDE2LCA4KSAqIE1hdGgucmFuZG9tKCkpLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgdmFyIHdjYWNoZSA9IHt9O1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNhY2hlS2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBjYWNoZUtleXNbaV07XG4gICAgICAgICAgICB3Y2FjaGVba2V5XSA9IGtleTtcbiAgICAgICAgfVxuICAgICAgICBzb3VyY2VzW3drZXldID0gW1xuICAgICAgICAgICAgRnVuY3Rpb24oWydyZXF1aXJlJywnbW9kdWxlJywnZXhwb3J0cyddLCAnKCcgKyBmbiArICcpKHNlbGYpJyksXG4gICAgICAgICAgICB3Y2FjaGVcbiAgICAgICAgXTtcbiAgICB9XG4gICAgdmFyIHNrZXkgPSBNYXRoLmZsb29yKE1hdGgucG93KDE2LCA4KSAqIE1hdGgucmFuZG9tKCkpLnRvU3RyaW5nKDE2KTtcblxuICAgIHZhciBzY2FjaGUgPSB7fTsgc2NhY2hlW3drZXldID0gd2tleTtcbiAgICBzb3VyY2VzW3NrZXldID0gW1xuICAgICAgICBGdW5jdGlvbihbJ3JlcXVpcmUnXSwgKFxuICAgICAgICAgICAgLy8gdHJ5IHRvIGNhbGwgZGVmYXVsdCBpZiBkZWZpbmVkIHRvIGFsc28gc3VwcG9ydCBiYWJlbCBlc21vZHVsZVxuICAgICAgICAgICAgLy8gZXhwb3J0c1xuICAgICAgICAgICAgJ3ZhciBmID0gcmVxdWlyZSgnICsgc3RyaW5naWZ5KHdrZXkpICsgJyk7JyArXG4gICAgICAgICAgICAnKGYuZGVmYXVsdCA/IGYuZGVmYXVsdCA6IGYpKHNlbGYpOydcbiAgICAgICAgKSksXG4gICAgICAgIHNjYWNoZVxuICAgIF07XG5cbiAgICB2YXIgd29ya2VyU291cmNlcyA9IHt9O1xuICAgIHJlc29sdmVTb3VyY2VzKHNrZXkpO1xuXG4gICAgZnVuY3Rpb24gcmVzb2x2ZVNvdXJjZXMoa2V5KSB7XG4gICAgICAgIHdvcmtlclNvdXJjZXNba2V5XSA9IHRydWU7XG5cbiAgICAgICAgZm9yICh2YXIgZGVwUGF0aCBpbiBzb3VyY2VzW2tleV1bMV0pIHtcbiAgICAgICAgICAgIHZhciBkZXBLZXkgPSBzb3VyY2VzW2tleV1bMV1bZGVwUGF0aF07XG4gICAgICAgICAgICBpZiAoIXdvcmtlclNvdXJjZXNbZGVwS2V5XSkge1xuICAgICAgICAgICAgICAgIHJlc29sdmVTb3VyY2VzKGRlcEtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgc3JjID0gJygnICsgYnVuZGxlRm4gKyAnKSh7J1xuICAgICAgICArIE9iamVjdC5rZXlzKHdvcmtlclNvdXJjZXMpLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gc3RyaW5naWZ5KGtleSkgKyAnOlsnXG4gICAgICAgICAgICAgICAgKyBzb3VyY2VzW2tleV1bMF1cbiAgICAgICAgICAgICAgICArICcsJyArIHN0cmluZ2lmeShzb3VyY2VzW2tleV1bMV0pICsgJ10nXG4gICAgICAgICAgICA7XG4gICAgICAgIH0pLmpvaW4oJywnKVxuICAgICAgICArICd9LHt9LFsnICsgc3RyaW5naWZ5KHNrZXkpICsgJ10pJ1xuICAgIDtcblxuICAgIHZhciBVUkwgPSB3aW5kb3cuVVJMIHx8IHdpbmRvdy53ZWJraXRVUkwgfHwgd2luZG93Lm1velVSTCB8fCB3aW5kb3cubXNVUkw7XG5cbiAgICB2YXIgYmxvYiA9IG5ldyBCbG9iKFtzcmNdLCB7IHR5cGU6ICd0ZXh0L2phdmFzY3JpcHQnIH0pO1xuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuYmFyZSkgeyByZXR1cm4gYmxvYjsgfVxuICAgIHZhciB3b3JrZXJVcmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuICAgIHZhciB3b3JrZXIgPSBuZXcgV29ya2VyKHdvcmtlclVybCk7XG4gICAgd29ya2VyLm9iamVjdFVSTCA9IHdvcmtlclVybDtcbiAgICByZXR1cm4gd29ya2VyO1xufTtcbiIsIi8qKlxuICogSExTIGNvbmZpZ1xuICovXG4ndXNlIHN0cmljdCc7XG5cbmltcG9ydCBBYnJDb250cm9sbGVyIGZyb20gICAgJy4vY29udHJvbGxlci9hYnItY29udHJvbGxlcic7XG5pbXBvcnQgQnVmZmVyQ29udHJvbGxlciBmcm9tICAnLi9jb250cm9sbGVyL2J1ZmZlci1jb250cm9sbGVyJztcbmltcG9ydCBDYXBMZXZlbENvbnRyb2xsZXIgZnJvbSAgJy4vY29udHJvbGxlci9jYXAtbGV2ZWwtY29udHJvbGxlcic7XG5pbXBvcnQgRlBTQ29udHJvbGxlciBmcm9tICcuL2NvbnRyb2xsZXIvZnBzLWNvbnRyb2xsZXInO1xuaW1wb3J0IFhockxvYWRlciBmcm9tICcuL3V0aWxzL3hoci1sb2FkZXInO1xuLy9pbXBvcnQgRmV0Y2hMb2FkZXIgZnJvbSAnLi91dGlscy9mZXRjaC1sb2FkZXInO1xuLy8jaWYgYWx0YXVkaW9cbmltcG9ydCBBdWRpb1RyYWNrQ29udHJvbGxlciBmcm9tICcuL2NvbnRyb2xsZXIvYXVkaW8tdHJhY2stY29udHJvbGxlcic7XG5pbXBvcnQgQXVkaW9TdHJlYW1Db250cm9sbGVyIGZyb20gICcuL2NvbnRyb2xsZXIvYXVkaW8tc3RyZWFtLWNvbnRyb2xsZXInO1xuLy8jZW5kaWZcblxuLy8jaWYgc3VidGl0bGVcbmltcG9ydCBDdWVzIGZyb20gJy4vdXRpbHMvY3Vlcyc7XG5pbXBvcnQgVGltZWxpbmVDb250cm9sbGVyIGZyb20gJy4vY29udHJvbGxlci90aW1lbGluZS1jb250cm9sbGVyJztcbmltcG9ydCBTdWJ0aXRsZVRyYWNrQ29udHJvbGxlciBmcm9tICcuL2NvbnRyb2xsZXIvc3VidGl0bGUtdHJhY2stY29udHJvbGxlcic7XG5pbXBvcnQgU3VidGl0bGVTdHJlYW1Db250cm9sbGVyIGZyb20gICcuL2NvbnRyb2xsZXIvc3VidGl0bGUtc3RyZWFtLWNvbnRyb2xsZXInO1xuLy8jZW5kaWZcblxuZXhwb3J0IHZhciBobHNEZWZhdWx0Q29uZmlnID0ge1xuICAgICAgYXV0b1N0YXJ0TG9hZDogdHJ1ZSwgICAgICAgICAgICAgICAgICAgIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcbiAgICAgIHN0YXJ0UG9zaXRpb246IC0xLCAgICAgICAgICAgICAgICAgICAgICAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXG4gICAgICBkZWZhdWx0QXVkaW9Db2RlYzogdW5kZWZpbmVkLCAgICAgICAgICAgLy8gdXNlZCBieSBzdHJlYW0tY29udHJvbGxlclxuICAgICAgZGVidWc6IGZhbHNlLCAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHVzZWQgYnkgbG9nZ2VyXG4gICAgICBjYXBMZXZlbE9uRlBTRHJvcDogZmFsc2UsICAgICAgICAgICAgICAgLy8gdXNlZCBieSBmcHMtY29udHJvbGxlclxuICAgICAgY2FwTGV2ZWxUb1BsYXllclNpemU6IGZhbHNlLCAgICAgICAgICAgIC8vIHVzZWQgYnkgY2FwLWxldmVsLWNvbnRyb2xsZXJcbiAgICAgIGluaXRpYWxMaXZlTWFuaWZlc3RTaXplOiAxLCAgICAgICAgICAgICAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXG4gICAgICBtYXhCdWZmZXJMZW5ndGg6IDMwLCAgICAgICAgICAgICAgICAgICAgLy8gdXNlZCBieSBzdHJlYW0tY29udHJvbGxlclxuICAgICAgbWF4QnVmZmVyU2l6ZTogNjAgKiAxMDAwICogMTAwMCwgICAgICAgIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcbiAgICAgIG1heEJ1ZmZlckhvbGU6IDAuNSwgICAgICAgICAgICAgICAgICAgICAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXG4gICAgICBtYXhTZWVrSG9sZTogMiwgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdXNlZCBieSBzdHJlYW0tY29udHJvbGxlclxuICAgICAgbG93QnVmZmVyV2F0Y2hkb2dQZXJpb2Q6IDAuNSwgICAgICAgICAgIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcbiAgICAgIGhpZ2hCdWZmZXJXYXRjaGRvZ1BlcmlvZDogMywgICAgICAgICAgICAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXG4gICAgICBudWRnZU9mZnNldDogMC4xLCAgICAgICAgICAgICAgICAgICAgICAgLy8gdXNlZCBieSBzdHJlYW0tY29udHJvbGxlclxuICAgICAgbnVkZ2VNYXhSZXRyeSA6IDMsICAgICAgICAgICAgICAgICAgICAgIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcbiAgICAgIG1heEZyYWdMb29rVXBUb2xlcmFuY2U6IDAuMiwgICAgICAgICAgICAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXG4gICAgICBsaXZlU3luY0R1cmF0aW9uQ291bnQ6MywgICAgICAgICAgICAgICAgLy8gdXNlZCBieSBzdHJlYW0tY29udHJvbGxlclxuICAgICAgbGl2ZU1heExhdGVuY3lEdXJhdGlvbkNvdW50OiBJbmZpbml0eSwgIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcbiAgICAgIGxpdmVTeW5jRHVyYXRpb246IHVuZGVmaW5lZCwgICAgICAgICAgICAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXG4gICAgICBsaXZlTWF4TGF0ZW5jeUR1cmF0aW9uOiB1bmRlZmluZWQsICAgICAgLy8gdXNlZCBieSBzdHJlYW0tY29udHJvbGxlclxuICAgICAgbWF4TWF4QnVmZmVyTGVuZ3RoOiA2MDAsICAgICAgICAgICAgICAgIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcbiAgICAgIGVuYWJsZVdvcmtlcjogdHJ1ZSwgICAgICAgICAgICAgICAgICAgICAvLyB1c2VkIGJ5IGRlbXV4ZXJcbiAgICAgIGVuYWJsZVNvZnR3YXJlQUVTOiB0cnVlLCAgICAgICAgICAgICAgICAvLyB1c2VkIGJ5IGRlY3J5cHRlclxuICAgICAgbWFuaWZlc3RMb2FkaW5nVGltZU91dDogMTAwMDAsICAgICAgICAgIC8vIHVzZWQgYnkgcGxheWxpc3QtbG9hZGVyXG4gICAgICBtYW5pZmVzdExvYWRpbmdNYXhSZXRyeTogMSwgICAgICAgICAgICAgLy8gdXNlZCBieSBwbGF5bGlzdC1sb2FkZXJcbiAgICAgIG1hbmlmZXN0TG9hZGluZ1JldHJ5RGVsYXk6IDEwMDAsICAgICAgICAvLyB1c2VkIGJ5IHBsYXlsaXN0LWxvYWRlclxuICAgICAgbWFuaWZlc3RMb2FkaW5nTWF4UmV0cnlUaW1lb3V0OiA2NDAwMCwgIC8vIHVzZWQgYnkgcGxheWxpc3QtbG9hZGVyXG4gICAgICBzdGFydExldmVsOiB1bmRlZmluZWQsICAgICAgICAgICAgICAgICAgLy8gdXNlZCBieSBsZXZlbC1jb250cm9sbGVyXG4gICAgICBsZXZlbExvYWRpbmdUaW1lT3V0OiAxMDAwMCwgICAgICAgICAgICAgLy8gdXNlZCBieSBwbGF5bGlzdC1sb2FkZXJcbiAgICAgIGxldmVsTG9hZGluZ01heFJldHJ5OiA0LCAgICAgICAgICAgICAgICAvLyB1c2VkIGJ5IHBsYXlsaXN0LWxvYWRlclxuICAgICAgbGV2ZWxMb2FkaW5nUmV0cnlEZWxheTogMTAwMCwgICAgICAgICAgIC8vIHVzZWQgYnkgcGxheWxpc3QtbG9hZGVyXG4gICAgICBsZXZlbExvYWRpbmdNYXhSZXRyeVRpbWVvdXQ6IDY0MDAwLCAgICAgLy8gdXNlZCBieSBwbGF5bGlzdC1sb2FkZXJcbiAgICAgIGZyYWdMb2FkaW5nVGltZU91dDogMjAwMDAsICAgICAgICAgICAgICAvLyB1c2VkIGJ5IGZyYWdtZW50LWxvYWRlclxuICAgICAgZnJhZ0xvYWRpbmdNYXhSZXRyeTogNiwgICAgICAgICAgICAgICAgIC8vIHVzZWQgYnkgZnJhZ21lbnQtbG9hZGVyXG4gICAgICBmcmFnTG9hZGluZ1JldHJ5RGVsYXk6IDEwMDAsICAgICAgICAgICAgLy8gdXNlZCBieSBmcmFnbWVudC1sb2FkZXJcbiAgICAgIGZyYWdMb2FkaW5nTWF4UmV0cnlUaW1lb3V0OiA2NDAwMCwgICAgICAvLyB1c2VkIGJ5IGZyYWdtZW50LWxvYWRlclxuICAgICAgZnJhZ0xvYWRpbmdMb29wVGhyZXNob2xkOiAzLCAgICAgICAgICAgIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcbiAgICAgIHN0YXJ0RnJhZ1ByZWZldGNoOiBmYWxzZSwgICAgICAgICAgICAgICAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXG4gICAgICBmcHNEcm9wcGVkTW9uaXRvcmluZ1BlcmlvZDogNTAwMCwgICAgICAgLy8gdXNlZCBieSBmcHMtY29udHJvbGxlclxuICAgICAgZnBzRHJvcHBlZE1vbml0b3JpbmdUaHJlc2hvbGQ6IDAuMiwgICAgIC8vIHVzZWQgYnkgZnBzLWNvbnRyb2xsZXJcbiAgICAgIGFwcGVuZEVycm9yTWF4UmV0cnk6IDMsICAgICAgICAgICAgICAgICAvLyB1c2VkIGJ5IGJ1ZmZlci1jb250cm9sbGVyXG4gICAgICBsb2FkZXI6IFhockxvYWRlcixcbiAgICAgIC8vbG9hZGVyOiBGZXRjaExvYWRlcixcbiAgICAgIGZMb2FkZXI6IHVuZGVmaW5lZCxcbiAgICAgIHBMb2FkZXI6IHVuZGVmaW5lZCxcbiAgICAgIHhoclNldHVwOiB1bmRlZmluZWQsXG4gICAgICBmZXRjaFNldHVwOiB1bmRlZmluZWQsXG4gICAgICBhYnJDb250cm9sbGVyOiBBYnJDb250cm9sbGVyLFxuICAgICAgYnVmZmVyQ29udHJvbGxlcjogQnVmZmVyQ29udHJvbGxlcixcbiAgICAgIGNhcExldmVsQ29udHJvbGxlcjogQ2FwTGV2ZWxDb250cm9sbGVyLFxuICAgICAgZnBzQ29udHJvbGxlcjogRlBTQ29udHJvbGxlcixcbi8vI2lmIGFsdGF1ZGlvXG4gICAgICBhdWRpb1N0cmVhbUNvbnRyb2xsZXI6IEF1ZGlvU3RyZWFtQ29udHJvbGxlcixcbiAgICAgIGF1ZGlvVHJhY2tDb250cm9sbGVyIDogQXVkaW9UcmFja0NvbnRyb2xsZXIsXG4vLyNlbmRpZlxuLy8jaWYgc3VidGl0bGVcbiAgICAgIHN1YnRpdGxlU3RyZWFtQ29udHJvbGxlcjogU3VidGl0bGVTdHJlYW1Db250cm9sbGVyLFxuICAgICAgc3VidGl0bGVUcmFja0NvbnRyb2xsZXI6IFN1YnRpdGxlVHJhY2tDb250cm9sbGVyLFxuICAgICAgdGltZWxpbmVDb250cm9sbGVyOiBUaW1lbGluZUNvbnRyb2xsZXIsXG4gICAgICBjdWVIYW5kbGVyOiBDdWVzLFxuICAgICAgZW5hYmxlQ0VBNzA4Q2FwdGlvbnM6IHRydWUsICAgICAgICAgICAgICAgLy8gdXNlZCBieSB0aW1lbGluZS1jb250cm9sbGVyXG4gICAgICBlbmFibGVXZWJWVFQ6IHRydWUsICAgICAgICAgICAgICAgICAgICAgICAvLyB1c2VkIGJ5IHRpbWVsaW5lLWNvbnRyb2xsZXJcbiAgICAgIGNhcHRpb25zVGV4dFRyYWNrMUxhYmVsOiAnRW5nbGlzaCcsICAgICAgIC8vIHVzZWQgYnkgdGltZWxpbmUtY29udHJvbGxlclxuICAgICAgY2FwdGlvbnNUZXh0VHJhY2sxTGFuZ3VhZ2VDb2RlOiAnZW4nLCAgICAgIC8vIHVzZWQgYnkgdGltZWxpbmUtY29udHJvbGxlclxuICAgICAgY2FwdGlvbnNUZXh0VHJhY2syTGFiZWw6ICdTcGFuaXNoJywgICAgICAgLy8gdXNlZCBieSB0aW1lbGluZS1jb250cm9sbGVyXG4gICAgICBjYXB0aW9uc1RleHRUcmFjazJMYW5ndWFnZUNvZGU6ICdlcycsICAgICAvLyB1c2VkIGJ5IHRpbWVsaW5lLWNvbnRyb2xsZXJcbi8vI2VuZGlmXG4gICAgICBzdHJldGNoU2hvcnRWaWRlb1RyYWNrOiBmYWxzZSwgICAgICAgICAgICAvLyB1c2VkIGJ5IG1wNC1yZW11eGVyXG4gICAgICBmb3JjZUtleUZyYW1lT25EaXNjb250aW51aXR5OiB0cnVlLCAgICAgICAvLyB1c2VkIGJ5IHRzLWRlbXV4ZXJcbiAgICAgIGFickV3bWFGYXN0TGl2ZTogMywgICAgICAgICAgICAgICAgICAgICAgIC8vIHVzZWQgYnkgYWJyLWNvbnRyb2xsZXJcbiAgICAgIGFickV3bWFTbG93TGl2ZTogOSwgICAgICAgICAgICAgICAgICAgICAgIC8vIHVzZWQgYnkgYWJyLWNvbnRyb2xsZXJcbiAgICAgIGFickV3bWFGYXN0Vm9EOiAzLCAgICAgICAgICAgICAgICAgICAgICAgIC8vIHVzZWQgYnkgYWJyLWNvbnRyb2xsZXJcbiAgICAgIGFickV3bWFTbG93Vm9EOiA5LCAgICAgICAgICAgICAgICAgICAgICAgIC8vIHVzZWQgYnkgYWJyLWNvbnRyb2xsZXJcbiAgICAgIGFickV3bWFEZWZhdWx0RXN0aW1hdGU6IDVlNSwgLy8gNTAwIGticHMgIC8vIHVzZWQgYnkgYWJyLWNvbnRyb2xsZXJcbiAgICAgIGFickJhbmRXaWR0aEZhY3RvciA6IDAuOTUsICAgICAgICAgICAgICAgIC8vIHVzZWQgYnkgYWJyLWNvbnRyb2xsZXJcbiAgICAgIGFickJhbmRXaWR0aFVwRmFjdG9yIDogMC43LCAgICAgICAgICAgICAgIC8vIHVzZWQgYnkgYWJyLWNvbnRyb2xsZXJcbiAgICAgIGFick1heFdpdGhSZWFsQml0cmF0ZSA6IGZhbHNlLCAgICAgICAgICAgIC8vIHVzZWQgYnkgYWJyLWNvbnRyb2xsZXJcbiAgICAgIG1heFN0YXJ2YXRpb25EZWxheSA6IDQsICAgICAgICAgICAgICAgICAgIC8vIHVzZWQgYnkgYWJyLWNvbnRyb2xsZXJcbiAgICAgIG1heExvYWRpbmdEZWxheSA6IDQsICAgICAgICAgICAgICAgICAgICAgIC8vIHVzZWQgYnkgYWJyLWNvbnRyb2xsZXJcbiAgICAgIG1pbkF1dG9CaXRyYXRlOiAwICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHVzZWQgYnkgaGxzXG4gICAgfTtcbiIsIi8qXG4gKiBzaW1wbGUgQUJSIENvbnRyb2xsZXJcbiAqICAtIGNvbXB1dGUgbmV4dCBsZXZlbCBiYXNlZCBvbiBsYXN0IGZyYWdtZW50IGJ3IGhldXJpc3RpY3NcbiAqICAtIGltcGxlbWVudCBhbiBhYmFuZG9uIHJ1bGVzIHRyaWdnZXJlZCBpZiB3ZSBoYXZlIGxlc3MgdGhhbiAyIGZyYWcgYnVmZmVyZWQgYW5kIGlmIGNvbXB1dGVkIGJ3IHNob3dzIHRoYXQgd2UgcmlzayBidWZmZXIgc3RhbGxpbmdcbiAqL1xuXG5pbXBvcnQgRXZlbnQgZnJvbSAnLi4vZXZlbnRzJztcbmltcG9ydCBFdmVudEhhbmRsZXIgZnJvbSAnLi4vZXZlbnQtaGFuZGxlcic7XG5pbXBvcnQgQnVmZmVySGVscGVyIGZyb20gJy4uL2hlbHBlci9idWZmZXItaGVscGVyJztcbmltcG9ydCB7RXJyb3JEZXRhaWxzfSBmcm9tICcuLi9lcnJvcnMnO1xuaW1wb3J0IHtsb2dnZXJ9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XG5pbXBvcnQgRXdtYUJhbmRXaWR0aEVzdGltYXRvciBmcm9tICcuLi91dGlscy9ld21hLWJhbmR3aWR0aC1lc3RpbWF0b3InO1xuXG5jbGFzcyBBYnJDb250cm9sbGVyIGV4dGVuZHMgRXZlbnRIYW5kbGVyIHtcblxuICBjb25zdHJ1Y3RvcihobHMpIHtcbiAgICBzdXBlcihobHMsIEV2ZW50LkZSQUdfTE9BRElORyxcbiAgICAgICAgICAgICAgIEV2ZW50LkZSQUdfTE9BREVELFxuICAgICAgICAgICAgICAgRXZlbnQuRlJBR19CVUZGRVJFRCxcbiAgICAgICAgICAgICAgIEV2ZW50LkVSUk9SKTtcbiAgICB0aGlzLmxhc3RMb2FkZWRGcmFnTGV2ZWwgPSAwO1xuICAgIHRoaXMuX25leHRBdXRvTGV2ZWwgPSAtMTtcbiAgICB0aGlzLmhscyA9IGhscztcbiAgICB0aGlzLm9uQ2hlY2sgPSB0aGlzLl9hYmFuZG9uUnVsZXNDaGVjay5iaW5kKHRoaXMpO1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmNsZWFyVGltZXIoKTtcbiAgICBFdmVudEhhbmRsZXIucHJvdG90eXBlLmRlc3Ryb3kuY2FsbCh0aGlzKTtcbiAgfVxuXG4gIG9uRnJhZ0xvYWRpbmcoZGF0YSkge1xuICAgIGxldCBmcmFnID0gZGF0YS5mcmFnO1xuICAgIGlmIChmcmFnLnR5cGUgPT09ICdtYWluJykge1xuICAgICAgaWYgKCF0aGlzLnRpbWVyKSB7XG4gICAgICAgIHRoaXMudGltZXIgPSBzZXRJbnRlcnZhbCh0aGlzLm9uQ2hlY2ssIDEwMCk7XG4gICAgICB9XG4gICAgICAvLyBsYXp5IGluaXQgb2YgYncgRXN0aW1hdG9yLCByYXRpb25hbGUgaXMgdGhhdCB3ZSB1c2UgZGlmZmVyZW50IHBhcmFtcyBmb3IgTGl2ZS9Wb0RcbiAgICAgIC8vIHNvIHdlIG5lZWQgdG8gd2FpdCBmb3Igc3RyZWFtIG1hbmlmZXN0IC8gcGxheWxpc3QgdHlwZSB0byBpbnN0YW50aWF0ZSBpdC5cbiAgICAgIGlmICghdGhpcy5fYndFc3RpbWF0b3IpIHtcbiAgICAgICAgbGV0IGhscyA9IHRoaXMuaGxzLFxuICAgICAgICAgICAgbGV2ZWwgPSBkYXRhLmZyYWcubGV2ZWwsXG4gICAgICAgICAgICBpc0xpdmUgPSBobHMubGV2ZWxzW2xldmVsXS5kZXRhaWxzLmxpdmUsXG4gICAgICAgICAgICBjb25maWcgPSBobHMuY29uZmlnLFxuICAgICAgICAgICAgZXdtYUZhc3QsIGV3bWFTbG93O1xuXG4gICAgICAgIGlmIChpc0xpdmUpIHtcbiAgICAgICAgICBld21hRmFzdCA9IGNvbmZpZy5hYnJFd21hRmFzdExpdmU7XG4gICAgICAgICAgZXdtYVNsb3cgPSBjb25maWcuYWJyRXdtYVNsb3dMaXZlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGV3bWFGYXN0ID0gY29uZmlnLmFickV3bWFGYXN0Vm9EO1xuICAgICAgICAgIGV3bWFTbG93ID0gY29uZmlnLmFickV3bWFTbG93Vm9EO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2J3RXN0aW1hdG9yID0gbmV3IEV3bWFCYW5kV2lkdGhFc3RpbWF0b3IoaGxzLGV3bWFTbG93LGV3bWFGYXN0LGNvbmZpZy5hYnJFd21hRGVmYXVsdEVzdGltYXRlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZnJhZ0N1cnJlbnQgPSBmcmFnO1xuICAgIH1cbiAgfVxuXG4gIF9hYmFuZG9uUnVsZXNDaGVjaygpIHtcbiAgICAvKlxuICAgICAgbW9uaXRvciBmcmFnbWVudCByZXRyaWV2YWwgdGltZS4uLlxuICAgICAgd2UgY29tcHV0ZSBleHBlY3RlZCB0aW1lIG9mIGFycml2YWwgb2YgdGhlIGNvbXBsZXRlIGZyYWdtZW50LlxuICAgICAgd2UgY29tcGFyZSBpdCB0byBleHBlY3RlZCB0aW1lIG9mIGJ1ZmZlciBzdGFydmF0aW9uXG4gICAgKi9cbiAgICBsZXQgaGxzID0gdGhpcy5obHMsIHYgPSBobHMubWVkaWEsZnJhZyA9IHRoaXMuZnJhZ0N1cnJlbnQsIGxvYWRlciA9IGZyYWcubG9hZGVyLCBtaW5BdXRvTGV2ZWwgPSBobHMubWluQXV0b0xldmVsO1xuXG4gICAgLy8gaWYgbG9hZGVyIGhhcyBiZWVuIGRlc3Ryb3llZCBvciBsb2FkaW5nIGhhcyBiZWVuIGFib3J0ZWQsIHN0b3AgdGltZXIgYW5kIHJldHVyblxuICAgIGlmKCFsb2FkZXIgfHwgKCBsb2FkZXIuc3RhdHMgJiYgbG9hZGVyLnN0YXRzLmFib3J0ZWQpKSB7XG4gICAgICBsb2dnZXIud2FybignZnJhZyBsb2FkZXIgZGVzdHJveSBvciBhYm9ydGVkLCBkaXNhcm0gYWJhbmRvblJ1bGVzJyk7XG4gICAgICB0aGlzLmNsZWFyVGltZXIoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IHN0YXRzID0gbG9hZGVyLnN0YXRzO1xuICAgIC8qIG9ubHkgbW9uaXRvciBmcmFnIHJldHJpZXZhbCB0aW1lIGlmXG4gICAgKHZpZGVvIG5vdCBwYXVzZWQgT1IgZmlyc3QgZnJhZ21lbnQgYmVpbmcgbG9hZGVkKHJlYWR5IHN0YXRlID09PSBIQVZFX05PVEhJTkcgPSAwKSkgQU5EIGF1dG9zd2l0Y2hpbmcgZW5hYmxlZCBBTkQgbm90IGxvd2VzdCBsZXZlbCAoPT4gbWVhbnMgdGhhdCB3ZSBoYXZlIHNldmVyYWwgbGV2ZWxzKSAqL1xuICAgIGlmICh2ICYmICgoIXYucGF1c2VkICYmICh2LnBsYXliYWNrUmF0ZSAhPT0gMCkpIHx8ICF2LnJlYWR5U3RhdGUpICYmIGZyYWcuYXV0b0xldmVsICYmIGZyYWcubGV2ZWwpIHtcbiAgICAgIGxldCByZXF1ZXN0RGVsYXkgPSBwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXRzLnRyZXF1ZXN0LFxuICAgICAgICAgIHBsYXliYWNrUmF0ZSA9IE1hdGguYWJzKHYucGxheWJhY2tSYXRlKTtcbiAgICAgIC8vIG1vbml0b3IgZnJhZ21lbnQgbG9hZCBwcm9ncmVzcyBhZnRlciBoYWxmIG9mIGV4cGVjdGVkIGZyYWdtZW50IGR1cmF0aW9uLHRvIHN0YWJpbGl6ZSBiaXRyYXRlXG4gICAgICBpZiAocmVxdWVzdERlbGF5ID4gKDUwMCAqIGZyYWcuZHVyYXRpb24gLyBwbGF5YmFja1JhdGUpKSB7XG4gICAgICAgIGxldCBsZXZlbHMgPSBobHMubGV2ZWxzLFxuICAgICAgICAgICAgbG9hZFJhdGUgPSBNYXRoLm1heCgxLCBzdGF0cy5idyA/IHN0YXRzLmJ3IC8gOCA6IHN0YXRzLmxvYWRlZCAqIDEwMDAgLyByZXF1ZXN0RGVsYXkpLCAvLyBieXRlL3M7IGF0IGxlYXN0IDEgYnl0ZS9zIHRvIGF2b2lkIGRpdmlzaW9uIGJ5IHplcm9cbiAgICAgICAgICAgIC8vIGNvbXB1dGUgZXhwZWN0ZWQgZnJhZ21lbnQgbGVuZ3RoIHVzaW5nIGZyYWcgZHVyYXRpb24gYW5kIGxldmVsIGJpdHJhdGUuIGFsc28gZW5zdXJlIHRoYXQgZXhwZWN0ZWQgbGVuIGlzIGd0ZSB0aGFuIGFscmVhZHkgbG9hZGVkIHNpemVcbiAgICAgICAgICAgIGxldmVsID0gbGV2ZWxzW2ZyYWcubGV2ZWxdLFxuICAgICAgICAgICAgbGV2ZWxCaXRyYXRlID0gbGV2ZWwucmVhbEJpdHJhdGUgPyBNYXRoLm1heChsZXZlbC5yZWFsQml0cmF0ZSxsZXZlbC5iaXRyYXRlKSA6IGxldmVsLmJpdHJhdGUsXG4gICAgICAgICAgICBleHBlY3RlZExlbiA9IHN0YXRzLnRvdGFsID8gc3RhdHMudG90YWwgOiBNYXRoLm1heChzdGF0cy5sb2FkZWQsIE1hdGgucm91bmQoZnJhZy5kdXJhdGlvbiAqIGxldmVsQml0cmF0ZSAvIDgpKSxcbiAgICAgICAgICAgIHBvcyA9IHYuY3VycmVudFRpbWUsXG4gICAgICAgICAgICBmcmFnTG9hZGVkRGVsYXkgPSAoZXhwZWN0ZWRMZW4gLSBzdGF0cy5sb2FkZWQpIC8gbG9hZFJhdGUsXG4gICAgICAgICAgICBidWZmZXJTdGFydmF0aW9uRGVsYXkgPSAoQnVmZmVySGVscGVyLmJ1ZmZlckluZm8odixwb3MsaGxzLmNvbmZpZy5tYXhCdWZmZXJIb2xlKS5lbmQgLSBwb3MpIC8gcGxheWJhY2tSYXRlO1xuICAgICAgICAvLyBjb25zaWRlciBlbWVyZ2VuY3kgc3dpdGNoIGRvd24gb25seSBpZiB3ZSBoYXZlIGxlc3MgdGhhbiAyIGZyYWcgYnVmZmVyZWQgQU5EXG4gICAgICAgIC8vIHRpbWUgdG8gZmluaXNoIGxvYWRpbmcgY3VycmVudCBmcmFnbWVudCBpcyBiaWdnZXIgdGhhbiBidWZmZXIgc3RhcnZhdGlvbiBkZWxheVxuICAgICAgICAvLyBpZSBpZiB3ZSByaXNrIGJ1ZmZlciBzdGFydmF0aW9uIGlmIGJ3IGRvZXMgbm90IGluY3JlYXNlIHF1aWNrbHlcbiAgICAgICAgaWYgKChidWZmZXJTdGFydmF0aW9uRGVsYXkgPCAoMiAqIGZyYWcuZHVyYXRpb24gLyBwbGF5YmFja1JhdGUpKSAmJiAoZnJhZ0xvYWRlZERlbGF5ID4gYnVmZmVyU3RhcnZhdGlvbkRlbGF5KSkge1xuICAgICAgICAgIGxldCBmcmFnTGV2ZWxOZXh0TG9hZGVkRGVsYXksIG5leHRMb2FkTGV2ZWw7XG4gICAgICAgICAgLy8gbGV0cyBpdGVyYXRlIHRocm91Z2ggbG93ZXIgbGV2ZWwgYW5kIHRyeSB0byBmaW5kIHRoZSBiaWdnZXN0IG9uZSB0aGF0IGNvdWxkIGF2b2lkIHJlYnVmZmVyaW5nXG4gICAgICAgICAgLy8gd2Ugc3RhcnQgZnJvbSBjdXJyZW50IGxldmVsIC0gMSBhbmQgd2Ugc3RlcCBkb3duICwgdW50aWwgd2UgZmluZCBhIG1hdGNoaW5nIGxldmVsXG4gICAgICAgICAgZm9yIChuZXh0TG9hZExldmVsID0gZnJhZy5sZXZlbCAtIDEgOyBuZXh0TG9hZExldmVsID4gbWluQXV0b0xldmVsIDsgbmV4dExvYWRMZXZlbC0tKSB7XG4gICAgICAgICAgICAvLyBjb21wdXRlIHRpbWUgdG8gbG9hZCBuZXh0IGZyYWdtZW50IGF0IGxvd2VyIGxldmVsXG4gICAgICAgICAgICAvLyAwLjggOiBjb25zaWRlciBvbmx5IDgwJSBvZiBjdXJyZW50IGJ3IHRvIGJlIGNvbnNlcnZhdGl2ZVxuICAgICAgICAgICAgLy8gOCA9IGJpdHMgcGVyIGJ5dGUgKGJwcy9CcHMpXG4gICAgICAgICAgICBsZXQgbGV2ZWxOZXh0Qml0cmF0ZSA9IGxldmVsc1tuZXh0TG9hZExldmVsXS5yZWFsQml0cmF0ZSA/IE1hdGgubWF4KGxldmVsc1tuZXh0TG9hZExldmVsXS5yZWFsQml0cmF0ZSxsZXZlbHNbbmV4dExvYWRMZXZlbF0uYml0cmF0ZSkgOiBsZXZlbHNbbmV4dExvYWRMZXZlbF0uYml0cmF0ZTtcbiAgICAgICAgICAgIGZyYWdMZXZlbE5leHRMb2FkZWREZWxheSA9IGZyYWcuZHVyYXRpb24gKiBsZXZlbE5leHRCaXRyYXRlIC8gKDggKiAwLjggKiBsb2FkUmF0ZSk7XG4gICAgICAgICAgICBpZiAoZnJhZ0xldmVsTmV4dExvYWRlZERlbGF5IDwgYnVmZmVyU3RhcnZhdGlvbkRlbGF5KSB7XG4gICAgICAgICAgICAgIC8vIHdlIGZvdW5kIGEgbG93ZXIgbGV2ZWwgdGhhdCBiZSByZWJ1ZmZlcmluZyBmcmVlIHdpdGggY3VycmVudCBlc3RpbWF0ZWQgYncgIVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gb25seSBlbWVyZ2VuY3kgc3dpdGNoIGRvd24gaWYgaXQgdGFrZXMgbGVzcyB0aW1lIHRvIGxvYWQgbmV3IGZyYWdtZW50IGF0IGxvd2VzdCBsZXZlbCBpbnN0ZWFkXG4gICAgICAgICAgLy8gb2YgZmluaXNoaW5nIGxvYWRpbmcgY3VycmVudCBvbmUgLi4uXG4gICAgICAgICAgaWYgKGZyYWdMZXZlbE5leHRMb2FkZWREZWxheSA8IGZyYWdMb2FkZWREZWxheSkge1xuICAgICAgICAgICAgbG9nZ2VyLndhcm4oYGxvYWRpbmcgdG9vIHNsb3csIGFib3J0IGZyYWdtZW50IGxvYWRpbmcgYW5kIHN3aXRjaCB0byBsZXZlbCAke25leHRMb2FkTGV2ZWx9OmZyYWdMb2FkZWREZWxheVske25leHRMb2FkTGV2ZWx9XTxmcmFnTG9hZGVkRGVsYXlbJHtmcmFnLmxldmVsLTF9XTtidWZmZXJTdGFydmF0aW9uRGVsYXk6JHtmcmFnTGV2ZWxOZXh0TG9hZGVkRGVsYXkudG9GaXhlZCgxKX08JHtmcmFnTG9hZGVkRGVsYXkudG9GaXhlZCgxKX06JHtidWZmZXJTdGFydmF0aW9uRGVsYXkudG9GaXhlZCgxKX1gKTtcbiAgICAgICAgICAgIC8vIGZvcmNlIG5leHQgbG9hZCBsZXZlbCBpbiBhdXRvIG1vZGVcbiAgICAgICAgICAgIGhscy5uZXh0TG9hZExldmVsID0gbmV4dExvYWRMZXZlbDtcbiAgICAgICAgICAgIC8vIHVwZGF0ZSBidyBlc3RpbWF0ZSBmb3IgdGhpcyBmcmFnbWVudCBiZWZvcmUgY2FuY2VsbGluZyBsb2FkICh0aGlzIHdpbGwgaGVscCByZWR1Y2luZyB0aGUgYncpXG4gICAgICAgICAgICB0aGlzLl9id0VzdGltYXRvci5zYW1wbGUocmVxdWVzdERlbGF5LHN0YXRzLmxvYWRlZCk7XG4gICAgICAgICAgICAvL2Fib3J0IGZyYWdtZW50IGxvYWRpbmdcbiAgICAgICAgICAgIGxvYWRlci5hYm9ydCgpO1xuICAgICAgICAgICAgLy8gc3RvcCBhYmFuZG9uIHJ1bGVzIHRpbWVyXG4gICAgICAgICAgICB0aGlzLmNsZWFyVGltZXIoKTtcbiAgICAgICAgICAgIGhscy50cmlnZ2VyKEV2ZW50LkZSQUdfTE9BRF9FTUVSR0VOQ1lfQUJPUlRFRCwge2ZyYWc6IGZyYWcsIHN0YXRzOiBzdGF0cyB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBvbkZyYWdMb2FkZWQoZGF0YSkge1xuICAgIGxldCBmcmFnID0gZGF0YS5mcmFnO1xuICAgIGlmIChmcmFnLnR5cGUgPT09ICdtYWluJyAmJiAhaXNOYU4oZnJhZy5zbikpIHtcbiAgICAgIC8vIHN0b3AgbW9uaXRvcmluZyBidyBvbmNlIGZyYWcgbG9hZGVkXG4gICAgICB0aGlzLmNsZWFyVGltZXIoKTtcbiAgICAgIC8vIHN0b3JlIGxldmVsIGlkIGFmdGVyIHN1Y2Nlc3NmdWwgZnJhZ21lbnQgbG9hZFxuICAgICAgdGhpcy5sYXN0TG9hZGVkRnJhZ0xldmVsID0gZnJhZy5sZXZlbDtcbiAgICAgIC8vIHJlc2V0IGZvcmNlZCBhdXRvIGxldmVsIHZhbHVlIHNvIHRoYXQgbmV4dCBsZXZlbCB3aWxsIGJlIHNlbGVjdGVkXG4gICAgICB0aGlzLl9uZXh0QXV0b0xldmVsID0gLTE7XG5cbiAgICAgIC8vIGNvbXB1dGUgbGV2ZWwgYXZlcmFnZSBiaXRyYXRlXG4gICAgICBpZiAodGhpcy5obHMuY29uZmlnLmFick1heFdpdGhSZWFsQml0cmF0ZSkge1xuICAgICAgICBjb25zdCBsZXZlbCA9IHRoaXMuaGxzLmxldmVsc1tmcmFnLmxldmVsXTtcbiAgICAgICAgbGV0IGxvYWRlZEJ5dGVzID0gKGxldmVsLmxvYWRlZCA/IGxldmVsLmxvYWRlZC5ieXRlcyA6IDApICsgZGF0YS5zdGF0cy5sb2FkZWQ7XG4gICAgICAgIGxldCBsb2FkZWREdXJhdGlvbiA9IChsZXZlbC5sb2FkZWQgPyBsZXZlbC5sb2FkZWQuZHVyYXRpb24gOiAwKSArIGRhdGEuZnJhZy5kdXJhdGlvbjtcbiAgICAgICAgbGV2ZWwubG9hZGVkID0geyBieXRlcyA6IGxvYWRlZEJ5dGVzLCBkdXJhdGlvbiA6IGxvYWRlZER1cmF0aW9uIH07XG4gICAgICAgIGxldmVsLnJlYWxCaXRyYXRlID0gTWF0aC5yb3VuZCg4KmxvYWRlZEJ5dGVzL2xvYWRlZER1cmF0aW9uKTtcbiAgICAgIH1cbiAgICAgIC8vIGlmIGZyYWdtZW50IGhhcyBiZWVuIGxvYWRlZCB0byBwZXJmb3JtIGEgYml0cmF0ZSB0ZXN0LFxuICAgICAgaWYgKGRhdGEuZnJhZy5iaXRyYXRlVGVzdCkge1xuICAgICAgICBsZXQgc3RhdHMgPSBkYXRhLnN0YXRzO1xuICAgICAgICBzdGF0cy50cGFyc2VkID0gc3RhdHMudGJ1ZmZlcmVkID0gc3RhdHMudGxvYWQ7XG4gICAgICAgIHRoaXMub25GcmFnQnVmZmVyZWQoZGF0YSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgb25GcmFnQnVmZmVyZWQoZGF0YSkge1xuICAgIHZhciBzdGF0cyA9IGRhdGEuc3RhdHMsIGZyYWcgPSBkYXRhLmZyYWc7XG4gICAgLy8gb25seSB1cGRhdGUgc3RhdHMgb24gZmlyc3QgZnJhZyBidWZmZXJpbmdcbiAgICAvLyBpZiBzYW1lIGZyYWcgaXMgbG9hZGVkIG11bHRpcGxlIHRpbWVzLCBpdCBtaWdodCBiZSBpbiBicm93c2VyIGNhY2hlLCBhbmQgbG9hZGVkIHF1aWNrbHlcbiAgICAvLyBhbmQgbGVhZGluZyB0byB3cm9uZyBidyBlc3RpbWF0aW9uXG4gICAgLy8gb24gYml0cmF0ZSB0ZXN0LCBhbHNvIG9ubHkgdXBkYXRlIHN0YXRzIG9uY2UgKGlmIHRsb2FkID0gdGJ1ZmZlcmVkID09IG9uIEZSQUdfTE9BREVEKVxuICAgIGlmIChzdGF0cy5hYm9ydGVkICE9PSB0cnVlICYmIGZyYWcubG9hZENvdW50ZXIgPT09IDEgJiYgZnJhZy50eXBlID09PSAnbWFpbicgJiYgIWlzTmFOKGZyYWcuc24pICYmICgoIWZyYWcuYml0cmF0ZVRlc3QgfHwgc3RhdHMudGxvYWQgPT09IHN0YXRzLnRidWZmZXJlZCkpKSB7XG4gICAgICAvLyB1c2UgdHBhcnNlZC10cmVxdWVzdCBpbnN0ZWFkIG9mIHRidWZmZXJlZC10cmVxdWVzdCB0byBjb21wdXRlIGZyYWdMb2FkaW5nUHJvY2Vzc2luZzsgcmF0aW9uYWxlIGlzIHRoYXQgIGJ1ZmZlciBhcHBlbmRpbmcgb25seSBoYXBwZW5zIG9uY2UgbWVkaWEgaXMgYXR0YWNoZWRcbiAgICAgIC8vIGluIGNhc2Ugd2UgdXNlIGNvbmZpZy5zdGFydEZyYWdQcmVmZXRjaCB3aGlsZSBtZWRpYSBpcyBub3QgYXR0YWNoZWQgeWV0LCBmcmFnbWVudCBtaWdodCBiZSBwYXJzZWQgd2hpbGUgbWVkaWEgbm90IGF0dGFjaGVkIHlldCwgYnV0IGl0IHdpbGwgb25seSBiZSBidWZmZXJlZCBvbiBtZWRpYSBhdHRhY2hlZFxuICAgICAgLy8gYXMgYSBjb25zZXF1ZW5jZSBpdCBjb3VsZCBoYXBwZW4gcmVhbGx5IGxhdGUgaW4gdGhlIHByb2Nlc3MuIG1lYW5pbmcgdGhhdCBhcHBlbmRpbmcgZHVyYXRpb24gbWlnaHQgYXBwZWFycyBodWdlIC4uLiBsZWFkaW5nIHRvIHVuZGVyZXN0aW1hdGVkIHRocm91Z2hwdXQgZXN0aW1hdGlvblxuICAgICAgbGV0IGZyYWdMb2FkaW5nUHJvY2Vzc2luZ01zID0gc3RhdHMudHBhcnNlZCAtIHN0YXRzLnRyZXF1ZXN0O1xuICAgICAgbG9nZ2VyLmxvZyhgbGF0ZW5jeS9sb2FkaW5nL3BhcnNpbmcvYXBwZW5kL2ticHM6JHtNYXRoLnJvdW5kKHN0YXRzLnRmaXJzdC1zdGF0cy50cmVxdWVzdCl9LyR7TWF0aC5yb3VuZChzdGF0cy50bG9hZC1zdGF0cy50Zmlyc3QpfS8ke01hdGgucm91bmQoc3RhdHMudHBhcnNlZC1zdGF0cy50bG9hZCl9LyR7TWF0aC5yb3VuZChzdGF0cy50YnVmZmVyZWQtc3RhdHMudHBhcnNlZCl9LyR7TWF0aC5yb3VuZCg4KnN0YXRzLmxvYWRlZC8oc3RhdHMudGJ1ZmZlcmVkLXN0YXRzLnRyZXF1ZXN0KSl9YCk7XG4gICAgICB0aGlzLl9id0VzdGltYXRvci5zYW1wbGUoZnJhZ0xvYWRpbmdQcm9jZXNzaW5nTXMsc3RhdHMubG9hZGVkKTtcbiAgICAgIC8vIGlmIGZyYWdtZW50IGhhcyBiZWVuIGxvYWRlZCB0byBwZXJmb3JtIGEgYml0cmF0ZSB0ZXN0LCAoaGxzLnN0YXJ0TGV2ZWwgPSAtMSksIHN0b3JlIGJpdHJhdGUgdGVzdCBkZWxheSBkdXJhdGlvblxuICAgICAgaWYgKGZyYWcuYml0cmF0ZVRlc3QpIHtcbiAgICAgICAgdGhpcy5iaXRyYXRlVGVzdERlbGF5ID0gZnJhZ0xvYWRpbmdQcm9jZXNzaW5nTXMvMTAwMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYml0cmF0ZVRlc3REZWxheSA9IDA7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgb25FcnJvcihkYXRhKSB7XG4gICAgLy8gc3RvcCB0aW1lciBpbiBjYXNlIG9mIGZyYWcgbG9hZGluZyBlcnJvclxuICAgIHN3aXRjaChkYXRhLmRldGFpbHMpIHtcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkZSQUdfTE9BRF9FUlJPUjpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkZSQUdfTE9BRF9USU1FT1VUOlxuICAgICAgICB0aGlzLmNsZWFyVGltZXIoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuIGNsZWFyVGltZXIoKSB7XG4gICAgaWYgKHRoaXMudGltZXIpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy50aW1lcik7XG4gICAgICB0aGlzLnRpbWVyID0gbnVsbDtcbiAgICB9XG4gfVxuXG4gIC8vIHJldHVybiBuZXh0IGF1dG8gbGV2ZWxcbiAgZ2V0IG5leHRBdXRvTGV2ZWwoKSB7XG4gICAgY29uc3QgZm9yY2VkQXV0b0xldmVsID0gdGhpcy5fbmV4dEF1dG9MZXZlbDtcbiAgICBjb25zdCBid0VzdGltYXRvciA9IHRoaXMuX2J3RXN0aW1hdG9yO1xuICAgIC8vIGluIGNhc2UgbmV4dCBhdXRvIGxldmVsIGhhcyBiZWVuIGZvcmNlZCwgYW5kIGJ3IG5vdCBhdmFpbGFibGUgb3Igbm90IHJlbGlhYmxlLCByZXR1cm4gZm9yY2VkIHZhbHVlXG4gICAgaWYgKGZvcmNlZEF1dG9MZXZlbCAhPT0gLTEgJiYgKCFid0VzdGltYXRvciB8fCAhYndFc3RpbWF0b3IuY2FuRXN0aW1hdGUoKSkpIHtcbiAgICAgIHJldHVybiBmb3JjZWRBdXRvTGV2ZWw7XG4gICAgfVxuICAgIC8vIGNvbXB1dGUgbmV4dCBsZXZlbCB1c2luZyBBQlIgbG9naWNcbiAgICBsZXQgbmV4dEFCUkF1dG9MZXZlbCA9IHRoaXMuX25leHRBQlJBdXRvTGV2ZWw7XG4gICAgLy8gaWYgZm9yY2VkIGF1dG8gbGV2ZWwgaGFzIGJlZW4gZGVmaW5lZCwgdXNlIGl0IHRvIGNhcCBBQlIgY29tcHV0ZWQgcXVhbGl0eSBsZXZlbFxuICAgIGlmIChmb3JjZWRBdXRvTGV2ZWwgIT09IC0xKSB7XG4gICAgICBuZXh0QUJSQXV0b0xldmVsID0gTWF0aC5taW4oZm9yY2VkQXV0b0xldmVsLG5leHRBQlJBdXRvTGV2ZWwpO1xuICAgIH1cbiAgICByZXR1cm4gbmV4dEFCUkF1dG9MZXZlbDtcbiAgfVxuICBnZXQgX25leHRBQlJBdXRvTGV2ZWwoKSB7XG4gICAgdmFyIGhscyA9IHRoaXMuaGxzLCBtYXhBdXRvTGV2ZWwgPSBobHMubWF4QXV0b0xldmVsLCBsZXZlbHMgPSBobHMubGV2ZWxzLCBjb25maWcgPSBobHMuY29uZmlnLCBtaW5BdXRvTGV2ZWwgPSBobHMubWluQXV0b0xldmVsO1xuICAgIGNvbnN0IHYgPSBobHMubWVkaWEsXG4gICAgICAgICAgY3VycmVudExldmVsID0gdGhpcy5sYXN0TG9hZGVkRnJhZ0xldmVsLFxuICAgICAgICAgIGN1cnJlbnRGcmFnRHVyYXRpb24gPSB0aGlzLmZyYWdDdXJyZW50ID8gdGhpcy5mcmFnQ3VycmVudC5kdXJhdGlvbiA6IDAsXG4gICAgICAgICAgcG9zID0gKHYgPyB2LmN1cnJlbnRUaW1lIDogMCksXG4gICAgICAgICAgLy8gcGxheWJhY2tSYXRlIGlzIHRoZSBhYnNvbHV0ZSB2YWx1ZSBvZiB0aGUgcGxheWJhY2sgcmF0ZTsgaWYgdi5wbGF5YmFja1JhdGUgaXMgMCwgd2UgdXNlIDEgdG8gbG9hZCBhc1xuICAgICAgICAgIC8vIGlmIHdlJ3JlIHBsYXlpbmcgYmFjayBhdCB0aGUgbm9ybWFsIHJhdGUuXG4gICAgICAgICAgcGxheWJhY2tSYXRlID0gKCh2ICYmICh2LnBsYXliYWNrUmF0ZSAhPT0gMCkpID8gTWF0aC5hYnModi5wbGF5YmFja1JhdGUpIDogMS4wKSxcbiAgICAgICAgICBhdmdidyA9IHRoaXMuX2J3RXN0aW1hdG9yID8gdGhpcy5fYndFc3RpbWF0b3IuZ2V0RXN0aW1hdGUoKSA6IGNvbmZpZy5hYnJFd21hRGVmYXVsdEVzdGltYXRlLFxuICAgICAgICAgIC8vIGJ1ZmZlclN0YXJ2YXRpb25EZWxheSBpcyB0aGUgd2FsbC1jbG9jayB0aW1lIGxlZnQgdW50aWwgdGhlIHBsYXliYWNrIGJ1ZmZlciBpcyBleGhhdXN0ZWQuXG4gICAgICAgICAgYnVmZmVyU3RhcnZhdGlvbkRlbGF5ID0gKEJ1ZmZlckhlbHBlci5idWZmZXJJbmZvKHYsIHBvcywgY29uZmlnLm1heEJ1ZmZlckhvbGUpLmVuZCAtIHBvcykgLyBwbGF5YmFja1JhdGU7XG5cbiAgICAvLyBGaXJzdCwgbG9vayB0byBzZWUgaWYgd2UgY2FuIGZpbmQgYSBsZXZlbCBtYXRjaGluZyB3aXRoIG91ciBhdmcgYmFuZHdpZHRoIEFORCB0aGF0IGNvdWxkIGFsc28gZ3VhcmFudGVlIG5vIHJlYnVmZmVyaW5nIGF0IGFsbFxuICAgIGxldCBiZXN0TGV2ZWwgPSB0aGlzLl9maW5kQmVzdExldmVsKGN1cnJlbnRMZXZlbCxjdXJyZW50RnJhZ0R1cmF0aW9uLGF2Z2J3LG1pbkF1dG9MZXZlbCxtYXhBdXRvTGV2ZWwsYnVmZmVyU3RhcnZhdGlvbkRlbGF5LGNvbmZpZy5hYnJCYW5kV2lkdGhGYWN0b3IsY29uZmlnLmFickJhbmRXaWR0aFVwRmFjdG9yLGxldmVscyk7XG4gICAgaWYgKGJlc3RMZXZlbCA+PSAwKSB7XG4gICAgICByZXR1cm4gYmVzdExldmVsO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb2dnZXIudHJhY2UoJ3JlYnVmZmVyaW5nIGV4cGVjdGVkIHRvIGhhcHBlbiwgbGV0cyB0cnkgdG8gZmluZCBhIHF1YWxpdHkgbGV2ZWwgbWluaW1pemluZyB0aGUgcmVidWZmZXJpbmcnKTtcbiAgICAgIC8vIG5vdCBwb3NzaWJsZSB0byBnZXQgcmlkIG9mIHJlYnVmZmVyaW5nIC4uLiBsZXQncyB0cnkgdG8gZmluZCBsZXZlbCB0aGF0IHdpbGwgZ3VhcmFudGVlIGxlc3MgdGhhbiBtYXhTdGFydmF0aW9uRGVsYXkgb2YgcmVidWZmZXJpbmdcbiAgICAgIC8vIGlmIG5vIG1hdGNoaW5nIGxldmVsIGZvdW5kLCBsb2dpYyB3aWxsIHJldHVybiAwXG4gICAgICBsZXQgbWF4U3RhcnZhdGlvbkRlbGF5ID0gY3VycmVudEZyYWdEdXJhdGlvbiA/IE1hdGgubWluKGN1cnJlbnRGcmFnRHVyYXRpb24sY29uZmlnLm1heFN0YXJ2YXRpb25EZWxheSkgOiBjb25maWcubWF4U3RhcnZhdGlvbkRlbGF5LFxuICAgICAgICAgIGJ3RmFjdG9yID0gY29uZmlnLmFickJhbmRXaWR0aEZhY3RvcixcbiAgICAgICAgICBid1VwRmFjdG9yID0gY29uZmlnLmFickJhbmRXaWR0aFVwRmFjdG9yO1xuICAgICAgaWYgKGJ1ZmZlclN0YXJ2YXRpb25EZWxheSA9PT0gMCkge1xuICAgICAgICAvLyBpbiBjYXNlIGJ1ZmZlciBpcyBlbXB0eSwgbGV0J3MgY2hlY2sgaWYgcHJldmlvdXMgZnJhZ21lbnQgd2FzIGxvYWRlZCB0byBwZXJmb3JtIGEgYml0cmF0ZSB0ZXN0XG4gICAgICAgIGxldCBiaXRyYXRlVGVzdERlbGF5ID0gdGhpcy5iaXRyYXRlVGVzdERlbGF5O1xuICAgICAgICBpZiAoYml0cmF0ZVRlc3REZWxheSkge1xuICAgICAgICAgIC8vIGlmIGl0IGlzIHRoZSBjYXNlLCB0aGVuIHdlIG5lZWQgdG8gYWRqdXN0IG91ciBtYXggc3RhcnZhdGlvbiBkZWxheSB1c2luZyBtYXhMb2FkaW5nRGVsYXkgY29uZmlnIHZhbHVlXG4gICAgICAgICAgLy8gbWF4IHZpZGVvIGxvYWRpbmcgZGVsYXkgdXNlZCBpbiAgYXV0b21hdGljIHN0YXJ0IGxldmVsIHNlbGVjdGlvbiA6XG4gICAgICAgICAgLy8gaW4gdGhhdCBtb2RlIEFCUiBjb250cm9sbGVyIHdpbGwgZW5zdXJlIHRoYXQgdmlkZW8gbG9hZGluZyB0aW1lIChpZSB0aGUgdGltZSB0byBmZXRjaCB0aGUgZmlyc3QgZnJhZ21lbnQgYXQgbG93ZXN0IHF1YWxpdHkgbGV2ZWwgK1xuICAgICAgICAgIC8vIHRoZSB0aW1lIHRvIGZldGNoIHRoZSBmcmFnbWVudCBhdCB0aGUgYXBwcm9wcmlhdGUgcXVhbGl0eSBsZXZlbCBpcyBsZXNzIHRoYW4gYGBgbWF4TG9hZGluZ0RlbGF5YGBgIClcbiAgICAgICAgICAvLyBjYXAgbWF4TG9hZGluZ0RlbGF5IGFuZCBlbnN1cmUgaXQgaXMgbm90IGJpZ2dlciAndGhhbiBiaXRyYXRlIHRlc3QnIGZyYWcgZHVyYXRpb25cbiAgICAgICAgICBjb25zdCBtYXhMb2FkaW5nRGVsYXkgPSBjdXJyZW50RnJhZ0R1cmF0aW9uID8gTWF0aC5taW4oY3VycmVudEZyYWdEdXJhdGlvbixjb25maWcubWF4TG9hZGluZ0RlbGF5KSA6IGNvbmZpZy5tYXhMb2FkaW5nRGVsYXk7XG4gICAgICAgICAgbWF4U3RhcnZhdGlvbkRlbGF5ID0gbWF4TG9hZGluZ0RlbGF5IC0gYml0cmF0ZVRlc3REZWxheTtcbiAgICAgICAgICBsb2dnZXIudHJhY2UoYGJpdHJhdGUgdGVzdCB0b29rICR7TWF0aC5yb3VuZCgxMDAwKmJpdHJhdGVUZXN0RGVsYXkpfW1zLCBzZXQgZmlyc3QgZnJhZ21lbnQgbWF4IGZldGNoRHVyYXRpb24gdG8gJHtNYXRoLnJvdW5kKDEwMDAqbWF4U3RhcnZhdGlvbkRlbGF5KX0gbXNgKTtcbiAgICAgICAgICAvLyBkb24ndCB1c2UgY29uc2VydmF0aXZlIGZhY3RvciBvbiBiaXRyYXRlIHRlc3RcbiAgICAgICAgICBid0ZhY3RvciA9IGJ3VXBGYWN0b3IgPSAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBiZXN0TGV2ZWwgPSB0aGlzLl9maW5kQmVzdExldmVsKGN1cnJlbnRMZXZlbCxjdXJyZW50RnJhZ0R1cmF0aW9uLGF2Z2J3LG1pbkF1dG9MZXZlbCxtYXhBdXRvTGV2ZWwsYnVmZmVyU3RhcnZhdGlvbkRlbGF5K21heFN0YXJ2YXRpb25EZWxheSxid0ZhY3Rvcixid1VwRmFjdG9yLGxldmVscyk7XG4gICAgICByZXR1cm4gTWF0aC5tYXgoYmVzdExldmVsLDApO1xuICAgIH1cbiAgfVxuXG4gIF9maW5kQmVzdExldmVsKGN1cnJlbnRMZXZlbCxjdXJyZW50RnJhZ0R1cmF0aW9uLGN1cnJlbnRCdyxtaW5BdXRvTGV2ZWwsbWF4QXV0b0xldmVsLG1heEZldGNoRHVyYXRpb24sYndGYWN0b3IsYndVcEZhY3RvcixsZXZlbHMpIHtcbiAgICBmb3IgKGxldCBpID0gbWF4QXV0b0xldmVsOyBpID49IG1pbkF1dG9MZXZlbDsgaS0tKSB7XG4gICAgICBsZXQgbGV2ZWxJbmZvID0gbGV2ZWxzW2ldLFxuICAgICAgICAgIGxldmVsRGV0YWlscyA9IGxldmVsSW5mby5kZXRhaWxzLFxuICAgICAgICAgIGF2Z0R1cmF0aW9uID0gbGV2ZWxEZXRhaWxzID8gbGV2ZWxEZXRhaWxzLnRvdGFsZHVyYXRpb24vbGV2ZWxEZXRhaWxzLmZyYWdtZW50cy5sZW5ndGggOiBjdXJyZW50RnJhZ0R1cmF0aW9uLFxuICAgICAgICAgIGxpdmUgPSBsZXZlbERldGFpbHMgPyBsZXZlbERldGFpbHMubGl2ZSA6IGZhbHNlLFxuICAgICAgICAgIGFkanVzdGVkYnc7XG4gICAgLy8gZm9sbG93IGFsZ29yaXRobSBjYXB0dXJlZCBmcm9tIHN0YWdlZnJpZ2h0IDpcbiAgICAvLyBodHRwczovL2FuZHJvaWQuZ29vZ2xlc291cmNlLmNvbS9wbGF0Zm9ybS9mcmFtZXdvcmtzL2F2LysvbWFzdGVyL21lZGlhL2xpYnN0YWdlZnJpZ2h0L2h0dHBsaXZlL0xpdmVTZXNzaW9uLmNwcFxuICAgIC8vIFBpY2sgdGhlIGhpZ2hlc3QgYmFuZHdpZHRoIHN0cmVhbSBiZWxvdyBvciBlcXVhbCB0byBlc3RpbWF0ZWQgYmFuZHdpZHRoLlxuICAgIC8vIGNvbnNpZGVyIG9ubHkgODAlIG9mIHRoZSBhdmFpbGFibGUgYmFuZHdpZHRoLCBidXQgaWYgd2UgYXJlIHN3aXRjaGluZyB1cCxcbiAgICAvLyBiZSBldmVuIG1vcmUgY29uc2VydmF0aXZlICg3MCUpIHRvIGF2b2lkIG92ZXJlc3RpbWF0aW5nIGFuZCBpbW1lZGlhdGVseVxuICAgIC8vIHN3aXRjaGluZyBiYWNrLlxuICAgICAgaWYgKGkgPD0gY3VycmVudExldmVsKSB7XG4gICAgICAgIGFkanVzdGVkYncgPSBid0ZhY3RvciAqIGN1cnJlbnRCdztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFkanVzdGVkYncgPSBid1VwRmFjdG9yICogY3VycmVudEJ3O1xuICAgICAgfVxuICAgICAgY29uc3QgYml0cmF0ZSA9IGxldmVsc1tpXS5yZWFsQml0cmF0ZSA/IE1hdGgubWF4KGxldmVsc1tpXS5yZWFsQml0cmF0ZSxsZXZlbHNbaV0uYml0cmF0ZSkgOiBsZXZlbHNbaV0uYml0cmF0ZSxcbiAgICAgICAgICAgIGZldGNoRHVyYXRpb24gPSBiaXRyYXRlICogYXZnRHVyYXRpb24gLyBhZGp1c3RlZGJ3O1xuXG4gICAgbG9nZ2VyLnRyYWNlKGBsZXZlbC9hZGp1c3RlZGJ3L2JpdHJhdGUvYXZnRHVyYXRpb24vbWF4RmV0Y2hEdXJhdGlvbi9mZXRjaER1cmF0aW9uOiAke2l9LyR7TWF0aC5yb3VuZChhZGp1c3RlZGJ3KX0vJHtiaXRyYXRlfS8ke2F2Z0R1cmF0aW9ufS8ke21heEZldGNoRHVyYXRpb259LyR7ZmV0Y2hEdXJhdGlvbn1gKTtcbiAgICAgIC8vIGlmIGFkanVzdGVkIGJ3IGlzIGdyZWF0ZXIgdGhhbiBsZXZlbCBiaXRyYXRlIEFORFxuICAgICAgaWYgKGFkanVzdGVkYncgPiBiaXRyYXRlICYmXG4gICAgICAvLyBmcmFnbWVudCBmZXRjaER1cmF0aW9uIHVua25vd24gT1IgbGl2ZSBzdHJlYW0gT1IgZnJhZ21lbnQgZmV0Y2hEdXJhdGlvbiBsZXNzIHRoYW4gbWF4IGFsbG93ZWQgZmV0Y2ggZHVyYXRpb24sIHRoZW4gdGhpcyBsZXZlbCBtYXRjaGVzXG4gICAgICAvLyB3ZSBkb24ndCBhY2NvdW50IGZvciBtYXggRmV0Y2ggRHVyYXRpb24gZm9yIGxpdmUgc3RyZWFtcywgdGhpcyBpcyB0byBhdm9pZCBzd2l0Y2hpbmcgZG93biB3aGVuIG5lYXIgdGhlIGVkZ2Ugb2YgbGl2ZSBzbGlkaW5nIHdpbmRvdyAuLi5cbiAgICAgICAgKCFmZXRjaER1cmF0aW9uIHx8wqBsaXZlIHx8IGZldGNoRHVyYXRpb24gPCBtYXhGZXRjaER1cmF0aW9uKSApIHtcbiAgICAgICAgLy8gYXMgd2UgYXJlIGxvb3BpbmcgZnJvbSBoaWdoZXN0IHRvIGxvd2VzdCwgdGhpcyB3aWxsIHJldHVybiB0aGUgYmVzdCBhY2hpZXZhYmxlIHF1YWxpdHkgbGV2ZWxcblxuICAgICAgICByZXR1cm4gaTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gbm90IGVub3VnaCB0aW1lIGJ1ZGdldCBldmVuIHdpdGggcXVhbGl0eSBsZXZlbCAwIC4uLiByZWJ1ZmZlcmluZyBtaWdodCBoYXBwZW5cbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICBzZXQgbmV4dEF1dG9MZXZlbChuZXh0TGV2ZWwpIHtcbiAgICB0aGlzLl9uZXh0QXV0b0xldmVsID0gbmV4dExldmVsO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEFickNvbnRyb2xsZXI7XG5cbiIsIi8qXG4gKiBBdWRpbyBTdHJlYW0gQ29udHJvbGxlclxuKi9cblxuaW1wb3J0IEJpbmFyeVNlYXJjaCBmcm9tICcuLi91dGlscy9iaW5hcnktc2VhcmNoJztcbmltcG9ydCBCdWZmZXJIZWxwZXIgZnJvbSAnLi4vaGVscGVyL2J1ZmZlci1oZWxwZXInO1xuaW1wb3J0IERlbXV4ZXIgZnJvbSAnLi4vZGVtdXgvZGVtdXhlcic7XG5pbXBvcnQgRXZlbnQgZnJvbSAnLi4vZXZlbnRzJztcbmltcG9ydCBFdmVudEhhbmRsZXIgZnJvbSAnLi4vZXZlbnQtaGFuZGxlcic7XG5pbXBvcnQgTGV2ZWxIZWxwZXIgZnJvbSAnLi4vaGVscGVyL2xldmVsLWhlbHBlcic7XG5pbXBvcnQgVGltZVJhbmdlcyBmcm9tICcuLi91dGlscy90aW1lUmFuZ2VzJztcbmltcG9ydCB7RXJyb3JUeXBlcywgRXJyb3JEZXRhaWxzfSBmcm9tICcuLi9lcnJvcnMnO1xuaW1wb3J0IHtsb2dnZXJ9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XG5pbXBvcnQgeyBmaW5kRnJhZ1dpdGhDQyB9IGZyb20gJy4uL3V0aWxzL2Rpc2NvbnRpbnVpdGllcyc7XG5cbmNvbnN0IFN0YXRlID0ge1xuICBTVE9QUEVEIDogJ1NUT1BQRUQnLFxuICBTVEFSVElORyA6ICdTVEFSVElORycsXG4gIElETEUgOiAnSURMRScsXG4gIFBBVVNFRCA6ICdQQVVTRUQnLFxuICBLRVlfTE9BRElORyA6ICdLRVlfTE9BRElORycsXG4gIEZSQUdfTE9BRElORyA6ICdGUkFHX0xPQURJTkcnLFxuICBGUkFHX0xPQURJTkdfV0FJVElOR19SRVRSWSA6ICdGUkFHX0xPQURJTkdfV0FJVElOR19SRVRSWScsXG4gIFdBSVRJTkdfVFJBQ0sgOiAnV0FJVElOR19UUkFDSycsXG4gIFBBUlNJTkcgOiAnUEFSU0lORycsXG4gIFBBUlNFRCA6ICdQQVJTRUQnLFxuICBCVUZGRVJfRkxVU0hJTkcgOiAnQlVGRkVSX0ZMVVNISU5HJyxcbiAgRU5ERUQgOiAnRU5ERUQnLFxuICBFUlJPUiA6ICdFUlJPUicsXG4gIFdBSVRJTkdfSU5JVF9QVFMgOiAnV0FJVElOR19JTklUX1BUUydcbn07XG5cbmNsYXNzIEF1ZGlvU3RyZWFtQ29udHJvbGxlciBleHRlbmRzIEV2ZW50SGFuZGxlciB7XG5cbiAgY29uc3RydWN0b3IoaGxzKSB7XG4gICAgc3VwZXIoaGxzLFxuICAgICAgRXZlbnQuTUVESUFfQVRUQUNIRUQsXG4gICAgICBFdmVudC5NRURJQV9ERVRBQ0hJTkcsXG4gICAgICBFdmVudC5BVURJT19UUkFDS1NfVVBEQVRFRCxcbiAgICAgIEV2ZW50LkFVRElPX1RSQUNLX1NXSVRDSElORyxcbiAgICAgIEV2ZW50LkFVRElPX1RSQUNLX0xPQURFRCxcbiAgICAgIEV2ZW50LktFWV9MT0FERUQsXG4gICAgICBFdmVudC5GUkFHX0xPQURFRCxcbiAgICAgIEV2ZW50LkZSQUdfUEFSU0lOR19JTklUX1NFR01FTlQsXG4gICAgICBFdmVudC5GUkFHX1BBUlNJTkdfREFUQSxcbiAgICAgIEV2ZW50LkZSQUdfUEFSU0VELFxuICAgICAgRXZlbnQuRVJST1IsXG4gICAgICBFdmVudC5CVUZGRVJfQ1JFQVRFRCxcbiAgICAgIEV2ZW50LkJVRkZFUl9BUFBFTkRFRCxcbiAgICAgIEV2ZW50LkJVRkZFUl9GTFVTSEVELFxuICAgICAgRXZlbnQuSU5JVF9QVFNfRk9VTkQpO1xuXG4gICAgdGhpcy5jb25maWcgPSBobHMuY29uZmlnO1xuICAgIHRoaXMuYXVkaW9Db2RlY1N3YXAgPSBmYWxzZTtcbiAgICB0aGlzLnRpY2tzID0gMDtcbiAgICB0aGlzLl9zdGF0ZSA9IFN0YXRlLlNUT1BQRUQ7XG4gICAgdGhpcy5vbnRpY2sgPSB0aGlzLnRpY2suYmluZCh0aGlzKTtcbiAgICB0aGlzLmluaXRQVFM9W107XG4gICAgdGhpcy53YWl0aW5nRnJhZ21lbnQ9bnVsbDtcbiAgICB0aGlzLnZpZGVvVHJhY2tDQyA9IG51bGw7XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuc3RvcExvYWQoKTtcbiAgICBpZiAodGhpcy50aW1lcikge1xuICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLnRpbWVyKTtcbiAgICAgIHRoaXMudGltZXIgPSBudWxsO1xuICAgIH1cbiAgICBFdmVudEhhbmRsZXIucHJvdG90eXBlLmRlc3Ryb3kuY2FsbCh0aGlzKTtcbiAgICB0aGlzLnN0YXRlID0gU3RhdGUuU1RPUFBFRDtcbiAgfVxuXG4gIC8vU2lnbmFsIHRoYXQgdmlkZW8gUFRTIHdhcyBmb3VuZFxuICBvbkluaXRQdHNGb3VuZChkYXRhKSB7XG4gICAgdmFyIGRlbXV4ZXJJZD1kYXRhLmlkLCBjYyA9IGRhdGEuZnJhZy5jYywgaW5pdFBUUyA9IGRhdGEuaW5pdFBUUztcbiAgICBpZihkZW11eGVySWQgPT09ICdtYWluJykge1xuICAgICAgLy9BbHdheXMgdXBkYXRlIHRoZSBuZXcgSU5JVCBQVFNcbiAgICAgIC8vQ2FuIGNoYW5nZSBkdWUgbGV2ZWwgc3dpdGNoXG4gICAgICB0aGlzLmluaXRQVFNbY2NdID0gaW5pdFBUUztcbiAgICAgIHRoaXMudmlkZW9UcmFja0NDID0gY2M7XG4gICAgICBsb2dnZXIubG9nKGBJbml0UFRTIGZvciBjYzoke2NjfSBmb3VuZCBmcm9tIHZpZGVvIHRyYWNrOiR7aW5pdFBUU31gKTtcblxuICAgICAgLy9JZiB3ZSBhcmUgd2FpdGluZyB3ZSBuZWVkIHRvIGRlbXV4L3JlbXV4IHRoZSB3YWl0aW5nIGZyYWdcbiAgICAgIC8vV2l0aCB0aGUgbmV3IGluaXRQVFNcbiAgICAgIGlmICh0aGlzLnN0YXRlID09PSBTdGF0ZS5XQUlUSU5HX0lOSVRfUFRTKSB7XG4gICAgICAgIGxvZ2dlci5sb2coJ3NlbmRpbmcgcGVuZGluZyBhdWRpbyBmcmFnIHRvIGRlbXV4ZXInKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkZSQUdfTE9BRElORztcbiAgICAgICAgLy9XZSBoYXZlIGF1ZGlvIGZyYWcgd2FpdGluZyBvciB2aWRlbyBwdHNcbiAgICAgICAgLy9MZXQgcHJvY2VzcyBpdFxuICAgICAgICB0aGlzLm9uRnJhZ0xvYWRlZCh0aGlzLndhaXRpbmdGcmFnbWVudCk7XG4gICAgICAgIC8vTGV0cyBjbGVhbiB0aGUgd2FpdGluZyBmcmFnXG4gICAgICAgIHRoaXMud2FpdGluZ0ZyYWdtZW50ID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBzdGFydExvYWQoc3RhcnRQb3NpdGlvbikge1xuICAgIGlmICh0aGlzLnRyYWNrcykge1xuICAgICAgdmFyIGxhc3RDdXJyZW50VGltZSA9IHRoaXMubGFzdEN1cnJlbnRUaW1lO1xuICAgICAgdGhpcy5zdG9wTG9hZCgpO1xuICAgICAgaWYgKCF0aGlzLnRpbWVyKSB7XG4gICAgICAgIHRoaXMudGltZXIgPSBzZXRJbnRlcnZhbCh0aGlzLm9udGljaywgMTAwKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZnJhZ0xvYWRFcnJvciA9IDA7XG4gICAgICBpZiAobGFzdEN1cnJlbnRUaW1lID4gMCAmJiBzdGFydFBvc2l0aW9uID09PSAtMSkge1xuICAgICAgICBsb2dnZXIubG9nKGBhdWRpbzpvdmVycmlkZSBzdGFydFBvc2l0aW9uIHdpdGggbGFzdEN1cnJlbnRUaW1lIEAke2xhc3RDdXJyZW50VGltZS50b0ZpeGVkKDMpfWApO1xuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubGFzdEN1cnJlbnRUaW1lID0gdGhpcy5zdGFydFBvc2l0aW9uID8gdGhpcy5zdGFydFBvc2l0aW9uIDogc3RhcnRQb3NpdGlvbjtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLlNUQVJUSU5HO1xuICAgICAgfVxuICAgICAgdGhpcy5uZXh0TG9hZFBvc2l0aW9uID0gdGhpcy5zdGFydFBvc2l0aW9uID0gdGhpcy5sYXN0Q3VycmVudFRpbWU7XG4gICAgICB0aGlzLnRpY2soKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zdGFydFBvc2l0aW9uID0gc3RhcnRQb3NpdGlvbjtcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5TVE9QUEVEO1xuICAgIH1cbiAgfVxuXG4gIHN0b3BMb2FkKCkge1xuICAgIHZhciBmcmFnID0gdGhpcy5mcmFnQ3VycmVudDtcbiAgICBpZiAoZnJhZykge1xuICAgICAgaWYgKGZyYWcubG9hZGVyKSB7XG4gICAgICAgIGZyYWcubG9hZGVyLmFib3J0KCk7XG4gICAgICB9XG4gICAgICB0aGlzLmZyYWdDdXJyZW50ID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5mcmFnUHJldmlvdXMgPSBudWxsO1xuICAgIGlmICh0aGlzLmRlbXV4ZXIpIHtcbiAgICAgIHRoaXMuZGVtdXhlci5kZXN0cm95KCk7XG4gICAgICB0aGlzLmRlbXV4ZXIgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLnN0YXRlID0gU3RhdGUuU1RPUFBFRDtcbiAgfVxuXG4gIHNldCBzdGF0ZShuZXh0U3RhdGUpIHtcbiAgICBpZiAodGhpcy5zdGF0ZSAhPT0gbmV4dFN0YXRlKSB7XG4gICAgICBjb25zdCBwcmV2aW91c1N0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICAgIHRoaXMuX3N0YXRlID0gbmV4dFN0YXRlO1xuICAgICAgbG9nZ2VyLmxvZyhgYXVkaW8gc3RyZWFtOiR7cHJldmlvdXNTdGF0ZX0tPiR7bmV4dFN0YXRlfWApO1xuICAgIH1cbiAgfVxuXG4gIGdldCBzdGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhdGU7XG4gIH1cblxuICB0aWNrKCkge1xuICAgIHRoaXMudGlja3MrKztcbiAgICBpZiAodGhpcy50aWNrcyA9PT0gMSkge1xuICAgICAgdGhpcy5kb1RpY2soKTtcbiAgICAgIGlmICh0aGlzLnRpY2tzID4gMSkge1xuICAgICAgICBzZXRUaW1lb3V0KHRoaXMudGljaywgMSk7XG4gICAgICB9XG4gICAgICB0aGlzLnRpY2tzID0gMDtcbiAgICB9XG4gIH1cblxuICBkb1RpY2soKSB7XG4gICAgdmFyIHBvcywgdHJhY2ssIHRyYWNrRGV0YWlscywgaGxzID0gdGhpcy5obHMsIGNvbmZpZyA9IGhscy5jb25maWc7XG4gICAgLy9sb2dnZXIubG9nKCdhdWRpb1N0cmVhbTonICsgdGhpcy5zdGF0ZSk7XG4gICAgc3dpdGNoKHRoaXMuc3RhdGUpIHtcbiAgICAgIGNhc2UgU3RhdGUuRVJST1I6XG4gICAgICAgIC8vZG9uJ3QgZG8gYW55dGhpbmcgaW4gZXJyb3Igc3RhdGUgdG8gYXZvaWQgYnJlYWtpbmcgZnVydGhlciAuLi5cbiAgICAgIGNhc2UgU3RhdGUuUEFVU0VEOlxuICAgICAgICAvL2Rvbid0IGRvIGFueXRoaW5nIGluIHBhdXNlZCBzdGF0ZSBlaXRoZXIgLi4uXG4gICAgICBjYXNlIFN0YXRlLkJVRkZFUl9GTFVTSElORzpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFN0YXRlLlNUQVJUSU5HOlxuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuV0FJVElOR19UUkFDSztcbiAgICAgICAgdGhpcy5sb2FkZWRtZXRhZGF0YSA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgU3RhdGUuSURMRTpcbiAgICAgICAgY29uc3QgdHJhY2tzID0gdGhpcy50cmFja3M7XG4gICAgICAgIC8vIGF1ZGlvIHRyYWNrcyBub3QgcmVjZWl2ZWQgPT4gZXhpdCBsb29wXG4gICAgICAgIGlmICghdHJhY2tzKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgdmlkZW8gbm90IGF0dGFjaGVkIEFORFxuICAgICAgICAvLyBzdGFydCBmcmFnbWVudCBhbHJlYWR5IHJlcXVlc3RlZCBPUiBzdGFydCBmcmFnIHByZWZldGNoIGRpc2FibGVcbiAgICAgICAgLy8gZXhpdCBsb29wXG4gICAgICAgIC8vID0+IGlmIG1lZGlhIG5vdCBhdHRhY2hlZCBidXQgc3RhcnQgZnJhZyBwcmVmZXRjaCBpcyBlbmFibGVkIGFuZCBzdGFydCBmcmFnIG5vdCByZXF1ZXN0ZWQgeWV0LCB3ZSB3aWxsIG5vdCBleGl0IGxvb3BcbiAgICAgICAgaWYgKCF0aGlzLm1lZGlhICYmXG4gICAgICAgICAgKHRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkIHx8ICFjb25maWcuc3RhcnRGcmFnUHJlZmV0Y2gpKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZGV0ZXJtaW5lIG5leHQgY2FuZGlkYXRlIGZyYWdtZW50IHRvIGJlIGxvYWRlZCwgYmFzZWQgb24gY3VycmVudCBwb3NpdGlvbiBhbmRcbiAgICAgICAgLy8gIGVuZCBvZiBidWZmZXIgcG9zaXRpb25cbiAgICAgICAgLy8gaWYgd2UgaGF2ZSBub3QgeWV0IGxvYWRlZCBhbnkgZnJhZ21lbnQsIHN0YXJ0IGxvYWRpbmcgZnJvbSBzdGFydCBwb3NpdGlvblxuICAgICAgICBpZiAodGhpcy5sb2FkZWRtZXRhZGF0YSkge1xuICAgICAgICAgIHBvcyA9IHRoaXMubWVkaWEuY3VycmVudFRpbWU7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5uZXh0TG9hZFBvc2l0aW9uKSB7XG4gICAgICAgICAgcG9zID0gdGhpcy5uZXh0TG9hZFBvc2l0aW9uO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBvcyA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgbWVkaWEgPSB0aGlzLm1lZGlhQnVmZmVyID8gdGhpcy5tZWRpYUJ1ZmZlciA6IHRoaXMubWVkaWEsXG4gICAgICAgICAgICBidWZmZXJJbmZvID0gQnVmZmVySGVscGVyLmJ1ZmZlckluZm8obWVkaWEscG9zLGNvbmZpZy5tYXhCdWZmZXJIb2xlKSxcbiAgICAgICAgICAgIGJ1ZmZlckxlbiA9IGJ1ZmZlckluZm8ubGVuLFxuICAgICAgICAgICAgYnVmZmVyRW5kID0gYnVmZmVySW5mby5lbmQsXG4gICAgICAgICAgICBmcmFnUHJldmlvdXMgPSB0aGlzLmZyYWdQcmV2aW91cyxcbiAgICAgICAgICAgIG1heEJ1ZkxlbiA9IGNvbmZpZy5tYXhNYXhCdWZmZXJMZW5ndGgsXG4gICAgICAgICAgICBhdWRpb1N3aXRjaCA9IHRoaXMuYXVkaW9Td2l0Y2gsXG4gICAgICAgICAgICB0cmFja0lkID0gdGhpcy50cmFja0lkO1xuXG4gICAgICAgIC8vIGlmIGJ1ZmZlciBsZW5ndGggaXMgbGVzcyB0aGFuIG1heEJ1ZkxlbiB0cnkgdG8gbG9hZCBhIG5ldyBmcmFnbWVudFxuICAgICAgICBpZiAoKGJ1ZmZlckxlbiA8IG1heEJ1ZkxlbiB8fCBhdWRpb1N3aXRjaCkgJiYgdHJhY2tJZCA8IHRyYWNrcy5sZW5ndGgpIHtcbiAgICAgICAgICB0cmFja0RldGFpbHMgPSB0cmFja3NbdHJhY2tJZF0uZGV0YWlscztcbiAgICAgICAgICAvLyBpZiB0cmFjayBpbmZvIG5vdCByZXRyaWV2ZWQgeWV0LCBzd2l0Y2ggc3RhdGUgYW5kIHdhaXQgZm9yIHRyYWNrIHJldHJpZXZhbFxuICAgICAgICAgIGlmICh0eXBlb2YgdHJhY2tEZXRhaWxzID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLldBSVRJTkdfVFJBQ0s7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyB3ZSBqdXN0IGdvdCBkb25lIGxvYWRpbmcgdGhlIGZpbmFsIGZyYWdtZW50LCBjaGVjayBpZiB3ZSBuZWVkIHRvIGZpbmFsaXplIG1lZGlhIHN0cmVhbVxuICAgICAgICAgIGlmICghYXVkaW9Td2l0Y2ggJiYgIXRyYWNrRGV0YWlscy5saXZlICYmIGZyYWdQcmV2aW91cyAmJiBmcmFnUHJldmlvdXMuc24gPT09IHRyYWNrRGV0YWlscy5lbmRTTikge1xuICAgICAgICAgICAgICAvLyBpZiB3ZSBhcmUgbm90IHNlZWtpbmcgb3IgaWYgd2UgYXJlIHNlZWtpbmcgYnV0IGV2ZXJ5dGhpbmcgKGFsbW9zdCkgdGlsIHRoZSBlbmQgaXMgYnVmZmVyZWQsIGxldCdzIHNpZ25hbCBlb3NcbiAgICAgICAgICAgICAgLy8gd2UgZG9uJ3QgY29tcGFyZSBleGFjdGx5IG1lZGlhLmR1cmF0aW9uID09PSBidWZmZXJJbmZvLmVuZCBhcyB0aGVyZSBjb3VsZCBiZSBzb21lIHN1YnRsZSBtZWRpYSBkdXJhdGlvbiBkaWZmZXJlbmNlIHdoZW4gc3dpdGNoaW5nXG4gICAgICAgICAgICAgIC8vIGJldHdlZW4gZGlmZmVyZW50IHJlbmRpdGlvbnMuIHVzaW5nIGhhbGYgZnJhZyBkdXJhdGlvbiBzaG91bGQgaGVscCBjb3BlIHdpdGggdGhlc2UgY2FzZXMuXG4gICAgICAgICAgICAgIGlmICghdGhpcy5tZWRpYS5zZWVraW5nIHx8ICh0aGlzLm1lZGlhLmR1cmF0aW9uLWJ1ZmZlckVuZCkgPCBmcmFnUHJldmlvdXMuZHVyYXRpb24vMikge1xuICAgICAgICAgICAgICAvLyBGaW5hbGl6ZSB0aGUgbWVkaWEgc3RyZWFtXG4gICAgICAgICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuQlVGRkVSX0VPUyx7IHR5cGUgOiAnYXVkaW8nfSk7XG4gICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5FTkRFRDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gZmluZCBmcmFnbWVudCBpbmRleCwgY29udGlndW91cyB3aXRoIGVuZCBvZiBidWZmZXIgcG9zaXRpb25cbiAgICAgICAgICBsZXQgZnJhZ21lbnRzID0gdHJhY2tEZXRhaWxzLmZyYWdtZW50cyxcbiAgICAgICAgICAgICAgZnJhZ0xlbiA9IGZyYWdtZW50cy5sZW5ndGgsXG4gICAgICAgICAgICAgIHN0YXJ0ID0gZnJhZ21lbnRzWzBdLnN0YXJ0LFxuICAgICAgICAgICAgICBlbmQgPSBmcmFnbWVudHNbZnJhZ0xlbi0xXS5zdGFydCArIGZyYWdtZW50c1tmcmFnTGVuLTFdLmR1cmF0aW9uLFxuICAgICAgICAgICAgICBmcmFnO1xuXG4gICAgICAgICAgLy8gV2hlbiBzd2l0Y2hpbmcgYXVkaW8gdHJhY2ssIHJlbG9hZCBhdWRpbyBhcyBjbG9zZSBhcyBwb3NzaWJsZSB0byBjdXJyZW50VGltZVxuICAgICAgICAgIGlmKGF1ZGlvU3dpdGNoKXtcbiAgICAgICAgICAgIGlmICh0cmFja0RldGFpbHMubGl2ZSAmJiAhdHJhY2tEZXRhaWxzLlBUU0tub3duKSB7XG4gICAgICAgICAgICAgIGxvZ2dlci5sb2coYHN3aXRjaGluZyBhdWRpb3RyYWNrLCBsaXZlIHN0cmVhbSwgdW5rbm93biBQVFMsbG9hZCBmaXJzdCBmcmFnbWVudGApO1xuICAgICAgICAgICAgICBidWZmZXJFbmQgPSAwO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYnVmZmVyRW5kID0gcG9zO1xuICAgICAgICAgICAgICAvLyBpZiBjdXJyZW50VGltZSAocG9zKSBpcyBsZXNzIHRoYW4gYWx0IGF1ZGlvIHBsYXlsaXN0IHN0YXJ0IHRpbWUsIGl0IG1lYW5zIHRoYXQgYWx0IGF1ZGlvIGlzIGFoZWFkIG9mIGN1cnJlbnRUaW1lXG4gICAgICAgICAgICAgIGlmICh0cmFja0RldGFpbHMuUFRTS25vd24gJiYgcG9zIDwgc3RhcnQpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiBldmVyeXRoaW5nIGlzIGJ1ZmZlcmVkIGZyb20gcG9zIHRvIHN0YXJ0IG9yIGlmIGF1ZGlvIGJ1ZmZlciB1cGZyb250LCBsZXQncyBzZWVrIHRvIHN0YXJ0XG4gICAgICAgICAgICAgICAgaWYgKGJ1ZmZlckluZm8uZW5kID4gc3RhcnQgfHwgYnVmZmVySW5mby5uZXh0U3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgIGxvZ2dlci5sb2coJ2FsdCBhdWRpbyB0cmFjayBhaGVhZCBvZiBtYWluIHRyYWNrLCBzZWVrIHRvIHN0YXJ0IG9mIGFsdCBhdWRpbyB0cmFjaycpO1xuICAgICAgICAgICAgICAgICAgdGhpcy5tZWRpYS5jdXJyZW50VGltZSA9IHN0YXJ0ICsgMC4wNTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodHJhY2tEZXRhaWxzLmluaXRTZWdtZW50ICYmICF0cmFja0RldGFpbHMuaW5pdFNlZ21lbnQuZGF0YSkge1xuICAgICAgICAgICAgICBmcmFnID0gdHJhY2tEZXRhaWxzLmluaXRTZWdtZW50O1xuICAgICAgICAgICB9XG4gICAgICAgICAgLy8gaWYgYnVmZmVyRW5kIGJlZm9yZSBzdGFydCBvZiBwbGF5bGlzdCwgbG9hZCBmaXJzdCBmcmFnbWVudFxuICAgICAgICAgIGVsc2UgaWYgKGJ1ZmZlckVuZCA8PSBzdGFydCkge1xuICAgICAgICAgICAgZnJhZyA9IGZyYWdtZW50c1swXTtcbiAgICAgICAgICAgIGlmICh0aGlzLnZpZGVvVHJhY2tDQyAhPT0gbnVsbCAmJiBmcmFnLmNjICE9PSB0aGlzLnZpZGVvVHJhY2tDQykge1xuICAgICAgICAgICAgICAvLyBFbnN1cmUgd2UgZmluZCBhIGZyYWdtZW50IHdoaWNoIG1hdGNoZXMgdGhlIGNvbnRpbnVpdHkgb2YgdGhlIHZpZGVvIHRyYWNrXG4gICAgICAgICAgICAgIGZyYWcgPSBmaW5kRnJhZ1dpdGhDQyhmcmFnbWVudHMsIHRoaXMudmlkZW9UcmFja0NDKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0cmFja0RldGFpbHMubGl2ZSAmJiBmcmFnLmxvYWRJZHggJiYgZnJhZy5sb2FkSWR4ID09PSB0aGlzLmZyYWdMb2FkSWR4KSB7XG4gICAgICAgICAgICAgIC8vIHdlIGp1c3QgbG9hZGVkIHRoaXMgZmlyc3QgZnJhZ21lbnQsIGFuZCB3ZSBhcmUgc3RpbGwgbGFnZ2luZyBiZWhpbmQgdGhlIHN0YXJ0IG9mIHRoZSBsaXZlIHBsYXlsaXN0XG4gICAgICAgICAgICAgIC8vIGxldCdzIGZvcmNlIHNlZWsgdG8gc3RhcnRcbiAgICAgICAgICAgICAgY29uc3QgbmV4dEJ1ZmZlcmVkID0gYnVmZmVySW5mby5uZXh0U3RhcnQgPyBidWZmZXJJbmZvLm5leHRTdGFydCA6IHN0YXJ0O1xuICAgICAgICAgICAgICBsb2dnZXIubG9nKGBubyBhbHQgYXVkaW8gYXZhaWxhYmxlIEBjdXJyZW50VGltZToke3RoaXMubWVkaWEuY3VycmVudFRpbWV9LCBzZWVraW5nIEAke25leHRCdWZmZXJlZCArIDAuMDV9YCk7XG4gICAgICAgICAgICAgIHRoaXMubWVkaWEuY3VycmVudFRpbWUgPSBuZXh0QnVmZmVyZWQgKyAwLjA1O1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBmb3VuZEZyYWc7XG4gICAgICAgICAgICBsZXQgbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSA9IGNvbmZpZy5tYXhGcmFnTG9va1VwVG9sZXJhbmNlO1xuICAgICAgICAgICAgY29uc3QgZnJhZ05leHQgPSBmcmFnUHJldmlvdXMgPyBmcmFnbWVudHNbZnJhZ1ByZXZpb3VzLnNuIC0gZnJhZ21lbnRzWzBdLnNuICsgMV0gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjb25zdCBmcmFnbWVudFdpdGhpblRvbGVyYW5jZVRlc3QgPSAoY2FuZGlkYXRlKSA9PiB7XG4gICAgICAgICAgICAgIC8vIG9mZnNldCBzaG91bGQgYmUgd2l0aGluIGZyYWdtZW50IGJvdW5kYXJ5IC0gY29uZmlnLm1heEZyYWdMb29rVXBUb2xlcmFuY2VcbiAgICAgICAgICAgICAgLy8gdGhpcyBpcyB0byBjb3BlIHdpdGggc2l0dWF0aW9ucyBsaWtlXG4gICAgICAgICAgICAgIC8vIGJ1ZmZlckVuZCA9IDkuOTkxXG4gICAgICAgICAgICAgIC8vIGZyYWdbw5hdIDogWzAsMTBdXG4gICAgICAgICAgICAgIC8vIGZyYWdbMV0gOiBbMTAsMjBdXG4gICAgICAgICAgICAgIC8vIGJ1ZmZlckVuZCBpcyB3aXRoaW4gZnJhZ1swXSByYW5nZSAuLi4gYWx0aG91Z2ggd2hhdCB3ZSBhcmUgZXhwZWN0aW5nIGlzIHRvIHJldHVybiBmcmFnWzFdIGhlcmVcbiAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgIGZyYWcgc3RhcnQgICAgICAgICAgICAgICBmcmFnIHN0YXJ0K2R1cmF0aW9uXG4gICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICAgfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfFxuICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgPC0tLT4gICAgICAgICAgICAgICAgICAgICAgICAgPC0tLT5cbiAgICAgICAgICAgICAgLy8gIC4uLi0tLS0tLS0tPjwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLT48LS0tLS0tLS0tLi4uLlxuICAgICAgICAgICAgICAvLyBwcmV2aW91cyBmcmFnICAgICAgICAgbWF0Y2hpbmcgZnJhZ21lbnQgICAgICAgICBuZXh0IGZyYWdcbiAgICAgICAgICAgICAgLy8gIHJldHVybiAtMSAgICAgICAgICAgICByZXR1cm4gMCAgICAgICAgICAgICAgICAgcmV0dXJuIDFcbiAgICAgICAgICAgICAgLy9sb2dnZXIubG9nKGBsZXZlbC9zbi9zdGFydC9lbmQvYnVmRW5kOiR7bGV2ZWx9LyR7Y2FuZGlkYXRlLnNufS8ke2NhbmRpZGF0ZS5zdGFydH0vJHsoY2FuZGlkYXRlLnN0YXJ0K2NhbmRpZGF0ZS5kdXJhdGlvbil9LyR7YnVmZmVyRW5kfWApO1xuICAgICAgICAgICAgICAvLyBTZXQgdGhlIGxvb2t1cCB0b2xlcmFuY2UgdG8gYmUgc21hbGwgZW5vdWdoIHRvIGRldGVjdCB0aGUgY3VycmVudCBzZWdtZW50IC0gZW5zdXJlcyB3ZSBkb24ndCBza2lwIG92ZXIgdmVyeSBzbWFsbCBzZWdtZW50c1xuICAgICAgICAgICAgICBsZXQgY2FuZGlkYXRlTG9va3VwVG9sZXJhbmNlID0gTWF0aC5taW4obWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSwgY2FuZGlkYXRlLmR1cmF0aW9uKTtcbiAgICAgICAgICAgICAgaWYgKChjYW5kaWRhdGUuc3RhcnQgKyBjYW5kaWRhdGUuZHVyYXRpb24gLSBjYW5kaWRhdGVMb29rdXBUb2xlcmFuY2UpIDw9IGJ1ZmZlckVuZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgICB9Ly8gaWYgbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSB3aWxsIGhhdmUgbmVnYXRpdmUgdmFsdWUgdGhlbiBkb24ndCByZXR1cm4gLTEgZm9yIGZpcnN0IGVsZW1lbnRcbiAgICAgICAgICAgICAgZWxzZSBpZiAoY2FuZGlkYXRlLnN0YXJ0IC0gY2FuZGlkYXRlTG9va3VwVG9sZXJhbmNlID4gYnVmZmVyRW5kICYmIGNhbmRpZGF0ZS5zdGFydCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGlmIChidWZmZXJFbmQgPCBlbmQpIHtcbiAgICAgICAgICAgICAgaWYgKGJ1ZmZlckVuZCA+IGVuZCAtIG1heEZyYWdMb29rVXBUb2xlcmFuY2UpIHtcbiAgICAgICAgICAgICAgICBtYXhGcmFnTG9va1VwVG9sZXJhbmNlID0gMDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyBQcmVmZXIgdGhlIG5leHQgZnJhZ21lbnQgaWYgaXQncyB3aXRoaW4gdG9sZXJhbmNlXG4gICAgICAgICAgICAgIGlmIChmcmFnTmV4dCAmJiAhZnJhZ21lbnRXaXRoaW5Ub2xlcmFuY2VUZXN0KGZyYWdOZXh0KSkge1xuICAgICAgICAgICAgICAgIGZvdW5kRnJhZyA9IGZyYWdOZXh0O1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvdW5kRnJhZyA9IEJpbmFyeVNlYXJjaC5zZWFyY2goZnJhZ21lbnRzLCBmcmFnbWVudFdpdGhpblRvbGVyYW5jZVRlc3QpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyByZWFjaCBlbmQgb2YgcGxheWxpc3RcbiAgICAgICAgICAgICAgZm91bmRGcmFnID0gZnJhZ21lbnRzW2ZyYWdMZW4tMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZm91bmRGcmFnKSB7XG4gICAgICAgICAgICAgIGZyYWcgPSBmb3VuZEZyYWc7XG4gICAgICAgICAgICAgIHN0YXJ0ID0gZm91bmRGcmFnLnN0YXJ0O1xuICAgICAgICAgICAgICAvL2xvZ2dlci5sb2coJ2ZpbmQgU04gbWF0Y2hpbmcgd2l0aCBwb3M6JyArICBidWZmZXJFbmQgKyAnOicgKyBmcmFnLnNuKTtcbiAgICAgICAgICAgICAgaWYgKGZyYWdQcmV2aW91cyAmJiBmcmFnLmxldmVsID09PSBmcmFnUHJldmlvdXMubGV2ZWwgJiYgZnJhZy5zbiA9PT0gZnJhZ1ByZXZpb3VzLnNuKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZyYWcuc24gPCB0cmFja0RldGFpbHMuZW5kU04pIHtcbiAgICAgICAgICAgICAgICAgIGZyYWcgPSBmcmFnbWVudHNbZnJhZy5zbiArIDEgLSB0cmFja0RldGFpbHMuc3RhcnRTTl07XG4gICAgICAgICAgICAgICAgICBsb2dnZXIubG9nKGBTTiBqdXN0IGxvYWRlZCwgbG9hZCBuZXh0IG9uZTogJHtmcmFnLnNufWApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBmcmFnID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYoZnJhZykge1xuICAgICAgICAgICAgLy9sb2dnZXIubG9nKCcgICAgICBsb2FkaW5nIGZyYWcgJyArIGkgKycscG9zL2J1ZkVuZDonICsgcG9zLnRvRml4ZWQoMykgKyAnLycgKyBidWZmZXJFbmQudG9GaXhlZCgzKSk7XG4gICAgICAgICAgICBpZiAoZnJhZy5kZWNyeXB0ZGF0YSAmJiAoZnJhZy5kZWNyeXB0ZGF0YS51cmkgIT0gbnVsbCkgJiYgKGZyYWcuZGVjcnlwdGRhdGEua2V5ID09IG51bGwpKSB7XG4gICAgICAgICAgICAgIGxvZ2dlci5sb2coYExvYWRpbmcga2V5IGZvciAke2ZyYWcuc259IG9mIFske3RyYWNrRGV0YWlscy5zdGFydFNOfSAsJHt0cmFja0RldGFpbHMuZW5kU059XSx0cmFjayAke3RyYWNrSWR9YCk7XG4gICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5LRVlfTE9BRElORztcbiAgICAgICAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnQuS0VZX0xPQURJTkcsIHtmcmFnOiBmcmFnfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBsb2dnZXIubG9nKGBMb2FkaW5nICR7ZnJhZy5zbn0sIGNjOiAke2ZyYWcuY2N9IG9mIFske3RyYWNrRGV0YWlscy5zdGFydFNOfSAsJHt0cmFja0RldGFpbHMuZW5kU059XSx0cmFjayAke3RyYWNrSWR9LCBjdXJyZW50VGltZToke3Bvc30sYnVmZmVyRW5kOiR7YnVmZmVyRW5kLnRvRml4ZWQoMyl9YCk7XG4gICAgICAgICAgICAgIC8vIGVuc3VyZSB0aGF0IHdlIGFyZSBub3QgcmVsb2FkaW5nIHRoZSBzYW1lIGZyYWdtZW50cyBpbiBsb29wIC4uLlxuICAgICAgICAgICAgICBpZiAodGhpcy5mcmFnTG9hZElkeCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mcmFnTG9hZElkeCsrO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZnJhZ0xvYWRJZHggPSAwO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChmcmFnLmxvYWRDb3VudGVyKSB7XG4gICAgICAgICAgICAgICAgZnJhZy5sb2FkQ291bnRlcisrO1xuICAgICAgICAgICAgICAgIGxldCBtYXhUaHJlc2hvbGQgPSBjb25maWcuZnJhZ0xvYWRpbmdMb29wVGhyZXNob2xkO1xuICAgICAgICAgICAgICAgIC8vIGlmIHRoaXMgZnJhZyBoYXMgYWxyZWFkeSBiZWVuIGxvYWRlZCAzIHRpbWVzLCBhbmQgaWYgaXQgaGFzIGJlZW4gcmVsb2FkZWQgcmVjZW50bHlcbiAgICAgICAgICAgICAgICBpZiAoZnJhZy5sb2FkQ291bnRlciA+IG1heFRocmVzaG9sZCAmJiAoTWF0aC5hYnModGhpcy5mcmFnTG9hZElkeCAtIGZyYWcubG9hZElkeCkgPCBtYXhUaHJlc2hvbGQpKSB7XG4gICAgICAgICAgICAgICAgICBobHMudHJpZ2dlcihFdmVudC5FUlJPUiwge3R5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsIGRldGFpbHM6IEVycm9yRGV0YWlscy5GUkFHX0xPT1BfTE9BRElOR19FUlJPUiwgZmF0YWw6IGZhbHNlLCBmcmFnOiBmcmFnfSk7XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZyYWcubG9hZENvdW50ZXIgPSAxO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGZyYWcubG9hZElkeCA9IHRoaXMuZnJhZ0xvYWRJZHg7XG4gICAgICAgICAgICAgIHRoaXMuZnJhZ0N1cnJlbnQgPSBmcmFnO1xuICAgICAgICAgICAgICB0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCA9IHRydWU7XG4gICAgICAgICAgICAgIGlmICghaXNOYU4oZnJhZy5zbikpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5leHRMb2FkUG9zaXRpb24gPSBmcmFnLnN0YXJ0ICsgZnJhZy5kdXJhdGlvbjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBobHMudHJpZ2dlcihFdmVudC5GUkFHX0xPQURJTkcsIHtmcmFnOiBmcmFnfSk7XG4gICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5GUkFHX0xPQURJTkc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBTdGF0ZS5XQUlUSU5HX1RSQUNLOlxuICAgICAgICB0cmFjayA9IHRoaXMudHJhY2tzW3RoaXMudHJhY2tJZF07XG4gICAgICAgIC8vIGNoZWNrIGlmIHBsYXlsaXN0IGlzIGFscmVhZHkgbG9hZGVkXG4gICAgICAgIGlmICh0cmFjayAmJiB0cmFjay5kZXRhaWxzKSB7XG4gICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFN0YXRlLkZSQUdfTE9BRElOR19XQUlUSU5HX1JFVFJZOlxuICAgICAgICB2YXIgbm93ID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIHZhciByZXRyeURhdGUgPSB0aGlzLnJldHJ5RGF0ZTtcbiAgICAgICAgbWVkaWEgPSB0aGlzLm1lZGlhO1xuICAgICAgICB2YXIgaXNTZWVraW5nID0gbWVkaWEgJiYgbWVkaWEuc2Vla2luZztcbiAgICAgICAgLy8gaWYgY3VycmVudCB0aW1lIGlzIGd0IHRoYW4gcmV0cnlEYXRlLCBvciBpZiBtZWRpYSBzZWVraW5nIGxldCdzIHN3aXRjaCB0byBJRExFIHN0YXRlIHRvIHJldHJ5IGxvYWRpbmdcbiAgICAgICAgaWYoIXJldHJ5RGF0ZSB8fCAobm93ID49IHJldHJ5RGF0ZSkgfHwgaXNTZWVraW5nKSB7XG4gICAgICAgICAgbG9nZ2VyLmxvZyhgYXVkaW9TdHJlYW1Db250cm9sbGVyOiByZXRyeURhdGUgcmVhY2hlZCwgc3dpdGNoIGJhY2sgdG8gSURMRSBzdGF0ZWApO1xuICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBTdGF0ZS5XQUlUSU5HX0lOSVRfUFRTOlxuICAgICAgICBpZiAodGhpcy5pbml0UFRTW3RoaXMudmlkZW9UcmFja0NDXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBFbnN1cmUgd2UgZG9uJ3QgZ2V0IHN0dWNrIGluIHRoZSBXQUlUSU5HX0lOSVRfUFRTIHN0YXRlIGlmIHRoZSB3YWl0aW5nIGZyYWcgQ0MgZG9lc24ndCBtYXRjaCBhbnkgaW5pdFBUU1xuICAgICAgICBjb25zdCB3YWl0aW5nRnJhZyA9IHRoaXMud2FpdGluZ0ZyYWdtZW50O1xuICAgICAgICBpZiAod2FpdGluZ0ZyYWcpIHtcbiAgICAgICAgICBjb25zdCB3YWl0aW5nRnJhZ0NDID0gd2FpdGluZ0ZyYWcuZnJhZy5jYztcbiAgICAgICAgICBpZiAodGhpcy52aWRlb1RyYWNrQ0MgIT09IHdhaXRpbmdGcmFnQ0MpIHtcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKGBXYWl0aW5nIGZyYWdtZW50IENDICgke3dhaXRpbmdGcmFnQ0N9KSBkb2VzIG5vdCBtYXRjaCB2aWRlbyB0cmFjayBDQyAoJHt0aGlzLnZpZGVvVHJhY2tDQ30pYCk7XG4gICAgICAgICAgICB0aGlzLndhaXRpbmdGcmFnbWVudCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5vbkZyYWdMb2FkZWQodGhpcy53YWl0aW5nRnJhZ21lbnQpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkZSQUdfTE9BRElORztcbiAgICAgICAgICAgIHRoaXMud2FpdGluZ0ZyYWdtZW50ID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgU3RhdGUuU1RPUFBFRDpcbiAgICAgIGNhc2UgU3RhdGUuRlJBR19MT0FESU5HOlxuICAgICAgY2FzZSBTdGF0ZS5QQVJTSU5HOlxuICAgICAgY2FzZSBTdGF0ZS5QQVJTRUQ6XG4gICAgICBjYXNlIFN0YXRlLkVOREVEOlxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIG9uTWVkaWFBdHRhY2hlZChkYXRhKSB7XG4gICAgdmFyIG1lZGlhID0gdGhpcy5tZWRpYSA9IHRoaXMubWVkaWFCdWZmZXIgPSBkYXRhLm1lZGlhO1xuICAgIHRoaXMub252c2Vla2luZyA9IHRoaXMub25NZWRpYVNlZWtpbmcuYmluZCh0aGlzKTtcbiAgICB0aGlzLm9udmVuZGVkID0gdGhpcy5vbk1lZGlhRW5kZWQuYmluZCh0aGlzKTtcbiAgICBtZWRpYS5hZGRFdmVudExpc3RlbmVyKCdzZWVraW5nJywgdGhpcy5vbnZzZWVraW5nKTtcbiAgICBtZWRpYS5hZGRFdmVudExpc3RlbmVyKCdlbmRlZCcsIHRoaXMub252ZW5kZWQpO1xuICAgIGxldCBjb25maWcgPSB0aGlzLmNvbmZpZztcbiAgICBpZih0aGlzLnRyYWNrcyAmJiBjb25maWcuYXV0b1N0YXJ0TG9hZCkge1xuICAgICAgdGhpcy5zdGFydExvYWQoY29uZmlnLnN0YXJ0UG9zaXRpb24pO1xuICAgIH1cbiAgfVxuXG4gIG9uTWVkaWFEZXRhY2hpbmcoKSB7XG4gICAgdmFyIG1lZGlhID0gdGhpcy5tZWRpYTtcbiAgICBpZiAobWVkaWEgJiYgbWVkaWEuZW5kZWQpIHtcbiAgICAgIGxvZ2dlci5sb2coJ01TRSBkZXRhY2hpbmcgYW5kIHZpZGVvIGVuZGVkLCByZXNldCBzdGFydFBvc2l0aW9uJyk7XG4gICAgICB0aGlzLnN0YXJ0UG9zaXRpb24gPSB0aGlzLmxhc3RDdXJyZW50VGltZSA9IDA7XG4gICAgfVxuXG4gICAgLy8gcmVzZXQgZnJhZ21lbnQgbG9hZGluZyBjb3VudGVyIG9uIE1TRSBkZXRhY2hpbmcgdG8gYXZvaWQgcmVwb3J0aW5nIEZSQUdfTE9PUF9MT0FESU5HX0VSUk9SIGFmdGVyIGVycm9yIHJlY292ZXJ5XG4gICAgdmFyIHRyYWNrcyA9IHRoaXMudHJhY2tzO1xuICAgIGlmICh0cmFja3MpIHtcbiAgICAgIC8vIHJlc2V0IGZyYWdtZW50IGxvYWQgY291bnRlclxuICAgICAgICB0cmFja3MuZm9yRWFjaCh0cmFjayA9PiB7XG4gICAgICAgICAgaWYodHJhY2suZGV0YWlscykge1xuICAgICAgICAgICAgdHJhY2suZGV0YWlscy5mcmFnbWVudHMuZm9yRWFjaChmcmFnbWVudCA9PiB7XG4gICAgICAgICAgICAgIGZyYWdtZW50LmxvYWRDb3VudGVyID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIC8vIHJlbW92ZSB2aWRlbyBsaXN0ZW5lcnNcbiAgICBpZiAobWVkaWEpIHtcbiAgICAgIG1lZGlhLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3NlZWtpbmcnLCB0aGlzLm9udnNlZWtpbmcpO1xuICAgICAgbWVkaWEucmVtb3ZlRXZlbnRMaXN0ZW5lcignZW5kZWQnLCB0aGlzLm9udmVuZGVkKTtcbiAgICAgIHRoaXMub252c2Vla2luZyA9IHRoaXMub252c2Vla2VkICA9IHRoaXMub252ZW5kZWQgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLm1lZGlhID0gdGhpcy5tZWRpYUJ1ZmZlciA9IG51bGw7XG4gICAgdGhpcy5sb2FkZWRtZXRhZGF0YSA9IGZhbHNlO1xuICAgIHRoaXMuc3RvcExvYWQoKTtcbiAgfVxuXG4gIG9uTWVkaWFTZWVraW5nKCkge1xuICAgIGlmICh0aGlzLnN0YXRlID09PSBTdGF0ZS5FTkRFRCkge1xuICAgICAgICAvLyBzd2l0Y2ggdG8gSURMRSBzdGF0ZSB0byBjaGVjayBmb3IgcG90ZW50aWFsIG5ldyBmcmFnbWVudFxuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICB9XG4gICAgaWYgKHRoaXMubWVkaWEpIHtcbiAgICAgIHRoaXMubGFzdEN1cnJlbnRUaW1lID0gdGhpcy5tZWRpYS5jdXJyZW50VGltZTtcbiAgICB9XG4gICAgLy8gYXZvaWQgcmVwb3J0aW5nIGZyYWdtZW50IGxvb3AgbG9hZGluZyBlcnJvciBpbiBjYXNlIHVzZXIgaXMgc2Vla2luZyBzZXZlcmFsIHRpbWVzIG9uIHNhbWUgcG9zaXRpb25cbiAgICBpZiAodGhpcy5mcmFnTG9hZElkeCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLmZyYWdMb2FkSWR4ICs9IDIgKiB0aGlzLmNvbmZpZy5mcmFnTG9hZGluZ0xvb3BUaHJlc2hvbGQ7XG4gICAgfVxuICAgIC8vIHRpY2sgdG8gc3BlZWQgdXAgcHJvY2Vzc2luZ1xuICAgIHRoaXMudGljaygpO1xuICB9XG5cbiAgb25NZWRpYUVuZGVkKCkge1xuICAgIC8vIHJlc2V0IHN0YXJ0UG9zaXRpb24gYW5kIGxhc3RDdXJyZW50VGltZSB0byByZXN0YXJ0IHBsYXliYWNrIEAgc3RyZWFtIGJlZ2lubmluZ1xuICAgIHRoaXMuc3RhcnRQb3NpdGlvbiA9IHRoaXMubGFzdEN1cnJlbnRUaW1lID0gMDtcbiAgfVxuXG5cbiAgb25BdWRpb1RyYWNrc1VwZGF0ZWQoZGF0YSkge1xuICAgIGxvZ2dlci5sb2coJ2F1ZGlvIHRyYWNrcyB1cGRhdGVkJyk7XG4gICAgdGhpcy50cmFja3MgPSBkYXRhLmF1ZGlvVHJhY2tzO1xuICB9XG5cbiAgb25BdWRpb1RyYWNrU3dpdGNoaW5nKGRhdGEpIHtcbiAgICAvLyBpZiBhbnkgVVJMIGZvdW5kIG9uIG5ldyBhdWRpbyB0cmFjaywgaXQgaXMgYW4gYWx0ZXJuYXRlIGF1ZGlvIHRyYWNrXG4gICAgdmFyIGFsdEF1ZGlvID0gISFkYXRhLnVybDtcbiAgICB0aGlzLnRyYWNrSWQgPSBkYXRhLmlkO1xuICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuXG4gICAgdGhpcy5mcmFnQ3VycmVudCA9IG51bGw7XG4gICAgdGhpcy5zdGF0ZSA9IFN0YXRlLlBBVVNFRDtcbiAgICB0aGlzLndhaXRpbmdGcmFnbWVudD1udWxsO1xuICAgIC8vIGRlc3Ryb3kgdXNlbGVzcyBkZW11eGVyIHdoZW4gc3dpdGNoaW5nIGF1ZGlvIHRvIG1haW5cbiAgICBpZiAoIWFsdEF1ZGlvKSB7XG4gICAgICBpZiAodGhpcy5kZW11eGVyKSB7XG4gICAgICAgIHRoaXMuZGVtdXhlci5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuZGVtdXhlciA9IG51bGw7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHN3aXRjaGluZyB0byBhdWRpbyB0cmFjaywgc3RhcnQgdGltZXIgaWYgbm90IGFscmVhZHkgc3RhcnRlZFxuICAgICAgaWYgKCF0aGlzLnRpbWVyKSB7XG4gICAgICAgIHRoaXMudGltZXIgPSBzZXRJbnRlcnZhbCh0aGlzLm9udGljaywgMTAwKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvL3Nob3VsZCB3ZSBzd2l0Y2ggdHJhY2tzID9cbiAgICBpZihhbHRBdWRpbyl7XG4gICAgICB0aGlzLmF1ZGlvU3dpdGNoID0gdHJ1ZTtcbiAgICAgIC8vbWFpbiBhdWRpbyB0cmFjayBhcmUgaGFuZGxlZCBieSBzdHJlYW0tY29udHJvbGxlciwganVzdCBkbyBzb21ldGhpbmcgaWYgc3dpdGNoaW5nIHRvIGFsdCBhdWRpbyB0cmFja1xuICAgICAgdGhpcy5zdGF0ZT1TdGF0ZS5JRExFO1xuICAgICAgLy8gaW5jcmVhc2UgZnJhZ21lbnQgbG9hZCBJbmRleCB0byBhdm9pZCBmcmFnIGxvb3AgbG9hZGluZyBlcnJvciBhZnRlciBidWZmZXIgZmx1c2hcbiAgICAgIGlmICh0aGlzLmZyYWdMb2FkSWR4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5mcmFnTG9hZElkeCArPSAyICogdGhpcy5jb25maWcuZnJhZ0xvYWRpbmdMb29wVGhyZXNob2xkO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnRpY2soKTtcbiAgfVxuXG4gIG9uQXVkaW9UcmFja0xvYWRlZChkYXRhKSB7XG4gICAgdmFyIG5ld0RldGFpbHMgPSBkYXRhLmRldGFpbHMsXG4gICAgICAgIHRyYWNrSWQgPSBkYXRhLmlkLFxuICAgICAgICB0cmFjayA9IHRoaXMudHJhY2tzW3RyYWNrSWRdLFxuICAgICAgICBkdXJhdGlvbiA9IG5ld0RldGFpbHMudG90YWxkdXJhdGlvbixcbiAgICAgICAgc2xpZGluZyA9IDA7XG5cbiAgICBsb2dnZXIubG9nKGB0cmFjayAke3RyYWNrSWR9IGxvYWRlZCBbJHtuZXdEZXRhaWxzLnN0YXJ0U059LCR7bmV3RGV0YWlscy5lbmRTTn1dLGR1cmF0aW9uOiR7ZHVyYXRpb259YCk7XG5cbiAgICBpZiAobmV3RGV0YWlscy5saXZlKSB7XG4gICAgICB2YXIgY3VyRGV0YWlscyA9IHRyYWNrLmRldGFpbHM7XG4gICAgICBpZiAoY3VyRGV0YWlscyAmJiBuZXdEZXRhaWxzLmZyYWdtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIC8vIHdlIGFscmVhZHkgaGF2ZSBkZXRhaWxzIGZvciB0aGF0IGxldmVsLCBtZXJnZSB0aGVtXG4gICAgICAgIExldmVsSGVscGVyLm1lcmdlRGV0YWlscyhjdXJEZXRhaWxzLG5ld0RldGFpbHMpO1xuICAgICAgICBzbGlkaW5nID0gbmV3RGV0YWlscy5mcmFnbWVudHNbMF0uc3RhcnQ7XG4gICAgICAgIC8vIFRPRE9cbiAgICAgICAgLy90aGlzLmxpdmVTeW5jUG9zaXRpb24gPSB0aGlzLmNvbXB1dGVMaXZlUG9zaXRpb24oc2xpZGluZywgY3VyRGV0YWlscyk7XG4gICAgICAgIGlmIChuZXdEZXRhaWxzLlBUU0tub3duKSB7XG4gICAgICAgICAgbG9nZ2VyLmxvZyhgbGl2ZSBhdWRpbyBwbGF5bGlzdCBzbGlkaW5nOiR7c2xpZGluZy50b0ZpeGVkKDMpfWApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxvZ2dlci5sb2coJ2xpdmUgYXVkaW8gcGxheWxpc3QgLSBvdXRkYXRlZCBQVFMsIHVua25vd24gc2xpZGluZycpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXdEZXRhaWxzLlBUU0tub3duID0gZmFsc2U7XG4gICAgICAgIGxvZ2dlci5sb2coJ2xpdmUgYXVkaW8gcGxheWxpc3QgLSBmaXJzdCBsb2FkLCB1bmtub3duIHNsaWRpbmcnKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbmV3RGV0YWlscy5QVFNLbm93biA9IGZhbHNlO1xuICAgIH1cbiAgICB0cmFjay5kZXRhaWxzID0gbmV3RGV0YWlscztcblxuICAgIC8vIGNvbXB1dGUgc3RhcnQgcG9zaXRpb25cbiAgICBpZiAoIXRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkKSB7XG4gICAgLy8gY29tcHV0ZSBzdGFydCBwb3NpdGlvbiBpZiBzZXQgdG8gLTEuIHVzZSBpdCBzdHJhaWdodCBhd2F5IGlmIHZhbHVlIGlzIGRlZmluZWRcbiAgICAgIGlmICh0aGlzLnN0YXJ0UG9zaXRpb24gPT09IC0xKSB7XG4gICAgICAgIC8vIGZpcnN0LCBjaGVjayBpZiBzdGFydCB0aW1lIG9mZnNldCBoYXMgYmVlbiBzZXQgaW4gcGxheWxpc3QsIGlmIHllcywgdXNlIHRoaXMgdmFsdWVcbiAgICAgICAgbGV0IHN0YXJ0VGltZU9mZnNldCA9IG5ld0RldGFpbHMuc3RhcnRUaW1lT2Zmc2V0O1xuICAgICAgICBpZighaXNOYU4oc3RhcnRUaW1lT2Zmc2V0KSkge1xuICAgICAgICAgIGxvZ2dlci5sb2coYHN0YXJ0IHRpbWUgb2Zmc2V0IGZvdW5kIGluIHBsYXlsaXN0LCBhZGp1c3Qgc3RhcnRQb3NpdGlvbiB0byAke3N0YXJ0VGltZU9mZnNldH1gKTtcbiAgICAgICAgICB0aGlzLnN0YXJ0UG9zaXRpb24gPSBzdGFydFRpbWVPZmZzZXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5zdGFydFBvc2l0aW9uID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5uZXh0TG9hZFBvc2l0aW9uID0gdGhpcy5zdGFydFBvc2l0aW9uO1xuICAgIH1cbiAgICAvLyBvbmx5IHN3aXRjaCBiYXRjayB0byBJRExFIHN0YXRlIGlmIHdlIHdlcmUgd2FpdGluZyBmb3IgdHJhY2sgdG8gc3RhcnQgZG93bmxvYWRpbmcgYSBuZXcgZnJhZ21lbnRcbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuV0FJVElOR19UUkFDSykge1xuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgfVxuICAgIC8vdHJpZ2dlciBoYW5kbGVyIHJpZ2h0IG5vd1xuICAgIHRoaXMudGljaygpO1xuICB9XG5cbiAgb25LZXlMb2FkZWQoKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLktFWV9MT0FESU5HKSB7XG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgIHRoaXMudGljaygpO1xuICAgIH1cbiAgfVxuXG4gIG9uRnJhZ0xvYWRlZChkYXRhKSB7XG4gICAgdmFyIGZyYWdDdXJyZW50ID0gdGhpcy5mcmFnQ3VycmVudCxcbiAgICAgICAgZnJhZ0xvYWRlZCA9IGRhdGEuZnJhZztcbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuRlJBR19MT0FESU5HICYmXG4gICAgICAgIGZyYWdDdXJyZW50ICYmXG4gICAgICAgIGZyYWdMb2FkZWQudHlwZSA9PT0gJ2F1ZGlvJyAmJlxuICAgICAgICBmcmFnTG9hZGVkLmxldmVsID09PSBmcmFnQ3VycmVudC5sZXZlbCAmJlxuICAgICAgICBmcmFnTG9hZGVkLnNuID09PSBmcmFnQ3VycmVudC5zbikge1xuICAgICAgICB2YXIgdHJhY2sgPSB0aGlzLnRyYWNrc1t0aGlzLnRyYWNrSWRdLFxuICAgICAgICAgICAgZGV0YWlscyA9IHRyYWNrLmRldGFpbHMsXG4gICAgICAgICAgICBkdXJhdGlvbiA9IGRldGFpbHMudG90YWxkdXJhdGlvbixcbiAgICAgICAgICAgIHRyYWNrSWQgPSBmcmFnQ3VycmVudC5sZXZlbCxcbiAgICAgICAgICAgIHNuID0gZnJhZ0N1cnJlbnQuc24sXG4gICAgICAgICAgICBjYyA9IGZyYWdDdXJyZW50LmNjLFxuICAgICAgICAgICAgYXVkaW9Db2RlYyA9IHRoaXMuY29uZmlnLmRlZmF1bHRBdWRpb0NvZGVjIHx8IHRyYWNrLmF1ZGlvQ29kZWMgfHwgJ21wNGEuNDAuMicsXG4gICAgICAgICAgICBzdGF0cyA9IHRoaXMuc3RhdHMgPSBkYXRhLnN0YXRzO1xuICAgICAgaWYgKHNuID09PSAnaW5pdFNlZ21lbnQnKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuXG4gICAgICAgIHN0YXRzLnRwYXJzZWQgPSBzdGF0cy50YnVmZmVyZWQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgZGV0YWlscy5pbml0U2VnbWVudC5kYXRhID0gZGF0YS5wYXlsb2FkO1xuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkZSQUdfQlVGRkVSRUQsIHtzdGF0czogc3RhdHMsIGZyYWc6IGZyYWdDdXJyZW50LCBpZCA6ICdhdWRpbyd9KTtcbiAgICAgICAgdGhpcy50aWNrKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuUEFSU0lORztcbiAgICAgICAgLy8gdHJhbnNtdXggdGhlIE1QRUctVFMgZGF0YSB0byBJU08tQk1GRiBzZWdtZW50c1xuICAgICAgICB0aGlzLmFwcGVuZGVkID0gZmFsc2U7XG4gICAgICAgIGlmKCF0aGlzLmRlbXV4ZXIpIHtcbiAgICAgICAgICB0aGlzLmRlbXV4ZXIgPSBuZXcgRGVtdXhlcih0aGlzLmhscywnYXVkaW8nKTtcbiAgICAgICAgfVxuICAgICAgICAvL0NoZWNrIGlmIHdlIGhhdmUgdmlkZW8gaW5pdFBUU1xuICAgICAgICAvLyBJZiBub3Qgd2UgbmVlZCB0byB3YWl0IGZvciBpdFxuICAgICAgICBsZXQgaW5pdFBUUyA9IHRoaXMuaW5pdFBUU1tjY107XG4gICAgICAgIGxldCBpbml0U2VnbWVudERhdGEgPSBkZXRhaWxzLmluaXRTZWdtZW50ID8gZGV0YWlscy5pbml0U2VnbWVudC5kYXRhIDogW107XG4gICAgICAgIGlmIChpbml0U2VnbWVudERhdGEgfHwgaW5pdFBUUyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5wZW5kaW5nQnVmZmVyaW5nID0gdHJ1ZTtcbiAgICAgICAgICBsb2dnZXIubG9nKGBEZW11eGluZyAke3NufSBvZiBbJHtkZXRhaWxzLnN0YXJ0U059ICwke2RldGFpbHMuZW5kU059XSx0cmFjayAke3RyYWNrSWR9YCk7XG4gICAgICAgICAgLy8gdGltZSBPZmZzZXQgaXMgYWNjdXJhdGUgaWYgbGV2ZWwgUFRTIGlzIGtub3duLCBvciBpZiBwbGF5bGlzdCBpcyBub3Qgc2xpZGluZyAobm90IGxpdmUpXG4gICAgICAgICAgbGV0IGFjY3VyYXRlVGltZU9mZnNldCA9IGZhbHNlOyAvL2RldGFpbHMuUFRTS25vd24gfHwgIWRldGFpbHMubGl2ZTtcbiAgICAgICAgICB0aGlzLmRlbXV4ZXIucHVzaChkYXRhLnBheWxvYWQsIGluaXRTZWdtZW50RGF0YSwgYXVkaW9Db2RlYywgbnVsbCwgZnJhZ0N1cnJlbnQsIGR1cmF0aW9uLCBhY2N1cmF0ZVRpbWVPZmZzZXQsIGluaXRQVFMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxvZ2dlci5sb2coYHVua25vd24gdmlkZW8gUFRTIGZvciBjb250aW51aXR5IGNvdW50ZXIgJHtjY30sIHdhaXRpbmcgZm9yIHZpZGVvIFBUUyBiZWZvcmUgZGVtdXhpbmcgYXVkaW8gZnJhZyAke3NufSBvZiBbJHtkZXRhaWxzLnN0YXJ0U059ICwke2RldGFpbHMuZW5kU059XSx0cmFjayAke3RyYWNrSWR9YCk7XG4gICAgICAgICAgdGhpcy53YWl0aW5nRnJhZ21lbnQ9ZGF0YTtcbiAgICAgICAgICB0aGlzLnN0YXRlPVN0YXRlLldBSVRJTkdfSU5JVF9QVFM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5mcmFnTG9hZEVycm9yID0gMDtcbiAgfVxuXG4gIG9uRnJhZ1BhcnNpbmdJbml0U2VnbWVudChkYXRhKSB7XG4gICAgY29uc3QgZnJhZ0N1cnJlbnQgPSB0aGlzLmZyYWdDdXJyZW50O1xuICAgIGNvbnN0IGZyYWdOZXcgPSBkYXRhLmZyYWc7XG4gICAgaWYgKGZyYWdDdXJyZW50ICYmXG4gICAgICAgIGRhdGEuaWQgPT09ICdhdWRpbycgJiZcbiAgICAgICAgZnJhZ05ldy5zbiA9PT0gZnJhZ0N1cnJlbnQuc24gJiZcbiAgICAgICAgZnJhZ05ldy5sZXZlbCA9PT0gZnJhZ0N1cnJlbnQubGV2ZWwgJiZcbiAgICAgICAgdGhpcy5zdGF0ZSA9PT0gU3RhdGUuUEFSU0lORykge1xuICAgICAgbGV0IHRyYWNrcyA9IGRhdGEudHJhY2tzLCB0cmFjaztcblxuICAgICAgLy8gZGVsZXRlIGFueSB2aWRlbyB0cmFjayBmb3VuZCBvbiBhdWRpbyBkZW11eGVyXG4gICAgICBpZiAodHJhY2tzLnZpZGVvKSB7XG4gICAgICAgIGRlbGV0ZSB0cmFja3MudmlkZW87XG4gICAgICB9XG5cbiAgICAgIC8vIGluY2x1ZGUgbGV2ZWxDb2RlYyBpbiBhdWRpbyBhbmQgdmlkZW8gdHJhY2tzXG4gICAgICB0cmFjayA9IHRyYWNrcy5hdWRpbztcbiAgICAgIGlmKHRyYWNrKSB7XG4gICAgICAgIHRyYWNrLmxldmVsQ29kZWMgPSAnbXA0YS40MC4yJztcbiAgICAgICAgdHJhY2suaWQgPSBkYXRhLmlkO1xuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkJVRkZFUl9DT0RFQ1MsdHJhY2tzKTtcbiAgICAgICAgbG9nZ2VyLmxvZyhgYXVkaW8gdHJhY2s6YXVkaW8sY29udGFpbmVyOiR7dHJhY2suY29udGFpbmVyfSxjb2RlY3NbbGV2ZWwvcGFyc2VkXT1bJHt0cmFjay5sZXZlbENvZGVjfS8ke3RyYWNrLmNvZGVjfV1gKTtcbiAgICAgICAgbGV0IGluaXRTZWdtZW50ID0gdHJhY2suaW5pdFNlZ21lbnQ7XG4gICAgICAgIGlmIChpbml0U2VnbWVudCkge1xuICAgICAgICAgIGxldCBhcHBlbmRPYmogPSB7dHlwZTogJ2F1ZGlvJywgZGF0YTogaW5pdFNlZ21lbnQsIHBhcmVudCA6ICdhdWRpbycsY29udGVudCA6ICdpbml0U2VnbWVudCd9O1xuICAgICAgICAgIGlmICh0aGlzLmF1ZGlvU3dpdGNoKSB7XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdEYXRhID0gW2FwcGVuZE9ial07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kZWQgPSB0cnVlO1xuICAgICAgICAgICAgLy8gYXJtIHBlbmRpbmcgQnVmZmVyaW5nIGZsYWcgYmVmb3JlIGFwcGVuZGluZyBhIHNlZ21lbnRcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ0J1ZmZlcmluZyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkJVRkZFUl9BUFBFTkRJTkcsIGFwcGVuZE9iaik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vdHJpZ2dlciBoYW5kbGVyIHJpZ2h0IG5vd1xuICAgICAgICB0aGlzLnRpY2soKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBvbkZyYWdQYXJzaW5nRGF0YShkYXRhKSB7XG4gICAgY29uc3QgZnJhZ0N1cnJlbnQgPSB0aGlzLmZyYWdDdXJyZW50O1xuICAgIGNvbnN0IGZyYWdOZXcgPSBkYXRhLmZyYWc7XG4gICAgaWYgKGZyYWdDdXJyZW50ICYmXG4gICAgICAgIGRhdGEuaWQgPT09ICdhdWRpbycgJiZcbiAgICAgICAgZGF0YS50eXBlID09PSAnYXVkaW8nICYmXG4gICAgICAgIGZyYWdOZXcuc24gPT09IGZyYWdDdXJyZW50LnNuICYmXG4gICAgICAgIGZyYWdOZXcubGV2ZWwgPT09IGZyYWdDdXJyZW50LmxldmVsICYmXG4gICAgICAgIHRoaXMuc3RhdGUgPT09IFN0YXRlLlBBUlNJTkcpIHtcbiAgICAgIGxldCB0cmFja0lkPSB0aGlzLnRyYWNrSWQsXG4gICAgICAgICAgdHJhY2sgPSB0aGlzLnRyYWNrc1t0cmFja0lkXSxcbiAgICAgICAgICBobHMgPSB0aGlzLmhscztcblxuICAgICAgaWYgKGlzTmFOKGRhdGEuZW5kUFRTKSkge1xuICAgICAgICBkYXRhLmVuZFBUUyA9IGRhdGEuc3RhcnRQVFMgKyBmcmFnQ3VycmVudC5kdXJhdGlvbjtcbiAgICAgICAgZGF0YS5lbmREVFMgPSBkYXRhLnN0YXJ0RFRTICsgZnJhZ0N1cnJlbnQuZHVyYXRpb247XG4gICAgICB9XG5cbiAgICAgIGxvZ2dlci5sb2coYHBhcnNlZCAke2RhdGEudHlwZX0sUFRTOlske2RhdGEuc3RhcnRQVFMudG9GaXhlZCgzKX0sJHtkYXRhLmVuZFBUUy50b0ZpeGVkKDMpfV0sRFRTOlske2RhdGEuc3RhcnREVFMudG9GaXhlZCgzKX0vJHtkYXRhLmVuZERUUy50b0ZpeGVkKDMpfV0sbmI6JHtkYXRhLm5ifWApO1xuICAgICAgTGV2ZWxIZWxwZXIudXBkYXRlRnJhZ1BUU0RUUyh0cmFjay5kZXRhaWxzLGZyYWdDdXJyZW50LnNuLGRhdGEuc3RhcnRQVFMsZGF0YS5lbmRQVFMpO1xuXG4gICAgICBsZXQgYXVkaW9Td2l0Y2ggPSB0aGlzLmF1ZGlvU3dpdGNoLCBtZWRpYSA9IHRoaXMubWVkaWEsIGFwcGVuZE9uQnVmZmVyRmx1c2ggPSBmYWxzZTtcbiAgICAgIC8vT25seSBmbHVzaCBhdWRpbyBmcm9tIG9sZCBhdWRpbyB0cmFja3Mgd2hlbiBQVFMgaXMga25vd24gb24gbmV3IGF1ZGlvIHRyYWNrXG4gICAgICBpZihhdWRpb1N3aXRjaCAmJiBtZWRpYSkge1xuICAgICAgICBpZiAobWVkaWEucmVhZHlTdGF0ZSkge1xuICAgICAgICAgIGxldCBjdXJyZW50VGltZSA9IG1lZGlhLmN1cnJlbnRUaW1lO1xuICAgICAgICAgIGxvZ2dlci5sb2coJ3N3aXRjaGluZyBhdWRpbyB0cmFjayA6IGN1cnJlbnRUaW1lOicrIGN1cnJlbnRUaW1lKTtcbiAgICAgICAgICBpZiAoY3VycmVudFRpbWUgPj0gZGF0YS5zdGFydFBUUykge1xuICAgICAgICAgICAgbG9nZ2VyLmxvZygnc3dpdGNoaW5nIGF1ZGlvIHRyYWNrIDogZmx1c2hpbmcgYWxsIGF1ZGlvJyk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuQlVGRkVSX0ZMVVNISU5HO1xuICAgICAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnQuQlVGRkVSX0ZMVVNISU5HLCB7c3RhcnRPZmZzZXQ6IDAgLCBlbmRPZmZzZXQ6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSwgdHlwZSA6ICdhdWRpbyd9KTtcbiAgICAgICAgICAgIGFwcGVuZE9uQnVmZmVyRmx1c2ggPSB0cnVlO1xuICAgICAgICAgICAgLy9MZXRzIGFubm91bmNlIHRoYXQgdGhlIGluaXRpYWwgYXVkaW8gdHJhY2sgc3dpdGNoIGZsdXNoIG9jY3VyXG4gICAgICAgICAgICB0aGlzLmF1ZGlvU3dpdGNoID0gZmFsc2U7XG4gICAgICAgICAgICBobHMudHJpZ2dlcihFdmVudC5BVURJT19UUkFDS19TV0lUQ0hFRCwge2lkIDogdHJhY2tJZH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvL0xldHMgYW5ub3VuY2UgdGhhdCB0aGUgaW5pdGlhbCBhdWRpbyB0cmFjayBzd2l0Y2ggZmx1c2ggb2NjdXJcbiAgICAgICAgICB0aGlzLmF1ZGlvU3dpdGNoPWZhbHNlO1xuICAgICAgICAgIGhscy50cmlnZ2VyKEV2ZW50LkFVRElPX1RSQUNLX1NXSVRDSEVELCB7aWQgOiB0cmFja0lkfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuXG4gICAgICBsZXQgcGVuZGluZ0RhdGEgPSB0aGlzLnBlbmRpbmdEYXRhO1xuICAgICAgaWYoIXRoaXMuYXVkaW9Td2l0Y2gpIHtcbiAgICAgICAgW2RhdGEuZGF0YTEsIGRhdGEuZGF0YTJdLmZvckVhY2goYnVmZmVyID0+IHtcbiAgICAgICAgICBpZiAoYnVmZmVyICYmIGJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgICAgIHBlbmRpbmdEYXRhLnB1c2goe3R5cGU6IGRhdGEudHlwZSwgZGF0YTogYnVmZmVyLCBwYXJlbnQgOiAnYXVkaW8nLGNvbnRlbnQgOiAnZGF0YSd9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgaWYgKCFhcHBlbmRPbkJ1ZmZlckZsdXNoICYmIHBlbmRpbmdEYXRhLmxlbmd0aCkge1xuICAgICAgICAgIHBlbmRpbmdEYXRhLmZvckVhY2goYXBwZW5kT2JqID0+IHtcbiAgICAgICAgICAgIC8vIG9ubHkgYXBwZW5kIGluIFBBUlNJTkcgc3RhdGUgKHJhdGlvbmFsZSBpcyB0aGF0IGFuIGFwcGVuZGluZyBlcnJvciBjb3VsZCBoYXBwZW4gc3luY2hyb25vdXNseSBvbiBmaXJzdCBzZWdtZW50IGFwcGVuZGluZylcbiAgICAgICAgICAgIC8vIGluIHRoYXQgY2FzZSBpdCBpcyB1c2VsZXNzIHRvIGFwcGVuZCBmb2xsb3dpbmcgc2VnbWVudHNcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlID09PSBTdGF0ZS5QQVJTSU5HKSB7XG4gICAgICAgICAgICAgIC8vIGFybSBwZW5kaW5nIEJ1ZmZlcmluZyBmbGFnIGJlZm9yZSBhcHBlbmRpbmcgYSBzZWdtZW50XG4gICAgICAgICAgICAgIHRoaXMucGVuZGluZ0J1ZmZlcmluZyA9IHRydWU7XG4gICAgICAgICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuQlVGRkVSX0FQUEVORElORywgYXBwZW5kT2JqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzLnBlbmRpbmdEYXRhID0gW107XG4gICAgICAgICAgdGhpcy5hcHBlbmRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vdHJpZ2dlciBoYW5kbGVyIHJpZ2h0IG5vd1xuICAgICAgdGhpcy50aWNrKCk7XG4gICAgfVxuICB9XG5cbiAgb25GcmFnUGFyc2VkKGRhdGEpIHtcbiAgICBjb25zdCBmcmFnQ3VycmVudCA9IHRoaXMuZnJhZ0N1cnJlbnQ7XG4gICAgY29uc3QgZnJhZ05ldyA9IGRhdGEuZnJhZztcbiAgICBpZiAoZnJhZ0N1cnJlbnQgJiZcbiAgICAgICAgZGF0YS5pZCA9PT0gJ2F1ZGlvJyAmJlxuICAgICAgICBmcmFnTmV3LnNuID09PSBmcmFnQ3VycmVudC5zbiAmJlxuICAgICAgICBmcmFnTmV3LmxldmVsID09PSBmcmFnQ3VycmVudC5sZXZlbCAmJlxuICAgICAgICB0aGlzLnN0YXRlID09PSBTdGF0ZS5QQVJTSU5HKSB7XG4gICAgICB0aGlzLnN0YXRzLnRwYXJzZWQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5QQVJTRUQ7XG4gICAgICB0aGlzLl9jaGVja0FwcGVuZGVkUGFyc2VkKCk7XG4gICAgfVxuICB9XG5cblxuICBvbkJ1ZmZlckNyZWF0ZWQoZGF0YSkge1xuICAgIGxldCBhdWRpb1RyYWNrID0gZGF0YS50cmFja3MuYXVkaW87XG4gICAgaWYgKGF1ZGlvVHJhY2spIHtcbiAgICAgIHRoaXMubWVkaWFCdWZmZXIgPSBhdWRpb1RyYWNrLmJ1ZmZlcjtcbiAgICAgIHRoaXMubG9hZGVkbWV0YWRhdGEgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIG9uQnVmZmVyQXBwZW5kZWQoZGF0YSkge1xuICAgIGlmIChkYXRhLnBhcmVudCA9PT0gJ2F1ZGlvJykge1xuICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgICAgaWYgKHN0YXRlID09PSBTdGF0ZS5QQVJTSU5HIHx8IHN0YXRlID09PSBTdGF0ZS5QQVJTRUQpIHtcbiAgICAgICAgLy8gY2hlY2sgaWYgYWxsIGJ1ZmZlcnMgaGF2ZSBiZWVuIGFwcGVuZGVkXG4gICAgICAgIHRoaXMucGVuZGluZ0J1ZmZlcmluZyA9IChkYXRhLnBlbmRpbmcgPiAwKTtcbiAgICAgICAgdGhpcy5fY2hlY2tBcHBlbmRlZFBhcnNlZCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIF9jaGVja0FwcGVuZGVkUGFyc2VkKCkge1xuICAgIC8vdHJpZ2dlciBoYW5kbGVyIHJpZ2h0IG5vd1xuICAgIGlmICh0aGlzLnN0YXRlID09PSBTdGF0ZS5QQVJTRUQgJiYgKCF0aGlzLmFwcGVuZGVkIHx8ICF0aGlzLnBlbmRpbmdCdWZmZXJpbmcpKSAgIHtcbiAgICAgIGxldCBmcmFnID0gdGhpcy5mcmFnQ3VycmVudCwgc3RhdHMgPSB0aGlzLnN0YXRzLCBobHMgPSB0aGlzLmhscztcbiAgICAgIGlmIChmcmFnKSB7XG4gICAgICAgIHRoaXMuZnJhZ1ByZXZpb3VzID0gZnJhZztcbiAgICAgICAgc3RhdHMudGJ1ZmZlcmVkID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIGhscy50cmlnZ2VyKEV2ZW50LkZSQUdfQlVGRkVSRUQsIHtzdGF0czogc3RhdHMsIGZyYWc6IGZyYWcsIGlkIDogJ2F1ZGlvJ30pO1xuICAgICAgICBsZXQgbWVkaWEgPSB0aGlzLm1lZGlhQnVmZmVyID8gdGhpcy5tZWRpYUJ1ZmZlciA6IHRoaXMubWVkaWE7XG4gICAgICAgIGxvZ2dlci5sb2coYGF1ZGlvIGJ1ZmZlcmVkIDogJHtUaW1lUmFuZ2VzLnRvU3RyaW5nKG1lZGlhLmJ1ZmZlcmVkKX1gKTtcbiAgICAgICAgaWYgKHRoaXMuYXVkaW9Td2l0Y2ggJiYgdGhpcy5hcHBlbmRlZCkge1xuICAgICAgICAgIHRoaXMuYXVkaW9Td2l0Y2ggPSBmYWxzZTtcbiAgICAgICAgICBobHMudHJpZ2dlcihFdmVudC5BVURJT19UUkFDS19TV0lUQ0hFRCwge2lkIDogdGhpcy50cmFja0lkfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICB9XG4gICAgICB0aGlzLnRpY2soKTtcbiAgICB9XG4gIH1cblxuICBvbkVycm9yKGRhdGEpIHtcbiAgICBsZXQgZnJhZyA9IGRhdGEuZnJhZztcbiAgICAvLyBkb24ndCBoYW5kbGUgZnJhZyBlcnJvciBub3QgcmVsYXRlZCB0byBhdWRpbyBmcmFnbWVudFxuICAgIGlmIChmcmFnICYmIGZyYWcudHlwZSAhPT0gJ2F1ZGlvJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzd2l0Y2goZGF0YS5kZXRhaWxzKSB7XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5GUkFHX0xPQURfRVJST1I6XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5GUkFHX0xPQURfVElNRU9VVDpcbiAgICAgICAgaWYoIWRhdGEuZmF0YWwpIHtcbiAgICAgICAgICB2YXIgbG9hZEVycm9yID0gdGhpcy5mcmFnTG9hZEVycm9yO1xuICAgICAgICAgIGlmKGxvYWRFcnJvcikge1xuICAgICAgICAgICAgbG9hZEVycm9yKys7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxvYWRFcnJvcj0xO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgY29uZmlnID0gdGhpcy5jb25maWc7XG4gICAgICAgICAgaWYgKGxvYWRFcnJvciA8PSBjb25maWcuZnJhZ0xvYWRpbmdNYXhSZXRyeSkge1xuICAgICAgICAgICAgdGhpcy5mcmFnTG9hZEVycm9yID0gbG9hZEVycm9yO1xuICAgICAgICAgICAgLy8gcmVzZXQgbG9hZCBjb3VudGVyIHRvIGF2b2lkIGZyYWcgbG9vcCBsb2FkaW5nIGVycm9yXG4gICAgICAgICAgICBmcmFnLmxvYWRDb3VudGVyID0gMDtcbiAgICAgICAgICAgIC8vIGV4cG9uZW50aWFsIGJhY2tvZmYgY2FwcGVkIHRvIGNvbmZpZy5mcmFnTG9hZGluZ01heFJldHJ5VGltZW91dFxuICAgICAgICAgICAgdmFyIGRlbGF5ID0gTWF0aC5taW4oTWF0aC5wb3coMixsb2FkRXJyb3ItMSkqY29uZmlnLmZyYWdMb2FkaW5nUmV0cnlEZWxheSxjb25maWcuZnJhZ0xvYWRpbmdNYXhSZXRyeVRpbWVvdXQpO1xuICAgICAgICAgICAgbG9nZ2VyLndhcm4oYGF1ZGlvU3RyZWFtQ29udHJvbGxlcjogZnJhZyBsb2FkaW5nIGZhaWxlZCwgcmV0cnkgaW4gJHtkZWxheX0gbXNgKTtcbiAgICAgICAgICAgIHRoaXMucmV0cnlEYXRlID0gcGVyZm9ybWFuY2Uubm93KCkgKyBkZWxheTtcbiAgICAgICAgICAgIC8vIHJldHJ5IGxvYWRpbmcgc3RhdGVcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5GUkFHX0xPQURJTkdfV0FJVElOR19SRVRSWTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGBhdWRpb1N0cmVhbUNvbnRyb2xsZXI6ICR7ZGF0YS5kZXRhaWxzfSByZWFjaGVzIG1heCByZXRyeSwgcmVkaXNwYXRjaCBhcyBmYXRhbCAuLi5gKTtcbiAgICAgICAgICAgIC8vIHN3aXRjaCBlcnJvciB0byBmYXRhbFxuICAgICAgICAgICAgZGF0YS5mYXRhbCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuRVJST1I7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBFcnJvckRldGFpbHMuRlJBR19MT09QX0xPQURJTkdfRVJST1I6XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5BVURJT19UUkFDS19MT0FEX0VSUk9SOlxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuQVVESU9fVFJBQ0tfTE9BRF9USU1FT1VUOlxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuS0VZX0xPQURfRVJST1I6XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5LRVlfTE9BRF9USU1FT1VUOlxuICAgICAgICAvLyAgd2hlbiBpbiBFUlJPUiBzdGF0ZSwgZG9uJ3Qgc3dpdGNoIGJhY2sgdG8gSURMRSBzdGF0ZSBpbiBjYXNlIGEgbm9uLWZhdGFsIGVycm9yIGlzIHJlY2VpdmVkXG4gICAgICAgIGlmKHRoaXMuc3RhdGUgIT09IFN0YXRlLkVSUk9SKSB7XG4gICAgICAgICAgICAvLyBpZiBmYXRhbCBlcnJvciwgc3RvcCBwcm9jZXNzaW5nLCBvdGhlcndpc2UgbW92ZSB0byBJRExFIHRvIHJldHJ5IGxvYWRpbmdcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBkYXRhLmZhdGFsID8gU3RhdGUuRVJST1IgOiBTdGF0ZS5JRExFO1xuICAgICAgICAgICAgbG9nZ2VyLndhcm4oYGF1ZGlvU3RyZWFtQ29udHJvbGxlcjogJHtkYXRhLmRldGFpbHN9IHdoaWxlIGxvYWRpbmcgZnJhZyxzd2l0Y2ggdG8gJHt0aGlzLnN0YXRlfSBzdGF0ZSAuLi5gKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkJVRkZFUl9GVUxMX0VSUk9SOlxuICAgICAgICAvLyBpZiBpbiBhcHBlbmRpbmcgc3RhdGVcbiAgICAgICAgaWYgKGRhdGEucGFyZW50ID09PSAnYXVkaW8nICYmICh0aGlzLnN0YXRlID09PSBTdGF0ZS5QQVJTSU5HIHx8wqB0aGlzLnN0YXRlID09PSBTdGF0ZS5QQVJTRUQpKSB7XG4gICAgICAgICAgY29uc3QgbWVkaWEgPSB0aGlzLm1lZGlhQnVmZmVyLFxuICAgICAgICAgICAgICAgIGN1cnJlbnRUaW1lID0gdGhpcy5tZWRpYS5jdXJyZW50VGltZSxcbiAgICAgICAgICAgICAgICBtZWRpYUJ1ZmZlcmVkID0gbWVkaWEgJiYgQnVmZmVySGVscGVyLmlzQnVmZmVyZWQobWVkaWEsY3VycmVudFRpbWUpICYmIEJ1ZmZlckhlbHBlci5pc0J1ZmZlcmVkKG1lZGlhLGN1cnJlbnRUaW1lKzAuNSk7XG4gICAgICAgICAgLy8gcmVkdWNlIG1heCBidWYgbGVuIGlmIGN1cnJlbnQgcG9zaXRpb24gaXMgYnVmZmVyZWRcbiAgICAgICAgICBpZiAobWVkaWFCdWZmZXJlZCkge1xuICAgICAgICAgICAgY29uc3QgY29uZmlnID0gdGhpcy5jb25maWc7XG4gICAgICAgICAgICBpZihjb25maWcubWF4TWF4QnVmZmVyTGVuZ3RoID49IGNvbmZpZy5tYXhCdWZmZXJMZW5ndGgpIHtcbiAgICAgICAgICAgICAgLy8gcmVkdWNlIG1heCBidWZmZXIgbGVuZ3RoIGFzIGl0IG1pZ2h0IGJlIHRvbyBoaWdoLiB3ZSBkbyB0aGlzIHRvIGF2b2lkIGxvb3AgZmx1c2hpbmcgLi4uXG4gICAgICAgICAgICAgIGNvbmZpZy5tYXhNYXhCdWZmZXJMZW5ndGgvPTI7XG4gICAgICAgICAgICAgIGxvZ2dlci53YXJuKGBhdWRpbzpyZWR1Y2UgbWF4IGJ1ZmZlciBsZW5ndGggdG8gJHtjb25maWcubWF4TWF4QnVmZmVyTGVuZ3RofXNgKTtcbiAgICAgICAgICAgICAgLy8gaW5jcmVhc2UgZnJhZ21lbnQgbG9hZCBJbmRleCB0byBhdm9pZCBmcmFnIGxvb3AgbG9hZGluZyBlcnJvciBhZnRlciBidWZmZXIgZmx1c2hcbiAgICAgICAgICAgICAgdGhpcy5mcmFnTG9hZElkeCArPSAyICogY29uZmlnLmZyYWdMb2FkaW5nTG9vcFRocmVzaG9sZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBjdXJyZW50IHBvc2l0aW9uIGlzIG5vdCBidWZmZXJlZCwgYnV0IGJyb3dzZXIgaXMgc3RpbGwgY29tcGxhaW5pbmcgYWJvdXQgYnVmZmVyIGZ1bGwgZXJyb3JcbiAgICAgICAgICAgIC8vIHRoaXMgaGFwcGVucyBvbiBJRS9FZGdlLCByZWZlciB0byBodHRwczovL2dpdGh1Yi5jb20vdmlkZW8tZGV2L2hscy5qcy9wdWxsLzcwOFxuICAgICAgICAgICAgLy8gaW4gdGhhdCBjYXNlIGZsdXNoIHRoZSB3aG9sZSBhdWRpbyBidWZmZXIgdG8gcmVjb3ZlclxuICAgICAgICAgICAgbG9nZ2VyLndhcm4oJ2J1ZmZlciBmdWxsIGVycm9yIGFsc28gbWVkaWEuY3VycmVudFRpbWUgaXMgbm90IGJ1ZmZlcmVkLCBmbHVzaCBhdWRpbyBidWZmZXInKTtcbiAgICAgICAgICAgIHRoaXMuZnJhZ0N1cnJlbnQgPSBudWxsO1xuICAgICAgICAgICAgLy8gZmx1c2ggZXZlcnl0aGluZ1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkJVRkZFUl9GTFVTSElORztcbiAgICAgICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuQlVGRkVSX0ZMVVNISU5HLCB7c3RhcnRPZmZzZXQ6IDAgLCBlbmRPZmZzZXQ6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSwgdHlwZSA6ICdhdWRpbyd9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBvbkJ1ZmZlckZsdXNoZWQoKSB7XG4gICAgbGV0IHBlbmRpbmdEYXRhID0gdGhpcy5wZW5kaW5nRGF0YTtcbiAgICBpZiAocGVuZGluZ0RhdGEgJiYgcGVuZGluZ0RhdGEubGVuZ3RoKSB7XG4gICAgICBsb2dnZXIubG9nKCdhcHBlbmRpbmcgcGVuZGluZyBhdWRpbyBkYXRhIG9uIEJ1ZmZlciBGbHVzaGVkJyk7XG4gICAgICBwZW5kaW5nRGF0YS5mb3JFYWNoKGFwcGVuZE9iaiA9PiB7XG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuQlVGRkVSX0FQUEVORElORywgYXBwZW5kT2JqKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5hcHBlbmRlZCA9IHRydWU7XG4gICAgICB0aGlzLnBlbmRpbmdEYXRhID0gW107XG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuUEFSU0VEO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBtb3ZlIHRvIElETEUgb25jZSBmbHVzaCBjb21wbGV0ZS4gdGhpcyBzaG91bGQgdHJpZ2dlciBuZXcgZnJhZ21lbnQgbG9hZGluZ1xuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICAvLyByZXNldCByZWZlcmVuY2UgdG8gZnJhZ1xuICAgICAgdGhpcy5mcmFnUHJldmlvdXMgPSBudWxsO1xuICAgICAgdGhpcy50aWNrKCk7XG4gICAgfVxuICB9XG59XG5leHBvcnQgZGVmYXVsdCBBdWRpb1N0cmVhbUNvbnRyb2xsZXI7XG5cbiIsIi8qXG4gKiBhdWRpbyB0cmFjayBjb250cm9sbGVyXG4qL1xuXG5pbXBvcnQgRXZlbnQgZnJvbSAnLi4vZXZlbnRzJztcbmltcG9ydCBFdmVudEhhbmRsZXIgZnJvbSAnLi4vZXZlbnQtaGFuZGxlcic7XG5pbXBvcnQge2xvZ2dlcn0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcblxuY2xhc3MgQXVkaW9UcmFja0NvbnRyb2xsZXIgZXh0ZW5kcyBFdmVudEhhbmRsZXIge1xuXG4gIGNvbnN0cnVjdG9yKGhscykge1xuICAgIHN1cGVyKGhscywgRXZlbnQuTUFOSUZFU1RfTE9BRElORyxcbiAgICAgICAgICAgICAgIEV2ZW50Lk1BTklGRVNUX0xPQURFRCxcbiAgICAgICAgICAgICAgIEV2ZW50LkFVRElPX1RSQUNLX0xPQURFRCk7XG4gICAgdGhpcy50aWNrcyA9IDA7XG4gICAgdGhpcy5vbnRpY2sgPSB0aGlzLnRpY2suYmluZCh0aGlzKTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgRXZlbnRIYW5kbGVyLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XG4gIH1cbiAgdGljaygpIHtcbiAgICB0aGlzLnRpY2tzKys7XG4gICAgaWYgKHRoaXMudGlja3MgPT09IDEpIHtcbiAgICAgIHRoaXMuZG9UaWNrKCk7XG4gICAgICBpZiAodGhpcy50aWNrcyA+IDEpIHtcbiAgICAgICAgc2V0VGltZW91dCh0aGlzLnRpY2ssIDEpO1xuICAgICAgfVxuICAgICAgdGhpcy50aWNrcyA9IDA7XG4gICAgfVxuICB9XG4gIGRvVGljaygpIHtcbiAgICB0aGlzLnVwZGF0ZVRyYWNrKHRoaXMudHJhY2tJZCk7XG4gIH1cbiAgb25NYW5pZmVzdExvYWRpbmcoKSB7XG4gICAgLy8gcmVzZXQgYXVkaW8gdHJhY2tzIG9uIG1hbmlmZXN0IGxvYWRpbmdcbiAgICB0aGlzLnRyYWNrcyA9IFtdO1xuICAgIHRoaXMudHJhY2tJZCA9IC0xO1xuICB9XG5cbiAgb25NYW5pZmVzdExvYWRlZChkYXRhKSB7XG4gICAgbGV0IHRyYWNrcyA9IGRhdGEuYXVkaW9UcmFja3MgfHwgW107XG4gICAgbGV0IGRlZmF1bHRGb3VuZCA9IGZhbHNlO1xuICAgIHRoaXMudHJhY2tzID0gdHJhY2tzO1xuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuQVVESU9fVFJBQ0tTX1VQREFURUQsIHthdWRpb1RyYWNrcyA6IHRyYWNrc30pO1xuICAgIC8vIGxvb3AgdGhyb3VnaCBhdmFpbGFibGUgYXVkaW8gdHJhY2tzIGFuZCBhdXRvc2VsZWN0IGRlZmF1bHQgaWYgbmVlZGVkXG4gICAgbGV0IGlkID0gMDtcbiAgICB0cmFja3MuZm9yRWFjaCh0cmFjayA9PiB7XG4gICAgICBpZih0cmFjay5kZWZhdWx0KSB7XG4gICAgICAgIHRoaXMuYXVkaW9UcmFjayA9IGlkO1xuICAgICAgICBkZWZhdWx0Rm91bmQgPSB0cnVlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZCsrO1xuICAgIH0pO1xuICAgIGlmIChkZWZhdWx0Rm91bmQgPT09IGZhbHNlICYmIHRyYWNrcy5sZW5ndGgpIHtcbiAgICAgIGxvZ2dlci5sb2coJ25vIGRlZmF1bHQgYXVkaW8gdHJhY2sgZGVmaW5lZCwgdXNlIGZpcnN0IGF1ZGlvIHRyYWNrIGFzIGRlZmF1bHQnKTtcbiAgICAgIHRoaXMuYXVkaW9UcmFjayA9IDA7XG4gICAgfVxuICB9XG5cbiAgb25BdWRpb1RyYWNrTG9hZGVkKGRhdGEpIHtcbiAgICBpZiAoZGF0YS5pZCA8IHRoaXMudHJhY2tzLmxlbmd0aCkge1xuICAgICAgbG9nZ2VyLmxvZyhgYXVkaW9UcmFjayAke2RhdGEuaWR9IGxvYWRlZGApO1xuICAgICAgdGhpcy50cmFja3NbZGF0YS5pZF0uZGV0YWlscyA9IGRhdGEuZGV0YWlscztcbiAgICAgIC8vIGNoZWNrIGlmIGN1cnJlbnQgcGxheWxpc3QgaXMgYSBsaXZlIHBsYXlsaXN0XG4gICAgICBpZiAoZGF0YS5kZXRhaWxzLmxpdmUgJiYgIXRoaXMudGltZXIpIHtcbiAgICAgICAgLy8gaWYgbGl2ZSBwbGF5bGlzdCB3ZSB3aWxsIGhhdmUgdG8gcmVsb2FkIGl0IHBlcmlvZGljYWxseVxuICAgICAgICAvLyBzZXQgcmVsb2FkIHBlcmlvZCB0byBwbGF5bGlzdCB0YXJnZXQgZHVyYXRpb25cbiAgICAgICAgdGhpcy50aW1lciA9IHNldEludGVydmFsKHRoaXMub250aWNrLCAxMDAwICogZGF0YS5kZXRhaWxzLnRhcmdldGR1cmF0aW9uKTtcbiAgICAgIH1cbiAgICAgIGlmICghZGF0YS5kZXRhaWxzLmxpdmUgJiYgdGhpcy50aW1lcikge1xuICAgICAgICAvLyBwbGF5bGlzdCBpcyBub3QgbGl2ZSBhbmQgdGltZXIgaXMgYXJtZWQgOiBzdG9wcGluZyBpdFxuICAgICAgICBjbGVhckludGVydmFsKHRoaXMudGltZXIpO1xuICAgICAgICB0aGlzLnRpbWVyID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKiogZ2V0IGFsdGVybmF0ZSBhdWRpbyB0cmFja3MgbGlzdCBmcm9tIHBsYXlsaXN0ICoqL1xuICBnZXQgYXVkaW9UcmFja3MoKSB7XG4gICAgcmV0dXJuIHRoaXMudHJhY2tzO1xuICB9XG5cbiAgLyoqIGdldCBpbmRleCBvZiB0aGUgc2VsZWN0ZWQgYXVkaW8gdHJhY2sgKGluZGV4IGluIGF1ZGlvIHRyYWNrIGxpc3RzKSAqKi9cbiAgZ2V0IGF1ZGlvVHJhY2soKSB7XG4gICByZXR1cm4gdGhpcy50cmFja0lkO1xuICB9XG5cbiAgLyoqIHNlbGVjdCBhbiBhdWRpbyB0cmFjaywgYmFzZWQgb24gaXRzIGluZGV4IGluIGF1ZGlvIHRyYWNrIGxpc3RzKiovXG4gIHNldCBhdWRpb1RyYWNrKGF1ZGlvVHJhY2tJZCkge1xuICAgIGlmICh0aGlzLnRyYWNrSWQgIT09IGF1ZGlvVHJhY2tJZCB8fCB0aGlzLnRyYWNrc1thdWRpb1RyYWNrSWRdLmRldGFpbHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5zZXRBdWRpb1RyYWNrSW50ZXJuYWwoYXVkaW9UcmFja0lkKTtcbiAgICB9XG4gIH1cblxuIHNldEF1ZGlvVHJhY2tJbnRlcm5hbChuZXdJZCkge1xuICAgIC8vIGNoZWNrIGlmIGxldmVsIGlkeCBpcyB2YWxpZFxuICAgIGlmIChuZXdJZCA+PSAwICYmIG5ld0lkIDwgdGhpcy50cmFja3MubGVuZ3RoKSB7XG4gICAgICAvLyBzdG9wcGluZyBsaXZlIHJlbG9hZGluZyB0aW1lciBpZiBhbnlcbiAgICAgIGlmICh0aGlzLnRpbWVyKSB7XG4gICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLnRpbWVyKTtcbiAgICAgICB0aGlzLnRpbWVyID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHRoaXMudHJhY2tJZCA9IG5ld0lkO1xuICAgICAgbG9nZ2VyLmxvZyhgc3dpdGNoaW5nIHRvIGF1ZGlvVHJhY2sgJHtuZXdJZH1gKTtcbiAgICAgIGxldCBhdWRpb1RyYWNrID0gdGhpcy50cmFja3NbbmV3SWRdLFxuICAgICAgICAgIGhscyA9IHRoaXMuaGxzLFxuICAgICAgICAgIHR5cGUgPSBhdWRpb1RyYWNrLnR5cGUsXG4gICAgICAgICAgdXJsID0gYXVkaW9UcmFjay51cmwsXG4gICAgICAgICAgZXZlbnRPYmogPSB7aWQ6IG5ld0lkLCB0eXBlIDogdHlwZSwgdXJsIDogdXJsfTtcbiAgICAgIC8vIGtlZXAgQVVESU9fVFJBQ0tfU1dJVENIIGZvciBsZWdhY3kgcmVhc29uXG4gICAgICBobHMudHJpZ2dlcihFdmVudC5BVURJT19UUkFDS19TV0lUQ0gsIGV2ZW50T2JqKTtcbiAgICAgIGhscy50cmlnZ2VyKEV2ZW50LkFVRElPX1RSQUNLX1NXSVRDSElORywgZXZlbnRPYmopO1xuICAgICAgIC8vIGNoZWNrIGlmIHdlIG5lZWQgdG8gbG9hZCBwbGF5bGlzdCBmb3IgdGhpcyBhdWRpbyBUcmFja1xuICAgICAgIGxldCBkZXRhaWxzID0gYXVkaW9UcmFjay5kZXRhaWxzO1xuICAgICAgaWYgKHVybCAmJiAoZGV0YWlscyA9PT0gdW5kZWZpbmVkIHx8IGRldGFpbHMubGl2ZSA9PT0gdHJ1ZSkpIHtcbiAgICAgICAgLy8gdHJhY2sgbm90IHJldHJpZXZlZCB5ZXQsIG9yIGxpdmUgcGxheWxpc3Qgd2UgbmVlZCB0byAocmUpbG9hZCBpdFxuICAgICAgICBsb2dnZXIubG9nKGAocmUpbG9hZGluZyBwbGF5bGlzdCBmb3IgYXVkaW9UcmFjayAke25ld0lkfWApO1xuICAgICAgICBobHMudHJpZ2dlcihFdmVudC5BVURJT19UUkFDS19MT0FESU5HLCB7dXJsOiB1cmwsIGlkOiBuZXdJZH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHVwZGF0ZVRyYWNrKG5ld0lkKSB7XG4gICAgLy8gY2hlY2sgaWYgbGV2ZWwgaWR4IGlzIHZhbGlkXG4gICAgaWYgKG5ld0lkID49IDAgJiYgbmV3SWQgPCB0aGlzLnRyYWNrcy5sZW5ndGgpIHtcbiAgICAgIC8vIHN0b3BwaW5nIGxpdmUgcmVsb2FkaW5nIHRpbWVyIGlmIGFueVxuICAgICAgaWYgKHRoaXMudGltZXIpIHtcbiAgICAgICBjbGVhckludGVydmFsKHRoaXMudGltZXIpO1xuICAgICAgIHRoaXMudGltZXIgPSBudWxsO1xuICAgICAgfVxuICAgICAgdGhpcy50cmFja0lkID0gbmV3SWQ7XG4gICAgICBsb2dnZXIubG9nKGB1cGRhdGluZyBhdWRpb1RyYWNrICR7bmV3SWR9YCk7XG4gICAgICBsZXQgYXVkaW9UcmFjayA9IHRoaXMudHJhY2tzW25ld0lkXSwgdXJsID0gYXVkaW9UcmFjay51cmw7XG4gICAgICAgLy8gY2hlY2sgaWYgd2UgbmVlZCB0byBsb2FkIHBsYXlsaXN0IGZvciB0aGlzIGF1ZGlvIFRyYWNrXG4gICAgICAgbGV0IGRldGFpbHMgPSBhdWRpb1RyYWNrLmRldGFpbHM7XG4gICAgICBpZiAodXJsICYmIChkZXRhaWxzID09PSB1bmRlZmluZWQgfHwgZGV0YWlscy5saXZlID09PSB0cnVlKSkge1xuICAgICAgICAvLyB0cmFjayBub3QgcmV0cmlldmVkIHlldCwgb3IgbGl2ZSBwbGF5bGlzdCB3ZSBuZWVkIHRvIChyZSlsb2FkIGl0XG4gICAgICAgIGxvZ2dlci5sb2coYChyZSlsb2FkaW5nIHBsYXlsaXN0IGZvciBhdWRpb1RyYWNrICR7bmV3SWR9YCk7XG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuQVVESU9fVFJBQ0tfTE9BRElORywge3VybDogdXJsLCBpZDogbmV3SWR9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQXVkaW9UcmFja0NvbnRyb2xsZXI7XG4iLCIvKlxuICogQnVmZmVyIENvbnRyb2xsZXJcbiovXG5cbmltcG9ydCBFdmVudCBmcm9tICcuLi9ldmVudHMnO1xuaW1wb3J0IEV2ZW50SGFuZGxlciBmcm9tICcuLi9ldmVudC1oYW5kbGVyJztcbmltcG9ydCB7bG9nZ2VyfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xuaW1wb3J0IHtFcnJvclR5cGVzLCBFcnJvckRldGFpbHN9IGZyb20gJy4uL2Vycm9ycyc7XG5cblxuY2xhc3MgQnVmZmVyQ29udHJvbGxlciBleHRlbmRzIEV2ZW50SGFuZGxlciB7XG5cbiAgY29uc3RydWN0b3IoaGxzKSB7XG4gICAgc3VwZXIoaGxzLFxuICAgICAgRXZlbnQuTUVESUFfQVRUQUNISU5HLFxuICAgICAgRXZlbnQuTUVESUFfREVUQUNISU5HLFxuICAgICAgRXZlbnQuTUFOSUZFU1RfUEFSU0VELFxuICAgICAgRXZlbnQuQlVGRkVSX1JFU0VULFxuICAgICAgRXZlbnQuQlVGRkVSX0FQUEVORElORyxcbiAgICAgIEV2ZW50LkJVRkZFUl9DT0RFQ1MsXG4gICAgICBFdmVudC5CVUZGRVJfRU9TLFxuICAgICAgRXZlbnQuQlVGRkVSX0ZMVVNISU5HLFxuICAgICAgRXZlbnQuTEVWRUxfUFRTX1VQREFURUQsXG4gICAgICBFdmVudC5MRVZFTF9VUERBVEVEKTtcblxuICAgIC8vIHRoZSB2YWx1ZSB0aGF0IHdlIGhhdmUgc2V0IG1lZGlhc291cmNlLmR1cmF0aW9uIHRvXG4gICAgLy8gKHRoZSBhY3R1YWwgZHVyYXRpb24gbWF5IGJlIHR3ZWFrZWQgc2xpZ2hseSBieSB0aGUgYnJvd3NlcilcbiAgICB0aGlzLl9tc0R1cmF0aW9uID0gbnVsbDtcbiAgICAvLyB0aGUgdmFsdWUgdGhhdCB3ZSB3YW50IHRvIHNldCBtZWRpYVNvdXJjZS5kdXJhdGlvbiB0b1xuICAgIHRoaXMuX2xldmVsRHVyYXRpb24gPSBudWxsO1xuXG4gICAgLy8gU291cmNlIEJ1ZmZlciBsaXN0ZW5lcnNcbiAgICB0aGlzLm9uc2J1ZSA9IHRoaXMub25TQlVwZGF0ZUVuZC5iaW5kKHRoaXMpO1xuICAgIHRoaXMub25zYmUgID0gdGhpcy5vblNCVXBkYXRlRXJyb3IuYmluZCh0aGlzKTtcbiAgICB0aGlzLnBlbmRpbmdUcmFja3MgPSB7fTtcbiAgICB0aGlzLnRyYWNrcyA9IHt9O1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICBFdmVudEhhbmRsZXIucHJvdG90eXBlLmRlc3Ryb3kuY2FsbCh0aGlzKTtcbiAgfVxuXG4gIG9uTGV2ZWxQdHNVcGRhdGVkKGRhdGEpIHtcbiAgICBsZXQgdHlwZSA9IGRhdGEudHlwZTtcbiAgICBsZXQgYXVkaW9UcmFjayA9IHRoaXMudHJhY2tzLmF1ZGlvO1xuXG4gICAgLy8gQWRqdXN0aW5nIGBTb3VyY2VCdWZmZXIudGltZXN0YW1wT2Zmc2V0YCAoZGVzaXJlZCBwb2ludCBpbiB0aGUgdGltZWxpbmUgd2hlcmUgdGhlIG5leHQgZnJhbWVzIHNob3VsZCBiZSBhcHBlbmRlZClcbiAgICAvLyBpbiBDaHJvbWUgYnJvd3NlciB3aGVuIHdlIGRldGVjdCBNUEVHIGF1ZGlvIGNvbnRhaW5lciBhbmQgdGltZSBkZWx0YSBiZXR3ZWVuIGxldmVsIFBUUyBhbmQgYFNvdXJjZUJ1ZmZlci50aW1lc3RhbXBPZmZzZXRgXG4gICAgLy8gaXMgZ3JlYXRlciB0aGFuIDEwMG1zICh0aGlzIGlzIGVub3VnaCB0byBoYW5kbGUgc2VlayBmb3IgVk9EIG9yIGxldmVsIGNoYW5nZSBmb3IgTElWRSB2aWRlb3MpLiBBdCB0aGUgdGltZSBvZiBjaGFuZ2Ugd2UgaXNzdWVcbiAgICAvLyBgU291cmNlQnVmZmVyLmFib3J0KClgIGFuZCBhZGp1c3RpbmcgYFNvdXJjZUJ1ZmZlci50aW1lc3RhbXBPZmZzZXRgIGlmIGBTb3VyY2VCdWZmZXIudXBkYXRpbmdgIGlzIGZhbHNlIG9yIGF3YWl0aW5nIGB1cGRhdGVlbmRgXG4gICAgLy8gZXZlbnQgaWYgU0IgaXMgaW4gdXBkYXRpbmcgc3RhdGUuXG4gICAgLy8gTW9yZSBpbmZvIGhlcmU6IGh0dHBzOi8vZ2l0aHViLmNvbS92aWRlby1kZXYvaGxzLmpzL2lzc3Vlcy8zMzIjaXNzdWVjb21tZW50LTI1Nzk4NjQ4NlxuXG4gICAgaWYgKHR5cGUgPT09ICdhdWRpbycgJiYgYXVkaW9UcmFjayAmJiBhdWRpb1RyYWNrLmNvbnRhaW5lciA9PT0gJ2F1ZGlvL21wZWcnKSB7IC8vIENocm9tZSBhdWRpbyBtcDMgdHJhY2tcbiAgICAgIGxldCBhdWRpb0J1ZmZlciA9IHRoaXMuc291cmNlQnVmZmVyLmF1ZGlvO1xuICAgICAgbGV0IGRlbHRhID0gTWF0aC5hYnMoYXVkaW9CdWZmZXIudGltZXN0YW1wT2Zmc2V0IC0gZGF0YS5zdGFydCk7XG5cbiAgICAgIC8vIGFkanVzdCB0aW1lc3RhbXAgb2Zmc2V0IGlmIHRpbWUgZGVsdGEgaXMgZ3JlYXRlciB0aGFuIDEwMG1zXG4gICAgICBpZiAoZGVsdGEgPiAwLjEpIHtcbiAgICAgICAgbGV0IHVwZGF0aW5nID0gYXVkaW9CdWZmZXIudXBkYXRpbmc7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBhdWRpb0J1ZmZlci5hYm9ydCgpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICB1cGRhdGluZyA9IHRydWU7XG4gICAgICAgICAgbG9nZ2VyLndhcm4oJ2NhbiBub3QgYWJvcnQgYXVkaW8gYnVmZmVyOiAnICsgZXJyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdXBkYXRpbmcpIHtcbiAgICAgICAgICBsb2dnZXIud2FybignY2hhbmdlIG1wZWcgYXVkaW8gdGltZXN0YW1wIG9mZnNldCBmcm9tICcgKyBhdWRpb0J1ZmZlci50aW1lc3RhbXBPZmZzZXQgKyAnIHRvICcgKyBkYXRhLnN0YXJ0KTtcbiAgICAgICAgICBhdWRpb0J1ZmZlci50aW1lc3RhbXBPZmZzZXQgPSBkYXRhLnN0YXJ0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuYXVkaW9UaW1lc3RhbXBPZmZzZXQgPSBkYXRhLnN0YXJ0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgb25NYW5pZmVzdFBhcnNlZChkYXRhKSB7XG4gICAgbGV0IGF1ZGlvRXhwZWN0ZWQgPSBkYXRhLmF1ZGlvLFxuICAgICAgICB2aWRlb0V4cGVjdGVkID0gZGF0YS52aWRlbyxcbiAgICAgICAgc291cmNlQnVmZmVyTmIgPSAwO1xuICAgIC8vIGluIGNhc2Ugb2YgYWx0IGF1ZGlvIDIgQlVGRkVSX0NPREVDUyBldmVudHMgd2lsbCBiZSB0cmlnZ2VyZWQsIG9uZSBwZXIgc3RyZWFtIGNvbnRyb2xsZXJcbiAgICAvLyBzb3VyY2VidWZmZXJzIHdpbGwgYmUgY3JlYXRlZCBhbGwgYXQgb25jZSB3aGVuIHRoZSBleHBlY3RlZCBuYiBvZiB0cmFja3Mgd2lsbCBiZSByZWFjaGVkXG4gICAgLy8gaW4gY2FzZSBhbHQgYXVkaW8gaXMgbm90IHVzZWQsIG9ubHkgb25lIEJVRkZFUl9DT0RFQyBldmVudCB3aWxsIGJlIGZpcmVkIGZyb20gbWFpbiBzdHJlYW0gY29udHJvbGxlclxuICAgIC8vIGl0IHdpbGwgY29udGFpbiB0aGUgZXhwZWN0ZWQgbmIgb2Ygc291cmNlIGJ1ZmZlcnMsIG5vIG5lZWQgdG8gY29tcHV0ZSBpdFxuICAgIGlmIChkYXRhLmFsdEF1ZGlvICYmIChhdWRpb0V4cGVjdGVkIHx8IHZpZGVvRXhwZWN0ZWQpKSB7XG4gICAgICBzb3VyY2VCdWZmZXJOYiA9IChhdWRpb0V4cGVjdGVkID8gMSA6IDApICsgKHZpZGVvRXhwZWN0ZWQgPyAxIDogMCk7XG4gICAgICBsb2dnZXIubG9nKGAke3NvdXJjZUJ1ZmZlck5ifSBzb3VyY2VCdWZmZXIocykgZXhwZWN0ZWRgKTtcbiAgICB9XG4gICAgdGhpcy5zb3VyY2VCdWZmZXJOYiA9IHNvdXJjZUJ1ZmZlck5iO1xuICB9XG5cbiAgb25NZWRpYUF0dGFjaGluZyhkYXRhKSB7XG4gICAgbGV0IG1lZGlhID0gdGhpcy5tZWRpYSA9IGRhdGEubWVkaWE7XG4gICAgaWYgKG1lZGlhKSB7XG4gICAgICAvLyBzZXR1cCB0aGUgbWVkaWEgc291cmNlXG4gICAgICB2YXIgbXMgPSB0aGlzLm1lZGlhU291cmNlID0gbmV3IE1lZGlhU291cmNlKCk7XG4gICAgICAvL01lZGlhIFNvdXJjZSBsaXN0ZW5lcnNcbiAgICAgIHRoaXMub25tc28gPSB0aGlzLm9uTWVkaWFTb3VyY2VPcGVuLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLm9ubXNlID0gdGhpcy5vbk1lZGlhU291cmNlRW5kZWQuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMub25tc2MgPSB0aGlzLm9uTWVkaWFTb3VyY2VDbG9zZS5iaW5kKHRoaXMpO1xuICAgICAgbXMuYWRkRXZlbnRMaXN0ZW5lcignc291cmNlb3BlbicsIHRoaXMub25tc28pO1xuICAgICAgbXMuYWRkRXZlbnRMaXN0ZW5lcignc291cmNlZW5kZWQnLCB0aGlzLm9ubXNlKTtcbiAgICAgIG1zLmFkZEV2ZW50TGlzdGVuZXIoJ3NvdXJjZWNsb3NlJywgdGhpcy5vbm1zYyk7XG4gICAgICAvLyBsaW5rIHZpZGVvIGFuZCBtZWRpYSBTb3VyY2VcbiAgICAgIG1lZGlhLnNyYyA9IFVSTC5jcmVhdGVPYmplY3RVUkwobXMpO1xuICAgIH1cbiAgfVxuXG4gIG9uTWVkaWFEZXRhY2hpbmcoKSB7XG4gICAgbG9nZ2VyLmxvZygnbWVkaWEgc291cmNlIGRldGFjaGluZycpO1xuICAgIHZhciBtcyA9IHRoaXMubWVkaWFTb3VyY2U7XG4gICAgaWYgKG1zKSB7XG4gICAgICBpZiAobXMucmVhZHlTdGF0ZSA9PT0gJ29wZW4nKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gZW5kT2ZTdHJlYW0gY291bGQgdHJpZ2dlciBleGNlcHRpb24gaWYgYW55IHNvdXJjZWJ1ZmZlciBpcyBpbiB1cGRhdGluZyBzdGF0ZVxuICAgICAgICAgIC8vIHdlIGRvbid0IHJlYWxseSBjYXJlIGFib3V0IGNoZWNraW5nIHNvdXJjZWJ1ZmZlciBzdGF0ZSBoZXJlLFxuICAgICAgICAgIC8vIGFzIHdlIGFyZSBhbnl3YXkgZGV0YWNoaW5nIHRoZSBNZWRpYVNvdXJjZVxuICAgICAgICAgIC8vIGxldCdzIGp1c3QgYXZvaWQgdGhpcyBleGNlcHRpb24gdG8gcHJvcGFnYXRlXG4gICAgICAgICAgbXMuZW5kT2ZTdHJlYW0oKTtcbiAgICAgICAgfSBjYXRjaChlcnIpIHtcbiAgICAgICAgICBsb2dnZXIud2Fybihgb25NZWRpYURldGFjaGluZzoke2Vyci5tZXNzYWdlfSB3aGlsZSBjYWxsaW5nIGVuZE9mU3RyZWFtYCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG1zLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3NvdXJjZW9wZW4nLCB0aGlzLm9ubXNvKTtcbiAgICAgIG1zLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3NvdXJjZWVuZGVkJywgdGhpcy5vbm1zZSk7XG4gICAgICBtcy5yZW1vdmVFdmVudExpc3RlbmVyKCdzb3VyY2VjbG9zZScsIHRoaXMub25tc2MpO1xuXG4gICAgICAvLyBEZXRhY2ggcHJvcGVybHkgdGhlIE1lZGlhU291cmNlIGZyb20gdGhlIEhUTUxNZWRpYUVsZW1lbnQgYXNcbiAgICAgIC8vIHN1Z2dlc3RlZCBpbiBodHRwczovL2dpdGh1Yi5jb20vdzNjL21lZGlhLXNvdXJjZS9pc3N1ZXMvNTMuXG4gICAgICBpZiAodGhpcy5tZWRpYSkge1xuICAgICAgICBVUkwucmV2b2tlT2JqZWN0VVJMKHRoaXMubWVkaWEuc3JjKTtcbiAgICAgICAgdGhpcy5tZWRpYS5yZW1vdmVBdHRyaWJ1dGUoJ3NyYycpO1xuICAgICAgICB0aGlzLm1lZGlhLmxvYWQoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5tZWRpYVNvdXJjZSA9IG51bGw7XG4gICAgICB0aGlzLm1lZGlhID0gbnVsbDtcbiAgICAgIHRoaXMucGVuZGluZ1RyYWNrcyA9IHt9O1xuICAgICAgdGhpcy50cmFja3MgPSB7fTtcbiAgICAgIHRoaXMuc291cmNlQnVmZmVyID0ge307XG4gICAgICB0aGlzLmZsdXNoUmFuZ2UgPSBbXTtcbiAgICAgIHRoaXMuc2VnbWVudHMgPSBbXTtcbiAgICAgIHRoaXMuYXBwZW5kZWQgPSAwO1xuICAgIH1cbiAgICB0aGlzLm9ubXNvID0gdGhpcy5vbm1zZSA9IHRoaXMub25tc2MgPSBudWxsO1xuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuTUVESUFfREVUQUNIRUQpO1xuICB9XG5cbiAgb25NZWRpYVNvdXJjZU9wZW4oKSB7XG4gICAgbG9nZ2VyLmxvZygnbWVkaWEgc291cmNlIG9wZW5lZCcpO1xuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuTUVESUFfQVRUQUNIRUQsIHsgbWVkaWEgOiB0aGlzLm1lZGlhIH0pO1xuICAgIGxldCBtZWRpYVNvdXJjZSA9IHRoaXMubWVkaWFTb3VyY2U7XG4gICAgaWYgKG1lZGlhU291cmNlKSB7XG4gICAgICAvLyBvbmNlIHJlY2VpdmVkLCBkb24ndCBsaXN0ZW4gYW55bW9yZSB0byBzb3VyY2VvcGVuIGV2ZW50XG4gICAgICBtZWRpYVNvdXJjZS5yZW1vdmVFdmVudExpc3RlbmVyKCdzb3VyY2VvcGVuJywgdGhpcy5vbm1zbyk7XG4gICAgfVxuICAgIHRoaXMuY2hlY2tQZW5kaW5nVHJhY2tzKCk7XG4gIH1cblxuICBjaGVja1BlbmRpbmdUcmFja3MoKSB7XG4gICAgLy8gaWYgYW55IGJ1ZmZlciBjb2RlY3MgcGVuZGluZywgY2hlY2sgaWYgd2UgaGF2ZSBlbm91Z2ggdG8gY3JlYXRlIHNvdXJjZUJ1ZmZlcnNcbiAgICBsZXQgcGVuZGluZ1RyYWNrcyA9IHRoaXMucGVuZGluZ1RyYWNrcyxcbiAgICAgICAgcGVuZGluZ1RyYWNrc05iID0gT2JqZWN0LmtleXMocGVuZGluZ1RyYWNrcykubGVuZ3RoO1xuICAgIC8vIGlmIGFueSBwZW5kaW5nIHRyYWNrcyBhbmQgKGlmIG5iIG9mIHBlbmRpbmcgdHJhY2tzIGd0IG9yIGVxdWFsIHRoYW4gZXhwZWN0ZWQgbmIgb3IgaWYgdW5rbm93biBleHBlY3RlZCBuYilcbiAgICBpZiAocGVuZGluZ1RyYWNrc05iICYmIChcbiAgICAgICAgdGhpcy5zb3VyY2VCdWZmZXJOYiA8PSBwZW5kaW5nVHJhY2tzTmIgfHxcbiAgICAgICAgdGhpcy5zb3VyY2VCdWZmZXJOYiA9PT0gMCkpIHtcbiAgICAgIC8vIG9rLCBsZXQncyBjcmVhdGUgdGhlbSBub3cgIVxuICAgICAgdGhpcy5jcmVhdGVTb3VyY2VCdWZmZXJzKHBlbmRpbmdUcmFja3MpO1xuICAgICAgdGhpcy5wZW5kaW5nVHJhY2tzID0ge307XG4gICAgICAvLyBhcHBlbmQgYW55IHBlbmRpbmcgc2VnbWVudHMgbm93ICFcbiAgICAgIHRoaXMuZG9BcHBlbmRpbmcoKTtcbiAgICB9XG4gIH1cblxuICBvbk1lZGlhU291cmNlQ2xvc2UoKSB7XG4gICAgbG9nZ2VyLmxvZygnbWVkaWEgc291cmNlIGNsb3NlZCcpO1xuICB9XG5cbiAgb25NZWRpYVNvdXJjZUVuZGVkKCkge1xuICAgIGxvZ2dlci5sb2coJ21lZGlhIHNvdXJjZSBlbmRlZCcpO1xuICB9XG5cblxuICBvblNCVXBkYXRlRW5kKCkge1xuICAgIC8vIHVwZGF0ZSB0aW1lc3RhbXBPZmZzZXRcbiAgICBpZiAodGhpcy5hdWRpb1RpbWVzdGFtcE9mZnNldCkge1xuICAgICAgbGV0IGF1ZGlvQnVmZmVyID0gdGhpcy5zb3VyY2VCdWZmZXIuYXVkaW87XG4gICAgICBsb2dnZXIud2FybignY2hhbmdlIG1wZWcgYXVkaW8gdGltZXN0YW1wIG9mZnNldCBmcm9tICcgKyBhdWRpb0J1ZmZlci50aW1lc3RhbXBPZmZzZXQgKyAnIHRvICcgKyB0aGlzLmF1ZGlvVGltZXN0YW1wT2Zmc2V0KTtcbiAgICAgIGF1ZGlvQnVmZmVyLnRpbWVzdGFtcE9mZnNldCA9IHRoaXMuYXVkaW9UaW1lc3RhbXBPZmZzZXQ7XG4gICAgICBkZWxldGUgdGhpcy5hdWRpb1RpbWVzdGFtcE9mZnNldDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fbmVlZHNGbHVzaCkge1xuICAgICAgdGhpcy5kb0ZsdXNoKCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX25lZWRzRW9zKSB7XG4gICAgICB0aGlzLmNoZWNrRW9zKCk7XG4gICAgfVxuICAgIHRoaXMuYXBwZW5kaW5nID0gZmFsc2U7XG4gICAgbGV0IHBhcmVudCA9IHRoaXMucGFyZW50O1xuICAgIC8vIGNvdW50IG5iIG9mIHBlbmRpbmcgc2VnbWVudHMgd2FpdGluZyBmb3IgYXBwZW5kaW5nIG9uIHRoaXMgc291cmNlYnVmZmVyXG4gICAgbGV0IHBlbmRpbmcgPSB0aGlzLnNlZ21lbnRzLnJlZHVjZSggKGNvdW50ZXIsIHNlZ21lbnQpID0+IChzZWdtZW50LnBhcmVudCA9PT0gcGFyZW50KSA/IGNvdW50ZXIgKyAxIDogY291bnRlciAsIDApO1xuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuQlVGRkVSX0FQUEVOREVELCB7IHBhcmVudCA6IHBhcmVudCwgcGVuZGluZyA6IHBlbmRpbmcgfSk7XG5cbiAgICAvLyBkb24ndCBhcHBlbmQgaW4gZmx1c2hpbmcgbW9kZVxuICAgIGlmICghdGhpcy5fbmVlZHNGbHVzaCkge1xuICAgICAgdGhpcy5kb0FwcGVuZGluZygpO1xuICAgIH1cblxuICAgIHRoaXMudXBkYXRlTWVkaWFFbGVtZW50RHVyYXRpb24oKTtcbiAgfVxuXG4gIG9uU0JVcGRhdGVFcnJvcihldmVudCkge1xuICAgIGxvZ2dlci5lcnJvcignc291cmNlQnVmZmVyIGVycm9yOicsIGV2ZW50KTtcbiAgICAvLyBhY2NvcmRpbmcgdG8gaHR0cDovL3d3dy53My5vcmcvVFIvbWVkaWEtc291cmNlLyNzb3VyY2VidWZmZXItYXBwZW5kLWVycm9yXG4gICAgLy8gdGhpcyBlcnJvciBtaWdodCBub3QgYWx3YXlzIGJlIGZhdGFsIChpdCBpcyBmYXRhbCBpZiBkZWNvZGUgZXJyb3IgaXMgc2V0LCBpbiB0aGF0IGNhc2VcbiAgICAvLyBpdCB3aWxsIGJlIGZvbGxvd2VkIGJ5IGEgbWVkaWFFbGVtZW50IGVycm9yIC4uLilcbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkVSUk9SLCB7dHlwZTogRXJyb3JUeXBlcy5NRURJQV9FUlJPUiwgZGV0YWlsczogRXJyb3JEZXRhaWxzLkJVRkZFUl9BUFBFTkRJTkdfRVJST1IsIGZhdGFsOiBmYWxzZX0pO1xuICAgIC8vIHdlIGRvbid0IG5lZWQgdG8gZG8gbW9yZSB0aGFuIHRoYXQsIGFzIGFjY29yZGluIHRvIHRoZSBzcGVjLCB1cGRhdGVlbmQgd2lsbCBiZSBmaXJlZCBqdXN0IGFmdGVyXG4gIH1cblxuICBvbkJ1ZmZlclJlc2V0KCkge1xuICAgIHZhciBzb3VyY2VCdWZmZXIgPSB0aGlzLnNvdXJjZUJ1ZmZlcjtcbiAgICBmb3IodmFyIHR5cGUgaW4gc291cmNlQnVmZmVyKSB7XG4gICAgICB2YXIgc2IgPSBzb3VyY2VCdWZmZXJbdHlwZV07XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLm1lZGlhU291cmNlLnJlbW92ZVNvdXJjZUJ1ZmZlcihzYik7XG4gICAgICAgIHNiLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3VwZGF0ZWVuZCcsIHRoaXMub25zYnVlKTtcbiAgICAgICAgc2IucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCB0aGlzLm9uc2JlKTtcbiAgICAgIH0gY2F0Y2goZXJyKSB7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuc291cmNlQnVmZmVyID0ge307XG4gICAgdGhpcy5mbHVzaFJhbmdlID0gW107XG4gICAgdGhpcy5zZWdtZW50cyA9IFtdO1xuICAgIHRoaXMuYXBwZW5kZWQgPSAwO1xuICB9XG5cbiAgb25CdWZmZXJDb2RlY3ModHJhY2tzKSB7XG4gICAgLy8gaWYgc291cmNlIGJ1ZmZlcihzKSBub3QgY3JlYXRlZCB5ZXQsIGFwcGVuZGVkIGJ1ZmZlciB0cmFja3MgaW4gdGhpcy5wZW5kaW5nVHJhY2tzXG4gICAgLy8gaWYgc291cmNlYnVmZmVycyBhbHJlYWR5IGNyZWF0ZWQsIGRvIG5vdGhpbmcgLi4uXG4gICAgaWYgKE9iamVjdC5rZXlzKHRoaXMuc291cmNlQnVmZmVyKS5sZW5ndGggPT09IDApIHtcbiAgICAgIGZvciAodmFyIHRyYWNrTmFtZSBpbiB0cmFja3MpIHsgdGhpcy5wZW5kaW5nVHJhY2tzW3RyYWNrTmFtZV0gPSB0cmFja3NbdHJhY2tOYW1lXTsgfVxuICAgICAgbGV0IG1lZGlhU291cmNlID0gdGhpcy5tZWRpYVNvdXJjZTtcbiAgICAgIGlmIChtZWRpYVNvdXJjZSAmJiBtZWRpYVNvdXJjZS5yZWFkeVN0YXRlID09PSAnb3BlbicpIHtcbiAgICAgICAgLy8gdHJ5IHRvIGNyZWF0ZSBzb3VyY2VidWZmZXJzIGlmIG1lZGlhc291cmNlIG9wZW5lZFxuICAgICAgICB0aGlzLmNoZWNrUGVuZGluZ1RyYWNrcygpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG5cbiAgY3JlYXRlU291cmNlQnVmZmVycyh0cmFja3MpIHtcbiAgICB2YXIgc291cmNlQnVmZmVyID0gdGhpcy5zb3VyY2VCdWZmZXIsbWVkaWFTb3VyY2UgPSB0aGlzLm1lZGlhU291cmNlO1xuXG4gICAgZm9yIChsZXQgdHJhY2tOYW1lIGluIHRyYWNrcykge1xuICAgICAgaWYoIXNvdXJjZUJ1ZmZlclt0cmFja05hbWVdKSB7XG4gICAgICAgIGxldCB0cmFjayA9IHRyYWNrc1t0cmFja05hbWVdO1xuICAgICAgICAvLyB1c2UgbGV2ZWxDb2RlYyBhcyBmaXJzdCBwcmlvcml0eVxuICAgICAgICBsZXQgY29kZWMgPSB0cmFjay5sZXZlbENvZGVjIHx8IHRyYWNrLmNvZGVjO1xuICAgICAgICBsZXQgbWltZVR5cGUgPSBgJHt0cmFjay5jb250YWluZXJ9O2NvZGVjcz0ke2NvZGVjfWA7XG4gICAgICAgIGxvZ2dlci5sb2coYGNyZWF0aW5nIHNvdXJjZUJ1ZmZlcigke21pbWVUeXBlfSlgKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBsZXQgc2IgPSBzb3VyY2VCdWZmZXJbdHJhY2tOYW1lXSA9IG1lZGlhU291cmNlLmFkZFNvdXJjZUJ1ZmZlcihtaW1lVHlwZSk7XG4gICAgICAgICAgc2IuYWRkRXZlbnRMaXN0ZW5lcigndXBkYXRlZW5kJywgdGhpcy5vbnNidWUpO1xuICAgICAgICAgIHNiLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgdGhpcy5vbnNiZSk7XG4gICAgICAgICAgdGhpcy50cmFja3NbdHJhY2tOYW1lXSA9IHtjb2RlYzogY29kZWMsIGNvbnRhaW5lcjogdHJhY2suY29udGFpbmVyfTtcbiAgICAgICAgICB0cmFjay5idWZmZXIgPSBzYjtcbiAgICAgICAgfSBjYXRjaChlcnIpIHtcbiAgICAgICAgICBsb2dnZXIuZXJyb3IoYGVycm9yIHdoaWxlIHRyeWluZyB0byBhZGQgc291cmNlQnVmZmVyOiR7ZXJyLm1lc3NhZ2V9YCk7XG4gICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5FUlJPUiwge3R5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsIGRldGFpbHM6IEVycm9yRGV0YWlscy5CVUZGRVJfQUREX0NPREVDX0VSUk9SLCBmYXRhbDogZmFsc2UsIGVycjogZXJyLCBtaW1lVHlwZSA6IG1pbWVUeXBlfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5CVUZGRVJfQ1JFQVRFRCwgeyB0cmFja3MgOiB0cmFja3MgfSApO1xuICB9XG5cbiAgb25CdWZmZXJBcHBlbmRpbmcoZGF0YSkge1xuICAgIGlmICghdGhpcy5fbmVlZHNGbHVzaCkge1xuICAgICAgaWYgKCF0aGlzLnNlZ21lbnRzKSB7XG4gICAgICAgIHRoaXMuc2VnbWVudHMgPSBbIGRhdGEgXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2VnbWVudHMucHVzaChkYXRhKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZG9BcHBlbmRpbmcoKTtcbiAgICB9XG4gIH1cblxuICBvbkJ1ZmZlckFwcGVuZEZhaWwoZGF0YSkge1xuICAgIGxvZ2dlci5lcnJvcignc291cmNlQnVmZmVyIGVycm9yOicsZGF0YS5ldmVudCk7XG4gICAgLy8gYWNjb3JkaW5nIHRvIGh0dHA6Ly93d3cudzMub3JnL1RSL21lZGlhLXNvdXJjZS8jc291cmNlYnVmZmVyLWFwcGVuZC1lcnJvclxuICAgIC8vIHRoaXMgZXJyb3IgbWlnaHQgbm90IGFsd2F5cyBiZSBmYXRhbCAoaXQgaXMgZmF0YWwgaWYgZGVjb2RlIGVycm9yIGlzIHNldCwgaW4gdGhhdCBjYXNlXG4gICAgLy8gaXQgd2lsbCBiZSBmb2xsb3dlZCBieSBhIG1lZGlhRWxlbWVudCBlcnJvciAuLi4pXG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5FUlJPUiwge3R5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsIGRldGFpbHM6IEVycm9yRGV0YWlscy5CVUZGRVJfQVBQRU5ESU5HX0VSUk9SLCBmYXRhbDogZmFsc2V9KTtcbiAgfVxuXG4gIC8vIG9uIEJVRkZFUl9FT1MgbWFyayBtYXRjaGluZyBzb3VyY2VidWZmZXIocykgYXMgZW5kZWQgYW5kIHRyaWdnZXIgY2hlY2tFb3MoKVxuICBvbkJ1ZmZlckVvcyhkYXRhKSB7XG4gICAgdmFyIHNiID0gdGhpcy5zb3VyY2VCdWZmZXI7XG4gICAgbGV0IGRhdGFUeXBlID0gZGF0YS50eXBlO1xuICAgIGZvcihsZXQgdHlwZSBpbiBzYikge1xuICAgICAgaWYgKCFkYXRhVHlwZSB8fCB0eXBlID09PSBkYXRhVHlwZSkge1xuICAgICAgICBpZiAoIXNiW3R5cGVdLmVuZGVkKSB7XG4gICAgICAgICAgc2JbdHlwZV0uZW5kZWQgPSB0cnVlO1xuICAgICAgICAgIGxvZ2dlci5sb2coYCR7dHlwZX0gc291cmNlQnVmZmVyIG5vdyBFT1NgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmNoZWNrRW9zKCk7XG4gIH1cblxuIC8vIGlmIGFsbCBzb3VyY2UgYnVmZmVycyBhcmUgbWFya2VkIGFzIGVuZGVkLCBzaWduYWwgZW5kT2ZTdHJlYW0oKSB0byBNZWRpYVNvdXJjZS5cbiBjaGVja0VvcygpIHtcbiAgICB2YXIgc2IgPSB0aGlzLnNvdXJjZUJ1ZmZlciwgbWVkaWFTb3VyY2UgPSB0aGlzLm1lZGlhU291cmNlO1xuICAgIGlmICghbWVkaWFTb3VyY2UgfHwgbWVkaWFTb3VyY2UucmVhZHlTdGF0ZSAhPT0gJ29wZW4nKSB7XG4gICAgICB0aGlzLl9uZWVkc0VvcyA9IGZhbHNlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IobGV0IHR5cGUgaW4gc2IpIHtcbiAgICAgIGxldCBzYm9iaiA9IHNiW3R5cGVdO1xuICAgICAgaWYgKCFzYm9iai5lbmRlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZihzYm9iai51cGRhdGluZykge1xuICAgICAgICB0aGlzLl9uZWVkc0VvcyA9IHRydWU7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgbG9nZ2VyLmxvZygnYWxsIG1lZGlhIGRhdGEgYXZhaWxhYmxlLCBzaWduYWwgZW5kT2ZTdHJlYW0oKSB0byBNZWRpYVNvdXJjZSBhbmQgc3RvcCBsb2FkaW5nIGZyYWdtZW50Jyk7XG4gICAgLy9Ob3RpZnkgdGhlIG1lZGlhIGVsZW1lbnQgdGhhdCBpdCBub3cgaGFzIGFsbCBvZiB0aGUgbWVkaWEgZGF0YVxuICAgIHRyeSB7XG4gICAgICBtZWRpYVNvdXJjZS5lbmRPZlN0cmVhbSgpO1xuICAgIH0gY2F0Y2goZSkge1xuICAgICAgbG9nZ2VyLndhcm4oJ2V4Y2VwdGlvbiB3aGlsZSBjYWxsaW5nIG1lZGlhU291cmNlLmVuZE9mU3RyZWFtKCknKTtcbiAgICB9XG4gICAgdGhpcy5fbmVlZHNFb3MgPSBmYWxzZTtcbiB9XG5cblxuICBvbkJ1ZmZlckZsdXNoaW5nKGRhdGEpIHtcbiAgICB0aGlzLmZsdXNoUmFuZ2UucHVzaCh7c3RhcnQ6IGRhdGEuc3RhcnRPZmZzZXQsIGVuZDogZGF0YS5lbmRPZmZzZXQsIHR5cGUgOiBkYXRhLnR5cGV9KTtcbiAgICAvLyBhdHRlbXB0IGZsdXNoIGltbWVkaWF0bHlcbiAgICB0aGlzLmZsdXNoQnVmZmVyQ291bnRlciA9IDA7XG4gICAgdGhpcy5kb0ZsdXNoKCk7XG4gIH1cblxuICBvbkxldmVsVXBkYXRlZChldmVudCkge1xuICAgIGxldCBkZXRhaWxzID0gZXZlbnQuZGV0YWlscztcbiAgICBpZiAoZGV0YWlscy5mcmFnbWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2xldmVsRHVyYXRpb24gPSBkZXRhaWxzLnRvdGFsZHVyYXRpb24gKyBkZXRhaWxzLmZyYWdtZW50c1swXS5zdGFydDtcbiAgICB0aGlzLnVwZGF0ZU1lZGlhRWxlbWVudER1cmF0aW9uKCk7XG4gIH1cblxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vdmlkZW8tZGV2L2hscy5qcy9pc3N1ZXMvMzU1XG4gIHVwZGF0ZU1lZGlhRWxlbWVudER1cmF0aW9uKCkge1xuICAgIGxldCBtZWRpYSA9IHRoaXMubWVkaWEsXG4gICAgICAgIG1lZGlhU291cmNlID0gdGhpcy5tZWRpYVNvdXJjZSxcbiAgICAgICAgc291cmNlQnVmZmVyID0gdGhpcy5zb3VyY2VCdWZmZXIsXG4gICAgICAgIGxldmVsRHVyYXRpb24gPSB0aGlzLl9sZXZlbER1cmF0aW9uO1xuICAgIGlmIChsZXZlbER1cmF0aW9uID09PSBudWxsIHx8ICFtZWRpYSB8fCAhbWVkaWFTb3VyY2UgfHwgIXNvdXJjZUJ1ZmZlciB8fCBtZWRpYS5yZWFkeVN0YXRlID09PSAwIHx8IG1lZGlhU291cmNlLnJlYWR5U3RhdGUgIT09ICdvcGVuJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGxldCB0eXBlIGluIHNvdXJjZUJ1ZmZlcikge1xuICAgICAgaWYgKHNvdXJjZUJ1ZmZlclt0eXBlXS51cGRhdGluZykge1xuICAgICAgICAvLyBjYW4ndCBzZXQgZHVyYXRpb24gd2hpbHN0IGEgYnVmZmVyIGlzIHVwZGF0aW5nXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMuX21zRHVyYXRpb24gPT09IG51bGwpIHtcbiAgICAgIC8vIGluaXRpYWxpc2UgdG8gdGhlIHZhbHVlIHRoYXQgdGhlIG1lZGlhIHNvdXJjZSBpcyByZXBvcnRpbmdcbiAgICAgIHRoaXMuX21zRHVyYXRpb24gPSBtZWRpYVNvdXJjZS5kdXJhdGlvbjtcbiAgICB9XG4gICAgbGV0IGR1cmF0aW9uID0gbWVkaWEuZHVyYXRpb247XG4gICAgLy8gbGV2ZWxEdXJhdGlvbiB3YXMgdGhlIGxhc3QgdmFsdWUgd2Ugc2V0LlxuICAgIC8vIG5vdCB1c2luZyBtZWRpYVNvdXJjZS5kdXJhdGlvbiBhcyB0aGUgYnJvd3NlciBtYXkgdHdlYWsgdGhpcyB2YWx1ZVxuICAgIC8vIG9ubHkgdXBkYXRlIG1lZGlhc291cmNlIGR1cmF0aW9uIGlmIGl0cyB2YWx1ZSBpbmNyZWFzZSwgdGhpcyBpcyB0byBhdm9pZFxuICAgIC8vIGZsdXNoaW5nIGFscmVhZHkgYnVmZmVyZWQgcG9ydGlvbiB3aGVuIHN3aXRjaGluZyBiZXR3ZWVuIHF1YWxpdHkgbGV2ZWxcbiAgICBpZiAoKGxldmVsRHVyYXRpb24gPiB0aGlzLl9tc0R1cmF0aW9uICYmIGxldmVsRHVyYXRpb24gPiBkdXJhdGlvbikgfHwgKGR1cmF0aW9uID09PSBJbmZpbml0eSB8fCBpc05hTihkdXJhdGlvbikgKSkge1xuICAgICAgbG9nZ2VyLmxvZyhgVXBkYXRpbmcgbWVkaWFzb3VyY2UgZHVyYXRpb24gdG8gJHtsZXZlbER1cmF0aW9uLnRvRml4ZWQoMyl9YCk7XG4gICAgICB0aGlzLl9tc0R1cmF0aW9uID0gbWVkaWFTb3VyY2UuZHVyYXRpb24gPSBsZXZlbER1cmF0aW9uO1xuICAgIH1cbiAgfVxuXG4gIGRvRmx1c2goKSB7XG4gICAgLy8gbG9vcCB0aHJvdWdoIGFsbCBidWZmZXIgcmFuZ2VzIHRvIGZsdXNoXG4gICAgd2hpbGUodGhpcy5mbHVzaFJhbmdlLmxlbmd0aCkge1xuICAgICAgdmFyIHJhbmdlID0gdGhpcy5mbHVzaFJhbmdlWzBdO1xuICAgICAgLy8gZmx1c2hCdWZmZXIgd2lsbCBhYm9ydCBhbnkgYnVmZmVyIGFwcGVuZCBpbiBwcm9ncmVzcyBhbmQgZmx1c2ggQXVkaW8vVmlkZW8gQnVmZmVyXG4gICAgICBpZiAodGhpcy5mbHVzaEJ1ZmZlcihyYW5nZS5zdGFydCwgcmFuZ2UuZW5kLCByYW5nZS50eXBlKSkge1xuICAgICAgICAvLyByYW5nZSBmbHVzaGVkLCByZW1vdmUgZnJvbSBmbHVzaCBhcnJheVxuICAgICAgICB0aGlzLmZsdXNoUmFuZ2Uuc2hpZnQoKTtcbiAgICAgICAgdGhpcy5mbHVzaEJ1ZmZlckNvdW50ZXIgPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fbmVlZHNGbHVzaCA9IHRydWU7XG4gICAgICAgIC8vIGF2b2lkIGxvb3BpbmcsIHdhaXQgZm9yIFNCIHVwZGF0ZSBlbmQgdG8gcmV0cmlnZ2VyIGEgZmx1c2hcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5mbHVzaFJhbmdlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgLy8gZXZlcnl0aGluZyBmbHVzaGVkXG4gICAgICB0aGlzLl9uZWVkc0ZsdXNoID0gZmFsc2U7XG5cbiAgICAgIC8vIGxldCdzIHJlY29tcHV0ZSB0aGlzLmFwcGVuZGVkLCB3aGljaCBpcyB1c2VkIHRvIGF2b2lkIGZsdXNoIGxvb3BpbmdcbiAgICAgIHZhciBhcHBlbmRlZCA9IDA7XG4gICAgICB2YXIgc291cmNlQnVmZmVyID0gdGhpcy5zb3VyY2VCdWZmZXI7XG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKHZhciB0eXBlIGluIHNvdXJjZUJ1ZmZlcikge1xuICAgICAgICAgIGFwcGVuZGVkICs9IHNvdXJjZUJ1ZmZlclt0eXBlXS5idWZmZXJlZC5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2goZXJyb3IpIHtcbiAgICAgICAgLy8gZXJyb3IgY291bGQgYmUgdGhyb3duIHdoaWxlIGFjY2Vzc2luZyBidWZmZXJlZCwgaW4gY2FzZSBzb3VyY2VidWZmZXIgaGFzIGFscmVhZHkgYmVlbiByZW1vdmVkIGZyb20gTWVkaWFTb3VyY2VcbiAgICAgICAgLy8gdGhpcyBpcyBoYXJtZXNzIGF0IHRoaXMgc3RhZ2UsIGNhdGNoIHRoaXMgdG8gYXZvaWQgcmVwb3J0aW5nIGFuIGludGVybmFsIGV4Y2VwdGlvblxuICAgICAgICBsb2dnZXIuZXJyb3IoJ2Vycm9yIHdoaWxlIGFjY2Vzc2luZyBzb3VyY2VCdWZmZXIuYnVmZmVyZWQnKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYXBwZW5kZWQgPSBhcHBlbmRlZDtcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuQlVGRkVSX0ZMVVNIRUQpO1xuICAgIH1cbiAgfVxuXG4gIGRvQXBwZW5kaW5nKCkge1xuICAgIHZhciBobHMgPSB0aGlzLmhscywgc291cmNlQnVmZmVyID0gdGhpcy5zb3VyY2VCdWZmZXIsIHNlZ21lbnRzID0gdGhpcy5zZWdtZW50cztcbiAgICBpZiAoT2JqZWN0LmtleXMoc291cmNlQnVmZmVyKS5sZW5ndGgpIHtcbiAgICAgIGlmICh0aGlzLm1lZGlhLmVycm9yKSB7XG4gICAgICAgIHRoaXMuc2VnbWVudHMgPSBbXTtcbiAgICAgICAgbG9nZ2VyLmVycm9yKCd0cnlpbmcgdG8gYXBwZW5kIGFsdGhvdWdoIGEgbWVkaWEgZXJyb3Igb2NjdXJlZCwgZmx1c2ggc2VnbWVudCBhbmQgYWJvcnQnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuYXBwZW5kaW5nKSB7XG4gICAgICAgIC8vbG9nZ2VyLmxvZyhgc2IgYXBwZW5kaW5nIGluIHByb2dyZXNzYCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChzZWdtZW50cyAmJiBzZWdtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgbGV0IHNlZ21lbnQgPSBzZWdtZW50cy5zaGlmdCgpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGxldCB0eXBlID0gc2VnbWVudC50eXBlLCBzYiA9IHNvdXJjZUJ1ZmZlclt0eXBlXTtcbiAgICAgICAgICBpZihzYikge1xuICAgICAgICAgICAgaWYoIXNiLnVwZGF0aW5nKSB7XG4gICAgICAgICAgICAgIC8vIHJlc2V0IHNvdXJjZUJ1ZmZlciBlbmRlZCBmbGFnIGJlZm9yZSBhcHBlbmRpbmcgc2VnbWVudFxuICAgICAgICAgICAgICBzYi5lbmRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAvL2xvZ2dlci5sb2coYGFwcGVuZGluZyAke3NlZ21lbnQuY29udGVudH0gJHt0eXBlfSBTQiwgc2l6ZToke3NlZ21lbnQuZGF0YS5sZW5ndGh9LCAke3NlZ21lbnQucGFyZW50fWApO1xuICAgICAgICAgICAgICB0aGlzLnBhcmVudCA9IHNlZ21lbnQucGFyZW50O1xuICAgICAgICAgICAgICBzYi5hcHBlbmRCdWZmZXIoc2VnbWVudC5kYXRhKTtcbiAgICAgICAgICAgICAgdGhpcy5hcHBlbmRFcnJvciA9IDA7XG4gICAgICAgICAgICAgIHRoaXMuYXBwZW5kZWQrKztcbiAgICAgICAgICAgICAgdGhpcy5hcHBlbmRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc2VnbWVudHMudW5zaGlmdChzZWdtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gaW4gY2FzZSB3ZSBkb24ndCBoYXZlIGFueSBzb3VyY2UgYnVmZmVyIG1hdGNoaW5nIHdpdGggdGhpcyBzZWdtZW50IHR5cGUsXG4gICAgICAgICAgICAvLyBpdCBtZWFucyB0aGF0IE1lZGlhc291cmNlIGZhaWxzIHRvIGNyZWF0ZSBzb3VyY2VidWZmZXJcbiAgICAgICAgICAgIC8vIGRpc2NhcmQgdGhpcyBzZWdtZW50LCBhbmQgdHJpZ2dlciB1cGRhdGUgZW5kXG4gICAgICAgICAgICB0aGlzLm9uU0JVcGRhdGVFbmQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2goZXJyKSB7XG4gICAgICAgICAgLy8gaW4gY2FzZSBhbnkgZXJyb3Igb2NjdXJlZCB3aGlsZSBhcHBlbmRpbmcsIHB1dCBiYWNrIHNlZ21lbnQgaW4gc2VnbWVudHMgdGFibGVcbiAgICAgICAgICBsb2dnZXIuZXJyb3IoYGVycm9yIHdoaWxlIHRyeWluZyB0byBhcHBlbmQgYnVmZmVyOiR7ZXJyLm1lc3NhZ2V9YCk7XG4gICAgICAgICAgc2VnbWVudHMudW5zaGlmdChzZWdtZW50KTtcbiAgICAgICAgICB2YXIgZXZlbnQgPSB7dHlwZTogRXJyb3JUeXBlcy5NRURJQV9FUlJPUiwgcGFyZW50IDogc2VnbWVudC5wYXJlbnR9O1xuICAgICAgICAgIGlmKGVyci5jb2RlICE9PSAyMikge1xuICAgICAgICAgICAgaWYgKHRoaXMuYXBwZW5kRXJyb3IpIHtcbiAgICAgICAgICAgICAgdGhpcy5hcHBlbmRFcnJvcisrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5hcHBlbmRFcnJvciA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBldmVudC5kZXRhaWxzID0gRXJyb3JEZXRhaWxzLkJVRkZFUl9BUFBFTkRfRVJST1I7XG4gICAgICAgICAgICAvKiB3aXRoIFVIRCBjb250ZW50LCB3ZSBjb3VsZCBnZXQgbG9vcCBvZiBxdW90YSBleGNlZWRlZCBlcnJvciB1bnRpbFxuICAgICAgICAgICAgICBicm93c2VyIGlzIGFibGUgdG8gZXZpY3Qgc29tZSBkYXRhIGZyb20gc291cmNlYnVmZmVyLiByZXRyeWluZyBoZWxwIHJlY292ZXJpbmcgdGhpc1xuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmICh0aGlzLmFwcGVuZEVycm9yID4gaGxzLmNvbmZpZy5hcHBlbmRFcnJvck1heFJldHJ5KSB7XG4gICAgICAgICAgICAgIGxvZ2dlci5sb2coYGZhaWwgJHtobHMuY29uZmlnLmFwcGVuZEVycm9yTWF4UmV0cnl9IHRpbWVzIHRvIGFwcGVuZCBzZWdtZW50IGluIHNvdXJjZUJ1ZmZlcmApO1xuICAgICAgICAgICAgICBzZWdtZW50cyA9IFtdO1xuICAgICAgICAgICAgICBldmVudC5mYXRhbCA9IHRydWU7XG4gICAgICAgICAgICAgIGhscy50cmlnZ2VyKEV2ZW50LkVSUk9SLCBldmVudCk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGV2ZW50LmZhdGFsID0gZmFsc2U7XG4gICAgICAgICAgICAgIGhscy50cmlnZ2VyKEV2ZW50LkVSUk9SLCBldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFF1b3RhRXhjZWVkZWRFcnJvcjogaHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvaW5mcmFzdHJ1Y3R1cmUuaHRtbCNxdW90YWV4Y2VlZGVkZXJyb3JcbiAgICAgICAgICAgIC8vIGxldCdzIHN0b3AgYXBwZW5kaW5nIGFueSBzZWdtZW50cywgYW5kIHJlcG9ydCBCVUZGRVJfRlVMTF9FUlJPUiBlcnJvclxuICAgICAgICAgICAgdGhpcy5zZWdtZW50cyA9IFtdO1xuICAgICAgICAgICAgZXZlbnQuZGV0YWlscyA9IEVycm9yRGV0YWlscy5CVUZGRVJfRlVMTF9FUlJPUjtcbiAgICAgICAgICAgIGV2ZW50LmZhdGFsID0gZmFsc2U7XG4gICAgICAgICAgICBobHMudHJpZ2dlcihFdmVudC5FUlJPUixldmVudCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLypcbiAgICBmbHVzaCBzcGVjaWZpZWQgYnVmZmVyZWQgcmFuZ2UsXG4gICAgcmV0dXJuIHRydWUgb25jZSByYW5nZSBoYXMgYmVlbiBmbHVzaGVkLlxuICAgIGFzIHNvdXJjZUJ1ZmZlci5yZW1vdmUoKSBpcyBhc3luY2hyb25vdXMsIGZsdXNoQnVmZmVyIHdpbGwgYmUgcmV0cmlnZ2VyZWQgb24gc291cmNlQnVmZmVyIHVwZGF0ZSBlbmRcbiAgKi9cbiAgZmx1c2hCdWZmZXIoc3RhcnRPZmZzZXQsIGVuZE9mZnNldCwgdHlwZUluKSB7XG4gICAgdmFyIHNiLCBpLCBidWZTdGFydCwgYnVmRW5kLCBmbHVzaFN0YXJ0LCBmbHVzaEVuZCwgc291cmNlQnVmZmVyID0gdGhpcy5zb3VyY2VCdWZmZXI7XG4gICAgaWYgKE9iamVjdC5rZXlzKHNvdXJjZUJ1ZmZlcikubGVuZ3RoKSB7XG4gICAgICBsb2dnZXIubG9nKGBmbHVzaEJ1ZmZlcixwb3Mvc3RhcnQvZW5kOiAke3RoaXMubWVkaWEuY3VycmVudFRpbWUudG9GaXhlZCgzKX0vJHtzdGFydE9mZnNldH0vJHtlbmRPZmZzZXR9YCk7XG4gICAgICAvLyBzYWZlZ3VhcmQgdG8gYXZvaWQgaW5maW5pdGUgbG9vcGluZyA6IGRvbid0IHRyeSB0byBmbHVzaCBtb3JlIHRoYW4gdGhlIG5iIG9mIGFwcGVuZGVkIHNlZ21lbnRzXG4gICAgICBpZiAodGhpcy5mbHVzaEJ1ZmZlckNvdW50ZXIgPCB0aGlzLmFwcGVuZGVkKSB7XG4gICAgICAgIGZvciAodmFyIHR5cGUgaW4gc291cmNlQnVmZmVyKSB7XG4gICAgICAgICAgLy8gY2hlY2sgaWYgc291cmNlYnVmZmVyIHR5cGUgaXMgZGVmaW5lZCAodHlwZUluKTogaWYgeWVzLCBsZXQncyBvbmx5IGZsdXNoIHRoaXMgb25lXG4gICAgICAgICAgLy8gaWYgbm8sIGxldCdzIGZsdXNoIGFsbCBzb3VyY2VidWZmZXJzXG4gICAgICAgICAgaWYgKHR5cGVJbiAmJiB0eXBlICE9PSB0eXBlSW4pIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzYiA9IHNvdXJjZUJ1ZmZlclt0eXBlXTtcbiAgICAgICAgICAvLyB3ZSBhcmUgZ29pbmcgdG8gZmx1c2ggYnVmZmVyLCBtYXJrIHNvdXJjZSBidWZmZXIgYXMgJ25vdCBlbmRlZCdcbiAgICAgICAgICBzYi5lbmRlZCA9IGZhbHNlO1xuICAgICAgICAgIGlmICghc2IudXBkYXRpbmcpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBzYi5idWZmZXJlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGJ1ZlN0YXJ0ID0gc2IuYnVmZmVyZWQuc3RhcnQoaSk7XG4gICAgICAgICAgICAgICAgYnVmRW5kID0gc2IuYnVmZmVyZWQuZW5kKGkpO1xuICAgICAgICAgICAgICAgIC8vIHdvcmthcm91bmQgZmlyZWZveCBub3QgYWJsZSB0byBwcm9wZXJseSBmbHVzaCBtdWx0aXBsZSBidWZmZXJlZCByYW5nZS5cbiAgICAgICAgICAgICAgICBpZiAobmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ2ZpcmVmb3gnKSAhPT0gLTEgJiYgZW5kT2Zmc2V0ID09PSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpIHtcbiAgICAgICAgICAgICAgICAgIGZsdXNoU3RhcnQgPSBzdGFydE9mZnNldDtcbiAgICAgICAgICAgICAgICAgIGZsdXNoRW5kID0gZW5kT2Zmc2V0O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBmbHVzaFN0YXJ0ID0gTWF0aC5tYXgoYnVmU3RhcnQsIHN0YXJ0T2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgIGZsdXNoRW5kID0gTWF0aC5taW4oYnVmRW5kLCBlbmRPZmZzZXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvKiBzb21ldGltZXMgc291cmNlYnVmZmVyLnJlbW92ZSgpIGRvZXMgbm90IGZsdXNoXG4gICAgICAgICAgICAgICAgICAgdGhlIGV4YWN0IGV4cGVjdGVkIHRpbWUgcmFuZ2UuXG4gICAgICAgICAgICAgICAgICAgdG8gYXZvaWQgcm91bmRpbmcgaXNzdWVzL2luZmluaXRlIGxvb3AsXG4gICAgICAgICAgICAgICAgICAgb25seSBmbHVzaCBidWZmZXIgcmFuZ2Ugb2YgbGVuZ3RoIGdyZWF0ZXIgdGhhbiA1MDBtcy5cbiAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGlmIChNYXRoLm1pbihmbHVzaEVuZCxidWZFbmQpIC0gZmx1c2hTdGFydCA+IDAuNSApIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuZmx1c2hCdWZmZXJDb3VudGVyKys7XG4gICAgICAgICAgICAgICAgICBsb2dnZXIubG9nKGBmbHVzaCAke3R5cGV9IFske2ZsdXNoU3RhcnR9LCR7Zmx1c2hFbmR9XSwgb2YgWyR7YnVmU3RhcnR9LCR7YnVmRW5kfV0sIHBvczoke3RoaXMubWVkaWEuY3VycmVudFRpbWV9YCk7XG4gICAgICAgICAgICAgICAgICBzYi5yZW1vdmUoZmx1c2hTdGFydCwgZmx1c2hFbmQpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgICAgICAgIGxvZ2dlci53YXJuKCdleGNlcHRpb24gd2hpbGUgYWNjZXNzaW5nIHNvdXJjZWJ1ZmZlciwgaXQgbWlnaHQgaGF2ZSBiZWVuIHJlbW92ZWQgZnJvbSBNZWRpYVNvdXJjZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvL2xvZ2dlci5sb2coJ2Fib3J0ICcgKyB0eXBlICsgJyBhcHBlbmQgaW4gcHJvZ3Jlc3MnKTtcbiAgICAgICAgICAgIC8vIHRoaXMgd2lsbCBhYm9ydCBhbnkgYXBwZW5kaW5nIGluIHByb2dyZXNzXG4gICAgICAgICAgICAvL3NiLmFib3J0KCk7XG4gICAgICAgICAgICBsb2dnZXIud2FybignY2Fubm90IGZsdXNoLCBzYiB1cGRhdGluZyBpbiBwcm9ncmVzcycpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbG9nZ2VyLndhcm4oJ2Fib3J0IGZsdXNoaW5nIHRvbyBtYW55IHJldHJpZXMnKTtcbiAgICAgIH1cbiAgICAgIGxvZ2dlci5sb2coJ2J1ZmZlciBmbHVzaGVkJyk7XG4gICAgfVxuICAgIC8vIGV2ZXJ5dGhpbmcgZmx1c2hlZCAhXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQnVmZmVyQ29udHJvbGxlcjtcbiIsIi8qXG4gKiBjYXAgc3RyZWFtIGxldmVsIHRvIG1lZGlhIHNpemUgZGltZW5zaW9uIGNvbnRyb2xsZXJcbiovXG5cbmltcG9ydCBFdmVudCBmcm9tICcuLi9ldmVudHMnO1xuaW1wb3J0IEV2ZW50SGFuZGxlciBmcm9tICcuLi9ldmVudC1oYW5kbGVyJztcblxuY2xhc3MgQ2FwTGV2ZWxDb250cm9sbGVyIGV4dGVuZHMgRXZlbnRIYW5kbGVyIHtcblx0Y29uc3RydWN0b3IoaGxzKSB7XG4gICAgc3VwZXIoaGxzLFxuICAgICAgRXZlbnQuRlBTX0RST1BfTEVWRUxfQ0FQUElORyxcbiAgICAgIEV2ZW50Lk1FRElBX0FUVEFDSElORyxcbiAgICAgIEV2ZW50Lk1BTklGRVNUX1BBUlNFRCk7XG5cdH1cblxuXHRkZXN0cm95KCkge1xuICAgIGlmICh0aGlzLmhscy5jb25maWcuY2FwTGV2ZWxUb1BsYXllclNpemUpIHtcbiAgICAgIHRoaXMubWVkaWEgPSB0aGlzLnJlc3RyaWN0ZWRMZXZlbHMgPSBudWxsO1xuICAgICAgdGhpcy5hdXRvTGV2ZWxDYXBwaW5nID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgICAgaWYgKHRoaXMudGltZXIpIHtcbiAgICAgICAgdGhpcy50aW1lciA9IGNsZWFySW50ZXJ2YWwodGhpcy50aW1lcik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgb25GcHNEcm9wTGV2ZWxDYXBwaW5nKGRhdGEpIHtcbiAgICBpZiAoIXRoaXMucmVzdHJpY3RlZExldmVscykge1xuICAgICAgdGhpcy5yZXN0cmljdGVkTGV2ZWxzID0gW107XG4gICAgfVxuICAgIGlmICghdGhpcy5pc0xldmVsUmVzdHJpY3RlZChkYXRhLmRyb3BwZWRMZXZlbCkpIHtcbiAgICAgIHRoaXMucmVzdHJpY3RlZExldmVscy5wdXNoKGRhdGEuZHJvcHBlZExldmVsKTtcbiAgICB9XG4gIH1cblxuXHRvbk1lZGlhQXR0YWNoaW5nKGRhdGEpIHtcbiAgICB0aGlzLm1lZGlhID0gZGF0YS5tZWRpYSBpbnN0YW5jZW9mIEhUTUxWaWRlb0VsZW1lbnQgPyBkYXRhLm1lZGlhIDogbnVsbDtcbiAgfVxuXG4gIG9uTWFuaWZlc3RQYXJzZWQoZGF0YSkge1xuICAgIGNvbnN0IGhscyA9IHRoaXMuaGxzO1xuICAgIGlmIChobHMuY29uZmlnLmNhcExldmVsVG9QbGF5ZXJTaXplKSB7XG4gICAgICB0aGlzLmF1dG9MZXZlbENhcHBpbmcgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgICB0aGlzLmxldmVscyA9IGRhdGEubGV2ZWxzO1xuICAgICAgaGxzLmZpcnN0TGV2ZWwgPSB0aGlzLmdldE1heExldmVsKGRhdGEuZmlyc3RMZXZlbCk7XG4gICAgICBjbGVhckludGVydmFsKHRoaXMudGltZXIpO1xuICAgICAgdGhpcy50aW1lciA9IHNldEludGVydmFsKHRoaXMuZGV0ZWN0UGxheWVyU2l6ZS5iaW5kKHRoaXMpLCAxMDAwKTtcbiAgICAgIHRoaXMuZGV0ZWN0UGxheWVyU2l6ZSgpO1xuICAgIH1cbiAgfVxuXG4gIGRldGVjdFBsYXllclNpemUoKSB7XG4gICAgaWYgKHRoaXMubWVkaWEpIHtcbiAgICAgIGxldCBsZXZlbHNMZW5ndGggPSB0aGlzLmxldmVscyA/IHRoaXMubGV2ZWxzLmxlbmd0aCA6IDA7XG4gICAgICBpZiAobGV2ZWxzTGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IGhscyA9IHRoaXMuaGxzO1xuICAgICAgICBobHMuYXV0b0xldmVsQ2FwcGluZyA9IHRoaXMuZ2V0TWF4TGV2ZWwobGV2ZWxzTGVuZ3RoIC0gMSk7XG4gICAgICAgIGlmIChobHMuYXV0b0xldmVsQ2FwcGluZyA+IHRoaXMuYXV0b0xldmVsQ2FwcGluZykge1xuICAgICAgICAgIC8vIGlmIGF1dG8gbGV2ZWwgY2FwcGluZyBoYXMgYSBoaWdoZXIgdmFsdWUgZm9yIHRoZSBwcmV2aW91cyBvbmUsIGZsdXNoIHRoZSBidWZmZXIgdXNpbmcgbmV4dExldmVsU3dpdGNoXG4gICAgICAgICAgLy8gdXN1YWxseSBoYXBwZW4gd2hlbiB0aGUgdXNlciBnbyB0byB0aGUgZnVsbHNjcmVlbiBtb2RlLlxuICAgICAgICAgIGhscy5zdHJlYW1Db250cm9sbGVyLm5leHRMZXZlbFN3aXRjaCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYXV0b0xldmVsQ2FwcGluZyA9IGhscy5hdXRvTGV2ZWxDYXBwaW5nO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qXG4gICogcmV0dXJucyBsZXZlbCBzaG91bGQgYmUgdGhlIG9uZSB3aXRoIHRoZSBkaW1lbnNpb25zIGVxdWFsIG9yIGdyZWF0ZXIgdGhhbiB0aGUgbWVkaWEgKHBsYXllcikgZGltZW5zaW9ucyAoc28gdGhlIHZpZGVvIHdpbGwgYmUgZG93bnNjYWxlZClcbiAgKi9cbiAgZ2V0TWF4TGV2ZWwoY2FwTGV2ZWxJbmRleCkge1xuICAgIGxldCByZXN1bHQgPSAwLFxuICAgICAgICBpLFxuICAgICAgICBsZXZlbCxcbiAgICAgICAgbVdpZHRoID0gdGhpcy5tZWRpYVdpZHRoLFxuICAgICAgICBtSGVpZ2h0ID0gdGhpcy5tZWRpYUhlaWdodCxcbiAgICAgICAgbFdpZHRoID0gMCxcbiAgICAgICAgbEhlaWdodCA9IDA7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDw9IGNhcExldmVsSW5kZXg7IGkrKykge1xuICAgICAgbGV2ZWwgPSB0aGlzLmxldmVsc1tpXTtcbiAgICAgIGlmICh0aGlzLmlzTGV2ZWxSZXN0cmljdGVkKGkpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgcmVzdWx0ID0gaTtcbiAgICAgIGxXaWR0aCA9IGxldmVsLndpZHRoO1xuICAgICAgbEhlaWdodCA9IGxldmVsLmhlaWdodDtcbiAgICAgIGlmIChtV2lkdGggPD0gbFdpZHRoIHx8IG1IZWlnaHQgPD0gbEhlaWdodCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGlzTGV2ZWxSZXN0cmljdGVkKGxldmVsKSB7XG4gICAgcmV0dXJuICh0aGlzLnJlc3RyaWN0ZWRMZXZlbHMgJiYgdGhpcy5yZXN0cmljdGVkTGV2ZWxzLmluZGV4T2YobGV2ZWwpICE9PSAtMSkgPyB0cnVlIDogZmFsc2U7XG4gIH1cblxuICBnZXQgY29udGVudFNjYWxlRmFjdG9yKCkge1xuICAgIGxldCBwaXhlbFJhdGlvID0gMTtcbiAgICB0cnkge1xuICAgICAgcGl4ZWxSYXRpbyA9ICB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbztcbiAgICB9IGNhdGNoKGUpIHt9XG4gICAgcmV0dXJuIHBpeGVsUmF0aW87XG4gIH1cblxuICBnZXQgbWVkaWFXaWR0aCgpIHtcbiAgICBsZXQgd2lkdGg7XG4gICAgY29uc3QgbWVkaWEgPSB0aGlzLm1lZGlhO1xuICAgIGlmIChtZWRpYSkge1xuICAgICAgd2lkdGggPSBtZWRpYS53aWR0aCB8fCBtZWRpYS5jbGllbnRXaWR0aCB8fCBtZWRpYS5vZmZzZXRXaWR0aDtcbiAgICAgIHdpZHRoICo9IHRoaXMuY29udGVudFNjYWxlRmFjdG9yO1xuICAgIH1cbiAgICByZXR1cm4gd2lkdGg7XG4gIH1cblxuICBnZXQgbWVkaWFIZWlnaHQoKSB7XG4gICAgbGV0IGhlaWdodDtcbiAgICBjb25zdCBtZWRpYSA9IHRoaXMubWVkaWE7XG4gICAgaWYgKG1lZGlhKSB7XG4gICAgICBoZWlnaHQgPSBtZWRpYS5oZWlnaHQgfHwgbWVkaWEuY2xpZW50SGVpZ2h0IHx8IG1lZGlhLm9mZnNldEhlaWdodDtcbiAgICAgIGhlaWdodCAqPSB0aGlzLmNvbnRlbnRTY2FsZUZhY3RvcjtcbiAgICB9XG4gICAgcmV0dXJuIGhlaWdodDtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDYXBMZXZlbENvbnRyb2xsZXI7XG4iLCIvKlxuICogRlBTIENvbnRyb2xsZXJcbiovXG5cbmltcG9ydCBFdmVudCBmcm9tICcuLi9ldmVudHMnO1xuaW1wb3J0IEV2ZW50SGFuZGxlciBmcm9tICcuLi9ldmVudC1oYW5kbGVyJztcbmltcG9ydCB7bG9nZ2VyfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xuXG5jbGFzcyBGUFNDb250cm9sbGVyIGV4dGVuZHMgRXZlbnRIYW5kbGVye1xuXG4gIGNvbnN0cnVjdG9yKGhscykge1xuICAgIHN1cGVyKGhscywgRXZlbnQuTUVESUFfQVRUQUNISU5HKTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMudGltZXIpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy50aW1lcik7XG4gICAgfVxuICAgIHRoaXMuaXNWaWRlb1BsYXliYWNrUXVhbGl0eUF2YWlsYWJsZSA9IGZhbHNlO1xuICB9XG5cbiAgb25NZWRpYUF0dGFjaGluZyhkYXRhKSB7XG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5obHMuY29uZmlnO1xuICAgIGlmIChjb25maWcuY2FwTGV2ZWxPbkZQU0Ryb3ApIHtcbiAgICAgIGNvbnN0IHZpZGVvID0gdGhpcy52aWRlbyA9IGRhdGEubWVkaWEgaW5zdGFuY2VvZiBIVE1MVmlkZW9FbGVtZW50ID8gZGF0YS5tZWRpYSA6IG51bGw7XG4gICAgICBpZiAodHlwZW9mIHZpZGVvLmdldFZpZGVvUGxheWJhY2tRdWFsaXR5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMuaXNWaWRlb1BsYXliYWNrUXVhbGl0eUF2YWlsYWJsZSA9IHRydWU7XG4gICAgICB9XG4gICAgICBjbGVhckludGVydmFsKHRoaXMudGltZXIpO1xuICAgICAgdGhpcy50aW1lciA9IHNldEludGVydmFsKHRoaXMuY2hlY2tGUFNJbnRlcnZhbC5iaW5kKHRoaXMpLCBjb25maWcuZnBzRHJvcHBlZE1vbml0b3JpbmdQZXJpb2QpO1xuICAgIH1cbiAgfVxuXG4gIGNoZWNrRlBTKHZpZGVvLCBkZWNvZGVkRnJhbWVzLCBkcm9wcGVkRnJhbWVzKSB7XG4gICAgbGV0IGN1cnJlbnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgaWYgKGRlY29kZWRGcmFtZXMpIHtcbiAgICAgIGlmICh0aGlzLmxhc3RUaW1lKSB7XG4gICAgICAgIGxldCBjdXJyZW50UGVyaW9kID0gY3VycmVudFRpbWUgLSB0aGlzLmxhc3RUaW1lLFxuICAgICAgICAgICAgY3VycmVudERyb3BwZWQgPSBkcm9wcGVkRnJhbWVzIC0gdGhpcy5sYXN0RHJvcHBlZEZyYW1lcyxcbiAgICAgICAgICAgIGN1cnJlbnREZWNvZGVkID0gZGVjb2RlZEZyYW1lcyAtIHRoaXMubGFzdERlY29kZWRGcmFtZXMsXG4gICAgICAgICAgICBkcm9wcGVkRlBTID0gMTAwMCAqIGN1cnJlbnREcm9wcGVkIC8gY3VycmVudFBlcmlvZCxcbiAgICAgICAgICAgIGhscyA9IHRoaXMuaGxzO1xuICAgICAgICBobHMudHJpZ2dlcihFdmVudC5GUFNfRFJPUCwge2N1cnJlbnREcm9wcGVkOiBjdXJyZW50RHJvcHBlZCwgY3VycmVudERlY29kZWQ6IGN1cnJlbnREZWNvZGVkLCB0b3RhbERyb3BwZWRGcmFtZXM6IGRyb3BwZWRGcmFtZXN9KTtcbiAgICAgICAgaWYgKGRyb3BwZWRGUFMgPiAwKSB7XG4gICAgICAgICAgLy9sb2dnZXIubG9nKCdjaGVja0ZQUyA6IGRyb3BwZWRGUFMvZGVjb2RlZEZQUzonICsgZHJvcHBlZEZQUy8oMTAwMCAqIGN1cnJlbnREZWNvZGVkIC8gY3VycmVudFBlcmlvZCkpO1xuICAgICAgICAgIGlmIChjdXJyZW50RHJvcHBlZCA+IGhscy5jb25maWcuZnBzRHJvcHBlZE1vbml0b3JpbmdUaHJlc2hvbGQgKiBjdXJyZW50RGVjb2RlZCkge1xuICAgICAgICAgICAgbGV0IGN1cnJlbnRMZXZlbCA9IGhscy5jdXJyZW50TGV2ZWw7XG4gICAgICAgICAgICBsb2dnZXIud2FybignZHJvcCBGUFMgcmF0aW8gZ3JlYXRlciB0aGFuIG1heCBhbGxvd2VkIHZhbHVlIGZvciBjdXJyZW50TGV2ZWw6ICcgKyBjdXJyZW50TGV2ZWwpO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRMZXZlbCA+IDAgJiYgKGhscy5hdXRvTGV2ZWxDYXBwaW5nID09PSAtMSB8fCBobHMuYXV0b0xldmVsQ2FwcGluZyA+PSBjdXJyZW50TGV2ZWwpKSB7XG4gICAgICAgICAgICAgIGN1cnJlbnRMZXZlbCA9IGN1cnJlbnRMZXZlbCAtIDE7XG4gICAgICAgICAgICAgIGhscy50cmlnZ2VyKEV2ZW50LkZQU19EUk9QX0xFVkVMX0NBUFBJTkcsIHtsZXZlbDogY3VycmVudExldmVsLCBkcm9wcGVkTGV2ZWw6IGhscy5jdXJyZW50TGV2ZWx9KTtcbiAgICAgICAgICAgICAgaGxzLmF1dG9MZXZlbENhcHBpbmcgPSBjdXJyZW50TGV2ZWw7XG4gICAgICAgICAgICAgIGhscy5zdHJlYW1Db250cm9sbGVyLm5leHRMZXZlbFN3aXRjaCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5sYXN0VGltZSA9IGN1cnJlbnRUaW1lO1xuICAgICAgdGhpcy5sYXN0RHJvcHBlZEZyYW1lcyA9IGRyb3BwZWRGcmFtZXM7XG4gICAgICB0aGlzLmxhc3REZWNvZGVkRnJhbWVzID0gZGVjb2RlZEZyYW1lcztcbiAgICB9XG4gIH1cblxuICBjaGVja0ZQU0ludGVydmFsKCkge1xuICAgIGNvbnN0IHZpZGVvID0gdGhpcy52aWRlbztcbiAgICBpZiAodmlkZW8pIHtcbiAgICAgIGlmICh0aGlzLmlzVmlkZW9QbGF5YmFja1F1YWxpdHlBdmFpbGFibGUpIHtcbiAgICAgICAgbGV0IHZpZGVvUGxheWJhY2tRdWFsaXR5ID0gdmlkZW8uZ2V0VmlkZW9QbGF5YmFja1F1YWxpdHkoKTtcbiAgICAgICAgdGhpcy5jaGVja0ZQUyh2aWRlbywgdmlkZW9QbGF5YmFja1F1YWxpdHkudG90YWxWaWRlb0ZyYW1lcywgdmlkZW9QbGF5YmFja1F1YWxpdHkuZHJvcHBlZFZpZGVvRnJhbWVzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY2hlY2tGUFModmlkZW8sIHZpZGVvLndlYmtpdERlY29kZWRGcmFtZUNvdW50LCB2aWRlby53ZWJraXREcm9wcGVkRnJhbWVDb3VudCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEZQU0NvbnRyb2xsZXI7XG5cbiIsIi8qXG4gKiBMZXZlbCBDb250cm9sbGVyXG4qL1xuXG5pbXBvcnQgRXZlbnQgZnJvbSAnLi4vZXZlbnRzJztcbmltcG9ydCBFdmVudEhhbmRsZXIgZnJvbSAnLi4vZXZlbnQtaGFuZGxlcic7XG5pbXBvcnQge2xvZ2dlcn0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcbmltcG9ydCB7RXJyb3JUeXBlcywgRXJyb3JEZXRhaWxzfSBmcm9tICcuLi9lcnJvcnMnO1xuaW1wb3J0IEJ1ZmZlckhlbHBlciBmcm9tICcuLi9oZWxwZXIvYnVmZmVyLWhlbHBlcic7XG5cbmNsYXNzIExldmVsQ29udHJvbGxlciBleHRlbmRzIEV2ZW50SGFuZGxlciB7XG5cbiAgY29uc3RydWN0b3IoaGxzKSB7XG4gICAgc3VwZXIoaGxzLFxuICAgICAgRXZlbnQuTUFOSUZFU1RfTE9BREVELFxuICAgICAgRXZlbnQuTEVWRUxfTE9BREVELFxuICAgICAgRXZlbnQuRlJBR19MT0FERUQsXG4gICAgICBFdmVudC5FUlJPUik7XG4gICAgdGhpcy5vbnRpY2sgPSB0aGlzLnRpY2suYmluZCh0aGlzKTtcbiAgICB0aGlzLl9tYW51YWxMZXZlbCA9IC0xO1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICBpZiAodGhpcy50aW1lcikge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZXIpO1xuICAgICAgdGhpcy50aW1lciA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMuX21hbnVhbExldmVsID0gLTE7XG4gIH1cblxuICBzdGFydExvYWQoKSB7XG4gICAgdGhpcy5jYW5sb2FkID0gdHJ1ZTtcbiAgICBsZXQgbGV2ZWxzID0gdGhpcy5fbGV2ZWxzO1xuICAgIC8vIGNsZWFuIHVwIGxpdmUgbGV2ZWwgZGV0YWlscyB0byBmb3JjZSByZWxvYWQgdGhlbSwgYW5kIHJlc2V0IGxvYWQgZXJyb3JzXG4gICAgaWYobGV2ZWxzKSB7XG4gICAgICBsZXZlbHMuZm9yRWFjaChsZXZlbCA9PiB7XG4gICAgICAgIGxldmVsLmxvYWRFcnJvciA9IDA7XG4gICAgICAgIGNvbnN0IGxldmVsRGV0YWlscyA9IGxldmVsLmRldGFpbHM7XG4gICAgICAgIGlmIChsZXZlbERldGFpbHMgJiYgbGV2ZWxEZXRhaWxzLmxpdmUpIHtcbiAgICAgICAgICBsZXZlbC5kZXRhaWxzID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgLy8gc3BlZWQgdXAgbGl2ZSBwbGF5bGlzdCByZWZyZXNoIGlmIHRpbWVyIGV4aXN0c1xuICAgIGlmICh0aGlzLnRpbWVyKSB7XG4gICAgICB0aGlzLnRpY2soKTtcbiAgICB9XG4gIH1cblxuICBzdG9wTG9hZCgpIHtcbiAgICB0aGlzLmNhbmxvYWQgPSBmYWxzZTtcbiAgfVxuXG4gIG9uTWFuaWZlc3RMb2FkZWQoZGF0YSkge1xuICAgIHZhciBsZXZlbHMwID0gW10sXG4gICAgICAgIGxldmVscyA9IFtdLFxuICAgICAgICBiaXRyYXRlU3RhcnQsXG4gICAgICAgIGJpdHJhdGVTZXQgPSB7fSxcbiAgICAgICAgdmlkZW9Db2RlY0ZvdW5kID0gZmFsc2UsXG4gICAgICAgIGF1ZGlvQ29kZWNGb3VuZCA9IGZhbHNlLFxuICAgICAgICBobHMgPSB0aGlzLmhscyxcbiAgICAgICAgYnJva2VubXA0aW5tcDMgPSAvY2hyb21lfGZpcmVmb3gvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpKSxcbiAgICAgICAgY2hlY2tTdXBwb3J0ZWQgPSBmdW5jdGlvbih0eXBlLGNvZGVjKSB7IHJldHVybiBNZWRpYVNvdXJjZS5pc1R5cGVTdXBwb3J0ZWQoYCR7dHlwZX0vbXA0O2NvZGVjcz0ke2NvZGVjfWApO307XG5cbiAgICAvLyByZWdyb3VwIHJlZHVuZGFudCBsZXZlbCB0b2dldGhlclxuICAgIGRhdGEubGV2ZWxzLmZvckVhY2gobGV2ZWwgPT4ge1xuICAgICAgaWYobGV2ZWwudmlkZW9Db2RlYykge1xuICAgICAgICB2aWRlb0NvZGVjRm91bmQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgLy8gZXJhc2UgYXVkaW8gY29kZWMgaW5mbyBpZiBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgbXA0YS40MC4zNC4gZGVtdXhlciB3aWxsIGF1dG9kZXRlY3QgY29kZWMgYW5kIGZhbGxiYWNrIHRvIG1wZWcvYXVkaW9cbiAgICAgIGlmKGJyb2tlbm1wNGlubXAzICYmIGxldmVsLmF1ZGlvQ29kZWMgJiYgbGV2ZWwuYXVkaW9Db2RlYy5pbmRleE9mKCdtcDRhLjQwLjM0JykgIT09IC0xKSB7XG4gICAgICAgIGxldmVsLmF1ZGlvQ29kZWMgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBpZihsZXZlbC5hdWRpb0NvZGVjIHx8IChsZXZlbC5hdHRycyAmJiBsZXZlbC5hdHRycy5BVURJTykpIHtcbiAgICAgICAgYXVkaW9Db2RlY0ZvdW5kID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGxldCByZWR1bmRhbnRMZXZlbElkID0gYml0cmF0ZVNldFtsZXZlbC5iaXRyYXRlXTtcbiAgICAgIGlmIChyZWR1bmRhbnRMZXZlbElkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgYml0cmF0ZVNldFtsZXZlbC5iaXRyYXRlXSA9IGxldmVsczAubGVuZ3RoO1xuICAgICAgICBsZXZlbC51cmwgPSBbbGV2ZWwudXJsXTtcbiAgICAgICAgbGV2ZWwudXJsSWQgPSAwO1xuICAgICAgICBsZXZlbHMwLnB1c2gobGV2ZWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV2ZWxzMFtyZWR1bmRhbnRMZXZlbElkXS51cmwucHVzaChsZXZlbC51cmwpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gcmVtb3ZlIGF1ZGlvLW9ubHkgbGV2ZWwgaWYgd2UgYWxzbyBoYXZlIGxldmVscyB3aXRoIGF1ZGlvK3ZpZGVvIGNvZGVjcyBzaWduYWxsZWRcbiAgICBpZih2aWRlb0NvZGVjRm91bmQgJiYgYXVkaW9Db2RlY0ZvdW5kKSB7XG4gICAgICBsZXZlbHMwLmZvckVhY2gobGV2ZWwgPT4ge1xuICAgICAgICBpZihsZXZlbC52aWRlb0NvZGVjKSB7XG4gICAgICAgICAgbGV2ZWxzLnB1c2gobGV2ZWwpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV2ZWxzID0gbGV2ZWxzMDtcbiAgICB9XG4gICAgLy8gb25seSBrZWVwIGxldmVsIHdpdGggc3VwcG9ydGVkIGF1ZGlvL3ZpZGVvIGNvZGVjc1xuICAgIGxldmVscyA9IGxldmVscy5maWx0ZXIoZnVuY3Rpb24obGV2ZWwpIHtcbiAgICBsZXQgYXVkaW9Db2RlYyA9IGxldmVsLmF1ZGlvQ29kZWMsIHZpZGVvQ29kZWMgPSBsZXZlbC52aWRlb0NvZGVjO1xuICAgICAgcmV0dXJuICghYXVkaW9Db2RlYyB8fCBjaGVja1N1cHBvcnRlZCgnYXVkaW8nLGF1ZGlvQ29kZWMpKSAmJlxuICAgICAgICAgICAgICghdmlkZW9Db2RlYyB8fCBjaGVja1N1cHBvcnRlZCgndmlkZW8nLHZpZGVvQ29kZWMpKTtcbiAgICB9KTtcblxuICAgIGlmKGxldmVscy5sZW5ndGgpIHtcbiAgICAgIC8vIHN0YXJ0IGJpdHJhdGUgaXMgdGhlIGZpcnN0IGJpdHJhdGUgb2YgdGhlIG1hbmlmZXN0XG4gICAgICBiaXRyYXRlU3RhcnQgPSBsZXZlbHNbMF0uYml0cmF0ZTtcbiAgICAgIC8vIHNvcnQgbGV2ZWwgb24gYml0cmF0ZVxuICAgICAgbGV2ZWxzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEuYml0cmF0ZSAtIGIuYml0cmF0ZTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5fbGV2ZWxzID0gbGV2ZWxzO1xuICAgICAgLy8gZmluZCBpbmRleCBvZiBmaXJzdCBsZXZlbCBpbiBzb3J0ZWQgbGV2ZWxzXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxldmVscy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAobGV2ZWxzW2ldLmJpdHJhdGUgPT09IGJpdHJhdGVTdGFydCkge1xuICAgICAgICAgIHRoaXMuX2ZpcnN0TGV2ZWwgPSBpO1xuICAgICAgICAgIGxvZ2dlci5sb2coYG1hbmlmZXN0IGxvYWRlZCwke2xldmVscy5sZW5ndGh9IGxldmVsKHMpIGZvdW5kLCBmaXJzdCBiaXRyYXRlOiR7Yml0cmF0ZVN0YXJ0fWApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBobHMudHJpZ2dlcihFdmVudC5NQU5JRkVTVF9QQVJTRUQsIHtsZXZlbHM6IGxldmVscywgZmlyc3RMZXZlbDogdGhpcy5fZmlyc3RMZXZlbCwgc3RhdHM6IGRhdGEuc3RhdHMsIGF1ZGlvIDogYXVkaW9Db2RlY0ZvdW5kLCB2aWRlbyA6IHZpZGVvQ29kZWNGb3VuZCwgYWx0QXVkaW8gOiBkYXRhLmF1ZGlvVHJhY2tzLmxlbmd0aCA+IDB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaGxzLnRyaWdnZXIoRXZlbnQuRVJST1IsIHt0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLCBkZXRhaWxzOiBFcnJvckRldGFpbHMuTUFOSUZFU1RfSU5DT01QQVRJQkxFX0NPREVDU19FUlJPUiwgZmF0YWw6IHRydWUsIHVybDogaGxzLnVybCwgcmVhc29uOiAnbm8gbGV2ZWwgd2l0aCBjb21wYXRpYmxlIGNvZGVjcyBmb3VuZCBpbiBtYW5pZmVzdCd9KTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZ2V0IGxldmVscygpIHtcbiAgICByZXR1cm4gdGhpcy5fbGV2ZWxzO1xuICB9XG5cbiAgZ2V0IGxldmVsKCkge1xuICAgIHJldHVybiB0aGlzLl9sZXZlbDtcbiAgfVxuXG4gIHNldCBsZXZlbChuZXdMZXZlbCkge1xuICAgIGxldCBsZXZlbHMgPSB0aGlzLl9sZXZlbHM7XG4gICAgaWYgKGxldmVscyAmJiBsZXZlbHMubGVuZ3RoID4gbmV3TGV2ZWwpIHtcbiAgICAgIGlmICh0aGlzLl9sZXZlbCAhPT0gbmV3TGV2ZWwgfHwgbGV2ZWxzW25ld0xldmVsXS5kZXRhaWxzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5zZXRMZXZlbEludGVybmFsKG5ld0xldmVsKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuIHNldExldmVsSW50ZXJuYWwobmV3TGV2ZWwpIHtcbiAgICBjb25zdCBsZXZlbHMgPSB0aGlzLl9sZXZlbHM7XG4gICAgY29uc3QgaGxzID0gdGhpcy5obHM7XG4gICAgLy8gY2hlY2sgaWYgbGV2ZWwgaWR4IGlzIHZhbGlkXG4gICAgaWYgKG5ld0xldmVsID49IDAgJiYgbmV3TGV2ZWwgPCBsZXZlbHMubGVuZ3RoKSB7XG4gICAgICAvLyBzdG9wcGluZyBsaXZlIHJlbG9hZGluZyB0aW1lciBpZiBhbnlcbiAgICAgIGlmICh0aGlzLnRpbWVyKSB7XG4gICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZXIpO1xuICAgICAgIHRoaXMudGltZXIgPSBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX2xldmVsICE9PSBuZXdMZXZlbCkge1xuICAgICAgICBsb2dnZXIubG9nKGBzd2l0Y2hpbmcgdG8gbGV2ZWwgJHtuZXdMZXZlbH1gKTtcbiAgICAgICAgdGhpcy5fbGV2ZWwgPSBuZXdMZXZlbDtcbiAgICAgICAgdmFyIGxldmVsUHJvcGVydGllcyA9IGxldmVsc1tuZXdMZXZlbF07XG4gICAgICAgIGxldmVsUHJvcGVydGllcy5sZXZlbCA9IG5ld0xldmVsO1xuICAgICAgICAvLyBMRVZFTF9TV0lUQ0ggdG8gYmUgZGVwcmVjYXRlZCBpbiBuZXh0IG1ham9yIHJlbGVhc2VcbiAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnQuTEVWRUxfU1dJVENILCBsZXZlbFByb3BlcnRpZXMpO1xuICAgICAgICBobHMudHJpZ2dlcihFdmVudC5MRVZFTF9TV0lUQ0hJTkcsIGxldmVsUHJvcGVydGllcyk7XG4gICAgICB9XG4gICAgICB2YXIgbGV2ZWwgPSBsZXZlbHNbbmV3TGV2ZWxdLCBsZXZlbERldGFpbHMgPSBsZXZlbC5kZXRhaWxzO1xuICAgICAgIC8vIGNoZWNrIGlmIHdlIG5lZWQgdG8gbG9hZCBwbGF5bGlzdCBmb3IgdGhpcyBsZXZlbFxuICAgICAgaWYgKCFsZXZlbERldGFpbHMgfHwgbGV2ZWxEZXRhaWxzLmxpdmUgPT09IHRydWUpIHtcbiAgICAgICAgLy8gbGV2ZWwgbm90IHJldHJpZXZlZCB5ZXQsIG9yIGxpdmUgcGxheWxpc3Qgd2UgbmVlZCB0byAocmUpbG9hZCBpdFxuICAgICAgICB2YXIgdXJsSWQgPSBsZXZlbC51cmxJZDtcbiAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnQuTEVWRUxfTE9BRElORywge3VybDogbGV2ZWwudXJsW3VybElkXSwgbGV2ZWw6IG5ld0xldmVsLCBpZDogdXJsSWR9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaW52YWxpZCBsZXZlbCBpZCBnaXZlbiwgdHJpZ2dlciBlcnJvclxuICAgICAgaGxzLnRyaWdnZXIoRXZlbnQuRVJST1IsIHt0eXBlIDogRXJyb3JUeXBlcy5PVEhFUl9FUlJPUiwgZGV0YWlsczogRXJyb3JEZXRhaWxzLkxFVkVMX1NXSVRDSF9FUlJPUiwgbGV2ZWw6IG5ld0xldmVsLCBmYXRhbDogZmFsc2UsIHJlYXNvbjogJ2ludmFsaWQgbGV2ZWwgaWR4J30pO1xuICAgIH1cbiB9XG5cbiAgZ2V0IG1hbnVhbExldmVsKCkge1xuICAgIHJldHVybiB0aGlzLl9tYW51YWxMZXZlbDtcbiAgfVxuXG4gIHNldCBtYW51YWxMZXZlbChuZXdMZXZlbCkge1xuICAgIHRoaXMuX21hbnVhbExldmVsID0gbmV3TGV2ZWw7XG4gICAgaWYgKHRoaXMuX3N0YXJ0TGV2ZWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5fc3RhcnRMZXZlbCA9IG5ld0xldmVsO1xuICAgIH1cbiAgICBpZiAobmV3TGV2ZWwgIT09IC0xKSB7XG4gICAgICB0aGlzLmxldmVsID0gbmV3TGV2ZWw7XG4gICAgfVxuICB9XG5cbiAgZ2V0IGZpcnN0TGV2ZWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZpcnN0TGV2ZWw7XG4gIH1cblxuICBzZXQgZmlyc3RMZXZlbChuZXdMZXZlbCkge1xuICAgIHRoaXMuX2ZpcnN0TGV2ZWwgPSBuZXdMZXZlbDtcbiAgfVxuXG4gIGdldCBzdGFydExldmVsKCkge1xuICAgIC8vIGhscy5zdGFydExldmVsIHRha2VzIHByZWNlZGVuY2Ugb3ZlciBjb25maWcuc3RhcnRMZXZlbFxuICAgIC8vIGlmIG5vbmUgb2YgdGhlc2UgdmFsdWVzIGFyZSBkZWZpbmVkLCBmYWxsYmFjayBvbiB0aGlzLl9maXJzdExldmVsIChmaXJzdCBxdWFsaXR5IGxldmVsIGFwcGVhcmluZyBpbiB2YXJpYW50IG1hbmlmZXN0KVxuICAgIGlmICh0aGlzLl9zdGFydExldmVsID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGxldCBjb25maWdTdGFydExldmVsID0gdGhpcy5obHMuY29uZmlnLnN0YXJ0TGV2ZWw7XG4gICAgICBpZiAoY29uZmlnU3RhcnRMZXZlbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBjb25maWdTdGFydExldmVsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZpcnN0TGV2ZWw7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLl9zdGFydExldmVsO1xuICAgIH1cbiAgfVxuXG4gIHNldCBzdGFydExldmVsKG5ld0xldmVsKSB7XG4gICAgdGhpcy5fc3RhcnRMZXZlbCA9IG5ld0xldmVsO1xuICB9XG5cbiAgb25FcnJvcihkYXRhKSB7XG4gICAgaWYoZGF0YS5mYXRhbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCBkZXRhaWxzID0gZGF0YS5kZXRhaWxzLCBobHMgPSB0aGlzLmhscywgbGV2ZWxJZCwgbGV2ZWwsIGxldmVsRXJyb3IgPSBmYWxzZTtcbiAgICBsZXQgcmVtb3ZlTGV2ZWwgPSBmYWxzZTtcbiAgICAvLyB0cnkgdG8gcmVjb3ZlciBub3QgZmF0YWwgZXJyb3JzXG4gICAgc3dpdGNoKGRldGFpbHMpIHtcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkZSQUdfTE9BRF9FUlJPUjpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkZSQUdfTE9BRF9USU1FT1VUOlxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuRlJBR19MT09QX0xPQURJTkdfRVJST1I6XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5LRVlfTE9BRF9FUlJPUjpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLktFWV9MT0FEX1RJTUVPVVQ6XG4gICAgICAgICBsZXZlbElkID0gZGF0YS5mcmFnLmxldmVsO1xuICAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5MRVZFTF9MT0FEX0VSUk9SOlxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuTEVWRUxfTE9BRF9USU1FT1VUOlxuICAgICAgICBsZXZlbElkID0gZGF0YS5jb250ZXh0LmxldmVsO1xuICAgICAgICBsZXZlbEVycm9yID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5SRU1VWF9BTExPQ19FUlJPUjpcbiAgICAgICAgbGV2ZWxJZCA9IGRhdGEubGV2ZWw7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBFcnJvckRldGFpbHMuTUFOSUZFU1RfRU1QVFlfRVJST1I6XG4gICAgICAgIGxldmVsSWQgPSBkYXRhLmNvbnRleHQubGV2ZWw7XG4gICAgICAgIGxldmVsRXJyb3IgPSB0cnVlO1xuICAgICAgICByZW1vdmVMZXZlbCA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIC8qIHRyeSB0byBzd2l0Y2ggdG8gYSByZWR1bmRhbnQgc3RyZWFtIGlmIGFueSBhdmFpbGFibGUuXG4gICAgICogaWYgbm8gcmVkdW5kYW50IHN0cmVhbSBhdmFpbGFibGUsIGVtZXJnZW5jeSBzd2l0Y2ggZG93biAoaWYgaW4gYXV0byBtb2RlIGFuZCBjdXJyZW50IGxldmVsIG5vdCAwKVxuICAgICAqIG90aGVyd2lzZSwgd2UgY2Fubm90IHJlY292ZXIgdGhpcyBuZXR3b3JrIGVycm9yIC4uLlxuICAgICAqL1xuICAgIGlmIChsZXZlbElkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGxldmVsID0gdGhpcy5fbGV2ZWxzW2xldmVsSWRdO1xuICAgICAgaWYoIWxldmVsLmxvYWRFcnJvcikge1xuICAgICAgICBsZXZlbC5sb2FkRXJyb3IgPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV2ZWwubG9hZEVycm9yKys7XG4gICAgICB9XG4gICAgICAvLyBpZiBhbnkgcmVkdW5kYW50IHN0cmVhbXMgYXZhaWxhYmxlIGFuZCBpZiB3ZSBoYXZlbid0IHRyeSB0aGVtIGFsbCAobGV2ZWwubG9hZEVycm9yIGlzIHJlc2V0ZWQgb24gc3VjY2Vzc2Z1bCBmcmFnL2xldmVsIGxvYWQuXG4gICAgICAvLyBpZiBsZXZlbC5sb2FkRXJyb3IgcmVhY2hlcyBuYlJlZHVuZGFudExldmVsIGl0IG1lYW5zIHRoYXQgd2UgdHJpZWQgdGhlbSBhbGwsIG5vIGhvcGUgID0+IGxldCdzIHN3aXRjaCBkb3duXG4gICAgICBjb25zdCBuYlJlZHVuZGFudExldmVsID0gbGV2ZWwudXJsLmxlbmd0aDtcbiAgICAgaWYgKG5iUmVkdW5kYW50TGV2ZWwgPiAxICYmIGxldmVsLmxvYWRFcnJvciA8IG5iUmVkdW5kYW50TGV2ZWwpIHtcbiAgICAgICAgbGV2ZWwudXJsSWQgPSAobGV2ZWwudXJsSWQgKyAxKSAlIG5iUmVkdW5kYW50TGV2ZWw7XG4gICAgICAgIGxldmVsLmRldGFpbHMgPSB1bmRlZmluZWQ7XG4gICAgICAgIGxvZ2dlci53YXJuKGBsZXZlbCBjb250cm9sbGVyLCR7ZGV0YWlsc30gZm9yIGxldmVsICR7bGV2ZWxJZH06IHN3aXRjaGluZyB0byByZWR1bmRhbnQgc3RyZWFtIGlkICR7bGV2ZWwudXJsSWR9YCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocmVtb3ZlTGV2ZWwpIHtcbiAgICAgICAgICBsb2dnZXIud2FybihgQmFkIGxldmVsIGVuY291bnRlcmVkLCByZW1vdmluZyAmIGZvcmNpbmcgdG8gYXV0byBtb2RlYCk7XG4gICAgICAgICAgdGhpcy5fbGV2ZWxzID0gdGhpcy5sZXZlbHMuZmlsdGVyKChsLCBpbmRleCkgPT4gaW5kZXggIT09IGxldmVsSWQpO1xuICAgICAgICAgIGhscy5jdXJyZW50TGV2ZWwgPSAtMTtcbiAgICAgICAgICBobHMudHJpZ2dlcihFdmVudC5MRVZFTF9SRU1PVkVELCB7IGxldmVsOiBsZXZlbElkIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIHdlIGNvdWxkIHRyeSB0byByZWNvdmVyIGlmIGluIGF1dG8gbW9kZSBhbmQgY3VycmVudCBsZXZlbCBub3QgbG93ZXN0IGxldmVsICgwKVxuICAgICAgICBsZXQgcmVjb3ZlcmFibGUgPSAoKHRoaXMuX21hbnVhbExldmVsID09PSAtMSkgJiYgbGV2ZWxJZCk7XG4gICAgICAgIGlmIChyZWNvdmVyYWJsZSkge1xuICAgICAgICAgIGxvZ2dlci53YXJuKGBsZXZlbCBjb250cm9sbGVyLCR7ZGV0YWlsc306IHN3aXRjaC1kb3duIGZvciBuZXh0IGZyYWdtZW50YCk7XG4gICAgICAgICAgaGxzLm5leHRBdXRvTGV2ZWwgPSBNYXRoLm1heCgwLGxldmVsSWQtMSk7XG4gICAgICAgIH0gZWxzZSBpZihsZXZlbCAmJiBsZXZlbC5kZXRhaWxzICYmIGxldmVsLmRldGFpbHMubGl2ZSkge1xuICAgICAgICAgIGxvZ2dlci53YXJuKGBsZXZlbCBjb250cm9sbGVyLCR7ZGV0YWlsc30gb24gbGl2ZSBzdHJlYW0sIGRpc2NhcmRgKTtcbiAgICAgICAgICBpZiAobGV2ZWxFcnJvcikge1xuICAgICAgICAgICAgLy8gcmVzZXQgdGhpcy5fbGV2ZWwgc28gdGhhdCBhbm90aGVyIGNhbGwgdG8gc2V0IGxldmVsKCkgd2lsbCByZXRyaWdnZXIgYSBmcmFnIGxvYWRcbiAgICAgICAgICAgIHRoaXMuX2xldmVsID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBvdGhlciBlcnJvcnMgYXJlIGhhbmRsZWQgYnkgc3RyZWFtIGNvbnRyb2xsZXJcbiAgICAgICAgfSBlbHNlIGlmIChkZXRhaWxzID09PSBFcnJvckRldGFpbHMuTEVWRUxfTE9BRF9FUlJPUiB8fFxuICAgICAgICAgICAgICAgICAgIGRldGFpbHMgPT09IEVycm9yRGV0YWlscy5MRVZFTF9MT0FEX1RJTUVPVVQpIHtcbiAgICAgICAgICBsZXQgbWVkaWEgPSBobHMubWVkaWEsXG4gICAgICAgICAgICAvLyAwLjUgOiB0b2xlcmFuY2UgbmVlZGVkIGFzIHNvbWUgYnJvd3NlcnMgc3RhbGxzIHBsYXliYWNrIGJlZm9yZSByZWFjaGluZyBidWZmZXJlZCBlbmRcbiAgICAgICAgICAgICAgbWVkaWFCdWZmZXJlZCA9IG1lZGlhICYmIEJ1ZmZlckhlbHBlci5pc0J1ZmZlcmVkKG1lZGlhLG1lZGlhLmN1cnJlbnRUaW1lKSAmJiBCdWZmZXJIZWxwZXIuaXNCdWZmZXJlZChtZWRpYSxtZWRpYS5jdXJyZW50VGltZSswLjUpO1xuICAgICAgICAgIGlmIChtZWRpYUJ1ZmZlcmVkKSB7XG4gICAgICAgICAgICBsZXQgcmV0cnlEZWxheSA9IGhscy5jb25maWcubGV2ZWxMb2FkaW5nUmV0cnlEZWxheTtcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKGBsZXZlbCBjb250cm9sbGVyLCR7ZGV0YWlsc30sIGJ1dCBtZWRpYSBidWZmZXJlZCwgcmV0cnkgaW4gJHtyZXRyeURlbGF5fW1zYCk7XG4gICAgICAgICAgICB0aGlzLnRpbWVyID0gc2V0VGltZW91dCh0aGlzLm9udGljayxyZXRyeURlbGF5KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGBjYW5ub3QgcmVjb3ZlciAke2RldGFpbHN9IGVycm9yYCk7XG4gICAgICAgICAgICB0aGlzLl9sZXZlbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIC8vIHN0b3BwaW5nIGxpdmUgcmVsb2FkaW5nIHRpbWVyIGlmIGFueVxuICAgICAgICAgICAgaWYgKHRoaXMudGltZXIpIHtcbiAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZXIpO1xuICAgICAgICAgICAgICB0aGlzLnRpbWVyID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHN3aXRjaCBlcnJvciB0byBmYXRhbFxuICAgICAgICAgICAgZGF0YS5mYXRhbCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gcmVzZXQgbGV2ZWwgbG9hZCBlcnJvciBjb3VudGVyIG9uIHN1Y2Nlc3NmdWwgZnJhZyBsb2FkZWRcbiAgb25GcmFnTG9hZGVkKGRhdGEpIHtcbiAgICBjb25zdCBmcmFnTG9hZGVkID0gZGF0YS5mcmFnO1xuICAgIGlmIChmcmFnTG9hZGVkICYmIGZyYWdMb2FkZWQudHlwZSA9PT0gJ21haW4nKSB7XG4gICAgICBjb25zdCBsZXZlbCA9IHRoaXMuX2xldmVsc1tmcmFnTG9hZGVkLmxldmVsXTtcbiAgICAgIGlmIChsZXZlbCkge1xuICAgICAgICBsZXZlbC5sb2FkRXJyb3IgPSAwO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIG9uTGV2ZWxMb2FkZWQoZGF0YSkge1xuICAgIGNvbnN0IGxldmVsSWQgPSBkYXRhLmxldmVsO1xuICAgICAvLyBvbmx5IHByb2Nlc3MgbGV2ZWwgbG9hZGVkIGV2ZW50cyBtYXRjaGluZyB3aXRoIGV4cGVjdGVkIGxldmVsXG4gICAgaWYgKGxldmVsSWQgPT09IHRoaXMuX2xldmVsKSB7XG4gICAgICBsZXQgY3VyTGV2ZWwgPSB0aGlzLl9sZXZlbHNbbGV2ZWxJZF07XG4gICAgICAvLyByZXNldCBsZXZlbCBsb2FkIGVycm9yIGNvdW50ZXIgb24gc3VjY2Vzc2Z1bCBsZXZlbCBsb2FkZWRcbiAgICAgIGN1ckxldmVsLmxvYWRFcnJvciA9IDA7XG4gICAgICBsZXQgbmV3RGV0YWlscyA9IGRhdGEuZGV0YWlscztcbiAgICAgIC8vIGlmIGN1cnJlbnQgcGxheWxpc3QgaXMgYSBsaXZlIHBsYXlsaXN0LCBhcm0gYSB0aW1lciB0byByZWxvYWQgaXRcbiAgICAgIGlmIChuZXdEZXRhaWxzLmxpdmUpIHtcbiAgICAgICAgbGV0IHJlbG9hZEludGVydmFsID0gMTAwMCooIG5ld0RldGFpbHMuYXZlcmFnZXRhcmdldGR1cmF0aW9uID8gbmV3RGV0YWlscy5hdmVyYWdldGFyZ2V0ZHVyYXRpb24gOiBuZXdEZXRhaWxzLnRhcmdldGR1cmF0aW9uKSxcbiAgICAgICAgICAgIGN1ckxldmVsID0gdGhpcy5fbGV2ZWxzW2RhdGEubGV2ZWxdLFxuICAgICAgICAgICAgY3VyRGV0YWlscyA9IGN1ckxldmVsLmRldGFpbHM7XG4gICAgICAgIGlmIChjdXJEZXRhaWxzICYmIG5ld0RldGFpbHMuZW5kU04gPT09IGN1ckRldGFpbHMuZW5kU04pIHtcbiAgICAgICAgICAvLyBmb2xsb3cgSExTIFNwZWMsIElmIHRoZSBjbGllbnQgcmVsb2FkcyBhIFBsYXlsaXN0IGZpbGUgYW5kIGZpbmRzIHRoYXQgaXQgaGFzIG5vdFxuICAgICAgICAgIC8vIGNoYW5nZWQgdGhlbiBpdCBNVVNUIHdhaXQgZm9yIGEgcGVyaW9kIG9mIG9uZS1oYWxmIHRoZSB0YXJnZXRcbiAgICAgICAgICAvLyBkdXJhdGlvbiBiZWZvcmUgcmV0cnlpbmcuXG4gICAgICAgICAgcmVsb2FkSW50ZXJ2YWwgLz0yO1xuICAgICAgICAgIGxvZ2dlci5sb2coYHNhbWUgbGl2ZSBwbGF5bGlzdCwgcmVsb2FkIHR3aWNlIGZhc3RlcmApO1xuICAgICAgICB9XG4gICAgICAgIC8vIGRlY3JlbWVudCByZWxvYWRJbnRlcnZhbCB3aXRoIGxldmVsIGxvYWRpbmcgZGVsYXlcbiAgICAgICAgcmVsb2FkSW50ZXJ2YWwgLT0gcGVyZm9ybWFuY2Uubm93KCkgLSBkYXRhLnN0YXRzLnRyZXF1ZXN0O1xuICAgICAgICAvLyBpbiBhbnkgY2FzZSwgZG9uJ3QgcmVsb2FkIG1vcmUgdGhhbiBldmVyeSBzZWNvbmRcbiAgICAgICAgcmVsb2FkSW50ZXJ2YWwgPSBNYXRoLm1heCgxMDAwLE1hdGgucm91bmQocmVsb2FkSW50ZXJ2YWwpKTtcbiAgICAgICAgbG9nZ2VyLmxvZyhgbGl2ZSBwbGF5bGlzdCwgcmVsb2FkIGluICR7cmVsb2FkSW50ZXJ2YWx9IG1zYCk7XG4gICAgICAgIHRoaXMudGltZXIgPSBzZXRUaW1lb3V0KHRoaXMub250aWNrLHJlbG9hZEludGVydmFsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudGltZXIgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHRpY2soKSB7XG4gICAgdmFyIGxldmVsSWQgPSB0aGlzLl9sZXZlbDtcbiAgICBpZiAobGV2ZWxJZCAhPT0gdW5kZWZpbmVkICYmIHRoaXMuY2FubG9hZCkge1xuICAgICAgdmFyIGxldmVsID0gdGhpcy5fbGV2ZWxzW2xldmVsSWRdO1xuICAgICAgaWYgKGxldmVsICYmIGxldmVsLnVybCkge1xuICAgICAgICB2YXIgdXJsSWQgPSBsZXZlbC51cmxJZDtcbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5MRVZFTF9MT0FESU5HLCB7dXJsOiBsZXZlbC51cmxbdXJsSWRdLCBsZXZlbDogbGV2ZWxJZCwgaWQ6IHVybElkfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZ2V0IG5leHRMb2FkTGV2ZWwoKSB7XG4gICAgaWYgKHRoaXMuX21hbnVhbExldmVsICE9PSAtMSkge1xuICAgICAgcmV0dXJuIHRoaXMuX21hbnVhbExldmVsO1xuICAgIH0gZWxzZSB7XG4gICAgIHJldHVybiB0aGlzLmhscy5uZXh0QXV0b0xldmVsO1xuICAgIH1cbiAgfVxuXG4gIHNldCBuZXh0TG9hZExldmVsKG5leHRMZXZlbCkge1xuICAgIHRoaXMubGV2ZWwgPSBuZXh0TGV2ZWw7XG4gICAgaWYgKHRoaXMuX21hbnVhbExldmVsID09PSAtMSkge1xuICAgICAgdGhpcy5obHMubmV4dEF1dG9MZXZlbCA9IG5leHRMZXZlbDtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTGV2ZWxDb250cm9sbGVyO1xuXG4iLCIvKlxuICogU3RyZWFtIENvbnRyb2xsZXJcbiovXG5cbmltcG9ydCBCaW5hcnlTZWFyY2ggZnJvbSAnLi4vdXRpbHMvYmluYXJ5LXNlYXJjaCc7XG5pbXBvcnQgQnVmZmVySGVscGVyIGZyb20gJy4uL2hlbHBlci9idWZmZXItaGVscGVyJztcbmltcG9ydCBEZW11eGVyIGZyb20gJy4uL2RlbXV4L2RlbXV4ZXInO1xuaW1wb3J0IEV2ZW50IGZyb20gJy4uL2V2ZW50cyc7XG5pbXBvcnQgRXZlbnRIYW5kbGVyIGZyb20gJy4uL2V2ZW50LWhhbmRsZXInO1xuaW1wb3J0IExldmVsSGVscGVyIGZyb20gJy4uL2hlbHBlci9sZXZlbC1oZWxwZXInO1xuaW1wb3J0IFRpbWVSYW5nZXMgZnJvbSAnLi4vdXRpbHMvdGltZVJhbmdlcyc7XG5pbXBvcnQge0Vycm9yVHlwZXMsIEVycm9yRGV0YWlsc30gZnJvbSAnLi4vZXJyb3JzJztcbmltcG9ydCB7bG9nZ2VyfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xuaW1wb3J0IHsgYWxpZ25EaXNjb250aW51aXRpZXMsIGZpbmRGaXJzdEZyYWdXaXRoQ0MgfSBmcm9tICcuLi91dGlscy9kaXNjb250aW51aXRpZXMnO1xuXG5jb25zdCBTdGF0ZSA9IHtcbiAgU1RPUFBFRCA6ICdTVE9QUEVEJyxcbiAgSURMRSA6ICdJRExFJyxcbiAgS0VZX0xPQURJTkcgOiAnS0VZX0xPQURJTkcnLFxuICBGUkFHX0xPQURJTkcgOiAnRlJBR19MT0FESU5HJyxcbiAgRlJBR19MT0FESU5HX1dBSVRJTkdfUkVUUlkgOiAnRlJBR19MT0FESU5HX1dBSVRJTkdfUkVUUlknLFxuICBXQUlUSU5HX0xFVkVMIDogJ1dBSVRJTkdfTEVWRUwnLFxuICBQQVJTSU5HIDogJ1BBUlNJTkcnLFxuICBQQVJTRUQgOiAnUEFSU0VEJyxcbiAgQlVGRkVSX0ZMVVNISU5HIDogJ0JVRkZFUl9GTFVTSElORycsXG4gIEVOREVEIDogJ0VOREVEJyxcbiAgRVJST1IgOiAnRVJST1InXG59O1xuXG5jbGFzcyBTdHJlYW1Db250cm9sbGVyIGV4dGVuZHMgRXZlbnRIYW5kbGVyIHtcblxuICBjb25zdHJ1Y3RvcihobHMpIHtcbiAgICBzdXBlcihobHMsXG4gICAgICBFdmVudC5NRURJQV9BVFRBQ0hFRCxcbiAgICAgIEV2ZW50Lk1FRElBX0RFVEFDSElORyxcbiAgICAgIEV2ZW50Lk1BTklGRVNUX0xPQURJTkcsXG4gICAgICBFdmVudC5NQU5JRkVTVF9QQVJTRUQsXG4gICAgICBFdmVudC5MRVZFTF9MT0FERUQsXG4gICAgICBFdmVudC5LRVlfTE9BREVELFxuICAgICAgRXZlbnQuRlJBR19MT0FERUQsXG4gICAgICBFdmVudC5GUkFHX0xPQURfRU1FUkdFTkNZX0FCT1JURUQsXG4gICAgICBFdmVudC5GUkFHX1BBUlNJTkdfSU5JVF9TRUdNRU5ULFxuICAgICAgRXZlbnQuRlJBR19QQVJTSU5HX0RBVEEsXG4gICAgICBFdmVudC5GUkFHX1BBUlNFRCxcbiAgICAgIEV2ZW50LkVSUk9SLFxuICAgICAgRXZlbnQuQVVESU9fVFJBQ0tfU1dJVENISU5HLFxuICAgICAgRXZlbnQuQVVESU9fVFJBQ0tfU1dJVENIRUQsXG4gICAgICBFdmVudC5CVUZGRVJfQ1JFQVRFRCxcbiAgICAgIEV2ZW50LkJVRkZFUl9BUFBFTkRFRCxcbiAgICAgIEV2ZW50LkJVRkZFUl9GTFVTSEVELFxuICAgICAgRXZlbnQuTEVWRUxfUkVNT1ZFRFxuICAgICk7XG5cbiAgICB0aGlzLmNvbmZpZyA9IGhscy5jb25maWc7XG4gICAgdGhpcy5hdWRpb0NvZGVjU3dhcCA9IGZhbHNlO1xuICAgIHRoaXMudGlja3MgPSAwO1xuICAgIHRoaXMuX3N0YXRlID0gU3RhdGUuU1RPUFBFRDtcbiAgICB0aGlzLm9udGljayA9IHRoaXMudGljay5iaW5kKHRoaXMpO1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnN0b3BMb2FkKCk7XG4gICAgaWYgKHRoaXMudGltZXIpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy50aW1lcik7XG4gICAgICB0aGlzLnRpbWVyID0gbnVsbDtcbiAgICB9XG4gICAgRXZlbnRIYW5kbGVyLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XG4gICAgdGhpcy5zdGF0ZSA9IFN0YXRlLlNUT1BQRUQ7XG4gIH1cblxuICBzdGFydExvYWQoc3RhcnRQb3NpdGlvbikge1xuICAgIGlmICh0aGlzLmxldmVscykge1xuICAgICAgbGV0IGxhc3RDdXJyZW50VGltZSA9IHRoaXMubGFzdEN1cnJlbnRUaW1lLCBobHMgPSB0aGlzLmhscztcbiAgICAgIHRoaXMuc3RvcExvYWQoKTtcbiAgICAgIGlmICghdGhpcy50aW1lcikge1xuICAgICAgICB0aGlzLnRpbWVyID0gc2V0SW50ZXJ2YWwodGhpcy5vbnRpY2ssIDEwMCk7XG4gICAgICB9XG4gICAgICB0aGlzLmxldmVsID0gLTE7XG4gICAgICB0aGlzLmZyYWdMb2FkRXJyb3IgPSAwO1xuICAgICAgaWYgKCF0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCkge1xuICAgICAgICAvLyBkZXRlcm1pbmUgbG9hZCBsZXZlbFxuICAgICAgICBsZXQgc3RhcnRMZXZlbCA9IGhscy5zdGFydExldmVsO1xuICAgICAgICBpZiAoc3RhcnRMZXZlbCA9PT0gLTEpIHtcbiAgICAgICAgICAvLyAtMSA6IGd1ZXNzIHN0YXJ0IExldmVsIGJ5IGRvaW5nIGEgYml0cmF0ZSB0ZXN0IGJ5IGxvYWRpbmcgZmlyc3QgZnJhZ21lbnQgb2YgbG93ZXN0IHF1YWxpdHkgbGV2ZWxcbiAgICAgICAgICBzdGFydExldmVsID0gMDtcbiAgICAgICAgICB0aGlzLmJpdHJhdGVUZXN0ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzZXQgbmV3IGxldmVsIHRvIHBsYXlsaXN0IGxvYWRlciA6IHRoaXMgd2lsbCB0cmlnZ2VyIHN0YXJ0IGxldmVsIGxvYWRcbiAgICAgICAgLy8gaGxzLm5leHRMb2FkTGV2ZWwgcmVtYWlucyB1bnRpbCBpdCBpcyBzZXQgdG8gYSBuZXcgdmFsdWUgb3IgdW50aWwgYSBuZXcgZnJhZyBpcyBzdWNjZXNzZnVsbHkgbG9hZGVkXG4gICAgICAgIHRoaXMubGV2ZWwgPSBobHMubmV4dExvYWRMZXZlbCA9IHN0YXJ0TGV2ZWw7XG4gICAgICAgIHRoaXMubG9hZGVkbWV0YWRhdGEgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIGlmIHN0YXJ0UG9zaXRpb24gdW5kZWZpbmVkIGJ1dCBsYXN0Q3VycmVudFRpbWUgc2V0LCBzZXQgc3RhcnRQb3NpdGlvbiB0byBsYXN0IGN1cnJlbnRUaW1lXG4gICAgICBpZiAobGFzdEN1cnJlbnRUaW1lID4gMCAmJiBzdGFydFBvc2l0aW9uID09PSAtMSkge1xuICAgICAgICBsb2dnZXIubG9nKGBvdmVycmlkZSBzdGFydFBvc2l0aW9uIHdpdGggbGFzdEN1cnJlbnRUaW1lIEAke2xhc3RDdXJyZW50VGltZS50b0ZpeGVkKDMpfWApO1xuICAgICAgICBzdGFydFBvc2l0aW9uID0gbGFzdEN1cnJlbnRUaW1lO1xuICAgICAgfVxuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICB0aGlzLm5leHRMb2FkUG9zaXRpb24gPSB0aGlzLnN0YXJ0UG9zaXRpb24gPSB0aGlzLmxhc3RDdXJyZW50VGltZSA9IHN0YXJ0UG9zaXRpb247XG4gICAgICB0aGlzLnRpY2soKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5mb3JjZVN0YXJ0TG9hZCA9IHRydWU7XG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuU1RPUFBFRDtcbiAgICB9XG4gIH1cblxuICBzdG9wTG9hZCgpIHtcbiAgICB2YXIgZnJhZyA9IHRoaXMuZnJhZ0N1cnJlbnQ7XG4gICAgaWYgKGZyYWcpIHtcbiAgICAgIGlmIChmcmFnLmxvYWRlcikge1xuICAgICAgICBmcmFnLmxvYWRlci5hYm9ydCgpO1xuICAgICAgfVxuICAgICAgdGhpcy5mcmFnQ3VycmVudCA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMuZnJhZ1ByZXZpb3VzID0gbnVsbDtcbiAgICBpZiAodGhpcy5kZW11eGVyKSB7XG4gICAgICB0aGlzLmRlbXV4ZXIuZGVzdHJveSgpO1xuICAgICAgdGhpcy5kZW11eGVyID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5zdGF0ZSA9IFN0YXRlLlNUT1BQRUQ7XG4gICAgdGhpcy5mb3JjZVN0YXJ0TG9hZCA9IGZhbHNlO1xuICB9XG5cbiAgdGljaygpIHtcbiAgICB0aGlzLnRpY2tzKys7XG4gICAgaWYgKHRoaXMudGlja3MgPT09IDEpIHtcbiAgICAgIHRoaXMuZG9UaWNrKCk7XG4gICAgICBpZiAodGhpcy50aWNrcyA+IDEpIHtcbiAgICAgICAgc2V0VGltZW91dCh0aGlzLnRpY2ssIDEpO1xuICAgICAgfVxuICAgICAgdGhpcy50aWNrcyA9IDA7XG4gICAgfVxuICB9XG5cbiAgZG9UaWNrKCkge1xuICAgIHN3aXRjaCh0aGlzLnN0YXRlKSB7XG4gICAgICBjYXNlIFN0YXRlLkVSUk9SOlxuICAgICAgICAvL2Rvbid0IGRvIGFueXRoaW5nIGluIGVycm9yIHN0YXRlIHRvIGF2b2lkIGJyZWFraW5nIGZ1cnRoZXIgLi4uXG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBTdGF0ZS5CVUZGRVJfRkxVU0hJTkc6XG4gICAgICAvLyBpbiBidWZmZXIgZmx1c2hpbmcgc3RhdGUsIHJlc2V0IGZyYWdMb2FkRXJyb3IgY291bnRlclxuICAgICAgICB0aGlzLmZyYWdMb2FkRXJyb3IgPSAwO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgU3RhdGUuSURMRTpcbiAgICAgICAgLy8gd2hlbiB0aGlzIHJldHVybnMgZmFsc2UgdGhlcmUgd2FzIGFuIGVycm9yIGFuZCB3ZSBzaGFsbCByZXR1cm4gaW1tZWRpYXRseVxuICAgICAgICAvLyBmcm9tIGN1cnJlbnQgdGlja1xuICAgICAgICBpZiAoIXRoaXMuX2RvVGlja0lkbGUoKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgU3RhdGUuV0FJVElOR19MRVZFTDpcbiAgICAgICAgdmFyIGxldmVsID0gdGhpcy5sZXZlbHNbdGhpcy5sZXZlbF07XG4gICAgICAgIC8vIGNoZWNrIGlmIHBsYXlsaXN0IGlzIGFscmVhZHkgbG9hZGVkXG4gICAgICAgIGlmIChsZXZlbCAmJiBsZXZlbC5kZXRhaWxzKSB7XG4gICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFN0YXRlLkZSQUdfTE9BRElOR19XQUlUSU5HX1JFVFJZOlxuICAgICAgICB2YXIgbm93ID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIHZhciByZXRyeURhdGUgPSB0aGlzLnJldHJ5RGF0ZTtcbiAgICAgICAgLy8gaWYgY3VycmVudCB0aW1lIGlzIGd0IHRoYW4gcmV0cnlEYXRlLCBvciBpZiBtZWRpYSBzZWVraW5nIGxldCdzIHN3aXRjaCB0byBJRExFIHN0YXRlIHRvIHJldHJ5IGxvYWRpbmdcbiAgICAgICAgaWYoIXJldHJ5RGF0ZSB8fCAobm93ID49IHJldHJ5RGF0ZSkgfHwgKHRoaXMubWVkaWEgJiYgdGhpcy5tZWRpYS5zZWVraW5nKSkge1xuICAgICAgICAgIGxvZ2dlci5sb2coYG1lZGlhQ29udHJvbGxlcjogcmV0cnlEYXRlIHJlYWNoZWQsIHN3aXRjaCBiYWNrIHRvIElETEUgc3RhdGVgKTtcbiAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgU3RhdGUuRVJST1I6XG4gICAgICBjYXNlIFN0YXRlLlNUT1BQRUQ6XG4gICAgICBjYXNlIFN0YXRlLkZSQUdfTE9BRElORzpcbiAgICAgIGNhc2UgU3RhdGUuUEFSU0lORzpcbiAgICAgIGNhc2UgU3RhdGUuUEFSU0VEOlxuICAgICAgY2FzZSBTdGF0ZS5FTkRFRDpcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgLy8gY2hlY2sgYnVmZmVyXG4gICAgdGhpcy5fY2hlY2tCdWZmZXIoKTtcbiAgICAvLyBjaGVjay91cGRhdGUgY3VycmVudCBmcmFnbWVudFxuICAgIHRoaXMuX2NoZWNrRnJhZ21lbnRDaGFuZ2VkKCk7XG4gIH1cblxuICAvLyBJcm9uaWNhbGx5IHRoZSBcImlkbGVcIiBzdGF0ZSBpcyB0aGUgb24gd2UgZG8gdGhlIG1vc3QgbG9naWMgaW4gaXQgc2VlbXMgLi4uLlxuICAvLyBOT1RFOiBNYXliZSB3ZSBjb3VsZCByYXRoZXIgc2NoZWR1bGUgYSBjaGVjayBmb3IgYnVmZmVyIGxlbmd0aCBhZnRlciBoYWxmIG9mIHRoZSBjdXJyZW50bHlcbiAgLy8gICAgICAgcGxheWVkIHNlZ21lbnQsIG9yIG9uIHBhdXNlL3BsYXkvc2VlayBpbnN0ZWFkIG9mIG5haXZlbHkgY2hlY2tpbmcgZXZlcnkgMTAwbXM/XG4gIF9kb1RpY2tJZGxlKCkge1xuICAgIGNvbnN0IGhscyA9IHRoaXMuaGxzLFxuICAgICAgICAgIGNvbmZpZyA9IGhscy5jb25maWcsXG4gICAgICAgICAgbWVkaWEgPSB0aGlzLm1lZGlhO1xuXG4gICAgLy8gaWYgdmlkZW8gbm90IGF0dGFjaGVkIEFORFxuICAgIC8vIHN0YXJ0IGZyYWdtZW50IGFscmVhZHkgcmVxdWVzdGVkIE9SIHN0YXJ0IGZyYWcgcHJlZmV0Y2ggZGlzYWJsZVxuICAgIC8vIGV4aXQgbG9vcFxuICAgIC8vID0+IGlmIHN0YXJ0IGxldmVsIGxvYWRlZCBhbmQgbWVkaWEgbm90IGF0dGFjaGVkIGJ1dCBzdGFydCBmcmFnIHByZWZldGNoIGlzIGVuYWJsZWQgYW5kIHN0YXJ0IGZyYWcgbm90IHJlcXVlc3RlZCB5ZXQsIHdlIHdpbGwgbm90IGV4aXQgbG9vcFxuICAgIGlmICh0aGlzLmxldmVsTGFzdExvYWRlZCAhPT0gdW5kZWZpbmVkICYmICFtZWRpYSAmJlxuICAgICAgKHRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkIHx8ICFjb25maWcuc3RhcnRGcmFnUHJlZmV0Y2gpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBpZiB3ZSBoYXZlIG5vdCB5ZXQgbG9hZGVkIGFueSBmcmFnbWVudCwgc3RhcnQgbG9hZGluZyBmcm9tIHN0YXJ0IHBvc2l0aW9uXG4gICAgbGV0IHBvcyA9IDA7XG4gICAgaWYgKHRoaXMubG9hZGVkbWV0YWRhdGEpIHtcbiAgICAgIHBvcyA9IG1lZGlhLmN1cnJlbnRUaW1lO1xuICAgIH0gZWxzZSBpZiAodGhpcy5uZXh0TG9hZFBvc2l0aW9uKSB7XG4gICAgICBwb3MgPSB0aGlzLm5leHRMb2FkUG9zaXRpb247XG4gICAgfVxuXG4gICAgLy8gZGV0ZXJtaW5lIG5leHQgbG9hZCBsZXZlbFxuICAgIGxldCBsZXZlbCA9IGhscy5uZXh0TG9hZExldmVsLFxuICAgICAgICBsZXZlbEluZm8gPSB0aGlzLmxldmVsc1tsZXZlbF0sXG4gICAgICAgIGxldmVsQml0cmF0ZSA9IGxldmVsSW5mby5iaXRyYXRlLFxuICAgICAgICBtYXhCdWZMZW47XG5cbiAgICAvLyBjb21wdXRlIG1heCBCdWZmZXIgTGVuZ3RoIHRoYXQgd2UgY291bGQgZ2V0IGZyb20gdGhpcyBsb2FkIGxldmVsLCBiYXNlZCBvbiBsZXZlbCBiaXRyYXRlLiBkb24ndCBidWZmZXIgbW9yZSB0aGFuIDYwIE1CIGFuZCBtb3JlIHRoYW4gMzBzXG4gICAgaWYgKGxldmVsQml0cmF0ZSkge1xuICAgICAgbWF4QnVmTGVuID0gTWF0aC5tYXgoOCAqIGNvbmZpZy5tYXhCdWZmZXJTaXplIC8gbGV2ZWxCaXRyYXRlLCBjb25maWcubWF4QnVmZmVyTGVuZ3RoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWF4QnVmTGVuID0gY29uZmlnLm1heEJ1ZmZlckxlbmd0aDtcbiAgICB9XG4gICAgbWF4QnVmTGVuID0gTWF0aC5taW4obWF4QnVmTGVuLCBjb25maWcubWF4TWF4QnVmZmVyTGVuZ3RoKTtcblxuICAgIC8vIGRldGVybWluZSBuZXh0IGNhbmRpZGF0ZSBmcmFnbWVudCB0byBiZSBsb2FkZWQsIGJhc2VkIG9uIGN1cnJlbnQgcG9zaXRpb24gYW5kIGVuZCBvZiBidWZmZXIgcG9zaXRpb25cbiAgICAvLyBlbnN1cmUgdXAgdG8gYGNvbmZpZy5tYXhNYXhCdWZmZXJMZW5ndGhgIG9mIGJ1ZmZlciB1cGZyb250XG5cbiAgICBjb25zdCBidWZmZXJJbmZvID0gQnVmZmVySGVscGVyLmJ1ZmZlckluZm8odGhpcy5tZWRpYUJ1ZmZlciA/IHRoaXMubWVkaWFCdWZmZXIgOiBtZWRpYSwgcG9zLCBjb25maWcubWF4QnVmZmVySG9sZSksXG4gICAgICAgICAgYnVmZmVyTGVuID0gYnVmZmVySW5mby5sZW47XG4gICAgLy8gU3RheSBpZGxlIGlmIHdlIGFyZSBzdGlsbCB3aXRoIGJ1ZmZlciBtYXJnaW5zXG4gICAgaWYgKGJ1ZmZlckxlbiA+PSBtYXhCdWZMZW4pIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIGlmIGJ1ZmZlciBsZW5ndGggaXMgbGVzcyB0aGFuIG1heEJ1ZkxlbiB0cnkgdG8gbG9hZCBhIG5ldyBmcmFnbWVudCAuLi5cbiAgICBsb2dnZXIudHJhY2UoYGJ1ZmZlciBsZW5ndGggb2YgJHtidWZmZXJMZW4udG9GaXhlZCgzKX0gaXMgYmVsb3cgbWF4IG9mICR7bWF4QnVmTGVuLnRvRml4ZWQoMyl9LiBjaGVja2luZyBmb3IgbW9yZSBwYXlsb2FkIC4uLmApO1xuXG4gICAgLy8gc2V0IG5leHQgbG9hZCBsZXZlbCA6IHRoaXMgd2lsbCB0cmlnZ2VyIGEgcGxheWxpc3QgbG9hZCBpZiBuZWVkZWRcbiAgICB0aGlzLmxldmVsID0gaGxzLm5leHRMb2FkTGV2ZWwgPSBsZXZlbDtcblxuICAgIGNvbnN0IGxldmVsRGV0YWlscyA9IGxldmVsSW5mby5kZXRhaWxzO1xuICAgIC8vIGlmIGxldmVsIGluZm8gbm90IHJldHJpZXZlZCB5ZXQsIHN3aXRjaCBzdGF0ZSBhbmQgd2FpdCBmb3IgbGV2ZWwgcmV0cmlldmFsXG4gICAgLy8gaWYgbGl2ZSBwbGF5bGlzdCwgZW5zdXJlIHRoYXQgbmV3IHBsYXlsaXN0IGhhcyBiZWVuIHJlZnJlc2hlZCB0byBhdm9pZCBsb2FkaW5nL3RyeSB0byBsb2FkXG4gICAgLy8gYSB1c2VsZXNzIGFuZCBvdXRkYXRlZCBmcmFnbWVudCAodGhhdCBtaWdodCBldmVuIGludHJvZHVjZSBsb2FkIGVycm9yIGlmIGl0IGlzIGFscmVhZHkgb3V0IG9mIHRoZSBsaXZlIHBsYXlsaXN0KVxuICAgIGlmICh0eXBlb2YgbGV2ZWxEZXRhaWxzID09PSAndW5kZWZpbmVkJyB8fCBsZXZlbERldGFpbHMubGl2ZSAmJiB0aGlzLmxldmVsTGFzdExvYWRlZCAhPT0gbGV2ZWwpIHtcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5XQUlUSU5HX0xFVkVMO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gd2UganVzdCBnb3QgZG9uZSBsb2FkaW5nIHRoZSBmaW5hbCBmcmFnbWVudCwgY2hlY2sgaWYgd2UgbmVlZCB0byBmaW5hbGl6ZSBtZWRpYSBzdHJlYW1cbiAgICBsZXQgZnJhZ1ByZXZpb3VzID0gdGhpcy5mcmFnUHJldmlvdXM7XG4gICAgaWYgKCFsZXZlbERldGFpbHMubGl2ZSAmJiBmcmFnUHJldmlvdXMgJiYgZnJhZ1ByZXZpb3VzLnNuID09PSBsZXZlbERldGFpbHMuZW5kU04pIHtcbiAgICAgICAgLy8gZnJhZ1ByZXZpb3VzIGlzIGxhc3QgZnJhZ21lbnQuIHJldHJpZXZlIGxldmVsIGR1cmF0aW9uIHVzaW5nIGxhc3QgZnJhZyBzdGFydCBvZmZzZXQgKyBkdXJhdGlvblxuICAgICAgICAvLyByZWFsIGR1cmF0aW9uIG1pZ2h0IGJlIGxvd2VyIHRoYW4gaW5pdGlhbCBkdXJhdGlvbiBpZiB0aGVyZSBhcmUgZHJpZnRzIGJldHdlZW4gcmVhbCBmcmFnIGR1cmF0aW9uIGFuZCBwbGF5bGlzdCBzaWduYWxpbmdcbiAgICAgICAgY29uc3QgZHVyYXRpb24gPSBNYXRoLm1pbihtZWRpYS5kdXJhdGlvbixmcmFnUHJldmlvdXMuc3RhcnQgKyBmcmFnUHJldmlvdXMuZHVyYXRpb24pO1xuICAgICAgICAvLyBpZiBldmVyeXRoaW5nIChhbG1vc3QpIHRpbCB0aGUgZW5kIGlzIGJ1ZmZlcmVkLCBsZXQncyBzaWduYWwgZW9zXG4gICAgICAgIC8vIHdlIGRvbid0IGNvbXBhcmUgZXhhY3RseSBtZWRpYS5kdXJhdGlvbiA9PT0gYnVmZmVySW5mby5lbmQgYXMgdGhlcmUgY291bGQgYmUgc29tZSBzdWJ0bGUgbWVkaWEgZHVyYXRpb24gZGlmZmVyZW5jZVxuICAgICAgICAvLyB1c2luZyBoYWxmIGZyYWcgZHVyYXRpb24gc2hvdWxkIGhlbHAgY29wZSB3aXRoIHRoZXNlIGNhc2VzLlxuICAgICAgICAvLyBhbHNvIGNvcGUgd2l0aCBhbG1vc3QgemVybyBsYXN0IGZyYWcgZHVyYXRpb24gKG1heCBsYXN0IGZyYWcgZHVyYXRpb24gd2l0aCAyMDBtcykgcmVmZXIgdG8gaHR0cHM6Ly9naXRodWIuY29tL3ZpZGVvLWRldi9obHMuanMvcHVsbC82NTdcbiAgICAgICAgaWYgKGR1cmF0aW9uIC0gTWF0aC5tYXgoYnVmZmVySW5mby5lbmQsZnJhZ1ByZXZpb3VzLnN0YXJ0KSA8PSBNYXRoLm1heCgwLjIsZnJhZ1ByZXZpb3VzLmR1cmF0aW9uLzIpKSB7XG4gICAgICAgIC8vIEZpbmFsaXplIHRoZSBtZWRpYSBzdHJlYW1cbiAgICAgICAgbGV0IGRhdGEgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYWx0QXVkaW8pIHtcbiAgICAgICAgICBkYXRhLnR5cGUgPSAndmlkZW8nO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuQlVGRkVSX0VPUyxkYXRhKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkVOREVEO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBpZiB3ZSBoYXZlIHRoZSBsZXZlbERldGFpbHMgZm9yIHRoZSBzZWxlY3RlZCB2YXJpYW50LCBsZXRzIGNvbnRpbnVlIGVucmljaGVuIG91ciBzdHJlYW0gKGxvYWQga2V5cy9mcmFnbWVudHMgb3IgdHJpZ2dlciBFT1MsIGV0Yy4uKVxuICAgIHJldHVybiB0aGlzLl9mZXRjaFBheWxvYWRPckVvcyhwb3MsIGJ1ZmZlckluZm8sIGxldmVsRGV0YWlscyk7XG4gIH1cblxuICBfZmV0Y2hQYXlsb2FkT3JFb3MocG9zLCBidWZmZXJJbmZvLCBsZXZlbERldGFpbHMpIHtcbiAgICBjb25zdCBmcmFnUHJldmlvdXMgPSB0aGlzLmZyYWdQcmV2aW91cyxcbiAgICAgICAgICBsZXZlbCA9IHRoaXMubGV2ZWwsXG4gICAgICAgICAgZnJhZ21lbnRzID0gbGV2ZWxEZXRhaWxzLmZyYWdtZW50cyxcbiAgICAgICAgICBmcmFnTGVuID0gZnJhZ21lbnRzLmxlbmd0aDtcblxuICAgIC8vIGVtcHR5IHBsYXlsaXN0XG4gICAgaWYgKGZyYWdMZW4gPT09IDApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBmaW5kIGZyYWdtZW50IGluZGV4LCBjb250aWd1b3VzIHdpdGggZW5kIG9mIGJ1ZmZlciBwb3NpdGlvblxuICAgIGxldCBzdGFydCA9IGZyYWdtZW50c1swXS5zdGFydCxcbiAgICAgICAgZW5kID0gZnJhZ21lbnRzW2ZyYWdMZW4tMV0uc3RhcnQgKyBmcmFnbWVudHNbZnJhZ0xlbi0xXS5kdXJhdGlvbixcbiAgICAgICAgYnVmZmVyRW5kID0gYnVmZmVySW5mby5lbmQsXG4gICAgICAgIGZyYWc7XG5cbiAgICBpZiAobGV2ZWxEZXRhaWxzLmluaXRTZWdtZW50ICYmICFsZXZlbERldGFpbHMuaW5pdFNlZ21lbnQuZGF0YSkge1xuICAgICAgZnJhZyA9IGxldmVsRGV0YWlscy5pbml0U2VnbWVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaW4gY2FzZSBvZiBsaXZlIHBsYXlsaXN0IHdlIG5lZWQgdG8gZW5zdXJlIHRoYXQgcmVxdWVzdGVkIHBvc2l0aW9uIGlzIG5vdCBsb2NhdGVkIGJlZm9yZSBwbGF5bGlzdCBzdGFydFxuICAgICAgaWYgKGxldmVsRGV0YWlscy5saXZlKSB7XG4gICAgICAgIGxldCBpbml0aWFsTGl2ZU1hbmlmZXN0U2l6ZSA9IHRoaXMuY29uZmlnLmluaXRpYWxMaXZlTWFuaWZlc3RTaXplO1xuICAgICAgICBpZiAoZnJhZ0xlbiA8IGluaXRpYWxMaXZlTWFuaWZlc3RTaXplKSB7XG4gICAgICAgICAgbG9nZ2VyLndhcm4oYENhbiBub3Qgc3RhcnQgcGxheWJhY2sgb2YgYSBsZXZlbCwgcmVhc29uOiBub3QgZW5vdWdoIGZyYWdtZW50cyAke2ZyYWdMZW59IDwgJHtpbml0aWFsTGl2ZU1hbmlmZXN0U2l6ZX1gKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBmcmFnID0gdGhpcy5fZW5zdXJlRnJhZ21lbnRBdExpdmVQb2ludChsZXZlbERldGFpbHMsIGJ1ZmZlckVuZCwgc3RhcnQsIGVuZCwgZnJhZ1ByZXZpb3VzLCBmcmFnbWVudHMsIGZyYWdMZW4pO1xuICAgICAgICAvLyBpZiBpdCBleHBsaWNpdGVseSByZXR1cm5zIG51bGwgZG9uJ3QgbG9hZCBhbnkgZnJhZ21lbnQgYW5kIGV4aXQgZnVuY3Rpb24gbm93XG4gICAgICAgIGlmIChmcmFnID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFZvRCBwbGF5bGlzdDogaWYgYnVmZmVyRW5kIGJlZm9yZSBzdGFydCBvZiBwbGF5bGlzdCwgbG9hZCBmaXJzdCBmcmFnbWVudFxuICAgICAgICBpZiAoYnVmZmVyRW5kIDwgc3RhcnQpIHtcbiAgICAgICAgICBmcmFnID0gZnJhZ21lbnRzWzBdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghZnJhZykge1xuICAgICAgZnJhZyA9IHRoaXMuX2ZpbmRGcmFnbWVudChzdGFydCwgZnJhZ1ByZXZpb3VzLCBmcmFnTGVuLCBmcmFnbWVudHMsIGJ1ZmZlckVuZCwgZW5kLCBsZXZlbERldGFpbHMpO1xuICAgIH1cbiAgICBpZihmcmFnKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbG9hZEZyYWdtZW50T3JLZXkoZnJhZywgbGV2ZWwsIGxldmVsRGV0YWlscywgcG9zLCBidWZmZXJFbmQpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIF9lbnN1cmVGcmFnbWVudEF0TGl2ZVBvaW50KGxldmVsRGV0YWlscywgYnVmZmVyRW5kLCBzdGFydCwgZW5kLCBmcmFnUHJldmlvdXMsIGZyYWdtZW50cywgZnJhZ0xlbikge1xuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuaGxzLmNvbmZpZywgbWVkaWEgPSB0aGlzLm1lZGlhO1xuXG4gICAgbGV0IGZyYWc7XG5cbiAgICAvLyBjaGVjayBpZiByZXF1ZXN0ZWQgcG9zaXRpb24gaXMgd2l0aGluIHNlZWthYmxlIGJvdW5kYXJpZXMgOlxuICAgIC8vbG9nZ2VyLmxvZyhgc3RhcnQvcG9zL2J1ZkVuZC9zZWVraW5nOiR7c3RhcnQudG9GaXhlZCgzKX0vJHtwb3MudG9GaXhlZCgzKX0vJHtidWZmZXJFbmQudG9GaXhlZCgzKX0vJHt0aGlzLm1lZGlhLnNlZWtpbmd9YCk7XG4gICAgbGV0IG1heExhdGVuY3kgPSBjb25maWcubGl2ZU1heExhdGVuY3lEdXJhdGlvbiAhPT0gdW5kZWZpbmVkID8gY29uZmlnLmxpdmVNYXhMYXRlbmN5RHVyYXRpb24gOiBjb25maWcubGl2ZU1heExhdGVuY3lEdXJhdGlvbkNvdW50KmxldmVsRGV0YWlscy50YXJnZXRkdXJhdGlvbjtcblxuICAgIGlmIChidWZmZXJFbmQgPCBNYXRoLm1heChzdGFydC1jb25maWcubWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSwgZW5kIC0gbWF4TGF0ZW5jeSkpIHtcbiAgICAgICAgbGV0IGxpdmVTeW5jUG9zaXRpb24gPSB0aGlzLmxpdmVTeW5jUG9zaXRpb24gPSB0aGlzLmNvbXB1dGVMaXZlUG9zaXRpb24oc3RhcnQsIGxldmVsRGV0YWlscyk7XG4gICAgICAgIGxvZ2dlci5sb2coYGJ1ZmZlciBlbmQ6ICR7YnVmZmVyRW5kLnRvRml4ZWQoMyl9IGlzIGxvY2F0ZWQgdG9vIGZhciBmcm9tIHRoZSBlbmQgb2YgbGl2ZSBzbGlkaW5nIHBsYXlsaXN0LCByZXNldCBjdXJyZW50VGltZSB0byA6ICR7bGl2ZVN5bmNQb3NpdGlvbi50b0ZpeGVkKDMpfWApO1xuICAgICAgICBidWZmZXJFbmQgPSBsaXZlU3luY1Bvc2l0aW9uO1xuICAgICAgICBpZiAobWVkaWEgJiYgbWVkaWEucmVhZHlTdGF0ZSAmJiBtZWRpYS5kdXJhdGlvbiA+IGxpdmVTeW5jUG9zaXRpb24pIHtcbiAgICAgICAgICBtZWRpYS5jdXJyZW50VGltZSA9IGxpdmVTeW5jUG9zaXRpb247XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBpZiBlbmQgb2YgYnVmZmVyIGdyZWF0ZXIgdGhhbiBsaXZlIGVkZ2UsIGRvbid0IGxvYWQgYW55IGZyYWdtZW50XG4gICAgLy8gdGhpcyBjb3VsZCBoYXBwZW4gaWYgbGl2ZSBwbGF5bGlzdCBpbnRlcm1pdHRlbnRseSBzbGlkZXMgaW4gdGhlIHBhc3QuXG4gICAgLy8gbGV2ZWwgMSBsb2FkZWQgWzE4MjU4MDE2MSwxODI1ODAxNjddXG4gICAgLy8gbGV2ZWwgMSBsb2FkZWQgWzE4MjU4MDE2MiwxODI1ODAxNjldXG4gICAgLy8gTG9hZGluZyAxODI1ODAxNjggb2YgWzE4MjU4MDE2MiAsMTgyNTgwMTY5XSxsZXZlbCAxIC4uXG4gICAgLy8gTG9hZGluZyAxODI1ODAxNjkgb2YgWzE4MjU4MDE2MiAsMTgyNTgwMTY5XSxsZXZlbCAxIC4uXG4gICAgLy8gbGV2ZWwgMSBsb2FkZWQgWzE4MjU4MDE2MiwxODI1ODAxNjhdIDw9PT09PT09PT09PT09IGhlcmUgd2Ugc2hvdWxkIGhhdmUgYnVmZmVyRW5kID4gZW5kLiBpbiB0aGF0IGNhc2UgYnJlYWsgdG8gYXZvaWQgcmVsb2FkaW5nIDE4MjU4MDE2OFxuICAgIC8vIGxldmVsIDEgbG9hZGVkIFsxODI1ODAxNjQsMTgyNTgwMTcxXVxuICAgIC8vXG4gICAgLy8gZG9uJ3QgcmV0dXJuIG51bGwgaW4gY2FzZSBtZWRpYSBub3QgbG9hZGVkIHlldCAocmVhZHlzdGF0ZSA9PT0gMClcbiAgICBpZiAobGV2ZWxEZXRhaWxzLlBUU0tub3duICYmIGJ1ZmZlckVuZCA+IGVuZCAmJiBtZWRpYSAmJiBtZWRpYS5yZWFkeVN0YXRlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgJiYgIWxldmVsRGV0YWlscy5QVFNLbm93bikge1xuICAgICAgLyogd2UgYXJlIHN3aXRjaGluZyBsZXZlbCBvbiBsaXZlIHBsYXlsaXN0LCBidXQgd2UgZG9uJ3QgaGF2ZSBhbnkgUFRTIGluZm8gZm9yIHRoYXQgcXVhbGl0eSBsZXZlbCAuLi5cbiAgICAgICAgIHRyeSB0byBsb2FkIGZyYWcgbWF0Y2hpbmcgd2l0aCBuZXh0IFNOLlxuICAgICAgICAgZXZlbiBpZiBTTiBhcmUgbm90IHN5bmNocm9uaXplZCBiZXR3ZWVuIHBsYXlsaXN0cywgbG9hZGluZyB0aGlzIGZyYWcgd2lsbCBoZWxwIHVzXG4gICAgICAgICBjb21wdXRlIHBsYXlsaXN0IHNsaWRpbmcgYW5kIGZpbmQgdGhlIHJpZ2h0IG9uZSBhZnRlciBpbiBjYXNlIGl0IHdhcyBub3QgdGhlIHJpZ2h0IGNvbnNlY3V0aXZlIG9uZSAqL1xuICAgICAgaWYgKGZyYWdQcmV2aW91cykge1xuICAgICAgICB2YXIgdGFyZ2V0U04gPSBmcmFnUHJldmlvdXMuc24gKyAxO1xuICAgICAgICB2YXIgdGFyZ2V0Q0MgPSBmcmFnUHJldmlvdXMuY2MgKyAxO1xuICAgICAgICBpZiAodGFyZ2V0U04gPj0gbGV2ZWxEZXRhaWxzLnN0YXJ0U04gJiYgdGFyZ2V0U04gPD0gbGV2ZWxEZXRhaWxzLmVuZFNOKSB7XG4gICAgICAgICAgZnJhZyA9IGZyYWdtZW50c1t0YXJnZXRTTiAtIGxldmVsRGV0YWlscy5zdGFydFNOXTtcbiAgICAgICAgICBsb2dnZXIubG9nKGBsaXZlIHBsYXlsaXN0LCBzd2l0Y2hpbmcgcGxheWxpc3QsIGxvYWQgZnJhZyB3aXRoIG5leHQgU046ICR7ZnJhZy5zbn1gKTtcbiAgICAgICAgfSBlbHNlIGlmICh0YXJnZXRDQyA+PSBsZXZlbERldGFpbHMuc3RhcnRDQyAmJiB0YXJnZXRDQyA8PSBsZXZlbERldGFpbHMuZW5kQ0MpIHtcbiAgICAgICAgICBmcmFnID0gZmluZEZpcnN0RnJhZ1dpdGhDQyhmcmFnbWVudHMsIHRhcmdldENDKTtcbiAgICAgICAgICBsb2dnZXIubG9nKGBMaXZlIHBsYXlsaXN0IHN3aXRjaCwgY2Fubm90IGZpbmQgZnJhZyB3aXRoIHRhcmdldCBTTi4gTG9hZGluZyBmcmFnIHdpdGggbmV4dCBDQzogJHsgZnJhZy5jYyB9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghZnJhZykge1xuICAgICAgICAvKiB3ZSBoYXZlIG5vIGlkZWEgYWJvdXQgd2hpY2ggZnJhZ21lbnQgc2hvdWxkIGJlIGxvYWRlZC5cbiAgICAgICAgICAgc28gbGV0J3MgbG9hZCBtaWQgZnJhZ21lbnQuIGl0IHdpbGwgaGVscCBjb21wdXRpbmcgcGxheWxpc3Qgc2xpZGluZyBhbmQgZmluZCB0aGUgcmlnaHQgb25lXG4gICAgICAgICovXG4gICAgICAgIGZyYWcgPSBmcmFnbWVudHNbTWF0aC5taW4oZnJhZ0xlbiAtIDEsIE1hdGgucm91bmQoZnJhZ0xlbiAvIDIpKV07XG4gICAgICAgIGxvZ2dlci5sb2coYGxpdmUgcGxheWxpc3QsIHN3aXRjaGluZyBwbGF5bGlzdCwgdW5rbm93biwgbG9hZCBtaWRkbGUgZnJhZyA6ICR7ZnJhZy5zbn1gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZyYWc7XG4gIH1cblxuICBfZmluZEZyYWdtZW50KHN0YXJ0LCBmcmFnUHJldmlvdXMsIGZyYWdMZW4sIGZyYWdtZW50cywgYnVmZmVyRW5kLCBlbmQsIGxldmVsRGV0YWlscykge1xuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuaGxzLmNvbmZpZztcbiAgICBsZXQgZnJhZztcbiAgICBsZXQgZm91bmRGcmFnO1xuICAgIGxldCBtYXhGcmFnTG9va1VwVG9sZXJhbmNlID0gY29uZmlnLm1heEZyYWdMb29rVXBUb2xlcmFuY2U7XG4gICAgY29uc3QgZnJhZ05leHQgPSBmcmFnUHJldmlvdXMgPyBmcmFnbWVudHNbZnJhZ1ByZXZpb3VzLnNuIC0gZnJhZ21lbnRzWzBdLnNuICsgMV0gOiB1bmRlZmluZWQ7XG4gICAgbGV0IGZyYWdtZW50V2l0aGluVG9sZXJhbmNlVGVzdCA9IChjYW5kaWRhdGUpID0+IHtcbiAgICAgIC8vIG9mZnNldCBzaG91bGQgYmUgd2l0aGluIGZyYWdtZW50IGJvdW5kYXJ5IC0gY29uZmlnLm1heEZyYWdMb29rVXBUb2xlcmFuY2VcbiAgICAgIC8vIHRoaXMgaXMgdG8gY29wZSB3aXRoIHNpdHVhdGlvbnMgbGlrZVxuICAgICAgLy8gYnVmZmVyRW5kID0gOS45OTFcbiAgICAgIC8vIGZyYWdbw5hdIDogWzAsMTBdXG4gICAgICAvLyBmcmFnWzFdIDogWzEwLDIwXVxuICAgICAgLy8gYnVmZmVyRW5kIGlzIHdpdGhpbiBmcmFnWzBdIHJhbmdlIC4uLiBhbHRob3VnaCB3aGF0IHdlIGFyZSBleHBlY3RpbmcgaXMgdG8gcmV0dXJuIGZyYWdbMV0gaGVyZVxuICAgICAgLy8gICAgICAgICAgICAgIGZyYWcgc3RhcnQgICAgICAgICAgICAgICBmcmFnIHN0YXJ0K2R1cmF0aW9uXG4gICAgICAvLyAgICAgICAgICAgICAgICAgIHwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXxcbiAgICAgIC8vICAgICAgICAgICAgICA8LS0tPiAgICAgICAgICAgICAgICAgICAgICAgICA8LS0tPlxuICAgICAgLy8gIC4uLi0tLS0tLS0tPjwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLT48LS0tLS0tLS0tLi4uLlxuICAgICAgLy8gcHJldmlvdXMgZnJhZyAgICAgICAgIG1hdGNoaW5nIGZyYWdtZW50ICAgICAgICAgbmV4dCBmcmFnXG4gICAgICAvLyAgcmV0dXJuIC0xICAgICAgICAgICAgIHJldHVybiAwICAgICAgICAgICAgICAgICByZXR1cm4gMVxuICAgICAgLy9sb2dnZXIubG9nKGBsZXZlbC9zbi9zdGFydC9lbmQvYnVmRW5kOiR7bGV2ZWx9LyR7Y2FuZGlkYXRlLnNufS8ke2NhbmRpZGF0ZS5zdGFydH0vJHsoY2FuZGlkYXRlLnN0YXJ0K2NhbmRpZGF0ZS5kdXJhdGlvbil9LyR7YnVmZmVyRW5kfWApO1xuICAgICAgLy8gU2V0IHRoZSBsb29rdXAgdG9sZXJhbmNlIHRvIGJlIHNtYWxsIGVub3VnaCB0byBkZXRlY3QgdGhlIGN1cnJlbnQgc2VnbWVudCAtIGVuc3VyZXMgd2UgZG9uJ3Qgc2tpcCBvdmVyIHZlcnkgc21hbGwgc2VnbWVudHNcbiAgICAgIGxldCBjYW5kaWRhdGVMb29rdXBUb2xlcmFuY2UgPSBNYXRoLm1pbihtYXhGcmFnTG9va1VwVG9sZXJhbmNlLCBjYW5kaWRhdGUuZHVyYXRpb24pO1xuICAgICAgaWYgKGNhbmRpZGF0ZS5zdGFydCArIGNhbmRpZGF0ZS5kdXJhdGlvbiAtIGNhbmRpZGF0ZUxvb2t1cFRvbGVyYW5jZSA8PSBidWZmZXJFbmQpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9IC8vIGlmIG1heEZyYWdMb29rVXBUb2xlcmFuY2Ugd2lsbCBoYXZlIG5lZ2F0aXZlIHZhbHVlIHRoZW4gZG9uJ3QgcmV0dXJuIC0xIGZvciBmaXJzdCBlbGVtZW50XG4gICAgICBlbHNlIGlmIChjYW5kaWRhdGUuc3RhcnQgLSBjYW5kaWRhdGVMb29rdXBUb2xlcmFuY2UgPiBidWZmZXJFbmQgJiYgY2FuZGlkYXRlLnN0YXJ0KSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAwO1xuICAgIH07XG5cbiAgICBpZiAoYnVmZmVyRW5kIDwgZW5kKSB7XG4gICAgICBpZiAoYnVmZmVyRW5kID4gZW5kIC0gbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSkge1xuICAgICAgICBtYXhGcmFnTG9va1VwVG9sZXJhbmNlID0gMDtcbiAgICAgIH1cbiAgICAgIC8vIFByZWZlciB0aGUgbmV4dCBmcmFnbWVudCBpZiBpdCdzIHdpdGhpbiB0b2xlcmFuY2VcbiAgICAgIGlmIChmcmFnTmV4dCAmJiAhZnJhZ21lbnRXaXRoaW5Ub2xlcmFuY2VUZXN0KGZyYWdOZXh0KSkge1xuICAgICAgICBmb3VuZEZyYWcgPSBmcmFnTmV4dDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvdW5kRnJhZyA9IEJpbmFyeVNlYXJjaC5zZWFyY2goZnJhZ21lbnRzLCBmcmFnbWVudFdpdGhpblRvbGVyYW5jZVRlc3QpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyByZWFjaCBlbmQgb2YgcGxheWxpc3RcbiAgICAgIGZvdW5kRnJhZyA9IGZyYWdtZW50c1tmcmFnTGVuLTFdO1xuICAgIH1cbiAgICBpZiAoZm91bmRGcmFnKSB7XG4gICAgICBmcmFnID0gZm91bmRGcmFnO1xuICAgICAgY29uc3QgY3VyU05JZHggPSBmcmFnLnNuIC0gbGV2ZWxEZXRhaWxzLnN0YXJ0U047XG4gICAgICBjb25zdCBzYW1lTGV2ZWwgPSBmcmFnUHJldmlvdXMgJiYgZnJhZy5sZXZlbCA9PT0gZnJhZ1ByZXZpb3VzLmxldmVsO1xuICAgICAgY29uc3QgcHJldkZyYWcgPSBmcmFnbWVudHNbY3VyU05JZHggLSAxXTtcbiAgICAgIGNvbnN0IG5leHRGcmFnID0gZnJhZ21lbnRzW2N1clNOSWR4ICsgMV07XG4gICAgICAvL2xvZ2dlci5sb2coJ2ZpbmQgU04gbWF0Y2hpbmcgd2l0aCBwb3M6JyArICBidWZmZXJFbmQgKyAnOicgKyBmcmFnLnNuKTtcbiAgICAgICBpZiAoc2FtZUxldmVsICYmIGZyYWcuc24gPT09IGZyYWdQcmV2aW91cy5zbikge1xuICAgICAgICAgIGlmIChmcmFnLnNuIDwgbGV2ZWxEZXRhaWxzLmVuZFNOKSB7XG4gICAgICAgICAgICBsZXQgZGVsdGFQVFMgPSBmcmFnUHJldmlvdXMuZGVsdGFQVFM7XG4gICAgICAgICAgICAvLyBpZiB0aGVyZSBpcyBhIHNpZ25pZmljYW50IGRlbHRhIGJldHdlZW4gYXVkaW8gYW5kIHZpZGVvLCBsYXJnZXIgdGhhbiBtYXggYWxsb3dlZCBob2xlLFxuICAgICAgICAgICAgLy8gYW5kIGlmIHByZXZpb3VzIHJlbXV4ZWQgZnJhZ21lbnQgZGlkIG5vdCBzdGFydCB3aXRoIGEga2V5ZnJhbWUuIChmcmFnUHJldmlvdXMuZHJvcHBlZClcbiAgICAgICAgICAgIC8vIGxldCdzIHRyeSB0byBsb2FkIHByZXZpb3VzIGZyYWdtZW50IGFnYWluIHRvIGdldCBsYXN0IGtleWZyYW1lXG4gICAgICAgICAgICAvLyB0aGVuIHdlIHdpbGwgcmVsb2FkIGFnYWluIGN1cnJlbnQgZnJhZ21lbnQgKHRoYXQgd2F5IHdlIHNob3VsZCBiZSBhYmxlIHRvIGZpbGwgdGhlIGJ1ZmZlciBob2xlIC4uLilcbiAgICAgICAgICAgIGlmIChkZWx0YVBUUyAmJiBkZWx0YVBUUyA+IGNvbmZpZy5tYXhCdWZmZXJIb2xlICYmIGZyYWdQcmV2aW91cy5kcm9wcGVkICYmIGN1clNOSWR4ICYmICFmcmFnLmJhY2t0cmFja2VkKSB7XG4gICAgICAgICAgICAgIGZyYWcgPSBwcmV2RnJhZztcbiAgICAgICAgICAgICAgbG9nZ2VyLndhcm4oYFNOIGp1c3QgbG9hZGVkLCB3aXRoIGxhcmdlIFBUUyBnYXAgYmV0d2VlbiBhdWRpbyBhbmQgdmlkZW8sIG1heWJlIGZyYWcgaXMgbm90IHN0YXJ0aW5nIHdpdGggYSBrZXlmcmFtZSA/IGxvYWQgcHJldmlvdXMgb25lIHRvIHRyeSB0byBvdmVyY29tZSB0aGlzYCk7XG4gICAgICAgICAgICAgIC8vIGRlY3JlbWVudCBwcmV2aW91cyBmcmFnIGxvYWQgY291bnRlciB0byBhdm9pZCBmcmFnIGxvb3AgbG9hZGluZyBlcnJvciB3aGVuIG5leHQgZnJhZ21lbnQgd2lsbCBnZXQgcmVsb2FkZWRcbiAgICAgICAgICAgICAgZnJhZ1ByZXZpb3VzLmxvYWRDb3VudGVyLS07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBmcmFnID0gbmV4dEZyYWc7XG4gICAgICAgICAgICAgIGxvZ2dlci5sb2coYFNOIGp1c3QgbG9hZGVkLCBsb2FkIG5leHQgb25lOiAke2ZyYWcuc259YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZyYWcgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChmcmFnLmRyb3BwZWQgJiYgIXNhbWVMZXZlbCkge1xuICAgICAgICAgLy8gT25seSBiYWNrdHJhY2sgYSBtYXggb2YgMSBjb25zZWN1dGl2ZSBmcmFnbWVudCB0byBwcmV2ZW50IHNsaWRpbmcgYmFjayB0b28gZmFyIHdoZW4gbGl0dGxlIG9yIG5vIGZyYWdzIHN0YXJ0IHdpdGgga2V5ZnJhbWVzXG4gICAgICAgICBpZiAobmV4dEZyYWcgJiYgbmV4dEZyYWcuYmFja3RyYWNrZWQpIHtcbiAgICAgICAgICAgbG9nZ2VyLndhcm4oYEFscmVhZHkgYmFja3RyYWNrZWQgZnJvbSBmcmFnbWVudCAke2N1clNOSWR4ICsgMX0sIHdpbGwgbm90IGJhY2t0cmFjayB0byBmcmFnbWVudCAke2N1clNOSWR4fS4gTG9hZGluZyBmcmFnbWVudCAke2N1clNOSWR4ICsgMX1gKTtcbiAgICAgICAgICAgZnJhZyA9IG5leHRGcmFnO1xuICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgLy8gSWYgYSBmcmFnbWVudCBoYXMgZHJvcHBlZCBmcmFtZXMgYW5kIGl0J3MgaW4gYSBkaWZmZXJlbnQgbGV2ZWwvc2VxdWVuY2UsIGxvYWQgdGhlIHByZXZpb3VzIGZyYWdtZW50IHRvIHRyeSBhbmQgZmluZCB0aGUga2V5ZnJhbWVcbiAgICAgICAgICAgLy8gUmVzZXQgdGhlIGRyb3BwZWQgY291bnQgbm93IHNpbmNlIGl0IHdvbid0IGJlIHJlc2V0IHVudGlsIHdlIHBhcnNlIHRoZSBmcmFnbWVudCBhZ2Fpbiwgd2hpY2ggcHJldmVudHMgaW5maW5pdGUgYmFja3RyYWNraW5nIG9uIHRoZSBzYW1lIHNlZ21lbnRcbiAgICAgICAgICAgbG9nZ2VyLndhcm4oJ0xvYWRlZCBmcmFnbWVudCB3aXRoIGRyb3BwZWQgZnJhbWVzLCBiYWNrdHJhY2tpbmcgMSBzZWdtZW50IHRvIGZpbmQgYSBrZXlmcmFtZScpO1xuICAgICAgICAgICBmcmFnLmRyb3BwZWQgPSAwO1xuICAgICAgICAgICBpZiAocHJldkZyYWcpIHtcbiAgICAgICAgICAgICBpZiAocHJldkZyYWcubG9hZENvdW50ZXIpIHtcbiAgICAgICAgICAgICAgIHByZXZGcmFnLmxvYWRDb3VudGVyLS07XG4gICAgICAgICAgICAgfVxuICAgICAgICAgICAgIGZyYWcgPSBwcmV2RnJhZztcbiAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICBmcmFnID0gbnVsbDtcbiAgICAgICAgICAgfVxuICAgICAgICAgfVxuICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZyYWc7XG4gIH1cblxuICBfbG9hZEZyYWdtZW50T3JLZXkoZnJhZywgbGV2ZWwsIGxldmVsRGV0YWlscywgcG9zLCBidWZmZXJFbmQpIHtcbiAgICBjb25zdCBobHMgPSB0aGlzLmhscyxcbiAgICAgICAgICBjb25maWcgPSBobHMuY29uZmlnO1xuXG4gICAgLy9sb2dnZXIubG9nKCdsb2FkaW5nIGZyYWcgJyArIGkgKycscG9zL2J1ZkVuZDonICsgcG9zLnRvRml4ZWQoMykgKyAnLycgKyBidWZmZXJFbmQudG9GaXhlZCgzKSk7XG4gICAgaWYgKChmcmFnLmRlY3J5cHRkYXRhICYmIGZyYWcuZGVjcnlwdGRhdGEudXJpICE9IG51bGwpICYmIChmcmFnLmRlY3J5cHRkYXRhLmtleSA9PSBudWxsKSkge1xuICAgICAgbG9nZ2VyLmxvZyhgTG9hZGluZyBrZXkgZm9yICR7ZnJhZy5zbn0gb2YgWyR7bGV2ZWxEZXRhaWxzLnN0YXJ0U059ICwke2xldmVsRGV0YWlscy5lbmRTTn1dLGxldmVsICR7bGV2ZWx9YCk7XG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuS0VZX0xPQURJTkc7XG4gICAgICBobHMudHJpZ2dlcihFdmVudC5LRVlfTE9BRElORywge2ZyYWc6IGZyYWd9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbG9nZ2VyLmxvZyhgTG9hZGluZyAke2ZyYWcuc259IG9mIFske2xldmVsRGV0YWlscy5zdGFydFNOfSAsJHtsZXZlbERldGFpbHMuZW5kU059XSxsZXZlbCAke2xldmVsfSwgY3VycmVudFRpbWU6JHtwb3MudG9GaXhlZCgzKX0sYnVmZmVyRW5kOiR7YnVmZmVyRW5kfWApO1xuICAgICAgLy8gZW5zdXJlIHRoYXQgd2UgYXJlIG5vdCByZWxvYWRpbmcgdGhlIHNhbWUgZnJhZ21lbnRzIGluIGxvb3AgLi4uXG4gICAgICBpZiAodGhpcy5mcmFnTG9hZElkeCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuZnJhZ0xvYWRJZHgrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZnJhZ0xvYWRJZHggPSAwO1xuICAgICAgfVxuICAgICAgaWYgKGZyYWcubG9hZENvdW50ZXIpIHtcbiAgICAgICAgZnJhZy5sb2FkQ291bnRlcisrO1xuICAgICAgICBsZXQgbWF4VGhyZXNob2xkID0gY29uZmlnLmZyYWdMb2FkaW5nTG9vcFRocmVzaG9sZDtcbiAgICAgICAgLy8gaWYgdGhpcyBmcmFnIGhhcyBhbHJlYWR5IGJlZW4gbG9hZGVkIDMgdGltZXMsIGFuZCBpZiBpdCBoYXMgYmVlbiByZWxvYWRlZCByZWNlbnRseVxuICAgICAgICBpZiAoZnJhZy5sb2FkQ291bnRlciA+IG1heFRocmVzaG9sZCAmJiAoTWF0aC5hYnModGhpcy5mcmFnTG9hZElkeCAtIGZyYWcubG9hZElkeCkgPCBtYXhUaHJlc2hvbGQpKSB7XG4gICAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnQuRVJST1IsIHt0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLCBkZXRhaWxzOiBFcnJvckRldGFpbHMuRlJBR19MT09QX0xPQURJTkdfRVJST1IsIGZhdGFsOiBmYWxzZSwgZnJhZzogZnJhZ30pO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZnJhZy5sb2FkQ291bnRlciA9IDE7XG4gICAgICB9XG4gICAgICBmcmFnLmxvYWRJZHggPSB0aGlzLmZyYWdMb2FkSWR4O1xuICAgICAgdGhpcy5mcmFnQ3VycmVudCA9IGZyYWc7XG4gICAgICB0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCA9IHRydWU7XG4gICAgICBpZiAoIWlzTmFOKGZyYWcuc24pKSB7XG4gICAgICAgIHRoaXMubmV4dExvYWRQb3NpdGlvbiA9IGZyYWcuc3RhcnQgKyBmcmFnLmR1cmF0aW9uO1xuICAgICAgfVxuICAgICAgZnJhZy5hdXRvTGV2ZWwgPSBobHMuYXV0b0xldmVsRW5hYmxlZDtcbiAgICAgIGZyYWcuYml0cmF0ZVRlc3QgPSB0aGlzLmJpdHJhdGVUZXN0O1xuICAgICAgaGxzLnRyaWdnZXIoRXZlbnQuRlJBR19MT0FESU5HLCB7ZnJhZzogZnJhZ30pO1xuICAgICAgLy8gbGF6eSBkZW11eGVyIGluaXQsIGFzIHRoaXMgY291bGQgdGFrZSBzb21lIHRpbWUgLi4uIGRvIGl0IGR1cmluZyBmcmFnIGxvYWRpbmdcbiAgICAgIGlmICghdGhpcy5kZW11eGVyKSB7XG4gICAgICAgIHRoaXMuZGVtdXhlciA9IG5ldyBEZW11eGVyKGhscywnbWFpbicpO1xuICAgICAgfVxuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkZSQUdfTE9BRElORztcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHNldCBzdGF0ZShuZXh0U3RhdGUpIHtcbiAgICBpZiAodGhpcy5zdGF0ZSAhPT0gbmV4dFN0YXRlKSB7XG4gICAgICBjb25zdCBwcmV2aW91c1N0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICAgIHRoaXMuX3N0YXRlID0gbmV4dFN0YXRlO1xuICAgICAgbG9nZ2VyLmxvZyhgbWFpbiBzdHJlYW06JHtwcmV2aW91c1N0YXRlfS0+JHtuZXh0U3RhdGV9YCk7XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LlNUUkVBTV9TVEFURV9UUkFOU0lUSU9OLCB7cHJldmlvdXNTdGF0ZSwgbmV4dFN0YXRlfSk7XG4gICAgfVxuICB9XG5cbiAgZ2V0IHN0YXRlKCkge1xuICAgIHJldHVybiB0aGlzLl9zdGF0ZTtcbiAgfVxuXG4gIGdldEJ1ZmZlcmVkRnJhZyhwb3NpdGlvbikge1xuICAgIHJldHVybiBCaW5hcnlTZWFyY2guc2VhcmNoKHRoaXMuX2J1ZmZlcmVkRnJhZ3MsIGZ1bmN0aW9uKGZyYWcpIHtcbiAgICAgIGlmIChwb3NpdGlvbiA8IGZyYWcuc3RhcnRQVFMpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfSBlbHNlIGlmIChwb3NpdGlvbiA+IGZyYWcuZW5kUFRTKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuICAgICAgcmV0dXJuIDA7XG4gICAgfSk7XG4gIH1cblxuICBnZXQgY3VycmVudExldmVsKCkge1xuICAgIGxldCBtZWRpYSA9IHRoaXMubWVkaWE7XG4gICAgaWYgKG1lZGlhKSB7XG4gICAgICBjb25zdCBmcmFnID0gdGhpcy5nZXRCdWZmZXJlZEZyYWcobWVkaWEuY3VycmVudFRpbWUpO1xuICAgICAgaWYgKGZyYWcpIHtcbiAgICAgICAgcmV0dXJuIGZyYWcubGV2ZWw7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIGdldCBuZXh0QnVmZmVyZWRGcmFnKCkge1xuICAgIGxldCBtZWRpYSA9IHRoaXMubWVkaWE7XG4gICAgaWYgKG1lZGlhKSB7XG4gICAgICAvLyBmaXJzdCBnZXQgZW5kIHJhbmdlIG9mIGN1cnJlbnQgZnJhZ21lbnRcbiAgICAgIHJldHVybiB0aGlzLmZvbGxvd2luZ0J1ZmZlcmVkRnJhZyh0aGlzLmdldEJ1ZmZlcmVkRnJhZyhtZWRpYS5jdXJyZW50VGltZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICBmb2xsb3dpbmdCdWZmZXJlZEZyYWcoZnJhZykge1xuICAgIGlmIChmcmFnKSB7XG4gICAgICAvLyB0cnkgdG8gZ2V0IHJhbmdlIG9mIG5leHQgZnJhZ21lbnQgKDUwMG1zIGFmdGVyIHRoaXMgcmFuZ2UpXG4gICAgICByZXR1cm4gdGhpcy5nZXRCdWZmZXJlZEZyYWcoZnJhZy5lbmRQVFMgKyAwLjUpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGdldCBuZXh0TGV2ZWwoKSB7XG4gICAgY29uc3QgZnJhZyA9IHRoaXMubmV4dEJ1ZmZlcmVkRnJhZztcbiAgICBpZiAoZnJhZykge1xuICAgICAgcmV0dXJuIGZyYWcubGV2ZWw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gIH1cblxuICBfY2hlY2tGcmFnbWVudENoYW5nZWQoKSB7XG4gICAgdmFyIGZyYWdQbGF5aW5nQ3VycmVudCwgY3VycmVudFRpbWUsIHZpZGVvID0gdGhpcy5tZWRpYTtcbiAgICBpZiAodmlkZW8gJiYgdmlkZW8ucmVhZHlTdGF0ZSAmJiB2aWRlby5zZWVraW5nID09PSBmYWxzZSkge1xuICAgICAgY3VycmVudFRpbWUgPSB2aWRlby5jdXJyZW50VGltZTtcbiAgICAgIC8qIGlmIHZpZGVvIGVsZW1lbnQgaXMgaW4gc2Vla2VkIHN0YXRlLCBjdXJyZW50VGltZSBjYW4gb25seSBpbmNyZWFzZS5cbiAgICAgICAgKGFzc3VtaW5nIHRoYXQgcGxheWJhY2sgcmF0ZSBpcyBwb3NpdGl2ZSAuLi4pXG4gICAgICAgIEFzIHNvbWV0aW1lcyBjdXJyZW50VGltZSBqdW1wcyBiYWNrIHRvIHplcm8gYWZ0ZXIgYVxuICAgICAgICBtZWRpYSBkZWNvZGUgZXJyb3IsIGNoZWNrIHRoaXMsIHRvIGF2b2lkIHNlZWtpbmcgYmFjayB0b1xuICAgICAgICB3cm9uZyBwb3NpdGlvbiBhZnRlciBhIG1lZGlhIGRlY29kZSBlcnJvclxuICAgICAgKi9cbiAgICAgIGlmKGN1cnJlbnRUaW1lID4gdmlkZW8ucGxheWJhY2tSYXRlKnRoaXMubGFzdEN1cnJlbnRUaW1lKSB7XG4gICAgICAgIHRoaXMubGFzdEN1cnJlbnRUaW1lID0gY3VycmVudFRpbWU7XG4gICAgICB9XG4gICAgICBpZiAoQnVmZmVySGVscGVyLmlzQnVmZmVyZWQodmlkZW8sY3VycmVudFRpbWUpKSB7XG4gICAgICAgIGZyYWdQbGF5aW5nQ3VycmVudCA9IHRoaXMuZ2V0QnVmZmVyZWRGcmFnKGN1cnJlbnRUaW1lKTtcbiAgICAgIH0gZWxzZSBpZiAoQnVmZmVySGVscGVyLmlzQnVmZmVyZWQodmlkZW8sY3VycmVudFRpbWUgKyAwLjEpKSB7XG4gICAgICAgIC8qIGVuc3VyZSB0aGF0IEZSQUdfQ0hBTkdFRCBldmVudCBpcyB0cmlnZ2VyZWQgYXQgc3RhcnR1cCxcbiAgICAgICAgICB3aGVuIGZpcnN0IHZpZGVvIGZyYW1lIGlzIGRpc3BsYXllZCBhbmQgcGxheWJhY2sgaXMgcGF1c2VkLlxuICAgICAgICAgIGFkZCBhIHRvbGVyYW5jZSBvZiAxMDBtcywgaW4gY2FzZSBjdXJyZW50IHBvc2l0aW9uIGlzIG5vdCBidWZmZXJlZCxcbiAgICAgICAgICBjaGVjayBpZiBjdXJyZW50IHBvcysxMDBtcyBpcyBidWZmZXJlZCBhbmQgdXNlIHRoYXQgYnVmZmVyIHJhbmdlXG4gICAgICAgICAgZm9yIEZSQUdfQ0hBTkdFRCBldmVudCByZXBvcnRpbmcgKi9cbiAgICAgICAgZnJhZ1BsYXlpbmdDdXJyZW50ID0gdGhpcy5nZXRCdWZmZXJlZEZyYWcoY3VycmVudFRpbWUgKyAwLjEpO1xuICAgICAgfVxuICAgICAgaWYgKGZyYWdQbGF5aW5nQ3VycmVudCkge1xuICAgICAgICB2YXIgZnJhZ1BsYXlpbmcgPSBmcmFnUGxheWluZ0N1cnJlbnQ7XG4gICAgICAgIGlmIChmcmFnUGxheWluZyAhPT0gdGhpcy5mcmFnUGxheWluZykge1xuICAgICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuRlJBR19DSEFOR0VELCB7ZnJhZzogZnJhZ1BsYXlpbmd9KTtcbiAgICAgICAgICBjb25zdCBmcmFnUGxheWluZ0xldmVsID0gZnJhZ1BsYXlpbmcubGV2ZWw7XG4gICAgICAgICAgaWYgKCF0aGlzLmZyYWdQbGF5aW5nIHx8IHRoaXMuZnJhZ1BsYXlpbmcubGV2ZWwgIT09IGZyYWdQbGF5aW5nTGV2ZWwpIHtcbiAgICAgICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuTEVWRUxfU1dJVENIRUQsIHtsZXZlbDogZnJhZ1BsYXlpbmdMZXZlbH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmZyYWdQbGF5aW5nID0gZnJhZ1BsYXlpbmc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKlxuICAgIG9uIGltbWVkaWF0ZSBsZXZlbCBzd2l0Y2ggOlxuICAgICAtIHBhdXNlIHBsYXliYWNrIGlmIHBsYXlpbmdcbiAgICAgLSBjYW5jZWwgYW55IHBlbmRpbmcgbG9hZCByZXF1ZXN0XG4gICAgIC0gYW5kIHRyaWdnZXIgYSBidWZmZXIgZmx1c2hcbiAgKi9cbiAgaW1tZWRpYXRlTGV2ZWxTd2l0Y2goKSB7XG4gICAgbG9nZ2VyLmxvZygnaW1tZWRpYXRlTGV2ZWxTd2l0Y2gnKTtcbiAgICBpZiAoIXRoaXMuaW1tZWRpYXRlU3dpdGNoKSB7XG4gICAgICB0aGlzLmltbWVkaWF0ZVN3aXRjaCA9IHRydWU7XG4gICAgICBsZXQgbWVkaWEgPSB0aGlzLm1lZGlhLCBwcmV2aW91c2x5UGF1c2VkO1xuICAgICAgaWYgKG1lZGlhKSB7XG4gICAgICAgIHByZXZpb3VzbHlQYXVzZWQgPSBtZWRpYS5wYXVzZWQ7XG4gICAgICAgIG1lZGlhLnBhdXNlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBkb24ndCByZXN0YXJ0IHBsYXliYWNrIGFmdGVyIGluc3RhbnQgbGV2ZWwgc3dpdGNoIGluIGNhc2UgbWVkaWEgbm90IGF0dGFjaGVkXG4gICAgICAgIHByZXZpb3VzbHlQYXVzZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgdGhpcy5wcmV2aW91c2x5UGF1c2VkID0gcHJldmlvdXNseVBhdXNlZDtcbiAgICB9XG4gICAgdmFyIGZyYWdDdXJyZW50ID0gdGhpcy5mcmFnQ3VycmVudDtcbiAgICBpZiAoZnJhZ0N1cnJlbnQgJiYgZnJhZ0N1cnJlbnQubG9hZGVyKSB7XG4gICAgICBmcmFnQ3VycmVudC5sb2FkZXIuYWJvcnQoKTtcbiAgICB9XG4gICAgdGhpcy5mcmFnQ3VycmVudCA9IG51bGw7XG4gICAgLy8gaW5jcmVhc2UgZnJhZ21lbnQgbG9hZCBJbmRleCB0byBhdm9pZCBmcmFnIGxvb3AgbG9hZGluZyBlcnJvciBhZnRlciBidWZmZXIgZmx1c2hcbiAgICB0aGlzLmZyYWdMb2FkSWR4ICs9IDIgKiB0aGlzLmNvbmZpZy5mcmFnTG9hZGluZ0xvb3BUaHJlc2hvbGQ7XG4gICAgLy8gZmx1c2ggZXZlcnl0aGluZ1xuICAgIHRoaXMuZmx1c2hNYWluQnVmZmVyKDAsTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKTtcbiAgfVxuXG4gIC8qXG4gICAgIG9uIGltbWVkaWF0ZSBsZXZlbCBzd2l0Y2ggZW5kLCBhZnRlciBuZXcgZnJhZ21lbnQgaGFzIGJlZW4gYnVmZmVyZWQgOlxuICAgICAgLSBudWRnZSB2aWRlbyBkZWNvZGVyIGJ5IHNsaWdodGx5IGFkanVzdGluZyB2aWRlbyBjdXJyZW50VGltZSAoaWYgY3VycmVudFRpbWUgYnVmZmVyZWQpXG4gICAgICAtIHJlc3VtZSB0aGUgcGxheWJhY2sgaWYgbmVlZGVkXG4gICovXG4gIGltbWVkaWF0ZUxldmVsU3dpdGNoRW5kKCkge1xuICAgIGxldCBtZWRpYSA9IHRoaXMubWVkaWE7XG4gICAgaWYgKG1lZGlhICYmIG1lZGlhLmJ1ZmZlcmVkLmxlbmd0aCkge1xuICAgICAgdGhpcy5pbW1lZGlhdGVTd2l0Y2ggPSBmYWxzZTtcbiAgICAgIGlmKEJ1ZmZlckhlbHBlci5pc0J1ZmZlcmVkKG1lZGlhLG1lZGlhLmN1cnJlbnRUaW1lKSkge1xuICAgICAgICAvLyBvbmx5IG51ZGdlIGlmIGN1cnJlbnRUaW1lIGlzIGJ1ZmZlcmVkXG4gICAgICAgIG1lZGlhLmN1cnJlbnRUaW1lIC09IDAuMDAwMTtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5wcmV2aW91c2x5UGF1c2VkKSB7XG4gICAgICAgIG1lZGlhLnBsYXkoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBuZXh0TGV2ZWxTd2l0Y2goKSB7XG4gICAgLyogdHJ5IHRvIHN3aXRjaCBBU0FQIHdpdGhvdXQgYnJlYWtpbmcgdmlkZW8gcGxheWJhY2sgOlxuICAgICAgIGluIG9yZGVyIHRvIGVuc3VyZSBzbW9vdGggYnV0IHF1aWNrIGxldmVsIHN3aXRjaGluZyxcbiAgICAgIHdlIG5lZWQgdG8gZmluZCB0aGUgbmV4dCBmbHVzaGFibGUgYnVmZmVyIHJhbmdlXG4gICAgICB3ZSBzaG91bGQgdGFrZSBpbnRvIGFjY291bnQgbmV3IHNlZ21lbnQgZmV0Y2ggdGltZVxuICAgICovXG4gICAgbGV0IG1lZGlhID0gdGhpcy5tZWRpYTtcbiAgICAvLyBlbnN1cmUgdGhhdCBtZWRpYSBpcyBkZWZpbmVkIGFuZCB0aGF0IG1ldGFkYXRhIGFyZSBhdmFpbGFibGUgKHRvIHJldHJpZXZlIGN1cnJlbnRUaW1lKVxuICAgIGlmIChtZWRpYSAmJiBtZWRpYS5yZWFkeVN0YXRlKSB7XG4gICAgICBsZXQgZmV0Y2hkZWxheSwgZnJhZ1BsYXlpbmdDdXJyZW50LCBuZXh0QnVmZmVyZWRGcmFnO1xuICAgICAgLy8gaW5jcmVhc2UgZnJhZ21lbnQgbG9hZCBJbmRleCB0byBhdm9pZCBmcmFnIGxvb3AgbG9hZGluZyBlcnJvciBhZnRlciBidWZmZXIgZmx1c2hcbiAgICAgIHRoaXMuZnJhZ0xvYWRJZHggKz0gMiAqIHRoaXMuY29uZmlnLmZyYWdMb2FkaW5nTG9vcFRocmVzaG9sZDtcbiAgICAgIGZyYWdQbGF5aW5nQ3VycmVudCA9IHRoaXMuZ2V0QnVmZmVyZWRGcmFnKG1lZGlhLmN1cnJlbnRUaW1lKTtcbiAgICAgIGlmIChmcmFnUGxheWluZ0N1cnJlbnQgJiYgZnJhZ1BsYXlpbmdDdXJyZW50LnN0YXJ0UFRTID4gMSkge1xuICAgICAgICAvLyBmbHVzaCBidWZmZXIgcHJlY2VkaW5nIGN1cnJlbnQgZnJhZ21lbnQgKGZsdXNoIHVudGlsIGN1cnJlbnQgZnJhZ21lbnQgc3RhcnQgb2Zmc2V0KVxuICAgICAgICAvLyBtaW51cyAxcyB0byBhdm9pZCB2aWRlbyBmcmVlemluZywgdGhhdCBjb3VsZCBoYXBwZW4gaWYgd2UgZmx1c2gga2V5ZnJhbWUgb2YgY3VycmVudCB2aWRlbyAuLi5cbiAgICAgICAgdGhpcy5mbHVzaE1haW5CdWZmZXIoMCxmcmFnUGxheWluZ0N1cnJlbnQuc3RhcnRQVFMgLSAxKTtcbiAgICAgIH1cbiAgICAgIGlmICghbWVkaWEucGF1c2VkKSB7XG4gICAgICAgIC8vIGFkZCBhIHNhZmV0eSBkZWxheSBvZiAxc1xuICAgICAgICB2YXIgbmV4dExldmVsSWQgPSB0aGlzLmhscy5uZXh0TG9hZExldmVsLG5leHRMZXZlbCA9IHRoaXMubGV2ZWxzW25leHRMZXZlbElkXSwgZnJhZ0xhc3RLYnBzID0gdGhpcy5mcmFnTGFzdEticHM7XG4gICAgICAgIGlmIChmcmFnTGFzdEticHMgJiYgdGhpcy5mcmFnQ3VycmVudCkge1xuICAgICAgICAgIGZldGNoZGVsYXkgPSB0aGlzLmZyYWdDdXJyZW50LmR1cmF0aW9uICogbmV4dExldmVsLmJpdHJhdGUgLyAoMTAwMCAqIGZyYWdMYXN0S2JwcykgKyAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZldGNoZGVsYXkgPSAwO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmZXRjaGRlbGF5ID0gMDtcbiAgICAgIH1cbiAgICAgIC8vbG9nZ2VyLmxvZygnZmV0Y2hkZWxheTonK2ZldGNoZGVsYXkpO1xuICAgICAgLy8gZmluZCBidWZmZXIgcmFuZ2UgdGhhdCB3aWxsIGJlIHJlYWNoZWQgb25jZSBuZXcgZnJhZ21lbnQgd2lsbCBiZSBmZXRjaGVkXG4gICAgICBuZXh0QnVmZmVyZWRGcmFnID0gdGhpcy5nZXRCdWZmZXJlZEZyYWcobWVkaWEuY3VycmVudFRpbWUgKyBmZXRjaGRlbGF5KTtcbiAgICAgIGlmIChuZXh0QnVmZmVyZWRGcmFnKSB7XG4gICAgICAgIC8vIHdlIGNhbiBmbHVzaCBidWZmZXIgcmFuZ2UgZm9sbG93aW5nIHRoaXMgb25lIHdpdGhvdXQgc3RhbGxpbmcgcGxheWJhY2tcbiAgICAgICAgbmV4dEJ1ZmZlcmVkRnJhZyA9IHRoaXMuZm9sbG93aW5nQnVmZmVyZWRGcmFnKG5leHRCdWZmZXJlZEZyYWcpO1xuICAgICAgICBpZiAobmV4dEJ1ZmZlcmVkRnJhZykge1xuICAgICAgICAgIC8vIGlmIHdlIGFyZSBoZXJlLCB3ZSBjYW4gYWxzbyBjYW5jZWwgYW55IGxvYWRpbmcvZGVtdXhpbmcgaW4gcHJvZ3Jlc3MsIGFzIHRoZXkgYXJlIHVzZWxlc3NcbiAgICAgICAgICB2YXIgZnJhZ0N1cnJlbnQgPSB0aGlzLmZyYWdDdXJyZW50O1xuICAgICAgICAgIGlmIChmcmFnQ3VycmVudCAmJiBmcmFnQ3VycmVudC5sb2FkZXIpIHtcbiAgICAgICAgICAgIGZyYWdDdXJyZW50LmxvYWRlci5hYm9ydCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmZyYWdDdXJyZW50ID0gbnVsbDtcbiAgICAgICAgICAvLyBmbHVzaCBwb3NpdGlvbiBpcyB0aGUgc3RhcnQgcG9zaXRpb24gb2YgdGhpcyBuZXcgYnVmZmVyXG4gICAgICAgICAgdGhpcy5mbHVzaE1haW5CdWZmZXIobmV4dEJ1ZmZlcmVkRnJhZy5zdGFydFBUUyAsIE51bWJlci5QT1NJVElWRV9JTkZJTklUWSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmbHVzaE1haW5CdWZmZXIoc3RhcnRPZmZzZXQsZW5kT2Zmc2V0KSB7XG4gICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkJVRkZFUl9GTFVTSElORztcbiAgICBsZXQgZmx1c2hTY29wZSA9IHtzdGFydE9mZnNldDogc3RhcnRPZmZzZXQsIGVuZE9mZnNldDogZW5kT2Zmc2V0fTtcbiAgICAvLyBpZiBhbHRlcm5hdGUgYXVkaW8gdHJhY2tzIGFyZSB1c2VkLCBvbmx5IGZsdXNoIHZpZGVvLCBvdGhlcndpc2UgZmx1c2ggZXZlcnl0aGluZ1xuICAgIGlmICh0aGlzLmFsdEF1ZGlvKSB7XG4gICAgICBmbHVzaFNjb3BlLnR5cGUgPSAndmlkZW8nO1xuICAgIH1cbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkJVRkZFUl9GTFVTSElORywgZmx1c2hTY29wZSk7XG4gIH1cblxuICBvbk1lZGlhQXR0YWNoZWQoZGF0YSkge1xuICAgIHZhciBtZWRpYSA9IHRoaXMubWVkaWEgPSB0aGlzLm1lZGlhQnVmZmVyID0gZGF0YS5tZWRpYTtcbiAgICB0aGlzLm9udnNlZWtpbmcgPSB0aGlzLm9uTWVkaWFTZWVraW5nLmJpbmQodGhpcyk7XG4gICAgdGhpcy5vbnZzZWVrZWQgPSB0aGlzLm9uTWVkaWFTZWVrZWQuYmluZCh0aGlzKTtcbiAgICB0aGlzLm9udmVuZGVkID0gdGhpcy5vbk1lZGlhRW5kZWQuYmluZCh0aGlzKTtcbiAgICBtZWRpYS5hZGRFdmVudExpc3RlbmVyKCdzZWVraW5nJywgdGhpcy5vbnZzZWVraW5nKTtcbiAgICBtZWRpYS5hZGRFdmVudExpc3RlbmVyKCdzZWVrZWQnLCB0aGlzLm9udnNlZWtlZCk7XG4gICAgbWVkaWEuYWRkRXZlbnRMaXN0ZW5lcignZW5kZWQnLCB0aGlzLm9udmVuZGVkKTtcbiAgICBsZXQgY29uZmlnID0gdGhpcy5jb25maWc7XG4gICAgaWYodGhpcy5sZXZlbHMgJiYgY29uZmlnLmF1dG9TdGFydExvYWQpIHtcbiAgICAgIHRoaXMuaGxzLnN0YXJ0TG9hZChjb25maWcuc3RhcnRQb3NpdGlvbik7XG4gICAgfVxuICB9XG5cbiAgb25NZWRpYURldGFjaGluZygpIHtcbiAgICB2YXIgbWVkaWEgPSB0aGlzLm1lZGlhO1xuICAgIGlmIChtZWRpYSAmJiBtZWRpYS5lbmRlZCkge1xuICAgICAgbG9nZ2VyLmxvZygnTVNFIGRldGFjaGluZyBhbmQgdmlkZW8gZW5kZWQsIHJlc2V0IHN0YXJ0UG9zaXRpb24nKTtcbiAgICAgIHRoaXMuc3RhcnRQb3NpdGlvbiA9IHRoaXMubGFzdEN1cnJlbnRUaW1lID0gMDtcbiAgICB9XG5cbiAgICAvLyByZXNldCBmcmFnbWVudCBsb2FkaW5nIGNvdW50ZXIgb24gTVNFIGRldGFjaGluZyB0byBhdm9pZCByZXBvcnRpbmcgRlJBR19MT09QX0xPQURJTkdfRVJST1IgYWZ0ZXIgZXJyb3IgcmVjb3ZlcnlcbiAgICB2YXIgbGV2ZWxzID0gdGhpcy5sZXZlbHM7XG4gICAgaWYgKGxldmVscykge1xuICAgICAgLy8gcmVzZXQgZnJhZ21lbnQgbG9hZCBjb3VudGVyXG4gICAgICAgIGxldmVscy5mb3JFYWNoKGxldmVsID0+IHtcbiAgICAgICAgICBpZihsZXZlbC5kZXRhaWxzKSB7XG4gICAgICAgICAgICBsZXZlbC5kZXRhaWxzLmZyYWdtZW50cy5mb3JFYWNoKGZyYWdtZW50ID0+IHtcbiAgICAgICAgICAgICAgZnJhZ21lbnQubG9hZENvdW50ZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgIGZyYWdtZW50LmJhY2t0cmFja2VkID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIC8vIHJlbW92ZSB2aWRlbyBsaXN0ZW5lcnNcbiAgICBpZiAobWVkaWEpIHtcbiAgICAgIG1lZGlhLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3NlZWtpbmcnLCB0aGlzLm9udnNlZWtpbmcpO1xuICAgICAgbWVkaWEucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Vla2VkJywgdGhpcy5vbnZzZWVrZWQpO1xuICAgICAgbWVkaWEucmVtb3ZlRXZlbnRMaXN0ZW5lcignZW5kZWQnLCB0aGlzLm9udmVuZGVkKTtcbiAgICAgIHRoaXMub252c2Vla2luZyA9IHRoaXMub252c2Vla2VkICA9IHRoaXMub252ZW5kZWQgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLm1lZGlhID0gdGhpcy5tZWRpYUJ1ZmZlciA9IG51bGw7XG4gICAgdGhpcy5sb2FkZWRtZXRhZGF0YSA9IGZhbHNlO1xuICAgIHRoaXMuc3RvcExvYWQoKTtcbiAgfVxuXG4gIG9uTWVkaWFTZWVraW5nKCkge1xuICAgIGxldCBtZWRpYSA9IHRoaXMubWVkaWEsIGN1cnJlbnRUaW1lID0gbWVkaWEgPyBtZWRpYS5jdXJyZW50VGltZSA6IHVuZGVmaW5lZCwgY29uZmlnID0gdGhpcy5jb25maWc7XG4gICAgbG9nZ2VyLmxvZyhgbWVkaWEgc2Vla2luZyB0byAke2N1cnJlbnRUaW1lLnRvRml4ZWQoMyl9YCk7XG4gICAgaWYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLkZSQUdfTE9BRElORykge1xuICAgICAgbGV0IG1lZGlhQnVmZmVyID0gdGhpcy5tZWRpYUJ1ZmZlciA/IHRoaXMubWVkaWFCdWZmZXIgOiBtZWRpYTtcbiAgICAgIGxldCBidWZmZXJJbmZvID0gQnVmZmVySGVscGVyLmJ1ZmZlckluZm8obWVkaWFCdWZmZXIsY3VycmVudFRpbWUsdGhpcy5jb25maWcubWF4QnVmZmVySG9sZSksXG4gICAgICAgICAgZnJhZ0N1cnJlbnQgPSB0aGlzLmZyYWdDdXJyZW50O1xuICAgICAgLy8gY2hlY2sgaWYgd2UgYXJlIHNlZWtpbmcgdG8gYSB1bmJ1ZmZlcmVkIGFyZWEgQU5EIGlmIGZyYWcgbG9hZGluZyBpcyBpbiBwcm9ncmVzc1xuICAgICAgaWYgKGJ1ZmZlckluZm8ubGVuID09PSAwICYmIGZyYWdDdXJyZW50KSB7XG4gICAgICAgIGxldCB0b2xlcmFuY2UgPSBjb25maWcubWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSxcbiAgICAgICAgICAgIGZyYWdTdGFydE9mZnNldCA9IGZyYWdDdXJyZW50LnN0YXJ0IC0gdG9sZXJhbmNlLFxuICAgICAgICAgICAgZnJhZ0VuZE9mZnNldCA9IGZyYWdDdXJyZW50LnN0YXJ0ICsgZnJhZ0N1cnJlbnQuZHVyYXRpb24gKyB0b2xlcmFuY2U7XG4gICAgICAgIC8vIGNoZWNrIGlmIHdlIHNlZWsgcG9zaXRpb24gd2lsbCBiZSBvdXQgb2YgY3VycmVudGx5IGxvYWRlZCBmcmFnIHJhbmdlIDogaWYgb3V0IGNhbmNlbCBmcmFnIGxvYWQsIGlmIGluLCBkb24ndCBkbyBhbnl0aGluZ1xuICAgICAgICBpZiAoY3VycmVudFRpbWUgPCBmcmFnU3RhcnRPZmZzZXQgfHwgY3VycmVudFRpbWUgPiBmcmFnRW5kT2Zmc2V0KSB7XG4gICAgICAgICAgaWYgKGZyYWdDdXJyZW50LmxvYWRlcikge1xuICAgICAgICAgICAgbG9nZ2VyLmxvZygnc2Vla2luZyBvdXRzaWRlIG9mIGJ1ZmZlciB3aGlsZSBmcmFnbWVudCBsb2FkIGluIHByb2dyZXNzLCBjYW5jZWwgZnJhZ21lbnQgbG9hZCcpO1xuICAgICAgICAgICAgZnJhZ0N1cnJlbnQubG9hZGVyLmFib3J0KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuZnJhZ0N1cnJlbnQgPSBudWxsO1xuICAgICAgICAgIHRoaXMuZnJhZ1ByZXZpb3VzID0gbnVsbDtcbiAgICAgICAgICAvLyBzd2l0Y2ggdG8gSURMRSBzdGF0ZSB0byBsb2FkIG5ldyBmcmFnbWVudFxuICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxvZ2dlci5sb2coJ3NlZWtpbmcgb3V0c2lkZSBvZiBidWZmZXIgYnV0IHdpdGhpbiBjdXJyZW50bHkgbG9hZGVkIGZyYWdtZW50IHJhbmdlJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLkVOREVEKSB7XG4gICAgICAgIC8vIHN3aXRjaCB0byBJRExFIHN0YXRlIHRvIGNoZWNrIGZvciBwb3RlbnRpYWwgbmV3IGZyYWdtZW50XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgIH1cbiAgICBpZiAobWVkaWEpIHtcbiAgICAgIHRoaXMubGFzdEN1cnJlbnRUaW1lID0gY3VycmVudFRpbWU7XG4gICAgfVxuICAgIC8vIGF2b2lkIHJlcG9ydGluZyBmcmFnbWVudCBsb29wIGxvYWRpbmcgZXJyb3IgaW4gY2FzZSB1c2VyIGlzIHNlZWtpbmcgc2V2ZXJhbCB0aW1lcyBvbiBzYW1lIHBvc2l0aW9uXG4gICAgaWYgKHRoaXMuc3RhdGUgIT09IFN0YXRlLkZSQUdfTE9BRElORyAmJiB0aGlzLmZyYWdMb2FkSWR4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuZnJhZ0xvYWRJZHggKz0gMiAqIGNvbmZpZy5mcmFnTG9hZGluZ0xvb3BUaHJlc2hvbGQ7XG4gICAgfVxuICAgIC8vIGluIGNhc2Ugc2Vla2luZyBvY2N1cnMgYWx0aG91Z2ggbm8gbWVkaWEgYnVmZmVyZWQsIGFkanVzdCBzdGFydFBvc2l0aW9uIGFuZCBuZXh0TG9hZFBvc2l0aW9uIHRvIHNlZWsgdGFyZ2V0XG4gICAgaWYoIXRoaXMubG9hZGVkbWV0YWRhdGEpIHtcbiAgICAgIHRoaXMubmV4dExvYWRQb3NpdGlvbiA9IHRoaXMuc3RhcnRQb3NpdGlvbiA9IGN1cnJlbnRUaW1lO1xuICAgIH1cbiAgICAvLyB0aWNrIHRvIHNwZWVkIHVwIHByb2Nlc3NpbmdcbiAgICB0aGlzLnRpY2soKTtcbiAgfVxuXG4gIG9uTWVkaWFTZWVrZWQoKSB7XG4gICAgbG9nZ2VyLmxvZyhgbWVkaWEgc2Vla2VkIHRvICR7dGhpcy5tZWRpYS5jdXJyZW50VGltZS50b0ZpeGVkKDMpfWApO1xuICAgIC8vIHRpY2sgdG8gc3BlZWQgdXAgRlJBR01FTlRfUExBWUlORyB0cmlnZ2VyaW5nXG4gICAgdGhpcy50aWNrKCk7XG4gIH1cblxuICBvbk1lZGlhRW5kZWQoKSB7XG4gICAgbG9nZ2VyLmxvZygnbWVkaWEgZW5kZWQnKTtcbiAgICAvLyByZXNldCBzdGFydFBvc2l0aW9uIGFuZCBsYXN0Q3VycmVudFRpbWUgdG8gcmVzdGFydCBwbGF5YmFjayBAIHN0cmVhbSBiZWdpbm5pbmdcbiAgICB0aGlzLnN0YXJ0UG9zaXRpb24gPSB0aGlzLmxhc3RDdXJyZW50VGltZSA9IDA7XG4gIH1cblxuXG4gIG9uTWFuaWZlc3RMb2FkaW5nKCkge1xuICAgIC8vIHJlc2V0IGJ1ZmZlciBvbiBtYW5pZmVzdCBsb2FkaW5nXG4gICAgbG9nZ2VyLmxvZygndHJpZ2dlciBCVUZGRVJfUkVTRVQnKTtcbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkJVRkZFUl9SRVNFVCk7XG4gICAgdGhpcy5fYnVmZmVyZWRGcmFncyA9IFtdO1xuICAgIHRoaXMuc3RhbGxlZCA9IGZhbHNlO1xuICAgIHRoaXMuc3RhcnRQb3NpdGlvbiA9IHRoaXMubGFzdEN1cnJlbnRUaW1lID0gMDtcbiAgfVxuXG4gIG9uTWFuaWZlc3RQYXJzZWQoZGF0YSkge1xuICAgIHZhciBhYWMgPSBmYWxzZSwgaGVhYWMgPSBmYWxzZSwgY29kZWM7XG4gICAgZGF0YS5sZXZlbHMuZm9yRWFjaChsZXZlbCA9PiB7XG4gICAgICAvLyBkZXRlY3QgaWYgd2UgaGF2ZSBkaWZmZXJlbnQga2luZCBvZiBhdWRpbyBjb2RlY3MgdXNlZCBhbW9uZ3N0IHBsYXlsaXN0c1xuICAgICAgY29kZWMgPSBsZXZlbC5hdWRpb0NvZGVjO1xuICAgICAgaWYgKGNvZGVjKSB7XG4gICAgICAgIGlmIChjb2RlYy5pbmRleE9mKCdtcDRhLjQwLjInKSAhPT0gLTEpIHtcbiAgICAgICAgICBhYWMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb2RlYy5pbmRleE9mKCdtcDRhLjQwLjUnKSAhPT0gLTEpIHtcbiAgICAgICAgICBoZWFhYyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLmF1ZGlvQ29kZWNTd2l0Y2ggPSAoYWFjICYmIGhlYWFjKTtcbiAgICBpZiAodGhpcy5hdWRpb0NvZGVjU3dpdGNoKSB7XG4gICAgICBsb2dnZXIubG9nKCdib3RoIEFBQy9IRS1BQUMgYXVkaW8gZm91bmQgaW4gbGV2ZWxzOyBkZWNsYXJpbmcgbGV2ZWwgY29kZWMgYXMgSEUtQUFDJyk7XG4gICAgfVxuICAgIHRoaXMubGV2ZWxzID0gZGF0YS5sZXZlbHM7XG4gICAgdGhpcy5zdGFydExldmVsTG9hZGVkID0gZmFsc2U7XG4gICAgdGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgPSBmYWxzZTtcbiAgICBsZXQgY29uZmlnID0gdGhpcy5jb25maWc7XG4gICAgaWYgKGNvbmZpZy5hdXRvU3RhcnRMb2FkIHx8IHRoaXMuZm9yY2VTdGFydExvYWQpIHtcbiAgICAgIHRoaXMuaGxzLnN0YXJ0TG9hZChjb25maWcuc3RhcnRQb3NpdGlvbik7XG4gICAgfVxuICB9XG5cbiAgb25MZXZlbExvYWRlZChkYXRhKSB7XG4gICAgY29uc3QgbmV3RGV0YWlscyA9IGRhdGEuZGV0YWlscztcbiAgICBjb25zdCBuZXdMZXZlbElkID0gZGF0YS5sZXZlbDtcbiAgICBjb25zdCBsYXN0TGV2ZWwgPSB0aGlzLmxldmVsc1t0aGlzLmxldmVsTGFzdExvYWRlZF07XG4gICAgY29uc3QgY3VyTGV2ZWwgPSB0aGlzLmxldmVsc1tuZXdMZXZlbElkXTtcbiAgICBjb25zdCBkdXJhdGlvbiA9IG5ld0RldGFpbHMudG90YWxkdXJhdGlvbjtcbiAgICBsZXQgc2xpZGluZyA9IDA7XG5cbiAgICBsb2dnZXIubG9nKGBsZXZlbCAke25ld0xldmVsSWR9IGxvYWRlZCBbJHtuZXdEZXRhaWxzLnN0YXJ0U059LCR7bmV3RGV0YWlscy5lbmRTTn1dLCBjYyBbJHtuZXdEZXRhaWxzLnN0YXJ0Q0N9LCAke25ld0RldGFpbHMuZW5kQ0N9XSBkdXJhdGlvbjoke2R1cmF0aW9ufWApO1xuXG4gICAgaWYgKG5ld0RldGFpbHMubGl2ZSkge1xuICAgICAgY29uc3QgY3VyRGV0YWlscyA9IGN1ckxldmVsLmRldGFpbHM7XG4gICAgICBpZiAoY3VyRGV0YWlscyAmJiBuZXdEZXRhaWxzLmZyYWdtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIC8vIHdlIGFscmVhZHkgaGF2ZSBkZXRhaWxzIGZvciB0aGF0IGxldmVsLCBtZXJnZSB0aGVtXG4gICAgICAgIExldmVsSGVscGVyLm1lcmdlRGV0YWlscyhjdXJEZXRhaWxzLG5ld0RldGFpbHMpO1xuICAgICAgICBzbGlkaW5nID0gbmV3RGV0YWlscy5mcmFnbWVudHNbMF0uc3RhcnQ7XG4gICAgICAgIHRoaXMubGl2ZVN5bmNQb3NpdGlvbiA9IHRoaXMuY29tcHV0ZUxpdmVQb3NpdGlvbihzbGlkaW5nLCBjdXJEZXRhaWxzKTtcbiAgICAgICAgaWYgKG5ld0RldGFpbHMuUFRTS25vd24pIHtcbiAgICAgICAgICBsb2dnZXIubG9nKGBsaXZlIHBsYXlsaXN0IHNsaWRpbmc6JHtzbGlkaW5nLnRvRml4ZWQoMyl9YCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbG9nZ2VyLmxvZygnbGl2ZSBwbGF5bGlzdCAtIG91dGRhdGVkIFBUUywgdW5rbm93biBzbGlkaW5nJyk7XG4gICAgICAgICAgYWxpZ25EaXNjb250aW51aXRpZXModGhpcy5mcmFnUHJldmlvdXMsIGxhc3RMZXZlbCwgbmV3RGV0YWlscyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxvZ2dlci5sb2coJ2xpdmUgcGxheWxpc3QgLSBmaXJzdCBsb2FkLCB1bmtub3duIHNsaWRpbmcnKTtcbiAgICAgICAgbmV3RGV0YWlscy5QVFNLbm93biA9IGZhbHNlO1xuICAgICAgICBhbGlnbkRpc2NvbnRpbnVpdGllcyh0aGlzLmZyYWdQcmV2aW91cywgbGFzdExldmVsLCBuZXdEZXRhaWxzKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbmV3RGV0YWlscy5QVFNLbm93biA9IGZhbHNlO1xuICAgIH1cbiAgICAvLyBvdmVycmlkZSBsZXZlbCBpbmZvXG4gICAgdGhpcy5sZXZlbExhc3RMb2FkZWQgPSBuZXdMZXZlbElkO1xuICAgIGN1ckxldmVsLmRldGFpbHMgPSBuZXdEZXRhaWxzO1xuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuTEVWRUxfVVBEQVRFRCwgeyBkZXRhaWxzOiBuZXdEZXRhaWxzLCBsZXZlbDogbmV3TGV2ZWxJZCB9KTtcblxuICAgIGlmICh0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCA9PT0gZmFsc2UpIHtcbiAgICAvLyBjb21wdXRlIHN0YXJ0IHBvc2l0aW9uIGlmIHNldCB0byAtMS4gdXNlIGl0IHN0cmFpZ2h0IGF3YXkgaWYgdmFsdWUgaXMgZGVmaW5lZFxuICAgICAgaWYgKHRoaXMuc3RhcnRQb3NpdGlvbiA9PT0gLTEgfHzCoHRoaXMubGFzdEN1cnJlbnRUaW1lID09PSAtMSkge1xuICAgICAgICAvLyBmaXJzdCwgY2hlY2sgaWYgc3RhcnQgdGltZSBvZmZzZXQgaGFzIGJlZW4gc2V0IGluIHBsYXlsaXN0LCBpZiB5ZXMsIHVzZSB0aGlzIHZhbHVlXG4gICAgICAgIGxldCBzdGFydFRpbWVPZmZzZXQgPSBuZXdEZXRhaWxzLnN0YXJ0VGltZU9mZnNldDtcbiAgICAgICAgaWYoIWlzTmFOKHN0YXJ0VGltZU9mZnNldCkpIHtcbiAgICAgICAgICBpZiAoc3RhcnRUaW1lT2Zmc2V0IDwgMCkge1xuICAgICAgICAgICAgbG9nZ2VyLmxvZyhgbmVnYXRpdmUgc3RhcnQgdGltZSBvZmZzZXQgJHtzdGFydFRpbWVPZmZzZXR9LCBjb3VudCBmcm9tIGVuZCBvZiBsYXN0IGZyYWdtZW50YCk7XG4gICAgICAgICAgICBzdGFydFRpbWVPZmZzZXQgPSBzbGlkaW5nICsgZHVyYXRpb24gKyBzdGFydFRpbWVPZmZzZXQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxvZ2dlci5sb2coYHN0YXJ0IHRpbWUgb2Zmc2V0IGZvdW5kIGluIHBsYXlsaXN0LCBhZGp1c3Qgc3RhcnRQb3NpdGlvbiB0byAke3N0YXJ0VGltZU9mZnNldH1gKTtcbiAgICAgICAgICB0aGlzLnN0YXJ0UG9zaXRpb24gPSBzdGFydFRpbWVPZmZzZXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gaWYgbGl2ZSBwbGF5bGlzdCwgc2V0IHN0YXJ0IHBvc2l0aW9uIHRvIGJlIGZyYWdtZW50IE4tdGhpcy5jb25maWcubGl2ZVN5bmNEdXJhdGlvbkNvdW50ICh1c3VhbGx5IDMpXG4gICAgICAgICAgaWYgKG5ld0RldGFpbHMubGl2ZSkge1xuICAgICAgICAgICAgdGhpcy5zdGFydFBvc2l0aW9uID0gdGhpcy5jb21wdXRlTGl2ZVBvc2l0aW9uKHNsaWRpbmcsIG5ld0RldGFpbHMpO1xuICAgICAgICAgICAgbG9nZ2VyLmxvZyhgY29uZmlndXJlIHN0YXJ0UG9zaXRpb24gdG8gJHt0aGlzLnN0YXJ0UG9zaXRpb259YCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRQb3NpdGlvbiA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMubGFzdEN1cnJlbnRUaW1lID0gdGhpcy5zdGFydFBvc2l0aW9uO1xuICAgICAgfVxuICAgICAgdGhpcy5uZXh0TG9hZFBvc2l0aW9uID0gdGhpcy5zdGFydFBvc2l0aW9uO1xuICAgIH1cbiAgICAvLyBvbmx5IHN3aXRjaCBiYXRjayB0byBJRExFIHN0YXRlIGlmIHdlIHdlcmUgd2FpdGluZyBmb3IgbGV2ZWwgdG8gc3RhcnQgZG93bmxvYWRpbmcgYSBuZXcgZnJhZ21lbnRcbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuV0FJVElOR19MRVZFTCkge1xuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgfVxuICAgIC8vdHJpZ2dlciBoYW5kbGVyIHJpZ2h0IG5vd1xuICAgIHRoaXMudGljaygpO1xuICB9XG5cbiAgb25LZXlMb2FkZWQoKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLktFWV9MT0FESU5HKSB7XG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgIHRoaXMudGljaygpO1xuICAgIH1cbiAgfVxuXG4gIG9uRnJhZ0xvYWRlZChkYXRhKSB7XG4gICAgdmFyIGZyYWdDdXJyZW50ID0gdGhpcy5mcmFnQ3VycmVudCxcbiAgICAgICAgZnJhZ0xvYWRlZCA9IGRhdGEuZnJhZztcbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuRlJBR19MT0FESU5HICYmXG4gICAgICAgIGZyYWdDdXJyZW50ICYmXG4gICAgICAgIGZyYWdMb2FkZWQudHlwZSA9PT0gJ21haW4nICYmXG4gICAgICAgIGZyYWdMb2FkZWQubGV2ZWwgPT09IGZyYWdDdXJyZW50LmxldmVsICYmXG4gICAgICAgIGZyYWdMb2FkZWQuc24gPT09IGZyYWdDdXJyZW50LnNuKSB7XG4gICAgICBsZXQgc3RhdHMgPSBkYXRhLnN0YXRzLFxuICAgICAgICAgIGN1cnJlbnRMZXZlbCA9IHRoaXMubGV2ZWxzW2ZyYWdDdXJyZW50LmxldmVsXSxcbiAgICAgICAgICBkZXRhaWxzID0gY3VycmVudExldmVsLmRldGFpbHM7XG4gICAgICBsb2dnZXIubG9nKGBMb2FkZWQgICR7ZnJhZ0N1cnJlbnQuc259IG9mIFske2RldGFpbHMuc3RhcnRTTn0gLCR7ZGV0YWlscy5lbmRTTn1dLGxldmVsICR7ZnJhZ0N1cnJlbnQubGV2ZWx9YCk7XG4gICAgICAvLyByZXNldCBmcmFnIGJpdHJhdGUgdGVzdCBpbiBhbnkgY2FzZSBhZnRlciBmcmFnIGxvYWRlZCBldmVudFxuICAgICAgdGhpcy5iaXRyYXRlVGVzdCA9IGZhbHNlO1xuICAgICAgdGhpcy5zdGF0cyA9IHN0YXRzO1xuICAgICAgLy8gaWYgdGhpcyBmcmFnIHdhcyBsb2FkZWQgdG8gcGVyZm9ybSBhIGJpdHJhdGUgdGVzdCBBTkQgaWYgaGxzLm5leHRMb2FkTGV2ZWwgaXMgZ3JlYXRlciB0aGFuIDBcbiAgICAgIC8vIHRoZW4gdGhpcyBtZWFucyB0aGF0IHdlIHNob3VsZCBiZSBhYmxlIHRvIGxvYWQgYSBmcmFnbWVudCBhdCBhIGhpZ2hlciBxdWFsaXR5IGxldmVsXG4gICAgICBpZiAoZnJhZ0xvYWRlZC5iaXRyYXRlVGVzdCA9PT0gdHJ1ZSAmJiB0aGlzLmhscy5uZXh0TG9hZExldmVsKSB7XG4gICAgICAgIC8vIHN3aXRjaCBiYWNrIHRvIElETEUgc3RhdGUgLi4uIHdlIGp1c3QgbG9hZGVkIGEgZnJhZ21lbnQgdG8gZGV0ZXJtaW5lIGFkZXF1YXRlIHN0YXJ0IGJpdHJhdGUgYW5kIGluaXRpYWxpemUgYXV0b3N3aXRjaCBhbGdvXG4gICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgICB0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCA9IGZhbHNlO1xuICAgICAgICBzdGF0cy50cGFyc2VkID0gc3RhdHMudGJ1ZmZlcmVkID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuRlJBR19CVUZGRVJFRCwge3N0YXRzOiBzdGF0cywgZnJhZzogZnJhZ0N1cnJlbnQsIGlkIDogJ21haW4nfSk7XG4gICAgICAgIHRoaXMudGljaygpO1xuICAgICAgfSBlbHNlIGlmIChmcmFnTG9hZGVkLnNuID09PSAnaW5pdFNlZ21lbnQnKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgICBzdGF0cy50cGFyc2VkID0gc3RhdHMudGJ1ZmZlcmVkID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIGRldGFpbHMuaW5pdFNlZ21lbnQuZGF0YSA9IGRhdGEucGF5bG9hZDtcbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5GUkFHX0JVRkZFUkVELCB7c3RhdHM6IHN0YXRzLCBmcmFnOiBmcmFnQ3VycmVudCwgaWQgOiAnbWFpbid9KTtcbiAgICAgICAgdGhpcy50aWNrKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuUEFSU0lORztcbiAgICAgICAgLy8gdHJhbnNtdXggdGhlIE1QRUctVFMgZGF0YSB0byBJU08tQk1GRiBzZWdtZW50c1xuICAgICAgICBsZXQgZHVyYXRpb24gPSBkZXRhaWxzLnRvdGFsZHVyYXRpb24sXG4gICAgICAgICAgICBsZXZlbCA9IGZyYWdDdXJyZW50LmxldmVsLFxuICAgICAgICAgICAgc24gPSBmcmFnQ3VycmVudC5zbixcbiAgICAgICAgICAgIGF1ZGlvQ29kZWMgPSB0aGlzLmNvbmZpZy5kZWZhdWx0QXVkaW9Db2RlYyB8fCBjdXJyZW50TGV2ZWwuYXVkaW9Db2RlYztcbiAgICAgICAgaWYodGhpcy5hdWRpb0NvZGVjU3dhcCkge1xuICAgICAgICAgIGxvZ2dlci5sb2coJ3N3YXBwaW5nIHBsYXlsaXN0IGF1ZGlvIGNvZGVjJyk7XG4gICAgICAgICAgaWYoYXVkaW9Db2RlYyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBhdWRpb0NvZGVjID0gdGhpcy5sYXN0QXVkaW9Db2RlYztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYoYXVkaW9Db2RlYykge1xuICAgICAgICAgICAgaWYoYXVkaW9Db2RlYy5pbmRleE9mKCdtcDRhLjQwLjUnKSAhPT0tMSkge1xuICAgICAgICAgICAgICBhdWRpb0NvZGVjID0gJ21wNGEuNDAuMic7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBhdWRpb0NvZGVjID0gJ21wNGEuNDAuNSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMucGVuZGluZ0J1ZmZlcmluZyA9IHRydWU7XG4gICAgICAgIHRoaXMuYXBwZW5kZWQgPSBmYWxzZTtcbiAgICAgICAgbG9nZ2VyLmxvZyhgUGFyc2luZyAke3NufSBvZiBbJHtkZXRhaWxzLnN0YXJ0U059ICwke2RldGFpbHMuZW5kU059XSxsZXZlbCAke2xldmVsfSwgY2MgJHtmcmFnQ3VycmVudC5jY31gKTtcbiAgICAgICAgbGV0IGRlbXV4ZXIgPSB0aGlzLmRlbXV4ZXI7XG4gICAgICAgIGlmICghZGVtdXhlcikge1xuICAgICAgICAgIGRlbXV4ZXIgPSB0aGlzLmRlbXV4ZXIgPSBuZXcgRGVtdXhlcih0aGlzLmhscywnbWFpbicpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRpbWUgT2Zmc2V0IGlzIGFjY3VyYXRlIGlmIGxldmVsIFBUUyBpcyBrbm93biwgb3IgaWYgcGxheWxpc3QgaXMgbm90IHNsaWRpbmcgKG5vdCBsaXZlKSBhbmQgaWYgbWVkaWEgaXMgbm90IHNlZWtpbmcgKHRoaXMgaXMgdG8gb3ZlcmNvbWUgcG90ZW50aWFsIHRpbWVzdGFtcCBkcmlmdHMgYmV0d2VlbiBwbGF5bGlzdHMgYW5kIGZyYWdtZW50cylcbiAgICAgICAgbGV0IG1lZGlhID0gdGhpcy5tZWRpYTtcbiAgICAgICAgbGV0IG1lZGlhU2Vla2luZyA9IG1lZGlhICYmIG1lZGlhLnNlZWtpbmc7XG4gICAgICAgIGxldCBhY2N1cmF0ZVRpbWVPZmZzZXQgPSAhbWVkaWFTZWVraW5nICYmIChkZXRhaWxzLlBUU0tub3duIHx8ICFkZXRhaWxzLmxpdmUpO1xuICAgICAgICBsZXQgaW5pdFNlZ21lbnREYXRhID0gZGV0YWlscy5pbml0U2VnbWVudCA/IGRldGFpbHMuaW5pdFNlZ21lbnQuZGF0YSA6IFtdO1xuICAgICAgICBkZW11eGVyLnB1c2goZGF0YS5wYXlsb2FkLCBpbml0U2VnbWVudERhdGEsYXVkaW9Db2RlYywgY3VycmVudExldmVsLnZpZGVvQ29kZWMsIGZyYWdDdXJyZW50LCBkdXJhdGlvbiwgYWNjdXJhdGVUaW1lT2Zmc2V0LHVuZGVmaW5lZCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuZnJhZ0xvYWRFcnJvciA9IDA7XG4gIH1cblxuICBvbkZyYWdQYXJzaW5nSW5pdFNlZ21lbnQoZGF0YSkge1xuICAgIGNvbnN0IGZyYWdDdXJyZW50ID0gdGhpcy5mcmFnQ3VycmVudDtcbiAgICBjb25zdCBmcmFnTmV3ID0gZGF0YS5mcmFnO1xuICAgIGlmIChmcmFnQ3VycmVudCAmJlxuICAgICAgICBkYXRhLmlkID09PSAnbWFpbicgJiZcbiAgICAgICAgZnJhZ05ldy5zbiA9PT0gZnJhZ0N1cnJlbnQuc24gJiZcbiAgICAgICAgZnJhZ05ldy5sZXZlbCA9PT0gZnJhZ0N1cnJlbnQubGV2ZWwgJiZcbiAgICAgICAgdGhpcy5zdGF0ZSA9PT0gU3RhdGUuUEFSU0lORykge1xuICAgICAgdmFyIHRyYWNrcyA9IGRhdGEudHJhY2tzLCB0cmFja05hbWUsIHRyYWNrO1xuXG4gICAgICAvLyBpZiBhdWRpbyB0cmFjayBpcyBleHBlY3RlZCB0byBjb21lIGZyb20gYXVkaW8gc3RyZWFtIGNvbnRyb2xsZXIsIGRpc2NhcmQgYW55IGNvbWluZyBmcm9tIG1haW5cbiAgICAgIGlmICh0cmFja3MuYXVkaW8gJiYgdGhpcy5hbHRBdWRpbykge1xuICAgICAgICBkZWxldGUgdHJhY2tzLmF1ZGlvO1xuICAgICAgfVxuICAgICAgLy8gaW5jbHVkZSBsZXZlbENvZGVjIGluIGF1ZGlvIGFuZCB2aWRlbyB0cmFja3NcbiAgICAgIHRyYWNrID0gdHJhY2tzLmF1ZGlvO1xuICAgICAgaWYodHJhY2spIHtcbiAgICAgICAgdmFyIGF1ZGlvQ29kZWMgPSB0aGlzLmxldmVsc1t0aGlzLmxldmVsXS5hdWRpb0NvZGVjLFxuICAgICAgICAgICAgdWEgPSBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmKGF1ZGlvQ29kZWMgJiYgdGhpcy5hdWRpb0NvZGVjU3dhcCkge1xuICAgICAgICAgIGxvZ2dlci5sb2coJ3N3YXBwaW5nIHBsYXlsaXN0IGF1ZGlvIGNvZGVjJyk7XG4gICAgICAgICAgaWYoYXVkaW9Db2RlYy5pbmRleE9mKCdtcDRhLjQwLjUnKSAhPT0tMSkge1xuICAgICAgICAgICAgYXVkaW9Db2RlYyA9ICdtcDRhLjQwLjInO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhdWRpb0NvZGVjID0gJ21wNGEuNDAuNSc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGluIGNhc2UgQUFDIGFuZCBIRS1BQUMgYXVkaW8gY29kZWNzIGFyZSBzaWduYWxsZWQgaW4gbWFuaWZlc3RcbiAgICAgICAgLy8gZm9yY2UgSEUtQUFDICwgYXMgaXQgc2VlbXMgdGhhdCBtb3N0IGJyb3dzZXJzIHByZWZlcnMgdGhhdCB3YXksXG4gICAgICAgIC8vIGV4Y2VwdCBmb3IgbW9ubyBzdHJlYW1zIE9SIG9uIEZGXG4gICAgICAgIC8vIHRoZXNlIGNvbmRpdGlvbnMgbWlnaHQgbmVlZCB0byBiZSByZXZpZXdlZCAuLi5cbiAgICAgICAgaWYgKHRoaXMuYXVkaW9Db2RlY1N3aXRjaCkge1xuICAgICAgICAgICAgLy8gZG9uJ3QgZm9yY2UgSEUtQUFDIGlmIG1vbm8gc3RyZWFtXG4gICAgICAgICAgIGlmKHRyYWNrLm1ldGFkYXRhLmNoYW5uZWxDb3VudCAhPT0gMSAmJlxuICAgICAgICAgICAgLy8gZG9uJ3QgZm9yY2UgSEUtQUFDIGlmIGZpcmVmb3hcbiAgICAgICAgICAgIHVhLmluZGV4T2YoJ2ZpcmVmb3gnKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgYXVkaW9Db2RlYyA9ICdtcDRhLjQwLjUnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBIRS1BQUMgaXMgYnJva2VuIG9uIEFuZHJvaWQsIGFsd2F5cyBzaWduYWwgYXVkaW8gY29kZWMgYXMgQUFDIGV2ZW4gaWYgdmFyaWFudCBtYW5pZmVzdCBzdGF0ZXMgb3RoZXJ3aXNlXG4gICAgICAgIGlmKHVhLmluZGV4T2YoJ2FuZHJvaWQnKSAhPT0gLTEgJiYgdHJhY2suY29udGFpbmVyICE9PSAnYXVkaW8vbXBlZycpIHsgLy8gRXhjbHVkZSBtcGVnIGF1ZGlvXG4gICAgICAgICAgYXVkaW9Db2RlYyA9ICdtcDRhLjQwLjInO1xuICAgICAgICAgIGxvZ2dlci5sb2coYEFuZHJvaWQ6IGZvcmNlIGF1ZGlvIGNvZGVjIHRvICR7YXVkaW9Db2RlY31gKTtcbiAgICAgICAgfVxuICAgICAgICB0cmFjay5sZXZlbENvZGVjID0gYXVkaW9Db2RlYztcbiAgICAgICAgdHJhY2suaWQgPSBkYXRhLmlkO1xuICAgICAgfVxuICAgICAgdHJhY2sgPSB0cmFja3MudmlkZW87XG4gICAgICBpZih0cmFjaykge1xuICAgICAgICB0cmFjay5sZXZlbENvZGVjID0gdGhpcy5sZXZlbHNbdGhpcy5sZXZlbF0udmlkZW9Db2RlYztcbiAgICAgICAgdHJhY2suaWQgPSBkYXRhLmlkO1xuICAgICAgfVxuICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5CVUZGRVJfQ09ERUNTLHRyYWNrcyk7XG4gICAgICAvLyBsb29wIHRocm91Z2ggdHJhY2tzIHRoYXQgYXJlIGdvaW5nIHRvIGJlIHByb3ZpZGVkIHRvIGJ1ZmZlckNvbnRyb2xsZXJcbiAgICAgIGZvciAodHJhY2tOYW1lIGluIHRyYWNrcykge1xuICAgICAgICB0cmFjayA9IHRyYWNrc1t0cmFja05hbWVdO1xuICAgICAgICBsb2dnZXIubG9nKGBtYWluIHRyYWNrOiR7dHJhY2tOYW1lfSxjb250YWluZXI6JHt0cmFjay5jb250YWluZXJ9LGNvZGVjc1tsZXZlbC9wYXJzZWRdPVske3RyYWNrLmxldmVsQ29kZWN9LyR7dHJhY2suY29kZWN9XWApO1xuICAgICAgICB2YXIgaW5pdFNlZ21lbnQgPSB0cmFjay5pbml0U2VnbWVudDtcbiAgICAgICAgaWYgKGluaXRTZWdtZW50KSB7XG4gICAgICAgICAgdGhpcy5hcHBlbmRlZCA9IHRydWU7XG4gICAgICAgICAgLy8gYXJtIHBlbmRpbmcgQnVmZmVyaW5nIGZsYWcgYmVmb3JlIGFwcGVuZGluZyBhIHNlZ21lbnRcbiAgICAgICAgICB0aGlzLnBlbmRpbmdCdWZmZXJpbmcgPSB0cnVlO1xuICAgICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuQlVGRkVSX0FQUEVORElORywge3R5cGU6IHRyYWNrTmFtZSwgZGF0YTogaW5pdFNlZ21lbnQsIHBhcmVudCA6ICdtYWluJywgY29udGVudCA6ICdpbml0U2VnbWVudCd9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy90cmlnZ2VyIGhhbmRsZXIgcmlnaHQgbm93XG4gICAgICB0aGlzLnRpY2soKTtcbiAgICB9XG4gIH1cblxuICBvbkZyYWdQYXJzaW5nRGF0YShkYXRhKSB7XG4gICAgY29uc3QgZnJhZ0N1cnJlbnQgPSB0aGlzLmZyYWdDdXJyZW50O1xuICAgIGNvbnN0IGZyYWdOZXcgPSBkYXRhLmZyYWc7XG4gICAgaWYgKGZyYWdDdXJyZW50ICYmXG4gICAgICAgIGRhdGEuaWQgPT09ICdtYWluJyAmJlxuICAgICAgICBmcmFnTmV3LnNuID09PSBmcmFnQ3VycmVudC5zbiAmJlxuICAgICAgICBmcmFnTmV3LmxldmVsID09PSBmcmFnQ3VycmVudC5sZXZlbCAmJlxuICAgICAgICAhKGRhdGEudHlwZSA9PT0gJ2F1ZGlvJyAmJiB0aGlzLmFsdEF1ZGlvKSAmJiAvLyBmaWx0ZXIgb3V0IG1haW4gYXVkaW8gaWYgYXVkaW8gdHJhY2sgaXMgbG9hZGVkIHRocm91Z2ggYXVkaW8gc3RyZWFtIGNvbnRyb2xsZXJcbiAgICAgICAgdGhpcy5zdGF0ZSA9PT0gU3RhdGUuUEFSU0lORykge1xuICAgICAgdmFyIGxldmVsID0gdGhpcy5sZXZlbHNbdGhpcy5sZXZlbF0sXG4gICAgICAgICAgZnJhZyA9IGZyYWdDdXJyZW50O1xuICAgICAgICAgIGlmIChpc05hTihkYXRhLmVuZFBUUykpIHtcbiAgICAgICAgICAgIGRhdGEuZW5kUFRTID0gZGF0YS5zdGFydFBUUyArIGZyYWdDdXJyZW50LmR1cmF0aW9uO1xuICAgICAgICAgICAgZGF0YS5lbmREVFMgPSBkYXRhLnN0YXJ0RFRTICsgZnJhZ0N1cnJlbnQuZHVyYXRpb247XG4gICAgICAgICAgfVxuXG4gICAgICBsb2dnZXIubG9nKGBQYXJzZWQgJHtkYXRhLnR5cGV9LFBUUzpbJHtkYXRhLnN0YXJ0UFRTLnRvRml4ZWQoMyl9LCR7ZGF0YS5lbmRQVFMudG9GaXhlZCgzKX1dLERUUzpbJHtkYXRhLnN0YXJ0RFRTLnRvRml4ZWQoMyl9LyR7ZGF0YS5lbmREVFMudG9GaXhlZCgzKX1dLG5iOiR7ZGF0YS5uYn0sZHJvcHBlZDoke2RhdGEuZHJvcHBlZCB8fCAwfWApO1xuXG4gICAgICAvLyBEZXRlY3QgZ2FwcyBpbiBhIGZyYWdtZW50ICBhbmQgdHJ5IHRvIGZpeCBpdCBieSBmaW5kaW5nIGEga2V5ZnJhbWUgaW4gdGhlIHByZXZpb3VzIGZyYWdtZW50IChzZWUgX2ZpbmRGcmFnbWVudHMpXG4gICAgICBpZihkYXRhLnR5cGUgPT09ICd2aWRlbycpIHtcbiAgICAgICAgZnJhZy5kcm9wcGVkID0gZGF0YS5kcm9wcGVkO1xuICAgICAgICBpZiAoZnJhZy5kcm9wcGVkKSB7XG4gICAgICAgICAgaWYgKCFmcmFnLmJhY2t0cmFja2VkKSB7XG4gICAgICAgICAgICAvLyBSZXR1cm4gYmFjayB0byB0aGUgSURMRSBzdGF0ZSB3aXRob3V0IGFwcGVuZGluZyB0byBidWZmZXJcbiAgICAgICAgICAgIC8vIENhdXNlcyBmaW5kRnJhZ21lbnRzIHRvIGJhY2t0cmFjayBhIHNlZ21lbnQgYW5kIGZpbmQgdGhlIGtleWZyYW1lXG4gICAgICAgICAgICAvLyBBdWRpbyBmcmFnbWVudHMgYXJyaXZpbmcgYmVmb3JlIHZpZGVvIHNldHMgdGhlIG5leHRMb2FkUG9zaXRpb24sIGNhdXNpbmcgX2ZpbmRGcmFnbWVudHMgdG8gc2tpcCB0aGUgYmFja3RyYWNrZWQgZnJhZ21lbnRcbiAgICAgICAgICAgIGZyYWcuYmFja3RyYWNrZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5uZXh0TG9hZFBvc2l0aW9uID0gZGF0YS5zdGFydFBUUztcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgICAgICAgdGhpcy50aWNrKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKCdBbHJlYWR5IGJhY2t0cmFja2VkIG9uIHRoaXMgZnJhZ21lbnQsIGFwcGVuZGluZyB3aXRoIHRoZSBnYXAnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gT25seSByZXNldCB0aGUgYmFja3RyYWNrZWQgZmxhZyBpZiB3ZSd2ZSBsb2FkZWQgdGhlIGZyYWcgd2l0aG91dCBhbnkgZHJvcHBlZCBmcmFtZXNcbiAgICAgICAgICBmcmFnLmJhY2t0cmFja2VkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGRyaWZ0ID0gTGV2ZWxIZWxwZXIudXBkYXRlRnJhZ1BUU0RUUyhsZXZlbC5kZXRhaWxzLGZyYWcuc24sZGF0YS5zdGFydFBUUyxkYXRhLmVuZFBUUyxkYXRhLnN0YXJ0RFRTLGRhdGEuZW5kRFRTKSxcbiAgICAgICAgICBobHMgPSB0aGlzLmhscztcbiAgICAgIGhscy50cmlnZ2VyKEV2ZW50LkxFVkVMX1BUU19VUERBVEVELCB7ZGV0YWlsczogbGV2ZWwuZGV0YWlscywgbGV2ZWw6IHRoaXMubGV2ZWwsIGRyaWZ0OiBkcmlmdCwgdHlwZTogZGF0YS50eXBlLCBzdGFydDogZGF0YS5zdGFydFBUUywgZW5kOiBkYXRhLmVuZFBUU30pO1xuXG4gICAgICAvLyBoYXMgcmVtdXhlciBkcm9wcGVkIHZpZGVvIGZyYW1lcyBsb2NhdGVkIGJlZm9yZSBmaXJzdCBrZXlmcmFtZSA/XG4gICAgICBbZGF0YS5kYXRhMSwgZGF0YS5kYXRhMl0uZm9yRWFjaChidWZmZXIgPT4ge1xuICAgICAgICAvLyBvbmx5IGFwcGVuZCBpbiBQQVJTSU5HIHN0YXRlIChyYXRpb25hbGUgaXMgdGhhdCBhbiBhcHBlbmRpbmcgZXJyb3IgY291bGQgaGFwcGVuIHN5bmNocm9ub3VzbHkgb24gZmlyc3Qgc2VnbWVudCBhcHBlbmRpbmcpXG4gICAgICAgIC8vIGluIHRoYXQgY2FzZSBpdCBpcyB1c2VsZXNzIHRvIGFwcGVuZCBmb2xsb3dpbmcgc2VnbWVudHNcbiAgICAgICAgaWYgKGJ1ZmZlciAmJiBidWZmZXIubGVuZ3RoICYmIHRoaXMuc3RhdGUgPT09IFN0YXRlLlBBUlNJTkcpIHtcbiAgICAgICAgICB0aGlzLmFwcGVuZGVkID0gdHJ1ZTtcbiAgICAgICAgICAvLyBhcm0gcGVuZGluZyBCdWZmZXJpbmcgZmxhZyBiZWZvcmUgYXBwZW5kaW5nIGEgc2VnbWVudFxuICAgICAgICAgIHRoaXMucGVuZGluZ0J1ZmZlcmluZyA9IHRydWU7XG4gICAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnQuQlVGRkVSX0FQUEVORElORywge3R5cGU6IGRhdGEudHlwZSwgZGF0YTogYnVmZmVyLCBwYXJlbnQgOiAnbWFpbicsY29udGVudCA6ICdkYXRhJ30pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIC8vdHJpZ2dlciBoYW5kbGVyIHJpZ2h0IG5vd1xuICAgICAgdGhpcy50aWNrKCk7XG4gICAgfVxuICB9XG5cbiAgb25GcmFnUGFyc2VkKGRhdGEpIHtcbiAgICBjb25zdCBmcmFnQ3VycmVudCA9IHRoaXMuZnJhZ0N1cnJlbnQ7XG4gICAgY29uc3QgZnJhZ05ldyA9IGRhdGEuZnJhZztcbiAgICBpZiAoZnJhZ0N1cnJlbnQgJiZcbiAgICAgICAgZGF0YS5pZCA9PT0gJ21haW4nICYmXG4gICAgICAgIGZyYWdOZXcuc24gPT09IGZyYWdDdXJyZW50LnNuICYmXG4gICAgICAgIGZyYWdOZXcubGV2ZWwgPT09IGZyYWdDdXJyZW50LmxldmVsICYmXG4gICAgICAgIHRoaXMuc3RhdGUgPT09IFN0YXRlLlBBUlNJTkcpIHtcbiAgICAgIHRoaXMuc3RhdHMudHBhcnNlZCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLlBBUlNFRDtcbiAgICAgIHRoaXMuX2NoZWNrQXBwZW5kZWRQYXJzZWQoKTtcbiAgICB9XG4gIH1cblxuICBvbkF1ZGlvVHJhY2tTd2l0Y2hpbmcoZGF0YSkge1xuICAgIC8vIGlmIGFueSBVUkwgZm91bmQgb24gbmV3IGF1ZGlvIHRyYWNrLCBpdCBpcyBhbiBhbHRlcm5hdGUgYXVkaW8gdHJhY2tcbiAgICB2YXIgYWx0QXVkaW8gPSAhIWRhdGEudXJsLFxuICAgICAgICB0cmFja0lkID0gZGF0YS5pZDtcbiAgICAvLyBpZiB3ZSBzd2l0Y2ggb24gbWFpbiBhdWRpbywgZW5zdXJlIHRoYXQgbWFpbiBmcmFnbWVudCBzY2hlZHVsaW5nIGlzIHN5bmNlZCB3aXRoIG1lZGlhLmJ1ZmZlcmVkXG4gICAgLy8gZG9uJ3QgZG8gYW55dGhpbmcgaWYgd2Ugc3dpdGNoIHRvIGFsdCBhdWRpbzogYXVkaW8gc3RyZWFtIGNvbnRyb2xsZXIgaXMgaGFuZGxpbmcgaXQuXG4gICAgLy8gd2Ugd2lsbCBqdXN0IGhhdmUgdG8gY2hhbmdlIGJ1ZmZlciBzY2hlZHVsaW5nIG9uIGF1ZGlvVHJhY2tTd2l0Y2hlZFxuICAgIGlmICghYWx0QXVkaW8pIHtcbiAgICAgIGlmICh0aGlzLm1lZGlhQnVmZmVyICE9PSB0aGlzLm1lZGlhKSB7XG4gICAgICAgIGxvZ2dlci5sb2coYHN3aXRjaGluZyBvbiBtYWluIGF1ZGlvLCB1c2UgbWVkaWEuYnVmZmVyZWQgdG8gc2NoZWR1bGUgbWFpbiBmcmFnbWVudCBsb2FkaW5nYCk7XG4gICAgICAgIHRoaXMubWVkaWFCdWZmZXIgPSB0aGlzLm1lZGlhO1xuICAgICAgICBsZXQgZnJhZ0N1cnJlbnQgPSB0aGlzLmZyYWdDdXJyZW50O1xuICAgICAgICAvLyB3ZSBuZWVkIHRvIHJlZmlsbCBhdWRpbyBidWZmZXIgZnJvbSBtYWluOiBjYW5jZWwgYW55IGZyYWcgbG9hZGluZyB0byBzcGVlZCB1cCBhdWRpbyBzd2l0Y2hcbiAgICAgICAgaWYgKGZyYWdDdXJyZW50LmxvYWRlcikge1xuICAgICAgICAgIGxvZ2dlci5sb2coJ3N3aXRjaGluZyB0byBtYWluIGF1ZGlvIHRyYWNrLCBjYW5jZWwgbWFpbiBmcmFnbWVudCBsb2FkJyk7XG4gICAgICAgICAgZnJhZ0N1cnJlbnQubG9hZGVyLmFib3J0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5mcmFnQ3VycmVudCA9IG51bGw7XG4gICAgICAgIHRoaXMuZnJhZ1ByZXZpb3VzID0gbnVsbDtcbiAgICAgICAgLy8gZGVzdHJveSBkZW11eGVyIHRvIGZvcmNlIGluaXQgc2VnbWVudCBnZW5lcmF0aW9uIChmb2xsb3dpbmcgYXVkaW8gc3dpdGNoKVxuICAgICAgICBpZiAodGhpcy5kZW11eGVyKSB7XG4gICAgICAgICAgdGhpcy5kZW11eGVyLmRlc3Ryb3koKTtcbiAgICAgICAgICB0aGlzLmRlbXV4ZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIHN3aXRjaCB0byBJRExFIHN0YXRlIHRvIGxvYWQgbmV3IGZyYWdtZW50XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgfVxuICAgICAgbGV0IGhscyA9IHRoaXMuaGxzO1xuICAgICAgLy8gc3dpdGNoaW5nIHRvIG1haW4gYXVkaW8sIGZsdXNoIGFsbCBhdWRpbyBhbmQgdHJpZ2dlciB0cmFjayBzd2l0Y2hlZFxuICAgICAgaGxzLnRyaWdnZXIoRXZlbnQuQlVGRkVSX0ZMVVNISU5HLCB7c3RhcnRPZmZzZXQ6IDAgLCBlbmRPZmZzZXQ6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSwgdHlwZSA6ICdhdWRpbyd9KTtcbiAgICAgIGhscy50cmlnZ2VyKEV2ZW50LkFVRElPX1RSQUNLX1NXSVRDSEVELCB7aWQgOiB0cmFja0lkfSk7XG4gICAgICB0aGlzLmFsdEF1ZGlvID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgb25BdWRpb1RyYWNrU3dpdGNoZWQoZGF0YSkge1xuICAgIHZhciB0cmFja0lkID0gZGF0YS5pZCxcbiAgICBhbHRBdWRpbyA9ICEhdGhpcy5obHMuYXVkaW9UcmFja3NbdHJhY2tJZF0udXJsO1xuICAgIGlmIChhbHRBdWRpbykge1xuICAgICAgbGV0IHZpZGVvQnVmZmVyID0gdGhpcy52aWRlb0J1ZmZlcjtcbiAgICAgIC8vIGlmIHdlIHN3aXRjaGVkIG9uIGFsdGVybmF0ZSBhdWRpbywgZW5zdXJlIHRoYXQgbWFpbiBmcmFnbWVudCBzY2hlZHVsaW5nIGlzIHN5bmNlZCB3aXRoIHZpZGVvIHNvdXJjZWJ1ZmZlciBidWZmZXJlZFxuICAgICAgaWYgKHZpZGVvQnVmZmVyICYmIHRoaXMubWVkaWFCdWZmZXIgIT09IHZpZGVvQnVmZmVyKSB7XG4gICAgICAgIGxvZ2dlci5sb2coYHN3aXRjaGluZyBvbiBhbHRlcm5hdGUgYXVkaW8sIHVzZSB2aWRlby5idWZmZXJlZCB0byBzY2hlZHVsZSBtYWluIGZyYWdtZW50IGxvYWRpbmdgKTtcbiAgICAgICAgdGhpcy5tZWRpYUJ1ZmZlciA9IHZpZGVvQnVmZmVyO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmFsdEF1ZGlvID0gYWx0QXVkaW87XG4gICAgdGhpcy50aWNrKCk7XG4gIH1cblxuXG5cbiAgb25CdWZmZXJDcmVhdGVkKGRhdGEpIHtcbiAgICBsZXQgdHJhY2tzID0gZGF0YS50cmFja3MsIG1lZGlhVHJhY2ssIG5hbWUsIGFsdGVybmF0ZSA9IGZhbHNlO1xuICAgIGZvcih2YXIgdHlwZSBpbiB0cmFja3MpIHtcbiAgICAgIGxldCB0cmFjayA9IHRyYWNrc1t0eXBlXTtcbiAgICAgIGlmICh0cmFjay5pZCA9PT0gJ21haW4nKSB7XG4gICAgICAgIG5hbWUgPSB0eXBlO1xuICAgICAgICBtZWRpYVRyYWNrID0gdHJhY2s7XG4gICAgICAgIC8vIGtlZXAgdmlkZW8gc291cmNlIGJ1ZmZlciByZWZlcmVuY2VcbiAgICAgICAgaWYgKHR5cGUgPT09ICd2aWRlbycpIHtcbiAgICAgICAgICB0aGlzLnZpZGVvQnVmZmVyID0gdHJhY2tzW3R5cGVdLmJ1ZmZlcjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWx0ZXJuYXRlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGFsdGVybmF0ZSAmJiBtZWRpYVRyYWNrKSB7XG4gICAgICBsb2dnZXIubG9nKGBhbHRlcm5hdGUgdHJhY2sgZm91bmQsIHVzZSAke25hbWV9LmJ1ZmZlcmVkIHRvIHNjaGVkdWxlIG1haW4gZnJhZ21lbnQgbG9hZGluZ2ApO1xuICAgICAgdGhpcy5tZWRpYUJ1ZmZlciA9IG1lZGlhVHJhY2suYnVmZmVyO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm1lZGlhQnVmZmVyID0gdGhpcy5tZWRpYTtcbiAgICB9XG4gIH1cblxuICBvbkJ1ZmZlckFwcGVuZGVkKGRhdGEpIHtcbiAgICBpZiAoZGF0YS5wYXJlbnQgPT09ICdtYWluJykge1xuICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgICAgaWYgKHN0YXRlID09PSBTdGF0ZS5QQVJTSU5HIHx8IHN0YXRlID09PSBTdGF0ZS5QQVJTRUQpIHtcbiAgICAgICAgLy8gY2hlY2sgaWYgYWxsIGJ1ZmZlcnMgaGF2ZSBiZWVuIGFwcGVuZGVkXG4gICAgICAgIHRoaXMucGVuZGluZ0J1ZmZlcmluZyA9IChkYXRhLnBlbmRpbmcgPiAwKTtcbiAgICAgICAgdGhpcy5fY2hlY2tBcHBlbmRlZFBhcnNlZCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIF9jaGVja0FwcGVuZGVkUGFyc2VkKCkge1xuICAgIC8vdHJpZ2dlciBoYW5kbGVyIHJpZ2h0IG5vd1xuICAgIGlmICh0aGlzLnN0YXRlID09PSBTdGF0ZS5QQVJTRUQgJiYgKCF0aGlzLmFwcGVuZGVkIHx8ICF0aGlzLnBlbmRpbmdCdWZmZXJpbmcpKSB7XG4gICAgICBjb25zdCBmcmFnID0gdGhpcy5mcmFnQ3VycmVudDtcbiAgICAgIGlmIChmcmFnKSB7XG4gICAgICAgIGNvbnN0IG1lZGlhID0gdGhpcy5tZWRpYUJ1ZmZlciA/IHRoaXMubWVkaWFCdWZmZXIgOiB0aGlzLm1lZGlhO1xuICAgICAgICBsb2dnZXIubG9nKGBtYWluIGJ1ZmZlcmVkIDogJHtUaW1lUmFuZ2VzLnRvU3RyaW5nKG1lZGlhLmJ1ZmZlcmVkKX1gKTtcbiAgICAgICAgLy8gZmlsdGVyIGZyYWdtZW50cyBwb3RlbnRpYWxseSBldmljdGVkIGZyb20gYnVmZmVyLiB0aGlzIGlzIHRvIGF2b2lkIG1lbWxlYWsgb24gbGl2ZSBzdHJlYW1zXG4gICAgICAgIGxldCBidWZmZXJlZEZyYWdzID0gdGhpcy5fYnVmZmVyZWRGcmFncy5maWx0ZXIoZnJhZyA9PiB7cmV0dXJuIEJ1ZmZlckhlbHBlci5pc0J1ZmZlcmVkKG1lZGlhLChmcmFnLnN0YXJ0UFRTICsgZnJhZy5lbmRQVFMpIC8gMik7fSk7XG4gICAgICAgIC8vIHB1c2ggbmV3IHJhbmdlXG4gICAgICAgIGJ1ZmZlcmVkRnJhZ3MucHVzaChmcmFnKTtcbiAgICAgICAgLy8gc29ydCBmcmFncywgYXMgd2UgdXNlIEJpbmFyeVNlYXJjaCBmb3IgbG9va3VwIGluIGdldEJ1ZmZlcmVkRnJhZyAuLi5cbiAgICAgICAgdGhpcy5fYnVmZmVyZWRGcmFncyA9IGJ1ZmZlcmVkRnJhZ3Muc29ydChmdW5jdGlvbihhLGIpIHtyZXR1cm4gKGEuc3RhcnRQVFMgLSBiLnN0YXJ0UFRTKTt9KTtcbiAgICAgICAgdGhpcy5mcmFnUHJldmlvdXMgPSBmcmFnO1xuICAgICAgICBjb25zdCBzdGF0cyA9IHRoaXMuc3RhdHM7XG4gICAgICAgIHN0YXRzLnRidWZmZXJlZCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICAvLyB3ZSBzaG91bGQgZ2V0IHJpZCBvZiB0aGlzLmZyYWdMYXN0S2Jwc1xuICAgICAgICB0aGlzLmZyYWdMYXN0S2JwcyA9IE1hdGgucm91bmQoOCAqIHN0YXRzLnRvdGFsIC8gKHN0YXRzLnRidWZmZXJlZCAtIHN0YXRzLnRmaXJzdCkpO1xuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkZSQUdfQlVGRkVSRUQsIHtzdGF0czogc3RhdHMsIGZyYWc6IGZyYWcsIGlkIDogJ21haW4nfSk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgfVxuICAgICAgdGhpcy50aWNrKCk7XG4gICAgfVxuICB9XG5cbiAgb25FcnJvcihkYXRhKSB7XG4gICAgbGV0IGZyYWcgPSBkYXRhLmZyYWcgfHzCoHRoaXMuZnJhZ0N1cnJlbnQ7XG4gICAgLy8gZG9uJ3QgaGFuZGxlIGZyYWcgZXJyb3Igbm90IHJlbGF0ZWQgdG8gbWFpbiBmcmFnbWVudFxuICAgIGlmIChmcmFnICYmIGZyYWcudHlwZSAhPT0gJ21haW4nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBtZWRpYSA9IHRoaXMubWVkaWEsXG4gICAgICAgIC8vIDAuNSA6IHRvbGVyYW5jZSBuZWVkZWQgYXMgc29tZSBicm93c2VycyBzdGFsbHMgcGxheWJhY2sgYmVmb3JlIHJlYWNoaW5nIGJ1ZmZlcmVkIGVuZFxuICAgICAgICBtZWRpYUJ1ZmZlcmVkID0gbWVkaWEgJiYgQnVmZmVySGVscGVyLmlzQnVmZmVyZWQobWVkaWEsbWVkaWEuY3VycmVudFRpbWUpICYmIEJ1ZmZlckhlbHBlci5pc0J1ZmZlcmVkKG1lZGlhLG1lZGlhLmN1cnJlbnRUaW1lKzAuNSk7XG4gICAgc3dpdGNoKGRhdGEuZGV0YWlscykge1xuICAgICAgY2FzZSBFcnJvckRldGFpbHMuRlJBR19MT0FEX0VSUk9SOlxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuRlJBR19MT0FEX1RJTUVPVVQ6XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5LRVlfTE9BRF9FUlJPUjpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLktFWV9MT0FEX1RJTUVPVVQ6XG4gICAgICAgIGlmKCFkYXRhLmZhdGFsKSB7XG4gICAgICAgICAgdmFyIGxvYWRFcnJvciA9IHRoaXMuZnJhZ0xvYWRFcnJvcjtcbiAgICAgICAgICBpZihsb2FkRXJyb3IpIHtcbiAgICAgICAgICAgIGxvYWRFcnJvcisrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsb2FkRXJyb3I9MTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGV0IGNvbmZpZyA9IHRoaXMuY29uZmlnO1xuICAgICAgICAgIC8vIGtlZXAgcmV0cnlpbmcgLyBkb24ndCByYWlzZSBmYXRhbCBuZXR3b3JrIGVycm9yIGlmIGN1cnJlbnQgcG9zaXRpb24gaXMgYnVmZmVyZWQgb3IgaWYgaW4gYXV0b21vZGUgd2l0aCBjdXJyZW50IGxldmVsIG5vdCAwXG4gICAgICAgICAgaWYgKGxvYWRFcnJvciA8PSBjb25maWcuZnJhZ0xvYWRpbmdNYXhSZXRyeSB8fCBtZWRpYUJ1ZmZlcmVkIHx8IChmcmFnLmF1dG9MZXZlbCAmJiBmcmFnLmxldmVsKSkge1xuICAgICAgICAgICAgdGhpcy5mcmFnTG9hZEVycm9yID0gbG9hZEVycm9yO1xuICAgICAgICAgICAgLy8gcmVzZXQgbG9hZCBjb3VudGVyIHRvIGF2b2lkIGZyYWcgbG9vcCBsb2FkaW5nIGVycm9yXG4gICAgICAgICAgICBmcmFnLmxvYWRDb3VudGVyID0gMDtcbiAgICAgICAgICAgIC8vIGV4cG9uZW50aWFsIGJhY2tvZmYgY2FwcGVkIHRvIGNvbmZpZy5mcmFnTG9hZGluZ01heFJldHJ5VGltZW91dFxuICAgICAgICAgICAgdmFyIGRlbGF5ID0gTWF0aC5taW4oTWF0aC5wb3coMixsb2FkRXJyb3ItMSkqY29uZmlnLmZyYWdMb2FkaW5nUmV0cnlEZWxheSxjb25maWcuZnJhZ0xvYWRpbmdNYXhSZXRyeVRpbWVvdXQpO1xuICAgICAgICAgICAgbG9nZ2VyLndhcm4oYG1lZGlhQ29udHJvbGxlcjogZnJhZyBsb2FkaW5nIGZhaWxlZCwgcmV0cnkgaW4gJHtkZWxheX0gbXNgKTtcbiAgICAgICAgICAgIHRoaXMucmV0cnlEYXRlID0gcGVyZm9ybWFuY2Uubm93KCkgKyBkZWxheTtcbiAgICAgICAgICAgIC8vIHJldHJ5IGxvYWRpbmcgc3RhdGVcbiAgICAgICAgICAgIC8vIGlmIGxvYWRlZG1ldGFkYXRhIGlzIG5vdCBzZXQsIGl0IG1lYW5zIHRoYXQgd2UgYXJlIGVtZXJnZW5jeSBzd2l0Y2ggZG93biBvbiBmaXJzdCBmcmFnXG4gICAgICAgICAgICAvLyBpbiB0aGF0IGNhc2UsIHJlc2V0IHN0YXJ0RnJhZ1JlcXVlc3RlZCBmbGFnXG4gICAgICAgICAgICBpZighdGhpcy5sb2FkZWRtZXRhZGF0YSkge1xuICAgICAgICAgICAgICB0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICB0aGlzLm5leHRMb2FkUG9zaXRpb24gPSB0aGlzLnN0YXJ0UG9zaXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuRlJBR19MT0FESU5HX1dBSVRJTkdfUkVUUlk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcihgbWVkaWFDb250cm9sbGVyOiAke2RhdGEuZGV0YWlsc30gcmVhY2hlcyBtYXggcmV0cnksIHJlZGlzcGF0Y2ggYXMgZmF0YWwgLi4uYCk7XG4gICAgICAgICAgICAvLyBzd2l0Y2ggZXJyb3IgdG8gZmF0YWxcbiAgICAgICAgICAgIGRhdGEuZmF0YWwgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkVSUk9SO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkZSQUdfTE9PUF9MT0FESU5HX0VSUk9SOlxuICAgICAgICBpZighZGF0YS5mYXRhbCkge1xuICAgICAgICAgIC8vIGlmIGJ1ZmZlciBpcyBub3QgZW1wdHlcbiAgICAgICAgICBpZiAobWVkaWFCdWZmZXJlZCkge1xuICAgICAgICAgICAgLy8gdHJ5IHRvIHJlZHVjZSBtYXggYnVmZmVyIGxlbmd0aCA6IHJhdGlvbmFsZSBpcyB0aGF0IHdlIGNvdWxkIGdldFxuICAgICAgICAgICAgLy8gZnJhZyBsb29wIGxvYWRpbmcgZXJyb3IgYmVjYXVzZSBvZiBidWZmZXIgZXZpY3Rpb25cbiAgICAgICAgICAgIHRoaXMuX3JlZHVjZU1heEJ1ZmZlckxlbmd0aChmcmFnLmR1cmF0aW9uKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBidWZmZXIgZW1wdHkuIHJlcG9ydCBhcyBmYXRhbCBpZiBpbiBtYW51YWwgbW9kZSBvciBpZiBsb3dlc3QgbGV2ZWwuXG4gICAgICAgICAgICAvLyBsZXZlbCBjb250cm9sbGVyIHRha2VzIGNhcmUgb2YgZW1lcmdlbmN5IHN3aXRjaCBkb3duIGxvZ2ljXG4gICAgICAgICAgICBpZiAoIWZyYWcuYXV0b0xldmVsIHx8IGZyYWcubGV2ZWwgPT09IDApIHtcbiAgICAgICAgICAgICAgLy8gc3dpdGNoIGVycm9yIHRvIGZhdGFsXG4gICAgICAgICAgICAgIGRhdGEuZmF0YWwgPSB0cnVlO1xuICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuRVJST1I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBFcnJvckRldGFpbHMuTEVWRUxfTE9BRF9FUlJPUjpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkxFVkVMX0xPQURfVElNRU9VVDpcbiAgICAgICAgaWYodGhpcy5zdGF0ZSAhPT0gU3RhdGUuRVJST1IpIHtcbiAgICAgICAgICBpZiAoZGF0YS5mYXRhbCkge1xuICAgICAgICAgICAvLyBpZiBmYXRhbCBlcnJvciwgc3RvcCBwcm9jZXNzaW5nXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuRVJST1I7XG4gICAgICAgICAgICBsb2dnZXIud2Fybihgc3RyZWFtQ29udHJvbGxlcjogJHtkYXRhLmRldGFpbHN9LHN3aXRjaCB0byAke3RoaXMuc3RhdGV9IHN0YXRlIC4uLmApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBpbiBjYXMgb2Ygbm9uIGZhdGFsIGVycm9yIHdoaWxlIHdhaXRpbmcgbGV2ZWwgbG9hZCB0byBiZSBjb21wbGV0ZWQsIHN3aXRjaCBiYWNrIHRvIElETEVcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlID09PSBTdGF0ZS5XQUlUSU5HX0xFVkVMKSB7XG4gICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkJVRkZFUl9GVUxMX0VSUk9SOlxuICAgICAgICAvLyBpZiBpbiBhcHBlbmRpbmcgc3RhdGVcbiAgICAgICAgaWYgKGRhdGEucGFyZW50ID09PSAnbWFpbicgJiYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLlBBUlNJTkcgfHzCoHRoaXMuc3RhdGUgPT09IFN0YXRlLlBBUlNFRCkpIHtcbiAgICAgICAgICAvLyByZWR1Y2UgbWF4IGJ1ZiBsZW4gaWYgY3VycmVudCBwb3NpdGlvbiBpcyBidWZmZXJlZFxuICAgICAgICAgIGlmIChtZWRpYUJ1ZmZlcmVkKSB7XG4gICAgICAgICAgICB0aGlzLl9yZWR1Y2VNYXhCdWZmZXJMZW5ndGgodGhpcy5jb25maWcubWF4QnVmZmVyTGVuZ3RoKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBjdXJyZW50IHBvc2l0aW9uIGlzIG5vdCBidWZmZXJlZCwgYnV0IGJyb3dzZXIgaXMgc3RpbGwgY29tcGxhaW5pbmcgYWJvdXQgYnVmZmVyIGZ1bGwgZXJyb3JcbiAgICAgICAgICAgIC8vIHRoaXMgaGFwcGVucyBvbiBJRS9FZGdlLCByZWZlciB0byBodHRwczovL2dpdGh1Yi5jb20vdmlkZW8tZGV2L2hscy5qcy9wdWxsLzcwOFxuICAgICAgICAgICAgLy8gaW4gdGhhdCBjYXNlIGZsdXNoIHRoZSB3aG9sZSBidWZmZXIgdG8gcmVjb3ZlclxuICAgICAgICAgICAgbG9nZ2VyLndhcm4oJ2J1ZmZlciBmdWxsIGVycm9yIGFsc28gbWVkaWEuY3VycmVudFRpbWUgaXMgbm90IGJ1ZmZlcmVkLCBmbHVzaCBldmVyeXRoaW5nJyk7XG4gICAgICAgICAgICB0aGlzLmZyYWdDdXJyZW50ID0gbnVsbDtcbiAgICAgICAgICAgIC8vIGZsdXNoIGV2ZXJ5dGhpbmdcbiAgICAgICAgICAgIHRoaXMuZmx1c2hNYWluQnVmZmVyKDAsTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBfcmVkdWNlTWF4QnVmZmVyTGVuZ3RoKG1pbkxlbmd0aCkge1xuICAgIGxldCBjb25maWcgPSB0aGlzLmNvbmZpZztcbiAgICBpZiAoY29uZmlnLm1heE1heEJ1ZmZlckxlbmd0aCA+PSBtaW5MZW5ndGgpIHtcbiAgICAgIC8vIHJlZHVjZSBtYXggYnVmZmVyIGxlbmd0aCBhcyBpdCBtaWdodCBiZSB0b28gaGlnaC4gd2UgZG8gdGhpcyB0byBhdm9pZCBsb29wIGZsdXNoaW5nIC4uLlxuICAgICAgY29uZmlnLm1heE1heEJ1ZmZlckxlbmd0aC89MjtcbiAgICAgIGxvZ2dlci53YXJuKGBtYWluOnJlZHVjZSBtYXggYnVmZmVyIGxlbmd0aCB0byAke2NvbmZpZy5tYXhNYXhCdWZmZXJMZW5ndGh9c2ApO1xuICAgICAgLy8gaW5jcmVhc2UgZnJhZ21lbnQgbG9hZCBJbmRleCB0byBhdm9pZCBmcmFnIGxvb3AgbG9hZGluZyBlcnJvciBhZnRlciBidWZmZXIgZmx1c2hcbiAgICAgIHRoaXMuZnJhZ0xvYWRJZHggKz0gMiAqIGNvbmZpZy5mcmFnTG9hZGluZ0xvb3BUaHJlc2hvbGQ7XG4gICAgfVxuICB9XG5cbl9jaGVja0J1ZmZlcigpIHtcbiAgICB2YXIgbWVkaWEgPSB0aGlzLm1lZGlhO1xuICAgIC8vIGlmIHJlYWR5IHN0YXRlIGRpZmZlcmVudCBmcm9tIEhBVkVfTk9USElORyAobnVtZXJpYyB2YWx1ZSAwKSwgd2UgYXJlIGFsbG93ZWQgdG8gc2Vla1xuICAgIGlmKG1lZGlhICYmIG1lZGlhLnJlYWR5U3RhdGUpIHtcbiAgICAgICAgbGV0IGN1cnJlbnRUaW1lID0gbWVkaWEuY3VycmVudFRpbWUsXG4gICAgICAgICAgICBtZWRpYUJ1ZmZlciA9IHRoaXMubWVkaWFCdWZmZXIgPyB0aGlzLm1lZGlhQnVmZmVyIDogbWVkaWEsXG4gICAgICAgICAgICAgYnVmZmVyZWQgPSBtZWRpYUJ1ZmZlci5idWZmZXJlZDtcbiAgICAgIC8vIGFkanVzdCBjdXJyZW50VGltZSB0byBzdGFydCBwb3NpdGlvbiBvbiBsb2FkZWQgbWV0YWRhdGFcbiAgICAgIGlmKCF0aGlzLmxvYWRlZG1ldGFkYXRhICYmIGJ1ZmZlcmVkLmxlbmd0aCkge1xuICAgICAgICB0aGlzLmxvYWRlZG1ldGFkYXRhID0gdHJ1ZTtcbiAgICAgICAgLy8gb25seSBhZGp1c3QgY3VycmVudFRpbWUgaWYgZGlmZmVyZW50IGZyb20gc3RhcnRQb3NpdGlvbiBvciBpZiBzdGFydFBvc2l0aW9uIG5vdCBidWZmZXJlZFxuICAgICAgICAvLyBhdCB0aGF0IHN0YWdlLCB0aGVyZSBzaG91bGQgYmUgb25seSBvbmUgYnVmZmVyZWQgcmFuZ2UsIGFzIHdlIHJlYWNoIHRoYXQgY29kZSBhZnRlciBmaXJzdCBmcmFnbWVudCBoYXMgYmVlbiBidWZmZXJlZFxuICAgICAgICBsZXQgc3RhcnRQb3NpdGlvbiA9IG1lZGlhLnNlZWtpbmcgPyBjdXJyZW50VGltZSA6IHRoaXMuc3RhcnRQb3NpdGlvbixcbiAgICAgICAgICAgIHN0YXJ0UG9zaXRpb25CdWZmZXJlZCA9IEJ1ZmZlckhlbHBlci5pc0J1ZmZlcmVkKG1lZGlhQnVmZmVyLHN0YXJ0UG9zaXRpb24pO1xuICAgICAgICAvLyBpZiBjdXJyZW50VGltZSBub3QgbWF0Y2hpbmcgd2l0aCBleHBlY3RlZCBzdGFydFBvc2l0aW9uIG9yIHN0YXJ0UG9zaXRpb24gbm90IGJ1ZmZlcmVkXG4gICAgICAgIGlmIChjdXJyZW50VGltZSAhPT0gc3RhcnRQb3NpdGlvbiB8fCAhc3RhcnRQb3NpdGlvbkJ1ZmZlcmVkKSB7XG4gICAgICAgICAgbG9nZ2VyLmxvZyhgdGFyZ2V0IHN0YXJ0IHBvc2l0aW9uOiR7c3RhcnRQb3NpdGlvbn1gKTtcbiAgICAgICAgICAvLyBpZiBzdGFydFBvc2l0aW9uIG5vdCBidWZmZXJlZCwgbGV0J3Mgc2VlayB0byBidWZmZXJlZC5zdGFydCgwKVxuICAgICAgICAgIGlmKCFzdGFydFBvc2l0aW9uQnVmZmVyZWQpIHtcbiAgICAgICAgICAgIHN0YXJ0UG9zaXRpb24gPSBidWZmZXJlZC5zdGFydCgwKTtcbiAgICAgICAgICAgIGxvZ2dlci5sb2coYHRhcmdldCBzdGFydCBwb3NpdGlvbiBub3QgYnVmZmVyZWQsIHNlZWsgdG8gYnVmZmVyZWQuc3RhcnQoMCkgJHtzdGFydFBvc2l0aW9ufWApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsb2dnZXIubG9nKGBhZGp1c3QgY3VycmVudFRpbWUgZnJvbSAke2N1cnJlbnRUaW1lfSB0byAke3N0YXJ0UG9zaXRpb259YCk7XG4gICAgICAgICAgbWVkaWEuY3VycmVudFRpbWUgPSBzdGFydFBvc2l0aW9uO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuaW1tZWRpYXRlU3dpdGNoKSB7XG4gICAgICAgIHRoaXMuaW1tZWRpYXRlTGV2ZWxTd2l0Y2hFbmQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBidWZmZXJJbmZvID0gQnVmZmVySGVscGVyLmJ1ZmZlckluZm8obWVkaWEsY3VycmVudFRpbWUsMCksXG4gICAgICAgICAgICBleHBlY3RlZFBsYXlpbmcgPSAhKG1lZGlhLnBhdXNlZCB8fCAvLyBub3QgcGxheWluZyB3aGVuIG1lZGlhIGlzIHBhdXNlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZWRpYS5lbmRlZCAgfHwgLy8gbm90IHBsYXlpbmcgd2hlbiBtZWRpYSBpcyBlbmRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZWRpYS5idWZmZXJlZC5sZW5ndGggPT09IDApLCAvLyBub3QgcGxheWluZyBpZiBub3RoaW5nIGJ1ZmZlcmVkXG4gICAgICAgICAgICBqdW1wVGhyZXNob2xkID0gMC41LCAvLyB0b2xlcmFuY2UgbmVlZGVkIGFzIHNvbWUgYnJvd3NlcnMgc3RhbGxzIHBsYXliYWNrIGJlZm9yZSByZWFjaGluZyBidWZmZXJlZCByYW5nZSBlbmRcbiAgICAgICAgICAgIHBsYXloZWFkTW92aW5nID0gY3VycmVudFRpbWUgIT09IHRoaXMubGFzdEN1cnJlbnRUaW1lLFxuICAgICAgICAgICAgY29uZmlnID0gdGhpcy5jb25maWc7XG5cbiAgICAgICAgaWYgKHBsYXloZWFkTW92aW5nKSB7XG4gICAgICAgICAgLy8gcGxheWVkIG1vdmluZywgYnV0IHdhcyBwcmV2aW91c2x5IHN0YWxsZWQgPT4gbm93IG5vdCBzdHVjayBhbnltb3JlXG4gICAgICAgICAgaWYgKHRoaXMuc3RhbGxSZXBvcnRlZCkge1xuICAgICAgICAgICAgbG9nZ2VyLndhcm4oYHBsYXliYWNrIG5vdCBzdHVjayBhbnltb3JlIEAke2N1cnJlbnRUaW1lfSwgYWZ0ZXIgJHtNYXRoLnJvdW5kKHBlcmZvcm1hbmNlLm5vdygpLXRoaXMuc3RhbGxlZCl9bXNgKTtcbiAgICAgICAgICAgIHRoaXMuc3RhbGxSZXBvcnRlZCA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnN0YWxsZWQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgdGhpcy5udWRnZVJldHJ5ID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBwbGF5aGVhZCBub3QgbW92aW5nXG4gICAgICAgICAgaWYoZXhwZWN0ZWRQbGF5aW5nKSB7XG4gICAgICAgICAgICAvLyBwbGF5aGVhZCBub3QgbW92aW5nIEJVVCBtZWRpYSBleHBlY3RlZCB0byBwbGF5XG4gICAgICAgICAgICBjb25zdCB0bm93ID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgICAgICBjb25zdCBobHMgPSB0aGlzLmhscztcbiAgICAgICAgICAgIGlmKCF0aGlzLnN0YWxsZWQpIHtcbiAgICAgICAgICAgICAgLy8gc3RhbGwganVzdCBkZXRlY3RlZCwgc3RvcmUgY3VycmVudCB0aW1lXG4gICAgICAgICAgICAgIHRoaXMuc3RhbGxlZCA9IHRub3c7XG4gICAgICAgICAgICAgIHRoaXMuc3RhbGxSZXBvcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gcGxheWJhY2sgYWxyZWFkeSBzdGFsbGVkLCBjaGVjayBzdGFsbGluZyBkdXJhdGlvblxuICAgICAgICAgICAgICAvLyBpZiBzdGFsbGluZyBmb3IgbW9yZSB0aGFuIGEgZ2l2ZW4gdGhyZXNob2xkLCBsZXQncyB0cnkgdG8gcmVjb3ZlclxuICAgICAgICAgICAgICBjb25zdCBzdGFsbGVkRHVyYXRpb24gPSB0bm93IC0gdGhpcy5zdGFsbGVkO1xuICAgICAgICAgICAgICBjb25zdCBidWZmZXJMZW4gPSBidWZmZXJJbmZvLmxlbjtcbiAgICAgICAgICAgICAgbGV0IG51ZGdlUmV0cnkgPSB0aGlzLm51ZGdlUmV0cnkgfHwgMDtcbiAgICAgICAgICAgICAgLy8gaGF2ZSB3ZSByZWFjaGVkIHN0YWxsIGRlYWRsaW5lID9cbiAgICAgICAgICAgICAgaWYgKGJ1ZmZlckxlbiA8PSBqdW1wVGhyZXNob2xkICYmIHN0YWxsZWREdXJhdGlvbiA+IGNvbmZpZy5sb3dCdWZmZXJXYXRjaGRvZ1BlcmlvZCAqIDEwMDApIHtcbiAgICAgICAgICAgICAgICAvLyByZXBvcnQgc3RhbGxlZCBlcnJvciBvbmNlXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnN0YWxsUmVwb3J0ZWQpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuc3RhbGxSZXBvcnRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICBsb2dnZXIud2FybihgcGxheWJhY2sgc3RhbGxpbmcgaW4gbG93IGJ1ZmZlciBAJHtjdXJyZW50VGltZX1gKTtcbiAgICAgICAgICAgICAgICAgIGhscy50cmlnZ2VyKEV2ZW50LkVSUk9SLCB7dHlwZTogRXJyb3JUeXBlcy5NRURJQV9FUlJPUiwgZGV0YWlsczogRXJyb3JEZXRhaWxzLkJVRkZFUl9TVEFMTEVEX0VSUk9SLCBmYXRhbDogZmFsc2UsIGJ1ZmZlciA6IGJ1ZmZlckxlbn0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBpZiBidWZmZXIgbGVuIGlzIGJlbG93IHRocmVzaG9sZCwgdHJ5IHRvIGp1bXAgdG8gc3RhcnQgb2YgbmV4dCBidWZmZXIgcmFuZ2UgaWYgY2xvc2VcbiAgICAgICAgICAgICAgICAvLyBubyBidWZmZXIgYXZhaWxhYmxlIEAgY3VycmVudFRpbWUsIGNoZWNrIGlmIG5leHQgYnVmZmVyIGlzIGNsb3NlICh3aXRoaW4gYSBjb25maWcubWF4U2Vla0hvbGUgc2Vjb25kIHJhbmdlKVxuICAgICAgICAgICAgICAgIHZhciBuZXh0QnVmZmVyU3RhcnQgPSBidWZmZXJJbmZvLm5leHRTdGFydCwgZGVsdGEgPSBuZXh0QnVmZmVyU3RhcnQtY3VycmVudFRpbWU7XG4gICAgICAgICAgICAgICAgaWYobmV4dEJ1ZmZlclN0YXJ0ICYmXG4gICAgICAgICAgICAgICAgICAgKGRlbHRhIDwgY29uZmlnLm1heFNlZWtIb2xlKSAmJlxuICAgICAgICAgICAgICAgICAgIChkZWx0YSA+IDApKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLm51ZGdlUmV0cnkgPSArK251ZGdlUmV0cnk7XG4gICAgICAgICAgICAgICAgICBjb25zdCBudWRnZU9mZnNldCA9IG51ZGdlUmV0cnkgKiBjb25maWcubnVkZ2VPZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAvLyBuZXh0IGJ1ZmZlciBpcyBjbG9zZSAhIGFkanVzdCBjdXJyZW50VGltZSB0byBuZXh0QnVmZmVyU3RhcnRcbiAgICAgICAgICAgICAgICAgIC8vIHRoaXMgd2lsbCBlbnN1cmUgZWZmZWN0aXZlIHZpZGVvIGRlY29kaW5nXG4gICAgICAgICAgICAgICAgICBsb2dnZXIubG9nKGBhZGp1c3QgY3VycmVudFRpbWUgZnJvbSAke21lZGlhLmN1cnJlbnRUaW1lfSB0byBuZXh0IGJ1ZmZlcmVkIEAgJHtuZXh0QnVmZmVyU3RhcnR9ICsgbnVkZ2UgJHtudWRnZU9mZnNldH1gKTtcbiAgICAgICAgICAgICAgICAgIG1lZGlhLmN1cnJlbnRUaW1lID0gbmV4dEJ1ZmZlclN0YXJ0ICsgbnVkZ2VPZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAvLyByZXNldCBzdGFsbGVkIHNvIHRvIHJlYXJtIHdhdGNoZG9nIHRpbWVyXG4gICAgICAgICAgICAgICAgICB0aGlzLnN0YWxsZWQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICBobHMudHJpZ2dlcihFdmVudC5FUlJPUiwge3R5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsIGRldGFpbHM6IEVycm9yRGV0YWlscy5CVUZGRVJfU0VFS19PVkVSX0hPTEUsIGZhdGFsOiBmYWxzZSwgaG9sZSA6IG5leHRCdWZmZXJTdGFydCArIG51ZGdlT2Zmc2V0IC0gY3VycmVudFRpbWV9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoYnVmZmVyTGVuID4ganVtcFRocmVzaG9sZCAmJiBzdGFsbGVkRHVyYXRpb24gPiBjb25maWcuaGlnaEJ1ZmZlcldhdGNoZG9nUGVyaW9kICogMTAwMCkge1xuICAgICAgICAgICAgICAgIC8vIHJlcG9ydCBzdGFsbGVkIGVycm9yIG9uY2VcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuc3RhbGxSZXBvcnRlZCkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5zdGFsbFJlcG9ydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIGxvZ2dlci53YXJuKGBwbGF5YmFjayBzdGFsbGluZyBpbiBoaWdoIGJ1ZmZlciBAJHtjdXJyZW50VGltZX1gKTtcbiAgICAgICAgICAgICAgICAgIGhscy50cmlnZ2VyKEV2ZW50LkVSUk9SLCB7dHlwZTogRXJyb3JUeXBlcy5NRURJQV9FUlJPUiwgZGV0YWlsczogRXJyb3JEZXRhaWxzLkJVRkZFUl9TVEFMTEVEX0VSUk9SLCBmYXRhbDogZmFsc2UsIGJ1ZmZlciA6IGJ1ZmZlckxlbn0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyByZXNldCBzdGFsbGVkIHNvIHRvIHJlYXJtIHdhdGNoZG9nIHRpbWVyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGFsbGVkID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHRoaXMubnVkZ2VSZXRyeSA9ICsrbnVkZ2VSZXRyeTtcbiAgICAgICAgICAgICAgICBpZiAobnVkZ2VSZXRyeSA8IGNvbmZpZy5udWRnZU1heFJldHJ5KSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50VGltZSA9IG1lZGlhLmN1cnJlbnRUaW1lO1xuICAgICAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0VGltZSA9IGN1cnJlbnRUaW1lICsgbnVkZ2VSZXRyeSAqIGNvbmZpZy5udWRnZU9mZnNldDtcbiAgICAgICAgICAgICAgICAgIGxvZ2dlci5sb2coYGFkanVzdCBjdXJyZW50VGltZSBmcm9tICR7Y3VycmVudFRpbWV9IHRvICR7dGFyZ2V0VGltZX1gKTtcbiAgICAgICAgICAgICAgICAgIC8vIHBsYXliYWNrIHN0YWxsZWQgaW4gYnVmZmVyZWQgYXJlYSAuLi4gbGV0J3MgbnVkZ2UgY3VycmVudFRpbWUgdG8gdHJ5IHRvIG92ZXJjb21lIHRoaXNcbiAgICAgICAgICAgICAgICAgIG1lZGlhLmN1cnJlbnRUaW1lID0gdGFyZ2V0VGltZTtcbiAgICAgICAgICAgICAgICAgIGhscy50cmlnZ2VyKEV2ZW50LkVSUk9SLCB7dHlwZTogRXJyb3JUeXBlcy5NRURJQV9FUlJPUiwgZGV0YWlsczogRXJyb3JEZXRhaWxzLkJVRkZFUl9OVURHRV9PTl9TVEFMTCwgZmF0YWw6IGZhbHNlfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcihgc3RpbGwgc3R1Y2sgaW4gaGlnaCBidWZmZXIgQCR7Y3VycmVudFRpbWV9IGFmdGVyICR7Y29uZmlnLm51ZGdlTWF4UmV0cnl9LCByYWlzZSBmYXRhbCBlcnJvcmApO1xuICAgICAgICAgICAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnQuRVJST1IsIHt0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLCBkZXRhaWxzOiBFcnJvckRldGFpbHMuQlVGRkVSX1NUQUxMRURfRVJST1IsIGZhdGFsOiB0cnVlfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgb25GcmFnTG9hZEVtZXJnZW5jeUFib3J0ZWQoKSB7XG4gICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgLy8gaWYgbG9hZGVkbWV0YWRhdGEgaXMgbm90IHNldCwgaXQgbWVhbnMgdGhhdCB3ZSBhcmUgZW1lcmdlbmN5IHN3aXRjaCBkb3duIG9uIGZpcnN0IGZyYWdcbiAgICAvLyBpbiB0aGF0IGNhc2UsIHJlc2V0IHN0YXJ0RnJhZ1JlcXVlc3RlZCBmbGFnXG4gICAgaWYoIXRoaXMubG9hZGVkbWV0YWRhdGEpIHtcbiAgICAgIHRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkID0gZmFsc2U7XG4gICAgICB0aGlzLm5leHRMb2FkUG9zaXRpb24gPSB0aGlzLnN0YXJ0UG9zaXRpb247XG4gICAgfVxuICAgIHRoaXMudGljaygpO1xuICB9XG5cbiAgb25CdWZmZXJGbHVzaGVkKCkge1xuICAgIC8qIGFmdGVyIHN1Y2Nlc3NmdWwgYnVmZmVyIGZsdXNoaW5nLCBmaWx0ZXIgZmx1c2hlZCBmcmFnbWVudHMgZnJvbSBidWZmZXJlZEZyYWdzXG4gICAgICB1c2UgbWVkaWFCdWZmZXJlZCBpbnN0ZWFkIG9mIG1lZGlhIChzbyB0aGF0IHdlIHdpbGwgY2hlY2sgYWdhaW5zdCB2aWRlby5idWZmZXJlZCByYW5nZXMgaW4gY2FzZSBvZiBhbHQgYXVkaW8gdHJhY2spXG4gICAgKi9cbiAgICBjb25zdCBtZWRpYSA9IHRoaXMubWVkaWFCdWZmZXIgPyB0aGlzLm1lZGlhQnVmZmVyIDogdGhpcy5tZWRpYTtcbiAgICB0aGlzLl9idWZmZXJlZEZyYWdzID0gdGhpcy5fYnVmZmVyZWRGcmFncy5maWx0ZXIoZnJhZyA9PiB7cmV0dXJuIEJ1ZmZlckhlbHBlci5pc0J1ZmZlcmVkKG1lZGlhLChmcmFnLnN0YXJ0UFRTICsgZnJhZy5lbmRQVFMpIC8gMik7fSk7XG5cbiAgICAvLyBpbmNyZWFzZSBmcmFnbWVudCBsb2FkIEluZGV4IHRvIGF2b2lkIGZyYWcgbG9vcCBsb2FkaW5nIGVycm9yIGFmdGVyIGJ1ZmZlciBmbHVzaFxuICAgIHRoaXMuZnJhZ0xvYWRJZHggKz0gMiAqIHRoaXMuY29uZmlnLmZyYWdMb2FkaW5nTG9vcFRocmVzaG9sZDtcbiAgICAvLyBtb3ZlIHRvIElETEUgb25jZSBmbHVzaCBjb21wbGV0ZS4gdGhpcyBzaG91bGQgdHJpZ2dlciBuZXcgZnJhZ21lbnQgbG9hZGluZ1xuICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgIC8vIHJlc2V0IHJlZmVyZW5jZSB0byBmcmFnXG4gICAgdGhpcy5mcmFnUHJldmlvdXMgPSBudWxsO1xuICB9XG5cbiAgb25MZXZlbFJlbW92ZWQoZGF0YSkge1xuICAgIHRoaXMubGV2ZWxzID0gdGhpcy5sZXZlbHMuZmlsdGVyKChsZXZlbCwgaW5kZXgpID0+IGluZGV4ICE9PSBkYXRhLmxldmVsKTtcbiAgfVxuXG4gIHN3YXBBdWRpb0NvZGVjKCkge1xuICAgIHRoaXMuYXVkaW9Db2RlY1N3YXAgPSAhdGhpcy5hdWRpb0NvZGVjU3dhcDtcbiAgfVxuXG4gIGNvbXB1dGVMaXZlUG9zaXRpb24oc2xpZGluZywgbGV2ZWxEZXRhaWxzKSB7XG4gICAgbGV0IHRhcmdldExhdGVuY3kgPSB0aGlzLmNvbmZpZy5saXZlU3luY0R1cmF0aW9uICE9PSB1bmRlZmluZWQgPyB0aGlzLmNvbmZpZy5saXZlU3luY0R1cmF0aW9uIDogdGhpcy5jb25maWcubGl2ZVN5bmNEdXJhdGlvbkNvdW50ICogbGV2ZWxEZXRhaWxzLnRhcmdldGR1cmF0aW9uO1xuICAgIHJldHVybiBzbGlkaW5nICsgTWF0aC5tYXgoMCwgbGV2ZWxEZXRhaWxzLnRvdGFsZHVyYXRpb24gLSB0YXJnZXRMYXRlbmN5KTtcbiAgfVxuXG4gIGdldCBsaXZlU3luY1Bvc2l0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9saXZlU3luY1Bvc2l0aW9uO1xuICB9XG5cbiAgc2V0IGxpdmVTeW5jUG9zaXRpb24odmFsdWUpIHtcbiAgICB0aGlzLl9saXZlU3luY1Bvc2l0aW9uID0gdmFsdWU7XG4gIH1cbn1cbmV4cG9ydCBkZWZhdWx0IFN0cmVhbUNvbnRyb2xsZXI7XG5cbiIsIi8qXG4gKiBTdWJ0aXRsZSBTdHJlYW0gQ29udHJvbGxlclxuKi9cblxuaW1wb3J0IEV2ZW50IGZyb20gJy4uL2V2ZW50cyc7XG5pbXBvcnQgRXZlbnRIYW5kbGVyIGZyb20gJy4uL2V2ZW50LWhhbmRsZXInO1xuaW1wb3J0IHtsb2dnZXJ9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XG5cbmNsYXNzIFN1YnRpdGxlU3RyZWFtQ29udHJvbGxlciBleHRlbmRzIEV2ZW50SGFuZGxlciB7XG5cbiAgY29uc3RydWN0b3IoaGxzKSB7XG4gICAgc3VwZXIoaGxzLFxuICAgICAgRXZlbnQuRVJST1IsXG4gICAgICBFdmVudC5TVUJUSVRMRV9UUkFDS1NfVVBEQVRFRCxcbiAgICAgIEV2ZW50LlNVQlRJVExFX1RSQUNLX1NXSVRDSCxcbiAgICAgIEV2ZW50LlNVQlRJVExFX1RSQUNLX0xPQURFRCxcbiAgICAgIEV2ZW50LlNVQlRJVExFX0ZSQUdfUFJPQ0VTU0VEKTtcbiAgICB0aGlzLmNvbmZpZyA9IGhscy5jb25maWc7XG4gICAgdGhpcy52dHRGcmFnU05zUHJvY2Vzc2VkID0ge307XG4gICAgdGhpcy52dHRGcmFnUXVldWVzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuY3VycmVudGx5UHJvY2Vzc2luZyA9IG51bGw7XG4gICAgdGhpcy5jdXJyZW50VHJhY2tJZCA9IC0xO1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICBFdmVudEhhbmRsZXIucHJvdG90eXBlLmRlc3Ryb3kuY2FsbCh0aGlzKTtcbiAgfVxuXG4gIC8vIFJlbW92ZSBhbGwgcXVldWVkIGl0ZW1zIGFuZCBjcmVhdGUgYSBuZXcsIGVtcHR5IHF1ZXVlIGZvciBlYWNoIHRyYWNrLlxuICBjbGVhclZ0dEZyYWdRdWV1ZXMoKSB7XG4gICAgdGhpcy52dHRGcmFnUXVldWVzID0ge307XG4gICAgdGhpcy50cmFja3MuZm9yRWFjaCh0cmFjayA9PiB7XG4gICAgICB0aGlzLnZ0dEZyYWdRdWV1ZXNbdHJhY2suaWRdID0gW107XG4gICAgfSk7XG4gIH1cblxuICAvLyBJZiBubyBmcmFnIGlzIGJlaW5nIHByb2Nlc3NlZCBhbmQgcXVldWUgaXNuJ3QgZW1wdHksIGluaXRpYXRlIHByb2Nlc3Npbmcgb2YgbmV4dCBmcmFnIGluIGxpbmUuXG4gIG5leHRGcmFnKCkge1xuICAgIGlmKHRoaXMuY3VycmVudGx5UHJvY2Vzc2luZyA9PT0gbnVsbCAmJiB0aGlzLmN1cnJlbnRUcmFja0lkID4gLTEgJiYgdGhpcy52dHRGcmFnUXVldWVzW3RoaXMuY3VycmVudFRyYWNrSWRdLmxlbmd0aCkge1xuICAgICAgbGV0IGZyYWcgPSB0aGlzLmN1cnJlbnRseVByb2Nlc3NpbmcgPSB0aGlzLnZ0dEZyYWdRdWV1ZXNbdGhpcy5jdXJyZW50VHJhY2tJZF0uc2hpZnQoKTtcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuRlJBR19MT0FESU5HLCB7ZnJhZ30pO1xuICAgIH1cbiAgfVxuXG4gIC8vIFdoZW4gZnJhZ21lbnQgaGFzIGZpbmlzaGVkIHByb2Nlc3NpbmcsIGFkZCBzbiB0byBsaXN0IG9mIGNvbXBsZXRlZCBpZiBzdWNjZXNzZnVsLlxuICBvblN1YnRpdGxlRnJhZ1Byb2Nlc3NlZChkYXRhKSB7XG4gICAgaWYoZGF0YS5zdWNjZXNzKSB7XG4gICAgICB0aGlzLnZ0dEZyYWdTTnNQcm9jZXNzZWRbZGF0YS5mcmFnLnRyYWNrSWRdLnB1c2goZGF0YS5mcmFnLnNuKTtcbiAgICB9XG4gICAgdGhpcy5jdXJyZW50bHlQcm9jZXNzaW5nID0gbnVsbDtcbiAgICB0aGlzLm5leHRGcmFnKCk7XG4gIH1cblxuICAvLyBJZiBzb21ldGhpbmcgZ29lcyB3cm9uZywgcHJvY2VkZSB0byBuZXh0IGZyYWcsIGlmIHdlIHdlcmUgcHJvY2Vzc2luZyBvbmUuXG4gIG9uRXJyb3IoZGF0YSkge1xuICAgIGxldCBmcmFnID0gZGF0YS5mcmFnO1xuICAgIC8vIGRvbid0IGhhbmRsZSBmcmFnIGVycm9yIG5vdCByZWxhdGVkIHRvIHN1YnRpdGxlIGZyYWdtZW50XG4gICAgaWYgKGZyYWcgJiYgZnJhZy50eXBlICE9PSAnc3VidGl0bGUnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmKHRoaXMuY3VycmVudGx5UHJvY2Vzc2luZykge1xuICAgICAgdGhpcy5jdXJyZW50bHlQcm9jZXNzaW5nID0gbnVsbDtcbiAgICAgIHRoaXMubmV4dEZyYWcoKTtcbiAgICB9XG4gIH1cblxuICAvLyBHb3QgYWxsIG5ldyBzdWJ0aXRsZSB0cmFja3MuXG4gIG9uU3VidGl0bGVUcmFja3NVcGRhdGVkKGRhdGEpIHtcbiAgICBsb2dnZXIubG9nKCdzdWJ0aXRsZSB0cmFja3MgdXBkYXRlZCcpO1xuICAgIHRoaXMudHJhY2tzID0gZGF0YS5zdWJ0aXRsZVRyYWNrcztcbiAgICB0aGlzLmNsZWFyVnR0RnJhZ1F1ZXVlcygpO1xuICAgIHRoaXMudnR0RnJhZ1NOc1Byb2Nlc3NlZCA9IHt9O1xuICAgIHRoaXMudHJhY2tzLmZvckVhY2godHJhY2sgPT4ge1xuICAgICAgdGhpcy52dHRGcmFnU05zUHJvY2Vzc2VkW3RyYWNrLmlkXSA9IFtdO1xuICAgIH0pO1xuICB9XG5cbiAgb25TdWJ0aXRsZVRyYWNrU3dpdGNoKGRhdGEpIHtcbiAgICB0aGlzLmN1cnJlbnRUcmFja0lkID0gZGF0YS5pZDtcbiAgICB0aGlzLmNsZWFyVnR0RnJhZ1F1ZXVlcygpO1xuICB9XG5cbiAgLy8gR290IGEgbmV3IHNldCBvZiBzdWJ0aXRsZSBmcmFnbWVudHMuXG4gIG9uU3VidGl0bGVUcmFja0xvYWRlZChkYXRhKSB7XG4gICAgY29uc3QgcHJvY2Vzc2VkRnJhZ1NOcyA9IHRoaXMudnR0RnJhZ1NOc1Byb2Nlc3NlZFtkYXRhLmlkXSxcbiAgICAgICAgZnJhZ1F1ZXVlID0gdGhpcy52dHRGcmFnUXVldWVzW2RhdGEuaWRdLFxuICAgICAgICBjdXJyZW50RnJhZ1NOID0gISF0aGlzLmN1cnJlbnRseVByb2Nlc3NpbmcgPyB0aGlzLmN1cnJlbnRseVByb2Nlc3Npbmcuc24gOiAtMTtcblxuICAgIGNvbnN0IGFscmVhZHlQcm9jZXNzZWQgPSBmdW5jdGlvbihmcmFnKSB7XG4gICAgICByZXR1cm4gcHJvY2Vzc2VkRnJhZ1NOcy5pbmRleE9mKGZyYWcuc24pID4gLTE7XG4gICAgfTtcblxuICAgIGNvbnN0IGFscmVhZHlJblF1ZXVlID0gZnVuY3Rpb24oZnJhZykge1xuICAgICAgcmV0dXJuIGZyYWdRdWV1ZS5zb21lKGZyYWdJblF1ZXVlID0+IHtyZXR1cm4gZnJhZ0luUXVldWUuc24gPT09IGZyYWcuc247fSk7XG4gICAgfTtcblxuICAgIC8vIEFkZCBhbGwgZnJhZ21lbnRzIHRoYXQgaGF2ZW4ndCBiZWVuLCBhcmVuJ3QgY3VycmVudGx5IGJlaW5nIGFuZCBhcmVuJ3Qgd2FpdGluZyB0byBiZSBwcm9jZXNzZWQsIHRvIHF1ZXVlLlxuICAgIGRhdGEuZGV0YWlscy5mcmFnbWVudHMuZm9yRWFjaChmcmFnID0+wqB7XG4gICAgICBpZighKGFscmVhZHlQcm9jZXNzZWQoZnJhZykgfHwgZnJhZy5zbiA9PT0gY3VycmVudEZyYWdTTiB8fCBhbHJlYWR5SW5RdWV1ZShmcmFnKSkpIHtcbiAgICAgICAgLy8gRnJhZ3MgZG9uJ3Qga25vdyB0aGVpciBzdWJ0aXRsZSB0cmFjayBJRCwgc28gbGV0J3MganVzdCBhZGQgdGhhdC4uLlxuICAgICAgICBmcmFnLnRyYWNrSWQgPSBkYXRhLmlkO1xuICAgICAgICBmcmFnUXVldWUucHVzaChmcmFnKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRoaXMubmV4dEZyYWcoKTtcbiAgfVxufVxuZXhwb3J0IGRlZmF1bHQgU3VidGl0bGVTdHJlYW1Db250cm9sbGVyO1xuXG4iLCIvKlxuICogYXVkaW8gdHJhY2sgY29udHJvbGxlclxuKi9cblxuaW1wb3J0IEV2ZW50IGZyb20gJy4uL2V2ZW50cyc7XG5pbXBvcnQgRXZlbnRIYW5kbGVyIGZyb20gJy4uL2V2ZW50LWhhbmRsZXInO1xuaW1wb3J0IHtsb2dnZXJ9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XG5cbmNsYXNzIFN1YnRpdGxlVHJhY2tDb250cm9sbGVyIGV4dGVuZHMgRXZlbnRIYW5kbGVyIHtcblxuICBjb25zdHJ1Y3RvcihobHMpIHtcbiAgICBzdXBlcihobHMsXG4gICAgICAgICAgICAgICBFdmVudC5NRURJQV9BVFRBQ0hFRCxcbiAgICAgICAgICAgICAgIEV2ZW50Lk1FRElBX0RFVEFDSElORyxcbiAgICAgICAgICAgICAgIEV2ZW50Lk1BTklGRVNUX0xPQURJTkcsXG4gICAgICAgICAgICAgICBFdmVudC5NQU5JRkVTVF9MT0FERUQsXG4gICAgICAgICAgICAgICBFdmVudC5TVUJUSVRMRV9UUkFDS19MT0FERUQpO1xuICAgIHRoaXMudHJhY2tzID0gW107XG4gICAgdGhpcy50cmFja0lkID0gLTE7XG4gICAgdGhpcy5tZWRpYSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgRXZlbnRIYW5kbGVyLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XG4gIH1cblxuICAvLyBMaXN0ZW4gZm9yIHN1YnRpdGxlIHRyYWNrIGNoYW5nZSwgdGhlbiBleHRyYWN0IHRoZSBjdXJyZW50IHRyYWNrIElELlxuICBvbk1lZGlhQXR0YWNoZWQoZGF0YSkge1xuICAgIHRoaXMubWVkaWEgPSBkYXRhLm1lZGlhO1xuICAgIGlmICghdGhpcy5tZWRpYSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMubWVkaWEudGV4dFRyYWNrcy5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCAoKSA9PiB7XG4gICAgICAvLyBNZWRpYSBpcyB1bmRlZmluZWQgd2hlbiBzd2l0Y2hpbmcgc3RyZWFtcyB2aWEgbG9hZFNvdXJjZSgpXG4gICAgICBpZiAoIXRoaXMubWVkaWEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBsZXQgdHJhY2tJZCA9IC0xO1xuICAgICAgbGV0IHRyYWNrcyA9IHRoaXMubWVkaWEudGV4dFRyYWNrcztcbiAgICAgIGZvcihsZXQgaWQgPSAwOyBpZDwgdHJhY2tzLmxlbmd0aDsgaWQrKykge1xuICAgICAgICBpZih0cmFja3NbaWRdLm1vZGUgPT09ICdzaG93aW5nJykge1xuICAgICAgICAgIHRyYWNrSWQgPSBpZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gU2V0dGluZyBjdXJyZW50IHN1YnRpdGxlVHJhY2sgd2lsbCBpbnZva2UgY29kZS5cbiAgICAgIHRoaXMuc3VidGl0bGVUcmFjayA9IHRyYWNrSWQ7XG4gICAgfSk7XG4gIH1cblxuICBvbk1lZGlhRGV0YWNoaW5nKCkge1xuICAgIC8vIFRPRE86IFJlbW92ZSBldmVudCBsaXN0ZW5lcnMuXG4gICAgdGhpcy5tZWRpYSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8vIFJlc2V0IHN1YnRpdGxlIHRyYWNrcyBvbiBtYW5pZmVzdCBsb2FkaW5nXG4gIG9uTWFuaWZlc3RMb2FkaW5nKCkge1xuICAgIHRoaXMudHJhY2tzID0gW107XG4gICAgdGhpcy50cmFja0lkID0gLTE7XG4gIH1cblxuICAvLyBGaXJlZCB3aGVuZXZlciBhIG5ldyBtYW5pZmVzdCBpcyBsb2FkZWQuXG4gIG9uTWFuaWZlc3RMb2FkZWQoZGF0YSkge1xuICAgIGxldCB0cmFja3MgPSBkYXRhLnN1YnRpdGxlcyB8fCBbXTtcbiAgICBsZXQgZGVmYXVsdEZvdW5kID0gZmFsc2U7XG4gICAgdGhpcy50cmFja3MgPSB0cmFja3M7XG4gICAgdGhpcy50cmFja0lkID0gLTE7XG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5TVUJUSVRMRV9UUkFDS1NfVVBEQVRFRCwge3N1YnRpdGxlVHJhY2tzIDogdHJhY2tzfSk7XG5cbiAgICAvLyBsb29wIHRocm91Z2ggYXZhaWxhYmxlIHN1YnRpdGxlIHRyYWNrcyBhbmQgYXV0b3NlbGVjdCBkZWZhdWx0IGlmIG5lZWRlZFxuICAgIC8vIFRPRE86IGltcHJvdmUgc2VsZWN0aW9uIGxvZ2ljIHRvIGhhbmRsZSBmb3JjZWQsIGV0Y1xuICAgIHRyYWNrcy5mb3JFYWNoKHRyYWNrID0+IHtcbiAgICAgIGlmICh0cmFjay5kZWZhdWx0KSB7XG4gICAgICAgIHRoaXMuc3VidGl0bGVUcmFjayA9IHRyYWNrLmlkO1xuICAgICAgICBkZWZhdWx0Rm91bmQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLy8gVHJpZ2dlciBzdWJ0aXRsZSB0cmFjayBwbGF5bGlzdCByZWxvYWQuXG4gIG9uVGljaygpIHtcbiAgICBjb25zdCB0cmFja0lkID0gdGhpcy50cmFja0lkO1xuICAgIGNvbnN0IHN1YnRpdGxlVHJhY2sgPSB0aGlzLnRyYWNrc1t0cmFja0lkXTtcbiAgICBpZiAoIXN1YnRpdGxlVHJhY2spIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBkZXRhaWxzID0gc3VidGl0bGVUcmFjay5kZXRhaWxzO1xuICAgIC8vIGNoZWNrIGlmIHdlIG5lZWQgdG8gbG9hZCBwbGF5bGlzdCBmb3IgdGhpcyBzdWJ0aXRsZSBUcmFja1xuICAgIGlmIChkZXRhaWxzID09PSB1bmRlZmluZWQgfHwgZGV0YWlscy5saXZlID09PSB0cnVlKSB7XG4gICAgICAvLyB0cmFjayBub3QgcmV0cmlldmVkIHlldCwgb3IgbGl2ZSBwbGF5bGlzdCB3ZSBuZWVkIHRvIChyZSlsb2FkIGl0XG4gICAgICBsb2dnZXIubG9nKGAocmUpbG9hZGluZyBwbGF5bGlzdCBmb3Igc3VidGl0bGUgdHJhY2sgJHt0cmFja0lkfWApO1xuICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5TVUJUSVRMRV9UUkFDS19MT0FESU5HLCB7dXJsOiBzdWJ0aXRsZVRyYWNrLnVybCwgaWQ6IHRyYWNrSWR9KTtcbiAgICB9XG4gIH1cblxuICBvblN1YnRpdGxlVHJhY2tMb2FkZWQoZGF0YSkge1xuICAgIGlmIChkYXRhLmlkIDwgdGhpcy50cmFja3MubGVuZ3RoKSB7XG4gICAgICBsb2dnZXIubG9nKGBzdWJ0aXRsZSB0cmFjayAke2RhdGEuaWR9IGxvYWRlZGApO1xuICAgICAgdGhpcy50cmFja3NbZGF0YS5pZF0uZGV0YWlscyA9IGRhdGEuZGV0YWlscztcbiAgICAgIC8vIGNoZWNrIGlmIGN1cnJlbnQgcGxheWxpc3QgaXMgYSBsaXZlIHBsYXlsaXN0XG4gICAgICBpZiAoZGF0YS5kZXRhaWxzLmxpdmUgJiYgIXRoaXMudGltZXIpIHtcbiAgICAgICAgLy8gaWYgbGl2ZSBwbGF5bGlzdCB3ZSB3aWxsIGhhdmUgdG8gcmVsb2FkIGl0IHBlcmlvZGljYWxseVxuICAgICAgICAvLyBzZXQgcmVsb2FkIHBlcmlvZCB0byBwbGF5bGlzdCB0YXJnZXQgZHVyYXRpb25cbiAgICAgICAgdGhpcy50aW1lciA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgICB0aGlzLm9uVGljaygpO1xuICAgICAgICB9LCAxMDAwICogZGF0YS5kZXRhaWxzLnRhcmdldGR1cmF0aW9uLCB0aGlzKTtcbiAgICAgIH1cbiAgICAgIGlmICghZGF0YS5kZXRhaWxzLmxpdmUgJiYgdGhpcy50aW1lcikge1xuICAgICAgICAvLyBwbGF5bGlzdCBpcyBub3QgbGl2ZSBhbmQgdGltZXIgaXMgYXJtZWQgOiBzdG9wcGluZyBpdFxuICAgICAgICBjbGVhckludGVydmFsKHRoaXMudGltZXIpO1xuICAgICAgICB0aGlzLnRpbWVyID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKiogZ2V0IGFsdGVybmF0ZSBzdWJ0aXRsZSB0cmFja3MgbGlzdCBmcm9tIHBsYXlsaXN0ICoqL1xuICBnZXQgc3VidGl0bGVUcmFja3MoKSB7XG4gICAgcmV0dXJuIHRoaXMudHJhY2tzO1xuICB9XG5cbiAgLyoqIGdldCBpbmRleCBvZiB0aGUgc2VsZWN0ZWQgc3VidGl0bGUgdHJhY2sgKGluZGV4IGluIHN1YnRpdGxlIHRyYWNrIGxpc3RzKSAqKi9cbiAgZ2V0IHN1YnRpdGxlVHJhY2soKSB7XG4gICByZXR1cm4gdGhpcy50cmFja0lkO1xuICB9XG5cbiAgLyoqIHNlbGVjdCBhIHN1YnRpdGxlIHRyYWNrLCBiYXNlZCBvbiBpdHMgaW5kZXggaW4gc3VidGl0bGUgdHJhY2sgbGlzdHMqKi9cbiAgc2V0IHN1YnRpdGxlVHJhY2soc3VidGl0bGVUcmFja0lkKSB7XG4gICAgaWYgKHRoaXMudHJhY2tJZCAhPT0gc3VidGl0bGVUcmFja0lkKSB7Ly8gfHwgdGhpcy50cmFja3Nbc3VidGl0bGVUcmFja0lkXS5kZXRhaWxzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuc2V0U3VidGl0bGVUcmFja0ludGVybmFsKHN1YnRpdGxlVHJhY2tJZCk7XG4gICAgfVxuICB9XG5cbiBzZXRTdWJ0aXRsZVRyYWNrSW50ZXJuYWwobmV3SWQpIHtcbiAgICAvLyBjaGVjayBpZiBsZXZlbCBpZHggaXMgdmFsaWRcbiAgICBpZiAobmV3SWQgPj0gMCAmJiBuZXdJZCA8IHRoaXMudHJhY2tzLmxlbmd0aCkge1xuICAgICAgLy8gc3RvcHBpbmcgbGl2ZSByZWxvYWRpbmcgdGltZXIgaWYgYW55XG4gICAgICBpZiAodGhpcy50aW1lcikge1xuICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy50aW1lcik7XG4gICAgICAgdGhpcy50aW1lciA9IG51bGw7XG4gICAgICB9XG4gICAgICB0aGlzLnRyYWNrSWQgPSBuZXdJZDtcbiAgICAgIGxvZ2dlci5sb2coYHN3aXRjaGluZyB0byBzdWJ0aXRsZSB0cmFjayAke25ld0lkfWApO1xuICAgICAgbGV0IHN1YnRpdGxlVHJhY2sgPSB0aGlzLnRyYWNrc1tuZXdJZF07XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LlNVQlRJVExFX1RSQUNLX1NXSVRDSCwge2lkOiBuZXdJZH0pO1xuICAgICAgIC8vIGNoZWNrIGlmIHdlIG5lZWQgdG8gbG9hZCBwbGF5bGlzdCBmb3IgdGhpcyBzdWJ0aXRsZSBUcmFja1xuICAgICAgbGV0IGRldGFpbHMgPSBzdWJ0aXRsZVRyYWNrLmRldGFpbHM7XG4gICAgICBpZiAoZGV0YWlscyA9PT0gdW5kZWZpbmVkIHx8IGRldGFpbHMubGl2ZSA9PT0gdHJ1ZSkge1xuICAgICAgICAvLyB0cmFjayBub3QgcmV0cmlldmVkIHlldCwgb3IgbGl2ZSBwbGF5bGlzdCB3ZSBuZWVkIHRvIChyZSlsb2FkIGl0XG4gICAgICAgIGxvZ2dlci5sb2coYChyZSlsb2FkaW5nIHBsYXlsaXN0IGZvciBzdWJ0aXRsZSB0cmFjayAke25ld0lkfWApO1xuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LlNVQlRJVExFX1RSQUNLX0xPQURJTkcsIHt1cmw6IHN1YnRpdGxlVHJhY2sudXJsLCBpZDogbmV3SWR9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgU3VidGl0bGVUcmFja0NvbnRyb2xsZXI7XG4iLCIvKlxuICogVGltZWxpbmUgQ29udHJvbGxlclxuKi9cblxuaW1wb3J0IEV2ZW50IGZyb20gJy4uL2V2ZW50cyc7XG5pbXBvcnQgRXZlbnRIYW5kbGVyIGZyb20gJy4uL2V2ZW50LWhhbmRsZXInO1xuaW1wb3J0IENlYTYwOFBhcnNlciBmcm9tICcuLi91dGlscy9jZWEtNjA4LXBhcnNlcic7XG5pbXBvcnQgV2ViVlRUUGFyc2VyIGZyb20gJy4uL3V0aWxzL3dlYnZ0dC1wYXJzZXInO1xuaW1wb3J0IHtsb2dnZXJ9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XG5cbmZ1bmN0aW9uIGNsZWFyQ3VycmVudEN1ZXModHJhY2spIHtcbiAgaWYgKHRyYWNrICYmIHRyYWNrLmN1ZXMpIHtcbiAgICB3aGlsZSAodHJhY2suY3Vlcy5sZW5ndGggPiAwKSB7XG4gICAgICB0cmFjay5yZW1vdmVDdWUodHJhY2suY3Vlc1swXSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJldXNlVnR0VGV4dFRyYWNrKGluVXNlVHJhY2ssIG1hbmlmZXN0VHJhY2spIHtcbiAgcmV0dXJuIGluVXNlVHJhY2sgJiYgKCFpblVzZVRyYWNrLl9pZCB8fCAvXnN1YnRpdGxlLy50ZXN0KGluVXNlVHJhY2suX2lkKSkgJiZcbiAgICBpblVzZVRyYWNrLmxhYmVsID09PSBtYW5pZmVzdFRyYWNrLm5hbWUgJiYgIShpblVzZVRyYWNrLnRleHRUcmFjazEgfHwgaW5Vc2VUcmFjay50ZXh0VHJhY2syKTtcbn1cblxuZnVuY3Rpb24gaW50ZXJzZWN0aW9uKHgxLCB4MiwgeTEsIHkyKSB7XG4gIHJldHVybiBNYXRoLm1pbih4MiwgeTIpIC0gTWF0aC5tYXgoeDEsIHkxKTtcbn1cblxuY2xhc3MgVGltZWxpbmVDb250cm9sbGVyIGV4dGVuZHMgRXZlbnRIYW5kbGVyIHtcblxuICBjb25zdHJ1Y3RvcihobHMpIHtcbiAgICBzdXBlcihobHMsIEV2ZW50Lk1FRElBX0FUVEFDSElORyxcbiAgICAgICAgICAgICAgICBFdmVudC5NRURJQV9ERVRBQ0hJTkcsXG4gICAgICAgICAgICAgICAgRXZlbnQuRlJBR19QQVJTSU5HX1VTRVJEQVRBLFxuICAgICAgICAgICAgICAgIEV2ZW50Lk1BTklGRVNUX0xPQURJTkcsXG4gICAgICAgICAgICAgICAgRXZlbnQuTUFOSUZFU1RfTE9BREVELFxuICAgICAgICAgICAgICAgIEV2ZW50LkZSQUdfTE9BREVELFxuICAgICAgICAgICAgICAgIEV2ZW50LkxFVkVMX1NXSVRDSElORyxcbiAgICAgICAgICAgICAgICBFdmVudC5JTklUX1BUU19GT1VORCk7XG5cbiAgICB0aGlzLmhscyA9IGhscztcbiAgICB0aGlzLmNvbmZpZyA9IGhscy5jb25maWc7XG4gICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcbiAgICB0aGlzLkN1ZXMgPSBobHMuY29uZmlnLmN1ZUhhbmRsZXI7XG4gICAgdGhpcy50ZXh0VHJhY2tzID0gW107XG4gICAgdGhpcy50cmFja3MgPSBbXTtcbiAgICB0aGlzLnVucGFyc2VkVnR0RnJhZ3MgPSBbXTtcbiAgICB0aGlzLmluaXRQVFMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5jdWVSYW5nZXMgPSBbXTtcbiAgICB0aGlzLm1hbmlmZXN0Q2FwdGlvbnNMYWJlbHMgPSB7fTtcblxuICAgIGlmICh0aGlzLmNvbmZpZy5lbmFibGVDRUE3MDhDYXB0aW9ucylcbiAgICB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgY2FwdGlvbnNMYWJlbHMgPSB0aGlzLm1hbmlmZXN0Q2FwdGlvbnNMYWJlbHM7XG4gICAgICB2YXIgc2VuZEFkZFRyYWNrRXZlbnQgPSBmdW5jdGlvbiAodHJhY2ssIG1lZGlhKVxuICAgICAge1xuICAgICAgICB2YXIgZSA9IG51bGw7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZSA9IG5ldyB3aW5kb3cuRXZlbnQoJ2FkZHRyYWNrJyk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIC8vZm9yIElFMTFcbiAgICAgICAgICBlID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50Jyk7XG4gICAgICAgICAgZS5pbml0RXZlbnQoJ2FkZHRyYWNrJywgZmFsc2UsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBlLnRyYWNrID0gdHJhY2s7XG4gICAgICAgIG1lZGlhLmRpc3BhdGNoRXZlbnQoZSk7XG4gICAgICB9O1xuXG4gICAgICB2YXIgY2hhbm5lbDEgPVxuICAgICAge1xuICAgICAgICAnbmV3Q3VlJzogZnVuY3Rpb24oc3RhcnRUaW1lLCBlbmRUaW1lLCBzY3JlZW4pXG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoIXNlbGYudGV4dFRyYWNrMSlcbiAgICAgICAgICB7XG4gICAgICAgICAgICAvL0VuYWJsZSByZXVzZSBvZiBleGlzdGluZyB0ZXh0IHRyYWNrLlxuICAgICAgICAgICAgdmFyIGV4aXN0aW5nVHJhY2sxID0gc2VsZi5nZXRFeGlzdGluZ1RyYWNrKCcxJyk7XG4gICAgICAgICAgICBpZiAoIWV4aXN0aW5nVHJhY2sxKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBzZWxmLnRleHRUcmFjazEgPSBzZWxmLmNyZWF0ZVRleHRUcmFjaygnY2FwdGlvbnMnLCBjYXB0aW9uc0xhYmVscy5jYXB0aW9uc1RleHRUcmFjazFMYWJlbCxcbiAgICAgICAgICAgICAgICBjYXB0aW9uc0xhYmVscy5jYXB0aW9uc1RleHRUcmFjazFMYW5ndWFnZUNvZGUpO1xuICAgICAgICAgICAgICBzZWxmLnRleHRUcmFjazEudGV4dFRyYWNrMSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHNlbGYudGV4dFRyYWNrMSA9IGV4aXN0aW5nVHJhY2sxO1xuICAgICAgICAgICAgICBjbGVhckN1cnJlbnRDdWVzKHNlbGYudGV4dFRyYWNrMSk7XG5cbiAgICAgICAgICAgICAgc2VuZEFkZFRyYWNrRXZlbnQoc2VsZi50ZXh0VHJhY2sxLCBzZWxmLm1lZGlhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgc2VsZi5hZGRDdWVzKCd0ZXh0VHJhY2sxJywgc3RhcnRUaW1lLCBlbmRUaW1lLCBzY3JlZW4pO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB2YXIgY2hhbm5lbDIgPVxuICAgICAge1xuICAgICAgICAnbmV3Q3VlJzogZnVuY3Rpb24oc3RhcnRUaW1lLCBlbmRUaW1lLCBzY3JlZW4pXG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoIXNlbGYudGV4dFRyYWNrMilcbiAgICAgICAgICB7XG4gICAgICAgICAgICAvL0VuYWJsZSByZXVzZSBvZiBleGlzdGluZyB0ZXh0IHRyYWNrLlxuICAgICAgICAgICAgdmFyIGV4aXN0aW5nVHJhY2syID0gc2VsZi5nZXRFeGlzdGluZ1RyYWNrKCcyJyk7XG4gICAgICAgICAgICBpZiAoIWV4aXN0aW5nVHJhY2syKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBzZWxmLnRleHRUcmFjazIgPSBzZWxmLmNyZWF0ZVRleHRUcmFjaygnY2FwdGlvbnMnLCBjYXB0aW9uc0xhYmVscy5jYXB0aW9uc1RleHRUcmFjazJMYWJlbCxcbiAgICAgICAgICAgICAgICBjYXB0aW9uc0xhYmVscy5jYXB0aW9uc1RleHRUcmFjazJMYW5ndWFnZUNvZGUpO1xuICAgICAgICAgICAgICBzZWxmLnRleHRUcmFjazIudGV4dFRyYWNrMiA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHNlbGYudGV4dFRyYWNrMiA9IGV4aXN0aW5nVHJhY2syO1xuICAgICAgICAgICAgICBjbGVhckN1cnJlbnRDdWVzKHNlbGYudGV4dFRyYWNrMik7XG5cbiAgICAgICAgICAgICAgc2VuZEFkZFRyYWNrRXZlbnQoc2VsZi50ZXh0VHJhY2syLCBzZWxmLm1lZGlhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgc2VsZi5hZGRDdWVzKCd0ZXh0VHJhY2syJywgc3RhcnRUaW1lLCBlbmRUaW1lLCBzY3JlZW4pO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB0aGlzLmNlYTYwOFBhcnNlciA9IG5ldyBDZWE2MDhQYXJzZXIoMCwgY2hhbm5lbDEsIGNoYW5uZWwyKTtcbiAgICB9XG4gIH1cblxuICBhZGRDdWVzKGNoYW5uZWwsIHN0YXJ0VGltZSwgZW5kVGltZSwgc2NyZWVuKSB7XG4gICAgLy8gc2tpcCBjdWVzIHdoaWNoIG92ZXJsYXAgbW9yZSB0aGFuIDUwJSB3aXRoIHByZXZpb3VzbHkgcGFyc2VkIHRpbWUgcmFuZ2VzXG4gICAgY29uc3QgcmFuZ2VzID0gdGhpcy5jdWVSYW5nZXM7XG4gICAgbGV0IG1lcmdlZCA9IGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSByYW5nZXMubGVuZ3RoOyBpLS07KSB7XG4gICAgICBsZXQgY3VlUmFuZ2UgPSByYW5nZXNbaV07XG4gICAgICBsZXQgb3ZlcmxhcCA9IGludGVyc2VjdGlvbihjdWVSYW5nZVswXSwgY3VlUmFuZ2VbMV0sIHN0YXJ0VGltZSwgZW5kVGltZSk7XG4gICAgICBpZiAob3ZlcmxhcCA+PSAwKSB7XG4gICAgICAgIGN1ZVJhbmdlWzBdID0gTWF0aC5taW4oY3VlUmFuZ2VbMF0sIHN0YXJ0VGltZSk7XG4gICAgICAgIGN1ZVJhbmdlWzFdID0gTWF0aC5tYXgoY3VlUmFuZ2VbMV0sIGVuZFRpbWUpO1xuICAgICAgICBtZXJnZWQgPSB0cnVlO1xuICAgICAgICBpZiAoKG92ZXJsYXAgLyAoZW5kVGltZSAtIHN0YXJ0VGltZSkpID4gMC41KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghbWVyZ2VkKSB7XG4gICAgICByYW5nZXMucHVzaChbc3RhcnRUaW1lLCBlbmRUaW1lXSk7XG4gICAgfVxuICAgIHRoaXMuQ3Vlcy5uZXdDdWUodGhpc1tjaGFubmVsXSwgc3RhcnRUaW1lLCBlbmRUaW1lLCBzY3JlZW4pO1xuICB9XG5cbiAgLy8gVHJpZ2dlcmVkIHdoZW4gYW4gaW5pdGlhbCBQVFMgaXMgZm91bmQ7IHVzZWQgZm9yIHN5bmNocm9uaXNhdGlvbiBvZiBXZWJWVFQuXG4gIG9uSW5pdFB0c0ZvdW5kKGRhdGEpIHtcbiAgICBpZiAodHlwZW9mIHRoaXMuaW5pdFBUUyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRoaXMuaW5pdFBUUyA9IGRhdGEuaW5pdFBUUztcbiAgICB9XG5cbiAgICAvLyBEdWUgdG8gYXN5bmNocm9ueSwgaW5pdGlhbCBQVFMgbWF5IGFycml2ZSBsYXRlciB0aGFuIHRoZSBmaXJzdCBWVFQgZnJhZ21lbnRzIGFyZSBsb2FkZWQuXG4gICAgLy8gUGFyc2UgYW55IHVucGFyc2VkIGZyYWdtZW50cyB1cG9uIHJlY2VpdmluZyB0aGUgaW5pdGlhbCBQVFMuXG4gICAgaWYgKHRoaXMudW5wYXJzZWRWdHRGcmFncy5sZW5ndGgpIHtcbiAgICAgIHRoaXMudW5wYXJzZWRWdHRGcmFncy5mb3JFYWNoKGZyYWcgPT4ge1xuICAgICAgICB0aGlzLm9uRnJhZ0xvYWRlZChmcmFnKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy51bnBhcnNlZFZ0dEZyYWdzID0gW107XG4gICAgfVxuICB9XG5cbiAgZ2V0RXhpc3RpbmdUcmFjayhjaGFubmVsTnVtYmVyKSB7XG4gICAgY29uc3QgbWVkaWEgPSB0aGlzLm1lZGlhO1xuICAgIGlmIChtZWRpYSkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtZWRpYS50ZXh0VHJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCB0ZXh0VHJhY2sgPSBtZWRpYS50ZXh0VHJhY2tzW2ldO1xuICAgICAgICBsZXQgcHJvcE5hbWUgPSAndGV4dFRyYWNrJyArIGNoYW5uZWxOdW1iZXI7XG4gICAgICAgIGlmICh0ZXh0VHJhY2tbcHJvcE5hbWVdID09PSB0cnVlKSB7XG4gICAgICAgICAgcmV0dXJuIHRleHRUcmFjaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGNyZWF0ZVRleHRUcmFjayhraW5kLCBsYWJlbCwgbGFuZykge1xuICAgIGNvbnN0IG1lZGlhID0gdGhpcy5tZWRpYTtcbiAgICBpZiAobWVkaWEpXG4gICAge1xuICAgICAgcmV0dXJuIG1lZGlhLmFkZFRleHRUcmFjayhraW5kLCBsYWJlbCwgbGFuZyk7XG4gICAgfVxuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICBFdmVudEhhbmRsZXIucHJvdG90eXBlLmRlc3Ryb3kuY2FsbCh0aGlzKTtcbiAgfVxuXG4gIG9uTWVkaWFBdHRhY2hpbmcoZGF0YSkge1xuICAgIHRoaXMubWVkaWEgPSBkYXRhLm1lZGlhO1xuICB9XG5cbiAgb25NZWRpYURldGFjaGluZygpIHtcbiAgICBjbGVhckN1cnJlbnRDdWVzKHRoaXMudGV4dFRyYWNrMSk7XG4gICAgY2xlYXJDdXJyZW50Q3Vlcyh0aGlzLnRleHRUcmFjazIpO1xuICB9XG5cbiAgb25NYW5pZmVzdExvYWRpbmcoKVxuICB7XG4gICAgdGhpcy5sYXN0U24gPSAtMTsgLy8gRGV0ZWN0IGRpc2NvbnRpZ3VpdHkgaW4gZnJhZ21lbnQgcGFyc2luZ1xuICAgIHRoaXMucHJldkNDID0gLTE7XG4gICAgdGhpcy52dHRDQ3MgPSB7Y2NPZmZzZXQ6IDAsIHByZXNlbnRhdGlvbk9mZnNldDogMH07IC8vIERldGVjdCBkaXNjb250aW51aXR5IGluIHN1YnRpdGxlIG1hbmlmZXN0c1xuXG4gICAgLy8gY2xlYXIgb3V0ZGF0ZWQgc3VidGl0bGVzXG4gICAgY29uc3QgbWVkaWEgPSB0aGlzLm1lZGlhO1xuICAgIGlmIChtZWRpYSkge1xuICAgICAgY29uc3QgdGV4dFRyYWNrcyA9IG1lZGlhLnRleHRUcmFja3M7XG4gICAgICBpZiAodGV4dFRyYWNrcykge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRleHRUcmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjbGVhckN1cnJlbnRDdWVzKHRleHRUcmFja3NbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgb25NYW5pZmVzdExvYWRlZChkYXRhKSB7XG4gICAgdGhpcy50ZXh0VHJhY2tzID0gW107XG4gICAgdGhpcy51bnBhcnNlZFZ0dEZyYWdzID0gdGhpcy51bnBhcnNlZFZ0dEZyYWdzIHx8IFtdO1xuICAgIHRoaXMuaW5pdFBUUyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmN1ZVJhbmdlcyA9IFtdO1xuICAgIHZhciBjYXB0aW9uc0xhYmVscyA9IHRoaXMubWFuaWZlc3RDYXB0aW9uc0xhYmVscztcblxuICAgIGNhcHRpb25zTGFiZWxzLmNhcHRpb25zVGV4dFRyYWNrMUxhYmVsID0gJ1Vua25vd24gQ0MnO1xuICAgIGNhcHRpb25zTGFiZWxzLmNhcHRpb25zVGV4dFRyYWNrMUxhbmd1YWdlQ29kZSA9ICdlbic7XG4gICAgY2FwdGlvbnNMYWJlbHMuY2FwdGlvbnNUZXh0VHJhY2syTGFiZWwgPSAnVW5rbm93biBDQyc7XG4gICAgY2FwdGlvbnNMYWJlbHMuY2FwdGlvbnNUZXh0VHJhY2syTGFuZ3VhZ2VDb2RlID0gJ2VzJztcblxuICAgIGlmICh0aGlzLmNvbmZpZy5lbmFibGVXZWJWVFQpIHtcbiAgICAgIHRoaXMudHJhY2tzID0gZGF0YS5zdWJ0aXRsZXMgfHwgW107XG4gICAgICBjb25zdCBpblVzZVRyYWNrcyA9IHRoaXMubWVkaWEgPyB0aGlzLm1lZGlhLnRleHRUcmFja3MgOiBbXTtcblxuICAgICAgdGhpcy50cmFja3MuZm9yRWFjaCgodHJhY2ssIGluZGV4KSA9PiB7XG4gICAgICAgIGxldCB0ZXh0VHJhY2s7XG4gICAgICAgIGlmIChpbmRleCA8IGluVXNlVHJhY2tzLmxlbmd0aCkge2NvbnN0IGluVXNlVHJhY2sgPSBpblVzZVRyYWNrc1tpbmRleF07XG4gICAgICAgIC8vIFJldXNlIHRyYWNrcyB3aXRoIHRoZSBzYW1lIGxhYmVsLCBidXQgZG8gbm90IHJldXNlIDYwOC83MDggdHJhY2tzXG4gICAgICAgIGlmIChyZXVzZVZ0dFRleHRUcmFjayhpblVzZVRyYWNrLCB0cmFjaykpIHtcbiAgICAgICAgICB0ZXh0VHJhY2sgPSBpblVzZVRyYWNrO1xuICAgICAgICB9IH1cbiAgICAgICAgaWYgKCF0ZXh0VHJhY2spIHtcbiAgICAgICAgICB0ZXh0VHJhY2sgPSB0aGlzLmNyZWF0ZVRleHRUcmFjaygnc3VidGl0bGVzJywgdHJhY2submFtZSwgdHJhY2subGFuZyk7XG4gICAgICAgIH1cbiAgICAgICAgdGV4dFRyYWNrLm1vZGUgPSB0cmFjay5kZWZhdWx0ID8gJ3Nob3dpbmcnIDogJ2hpZGRlbic7XG4gICAgICAgIHRoaXMudGV4dFRyYWNrcy5wdXNoKHRleHRUcmFjayk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5jb25maWcuZW5hYmxlQ0VBNzA4Q2FwdGlvbnMgJiYgZGF0YS5jYXB0aW9ucykge1xuICAgICAgbGV0IGluZGV4O1xuICAgICAgbGV0IGluc3RyZWFtSWRNYXRjaDtcblxuICAgICAgZGF0YS5jYXB0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChjYXB0aW9uc1RyYWNrKSB7XG4gICAgICAgIGluc3RyZWFtSWRNYXRjaCA9IC8oPzpDQ3xTRVJWSUNFKShbMS0yXSkvLmV4ZWMoY2FwdGlvbnNUcmFjay5pbnN0cmVhbUlkKTtcblxuICAgICAgICBpZiAoIWluc3RyZWFtSWRNYXRjaCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGluZGV4ID0gaW5zdHJlYW1JZE1hdGNoWzFdO1xuICAgICAgICBjYXB0aW9uc0xhYmVsc1snY2FwdGlvbnNUZXh0VHJhY2snICsgaW5kZXggKyAnTGFiZWwnXSA9IGNhcHRpb25zVHJhY2submFtZTtcblxuICAgICAgICBpZiAoY2FwdGlvbnNUcmFjay5sYW5nKSB7IC8vIG9wdGlvbmFsIGF0dHJpYnV0ZVxuICAgICAgICAgIGNhcHRpb25zTGFiZWxzWydjYXB0aW9uc1RleHRUcmFjaycgKyBpbmRleCArICdMYW5ndWFnZUNvZGUnXSA9IGNhcHRpb25zVHJhY2subGFuZztcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgb25MZXZlbFN3aXRjaGluZygpIHtcbiAgICB0aGlzLmVuYWJsZWQgPSB0aGlzLmhscy5jdXJyZW50TGV2ZWwuY2xvc2VkQ2FwdGlvbnMgIT09ICdOT05FJztcbiAgfVxuXG4gIG9uRnJhZ0xvYWRlZChkYXRhKSB7XG4gICAgbGV0IGZyYWcgPSBkYXRhLmZyYWcsXG4gICAgICBwYXlsb2FkID0gZGF0YS5wYXlsb2FkO1xuICAgIGlmIChmcmFnLnR5cGUgPT09ICdtYWluJykge1xuICAgICAgdmFyIHNuID0gZnJhZy5zbjtcbiAgICAgIC8vIGlmIHRoaXMgZnJhZyBpc24ndCBjb250aWd1b3VzLCBjbGVhciB0aGUgcGFyc2VyIHNvIGN1ZXMgd2l0aCBiYWQgc3RhcnQvZW5kIHRpbWVzIGFyZW4ndCBhZGRlZCB0byB0aGUgdGV4dFRyYWNrXG4gICAgICBpZiAoc24gIT09IHRoaXMubGFzdFNuICsgMSkge1xuICAgICAgICB0aGlzLmNlYTYwOFBhcnNlci5yZXNldCgpO1xuICAgICAgfVxuICAgICAgdGhpcy5sYXN0U24gPSBzbjtcbiAgICB9XG4gICAgLy8gSWYgZnJhZ21lbnQgaXMgc3VidGl0bGUgdHlwZSwgcGFyc2UgYXMgV2ViVlRULlxuICAgIGVsc2UgaWYgKGZyYWcudHlwZSA9PT0gJ3N1YnRpdGxlJykge1xuICAgICAgaWYgKHBheWxvYWQuYnl0ZUxlbmd0aCkge1xuICAgICAgICAvLyBXZSBuZWVkIGFuIGluaXRpYWwgc3luY2hyb25pc2F0aW9uIFBUUy4gU3RvcmUgZnJhZ21lbnRzIGFzIGxvbmcgYXMgbm9uZSBoYXMgYXJyaXZlZC5cbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmluaXRQVFMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgdGhpcy51bnBhcnNlZFZ0dEZyYWdzLnB1c2goZGF0YSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCB2dHRDQ3MgPSB0aGlzLnZ0dENDcztcbiAgICAgICAgaWYgKCF2dHRDQ3NbZnJhZy5jY10pIHtcbiAgICAgICAgICB2dHRDQ3NbZnJhZy5jY10gPSB7IHN0YXJ0OiBmcmFnLnN0YXJ0LCBwcmV2Q0M6IHRoaXMucHJldkNDLCBuZXc6IHRydWUgfTtcbiAgICAgICAgICB0aGlzLnByZXZDQyA9IGZyYWcuY2M7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRleHRUcmFja3MgPSB0aGlzLnRleHRUcmFja3MsXG4gICAgICAgICAgaGxzID0gdGhpcy5obHM7XG5cbiAgICAgICAgLy8gUGFyc2UgdGhlIFdlYlZUVCBmaWxlIGNvbnRlbnRzLlxuICAgICAgICBXZWJWVFRQYXJzZXIucGFyc2UocGF5bG9hZCwgdGhpcy5pbml0UFRTLCB2dHRDQ3MsIGZyYWcuY2MsIGZ1bmN0aW9uIChjdWVzKSB7XG4gICAgICAgICAgICAvLyBBZGQgY3VlcyBhbmQgdHJpZ2dlciBldmVudCB3aXRoIHN1Y2Nlc3MgdHJ1ZS5cbiAgICAgICAgICAgIGN1ZXMuZm9yRWFjaChjdWUgPT4ge1xuICAgICAgICAgICAgICB0ZXh0VHJhY2tzW2ZyYWcudHJhY2tJZF0uYWRkQ3VlKGN1ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGhscy50cmlnZ2VyKEV2ZW50LlNVQlRJVExFX0ZSQUdfUFJPQ0VTU0VELCB7c3VjY2VzczogdHJ1ZSwgZnJhZzogZnJhZ30pO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIC8vIFNvbWV0aGluZyB3ZW50IHdyb25nIHdoaWxlIHBhcnNpbmcuIFRyaWdnZXIgZXZlbnQgd2l0aCBzdWNjZXNzIGZhbHNlLlxuICAgICAgICAgICAgbG9nZ2VyLmxvZyhgRmFpbGVkIHRvIHBhcnNlIFZUVCBjdWU6ICR7ZX1gKTtcbiAgICAgICAgICAgIGhscy50cmlnZ2VyKEV2ZW50LlNVQlRJVExFX0ZSQUdfUFJPQ0VTU0VELCB7c3VjY2VzczogZmFsc2UsIGZyYWc6IGZyYWd9KTtcbiAgICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAvLyBJbiBjYXNlIHRoZXJlIGlzIG5vIHBheWxvYWQsIGZpbmlzaCB1bnN1Y2Nlc3NmdWxseS5cbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5TVUJUSVRMRV9GUkFHX1BST0NFU1NFRCwge3N1Y2Nlc3M6IGZhbHNlLCBmcmFnOiBmcmFnfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgb25GcmFnUGFyc2luZ1VzZXJkYXRhKGRhdGEpIHtcbiAgICAvLyBwdXNoIGFsbCBvZiB0aGUgQ0VBLTcwOCBtZXNzYWdlcyBpbnRvIHRoZSBpbnRlcnByZXRlclxuICAgIC8vIGltbWVkaWF0ZWx5LiBJdCB3aWxsIGNyZWF0ZSB0aGUgcHJvcGVyIHRpbWVzdGFtcHMgYmFzZWQgb24gb3VyIFBUUyB2YWx1ZVxuICAgIGlmICh0aGlzLmVuYWJsZWQgJiYgdGhpcy5jb25maWcuZW5hYmxlQ0VBNzA4Q2FwdGlvbnMpIHtcbiAgICAgIGZvciAodmFyIGk9MDsgaTxkYXRhLnNhbXBsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNjZGF0YXMgPSB0aGlzLmV4dHJhY3RDZWE2MDhEYXRhKGRhdGEuc2FtcGxlc1tpXS5ieXRlcyk7XG4gICAgICAgIHRoaXMuY2VhNjA4UGFyc2VyLmFkZERhdGEoZGF0YS5zYW1wbGVzW2ldLnB0cywgY2NkYXRhcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZXh0cmFjdENlYTYwOERhdGEoYnl0ZUFycmF5KSB7XG4gICAgdmFyIGNvdW50ID0gYnl0ZUFycmF5WzBdICYgMzE7XG4gICAgdmFyIHBvc2l0aW9uID0gMjtcbiAgICB2YXIgdG1wQnl0ZSwgY2NieXRlMSwgY2NieXRlMiwgY2NWYWxpZCwgY2NUeXBlO1xuICAgIHZhciBhY3R1YWxDQ0J5dGVzID0gW107XG5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNvdW50OyBqKyspIHtcbiAgICAgIHRtcEJ5dGUgPSBieXRlQXJyYXlbcG9zaXRpb24rK107XG4gICAgICBjY2J5dGUxID0gMHg3RiAmIGJ5dGVBcnJheVtwb3NpdGlvbisrXTtcbiAgICAgIGNjYnl0ZTIgPSAweDdGICYgYnl0ZUFycmF5W3Bvc2l0aW9uKytdO1xuICAgICAgY2NWYWxpZCA9ICg0ICYgdG1wQnl0ZSkgIT09IDA7XG4gICAgICBjY1R5cGUgPSAzICYgdG1wQnl0ZTtcblxuICAgICAgaWYgKGNjYnl0ZTEgPT09IDAgJiYgY2NieXRlMiA9PT0gMCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNjVmFsaWQpIHtcbiAgICAgICAgaWYgKGNjVHlwZSA9PT0gMCkgLy8gfHwgY2NUeXBlID09PSAxXG4gICAgICAgIHtcbiAgICAgICAgICBhY3R1YWxDQ0J5dGVzLnB1c2goY2NieXRlMSk7XG4gICAgICAgICAgYWN0dWFsQ0NCeXRlcy5wdXNoKGNjYnl0ZTIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhY3R1YWxDQ0J5dGVzO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFRpbWVsaW5lQ29udHJvbGxlcjtcbiIsImV4cG9ydCBkZWZhdWx0IGNsYXNzIEFFU0NyeXB0byB7XG4gIGNvbnN0cnVjdG9yKHN1YnRsZSxpdikge1xuICAgIHRoaXMuc3VidGxlID0gc3VidGxlO1xuICAgIHRoaXMuYWVzSVYgPSBpdjtcbiAgfVxuXG4gIGRlY3J5cHQoZGF0YSwga2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuc3VidGxlLmRlY3J5cHQoe25hbWU6ICdBRVMtQ0JDJywgaXY6IHRoaXMuYWVzSVZ9LCBrZXksIGRhdGEpO1xuICB9XG59XG4iLCJjbGFzcyBBRVNEZWNyeXB0b3Ige1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICAvLyBTdGF0aWMgYWZ0ZXIgcnVubmluZyBpbml0VGFibGVcbiAgICB0aGlzLnJjb24gPSBbMHgwLCAweDEsIDB4MiwgMHg0LCAweDgsIDB4MTAsIDB4MjAsIDB4NDAsIDB4ODAsIDB4MWIsIDB4MzZdO1xuICAgIHRoaXMuc3ViTWl4ID0gW25ldyBVaW50MzJBcnJheSgyNTYpLG5ldyBVaW50MzJBcnJheSgyNTYpLG5ldyBVaW50MzJBcnJheSgyNTYpLG5ldyBVaW50MzJBcnJheSgyNTYpXTtcbiAgICB0aGlzLmludlN1Yk1peCA9IFtuZXcgVWludDMyQXJyYXkoMjU2KSxuZXcgVWludDMyQXJyYXkoMjU2KSxuZXcgVWludDMyQXJyYXkoMjU2KSxuZXcgVWludDMyQXJyYXkoMjU2KV07XG4gICAgdGhpcy5zQm94ID0gbmV3IFVpbnQzMkFycmF5KDI1Nik7XG4gICAgdGhpcy5pbnZTQm94ID0gbmV3IFVpbnQzMkFycmF5KDI1Nik7XG5cbiAgICAvLyBDaGFuZ2VzIGR1cmluZyBydW50aW1lXG4gICAgdGhpcy5rZXkgPSBuZXcgVWludDMyQXJyYXkoMCk7XG5cbiAgICB0aGlzLmluaXRUYWJsZSgpO1xuICB9XG5cbiAgLy8gVXNpbmcgdmlldy5nZXRVaW50MzIoKSBhbHNvIHN3YXBzIHRoZSBieXRlIG9yZGVyLlxuICB1aW50OEFycmF5VG9VaW50MzJBcnJheV8oYXJyYXlCdWZmZXIpIHtcbiAgICBsZXQgdmlldyA9IG5ldyBEYXRhVmlldyhhcnJheUJ1ZmZlcik7XG4gICAgbGV0IG5ld0FycmF5ID0gbmV3IFVpbnQzMkFycmF5KDQpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICBuZXdBcnJheVtpXSA9IHZpZXcuZ2V0VWludDMyKGkgKiA0KTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld0FycmF5O1xuICB9XG5cbiAgaW5pdFRhYmxlKCkge1xuICAgIGxldCBzQm94ID0gdGhpcy5zQm94O1xuICAgIGxldCBpbnZTQm94ID0gdGhpcy5pbnZTQm94O1xuICAgIGxldCBzdWJNaXggPSB0aGlzLnN1Yk1peDtcbiAgICBsZXQgc3ViTWl4MCA9IHN1Yk1peFswXTtcbiAgICBsZXQgc3ViTWl4MSA9IHN1Yk1peFsxXTtcbiAgICBsZXQgc3ViTWl4MiA9IHN1Yk1peFsyXTtcbiAgICBsZXQgc3ViTWl4MyA9IHN1Yk1peFszXTtcbiAgICBsZXQgaW52U3ViTWl4ICA9IHRoaXMuaW52U3ViTWl4O1xuICAgIGxldCBpbnZTdWJNaXgwID0gaW52U3ViTWl4WzBdO1xuICAgIGxldCBpbnZTdWJNaXgxID0gaW52U3ViTWl4WzFdO1xuICAgIGxldCBpbnZTdWJNaXgyID0gaW52U3ViTWl4WzJdO1xuICAgIGxldCBpbnZTdWJNaXgzID0gaW52U3ViTWl4WzNdO1xuXG4gICAgbGV0IGQgPSBuZXcgVWludDMyQXJyYXkoMjU2KTtcbiAgICBsZXQgeCA9IDA7XG4gICAgbGV0IHhpID0gMDtcbiAgICBsZXQgaSA9IDA7XG4gICAgZm9yIChpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG4gICAgICBpZiAoaSA8IDEyOCkge1xuICAgICAgICBkW2ldID0gaSA8PCAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZFtpXSA9IChpIDw8IDEpIF4gMHgxMWI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG4gICAgICBsZXQgc3ggPSB4aSBeICh4aSA8PCAxKSBeICh4aSA8PCAyKSBeICh4aSA8PCAzKSBeICh4aSA8PCA0KTtcbiAgICAgIHN4ID0gKHN4ID4+PiA4KSBeIChzeCAmIDB4ZmYpIF4gMHg2MztcbiAgICAgIHNCb3hbeF0gPSBzeDtcbiAgICAgIGludlNCb3hbc3hdID0geDtcblxuICAgICAgLy8gQ29tcHV0ZSBtdWx0aXBsaWNhdGlvblxuICAgICAgbGV0IHgyID0gZFt4XTtcbiAgICAgIGxldCB4NCA9IGRbeDJdO1xuICAgICAgbGV0IHg4ID0gZFt4NF07XG5cbiAgICAgIC8vIENvbXB1dGUgc3ViL2ludlN1YiBieXRlcywgbWl4IGNvbHVtbnMgdGFibGVzXG4gICAgICBsZXQgdCA9IChkW3N4XSAqIDB4MTAxKSBeIChzeCAqIDB4MTAxMDEwMCk7XG4gICAgICBzdWJNaXgwW3hdID0gKHQgPDwgMjQpIHwgKHQgPj4+IDgpO1xuICAgICAgc3ViTWl4MVt4XSA9ICh0IDw8IDE2KSB8ICh0ID4+PiAxNik7XG4gICAgICBzdWJNaXgyW3hdID0gKHQgPDwgOCkgfCAodCA+Pj4gMjQpO1xuICAgICAgc3ViTWl4M1t4XSA9IHQ7XG5cbiAgICAgIC8vIENvbXB1dGUgaW52IHN1YiBieXRlcywgaW52IG1peCBjb2x1bW5zIHRhYmxlc1xuICAgICAgdCA9ICh4OCAqIDB4MTAxMDEwMSkgXiAoeDQgKiAweDEwMDAxKSBeICh4MiAqIDB4MTAxKSBeICh4ICogMHgxMDEwMTAwKTtcbiAgICAgIGludlN1Yk1peDBbc3hdID0gKHQgPDwgMjQpIHwgKHQgPj4+IDgpO1xuICAgICAgaW52U3ViTWl4MVtzeF0gPSAodCA8PCAxNikgfCAodCA+Pj4gMTYpO1xuICAgICAgaW52U3ViTWl4MltzeF0gPSAodCA8PCA4KSB8ICh0ID4+PiAyNCk7XG4gICAgICBpbnZTdWJNaXgzW3N4XSA9IHQ7XG5cbiAgICAgIC8vIENvbXB1dGUgbmV4dCBjb3VudGVyXG4gICAgICBpZiAoIXgpIHtcbiAgICAgICAgeCA9IHhpID0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHggPSB4MiBeIGRbZFtkW3g4IF4geDJdXV07XG4gICAgICAgIHhpIF49IGRbZFt4aV1dO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGV4cGFuZEtleShrZXlCdWZmZXIpIHtcbiAgICAvLyBjb252ZXJ0IGtleUJ1ZmZlciB0byBVaW50MzJBcnJheVxuICAgIGxldCBrZXkgPSB0aGlzLnVpbnQ4QXJyYXlUb1VpbnQzMkFycmF5XyhrZXlCdWZmZXIpO1xuICAgIGxldCBzYW1lS2V5ID0gdHJ1ZTtcbiAgICBsZXQgb2Zmc2V0ID0gMDtcblxuICAgIHdoaWxlIChvZmZzZXQgPCBrZXkubGVuZ3RoICYmIHNhbWVLZXkpIHtcbiAgICAgIHNhbWVLZXkgPSAoa2V5W29mZnNldF0gPT09IHRoaXMua2V5W29mZnNldF0pO1xuICAgICAgb2Zmc2V0Kys7XG4gICAgfVxuXG4gICAgaWYgKHNhbWVLZXkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmtleSA9IGtleTtcbiAgICBsZXQga2V5U2l6ZSA9IHRoaXMua2V5U2l6ZSA9IGtleS5sZW5ndGg7XG5cbiAgICBpZiAoa2V5U2l6ZSAhPT0gNCAmJiBrZXlTaXplICE9PSA2ICYmIGtleVNpemUgIT09IDgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhZXMga2V5IHNpemU9JyArIGtleVNpemUpO1xuICAgIH1cblxuICAgIGxldCBrc1Jvd3MgPSB0aGlzLmtzUm93cyA9IChrZXlTaXplICsgNiArIDEpICogNDtcbiAgICBsZXQga3NSb3c7XG4gICAgbGV0IGludktzUm93O1xuXG4gICAgbGV0IGtleVNjaGVkdWxlID0gdGhpcy5rZXlTY2hlZHVsZSA9IG5ldyBVaW50MzJBcnJheShrc1Jvd3MpO1xuICAgIGxldCBpbnZLZXlTY2hlZHVsZSA9IHRoaXMuaW52S2V5U2NoZWR1bGUgPSBuZXcgVWludDMyQXJyYXkoa3NSb3dzKTtcbiAgICBsZXQgc2JveCA9IHRoaXMuc0JveDtcbiAgICBsZXQgcmNvbiA9IHRoaXMucmNvbjtcblxuICAgIGxldCBpbnZTdWJNaXggID0gdGhpcy5pbnZTdWJNaXg7XG4gICAgbGV0IGludlN1Yk1peDAgPSBpbnZTdWJNaXhbMF07XG4gICAgbGV0IGludlN1Yk1peDEgPSBpbnZTdWJNaXhbMV07XG4gICAgbGV0IGludlN1Yk1peDIgPSBpbnZTdWJNaXhbMl07XG4gICAgbGV0IGludlN1Yk1peDMgPSBpbnZTdWJNaXhbM107XG5cbiAgICBsZXQgcHJldjtcbiAgICBsZXQgdDtcblxuICAgIGZvciAoa3NSb3cgPSAwOyBrc1JvdyA8IGtzUm93czsga3NSb3crKykge1xuICAgICAgaWYgKGtzUm93IDwga2V5U2l6ZSkge1xuICAgICAgICBwcmV2ID0ga2V5U2NoZWR1bGVba3NSb3ddID0ga2V5W2tzUm93XTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB0ID0gcHJldjtcblxuICAgICAgaWYgKGtzUm93ICUga2V5U2l6ZSA9PT0gMCkge1xuICAgICAgICAvLyBSb3Qgd29yZFxuICAgICAgICB0ID0gKHQgPDwgOCkgfCAodCA+Pj4gMjQpO1xuXG4gICAgICAgIC8vIFN1YiB3b3JkXG4gICAgICAgIHQgPSAoc2JveFt0ID4+PiAyNF0gPDwgMjQpIHwgKHNib3hbKHQgPj4+IDE2KSAmIDB4ZmZdIDw8IDE2KSB8IChzYm94Wyh0ID4+PiA4KSAmIDB4ZmZdIDw8IDgpIHwgc2JveFt0ICYgMHhmZl07XG5cbiAgICAgICAgLy8gTWl4IFJjb25cbiAgICAgICAgdCBePSByY29uWyhrc1JvdyAvIGtleVNpemUpIHwgMF0gPDwgMjQ7XG4gICAgICB9IGVsc2UgaWYgKGtleVNpemUgPiA2ICYmIGtzUm93ICUga2V5U2l6ZSA9PT0gNCkgIHtcbiAgICAgICAgLy8gU3ViIHdvcmRcbiAgICAgICAgdCA9IChzYm94W3QgPj4+IDI0XSA8PCAyNCkgfCAoc2JveFsodCA+Pj4gMTYpICYgMHhmZl0gPDwgMTYpIHwgKHNib3hbKHQgPj4+IDgpICYgMHhmZl0gPDwgOCkgfCBzYm94W3QgJiAweGZmXTtcbiAgICAgIH1cblxuICAgICAga2V5U2NoZWR1bGVba3NSb3ddID0gcHJldiA9IChrZXlTY2hlZHVsZVtrc1JvdyAtIGtleVNpemVdIF4gdCkgPj4+IDA7XG4gICAgfVxuXG4gICAgZm9yIChpbnZLc1JvdyA9IDA7IGludktzUm93IDwga3NSb3dzOyBpbnZLc1JvdysrKSB7XG4gICAgICBrc1JvdyA9IGtzUm93cyAtIGludktzUm93O1xuICAgICAgaWYgKGludktzUm93ICYgMykge1xuICAgICAgICB0ID0ga2V5U2NoZWR1bGVba3NSb3ddO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdCA9IGtleVNjaGVkdWxlW2tzUm93IC0gNF07XG4gICAgICB9XG5cbiAgICAgIGlmIChpbnZLc1JvdyA8IDQgfHwga3NSb3cgPD0gNCkge1xuICAgICAgICBpbnZLZXlTY2hlZHVsZVtpbnZLc1Jvd10gPSB0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW52S2V5U2NoZWR1bGVbaW52S3NSb3ddID0gaW52U3ViTWl4MFtzYm94W3QgPj4+IDI0XV0gXiBpbnZTdWJNaXgxW3Nib3hbKHQgPj4+IDE2KSAmIDB4ZmZdXSBeIGludlN1Yk1peDJbc2JveFsodCA+Pj4gOCkgJiAweGZmXV0gXiBpbnZTdWJNaXgzW3Nib3hbdCAmIDB4ZmZdXTtcbiAgICAgIH1cblxuICAgICAgaW52S2V5U2NoZWR1bGVbaW52S3NSb3ddID0gaW52S2V5U2NoZWR1bGVbaW52S3NSb3ddID4+PiAwO1xuICAgIH1cbiAgfVxuXG4gIC8vIEFkZGluZyB0aGlzIGFzIGEgbWV0aG9kIGdyZWF0bHkgaW1wcm92ZXMgcGVyZm9ybWFuY2UuXG4gIG5ldHdvcmtUb0hvc3RPcmRlclN3YXAod29yZCkge1xuICAgIHJldHVybiAod29yZCA8PCAyNCkgfCAoKHdvcmQgJiAweGZmMDApIDw8IDgpIHwgKCh3b3JkICYgMHhmZjAwMDApID4+IDgpIHwgKHdvcmQgPj4+IDI0KTtcbiAgfVxuXG4gIGRlY3J5cHQoaW5wdXRBcnJheUJ1ZmZlciwgb2Zmc2V0LCBhZXNJVikge1xuICAgIGxldCBuUm91bmRzID0gdGhpcy5rZXlTaXplICsgNjtcbiAgICBsZXQgaW52S2V5U2NoZWR1bGUgPSB0aGlzLmludktleVNjaGVkdWxlO1xuICAgIGxldCBpbnZTQk9YID0gdGhpcy5pbnZTQm94O1xuXG4gICAgbGV0IGludlN1Yk1peCAgPSB0aGlzLmludlN1Yk1peDtcbiAgICBsZXQgaW52U3ViTWl4MCA9IGludlN1Yk1peFswXTtcbiAgICBsZXQgaW52U3ViTWl4MSA9IGludlN1Yk1peFsxXTtcbiAgICBsZXQgaW52U3ViTWl4MiA9IGludlN1Yk1peFsyXTtcbiAgICBsZXQgaW52U3ViTWl4MyA9IGludlN1Yk1peFszXTtcblxuICAgIGxldCBpbml0VmVjdG9yID0gdGhpcy51aW50OEFycmF5VG9VaW50MzJBcnJheV8oYWVzSVYpO1xuICAgIGxldCBpbml0VmVjdG9yMCA9IGluaXRWZWN0b3JbMF07XG4gICAgbGV0IGluaXRWZWN0b3IxID0gaW5pdFZlY3RvclsxXTtcbiAgICBsZXQgaW5pdFZlY3RvcjIgPSBpbml0VmVjdG9yWzJdO1xuICAgIGxldCBpbml0VmVjdG9yMyA9IGluaXRWZWN0b3JbM107XG5cbiAgICBsZXQgaW5wdXRJbnQzMiA9IG5ldyBJbnQzMkFycmF5KGlucHV0QXJyYXlCdWZmZXIpO1xuICAgIGxldCBvdXRwdXRJbnQzMiA9IG5ldyBJbnQzMkFycmF5KGlucHV0SW50MzIubGVuZ3RoKTtcblxuICAgIGxldCB0MCwgdDEsIHQyLCB0MztcbiAgICBsZXQgczAsIHMxLCBzMiwgczM7XG4gICAgbGV0IGlucHV0V29yZHMwLCBpbnB1dFdvcmRzMSwgaW5wdXRXb3JkczIsIGlucHV0V29yZHMzO1xuXG4gICAgdmFyIGtzUm93LCBpO1xuICAgIGxldCBzd2FwV29yZCA9IHRoaXMubmV0d29ya1RvSG9zdE9yZGVyU3dhcDtcblxuICAgIHdoaWxlIChvZmZzZXQgPCBpbnB1dEludDMyLmxlbmd0aCkge1xuICAgICAgaW5wdXRXb3JkczAgPSBzd2FwV29yZChpbnB1dEludDMyW29mZnNldF0pO1xuICAgICAgaW5wdXRXb3JkczEgPSBzd2FwV29yZChpbnB1dEludDMyW29mZnNldCArIDFdKTtcbiAgICAgIGlucHV0V29yZHMyID0gc3dhcFdvcmQoaW5wdXRJbnQzMltvZmZzZXQgKyAyXSk7XG4gICAgICBpbnB1dFdvcmRzMyA9IHN3YXBXb3JkKGlucHV0SW50MzJbb2Zmc2V0ICsgM10pO1xuXG4gICAgICBzMCA9IGlucHV0V29yZHMwIF4gaW52S2V5U2NoZWR1bGVbMF07XG4gICAgICBzMSA9IGlucHV0V29yZHMzIF4gaW52S2V5U2NoZWR1bGVbMV07XG4gICAgICBzMiA9IGlucHV0V29yZHMyIF4gaW52S2V5U2NoZWR1bGVbMl07XG4gICAgICBzMyA9IGlucHV0V29yZHMxIF4gaW52S2V5U2NoZWR1bGVbM107XG5cbiAgICAgIGtzUm93ID0gNDtcblxuICAgICAgLy8gSXRlcmF0ZSB0aHJvdWdoIHRoZSByb3VuZHMgb2YgZGVjcnlwdGlvblxuICAgICAgZm9yIChpID0gMTsgaSA8IG5Sb3VuZHM7IGkrKykge1xuICAgICAgICB0MCA9IGludlN1Yk1peDBbczAgPj4+IDI0XSBeIGludlN1Yk1peDFbKHMxID4+IDE2KSAmIDB4ZmZdIF4gaW52U3ViTWl4MlsoczIgPj4gOCkgJiAweGZmXSBeIGludlN1Yk1peDNbczMgJiAweGZmXSBeIGludktleVNjaGVkdWxlW2tzUm93XTtcbiAgICAgICAgdDEgPSBpbnZTdWJNaXgwW3MxID4+PiAyNF0gXiBpbnZTdWJNaXgxWyhzMiA+PiAxNikgJiAweGZmXSBeIGludlN1Yk1peDJbKHMzID4+IDgpICYgMHhmZl0gXiBpbnZTdWJNaXgzW3MwICYgMHhmZl0gXiBpbnZLZXlTY2hlZHVsZVtrc1JvdyArIDFdO1xuICAgICAgICB0MiA9IGludlN1Yk1peDBbczIgPj4+IDI0XSBeIGludlN1Yk1peDFbKHMzID4+IDE2KSAmIDB4ZmZdIF4gaW52U3ViTWl4MlsoczAgPj4gOCkgJiAweGZmXSBeIGludlN1Yk1peDNbczEgJiAweGZmXSBeIGludktleVNjaGVkdWxlW2tzUm93ICsgMl07XG4gICAgICAgIHQzID0gaW52U3ViTWl4MFtzMyA+Pj4gMjRdIF4gaW52U3ViTWl4MVsoczAgPj4gMTYpICYgMHhmZl0gXiBpbnZTdWJNaXgyWyhzMSA+PiA4KSAmIDB4ZmZdIF4gaW52U3ViTWl4M1tzMiAmIDB4ZmZdIF4gaW52S2V5U2NoZWR1bGVba3NSb3cgKyAzXTtcbiAgICAgICAgLy8gVXBkYXRlIHN0YXRlXG4gICAgICAgIHMwID0gdDA7XG4gICAgICAgIHMxID0gdDE7XG4gICAgICAgIHMyID0gdDI7XG4gICAgICAgIHMzID0gdDM7XG5cbiAgICAgICAga3NSb3cgPSBrc1JvdyArIDQ7XG4gICAgICB9XG5cbiAgICAgIC8vIFNoaWZ0IHJvd3MsIHN1YiBieXRlcywgYWRkIHJvdW5kIGtleVxuICAgICAgdDAgPSAoKGludlNCT1hbczAgPj4+IDI0XSA8PCAyNCkgXiAoaW52U0JPWFsoczEgPj4gMTYpICYgMHhmZl0gPDwgMTYpIF4gKGludlNCT1hbKHMyID4+IDgpICYgMHhmZl0gPDwgOCkgXiBpbnZTQk9YW3MzICYgMHhmZl0pIF4gaW52S2V5U2NoZWR1bGVba3NSb3ddO1xuICAgICAgdDEgPSAoKGludlNCT1hbczEgPj4+IDI0XSA8PCAyNCkgXiAoaW52U0JPWFsoczIgPj4gMTYpICYgMHhmZl0gPDwgMTYpIF4gKGludlNCT1hbKHMzID4+IDgpICYgMHhmZl0gPDwgOCkgXiBpbnZTQk9YW3MwICYgMHhmZl0pIF4gaW52S2V5U2NoZWR1bGVba3NSb3cgKyAxXTtcbiAgICAgIHQyID0gKChpbnZTQk9YW3MyID4+PiAyNF0gPDwgMjQpIF4gKGludlNCT1hbKHMzID4+IDE2KSAmIDB4ZmZdIDw8IDE2KSBeIChpbnZTQk9YWyhzMCA+PiA4KSAmIDB4ZmZdIDw8IDgpIF4gaW52U0JPWFtzMSAmIDB4ZmZdKSBeIGludktleVNjaGVkdWxlW2tzUm93ICsgMl07XG4gICAgICB0MyA9ICgoaW52U0JPWFtzMyA+Pj4gMjRdIDw8IDI0KSBeIChpbnZTQk9YWyhzMCA+PiAxNikgJiAweGZmXSA8PCAxNikgXiAoaW52U0JPWFsoczEgPj4gOCkgJiAweGZmXSA8PCA4KSBeIGludlNCT1hbczIgJiAweGZmXSkgXiBpbnZLZXlTY2hlZHVsZVtrc1JvdyArIDNdO1xuICAgICAga3NSb3cgPSBrc1JvdyArIDM7XG5cbiAgICAgIC8vIFdyaXRlXG4gICAgICBvdXRwdXRJbnQzMltvZmZzZXRdID0gc3dhcFdvcmQodDAgXiBpbml0VmVjdG9yMCk7XG4gICAgICBvdXRwdXRJbnQzMltvZmZzZXQgKyAxXSA9IHN3YXBXb3JkKHQzIF4gaW5pdFZlY3RvcjEpO1xuICAgICAgb3V0cHV0SW50MzJbb2Zmc2V0ICsgMl0gPSBzd2FwV29yZCh0MiBeIGluaXRWZWN0b3IyKTtcbiAgICAgIG91dHB1dEludDMyW29mZnNldCArIDNdID0gc3dhcFdvcmQodDEgXiBpbml0VmVjdG9yMyk7XG5cbiAgICAgIC8vIHJlc2V0IGluaXRWZWN0b3IgdG8gbGFzdCA0IHVuc2lnbmVkIGludFxuICAgICAgaW5pdFZlY3RvcjAgPSBpbnB1dFdvcmRzMDtcbiAgICAgIGluaXRWZWN0b3IxID0gaW5wdXRXb3JkczE7XG4gICAgICBpbml0VmVjdG9yMiA9IGlucHV0V29yZHMyO1xuICAgICAgaW5pdFZlY3RvcjMgPSBpbnB1dFdvcmRzMztcblxuICAgICAgb2Zmc2V0ID0gb2Zmc2V0ICsgNDtcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0cHV0SW50MzIuYnVmZmVyO1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmtleSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmtleVNpemUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5rc1Jvd3MgPSB1bmRlZmluZWQ7XG5cbiAgICB0aGlzLnNCb3ggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5pbnZTQm94ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuc3ViTWl4ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuaW52U3ViTWl4ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMua2V5U2NoZWR1bGUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5pbnZLZXlTY2hlZHVsZSA9IHVuZGVmaW5lZDtcblxuICAgIHRoaXMucmNvbiA9IHVuZGVmaW5lZDtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBBRVNEZWNyeXB0b3I7XG4iLCJpbXBvcnQgQUVTQ3J5cHRvIGZyb20gJy4vYWVzLWNyeXB0byc7XG5pbXBvcnQgRmFzdEFFU0tleSBmcm9tICcuL2Zhc3QtYWVzLWtleSc7XG5pbXBvcnQgQUVTRGVjcnlwdG9yIGZyb20gJy4vYWVzLWRlY3J5cHRvcic7XG5cbmltcG9ydCB7RXJyb3JUeXBlcywgRXJyb3JEZXRhaWxzfSBmcm9tICcuLi9lcnJvcnMnO1xuaW1wb3J0IHtsb2dnZXJ9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XG5cbi8qZ2xvYmFscyBzZWxmOiBmYWxzZSAqL1xuXG5jbGFzcyBEZWNyeXB0ZXIge1xuICBjb25zdHJ1Y3RvcihvYnNlcnZlcixjb25maWcpIHtcbiAgICB0aGlzLm9ic2VydmVyID0gb2JzZXJ2ZXI7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgdGhpcy5sb2dFbmFibGVkID0gdHJ1ZTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgYnJvd3NlckNyeXB0byA9IGNyeXB0byA/IGNyeXB0byA6IHNlbGYuY3J5cHRvO1xuICAgICAgdGhpcy5zdWJ0bGUgPSBicm93c2VyQ3J5cHRvLnN1YnRsZSB8fCBicm93c2VyQ3J5cHRvLndlYmtpdFN1YnRsZTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIHRoaXMuZGlzYWJsZVdlYkNyeXB0byA9ICF0aGlzLnN1YnRsZTtcbiAgfVxuXG4gIGlzU3luYygpIHtcbiAgICByZXR1cm4gKHRoaXMuZGlzYWJsZVdlYkNyeXB0byAmJiB0aGlzLmNvbmZpZy5lbmFibGVTb2Z0d2FyZUFFUyk7XG4gIH1cblxuICBkZWNyeXB0KGRhdGEsIGtleSwgaXYsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHRoaXMuZGlzYWJsZVdlYkNyeXB0byAmJiB0aGlzLmNvbmZpZy5lbmFibGVTb2Z0d2FyZUFFUykge1xuICAgICAgaWYgKHRoaXMubG9nRW5hYmxlZCkge1xuICAgICAgICBsb2dnZXIubG9nKCdKUyBBRVMgZGVjcnlwdCcpO1xuICAgICAgICB0aGlzLmxvZ0VuYWJsZWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGxldCBkZWNyeXB0b3IgPSB0aGlzLmRlY3J5cHRvcjtcbiAgICAgIGlmICghZGVjcnlwdG9yKSB7XG4gICAgICAgIHRoaXMuZGVjcnlwdG9yID0gZGVjcnlwdG9yID0gbmV3IEFFU0RlY3J5cHRvcigpO1xuICAgICAgfVxuICAgICAgZGVjcnlwdG9yLmV4cGFuZEtleShrZXkpO1xuICAgICAgY2FsbGJhY2soZGVjcnlwdG9yLmRlY3J5cHQoZGF0YSwgMCwgaXYpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBpZiAodGhpcy5sb2dFbmFibGVkKSB7XG4gICAgICAgIGxvZ2dlci5sb2coJ1dlYkNyeXB0byBBRVMgZGVjcnlwdCcpO1xuICAgICAgICB0aGlzLmxvZ0VuYWJsZWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHN1YnRsZSA9IHRoaXMuc3VidGxlO1xuICAgICAgaWYgKHRoaXMua2V5ICE9PSBrZXkpIHtcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgICAgIHRoaXMuZmFzdEFlc0tleSA9IG5ldyBGYXN0QUVTS2V5KHN1YnRsZSxrZXkpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmZhc3RBZXNLZXkuZXhwYW5kS2V5KCkuXG4gICAgICAgIHRoZW4oKGFlc0tleSkgPT4ge1xuICAgICAgICAgIC8vIGRlY3J5cHQgdXNpbmcgd2ViIGNyeXB0b1xuICAgICAgICAgIGxldCBjcnlwdG8gPSBuZXcgQUVTQ3J5cHRvKHN1YnRsZSxpdik7XG4gICAgICAgICAgY3J5cHRvLmRlY3J5cHQoZGF0YSwgYWVzS2V5KS5cbiAgICAgICAgICBjYXRjaCAoKGVycikgPT4ge1xuICAgICAgICAgICAgdGhpcy5vbldlYkNyeXB0b0Vycm9yKGVyciwgZGF0YSwga2V5LCBpdiwgY2FsbGJhY2spO1xuICAgICAgICAgIH0pLlxuICAgICAgICAgIHRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgY2FsbGJhY2socmVzdWx0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSkuXG4gICAgICAgIGNhdGNoICgoZXJyKSA9PiB7XG4gICAgICAgICAgdGhpcy5vbldlYkNyeXB0b0Vycm9yKGVyciwgZGF0YSwga2V5LCBpdiwgY2FsbGJhY2spO1xuICAgICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBvbldlYkNyeXB0b0Vycm9yKGVyciwgZGF0YSwga2V5LCBpdiwgY2FsbGJhY2spIHtcbiAgICBpZiAodGhpcy5jb25maWcuZW5hYmxlU29mdHdhcmVBRVMpIHtcbiAgICAgIGxvZ2dlci5sb2coJ1dlYkNyeXB0byBFcnJvciwgZGlzYWJsZSBXZWJDcnlwdG8gQVBJJyk7XG4gICAgICB0aGlzLmRpc2FibGVXZWJDcnlwdG8gPSB0cnVlO1xuICAgICAgdGhpcy5sb2dFbmFibGVkID0gdHJ1ZTtcbiAgICAgIHRoaXMuZGVjcnlwdChkYXRhLCBrZXksIGl2LCBjYWxsYmFjayk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgbG9nZ2VyLmVycm9yKGBkZWNyeXB0aW5nIGVycm9yIDogJHtlcnIubWVzc2FnZX1gKTtcbiAgICAgIHRoaXMub2JzZXJ2ZXIudHJpZ2dlcihFdmVudC5FUlJPUiwge3R5cGUgOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLCBkZXRhaWxzIDogRXJyb3JEZXRhaWxzLkZSQUdfREVDUllQVF9FUlJPUiwgZmF0YWwgOiB0cnVlLCByZWFzb24gOiBlcnIubWVzc2FnZX0pO1xuICAgIH1cbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgbGV0IGRlY3J5cHRvciA9IHRoaXMuZGVjcnlwdG9yO1xuICAgIGlmIChkZWNyeXB0b3IpIHtcbiAgICAgIGRlY3J5cHRvci5kZXN0cm95KCk7XG4gICAgICB0aGlzLmRlY3J5cHRvciA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgRGVjcnlwdGVyO1xuIiwiY2xhc3MgRmFzdEFFU0tleSB7XG4gIGNvbnN0cnVjdG9yKHN1YnRsZSxrZXkpIHtcbiAgICB0aGlzLnN1YnRsZSA9IHN1YnRsZTtcbiAgICB0aGlzLmtleSA9IGtleTtcbiAgfVxuXG4gIGV4cGFuZEtleSgpIHtcbiAgICByZXR1cm4gdGhpcy5zdWJ0bGUuaW1wb3J0S2V5KCdyYXcnLCB0aGlzLmtleSwge25hbWU6ICdBRVMtQ0JDJ30sIGZhbHNlLCBbJ2VuY3J5cHQnLCAnZGVjcnlwdCddKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBGYXN0QUVTS2V5O1xuIiwiLyoqXG4gKiBBQUMgZGVtdXhlclxuICovXG5pbXBvcnQgQURUUyBmcm9tICcuL2FkdHMnO1xuaW1wb3J0IHtsb2dnZXJ9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XG5pbXBvcnQgSUQzIGZyb20gJy4uL2RlbXV4L2lkMyc7XG5cbiBjbGFzcyBBQUNEZW11eGVyIHtcblxuICBjb25zdHJ1Y3RvcihvYnNlcnZlciwgcmVtdXhlciwgY29uZmlnKSB7XG4gICAgdGhpcy5vYnNlcnZlciA9IG9ic2VydmVyO1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgIHRoaXMucmVtdXhlciA9IHJlbXV4ZXI7XG4gIH1cblxuICByZXNldEluaXRTZWdtZW50KGluaXRTZWdtZW50LGF1ZGlvQ29kZWMsdmlkZW9Db2RlYywgZHVyYXRpb24pIHtcbiAgICB0aGlzLl9hYWNUcmFjayA9IHtjb250YWluZXIgOiAnYXVkaW8vYWR0cycsIHR5cGU6ICdhdWRpbycsIGlkIDotMSwgc2VxdWVuY2VOdW1iZXI6IDAsIGlzQUFDIDogdHJ1ZSAsIHNhbXBsZXMgOiBbXSwgbGVuIDogMCwgbWFuaWZlc3RDb2RlYyA6IGF1ZGlvQ29kZWMsIGR1cmF0aW9uIDogZHVyYXRpb24sIGlucHV0VGltZVNjYWxlIDogOTAwMDB9O1xuICB9XG5cbiAgcmVzZXRUaW1lU3RhbXAoKSB7XG4gIH1cblxuICAvLyBTb3VyY2UgZm9yIHByb2JlIGluZm8gLSBodHRwczovL3dpa2kubXVsdGltZWRpYS5jeC9pbmRleC5waHA/dGl0bGU9QURUU1xuICBzdGF0aWMgcHJvYmUoZGF0YSkge1xuICAgIHZhciBpZDMgPSBuZXcgSUQzKGRhdGEpLCBvZmZzZXQsIGxlbjtcbiAgICBmb3IgKCBvZmZzZXQgPSBpZDMubGVuZ3RoIHx8IDAsIGxlbiA9IGRhdGEubGVuZ3RoOyBvZmZzZXQgPCBsZW4gLSAxOyBvZmZzZXQrKykge1xuICAgICAgLy8gQURUUyBIZWFkZXIgaXMgfCAxMTExIDExMTEgfCAxMTExIFgwMFggfCB3aGVyZSBYIGNhbiBiZSBlaXRoZXIgMCBvciAxXG4gICAgICBpZiAoKGRhdGFbb2Zmc2V0XSA9PT0gMHhmZikgJiYgKGRhdGFbb2Zmc2V0KzFdICYgMHhmNikgPT09IDB4ZjApIHtcbiAgICAgICAgLy9sb2dnZXIubG9nKCdBRFRTIHN5bmMgd29yZCBmb3VuZCAhJyk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBmZWVkIGluY29taW5nIGRhdGEgdG8gdGhlIGZyb250IG9mIHRoZSBwYXJzaW5nIHBpcGVsaW5lXG4gIGFwcGVuZChkYXRhLCB0aW1lT2Zmc2V0LCBjb250aWd1b3VzLGFjY3VyYXRlVGltZU9mZnNldCkge1xuICAgIHZhciB0cmFjayxcbiAgICAgICAgaWQzID0gbmV3IElEMyhkYXRhKSxcbiAgICAgICAgcHRzLCBjb25maWcsIGZyYW1lTGVuZ3RoLCBmcmFtZUR1cmF0aW9uLCBmcmFtZUluZGV4LCBvZmZzZXQsIGhlYWRlckxlbmd0aCwgc3RhbXAsIGxlbiwgYWFjU2FtcGxlO1xuXG4gICAgLy8gVXNlIElEMyBUaW1lc3RhbXAgaWYgbmVlZGVkLCBhcyBpbiB2NCBhdWRpbyB0cmFja3MuICBPdGhlcndpc2UsIGNvbmNhdCBBQUMgYXVkaW8gaW4gdGhlIG9yZGVyIGl0IGNvbWVzIGluLlxuICAgIHB0cyA9IChpZDMudGltZVN0YW1wKSA/IDkwICogaWQzLnRpbWVTdGFtcCA6IHRpbWVPZmZzZXQgKiA5MDAwMDtcblxuICAgIHRyYWNrID0gdGhpcy5fYWFjVHJhY2s7XG5cbiAgICAvLyBMb29rIGZvciBBRFRTIGhlYWRlciB8IDExMTEgMTExMSB8IDExMTEgWDAwWCB8IHdoZXJlIFggY2FuIGJlIGVpdGhlciAwIG9yIDFcbiAgICBmb3IgKG9mZnNldCA9IGlkMy5sZW5ndGggfHwgMCwgbGVuID0gZGF0YS5sZW5ndGg7IG9mZnNldCA8IGxlbiAtIDE7IG9mZnNldCsrKSB7XG4gICAgICBpZiAoKGRhdGFbb2Zmc2V0XSA9PT0gMHhmZikgJiYgKGRhdGFbb2Zmc2V0KzFdICYgMHhmNikgPT09IDB4ZjApIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCF0cmFjay5zYW1wbGVyYXRlKSB7XG4gICAgICBjb25maWcgPSBBRFRTLmdldEF1ZGlvQ29uZmlnKHRoaXMub2JzZXJ2ZXIsZGF0YSwgb2Zmc2V0LCB0cmFjay5tYW5pZmVzdENvZGVjKTtcbiAgICAgIHRyYWNrLmNvbmZpZyA9IGNvbmZpZy5jb25maWc7XG4gICAgICB0cmFjay5zYW1wbGVyYXRlID0gY29uZmlnLnNhbXBsZXJhdGU7XG4gICAgICB0cmFjay5jaGFubmVsQ291bnQgPSBjb25maWcuY2hhbm5lbENvdW50O1xuICAgICAgdHJhY2suY29kZWMgPSBjb25maWcuY29kZWM7XG4gICAgICBsb2dnZXIubG9nKGBwYXJzZWQgY29kZWM6JHt0cmFjay5jb2RlY30scmF0ZToke2NvbmZpZy5zYW1wbGVyYXRlfSxuYiBjaGFubmVsOiR7Y29uZmlnLmNoYW5uZWxDb3VudH1gKTtcbiAgICB9XG4gICAgZnJhbWVJbmRleCA9IDA7XG4gICAgZnJhbWVEdXJhdGlvbiA9IDEwMjQgKiA5MDAwMCAvIHRyYWNrLnNhbXBsZXJhdGU7XG4gICAgd2hpbGUgKChvZmZzZXQgKyA1KSA8IGxlbikge1xuICAgICAgLy8gVGhlIHByb3RlY3Rpb24gc2tpcCBiaXQgdGVsbHMgdXMgaWYgd2UgaGF2ZSAyIGJ5dGVzIG9mIENSQyBkYXRhIGF0IHRoZSBlbmQgb2YgdGhlIEFEVFMgaGVhZGVyXG4gICAgICBoZWFkZXJMZW5ndGggPSAoISEoZGF0YVtvZmZzZXQgKyAxXSAmIDB4MDEpID8gNyA6IDkpO1xuICAgICAgLy8gcmV0cmlldmUgZnJhbWUgc2l6ZVxuICAgICAgZnJhbWVMZW5ndGggPSAoKGRhdGFbb2Zmc2V0ICsgM10gJiAweDAzKSA8PCAxMSkgfFxuICAgICAgICAgICAgICAgICAgICAgKGRhdGFbb2Zmc2V0ICsgNF0gPDwgMykgfFxuICAgICAgICAgICAgICAgICAgICAoKGRhdGFbb2Zmc2V0ICsgNV0gJiAweEUwKSA+Pj4gNSk7XG4gICAgICBmcmFtZUxlbmd0aCAgLT0gaGVhZGVyTGVuZ3RoO1xuICAgICAgLy9zdGFtcCA9IHBlcy5wdHM7XG5cbiAgICAgIGlmICgoZnJhbWVMZW5ndGggPiAwKSAmJiAoKG9mZnNldCArIGhlYWRlckxlbmd0aCArIGZyYW1lTGVuZ3RoKSA8PSBsZW4pKSB7XG4gICAgICAgIHN0YW1wID0gcHRzICsgZnJhbWVJbmRleCAqIGZyYW1lRHVyYXRpb247XG4gICAgICAgIC8vbG9nZ2VyLmxvZyhgQUFDIGZyYW1lLCBvZmZzZXQvbGVuZ3RoL3RvdGFsL3B0czoke29mZnNldCtoZWFkZXJMZW5ndGh9LyR7ZnJhbWVMZW5ndGh9LyR7ZGF0YS5ieXRlTGVuZ3RofS8keyhzdGFtcC85MCkudG9GaXhlZCgwKX1gKTtcbiAgICAgICAgYWFjU2FtcGxlID0ge3VuaXQ6IGRhdGEuc3ViYXJyYXkob2Zmc2V0ICsgaGVhZGVyTGVuZ3RoLCBvZmZzZXQgKyBoZWFkZXJMZW5ndGggKyBmcmFtZUxlbmd0aCksIHB0czogc3RhbXAsIGR0czogc3RhbXB9O1xuICAgICAgICB0cmFjay5zYW1wbGVzLnB1c2goYWFjU2FtcGxlKTtcbiAgICAgICAgdHJhY2subGVuICs9IGZyYW1lTGVuZ3RoO1xuICAgICAgICBvZmZzZXQgKz0gZnJhbWVMZW5ndGggKyBoZWFkZXJMZW5ndGg7XG4gICAgICAgIGZyYW1lSW5kZXgrKztcbiAgICAgICAgLy8gbG9vayBmb3IgQURUUyBoZWFkZXIgKDB4RkZGeClcbiAgICAgICAgZm9yICggOyBvZmZzZXQgPCAobGVuIC0gMSk7IG9mZnNldCsrKSB7XG4gICAgICAgICAgaWYgKChkYXRhW29mZnNldF0gPT09IDB4ZmYpICYmICgoZGF0YVtvZmZzZXQgKyAxXSAmIDB4ZjApID09PSAweGYwKSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgaWQzVHJhY2sgPSAoaWQzLnBheWxvYWQpID8geyBzYW1wbGVzIDogW3sgcHRzOiBwdHMsIGR0cyA6IHB0cywgdW5pdCA6IGlkMy5wYXlsb2FkfV0sIGlucHV0VGltZVNjYWxlOiA5MDAwMCB9IDogeyBzYW1wbGVzOiBbXSB9O1xuICAgIHRoaXMucmVtdXhlci5yZW11eCh0cmFjayxcbiAgICAgICAgICAgICAgICAgICAgICAgIHtzYW1wbGVzIDogW119LFxuICAgICAgICAgICAgICAgICAgICAgICAgaWQzVHJhY2ssXG4gICAgICAgICAgICAgICAgICAgICAgICB7c2FtcGxlcyA6IFtdfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVPZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aWd1b3VzLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWNjdXJhdGVUaW1lT2Zmc2V0KTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gIH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBBQUNEZW11eGVyO1xuIiwiLyoqXG4gKiAgQURUUyBwYXJzZXIgaGVscGVyXG4gKi9cbmltcG9ydCB7bG9nZ2VyfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xuaW1wb3J0IHtFcnJvclR5cGVzLCBFcnJvckRldGFpbHN9IGZyb20gJy4uL2Vycm9ycyc7XG5cbiBjb25zdCBBRFRTID0ge1xuICBnZXRBdWRpb0NvbmZpZyA6IGZ1bmN0aW9uKG9ic2VydmVyLCBkYXRhLCBvZmZzZXQsIGF1ZGlvQ29kZWMpIHtcbiAgICB2YXIgYWR0c09iamVjdFR5cGUsIC8vIDppbnRcbiAgICAgICAgYWR0c1NhbXBsZWluZ0luZGV4LCAvLyA6aW50XG4gICAgICAgIGFkdHNFeHRlbnNpb25TYW1wbGVpbmdJbmRleCwgLy8gOmludFxuICAgICAgICBhZHRzQ2hhbmVsQ29uZmlnLCAvLyA6aW50XG4gICAgICAgIGNvbmZpZyxcbiAgICAgICAgdXNlckFnZW50ID0gbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLFxuICAgICAgICBtYW5pZmVzdENvZGVjID0gYXVkaW9Db2RlYyxcbiAgICAgICAgYWR0c1NhbXBsZWluZ1JhdGVzID0gW1xuICAgICAgICAgICAgOTYwMDAsIDg4MjAwLFxuICAgICAgICAgICAgNjQwMDAsIDQ4MDAwLFxuICAgICAgICAgICAgNDQxMDAsIDMyMDAwLFxuICAgICAgICAgICAgMjQwMDAsIDIyMDUwLFxuICAgICAgICAgICAgMTYwMDAsIDEyMDAwLFxuICAgICAgICAgICAgMTEwMjUsIDgwMDAsXG4gICAgICAgICAgICA3MzUwXTtcbiAgICAvLyBieXRlIDJcbiAgICBhZHRzT2JqZWN0VHlwZSA9ICgoZGF0YVtvZmZzZXQgKyAyXSAmIDB4QzApID4+PiA2KSArIDE7XG4gICAgYWR0c1NhbXBsZWluZ0luZGV4ID0gKChkYXRhW29mZnNldCArIDJdICYgMHgzQykgPj4+IDIpO1xuICAgIGlmKGFkdHNTYW1wbGVpbmdJbmRleCA+IGFkdHNTYW1wbGVpbmdSYXRlcy5sZW5ndGgtMSkge1xuICAgICAgb2JzZXJ2ZXIudHJpZ2dlcihFdmVudC5FUlJPUiwge3R5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsIGRldGFpbHM6IEVycm9yRGV0YWlscy5GUkFHX1BBUlNJTkdfRVJST1IsIGZhdGFsOiB0cnVlLCByZWFzb246IGBpbnZhbGlkIEFEVFMgc2FtcGxpbmcgaW5kZXg6JHthZHRzU2FtcGxlaW5nSW5kZXh9YH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBhZHRzQ2hhbmVsQ29uZmlnID0gKChkYXRhW29mZnNldCArIDJdICYgMHgwMSkgPDwgMik7XG4gICAgLy8gYnl0ZSAzXG4gICAgYWR0c0NoYW5lbENvbmZpZyB8PSAoKGRhdGFbb2Zmc2V0ICsgM10gJiAweEMwKSA+Pj4gNik7XG4gICAgbG9nZ2VyLmxvZyhgbWFuaWZlc3QgY29kZWM6JHthdWRpb0NvZGVjfSxBRFRTIGRhdGE6dHlwZToke2FkdHNPYmplY3RUeXBlfSxzYW1wbGVpbmdJbmRleDoke2FkdHNTYW1wbGVpbmdJbmRleH1bJHthZHRzU2FtcGxlaW5nUmF0ZXNbYWR0c1NhbXBsZWluZ0luZGV4XX1Iel0sY2hhbm5lbENvbmZpZzoke2FkdHNDaGFuZWxDb25maWd9YCk7XG4gICAgLy8gZmlyZWZveDogZnJlcSBsZXNzIHRoYW4gMjRrSHogPSBBQUMgU0JSIChIRS1BQUMpXG4gICAgaWYgKC9maXJlZm94L2kudGVzdCh1c2VyQWdlbnQpKSB7XG4gICAgICBpZiAoYWR0c1NhbXBsZWluZ0luZGV4ID49IDYpIHtcbiAgICAgICAgYWR0c09iamVjdFR5cGUgPSA1O1xuICAgICAgICBjb25maWcgPSBuZXcgQXJyYXkoNCk7XG4gICAgICAgIC8vIEhFLUFBQyB1c2VzIFNCUiAoU3BlY3RyYWwgQmFuZCBSZXBsaWNhdGlvbikgLCBoaWdoIGZyZXF1ZW5jaWVzIGFyZSBjb25zdHJ1Y3RlZCBmcm9tIGxvdyBmcmVxdWVuY2llc1xuICAgICAgICAvLyB0aGVyZSBpcyBhIGZhY3RvciAyIGJldHdlZW4gZnJhbWUgc2FtcGxlIHJhdGUgYW5kIG91dHB1dCBzYW1wbGUgcmF0ZVxuICAgICAgICAvLyBtdWx0aXBseSBmcmVxdWVuY3kgYnkgMiAoc2VlIHRhYmxlIGJlbG93LCBlcXVpdmFsZW50IHRvIHN1YnN0cmFjdCAzKVxuICAgICAgICBhZHRzRXh0ZW5zaW9uU2FtcGxlaW5nSW5kZXggPSBhZHRzU2FtcGxlaW5nSW5kZXggLSAzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWR0c09iamVjdFR5cGUgPSAyO1xuICAgICAgICBjb25maWcgPSBuZXcgQXJyYXkoMik7XG4gICAgICAgIGFkdHNFeHRlbnNpb25TYW1wbGVpbmdJbmRleCA9IGFkdHNTYW1wbGVpbmdJbmRleDtcbiAgICAgIH1cbiAgICAgIC8vIEFuZHJvaWQgOiBhbHdheXMgdXNlIEFBQ1xuICAgIH0gZWxzZSBpZiAodXNlckFnZW50LmluZGV4T2YoJ2FuZHJvaWQnKSAhPT0gLTEpIHtcbiAgICAgIGFkdHNPYmplY3RUeXBlID0gMjtcbiAgICAgIGNvbmZpZyA9IG5ldyBBcnJheSgyKTtcbiAgICAgIGFkdHNFeHRlbnNpb25TYW1wbGVpbmdJbmRleCA9IGFkdHNTYW1wbGVpbmdJbmRleDtcbiAgICB9IGVsc2Uge1xuICAgICAgLyogIGZvciBvdGhlciBicm93c2VycyAoQ2hyb21lL1ZpdmFsZGkvT3BlcmEgLi4uKVxuICAgICAgICAgIGFsd2F5cyBmb3JjZSBhdWRpbyB0eXBlIHRvIGJlIEhFLUFBQyBTQlIsIGFzIHNvbWUgYnJvd3NlcnMgZG8gbm90IHN1cHBvcnQgYXVkaW8gY29kZWMgc3dpdGNoIHByb3Blcmx5IChsaWtlIENocm9tZSAuLi4pXG4gICAgICAqL1xuICAgICAgYWR0c09iamVjdFR5cGUgPSA1O1xuICAgICAgY29uZmlnID0gbmV3IEFycmF5KDQpO1xuICAgICAgLy8gaWYgKG1hbmlmZXN0IGNvZGVjIGlzIEhFLUFBQyBvciBIRS1BQUN2MikgT1IgKG1hbmlmZXN0IGNvZGVjIG5vdCBzcGVjaWZpZWQgQU5EIGZyZXF1ZW5jeSBsZXNzIHRoYW4gMjRrSHopXG4gICAgICBpZiAoKGF1ZGlvQ29kZWMgJiYgKChhdWRpb0NvZGVjLmluZGV4T2YoJ21wNGEuNDAuMjknKSAhPT0gLTEpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgIChhdWRpb0NvZGVjLmluZGV4T2YoJ21wNGEuNDAuNScpICE9PSAtMSkpKSB8fFxuICAgICAgICAgICghYXVkaW9Db2RlYyAmJiBhZHRzU2FtcGxlaW5nSW5kZXggPj0gNikpIHtcbiAgICAgICAgLy8gSEUtQUFDIHVzZXMgU0JSIChTcGVjdHJhbCBCYW5kIFJlcGxpY2F0aW9uKSAsIGhpZ2ggZnJlcXVlbmNpZXMgYXJlIGNvbnN0cnVjdGVkIGZyb20gbG93IGZyZXF1ZW5jaWVzXG4gICAgICAgIC8vIHRoZXJlIGlzIGEgZmFjdG9yIDIgYmV0d2VlbiBmcmFtZSBzYW1wbGUgcmF0ZSBhbmQgb3V0cHV0IHNhbXBsZSByYXRlXG4gICAgICAgIC8vIG11bHRpcGx5IGZyZXF1ZW5jeSBieSAyIChzZWUgdGFibGUgYmVsb3csIGVxdWl2YWxlbnQgdG8gc3Vic3RyYWN0IDMpXG4gICAgICAgIGFkdHNFeHRlbnNpb25TYW1wbGVpbmdJbmRleCA9IGFkdHNTYW1wbGVpbmdJbmRleCAtIDM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBpZiAobWFuaWZlc3QgY29kZWMgaXMgQUFDKSBBTkQgKGZyZXF1ZW5jeSBsZXNzIHRoYW4gMjRrSHogQU5EIG5iIGNoYW5uZWwgaXMgMSkgT1IgKG1hbmlmZXN0IGNvZGVjIG5vdCBzcGVjaWZpZWQgYW5kIG1vbm8gYXVkaW8pXG4gICAgICAgIC8vIENocm9tZSBmYWlscyB0byBwbGF5IGJhY2sgd2l0aCBsb3cgZnJlcXVlbmN5IEFBQyBMQyBtb25vIHdoZW4gaW5pdGlhbGl6ZWQgd2l0aCBIRS1BQUMuICBUaGlzIGlzIG5vdCBhIHByb2JsZW0gd2l0aCBzdGVyZW8uXG4gICAgICAgIGlmIChhdWRpb0NvZGVjICYmIGF1ZGlvQ29kZWMuaW5kZXhPZignbXA0YS40MC4yJykgIT09IC0xICYmIChhZHRzU2FtcGxlaW5nSW5kZXggPj0gNiAmJiBhZHRzQ2hhbmVsQ29uZmlnID09PSAxKSB8fFxuICAgICAgICAgICAgKCFhdWRpb0NvZGVjICYmIGFkdHNDaGFuZWxDb25maWcgPT09IDEpKSB7XG4gICAgICAgICAgYWR0c09iamVjdFR5cGUgPSAyO1xuICAgICAgICAgIGNvbmZpZyA9IG5ldyBBcnJheSgyKTtcbiAgICAgICAgfVxuICAgICAgICBhZHRzRXh0ZW5zaW9uU2FtcGxlaW5nSW5kZXggPSBhZHRzU2FtcGxlaW5nSW5kZXg7XG4gICAgICB9XG4gICAgfVxuICAgIC8qIHJlZmVyIHRvIGh0dHA6Ly93aWtpLm11bHRpbWVkaWEuY3gvaW5kZXgucGhwP3RpdGxlPU1QRUctNF9BdWRpbyNBdWRpb19TcGVjaWZpY19Db25maWdcbiAgICAgICAgSVNPIDE0NDk2LTMgKEFBQykucGRmIC0gVGFibGUgMS4xMyDigJQgU3ludGF4IG9mIEF1ZGlvU3BlY2lmaWNDb25maWcoKVxuICAgICAgQXVkaW8gUHJvZmlsZSAvIEF1ZGlvIE9iamVjdCBUeXBlXG4gICAgICAwOiBOdWxsXG4gICAgICAxOiBBQUMgTWFpblxuICAgICAgMjogQUFDIExDIChMb3cgQ29tcGxleGl0eSlcbiAgICAgIDM6IEFBQyBTU1IgKFNjYWxhYmxlIFNhbXBsZSBSYXRlKVxuICAgICAgNDogQUFDIExUUCAoTG9uZyBUZXJtIFByZWRpY3Rpb24pXG4gICAgICA1OiBTQlIgKFNwZWN0cmFsIEJhbmQgUmVwbGljYXRpb24pXG4gICAgICA2OiBBQUMgU2NhbGFibGVcbiAgICAgc2FtcGxpbmcgZnJlcVxuICAgICAgMDogOTYwMDAgSHpcbiAgICAgIDE6IDg4MjAwIEh6XG4gICAgICAyOiA2NDAwMCBIelxuICAgICAgMzogNDgwMDAgSHpcbiAgICAgIDQ6IDQ0MTAwIEh6XG4gICAgICA1OiAzMjAwMCBIelxuICAgICAgNjogMjQwMDAgSHpcbiAgICAgIDc6IDIyMDUwIEh6XG4gICAgICA4OiAxNjAwMCBIelxuICAgICAgOTogMTIwMDAgSHpcbiAgICAgIDEwOiAxMTAyNSBIelxuICAgICAgMTE6IDgwMDAgSHpcbiAgICAgIDEyOiA3MzUwIEh6XG4gICAgICAxMzogUmVzZXJ2ZWRcbiAgICAgIDE0OiBSZXNlcnZlZFxuICAgICAgMTU6IGZyZXF1ZW5jeSBpcyB3cml0dGVuIGV4cGxpY3RseVxuICAgICAgQ2hhbm5lbCBDb25maWd1cmF0aW9uc1xuICAgICAgVGhlc2UgYXJlIHRoZSBjaGFubmVsIGNvbmZpZ3VyYXRpb25zOlxuICAgICAgMDogRGVmaW5lZCBpbiBBT1QgU3BlY2lmYyBDb25maWdcbiAgICAgIDE6IDEgY2hhbm5lbDogZnJvbnQtY2VudGVyXG4gICAgICAyOiAyIGNoYW5uZWxzOiBmcm9udC1sZWZ0LCBmcm9udC1yaWdodFxuICAgICovXG4gICAgLy8gYXVkaW9PYmplY3RUeXBlID0gcHJvZmlsZSA9PiBwcm9maWxlLCB0aGUgTVBFRy00IEF1ZGlvIE9iamVjdCBUeXBlIG1pbnVzIDFcbiAgICBjb25maWdbMF0gPSBhZHRzT2JqZWN0VHlwZSA8PCAzO1xuICAgIC8vIHNhbXBsaW5nRnJlcXVlbmN5SW5kZXhcbiAgICBjb25maWdbMF0gfD0gKGFkdHNTYW1wbGVpbmdJbmRleCAmIDB4MEUpID4+IDE7XG4gICAgY29uZmlnWzFdIHw9IChhZHRzU2FtcGxlaW5nSW5kZXggJiAweDAxKSA8PCA3O1xuICAgIC8vIGNoYW5uZWxDb25maWd1cmF0aW9uXG4gICAgY29uZmlnWzFdIHw9IGFkdHNDaGFuZWxDb25maWcgPDwgMztcbiAgICBpZiAoYWR0c09iamVjdFR5cGUgPT09IDUpIHtcbiAgICAgIC8vIGFkdHNFeHRlbnNpb25TYW1wbGVpbmdJbmRleFxuICAgICAgY29uZmlnWzFdIHw9IChhZHRzRXh0ZW5zaW9uU2FtcGxlaW5nSW5kZXggJiAweDBFKSA+PiAxO1xuICAgICAgY29uZmlnWzJdID0gKGFkdHNFeHRlbnNpb25TYW1wbGVpbmdJbmRleCAmIDB4MDEpIDw8IDc7XG4gICAgICAvLyBhZHRzT2JqZWN0VHlwZSAoZm9yY2UgdG8gMiwgY2hyb21lIGlzIGNoZWNraW5nIHRoYXQgb2JqZWN0IHR5cGUgaXMgbGVzcyB0aGFuIDUgPz8/XG4gICAgICAvLyAgICBodHRwczovL2Nocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjLmdpdC8rL21hc3Rlci9tZWRpYS9mb3JtYXRzL21wNC9hYWMuY2NcbiAgICAgIGNvbmZpZ1syXSB8PSAyIDw8IDI7XG4gICAgICBjb25maWdbM10gPSAwO1xuICAgIH1cbiAgICByZXR1cm4ge2NvbmZpZzogY29uZmlnLCBzYW1wbGVyYXRlOiBhZHRzU2FtcGxlaW5nUmF0ZXNbYWR0c1NhbXBsZWluZ0luZGV4XSwgY2hhbm5lbENvdW50OiBhZHRzQ2hhbmVsQ29uZmlnLCBjb2RlYzogKCdtcDRhLjQwLicgKyBhZHRzT2JqZWN0VHlwZSksIG1hbmlmZXN0Q29kZWMgOiBtYW5pZmVzdENvZGVjfTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBBRFRTO1xuIiwiLyogIGlubGluZSBkZW11eGVyLlxuICogICBwcm9iZSBmcmFnbWVudHMgYW5kIGluc3RhbnRpYXRlIGFwcHJvcHJpYXRlIGRlbXV4ZXIgZGVwZW5kaW5nIG9uIGNvbnRlbnQgdHlwZSAoVFNEZW11eGVyLCBBQUNEZW11eGVyLCAuLi4pXG4gKi9cblxuaW1wb3J0IEV2ZW50IGZyb20gJy4uL2V2ZW50cyc7XG5pbXBvcnQge0Vycm9yVHlwZXMsIEVycm9yRGV0YWlsc30gZnJvbSAnLi4vZXJyb3JzJztcbmltcG9ydCBEZWNyeXB0ZXIgZnJvbSAnLi4vY3J5cHQvZGVjcnlwdGVyJztcbmltcG9ydCBBQUNEZW11eGVyIGZyb20gJy4uL2RlbXV4L2FhY2RlbXV4ZXInO1xuaW1wb3J0IE1QNERlbXV4ZXIgZnJvbSAnLi4vZGVtdXgvbXA0ZGVtdXhlcic7XG5pbXBvcnQgVFNEZW11eGVyIGZyb20gJy4uL2RlbXV4L3RzZGVtdXhlcic7XG5pbXBvcnQgTVA0UmVtdXhlciBmcm9tICcuLi9yZW11eC9tcDQtcmVtdXhlcic7XG5pbXBvcnQgUGFzc1Rocm91Z2hSZW11eGVyIGZyb20gJy4uL3JlbXV4L3Bhc3N0aHJvdWdoLXJlbXV4ZXInO1xuXG5jbGFzcyBEZW11eGVySW5saW5lIHtcblxuICBjb25zdHJ1Y3RvcihvYnNlcnZlcix0eXBlU3VwcG9ydGVkLCBjb25maWcsIHZlbmRvcikge1xuICAgIHRoaXMub2JzZXJ2ZXIgPSBvYnNlcnZlcjtcbiAgICB0aGlzLnR5cGVTdXBwb3J0ZWQgPSB0eXBlU3VwcG9ydGVkO1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgIHRoaXMudmVuZG9yID0gdmVuZG9yO1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICB2YXIgZGVtdXhlciA9IHRoaXMuZGVtdXhlcjtcbiAgICBpZiAoZGVtdXhlcikge1xuICAgICAgZGVtdXhlci5kZXN0cm95KCk7XG4gICAgfVxuICB9XG5cbiAgcHVzaChkYXRhLCBkZWNyeXB0ZGF0YSwgaW5pdFNlZ21lbnQsIGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWMsIHRpbWVPZmZzZXQsIGRpc2NvbnRpbnVpdHksIHRyYWNrU3dpdGNoLCBjb250aWd1b3VzLCBkdXJhdGlvbiwgYWNjdXJhdGVUaW1lT2Zmc2V0LCBkZWZhdWx0SW5pdFBUUykge1xuICAgIGlmICgoZGF0YS5ieXRlTGVuZ3RoID4gMCkgJiYgKGRlY3J5cHRkYXRhICE9IG51bGwpICYmIChkZWNyeXB0ZGF0YS5rZXkgIT0gbnVsbCkgJiYgKGRlY3J5cHRkYXRhLm1ldGhvZCA9PT0gJ0FFUy0xMjgnKSkge1xuICAgICAgbGV0IGRlY3J5cHRlciA9IHRoaXMuZGVjcnlwdGVyO1xuICAgICAgaWYgKGRlY3J5cHRlciA9PSBudWxsKSB7XG4gICAgICAgIGRlY3J5cHRlciA9IHRoaXMuZGVjcnlwdGVyID0gbmV3IERlY3J5cHRlcih0aGlzLm9ic2VydmVyLCB0aGlzLmNvbmZpZyk7XG4gICAgICB9XG4gICAgICB2YXIgbG9jYWx0aGlzID0gdGhpcztcbiAgICAgIC8vIHBlcmZvcm1hbmNlLm5vdygpIG5vdCBhdmFpbGFibGUgb24gV2ViV29ya2VyLCBhdCBsZWFzdCBvbiBTYWZhcmkgRGVza3RvcFxuICAgICAgdmFyIHN0YXJ0VGltZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgfSBjYXRjaChlcnJvcikge1xuICAgICAgICBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgfVxuICAgICAgZGVjcnlwdGVyLmRlY3J5cHQoZGF0YSwgZGVjcnlwdGRhdGEua2V5LmJ1ZmZlciwgZGVjcnlwdGRhdGEuaXYuYnVmZmVyLCBmdW5jdGlvbiAoZGVjcnlwdGVkRGF0YSkge1xuICAgICAgICB2YXIgZW5kVGltZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBlbmRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIH0gY2F0Y2goZXJyb3IpIHtcbiAgICAgICAgICBlbmRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgfVxuICAgICAgICBsb2NhbHRoaXMub2JzZXJ2ZXIudHJpZ2dlcihFdmVudC5GUkFHX0RFQ1JZUFRFRCwgeyBzdGF0czogeyB0c3RhcnQ6IHN0YXJ0VGltZSwgdGRlY3J5cHQ6IGVuZFRpbWUgfSB9KTtcbiAgICAgICAgbG9jYWx0aGlzLnB1c2hEZWNyeXB0ZWQobmV3IFVpbnQ4QXJyYXkoZGVjcnlwdGVkRGF0YSksIGRlY3J5cHRkYXRhLCBuZXcgVWludDhBcnJheShpbml0U2VnbWVudCksIGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWMsIHRpbWVPZmZzZXQsIGRpc2NvbnRpbnVpdHksIHRyYWNrU3dpdGNoLCBjb250aWd1b3VzLCBkdXJhdGlvbiwgYWNjdXJhdGVUaW1lT2Zmc2V0LGRlZmF1bHRJbml0UFRTKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnB1c2hEZWNyeXB0ZWQobmV3IFVpbnQ4QXJyYXkoZGF0YSksIGRlY3J5cHRkYXRhLCBuZXcgVWludDhBcnJheShpbml0U2VnbWVudCksIGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWMsIHRpbWVPZmZzZXQsIGRpc2NvbnRpbnVpdHksIHRyYWNrU3dpdGNoLCBjb250aWd1b3VzLCBkdXJhdGlvbixhY2N1cmF0ZVRpbWVPZmZzZXQsZGVmYXVsdEluaXRQVFMpO1xuICAgIH1cbiAgfVxuXG4gIHB1c2hEZWNyeXB0ZWQoZGF0YSwgZGVjcnlwdGRhdGEsIGluaXRTZWdtZW50LCBhdWRpb0NvZGVjLCB2aWRlb0NvZGVjLCB0aW1lT2Zmc2V0LCBkaXNjb250aW51aXR5LCB0cmFja1N3aXRjaCwgY29udGlndW91cywgZHVyYXRpb24sYWNjdXJhdGVUaW1lT2Zmc2V0LGRlZmF1bHRJbml0UFRTKSB7XG4gICAgdmFyIGRlbXV4ZXIgPSB0aGlzLmRlbXV4ZXI7XG4gICAgaWYgKCFkZW11eGVyIHx8wqBcbiAgICAgICAvLyBpbiBjYXNlIG9mIGNvbnRpbnVpdHkgY2hhbmdlLCB3ZSBtaWdodCBzd2l0Y2ggZnJvbSBjb250ZW50IHR5cGUgKEFBQyBjb250YWluZXIgdG8gVFMgY29udGFpbmVyIGZvciBleGFtcGxlKVxuICAgICAgIC8vIHNvIGxldCdzIGNoZWNrIHRoYXQgY3VycmVudCBkZW11eGVyIGlzIHN0aWxsIHZhbGlkXG4gICAgICAgIChkaXNjb250aW51aXR5ICYmICF0aGlzLnByb2JlKGRhdGEpKSkge1xuICAgICAgY29uc3Qgb2JzZXJ2ZXIgPSB0aGlzLm9ic2VydmVyO1xuICAgICAgY29uc3QgdHlwZVN1cHBvcnRlZCA9IHRoaXMudHlwZVN1cHBvcnRlZDtcbiAgICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuY29uZmlnO1xuICAgICAgY29uc3QgbXV4Q29uZmlnID0gWyB7ZGVtdXggOiBUU0RlbXV4ZXIsICByZW11eCA6IE1QNFJlbXV4ZXJ9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICB7ZGVtdXggOiBBQUNEZW11eGVyLCByZW11eCA6IE1QNFJlbXV4ZXJ9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICB7ZGVtdXggOiBNUDREZW11eGVyLCByZW11eCA6IFBhc3NUaHJvdWdoUmVtdXhlcn1dO1xuXG4gICAgICAvLyBwcm9iZSBmb3IgY29udGVudCB0eXBlXG4gICAgICBmb3IgKGxldCBpIGluIG11eENvbmZpZykge1xuICAgICAgICBjb25zdCBtdXggPSBtdXhDb25maWdbaV07XG4gICAgICAgIGNvbnN0IHByb2JlID0gbXV4LmRlbXV4LnByb2JlO1xuICAgICAgICBpZihwcm9iZShkYXRhKSkge1xuICAgICAgICAgIGNvbnN0IHJlbXV4ZXIgPSB0aGlzLnJlbXV4ZXIgPSBuZXcgbXV4LnJlbXV4KG9ic2VydmVyLGNvbmZpZyx0eXBlU3VwcG9ydGVkLCB0aGlzLnZlbmRvcik7XG4gICAgICAgICAgZGVtdXhlciA9IG5ldyBtdXguZGVtdXgob2JzZXJ2ZXIscmVtdXhlcixjb25maWcsdHlwZVN1cHBvcnRlZCk7XG4gICAgICAgICAgdGhpcy5wcm9iZSA9IHByb2JlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZighZGVtdXhlcikge1xuICAgICAgICBvYnNlcnZlci50cmlnZ2VyKEV2ZW50LkVSUk9SLCB7dHlwZSA6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsIGRldGFpbHM6IEVycm9yRGV0YWlscy5GUkFHX1BBUlNJTkdfRVJST1IsIGZhdGFsOiB0cnVlLCByZWFzb246ICdubyBkZW11eCBtYXRjaGluZyB3aXRoIGNvbnRlbnQgZm91bmQnfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuZGVtdXhlciA9IGRlbXV4ZXI7XG4gICAgfVxuICAgIGNvbnN0IHJlbXV4ZXIgPSB0aGlzLnJlbXV4ZXI7XG5cbiAgICBpZiAoZGlzY29udGludWl0eSB8fCB0cmFja1N3aXRjaCkge1xuICAgICAgZGVtdXhlci5yZXNldEluaXRTZWdtZW50KGluaXRTZWdtZW50LGF1ZGlvQ29kZWMsdmlkZW9Db2RlYyxkdXJhdGlvbik7XG4gICAgICByZW11eGVyLnJlc2V0SW5pdFNlZ21lbnQoKTtcbiAgICB9XG4gICAgaWYgKGRpc2NvbnRpbnVpdHkpIHtcbiAgICAgIGRlbXV4ZXIucmVzZXRUaW1lU3RhbXAoKTtcbiAgICAgIHJlbXV4ZXIucmVzZXRUaW1lU3RhbXAoZGVmYXVsdEluaXRQVFMpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGRlbXV4ZXIuc2V0RGVjcnlwdERhdGEgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGRlbXV4ZXIuc2V0RGVjcnlwdERhdGEoZGVjcnlwdGRhdGEpO1xuICAgIH1cbiAgICBkZW11eGVyLmFwcGVuZChkYXRhLHRpbWVPZmZzZXQsY29udGlndW91cyxhY2N1cmF0ZVRpbWVPZmZzZXQpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IERlbXV4ZXJJbmxpbmU7XG4iLCIvKiBkZW11eGVyIHdlYiB3b3JrZXIuXG4gKiAgLSBsaXN0ZW4gdG8gd29ya2VyIG1lc3NhZ2UsIGFuZCB0cmlnZ2VyIERlbXV4ZXJJbmxpbmUgdXBvbiByZWNlcHRpb24gb2YgRnJhZ21lbnRzLlxuICogIC0gcHJvdmlkZXMgTVA0IEJveGVzIGJhY2sgdG8gbWFpbiB0aHJlYWQgdXNpbmcgW3RyYW5zZmVyYWJsZSBvYmplY3RzXShodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS93ZWIvdXBkYXRlcy8yMDExLzEyL1RyYW5zZmVyYWJsZS1PYmplY3RzLUxpZ2h0bmluZy1GYXN0KSBpbiBvcmRlciB0byBtaW5pbWl6ZSBtZXNzYWdlIHBhc3Npbmcgb3ZlcmhlYWQuXG4gKi9cblxuIGltcG9ydCBEZW11eGVySW5saW5lIGZyb20gJy4uL2RlbXV4L2RlbXV4ZXItaW5saW5lJztcbiBpbXBvcnQgRXZlbnQgZnJvbSAnLi4vZXZlbnRzJztcbiBpbXBvcnQge2VuYWJsZUxvZ3N9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XG4gaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tICdldmVudHMnO1xuXG52YXIgRGVtdXhlcldvcmtlciA9IGZ1bmN0aW9uIChzZWxmKSB7XG4gIC8vIG9ic2VydmVyIHNldHVwXG4gIHZhciBvYnNlcnZlciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgb2JzZXJ2ZXIudHJpZ2dlciA9IGZ1bmN0aW9uIHRyaWdnZXIgKGV2ZW50LCAuLi5kYXRhKSB7XG4gICAgb2JzZXJ2ZXIuZW1pdChldmVudCwgZXZlbnQsIC4uLmRhdGEpO1xuICB9O1xuXG4gIG9ic2VydmVyLm9mZiA9IGZ1bmN0aW9uIG9mZiAoZXZlbnQsIC4uLmRhdGEpIHtcbiAgICBvYnNlcnZlci5yZW1vdmVMaXN0ZW5lcihldmVudCwgLi4uZGF0YSk7XG4gIH07XG5cbiAgdmFyIGZvcndhcmRNZXNzYWdlID0gZnVuY3Rpb24oZXYsZGF0YSkge1xuICAgIHNlbGYucG9zdE1lc3NhZ2Uoe2V2ZW50OiBldiwgZGF0YTpkYXRhIH0pO1xuICB9O1xuXG4gIHNlbGYuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGZ1bmN0aW9uIChldikge1xuICAgIHZhciBkYXRhID0gZXYuZGF0YTtcbiAgICAvL2NvbnNvbGUubG9nKCdkZW11eGVyIGNtZDonICsgZGF0YS5jbWQpO1xuICAgIHN3aXRjaCAoZGF0YS5jbWQpIHtcbiAgICAgIGNhc2UgJ2luaXQnOlxuICAgICAgICBsZXQgY29uZmlnID0gSlNPTi5wYXJzZShkYXRhLmNvbmZpZyk7XG4gICAgICAgIHNlbGYuZGVtdXhlciA9IG5ldyBEZW11eGVySW5saW5lKG9ic2VydmVyLCBkYXRhLnR5cGVTdXBwb3J0ZWQsIGNvbmZpZywgZGF0YS52ZW5kb3IpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGVuYWJsZUxvZ3MoY29uZmlnLmRlYnVnID09PSB0cnVlKTtcbiAgICAgICAgfSBjYXRjaChlcnIpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ2RlbXV4ZXJXb3JrZXI6IHVuYWJsZSB0byBlbmFibGUgbG9ncycpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNpZ25hbCBlbmQgb2Ygd29ya2VyIGluaXRcbiAgICAgICAgZm9yd2FyZE1lc3NhZ2UoJ2luaXQnLG51bGwpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2RlbXV4JzpcbiAgICAgICAgc2VsZi5kZW11eGVyLnB1c2goZGF0YS5kYXRhLCBkYXRhLmRlY3J5cHRkYXRhLCBkYXRhLmluaXRTZWdtZW50LCBkYXRhLmF1ZGlvQ29kZWMsIGRhdGEudmlkZW9Db2RlYywgZGF0YS50aW1lT2Zmc2V0LGRhdGEuZGlzY29udGludWl0eSwgZGF0YS50cmFja1N3aXRjaCxkYXRhLmNvbnRpZ3VvdXMsZGF0YS5kdXJhdGlvbixkYXRhLmFjY3VyYXRlVGltZU9mZnNldCxkYXRhLmRlZmF1bHRJbml0UFRTKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBicmVhaztcbiAgICB9XG4gIH0pO1xuXG4gIC8vIGZvcndhcmQgZXZlbnRzIHRvIG1haW4gdGhyZWFkXG4gIG9ic2VydmVyLm9uKEV2ZW50LkZSQUdfREVDUllQVEVELCBmb3J3YXJkTWVzc2FnZSk7XG4gIG9ic2VydmVyLm9uKEV2ZW50LkZSQUdfUEFSU0lOR19JTklUX1NFR01FTlQsIGZvcndhcmRNZXNzYWdlKTtcbiAgb2JzZXJ2ZXIub24oRXZlbnQuRlJBR19QQVJTRUQsIGZvcndhcmRNZXNzYWdlKTtcbiAgb2JzZXJ2ZXIub24oRXZlbnQuRVJST1IsIGZvcndhcmRNZXNzYWdlKTtcbiAgb2JzZXJ2ZXIub24oRXZlbnQuRlJBR19QQVJTSU5HX01FVEFEQVRBLCBmb3J3YXJkTWVzc2FnZSk7XG4gIG9ic2VydmVyLm9uKEV2ZW50LkZSQUdfUEFSU0lOR19VU0VSREFUQSwgZm9yd2FyZE1lc3NhZ2UpO1xuICBvYnNlcnZlci5vbihFdmVudC5JTklUX1BUU19GT1VORCwgZm9yd2FyZE1lc3NhZ2UpO1xuXG4gIC8vIHNwZWNpYWwgY2FzZSBmb3IgRlJBR19QQVJTSU5HX0RBVEE6IHBhc3MgZGF0YTEvZGF0YTIgYXMgdHJhbnNmZXJhYmxlIG9iamVjdCAobm8gY29weSlcbiAgb2JzZXJ2ZXIub24oRXZlbnQuRlJBR19QQVJTSU5HX0RBVEEsIGZ1bmN0aW9uKGV2LCBkYXRhKSB7XG4gICAgbGV0IHRyYW5zZmVyYWJsZSA9IFtdO1xuICAgIGxldCBtZXNzYWdlID0ge2V2ZW50OiBldiwgZGF0YTpkYXRhfTtcbiAgICBpZiAoZGF0YS5kYXRhMSkge1xuICAgICAgbWVzc2FnZS5kYXRhMSA9IGRhdGEuZGF0YTEuYnVmZmVyO1xuICAgICAgdHJhbnNmZXJhYmxlLnB1c2goZGF0YS5kYXRhMS5idWZmZXIpO1xuICAgICAgZGVsZXRlIGRhdGEuZGF0YTE7XG4gICAgfVxuICAgIGlmIChkYXRhLmRhdGEyKSB7XG4gICAgICBtZXNzYWdlLmRhdGEyID0gZGF0YS5kYXRhMi5idWZmZXI7XG4gICAgICB0cmFuc2ZlcmFibGUucHVzaChkYXRhLmRhdGEyLmJ1ZmZlcik7XG4gICAgICBkZWxldGUgZGF0YS5kYXRhMjtcbiAgICB9XG4gICAgc2VsZi5wb3N0TWVzc2FnZShtZXNzYWdlLHRyYW5zZmVyYWJsZSk7XG4gIH0pO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgRGVtdXhlcldvcmtlcjtcblxuIiwiaW1wb3J0IEV2ZW50IGZyb20gJy4uL2V2ZW50cyc7XG5pbXBvcnQgRGVtdXhlcklubGluZSBmcm9tICcuLi9kZW11eC9kZW11eGVyLWlubGluZSc7XG5pbXBvcnQgRGVtdXhlcldvcmtlciBmcm9tICcuLi9kZW11eC9kZW11eGVyLXdvcmtlcic7XG5pbXBvcnQge2xvZ2dlcn0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcbmltcG9ydCB7RXJyb3JUeXBlcywgRXJyb3JEZXRhaWxzfSBmcm9tICcuLi9lcnJvcnMnO1xuaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tICdldmVudHMnO1xuXG5jbGFzcyBEZW11eGVyIHtcblxuICBjb25zdHJ1Y3RvcihobHMsIGlkKSB7XG4gICAgdGhpcy5obHMgPSBobHM7XG4gICAgdGhpcy5pZCA9IGlkO1xuICAgIC8vIG9ic2VydmVyIHNldHVwXG4gICAgY29uc3Qgb2JzZXJ2ZXIgPSB0aGlzLm9ic2VydmVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgIGNvbnN0IGNvbmZpZyA9IGhscy5jb25maWc7XG4gICAgb2JzZXJ2ZXIudHJpZ2dlciA9IGZ1bmN0aW9uIHRyaWdnZXIgKGV2ZW50LCAuLi5kYXRhKSB7XG4gICAgICBvYnNlcnZlci5lbWl0KGV2ZW50LCBldmVudCwgLi4uZGF0YSk7XG4gICAgfTtcblxuICAgIG9ic2VydmVyLm9mZiA9IGZ1bmN0aW9uIG9mZiAoZXZlbnQsIC4uLmRhdGEpIHtcbiAgICAgIG9ic2VydmVyLnJlbW92ZUxpc3RlbmVyKGV2ZW50LCAuLi5kYXRhKTtcbiAgICB9O1xuXG4gICAgdmFyIGZvcndhcmRNZXNzYWdlID0gZnVuY3Rpb24oZXYsZGF0YSkge1xuICAgICAgZGF0YSA9IGRhdGEgfHwge307XG4gICAgICBkYXRhLmZyYWcgPSB0aGlzLmZyYWc7XG4gICAgICBkYXRhLmlkID0gdGhpcy5pZDtcbiAgICAgIGhscy50cmlnZ2VyKGV2LGRhdGEpO1xuICAgIH0uYmluZCh0aGlzKTtcblxuICAgIC8vIGZvcndhcmQgZXZlbnRzIHRvIG1haW4gdGhyZWFkXG4gICAgb2JzZXJ2ZXIub24oRXZlbnQuRlJBR19ERUNSWVBURUQsIGZvcndhcmRNZXNzYWdlKTtcbiAgICBvYnNlcnZlci5vbihFdmVudC5GUkFHX1BBUlNJTkdfSU5JVF9TRUdNRU5ULCBmb3J3YXJkTWVzc2FnZSk7XG4gICAgb2JzZXJ2ZXIub24oRXZlbnQuRlJBR19QQVJTSU5HX0RBVEEsIGZvcndhcmRNZXNzYWdlKTtcbiAgICBvYnNlcnZlci5vbihFdmVudC5GUkFHX1BBUlNFRCwgZm9yd2FyZE1lc3NhZ2UpO1xuICAgIG9ic2VydmVyLm9uKEV2ZW50LkVSUk9SLCBmb3J3YXJkTWVzc2FnZSk7XG4gICAgb2JzZXJ2ZXIub24oRXZlbnQuRlJBR19QQVJTSU5HX01FVEFEQVRBLCBmb3J3YXJkTWVzc2FnZSk7XG4gICAgb2JzZXJ2ZXIub24oRXZlbnQuRlJBR19QQVJTSU5HX1VTRVJEQVRBLCBmb3J3YXJkTWVzc2FnZSk7XG4gICAgb2JzZXJ2ZXIub24oRXZlbnQuSU5JVF9QVFNfRk9VTkQsIGZvcndhcmRNZXNzYWdlKTtcblxuICAgIGNvbnN0IHR5cGVTdXBwb3J0ZWQgPSB7XG4gICAgICBtcDQgOiBNZWRpYVNvdXJjZS5pc1R5cGVTdXBwb3J0ZWQoJ3ZpZGVvL21wNCcpLFxuICAgICAgbXBlZzogTWVkaWFTb3VyY2UuaXNUeXBlU3VwcG9ydGVkKCdhdWRpby9tcGVnJyksXG4gICAgICBtcDM6IE1lZGlhU291cmNlLmlzVHlwZVN1cHBvcnRlZCgnYXVkaW8vbXA0OyBjb2RlY3M9XCJtcDNcIicpXG4gICAgfTtcbiAgICAvLyBuYXZpZ2F0b3IudmVuZG9yIGlzIG5vdCBhbHdheXMgYXZhaWxhYmxlIGluIFdlYiBXb3JrZXJcbiAgICAvLyByZWZlciB0byBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvV29ya2VyR2xvYmFsU2NvcGUvbmF2aWdhdG9yXG4gICAgY29uc3QgdmVuZG9yID0gbmF2aWdhdG9yLnZlbmRvcjtcbiAgICBpZiAoY29uZmlnLmVuYWJsZVdvcmtlciAmJiAodHlwZW9mKFdvcmtlcikgIT09ICd1bmRlZmluZWQnKSkge1xuICAgICAgICBsb2dnZXIubG9nKCdkZW11eGluZyBpbiB3ZWJ3b3JrZXInKTtcbiAgICAgICAgbGV0IHc7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgbGV0IHdvcmsgPSByZXF1aXJlKCd3ZWJ3b3JraWZ5Jyk7XG4gICAgICAgICAgdyA9IHRoaXMudyA9IHdvcmsoRGVtdXhlcldvcmtlcik7XG4gICAgICAgICAgdGhpcy5vbndtc2cgPSB0aGlzLm9uV29ya2VyTWVzc2FnZS5iaW5kKHRoaXMpO1xuICAgICAgICAgIHcuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIHRoaXMub253bXNnKTtcbiAgICAgICAgICB3Lm9uZXJyb3IgPSBmdW5jdGlvbihldmVudCkgeyBobHMudHJpZ2dlcihFdmVudC5FUlJPUiwge3R5cGU6IEVycm9yVHlwZXMuT1RIRVJfRVJST1IsIGRldGFpbHM6IEVycm9yRGV0YWlscy5JTlRFUk5BTF9FWENFUFRJT04sIGZhdGFsOiB0cnVlLCBldmVudCA6ICdkZW11eGVyV29ya2VyJywgZXJyIDogeyBtZXNzYWdlIDogZXZlbnQubWVzc2FnZSArICcgKCcgKyBldmVudC5maWxlbmFtZSArICc6JyArIGV2ZW50LmxpbmVubyArICcpJyB9fSk7fTtcbiAgICAgICAgICB3LnBvc3RNZXNzYWdlKHtjbWQ6ICdpbml0JywgdHlwZVN1cHBvcnRlZCA6IHR5cGVTdXBwb3J0ZWQsIHZlbmRvciA6IHZlbmRvciwgaWQgOiBpZCwgY29uZmlnOiBKU09OLnN0cmluZ2lmeShjb25maWcpfSk7XG4gICAgICAgIH0gY2F0Y2goZXJyKSB7XG4gICAgICAgICAgbG9nZ2VyLmVycm9yKCdlcnJvciB3aGlsZSBpbml0aWFsaXppbmcgRGVtdXhlcldvcmtlciwgZmFsbGJhY2sgb24gRGVtdXhlcklubGluZScpO1xuICAgICAgICAgIGlmICh3KSB7XG4gICAgICAgICAgICAvLyByZXZva2UgdGhlIE9iamVjdCBVUkwgdGhhdCB3YXMgdXNlZCB0byBjcmVhdGUgZGVtdXhlciB3b3JrZXIsIHNvIGFzIG5vdCB0byBsZWFrIGl0XG4gICAgICAgICAgICBVUkwucmV2b2tlT2JqZWN0VVJMKHcub2JqZWN0VVJMKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5kZW11eGVyID0gbmV3IERlbXV4ZXJJbmxpbmUob2JzZXJ2ZXIsdHlwZVN1cHBvcnRlZCxjb25maWcsdmVuZG9yKTtcbiAgICAgICAgICB0aGlzLncgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZGVtdXhlciA9IG5ldyBEZW11eGVySW5saW5lKG9ic2VydmVyLHR5cGVTdXBwb3J0ZWQsY29uZmlnLCB2ZW5kb3IpO1xuICAgICAgfVxuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICBsZXQgdyA9IHRoaXMudztcbiAgICBpZiAodykge1xuICAgICAgdy5yZW1vdmVFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgdGhpcy5vbndtc2cpO1xuICAgICAgdy50ZXJtaW5hdGUoKTtcbiAgICAgIHRoaXMudyA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBkZW11eGVyID0gdGhpcy5kZW11eGVyO1xuICAgICAgaWYgKGRlbXV4ZXIpIHtcbiAgICAgICAgZGVtdXhlci5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuZGVtdXhlciA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBvYnNlcnZlciA9IHRoaXMub2JzZXJ2ZXI7XG4gICAgaWYgKG9ic2VydmVyKSB7XG4gICAgICBvYnNlcnZlci5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICAgIHRoaXMub2JzZXJ2ZXIgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHB1c2goZGF0YSwgaW5pdFNlZ21lbnQsIGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWMsIGZyYWcsIGR1cmF0aW9uLGFjY3VyYXRlVGltZU9mZnNldCxkZWZhdWx0SW5pdFBUUykge1xuICAgIGNvbnN0IHcgPSB0aGlzLnc7XG4gICAgY29uc3QgdGltZU9mZnNldCA9ICFpc05hTihmcmFnLnN0YXJ0RFRTKSA/IGZyYWcuc3RhcnREVFMgIDogZnJhZy5zdGFydDtcbiAgICBjb25zdCBkZWNyeXB0ZGF0YSA9IGZyYWcuZGVjcnlwdGRhdGE7XG4gICAgY29uc3QgbGFzdEZyYWcgPSB0aGlzLmZyYWc7XG4gICAgY29uc3QgZGlzY29udGludWl0eSA9ICEobGFzdEZyYWcgJiYgKGZyYWcuY2MgPT09IGxhc3RGcmFnLmNjKSk7XG4gICAgY29uc3QgdHJhY2tTd2l0Y2ggPSAhKGxhc3RGcmFnICYmIChmcmFnLmxldmVsID09PSBsYXN0RnJhZy5sZXZlbCkpO1xuICAgIGNvbnN0IG5leHRTTiA9IGxhc3RGcmFnICYmIChmcmFnLnNuID09PSAobGFzdEZyYWcuc24rMSkpO1xuICAgIGNvbnN0IGNvbnRpZ3VvdXMgPSAhdHJhY2tTd2l0Y2ggJiYgbmV4dFNOO1xuICAgIGlmIChkaXNjb250aW51aXR5KSB7XG4gICAgICBsb2dnZXIubG9nKGAke3RoaXMuaWR9OmRpc2NvbnRpbnVpdHkgZGV0ZWN0ZWRgKTtcbiAgICB9XG4gICAgaWYgKHRyYWNrU3dpdGNoKSB7XG4gICAgICBsb2dnZXIubG9nKGAke3RoaXMuaWR9OnN3aXRjaCBkZXRlY3RlZGApO1xuICAgIH1cbiAgICB0aGlzLmZyYWcgPSBmcmFnO1xuICAgIGlmICh3KSB7XG4gICAgICAvLyBwb3N0IGZyYWdtZW50IHBheWxvYWQgYXMgdHJhbnNmZXJhYmxlIG9iamVjdHMgKG5vIGNvcHkpXG4gICAgICB3LnBvc3RNZXNzYWdlKHtjbWQ6ICdkZW11eCcsIGRhdGEsIGRlY3J5cHRkYXRhLCBpbml0U2VnbWVudCwgYXVkaW9Db2RlYywgdmlkZW9Db2RlYywgdGltZU9mZnNldCwgZGlzY29udGludWl0eSwgdHJhY2tTd2l0Y2gsIGNvbnRpZ3VvdXMsIGR1cmF0aW9uLCBhY2N1cmF0ZVRpbWVPZmZzZXQsZGVmYXVsdEluaXRQVFN9LCBbZGF0YV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgZGVtdXhlciA9IHRoaXMuZGVtdXhlcjtcbiAgICAgIGlmIChkZW11eGVyKSB7XG4gICAgICAgIGRlbXV4ZXIucHVzaChkYXRhLCBkZWNyeXB0ZGF0YSwgaW5pdFNlZ21lbnQsIGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWMsIHRpbWVPZmZzZXQsIGRpc2NvbnRpbnVpdHksIHRyYWNrU3dpdGNoLCBjb250aWd1b3VzLCBkdXJhdGlvbiwgYWNjdXJhdGVUaW1lT2Zmc2V0LGRlZmF1bHRJbml0UFRTKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBvbldvcmtlck1lc3NhZ2UoZXYpIHtcbiAgICBsZXQgZGF0YSA9IGV2LmRhdGEsXG4gICAgICAgIGhscyA9IHRoaXMuaGxzO1xuICAgIC8vY29uc29sZS5sb2coJ29uV29ya2VyTWVzc2FnZTonICsgZGF0YS5ldmVudCk7XG4gICAgc3dpdGNoKGRhdGEuZXZlbnQpIHtcbiAgICAgIGNhc2UgJ2luaXQnOlxuICAgICAgICAvLyByZXZva2UgdGhlIE9iamVjdCBVUkwgdGhhdCB3YXMgdXNlZCB0byBjcmVhdGUgZGVtdXhlciB3b3JrZXIsIHNvIGFzIG5vdCB0byBsZWFrIGl0XG4gICAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwodGhpcy53Lm9iamVjdFVSTCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgLy8gc3BlY2lhbCBjYXNlIGZvciBGUkFHX1BBUlNJTkdfREFUQTogZGF0YTEgYW5kIGRhdGEyIGFyZSB0cmFuc2ZlcmFibGUgb2JqZWN0c1xuICAgICAgY2FzZSBFdmVudC5GUkFHX1BBUlNJTkdfREFUQTpcbiAgICAgICAgZGF0YS5kYXRhLmRhdGExID0gbmV3IFVpbnQ4QXJyYXkoZGF0YS5kYXRhMSk7XG4gICAgICAgIGlmIChkYXRhLmRhdGEyKSB7XG4gICAgICAgICAgZGF0YS5kYXRhLmRhdGEyID0gbmV3IFVpbnQ4QXJyYXkoZGF0YS5kYXRhMik7XG4gICAgICAgIH1cbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgZGF0YS5kYXRhID0gZGF0YS5kYXRhIHx8IHt9O1xuICAgICAgICBkYXRhLmRhdGEuZnJhZyA9IHRoaXMuZnJhZztcbiAgICAgICAgZGF0YS5kYXRhLmlkID0gdGhpcy5pZDtcbiAgICAgICAgaGxzLnRyaWdnZXIoZGF0YS5ldmVudCwgZGF0YS5kYXRhKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IERlbXV4ZXI7XG5cbiIsIi8qKlxuICogUGFyc2VyIGZvciBleHBvbmVudGlhbCBHb2xvbWIgY29kZXMsIGEgdmFyaWFibGUtYml0d2lkdGggbnVtYmVyIGVuY29kaW5nIHNjaGVtZSB1c2VkIGJ5IGgyNjQuXG4qL1xuXG5pbXBvcnQge2xvZ2dlcn0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcblxuY2xhc3MgRXhwR29sb21iIHtcblxuICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICAvLyB0aGUgbnVtYmVyIG9mIGJ5dGVzIGxlZnQgdG8gZXhhbWluZSBpbiB0aGlzLmRhdGFcbiAgICB0aGlzLmJ5dGVzQXZhaWxhYmxlID0gZGF0YS5ieXRlTGVuZ3RoO1xuICAgIC8vIHRoZSBjdXJyZW50IHdvcmQgYmVpbmcgZXhhbWluZWRcbiAgICB0aGlzLndvcmQgPSAwOyAvLyA6dWludFxuICAgIC8vIHRoZSBudW1iZXIgb2YgYml0cyBsZWZ0IHRvIGV4YW1pbmUgaW4gdGhlIGN1cnJlbnQgd29yZFxuICAgIHRoaXMuYml0c0F2YWlsYWJsZSA9IDA7IC8vIDp1aW50XG4gIH1cblxuICAvLyAoKTp2b2lkXG4gIGxvYWRXb3JkKCkge1xuICAgIHZhclxuICAgICAgZGF0YSA9IHRoaXMuZGF0YSxcbiAgICAgIGJ5dGVzQXZhaWxhYmxlID0gdGhpcy5ieXRlc0F2YWlsYWJsZSxcbiAgICAgIHBvc2l0aW9uID0gZGF0YS5ieXRlTGVuZ3RoIC0gYnl0ZXNBdmFpbGFibGUsXG4gICAgICB3b3JraW5nQnl0ZXMgPSBuZXcgVWludDhBcnJheSg0KSxcbiAgICAgIGF2YWlsYWJsZUJ5dGVzID0gTWF0aC5taW4oNCwgYnl0ZXNBdmFpbGFibGUpO1xuICAgIGlmIChhdmFpbGFibGVCeXRlcyA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdubyBieXRlcyBhdmFpbGFibGUnKTtcbiAgICB9XG4gICAgd29ya2luZ0J5dGVzLnNldChkYXRhLnN1YmFycmF5KHBvc2l0aW9uLCBwb3NpdGlvbiArIGF2YWlsYWJsZUJ5dGVzKSk7XG4gICAgdGhpcy53b3JkID0gbmV3IERhdGFWaWV3KHdvcmtpbmdCeXRlcy5idWZmZXIpLmdldFVpbnQzMigwKTtcbiAgICAvLyB0cmFjayB0aGUgYW1vdW50IG9mIHRoaXMuZGF0YSB0aGF0IGhhcyBiZWVuIHByb2Nlc3NlZFxuICAgIHRoaXMuYml0c0F2YWlsYWJsZSA9IGF2YWlsYWJsZUJ5dGVzICogODtcbiAgICB0aGlzLmJ5dGVzQXZhaWxhYmxlIC09IGF2YWlsYWJsZUJ5dGVzO1xuICB9XG5cbiAgLy8gKGNvdW50OmludCk6dm9pZFxuICBza2lwQml0cyhjb3VudCkge1xuICAgIHZhciBza2lwQnl0ZXM7IC8vIDppbnRcbiAgICBpZiAodGhpcy5iaXRzQXZhaWxhYmxlID4gY291bnQpIHtcbiAgICAgIHRoaXMud29yZCA8PD0gY291bnQ7XG4gICAgICB0aGlzLmJpdHNBdmFpbGFibGUgLT0gY291bnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvdW50IC09IHRoaXMuYml0c0F2YWlsYWJsZTtcbiAgICAgIHNraXBCeXRlcyA9IGNvdW50ID4+IDM7XG4gICAgICBjb3VudCAtPSAoc2tpcEJ5dGVzID4+IDMpO1xuICAgICAgdGhpcy5ieXRlc0F2YWlsYWJsZSAtPSBza2lwQnl0ZXM7XG4gICAgICB0aGlzLmxvYWRXb3JkKCk7XG4gICAgICB0aGlzLndvcmQgPDw9IGNvdW50O1xuICAgICAgdGhpcy5iaXRzQXZhaWxhYmxlIC09IGNvdW50O1xuICAgIH1cbiAgfVxuXG4gIC8vIChzaXplOmludCk6dWludFxuICByZWFkQml0cyhzaXplKSB7XG4gICAgdmFyXG4gICAgICBiaXRzID0gTWF0aC5taW4odGhpcy5iaXRzQXZhaWxhYmxlLCBzaXplKSwgLy8gOnVpbnRcbiAgICAgIHZhbHUgPSB0aGlzLndvcmQgPj4+ICgzMiAtIGJpdHMpOyAvLyA6dWludFxuICAgIGlmIChzaXplID4gMzIpIHtcbiAgICAgIGxvZ2dlci5lcnJvcignQ2Fubm90IHJlYWQgbW9yZSB0aGFuIDMyIGJpdHMgYXQgYSB0aW1lJyk7XG4gICAgfVxuICAgIHRoaXMuYml0c0F2YWlsYWJsZSAtPSBiaXRzO1xuICAgIGlmICh0aGlzLmJpdHNBdmFpbGFibGUgPiAwKSB7XG4gICAgICB0aGlzLndvcmQgPDw9IGJpdHM7XG4gICAgfSBlbHNlIGlmICh0aGlzLmJ5dGVzQXZhaWxhYmxlID4gMCkge1xuICAgICAgdGhpcy5sb2FkV29yZCgpO1xuICAgIH1cbiAgICBiaXRzID0gc2l6ZSAtIGJpdHM7XG4gICAgaWYgKGJpdHMgPiAwICYmIHRoaXMuYml0c0F2YWlsYWJsZSkge1xuICAgICAgcmV0dXJuIHZhbHUgPDwgYml0cyB8IHRoaXMucmVhZEJpdHMoYml0cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB2YWx1O1xuICAgIH1cbiAgfVxuXG4gIC8vICgpOnVpbnRcbiAgc2tpcExaKCkge1xuICAgIHZhciBsZWFkaW5nWmVyb0NvdW50OyAvLyA6dWludFxuICAgIGZvciAobGVhZGluZ1plcm9Db3VudCA9IDA7IGxlYWRpbmdaZXJvQ291bnQgPCB0aGlzLmJpdHNBdmFpbGFibGU7ICsrbGVhZGluZ1plcm9Db3VudCkge1xuICAgICAgaWYgKDAgIT09ICh0aGlzLndvcmQgJiAoMHg4MDAwMDAwMCA+Pj4gbGVhZGluZ1plcm9Db3VudCkpKSB7XG4gICAgICAgIC8vIHRoZSBmaXJzdCBiaXQgb2Ygd29ya2luZyB3b3JkIGlzIDFcbiAgICAgICAgdGhpcy53b3JkIDw8PSBsZWFkaW5nWmVyb0NvdW50O1xuICAgICAgICB0aGlzLmJpdHNBdmFpbGFibGUgLT0gbGVhZGluZ1plcm9Db3VudDtcbiAgICAgICAgcmV0dXJuIGxlYWRpbmdaZXJvQ291bnQ7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIHdlIGV4aGF1c3RlZCB3b3JkIGFuZCBzdGlsbCBoYXZlIG5vdCBmb3VuZCBhIDFcbiAgICB0aGlzLmxvYWRXb3JkKCk7XG4gICAgcmV0dXJuIGxlYWRpbmdaZXJvQ291bnQgKyB0aGlzLnNraXBMWigpO1xuICB9XG5cbiAgLy8gKCk6dm9pZFxuICBza2lwVUVHKCkge1xuICAgIHRoaXMuc2tpcEJpdHMoMSArIHRoaXMuc2tpcExaKCkpO1xuICB9XG5cbiAgLy8gKCk6dm9pZFxuICBza2lwRUcoKSB7XG4gICAgdGhpcy5za2lwQml0cygxICsgdGhpcy5za2lwTFooKSk7XG4gIH1cblxuICAvLyAoKTp1aW50XG4gIHJlYWRVRUcoKSB7XG4gICAgdmFyIGNseiA9IHRoaXMuc2tpcExaKCk7IC8vIDp1aW50XG4gICAgcmV0dXJuIHRoaXMucmVhZEJpdHMoY2x6ICsgMSkgLSAxO1xuICB9XG5cbiAgLy8gKCk6aW50XG4gIHJlYWRFRygpIHtcbiAgICB2YXIgdmFsdSA9IHRoaXMucmVhZFVFRygpOyAvLyA6aW50XG4gICAgaWYgKDB4MDEgJiB2YWx1KSB7XG4gICAgICAvLyB0aGUgbnVtYmVyIGlzIG9kZCBpZiB0aGUgbG93IG9yZGVyIGJpdCBpcyBzZXRcbiAgICAgIHJldHVybiAoMSArIHZhbHUpID4+PiAxOyAvLyBhZGQgMSB0byBtYWtlIGl0IGV2ZW4sIGFuZCBkaXZpZGUgYnkgMlxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gLTEgKiAodmFsdSA+Pj4gMSk7IC8vIGRpdmlkZSBieSB0d28gdGhlbiBtYWtlIGl0IG5lZ2F0aXZlXG4gICAgfVxuICB9XG5cbiAgLy8gU29tZSBjb252ZW5pZW5jZSBmdW5jdGlvbnNcbiAgLy8gOkJvb2xlYW5cbiAgcmVhZEJvb2xlYW4oKSB7XG4gICAgcmV0dXJuIDEgPT09IHRoaXMucmVhZEJpdHMoMSk7XG4gIH1cblxuICAvLyAoKTppbnRcbiAgcmVhZFVCeXRlKCkge1xuICAgIHJldHVybiB0aGlzLnJlYWRCaXRzKDgpO1xuICB9XG5cbiAgLy8gKCk6aW50XG4gIHJlYWRVU2hvcnQoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVhZEJpdHMoMTYpO1xuICB9XG4gICAgLy8gKCk6aW50XG4gIHJlYWRVSW50KCkge1xuICAgIHJldHVybiB0aGlzLnJlYWRCaXRzKDMyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZHZhbmNlIHRoZSBFeHBHb2xvbWIgZGVjb2RlciBwYXN0IGEgc2NhbGluZyBsaXN0LiBUaGUgc2NhbGluZ1xuICAgKiBsaXN0IGlzIG9wdGlvbmFsbHkgdHJhbnNtaXR0ZWQgYXMgcGFydCBvZiBhIHNlcXVlbmNlIHBhcmFtZXRlclxuICAgKiBzZXQgYW5kIGlzIG5vdCByZWxldmFudCB0byB0cmFuc211eGluZy5cbiAgICogQHBhcmFtIGNvdW50IHtudW1iZXJ9IHRoZSBudW1iZXIgb2YgZW50cmllcyBpbiB0aGlzIHNjYWxpbmcgbGlzdFxuICAgKiBAc2VlIFJlY29tbWVuZGF0aW9uIElUVS1UIEguMjY0LCBTZWN0aW9uIDcuMy4yLjEuMS4xXG4gICAqL1xuICBza2lwU2NhbGluZ0xpc3QoY291bnQpIHtcbiAgICB2YXJcbiAgICAgIGxhc3RTY2FsZSA9IDgsXG4gICAgICBuZXh0U2NhbGUgPSA4LFxuICAgICAgaixcbiAgICAgIGRlbHRhU2NhbGU7XG4gICAgZm9yIChqID0gMDsgaiA8IGNvdW50OyBqKyspIHtcbiAgICAgIGlmIChuZXh0U2NhbGUgIT09IDApIHtcbiAgICAgICAgZGVsdGFTY2FsZSA9IHRoaXMucmVhZEVHKCk7XG4gICAgICAgIG5leHRTY2FsZSA9IChsYXN0U2NhbGUgKyBkZWx0YVNjYWxlICsgMjU2KSAlIDI1NjtcbiAgICAgIH1cbiAgICAgIGxhc3RTY2FsZSA9IChuZXh0U2NhbGUgPT09IDApID8gbGFzdFNjYWxlIDogbmV4dFNjYWxlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZWFkIGEgc2VxdWVuY2UgcGFyYW1ldGVyIHNldCBhbmQgcmV0dXJuIHNvbWUgaW50ZXJlc3RpbmcgdmlkZW9cbiAgICogcHJvcGVydGllcy4gQSBzZXF1ZW5jZSBwYXJhbWV0ZXIgc2V0IGlzIHRoZSBIMjY0IG1ldGFkYXRhIHRoYXRcbiAgICogZGVzY3JpYmVzIHRoZSBwcm9wZXJ0aWVzIG9mIHVwY29taW5nIHZpZGVvIGZyYW1lcy5cbiAgICogQHBhcmFtIGRhdGEge1VpbnQ4QXJyYXl9IHRoZSBieXRlcyBvZiBhIHNlcXVlbmNlIHBhcmFtZXRlciBzZXRcbiAgICogQHJldHVybiB7b2JqZWN0fSBhbiBvYmplY3Qgd2l0aCBjb25maWd1cmF0aW9uIHBhcnNlZCBmcm9tIHRoZVxuICAgKiBzZXF1ZW5jZSBwYXJhbWV0ZXIgc2V0LCBpbmNsdWRpbmcgdGhlIGRpbWVuc2lvbnMgb2YgdGhlXG4gICAqIGFzc29jaWF0ZWQgdmlkZW8gZnJhbWVzLlxuICAgKi9cbiAgcmVhZFNQUygpIHtcbiAgICB2YXJcbiAgICAgIGZyYW1lQ3JvcExlZnRPZmZzZXQgPSAwLFxuICAgICAgZnJhbWVDcm9wUmlnaHRPZmZzZXQgPSAwLFxuICAgICAgZnJhbWVDcm9wVG9wT2Zmc2V0ID0gMCxcbiAgICAgIGZyYW1lQ3JvcEJvdHRvbU9mZnNldCA9IDAsXG4gICAgICBwcm9maWxlSWRjLHByb2ZpbGVDb21wYXQsbGV2ZWxJZGMsXG4gICAgICBudW1SZWZGcmFtZXNJblBpY09yZGVyQ250Q3ljbGUsIHBpY1dpZHRoSW5NYnNNaW51czEsXG4gICAgICBwaWNIZWlnaHRJbk1hcFVuaXRzTWludXMxLFxuICAgICAgZnJhbWVNYnNPbmx5RmxhZyxcbiAgICAgIHNjYWxpbmdMaXN0Q291bnQsXG4gICAgICBpLFxuICAgICAgcmVhZFVCeXRlID0gdGhpcy5yZWFkVUJ5dGUuYmluZCh0aGlzKSxcbiAgICAgIHJlYWRCaXRzID0gdGhpcy5yZWFkQml0cy5iaW5kKHRoaXMpLFxuICAgICAgcmVhZFVFRyA9IHRoaXMucmVhZFVFRy5iaW5kKHRoaXMpLFxuICAgICAgcmVhZEJvb2xlYW4gPSB0aGlzLnJlYWRCb29sZWFuLmJpbmQodGhpcyksXG4gICAgICBza2lwQml0cyA9IHRoaXMuc2tpcEJpdHMuYmluZCh0aGlzKSxcbiAgICAgIHNraXBFRyA9IHRoaXMuc2tpcEVHLmJpbmQodGhpcyksXG4gICAgICBza2lwVUVHID0gdGhpcy5za2lwVUVHLmJpbmQodGhpcyksXG4gICAgICBza2lwU2NhbGluZ0xpc3QgPSB0aGlzLnNraXBTY2FsaW5nTGlzdC5iaW5kKHRoaXMpO1xuXG4gICAgcmVhZFVCeXRlKCk7XG4gICAgcHJvZmlsZUlkYyA9IHJlYWRVQnl0ZSgpOyAvLyBwcm9maWxlX2lkY1xuICAgIHByb2ZpbGVDb21wYXQgPSByZWFkQml0cyg1KTsgLy8gY29uc3RyYWludF9zZXRbMC00XV9mbGFnLCB1KDUpXG4gICAgc2tpcEJpdHMoMyk7IC8vIHJlc2VydmVkX3plcm9fM2JpdHMgdSgzKSxcbiAgICBsZXZlbElkYyA9IHJlYWRVQnl0ZSgpOyAvL2xldmVsX2lkYyB1KDgpXG4gICAgc2tpcFVFRygpOyAvLyBzZXFfcGFyYW1ldGVyX3NldF9pZFxuICAgIC8vIHNvbWUgcHJvZmlsZXMgaGF2ZSBtb3JlIG9wdGlvbmFsIGRhdGEgd2UgZG9uJ3QgbmVlZFxuICAgIGlmIChwcm9maWxlSWRjID09PSAxMDAgfHxcbiAgICAgICAgcHJvZmlsZUlkYyA9PT0gMTEwIHx8XG4gICAgICAgIHByb2ZpbGVJZGMgPT09IDEyMiB8fFxuICAgICAgICBwcm9maWxlSWRjID09PSAyNDQgfHxcbiAgICAgICAgcHJvZmlsZUlkYyA9PT0gNDQgIHx8XG4gICAgICAgIHByb2ZpbGVJZGMgPT09IDgzICB8fFxuICAgICAgICBwcm9maWxlSWRjID09PSA4NiAgfHxcbiAgICAgICAgcHJvZmlsZUlkYyA9PT0gMTE4IHx8XG4gICAgICAgIHByb2ZpbGVJZGMgPT09IDEyOCkge1xuICAgICAgdmFyIGNocm9tYUZvcm1hdElkYyA9IHJlYWRVRUcoKTtcbiAgICAgIGlmIChjaHJvbWFGb3JtYXRJZGMgPT09IDMpIHtcbiAgICAgICAgc2tpcEJpdHMoMSk7IC8vIHNlcGFyYXRlX2NvbG91cl9wbGFuZV9mbGFnXG4gICAgICB9XG4gICAgICBza2lwVUVHKCk7IC8vIGJpdF9kZXB0aF9sdW1hX21pbnVzOFxuICAgICAgc2tpcFVFRygpOyAvLyBiaXRfZGVwdGhfY2hyb21hX21pbnVzOFxuICAgICAgc2tpcEJpdHMoMSk7IC8vIHFwcHJpbWVfeV96ZXJvX3RyYW5zZm9ybV9ieXBhc3NfZmxhZ1xuICAgICAgaWYgKHJlYWRCb29sZWFuKCkpIHsgLy8gc2VxX3NjYWxpbmdfbWF0cml4X3ByZXNlbnRfZmxhZ1xuICAgICAgICBzY2FsaW5nTGlzdENvdW50ID0gKGNocm9tYUZvcm1hdElkYyAhPT0gMykgPyA4IDogMTI7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzY2FsaW5nTGlzdENvdW50OyBpKyspIHtcbiAgICAgICAgICBpZiAocmVhZEJvb2xlYW4oKSkgeyAvLyBzZXFfc2NhbGluZ19saXN0X3ByZXNlbnRfZmxhZ1sgaSBdXG4gICAgICAgICAgICBpZiAoaSA8IDYpIHtcbiAgICAgICAgICAgICAgc2tpcFNjYWxpbmdMaXN0KDE2KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHNraXBTY2FsaW5nTGlzdCg2NCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHNraXBVRUcoKTsgLy8gbG9nMl9tYXhfZnJhbWVfbnVtX21pbnVzNFxuICAgIHZhciBwaWNPcmRlckNudFR5cGUgPSByZWFkVUVHKCk7XG4gICAgaWYgKHBpY09yZGVyQ250VHlwZSA9PT0gMCkge1xuICAgICAgcmVhZFVFRygpOyAvL2xvZzJfbWF4X3BpY19vcmRlcl9jbnRfbHNiX21pbnVzNFxuICAgIH0gZWxzZSBpZiAocGljT3JkZXJDbnRUeXBlID09PSAxKSB7XG4gICAgICBza2lwQml0cygxKTsgLy8gZGVsdGFfcGljX29yZGVyX2Fsd2F5c196ZXJvX2ZsYWdcbiAgICAgIHNraXBFRygpOyAvLyBvZmZzZXRfZm9yX25vbl9yZWZfcGljXG4gICAgICBza2lwRUcoKTsgLy8gb2Zmc2V0X2Zvcl90b3BfdG9fYm90dG9tX2ZpZWxkXG4gICAgICBudW1SZWZGcmFtZXNJblBpY09yZGVyQ250Q3ljbGUgPSByZWFkVUVHKCk7XG4gICAgICBmb3IoaSA9IDA7IGkgPCBudW1SZWZGcmFtZXNJblBpY09yZGVyQ250Q3ljbGU7IGkrKykge1xuICAgICAgICBza2lwRUcoKTsgLy8gb2Zmc2V0X2Zvcl9yZWZfZnJhbWVbIGkgXVxuICAgICAgfVxuICAgIH1cbiAgICBza2lwVUVHKCk7IC8vIG1heF9udW1fcmVmX2ZyYW1lc1xuICAgIHNraXBCaXRzKDEpOyAvLyBnYXBzX2luX2ZyYW1lX251bV92YWx1ZV9hbGxvd2VkX2ZsYWdcbiAgICBwaWNXaWR0aEluTWJzTWludXMxID0gcmVhZFVFRygpO1xuICAgIHBpY0hlaWdodEluTWFwVW5pdHNNaW51czEgPSByZWFkVUVHKCk7XG4gICAgZnJhbWVNYnNPbmx5RmxhZyA9IHJlYWRCaXRzKDEpO1xuICAgIGlmIChmcmFtZU1ic09ubHlGbGFnID09PSAwKSB7XG4gICAgICBza2lwQml0cygxKTsgLy8gbWJfYWRhcHRpdmVfZnJhbWVfZmllbGRfZmxhZ1xuICAgIH1cbiAgICBza2lwQml0cygxKTsgLy8gZGlyZWN0Xzh4OF9pbmZlcmVuY2VfZmxhZ1xuICAgIGlmIChyZWFkQm9vbGVhbigpKSB7IC8vIGZyYW1lX2Nyb3BwaW5nX2ZsYWdcbiAgICAgIGZyYW1lQ3JvcExlZnRPZmZzZXQgPSByZWFkVUVHKCk7XG4gICAgICBmcmFtZUNyb3BSaWdodE9mZnNldCA9IHJlYWRVRUcoKTtcbiAgICAgIGZyYW1lQ3JvcFRvcE9mZnNldCA9IHJlYWRVRUcoKTtcbiAgICAgIGZyYW1lQ3JvcEJvdHRvbU9mZnNldCA9IHJlYWRVRUcoKTtcbiAgICB9XG4gICAgbGV0IHBpeGVsUmF0aW8gPSBbMSwxXTtcbiAgICBpZiAocmVhZEJvb2xlYW4oKSkge1xuICAgICAgLy8gdnVpX3BhcmFtZXRlcnNfcHJlc2VudF9mbGFnXG4gICAgICBpZiAocmVhZEJvb2xlYW4oKSkge1xuICAgICAgICAvLyBhc3BlY3RfcmF0aW9faW5mb19wcmVzZW50X2ZsYWdcbiAgICAgICAgY29uc3QgYXNwZWN0UmF0aW9JZGMgPSByZWFkVUJ5dGUoKTtcbiAgICAgICAgc3dpdGNoIChhc3BlY3RSYXRpb0lkYykge1xuICAgICAgICAgIGNhc2UgMTogcGl4ZWxSYXRpbyA9IFsxLDFdOyBicmVhaztcbiAgICAgICAgICBjYXNlIDI6IHBpeGVsUmF0aW8gPSBbMTIsMTFdOyBicmVhaztcbiAgICAgICAgICBjYXNlIDM6IHBpeGVsUmF0aW8gPSBbMTAsMTFdOyBicmVhaztcbiAgICAgICAgICBjYXNlIDQ6IHBpeGVsUmF0aW8gPSBbMTYsMTFdOyBicmVhaztcbiAgICAgICAgICBjYXNlIDU6IHBpeGVsUmF0aW8gPSBbNDAsMzNdOyBicmVhaztcbiAgICAgICAgICBjYXNlIDY6IHBpeGVsUmF0aW8gPSBbMjQsMTFdOyBicmVhaztcbiAgICAgICAgICBjYXNlIDc6IHBpeGVsUmF0aW8gPSBbMjAsMTFdOyBicmVhaztcbiAgICAgICAgICBjYXNlIDg6IHBpeGVsUmF0aW8gPSBbMzIsMTFdOyBicmVhaztcbiAgICAgICAgICBjYXNlIDk6IHBpeGVsUmF0aW8gPSBbODAsMzNdOyBicmVhaztcbiAgICAgICAgICBjYXNlIDEwOiBwaXhlbFJhdGlvID0gWzE4LDExXTsgYnJlYWs7XG4gICAgICAgICAgY2FzZSAxMTogcGl4ZWxSYXRpbyA9IFsxNSwxMV07IGJyZWFrO1xuICAgICAgICAgIGNhc2UgMTI6IHBpeGVsUmF0aW8gPSBbNjQsMzNdOyBicmVhaztcbiAgICAgICAgICBjYXNlIDEzOiBwaXhlbFJhdGlvID0gWzE2MCw5OV07IGJyZWFrO1xuICAgICAgICAgIGNhc2UgMTQ6IHBpeGVsUmF0aW8gPSBbNCwzXTsgYnJlYWs7XG4gICAgICAgICAgY2FzZSAxNTogcGl4ZWxSYXRpbyA9IFszLDJdOyBicmVhaztcbiAgICAgICAgICBjYXNlIDE2OiBwaXhlbFJhdGlvID0gWzIsMV07IGJyZWFrO1xuICAgICAgICAgIGNhc2UgMjU1OiB7XG4gICAgICAgICAgICBwaXhlbFJhdGlvID0gW3JlYWRVQnl0ZSgpIDw8IDggfCByZWFkVUJ5dGUoKSwgcmVhZFVCeXRlKCkgPDwgOCB8IHJlYWRVQnl0ZSgpXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgd2lkdGg6IE1hdGguY2VpbCgoKChwaWNXaWR0aEluTWJzTWludXMxICsgMSkgKiAxNikgLSBmcmFtZUNyb3BMZWZ0T2Zmc2V0ICogMiAtIGZyYW1lQ3JvcFJpZ2h0T2Zmc2V0ICogMikpLFxuICAgICAgaGVpZ2h0OiAoKDIgLSBmcmFtZU1ic09ubHlGbGFnKSAqIChwaWNIZWlnaHRJbk1hcFVuaXRzTWludXMxICsgMSkgKiAxNikgLSAoKGZyYW1lTWJzT25seUZsYWc/IDIgOiA0KSAqIChmcmFtZUNyb3BUb3BPZmZzZXQgKyBmcmFtZUNyb3BCb3R0b21PZmZzZXQpKSxcbiAgICAgIHBpeGVsUmF0aW8gOiBwaXhlbFJhdGlvXG4gICAgfTtcbiAgfVxuXG4gIHJlYWRTbGljZVR5cGUoKSB7XG4gICAgLy8gc2tpcCBOQUx1IHR5cGVcbiAgICB0aGlzLnJlYWRVQnl0ZSgpO1xuICAgIC8vIGRpc2NhcmQgZmlyc3RfbWJfaW5fc2xpY2VcbiAgICB0aGlzLnJlYWRVRUcoKTtcbiAgICAvLyByZXR1cm4gc2xpY2VfdHlwZVxuICAgIHJldHVybiB0aGlzLnJlYWRVRUcoKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBFeHBHb2xvbWI7XG4iLCIvKipcbiAqIElEMyBwYXJzZXJcbiAqL1xuaW1wb3J0IHtsb2dnZXJ9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XG4vL2ltcG9ydCBIZXggZnJvbSAnLi4vdXRpbHMvaGV4JztcblxuIGNsYXNzIElEMyB7XG5cbiAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgIHRoaXMuX2hhc1RpbWVTdGFtcCA9IGZhbHNlO1xuICAgIHZhciBvZmZzZXQgPSAwLCBieXRlMSxieXRlMixieXRlMyxieXRlNCx0YWdTaXplLGVuZFBvcyxoZWFkZXIsbGVuO1xuICAgICAgZG8ge1xuICAgICAgICBoZWFkZXIgPSB0aGlzLnJlYWRVVEYoZGF0YSxvZmZzZXQsMyk7XG4gICAgICAgIG9mZnNldCs9MztcbiAgICAgICAgICAvLyBmaXJzdCBjaGVjayBmb3IgSUQzIGhlYWRlclxuICAgICAgICAgIGlmIChoZWFkZXIgPT09ICdJRDMnKSB7XG4gICAgICAgICAgICAgIC8vIHNraXAgMjQgYml0c1xuICAgICAgICAgICAgICBvZmZzZXQgKz0gMztcbiAgICAgICAgICAgICAgLy8gcmV0cmlldmUgdGFnKHMpIGxlbmd0aFxuICAgICAgICAgICAgICBieXRlMSA9IGRhdGFbb2Zmc2V0KytdICYgMHg3ZjtcbiAgICAgICAgICAgICAgYnl0ZTIgPSBkYXRhW29mZnNldCsrXSAmIDB4N2Y7XG4gICAgICAgICAgICAgIGJ5dGUzID0gZGF0YVtvZmZzZXQrK10gJiAweDdmO1xuICAgICAgICAgICAgICBieXRlNCA9IGRhdGFbb2Zmc2V0KytdICYgMHg3ZjtcbiAgICAgICAgICAgICAgdGFnU2l6ZSA9IChieXRlMSA8PCAyMSkgKyAoYnl0ZTIgPDwgMTQpICsgKGJ5dGUzIDw8IDcpICsgYnl0ZTQ7XG4gICAgICAgICAgICAgIGVuZFBvcyA9IG9mZnNldCArIHRhZ1NpemU7XG4gICAgICAgICAgICAgIC8vbG9nZ2VyLmxvZyhgSUQzIHRhZyBmb3VuZCwgc2l6ZS9lbmQ6ICR7dGFnU2l6ZX0vJHtlbmRQb3N9YCk7XG5cbiAgICAgICAgICAgICAgLy8gcmVhZCBJRDMgdGFnc1xuICAgICAgICAgICAgICB0aGlzLl9wYXJzZUlEM0ZyYW1lcyhkYXRhLCBvZmZzZXQsZW5kUG9zKTtcbiAgICAgICAgICAgICAgb2Zmc2V0ID0gZW5kUG9zO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaGVhZGVyID09PSAnM0RJJykge1xuICAgICAgICAgICAgICAvLyBodHRwOi8vaWQzLm9yZy9pZDN2Mi40LjAtc3RydWN0dXJlIGNoYXB0ZXIgMy40LiAgIElEM3YyIGZvb3RlclxuICAgICAgICAgICAgICBvZmZzZXQgKz0gNztcbiAgICAgICAgICAgICAgICAgIGxvZ2dlci5sb2coYDNESSBmb290ZXIgZm91bmQsIGVuZDogJHtvZmZzZXR9YCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgb2Zmc2V0IC09IDM7XG4gICAgICAgICAgICAgIGxlbiA9IG9mZnNldDtcbiAgICAgICAgICAgICAgICAgIGlmIChsZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAvL2xvZ2dlci5sb2coYElEMyBsZW46ICR7bGVufWApO1xuICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5oYXNUaW1lU3RhbXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLndhcm4oJ0lEMyB0YWcgZm91bmQsIGJ1dCBubyB0aW1lc3RhbXAnKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGVuZ3RoID0gbGVuO1xuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3BheWxvYWQgPSBkYXRhLnN1YmFycmF5KDAsbGVuKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgIH0gd2hpbGUgKHRydWUpO1xuICB9XG5cbiAgcmVhZFVURihkYXRhLHN0YXJ0LGxlbikge1xuXG4gICAgdmFyIHJlc3VsdCA9ICcnLG9mZnNldCA9IHN0YXJ0LCBlbmQgPSBzdGFydCArIGxlbjtcbiAgICBkbyB7XG4gICAgICByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShkYXRhW29mZnNldCsrXSk7XG4gICAgfSB3aGlsZShvZmZzZXQgPCBlbmQpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBfcGFyc2VJRDNGcmFtZXMoZGF0YSxvZmZzZXQsZW5kUG9zKSB7XG4gICAgdmFyIHRhZ0lkLHRhZ0xlbix0YWdTdGFydCx0YWdGbGFncyx0aW1lc3RhbXA7XG4gICAgd2hpbGUob2Zmc2V0ICsgOCA8PSBlbmRQb3MpIHtcbiAgICAgIHRhZ0lkID0gdGhpcy5yZWFkVVRGKGRhdGEsb2Zmc2V0LDQpO1xuICAgICAgb2Zmc2V0ICs9NDtcblxuICAgICAgdGFnTGVuID0gZGF0YVtvZmZzZXQrK10gPDwgMjQgK1xuICAgICAgICAgICAgICAgIGRhdGFbb2Zmc2V0KytdIDw8IDE2ICtcbiAgICAgICAgICAgICAgICBkYXRhW29mZnNldCsrXSA8PCA4ICtcbiAgICAgICAgICAgICAgICBkYXRhW29mZnNldCsrXTtcblxuICAgICAgdGFnRmxhZ3MgPSBkYXRhW29mZnNldCsrXSA8PCA4ICtcbiAgICAgICAgICAgICAgICAgIGRhdGFbb2Zmc2V0KytdO1xuXG4gICAgICB0YWdTdGFydCA9IG9mZnNldDtcbiAgICAgIC8vbG9nZ2VyLmxvZyhcIklEMyB0YWcgaWQ6XCIgKyB0YWdJZCk7XG4gICAgICBzd2l0Y2godGFnSWQpIHtcbiAgICAgICAgY2FzZSAnUFJJVic6XG4gICAgICAgICAgICAvL2xvZ2dlci5sb2coJ3BhcnNlIGZyYW1lOicgKyBIZXguaGV4RHVtcChkYXRhLnN1YmFycmF5KG9mZnNldCxlbmRQb3MpKSk7XG4gICAgICAgICAgICAvLyBvd25lciBzaG91bGQgYmUgXCJjb20uYXBwbGUuc3RyZWFtaW5nLnRyYW5zcG9ydFN0cmVhbVRpbWVzdGFtcFwiXG4gICAgICAgICAgICBpZiAodGhpcy5yZWFkVVRGKGRhdGEsb2Zmc2V0LDQ0KSA9PT0gJ2NvbS5hcHBsZS5zdHJlYW1pbmcudHJhbnNwb3J0U3RyZWFtVGltZXN0YW1wJykge1xuICAgICAgICAgICAgICAgIG9mZnNldCs9NDQ7XG4gICAgICAgICAgICAgICAgLy8gc21lbGxpbmcgZXZlbiBiZXR0ZXIgISB3ZSBmb3VuZCB0aGUgcmlnaHQgZGVzY3JpcHRvclxuICAgICAgICAgICAgICAgIC8vIHNraXAgbnVsbCBjaGFyYWN0ZXIgKHN0cmluZyBlbmQpICsgMyBmaXJzdCBieXRlc1xuICAgICAgICAgICAgICAgIG9mZnNldCs9IDQ7XG5cbiAgICAgICAgICAgICAgICAvLyB0aW1lc3RhbXAgaXMgMzMgYml0IGV4cHJlc3NlZCBhcyBhIGJpZy1lbmRpYW4gZWlnaHQtb2N0ZXQgbnVtYmVyLCB3aXRoIHRoZSB1cHBlciAzMSBiaXRzIHNldCB0byB6ZXJvLlxuICAgICAgICAgICAgICAgIHZhciBwdHMzM0JpdCAgPSBkYXRhW29mZnNldCsrXSAmIDB4MTtcbiAgICAgICAgICAgICAgICB0aGlzLl9oYXNUaW1lU3RhbXAgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgdGltZXN0YW1wID0gKChkYXRhW29mZnNldCsrXSA8PCAyMykgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZGF0YVtvZmZzZXQrK10gPDwgMTUpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGRhdGFbb2Zmc2V0KytdIDw8ICA3KSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFbb2Zmc2V0KytdKSAvNDU7XG5cbiAgICAgICAgICAgICAgICBpZiAocHRzMzNCaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGltZXN0YW1wICAgKz0gNDc3MjE4NTguODQ7IC8vIDJeMzIgLyA5MFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aW1lc3RhbXAgPSBNYXRoLnJvdW5kKHRpbWVzdGFtcCk7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRyYWNlKGBJRDMgdGltZXN0YW1wIGZvdW5kOiAke3RpbWVzdGFtcH1gKTtcbiAgICAgICAgICAgICAgICB0aGlzLl90aW1lU3RhbXAgPSB0aW1lc3RhbXA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGdldCBoYXNUaW1lU3RhbXAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2hhc1RpbWVTdGFtcDtcbiAgfVxuXG4gIGdldCB0aW1lU3RhbXAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RpbWVTdGFtcDtcbiAgfVxuXG4gIGdldCBsZW5ndGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xlbmd0aDtcbiAgfVxuXG4gIGdldCBwYXlsb2FkKCkge1xuICAgIHJldHVybiB0aGlzLl9wYXlsb2FkO1xuICB9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgSUQzO1xuXG4iLCIvKipcbiAqIE1QNCBkZW11eGVyXG4gKi9cbi8vaW1wb3J0IHtsb2dnZXJ9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XG5pbXBvcnQgRXZlbnQgZnJvbSAnLi4vZXZlbnRzJztcblxuXG4gY2xhc3MgTVA0RGVtdXhlciB7XG5cbiAgY29uc3RydWN0b3Iob2JzZXJ2ZXIsIHJlbXV4ZXIpIHtcbiAgICB0aGlzLm9ic2VydmVyID0gb2JzZXJ2ZXI7XG4gICAgdGhpcy5yZW11eGVyID0gcmVtdXhlcjtcbiAgfVxuXG4gIHJlc2V0VGltZVN0YW1wKCkge1xuXG4gIH1cblxuICByZXNldEluaXRTZWdtZW50KGluaXRTZWdtZW50LGF1ZGlvQ29kZWMsdmlkZW9Db2RlYywgZHVyYXRpb24pIHtcbiAgICAvL2pzaGludCB1bnVzZWQ6ZmFsc2VcbiAgICBjb25zdCBpbml0RGF0YSA9IHRoaXMuaW5pdERhdGEgPSBNUDREZW11eGVyLnBhcnNlSW5pdFNlZ21lbnQoaW5pdFNlZ21lbnQpO1xuICAgIHZhciB0cmFja3MgPSB7fTtcbiAgICBpZiAoaW5pdERhdGEuYXVkaW8pIHtcbiAgICAgIHRyYWNrcy5hdWRpbyA9IHsgY29udGFpbmVyIDogJ2F1ZGlvL21wNCcsIGNvZGVjIDogYXVkaW9Db2RlYywgaW5pdFNlZ21lbnQgOiBpbml0U2VnbWVudH07XG4gICAgfVxuICAgIGlmIChpbml0RGF0YS52aWRlbykge1xuICAgICAgdHJhY2tzLnZpZGVvID0geyBjb250YWluZXIgOiAndmlkZW8vbXA0JywgY29kZWMgOiB2aWRlb0NvZGVjLCBpbml0U2VnbWVudCA6IGluaXRTZWdtZW50fTtcbiAgICB9XG4gICAgdGhpcy5vYnNlcnZlci50cmlnZ2VyKEV2ZW50LkZSQUdfUEFSU0lOR19JTklUX1NFR01FTlQseyB0cmFja3MgOiB0cmFja3MgfSk7XG4gIH1cblxuICBzdGF0aWMgcHJvYmUoZGF0YSkge1xuICAgIGlmIChkYXRhLmxlbmd0aCA+PSA4KSB7XG4gICAgICBjb25zdCBkYXRhVHlwZSA9IE1QNERlbXV4ZXIuYmluMnN0cihkYXRhLnN1YmFycmF5KDQsOCkpO1xuICAgICAgcmV0dXJuIChbJ21vb2YnLCdmdHlwJywnc3R5cCddLmluZGV4T2YoZGF0YVR5cGUpID49IDApO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuXG4gIHN0YXRpYyBiaW4yc3RyKGJ1ZmZlcikge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGJ1ZmZlcik7XG4gIH1cblxuICAvLyBGaW5kIHRoZSBkYXRhIGZvciBhIGJveCBzcGVjaWZpZWQgYnkgaXRzIHBhdGhcbiAgc3RhdGljIGZpbmRCb3goZGF0YSwgcGF0aCkge1xuICAgIHZhciByZXN1bHRzID0gW10sXG4gICAgICAgIGksIHNpemUsIHR5cGUsIGVuZCwgc3VicmVzdWx0cztcblxuICAgIGlmICghcGF0aC5sZW5ndGgpIHtcbiAgICAgIC8vIHNob3J0LWNpcmN1aXQgdGhlIHNlYXJjaCBmb3IgZW1wdHkgcGF0aHNcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCBkYXRhLmJ5dGVMZW5ndGg7KSB7XG4gICAgICBzaXplICA9IGRhdGFbaV0gICAgIDw8IDI0O1xuICAgICAgc2l6ZSB8PSBkYXRhW2kgKyAxXSA8PCAxNjtcbiAgICAgIHNpemUgfD0gZGF0YVtpICsgMl0gPDwgODtcbiAgICAgIHNpemUgfD0gZGF0YVtpICsgM107XG5cbiAgICAgIHR5cGUgPSBNUDREZW11eGVyLmJpbjJzdHIoZGF0YS5zdWJhcnJheShpICsgNCwgaSArIDgpKTtcblxuICAgICAgZW5kID0gc2l6ZSA+IDEgPyBpICsgc2l6ZSA6IGRhdGEuYnl0ZUxlbmd0aDtcblxuICAgICAgaWYgKHR5cGUgPT09IHBhdGhbMF0pIHtcbiAgICAgICAgaWYgKHBhdGgubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgLy8gdGhpcyBpcyB0aGUgZW5kIG9mIHRoZSBwYXRoIGFuZCB3ZSd2ZSBmb3VuZCB0aGUgYm94IHdlIHdlcmVcbiAgICAgICAgICAvLyBsb29raW5nIGZvclxuICAgICAgICAgIHJlc3VsdHMucHVzaChkYXRhLnN1YmFycmF5KGkgKyA4LCBlbmQpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyByZWN1cnNpdmVseSBzZWFyY2ggZm9yIHRoZSBuZXh0IGJveCBhbG9uZyB0aGUgcGF0aFxuICAgICAgICAgIHN1YnJlc3VsdHMgPSBNUDREZW11eGVyLmZpbmRCb3goZGF0YS5zdWJhcnJheShpICsgOCwgZW5kKSwgcGF0aC5zbGljZSgxKSk7XG4gICAgICAgICAgaWYgKHN1YnJlc3VsdHMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXN1bHRzID0gcmVzdWx0cy5jb25jYXQoc3VicmVzdWx0cyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpID0gZW5kO1xuICAgIH1cblxuICAgIC8vIHdlJ3ZlIGZpbmlzaGVkIHNlYXJjaGluZyBhbGwgb2YgZGF0YVxuICAgIHJldHVybiByZXN1bHRzO1xuICB9XG5cblxuXG4vKipcbiAqIFBhcnNlcyBhbiBNUDQgaW5pdGlhbGl6YXRpb24gc2VnbWVudCBhbmQgZXh0cmFjdHMgc3RyZWFtIHR5cGUgYW5kXG4gKiB0aW1lc2NhbGUgdmFsdWVzIGZvciBhbnkgZGVjbGFyZWQgdHJhY2tzLiBUaW1lc2NhbGUgdmFsdWVzIGluZGljYXRlIHRoZVxuICogbnVtYmVyIG9mIGNsb2NrIHRpY2tzIHBlciBzZWNvbmQgdG8gYXNzdW1lIGZvciB0aW1lLWJhc2VkIHZhbHVlc1xuICogZWxzZXdoZXJlIGluIHRoZSBNUDQuXG4gKlxuICogVG8gZGV0ZXJtaW5lIHRoZSBzdGFydCB0aW1lIG9mIGFuIE1QNCwgeW91IG5lZWQgdHdvIHBpZWNlcyBvZlxuICogaW5mb3JtYXRpb246IHRoZSB0aW1lc2NhbGUgdW5pdCBhbmQgdGhlIGVhcmxpZXN0IGJhc2UgbWVkaWEgZGVjb2RlXG4gKiB0aW1lLiBNdWx0aXBsZSB0aW1lc2NhbGVzIGNhbiBiZSBzcGVjaWZpZWQgd2l0aGluIGFuIE1QNCBidXQgdGhlXG4gKiBiYXNlIG1lZGlhIGRlY29kZSB0aW1lIGlzIGFsd2F5cyBleHByZXNzZWQgaW4gdGhlIHRpbWVzY2FsZSBmcm9tXG4gKiB0aGUgbWVkaWEgaGVhZGVyIGJveCBmb3IgdGhlIHRyYWNrOlxuICogYGBgXG4gKiBtb292ID4gdHJhayA+IG1kaWEgPiBtZGhkLnRpbWVzY2FsZVxuICogbW9vdiA+IHRyYWsgPiBtZGlhID4gaGRsclxuICogYGBgXG4gKiBAcGFyYW0gaW5pdCB7VWludDhBcnJheX0gdGhlIGJ5dGVzIG9mIHRoZSBpbml0IHNlZ21lbnRcbiAqIEByZXR1cm4ge29iamVjdH0gYSBoYXNoIG9mIHRyYWNrIHR5cGUgdG8gdGltZXNjYWxlIHZhbHVlcyBvciBudWxsIGlmXG4gKiB0aGUgaW5pdCBzZWdtZW50IGlzIG1hbGZvcm1lZC5cbiAqL1xuICBzdGF0aWMgcGFyc2VJbml0U2VnbWVudChpbml0U2VnbWVudCkge1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICB2YXIgdHJha3MgPSBNUDREZW11eGVyLmZpbmRCb3goaW5pdFNlZ21lbnQsIFsnbW9vdicsICd0cmFrJ10pO1xuXG4gICAgdHJha3MuZm9yRWFjaCh0cmFrID0+IHtcbiAgICAgIGNvbnN0IHRraGQgPSBNUDREZW11eGVyLmZpbmRCb3godHJhaywgWyd0a2hkJ10pWzBdO1xuICAgICAgaWYgKHRraGQpIHtcbiAgICAgICAgbGV0IHZlcnNpb24gPSB0a2hkWzBdO1xuICAgICAgICBsZXQgaW5kZXggPSB2ZXJzaW9uID09PSAwID8gMTIgOiAyMDtcbiAgICAgICAgbGV0IHRyYWNrSWQgPSB0a2hkW2luZGV4XSAgICAgPDwgMjQgfFxuICAgICAgICAgICAgICAgICAgICAgIHRraGRbaW5kZXggKyAxXSA8PCAxNiB8XG4gICAgICAgICAgICAgICAgICAgICAgdGtoZFtpbmRleCArIDJdIDw8ICA4IHxcbiAgICAgICAgICAgICAgICAgICAgICB0a2hkW2luZGV4ICsgM107XG5cbiAgICAgICAgdHJhY2tJZCA9IHRyYWNrSWQgPCAwID8gNDI5NDk2NzI5NiArIHRyYWNrSWQgOiB0cmFja0lkO1xuXG4gICAgICAgIGNvbnN0IG1kaGQgPSBNUDREZW11eGVyLmZpbmRCb3godHJhaywgWydtZGlhJywgJ21kaGQnXSlbMF07XG4gICAgICAgIGlmIChtZGhkKSB7XG4gICAgICAgICAgdmVyc2lvbiA9IG1kaGRbMF07XG4gICAgICAgICAgaW5kZXggPSB2ZXJzaW9uID09PSAwID8gMTIgOiAyMDtcbiAgICAgICAgICBjb25zdCB0aW1lc2NhbGUgPSBtZGhkW2luZGV4XSAgICAgPDwgMjQgfFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1kaGRbaW5kZXggKyAxXSA8PCAxNiB8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWRoZFtpbmRleCArIDJdIDw8ICA4IHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZGhkW2luZGV4ICsgM107XG5cbiAgICAgICAgICBjb25zdCBoZGxyID0gTVA0RGVtdXhlci5maW5kQm94KHRyYWssIFsnbWRpYScsICdoZGxyJ10pWzBdO1xuICAgICAgICAgIGlmIChoZGxyKSB7XG4gICAgICAgICAgICBjb25zdCBoZGxyVHlwZSA9IE1QNERlbXV4ZXIuYmluMnN0cihoZGxyLnN1YmFycmF5KDgsIDEyKSk7XG4gICAgICAgICAgICBsZXQgdHlwZSA9IHsgJ3NvdW4nIDogJ2F1ZGlvJywgJ3ZpZGUnIDogJ3ZpZGVvJ31baGRsclR5cGVdO1xuICAgICAgICAgICAgaWYgKHR5cGUpIHtcbiAgICAgICAgICAgICAgcmVzdWx0W3RyYWNrSWRdID0geyB0aW1lc2NhbGUgOiB0aW1lc2NhbGUgLCB0eXBlIDogdHlwZX07XG4gICAgICAgICAgICAgIHJlc3VsdFt0eXBlXSA9IHsgdGltZXNjYWxlIDogdGltZXNjYWxlICwgaWQgOiB0cmFja0lkfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cblxuLyoqXG4gKiBEZXRlcm1pbmUgdGhlIGJhc2UgbWVkaWEgZGVjb2RlIHN0YXJ0IHRpbWUsIGluIHNlY29uZHMsIGZvciBhbiBNUDRcbiAqIGZyYWdtZW50LiBJZiBtdWx0aXBsZSBmcmFnbWVudHMgYXJlIHNwZWNpZmllZCwgdGhlIGVhcmxpZXN0IHRpbWUgaXNcbiAqIHJldHVybmVkLlxuICpcbiAqIFRoZSBiYXNlIG1lZGlhIGRlY29kZSB0aW1lIGNhbiBiZSBwYXJzZWQgZnJvbSB0cmFjayBmcmFnbWVudFxuICogbWV0YWRhdGE6XG4gKiBgYGBcbiAqIG1vb2YgPiB0cmFmID4gdGZkdC5iYXNlTWVkaWFEZWNvZGVUaW1lXG4gKiBgYGBcbiAqIEl0IHJlcXVpcmVzIHRoZSB0aW1lc2NhbGUgdmFsdWUgZnJvbSB0aGUgbWRoZCB0byBpbnRlcnByZXQuXG4gKlxuICogQHBhcmFtIHRpbWVzY2FsZSB7b2JqZWN0fSBhIGhhc2ggb2YgdHJhY2sgaWRzIHRvIHRpbWVzY2FsZSB2YWx1ZXMuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IHRoZSBlYXJsaWVzdCBiYXNlIG1lZGlhIGRlY29kZSBzdGFydCB0aW1lIGZvciB0aGVcbiAqIGZyYWdtZW50LCBpbiBzZWNvbmRzXG4gKi9cbnN0YXRpYyBzdGFydERUUyhpbml0RGF0YSwgZnJhZ21lbnQpIHtcbiAgdmFyIHRyYWZzLCBiYXNlVGltZXMsIHJlc3VsdDtcblxuICAvLyB3ZSBuZWVkIGluZm8gZnJvbSB0d28gY2hpbGRyZW5kIG9mIGVhY2ggdHJhY2sgZnJhZ21lbnQgYm94XG4gIHRyYWZzID0gTVA0RGVtdXhlci5maW5kQm94KGZyYWdtZW50LCBbJ21vb2YnLCAndHJhZiddKTtcblxuICAvLyBkZXRlcm1pbmUgdGhlIHN0YXJ0IHRpbWVzIGZvciBlYWNoIHRyYWNrXG4gIGJhc2VUaW1lcyA9IFtdLmNvbmNhdC5hcHBseShbXSwgdHJhZnMubWFwKGZ1bmN0aW9uKHRyYWYpIHtcbiAgICByZXR1cm4gTVA0RGVtdXhlci5maW5kQm94KHRyYWYsIFsndGZoZCddKS5tYXAoZnVuY3Rpb24odGZoZCkge1xuICAgICAgdmFyIGlkLCBzY2FsZSwgYmFzZVRpbWU7XG5cbiAgICAgIC8vIGdldCB0aGUgdHJhY2sgaWQgZnJvbSB0aGUgdGZoZFxuICAgICAgaWQgPSB0ZmhkWzRdIDw8IDI0IHxcbiAgICAgICAgICAgdGZoZFs1XSA8PCAxNiB8XG4gICAgICAgICAgIHRmaGRbNl0gPDwgOCB8XG4gICAgICAgICAgIHRmaGRbN107XG4gICAgICAvLyBhc3N1bWUgYSA5MGtIeiBjbG9jayBpZiBubyB0aW1lc2NhbGUgd2FzIHNwZWNpZmllZFxuICAgICAgc2NhbGUgPSBpbml0RGF0YVtpZF0udGltZXNjYWxlIHx8IDkwZTM7XG5cbiAgICAgIC8vIGdldCB0aGUgYmFzZSBtZWRpYSBkZWNvZGUgdGltZSBmcm9tIHRoZSB0ZmR0XG4gICAgICBiYXNlVGltZSA9IE1QNERlbXV4ZXIuZmluZEJveCh0cmFmLCBbJ3RmZHQnXSkubWFwKGZ1bmN0aW9uKHRmZHQpIHtcbiAgICAgICAgdmFyIHZlcnNpb24sIHJlc3VsdDtcblxuICAgICAgICB2ZXJzaW9uID0gdGZkdFswXTtcbiAgICAgICAgcmVzdWx0ID0gdGZkdFs0XSA8PCAyNCB8XG4gICAgICAgICAgICAgICAgIHRmZHRbNV0gPDwgMTYgfFxuICAgICAgICAgICAgICAgICB0ZmR0WzZdIDw8ICA4IHxcbiAgICAgICAgICAgICAgICAgdGZkdFs3XTtcbiAgICAgICAgaWYgKHZlcnNpb24gPT09ICAxKSB7XG4gICAgICAgICAgcmVzdWx0ICo9IE1hdGgucG93KDIsIDMyKTtcbiAgICAgICAgICByZXN1bHQgKz0gdGZkdFs4XSAgPDwgMjQgfFxuICAgICAgICAgICAgICAgICAgICB0ZmR0WzldICA8PCAxNiB8XG4gICAgICAgICAgICAgICAgICAgIHRmZHRbMTBdIDw8ICA4IHxcbiAgICAgICAgICAgICAgICAgICAgdGZkdFsxMV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0pWzBdO1xuICAgICAgYmFzZVRpbWUgPSBiYXNlVGltZSB8fCBJbmZpbml0eTtcblxuICAgICAgLy8gY29udmVydCBiYXNlIHRpbWUgdG8gc2Vjb25kc1xuICAgICAgcmV0dXJuIGJhc2VUaW1lIC8gc2NhbGU7XG4gICAgfSk7XG4gIH0pKTtcblxuICAvLyByZXR1cm4gdGhlIG1pbmltdW1cbiAgcmVzdWx0ID0gTWF0aC5taW4uYXBwbHkobnVsbCwgYmFzZVRpbWVzKTtcbiAgcmV0dXJuIGlzRmluaXRlKHJlc3VsdCkgPyByZXN1bHQgOiAwO1xufVxuXG4gIC8vIGZlZWQgaW5jb21pbmcgZGF0YSB0byB0aGUgZnJvbnQgb2YgdGhlIHBhcnNpbmcgcGlwZWxpbmVcbiAgYXBwZW5kKGRhdGEsIHRpbWVPZmZzZXQsY29udGlndW91cyxhY2N1cmF0ZVRpbWVPZmZzZXQpIHtcbiAgICBjb25zdCBpbml0RGF0YSA9IHRoaXMuaW5pdERhdGE7XG4gICAgY29uc3Qgc3RhcnREVFMgPSBNUDREZW11eGVyLnN0YXJ0RFRTKGluaXREYXRhLGRhdGEpO1xuICAgIHRoaXMucmVtdXhlci5yZW11eChpbml0RGF0YS5hdWRpbywgaW5pdERhdGEudmlkZW8sIG51bGwsIG51bGwsIHN0YXJ0RFRTLCBjb250aWd1b3VzLGFjY3VyYXRlVGltZU9mZnNldCxkYXRhKTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gIH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBNUDREZW11eGVyO1xuIiwiLyoqXG4gKiBTQU1QTEUtQUVTIGRlY3J5cHRlclxuKi9cblxuIGltcG9ydCBEZWNyeXB0ZXIgZnJvbSAnLi4vY3J5cHQvZGVjcnlwdGVyJztcblxuIGNsYXNzIFNhbXBsZUFlc0RlY3J5cHRlciB7XG5cbiAgY29uc3RydWN0b3Iob2JzZXJ2ZXIsIGNvbmZpZywgZGVjcnlwdGRhdGEsIGRpc2NhcmRFUEIpIHtcbiAgICB0aGlzLmRlY3J5cHRkYXRhID0gZGVjcnlwdGRhdGE7XG4gICAgdGhpcy5kaXNjYXJkRVBCID0gZGlzY2FyZEVQQjtcbiAgICB0aGlzLmRlY3J5cHRlciA9IG5ldyBEZWNyeXB0ZXIob2JzZXJ2ZXIsIGNvbmZpZyk7XG4gIH1cblxuICBkZWNyeXB0QnVmZmVyKGVuY3J5cHRlZERhdGEsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5kZWNyeXB0ZXIuZGVjcnlwdChlbmNyeXB0ZWREYXRhLCB0aGlzLmRlY3J5cHRkYXRhLmtleS5idWZmZXIsIHRoaXMuZGVjcnlwdGRhdGEuaXYuYnVmZmVyLCBjYWxsYmFjayk7XG4gIH1cblxuICAvLyBBQUMgLSBlbmNyeXB0IGFsbCBmdWxsIDE2IGJ5dGVzIGJsb2NrcyBzdGFydGluZyBmcm9tIG9mZnNldCAxNlxuICBkZWNyeXB0QWFjU2FtcGxlKHNhbXBsZXMsIHNhbXBsZUluZGV4LCBjYWxsYmFjaywgc3luYykge1xuICAgIGxldCBjdXJVbml0ID0gc2FtcGxlc1tzYW1wbGVJbmRleF0udW5pdDtcbiAgICBsZXQgZW5jcnlwdGVkRGF0YSA9IGN1clVuaXQuc3ViYXJyYXkoMTYsIGN1clVuaXQubGVuZ3RoIC0gY3VyVW5pdC5sZW5ndGggJSAxNik7XG4gICAgbGV0IGVuY3J5cHRlZEJ1ZmZlciA9IGVuY3J5cHRlZERhdGEuYnVmZmVyLnNsaWNlKFxuICAgICAgIGVuY3J5cHRlZERhdGEuYnl0ZU9mZnNldCxcbiAgICAgICBlbmNyeXB0ZWREYXRhLmJ5dGVPZmZzZXQgKyBlbmNyeXB0ZWREYXRhLmxlbmd0aCk7XG5cbiAgICBsZXQgbG9jYWx0aGlzID0gdGhpcztcbiAgICB0aGlzLmRlY3J5cHRCdWZmZXIoZW5jcnlwdGVkQnVmZmVyLCBmdW5jdGlvbiAoZGVjcnlwdGVkRGF0YSkge1xuICAgICAgZGVjcnlwdGVkRGF0YSA9IG5ldyBVaW50OEFycmF5KGRlY3J5cHRlZERhdGEpO1xuICAgICAgY3VyVW5pdC5zZXQoZGVjcnlwdGVkRGF0YSwgMTYpO1xuXG4gICAgICBpZiAoIXN5bmMpIHtcbiAgICAgICAgbG9jYWx0aGlzLmRlY3J5cHRBYWNTYW1wbGVzKHNhbXBsZXMsIHNhbXBsZUluZGV4ICsgMSwgY2FsbGJhY2spO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZGVjcnlwdEFhY1NhbXBsZXMoc2FtcGxlcywgc2FtcGxlSW5kZXgsIGNhbGxiYWNrKSB7XG4gICAgZm9yICg7OyBzYW1wbGVJbmRleCsrKSB7XG4gICAgICBpZiAoc2FtcGxlSW5kZXggPj0gc2FtcGxlcy5sZW5ndGgpIHtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2FtcGxlc1tzYW1wbGVJbmRleF0udW5pdC5sZW5ndGggPCAzMikge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgbGV0IHN5bmMgPSB0aGlzLmRlY3J5cHRlci5pc1N5bmMoKTtcblxuICAgICAgdGhpcy5kZWNyeXB0QWFjU2FtcGxlKHNhbXBsZXMsIHNhbXBsZUluZGV4LCBjYWxsYmFjaywgc3luYyk7XG5cbiAgICAgIGlmICghc3luYykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gQVZDIC0gZW5jcnlwdCBvbmUgMTYgYnl0ZXMgYmxvY2sgb3V0IG9mIHRlbiwgc3RhcnRpbmcgZnJvbSBvZmZzZXQgMzJcbiAgZ2V0QXZjRW5jcnlwdGVkRGF0YShkZWNvZGVkRGF0YSkge1xuICAgIGxldCBlbmNyeXB0ZWREYXRhTGVuID0gTWF0aC5mbG9vcigoZGVjb2RlZERhdGEubGVuZ3RoIC0gNDgpIC8gMTYwKSAqIDE2ICsgMTY7XG4gICAgbGV0IGVuY3J5cHRlZERhdGEgPSBuZXcgSW50OEFycmF5KGVuY3J5cHRlZERhdGFMZW4pO1xuICAgIGxldCBvdXRwdXRQb3MgPSAwO1xuICAgIGZvciAobGV0IGlucHV0UG9zID0gMzI7IGlucHV0UG9zIDw9IGRlY29kZWREYXRhLmxlbmd0aCAtIDE2OyBpbnB1dFBvcyArPSAxNjAsIG91dHB1dFBvcyArPSAxNikge1xuICAgICAgZW5jcnlwdGVkRGF0YS5zZXQoZGVjb2RlZERhdGEuc3ViYXJyYXkoaW5wdXRQb3MsIGlucHV0UG9zICsgMTYpLCBvdXRwdXRQb3MpO1xuICAgIH1cbiAgICByZXR1cm4gZW5jcnlwdGVkRGF0YTtcbiAgfVxuXG4gIGdldEF2Y0RlY3J5cHRlZFVuaXQoZGVjb2RlZERhdGEsIGRlY3J5cHRlZERhdGEpIHtcbiAgICBkZWNyeXB0ZWREYXRhID0gbmV3IFVpbnQ4QXJyYXkoZGVjcnlwdGVkRGF0YSk7XG4gICAgbGV0IGlucHV0UG9zID0gMDtcbiAgICBmb3IgKGxldCBvdXRwdXRQb3MgPSAzMjsgb3V0cHV0UG9zIDw9IGRlY29kZWREYXRhLmxlbmd0aCAtIDE2OyBvdXRwdXRQb3MgKz0gMTYwLCBpbnB1dFBvcyArPSAxNikge1xuICAgICAgZGVjb2RlZERhdGEuc2V0KGRlY3J5cHRlZERhdGEuc3ViYXJyYXkoaW5wdXRQb3MsIGlucHV0UG9zICsgMTYpLCBvdXRwdXRQb3MpO1xuICAgIH1cbiAgICByZXR1cm4gZGVjb2RlZERhdGE7XG4gIH1cblxuICBkZWNyeXB0QXZjU2FtcGxlKHNhbXBsZXMsIHNhbXBsZUluZGV4LCB1bml0SW5kZXgsIGNhbGxiYWNrLCBjdXJVbml0LCBzeW5jKSB7XG4gICAgbGV0IGRlY29kZWREYXRhID0gdGhpcy5kaXNjYXJkRVBCKGN1clVuaXQuZGF0YSk7XG4gICAgbGV0IGVuY3J5cHRlZERhdGEgPSB0aGlzLmdldEF2Y0VuY3J5cHRlZERhdGEoZGVjb2RlZERhdGEpO1xuICAgIGxldCBsb2NhbHRoaXMgPSB0aGlzO1xuXG4gICAgdGhpcy5kZWNyeXB0QnVmZmVyKGVuY3J5cHRlZERhdGEuYnVmZmVyLCBmdW5jdGlvbiAoZGVjcnlwdGVkRGF0YSkge1xuICAgICAgY3VyVW5pdC5kYXRhID0gbG9jYWx0aGlzLmdldEF2Y0RlY3J5cHRlZFVuaXQoZGVjb2RlZERhdGEsIGRlY3J5cHRlZERhdGEpO1xuXG4gICAgICBpZiAoIXN5bmMpIHtcbiAgICAgICAgbG9jYWx0aGlzLmRlY3J5cHRBdmNTYW1wbGVzKHNhbXBsZXMsIHNhbXBsZUluZGV4LCB1bml0SW5kZXggKyAxLCBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBkZWNyeXB0QXZjU2FtcGxlcyhzYW1wbGVzLCBzYW1wbGVJbmRleCwgdW5pdEluZGV4LCBjYWxsYmFjaykge1xuICAgIGZvciAoOzsgc2FtcGxlSW5kZXgrKywgdW5pdEluZGV4ID0gMCkge1xuICAgICAgaWYgKHNhbXBsZUluZGV4ID49IHNhbXBsZXMubGVuZ3RoKSB7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgbGV0IGN1clVuaXRzID0gc2FtcGxlc1tzYW1wbGVJbmRleF0udW5pdHM7XG4gICAgICBmb3IgKDs7IHVuaXRJbmRleCsrKSB7XG4gICAgICAgIGlmICh1bml0SW5kZXggPj0gY3VyVW5pdHMubGVuZ3RoKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgY3VyVW5pdCA9IGN1clVuaXRzW3VuaXRJbmRleF07XG4gICAgICAgIGlmIChjdXJVbml0Lmxlbmd0aCA8PSA0OCB8fCAoY3VyVW5pdC50eXBlICE9PSAxICYmIGN1clVuaXQudHlwZSAhPT0gNSkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBzeW5jID0gdGhpcy5kZWNyeXB0ZXIuaXNTeW5jKCk7XG5cbiAgICAgICAgdGhpcy5kZWNyeXB0QXZjU2FtcGxlKHNhbXBsZXMsIHNhbXBsZUluZGV4LCB1bml0SW5kZXgsIGNhbGxiYWNrLCBjdXJVbml0LCBzeW5jKTtcblxuICAgICAgICBpZiAoIXN5bmMpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiB9XG5cbiBleHBvcnQgZGVmYXVsdCBTYW1wbGVBZXNEZWNyeXB0ZXI7XG4iLCIvKipcbiAqIGhpZ2hseSBvcHRpbWl6ZWQgVFMgZGVtdXhlcjpcbiAqIHBhcnNlIFBBVCwgUE1UXG4gKiBleHRyYWN0IFBFUyBwYWNrZXQgZnJvbSBhdWRpbyBhbmQgdmlkZW8gUElEc1xuICogZXh0cmFjdCBBVkMvSDI2NCBOQUwgdW5pdHMgYW5kIEFBQy9BRFRTIHNhbXBsZXMgZnJvbSBQRVMgcGFja2V0XG4gKiB0cmlnZ2VyIHRoZSByZW11eGVyIHVwb24gcGFyc2luZyBjb21wbGV0aW9uXG4gKiBpdCBhbHNvIHRyaWVzIHRvIHdvcmthcm91bmQgYXMgYmVzdCBhcyBpdCBjYW4gYXVkaW8gY29kZWMgc3dpdGNoIChIRS1BQUMgdG8gQUFDIGFuZCB2aWNlIHZlcnNhKSwgd2l0aG91dCBoYXZpbmcgdG8gcmVzdGFydCB0aGUgTWVkaWFTb3VyY2UuXG4gKiBpdCBhbHNvIGNvbnRyb2xzIHRoZSByZW11eGluZyBwcm9jZXNzIDpcbiAqIHVwb24gZGlzY29udGludWl0eSBvciBsZXZlbCBzd2l0Y2ggZGV0ZWN0aW9uLCBpdCB3aWxsIGFsc28gbm90aWZpZXMgdGhlIHJlbXV4ZXIgc28gdGhhdCBpdCBjYW4gcmVzZXQgaXRzIHN0YXRlLlxuKi9cblxuIGltcG9ydCBBRFRTIGZyb20gJy4vYWR0cyc7XG4gaW1wb3J0IEV2ZW50IGZyb20gJy4uL2V2ZW50cyc7XG4gaW1wb3J0IEV4cEdvbG9tYiBmcm9tICcuL2V4cC1nb2xvbWInO1xuIGltcG9ydCBTYW1wbGVBZXNEZWNyeXB0ZXIgZnJvbSAnLi9zYW1wbGUtYWVzJztcbi8vIGltcG9ydCBIZXggZnJvbSAnLi4vdXRpbHMvaGV4JztcbiBpbXBvcnQge2xvZ2dlcn0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcbiBpbXBvcnQge0Vycm9yVHlwZXMsIEVycm9yRGV0YWlsc30gZnJvbSAnLi4vZXJyb3JzJztcblxuIGNsYXNzIFRTRGVtdXhlciB7XG5cbiAgY29uc3RydWN0b3Iob2JzZXJ2ZXIsIHJlbXV4ZXIsIGNvbmZpZywgdHlwZVN1cHBvcnRlZCkge1xuICAgIHRoaXMub2JzZXJ2ZXIgPSBvYnNlcnZlcjtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICB0aGlzLnR5cGVTdXBwb3J0ZWQgPSB0eXBlU3VwcG9ydGVkO1xuICAgIHRoaXMucmVtdXhlciA9IHJlbXV4ZXI7XG4gICAgdGhpcy5zYW1wbGVBZXMgPSBudWxsO1xuICB9XG5cbiAgc2V0RGVjcnlwdERhdGEoZGVjcnlwdGRhdGEpIHtcbiAgICBpZiAoKGRlY3J5cHRkYXRhICE9IG51bGwpICYmIChkZWNyeXB0ZGF0YS5rZXkgIT0gbnVsbCkgJiYgKGRlY3J5cHRkYXRhLm1ldGhvZCA9PT0gJ1NBTVBMRS1BRVMnKSkge1xuICAgICAgdGhpcy5zYW1wbGVBZXMgPSBuZXcgU2FtcGxlQWVzRGVjcnlwdGVyKHRoaXMub2JzZXJ2ZXIsIHRoaXMuY29uZmlnLCBkZWNyeXB0ZGF0YSwgdGhpcy5kaXNjYXJkRVBCKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zYW1wbGVBZXMgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBwcm9iZShkYXRhKSB7XG4gICAgLy8gYSBUUyBmcmFnbWVudCBzaG91bGQgY29udGFpbiBhdCBsZWFzdCAzIFRTIHBhY2tldHMsIGEgUEFULCBhIFBNVCwgYW5kIG9uZSBQSUQsIGVhY2ggc3RhcnRpbmcgd2l0aCAweDQ3XG4gICAgaWYgKGRhdGEubGVuZ3RoID49IDMqMTg4ICYmIGRhdGFbMF0gPT09IDB4NDcgJiYgZGF0YVsxODhdID09PSAweDQ3ICYmIGRhdGFbMioxODhdID09PSAweDQ3KSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJlc2V0SW5pdFNlZ21lbnQoaW5pdFNlZ21lbnQsYXVkaW9Db2RlYyx2aWRlb0NvZGVjLCBkdXJhdGlvbikge1xuICAgIHRoaXMucG10UGFyc2VkID0gZmFsc2U7XG4gICAgdGhpcy5fcG10SWQgPSAtMTtcbiAgICB0aGlzLl9hdmNUcmFjayA9IHtjb250YWluZXIgOiAndmlkZW8vbXAydCcsIHR5cGU6ICd2aWRlbycsIGlkIDotMSwgaW5wdXRUaW1lU2NhbGUgOiA5MDAwMCwgc2VxdWVuY2VOdW1iZXI6IDAsIHNhbXBsZXMgOiBbXSwgbGVuIDogMCwgZHJvcHBlZCA6IDB9O1xuICAgIHRoaXMuX2F1ZGlvVHJhY2sgPSB7Y29udGFpbmVyIDogJ3ZpZGVvL21wMnQnLCB0eXBlOiAnYXVkaW8nLCBpZCA6LTEsIGlucHV0VGltZVNjYWxlIDogOTAwMDAsIHNlcXVlbmNlTnVtYmVyOiAwLCBzYW1wbGVzIDogW10sIGxlbiA6IDAsIGlzQUFDOiB0cnVlfTtcbiAgICB0aGlzLl9pZDNUcmFjayA9IHt0eXBlOiAnaWQzJywgaWQgOi0xLCBpbnB1dFRpbWVTY2FsZSA6IDkwMDAwLCBzZXF1ZW5jZU51bWJlcjogMCwgc2FtcGxlcyA6IFtdLCBsZW4gOiAwfTtcbiAgICB0aGlzLl90eHRUcmFjayA9IHt0eXBlOiAndGV4dCcsIGlkOiAtMSwgaW5wdXRUaW1lU2NhbGUgOiA5MDAwMCwgc2VxdWVuY2VOdW1iZXI6IDAsIHNhbXBsZXMgOiBbXSwgbGVuIDogMH07XG4gICAgLy8gZmx1c2ggYW55IHBhcnRpYWwgY29udGVudFxuICAgIHRoaXMuYWFjT3ZlckZsb3cgPSBudWxsO1xuICAgIHRoaXMuYWFjTGFzdFBUUyA9IG51bGw7XG4gICAgdGhpcy5hdmNTYW1wbGUgPSBudWxsO1xuICAgIHRoaXMuYXVkaW9Db2RlYyA9IGF1ZGlvQ29kZWM7XG4gICAgdGhpcy52aWRlb0NvZGVjID0gdmlkZW9Db2RlYztcbiAgICB0aGlzLl9kdXJhdGlvbiA9IGR1cmF0aW9uO1xuICB9XG5cbiAgcmVzZXRUaW1lU3RhbXAoKSB7XG4gIH1cblxuICAvLyBmZWVkIGluY29taW5nIGRhdGEgdG8gdGhlIGZyb250IG9mIHRoZSBwYXJzaW5nIHBpcGVsaW5lXG4gIGFwcGVuZChkYXRhLCB0aW1lT2Zmc2V0LCBjb250aWd1b3VzLGFjY3VyYXRlVGltZU9mZnNldCkge1xuICAgIHZhciBzdGFydCwgbGVuID0gZGF0YS5sZW5ndGgsIHN0dCwgcGlkLCBhdGYsIG9mZnNldCxwZXMsXG4gICAgICAgIHVua25vd25QSURzID0gZmFsc2U7XG4gICAgdGhpcy5jb250aWd1b3VzID0gY29udGlndW91cztcbiAgICB2YXIgcG10UGFyc2VkID0gdGhpcy5wbXRQYXJzZWQsXG4gICAgICAgIGF2Y1RyYWNrID0gdGhpcy5fYXZjVHJhY2ssXG4gICAgICAgIGF1ZGlvVHJhY2sgPSB0aGlzLl9hdWRpb1RyYWNrLFxuICAgICAgICBpZDNUcmFjayA9IHRoaXMuX2lkM1RyYWNrLFxuICAgICAgICBhdmNJZCA9IGF2Y1RyYWNrLmlkLFxuICAgICAgICBhdWRpb0lkID0gYXVkaW9UcmFjay5pZCxcbiAgICAgICAgaWQzSWQgPSBpZDNUcmFjay5pZCxcbiAgICAgICAgcG10SWQgPSB0aGlzLl9wbXRJZCxcbiAgICAgICAgYXZjRGF0YSA9IGF2Y1RyYWNrLnBlc0RhdGEsXG4gICAgICAgIGF1ZGlvRGF0YSA9IGF1ZGlvVHJhY2sucGVzRGF0YSxcbiAgICAgICAgaWQzRGF0YSA9IGlkM1RyYWNrLnBlc0RhdGEsXG4gICAgICAgIHBhcnNlUEFUID0gdGhpcy5fcGFyc2VQQVQsXG4gICAgICAgIHBhcnNlUE1UID0gdGhpcy5fcGFyc2VQTVQsXG4gICAgICAgIHBhcnNlUEVTID0gdGhpcy5fcGFyc2VQRVMsXG4gICAgICAgIHBhcnNlQVZDUEVTID0gdGhpcy5fcGFyc2VBVkNQRVMuYmluZCh0aGlzKSxcbiAgICAgICAgcGFyc2VBQUNQRVMgPSB0aGlzLl9wYXJzZUFBQ1BFUy5iaW5kKHRoaXMpLFxuICAgICAgICBwYXJzZU1QRUdQRVMgPSB0aGlzLl9wYXJzZU1QRUdQRVMuYmluZCh0aGlzKSxcbiAgICAgICAgcGFyc2VJRDNQRVMgID0gdGhpcy5fcGFyc2VJRDNQRVMuYmluZCh0aGlzKTtcblxuICAgIC8vIGRvbid0IHBhcnNlIGxhc3QgVFMgcGFja2V0IGlmIGluY29tcGxldGVcbiAgICBsZW4gLT0gbGVuICUgMTg4O1xuICAgIC8vIGxvb3AgdGhyb3VnaCBUUyBwYWNrZXRzXG4gICAgZm9yIChzdGFydCA9IDA7IHN0YXJ0IDwgbGVuOyBzdGFydCArPSAxODgpIHtcbiAgICAgIGlmIChkYXRhW3N0YXJ0XSA9PT0gMHg0Nykge1xuICAgICAgICBzdHQgPSAhIShkYXRhW3N0YXJ0ICsgMV0gJiAweDQwKTtcbiAgICAgICAgLy8gcGlkIGlzIGEgMTMtYml0IGZpZWxkIHN0YXJ0aW5nIGF0IHRoZSBsYXN0IGJpdCBvZiBUU1sxXVxuICAgICAgICBwaWQgPSAoKGRhdGFbc3RhcnQgKyAxXSAmIDB4MWYpIDw8IDgpICsgZGF0YVtzdGFydCArIDJdO1xuICAgICAgICBhdGYgPSAoZGF0YVtzdGFydCArIDNdICYgMHgzMCkgPj4gNDtcbiAgICAgICAgLy8gaWYgYW4gYWRhcHRpb24gZmllbGQgaXMgcHJlc2VudCwgaXRzIGxlbmd0aCBpcyBzcGVjaWZpZWQgYnkgdGhlIGZpZnRoIGJ5dGUgb2YgdGhlIFRTIHBhY2tldCBoZWFkZXIuXG4gICAgICAgIGlmIChhdGYgPiAxKSB7XG4gICAgICAgICAgb2Zmc2V0ID0gc3RhcnQgKyA1ICsgZGF0YVtzdGFydCArIDRdO1xuICAgICAgICAgIC8vIGNvbnRpbnVlIGlmIHRoZXJlIGlzIG9ubHkgYWRhcHRhdGlvbiBmaWVsZFxuICAgICAgICAgIGlmIChvZmZzZXQgPT09IChzdGFydCArIDE4OCkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvZmZzZXQgPSBzdGFydCArIDQ7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoKHBpZCkge1xuICAgICAgICAgIGNhc2UgYXZjSWQ6XG4gICAgICAgICAgICBpZiAoc3R0KSB7XG4gICAgICAgICAgICAgIGlmIChhdmNEYXRhICYmIChwZXMgPSBwYXJzZVBFUyhhdmNEYXRhKSkpIHtcbiAgICAgICAgICAgICAgICBwYXJzZUFWQ1BFUyhwZXMsZmFsc2UpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGF2Y0RhdGEgPSB7ZGF0YTogW10sIHNpemU6IDB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGF2Y0RhdGEpIHtcbiAgICAgICAgICAgICAgYXZjRGF0YS5kYXRhLnB1c2goZGF0YS5zdWJhcnJheShvZmZzZXQsIHN0YXJ0ICsgMTg4KSk7XG4gICAgICAgICAgICAgIGF2Y0RhdGEuc2l6ZSArPSBzdGFydCArIDE4OCAtIG9mZnNldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgYXVkaW9JZDpcbiAgICAgICAgICAgIGlmIChzdHQpIHtcbiAgICAgICAgICAgICAgaWYgKGF1ZGlvRGF0YSAmJiAocGVzID0gcGFyc2VQRVMoYXVkaW9EYXRhKSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoYXVkaW9UcmFjay5pc0FBQykge1xuICAgICAgICAgICAgICAgICAgcGFyc2VBQUNQRVMocGVzKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcGFyc2VNUEVHUEVTKHBlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGF1ZGlvRGF0YSA9IHtkYXRhOiBbXSwgc2l6ZTogMH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYXVkaW9EYXRhKSB7XG4gICAgICAgICAgICAgIGF1ZGlvRGF0YS5kYXRhLnB1c2goZGF0YS5zdWJhcnJheShvZmZzZXQsIHN0YXJ0ICsgMTg4KSk7XG4gICAgICAgICAgICAgIGF1ZGlvRGF0YS5zaXplICs9IHN0YXJ0ICsgMTg4IC0gb2Zmc2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBpZDNJZDpcbiAgICAgICAgICAgIGlmIChzdHQpIHtcbiAgICAgICAgICAgICAgaWYgKGlkM0RhdGEgJiYgKHBlcyA9IHBhcnNlUEVTKGlkM0RhdGEpKSkge1xuICAgICAgICAgICAgICAgIHBhcnNlSUQzUEVTKHBlcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWQzRGF0YSA9IHtkYXRhOiBbXSwgc2l6ZTogMH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaWQzRGF0YSkge1xuICAgICAgICAgICAgICBpZDNEYXRhLmRhdGEucHVzaChkYXRhLnN1YmFycmF5KG9mZnNldCwgc3RhcnQgKyAxODgpKTtcbiAgICAgICAgICAgICAgaWQzRGF0YS5zaXplICs9IHN0YXJ0ICsgMTg4IC0gb2Zmc2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgaWYgKHN0dCkge1xuICAgICAgICAgICAgICBvZmZzZXQgKz0gZGF0YVtvZmZzZXRdICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBtdElkID0gdGhpcy5fcG10SWQgPSBwYXJzZVBBVChkYXRhLCBvZmZzZXQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBwbXRJZDpcbiAgICAgICAgICAgIGlmIChzdHQpIHtcbiAgICAgICAgICAgICAgb2Zmc2V0ICs9IGRhdGFbb2Zmc2V0XSArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcGFyc2VkUElEcyA9IHBhcnNlUE1UKGRhdGEsIG9mZnNldCwgdGhpcy50eXBlU3VwcG9ydGVkLm1wZWcgPT09IHRydWUgfHwgdGhpcy50eXBlU3VwcG9ydGVkLm1wMyA9PT0gdHJ1ZSwgdGhpcy5zYW1wbGVBZXMgIT0gbnVsbCk7XG5cbiAgICAgICAgICAgIC8vIG9ubHkgdXBkYXRlIHRyYWNrIGlkIGlmIHRyYWNrIFBJRCBmb3VuZCB3aGlsZSBwYXJzaW5nIFBNVFxuICAgICAgICAgICAgLy8gdGhpcyBpcyB0byBhdm9pZCByZXNldHRpbmcgdGhlIFBJRCB0byAtMSBpbiBjYXNlXG4gICAgICAgICAgICAvLyB0cmFjayBQSUQgdHJhbnNpZW50bHkgZGlzYXBwZWFycyBmcm9tIHRoZSBzdHJlYW1cbiAgICAgICAgICAgIC8vIHRoaXMgY291bGQgaGFwcGVuIGluIGNhc2Ugb2YgdHJhbnNpZW50IG1pc3NpbmcgYXVkaW8gc2FtcGxlcyBmb3IgZXhhbXBsZVxuICAgICAgICAgICAgYXZjSWQgPSBwYXJzZWRQSURzLmF2YztcbiAgICAgICAgICAgIGlmIChhdmNJZCA+IDApIHtcbiAgICAgICAgICAgICAgYXZjVHJhY2suaWQgPSBhdmNJZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF1ZGlvSWQgPSBwYXJzZWRQSURzLmF1ZGlvO1xuICAgICAgICAgICAgaWYgKGF1ZGlvSWQgPiAwKSB7XG4gICAgICAgICAgICAgIGF1ZGlvVHJhY2suaWQgPSBhdWRpb0lkO1xuICAgICAgICAgICAgICBhdWRpb1RyYWNrLmlzQUFDID0gcGFyc2VkUElEcy5pc0FBQztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlkM0lkID0gcGFyc2VkUElEcy5pZDM7XG4gICAgICAgICAgICBpZiAoaWQzSWQgPiAwKSB7XG4gICAgICAgICAgICAgIGlkM1RyYWNrLmlkID0gaWQzSWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodW5rbm93blBJRHMgJiYgIXBtdFBhcnNlZCkge1xuICAgICAgICAgICAgICBsb2dnZXIubG9nKCdyZXBhcnNlIGZyb20gYmVnaW5uaW5nJyk7XG4gICAgICAgICAgICAgIHVua25vd25QSURzID0gZmFsc2U7XG4gICAgICAgICAgICAgIC8vIHdlIHNldCBpdCB0byAtMTg4LCB0aGUgKz0gMTg4IGluIHRoZSBmb3IgbG9vcCB3aWxsIHJlc2V0IHN0YXJ0IHRvIDBcbiAgICAgICAgICAgICAgc3RhcnQgPSAtMTg4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG10UGFyc2VkID0gdGhpcy5wbXRQYXJzZWQgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAxNzpcbiAgICAgICAgICBjYXNlIDB4MWZmZjpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB1bmtub3duUElEcyA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5vYnNlcnZlci50cmlnZ2VyKEV2ZW50LkVSUk9SLCB7dHlwZSA6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsIGRldGFpbHM6IEVycm9yRGV0YWlscy5GUkFHX1BBUlNJTkdfRVJST1IsIGZhdGFsOiBmYWxzZSwgcmVhc29uOiAnVFMgcGFja2V0IGRpZCBub3Qgc3RhcnQgd2l0aCAweDQ3J30pO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyB0cnkgdG8gcGFyc2UgbGFzdCBQRVMgcGFja2V0c1xuICAgIGlmIChhdmNEYXRhICYmIChwZXMgPSBwYXJzZVBFUyhhdmNEYXRhKSkpIHtcbiAgICAgIHBhcnNlQVZDUEVTKHBlcyx0cnVlKTtcbiAgICAgIGF2Y1RyYWNrLnBlc0RhdGEgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBlaXRoZXIgYXZjRGF0YSBudWxsIG9yIFBFUyB0cnVuY2F0ZWQsIGtlZXAgaXQgZm9yIG5leHQgZnJhZyBwYXJzaW5nXG4gICAgICBhdmNUcmFjay5wZXNEYXRhID0gYXZjRGF0YTtcbiAgICB9XG5cbiAgICBpZiAoYXVkaW9EYXRhICYmIChwZXMgPSBwYXJzZVBFUyhhdWRpb0RhdGEpKSkge1xuICAgICAgaWYgKGF1ZGlvVHJhY2suaXNBQUMpIHtcbiAgICAgICAgcGFyc2VBQUNQRVMocGVzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnNlTVBFR1BFUyhwZXMpO1xuICAgICAgfVxuICAgICAgYXVkaW9UcmFjay5wZXNEYXRhID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGF1ZGlvRGF0YSAmJiBhdWRpb0RhdGEuc2l6ZSkge1xuICAgICAgICBsb2dnZXIubG9nKCdsYXN0IEFBQyBQRVMgcGFja2V0IHRydW5jYXRlZCxtaWdodCBvdmVybGFwIGJldHdlZW4gZnJhZ21lbnRzJyk7XG4gICAgICB9XG4gICAgIC8vIGVpdGhlciBhdWRpb0RhdGEgbnVsbCBvciBQRVMgdHJ1bmNhdGVkLCBrZWVwIGl0IGZvciBuZXh0IGZyYWcgcGFyc2luZ1xuICAgICAgYXVkaW9UcmFjay5wZXNEYXRhID0gYXVkaW9EYXRhO1xuICAgIH1cblxuICAgIGlmIChpZDNEYXRhICYmIChwZXMgPSBwYXJzZVBFUyhpZDNEYXRhKSkpIHtcbiAgICAgIHBhcnNlSUQzUEVTKHBlcyk7XG4gICAgICBpZDNUcmFjay5wZXNEYXRhID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZWl0aGVyIGlkM0RhdGEgbnVsbCBvciBQRVMgdHJ1bmNhdGVkLCBrZWVwIGl0IGZvciBuZXh0IGZyYWcgcGFyc2luZ1xuICAgICAgaWQzVHJhY2sucGVzRGF0YSA9IGlkM0RhdGE7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuc2FtcGxlQWVzID09IG51bGwpIHtcbiAgICAgIHRoaXMucmVtdXhlci5yZW11eChhdWRpb1RyYWNrLCBhdmNUcmFjaywgaWQzVHJhY2ssIHRoaXMuX3R4dFRyYWNrLCB0aW1lT2Zmc2V0LCBjb250aWd1b3VzLCBhY2N1cmF0ZVRpbWVPZmZzZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRlY3J5cHRBbmRSZW11eChhdWRpb1RyYWNrLCBhdmNUcmFjaywgaWQzVHJhY2ssIHRoaXMuX3R4dFRyYWNrLCB0aW1lT2Zmc2V0LCBjb250aWd1b3VzLCBhY2N1cmF0ZVRpbWVPZmZzZXQpO1xuICAgIH1cbiAgfVxuXG4gIGRlY3J5cHRBbmRSZW11eChhdWRpb1RyYWNrLCB2aWRlb1RyYWNrLCBpZDNUcmFjaywgdGV4dFRyYWNrLCB0aW1lT2Zmc2V0LCBjb250aWd1b3VzLCBhY2N1cmF0ZVRpbWVPZmZzZXQpIHtcbiAgICBpZiAoYXVkaW9UcmFjay5zYW1wbGVzICYmIGF1ZGlvVHJhY2suaXNBQUMpIHtcbiAgICAgIGxldCBsb2NhbHRoaXMgPSB0aGlzO1xuICAgICAgdGhpcy5zYW1wbGVBZXMuZGVjcnlwdEFhY1NhbXBsZXMoYXVkaW9UcmFjay5zYW1wbGVzLCAwLCBmdW5jdGlvbigpIHtcbiAgICAgICAgbG9jYWx0aGlzLmRlY3J5cHRBbmRSZW11eEF2YyhhdWRpb1RyYWNrLCB2aWRlb1RyYWNrLCBpZDNUcmFjaywgdGV4dFRyYWNrLCB0aW1lT2Zmc2V0LCBjb250aWd1b3VzLCBhY2N1cmF0ZVRpbWVPZmZzZXQpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGVjcnlwdEFuZFJlbXV4QXZjKGF1ZGlvVHJhY2ssIHZpZGVvVHJhY2ssIGlkM1RyYWNrLCB0ZXh0VHJhY2ssIHRpbWVPZmZzZXQsIGNvbnRpZ3VvdXMsIGFjY3VyYXRlVGltZU9mZnNldCk7XG4gICAgfVxuICB9XG5cbiAgZGVjcnlwdEFuZFJlbXV4QXZjKGF1ZGlvVHJhY2ssIHZpZGVvVHJhY2ssIGlkM1RyYWNrLCB0ZXh0VHJhY2ssIHRpbWVPZmZzZXQsIGNvbnRpZ3VvdXMsIGFjY3VyYXRlVGltZU9mZnNldCkge1xuICAgIGlmICh2aWRlb1RyYWNrLnNhbXBsZXMpIHtcbiAgICAgIGxldCBsb2NhbHRoaXMgPSB0aGlzO1xuICAgICAgdGhpcy5zYW1wbGVBZXMuZGVjcnlwdEF2Y1NhbXBsZXModmlkZW9UcmFjay5zYW1wbGVzLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGxvY2FsdGhpcy5yZW11eGVyLnJlbXV4KGF1ZGlvVHJhY2ssIHZpZGVvVHJhY2ssIGlkM1RyYWNrLCB0ZXh0VHJhY2ssIHRpbWVPZmZzZXQsIGNvbnRpZ3VvdXMsIGFjY3VyYXRlVGltZU9mZnNldCk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZW11eGVyLnJlbXV4KGF1ZGlvVHJhY2ssIHZpZGVvVHJhY2ssIGlkM1RyYWNrLCB0ZXh0VHJhY2ssIHRpbWVPZmZzZXQsIGNvbnRpZ3VvdXMsIGFjY3VyYXRlVGltZU9mZnNldCk7XG4gICAgfVxuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLl9pbml0UFRTID0gdGhpcy5faW5pdERUUyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9kdXJhdGlvbiA9IDA7XG4gIH1cblxuICBfcGFyc2VQQVQoZGF0YSwgb2Zmc2V0KSB7XG4gICAgLy8gc2tpcCB0aGUgUFNJIGhlYWRlciBhbmQgcGFyc2UgdGhlIGZpcnN0IFBNVCBlbnRyeVxuICAgIHJldHVybiAoZGF0YVtvZmZzZXQgKyAxMF0gJiAweDFGKSA8PCA4IHwgZGF0YVtvZmZzZXQgKyAxMV07XG4gICAgLy9sb2dnZXIubG9nKCdQTVQgUElEOicgICsgdGhpcy5fcG10SWQpO1xuICB9XG5cbiAgX3BhcnNlUE1UKGRhdGEsIG9mZnNldCwgbXBlZ1N1cHBvcnRlZCwgaXNTYW1wbGVBZXMpIHtcbiAgICB2YXIgc2VjdGlvbkxlbmd0aCwgdGFibGVFbmQsIHByb2dyYW1JbmZvTGVuZ3RoLCBwaWQsIHJlc3VsdCA9IHsgYXVkaW8gOiAtMSwgYXZjIDogLTEsIGlkMyA6IC0xLCBpc0FBQyA6IHRydWV9O1xuICAgIHNlY3Rpb25MZW5ndGggPSAoZGF0YVtvZmZzZXQgKyAxXSAmIDB4MGYpIDw8IDggfCBkYXRhW29mZnNldCArIDJdO1xuICAgIHRhYmxlRW5kID0gb2Zmc2V0ICsgMyArIHNlY3Rpb25MZW5ndGggLSA0O1xuICAgIC8vIHRvIGRldGVybWluZSB3aGVyZSB0aGUgdGFibGUgaXMsIHdlIGhhdmUgdG8gZmlndXJlIG91dCBob3dcbiAgICAvLyBsb25nIHRoZSBwcm9ncmFtIGluZm8gZGVzY3JpcHRvcnMgYXJlXG4gICAgcHJvZ3JhbUluZm9MZW5ndGggPSAoZGF0YVtvZmZzZXQgKyAxMF0gJiAweDBmKSA8PCA4IHwgZGF0YVtvZmZzZXQgKyAxMV07XG4gICAgLy8gYWR2YW5jZSB0aGUgb2Zmc2V0IHRvIHRoZSBmaXJzdCBlbnRyeSBpbiB0aGUgbWFwcGluZyB0YWJsZVxuICAgIG9mZnNldCArPSAxMiArIHByb2dyYW1JbmZvTGVuZ3RoO1xuICAgIHdoaWxlIChvZmZzZXQgPCB0YWJsZUVuZCkge1xuICAgICAgcGlkID0gKGRhdGFbb2Zmc2V0ICsgMV0gJiAweDFGKSA8PCA4IHwgZGF0YVtvZmZzZXQgKyAyXTtcbiAgICAgIHN3aXRjaChkYXRhW29mZnNldF0pIHtcbiAgICAgICAgY2FzZSAweGNmOiAgICAgLy8gU0FNUExFLUFFUyBBQUNcbiAgICAgICAgICBpZiAoIWlzU2FtcGxlQWVzKSB7XG4gICAgICAgICAgICBsb2dnZXIubG9nKCd1bmtvd24gc3RyZWFtIHR5cGU6JyAgKyBkYXRhW29mZnNldF0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cblxuICAgICAgICAvLyBJU08vSUVDIDEzODE4LTcgQURUUyBBQUMgKE1QRUctMiBsb3dlciBiaXQtcmF0ZSBhdWRpbylcbiAgICAgICAgY2FzZSAweDBmOlxuICAgICAgICAgIC8vbG9nZ2VyLmxvZygnQUFDIFBJRDonICArIHBpZCk7XG4gICAgICAgICAgaWYgKHJlc3VsdC5hdWRpbyA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJlc3VsdC5hdWRpbyA9IHBpZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgLy8gUGFja2V0aXplZCBtZXRhZGF0YSAoSUQzKVxuICAgICAgICBjYXNlIDB4MTU6XG4gICAgICAgICAgLy9sb2dnZXIubG9nKCdJRDMgUElEOicgICsgcGlkKTtcbiAgICAgICAgICBpZiAocmVzdWx0LmlkMyA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJlc3VsdC5pZDMgPSBwaWQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgMHhkYjogICAgIC8vIFNBTVBMRS1BRVMgQVZDXG4gICAgICAgICAgaWYgKCFpc1NhbXBsZUFlcykge1xuICAgICAgICAgICAgbG9nZ2VyLmxvZygndW5rb3duIHN0cmVhbSB0eXBlOicgICsgZGF0YVtvZmZzZXRdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG5cbiAgICAgICAgLy8gSVRVLVQgUmVjLiBILjI2NCBhbmQgSVNPL0lFQyAxNDQ5Ni0xMCAobG93ZXIgYml0LXJhdGUgdmlkZW8pXG4gICAgICAgIGNhc2UgMHgxYjpcbiAgICAgICAgICAvL2xvZ2dlci5sb2coJ0FWQyBQSUQ6JyAgKyBwaWQpO1xuICAgICAgICAgIGlmIChyZXN1bHQuYXZjID09PSAtMSkge1xuICAgICAgICAgICAgcmVzdWx0LmF2YyA9IHBpZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgLy8gSVNPL0lFQyAxMTE3Mi0zIChNUEVHLTEgYXVkaW8pXG4gICAgICAgIC8vIG9yIElTTy9JRUMgMTM4MTgtMyAoTVBFRy0yIGhhbHZlZCBzYW1wbGUgcmF0ZSBhdWRpbylcbiAgICAgICAgY2FzZSAweDAzOlxuICAgICAgICBjYXNlIDB4MDQ6XG4gICAgICAgICAgLy9sb2dnZXIubG9nKCdNUEVHIFBJRDonICArIHBpZCk7XG4gICAgICAgICAgaWYgKCFtcGVnU3VwcG9ydGVkKSB7XG4gICAgICAgICAgICBsb2dnZXIubG9nKCdNUEVHIGF1ZGlvIGZvdW5kLCBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3NlciBmb3Igbm93Jyk7XG4gICAgICAgICAgfSBlbHNlIGlmIChyZXN1bHQuYXVkaW8gPT09IC0xKSB7XG4gICAgICAgICAgICByZXN1bHQuYXVkaW8gPSBwaWQ7XG4gICAgICAgICAgICByZXN1bHQuaXNBQUMgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAweDI0OlxuICAgICAgICAgIGxvZ2dlci53YXJuKCdIRVZDIHN0cmVhbSB0eXBlIGZvdW5kLCBub3Qgc3VwcG9ydGVkIGZvciBub3cnKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGxvZ2dlci5sb2coJ3Vua293biBzdHJlYW0gdHlwZTonICArIGRhdGFbb2Zmc2V0XSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICAvLyBtb3ZlIHRvIHRoZSBuZXh0IHRhYmxlIGVudHJ5XG4gICAgICAvLyBza2lwIHBhc3QgdGhlIGVsZW1lbnRhcnkgc3RyZWFtIGRlc2NyaXB0b3JzLCBpZiBwcmVzZW50XG4gICAgICBvZmZzZXQgKz0gKChkYXRhW29mZnNldCArIDNdICYgMHgwRikgPDwgOCB8IGRhdGFbb2Zmc2V0ICsgNF0pICsgNTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIF9wYXJzZVBFUyhzdHJlYW0pIHtcbiAgICB2YXIgaSA9IDAsIGZyYWcsIHBlc0ZsYWdzLCBwZXNQcmVmaXgsIHBlc0xlbiwgcGVzSGRyTGVuLCBwZXNEYXRhLCBwZXNQdHMsIHBlc0R0cywgcGF5bG9hZFN0YXJ0T2Zmc2V0LCBkYXRhID0gc3RyZWFtLmRhdGE7XG4gICAgLy8gc2FmZXR5IGNoZWNrXG4gICAgaWYgKCFzdHJlYW0gfHwgc3RyZWFtLnNpemUgPT09IDApIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8vIHdlIG1pZ2h0IG5lZWQgdXAgdG8gMTkgYnl0ZXMgdG8gcmVhZCBQRVMgaGVhZGVyXG4gICAgLy8gaWYgZmlyc3QgY2h1bmsgb2YgZGF0YSBpcyBsZXNzIHRoYW4gMTkgYnl0ZXMsIGxldCdzIG1lcmdlIGl0IHdpdGggZm9sbG93aW5nIG9uZXMgdW50aWwgd2UgZ2V0IDE5IGJ5dGVzXG4gICAgLy8gdXN1YWxseSBvbmx5IG9uZSBtZXJnZSBpcyBuZWVkZWQgKGFuZCB0aGlzIGlzIHJhcmUgLi4uKVxuICAgIHdoaWxlKGRhdGFbMF0ubGVuZ3RoIDwgMTkgJiYgZGF0YS5sZW5ndGggPiAxKSB7XG4gICAgICBsZXQgbmV3RGF0YSA9IG5ldyBVaW50OEFycmF5KGRhdGFbMF0ubGVuZ3RoICsgZGF0YVsxXS5sZW5ndGgpO1xuICAgICAgbmV3RGF0YS5zZXQoZGF0YVswXSk7XG4gICAgICBuZXdEYXRhLnNldChkYXRhWzFdLCBkYXRhWzBdLmxlbmd0aCk7XG4gICAgICBkYXRhWzBdID0gbmV3RGF0YTtcbiAgICAgIGRhdGEuc3BsaWNlKDEsMSk7XG4gICAgfVxuICAgIC8vcmV0cmlldmUgUFRTL0RUUyBmcm9tIGZpcnN0IGZyYWdtZW50XG4gICAgZnJhZyA9IGRhdGFbMF07XG4gICAgcGVzUHJlZml4ID0gKGZyYWdbMF0gPDwgMTYpICsgKGZyYWdbMV0gPDwgOCkgKyBmcmFnWzJdO1xuICAgIGlmIChwZXNQcmVmaXggPT09IDEpIHtcbiAgICAgIHBlc0xlbiA9IChmcmFnWzRdIDw8IDgpICsgZnJhZ1s1XTtcbiAgICAgIC8vIGlmIFBFUyBwYXJzZWQgbGVuZ3RoIGlzIG5vdCB6ZXJvIGFuZCBncmVhdGVyIHRoYW4gdG90YWwgcmVjZWl2ZWQgbGVuZ3RoLCBzdG9wIHBhcnNpbmcuIFBFUyBtaWdodCBiZSB0cnVuY2F0ZWRcbiAgICAgIC8vIG1pbnVzIDYgOiBQRVMgaGVhZGVyIHNpemVcbiAgICAgIGlmIChwZXNMZW4gJiYgcGVzTGVuID4gc3RyZWFtLnNpemUgLSA2KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgcGVzRmxhZ3MgPSBmcmFnWzddO1xuICAgICAgaWYgKHBlc0ZsYWdzICYgMHhDMCkge1xuICAgICAgICAvKiBQRVMgaGVhZGVyIGRlc2NyaWJlZCBoZXJlIDogaHR0cDovL2R2ZC5zb3VyY2Vmb3JnZS5uZXQvZHZkaW5mby9wZXMtaGRyLmh0bWxcbiAgICAgICAgICAgIGFzIFBUUyAvIERUUyBpcyAzMyBiaXQgd2UgY2Fubm90IHVzZSBiaXR3aXNlIG9wZXJhdG9yIGluIEpTLFxuICAgICAgICAgICAgYXMgQml0d2lzZSBvcGVyYXRvcnMgdHJlYXQgdGhlaXIgb3BlcmFuZHMgYXMgYSBzZXF1ZW5jZSBvZiAzMiBiaXRzICovXG4gICAgICAgIHBlc1B0cyA9IChmcmFnWzldICYgMHgwRSkgKiA1MzY4NzA5MTIgKy8vIDEgPDwgMjlcbiAgICAgICAgICAoZnJhZ1sxMF0gJiAweEZGKSAqIDQxOTQzMDQgKy8vIDEgPDwgMjJcbiAgICAgICAgICAoZnJhZ1sxMV0gJiAweEZFKSAqIDE2Mzg0ICsvLyAxIDw8IDE0XG4gICAgICAgICAgKGZyYWdbMTJdICYgMHhGRikgKiAxMjggKy8vIDEgPDwgN1xuICAgICAgICAgIChmcmFnWzEzXSAmIDB4RkUpIC8gMjtcbiAgICAgICAgICAvLyBjaGVjayBpZiBncmVhdGVyIHRoYW4gMl4zMiAtMVxuICAgICAgICAgIGlmIChwZXNQdHMgPiA0Mjk0OTY3Mjk1KSB7XG4gICAgICAgICAgICAvLyBkZWNyZW1lbnQgMl4zM1xuICAgICAgICAgICAgcGVzUHRzIC09IDg1ODk5MzQ1OTI7XG4gICAgICAgICAgfVxuICAgICAgICBpZiAocGVzRmxhZ3MgJiAweDQwKSB7XG4gICAgICAgICAgcGVzRHRzID0gKGZyYWdbMTRdICYgMHgwRSApICogNTM2ODcwOTEyICsvLyAxIDw8IDI5XG4gICAgICAgICAgICAoZnJhZ1sxNV0gJiAweEZGICkgKiA0MTk0MzA0ICsvLyAxIDw8IDIyXG4gICAgICAgICAgICAoZnJhZ1sxNl0gJiAweEZFICkgKiAxNjM4NCArLy8gMSA8PCAxNFxuICAgICAgICAgICAgKGZyYWdbMTddICYgMHhGRiApICogMTI4ICsvLyAxIDw8IDdcbiAgICAgICAgICAgIChmcmFnWzE4XSAmIDB4RkUgKSAvIDI7XG4gICAgICAgICAgLy8gY2hlY2sgaWYgZ3JlYXRlciB0aGFuIDJeMzIgLTFcbiAgICAgICAgICBpZiAocGVzRHRzID4gNDI5NDk2NzI5NSkge1xuICAgICAgICAgICAgLy8gZGVjcmVtZW50IDJeMzNcbiAgICAgICAgICAgIHBlc0R0cyAtPSA4NTg5OTM0NTkyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocGVzUHRzIC0gcGVzRHRzID4gNjAqOTAwMDApIHtcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKGAke01hdGgucm91bmQoKHBlc1B0cyAtIHBlc0R0cykvOTAwMDApfXMgZGVsdGEgYmV0d2VlbiBQVFMgYW5kIERUUywgYWxpZ24gdGhlbWApO1xuICAgICAgICAgICAgcGVzUHRzID0gcGVzRHRzO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZXNEdHMgPSBwZXNQdHM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHBlc0hkckxlbiA9IGZyYWdbOF07XG4gICAgICAvLyA5IGJ5dGVzIDogNiBieXRlcyBmb3IgUEVTIGhlYWRlciArIDMgYnl0ZXMgZm9yIFBFUyBleHRlbnNpb25cbiAgICAgIHBheWxvYWRTdGFydE9mZnNldCA9IHBlc0hkckxlbiArIDk7XG5cbiAgICAgIHN0cmVhbS5zaXplIC09IHBheWxvYWRTdGFydE9mZnNldDtcbiAgICAgIC8vcmVhc3NlbWJsZSBQRVMgcGFja2V0XG4gICAgICBwZXNEYXRhID0gbmV3IFVpbnQ4QXJyYXkoc3RyZWFtLnNpemUpO1xuICAgICAgZm9yKCBsZXQgaiA9IDAsIGRhdGFMZW4gPSBkYXRhLmxlbmd0aDsgaiA8IGRhdGFMZW4gOyBqKyspIHtcbiAgICAgICAgZnJhZyA9IGRhdGFbal07XG4gICAgICAgIGxldCBsZW4gPSBmcmFnLmJ5dGVMZW5ndGg7XG4gICAgICAgIGlmIChwYXlsb2FkU3RhcnRPZmZzZXQpIHtcbiAgICAgICAgICBpZiAocGF5bG9hZFN0YXJ0T2Zmc2V0ID4gbGVuKSB7XG4gICAgICAgICAgICAvLyB0cmltIGZ1bGwgZnJhZyBpZiBQRVMgaGVhZGVyIGJpZ2dlciB0aGFuIGZyYWdcbiAgICAgICAgICAgIHBheWxvYWRTdGFydE9mZnNldC09bGVuO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHRyaW0gcGFydGlhbCBmcmFnIGlmIFBFUyBoZWFkZXIgc21hbGxlciB0aGFuIGZyYWdcbiAgICAgICAgICAgIGZyYWcgPSBmcmFnLnN1YmFycmF5KHBheWxvYWRTdGFydE9mZnNldCk7XG4gICAgICAgICAgICBsZW4tPXBheWxvYWRTdGFydE9mZnNldDtcbiAgICAgICAgICAgIHBheWxvYWRTdGFydE9mZnNldCA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHBlc0RhdGEuc2V0KGZyYWcsIGkpO1xuICAgICAgICBpKz1sZW47XG4gICAgICB9XG4gICAgICBpZiAocGVzTGVuKSB7XG4gICAgICAgIC8vIHBheWxvYWQgc2l6ZSA6IHJlbW92ZSBQRVMgaGVhZGVyICsgUEVTIGV4dGVuc2lvblxuICAgICAgICBwZXNMZW4gLT0gcGVzSGRyTGVuKzM7XG4gICAgICB9XG4gICAgICByZXR1cm4ge2RhdGE6IHBlc0RhdGEsIHB0czogcGVzUHRzLCBkdHM6IHBlc0R0cywgbGVuOiBwZXNMZW59O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICBwdXNoQWNjZXNVbml0KGF2Y1NhbXBsZSxhdmNUcmFjaykge1xuICAgIGlmIChhdmNTYW1wbGUudW5pdHMubGVuZ3RoICYmIGF2Y1NhbXBsZS5mcmFtZSkge1xuICAgICAgY29uc3Qgc2FtcGxlcyA9IGF2Y1RyYWNrLnNhbXBsZXM7XG4gICAgICBjb25zdCBuYlNhbXBsZXMgPSBzYW1wbGVzLmxlbmd0aDtcbiAgICAgIC8vIG9ubHkgcHVzaCBBVkMgc2FtcGxlIGlmIHN0YXJ0aW5nIHdpdGggYSBrZXlmcmFtZSBpcyBub3QgbWFuZGF0b3J5IE9SXG4gICAgICAvLyAgICBpZiBrZXlmcmFtZSBhbHJlYWR5IGZvdW5kIGluIHRoaXMgZnJhZ21lbnQgT1JcbiAgICAgIC8vICAgICAgIGtleWZyYW1lIGZvdW5kIGluIGxhc3QgZnJhZ21lbnQgKHRyYWNrLnNwcykgQU5EXG4gICAgICAvLyAgICAgICAgICBzYW1wbGVzIGFscmVhZHkgYXBwZW5kZWQgKHdlIGFscmVhZHkgZm91bmQgYSBrZXlmcmFtZSBpbiB0aGlzIGZyYWdtZW50KSBPUiBmcmFnbWVudCBpcyBjb250aWd1b3VzXG4gICAgICBpZiAoIXRoaXMuY29uZmlnLmZvcmNlS2V5RnJhbWVPbkRpc2NvbnRpbnVpdHkgfHxcbiAgICAgICAgICBhdmNTYW1wbGUua2V5ID09PSB0cnVlIHx8XG4gICAgICAgICAgKGF2Y1RyYWNrLnNwcyAmJiAobmJTYW1wbGVzIHx8IHRoaXMuY29udGlndW91cykpKSB7XG4gICAgICAgIGF2Y1NhbXBsZS5pZCA9IG5iU2FtcGxlcztcbiAgICAgICAgc2FtcGxlcy5wdXNoKGF2Y1NhbXBsZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBkcm9wcGVkIHNhbXBsZXMsIHRyYWNrIGl0XG4gICAgICAgIGF2Y1RyYWNrLmRyb3BwZWQrKztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYoYXZjU2FtcGxlLmRlYnVnLmxlbmd0aCkge1xuICAgICAgbG9nZ2VyLmxvZyhhdmNTYW1wbGUucHRzICsgJy8nICsgYXZjU2FtcGxlLmR0cyArICc6JyArIGF2Y1NhbXBsZS5kZWJ1Zyk7XG4gICAgfVxuICB9XG5cbiAgX3BhcnNlQVZDUEVTKHBlcyxsYXN0KSB7XG4gICAgLy9sb2dnZXIubG9nKCdwYXJzZSBuZXcgUEVTJyk7XG4gICAgdmFyIHRyYWNrID0gdGhpcy5fYXZjVHJhY2ssXG4gICAgICAgIHVuaXRzID0gdGhpcy5fcGFyc2VBVkNOQUx1KHBlcy5kYXRhKSxcbiAgICAgICAgZGVidWcgPSBmYWxzZSxcbiAgICAgICAgZXhwR29sb21iRGVjb2RlcixcbiAgICAgICAgYXZjU2FtcGxlID0gdGhpcy5hdmNTYW1wbGUsXG4gICAgICAgIHB1c2gsXG4gICAgICAgIGk7XG4gICAgLy9mcmVlIHBlcy5kYXRhIHRvIHNhdmUgdXAgc29tZSBtZW1vcnlcbiAgICBwZXMuZGF0YSA9IG51bGw7XG5cbiAgICB1bml0cy5mb3JFYWNoKHVuaXQgPT4ge1xuICAgICAgc3dpdGNoKHVuaXQudHlwZSkge1xuICAgICAgICAvL05EUlxuICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICBwdXNoID0gdHJ1ZTtcbiAgICAgICAgICAgaWYoZGVidWcgJiYgYXZjU2FtcGxlKSB7XG4gICAgICAgICAgICBhdmNTYW1wbGUuZGVidWcgKz0gJ05EUiAnO1xuICAgICAgICAgICB9XG4gICAgICAgICAgIGF2Y1NhbXBsZS5mcmFtZSA9IHRydWU7XG4gICAgICAgICAgIC8vIHJldHJpZXZlIHNsaWNlIHR5cGUgYnkgcGFyc2luZyBiZWdpbm5pbmcgb2YgTkFMIHVuaXQgKGZvbGxvdyBIMjY0IHNwZWMsIHNsaWNlX2hlYWRlciBkZWZpbml0aW9uKSB0byBkZXRlY3Qga2V5ZnJhbWUgZW1iZWRkZWQgaW4gTkRSXG4gICAgICAgICAgIGxldCBkYXRhID0gdW5pdC5kYXRhO1xuICAgICAgICAgICBpZiAoZGF0YS5sZW5ndGggPiA0KSB7XG4gICAgICAgICAgICAgbGV0IHNsaWNlVHlwZSA9IG5ldyBFeHBHb2xvbWIoZGF0YSkucmVhZFNsaWNlVHlwZSgpO1xuICAgICAgICAgICAgIC8vIDIgOiBJIHNsaWNlLCA0IDogU0kgc2xpY2UsIDcgOiBJIHNsaWNlLCA5OiBTSSBzbGljZVxuICAgICAgICAgICAgIC8vIFNJIHNsaWNlIDogQSBzbGljZSB0aGF0IGlzIGNvZGVkIHVzaW5nIGludHJhIHByZWRpY3Rpb24gb25seSBhbmQgdXNpbmcgcXVhbnRpc2F0aW9uIG9mIHRoZSBwcmVkaWN0aW9uIHNhbXBsZXMuXG4gICAgICAgICAgICAgLy8gQW4gU0kgc2xpY2UgY2FuIGJlIGNvZGVkIHN1Y2ggdGhhdCBpdHMgZGVjb2RlZCBzYW1wbGVzIGNhbiBiZSBjb25zdHJ1Y3RlZCBpZGVudGljYWxseSB0byBhbiBTUCBzbGljZS5cbiAgICAgICAgICAgICAvLyBJIHNsaWNlOiBBIHNsaWNlIHRoYXQgaXMgbm90IGFuIFNJIHNsaWNlIHRoYXQgaXMgZGVjb2RlZCB1c2luZyBpbnRyYSBwcmVkaWN0aW9uIG9ubHkuXG4gICAgICAgICAgICAgLy9pZiAoc2xpY2VUeXBlID09PSAyIHx8IHNsaWNlVHlwZSA9PT0gNykge1xuICAgICAgICAgICAgIGlmIChzbGljZVR5cGUgPT09IDIgfHwgc2xpY2VUeXBlID09PSA0IHx8IHNsaWNlVHlwZSA9PT0gNyB8fCBzbGljZVR5cGUgPT09IDkpIHtcbiAgICAgICAgICAgICAgICBhdmNTYW1wbGUua2V5ID0gdHJ1ZTtcbiAgICAgICAgICAgICB9XG4gICAgICAgICAgIH1cbiAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vSURSXG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICBwdXNoID0gdHJ1ZTtcbiAgICAgICAgICAvLyBoYW5kbGUgUEVTIG5vdCBzdGFydGluZyB3aXRoIEFVRFxuICAgICAgICAgIGlmICghYXZjU2FtcGxlKSB7XG4gICAgICAgICAgICBhdmNTYW1wbGUgPSB0aGlzLmF2Y1NhbXBsZSA9IHRoaXMuX2NyZWF0ZUFWQ1NhbXBsZSh0cnVlLHBlcy5wdHMscGVzLmR0cywnJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmKGRlYnVnKSB7XG4gICAgICAgICAgICBhdmNTYW1wbGUuZGVidWcgKz0gJ0lEUiAnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhdmNTYW1wbGUua2V5ID0gdHJ1ZTtcbiAgICAgICAgICBhdmNTYW1wbGUuZnJhbWUgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvL1NFSVxuICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgcHVzaCA9IHRydWU7XG4gICAgICAgICAgaWYoZGVidWcgJiYgYXZjU2FtcGxlKSB7XG4gICAgICAgICAgICBhdmNTYW1wbGUuZGVidWcgKz0gJ1NFSSAnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBleHBHb2xvbWJEZWNvZGVyID0gbmV3IEV4cEdvbG9tYih0aGlzLmRpc2NhcmRFUEIodW5pdC5kYXRhKSk7XG5cbiAgICAgICAgICAvLyBza2lwIGZyYW1lVHlwZVxuICAgICAgICAgIGV4cEdvbG9tYkRlY29kZXIucmVhZFVCeXRlKCk7XG5cbiAgICAgICAgICB2YXIgcGF5bG9hZFR5cGUgPSAwO1xuICAgICAgICAgIHZhciBwYXlsb2FkU2l6ZSA9IDA7XG4gICAgICAgICAgdmFyIGVuZE9mQ2FwdGlvbnMgPSBmYWxzZTtcbiAgICAgICAgICB2YXIgYiA9IDA7XG5cbiAgICAgICAgICB3aGlsZSAoIWVuZE9mQ2FwdGlvbnMgJiYgZXhwR29sb21iRGVjb2Rlci5ieXRlc0F2YWlsYWJsZSA+IDEpIHtcbiAgICAgICAgICAgIHBheWxvYWRUeXBlID0gMDtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBiID0gZXhwR29sb21iRGVjb2Rlci5yZWFkVUJ5dGUoKTtcbiAgICAgICAgICAgICAgICBwYXlsb2FkVHlwZSArPSBiO1xuICAgICAgICAgICAgfSB3aGlsZSAoYiA9PT0gMHhGRik7XG5cbiAgICAgICAgICAgIC8vIFBhcnNlIHBheWxvYWQgc2l6ZS5cbiAgICAgICAgICAgIHBheWxvYWRTaXplID0gMDtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBiID0gZXhwR29sb21iRGVjb2Rlci5yZWFkVUJ5dGUoKTtcbiAgICAgICAgICAgICAgICBwYXlsb2FkU2l6ZSArPSBiO1xuICAgICAgICAgICAgfSB3aGlsZSAoYiA9PT0gMHhGRik7XG5cbiAgICAgICAgICAgIC8vIFRPRE86IHRoZXJlIGNhbiBiZSBtb3JlIHRoYW4gb25lIHBheWxvYWQgaW4gYW4gU0VJIHBhY2tldC4uLlxuICAgICAgICAgICAgLy8gVE9ETzogbmVlZCB0byByZWFkIHR5cGUgYW5kIHNpemUgaW4gYSB3aGlsZSBsb29wIHRvIGdldCB0aGVtIGFsbFxuICAgICAgICAgICAgaWYgKHBheWxvYWRUeXBlID09PSA0ICYmIGV4cEdvbG9tYkRlY29kZXIuYnl0ZXNBdmFpbGFibGUgIT09IDApIHtcblxuICAgICAgICAgICAgICBlbmRPZkNhcHRpb25zID0gdHJ1ZTtcblxuICAgICAgICAgICAgICB2YXIgY291bnRyeUNvZGUgPSBleHBHb2xvbWJEZWNvZGVyLnJlYWRVQnl0ZSgpO1xuXG4gICAgICAgICAgICAgIGlmIChjb3VudHJ5Q29kZSA9PT0gMTgxKSB7XG4gICAgICAgICAgICAgICAgdmFyIHByb3ZpZGVyQ29kZSA9IGV4cEdvbG9tYkRlY29kZXIucmVhZFVTaG9ydCgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHByb3ZpZGVyQ29kZSA9PT0gNDkpIHtcbiAgICAgICAgICAgICAgICAgIHZhciB1c2VyU3RydWN0dXJlID0gZXhwR29sb21iRGVjb2Rlci5yZWFkVUludCgpO1xuXG4gICAgICAgICAgICAgICAgICBpZiAodXNlclN0cnVjdHVyZSA9PT0gMHg0NzQxMzkzNCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdXNlckRhdGFUeXBlID0gZXhwR29sb21iRGVjb2Rlci5yZWFkVUJ5dGUoKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBSYXcgQ0VBLTYwOCBieXRlcyB3cmFwcGVkIGluIENFQS03MDggcGFja2V0XG4gICAgICAgICAgICAgICAgICAgIGlmICh1c2VyRGF0YVR5cGUgPT09IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgZmlyc3RCeXRlID0gZXhwR29sb21iRGVjb2Rlci5yZWFkVUJ5dGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgc2Vjb25kQnl0ZSA9IGV4cEdvbG9tYkRlY29kZXIucmVhZFVCeXRlKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICB2YXIgdG90YWxDQ3MgPSAzMSAmIGZpcnN0Qnl0ZTtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgYnl0ZUFycmF5ID0gW2ZpcnN0Qnl0ZSwgc2Vjb25kQnl0ZV07XG5cbiAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdG90YWxDQ3M7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gMyBieXRlcyBwZXIgQ0NcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ5dGVBcnJheS5wdXNoKGV4cEdvbG9tYkRlY29kZXIucmVhZFVCeXRlKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnl0ZUFycmF5LnB1c2goZXhwR29sb21iRGVjb2Rlci5yZWFkVUJ5dGUoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBieXRlQXJyYXkucHVzaChleHBHb2xvbWJEZWNvZGVyLnJlYWRVQnl0ZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbnNlcnRTYW1wbGVJbk9yZGVyKHRoaXMuX3R4dFRyYWNrLnNhbXBsZXMsIHsgdHlwZTogMywgcHRzOiBwZXMucHRzLCBieXRlczogYnl0ZUFycmF5IH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwYXlsb2FkU2l6ZSA8IGV4cEdvbG9tYkRlY29kZXIuYnl0ZXNBdmFpbGFibGUpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGZvciAoaSA9IDA7IGk8cGF5bG9hZFNpemU7IGkrKylcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGV4cEdvbG9tYkRlY29kZXIucmVhZFVCeXRlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vU1BTXG4gICAgICAgIGNhc2UgNzpcbiAgICAgICAgICBwdXNoID0gdHJ1ZTtcbiAgICAgICAgICBpZihkZWJ1ZyAmJiBhdmNTYW1wbGUpIHtcbiAgICAgICAgICAgIGF2Y1NhbXBsZS5kZWJ1ZyArPSAnU1BTICc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmKCF0cmFjay5zcHMpIHtcbiAgICAgICAgICAgIGV4cEdvbG9tYkRlY29kZXIgPSBuZXcgRXhwR29sb21iKHVuaXQuZGF0YSk7XG4gICAgICAgICAgICB2YXIgY29uZmlnID0gZXhwR29sb21iRGVjb2Rlci5yZWFkU1BTKCk7XG4gICAgICAgICAgICB0cmFjay53aWR0aCA9IGNvbmZpZy53aWR0aDtcbiAgICAgICAgICAgIHRyYWNrLmhlaWdodCA9IGNvbmZpZy5oZWlnaHQ7XG4gICAgICAgICAgICB0cmFjay5waXhlbFJhdGlvID0gY29uZmlnLnBpeGVsUmF0aW87XG4gICAgICAgICAgICB0cmFjay5zcHMgPSBbdW5pdC5kYXRhXTtcbiAgICAgICAgICAgIHRyYWNrLmR1cmF0aW9uID0gdGhpcy5fZHVyYXRpb247XG4gICAgICAgICAgICB2YXIgY29kZWNhcnJheSA9IHVuaXQuZGF0YS5zdWJhcnJheSgxLCA0KTtcbiAgICAgICAgICAgIHZhciBjb2RlY3N0cmluZyA9ICdhdmMxLic7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgICAgICAgICAgIHZhciBoID0gY29kZWNhcnJheVtpXS50b1N0cmluZygxNik7XG4gICAgICAgICAgICAgIGlmIChoLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgICAgICBoID0gJzAnICsgaDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb2RlY3N0cmluZyArPSBoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJhY2suY29kZWMgPSBjb2RlY3N0cmluZztcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vUFBTXG4gICAgICAgIGNhc2UgODpcbiAgICAgICAgICBwdXNoID0gdHJ1ZTtcbiAgICAgICAgICBpZihkZWJ1ZyAmJiBhdmNTYW1wbGUpIHtcbiAgICAgICAgICAgIGF2Y1NhbXBsZS5kZWJ1ZyArPSAnUFBTICc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghdHJhY2sucHBzKSB7XG4gICAgICAgICAgICB0cmFjay5wcHMgPSBbdW5pdC5kYXRhXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIEFVRFxuICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgcHVzaCA9IGZhbHNlO1xuICAgICAgICAgIGlmIChhdmNTYW1wbGUpIHtcbiAgICAgICAgICAgIHRoaXMucHVzaEFjY2VzVW5pdChhdmNTYW1wbGUsdHJhY2spO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhdmNTYW1wbGUgPSB0aGlzLmF2Y1NhbXBsZSA9IHRoaXMuX2NyZWF0ZUFWQ1NhbXBsZShmYWxzZSxwZXMucHRzLHBlcy5kdHMsZGVidWcgPyAnQVVEICc6ICcnKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gRmlsbGVyIERhdGFcbiAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICBwdXNoID0gZmFsc2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcHVzaCA9IGZhbHNlO1xuICAgICAgICAgIGlmIChhdmNTYW1wbGUpIHtcbiAgICAgICAgICAgIGF2Y1NhbXBsZS5kZWJ1ZyArPSAndW5rbm93biBOQUwgJyArIHVuaXQudHlwZSArICcgJztcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZihhdmNTYW1wbGUgJiYgcHVzaCkge1xuICAgICAgICBsZXQgdW5pdHMgPSBhdmNTYW1wbGUudW5pdHM7XG4gICAgICAgIHVuaXRzLnB1c2godW5pdCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgLy8gaWYgbGFzdCBQRVMgcGFja2V0LCBwdXNoIHNhbXBsZXNcbiAgICBpZiAobGFzdCAmJiBhdmNTYW1wbGUpIHtcbiAgICAgIHRoaXMucHVzaEFjY2VzVW5pdChhdmNTYW1wbGUsdHJhY2spO1xuICAgICAgdGhpcy5hdmNTYW1wbGUgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIF9jcmVhdGVBVkNTYW1wbGUoa2V5LHB0cyxkdHMsZGVidWcpIHtcbiAgICByZXR1cm4geyBrZXkgOiBrZXksIHB0cyA6IHB0cywgZHRzIDogZHRzLCB1bml0cyA6IFtdLCBkZWJ1ZyA6IGRlYnVnfTtcbiAgfVxuXG4gIF9pbnNlcnRTYW1wbGVJbk9yZGVyKGFyciwgZGF0YSkge1xuICAgIHZhciBsZW4gPSBhcnIubGVuZ3RoO1xuICAgIGlmIChsZW4gPiAwKSB7XG4gICAgICBpZiAoZGF0YS5wdHMgPj0gYXJyW2xlbi0xXS5wdHMpXG4gICAgICB7XG4gICAgICAgIGFyci5wdXNoKGRhdGEpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGZvciAodmFyIHBvcyA9IGxlbiAtIDE7IHBvcyA+PSAwOyBwb3MtLSkge1xuICAgICAgICAgIGlmIChkYXRhLnB0cyA8IGFycltwb3NdLnB0cykge1xuICAgICAgICAgICAgYXJyLnNwbGljZShwb3MsIDAsIGRhdGEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgYXJyLnB1c2goZGF0YSk7XG4gICAgfVxuICB9XG5cbiAgX2dldExhc3ROYWxVbml0KCkge1xuICAgIGxldCBhdmNTYW1wbGUgPSB0aGlzLmF2Y1NhbXBsZSwgbGFzdFVuaXQ7XG4gICAgLy8gdHJ5IHRvIGZhbGxiYWNrIHRvIHByZXZpb3VzIHNhbXBsZSBpZiBjdXJyZW50IG9uZSBpcyBlbXB0eVxuICAgIGlmICghYXZjU2FtcGxlIHx8IGF2Y1NhbXBsZS51bml0cy5sZW5ndGggPT09IDApIHtcbiAgICAgIGxldCB0cmFjayA9IHRoaXMuX2F2Y1RyYWNrLCBzYW1wbGVzID0gdHJhY2suc2FtcGxlcztcbiAgICAgIGF2Y1NhbXBsZSA9IHNhbXBsZXNbc2FtcGxlcy5sZW5ndGgtMV07XG4gICAgfVxuICAgIGlmIChhdmNTYW1wbGUpIHtcbiAgICAgIGxldCB1bml0cyA9IGF2Y1NhbXBsZS51bml0cztcbiAgICAgIGxhc3RVbml0ID0gdW5pdHNbdW5pdHMubGVuZ3RoIC0gMV07XG4gICAgfVxuICAgIHJldHVybiBsYXN0VW5pdDtcbiAgfVxuXG4gIF9wYXJzZUFWQ05BTHUoYXJyYXkpIHtcbiAgICB2YXIgaSA9IDAsIGxlbiA9IGFycmF5LmJ5dGVMZW5ndGgsIHZhbHVlLCBvdmVyZmxvdywgdHJhY2sgPSB0aGlzLl9hdmNUcmFjaywgc3RhdGUgPSB0cmFjay5uYWx1U3RhdGUgfHwgMCwgbGFzdFN0YXRlID0gc3RhdGU7XG4gICAgdmFyIHVuaXRzID0gW10sIHVuaXQsIHVuaXRUeXBlLCBsYXN0VW5pdFN0YXJ0ID0gLTEsIGxhc3RVbml0VHlwZTtcbiAgICAvL2xvZ2dlci5sb2coJ1BFUzonICsgSGV4LmhleER1bXAoYXJyYXkpKTtcblxuICAgIGlmIChzdGF0ZSA9PT0gLTEpIHtcbiAgICAvLyBzcGVjaWFsIHVzZSBjYXNlIHdoZXJlIHdlIGZvdW5kIDMgb3IgNC1ieXRlIHN0YXJ0IGNvZGVzIGV4YWN0bHkgYXQgdGhlIGVuZCBvZiBwcmV2aW91cyBQRVMgcGFja2V0XG4gICAgICBsYXN0VW5pdFN0YXJ0ID0gMDtcbiAgICAgIC8vIE5BTHUgdHlwZSBpcyB2YWx1ZSByZWFkIGZyb20gb2Zmc2V0IDBcbiAgICAgIGxhc3RVbml0VHlwZSA9IGFycmF5WzBdICYgMHgxZjtcbiAgICAgIHN0YXRlID0gMDtcbiAgICAgIGkgPSAxO1xuICAgIH1cblxuICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICB2YWx1ZSA9IGFycmF5W2krK107XG4gICAgICAvLyBvcHRpbWl6YXRpb24uIHN0YXRlIDAgYW5kIDEgYXJlIHRoZSBwcmVkb21pbmFudCBjYXNlLiBsZXQncyBoYW5kbGUgdGhlbSBvdXRzaWRlIG9mIHRoZSBzd2l0Y2gvY2FzZVxuICAgICAgaWYgKCFzdGF0ZSkge1xuICAgICAgICBzdGF0ZSA9IHZhbHVlID8gMCA6IDE7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXRlID09PSAxKSB7XG4gICAgICAgIHN0YXRlID0gdmFsdWUgPyAwIDogMjtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICAvLyBoZXJlIHdlIGhhdmUgc3RhdGUgZWl0aGVyIGVxdWFsIHRvIDIgb3IgM1xuICAgICAgaWYoIXZhbHVlKSB7XG4gICAgICAgIHN0YXRlID0gMztcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT09IDEpIHtcbiAgICAgICAgaWYgKGxhc3RVbml0U3RhcnQgPj0wKSB7XG4gICAgICAgICAgdW5pdCA9IHtkYXRhOiBhcnJheS5zdWJhcnJheShsYXN0VW5pdFN0YXJ0LCBpIC0gc3RhdGUgLSAxKSwgdHlwZTogbGFzdFVuaXRUeXBlfTtcbiAgICAgICAgICAvL2xvZ2dlci5sb2coJ3B1c2hpbmcgTkFMVSwgdHlwZS9zaXplOicgKyB1bml0LnR5cGUgKyAnLycgKyB1bml0LmRhdGEuYnl0ZUxlbmd0aCk7XG4gICAgICAgICAgdW5pdHMucHVzaCh1bml0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBsYXN0VW5pdFN0YXJ0IGlzIHVuZGVmaW5lZCA9PiB0aGlzIGlzIHRoZSBmaXJzdCBzdGFydCBjb2RlIGZvdW5kIGluIHRoaXMgUEVTIHBhY2tldFxuICAgICAgICAgIC8vIGZpcnN0IGNoZWNrIGlmIHN0YXJ0IGNvZGUgZGVsaW1pdGVyIGlzIG92ZXJsYXBwaW5nIGJldHdlZW4gMiBQRVMgcGFja2V0cyxcbiAgICAgICAgICAvLyBpZSBpdCBzdGFydGVkIGluIGxhc3QgcGFja2V0IChsYXN0U3RhdGUgbm90IHplcm8pXG4gICAgICAgICAgLy8gYW5kIGVuZGVkIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhpcyBQRVMgcGFja2V0IChpIDw9IDQgLSBsYXN0U3RhdGUpXG4gICAgICAgICAgbGV0IGxhc3RVbml0ID0gdGhpcy5fZ2V0TGFzdE5hbFVuaXQoKTtcbiAgICAgICAgICBpZiAobGFzdFVuaXQpIHtcbiAgICAgICAgICAgIGlmKGxhc3RTdGF0ZSAmJiAgKGkgPD0gNCAtIGxhc3RTdGF0ZSkpIHtcbiAgICAgICAgICAgICAgLy8gc3RhcnQgZGVsaW1pdGVyIG92ZXJsYXBwaW5nIGJldHdlZW4gUEVTIHBhY2tldHNcbiAgICAgICAgICAgICAgLy8gc3RyaXAgc3RhcnQgZGVsaW1pdGVyIGJ5dGVzIGZyb20gdGhlIGVuZCBvZiBsYXN0IE5BTCB1bml0XG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgbGFzdFVuaXQgaGFkIGEgc3RhdGUgZGlmZmVyZW50IGZyb20gemVyb1xuICAgICAgICAgICAgICBpZiAobGFzdFVuaXQuc3RhdGUpIHtcbiAgICAgICAgICAgICAgICAvLyBzdHJpcCBsYXN0IGJ5dGVzXG4gICAgICAgICAgICAgICAgbGFzdFVuaXQuZGF0YSA9IGxhc3RVbml0LmRhdGEuc3ViYXJyYXkoMCxsYXN0VW5pdC5kYXRhLmJ5dGVMZW5ndGggLSBsYXN0U3RhdGUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiBOQUwgdW5pdHMgYXJlIG5vdCBzdGFydGluZyByaWdodCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBQRVMgcGFja2V0LCBwdXNoIHByZWNlZGluZyBkYXRhIGludG8gcHJldmlvdXMgTkFMIHVuaXQuXG4gICAgICAgICAgICBvdmVyZmxvdyAgPSBpIC0gc3RhdGUgLSAxO1xuICAgICAgICAgICAgaWYgKG92ZXJmbG93ID4gMCkge1xuICAgICAgICAgICAgICAvL2xvZ2dlci5sb2coJ2ZpcnN0IE5BTFUgZm91bmQgd2l0aCBvdmVyZmxvdzonICsgb3ZlcmZsb3cpO1xuICAgICAgICAgICAgICBsZXQgdG1wID0gbmV3IFVpbnQ4QXJyYXkobGFzdFVuaXQuZGF0YS5ieXRlTGVuZ3RoICsgb3ZlcmZsb3cpO1xuICAgICAgICAgICAgICB0bXAuc2V0KGxhc3RVbml0LmRhdGEsIDApO1xuICAgICAgICAgICAgICB0bXAuc2V0KGFycmF5LnN1YmFycmF5KDAsIG92ZXJmbG93KSwgbGFzdFVuaXQuZGF0YS5ieXRlTGVuZ3RoKTtcbiAgICAgICAgICAgICAgbGFzdFVuaXQuZGF0YSA9IHRtcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gY2hlY2sgaWYgd2UgY2FuIHJlYWQgdW5pdCB0eXBlXG4gICAgICAgIGlmIChpIDwgbGVuKSB7XG4gICAgICAgICAgdW5pdFR5cGUgPSBhcnJheVtpXSAmIDB4MWY7XG4gICAgICAgICAgLy9sb2dnZXIubG9nKCdmaW5kIE5BTFUgQCBvZmZzZXQ6JyArIGkgKyAnLHR5cGU6JyArIHVuaXRUeXBlKTtcbiAgICAgICAgICBsYXN0VW5pdFN0YXJ0ID0gaTtcbiAgICAgICAgICBsYXN0VW5pdFR5cGUgPSB1bml0VHlwZTtcbiAgICAgICAgICBzdGF0ZSA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gbm90IGVub3VnaCBieXRlIHRvIHJlYWQgdW5pdCB0eXBlLiBsZXQncyByZWFkIGl0IG9uIG5leHQgUEVTIHBhcnNpbmdcbiAgICAgICAgICBzdGF0ZSA9IC0xO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZSA9IDA7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChsYXN0VW5pdFN0YXJ0ID49MCAmJiBzdGF0ZSA+PTApIHtcbiAgICAgIHVuaXQgPSB7ZGF0YTogYXJyYXkuc3ViYXJyYXkobGFzdFVuaXRTdGFydCwgbGVuKSwgdHlwZTogbGFzdFVuaXRUeXBlLCBzdGF0ZSA6IHN0YXRlfTtcbiAgICAgIHVuaXRzLnB1c2godW5pdCk7XG4gICAgICAvL2xvZ2dlci5sb2coJ3B1c2hpbmcgTkFMVSwgdHlwZS9zaXplL3N0YXRlOicgKyB1bml0LnR5cGUgKyAnLycgKyB1bml0LmRhdGEuYnl0ZUxlbmd0aCArICcvJyArIHN0YXRlKTtcbiAgICB9XG4gICAgLy8gbm8gTkFMdSBmb3VuZFxuICAgIGlmICh1bml0cy5sZW5ndGggPT09IDApIHtcbiAgICAgIC8vIGFwcGVuZCBwZXMuZGF0YSB0byBwcmV2aW91cyBOQUwgdW5pdFxuICAgICAgbGV0ICBsYXN0VW5pdCA9IHRoaXMuX2dldExhc3ROYWxVbml0KCk7XG4gICAgICBpZiAobGFzdFVuaXQpIHtcbiAgICAgICAgbGV0IHRtcCA9IG5ldyBVaW50OEFycmF5KGxhc3RVbml0LmRhdGEuYnl0ZUxlbmd0aCArIGFycmF5LmJ5dGVMZW5ndGgpO1xuICAgICAgICB0bXAuc2V0KGxhc3RVbml0LmRhdGEsIDApO1xuICAgICAgICB0bXAuc2V0KGFycmF5LCBsYXN0VW5pdC5kYXRhLmJ5dGVMZW5ndGgpO1xuICAgICAgICBsYXN0VW5pdC5kYXRhID0gdG1wO1xuICAgICAgfVxuICAgIH1cbiAgICB0cmFjay5uYWx1U3RhdGUgPSBzdGF0ZTtcbiAgICByZXR1cm4gdW5pdHM7XG4gIH1cblxuICAvKipcbiAgICogcmVtb3ZlIEVtdWxhdGlvbiBQcmV2ZW50aW9uIGJ5dGVzIGZyb20gYSBSQlNQXG4gICAqL1xuICBkaXNjYXJkRVBCKGRhdGEpIHtcbiAgICB2YXIgbGVuZ3RoID0gZGF0YS5ieXRlTGVuZ3RoLFxuICAgICAgICBFUEJQb3NpdGlvbnMgPSBbXSxcbiAgICAgICAgaSA9IDEsXG4gICAgICAgIG5ld0xlbmd0aCwgbmV3RGF0YTtcblxuICAgIC8vIEZpbmQgYWxsIGBFbXVsYXRpb24gUHJldmVudGlvbiBCeXRlc2BcbiAgICB3aGlsZSAoaSA8IGxlbmd0aCAtIDIpIHtcbiAgICAgIGlmIChkYXRhW2ldID09PSAwICYmXG4gICAgICAgICAgZGF0YVtpICsgMV0gPT09IDAgJiZcbiAgICAgICAgICBkYXRhW2kgKyAyXSA9PT0gMHgwMykge1xuICAgICAgICBFUEJQb3NpdGlvbnMucHVzaChpICsgMik7XG4gICAgICAgIGkgKz0gMjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGkrKztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiBubyBFbXVsYXRpb24gUHJldmVudGlvbiBCeXRlcyB3ZXJlIGZvdW5kIGp1c3QgcmV0dXJuIHRoZSBvcmlnaW5hbFxuICAgIC8vIGFycmF5XG4gICAgaWYgKEVQQlBvc2l0aW9ucy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cblxuICAgIC8vIENyZWF0ZSBhIG5ldyBhcnJheSB0byBob2xkIHRoZSBOQUwgdW5pdCBkYXRhXG4gICAgbmV3TGVuZ3RoID0gbGVuZ3RoIC0gRVBCUG9zaXRpb25zLmxlbmd0aDtcbiAgICBuZXdEYXRhID0gbmV3IFVpbnQ4QXJyYXkobmV3TGVuZ3RoKTtcbiAgICB2YXIgc291cmNlSW5kZXggPSAwO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IG5ld0xlbmd0aDsgc291cmNlSW5kZXgrKywgaSsrKSB7XG4gICAgICBpZiAoc291cmNlSW5kZXggPT09IEVQQlBvc2l0aW9uc1swXSkge1xuICAgICAgICAvLyBTa2lwIHRoaXMgYnl0ZVxuICAgICAgICBzb3VyY2VJbmRleCsrO1xuICAgICAgICAvLyBSZW1vdmUgdGhpcyBwb3NpdGlvbiBpbmRleFxuICAgICAgICBFUEJQb3NpdGlvbnMuc2hpZnQoKTtcbiAgICAgIH1cbiAgICAgIG5ld0RhdGFbaV0gPSBkYXRhW3NvdXJjZUluZGV4XTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld0RhdGE7XG4gIH1cblxuICBfcGFyc2VBQUNQRVMocGVzKSB7XG4gICAgdmFyIHRyYWNrID0gdGhpcy5fYXVkaW9UcmFjayxcbiAgICAgICAgZGF0YSA9IHBlcy5kYXRhLFxuICAgICAgICBwdHMgPSBwZXMucHRzLFxuICAgICAgICBzdGFydE9mZnNldCA9IDAsXG4gICAgICAgIGFhY092ZXJGbG93ID0gdGhpcy5hYWNPdmVyRmxvdyxcbiAgICAgICAgYWFjTGFzdFBUUyA9IHRoaXMuYWFjTGFzdFBUUyxcbiAgICAgICAgY29uZmlnLCBmcmFtZUxlbmd0aCwgZnJhbWVEdXJhdGlvbiwgZnJhbWVJbmRleCwgb2Zmc2V0LCBoZWFkZXJMZW5ndGgsIHN0YW1wLCBsZW4sIGFhY1NhbXBsZTtcbiAgICBpZiAoYWFjT3ZlckZsb3cpIHtcbiAgICAgIHZhciB0bXAgPSBuZXcgVWludDhBcnJheShhYWNPdmVyRmxvdy5ieXRlTGVuZ3RoICsgZGF0YS5ieXRlTGVuZ3RoKTtcbiAgICAgIHRtcC5zZXQoYWFjT3ZlckZsb3csIDApO1xuICAgICAgdG1wLnNldChkYXRhLCBhYWNPdmVyRmxvdy5ieXRlTGVuZ3RoKTtcbiAgICAgIC8vbG9nZ2VyLmxvZyhgQUFDOiBhcHBlbmQgb3ZlcmZsb3dpbmcgJHthYWNPdmVyRmxvdy5ieXRlTGVuZ3RofSBieXRlcyB0byBiZWdpbm5pbmcgb2YgbmV3IFBFU2ApO1xuICAgICAgZGF0YSA9IHRtcDtcbiAgICB9XG4gICAgLy8gbG9vayBmb3IgQURUUyBoZWFkZXIgKDB4RkZGeClcbiAgICBmb3IgKG9mZnNldCA9IHN0YXJ0T2Zmc2V0LCBsZW4gPSBkYXRhLmxlbmd0aDsgb2Zmc2V0IDwgbGVuIC0gMTsgb2Zmc2V0KyspIHtcbiAgICAgIGlmICgoZGF0YVtvZmZzZXRdID09PSAweGZmKSAmJiAoZGF0YVtvZmZzZXQrMV0gJiAweGYwKSA9PT0gMHhmMCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gaWYgQURUUyBoZWFkZXIgZG9lcyBub3Qgc3RhcnQgc3RyYWlnaHQgZnJvbSB0aGUgYmVnaW5uaW5nIG9mIHRoZSBQRVMgcGF5bG9hZCwgcmFpc2UgYW4gZXJyb3JcbiAgICBpZiAob2Zmc2V0KSB7XG4gICAgICB2YXIgcmVhc29uLCBmYXRhbDtcbiAgICAgIGlmIChvZmZzZXQgPCBsZW4gLSAxKSB7XG4gICAgICAgIHJlYXNvbiA9IGBBQUMgUEVTIGRpZCBub3Qgc3RhcnQgd2l0aCBBRFRTIGhlYWRlcixvZmZzZXQ6JHtvZmZzZXR9YDtcbiAgICAgICAgZmF0YWwgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlYXNvbiA9ICdubyBBRFRTIGhlYWRlciBmb3VuZCBpbiBBQUMgUEVTJztcbiAgICAgICAgZmF0YWwgPSB0cnVlO1xuICAgICAgfVxuICAgICAgbG9nZ2VyLndhcm4oYHBhcnNpbmcgZXJyb3I6JHtyZWFzb259YCk7XG4gICAgICB0aGlzLm9ic2VydmVyLnRyaWdnZXIoRXZlbnQuRVJST1IsIHt0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLCBkZXRhaWxzOiBFcnJvckRldGFpbHMuRlJBR19QQVJTSU5HX0VSUk9SLCBmYXRhbDogZmF0YWwsIHJlYXNvbjogcmVhc29ufSk7XG4gICAgICBpZiAoZmF0YWwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXRyYWNrLnNhbXBsZXJhdGUpIHtcbiAgICAgIGNvbnN0IGF1ZGlvQ29kZWMgPSB0aGlzLmF1ZGlvQ29kZWM7XG4gICAgICBjb25maWcgPSBBRFRTLmdldEF1ZGlvQ29uZmlnKHRoaXMub2JzZXJ2ZXIsZGF0YSwgb2Zmc2V0LCBhdWRpb0NvZGVjKTtcbiAgICAgIHRyYWNrLmNvbmZpZyA9IGNvbmZpZy5jb25maWc7XG4gICAgICB0cmFjay5zYW1wbGVyYXRlID0gY29uZmlnLnNhbXBsZXJhdGU7XG4gICAgICB0cmFjay5jaGFubmVsQ291bnQgPSBjb25maWcuY2hhbm5lbENvdW50O1xuICAgICAgdHJhY2suY29kZWMgPSBjb25maWcuY29kZWM7XG4gICAgICB0cmFjay5tYW5pZmVzdENvZGVjID0gY29uZmlnLm1hbmlmZXN0Q29kZWM7XG4gICAgICB0cmFjay5kdXJhdGlvbiA9IHRoaXMuX2R1cmF0aW9uO1xuICAgICAgbG9nZ2VyLmxvZyhgcGFyc2VkIGNvZGVjOiR7dHJhY2suY29kZWN9LHJhdGU6JHtjb25maWcuc2FtcGxlcmF0ZX0sbmIgY2hhbm5lbDoke2NvbmZpZy5jaGFubmVsQ291bnR9YCk7XG4gICAgfVxuICAgIGZyYW1lSW5kZXggPSAwO1xuICAgIGZyYW1lRHVyYXRpb24gPSAxMDI0ICogOTAwMDAgLyB0cmFjay5zYW1wbGVyYXRlO1xuXG4gICAgLy8gaWYgbGFzdCBBQUMgZnJhbWUgaXMgb3ZlcmZsb3dpbmcsIHdlIHNob3VsZCBlbnN1cmUgdGltZXN0YW1wcyBhcmUgY29udGlndW91czpcbiAgICAvLyBmaXJzdCBzYW1wbGUgUFRTIHNob3VsZCBiZSBlcXVhbCB0byBsYXN0IHNhbXBsZSBQVFMgKyBmcmFtZUR1cmF0aW9uXG4gICAgaWYoYWFjT3ZlckZsb3cgJiYgYWFjTGFzdFBUUykge1xuICAgICAgdmFyIG5ld1BUUyA9IGFhY0xhc3RQVFMrZnJhbWVEdXJhdGlvbjtcbiAgICAgIGlmKE1hdGguYWJzKG5ld1BUUy1wdHMpID4gMSkge1xuICAgICAgICBsb2dnZXIubG9nKGBBQUM6IGFsaWduIFBUUyBmb3Igb3ZlcmxhcHBpbmcgZnJhbWVzIGJ5ICR7TWF0aC5yb3VuZCgobmV3UFRTLXB0cykvOTApfWApO1xuICAgICAgICBwdHM9bmV3UFRTO1xuICAgICAgfVxuICAgIH1cblxuICAgIHdoaWxlICgob2Zmc2V0ICsgNSkgPCBsZW4pIHtcbiAgICAgIC8vIFRoZSBwcm90ZWN0aW9uIHNraXAgYml0IHRlbGxzIHVzIGlmIHdlIGhhdmUgMiBieXRlcyBvZiBDUkMgZGF0YSBhdCB0aGUgZW5kIG9mIHRoZSBBRFRTIGhlYWRlclxuICAgICAgaGVhZGVyTGVuZ3RoID0gKCEhKGRhdGFbb2Zmc2V0ICsgMV0gJiAweDAxKSA/IDcgOiA5KTtcbiAgICAgIC8vIHJldHJpZXZlIGZyYW1lIHNpemVcbiAgICAgIGZyYW1lTGVuZ3RoID0gKChkYXRhW29mZnNldCArIDNdICYgMHgwMykgPDwgMTEpIHxcbiAgICAgICAgICAgICAgICAgICAgIChkYXRhW29mZnNldCArIDRdIDw8IDMpIHxcbiAgICAgICAgICAgICAgICAgICAgKChkYXRhW29mZnNldCArIDVdICYgMHhFMCkgPj4+IDUpO1xuICAgICAgZnJhbWVMZW5ndGggIC09IGhlYWRlckxlbmd0aDtcbiAgICAgIC8vc3RhbXAgPSBwZXMucHRzO1xuXG4gICAgICBpZiAoKGZyYW1lTGVuZ3RoID4gMCkgJiYgKChvZmZzZXQgKyBoZWFkZXJMZW5ndGggKyBmcmFtZUxlbmd0aCkgPD0gbGVuKSkge1xuICAgICAgICBzdGFtcCA9IHB0cyArIGZyYW1lSW5kZXggKiBmcmFtZUR1cmF0aW9uO1xuICAgICAgICAvL2xvZ2dlci5sb2coYEFBQyBmcmFtZSwgb2Zmc2V0L2xlbmd0aC90b3RhbC9wdHM6JHtvZmZzZXQraGVhZGVyTGVuZ3RofS8ke2ZyYW1lTGVuZ3RofS8ke2RhdGEuYnl0ZUxlbmd0aH0vJHsoc3RhbXAvOTApLnRvRml4ZWQoMCl9YCk7XG4gICAgICAgIGFhY1NhbXBsZSA9IHt1bml0OiBkYXRhLnN1YmFycmF5KG9mZnNldCArIGhlYWRlckxlbmd0aCwgb2Zmc2V0ICsgaGVhZGVyTGVuZ3RoICsgZnJhbWVMZW5ndGgpLCBwdHM6IHN0YW1wLCBkdHM6IHN0YW1wfTtcbiAgICAgICAgdHJhY2suc2FtcGxlcy5wdXNoKGFhY1NhbXBsZSk7XG4gICAgICAgIHRyYWNrLmxlbiArPSBmcmFtZUxlbmd0aDtcbiAgICAgICAgb2Zmc2V0ICs9IGZyYW1lTGVuZ3RoICsgaGVhZGVyTGVuZ3RoO1xuICAgICAgICBmcmFtZUluZGV4Kys7XG4gICAgICAgIC8vIGxvb2sgZm9yIEFEVFMgaGVhZGVyICgweEZGRngpXG4gICAgICAgIGZvciAoIDsgb2Zmc2V0IDwgKGxlbiAtIDEpOyBvZmZzZXQrKykge1xuICAgICAgICAgIGlmICgoZGF0YVtvZmZzZXRdID09PSAweGZmKSAmJiAoKGRhdGFbb2Zmc2V0ICsgMV0gJiAweGYwKSA9PT0gMHhmMCkpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvZmZzZXQgPCBsZW4pIHtcbiAgICAgIGFhY092ZXJGbG93ID0gZGF0YS5zdWJhcnJheShvZmZzZXQsIGxlbik7XG4gICAgICAvL2xvZ2dlci5sb2coYEFBQzogb3ZlcmZsb3cgZGV0ZWN0ZWQ6JHtsZW4tb2Zmc2V0fWApO1xuICAgIH0gZWxzZSB7XG4gICAgICBhYWNPdmVyRmxvdyA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMuYWFjT3ZlckZsb3cgPSBhYWNPdmVyRmxvdztcbiAgICB0aGlzLmFhY0xhc3RQVFMgPSBzdGFtcDtcbiAgfVxuXG4gIF9wYXJzZU1QRUdQRVMocGVzKSB7XG4gICAgdmFyIGRhdGEgPSBwZXMuZGF0YTtcbiAgICB2YXIgcHRzID0gcGVzLnB0cztcbiAgICB2YXIgbGVuZ3RoID0gZGF0YS5sZW5ndGg7XG4gICAgdmFyIGZyYW1lSW5kZXggPSAwO1xuICAgIHZhciBvZmZzZXQgPSAwO1xuICAgIHZhciBwYXJzZWQ7XG5cbiAgICB3aGlsZSAob2Zmc2V0IDwgbGVuZ3RoICYmXG4gICAgICAgIChwYXJzZWQgPSB0aGlzLl9wYXJzZU1wZWcoZGF0YSwgb2Zmc2V0LCBsZW5ndGgsIGZyYW1lSW5kZXgrKywgcHRzKSkgPiAwKSB7XG4gICAgICAgIG9mZnNldCArPSBwYXJzZWQ7XG4gICAgfVxuICB9XG5cbiAgX29uTXBlZ0ZyYW1lKGRhdGEsIGJpdFJhdGUsIHNhbXBsZVJhdGUsIGNoYW5uZWxDb3VudCwgZnJhbWVJbmRleCwgcHRzKSB7XG4gICAgdmFyIGZyYW1lRHVyYXRpb24gPSAoMTE1MiAvIHNhbXBsZVJhdGUpICogMTAwMDtcbiAgICB2YXIgc3RhbXAgPSBwdHMgKyBmcmFtZUluZGV4ICogZnJhbWVEdXJhdGlvbjtcbiAgICB2YXIgdHJhY2sgPSB0aGlzLl9hdWRpb1RyYWNrO1xuXG4gICAgdHJhY2suY29uZmlnID0gW107XG4gICAgdHJhY2suY2hhbm5lbENvdW50ID0gY2hhbm5lbENvdW50O1xuICAgIHRyYWNrLnNhbXBsZXJhdGUgPSBzYW1wbGVSYXRlO1xuICAgIHRyYWNrLmR1cmF0aW9uID0gdGhpcy5fZHVyYXRpb247XG4gICAgdHJhY2suc2FtcGxlcy5wdXNoKHt1bml0OiBkYXRhLCBwdHM6IHN0YW1wLCBkdHM6IHN0YW1wfSk7XG4gICAgdHJhY2subGVuICs9IGRhdGEubGVuZ3RoO1xuICB9XG5cbiAgX29uTXBlZ05vaXNlKGRhdGEpIHtcbiAgICBsb2dnZXIud2FybignbXBlZyBhdWRpbyBoYXMgbm9pc2U6ICcgKyBkYXRhLmxlbmd0aCArICcgYnl0ZXMnKTtcbiAgfVxuXG4gIF9wYXJzZU1wZWcoZGF0YSwgc3RhcnQsIGVuZCwgZnJhbWVJbmRleCwgcHRzKSB7XG4gICAgdmFyIEJpdHJhdGVzTWFwID0gW1xuICAgICAgICAzMiwgNjQsIDk2LCAxMjgsIDE2MCwgMTkyLCAyMjQsIDI1NiwgMjg4LCAzMjAsIDM1MiwgMzg0LCA0MTYsIDQ0OCxcbiAgICAgICAgMzIsIDQ4LCA1NiwgNjQsIDgwLCA5NiwgMTEyLCAxMjgsIDE2MCwgMTkyLCAyMjQsIDI1NiwgMzIwLCAzODQsXG4gICAgICAgIDMyLCA0MCwgNDgsIDU2LCA2NCwgODAsIDk2LCAxMTIsIDEyOCwgMTYwLCAxOTIsIDIyNCwgMjU2LCAzMjAsXG4gICAgICAgIDMyLCA0OCwgNTYsIDY0LCA4MCwgOTYsIDExMiwgMTI4LCAxNDQsIDE2MCwgMTc2LCAxOTIsIDIyNCwgMjU2LFxuICAgICAgICA4LCAxNiwgMjQsIDMyLCA0MCwgNDgsIDU2LCA2NCwgODAsIDk2LCAxMTIsIDEyOCwgMTQ0LCAxNjBdO1xuICAgIHZhciBTYW1wbGluZ1JhdGVNYXAgPSBbNDQxMDAsIDQ4MDAwLCAzMjAwMCwgMjIwNTAsIDI0MDAwLCAxNjAwMCwgMTEwMjUsIDEyMDAwLCA4MDAwXTtcblxuICAgIGlmIChzdGFydCArIDIgPiBlbmQpIHtcbiAgICAgICAgcmV0dXJuIC0xOyAvLyB3ZSBuZWVkIGF0IGxlYXN0IDIgYnl0ZXMgdG8gZGV0ZWN0IHN5bmMgcGF0dGVyblxuICAgIH1cbiAgICBpZiAoZGF0YVtzdGFydF0gPT09IDB4RkYgfHwgKGRhdGFbc3RhcnQgKyAxXSAmIDB4RTApID09PSAweEUwKSB7XG4gICAgICAgIC8vIFVzaW5nIGh0dHA6Ly93d3cuZGF0YXZveWFnZS5jb20vbXBnc2NyaXB0L21wZWdoZHIuaHRtIGFzIGEgcmVmZXJlbmNlXG4gICAgICAgIGlmIChzdGFydCArIDI0ID4gZW5kKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGhlYWRlckIgPSAoZGF0YVtzdGFydCArIDFdID4+IDMpICYgMztcbiAgICAgICAgdmFyIGhlYWRlckMgPSAoZGF0YVtzdGFydCArIDFdID4+IDEpICYgMztcbiAgICAgICAgdmFyIGhlYWRlckUgPSAoZGF0YVtzdGFydCArIDJdID4+IDQpICYgMTU7XG4gICAgICAgIHZhciBoZWFkZXJGID0gKGRhdGFbc3RhcnQgKyAyXSA+PiAyKSAmIDM7XG4gICAgICAgIHZhciBoZWFkZXJHID0gISEoZGF0YVtzdGFydCArIDJdICYgMik7XG4gICAgICAgIGlmIChoZWFkZXJCICE9PSAxICYmIGhlYWRlckUgIT09IDAgJiYgaGVhZGVyRSAhPT0gMTUgJiYgaGVhZGVyRiAhPT0gMykge1xuICAgICAgICAgICAgdmFyIGNvbHVtbkluQml0cmF0ZXMgPSBoZWFkZXJCID09PSAzID8gKDMgLSBoZWFkZXJDKSA6IChoZWFkZXJDID09PSAzID8gMyA6IDQpO1xuICAgICAgICAgICAgdmFyIGJpdFJhdGUgPSBCaXRyYXRlc01hcFtjb2x1bW5JbkJpdHJhdGVzICogMTQgKyBoZWFkZXJFIC0gMV0gKiAxMDAwO1xuICAgICAgICAgICAgdmFyIGNvbHVtbkluU2FtcGxlUmF0ZXMgPSBoZWFkZXJCID09PSAzID8gMCA6IGhlYWRlckIgPT09IDIgPyAxIDogMjtcbiAgICAgICAgICAgIHZhciBzYW1wbGVSYXRlID0gU2FtcGxpbmdSYXRlTWFwW2NvbHVtbkluU2FtcGxlUmF0ZXMgKiAzICsgaGVhZGVyRl07XG4gICAgICAgICAgICB2YXIgcGFkZGluZyA9IGhlYWRlckcgPyAxIDogMDtcbiAgICAgICAgICAgIHZhciBjaGFubmVsQ291bnQgPSBkYXRhW3N0YXJ0ICsgM10gPj4gNiA9PT0gMyA/IDEgOiAyOyAvLyBJZiBiaXRzIG9mIGNoYW5uZWwgbW9kZSBhcmUgYDExYCB0aGVuIGl0IGlzIGEgc2luZ2xlIGNoYW5uZWwgKE1vbm8pXG4gICAgICAgICAgICB2YXIgZnJhbWVMZW5ndGggPSBoZWFkZXJDID09PSAzID9cbiAgICAgICAgICAgICAgICAoKGhlYWRlckIgPT09IDMgPyAxMiA6IDYpICogYml0UmF0ZSAvIHNhbXBsZVJhdGUgKyBwYWRkaW5nKSA8PCAyIDpcbiAgICAgICAgICAgICAgICAoKGhlYWRlckIgPT09IDMgPyAxNDQgOiA3MikgKiBiaXRSYXRlIC8gc2FtcGxlUmF0ZSArIHBhZGRpbmcpIHwgMDtcbiAgICAgICAgICAgIGlmIChzdGFydCArIGZyYW1lTGVuZ3RoID4gZW5kKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX29uTXBlZ0ZyYW1lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fb25NcGVnRnJhbWUoZGF0YS5zdWJhcnJheShzdGFydCwgc3RhcnQgKyBmcmFtZUxlbmd0aCksIGJpdFJhdGUsIHNhbXBsZVJhdGUsIGNoYW5uZWxDb3VudCwgZnJhbWVJbmRleCwgcHRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmcmFtZUxlbmd0aDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBub2lzZSBvciBJRDMsIHRyeWluZyB0byBza2lwXG4gICAgdmFyIG9mZnNldCA9IHN0YXJ0ICsgMjtcbiAgICB3aGlsZSAob2Zmc2V0IDwgZW5kKSB7XG4gICAgICAgIGlmIChkYXRhW29mZnNldCAtIDFdID09PSAweEZGICYmIChkYXRhW29mZnNldF0gJiAweEUwKSA9PT0gMHhFMCkge1xuICAgICAgICAgICAgLy8gc3luYyBwYXR0ZXJuIGlzIGZvdW5kXG4gICAgICAgICAgICBpZiAodGhpcy5fb25NcGVnTm9pc2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9vbk1wZWdOb2lzZShkYXRhLnN1YmFycmF5KHN0YXJ0LCBvZmZzZXQgLSAxKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb2Zmc2V0IC0gc3RhcnQgLSAxO1xuICAgICAgICB9XG4gICAgICAgIG9mZnNldCsrO1xuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICBfcGFyc2VJRDNQRVMocGVzKSB7XG4gICAgdGhpcy5faWQzVHJhY2suc2FtcGxlcy5wdXNoKHBlcyk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgVFNEZW11eGVyO1xuIiwiZXhwb3J0IGNvbnN0IEVycm9yVHlwZXMgPSB7XG4gIC8vIElkZW50aWZpZXIgZm9yIGEgbmV0d29yayBlcnJvciAobG9hZGluZyBlcnJvciAvIHRpbWVvdXQgLi4uKVxuICBORVRXT1JLX0VSUk9SOiAnbmV0d29ya0Vycm9yJyxcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBtZWRpYSBFcnJvciAodmlkZW8vcGFyc2luZy9tZWRpYXNvdXJjZSBlcnJvcilcbiAgTUVESUFfRVJST1I6ICdtZWRpYUVycm9yJyxcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBtdXggRXJyb3IgKGRlbXV4aW5nL3JlbXV4aW5nKVxuICBNVVhfRVJST1I6ICdtdXhFcnJvcicsXG4gIC8vIElkZW50aWZpZXIgZm9yIGFsbCBvdGhlciBlcnJvcnNcbiAgT1RIRVJfRVJST1I6ICdvdGhlckVycm9yJ1xufTtcblxuZXhwb3J0IGNvbnN0IEVycm9yRGV0YWlscyA9IHtcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBtYW5pZmVzdCBsb2FkIGVycm9yIC0gZGF0YTogeyB1cmwgOiBmYXVsdHkgVVJMLCByZXNwb25zZSA6IHsgY29kZTogZXJyb3IgY29kZSwgdGV4dDogZXJyb3IgdGV4dCB9fVxuICBNQU5JRkVTVF9MT0FEX0VSUk9SOiAnbWFuaWZlc3RMb2FkRXJyb3InLFxuICAvLyBJZGVudGlmaWVyIGZvciBhIG1hbmlmZXN0IGxvYWQgdGltZW91dCAtIGRhdGE6IHsgdXJsIDogZmF1bHR5IFVSTCwgcmVzcG9uc2UgOiB7IGNvZGU6IGVycm9yIGNvZGUsIHRleHQ6IGVycm9yIHRleHQgfX1cbiAgTUFOSUZFU1RfTE9BRF9USU1FT1VUOiAnbWFuaWZlc3RMb2FkVGltZU91dCcsXG4gIC8vIElkZW50aWZpZXIgZm9yIGEgbWFuaWZlc3QgcGFyc2luZyBlcnJvciAtIGRhdGE6IHsgdXJsIDogZmF1bHR5IFVSTCwgcmVhc29uIDogZXJyb3IgcmVhc29ufVxuICBNQU5JRkVTVF9QQVJTSU5HX0VSUk9SOiAnbWFuaWZlc3RQYXJzaW5nRXJyb3InLFxuICAvLyBJZGVudGlmaWVyIGZvciBhIG1hbmlmZXN0IHdpdGggb25seSBpbmNvbXBhdGlibGUgY29kZWNzIGVycm9yIC0gZGF0YTogeyB1cmwgOiBmYXVsdHkgVVJMLCByZWFzb24gOiBlcnJvciByZWFzb259XG4gIE1BTklGRVNUX0lOQ09NUEFUSUJMRV9DT0RFQ1NfRVJST1I6ICdtYW5pZmVzdEluY29tcGF0aWJsZUNvZGVjc0Vycm9yJyxcbiAgLy9cbiAgTUFOSUZFU1RfRU1QVFlfRVJST1I6ICdtYW5pZmVzdEVtcHR5RXJyb3InLFxuICAvLyBJZGVudGlmaWVyIGZvciBhIGxldmVsIGxvYWQgZXJyb3IgLSBkYXRhOiB7IHVybCA6IGZhdWx0eSBVUkwsIHJlc3BvbnNlIDogeyBjb2RlOiBlcnJvciBjb2RlLCB0ZXh0OiBlcnJvciB0ZXh0IH19XG4gIExFVkVMX0xPQURfRVJST1I6ICdsZXZlbExvYWRFcnJvcicsXG4gIC8vIElkZW50aWZpZXIgZm9yIGEgbGV2ZWwgbG9hZCB0aW1lb3V0IC0gZGF0YTogeyB1cmwgOiBmYXVsdHkgVVJMLCByZXNwb25zZSA6IHsgY29kZTogZXJyb3IgY29kZSwgdGV4dDogZXJyb3IgdGV4dCB9fVxuICBMRVZFTF9MT0FEX1RJTUVPVVQ6ICdsZXZlbExvYWRUaW1lT3V0JyxcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBsZXZlbCBzd2l0Y2ggZXJyb3IgLSBkYXRhOiB7IGxldmVsIDogZmF1bHR5IGxldmVsIElkLCBldmVudCA6IGVycm9yIGRlc2NyaXB0aW9ufVxuICBMRVZFTF9TV0lUQ0hfRVJST1I6ICdsZXZlbFN3aXRjaEVycm9yJyxcbiAgLy8gSWRlbnRpZmllciBmb3IgYW4gYXVkaW8gdHJhY2sgbG9hZCBlcnJvciAtIGRhdGE6IHsgdXJsIDogZmF1bHR5IFVSTCwgcmVzcG9uc2UgOiB7IGNvZGU6IGVycm9yIGNvZGUsIHRleHQ6IGVycm9yIHRleHQgfX1cbiAgQVVESU9fVFJBQ0tfTE9BRF9FUlJPUjogJ2F1ZGlvVHJhY2tMb2FkRXJyb3InLFxuICAvLyBJZGVudGlmaWVyIGZvciBhbiBhdWRpbyB0cmFjayBsb2FkIHRpbWVvdXQgLSBkYXRhOiB7IHVybCA6IGZhdWx0eSBVUkwsIHJlc3BvbnNlIDogeyBjb2RlOiBlcnJvciBjb2RlLCB0ZXh0OiBlcnJvciB0ZXh0IH19XG4gIEFVRElPX1RSQUNLX0xPQURfVElNRU9VVDogJ2F1ZGlvVHJhY2tMb2FkVGltZU91dCcsXG4gIC8vIElkZW50aWZpZXIgZm9yIGZyYWdtZW50IGxvYWQgZXJyb3IgLSBkYXRhOiB7IGZyYWcgOiBmcmFnbWVudCBvYmplY3QsIHJlc3BvbnNlIDogeyBjb2RlOiBlcnJvciBjb2RlLCB0ZXh0OiBlcnJvciB0ZXh0IH19XG4gIEZSQUdfTE9BRF9FUlJPUjogJ2ZyYWdMb2FkRXJyb3InLFxuICAvLyBJZGVudGlmaWVyIGZvciBmcmFnbWVudCBsb29wIGxvYWRpbmcgZXJyb3IgLSBkYXRhOiB7IGZyYWcgOiBmcmFnbWVudCBvYmplY3R9XG4gIEZSQUdfTE9PUF9MT0FESU5HX0VSUk9SOiAnZnJhZ0xvb3BMb2FkaW5nRXJyb3InLFxuICAvLyBJZGVudGlmaWVyIGZvciBmcmFnbWVudCBsb2FkIHRpbWVvdXQgZXJyb3IgLSBkYXRhOiB7IGZyYWcgOiBmcmFnbWVudCBvYmplY3R9XG4gIEZSQUdfTE9BRF9USU1FT1VUOiAnZnJhZ0xvYWRUaW1lT3V0JyxcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBmcmFnbWVudCBkZWNyeXB0aW9uIGVycm9yIGV2ZW50IC0gZGF0YToge2lkIDogZGVtdXhlciBJZCxmcmFnOiBmcmFnbWVudCBvYmplY3QsIHJlYXNvbiA6IHBhcnNpbmcgZXJyb3IgZGVzY3JpcHRpb24gfVxuICBGUkFHX0RFQ1JZUFRfRVJST1I6ICdmcmFnRGVjcnlwdEVycm9yJyxcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBmcmFnbWVudCBwYXJzaW5nIGVycm9yIGV2ZW50IC0gZGF0YTogeyBpZCA6IGRlbXV4ZXIgSWQsIHJlYXNvbiA6IHBhcnNpbmcgZXJyb3IgZGVzY3JpcHRpb24gfVxuICAvLyB3aWxsIGJlIHJlbmFtZWQgREVNVVhfUEFSU0lOR19FUlJPUiBhbmQgc3dpdGNoZWQgdG8gTVVYX0VSUk9SIGluIHRoZSBuZXh0IG1ham9yIHJlbGVhc2VcbiAgRlJBR19QQVJTSU5HX0VSUk9SOiAnZnJhZ1BhcnNpbmdFcnJvcicsXG4gIC8vIElkZW50aWZpZXIgZm9yIGEgcmVtdXggYWxsb2MgZXJyb3IgZXZlbnQgLSBkYXRhOiB7IGlkIDogZGVtdXhlciBJZCwgZnJhZyA6IGZyYWdtZW50IG9iamVjdCwgYnl0ZXMgOiBuYiBvZiBieXRlcyBvbiB3aGljaCBhbGxvY2F0aW9uIGZhaWxlZCAsIHJlYXNvbiA6IGVycm9yIHRleHQgfVxuICBSRU1VWF9BTExPQ19FUlJPUiA6ICdyZW11eEFsbG9jRXJyb3InLFxuICAvLyBJZGVudGlmaWVyIGZvciBkZWNyeXB0IGtleSBsb2FkIGVycm9yIC0gZGF0YTogeyBmcmFnIDogZnJhZ21lbnQgb2JqZWN0LCByZXNwb25zZSA6IHsgY29kZTogZXJyb3IgY29kZSwgdGV4dDogZXJyb3IgdGV4dCB9fVxuICBLRVlfTE9BRF9FUlJPUjogJ2tleUxvYWRFcnJvcicsXG4gIC8vIElkZW50aWZpZXIgZm9yIGRlY3J5cHQga2V5IGxvYWQgdGltZW91dCBlcnJvciAtIGRhdGE6IHsgZnJhZyA6IGZyYWdtZW50IG9iamVjdH1cbiAgS0VZX0xPQURfVElNRU9VVDogJ2tleUxvYWRUaW1lT3V0JyxcbiAgLy8gVHJpZ2dlcmVkIHdoZW4gYW4gZXhjZXB0aW9uIG9jY3VycyB3aGlsZSBhZGRpbmcgYSBzb3VyY2VCdWZmZXIgdG8gTWVkaWFTb3VyY2UgLSBkYXRhIDogeyAgZXJyIDogZXhjZXB0aW9uICwgbWltZVR5cGUgOiBtaW1lVHlwZSB9XG4gIEJVRkZFUl9BRERfQ09ERUNfRVJST1I6ICdidWZmZXJBZGRDb2RlY0Vycm9yJyxcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBidWZmZXIgYXBwZW5kIGVycm9yIC0gZGF0YTogYXBwZW5kIGVycm9yIGRlc2NyaXB0aW9uXG4gIEJVRkZFUl9BUFBFTkRfRVJST1I6ICdidWZmZXJBcHBlbmRFcnJvcicsXG4gIC8vIElkZW50aWZpZXIgZm9yIGEgYnVmZmVyIGFwcGVuZGluZyBlcnJvciBldmVudCAtIGRhdGE6IGFwcGVuZGluZyBlcnJvciBkZXNjcmlwdGlvblxuICBCVUZGRVJfQVBQRU5ESU5HX0VSUk9SOiAnYnVmZmVyQXBwZW5kaW5nRXJyb3InLFxuICAvLyBJZGVudGlmaWVyIGZvciBhIGJ1ZmZlciBzdGFsbGVkIGVycm9yIGV2ZW50XG4gIEJVRkZFUl9TVEFMTEVEX0VSUk9SOiAnYnVmZmVyU3RhbGxlZEVycm9yJyxcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBidWZmZXIgZnVsbCBldmVudFxuICBCVUZGRVJfRlVMTF9FUlJPUjogJ2J1ZmZlckZ1bGxFcnJvcicsXG4gIC8vIElkZW50aWZpZXIgZm9yIGEgYnVmZmVyIHNlZWsgb3ZlciBob2xlIGV2ZW50XG4gIEJVRkZFUl9TRUVLX09WRVJfSE9MRTogJ2J1ZmZlclNlZWtPdmVySG9sZScsXG4gIC8vIElkZW50aWZpZXIgZm9yIGEgYnVmZmVyIG51ZGdlIG9uIHN0YWxsIChwbGF5YmFjayBpcyBzdHVjayBhbHRob3VnaCBjdXJyZW50VGltZSBpcyBpbiBhIGJ1ZmZlcmVkIGFyZWEpXG4gIEJVRkZFUl9OVURHRV9PTl9TVEFMTCA6ICdidWZmZXJOdWRnZU9uU3RhbGwnLFxuICAvLyBJZGVudGlmaWVyIGZvciBhbiBpbnRlcm5hbCBleGNlcHRpb24gaGFwcGVuaW5nIGluc2lkZSBobHMuanMgd2hpbGUgaGFuZGxpbmcgYW4gZXZlbnRcbiAgSU5URVJOQUxfRVhDRVBUSU9OOiAnaW50ZXJuYWxFeGNlcHRpb24nLFxuICAvLyBNYWxmb3JtZWQgV2ViVlRUIGNvbnRlbnRzXG4gIFdFQlZUVF9FWENFUFRJT046ICd3ZWJWVFRFeGNlcHRpb24nXG59O1xuIiwiLypcbipcbiogQWxsIG9iamVjdHMgaW4gdGhlIGV2ZW50IGhhbmRsaW5nIGNoYWluIHNob3VsZCBpbmhlcml0IGZyb20gdGhpcyBjbGFzc1xuKlxuKi9cblxuaW1wb3J0IHtsb2dnZXJ9IGZyb20gJy4vdXRpbHMvbG9nZ2VyJztcbmltcG9ydCB7RXJyb3JUeXBlcywgRXJyb3JEZXRhaWxzfSBmcm9tICcuL2Vycm9ycyc7XG5pbXBvcnQgRXZlbnQgZnJvbSAnLi9ldmVudHMnO1xuXG5jbGFzcyBFdmVudEhhbmRsZXIge1xuXG4gIGNvbnN0cnVjdG9yKGhscywgLi4uZXZlbnRzKSB7XG4gICAgdGhpcy5obHMgPSBobHM7XG4gICAgdGhpcy5vbkV2ZW50ID0gdGhpcy5vbkV2ZW50LmJpbmQodGhpcyk7XG4gICAgdGhpcy5oYW5kbGVkRXZlbnRzID0gZXZlbnRzO1xuICAgIHRoaXMudXNlR2VuZXJpY0hhbmRsZXIgPSB0cnVlO1xuXG4gICAgdGhpcy5yZWdpc3Rlckxpc3RlbmVycygpO1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnVucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgfVxuXG4gIGlzRXZlbnRIYW5kbGVyKCkge1xuICAgIHJldHVybiB0eXBlb2YgdGhpcy5oYW5kbGVkRXZlbnRzID09PSAnb2JqZWN0JyAmJiB0aGlzLmhhbmRsZWRFdmVudHMubGVuZ3RoICYmIHR5cGVvZiB0aGlzLm9uRXZlbnQgPT09ICdmdW5jdGlvbic7XG4gIH1cblxuICByZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICBpZiAodGhpcy5pc0V2ZW50SGFuZGxlcigpKSB7XG4gICAgICB0aGlzLmhhbmRsZWRFdmVudHMuZm9yRWFjaChmdW5jdGlvbihldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQgPT09ICdobHNFdmVudEdlbmVyaWMnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGb3JiaWRkZW4gZXZlbnQgbmFtZTogJyArIGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhscy5vbihldmVudCwgdGhpcy5vbkV2ZW50KTtcbiAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgfVxuICB9XG5cbiAgdW5yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICBpZiAodGhpcy5pc0V2ZW50SGFuZGxlcigpKSB7XG4gICAgICB0aGlzLmhhbmRsZWRFdmVudHMuZm9yRWFjaChmdW5jdGlvbihldmVudCkge1xuICAgICAgICB0aGlzLmhscy5vZmYoZXZlbnQsIHRoaXMub25FdmVudCk7XG4gICAgICB9LmJpbmQodGhpcykpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBhcmd1bWVudHM6IGV2ZW50IChzdHJpbmcpLCBkYXRhIChhbnkpXG4gICAqL1xuICBvbkV2ZW50KGV2ZW50LCBkYXRhKSB7XG4gICAgdGhpcy5vbkV2ZW50R2VuZXJpYyhldmVudCwgZGF0YSk7XG4gIH1cblxuICBvbkV2ZW50R2VuZXJpYyhldmVudCwgZGF0YSkge1xuICAgIHZhciBldmVudFRvRnVuY3Rpb24gPSBmdW5jdGlvbihldmVudCwgZGF0YSkge1xuICAgICAgdmFyIGZ1bmNOYW1lID0gJ29uJyArIGV2ZW50LnJlcGxhY2UoJ2hscycsICcnKTtcbiAgICAgIGlmICh0eXBlb2YgdGhpc1tmdW5jTmFtZV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFdmVudCAke2V2ZW50fSBoYXMgbm8gZ2VuZXJpYyBoYW5kbGVyIGluIHRoaXMgJHt0aGlzLmNvbnN0cnVjdG9yLm5hbWV9IGNsYXNzICh0cmllZCAke2Z1bmNOYW1lfSlgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzW2Z1bmNOYW1lXS5iaW5kKHRoaXMsIGRhdGEpO1xuICAgIH07XG4gICAgdHJ5IHtcbiAgICAgIGV2ZW50VG9GdW5jdGlvbi5jYWxsKHRoaXMsIGV2ZW50LCBkYXRhKS5jYWxsKCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBsb2dnZXIuZXJyb3IoYGludGVybmFsIGVycm9yIGhhcHBlbmVkIHdoaWxlIHByb2Nlc3NpbmcgJHtldmVudH06JHtlcnIubWVzc2FnZX1gKTtcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuRVJST1IsIHt0eXBlOiBFcnJvclR5cGVzLk9USEVSX0VSUk9SLCBkZXRhaWxzOiBFcnJvckRldGFpbHMuSU5URVJOQUxfRVhDRVBUSU9OLCBmYXRhbDogZmFsc2UsIGV2ZW50IDogZXZlbnQsIGVyciA6IGVycn0pO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBFdmVudEhhbmRsZXI7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgLy8gZmlyZWQgYmVmb3JlIE1lZGlhU291cmNlIGlzIGF0dGFjaGluZyB0byBtZWRpYSBlbGVtZW50IC0gZGF0YTogeyBtZWRpYSB9XG4gIE1FRElBX0FUVEFDSElORzogJ2hsc01lZGlhQXR0YWNoaW5nJyxcbiAgLy8gZmlyZWQgd2hlbiBNZWRpYVNvdXJjZSBoYXMgYmVlbiBzdWNjZXNmdWxseSBhdHRhY2hlZCB0byBtZWRpYSBlbGVtZW50IC0gZGF0YTogeyB9XG4gIE1FRElBX0FUVEFDSEVEOiAnaGxzTWVkaWFBdHRhY2hlZCcsXG4gIC8vIGZpcmVkIGJlZm9yZSBkZXRhY2hpbmcgTWVkaWFTb3VyY2UgZnJvbSBtZWRpYSBlbGVtZW50IC0gZGF0YTogeyB9XG4gIE1FRElBX0RFVEFDSElORzogJ2hsc01lZGlhRGV0YWNoaW5nJyxcbiAgLy8gZmlyZWQgd2hlbiBNZWRpYVNvdXJjZSBoYXMgYmVlbiBkZXRhY2hlZCBmcm9tIG1lZGlhIGVsZW1lbnQgLSBkYXRhOiB7IH1cbiAgTUVESUFfREVUQUNIRUQ6ICdobHNNZWRpYURldGFjaGVkJyxcbiAgLy8gZmlyZWQgd2hlbiB3ZSBidWZmZXIgaXMgZ29pbmcgdG8gYmUgcmVzZXR0ZWRcbiAgQlVGRkVSX1JFU0VUOiAnaGxzQnVmZmVyUmVzZXQnLFxuICAvLyBmaXJlZCB3aGVuIHdlIGtub3cgYWJvdXQgdGhlIGNvZGVjcyB0aGF0IHdlIG5lZWQgYnVmZmVycyBmb3IgdG8gcHVzaCBpbnRvIC0gZGF0YToge3RyYWNrcyA6IHsgY29udGFpbmVyLCBjb2RlYywgbGV2ZWxDb2RlYywgaW5pdFNlZ21lbnQsIG1ldGFkYXRhIH19XG4gIEJVRkZFUl9DT0RFQ1M6ICdobHNCdWZmZXJDb2RlY3MnLFxuICAvLyBmaXJlZCB3aGVuIHNvdXJjZWJ1ZmZlcnMgaGF2ZSBiZWVuIGNyZWF0ZWQgZGF0YTogeyB0cmFja3MgOiB0cmFja3N9XG4gIEJVRkZFUl9DUkVBVEVEOiAnaGxzQnVmZmVyQ3JlYXRlZCcsXG4gIC8vIGZpcmVkIHdoZW4gd2UgYXBwZW5kIGEgc2VnbWVudCB0byB0aGUgYnVmZmVyIC0gZGF0YTogeyBzZWdtZW50OiBzZWdtZW50IG9iamVjdCB9XG4gIEJVRkZFUl9BUFBFTkRJTkc6ICdobHNCdWZmZXJBcHBlbmRpbmcnLFxuICAvLyBmaXJlZCB3aGVuIHdlIGFyZSBkb25lIHdpdGggYXBwZW5kaW5nIGEgbWVkaWEgc2VnbWVudCB0byB0aGUgYnVmZmVyIGRhdGEgOiB7IHBhcmVudCA6IHNlZ21lbnQgcGFyZW50IHRoYXQgdHJpZ2dlcmVkIEJVRkZFUl9BUFBFTkRJTkcgLCBwZW5kaW5nIDogbmIgb2Ygc2VnbWVudHMgd2FpdGluZyBmb3IgYXBwZW5kaW5nIGZvciB0aGlzIHNlZ21lbnQgcGFyZW50fVxuICBCVUZGRVJfQVBQRU5ERUQ6ICdobHNCdWZmZXJBcHBlbmRlZCcsXG4gIC8vIGZpcmVkIHdoZW4gdGhlIHN0cmVhbSBpcyBmaW5pc2hlZCBhbmQgd2Ugd2FudCB0byBub3RpZnkgdGhlIG1lZGlhIGJ1ZmZlciB0aGF0IHRoZXJlIHdpbGwgYmUgbm8gbW9yZSBkYXRhXG4gIEJVRkZFUl9FT1M6ICdobHNCdWZmZXJFb3MnLFxuICAvLyBmaXJlZCB3aGVuIHRoZSBtZWRpYSBidWZmZXIgc2hvdWxkIGJlIGZsdXNoZWQgLSBkYXRhIHtzdGFydE9mZnNldCwgZW5kT2Zmc2V0fVxuICBCVUZGRVJfRkxVU0hJTkc6ICdobHNCdWZmZXJGbHVzaGluZycsXG4gIC8vIGZpcmVkIHdoZW4gdGhlIG1lZGlhIGhhcyBiZWVuIGZsdXNoZWRcbiAgQlVGRkVSX0ZMVVNIRUQ6ICdobHNCdWZmZXJGbHVzaGVkJyxcbiAgLy8gZmlyZWQgdG8gc2lnbmFsIHRoYXQgYSBtYW5pZmVzdCBsb2FkaW5nIHN0YXJ0cyAtIGRhdGE6IHsgdXJsIDogbWFuaWZlc3RVUkx9XG4gIE1BTklGRVNUX0xPQURJTkc6ICdobHNNYW5pZmVzdExvYWRpbmcnLFxuICAvLyBmaXJlZCBhZnRlciBtYW5pZmVzdCBoYXMgYmVlbiBsb2FkZWQgLSBkYXRhOiB7IGxldmVscyA6IFthdmFpbGFibGUgcXVhbGl0eSBsZXZlbHNdICwgYXVkaW9UcmFja3MgOiBbIGF2YWlsYWJsZSBhdWRpbyB0cmFja3NdLCB1cmwgOiBtYW5pZmVzdFVSTCwgc3RhdHMgOiB7IHRyZXF1ZXN0LCB0Zmlyc3QsIHRsb2FkLCBtdGltZX19XG4gIE1BTklGRVNUX0xPQURFRDogJ2hsc01hbmlmZXN0TG9hZGVkJyxcbiAgLy8gZmlyZWQgYWZ0ZXIgbWFuaWZlc3QgaGFzIGJlZW4gcGFyc2VkIC0gZGF0YTogeyBsZXZlbHMgOiBbYXZhaWxhYmxlIHF1YWxpdHkgbGV2ZWxzXSAsIGZpcnN0TGV2ZWwgOiBpbmRleCBvZiBmaXJzdCBxdWFsaXR5IGxldmVsIGFwcGVhcmluZyBpbiBNYW5pZmVzdH1cbiAgTUFOSUZFU1RfUEFSU0VEOiAnaGxzTWFuaWZlc3RQYXJzZWQnLFxuICAvLyBmaXJlZCB3aGVuIGEgbGV2ZWwgc3dpdGNoIGlzIHJlcXVlc3RlZCAtIGRhdGE6IHsgbGV2ZWwgOiBpZCBvZiBuZXcgbGV2ZWwgfSAvLyBkZXByZWNhdGVkIGluIGZhdm9yIExFVkVMX1NXSVRDSElOR1xuICBMRVZFTF9TV0lUQ0g6ICdobHNMZXZlbFN3aXRjaCcsXG4gIC8vIGZpcmVkIHdoZW4gYSBsZXZlbCBzd2l0Y2ggaXMgcmVxdWVzdGVkIC0gZGF0YTogeyBsZXZlbCA6IGlkIG9mIG5ldyBsZXZlbCB9XG4gIExFVkVMX1NXSVRDSElORzogJ2hsc0xldmVsU3dpdGNoaW5nJyxcbiAgLy8gZmlyZWQgd2hlbiBhIGxldmVsIHN3aXRjaCBpcyBlZmZlY3RpdmUgLSBkYXRhOiB7IGxldmVsIDogaWQgb2YgbmV3IGxldmVsIH1cbiAgTEVWRUxfU1dJVENIRUQ6ICdobHNMZXZlbFN3aXRjaGVkJyxcbiAgLy8gZmlyZWQgd2hlbiBhIGxldmVsIHBsYXlsaXN0IGxvYWRpbmcgc3RhcnRzIC0gZGF0YTogeyB1cmwgOiBsZXZlbCBVUkwgIGxldmVsIDogaWQgb2YgbGV2ZWwgYmVpbmcgbG9hZGVkfVxuICBMRVZFTF9MT0FESU5HOiAnaGxzTGV2ZWxMb2FkaW5nJyxcbiAgLy8gZmlyZWQgd2hlbiBhIGxldmVsIHBsYXlsaXN0IGxvYWRpbmcgZmluaXNoZXMgLSBkYXRhOiB7IGRldGFpbHMgOiBsZXZlbERldGFpbHMgb2JqZWN0LCBsZXZlbCA6IGlkIG9mIGxvYWRlZCBsZXZlbCwgc3RhdHMgOiB7IHRyZXF1ZXN0LCB0Zmlyc3QsIHRsb2FkLCBtdGltZX0gfVxuICBMRVZFTF9MT0FERUQ6ICdobHNMZXZlbExvYWRlZCcsXG4gIC8vIGZpcmVkIHdoZW4gYSBsZXZlbCdzIGRldGFpbHMgaGF2ZSBiZWVuIHVwZGF0ZWQgYmFzZWQgb24gcHJldmlvdXMgZGV0YWlscywgYWZ0ZXIgaXQgaGFzIGJlZW4gbG9hZGVkLiAtIGRhdGE6IHsgZGV0YWlscyA6IGxldmVsRGV0YWlscyBvYmplY3QsIGxldmVsIDogaWQgb2YgdXBkYXRlZCBsZXZlbCB9XG4gIExFVkVMX1VQREFURUQ6ICdobHNMZXZlbFVwZGF0ZWQnLFxuICAvLyBmaXJlZCB3aGVuIGEgbGV2ZWwncyBQVFMgaW5mb3JtYXRpb24gaGFzIGJlZW4gdXBkYXRlZCBhZnRlciBwYXJzaW5nIGEgZnJhZ21lbnQgLSBkYXRhOiB7IGRldGFpbHMgOiBsZXZlbERldGFpbHMgb2JqZWN0LCBsZXZlbCA6IGlkIG9mIHVwZGF0ZWQgbGV2ZWwsIGRyaWZ0OiBQVFMgZHJpZnQgb2JzZXJ2ZWQgd2hlbiBwYXJzaW5nIGxhc3QgZnJhZ21lbnQgfVxuICBMRVZFTF9QVFNfVVBEQVRFRDogJ2hsc0xldmVsUHRzVXBkYXRlZCcsXG4gIC8vIGZpcmVkIHRvIG5vdGlmeSB0aGF0IGF1ZGlvIHRyYWNrIGxpc3RzIGhhcyBiZWVuIHVwZGF0ZWQgZGF0YTogeyBhdWRpb1RyYWNrcyA6IGF1ZGlvVHJhY2tzfVxuICBMRVZFTF9SRU1PVkVEOiAnaGxzTGV2ZWxSZW1vdmVkJyxcbiAgLy8gZmlyZWQgd2hlbiBhIGxldmVsIHNob3VsZCBubyBsb25nZXIgYmUgdXNlZFxuICBBVURJT19UUkFDS1NfVVBEQVRFRDogJ2hsc0F1ZGlvVHJhY2tzVXBkYXRlZCcsXG4gIC8vIGZpcmVkIHdoZW4gYW4gYXVkaW8gdHJhY2sgc3dpdGNoIG9jY3VycyAtIGRhdGE6IHsgIGlkIDogYXVkaW8gdHJhY2sgaWR9IC8vIGRlcHJlY2F0ZWQgaW4gZmF2b3IgQVVESU9fVFJBQ0tfU1dJVENISU5HXG4gIEFVRElPX1RSQUNLX1NXSVRDSDogJ2hsc0F1ZGlvVHJhY2tTd2l0Y2gnLFxuICAvLyBmaXJlZCB3aGVuIGFuIGF1ZGlvIHRyYWNrIHN3aXRjaGluZyBpcyByZXF1ZXN0ZWQgLSBkYXRhOiB7ICBpZCA6IGF1ZGlvIHRyYWNrIGlkfVxuICBBVURJT19UUkFDS19TV0lUQ0hJTkc6ICdobHNBdWRpb1RyYWNrU3dpdGNoaW5nJyxcbiAgLy8gZmlyZWQgd2hlbiBhbiBhdWRpbyB0cmFjayBzd2l0Y2ggYWN0dWFsbHkgb2NjdXJzIC0gZGF0YTogeyAgaWQgOiBhdWRpbyB0cmFjayBpZH1cbiAgQVVESU9fVFJBQ0tfU1dJVENIRUQ6ICdobHNBdWRpb1RyYWNrU3dpdGNoZWQnLFxuICAvLyBmaXJlZCB3aGVuIGFuIGF1ZGlvIHRyYWNrIGxvYWRpbmcgc3RhcnRzIC0gZGF0YTogeyB1cmwgOiBhdWRpbyB0cmFjayBVUkwgIGlkIDogYXVkaW8gdHJhY2sgaWR9XG4gIEFVRElPX1RSQUNLX0xPQURJTkc6ICdobHNBdWRpb1RyYWNrTG9hZGluZycsXG4gIC8vIGZpcmVkIHdoZW4gYW4gYXVkaW8gdHJhY2sgbG9hZGluZyAgZmluaXNoZXMgLSBkYXRhOiB7IGRldGFpbHMgOiBsZXZlbERldGFpbHMgb2JqZWN0LCBpZCA6IGF1ZGlvIHRyYWNrIGlkLCBzdGF0cyA6IHsgdHJlcXVlc3QsIHRmaXJzdCwgdGxvYWQsIG10aW1lfSB9XG4gIEFVRElPX1RSQUNLX0xPQURFRDogJ2hsc0F1ZGlvVHJhY2tMb2FkZWQnLFxuICAvLyBmaXJlZCB0byBub3RpZnkgdGhhdCBzdWJ0aXRsZSB0cmFjayBsaXN0cyBoYXMgYmVlbiB1cGRhdGVkIGRhdGE6IHsgc3VidGl0bGVUcmFja3MgOiBzdWJ0aXRsZVRyYWNrc31cbiAgU1VCVElUTEVfVFJBQ0tTX1VQREFURUQ6ICdobHNTdWJ0aXRsZVRyYWNrc1VwZGF0ZWQnLFxuICAvLyBmaXJlZCB3aGVuIGFuIHN1YnRpdGxlIHRyYWNrIHN3aXRjaCBvY2N1cnMgLSBkYXRhOiB7ICBpZCA6IHN1YnRpdGxlIHRyYWNrIGlkfVxuICBTVUJUSVRMRV9UUkFDS19TV0lUQ0g6ICdobHNTdWJ0aXRsZVRyYWNrU3dpdGNoJyxcbiAgLy8gZmlyZWQgd2hlbiBhbiBzdWJ0aXRsZSB0cmFjayBsb2FkaW5nIHN0YXJ0cyAtIGRhdGE6IHsgdXJsIDogc3VidGl0bGUgdHJhY2sgVVJMICBpZCA6IHN1YnRpdGxlIHRyYWNrIGlkfVxuICBTVUJUSVRMRV9UUkFDS19MT0FESU5HOiAnaGxzU3VidGl0bGVUcmFja0xvYWRpbmcnLFxuICAvLyBmaXJlZCB3aGVuIGFuIHN1YnRpdGxlIHRyYWNrIGxvYWRpbmcgIGZpbmlzaGVzIC0gZGF0YTogeyBkZXRhaWxzIDogbGV2ZWxEZXRhaWxzIG9iamVjdCwgaWQgOiBzdWJ0aXRsZSB0cmFjayBpZCwgc3RhdHMgOiB7IHRyZXF1ZXN0LCB0Zmlyc3QsIHRsb2FkLCBtdGltZX0gfVxuICBTVUJUSVRMRV9UUkFDS19MT0FERUQ6ICdobHNTdWJ0aXRsZVRyYWNrTG9hZGVkJyxcbiAgLy8gZmlyZWQgd2hlbiBhIHN1YnRpdGxlIGZyYWdtZW50IGhhcyBiZWVuIHByb2Nlc3NlZCAtIGRhdGE6IHsgc3VjY2VzcyA6IGJvb2xlYW4sIGZyYWcgOiB0aGUgcHJvY2Vzc2VkIGZyYWd9XG4gIFNVQlRJVExFX0ZSQUdfUFJPQ0VTU0VEOiAnaGxzU3VidGl0bGVGcmFnUHJvY2Vzc2VkJyxcbiAgLy8gZmlyZWQgd2hlbiB0aGUgZmlyc3QgdGltZXN0YW1wIGlzIGZvdW5kLiAtIGRhdGE6IHsgaWQgOiBkZW11eGVyIGlkLCBpbml0UFRTOiBpbml0UFRTICwgZnJhZyA6IGZyYWdtZW50IG9iamVjdH1cbiAgSU5JVF9QVFNfRk9VTkQ6ICdobHNJbml0UHRzRm91bmQnLFxuICAvLyBmaXJlZCB3aGVuIGEgZnJhZ21lbnQgbG9hZGluZyBzdGFydHMgLSBkYXRhOiB7IGZyYWcgOiBmcmFnbWVudCBvYmplY3R9XG4gIEZSQUdfTE9BRElORzogJ2hsc0ZyYWdMb2FkaW5nJyxcbiAgLy8gZmlyZWQgd2hlbiBhIGZyYWdtZW50IGxvYWRpbmcgaXMgcHJvZ3Jlc3NpbmcgLSBkYXRhOiB7IGZyYWcgOiBmcmFnbWVudCBvYmplY3QsIHsgdHJlcXVlc3QsIHRmaXJzdCwgbG9hZGVkfX1cbiAgRlJBR19MT0FEX1BST0dSRVNTOiAnaGxzRnJhZ0xvYWRQcm9ncmVzcycsXG4gIC8vIElkZW50aWZpZXIgZm9yIGZyYWdtZW50IGxvYWQgYWJvcnRpbmcgZm9yIGVtZXJnZW5jeSBzd2l0Y2ggZG93biAtIGRhdGE6IHtmcmFnIDogZnJhZ21lbnQgb2JqZWN0fVxuICBGUkFHX0xPQURfRU1FUkdFTkNZX0FCT1JURUQ6ICdobHNGcmFnTG9hZEVtZXJnZW5jeUFib3J0ZWQnLFxuICAvLyBmaXJlZCB3aGVuIGEgZnJhZ21lbnQgbG9hZGluZyBpcyBjb21wbGV0ZWQgLSBkYXRhOiB7IGZyYWcgOiBmcmFnbWVudCBvYmplY3QsIHBheWxvYWQgOiBmcmFnbWVudCBwYXlsb2FkLCBzdGF0cyA6IHsgdHJlcXVlc3QsIHRmaXJzdCwgdGxvYWQsIGxlbmd0aH19XG4gIEZSQUdfTE9BREVEOiAnaGxzRnJhZ0xvYWRlZCcsXG4gIC8vIGZpcmVkIHdoZW4gYSBmcmFnbWVudCBoYXMgc3RhcnRlZCBkZWNyeXB0aW5nIC0gZGF0YTogeyBsZXZlbCA6IGxldmVsSWQsIHNuIDogc2VxdWVuY2UgbnVtYmVyIH1cbiAgRlJBR19ERUNSWVBUX1NUQVJURUQ6ICdobHNGcmFnRGVjcnlwdFN0YXJ0ZWQnLFxuICAvLyBmaXJlZCB3aGVuIGEgZnJhZ21lbnQgaGFzIGZpbmlzaGVkIGRlY3J5cHRpbmcgLSBkYXRhOiB7IGlkIDogZGVtdXhlciBpZCwgZnJhZzogZnJhZ21lbnQgb2JqZWN0LCBzdGF0cyA6IHt0c3RhcnQsdGRlY3J5cHR9IH1cbiAgRlJBR19ERUNSWVBURUQ6ICdobHNGcmFnRGVjcnlwdGVkJyxcbiAgLy8gZmlyZWQgd2hlbiBJbml0IFNlZ21lbnQgaGFzIGJlZW4gZXh0cmFjdGVkIGZyb20gZnJhZ21lbnQgLSBkYXRhOiB7IGlkIDogZGVtdXhlciBpZCwgZnJhZzogZnJhZ21lbnQgb2JqZWN0LCBtb292IDogbW9vdiBNUDQgYm94LCBjb2RlY3MgOiBjb2RlY3MgZm91bmQgd2hpbGUgcGFyc2luZyBmcmFnbWVudH1cbiAgRlJBR19QQVJTSU5HX0lOSVRfU0VHTUVOVDogJ2hsc0ZyYWdQYXJzaW5nSW5pdFNlZ21lbnQnLFxuICAvLyBmaXJlZCB3aGVuIHBhcnNpbmcgc2VpIHRleHQgaXMgY29tcGxldGVkIC0gZGF0YTogeyBpZCA6IGRlbXV4ZXIgaWQsICwgZnJhZzogZnJhZ21lbnQgb2JqZWN0LCBzYW1wbGVzIDogWyBzZWkgc2FtcGxlcyBwZXMgXSB9XG4gIEZSQUdfUEFSU0lOR19VU0VSREFUQTogJ2hsc0ZyYWdQYXJzaW5nVXNlcmRhdGEnLFxuICAvLyBmaXJlZCB3aGVuIHBhcnNpbmcgaWQzIGlzIGNvbXBsZXRlZCAtIGRhdGE6IHsgaWQgOiBkZW11eGVyIGlkLCBmcmFnOiBmcmFnbWVudCBvYmplY3QsIHNhbXBsZXMgOiBbIGlkMyBzYW1wbGVzIHBlcyBdIH1cbiAgRlJBR19QQVJTSU5HX01FVEFEQVRBOiAnaGxzRnJhZ1BhcnNpbmdNZXRhZGF0YScsXG4gIC8vIGZpcmVkIHdoZW4gZGF0YSBoYXZlIGJlZW4gZXh0cmFjdGVkIGZyb20gZnJhZ21lbnQgLSBkYXRhOiB7IGlkIDogZGVtdXhlciBpZCwgZnJhZzogZnJhZ21lbnQgb2JqZWN0LCBkYXRhMSA6IG1vb2YgTVA0IGJveCBvciBUUyBmcmFnbWVudHMsIGRhdGEyIDogbWRhdCBNUDQgYm94IG9yIG51bGx9XG4gIEZSQUdfUEFSU0lOR19EQVRBOiAnaGxzRnJhZ1BhcnNpbmdEYXRhJyxcbiAgLy8gZmlyZWQgd2hlbiBmcmFnbWVudCBwYXJzaW5nIGlzIGNvbXBsZXRlZCAtIGRhdGE6IHsgaWQgOiBkZW11eGVyIGlkLGZyYWc6IGZyYWdtZW50IG9iamVjdCB9XG4gIEZSQUdfUEFSU0VEOiAnaGxzRnJhZ1BhcnNlZCcsXG4gIC8vIGZpcmVkIHdoZW4gZnJhZ21lbnQgcmVtdXhlZCBNUDQgYm94ZXMgaGF2ZSBhbGwgYmVlbiBhcHBlbmRlZCBpbnRvIFNvdXJjZUJ1ZmZlciAtIGRhdGE6IHsgaWQgOiBkZW11eGVyIGlkLGZyYWcgOiBmcmFnbWVudCBvYmplY3QsIHN0YXRzIDogeyB0cmVxdWVzdCwgdGZpcnN0LCB0bG9hZCwgdHBhcnNlZCwgdGJ1ZmZlcmVkLCBsZW5ndGh9IH1cbiAgRlJBR19CVUZGRVJFRDogJ2hsc0ZyYWdCdWZmZXJlZCcsXG4gIC8vIGZpcmVkIHdoZW4gZnJhZ21lbnQgbWF0Y2hpbmcgd2l0aCBjdXJyZW50IG1lZGlhIHBvc2l0aW9uIGlzIGNoYW5naW5nIC0gZGF0YSA6IHsgaWQgOiBkZW11eGVyIGlkLCBmcmFnIDogZnJhZ21lbnQgb2JqZWN0IH1cbiAgRlJBR19DSEFOR0VEOiAnaGxzRnJhZ0NoYW5nZWQnLFxuICAvLyBJZGVudGlmaWVyIGZvciBhIEZQUyBkcm9wIGV2ZW50IC0gZGF0YToge2N1cmVudERyb3BwZWQsIGN1cnJlbnREZWNvZGVkLCB0b3RhbERyb3BwZWRGcmFtZXN9XG4gIEZQU19EUk9QOiAnaGxzRnBzRHJvcCcsXG4gIC8vdHJpZ2dlcmVkIHdoZW4gRlBTIGRyb3AgdHJpZ2dlcnMgYXV0byBsZXZlbCBjYXBwaW5nIC0gZGF0YToge2xldmVsLCBkcm9wcGVkbGV2ZWx9XG4gIEZQU19EUk9QX0xFVkVMX0NBUFBJTkc6ICdobHNGcHNEcm9wTGV2ZWxDYXBwaW5nJyxcbiAgLy8gSWRlbnRpZmllciBmb3IgYW4gZXJyb3IgZXZlbnQgLSBkYXRhOiB7IHR5cGUgOiBlcnJvciB0eXBlLCBkZXRhaWxzIDogZXJyb3IgZGV0YWlscywgZmF0YWwgOiBpZiB0cnVlLCBobHMuanMgY2Fubm90L3dpbGwgbm90IHRyeSB0byByZWNvdmVyLCBpZiBmYWxzZSwgaGxzLmpzIHdpbGwgdHJ5IHRvIHJlY292ZXIsb3RoZXIgZXJyb3Igc3BlY2lmaWMgZGF0YX1cbiAgRVJST1I6ICdobHNFcnJvcicsXG4gIC8vIGZpcmVkIHdoZW4gaGxzLmpzIGluc3RhbmNlIHN0YXJ0cyBkZXN0cm95aW5nLiBEaWZmZXJlbnQgZnJvbSBNRURJQV9ERVRBQ0hFRCBhcyBvbmUgY291bGQgd2FudCB0byBkZXRhY2ggYW5kIHJlYXR0YWNoIGEgbWVkaWEgdG8gdGhlIGluc3RhbmNlIG9mIGhscy5qcyB0byBoYW5kbGUgbWlkLXJvbGxzIGZvciBleGFtcGxlXG4gIERFU1RST1lJTkc6ICdobHNEZXN0cm95aW5nJyxcbiAgLy8gZmlyZWQgd2hlbiBhIGRlY3J5cHQga2V5IGxvYWRpbmcgc3RhcnRzIC0gZGF0YTogeyBmcmFnIDogZnJhZ21lbnQgb2JqZWN0fVxuICBLRVlfTE9BRElORzogJ2hsc0tleUxvYWRpbmcnLFxuICAvLyBmaXJlZCB3aGVuIGEgZGVjcnlwdCBrZXkgbG9hZGluZyBpcyBjb21wbGV0ZWQgLSBkYXRhOiB7IGZyYWcgOiBmcmFnbWVudCBvYmplY3QsIHBheWxvYWQgOiBrZXkgcGF5bG9hZCwgc3RhdHMgOiB7IHRyZXF1ZXN0LCB0Zmlyc3QsIHRsb2FkLCBsZW5ndGh9fVxuICBLRVlfTE9BREVEOiAnaGxzS2V5TG9hZGVkJyxcbiAgLy8gZmlyZWQgdXBvbiBzdHJlYW0gY29udHJvbGxlciBzdGF0ZSB0cmFuc2l0aW9ucyAtIGRhdGE6IHtwcmV2aW91c1N0YXRlLCBuZXh0U3RhdGV9XG4gIFNUUkVBTV9TVEFURV9UUkFOU0lUSU9OOiAnaGxzU3RyZWFtU3RhdGVUcmFuc2l0aW9uJ1xufTtcbiIsIi8qKlxuICogIEFBQyBoZWxwZXJcbiAqL1xuXG5jbGFzcyBBQUMge1xuICBzdGF0aWMgZ2V0U2lsZW50RnJhbWUoY29kZWMsY2hhbm5lbENvdW50KSB7XG4gICAgc3dpdGNoKGNvZGVjKSB7XG4gICAgICBjYXNlICdtcDRhLjQwLjInOlxuICAgICAgICBpZiAoY2hhbm5lbENvdW50ID09PSAxKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFsweDAwLCAweGM4LCAweDAwLCAweDgwLCAweDIzLCAweDgwXSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY2hhbm5lbENvdW50ID09PSAyKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFsweDIxLCAweDAwLCAweDQ5LCAweDkwLCAweDAyLCAweDE5LCAweDAwLCAweDIzLCAweDgwXSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY2hhbm5lbENvdW50ID09PSAzKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFsweDAwLCAweGM4LCAweDAwLCAweDgwLCAweDIwLCAweDg0LCAweDAxLCAweDI2LCAweDQwLCAweDA4LCAweDY0LCAweDAwLCAweDhlXSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY2hhbm5lbENvdW50ID09PSA0KSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFsweDAwLCAweGM4LCAweDAwLCAweDgwLCAweDIwLCAweDg0LCAweDAxLCAweDI2LCAweDQwLCAweDA4LCAweDY0LCAweDAwLCAweDgwLCAweDJjLCAweDgwLCAweDA4LCAweDAyLCAweDM4XSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY2hhbm5lbENvdW50ID09PSA1KSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFsweDAwLCAweGM4LCAweDAwLCAweDgwLCAweDIwLCAweDg0LCAweDAxLCAweDI2LCAweDQwLCAweDA4LCAweDY0LCAweDAwLCAweDgyLCAweDMwLCAweDA0LCAweDk5LCAweDAwLCAweDIxLCAweDkwLCAweDAyLCAweDM4XSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY2hhbm5lbENvdW50ID09PSA2KSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFsweDAwLCAweGM4LCAweDAwLCAweDgwLCAweDIwLCAweDg0LCAweDAxLCAweDI2LCAweDQwLCAweDA4LCAweDY0LCAweDAwLCAweDgyLCAweDMwLCAweDA0LCAweDk5LCAweDAwLCAweDIxLCAweDkwLCAweDAyLCAweDAwLCAweGIyLCAweDAwLCAweDIwLCAweDA4LCAweGUwXSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgLy8gaGFuZGxlIEhFLUFBQyBiZWxvdyAobXA0YS40MC41IC8gbXA0YS40MC4yOSlcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChjaGFubmVsQ291bnQgPT09IDEpIHtcbiAgICAgICAgICAvLyBmZm1wZWcgLXkgLWYgbGF2ZmkgLWkgXCJhZXZhbHNyYz0wOmQ9MC4wNVwiIC1jOmEgbGliZmRrX2FhYyAtcHJvZmlsZTphIGFhY19oZSAtYjphIDRrIG91dHB1dC5hYWMgJiYgaGV4ZHVtcCAtdiAtZSAnMTYvMSBcIjB4JXgsXCIgXCJcXG5cIicgLXYgb3V0cHV0LmFhY1xuICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShbMHgxLDB4NDAsMHgyMiwweDgwLDB4YTMsMHg0ZSwweGU2LDB4ODAsMHhiYSwweDgsMHgwLDB4MCwweDAsMHgxYywweDYsMHhmMSwweGMxLDB4YSwweDVhLDB4NWEsMHg1YSwweDVhLDB4NWEsMHg1YSwweDVhLDB4NWEsMHg1YSwweDVhLDB4NWEsMHg1YSwweDVhLDB4NWEsMHg1YSwweDVhLDB4NWEsMHg1YSwweDVhLDB4NWEsMHg1YSwweDVhLDB4NWEsMHg1YSwweDVhLDB4NWEsMHg1YSwweDVhLDB4NWEsMHg1YSwweDVhLDB4NWEsMHg1YSwweDVhLDB4NWEsMHg1YSwweDVhLDB4NWEsMHg1YSwweDVhLDB4NWVdKTtcbiAgICAgICAgfSBlbHNlIGlmIChjaGFubmVsQ291bnQgPT09IDIpIHtcbiAgICAgICAgICAvLyBmZm1wZWcgLXkgLWYgbGF2ZmkgLWkgXCJhZXZhbHNyYz0wfDA6ZD0wLjA1XCIgLWM6YSBsaWJmZGtfYWFjIC1wcm9maWxlOmEgYWFjX2hlX3YyIC1iOmEgNGsgb3V0cHV0LmFhYyAmJiBoZXhkdW1wIC12IC1lICcxNi8xIFwiMHgleCxcIiBcIlxcblwiJyAtdiBvdXRwdXQuYWFjXG4gICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFsweDEsMHg0MCwweDIyLDB4ODAsMHhhMywweDVlLDB4ZTYsMHg4MCwweGJhLDB4OCwweDAsMHgwLDB4MCwweDAsMHg5NSwweDAsMHg2LDB4ZjEsMHhhMSwweGEsMHg1YSwweDVhLDB4NWEsMHg1YSwweDVhLDB4NWEsMHg1YSwweDVhLDB4NWEsMHg1YSwweDVhLDB4NWEsMHg1YSwweDVhLDB4NWEsMHg1YSwweDVhLDB4NWEsMHg1YSwweDVhLDB4NWEsMHg1YSwweDVhLDB4NWEsMHg1YSwweDVhLDB4NWEsMHg1YSwweDVhLDB4NWEsMHg1YSwweDVhLDB4NWEsMHg1YSwweDVhLDB4NWEsMHg1YSwweDVhLDB4NWVdKTtcbiAgICAgICAgfSBlbHNlIGlmIChjaGFubmVsQ291bnQgPT09IDMpIHtcbiAgICAgICAgICAvLyBmZm1wZWcgLXkgLWYgbGF2ZmkgLWkgXCJhZXZhbHNyYz0wfDB8MDpkPTAuMDVcIiAtYzphIGxpYmZka19hYWMgLXByb2ZpbGU6YSBhYWNfaGVfdjIgLWI6YSA0ayBvdXRwdXQuYWFjICYmIGhleGR1bXAgLXYgLWUgJzE2LzEgXCIweCV4LFwiIFwiXFxuXCInIC12IG91dHB1dC5hYWNcbiAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzB4MSwweDQwLDB4MjIsMHg4MCwweGEzLDB4NWUsMHhlNiwweDgwLDB4YmEsMHg4LDB4MCwweDAsMHgwLDB4MCwweDk1LDB4MCwweDYsMHhmMSwweGExLDB4YSwweDVhLDB4NWEsMHg1YSwweDVhLDB4NWEsMHg1YSwweDVhLDB4NWEsMHg1YSwweDVhLDB4NWEsMHg1YSwweDVhLDB4NWEsMHg1YSwweDVhLDB4NWEsMHg1YSwweDVhLDB4NWEsMHg1YSwweDVhLDB4NWEsMHg1YSwweDVhLDB4NWEsMHg1YSwweDVhLDB4NWEsMHg1YSwweDVhLDB4NWEsMHg1YSwweDVhLDB4NWEsMHg1YSwweDVhLDB4NWEsMHg1ZV0pO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBBQUM7XG4iLCIvKipcbiAqIEJ1ZmZlciBIZWxwZXIgdXRpbHMsIHByb3ZpZGluZyBtZXRob2RzIGRlYWxpbmcgYnVmZmVyIGxlbmd0aCByZXRyaWV2YWxcbiovXG5cbmNvbnN0IEJ1ZmZlckhlbHBlciA9IHtcbiAgaXNCdWZmZXJlZCA6IGZ1bmN0aW9uKG1lZGlhLHBvc2l0aW9uKSB7XG4gICAgaWYgKG1lZGlhKSB7XG4gICAgICBsZXQgYnVmZmVyZWQgPSBtZWRpYS5idWZmZXJlZDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnVmZmVyZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHBvc2l0aW9uID49IGJ1ZmZlcmVkLnN0YXJ0KGkpICYmIHBvc2l0aW9uIDw9IGJ1ZmZlcmVkLmVuZChpKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcblxuICBidWZmZXJJbmZvIDogZnVuY3Rpb24obWVkaWEsIHBvcyxtYXhIb2xlRHVyYXRpb24pIHtcbiAgICBpZiAobWVkaWEpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciB2YnVmZmVyZWQgPSBtZWRpYS5idWZmZXJlZCwgYnVmZmVyZWQgPSBbXSwgaTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHZidWZmZXJlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGJ1ZmZlcmVkLnB1c2goe3N0YXJ0OiB2YnVmZmVyZWQuc3RhcnQoaSksIGVuZDogdmJ1ZmZlcmVkLmVuZChpKX0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlcmVkSW5mbyhidWZmZXJlZCwgcG9zLCBtYXhIb2xlRHVyYXRpb24pO1xuICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgIHJldHVybiB7bGVuOiAwLCBzdGFydDogMCwgZW5kOiAwLCBuZXh0U3RhcnQgOiB1bmRlZmluZWR9IDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHtsZW46IDAsIHN0YXJ0OiBwb3MsIGVuZDogcG9zLCBuZXh0U3RhcnQgOiB1bmRlZmluZWR9IDtcbiAgICB9XG4gIH0sXG5cbiAgYnVmZmVyZWRJbmZvIDogZnVuY3Rpb24oYnVmZmVyZWQscG9zLG1heEhvbGVEdXJhdGlvbikge1xuICAgIHZhciBidWZmZXJlZDIgPSBbXSxcbiAgICAgICAgLy8gYnVmZmVyU3RhcnQgYW5kIGJ1ZmZlckVuZCBhcmUgYnVmZmVyIGJvdW5kYXJpZXMgYXJvdW5kIGN1cnJlbnQgdmlkZW8gcG9zaXRpb25cbiAgICAgICAgYnVmZmVyTGVuLGJ1ZmZlclN0YXJ0LCBidWZmZXJFbmQsYnVmZmVyU3RhcnROZXh0LGk7XG4gICAgLy8gc29ydCBvbiBidWZmZXIuc3RhcnQvc21hbGxlciBlbmQgKElFIGRvZXMgbm90IGFsd2F5cyByZXR1cm4gc29ydGVkIGJ1ZmZlcmVkIHJhbmdlKVxuICAgIGJ1ZmZlcmVkLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHZhciBkaWZmID0gYS5zdGFydCAtIGIuc3RhcnQ7XG4gICAgICBpZiAoZGlmZikge1xuICAgICAgICByZXR1cm4gZGlmZjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBiLmVuZCAtIGEuZW5kO1xuICAgICAgfVxuICAgIH0pO1xuICAgIC8vIHRoZXJlIG1pZ2h0IGJlIHNvbWUgc21hbGwgaG9sZXMgYmV0d2VlbiBidWZmZXIgdGltZSByYW5nZVxuICAgIC8vIGNvbnNpZGVyIHRoYXQgaG9sZXMgc21hbGxlciB0aGFuIG1heEhvbGVEdXJhdGlvbiBhcmUgaXJyZWxldmFudCBhbmQgYnVpbGQgYW5vdGhlclxuICAgIC8vIGJ1ZmZlciB0aW1lIHJhbmdlIHJlcHJlc2VudGF0aW9ucyB0aGF0IGRpc2NhcmRzIHRob3NlIGhvbGVzXG4gICAgZm9yIChpID0gMDsgaSA8IGJ1ZmZlcmVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYnVmMmxlbiA9IGJ1ZmZlcmVkMi5sZW5ndGg7XG4gICAgICBpZihidWYybGVuKSB7XG4gICAgICAgIHZhciBidWYyZW5kID0gYnVmZmVyZWQyW2J1ZjJsZW4gLSAxXS5lbmQ7XG4gICAgICAgIC8vIGlmIHNtYWxsIGhvbGUgKHZhbHVlIGJldHdlZW4gMCBvciBtYXhIb2xlRHVyYXRpb24gKSBvciBvdmVybGFwcGluZyAobmVnYXRpdmUpXG4gICAgICAgIGlmKChidWZmZXJlZFtpXS5zdGFydCAtIGJ1ZjJlbmQpIDwgbWF4SG9sZUR1cmF0aW9uKSB7XG4gICAgICAgICAgLy8gbWVyZ2Ugb3ZlcmxhcHBpbmcgdGltZSByYW5nZXNcbiAgICAgICAgICAvLyB1cGRhdGUgbGFzdFJhbmdlLmVuZCBvbmx5IGlmIHNtYWxsZXIgdGhhbiBpdGVtLmVuZFxuICAgICAgICAgIC8vIGUuZy4gIFsgMSwgMTVdIHdpdGggIFsgMiw4XSA9PiBbIDEsMTVdIChubyBuZWVkIHRvIG1vZGlmeSBsYXN0UmFuZ2UuZW5kKVxuICAgICAgICAgIC8vIHdoZXJlYXMgWyAxLCA4XSB3aXRoICBbIDIsMTVdID0+IFsgMSwxNV0gKCBsYXN0UmFuZ2Ugc2hvdWxkIHN3aXRjaCBmcm9tIFsxLDhdIHRvIFsxLDE1XSlcbiAgICAgICAgICBpZihidWZmZXJlZFtpXS5lbmQgPiBidWYyZW5kKSB7XG4gICAgICAgICAgICBidWZmZXJlZDJbYnVmMmxlbiAtIDFdLmVuZCA9IGJ1ZmZlcmVkW2ldLmVuZDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gYmlnIGhvbGVcbiAgICAgICAgICBidWZmZXJlZDIucHVzaChidWZmZXJlZFtpXSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGZpcnN0IHZhbHVlXG4gICAgICAgIGJ1ZmZlcmVkMi5wdXNoKGJ1ZmZlcmVkW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChpID0gMCwgYnVmZmVyTGVuID0gMCwgYnVmZmVyU3RhcnQgPSBidWZmZXJFbmQgPSBwb3M7IGkgPCBidWZmZXJlZDIubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzdGFydCA9ICBidWZmZXJlZDJbaV0uc3RhcnQsXG4gICAgICAgICAgZW5kID0gYnVmZmVyZWQyW2ldLmVuZDtcbiAgICAgIC8vbG9nZ2VyLmxvZygnYnVmIHN0YXJ0L2VuZDonICsgYnVmZmVyZWQuc3RhcnQoaSkgKyAnLycgKyBidWZmZXJlZC5lbmQoaSkpO1xuICAgICAgaWYgKChwb3MgKyBtYXhIb2xlRHVyYXRpb24pID49IHN0YXJ0ICYmIHBvcyA8IGVuZCkge1xuICAgICAgICAvLyBwbGF5IHBvc2l0aW9uIGlzIGluc2lkZSB0aGlzIGJ1ZmZlciBUaW1lUmFuZ2UsIHJldHJpZXZlIGVuZCBvZiBidWZmZXIgcG9zaXRpb24gYW5kIGJ1ZmZlciBsZW5ndGhcbiAgICAgICAgYnVmZmVyU3RhcnQgPSBzdGFydDtcbiAgICAgICAgYnVmZmVyRW5kID0gZW5kO1xuICAgICAgICBidWZmZXJMZW4gPSBidWZmZXJFbmQgLSBwb3M7XG4gICAgICB9IGVsc2UgaWYgKChwb3MgKyBtYXhIb2xlRHVyYXRpb24pIDwgc3RhcnQpIHtcbiAgICAgICAgYnVmZmVyU3RhcnROZXh0ID0gc3RhcnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge2xlbjogYnVmZmVyTGVuLCBzdGFydDogYnVmZmVyU3RhcnQgfHwgMCwgZW5kOiBidWZmZXJFbmQgfHwgMCwgbmV4dFN0YXJ0IDogYnVmZmVyU3RhcnROZXh0fTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBCdWZmZXJIZWxwZXI7XG4iLCIvKipcbiAqIExldmVsIEhlbHBlciBjbGFzcywgcHJvdmlkaW5nIG1ldGhvZHMgZGVhbGluZyB3aXRoIHBsYXlsaXN0IHNsaWRpbmcgYW5kIGRyaWZ0XG4qL1xuXG5pbXBvcnQge2xvZ2dlcn0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcblxuY29uc3QgTGV2ZWxIZWxwZXIgPSB7XG5cbiAgbWVyZ2VEZXRhaWxzIDogZnVuY3Rpb24ob2xkRGV0YWlscyxuZXdEZXRhaWxzKSB7XG4gICAgdmFyIHN0YXJ0ID0gTWF0aC5tYXgob2xkRGV0YWlscy5zdGFydFNOLG5ld0RldGFpbHMuc3RhcnRTTiktbmV3RGV0YWlscy5zdGFydFNOLFxuICAgICAgICBlbmQgPSBNYXRoLm1pbihvbGREZXRhaWxzLmVuZFNOLG5ld0RldGFpbHMuZW5kU04pLW5ld0RldGFpbHMuc3RhcnRTTixcbiAgICAgICAgZGVsdGEgPSBuZXdEZXRhaWxzLnN0YXJ0U04gLSBvbGREZXRhaWxzLnN0YXJ0U04sXG4gICAgICAgIG9sZGZyYWdtZW50cyA9IG9sZERldGFpbHMuZnJhZ21lbnRzLFxuICAgICAgICBuZXdmcmFnbWVudHMgPSBuZXdEZXRhaWxzLmZyYWdtZW50cyxcbiAgICAgICAgY2NPZmZzZXQgPTAsXG4gICAgICAgIFBUU0ZyYWc7XG5cbiAgICAvLyBjaGVjayBpZiBvbGQvbmV3IHBsYXlsaXN0cyBoYXZlIGZyYWdtZW50cyBpbiBjb21tb25cbiAgICBpZiAoIGVuZCA8IHN0YXJ0KSB7XG4gICAgICBuZXdEZXRhaWxzLlBUU0tub3duID0gZmFsc2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIGxvb3AgdGhyb3VnaCBvdmVybGFwcGluZyBTTiBhbmQgdXBkYXRlIHN0YXJ0UFRTICwgY2MsIGFuZCBkdXJhdGlvbiBpZiBhbnkgZm91bmRcbiAgICBmb3IodmFyIGkgPSBzdGFydCA7IGkgPD0gZW5kIDsgaSsrKSB7XG4gICAgICB2YXIgb2xkRnJhZyA9IG9sZGZyYWdtZW50c1tkZWx0YStpXSxcbiAgICAgICAgICBuZXdGcmFnID0gbmV3ZnJhZ21lbnRzW2ldO1xuICAgICAgaWYgKG5ld0ZyYWcgJiYgb2xkRnJhZykge1xuICAgICAgICBjY09mZnNldCA9IG9sZEZyYWcuY2MgLSBuZXdGcmFnLmNjO1xuICAgICAgICBpZiAoIWlzTmFOKG9sZEZyYWcuc3RhcnRQVFMpKSB7XG4gICAgICAgICAgbmV3RnJhZy5zdGFydCA9IG5ld0ZyYWcuc3RhcnRQVFMgPSBvbGRGcmFnLnN0YXJ0UFRTO1xuICAgICAgICAgIG5ld0ZyYWcuZW5kUFRTID0gb2xkRnJhZy5lbmRQVFM7XG4gICAgICAgICAgbmV3RnJhZy5kdXJhdGlvbiA9IG9sZEZyYWcuZHVyYXRpb247XG4gICAgICAgICAgUFRTRnJhZyA9IG5ld0ZyYWc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZihjY09mZnNldCkge1xuICAgICAgbG9nZ2VyLmxvZyhgZGlzY29udGludWl0eSBzbGlkaW5nIGZyb20gcGxheWxpc3QsIHRha2UgZHJpZnQgaW50byBhY2NvdW50YCk7XG4gICAgICBmb3IoaSA9IDAgOyBpIDwgbmV3ZnJhZ21lbnRzLmxlbmd0aCA7IGkrKykge1xuICAgICAgICBuZXdmcmFnbWVudHNbaV0uY2MgKz0gY2NPZmZzZXQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gaWYgYXQgbGVhc3Qgb25lIGZyYWdtZW50IGNvbnRhaW5zIFBUUyBpbmZvLCByZWNvbXB1dGUgUFRTIGluZm9ybWF0aW9uIGZvciBhbGwgZnJhZ21lbnRzXG4gICAgaWYoUFRTRnJhZykge1xuICAgICAgTGV2ZWxIZWxwZXIudXBkYXRlRnJhZ1BUU0RUUyhuZXdEZXRhaWxzLFBUU0ZyYWcuc24sUFRTRnJhZy5zdGFydFBUUyxQVFNGcmFnLmVuZFBUUyxQVFNGcmFnLnN0YXJ0RFRTLFBUU0ZyYWcuZW5kRFRTKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZW5zdXJlIHRoYXQgZGVsdGEgaXMgd2l0aGluIG9sZGZyYWdtZW50cyByYW5nZVxuICAgICAgLy8gYWxzbyBhZGp1c3Qgc2xpZGluZyBpbiBjYXNlIGRlbHRhIGlzIDAgKHdlIGNvdWxkIGhhdmUgb2xkPVs1MC02MF0gYW5kIG5ldz1vbGQ9WzUwLTYxXSlcbiAgICAgIC8vIGluIHRoYXQgY2FzZSB3ZSBhbHNvIG5lZWQgdG8gYWRqdXN0IHN0YXJ0IG9mZnNldCBvZiBhbGwgZnJhZ21lbnRzXG4gICAgICBpZiAoZGVsdGEgPj0gMCAmJiBkZWx0YSA8IG9sZGZyYWdtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgLy8gYWRqdXN0IHN0YXJ0IGJ5IHNsaWRpbmcgb2Zmc2V0XG4gICAgICAgIHZhciBzbGlkaW5nID0gb2xkZnJhZ21lbnRzW2RlbHRhXS5zdGFydDtcbiAgICAgICAgZm9yKGkgPSAwIDsgaSA8IG5ld2ZyYWdtZW50cy5sZW5ndGggOyBpKyspIHtcbiAgICAgICAgICBuZXdmcmFnbWVudHNbaV0uc3RhcnQgKz0gc2xpZGluZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBpZiB3ZSBhcmUgaGVyZSwgaXQgbWVhbnMgd2UgaGF2ZSBmcmFnbWVudHMgb3ZlcmxhcHBpbmcgYmV0d2VlblxuICAgIC8vIG9sZCBhbmQgbmV3IGxldmVsLiByZWxpYWJsZSBQVFMgaW5mbyBpcyB0aHVzIHJlbHlpbmcgb24gb2xkIGxldmVsXG4gICAgbmV3RGV0YWlscy5QVFNLbm93biA9IG9sZERldGFpbHMuUFRTS25vd247XG4gICAgcmV0dXJuO1xuICB9LFxuXG4gIHVwZGF0ZUZyYWdQVFNEVFMgOiBmdW5jdGlvbihkZXRhaWxzLHNuLHN0YXJ0UFRTLGVuZFBUUyxzdGFydERUUyxlbmREVFMpIHtcbiAgICB2YXIgZnJhZ0lkeCwgZnJhZ21lbnRzLCBmcmFnLCBpO1xuICAgIC8vIGV4aXQgaWYgc24gb3V0IG9mIHJhbmdlXG4gICAgaWYgKCFkZXRhaWxzIHx8IHNuIDwgZGV0YWlscy5zdGFydFNOIHx8IHNuID4gZGV0YWlscy5lbmRTTikge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGZyYWdJZHggPSBzbiAtIGRldGFpbHMuc3RhcnRTTjtcbiAgICBmcmFnbWVudHMgPSBkZXRhaWxzLmZyYWdtZW50cztcbiAgICBmcmFnID0gZnJhZ21lbnRzW2ZyYWdJZHhdO1xuICAgIGlmKCFpc05hTihmcmFnLnN0YXJ0UFRTKSkge1xuICAgICAgLy8gZGVsdGEgUFRTIGJldHdlZW4gYXVkaW8gYW5kIHZpZGVvXG4gICAgICBsZXQgZGVsdGFQVFMgPSBNYXRoLmFicyhmcmFnLnN0YXJ0UFRTLXN0YXJ0UFRTKTtcbiAgICAgIGlmIChpc05hTihmcmFnLmRlbHRhUFRTKSkge1xuICAgICAgICBmcmFnLmRlbHRhUFRTID0gZGVsdGFQVFM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmcmFnLmRlbHRhUFRTID0gTWF0aC5tYXgoZGVsdGFQVFMsZnJhZy5kZWx0YVBUUyk7XG4gICAgICB9XG4gICAgICBzdGFydFBUUyA9IE1hdGgubWluKHN0YXJ0UFRTLGZyYWcuc3RhcnRQVFMpO1xuICAgICAgZW5kUFRTID0gTWF0aC5tYXgoZW5kUFRTLCBmcmFnLmVuZFBUUyk7XG4gICAgICBzdGFydERUUyA9IE1hdGgubWluKHN0YXJ0RFRTLGZyYWcuc3RhcnREVFMpO1xuICAgICAgZW5kRFRTID0gTWF0aC5tYXgoZW5kRFRTLCBmcmFnLmVuZERUUyk7XG4gICAgfVxuXG4gICAgdmFyIGRyaWZ0ID0gc3RhcnRQVFMgLSBmcmFnLnN0YXJ0O1xuXG4gICAgZnJhZy5zdGFydCA9IGZyYWcuc3RhcnRQVFMgPSBzdGFydFBUUztcbiAgICBmcmFnLmVuZFBUUyA9IGVuZFBUUztcbiAgICBmcmFnLnN0YXJ0RFRTID0gc3RhcnREVFM7XG4gICAgZnJhZy5lbmREVFMgPSBlbmREVFM7XG4gICAgZnJhZy5kdXJhdGlvbiA9IGVuZFBUUyAtIHN0YXJ0UFRTO1xuICAgIC8vIGFkanVzdCBmcmFnbWVudCBQVFMvZHVyYXRpb24gZnJvbSBzZXFudW0tMSB0byBmcmFnIDBcbiAgICBmb3IoaSA9IGZyYWdJZHggOyBpID4gMCA7IGktLSkge1xuICAgICAgTGV2ZWxIZWxwZXIudXBkYXRlUFRTKGZyYWdtZW50cyxpLGktMSk7XG4gICAgfVxuXG4gICAgLy8gYWRqdXN0IGZyYWdtZW50IFBUUy9kdXJhdGlvbiBmcm9tIHNlcW51bSB0byBsYXN0IGZyYWdcbiAgICBmb3IoaSA9IGZyYWdJZHggOyBpIDwgZnJhZ21lbnRzLmxlbmd0aCAtIDEgOyBpKyspIHtcbiAgICAgIExldmVsSGVscGVyLnVwZGF0ZVBUUyhmcmFnbWVudHMsaSxpKzEpO1xuICAgIH1cbiAgICBkZXRhaWxzLlBUU0tub3duID0gdHJ1ZTtcbiAgICAvL2xvZ2dlci5sb2coYCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhZyBzdGFydC9lbmQ6JHtzdGFydFBUUy50b0ZpeGVkKDMpfS8ke2VuZFBUUy50b0ZpeGVkKDMpfWApO1xuXG4gICAgcmV0dXJuIGRyaWZ0O1xuICB9LFxuXG4gIHVwZGF0ZVBUUyA6IGZ1bmN0aW9uKGZyYWdtZW50cyxmcm9tSWR4LCB0b0lkeCkge1xuICAgIHZhciBmcmFnRnJvbSA9IGZyYWdtZW50c1tmcm9tSWR4XSxmcmFnVG8gPSBmcmFnbWVudHNbdG9JZHhdLCBmcmFnVG9QVFMgPSBmcmFnVG8uc3RhcnRQVFM7XG4gICAgLy8gaWYgd2Uga25vdyBzdGFydFBUU1t0b0lkeF1cbiAgICBpZighaXNOYU4oZnJhZ1RvUFRTKSkge1xuICAgICAgLy8gdXBkYXRlIGZyYWdtZW50IGR1cmF0aW9uLlxuICAgICAgLy8gaXQgaGVscHMgdG8gZml4IGRyaWZ0cyBiZXR3ZWVuIHBsYXlsaXN0IHJlcG9ydGVkIGR1cmF0aW9uIGFuZCBmcmFnbWVudCByZWFsIGR1cmF0aW9uXG4gICAgICBpZiAodG9JZHggPiBmcm9tSWR4KSB7XG4gICAgICAgIGZyYWdGcm9tLmR1cmF0aW9uID0gZnJhZ1RvUFRTLWZyYWdGcm9tLnN0YXJ0O1xuICAgICAgICBpZihmcmFnRnJvbS5kdXJhdGlvbiA8IDApIHtcbiAgICAgICAgICBsb2dnZXIud2FybihgbmVnYXRpdmUgZHVyYXRpb24gY29tcHV0ZWQgZm9yIGZyYWcgJHtmcmFnRnJvbS5zbn0sbGV2ZWwgJHtmcmFnRnJvbS5sZXZlbH0sIHRoZXJlIHNob3VsZCBiZSBzb21lIGR1cmF0aW9uIGRyaWZ0IGJldHdlZW4gcGxheWxpc3QgYW5kIGZyYWdtZW50IWApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmcmFnVG8uZHVyYXRpb24gPSBmcmFnRnJvbS5zdGFydCAtIGZyYWdUb1BUUztcbiAgICAgICAgaWYoZnJhZ1RvLmR1cmF0aW9uIDwgMCkge1xuICAgICAgICAgIGxvZ2dlci53YXJuKGBuZWdhdGl2ZSBkdXJhdGlvbiBjb21wdXRlZCBmb3IgZnJhZyAke2ZyYWdUby5zbn0sbGV2ZWwgJHtmcmFnVG8ubGV2ZWx9LCB0aGVyZSBzaG91bGQgYmUgc29tZSBkdXJhdGlvbiBkcmlmdCBiZXR3ZWVuIHBsYXlsaXN0IGFuZCBmcmFnbWVudCFgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyB3ZSBkb250IGtub3cgc3RhcnRQVFNbdG9JZHhdXG4gICAgICBpZiAodG9JZHggPiBmcm9tSWR4KSB7XG4gICAgICAgIGZyYWdUby5zdGFydCA9IGZyYWdGcm9tLnN0YXJ0ICsgZnJhZ0Zyb20uZHVyYXRpb247XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmcmFnVG8uc3RhcnQgPSBNYXRoLm1heChmcmFnRnJvbS5zdGFydCAtIGZyYWdUby5kdXJhdGlvbiwgMCk7XG4gICAgICB9XG4gICAgfVxuICB9LFxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBMZXZlbEhlbHBlcjtcbiIsIi8qKlxuICogSExTIGludGVyZmFjZVxuICovXG4ndXNlIHN0cmljdCc7XG5cbmltcG9ydCBVUkxUb29sa2l0IGZyb20gJ3VybC10b29sa2l0JztcbmltcG9ydCBFdmVudCBmcm9tICcuL2V2ZW50cyc7XG5pbXBvcnQge0Vycm9yVHlwZXMsIEVycm9yRGV0YWlsc30gZnJvbSAnLi9lcnJvcnMnO1xuaW1wb3J0IFBsYXlsaXN0TG9hZGVyIGZyb20gJy4vbG9hZGVyL3BsYXlsaXN0LWxvYWRlcic7XG5pbXBvcnQgRnJhZ21lbnRMb2FkZXIgZnJvbSAnLi9sb2FkZXIvZnJhZ21lbnQtbG9hZGVyJztcbmltcG9ydCBLZXlMb2FkZXIgZnJvbSAnLi9sb2FkZXIva2V5LWxvYWRlcic7XG5cbmltcG9ydCBTdHJlYW1Db250cm9sbGVyIGZyb20gICcuL2NvbnRyb2xsZXIvc3RyZWFtLWNvbnRyb2xsZXInO1xuaW1wb3J0IExldmVsQ29udHJvbGxlciBmcm9tICAnLi9jb250cm9sbGVyL2xldmVsLWNvbnRyb2xsZXInO1xuXG5pbXBvcnQge2xvZ2dlciwgZW5hYmxlTG9nc30gZnJvbSAnLi91dGlscy9sb2dnZXInO1xuaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tICdldmVudHMnO1xuaW1wb3J0IHtobHNEZWZhdWx0Q29uZmlnfSBmcm9tICcuL2NvbmZpZyc7XG5cbmNsYXNzIEhscyB7XG5cbiAgc3RhdGljIGdldCB2ZXJzaW9uKCkge1xuICAgIC8vIHJlcGxhY2VkIHdpdGggYnJvd3NlcmlmeS12ZXJzaW9uaWZ5IHRyYW5zZm9ybVxuICAgIHJldHVybiAnX19WRVJTSU9OX18nO1xuICB9XG5cbiAgc3RhdGljIGlzU3VwcG9ydGVkKCkge1xuICAgIHdpbmRvdy5NZWRpYVNvdXJjZSA9IHdpbmRvdy5NZWRpYVNvdXJjZSB8fCB3aW5kb3cuV2ViS2l0TWVkaWFTb3VyY2U7XG4gICAgcmV0dXJuICh3aW5kb3cuTWVkaWFTb3VyY2UgJiZcbiAgICAgICAgICAgIHR5cGVvZiB3aW5kb3cuTWVkaWFTb3VyY2UuaXNUeXBlU3VwcG9ydGVkID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAgICAgICB3aW5kb3cuTWVkaWFTb3VyY2UuaXNUeXBlU3VwcG9ydGVkKCd2aWRlby9tcDQ7IGNvZGVjcz1cImF2YzEuNDJFMDFFLG1wNGEuNDAuMlwiJykpO1xuICB9XG5cbiAgc3RhdGljIGdldCBFdmVudHMoKSB7XG4gICAgcmV0dXJuIEV2ZW50O1xuICB9XG5cbiAgc3RhdGljIGdldCBFcnJvclR5cGVzKCkge1xuICAgIHJldHVybiBFcnJvclR5cGVzO1xuICB9XG5cbiAgc3RhdGljIGdldCBFcnJvckRldGFpbHMoKSB7XG4gICAgcmV0dXJuIEVycm9yRGV0YWlscztcbiAgfVxuXG4gIHN0YXRpYyBnZXQgRGVmYXVsdENvbmZpZygpIHtcbiAgICBpZighSGxzLmRlZmF1bHRDb25maWcpIHtcbiAgICAgIHJldHVybiBobHNEZWZhdWx0Q29uZmlnO1xuICAgIH1cbiAgICByZXR1cm4gSGxzLmRlZmF1bHRDb25maWc7XG4gIH1cblxuICBzdGF0aWMgc2V0IERlZmF1bHRDb25maWcoZGVmYXVsdENvbmZpZykge1xuICAgIEhscy5kZWZhdWx0Q29uZmlnID0gZGVmYXVsdENvbmZpZztcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKGNvbmZpZyA9IHt9KSB7XG4gICAgdmFyIGRlZmF1bHRDb25maWcgPSBIbHMuRGVmYXVsdENvbmZpZztcblxuICAgIGlmICgoY29uZmlnLmxpdmVTeW5jRHVyYXRpb25Db3VudCB8fCBjb25maWcubGl2ZU1heExhdGVuY3lEdXJhdGlvbkNvdW50KSAmJiAoY29uZmlnLmxpdmVTeW5jRHVyYXRpb24gfHwgY29uZmlnLmxpdmVNYXhMYXRlbmN5RHVyYXRpb24pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lsbGVnYWwgaGxzLmpzIGNvbmZpZzogZG9uXFwndCBtaXggdXAgbGl2ZVN5bmNEdXJhdGlvbkNvdW50L2xpdmVNYXhMYXRlbmN5RHVyYXRpb25Db3VudCBhbmQgbGl2ZVN5bmNEdXJhdGlvbi9saXZlTWF4TGF0ZW5jeUR1cmF0aW9uJyk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgcHJvcCBpbiBkZWZhdWx0Q29uZmlnKSB7XG4gICAgICAgIGlmIChwcm9wIGluIGNvbmZpZykgeyBjb250aW51ZTsgfVxuICAgICAgICBjb25maWdbcHJvcF0gPSBkZWZhdWx0Q29uZmlnW3Byb3BdO1xuICAgIH1cblxuICAgIGlmIChjb25maWcubGl2ZU1heExhdGVuY3lEdXJhdGlvbkNvdW50ICE9PSB1bmRlZmluZWQgJiYgY29uZmlnLmxpdmVNYXhMYXRlbmN5RHVyYXRpb25Db3VudCA8PSBjb25maWcubGl2ZVN5bmNEdXJhdGlvbkNvdW50KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lsbGVnYWwgaGxzLmpzIGNvbmZpZzogXCJsaXZlTWF4TGF0ZW5jeUR1cmF0aW9uQ291bnRcIiBtdXN0IGJlIGd0IFwibGl2ZVN5bmNEdXJhdGlvbkNvdW50XCInKTtcbiAgICB9XG5cbiAgICBpZiAoY29uZmlnLmxpdmVNYXhMYXRlbmN5RHVyYXRpb24gIT09IHVuZGVmaW5lZCAmJiAoY29uZmlnLmxpdmVNYXhMYXRlbmN5RHVyYXRpb24gPD0gY29uZmlnLmxpdmVTeW5jRHVyYXRpb24gfHwgY29uZmlnLmxpdmVTeW5jRHVyYXRpb24gPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSWxsZWdhbCBobHMuanMgY29uZmlnOiBcImxpdmVNYXhMYXRlbmN5RHVyYXRpb25cIiBtdXN0IGJlIGd0IFwibGl2ZVN5bmNEdXJhdGlvblwiJyk7XG4gICAgfVxuXG4gICAgZW5hYmxlTG9ncyhjb25maWcuZGVidWcpO1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgIHRoaXMuX2F1dG9MZXZlbENhcHBpbmcgPSAtMTtcbiAgICAvLyBvYnNlcnZlciBzZXR1cFxuICAgIHZhciBvYnNlcnZlciA9IHRoaXMub2JzZXJ2ZXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgb2JzZXJ2ZXIudHJpZ2dlciA9IGZ1bmN0aW9uIHRyaWdnZXIgKGV2ZW50LCAuLi5kYXRhKSB7XG4gICAgICBvYnNlcnZlci5lbWl0KGV2ZW50LCBldmVudCwgLi4uZGF0YSk7XG4gICAgfTtcblxuICAgIG9ic2VydmVyLm9mZiA9IGZ1bmN0aW9uIG9mZiAoZXZlbnQsIC4uLmRhdGEpIHtcbiAgICAgIG9ic2VydmVyLnJlbW92ZUxpc3RlbmVyKGV2ZW50LCAuLi5kYXRhKTtcbiAgICB9O1xuICAgIHRoaXMub24gPSBvYnNlcnZlci5vbi5iaW5kKG9ic2VydmVyKTtcbiAgICB0aGlzLm9mZiA9IG9ic2VydmVyLm9mZi5iaW5kKG9ic2VydmVyKTtcbiAgICB0aGlzLnRyaWdnZXIgPSBvYnNlcnZlci50cmlnZ2VyLmJpbmQob2JzZXJ2ZXIpO1xuXG4gICAgLy8gY29yZSBjb250cm9sbGVycyBhbmQgbmV0d29yayBsb2FkZXJzXG4gICAgY29uc3QgYWJyQ29udHJvbGxlciA9IHRoaXMuYWJyQ29udHJvbGxlciA9IG5ldyBjb25maWcuYWJyQ29udHJvbGxlcih0aGlzKTtcbiAgICBjb25zdCBidWZmZXJDb250cm9sbGVyICA9IG5ldyBjb25maWcuYnVmZmVyQ29udHJvbGxlcih0aGlzKTtcbiAgICBjb25zdCBjYXBMZXZlbENvbnRyb2xsZXIgPSBuZXcgY29uZmlnLmNhcExldmVsQ29udHJvbGxlcih0aGlzKTtcbiAgICBjb25zdCBmcHNDb250cm9sbGVyID0gbmV3IGNvbmZpZy5mcHNDb250cm9sbGVyKHRoaXMpO1xuICAgIGNvbnN0IHBsYXlMaXN0TG9hZGVyID0gbmV3IFBsYXlsaXN0TG9hZGVyKHRoaXMpO1xuICAgIGNvbnN0IGZyYWdtZW50TG9hZGVyID0gbmV3IEZyYWdtZW50TG9hZGVyKHRoaXMpO1xuICAgIGNvbnN0IGtleUxvYWRlciA9IG5ldyBLZXlMb2FkZXIodGhpcyk7XG5cbiAgICAvLyBuZXR3b3JrIGNvbnRyb2xsZXJzXG4gICAgY29uc3QgbGV2ZWxDb250cm9sbGVyID0gdGhpcy5sZXZlbENvbnRyb2xsZXIgPSBuZXcgTGV2ZWxDb250cm9sbGVyKHRoaXMpO1xuICAgIGNvbnN0IHN0cmVhbUNvbnRyb2xsZXIgPSB0aGlzLnN0cmVhbUNvbnRyb2xsZXIgPSBuZXcgU3RyZWFtQ29udHJvbGxlcih0aGlzKTtcbiAgICBsZXQgbmV0d29ya0NvbnRyb2xsZXJzID0gW2xldmVsQ29udHJvbGxlciwgc3RyZWFtQ29udHJvbGxlcl07XG5cbiAgICAvLyBvcHRpb25hbCBhdWRpbyBzdHJlYW0gY29udHJvbGxlclxuICAgIGxldCBDb250cm9sbGVyID0gY29uZmlnLmF1ZGlvU3RyZWFtQ29udHJvbGxlcjtcbiAgICBpZiAoQ29udHJvbGxlcikge1xuICAgICAgbmV0d29ya0NvbnRyb2xsZXJzLnB1c2gobmV3IENvbnRyb2xsZXIodGhpcykpO1xuICAgIH1cbiAgICB0aGlzLm5ldHdvcmtDb250cm9sbGVycyA9IG5ldHdvcmtDb250cm9sbGVycztcblxuICAgIGxldCBjb3JlQ29tcG9uZW50cyA9IFsgcGxheUxpc3RMb2FkZXIsIGZyYWdtZW50TG9hZGVyLCBrZXlMb2FkZXIsIGFickNvbnRyb2xsZXIsIGJ1ZmZlckNvbnRyb2xsZXIsIGNhcExldmVsQ29udHJvbGxlciwgZnBzQ29udHJvbGxlciBdO1xuXG4gICAgLy8gb3B0aW9uYWwgYXVkaW8gdHJhY2sgYW5kIHN1YnRpdGxlIGNvbnRyb2xsZXJcbiAgICBDb250cm9sbGVyID0gY29uZmlnLmF1ZGlvVHJhY2tDb250cm9sbGVyO1xuICAgIGlmIChDb250cm9sbGVyKSB7XG4gICAgICBsZXQgYXVkaW9UcmFja0NvbnRyb2xsZXIgPSBuZXcgQ29udHJvbGxlcih0aGlzKTtcbiAgICAgIHRoaXMuYXVkaW9UcmFja0NvbnRyb2xsZXIgPSBhdWRpb1RyYWNrQ29udHJvbGxlcjtcbiAgICAgIGNvcmVDb21wb25lbnRzLnB1c2goYXVkaW9UcmFja0NvbnRyb2xsZXIpO1xuICAgIH1cblxuICAgIENvbnRyb2xsZXIgPSBjb25maWcuc3VidGl0bGVUcmFja0NvbnRyb2xsZXI7XG4gICAgaWYgKENvbnRyb2xsZXIpIHtcbiAgICAgIGxldCBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlciA9IG5ldyBDb250cm9sbGVyKHRoaXMpO1xuICAgICAgdGhpcy5zdWJ0aXRsZVRyYWNrQ29udHJvbGxlciA9IHN1YnRpdGxlVHJhY2tDb250cm9sbGVyO1xuICAgICAgY29yZUNvbXBvbmVudHMucHVzaChzdWJ0aXRsZVRyYWNrQ29udHJvbGxlcik7XG4gICAgfVxuXG4gICAgLy8gb3B0aW9uYWwgc3VidGl0bGUgY29udHJvbGxlclxuICAgIFtjb25maWcuc3VidGl0bGVTdHJlYW1Db250cm9sbGVyLCBjb25maWcudGltZWxpbmVDb250cm9sbGVyXS5mb3JFYWNoKENvbnRyb2xsZXIgPT4ge1xuICAgICAgaWYgKENvbnRyb2xsZXIpIHtcbiAgICAgICAgY29yZUNvbXBvbmVudHMucHVzaChuZXcgQ29udHJvbGxlcih0aGlzKSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5jb3JlQ29tcG9uZW50cyA9IGNvcmVDb21wb25lbnRzO1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICBsb2dnZXIubG9nKCdkZXN0cm95Jyk7XG4gICAgdGhpcy50cmlnZ2VyKEV2ZW50LkRFU1RST1lJTkcpO1xuICAgIHRoaXMuZGV0YWNoTWVkaWEoKTtcbiAgICB0aGlzLmNvcmVDb21wb25lbnRzLmNvbmNhdCh0aGlzLm5ldHdvcmtDb250cm9sbGVycykuZm9yRWFjaChjb21wb25lbnQgPT4ge2NvbXBvbmVudC5kZXN0cm95KCk7fSk7XG4gICAgdGhpcy51cmwgPSBudWxsO1xuICAgIHRoaXMub2JzZXJ2ZXIucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgdGhpcy5fYXV0b0xldmVsQ2FwcGluZyA9IC0xO1xuICB9XG5cbiAgYXR0YWNoTWVkaWEobWVkaWEpIHtcbiAgICBsb2dnZXIubG9nKCdhdHRhY2hNZWRpYScpO1xuICAgIHRoaXMubWVkaWEgPSBtZWRpYTtcbiAgICB0aGlzLnRyaWdnZXIoRXZlbnQuTUVESUFfQVRUQUNISU5HLCB7bWVkaWE6IG1lZGlhfSk7XG4gIH1cblxuICBkZXRhY2hNZWRpYSgpIHtcbiAgICBsb2dnZXIubG9nKCdkZXRhY2hNZWRpYScpO1xuICAgIHRoaXMudHJpZ2dlcihFdmVudC5NRURJQV9ERVRBQ0hJTkcpO1xuICAgIHRoaXMubWVkaWEgPSBudWxsO1xuICB9XG5cbiAgbG9hZFNvdXJjZSh1cmwpIHtcbiAgICB1cmwgPSBVUkxUb29sa2l0LmJ1aWxkQWJzb2x1dGVVUkwod2luZG93LmxvY2F0aW9uLmhyZWYsIHVybCwgeyBhbHdheXNOb3JtYWxpemU6IHRydWUgfSk7XG4gICAgbG9nZ2VyLmxvZyhgbG9hZFNvdXJjZToke3VybH1gKTtcbiAgICB0aGlzLnVybCA9IHVybDtcbiAgICAvLyB3aGVuIGF0dGFjaGluZyB0byBhIHNvdXJjZSBVUkwsIHRyaWdnZXIgYSBwbGF5bGlzdCBsb2FkXG4gICAgdGhpcy50cmlnZ2VyKEV2ZW50Lk1BTklGRVNUX0xPQURJTkcsIHt1cmw6IHVybH0pO1xuICB9XG5cbiAgc3RhcnRMb2FkKHN0YXJ0UG9zaXRpb249LTEpIHtcbiAgICBsb2dnZXIubG9nKGBzdGFydExvYWQoJHtzdGFydFBvc2l0aW9ufSlgKTtcbiAgICB0aGlzLm5ldHdvcmtDb250cm9sbGVycy5mb3JFYWNoKGNvbnRyb2xsZXIgPT4ge2NvbnRyb2xsZXIuc3RhcnRMb2FkKHN0YXJ0UG9zaXRpb24pO30pO1xuICB9XG5cbiAgc3RvcExvYWQoKSB7XG4gICAgbG9nZ2VyLmxvZygnc3RvcExvYWQnKTtcbiAgICB0aGlzLm5ldHdvcmtDb250cm9sbGVycy5mb3JFYWNoKGNvbnRyb2xsZXIgPT4ge2NvbnRyb2xsZXIuc3RvcExvYWQoKTt9KTtcbiAgfVxuXG4gIHN3YXBBdWRpb0NvZGVjKCkge1xuICAgIGxvZ2dlci5sb2coJ3N3YXBBdWRpb0NvZGVjJyk7XG4gICAgdGhpcy5zdHJlYW1Db250cm9sbGVyLnN3YXBBdWRpb0NvZGVjKCk7XG4gIH1cblxuICByZWNvdmVyTWVkaWFFcnJvcigpIHtcbiAgICBsb2dnZXIubG9nKCdyZWNvdmVyTWVkaWFFcnJvcicpO1xuICAgIHZhciBtZWRpYSA9IHRoaXMubWVkaWE7XG4gICAgdGhpcy5kZXRhY2hNZWRpYSgpO1xuICAgIHRoaXMuYXR0YWNoTWVkaWEobWVkaWEpO1xuICB9XG5cbiAgLyoqIFJldHVybiBhbGwgcXVhbGl0eSBsZXZlbHMgKiovXG4gIGdldCBsZXZlbHMoKSB7XG4gICAgcmV0dXJuIHRoaXMubGV2ZWxDb250cm9sbGVyLmxldmVscztcbiAgfVxuXG4gIC8qKiBSZXR1cm4gY3VycmVudCBwbGF5YmFjayBxdWFsaXR5IGxldmVsICoqL1xuICBnZXQgY3VycmVudExldmVsKCkge1xuICAgIHJldHVybiB0aGlzLnN0cmVhbUNvbnRyb2xsZXIuY3VycmVudExldmVsO1xuICB9XG5cbiAgLyogc2V0IHF1YWxpdHkgbGV2ZWwgaW1tZWRpYXRlbHkgKC0xIGZvciBhdXRvbWF0aWMgbGV2ZWwgc2VsZWN0aW9uKSAqL1xuICBzZXQgY3VycmVudExldmVsKG5ld0xldmVsKSB7XG4gICAgbG9nZ2VyLmxvZyhgc2V0IGN1cnJlbnRMZXZlbDoke25ld0xldmVsfWApO1xuICAgIHRoaXMubG9hZExldmVsID0gbmV3TGV2ZWw7XG4gICAgdGhpcy5zdHJlYW1Db250cm9sbGVyLmltbWVkaWF0ZUxldmVsU3dpdGNoKCk7XG4gIH1cblxuICAvKiogUmV0dXJuIG5leHQgcGxheWJhY2sgcXVhbGl0eSBsZXZlbCAocXVhbGl0eSBsZXZlbCBvZiBuZXh0IGZyYWdtZW50KSAqKi9cbiAgZ2V0IG5leHRMZXZlbCgpIHtcbiAgICByZXR1cm4gdGhpcy5zdHJlYW1Db250cm9sbGVyLm5leHRMZXZlbDtcbiAgfVxuXG4gIC8qIHNldCBxdWFsaXR5IGxldmVsIGZvciBuZXh0IGZyYWdtZW50ICgtMSBmb3IgYXV0b21hdGljIGxldmVsIHNlbGVjdGlvbikgKi9cbiAgc2V0IG5leHRMZXZlbChuZXdMZXZlbCkge1xuICAgIGxvZ2dlci5sb2coYHNldCBuZXh0TGV2ZWw6JHtuZXdMZXZlbH1gKTtcbiAgICB0aGlzLmxldmVsQ29udHJvbGxlci5tYW51YWxMZXZlbCA9IG5ld0xldmVsO1xuICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlci5uZXh0TGV2ZWxTd2l0Y2goKTtcbiAgfVxuXG4gIC8qKiBSZXR1cm4gdGhlIHF1YWxpdHkgbGV2ZWwgb2YgY3VycmVudC9sYXN0IGxvYWRlZCBmcmFnbWVudCAqKi9cbiAgZ2V0IGxvYWRMZXZlbCgpIHtcbiAgICByZXR1cm4gdGhpcy5sZXZlbENvbnRyb2xsZXIubGV2ZWw7XG4gIH1cblxuICAvKiBzZXQgcXVhbGl0eSBsZXZlbCBmb3IgY3VycmVudC9uZXh0IGxvYWRlZCBmcmFnbWVudCAoLTEgZm9yIGF1dG9tYXRpYyBsZXZlbCBzZWxlY3Rpb24pICovXG4gIHNldCBsb2FkTGV2ZWwobmV3TGV2ZWwpIHtcbiAgICBsb2dnZXIubG9nKGBzZXQgbG9hZExldmVsOiR7bmV3TGV2ZWx9YCk7XG4gICAgdGhpcy5sZXZlbENvbnRyb2xsZXIubWFudWFsTGV2ZWwgPSBuZXdMZXZlbDtcbiAgfVxuXG4gIC8qKiBSZXR1cm4gdGhlIHF1YWxpdHkgbGV2ZWwgb2YgbmV4dCBsb2FkZWQgZnJhZ21lbnQgKiovXG4gIGdldCBuZXh0TG9hZExldmVsKCkge1xuICAgIHJldHVybiB0aGlzLmxldmVsQ29udHJvbGxlci5uZXh0TG9hZExldmVsO1xuICB9XG5cbiAgLyoqIHNldCBxdWFsaXR5IGxldmVsIG9mIG5leHQgbG9hZGVkIGZyYWdtZW50ICoqL1xuICBzZXQgbmV4dExvYWRMZXZlbChsZXZlbCkge1xuICAgIHRoaXMubGV2ZWxDb250cm9sbGVyLm5leHRMb2FkTGV2ZWwgPSBsZXZlbDtcbiAgfVxuXG4gIC8qKiBSZXR1cm4gZmlyc3QgbGV2ZWwgKGluZGV4IG9mIGZpcnN0IGxldmVsIHJlZmVyZW5jZWQgaW4gbWFuaWZlc3QpXG4gICoqL1xuICBnZXQgZmlyc3RMZXZlbCgpIHtcbiAgICByZXR1cm4gTWF0aC5tYXgodGhpcy5sZXZlbENvbnRyb2xsZXIuZmlyc3RMZXZlbCwgdGhpcy5taW5BdXRvTGV2ZWwpO1xuICB9XG5cbiAgLyoqIHNldCBmaXJzdCBsZXZlbCAoaW5kZXggb2YgZmlyc3QgbGV2ZWwgcmVmZXJlbmNlZCBpbiBtYW5pZmVzdClcbiAgKiovXG4gIHNldCBmaXJzdExldmVsKG5ld0xldmVsKSB7XG4gICAgbG9nZ2VyLmxvZyhgc2V0IGZpcnN0TGV2ZWw6JHtuZXdMZXZlbH1gKTtcbiAgICB0aGlzLmxldmVsQ29udHJvbGxlci5maXJzdExldmVsID0gbmV3TGV2ZWw7XG4gIH1cblxuICAvKiogUmV0dXJuIHN0YXJ0IGxldmVsIChsZXZlbCBvZiBmaXJzdCBmcmFnbWVudCB0aGF0IHdpbGwgYmUgcGxheWVkIGJhY2spXG4gICAgICBpZiBub3Qgb3ZlcnJpZGVkIGJ5IHVzZXIsIGZpcnN0IGxldmVsIGFwcGVhcmluZyBpbiBtYW5pZmVzdCB3aWxsIGJlIHVzZWQgYXMgc3RhcnQgbGV2ZWxcbiAgICAgIGlmIC0xIDogYXV0b21hdGljIHN0YXJ0IGxldmVsIHNlbGVjdGlvbiwgcGxheWJhY2sgd2lsbCBzdGFydCBmcm9tIGxldmVsIG1hdGNoaW5nIGRvd25sb2FkIGJhbmR3aWR0aCAoZGV0ZXJtaW5lZCBmcm9tIGRvd25sb2FkIG9mIGZpcnN0IHNlZ21lbnQpXG4gICoqL1xuICBnZXQgc3RhcnRMZXZlbCgpIHtcbiAgICByZXR1cm4gdGhpcy5sZXZlbENvbnRyb2xsZXIuc3RhcnRMZXZlbDtcbiAgfVxuXG4gIC8qKiBzZXQgIHN0YXJ0IGxldmVsIChsZXZlbCBvZiBmaXJzdCBmcmFnbWVudCB0aGF0IHdpbGwgYmUgcGxheWVkIGJhY2spXG4gICAgICBpZiBub3Qgb3ZlcnJpZGVkIGJ5IHVzZXIsIGZpcnN0IGxldmVsIGFwcGVhcmluZyBpbiBtYW5pZmVzdCB3aWxsIGJlIHVzZWQgYXMgc3RhcnQgbGV2ZWxcbiAgICAgIGlmIC0xIDogYXV0b21hdGljIHN0YXJ0IGxldmVsIHNlbGVjdGlvbiwgcGxheWJhY2sgd2lsbCBzdGFydCBmcm9tIGxldmVsIG1hdGNoaW5nIGRvd25sb2FkIGJhbmR3aWR0aCAoZGV0ZXJtaW5lZCBmcm9tIGRvd25sb2FkIG9mIGZpcnN0IHNlZ21lbnQpXG4gICoqL1xuICBzZXQgc3RhcnRMZXZlbChuZXdMZXZlbCkge1xuICAgIGxvZ2dlci5sb2coYHNldCBzdGFydExldmVsOiR7bmV3TGV2ZWx9YCk7XG4gICAgY29uc3QgaGxzID0gdGhpcztcbiAgICAvLyBpZiBub3QgaW4gYXV0b21hdGljIHN0YXJ0IGxldmVsIGRldGVjdGlvbiwgZW5zdXJlIHN0YXJ0TGV2ZWwgaXMgZ3JlYXRlciB0aGFuIG1pbkF1dG9MZXZlbFxuICAgIGlmIChuZXdMZXZlbCAhPT0gLTEpIHtcbiAgICAgIG5ld0xldmVsID0gTWF0aC5tYXgobmV3TGV2ZWwsaGxzLm1pbkF1dG9MZXZlbCk7XG4gICAgfVxuICAgIGhscy5sZXZlbENvbnRyb2xsZXIuc3RhcnRMZXZlbCA9IG5ld0xldmVsO1xuICB9XG5cbiAgLyoqIFJldHVybiB0aGUgY2FwcGluZy9tYXggbGV2ZWwgdmFsdWUgdGhhdCBjb3VsZCBiZSB1c2VkIGJ5IGF1dG9tYXRpYyBsZXZlbCBzZWxlY3Rpb24gYWxnb3JpdGhtICoqL1xuICBnZXQgYXV0b0xldmVsQ2FwcGluZygpIHtcbiAgICByZXR1cm4gdGhpcy5fYXV0b0xldmVsQ2FwcGluZztcbiAgfVxuXG4gIC8qKiBzZXQgdGhlIGNhcHBpbmcvbWF4IGxldmVsIHZhbHVlIHRoYXQgY291bGQgYmUgdXNlZCBieSBhdXRvbWF0aWMgbGV2ZWwgc2VsZWN0aW9uIGFsZ29yaXRobSAqKi9cbiAgc2V0IGF1dG9MZXZlbENhcHBpbmcobmV3TGV2ZWwpIHtcbiAgICBsb2dnZXIubG9nKGBzZXQgYXV0b0xldmVsQ2FwcGluZzoke25ld0xldmVsfWApO1xuICAgIHRoaXMuX2F1dG9MZXZlbENhcHBpbmcgPSBuZXdMZXZlbDtcbiAgfVxuXG4gIC8qIGNoZWNrIGlmIHdlIGFyZSBpbiBhdXRvbWF0aWMgbGV2ZWwgc2VsZWN0aW9uIG1vZGUgKi9cbiAgZ2V0IGF1dG9MZXZlbEVuYWJsZWQoKSB7XG4gICAgcmV0dXJuICh0aGlzLmxldmVsQ29udHJvbGxlci5tYW51YWxMZXZlbCA9PT0gLTEpO1xuICB9XG5cbiAgLyogcmV0dXJuIG1hbnVhbCBsZXZlbCAqL1xuICBnZXQgbWFudWFsTGV2ZWwoKSB7XG4gICAgcmV0dXJuIHRoaXMubGV2ZWxDb250cm9sbGVyLm1hbnVhbExldmVsO1xuICB9XG5cbiAgLyogcmV0dXJuIG1pbiBsZXZlbCBzZWxlY3RhYmxlIGluIGF1dG8gbW9kZSBhY2NvcmRpbmcgdG8gY29uZmlnLm1pbkF1dG9CaXRyYXRlICovXG4gIGdldCBtaW5BdXRvTGV2ZWwoKSB7XG4gICAgbGV0IGhscyA9IHRoaXMsIGxldmVscyA9IGhscy5sZXZlbHMsIG1pbkF1dG9CaXRyYXRlID0gaGxzLmNvbmZpZy5taW5BdXRvQml0cmF0ZSwgbGVuID0gbGV2ZWxzID8gbGV2ZWxzLmxlbmd0aCA6IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgY29uc3QgbGV2ZWxOZXh0Qml0cmF0ZSA9IGxldmVsc1tpXS5yZWFsQml0cmF0ZSA/IE1hdGgubWF4KGxldmVsc1tpXS5yZWFsQml0cmF0ZSxsZXZlbHNbaV0uYml0cmF0ZSkgOiBsZXZlbHNbaV0uYml0cmF0ZTtcbiAgICAgIGlmIChsZXZlbE5leHRCaXRyYXRlID4gbWluQXV0b0JpdHJhdGUpIHtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9XG5cbiAgLyogcmV0dXJuIG1heCBsZXZlbCBzZWxlY3RhYmxlIGluIGF1dG8gbW9kZSBhY2NvcmRpbmcgdG8gYXV0b0xldmVsQ2FwcGluZyAqL1xuICBnZXQgbWF4QXV0b0xldmVsKCkge1xuICAgIGNvbnN0IGhscyA9IHRoaXM7XG4gICAgY29uc3QgbGV2ZWxzID0gaGxzLmxldmVscztcbiAgICBjb25zdCBhdXRvTGV2ZWxDYXBwaW5nID0gaGxzLmF1dG9MZXZlbENhcHBpbmc7XG4gICAgbGV0IG1heEF1dG9MZXZlbDtcbiAgICBpZiAoYXV0b0xldmVsQ2FwcGluZz09PSAtMSAmJiBsZXZlbHMgJiYgbGV2ZWxzLmxlbmd0aCkge1xuICAgICAgbWF4QXV0b0xldmVsID0gbGV2ZWxzLmxlbmd0aCAtIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1heEF1dG9MZXZlbCA9IGF1dG9MZXZlbENhcHBpbmc7XG4gICAgfVxuICAgIHJldHVybiBtYXhBdXRvTGV2ZWw7XG4gIH1cblxuICAvLyByZXR1cm4gbmV4dCBhdXRvIGxldmVsXG4gIGdldCBuZXh0QXV0b0xldmVsKCkge1xuICAgIGNvbnN0IGhscyA9IHRoaXM7XG4gICAgLy8gZW5zdXJlIG5leHQgYXV0byBsZXZlbCBpcyBiZXR3ZWVuICBtaW4gYW5kIG1heCBhdXRvIGxldmVsXG4gICAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KGhscy5hYnJDb250cm9sbGVyLm5leHRBdXRvTGV2ZWwsaGxzLm1pbkF1dG9MZXZlbCksaGxzLm1heEF1dG9MZXZlbCk7XG4gIH1cblxuICAvLyB0aGlzIHNldHRlciBpcyB1c2VkIHRvIGZvcmNlIG5leHQgYXV0byBsZXZlbFxuICAvLyB0aGlzIGlzIHVzZWZ1bCB0byBmb3JjZSBhIHN3aXRjaCBkb3duIGluIGF1dG8gbW9kZSA6IGluIGNhc2Ugb2YgbG9hZCBlcnJvciBvbiBsZXZlbCBOLCBobHMuanMgY2FuIHNldCBuZXh0QXV0b0xldmVsIHRvIE4tMSBmb3IgZXhhbXBsZSlcbiAgLy8gZm9yY2VkIHZhbHVlIGlzIHZhbGlkIGZvciBvbmUgZnJhZ21lbnQuIHVwb24gc3VjY2VzZnVsIGZyYWcgbG9hZGluZyBhdCBmb3JjZWQgbGV2ZWwsIHRoaXMgdmFsdWUgd2lsbCBiZSByZXNldHRlZCB0byAtMSBieSBBQlIgY29udHJvbGxlclxuICBzZXQgbmV4dEF1dG9MZXZlbChuZXh0TGV2ZWwpIHtcbiAgICBjb25zdCBobHMgPSB0aGlzO1xuICAgIGhscy5hYnJDb250cm9sbGVyLm5leHRBdXRvTGV2ZWwgPSBNYXRoLm1heChobHMubWluQXV0b0xldmVsLG5leHRMZXZlbCk7XG4gIH1cblxuICAvKiogZ2V0IGFsdGVybmF0ZSBhdWRpbyB0cmFja3MgbGlzdCBmcm9tIHBsYXlsaXN0ICoqL1xuICBnZXQgYXVkaW9UcmFja3MoKSB7XG4gICAgY29uc3QgYXVkaW9UcmFja0NvbnRyb2xsZXIgPSB0aGlzLmF1ZGlvVHJhY2tDb250cm9sbGVyO1xuICAgIHJldHVybiBhdWRpb1RyYWNrQ29udHJvbGxlciA/IGF1ZGlvVHJhY2tDb250cm9sbGVyLmF1ZGlvVHJhY2tzIDogW107XG4gIH1cblxuICAvKiogZ2V0IGluZGV4IG9mIHRoZSBzZWxlY3RlZCBhdWRpbyB0cmFjayAoaW5kZXggaW4gYXVkaW8gdHJhY2sgbGlzdHMpICoqL1xuICBnZXQgYXVkaW9UcmFjaygpIHtcbiAgICBjb25zdCBhdWRpb1RyYWNrQ29udHJvbGxlciA9IHRoaXMuYXVkaW9UcmFja0NvbnRyb2xsZXI7XG4gICAgcmV0dXJuIGF1ZGlvVHJhY2tDb250cm9sbGVyID8gYXVkaW9UcmFja0NvbnRyb2xsZXIuYXVkaW9UcmFjayA6IC0xO1xuICB9XG5cbiAgLyoqIHNlbGVjdCBhbiBhdWRpbyB0cmFjaywgYmFzZWQgb24gaXRzIGluZGV4IGluIGF1ZGlvIHRyYWNrIGxpc3RzKiovXG4gIHNldCBhdWRpb1RyYWNrKGF1ZGlvVHJhY2tJZCkge1xuICAgIGNvbnN0IGF1ZGlvVHJhY2tDb250cm9sbGVyID0gdGhpcy5hdWRpb1RyYWNrQ29udHJvbGxlcjtcbiAgICBpZiAoYXVkaW9UcmFja0NvbnRyb2xsZXIpIHtcbiAgICAgIGF1ZGlvVHJhY2tDb250cm9sbGVyLmF1ZGlvVHJhY2sgPSBhdWRpb1RyYWNrSWQ7XG4gICAgfVxuICB9XG5cbiAgZ2V0IGxpdmVTeW5jUG9zaXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RyZWFtQ29udHJvbGxlci5saXZlU3luY1Bvc2l0aW9uO1xuICB9XG5cbiAgLyoqIGdldCBhbHRlcm5hdGUgc3VidGl0bGUgdHJhY2tzIGxpc3QgZnJvbSBwbGF5bGlzdCAqKi9cbiAgZ2V0IHN1YnRpdGxlVHJhY2tzKCkge1xuICAgIGNvbnN0IHN1YnRpdGxlVHJhY2tDb250cm9sbGVyID0gdGhpcy5zdWJ0aXRsZVRyYWNrQ29udHJvbGxlcjtcbiAgICByZXR1cm4gc3VidGl0bGVUcmFja0NvbnRyb2xsZXIgPyBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlci5zdWJ0aXRsZVRyYWNrcyA6IFtdO1xuICB9XG5cbiAgLyoqIGdldCBpbmRleCBvZiB0aGUgc2VsZWN0ZWQgc3VidGl0bGUgdHJhY2sgKGluZGV4IGluIHN1YnRpdGxlIHRyYWNrIGxpc3RzKSAqKi9cbiAgZ2V0IHN1YnRpdGxlVHJhY2soKSB7XG4gICAgY29uc3Qgc3VidGl0bGVUcmFja0NvbnRyb2xsZXIgPSB0aGlzLnN1YnRpdGxlVHJhY2tDb250cm9sbGVyO1xuICAgIHJldHVybiBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlciA/IHN1YnRpdGxlVHJhY2tDb250cm9sbGVyLnN1YnRpdGxlVHJhY2sgOiAtMTtcbiAgfVxuXG4gIC8qKiBzZWxlY3QgYW4gc3VidGl0bGUgdHJhY2ssIGJhc2VkIG9uIGl0cyBpbmRleCBpbiBzdWJ0aXRsZSB0cmFjayBsaXN0cyoqL1xuICBzZXQgc3VidGl0bGVUcmFjayhzdWJ0aXRsZVRyYWNrSWQpIHtcbiAgICBjb25zdCBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlciA9IHRoaXMuc3VidGl0bGVUcmFja0NvbnRyb2xsZXI7XG4gICAgaWYgKHN1YnRpdGxlVHJhY2tDb250cm9sbGVyKSB7XG4gICAgICBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlci5zdWJ0aXRsZVRyYWNrID0gc3VidGl0bGVUcmFja0lkO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBIbHM7XG4iLCIvLyBUaGlzIGlzIG1vc3RseSBmb3Igc3VwcG9ydCBvZiB0aGUgZXM2IG1vZHVsZSBleHBvcnRcbi8vIHN5bnRheCB3aXRoIHRoZSBiYWJlbCBjb21waWxlciwgaXQgbG9va3MgbGlrZSBpdCBkb2VzbnQgc3VwcG9ydFxuLy8gZnVuY3Rpb24gZXhwb3J0cyBsaWtlIHdlIGFyZSB1c2VkIHRvIGluIG5vZGUvY29tbW9uanNcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9obHMuanMnKS5kZWZhdWx0O1xuIiwiLypcbiAqIEZyYWdtZW50IExvYWRlclxuKi9cblxuaW1wb3J0IEV2ZW50IGZyb20gJy4uL2V2ZW50cyc7XG5pbXBvcnQgRXZlbnRIYW5kbGVyIGZyb20gJy4uL2V2ZW50LWhhbmRsZXInO1xuaW1wb3J0IHtFcnJvclR5cGVzLCBFcnJvckRldGFpbHN9IGZyb20gJy4uL2Vycm9ycyc7XG5pbXBvcnQge2xvZ2dlcn0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcblxuY2xhc3MgRnJhZ21lbnRMb2FkZXIgZXh0ZW5kcyBFdmVudEhhbmRsZXIge1xuXG4gIGNvbnN0cnVjdG9yKGhscykge1xuICAgIHN1cGVyKGhscywgRXZlbnQuRlJBR19MT0FESU5HKTtcbiAgICB0aGlzLmxvYWRlcnMgPSB7fTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgbGV0IGxvYWRlcnMgPSB0aGlzLmxvYWRlcnM7XG4gICAgZm9yIChsZXQgbG9hZGVyTmFtZSBpbiBsb2FkZXJzKSB7XG4gICAgICBsZXQgbG9hZGVyID0gbG9hZGVyc1tsb2FkZXJOYW1lXTtcbiAgICAgIGlmIChsb2FkZXIpIHtcbiAgICAgICAgbG9hZGVyLmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5sb2FkZXJzID0ge307XG4gICAgRXZlbnRIYW5kbGVyLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XG4gIH1cblxuICBvbkZyYWdMb2FkaW5nKGRhdGEpIHtcbiAgICBsZXQgZnJhZyA9IGRhdGEuZnJhZyxcbiAgICAgICAgdHlwZSA9IGZyYWcudHlwZSxcbiAgICAgICAgbG9hZGVyID0gdGhpcy5sb2FkZXJzW3R5cGVdLFxuICAgICAgICBjb25maWcgPSB0aGlzLmhscy5jb25maWc7XG5cbiAgICBmcmFnLmxvYWRlZCA9IDA7XG4gICAgaWYgKGxvYWRlcikge1xuICAgICAgbG9nZ2VyLndhcm4oYGFib3J0IHByZXZpb3VzIGZyYWdtZW50IGxvYWRlciBmb3IgdHlwZToke3R5cGV9YCk7XG4gICAgICBsb2FkZXIuYWJvcnQoKTtcbiAgICB9XG4gICAgbG9hZGVyICA9IHRoaXMubG9hZGVyc1t0eXBlXSA9IGZyYWcubG9hZGVyID0gdHlwZW9mKGNvbmZpZy5mTG9hZGVyKSAhPT0gJ3VuZGVmaW5lZCcgPyBuZXcgY29uZmlnLmZMb2FkZXIoY29uZmlnKSA6IG5ldyBjb25maWcubG9hZGVyKGNvbmZpZyk7XG5cbiAgICBsZXQgbG9hZGVyQ29udGV4dCwgbG9hZGVyQ29uZmlnLCBsb2FkZXJDYWxsYmFja3M7XG4gICAgbG9hZGVyQ29udGV4dCA9IHsgdXJsIDogZnJhZy51cmwsIGZyYWcgOiBmcmFnLCByZXNwb25zZVR5cGUgOiAnYXJyYXlidWZmZXInLCBwcm9ncmVzc0RhdGEgOiBmYWxzZX07XG4gICAgbGV0IHN0YXJ0ID0gZnJhZy5ieXRlUmFuZ2VTdGFydE9mZnNldCwgZW5kID0gZnJhZy5ieXRlUmFuZ2VFbmRPZmZzZXQ7XG4gICAgaWYgKCFpc05hTihzdGFydCkgJiYgIWlzTmFOKGVuZCkpIHtcbiAgICAgIGxvYWRlckNvbnRleHQucmFuZ2VTdGFydCA9IHN0YXJ0O1xuICAgICAgbG9hZGVyQ29udGV4dC5yYW5nZUVuZCA9IGVuZDtcbiAgICB9XG4gICAgbG9hZGVyQ29uZmlnID0geyB0aW1lb3V0IDogY29uZmlnLmZyYWdMb2FkaW5nVGltZU91dCwgbWF4UmV0cnkgOiAwICwgcmV0cnlEZWxheSA6IDAsIG1heFJldHJ5RGVsYXkgOiBjb25maWcuZnJhZ0xvYWRpbmdNYXhSZXRyeVRpbWVvdXR9O1xuICAgIGxvYWRlckNhbGxiYWNrcyA9IHsgb25TdWNjZXNzIDogdGhpcy5sb2Fkc3VjY2Vzcy5iaW5kKHRoaXMpLCBvbkVycm9yIDp0aGlzLmxvYWRlcnJvci5iaW5kKHRoaXMpLCBvblRpbWVvdXQgOiB0aGlzLmxvYWR0aW1lb3V0LmJpbmQodGhpcyksIG9uUHJvZ3Jlc3M6IHRoaXMubG9hZHByb2dyZXNzLmJpbmQodGhpcyl9O1xuICAgIGxvYWRlci5sb2FkKGxvYWRlckNvbnRleHQsbG9hZGVyQ29uZmlnLGxvYWRlckNhbGxiYWNrcyk7XG4gIH1cblxuICBsb2Fkc3VjY2VzcyhyZXNwb25zZSwgc3RhdHMsIGNvbnRleHQpIHtcbiAgICBsZXQgcGF5bG9hZCA9IHJlc3BvbnNlLmRhdGEsIGZyYWcgPSBjb250ZXh0LmZyYWc7XG4gICAgLy8gZGV0YWNoIGZyYWdtZW50IGxvYWRlciBvbiBsb2FkIHN1Y2Nlc3NcbiAgICBmcmFnLmxvYWRlciA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmxvYWRlcnNbZnJhZy50eXBlXSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkZSQUdfTE9BREVELCB7cGF5bG9hZDogcGF5bG9hZCwgZnJhZzogZnJhZywgc3RhdHM6IHN0YXRzfSk7XG4gIH1cblxuICBsb2FkZXJyb3IocmVzcG9uc2UsIGNvbnRleHQpIHtcbiAgICBsZXQgbG9hZGVyID0gY29udGV4dC5sb2FkZXI7XG4gICAgaWYgKGxvYWRlcikge1xuICAgICAgbG9hZGVyLmFib3J0KCk7XG4gICAgfVxuICAgIHRoaXMubG9hZGVyc1tjb250ZXh0LnR5cGVdID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuRVJST1IsIHt0eXBlOiBFcnJvclR5cGVzLk5FVFdPUktfRVJST1IsIGRldGFpbHM6IEVycm9yRGV0YWlscy5GUkFHX0xPQURfRVJST1IsIGZhdGFsOiBmYWxzZSwgZnJhZzogY29udGV4dC5mcmFnLCByZXNwb25zZTogcmVzcG9uc2V9KTtcbiAgfVxuXG4gIGxvYWR0aW1lb3V0KHN0YXRzLCBjb250ZXh0KSB7XG4gICAgbGV0IGxvYWRlciA9IGNvbnRleHQubG9hZGVyO1xuICAgIGlmIChsb2FkZXIpIHtcbiAgICAgIGxvYWRlci5hYm9ydCgpO1xuICAgIH1cbiAgICB0aGlzLmxvYWRlcnNbY29udGV4dC50eXBlXSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkVSUk9SLCB7dHlwZTogRXJyb3JUeXBlcy5ORVRXT1JLX0VSUk9SLCBkZXRhaWxzOiBFcnJvckRldGFpbHMuRlJBR19MT0FEX1RJTUVPVVQsIGZhdGFsOiBmYWxzZSwgZnJhZzogY29udGV4dC5mcmFnfSk7XG4gIH1cblxuICAvLyBkYXRhIHdpbGwgYmUgdXNlZCBmb3IgcHJvZ3Jlc3NpdmUgcGFyc2luZ1xuICBsb2FkcHJvZ3Jlc3Moc3RhdHMsIGNvbnRleHQsIGRhdGEpIHsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG4gICAgbGV0IGZyYWcgPSBjb250ZXh0LmZyYWc7XG4gICAgZnJhZy5sb2FkZWQgPSBzdGF0cy5sb2FkZWQ7XG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5GUkFHX0xPQURfUFJPR1JFU1MsIHtmcmFnOiBmcmFnLCBzdGF0czogc3RhdHN9KTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBGcmFnbWVudExvYWRlcjtcbiIsIi8qXG4gKiBEZWNyeXB0IGtleSBMb2FkZXJcbiovXG5cbmltcG9ydCBFdmVudCBmcm9tICcuLi9ldmVudHMnO1xuaW1wb3J0IEV2ZW50SGFuZGxlciBmcm9tICcuLi9ldmVudC1oYW5kbGVyJztcbmltcG9ydCB7RXJyb3JUeXBlcywgRXJyb3JEZXRhaWxzfSBmcm9tICcuLi9lcnJvcnMnO1xuaW1wb3J0IHtsb2dnZXJ9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XG5cbmNsYXNzIEtleUxvYWRlciBleHRlbmRzIEV2ZW50SGFuZGxlciB7XG5cbiAgY29uc3RydWN0b3IoaGxzKSB7XG4gICAgc3VwZXIoaGxzLCBFdmVudC5LRVlfTE9BRElORyk7XG4gICAgdGhpcy5sb2FkZXJzID0ge307XG4gICAgdGhpcy5kZWNyeXB0a2V5ID0gbnVsbDtcbiAgICB0aGlzLmRlY3J5cHR1cmwgPSBudWxsO1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICBmb3IgKGxldCBsb2FkZXJOYW1lIGluIHRoaXMubG9hZGVycykge1xuICAgICAgbGV0IGxvYWRlciA9IHRoaXMubG9hZGVyc1tsb2FkZXJOYW1lXTtcbiAgICAgIGlmIChsb2FkZXIpIHtcbiAgICAgICAgbG9hZGVyLmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5sb2FkZXJzID0ge307XG4gICAgRXZlbnRIYW5kbGVyLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XG4gIH1cblxuICBvbktleUxvYWRpbmcoZGF0YSkge1xuICAgIGxldCBmcmFnID0gZGF0YS5mcmFnLFxuICAgICAgICB0eXBlID0gZnJhZy50eXBlLFxuICAgICAgICBsb2FkZXIgPSB0aGlzLmxvYWRlcnNbdHlwZV0sXG4gICAgICAgIGRlY3J5cHRkYXRhID0gZnJhZy5kZWNyeXB0ZGF0YSxcbiAgICAgICAgdXJpID0gZGVjcnlwdGRhdGEudXJpO1xuICAgICAgICAvLyBpZiB1cmkgaXMgZGlmZmVyZW50IGZyb20gcHJldmlvdXMgb25lIG9yIGlmIGRlY3J5cHQga2V5IG5vdCByZXRyaWV2ZWQgeWV0XG4gICAgICBpZiAodXJpICE9PSB0aGlzLmRlY3J5cHR1cmwgfHwgdGhpcy5kZWNyeXB0a2V5ID09PSBudWxsKSB7XG4gICAgICAgIGxldCBjb25maWcgPSB0aGlzLmhscy5jb25maWc7XG5cbiAgICAgICAgaWYgKGxvYWRlcikge1xuICAgICAgICAgIGxvZ2dlci53YXJuKGBhYm9ydCBwcmV2aW91cyBrZXkgbG9hZGVyIGZvciB0eXBlOiR7dHlwZX1gKTtcbiAgICAgICAgICBsb2FkZXIuYWJvcnQoKTtcbiAgICAgICAgfVxuICAgICAgICBmcmFnLmxvYWRlciA9IHRoaXMubG9hZGVyc1t0eXBlXSA9IG5ldyBjb25maWcubG9hZGVyKGNvbmZpZyk7XG4gICAgICAgIHRoaXMuZGVjcnlwdHVybCA9IHVyaTtcbiAgICAgICAgdGhpcy5kZWNyeXB0a2V5ID0gbnVsbDtcblxuICAgICAgICBsZXQgbG9hZGVyQ29udGV4dCwgbG9hZGVyQ29uZmlnLCBsb2FkZXJDYWxsYmFja3M7XG4gICAgICAgIGxvYWRlckNvbnRleHQgPSB7IHVybCA6IHVyaSwgZnJhZyA6IGZyYWcsIHJlc3BvbnNlVHlwZSA6ICdhcnJheWJ1ZmZlcid9O1xuICAgICAgICBsb2FkZXJDb25maWcgPSB7IHRpbWVvdXQgOiBjb25maWcuZnJhZ0xvYWRpbmdUaW1lT3V0LCBtYXhSZXRyeSA6IGNvbmZpZy5mcmFnTG9hZGluZ01heFJldHJ5ICwgcmV0cnlEZWxheSA6IGNvbmZpZy5mcmFnTG9hZGluZ1JldHJ5RGVsYXksIG1heFJldHJ5RGVsYXkgOiBjb25maWcuZnJhZ0xvYWRpbmdNYXhSZXRyeVRpbWVvdXR9O1xuICAgICAgICBsb2FkZXJDYWxsYmFja3MgPSB7IG9uU3VjY2VzcyA6IHRoaXMubG9hZHN1Y2Nlc3MuYmluZCh0aGlzKSwgb25FcnJvciA6dGhpcy5sb2FkZXJyb3IuYmluZCh0aGlzKSwgb25UaW1lb3V0IDogdGhpcy5sb2FkdGltZW91dC5iaW5kKHRoaXMpfTtcbiAgICAgICAgZnJhZy5sb2FkZXIubG9hZChsb2FkZXJDb250ZXh0LGxvYWRlckNvbmZpZyxsb2FkZXJDYWxsYmFja3MpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmRlY3J5cHRrZXkpIHtcbiAgICAgICAgLy8gd2UgYWxyZWFkeSBsb2FkZWQgdGhpcyBrZXksIHJldHVybiBpdFxuICAgICAgICBkZWNyeXB0ZGF0YS5rZXkgPSB0aGlzLmRlY3J5cHRrZXk7XG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuS0VZX0xPQURFRCwge2ZyYWc6IGZyYWd9KTtcbiAgICAgIH1cbiAgfVxuXG4gIGxvYWRzdWNjZXNzKHJlc3BvbnNlLCBzdGF0cywgY29udGV4dCkge1xuICAgIGxldCBmcmFnID0gY29udGV4dC5mcmFnO1xuICAgIHRoaXMuZGVjcnlwdGtleSA9IGZyYWcuZGVjcnlwdGRhdGEua2V5ID0gbmV3IFVpbnQ4QXJyYXkocmVzcG9uc2UuZGF0YSk7XG4gICAgLy8gZGV0YWNoIGZyYWdtZW50IGxvYWRlciBvbiBsb2FkIHN1Y2Nlc3NcbiAgICBmcmFnLmxvYWRlciA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmxvYWRlcnNbZnJhZy50eXBlXSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LktFWV9MT0FERUQsIHtmcmFnOiBmcmFnfSk7XG4gIH1cblxuICBsb2FkZXJyb3IocmVzcG9uc2UsIGNvbnRleHQpIHtcbiAgICBsZXQgZnJhZyA9IGNvbnRleHQuZnJhZyxcbiAgICAgICAgbG9hZGVyID0gZnJhZy5sb2FkZXI7XG4gICAgaWYgKGxvYWRlcikge1xuICAgICAgbG9hZGVyLmFib3J0KCk7XG4gICAgfVxuICAgIHRoaXMubG9hZGVyc1tjb250ZXh0LnR5cGVdID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuRVJST1IsIHt0eXBlOiBFcnJvclR5cGVzLk5FVFdPUktfRVJST1IsIGRldGFpbHM6IEVycm9yRGV0YWlscy5LRVlfTE9BRF9FUlJPUiwgZmF0YWw6IGZhbHNlLCBmcmFnOiBmcmFnLCByZXNwb25zZTogcmVzcG9uc2V9KTtcbiAgfVxuXG4gIGxvYWR0aW1lb3V0KHN0YXRzLCBjb250ZXh0KSB7XG4gICAgbGV0IGZyYWcgPSBjb250ZXh0LmZyYWcsXG4gICAgICAgIGxvYWRlciA9IGZyYWcubG9hZGVyO1xuICAgIGlmIChsb2FkZXIpIHtcbiAgICAgIGxvYWRlci5hYm9ydCgpO1xuICAgIH1cbiAgICB0aGlzLmxvYWRlcnNbY29udGV4dC50eXBlXSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkVSUk9SLCB7dHlwZTogRXJyb3JUeXBlcy5ORVRXT1JLX0VSUk9SLCBkZXRhaWxzOiBFcnJvckRldGFpbHMuS0VZX0xPQURfVElNRU9VVCwgZmF0YWw6IGZhbHNlLCBmcmFnOiBmcmFnfSk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgS2V5TG9hZGVyO1xuIiwiLyoqXG4gKiBQbGF5bGlzdCBMb2FkZXJcbiovXG5cbmltcG9ydCBVUkxUb29sa2l0IGZyb20gJ3VybC10b29sa2l0JztcbmltcG9ydCBFdmVudCBmcm9tICcuLi9ldmVudHMnO1xuaW1wb3J0IEV2ZW50SGFuZGxlciBmcm9tICcuLi9ldmVudC1oYW5kbGVyJztcbmltcG9ydCB7RXJyb3JUeXBlcywgRXJyb3JEZXRhaWxzfSBmcm9tICcuLi9lcnJvcnMnO1xuaW1wb3J0IEF0dHJMaXN0IGZyb20gJy4uL3V0aWxzL2F0dHItbGlzdCc7XG5pbXBvcnQge2xvZ2dlcn0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcblxuLy8gaHR0cHM6Ly9yZWdleDEwMS5jb20gaXMgeW91ciBmcmllbmRcbmNvbnN0IE1BU1RFUl9QTEFZTElTVF9SRUdFWCA9IC8jRVhULVgtU1RSRUFNLUlORjooW15cXG5cXHJdKilbXFxyXFxuXSsoW15cXHJcXG5dKykvZztcbmNvbnN0IE1BU1RFUl9QTEFZTElTVF9NRURJQV9SRUdFWCA9IC8jRVhULVgtTUVESUE6KC4qKS9nO1xuY29uc3QgTEVWRUxfUExBWUxJU1RfUkVHRVhfRkFTVCA9IC8jRVhUSU5GOihcXGQqKD86XFwuXFxkKyk/KSg/OiwoLiopKT98KD8hIykoXFxTLispfCNFWFQtWC1CWVRFUkFOR0U6ICooLispfCNFWFQtWC1QUk9HUkFNLURBVEUtVElNRTooLispfCMuKi9nO1xuY29uc3QgTEVWRUxfUExBWUxJU1RfUkVHRVhfU0xPVyA9IC8oPzooPzojKEVYVE0zVSkpfCg/OiNFWFQtWC0oUExBWUxJU1QtVFlQRSk6KC4rKSl8KD86I0VYVC1YLShNRURJQS1TRVFVRU5DRSk6ICooXFxkKykpfCg/OiNFWFQtWC0oVEFSR0VURFVSQVRJT04pOiAqKFxcZCspKXwoPzojRVhULVgtKEtFWSk6KC4rKSl8KD86I0VYVC1YLShTVEFSVCk6KC4rKSl8KD86I0VYVC1YLShFTkRMSVNUKSl8KD86I0VYVC1YLShESVNDT05USU5VSVRZLVNFUSlVRU5DRTooXFxkKykpfCg/OiNFWFQtWC0oRElTKUNPTlRJTlVJVFkpKXwoPzojRVhULVgtKFZFUlNJT04pOihcXGQrKSl8KD86I0VYVC1YLShNQVApOiguKykpfCg/OigjKSguKik6KC4qKSl8KD86KCMpKC4qKSkoPzouKilcXHI/XFxuPy87XG5cbmNsYXNzIExldmVsS2V5IHtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLm1ldGhvZCA9IG51bGw7XG4gICAgdGhpcy5rZXkgPSBudWxsO1xuICAgIHRoaXMuaXYgPSBudWxsO1xuICAgIHRoaXMuX3VyaSA9IG51bGw7XG4gIH1cblxuICBnZXQgdXJpKCkge1xuICAgIGlmICghdGhpcy5fdXJpICYmIHRoaXMucmVsdXJpKSB7XG4gICAgICB0aGlzLl91cmkgPSBVUkxUb29sa2l0LmJ1aWxkQWJzb2x1dGVVUkwodGhpcy5iYXNldXJpLCB0aGlzLnJlbHVyaSwgeyBhbHdheXNOb3JtYWxpemU6IHRydWUgfSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl91cmk7XG4gIH1cblxufVxuXG5jbGFzcyBGcmFnbWVudCB7XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5fdXJsID0gbnVsbDtcbiAgICB0aGlzLl9ieXRlUmFuZ2UgPSBudWxsO1xuICAgIHRoaXMuX2RlY3J5cHRkYXRhID0gbnVsbDtcbiAgICB0aGlzLnRhZ0xpc3QgPSBbXTtcbiAgfVxuXG4gIGdldCB1cmwoKSB7XG4gICAgaWYgKCF0aGlzLl91cmwgJiYgdGhpcy5yZWx1cmwpIHtcbiAgICAgIHRoaXMuX3VybCA9IFVSTFRvb2xraXQuYnVpbGRBYnNvbHV0ZVVSTCh0aGlzLmJhc2V1cmwsIHRoaXMucmVsdXJsLCB7IGFsd2F5c05vcm1hbGl6ZTogdHJ1ZSB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3VybDtcbiAgfVxuXG4gIHNldCB1cmwodmFsdWUpIHtcbiAgICB0aGlzLl91cmwgPSB2YWx1ZTtcbiAgfVxuXG4gIGdldCBwcm9ncmFtRGF0ZVRpbWUoKSB7XG4gICAgaWYgKCF0aGlzLl9wcm9ncmFtRGF0ZVRpbWUgJiYgdGhpcy5yYXdQcm9ncmFtRGF0ZVRpbWUpIHtcbiAgICAgIHRoaXMuX3Byb2dyYW1EYXRlVGltZSA9IG5ldyBEYXRlKERhdGUucGFyc2UodGhpcy5yYXdQcm9ncmFtRGF0ZVRpbWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3Byb2dyYW1EYXRlVGltZTtcbiAgfVxuXG4gIGdldCBieXRlUmFuZ2UoKSB7XG4gICAgaWYgKCF0aGlzLl9ieXRlUmFuZ2UpIHtcbiAgICAgIGxldCBieXRlUmFuZ2UgPSB0aGlzLl9ieXRlUmFuZ2UgPSBbXTtcbiAgICAgIGlmICh0aGlzLnJhd0J5dGVSYW5nZSkge1xuICAgICAgICBjb25zdCBwYXJhbXMgPSB0aGlzLnJhd0J5dGVSYW5nZS5zcGxpdCgnQCcsIDIpO1xuICAgICAgICBpZiAocGFyYW1zLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIGNvbnN0IGxhc3RCeXRlUmFuZ2VFbmRPZmZzZXQgPSB0aGlzLmxhc3RCeXRlUmFuZ2VFbmRPZmZzZXQ7XG4gICAgICAgICAgYnl0ZVJhbmdlWzBdID0gbGFzdEJ5dGVSYW5nZUVuZE9mZnNldCA/IGxhc3RCeXRlUmFuZ2VFbmRPZmZzZXQgOiAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJ5dGVSYW5nZVswXSA9IHBhcnNlSW50KHBhcmFtc1sxXSk7XG4gICAgICAgIH1cbiAgICAgICAgYnl0ZVJhbmdlWzFdID0gcGFyc2VJbnQocGFyYW1zWzBdKSArIGJ5dGVSYW5nZVswXTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2J5dGVSYW5nZTtcbiAgfVxuXG4gIGdldCBieXRlUmFuZ2VTdGFydE9mZnNldCgpIHtcbiAgICByZXR1cm4gdGhpcy5ieXRlUmFuZ2VbMF07XG4gIH1cblxuICBnZXQgYnl0ZVJhbmdlRW5kT2Zmc2V0KCkge1xuICAgIHJldHVybiB0aGlzLmJ5dGVSYW5nZVsxXTtcbiAgfVxuXG4gIGdldCBkZWNyeXB0ZGF0YSgpIHtcbiAgICBpZiAoIXRoaXMuX2RlY3J5cHRkYXRhKSB7XG4gICAgICB0aGlzLl9kZWNyeXB0ZGF0YSA9IHRoaXMuZnJhZ21lbnREZWNyeXB0ZGF0YUZyb21MZXZlbGtleSh0aGlzLmxldmVsa2V5LCB0aGlzLnNuKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2RlY3J5cHRkYXRhO1xuICB9XG5cbiAgLyoqXG4gICAqIFV0aWxpdHkgbWV0aG9kIGZvciBwYXJzZUxldmVsUGxheWxpc3QgdG8gY3JlYXRlIGFuIGluaXRpYWxpemF0aW9uIHZlY3RvciBmb3IgYSBnaXZlbiBzZWdtZW50XG4gICAqIEByZXR1cm5zIHtVaW50OEFycmF5fVxuICAgKi9cbiAgY3JlYXRlSW5pdGlhbGl6YXRpb25WZWN0b3Ioc2VnbWVudE51bWJlcikge1xuICAgIHZhciB1aW50OFZpZXcgPSBuZXcgVWludDhBcnJheSgxNik7XG5cbiAgICBmb3IgKHZhciBpID0gMTI7IGkgPCAxNjsgaSsrKSB7XG4gICAgICB1aW50OFZpZXdbaV0gPSAoc2VnbWVudE51bWJlciA+PiA4ICogKDE1IC0gaSkpICYgMHhmZjtcbiAgICB9XG5cbiAgICByZXR1cm4gdWludDhWaWV3O1xuICB9XG5cbiAgLyoqXG4gICAqIFV0aWxpdHkgbWV0aG9kIGZvciBwYXJzZUxldmVsUGxheWxpc3QgdG8gZ2V0IGEgZnJhZ21lbnQncyBkZWNyeXB0aW9uIGRhdGEgZnJvbSB0aGUgY3VycmVudGx5IHBhcnNlZCBlbmNyeXB0aW9uIGtleSBkYXRhXG4gICAqIEBwYXJhbSBsZXZlbGtleSAtIGEgcGxheWxpc3QncyBlbmNyeXB0aW9uIGluZm9cbiAgICogQHBhcmFtIHNlZ21lbnROdW1iZXIgLSB0aGUgZnJhZ21lbnQncyBzZWdtZW50IG51bWJlclxuICAgKiBAcmV0dXJucyB7Kn0gLSBhbiBvYmplY3QgdG8gYmUgYXBwbGllZCBhcyBhIGZyYWdtZW50J3MgZGVjcnlwdGRhdGFcbiAgICovXG4gIGZyYWdtZW50RGVjcnlwdGRhdGFGcm9tTGV2ZWxrZXkobGV2ZWxrZXksIHNlZ21lbnROdW1iZXIpIHtcbiAgICB2YXIgZGVjcnlwdGRhdGEgPSBsZXZlbGtleTtcblxuICAgIGlmIChsZXZlbGtleSAmJiBsZXZlbGtleS5tZXRob2QgJiYgbGV2ZWxrZXkudXJpICYmICFsZXZlbGtleS5pdikge1xuICAgICAgZGVjcnlwdGRhdGEgPSBuZXcgTGV2ZWxLZXkoKTtcbiAgICAgIGRlY3J5cHRkYXRhLm1ldGhvZCA9IGxldmVsa2V5Lm1ldGhvZDtcbiAgICAgIGRlY3J5cHRkYXRhLmJhc2V1cmkgPSBsZXZlbGtleS5iYXNldXJpO1xuICAgICAgZGVjcnlwdGRhdGEucmVsdXJpID0gbGV2ZWxrZXkucmVsdXJpO1xuICAgICAgZGVjcnlwdGRhdGEuaXYgPSB0aGlzLmNyZWF0ZUluaXRpYWxpemF0aW9uVmVjdG9yKHNlZ21lbnROdW1iZXIpO1xuICAgIH1cblxuICAgIHJldHVybiBkZWNyeXB0ZGF0YTtcbiAgfVxuXG4gIGNsb25lT2JqKG9iaikge1xuICAgIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG9iaikpO1xuICB9XG59XG5cbmNsYXNzIFBsYXlsaXN0TG9hZGVyIGV4dGVuZHMgRXZlbnRIYW5kbGVyIHtcblxuICBjb25zdHJ1Y3RvcihobHMpIHtcbiAgICBzdXBlcihobHMsXG4gICAgICBFdmVudC5NQU5JRkVTVF9MT0FESU5HLFxuICAgICAgRXZlbnQuTEVWRUxfTE9BRElORyxcbiAgICAgIEV2ZW50LkFVRElPX1RSQUNLX0xPQURJTkcsXG4gICAgICBFdmVudC5TVUJUSVRMRV9UUkFDS19MT0FESU5HKTtcbiAgICB0aGlzLmxvYWRlcnMgPSB7fTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgZm9yIChsZXQgbG9hZGVyTmFtZSBpbiB0aGlzLmxvYWRlcnMpIHtcbiAgICAgIGxldCBsb2FkZXIgPSB0aGlzLmxvYWRlcnNbbG9hZGVyTmFtZV07XG4gICAgICBpZiAobG9hZGVyKSB7XG4gICAgICAgIGxvYWRlci5kZXN0cm95KCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMubG9hZGVycyA9IHt9O1xuICAgIEV2ZW50SGFuZGxlci5wcm90b3R5cGUuZGVzdHJveS5jYWxsKHRoaXMpO1xuICB9XG5cbiAgb25NYW5pZmVzdExvYWRpbmcoZGF0YSkge1xuICAgIHRoaXMubG9hZChkYXRhLnVybCwgeyB0eXBlIDogJ21hbmlmZXN0J30pO1xuICB9XG5cbiAgb25MZXZlbExvYWRpbmcoZGF0YSkge1xuICAgIHRoaXMubG9hZChkYXRhLnVybCwgeyB0eXBlIDogJ2xldmVsJywgbGV2ZWwgOiBkYXRhLmxldmVsLCBpZCA6IGRhdGEuaWR9KTtcbiAgfVxuXG4gIG9uQXVkaW9UcmFja0xvYWRpbmcoZGF0YSkge1xuICAgIHRoaXMubG9hZChkYXRhLnVybCwgeyB0eXBlIDogJ2F1ZGlvVHJhY2snLCBpZCA6IGRhdGEuaWR9KTtcbiAgfVxuXG4gIG9uU3VidGl0bGVUcmFja0xvYWRpbmcoZGF0YSkge1xuICAgIHRoaXMubG9hZChkYXRhLnVybCwgeyB0eXBlIDogJ3N1YnRpdGxlVHJhY2snLCBpZCA6IGRhdGEuaWR9KTtcbiAgfVxuXG4gIGxvYWQodXJsLCBjb250ZXh0KSB7XG4gICAgbGV0IGxvYWRlciA9IHRoaXMubG9hZGVyc1tjb250ZXh0LnR5cGVdO1xuICAgIGlmIChsb2FkZXIpIHtcbiAgICAgIGxldCBsb2FkZXJDb250ZXh0ID0gbG9hZGVyLmNvbnRleHQ7XG4gICAgICBpZiAobG9hZGVyQ29udGV4dCAmJiBsb2FkZXJDb250ZXh0LnVybCA9PT0gdXJsKSB7XG4gICAgICAgIGxvZ2dlci50cmFjZShgcGxheWxpc3QgcmVxdWVzdCBvbmdvaW5nYCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxvZ2dlci53YXJuKGBhYm9ydCBwcmV2aW91cyBsb2FkZXIgZm9yIHR5cGU6JHtjb250ZXh0LnR5cGV9YCk7XG4gICAgICAgIGxvYWRlci5hYm9ydCgpO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgY29uZmlnID0gdGhpcy5obHMuY29uZmlnLFxuICAgICAgICByZXRyeSxcbiAgICAgICAgdGltZW91dCxcbiAgICAgICAgcmV0cnlEZWxheSxcbiAgICAgICAgbWF4UmV0cnlEZWxheTtcbiAgICBpZihjb250ZXh0LnR5cGUgPT09ICdtYW5pZmVzdCcpIHtcbiAgICAgIHJldHJ5ID0gY29uZmlnLm1hbmlmZXN0TG9hZGluZ01heFJldHJ5O1xuICAgICAgdGltZW91dCA9IGNvbmZpZy5tYW5pZmVzdExvYWRpbmdUaW1lT3V0O1xuICAgICAgcmV0cnlEZWxheSA9IGNvbmZpZy5tYW5pZmVzdExvYWRpbmdSZXRyeURlbGF5O1xuICAgICAgbWF4UmV0cnlEZWxheSA9IGNvbmZpZy5tYW5pZmVzdExvYWRpbmdNYXhSZXRyeVRpbWVvdXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHJ5ID0gY29uZmlnLmxldmVsTG9hZGluZ01heFJldHJ5O1xuICAgICAgdGltZW91dCA9IGNvbmZpZy5sZXZlbExvYWRpbmdUaW1lT3V0O1xuICAgICAgcmV0cnlEZWxheSA9IGNvbmZpZy5sZXZlbExvYWRpbmdSZXRyeURlbGF5O1xuICAgICAgbWF4UmV0cnlEZWxheSA9IGNvbmZpZy5sZXZlbExvYWRpbmdNYXhSZXRyeVRpbWVvdXQ7XG4gICAgICBsb2dnZXIubG9nKGBsb2FkaW5nIHBsYXlsaXN0IGZvciAke2NvbnRleHQudHlwZX0gJHtjb250ZXh0LmxldmVsIHx8IGNvbnRleHQuaWR9YCk7XG4gICAgfVxuICAgIGxvYWRlciAgPSB0aGlzLmxvYWRlcnNbY29udGV4dC50eXBlXSA9IGNvbnRleHQubG9hZGVyID0gdHlwZW9mKGNvbmZpZy5wTG9hZGVyKSAhPT0gJ3VuZGVmaW5lZCcgPyBuZXcgY29uZmlnLnBMb2FkZXIoY29uZmlnKSA6IG5ldyBjb25maWcubG9hZGVyKGNvbmZpZyk7XG4gICAgY29udGV4dC51cmwgPSB1cmw7XG4gICAgY29udGV4dC5yZXNwb25zZVR5cGUgPSAnJztcblxuICAgIGxldCBsb2FkZXJDb25maWcsIGxvYWRlckNhbGxiYWNrcztcbiAgICBsb2FkZXJDb25maWcgPSB7IHRpbWVvdXQgOiB0aW1lb3V0LCBtYXhSZXRyeSA6IHJldHJ5ICwgcmV0cnlEZWxheSA6IHJldHJ5RGVsYXksIG1heFJldHJ5RGVsYXkgOiBtYXhSZXRyeURlbGF5fTtcbiAgICBsb2FkZXJDYWxsYmFja3MgPSB7IG9uU3VjY2VzcyA6IHRoaXMubG9hZHN1Y2Nlc3MuYmluZCh0aGlzKSwgb25FcnJvciA6dGhpcy5sb2FkZXJyb3IuYmluZCh0aGlzKSwgb25UaW1lb3V0IDogdGhpcy5sb2FkdGltZW91dC5iaW5kKHRoaXMpfTtcbiAgICBsb2FkZXIubG9hZChjb250ZXh0LGxvYWRlckNvbmZpZyxsb2FkZXJDYWxsYmFja3MpO1xuICB9XG5cbiAgcmVzb2x2ZSh1cmwsIGJhc2VVcmwpIHtcbiAgICByZXR1cm4gVVJMVG9vbGtpdC5idWlsZEFic29sdXRlVVJMKGJhc2VVcmwsIHVybCwgeyBhbHdheXNOb3JtYWxpemU6IHRydWUgfSk7XG4gIH1cblxuICBwYXJzZU1hc3RlclBsYXlsaXN0KHN0cmluZywgYmFzZXVybCkge1xuICAgIGxldCBsZXZlbHMgPSBbXSwgcmVzdWx0O1xuICAgIE1BU1RFUl9QTEFZTElTVF9SRUdFWC5sYXN0SW5kZXggPSAwO1xuICAgIHdoaWxlICgocmVzdWx0ID0gTUFTVEVSX1BMQVlMSVNUX1JFR0VYLmV4ZWMoc3RyaW5nKSkgIT0gbnVsbCl7XG4gICAgICBjb25zdCBsZXZlbCA9IHt9O1xuXG4gICAgICB2YXIgYXR0cnMgPSBsZXZlbC5hdHRycyA9IG5ldyBBdHRyTGlzdChyZXN1bHRbMV0pO1xuICAgICAgbGV2ZWwudXJsID0gdGhpcy5yZXNvbHZlKHJlc3VsdFsyXSwgYmFzZXVybCk7XG5cbiAgICAgIHZhciByZXNvbHV0aW9uID0gYXR0cnMuZGVjaW1hbFJlc29sdXRpb24oJ1JFU09MVVRJT04nKTtcbiAgICAgIGlmKHJlc29sdXRpb24pIHtcbiAgICAgICAgbGV2ZWwud2lkdGggPSByZXNvbHV0aW9uLndpZHRoO1xuICAgICAgICBsZXZlbC5oZWlnaHQgPSByZXNvbHV0aW9uLmhlaWdodDtcbiAgICAgIH1cbiAgICAgIGxldmVsLmJpdHJhdGUgPSBhdHRycy5kZWNpbWFsSW50ZWdlcignQVZFUkFHRS1CQU5EV0lEVEgnKSB8fCBhdHRycy5kZWNpbWFsSW50ZWdlcignQkFORFdJRFRIJyk7XG4gICAgICBsZXZlbC5uYW1lID0gYXR0cnMuTkFNRTtcblxuICAgICAgdmFyIGNvZGVjcyA9IGF0dHJzLkNPREVDUztcbiAgICAgIGlmKGNvZGVjcykge1xuICAgICAgICBjb2RlY3MgPSBjb2RlY3Muc3BsaXQoL1sgLF0rLyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29kZWNzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgY29kZWMgPSBjb2RlY3NbaV07XG4gICAgICAgICAgaWYgKGNvZGVjLmluZGV4T2YoJ2F2YzEnKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIGxldmVsLnZpZGVvQ29kZWMgPSB0aGlzLmF2YzF0b2F2Y290aShjb2RlYyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldmVsLmF1ZGlvQ29kZWMgPSBjb2RlYztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbGV2ZWxzLnB1c2gobGV2ZWwpO1xuICAgIH1cbiAgICByZXR1cm4gbGV2ZWxzO1xuICB9XG5cbiAgcGFyc2VNYXN0ZXJQbGF5bGlzdE1lZGlhKHN0cmluZywgYmFzZXVybCwgdHlwZSkge1xuICAgIGxldCByZXN1bHQsIG1lZGlhcyA9IFtdLCBpZCA9IDA7XG4gICAgTUFTVEVSX1BMQVlMSVNUX01FRElBX1JFR0VYLmxhc3RJbmRleCA9IDA7XG4gICAgd2hpbGUgKChyZXN1bHQgPSBNQVNURVJfUExBWUxJU1RfTUVESUFfUkVHRVguZXhlYyhzdHJpbmcpKSAhPSBudWxsKXtcbiAgICAgIGNvbnN0IG1lZGlhID0ge307XG4gICAgICB2YXIgYXR0cnMgPSBuZXcgQXR0ckxpc3QocmVzdWx0WzFdKTtcbiAgICAgIGlmKGF0dHJzLlRZUEUgPT09IHR5cGUpIHtcbiAgICAgICAgbWVkaWEuZ3JvdXBJZCA9IGF0dHJzWydHUk9VUC1JRCddO1xuICAgICAgICBtZWRpYS5pbnN0cmVhbUlkID0gYXR0cnNbJ0lOU1RSRUFNLUlEJ107XG4gICAgICAgIG1lZGlhLm5hbWUgPSBhdHRycy5OQU1FO1xuICAgICAgICBtZWRpYS50eXBlID0gdHlwZTtcbiAgICAgICAgbWVkaWEuZGVmYXVsdCA9IChhdHRycy5ERUZBVUxUID09PSAnWUVTJyk7XG4gICAgICAgIG1lZGlhLmF1dG9zZWxlY3QgPSAoYXR0cnMuQVVUT1NFTEVDVCA9PT0gJ1lFUycpO1xuICAgICAgICBtZWRpYS5mb3JjZWQgPSAoYXR0cnMuRk9SQ0VEID09PSAnWUVTJyk7XG4gICAgICAgIGlmIChhdHRycy5VUkkpIHtcbiAgICAgICAgICBtZWRpYS51cmwgPSB0aGlzLnJlc29sdmUoYXR0cnMuVVJJLCBiYXNldXJsKTtcbiAgICAgICAgfVxuICAgICAgICBtZWRpYS5sYW5nID0gYXR0cnMuTEFOR1VBR0U7XG4gICAgICAgIGlmKCFtZWRpYS5uYW1lKSB7XG4gICAgICAgICAgICBtZWRpYS5uYW1lID0gbWVkaWEubGFuZztcbiAgICAgICAgfVxuICAgICAgICBtZWRpYS5pZCA9IGlkKys7XG4gICAgICAgIG1lZGlhcy5wdXNoKG1lZGlhKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1lZGlhcztcbiAgfVxuXG4gIGF2YzF0b2F2Y290aShjb2RlYykge1xuICAgIHZhciByZXN1bHQsIGF2Y2RhdGEgPSBjb2RlYy5zcGxpdCgnLicpO1xuICAgIGlmIChhdmNkYXRhLmxlbmd0aCA+IDIpIHtcbiAgICAgIHJlc3VsdCA9IGF2Y2RhdGEuc2hpZnQoKSArICcuJztcbiAgICAgIHJlc3VsdCArPSBwYXJzZUludChhdmNkYXRhLnNoaWZ0KCkpLnRvU3RyaW5nKDE2KTtcbiAgICAgIHJlc3VsdCArPSAoJzAwMCcgKyBwYXJzZUludChhdmNkYXRhLnNoaWZ0KCkpLnRvU3RyaW5nKDE2KSkuc3Vic3RyKC00KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gY29kZWM7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBwYXJzZUxldmVsUGxheWxpc3Qoc3RyaW5nLCBiYXNldXJsLCBpZCwgdHlwZSkge1xuICAgIHZhciBjdXJyZW50U04gPSAwLFxuICAgICAgICB0b3RhbGR1cmF0aW9uID0gMCxcbiAgICAgICAgbGV2ZWwgPSB7dHlwZTogbnVsbCwgdmVyc2lvbjogbnVsbCwgdXJsOiBiYXNldXJsLCBmcmFnbWVudHM6IFtdLCBsaXZlOiB0cnVlLCBzdGFydFNOOiAwfSxcbiAgICAgICAgbGV2ZWxrZXkgPSBuZXcgTGV2ZWxLZXkoKSxcbiAgICAgICAgY2MgPSAwLFxuICAgICAgICBwcmV2RnJhZyA9IG51bGwsXG4gICAgICAgIGZyYWcgPSBuZXcgRnJhZ21lbnQoKSxcbiAgICAgICAgcmVzdWx0LFxuICAgICAgICBpO1xuXG4gICAgTEVWRUxfUExBWUxJU1RfUkVHRVhfRkFTVC5sYXN0SW5kZXggPSAwO1xuXG4gICAgd2hpbGUgKChyZXN1bHQgPSBMRVZFTF9QTEFZTElTVF9SRUdFWF9GQVNULmV4ZWMoc3RyaW5nKSkgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IGR1cmF0aW9uID0gcmVzdWx0WzFdO1xuICAgICAgaWYgKGR1cmF0aW9uKSB7IC8vIElORlxuICAgICAgICBmcmFnLmR1cmF0aW9uID0gcGFyc2VGbG9hdChkdXJhdGlvbik7XG4gICAgICAgIC8vIGF2b2lkIHNsaWNlZCBzdHJpbmdzICAgIGh0dHBzOi8vZ2l0aHViLmNvbS92aWRlby1kZXYvaGxzLmpzL2lzc3Vlcy85MzlcbiAgICAgICAgY29uc3QgdGl0bGUgPSAoJyAnICsgcmVzdWx0WzJdKS5zbGljZSgxKTtcbiAgICAgICAgZnJhZy50aXRsZSA9IHRpdGxlID8gdGl0bGUgOiBudWxsO1xuICAgICAgICBmcmFnLnRhZ0xpc3QucHVzaCh0aXRsZSA/IFsgJ0lORicsZHVyYXRpb24sdGl0bGUgXSA6IFsgJ0lORicsZHVyYXRpb24gXSk7XG4gICAgICB9IGVsc2UgaWYgKHJlc3VsdFszXSkgeyAvLyB1cmxcbiAgICAgICAgaWYgKCFpc05hTihmcmFnLmR1cmF0aW9uKSkge1xuICAgICAgICAgIGNvbnN0IHNuID0gY3VycmVudFNOKys7XG4gICAgICAgICAgZnJhZy50eXBlID0gdHlwZTtcbiAgICAgICAgICBmcmFnLnN0YXJ0ID0gdG90YWxkdXJhdGlvbjtcbiAgICAgICAgICBmcmFnLmxldmVsa2V5ID0gbGV2ZWxrZXk7XG4gICAgICAgICAgZnJhZy5zbiA9IHNuO1xuICAgICAgICAgIGZyYWcubGV2ZWwgPSBpZDtcbiAgICAgICAgICBmcmFnLmNjID0gY2M7XG4gICAgICAgICAgZnJhZy5iYXNldXJsID0gYmFzZXVybDtcbiAgICAgICAgICAvLyBhdm9pZCBzbGljZWQgc3RyaW5ncyAgICBodHRwczovL2dpdGh1Yi5jb20vdmlkZW8tZGV2L2hscy5qcy9pc3N1ZXMvOTM5XG4gICAgICAgICAgZnJhZy5yZWx1cmwgPSAoJyAnICsgcmVzdWx0WzNdKS5zbGljZSgxKTtcblxuICAgICAgICAgIGxldmVsLmZyYWdtZW50cy5wdXNoKGZyYWcpO1xuICAgICAgICAgIHByZXZGcmFnID0gZnJhZztcbiAgICAgICAgICB0b3RhbGR1cmF0aW9uICs9IGZyYWcuZHVyYXRpb247XG5cbiAgICAgICAgICBmcmFnID0gbmV3IEZyYWdtZW50KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocmVzdWx0WzRdKSB7IC8vIFgtQllURVJBTkdFXG4gICAgICAgIGZyYWcucmF3Qnl0ZVJhbmdlID0gKCcgJyArIHJlc3VsdFs0XSkuc2xpY2UoMSk7XG4gICAgICAgIGlmIChwcmV2RnJhZykge1xuICAgICAgICAgIGNvbnN0IGxhc3RCeXRlUmFuZ2VFbmRPZmZzZXQgPSBwcmV2RnJhZy5ieXRlUmFuZ2VFbmRPZmZzZXQ7XG4gICAgICAgICAgaWYgKGxhc3RCeXRlUmFuZ2VFbmRPZmZzZXQpIHtcbiAgICAgICAgICAgIGZyYWcubGFzdEJ5dGVSYW5nZUVuZE9mZnNldCA9IGxhc3RCeXRlUmFuZ2VFbmRPZmZzZXQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHJlc3VsdFs1XSkgeyAvLyBQUk9HUkFNLURBVEUtVElNRVxuICAgICAgICAvLyBhdm9pZCBzbGljZWQgc3RyaW5ncyAgICBodHRwczovL2dpdGh1Yi5jb20vdmlkZW8tZGV2L2hscy5qcy9pc3N1ZXMvOTM5XG4gICAgICAgIGZyYWcucmF3UHJvZ3JhbURhdGVUaW1lID0gKCcgJyArIHJlc3VsdFs1XSkuc2xpY2UoMSk7XG4gICAgICAgIGZyYWcudGFnTGlzdC5wdXNoKFsnUFJPR1JBTS1EQVRFLVRJTUUnLCBmcmFnLnJhd1Byb2dyYW1EYXRlVGltZV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0WzBdLm1hdGNoKExFVkVMX1BMQVlMSVNUX1JFR0VYX1NMT1cpO1xuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgcmVzdWx0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKHJlc3VsdFtpXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhdm9pZCBzbGljZWQgc3RyaW5ncyAgICBodHRwczovL2dpdGh1Yi5jb20vdmlkZW8tZGV2L2hscy5qcy9pc3N1ZXMvOTM5XG4gICAgICAgIGNvbnN0IHZhbHVlMSA9ICgnICcgKyByZXN1bHRbaSsxXSkuc2xpY2UoMSk7XG4gICAgICAgIGNvbnN0IHZhbHVlMiA9ICgnICcgKyByZXN1bHRbaSsyXSkuc2xpY2UoMSk7XG5cbiAgICAgICAgc3dpdGNoIChyZXN1bHRbaV0pIHtcbiAgICAgICAgICBjYXNlICcjJzpcbiAgICAgICAgICAgIGZyYWcudGFnTGlzdC5wdXNoKHZhbHVlMiA/IFsgdmFsdWUxLHZhbHVlMiBdIDogWyB2YWx1ZTEgXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdQTEFZTElTVC1UWVBFJzpcbiAgICAgICAgICAgIGxldmVsLnR5cGUgPSB2YWx1ZTEudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ01FRElBLVNFUVVFTkNFJzpcbiAgICAgICAgICAgIGN1cnJlbnRTTiA9IGxldmVsLnN0YXJ0U04gPSBwYXJzZUludCh2YWx1ZTEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnVEFSR0VURFVSQVRJT04nOlxuICAgICAgICAgICAgbGV2ZWwudGFyZ2V0ZHVyYXRpb24gPSBwYXJzZUZsb2F0KHZhbHVlMSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdWRVJTSU9OJzpcbiAgICAgICAgICAgIGxldmVsLnZlcnNpb24gPSBwYXJzZUludCh2YWx1ZTEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnRVhUTTNVJzpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ0VORExJU1QnOlxuICAgICAgICAgICAgbGV2ZWwubGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnRElTJzpcbiAgICAgICAgICAgIGNjKys7XG4gICAgICAgICAgICBmcmFnLnRhZ0xpc3QucHVzaChbJ0RJUyddKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ0RJU0NPTlRJTlVJVFktU0VRJzpcbiAgICAgICAgICAgIGNjID0gcGFyc2VJbnQodmFsdWUxKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ0tFWSc6XG4gICAgICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvZHJhZnQtcGFudG9zLWh0dHAtbGl2ZS1zdHJlYW1pbmctMDgjc2VjdGlvbi0zLjQuNFxuICAgICAgICAgICAgdmFyIGRlY3J5cHRwYXJhbXMgPSB2YWx1ZTE7XG4gICAgICAgICAgICB2YXIga2V5QXR0cnMgPSBuZXcgQXR0ckxpc3QoZGVjcnlwdHBhcmFtcyk7XG4gICAgICAgICAgICB2YXIgZGVjcnlwdG1ldGhvZCA9IGtleUF0dHJzLmVudW1lcmF0ZWRTdHJpbmcoJ01FVEhPRCcpLFxuICAgICAgICAgICAgICAgIGRlY3J5cHR1cmkgPSBrZXlBdHRycy5VUkksXG4gICAgICAgICAgICAgICAgZGVjcnlwdGl2ID0ga2V5QXR0cnMuaGV4YWRlY2ltYWxJbnRlZ2VyKCdJVicpO1xuICAgICAgICAgICAgaWYgKGRlY3J5cHRtZXRob2QpIHtcbiAgICAgICAgICAgICAgbGV2ZWxrZXkgPSBuZXcgTGV2ZWxLZXkoKTtcbiAgICAgICAgICAgICAgaWYgKChkZWNyeXB0dXJpKSAmJiAoWydBRVMtMTI4JywgJ1NBTVBMRS1BRVMnXS5pbmRleE9mKGRlY3J5cHRtZXRob2QpID49IDApKSB7XG4gICAgICAgICAgICAgICAgbGV2ZWxrZXkubWV0aG9kID0gZGVjcnlwdG1ldGhvZDtcbiAgICAgICAgICAgICAgICAvLyBVUkkgdG8gZ2V0IHRoZSBrZXlcbiAgICAgICAgICAgICAgICBsZXZlbGtleS5iYXNldXJpID0gYmFzZXVybDtcbiAgICAgICAgICAgICAgICBsZXZlbGtleS5yZWx1cmkgPSBkZWNyeXB0dXJpO1xuICAgICAgICAgICAgICAgIGxldmVsa2V5LmtleSA9IG51bGw7XG4gICAgICAgICAgICAgICAgLy8gSW5pdGlhbGl6YXRpb24gVmVjdG9yIChJVilcbiAgICAgICAgICAgICAgICBsZXZlbGtleS5pdiA9IGRlY3J5cHRpdjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnU1RBUlQnOlxuICAgICAgICAgICAgbGV0IHN0YXJ0UGFyYW1zID0gdmFsdWUxO1xuICAgICAgICAgICAgbGV0IHN0YXJ0QXR0cnMgPSBuZXcgQXR0ckxpc3Qoc3RhcnRQYXJhbXMpO1xuICAgICAgICAgICAgbGV0IHN0YXJ0VGltZU9mZnNldCA9IHN0YXJ0QXR0cnMuZGVjaW1hbEZsb2F0aW5nUG9pbnQoJ1RJTUUtT0ZGU0VUJyk7XG4gICAgICAgICAgICAvL1RJTUUtT0ZGU0VUIGNhbiBiZSAwXG4gICAgICAgICAgICBpZiAoICFpc05hTihzdGFydFRpbWVPZmZzZXQpICkge1xuICAgICAgICAgICAgICBsZXZlbC5zdGFydFRpbWVPZmZzZXQgPSBzdGFydFRpbWVPZmZzZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdNQVAnOlxuICAgICAgICAgICAgbGV0IG1hcEF0dHJzID0gbmV3IEF0dHJMaXN0KHZhbHVlMSk7XG4gICAgICAgICAgICBmcmFnLnJlbHVybCA9IG1hcEF0dHJzLlVSSTtcbiAgICAgICAgICAgIGZyYWcucmF3Qnl0ZVJhbmdlID0gbWFwQXR0cnMuQllURVJBTkdFO1xuICAgICAgICAgICAgZnJhZy5iYXNldXJsID0gYmFzZXVybDtcbiAgICAgICAgICAgIGZyYWcubGV2ZWwgPSBpZDtcbiAgICAgICAgICAgIGZyYWcudHlwZSA9IHR5cGU7XG4gICAgICAgICAgICBmcmFnLnNuID0gJ2luaXRTZWdtZW50JztcbiAgICAgICAgICAgIGxldmVsLmluaXRTZWdtZW50ID0gZnJhZztcbiAgICAgICAgICAgIGZyYWcgPSBuZXcgRnJhZ21lbnQoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBsb2dnZXIud2FybihgbGluZSBwYXJzZWQgYnV0IG5vdCBoYW5kbGVkOiAke3Jlc3VsdH1gKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZyYWcgPSBwcmV2RnJhZztcbiAgICAvL2xvZ2dlci5sb2coJ2ZvdW5kICcgKyBsZXZlbC5mcmFnbWVudHMubGVuZ3RoICsgJyBmcmFnbWVudHMnKTtcbiAgICBpZihmcmFnICYmICFmcmFnLnJlbHVybCkge1xuICAgICAgbGV2ZWwuZnJhZ21lbnRzLnBvcCgpO1xuICAgICAgdG90YWxkdXJhdGlvbi09ZnJhZy5kdXJhdGlvbjtcbiAgICB9XG4gICAgbGV2ZWwudG90YWxkdXJhdGlvbiA9IHRvdGFsZHVyYXRpb247XG4gICAgbGV2ZWwuYXZlcmFnZXRhcmdldGR1cmF0aW9uID0gdG90YWxkdXJhdGlvbiAvIGxldmVsLmZyYWdtZW50cy5sZW5ndGg7XG4gICAgbGV2ZWwuZW5kU04gPSBjdXJyZW50U04gLSAxO1xuICAgIGxldmVsLnN0YXJ0Q0MgPSBsZXZlbC5mcmFnbWVudHNbMF0gPyBsZXZlbC5mcmFnbWVudHNbMF0uY2MgOiAwO1xuICAgIGxldmVsLmVuZENDID0gY2M7XG4gICAgcmV0dXJuIGxldmVsO1xuICB9XG5cbiAgbG9hZHN1Y2Nlc3MocmVzcG9uc2UsIHN0YXRzLCBjb250ZXh0KSB7XG4gICAgdmFyIHN0cmluZyA9IHJlc3BvbnNlLmRhdGEsXG4gICAgICAgIHVybCA9IHJlc3BvbnNlLnVybCxcbiAgICAgICAgdHlwZSA9IGNvbnRleHQudHlwZSxcbiAgICAgICAgaWQgPSBjb250ZXh0LmlkLFxuICAgICAgICBsZXZlbCA9IGNvbnRleHQubGV2ZWwsXG4gICAgICAgIGhscyA9IHRoaXMuaGxzO1xuXG4gICAgdGhpcy5sb2FkZXJzW3R5cGVdID0gdW5kZWZpbmVkO1xuICAgIC8vIHJlc3BvbnNlVVJMIG5vdCBzdXBwb3J0ZWQgb24gc29tZSBicm93c2VycyAoaXQgaXMgdXNlZCB0byBkZXRlY3QgVVJMIHJlZGlyZWN0aW9uKVxuICAgIC8vIGRhdGEtdXJpIG1vZGUgYWxzbyBub3Qgc3VwcG9ydGVkIChidXQgbm8gbmVlZCB0byBkZXRlY3QgcmVkaXJlY3Rpb24pXG4gICAgaWYgKHVybCA9PT0gdW5kZWZpbmVkIHx8IHVybC5pbmRleE9mKCdkYXRhOicpID09PSAwKSB7XG4gICAgICAvLyBmYWxsYmFjayB0byBpbml0aWFsIFVSTFxuICAgICAgdXJsID0gY29udGV4dC51cmw7XG4gICAgfVxuICAgIHN0YXRzLnRsb2FkID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgLy9zdGF0cy5tdGltZSA9IG5ldyBEYXRlKHRhcmdldC5nZXRSZXNwb25zZUhlYWRlcignTGFzdC1Nb2RpZmllZCcpKTtcbiAgICBpZiAoc3RyaW5nLmluZGV4T2YoJyNFWFRNM1UnKSA9PT0gMCkge1xuICAgICAgaWYgKHN0cmluZy5pbmRleE9mKCcjRVhUSU5GOicpID4gMCkge1xuICAgICAgICBsZXQgaXNMZXZlbCA9ICh0eXBlICE9PSAnYXVkaW9UcmFjaycgJiYgdHlwZSAhPT0gJ3N1YnRpdGxlVHJhY2snKSxcbiAgICAgICAgICAgIGxldmVsSWQgPSAhaXNOYU4obGV2ZWwpID8gbGV2ZWwgOiAhaXNOYU4oaWQpID8gaWQgOiAwLFxuICAgICAgICAgICAgbGV2ZWxEZXRhaWxzID0gdGhpcy5wYXJzZUxldmVsUGxheWxpc3Qoc3RyaW5nLCB1cmwsIGxldmVsSWQsICh0eXBlID09PSAnYXVkaW9UcmFjaycgPyAnYXVkaW8nIDogKHR5cGUgPT09ICdzdWJ0aXRsZVRyYWNrJyA/ICdzdWJ0aXRsZScgOiAnbWFpbicpICkpO1xuICAgICAgICAgICAgbGV2ZWxEZXRhaWxzLnRsb2FkID0gc3RhdHMudGxvYWQ7XG4gICAgICAgIGlmICh0eXBlID09PSAnbWFuaWZlc3QnKSB7XG4gICAgICAgIC8vIGZpcnN0IHJlcXVlc3QsIHN0cmVhbSBtYW5pZmVzdCAobm8gbWFzdGVyIHBsYXlsaXN0KSwgZmlyZSBtYW5pZmVzdCBsb2FkZWQgZXZlbnQgd2l0aCBsZXZlbCBkZXRhaWxzXG4gICAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnQuTUFOSUZFU1RfTE9BREVELCB7bGV2ZWxzOiBbe3VybDogdXJsLCBkZXRhaWxzIDogbGV2ZWxEZXRhaWxzfV0sIGF1ZGlvVHJhY2tzIDogW10sIHVybDogdXJsLCBzdGF0czogc3RhdHN9KTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0cy50cGFyc2VkID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIGlmIChsZXZlbERldGFpbHMudGFyZ2V0ZHVyYXRpb24pIHtcbiAgICAgICAgICBpZiAoaXNMZXZlbCkge1xuICAgICAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnQuTEVWRUxfTE9BREVELCB7ZGV0YWlsczogbGV2ZWxEZXRhaWxzLCBsZXZlbDogbGV2ZWwgfHwgMCwgaWQ6IGlkIHx8IDAsIHN0YXRzOiBzdGF0c30pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gJ2F1ZGlvVHJhY2snKSB7XG4gICAgICAgICAgICAgIGhscy50cmlnZ2VyKEV2ZW50LkFVRElPX1RSQUNLX0xPQURFRCwge2RldGFpbHM6IGxldmVsRGV0YWlscywgaWQ6IGlkLCBzdGF0czogc3RhdHN9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT09ICdzdWJ0aXRsZVRyYWNrJykge1xuICAgICAgICAgICAgICBobHMudHJpZ2dlcihFdmVudC5TVUJUSVRMRV9UUkFDS19MT0FERUQsIHtkZXRhaWxzOiBsZXZlbERldGFpbHMsIGlkOiBpZCwgc3RhdHM6IHN0YXRzfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGhscy50cmlnZ2VyKEV2ZW50LkVSUk9SLCB7dHlwZTogRXJyb3JUeXBlcy5ORVRXT1JLX0VSUk9SLCBkZXRhaWxzOiBFcnJvckRldGFpbHMuTUFOSUZFU1RfUEFSU0lOR19FUlJPUiwgZmF0YWw6IHRydWUsIHVybDogdXJsLCByZWFzb246ICdpbnZhbGlkIHRhcmdldGR1cmF0aW9uJ30pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgbGV2ZWxzID0gdGhpcy5wYXJzZU1hc3RlclBsYXlsaXN0KHN0cmluZywgdXJsKTtcbiAgICAgICAgLy8gbXVsdGkgbGV2ZWwgcGxheWxpc3QsIHBhcnNlIGxldmVsIGluZm9cbiAgICAgICAgaWYgKGxldmVscy5sZW5ndGgpIHtcbiAgICAgICAgICBsZXQgYXVkaW9UcmFja3MgPSB0aGlzLnBhcnNlTWFzdGVyUGxheWxpc3RNZWRpYShzdHJpbmcsIHVybCwgJ0FVRElPJyk7XG4gICAgICAgICAgbGV0IHN1YnRpdGxlcyA9IHRoaXMucGFyc2VNYXN0ZXJQbGF5bGlzdE1lZGlhKHN0cmluZywgdXJsLCAnU1VCVElUTEVTJyk7XG4gICAgICAgICAgbGV0IGNhcHRpb25zID0gdGhpcy5wYXJzZU1hc3RlclBsYXlsaXN0TWVkaWEoc3RyaW5nLCB1cmwsICdDTE9TRUQtQ0FQVElPTlMnKTtcbiAgICAgICAgICBpZiAoYXVkaW9UcmFja3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBjaGVjayBpZiB3ZSBoYXZlIGZvdW5kIGFuIGF1ZGlvIHRyYWNrIGVtYmVkZGVkIGluIG1haW4gcGxheWxpc3QgKGF1ZGlvIHRyYWNrIHdpdGhvdXQgVVJJIGF0dHJpYnV0ZSlcbiAgICAgICAgICAgIGxldCBlbWJlZGRlZEF1ZGlvRm91bmQgPSBmYWxzZTtcbiAgICAgICAgICAgIGF1ZGlvVHJhY2tzLmZvckVhY2goYXVkaW9UcmFjayA9PiB7XG4gICAgICAgICAgICAgIGlmKCFhdWRpb1RyYWNrLnVybCkge1xuICAgICAgICAgICAgICAgIGVtYmVkZGVkQXVkaW9Gb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gaWYgbm8gZW1iZWRkZWQgYXVkaW8gdHJhY2sgZGVmaW5lZCwgYnV0IGF1ZGlvIGNvZGVjIHNpZ25hbGVkIGluIHF1YWxpdHkgbGV2ZWwsIHdlIG5lZWQgdG8gc2lnbmFsIHRoaXMgbWFpbiBhdWRpbyB0cmFja1xuICAgICAgICAgICAgLy8gdGhpcyBjb3VsZCBoYXBwZW4gd2l0aCBwbGF5bGlzdHMgd2l0aCBhbHQgYXVkaW8gcmVuZGl0aW9uIGluIHdoaWNoIHF1YWxpdHkgbGV2ZWxzIChtYWluKSBjb250YWlucyBib3RoIGF1ZGlvK3ZpZGVvLiBidXQgd2l0aCBtaXhlZCBhdWRpbyB0cmFjayBub3Qgc2lnbmFsZWRcbiAgICAgICAgICAgIGlmIChlbWJlZGRlZEF1ZGlvRm91bmQgPT09IGZhbHNlICYmIGxldmVsc1swXS5hdWRpb0NvZGVjICYmICFsZXZlbHNbMF0uYXR0cnMuQVVESU8pIHtcbiAgICAgICAgICAgICAgbG9nZ2VyLmxvZygnYXVkaW8gY29kZWMgc2lnbmFsZWQgaW4gcXVhbGl0eSBsZXZlbCwgYnV0IG5vIGVtYmVkZGVkIGF1ZGlvIHRyYWNrIHNpZ25hbGVkLCBjcmVhdGUgb25lJyk7XG4gICAgICAgICAgICAgIGF1ZGlvVHJhY2tzLnVuc2hpZnQoeyB0eXBlIDogJ21haW4nLCBuYW1lIDogJ21haW4nfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGhscy50cmlnZ2VyKEV2ZW50Lk1BTklGRVNUX0xPQURFRCwge2xldmVscywgYXVkaW9UcmFja3MsIHN1YnRpdGxlcywgY2FwdGlvbnMsIHVybCwgc3RhdHN9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodHlwZSA9PT0gJ21hbmlmZXN0Jykge1xuICAgICAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnQuRVJST1IsIHtcbiAgICAgICAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5ORVRXT1JLX0VSUk9SLFxuICAgICAgICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuTUFOSUZFU1RfUEFSU0lOR19FUlJPUixcbiAgICAgICAgICAgICAgZmF0YWw6IHRydWUsXG4gICAgICAgICAgICAgIHVybDogdXJsLFxuICAgICAgICAgICAgICByZWFzb246ICdubyBsZXZlbCBmb3VuZCBpbiBtYW5pZmVzdCdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBobHMudHJpZ2dlcihFdmVudC5FUlJPUiwge3R5cGU6IEVycm9yVHlwZXMuTkVUV09SS19FUlJPUiwgZGV0YWlsczogRXJyb3JEZXRhaWxzLk1BTklGRVNUX0VNUFRZX0VSUk9SLCBmYXRhbDogZmFsc2UsIHVybDogdXJsLCByZWFzb246ICdubyBsZXZlbCBmb3VuZCBpbiBtYW5pZmVzdCcsIGNvbnRleHQgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGhscy50cmlnZ2VyKEV2ZW50LkVSUk9SLCB7dHlwZTogRXJyb3JUeXBlcy5ORVRXT1JLX0VSUk9SLCBkZXRhaWxzOiBFcnJvckRldGFpbHMuTUFOSUZFU1RfUEFSU0lOR19FUlJPUiwgZmF0YWw6IHRydWUsIHVybDogdXJsLCByZWFzb246ICdubyBFWFRNM1UgZGVsaW1pdGVyJ30pO1xuICAgIH1cbiAgfVxuXG4gIGxvYWRlcnJvcihyZXNwb25zZSwgY29udGV4dCkge1xuICAgIHZhciBkZXRhaWxzLCBmYXRhbCxsb2FkZXIgPSBjb250ZXh0LmxvYWRlcjtcbiAgICBzd2l0Y2goY29udGV4dC50eXBlKSB7XG4gICAgICBjYXNlICdtYW5pZmVzdCc6XG4gICAgICAgIGRldGFpbHMgPSBFcnJvckRldGFpbHMuTUFOSUZFU1RfTE9BRF9FUlJPUjtcbiAgICAgICAgZmF0YWwgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2xldmVsJzpcbiAgICAgICAgZGV0YWlscyA9IEVycm9yRGV0YWlscy5MRVZFTF9MT0FEX0VSUk9SO1xuICAgICAgICBmYXRhbCA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2F1ZGlvVHJhY2snOlxuICAgICAgICBkZXRhaWxzID0gRXJyb3JEZXRhaWxzLkFVRElPX1RSQUNLX0xPQURfRVJST1I7XG4gICAgICAgIGZhdGFsID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAobG9hZGVyKSB7XG4gICAgICBsb2FkZXIuYWJvcnQoKTtcbiAgICAgIHRoaXMubG9hZGVyc1tjb250ZXh0LnR5cGVdID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkVSUk9SLCB7dHlwZTogRXJyb3JUeXBlcy5ORVRXT1JLX0VSUk9SLCBkZXRhaWxzOiBkZXRhaWxzLCBmYXRhbDogZmF0YWwsIHVybDogY29udGV4dC51cmwsIGxvYWRlcjogbG9hZGVyLCByZXNwb25zZTogcmVzcG9uc2UsIGNvbnRleHQgOiBjb250ZXh0fSk7XG4gIH1cblxuICBsb2FkdGltZW91dChzdGF0cywgY29udGV4dCkge1xuICAgIHZhciBkZXRhaWxzLCBmYXRhbCwgbG9hZGVyID0gY29udGV4dC5sb2FkZXI7XG4gICAgc3dpdGNoKGNvbnRleHQudHlwZSkge1xuICAgICAgY2FzZSAnbWFuaWZlc3QnOlxuICAgICAgICBkZXRhaWxzID0gRXJyb3JEZXRhaWxzLk1BTklGRVNUX0xPQURfVElNRU9VVDtcbiAgICAgICAgZmF0YWwgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2xldmVsJzpcbiAgICAgICAgZGV0YWlscyA9IEVycm9yRGV0YWlscy5MRVZFTF9MT0FEX1RJTUVPVVQ7XG4gICAgICAgIGZhdGFsID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnYXVkaW9UcmFjayc6XG4gICAgICAgIGRldGFpbHMgPSBFcnJvckRldGFpbHMuQVVESU9fVFJBQ0tfTE9BRF9USU1FT1VUO1xuICAgICAgICBmYXRhbCA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKGxvYWRlcikge1xuICAgICAgbG9hZGVyLmFib3J0KCk7XG4gICAgICB0aGlzLmxvYWRlcnNbY29udGV4dC50eXBlXSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5FUlJPUiwge3R5cGU6IEVycm9yVHlwZXMuTkVUV09SS19FUlJPUiwgZGV0YWlsczogZGV0YWlscywgZmF0YWw6IGZhdGFsLCB1cmw6IGNvbnRleHQudXJsLCBsb2FkZXI6IGxvYWRlciwgY29udGV4dCA6IGNvbnRleHR9KTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBQbGF5bGlzdExvYWRlcjtcbiIsIi8qKlxuICogR2VuZXJhdGUgTVA0IEJveFxuKi9cblxuLy9pbXBvcnQgSGV4IGZyb20gJy4uL3V0aWxzL2hleCc7XG5cbmNvbnN0IFVJTlQzMl9NQVggPSBNYXRoLnBvdygyLCAzMikgLSAxO1xuXG5jbGFzcyBNUDQge1xuICBzdGF0aWMgaW5pdCgpIHtcbiAgICBNUDQudHlwZXMgPSB7XG4gICAgICBhdmMxOiBbXSwgLy8gY29kaW5nbmFtZVxuICAgICAgYXZjQzogW10sXG4gICAgICBidHJ0OiBbXSxcbiAgICAgIGRpbmY6IFtdLFxuICAgICAgZHJlZjogW10sXG4gICAgICBlc2RzOiBbXSxcbiAgICAgIGZ0eXA6IFtdLFxuICAgICAgaGRscjogW10sXG4gICAgICBtZGF0OiBbXSxcbiAgICAgIG1kaGQ6IFtdLFxuICAgICAgbWRpYTogW10sXG4gICAgICBtZmhkOiBbXSxcbiAgICAgIG1pbmY6IFtdLFxuICAgICAgbW9vZjogW10sXG4gICAgICBtb292OiBbXSxcbiAgICAgIG1wNGE6IFtdLFxuICAgICAgJy5tcDMnOiBbXSxcbiAgICAgIG12ZXg6IFtdLFxuICAgICAgbXZoZDogW10sXG4gICAgICBwYXNwOiBbXSxcbiAgICAgIHNkdHA6IFtdLFxuICAgICAgc3RibDogW10sXG4gICAgICBzdGNvOiBbXSxcbiAgICAgIHN0c2M6IFtdLFxuICAgICAgc3RzZDogW10sXG4gICAgICBzdHN6OiBbXSxcbiAgICAgIHN0dHM6IFtdLFxuICAgICAgdGZkdDogW10sXG4gICAgICB0ZmhkOiBbXSxcbiAgICAgIHRyYWY6IFtdLFxuICAgICAgdHJhazogW10sXG4gICAgICB0cnVuOiBbXSxcbiAgICAgIHRyZXg6IFtdLFxuICAgICAgdGtoZDogW10sXG4gICAgICB2bWhkOiBbXSxcbiAgICAgIHNtaGQ6IFtdXG4gICAgfTtcblxuICAgIHZhciBpO1xuICAgIGZvciAoaSBpbiBNUDQudHlwZXMpIHtcbiAgICAgIGlmIChNUDQudHlwZXMuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgTVA0LnR5cGVzW2ldID0gW1xuICAgICAgICAgIGkuY2hhckNvZGVBdCgwKSxcbiAgICAgICAgICBpLmNoYXJDb2RlQXQoMSksXG4gICAgICAgICAgaS5jaGFyQ29kZUF0KDIpLFxuICAgICAgICAgIGkuY2hhckNvZGVBdCgzKVxuICAgICAgICBdO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciB2aWRlb0hkbHIgPSBuZXcgVWludDhBcnJheShbXG4gICAgICAweDAwLCAvLyB2ZXJzaW9uIDBcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGZsYWdzXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyBwcmVfZGVmaW5lZFxuICAgICAgMHg3NiwgMHg2OSwgMHg2NCwgMHg2NSwgLy8gaGFuZGxlcl90eXBlOiAndmlkZSdcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAgIDB4NTYsIDB4NjksIDB4NjQsIDB4NjUsXG4gICAgICAweDZmLCAweDQ4LCAweDYxLCAweDZlLFxuICAgICAgMHg2NCwgMHg2YywgMHg2NSwgMHg3MiwgMHgwMCAvLyBuYW1lOiAnVmlkZW9IYW5kbGVyJ1xuICAgIF0pO1xuXG4gICAgdmFyIGF1ZGlvSGRsciA9IG5ldyBVaW50OEFycmF5KFtcbiAgICAgIDB4MDAsIC8vIHZlcnNpb24gMFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gZmxhZ3NcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHByZV9kZWZpbmVkXG4gICAgICAweDczLCAweDZmLCAweDc1LCAweDZlLCAvLyBoYW5kbGVyX3R5cGU6ICdzb3VuJ1xuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxuICAgICAgMHg1MywgMHg2ZiwgMHg3NSwgMHg2ZSxcbiAgICAgIDB4NjQsIDB4NDgsIDB4NjEsIDB4NmUsXG4gICAgICAweDY0LCAweDZjLCAweDY1LCAweDcyLCAweDAwIC8vIG5hbWU6ICdTb3VuZEhhbmRsZXInXG4gICAgXSk7XG5cbiAgICBNUDQuSERMUl9UWVBFUyA9IHtcbiAgICAgICd2aWRlbyc6IHZpZGVvSGRscixcbiAgICAgICdhdWRpbyc6IGF1ZGlvSGRsclxuICAgIH07XG5cbiAgICB2YXIgZHJlZiA9IG5ldyBVaW50OEFycmF5KFtcbiAgICAgIDB4MDAsIC8vIHZlcnNpb24gMFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gZmxhZ3NcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDEsIC8vIGVudHJ5X2NvdW50XG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDBjLCAvLyBlbnRyeV9zaXplXG4gICAgICAweDc1LCAweDcyLCAweDZjLCAweDIwLCAvLyAndXJsJyB0eXBlXG4gICAgICAweDAwLCAvLyB2ZXJzaW9uIDBcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDEgLy8gZW50cnlfZmxhZ3NcbiAgICBdKTtcblxuICAgIHZhciBzdGNvID0gbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgMHgwMCwgLy8gdmVyc2lvblxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gZmxhZ3NcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAgLy8gZW50cnlfY291bnRcbiAgICBdKTtcblxuICAgIE1QNC5TVFRTID0gTVA0LlNUU0MgPSBNUDQuU1RDTyA9IHN0Y287XG5cbiAgICBNUDQuU1RTWiA9IG5ldyBVaW50OEFycmF5KFtcbiAgICAgIDB4MDAsIC8vIHZlcnNpb25cbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGZsYWdzXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyBzYW1wbGVfc2l6ZVxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gc2FtcGxlX2NvdW50XG4gICAgXSk7XG4gICAgTVA0LlZNSEQgPSBuZXcgVWludDhBcnJheShbXG4gICAgICAweDAwLCAvLyB2ZXJzaW9uXG4gICAgICAweDAwLCAweDAwLCAweDAxLCAvLyBmbGFnc1xuICAgICAgMHgwMCwgMHgwMCwgLy8gZ3JhcGhpY3Ntb2RlXG4gICAgICAweDAwLCAweDAwLFxuICAgICAgMHgwMCwgMHgwMCxcbiAgICAgIDB4MDAsIDB4MDAgLy8gb3Bjb2xvclxuICAgIF0pO1xuICAgIE1QNC5TTUhEID0gbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgMHgwMCwgLy8gdmVyc2lvblxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gZmxhZ3NcbiAgICAgIDB4MDAsIDB4MDAsIC8vIGJhbGFuY2VcbiAgICAgIDB4MDAsIDB4MDAgLy8gcmVzZXJ2ZWRcbiAgICBdKTtcblxuICAgIE1QNC5TVFNEID0gbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgMHgwMCwgLy8gdmVyc2lvbiAwXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAvLyBmbGFnc1xuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMV0pOy8vIGVudHJ5X2NvdW50XG5cbiAgICB2YXIgbWFqb3JCcmFuZCA9IG5ldyBVaW50OEFycmF5KFsxMDUsMTE1LDExMSwxMDldKTsgLy8gaXNvbVxuICAgIHZhciBhdmMxQnJhbmQgPSBuZXcgVWludDhBcnJheShbOTcsMTE4LDk5LDQ5XSk7IC8vIGF2YzFcbiAgICB2YXIgbWlub3JWZXJzaW9uID0gbmV3IFVpbnQ4QXJyYXkoWzAsIDAsIDAsIDFdKTtcblxuICAgIE1QNC5GVFlQID0gTVA0LmJveChNUDQudHlwZXMuZnR5cCwgbWFqb3JCcmFuZCwgbWlub3JWZXJzaW9uLCBtYWpvckJyYW5kLCBhdmMxQnJhbmQpO1xuICAgIE1QNC5ESU5GID0gTVA0LmJveChNUDQudHlwZXMuZGluZiwgTVA0LmJveChNUDQudHlwZXMuZHJlZiwgZHJlZikpO1xuICB9XG5cbiAgc3RhdGljIGJveCh0eXBlKSB7XG4gIHZhclxuICAgIHBheWxvYWQgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpLFxuICAgIHNpemUgPSA4LFxuICAgIGkgPSBwYXlsb2FkLmxlbmd0aCxcbiAgICBsZW4gPSBpLFxuICAgIHJlc3VsdDtcbiAgICAvLyBjYWxjdWxhdGUgdGhlIHRvdGFsIHNpemUgd2UgbmVlZCB0byBhbGxvY2F0ZVxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHNpemUgKz0gcGF5bG9hZFtpXS5ieXRlTGVuZ3RoO1xuICAgIH1cbiAgICByZXN1bHQgPSBuZXcgVWludDhBcnJheShzaXplKTtcbiAgICByZXN1bHRbMF0gPSAoc2l6ZSA+PiAyNCkgJiAweGZmO1xuICAgIHJlc3VsdFsxXSA9IChzaXplID4+IDE2KSAmIDB4ZmY7XG4gICAgcmVzdWx0WzJdID0gKHNpemUgPj4gOCkgJiAweGZmO1xuICAgIHJlc3VsdFszXSA9IHNpemUgICYgMHhmZjtcbiAgICByZXN1bHQuc2V0KHR5cGUsIDQpO1xuICAgIC8vIGNvcHkgdGhlIHBheWxvYWQgaW50byB0aGUgcmVzdWx0XG4gICAgZm9yIChpID0gMCwgc2l6ZSA9IDg7IGkgPCBsZW47IGkrKykge1xuICAgICAgLy8gY29weSBwYXlsb2FkW2ldIGFycmF5IEAgb2Zmc2V0IHNpemVcbiAgICAgIHJlc3VsdC5zZXQocGF5bG9hZFtpXSwgc2l6ZSk7XG4gICAgICBzaXplICs9IHBheWxvYWRbaV0uYnl0ZUxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHN0YXRpYyBoZGxyKHR5cGUpIHtcbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMuaGRsciwgTVA0LkhETFJfVFlQRVNbdHlwZV0pO1xuICB9XG5cbiAgc3RhdGljIG1kYXQoZGF0YSkge1xuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5tZGF0LCBkYXRhKTtcbiAgfVxuXG4gIHN0YXRpYyBtZGhkKHRpbWVzY2FsZSwgZHVyYXRpb24pIHtcbiAgICBkdXJhdGlvbiAqPSB0aW1lc2NhbGU7XG4gICAgY29uc3QgdXBwZXJXb3JkRHVyYXRpb24gPSBNYXRoLmZsb29yKGR1cmF0aW9uIC8gKFVJTlQzMl9NQVggKyAxKSk7XG4gICAgY29uc3QgbG93ZXJXb3JkRHVyYXRpb24gPSBNYXRoLmZsb29yKGR1cmF0aW9uICUgKFVJTlQzMl9NQVggKyAxKSk7XG4gICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLm1kaGQsIG5ldyBVaW50OEFycmF5KFtcbiAgICAgIDB4MDEsIC8vIHZlcnNpb24gMVxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gZmxhZ3NcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDIsIC8vIGNyZWF0aW9uX3RpbWVcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDMsIC8vIG1vZGlmaWNhdGlvbl90aW1lXG4gICAgICAodGltZXNjYWxlID4+IDI0KSAmIDB4RkYsXG4gICAgICAodGltZXNjYWxlID4+IDE2KSAmIDB4RkYsXG4gICAgICAodGltZXNjYWxlID4+ICA4KSAmIDB4RkYsXG4gICAgICB0aW1lc2NhbGUgJiAweEZGLCAvLyB0aW1lc2NhbGVcbiAgICAgICh1cHBlcldvcmREdXJhdGlvbiA+PiAyNCksXG4gICAgICAodXBwZXJXb3JkRHVyYXRpb24gPj4gMTYpICYgMHhGRixcbiAgICAgICh1cHBlcldvcmREdXJhdGlvbiA+PiAgOCkgJiAweEZGLFxuICAgICAgdXBwZXJXb3JkRHVyYXRpb24gJiAweEZGLFxuICAgICAgKGxvd2VyV29yZER1cmF0aW9uID4+IDI0KSxcbiAgICAgIChsb3dlcldvcmREdXJhdGlvbiA+PiAxNikgJiAweEZGLFxuICAgICAgKGxvd2VyV29yZER1cmF0aW9uID4+ICA4KSAmIDB4RkYsXG4gICAgICBsb3dlcldvcmREdXJhdGlvbiAmIDB4RkYsXG4gICAgICAweDU1LCAweGM0LCAvLyAndW5kJyBsYW5ndWFnZSAodW5kZXRlcm1pbmVkKVxuICAgICAgMHgwMCwgMHgwMFxuICAgIF0pKTtcbiAgfVxuXG4gIHN0YXRpYyBtZGlhKHRyYWNrKSB7XG4gICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLm1kaWEsIE1QNC5tZGhkKHRyYWNrLnRpbWVzY2FsZSwgdHJhY2suZHVyYXRpb24pLCBNUDQuaGRscih0cmFjay50eXBlKSwgTVA0Lm1pbmYodHJhY2spKTtcbiAgfVxuXG4gIHN0YXRpYyBtZmhkKHNlcXVlbmNlTnVtYmVyKSB7XG4gICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLm1maGQsIG5ldyBVaW50OEFycmF5KFtcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAvLyBmbGFnc1xuICAgICAgKHNlcXVlbmNlTnVtYmVyID4+IDI0KSxcbiAgICAgIChzZXF1ZW5jZU51bWJlciA+PiAxNikgJiAweEZGLFxuICAgICAgKHNlcXVlbmNlTnVtYmVyID4+ICA4KSAmIDB4RkYsXG4gICAgICBzZXF1ZW5jZU51bWJlciAmIDB4RkYsIC8vIHNlcXVlbmNlX251bWJlclxuICAgIF0pKTtcbiAgfVxuXG4gIHN0YXRpYyBtaW5mKHRyYWNrKSB7XG4gICAgaWYgKHRyYWNrLnR5cGUgPT09ICdhdWRpbycpIHtcbiAgICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5taW5mLCBNUDQuYm94KE1QNC50eXBlcy5zbWhkLCBNUDQuU01IRCksIE1QNC5ESU5GLCBNUDQuc3RibCh0cmFjaykpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMubWluZiwgTVA0LmJveChNUDQudHlwZXMudm1oZCwgTVA0LlZNSEQpLCBNUDQuRElORiwgTVA0LnN0YmwodHJhY2spKTtcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgbW9vZihzbiwgYmFzZU1lZGlhRGVjb2RlVGltZSwgdHJhY2spIHtcbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMubW9vZiwgTVA0Lm1maGQoc24pLCBNUDQudHJhZih0cmFjayxiYXNlTWVkaWFEZWNvZGVUaW1lKSk7XG4gIH1cbi8qKlxuICogQHBhcmFtIHRyYWNrcy4uLiAob3B0aW9uYWwpIHthcnJheX0gdGhlIHRyYWNrcyBhc3NvY2lhdGVkIHdpdGggdGhpcyBtb3ZpZVxuICovXG4gIHN0YXRpYyBtb292KHRyYWNrcykge1xuICAgIHZhclxuICAgICAgaSA9IHRyYWNrcy5sZW5ndGgsXG4gICAgICBib3hlcyA9IFtdO1xuXG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgYm94ZXNbaV0gPSBNUDQudHJhayh0cmFja3NbaV0pO1xuICAgIH1cblxuICAgIHJldHVybiBNUDQuYm94LmFwcGx5KG51bGwsIFtNUDQudHlwZXMubW9vdiwgTVA0Lm12aGQodHJhY2tzWzBdLnRpbWVzY2FsZSwgdHJhY2tzWzBdLmR1cmF0aW9uKV0uY29uY2F0KGJveGVzKS5jb25jYXQoTVA0Lm12ZXgodHJhY2tzKSkpO1xuICB9XG5cbiAgc3RhdGljIG12ZXgodHJhY2tzKSB7XG4gICAgdmFyXG4gICAgICBpID0gdHJhY2tzLmxlbmd0aCxcbiAgICAgIGJveGVzID0gW107XG5cbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBib3hlc1tpXSA9IE1QNC50cmV4KHRyYWNrc1tpXSk7XG4gICAgfVxuICAgIHJldHVybiBNUDQuYm94LmFwcGx5KG51bGwsIFtNUDQudHlwZXMubXZleF0uY29uY2F0KGJveGVzKSk7XG4gIH1cblxuICBzdGF0aWMgbXZoZCh0aW1lc2NhbGUsZHVyYXRpb24pIHtcbiAgICBkdXJhdGlvbio9dGltZXNjYWxlO1xuICAgIGNvbnN0IHVwcGVyV29yZER1cmF0aW9uID0gTWF0aC5mbG9vcihkdXJhdGlvbiAvIChVSU5UMzJfTUFYICsgMSkpO1xuICAgIGNvbnN0IGxvd2VyV29yZER1cmF0aW9uID0gTWF0aC5mbG9vcihkdXJhdGlvbiAlIChVSU5UMzJfTUFYICsgMSkpO1xuICAgIHZhclxuICAgICAgYnl0ZXMgPSBuZXcgVWludDhBcnJheShbXG4gICAgICAgIDB4MDEsIC8vIHZlcnNpb24gMVxuICAgICAgICAweDAwLCAweDAwLCAweDAwLCAvLyBmbGFnc1xuICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAyLCAvLyBjcmVhdGlvbl90aW1lXG4gICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDMsIC8vIG1vZGlmaWNhdGlvbl90aW1lXG4gICAgICAgICh0aW1lc2NhbGUgPj4gMjQpICYgMHhGRixcbiAgICAgICAgKHRpbWVzY2FsZSA+PiAxNikgJiAweEZGLFxuICAgICAgICAodGltZXNjYWxlID4+ICA4KSAmIDB4RkYsXG4gICAgICAgIHRpbWVzY2FsZSAmIDB4RkYsIC8vIHRpbWVzY2FsZVxuICAgICAgICAodXBwZXJXb3JkRHVyYXRpb24gPj4gMjQpLFxuICAgICAgICAodXBwZXJXb3JkRHVyYXRpb24gPj4gMTYpICYgMHhGRixcbiAgICAgICAgKHVwcGVyV29yZER1cmF0aW9uID4+ICA4KSAmIDB4RkYsXG4gICAgICAgIHVwcGVyV29yZER1cmF0aW9uICYgMHhGRixcbiAgICAgICAgKGxvd2VyV29yZER1cmF0aW9uID4+IDI0KSxcbiAgICAgICAgKGxvd2VyV29yZER1cmF0aW9uID4+IDE2KSAmIDB4RkYsXG4gICAgICAgIChsb3dlcldvcmREdXJhdGlvbiA+PiAgOCkgJiAweEZGLFxuICAgICAgICBsb3dlcldvcmREdXJhdGlvbiAmIDB4RkYsXG4gICAgICAgIDB4MDAsIDB4MDEsIDB4MDAsIDB4MDAsIC8vIDEuMCByYXRlXG4gICAgICAgIDB4MDEsIDB4MDAsIC8vIDEuMCB2b2x1bWVcbiAgICAgICAgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAgICAgMHgwMCwgMHgwMSwgMHgwMCwgMHgwMCxcbiAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgICAgMHgwMCwgMHgwMSwgMHgwMCwgMHgwMCxcbiAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgICAgMHg0MCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gdHJhbnNmb3JtYXRpb246IHVuaXR5IG1hdHJpeFxuICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyBwcmVfZGVmaW5lZFxuICAgICAgICAweGZmLCAweGZmLCAweGZmLCAweGZmIC8vIG5leHRfdHJhY2tfSURcbiAgICAgIF0pO1xuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5tdmhkLCBieXRlcyk7XG4gIH1cblxuICBzdGF0aWMgc2R0cCh0cmFjaykge1xuICAgIHZhclxuICAgICAgc2FtcGxlcyA9IHRyYWNrLnNhbXBsZXMgfHwgW10sXG4gICAgICBieXRlcyA9IG5ldyBVaW50OEFycmF5KDQgKyBzYW1wbGVzLmxlbmd0aCksXG4gICAgICBmbGFncyxcbiAgICAgIGk7XG4gICAgLy8gbGVhdmUgdGhlIGZ1bGwgYm94IGhlYWRlciAoNCBieXRlcykgYWxsIHplcm9cbiAgICAvLyB3cml0ZSB0aGUgc2FtcGxlIHRhYmxlXG4gICAgZm9yIChpID0gMDsgaSA8IHNhbXBsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGZsYWdzID0gc2FtcGxlc1tpXS5mbGFncztcbiAgICAgIGJ5dGVzW2kgKyA0XSA9IChmbGFncy5kZXBlbmRzT24gPDwgNCkgfFxuICAgICAgICAoZmxhZ3MuaXNEZXBlbmRlZE9uIDw8IDIpIHxcbiAgICAgICAgKGZsYWdzLmhhc1JlZHVuZGFuY3kpO1xuICAgIH1cblxuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5zZHRwLCBieXRlcyk7XG4gIH1cblxuICBzdGF0aWMgc3RibCh0cmFjaykge1xuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5zdGJsLCBNUDQuc3RzZCh0cmFjayksIE1QNC5ib3goTVA0LnR5cGVzLnN0dHMsIE1QNC5TVFRTKSwgTVA0LmJveChNUDQudHlwZXMuc3RzYywgTVA0LlNUU0MpLCBNUDQuYm94KE1QNC50eXBlcy5zdHN6LCBNUDQuU1RTWiksIE1QNC5ib3goTVA0LnR5cGVzLnN0Y28sIE1QNC5TVENPKSk7XG4gIH1cblxuICBzdGF0aWMgYXZjMSh0cmFjaykge1xuICAgIHZhciBzcHMgPSBbXSwgcHBzID0gW10sIGksIGRhdGEsIGxlbjtcbiAgICAvLyBhc3NlbWJsZSB0aGUgU1BTc1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHRyYWNrLnNwcy5sZW5ndGg7IGkrKykge1xuICAgICAgZGF0YSA9IHRyYWNrLnNwc1tpXTtcbiAgICAgIGxlbiA9IGRhdGEuYnl0ZUxlbmd0aDtcbiAgICAgIHNwcy5wdXNoKChsZW4gPj4+IDgpICYgMHhGRik7XG4gICAgICBzcHMucHVzaCgobGVuICYgMHhGRikpO1xuICAgICAgc3BzID0gc3BzLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChkYXRhKSk7IC8vIFNQU1xuICAgIH1cblxuICAgIC8vIGFzc2VtYmxlIHRoZSBQUFNzXG4gICAgZm9yIChpID0gMDsgaSA8IHRyYWNrLnBwcy5sZW5ndGg7IGkrKykge1xuICAgICAgZGF0YSA9IHRyYWNrLnBwc1tpXTtcbiAgICAgIGxlbiA9IGRhdGEuYnl0ZUxlbmd0aDtcbiAgICAgIHBwcy5wdXNoKChsZW4gPj4+IDgpICYgMHhGRik7XG4gICAgICBwcHMucHVzaCgobGVuICYgMHhGRikpO1xuICAgICAgcHBzID0gcHBzLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChkYXRhKSk7XG4gICAgfVxuXG4gICAgdmFyIGF2Y2MgPSBNUDQuYm94KE1QNC50eXBlcy5hdmNDLCBuZXcgVWludDhBcnJheShbXG4gICAgICAgICAgICAweDAxLCAgIC8vIHZlcnNpb25cbiAgICAgICAgICAgIHNwc1szXSwgLy8gcHJvZmlsZVxuICAgICAgICAgICAgc3BzWzRdLCAvLyBwcm9maWxlIGNvbXBhdFxuICAgICAgICAgICAgc3BzWzVdLCAvLyBsZXZlbFxuICAgICAgICAgICAgMHhmYyB8IDMsIC8vIGxlbmd0aFNpemVNaW51c09uZSwgaGFyZC1jb2RlZCB0byA0IGJ5dGVzXG4gICAgICAgICAgICAweEUwIHwgdHJhY2suc3BzLmxlbmd0aCAvLyAzYml0IHJlc2VydmVkICgxMTEpICsgbnVtT2ZTZXF1ZW5jZVBhcmFtZXRlclNldHNcbiAgICAgICAgICBdLmNvbmNhdChzcHMpLmNvbmNhdChbXG4gICAgICAgICAgICB0cmFjay5wcHMubGVuZ3RoIC8vIG51bU9mUGljdHVyZVBhcmFtZXRlclNldHNcbiAgICAgICAgICBdKS5jb25jYXQocHBzKSkpLCAvLyBcIlBQU1wiXG4gICAgICAgIHdpZHRoID0gdHJhY2sud2lkdGgsXG4gICAgICAgIGhlaWdodCA9IHRyYWNrLmhlaWdodCxcbiAgICAgICAgaFNwYWNpbmcgPSB0cmFjay5waXhlbFJhdGlvWzBdLFxuICAgICAgICB2U3BhY2luZyA9IHRyYWNrLnBpeGVsUmF0aW9bMV07XG4gICAgLy9jb25zb2xlLmxvZygnYXZjYzonICsgSGV4LmhleER1bXAoYXZjYykpO1xuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5hdmMxLCBuZXcgVWludDhBcnJheShbXG4gICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgICAgIDB4MDAsIDB4MDEsIC8vIGRhdGFfcmVmZXJlbmNlX2luZGV4XG4gICAgICAgIDB4MDAsIDB4MDAsIC8vIHByZV9kZWZpbmVkXG4gICAgICAgIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHByZV9kZWZpbmVkXG4gICAgICAgICh3aWR0aCA+PiA4KSAmIDB4RkYsXG4gICAgICAgIHdpZHRoICYgMHhmZiwgLy8gd2lkdGhcbiAgICAgICAgKGhlaWdodCA+PiA4KSAmIDB4RkYsXG4gICAgICAgIGhlaWdodCAmIDB4ZmYsIC8vIGhlaWdodFxuICAgICAgICAweDAwLCAweDQ4LCAweDAwLCAweDAwLCAvLyBob3JpenJlc29sdXRpb25cbiAgICAgICAgMHgwMCwgMHg0OCwgMHgwMCwgMHgwMCwgLy8gdmVydHJlc29sdXRpb25cbiAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAgICAgMHgwMCwgMHgwMSwgLy8gZnJhbWVfY291bnRcbiAgICAgICAgMHgxMixcbiAgICAgICAgMHg2NCwgMHg2MSwgMHg2OSwgMHg2QywgLy9kYWlseW1vdGlvbi9obHMuanNcbiAgICAgICAgMHg3OSwgMHg2RCwgMHg2RiwgMHg3NCxcbiAgICAgICAgMHg2OSwgMHg2RiwgMHg2RSwgMHgyRixcbiAgICAgICAgMHg2OCwgMHg2QywgMHg3MywgMHgyRSxcbiAgICAgICAgMHg2QSwgMHg3MywgMHgwMCwgMHgwMCxcbiAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gY29tcHJlc3Nvcm5hbWVcbiAgICAgICAgMHgwMCwgMHgxOCwgICAvLyBkZXB0aCA9IDI0XG4gICAgICAgIDB4MTEsIDB4MTFdKSwgLy8gcHJlX2RlZmluZWQgPSAtMVxuICAgICAgICAgIGF2Y2MsXG4gICAgICAgICAgTVA0LmJveChNUDQudHlwZXMuYnRydCwgbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgICAgICAgMHgwMCwgMHgxYywgMHg5YywgMHg4MCwgLy8gYnVmZmVyU2l6ZURCXG4gICAgICAgICAgICAweDAwLCAweDJkLCAweGM2LCAweGMwLCAvLyBtYXhCaXRyYXRlXG4gICAgICAgICAgICAweDAwLCAweDJkLCAweGM2LCAweGMwXSkpLCAvLyBhdmdCaXRyYXRlXG4gICAgICAgICAgTVA0LmJveChNUDQudHlwZXMucGFzcCwgbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgICAgICAgKGhTcGFjaW5nID4+IDI0KSwgICAgICAgICAvLyBoU3BhY2luZ1xuICAgICAgICAgICAgKGhTcGFjaW5nID4+IDE2KSAmIDB4RkYsXG4gICAgICAgICAgICAoaFNwYWNpbmcgPj4gIDgpICYgMHhGRixcbiAgICAgICAgICAgIGhTcGFjaW5nICYgMHhGRixcbiAgICAgICAgICAgICh2U3BhY2luZyA+PiAyNCksICAgICAgICAgLy8gdlNwYWNpbmdcbiAgICAgICAgICAgICh2U3BhY2luZyA+PiAxNikgJiAweEZGLFxuICAgICAgICAgICAgKHZTcGFjaW5nID4+ICA4KSAmIDB4RkYsXG4gICAgICAgICAgICB2U3BhY2luZyAmIDB4RkZdKSlcbiAgICAgICAgICApO1xuICB9XG5cbiAgc3RhdGljIGVzZHModHJhY2spIHtcbiAgICB2YXIgY29uZmlnbGVuID0gdHJhY2suY29uZmlnLmxlbmd0aDtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgMHgwMCwgLy8gdmVyc2lvbiAwXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAvLyBmbGFnc1xuXG4gICAgICAweDAzLCAvLyBkZXNjcmlwdG9yX3R5cGVcbiAgICAgIDB4MTcrY29uZmlnbGVuLCAvLyBsZW5ndGhcbiAgICAgIDB4MDAsIDB4MDEsIC8vZXNfaWRcbiAgICAgIDB4MDAsIC8vIHN0cmVhbV9wcmlvcml0eVxuXG4gICAgICAweDA0LCAvLyBkZXNjcmlwdG9yX3R5cGVcbiAgICAgIDB4MGYrY29uZmlnbGVuLCAvLyBsZW5ndGhcbiAgICAgIDB4NDAsIC8vY29kZWMgOiBtcGVnNF9hdWRpb1xuICAgICAgMHgxNSwgLy8gc3RyZWFtX3R5cGVcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGJ1ZmZlcl9zaXplXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyBtYXhCaXRyYXRlXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyBhdmdCaXRyYXRlXG5cbiAgICAgIDB4MDUgLy8gZGVzY3JpcHRvcl90eXBlXG4gICAgICBdLmNvbmNhdChbY29uZmlnbGVuXSkuY29uY2F0KHRyYWNrLmNvbmZpZykuY29uY2F0KFsweDA2LCAweDAxLCAweDAyXSkpOyAvLyBHQVNwZWNpZmljQ29uZmlnKSk7IC8vIGxlbmd0aCArIGF1ZGlvIGNvbmZpZyBkZXNjcmlwdG9yXG4gIH1cblxuICBzdGF0aWMgbXA0YSh0cmFjaykge1xuICAgIHZhciBzYW1wbGVyYXRlID0gdHJhY2suc2FtcGxlcmF0ZTtcbiAgICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5tcDRhLCBuZXcgVWludDhBcnJheShbXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAgIDB4MDAsIDB4MDEsIC8vIGRhdGFfcmVmZXJlbmNlX2luZGV4XG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAgIDB4MDAsIHRyYWNrLmNoYW5uZWxDb3VudCwgLy8gY2hhbm5lbGNvdW50XG4gICAgICAweDAwLCAweDEwLCAvLyBzYW1wbGVTaXplOjE2Yml0c1xuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWQyXG4gICAgICAoc2FtcGxlcmF0ZSA+PiA4KSAmIDB4RkYsXG4gICAgICBzYW1wbGVyYXRlICYgMHhmZiwgLy9cbiAgICAgIDB4MDAsIDB4MDBdKSxcbiAgICAgIE1QNC5ib3goTVA0LnR5cGVzLmVzZHMsIE1QNC5lc2RzKHRyYWNrKSkpO1xuICB9XG5cbiAgc3RhdGljIG1wMyh0cmFjaykge1xuICAgIHZhciBzYW1wbGVyYXRlID0gdHJhY2suc2FtcGxlcmF0ZTtcbiAgICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlc1snLm1wMyddLCBuZXcgVWludDhBcnJheShbXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAgIDB4MDAsIDB4MDEsIC8vIGRhdGFfcmVmZXJlbmNlX2luZGV4XG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAgIDB4MDAsIHRyYWNrLmNoYW5uZWxDb3VudCwgLy8gY2hhbm5lbGNvdW50XG4gICAgICAweDAwLCAweDEwLCAvLyBzYW1wbGVTaXplOjE2Yml0c1xuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWQyXG4gICAgICAoc2FtcGxlcmF0ZSA+PiA4KSAmIDB4RkYsXG4gICAgICBzYW1wbGVyYXRlICYgMHhmZiwgLy9cbiAgICAgIDB4MDAsIDB4MDBdKSk7XG4gIH1cblxuICBzdGF0aWMgc3RzZCh0cmFjaykge1xuICAgIGlmICh0cmFjay50eXBlID09PSAnYXVkaW8nKSB7XG4gICAgICBpZiAoIXRyYWNrLmlzQUFDICYmIHRyYWNrLmNvZGVjID09PSAnbXAzJykge1xuICAgICAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMuc3RzZCwgTVA0LlNUU0QsIE1QNC5tcDModHJhY2spKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5zdHNkLCBNUDQuU1RTRCwgTVA0Lm1wNGEodHJhY2spKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLnN0c2QsIE1QNC5TVFNELCBNUDQuYXZjMSh0cmFjaykpO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyB0a2hkKHRyYWNrKSB7XG4gICAgdmFyIGlkID0gdHJhY2suaWQsXG4gICAgICAgIGR1cmF0aW9uID0gdHJhY2suZHVyYXRpb24qdHJhY2sudGltZXNjYWxlLFxuICAgICAgICB3aWR0aCA9IHRyYWNrLndpZHRoLFxuICAgICAgICBoZWlnaHQgPSB0cmFjay5oZWlnaHQsXG4gICAgICAgIHVwcGVyV29yZER1cmF0aW9uID0gTWF0aC5mbG9vcihkdXJhdGlvbiAvIChVSU5UMzJfTUFYICsgMSkpLFxuICAgICAgICBsb3dlcldvcmREdXJhdGlvbiA9IE1hdGguZmxvb3IoZHVyYXRpb24gJSAoVUlOVDMyX01BWCArIDEpKTtcbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMudGtoZCwgbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgMHgwMSwgLy8gdmVyc2lvbiAxXG4gICAgICAweDAwLCAweDAwLCAweDA3LCAvLyBmbGFnc1xuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMiwgLy8gY3JlYXRpb25fdGltZVxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMywgLy8gbW9kaWZpY2F0aW9uX3RpbWVcbiAgICAgIChpZCA+PiAyNCkgJiAweEZGLFxuICAgICAgKGlkID4+IDE2KSAmIDB4RkYsXG4gICAgICAoaWQgPj4gOCkgJiAweEZGLFxuICAgICAgaWQgJiAweEZGLCAvLyB0cmFja19JRFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAgICh1cHBlcldvcmREdXJhdGlvbiA+PiAyNCksXG4gICAgICAodXBwZXJXb3JkRHVyYXRpb24gPj4gMTYpICYgMHhGRixcbiAgICAgICh1cHBlcldvcmREdXJhdGlvbiA+PiAgOCkgJiAweEZGLFxuICAgICAgdXBwZXJXb3JkRHVyYXRpb24gJiAweEZGLFxuICAgICAgKGxvd2VyV29yZER1cmF0aW9uID4+IDI0KSxcbiAgICAgIChsb3dlcldvcmREdXJhdGlvbiA+PiAxNikgJiAweEZGLFxuICAgICAgKGxvd2VyV29yZER1cmF0aW9uID4+ICA4KSAmIDB4RkYsXG4gICAgICBsb3dlcldvcmREdXJhdGlvbiAmIDB4RkYsXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAgIDB4MDAsIDB4MDAsIC8vIGxheWVyXG4gICAgICAweDAwLCAweDAwLCAvLyBhbHRlcm5hdGVfZ3JvdXBcbiAgICAgIDB4MDAsIDB4MDAsIC8vIG5vbi1hdWRpbyB0cmFjayB2b2x1bWVcbiAgICAgIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgICAweDAwLCAweDAxLCAweDAwLCAweDAwLFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgMHgwMCwgMHgwMSwgMHgwMCwgMHgwMCxcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgIDB4NDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHRyYW5zZm9ybWF0aW9uOiB1bml0eSBtYXRyaXhcbiAgICAgICh3aWR0aCA+PiA4KSAmIDB4RkYsXG4gICAgICB3aWR0aCAmIDB4RkYsXG4gICAgICAweDAwLCAweDAwLCAvLyB3aWR0aFxuICAgICAgKGhlaWdodCA+PiA4KSAmIDB4RkYsXG4gICAgICBoZWlnaHQgJiAweEZGLFxuICAgICAgMHgwMCwgMHgwMCAvLyBoZWlnaHRcbiAgICBdKSk7XG4gIH1cblxuICBzdGF0aWMgdHJhZih0cmFjayxiYXNlTWVkaWFEZWNvZGVUaW1lKSB7XG4gICAgdmFyIHNhbXBsZURlcGVuZGVuY3lUYWJsZSA9IE1QNC5zZHRwKHRyYWNrKSxcbiAgICAgICAgaWQgPSB0cmFjay5pZCxcbiAgICAgICAgdXBwZXJXb3JkQmFzZU1lZGlhRGVjb2RlVGltZSA9IE1hdGguZmxvb3IoYmFzZU1lZGlhRGVjb2RlVGltZSAvIChVSU5UMzJfTUFYICsgMSkpLFxuICAgICAgICBsb3dlcldvcmRCYXNlTWVkaWFEZWNvZGVUaW1lID0gTWF0aC5mbG9vcihiYXNlTWVkaWFEZWNvZGVUaW1lICUgKFVJTlQzMl9NQVggKyAxKSk7XG4gICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLnRyYWYsXG4gICAgICAgICAgICAgICBNUDQuYm94KE1QNC50eXBlcy50ZmhkLCBuZXcgVWludDhBcnJheShbXG4gICAgICAgICAgICAgICAgIDB4MDAsIC8vIHZlcnNpb24gMFxuICAgICAgICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLCAvLyBmbGFnc1xuICAgICAgICAgICAgICAgICAoaWQgPj4gMjQpLFxuICAgICAgICAgICAgICAgICAoaWQgPj4gMTYpICYgMFhGRixcbiAgICAgICAgICAgICAgICAgKGlkID4+IDgpICYgMFhGRixcbiAgICAgICAgICAgICAgICAgKGlkICYgMHhGRikgLy8gdHJhY2tfSURcbiAgICAgICAgICAgICAgIF0pKSxcbiAgICAgICAgICAgICAgIE1QNC5ib3goTVA0LnR5cGVzLnRmZHQsIG5ldyBVaW50OEFycmF5KFtcbiAgICAgICAgICAgICAgICAgMHgwMSwgLy8gdmVyc2lvbiAxXG4gICAgICAgICAgICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGZsYWdzXG4gICAgICAgICAgICAgICAgICh1cHBlcldvcmRCYXNlTWVkaWFEZWNvZGVUaW1lID4+MjQpLFxuICAgICAgICAgICAgICAgICAodXBwZXJXb3JkQmFzZU1lZGlhRGVjb2RlVGltZSA+PiAxNikgJiAwWEZGLFxuICAgICAgICAgICAgICAgICAodXBwZXJXb3JkQmFzZU1lZGlhRGVjb2RlVGltZSA+PiA4KSAmIDBYRkYsXG4gICAgICAgICAgICAgICAgICh1cHBlcldvcmRCYXNlTWVkaWFEZWNvZGVUaW1lICYgMHhGRiksXG4gICAgICAgICAgICAgICAgIChsb3dlcldvcmRCYXNlTWVkaWFEZWNvZGVUaW1lID4+MjQpLFxuICAgICAgICAgICAgICAgICAobG93ZXJXb3JkQmFzZU1lZGlhRGVjb2RlVGltZSA+PiAxNikgJiAwWEZGLFxuICAgICAgICAgICAgICAgICAobG93ZXJXb3JkQmFzZU1lZGlhRGVjb2RlVGltZSA+PiA4KSAmIDBYRkYsXG4gICAgICAgICAgICAgICAgIChsb3dlcldvcmRCYXNlTWVkaWFEZWNvZGVUaW1lICYgMHhGRilcbiAgICAgICAgICAgICAgIF0pKSxcbiAgICAgICAgICAgICAgIE1QNC50cnVuKHRyYWNrLFxuICAgICAgICAgICAgICAgICAgICBzYW1wbGVEZXBlbmRlbmN5VGFibGUubGVuZ3RoICtcbiAgICAgICAgICAgICAgICAgICAgMTYgKyAvLyB0ZmhkXG4gICAgICAgICAgICAgICAgICAgIDIwICsgLy8gdGZkdFxuICAgICAgICAgICAgICAgICAgICA4ICsgIC8vIHRyYWYgaGVhZGVyXG4gICAgICAgICAgICAgICAgICAgIDE2ICsgLy8gbWZoZFxuICAgICAgICAgICAgICAgICAgICA4ICsgIC8vIG1vb2YgaGVhZGVyXG4gICAgICAgICAgICAgICAgICAgIDgpLCAgLy8gbWRhdCBoZWFkZXJcbiAgICAgICAgICAgICAgIHNhbXBsZURlcGVuZGVuY3lUYWJsZSk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSB0cmFjayBib3guXG4gICAqIEBwYXJhbSB0cmFjayB7b2JqZWN0fSBhIHRyYWNrIGRlZmluaXRpb25cbiAgICogQHJldHVybiB7VWludDhBcnJheX0gdGhlIHRyYWNrIGJveFxuICAgKi9cbiAgc3RhdGljIHRyYWsodHJhY2spIHtcbiAgICB0cmFjay5kdXJhdGlvbiA9IHRyYWNrLmR1cmF0aW9uIHx8IDB4ZmZmZmZmZmY7XG4gICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLnRyYWssIE1QNC50a2hkKHRyYWNrKSwgTVA0Lm1kaWEodHJhY2spKTtcbiAgfVxuXG4gIHN0YXRpYyB0cmV4KHRyYWNrKSB7XG4gICAgdmFyIGlkID0gdHJhY2suaWQ7XG4gICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLnRyZXgsIG5ldyBVaW50OEFycmF5KFtcbiAgICAgIDB4MDAsIC8vIHZlcnNpb24gMFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gZmxhZ3NcbiAgICAgKGlkID4+IDI0KSxcbiAgICAgKGlkID4+IDE2KSAmIDBYRkYsXG4gICAgIChpZCA+PiA4KSAmIDBYRkYsXG4gICAgIChpZCAmIDB4RkYpLCAvLyB0cmFja19JRFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMSwgLy8gZGVmYXVsdF9zYW1wbGVfZGVzY3JpcHRpb25faW5kZXhcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGRlZmF1bHRfc2FtcGxlX2R1cmF0aW9uXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyBkZWZhdWx0X3NhbXBsZV9zaXplXG4gICAgICAweDAwLCAweDAxLCAweDAwLCAweDAxIC8vIGRlZmF1bHRfc2FtcGxlX2ZsYWdzXG4gICAgXSkpO1xuICB9XG5cbiAgc3RhdGljIHRydW4odHJhY2ssIG9mZnNldCkge1xuICAgIHZhciBzYW1wbGVzPSB0cmFjay5zYW1wbGVzIHx8IFtdLFxuICAgICAgICBsZW4gPSBzYW1wbGVzLmxlbmd0aCxcbiAgICAgICAgYXJyYXlsZW4gPSAxMiArICgxNiAqIGxlbiksXG4gICAgICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlsZW4pLFxuICAgICAgICBpLHNhbXBsZSxkdXJhdGlvbixzaXplLGZsYWdzLGN0cztcbiAgICBvZmZzZXQgKz0gOCArIGFycmF5bGVuO1xuICAgIGFycmF5LnNldChbXG4gICAgICAweDAwLCAvLyB2ZXJzaW9uIDBcbiAgICAgIDB4MDAsIDB4MGYsIDB4MDEsIC8vIGZsYWdzXG4gICAgICAobGVuID4+PiAyNCkgJiAweEZGLFxuICAgICAgKGxlbiA+Pj4gMTYpICYgMHhGRixcbiAgICAgIChsZW4gPj4+IDgpICYgMHhGRixcbiAgICAgIGxlbiAmIDB4RkYsIC8vIHNhbXBsZV9jb3VudFxuICAgICAgKG9mZnNldCA+Pj4gMjQpICYgMHhGRixcbiAgICAgIChvZmZzZXQgPj4+IDE2KSAmIDB4RkYsXG4gICAgICAob2Zmc2V0ID4+PiA4KSAmIDB4RkYsXG4gICAgICBvZmZzZXQgJiAweEZGIC8vIGRhdGFfb2Zmc2V0XG4gICAgXSwwKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHNhbXBsZSA9IHNhbXBsZXNbaV07XG4gICAgICBkdXJhdGlvbiA9IHNhbXBsZS5kdXJhdGlvbjtcbiAgICAgIHNpemUgPSBzYW1wbGUuc2l6ZTtcbiAgICAgIGZsYWdzID0gc2FtcGxlLmZsYWdzO1xuICAgICAgY3RzID0gc2FtcGxlLmN0cztcbiAgICAgIGFycmF5LnNldChbXG4gICAgICAgIChkdXJhdGlvbiA+Pj4gMjQpICYgMHhGRixcbiAgICAgICAgKGR1cmF0aW9uID4+PiAxNikgJiAweEZGLFxuICAgICAgICAoZHVyYXRpb24gPj4+IDgpICYgMHhGRixcbiAgICAgICAgZHVyYXRpb24gJiAweEZGLCAvLyBzYW1wbGVfZHVyYXRpb25cbiAgICAgICAgKHNpemUgPj4+IDI0KSAmIDB4RkYsXG4gICAgICAgIChzaXplID4+PiAxNikgJiAweEZGLFxuICAgICAgICAoc2l6ZSA+Pj4gOCkgJiAweEZGLFxuICAgICAgICBzaXplICYgMHhGRiwgLy8gc2FtcGxlX3NpemVcbiAgICAgICAgKGZsYWdzLmlzTGVhZGluZyA8PCAyKSB8IGZsYWdzLmRlcGVuZHNPbixcbiAgICAgICAgKGZsYWdzLmlzRGVwZW5kZWRPbiA8PCA2KSB8XG4gICAgICAgICAgKGZsYWdzLmhhc1JlZHVuZGFuY3kgPDwgNCkgfFxuICAgICAgICAgIChmbGFncy5wYWRkaW5nVmFsdWUgPDwgMSkgfFxuICAgICAgICAgIGZsYWdzLmlzTm9uU3luYyxcbiAgICAgICAgZmxhZ3MuZGVncmFkUHJpbyAmIDB4RjAgPDwgOCxcbiAgICAgICAgZmxhZ3MuZGVncmFkUHJpbyAmIDB4MEYsIC8vIHNhbXBsZV9mbGFnc1xuICAgICAgICAoY3RzID4+PiAyNCkgJiAweEZGLFxuICAgICAgICAoY3RzID4+PiAxNikgJiAweEZGLFxuICAgICAgICAoY3RzID4+PiA4KSAmIDB4RkYsXG4gICAgICAgIGN0cyAmIDB4RkYgLy8gc2FtcGxlX2NvbXBvc2l0aW9uX3RpbWVfb2Zmc2V0XG4gICAgICBdLDEyKzE2KmkpO1xuICAgIH1cbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMudHJ1biwgYXJyYXkpO1xuICB9XG5cbiAgc3RhdGljIGluaXRTZWdtZW50KHRyYWNrcykge1xuICAgIGlmICghTVA0LnR5cGVzKSB7XG4gICAgICBNUDQuaW5pdCgpO1xuICAgIH1cbiAgICB2YXIgbW92aWUgPSBNUDQubW9vdih0cmFja3MpLCByZXN1bHQ7XG4gICAgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoTVA0LkZUWVAuYnl0ZUxlbmd0aCArIG1vdmllLmJ5dGVMZW5ndGgpO1xuICAgIHJlc3VsdC5zZXQoTVA0LkZUWVApO1xuICAgIHJlc3VsdC5zZXQobW92aWUsIE1QNC5GVFlQLmJ5dGVMZW5ndGgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTVA0O1xuIiwiLyoqXG4gKiBmTVA0IHJlbXV4ZXJcbiovXG5cblxuaW1wb3J0IEFBQyBmcm9tICcuLi9oZWxwZXIvYWFjJztcbmltcG9ydCBFdmVudCBmcm9tICcuLi9ldmVudHMnO1xuaW1wb3J0IHtsb2dnZXJ9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XG5pbXBvcnQgTVA0IGZyb20gJy4uL3JlbXV4L21wNC1nZW5lcmF0b3InO1xuaW1wb3J0IHtFcnJvclR5cGVzLCBFcnJvckRldGFpbHN9IGZyb20gJy4uL2Vycm9ycyc7XG5cbmNsYXNzIE1QNFJlbXV4ZXIge1xuICBjb25zdHJ1Y3RvcihvYnNlcnZlciwgY29uZmlnLCB0eXBlU3VwcG9ydGVkLCB2ZW5kb3IpIHtcbiAgICB0aGlzLm9ic2VydmVyID0gb2JzZXJ2ZXI7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgdGhpcy50eXBlU3VwcG9ydGVkID0gdHlwZVN1cHBvcnRlZDtcbiAgICBjb25zdCB1c2VyQWdlbnQgPSBuYXZpZ2F0b3IudXNlckFnZW50O1xuICAgIHRoaXMuaXNTYWZhcmkgPSB2ZW5kb3IgJiYgdmVuZG9yLmluZGV4T2YoJ0FwcGxlJykgPiAtMSAmJiB1c2VyQWdlbnQgJiYgIXVzZXJBZ2VudC5tYXRjaCgnQ3JpT1MnKTtcbiAgICB0aGlzLklTR2VuZXJhdGVkID0gZmFsc2U7XG4gIH1cblxuICBkZXN0cm95KCkge1xuICB9XG5cbiAgcmVzZXRUaW1lU3RhbXAoZGVmYXVsdFRpbWVTdGFtcCkge1xuICAgIHRoaXMuX2luaXRQVFMgPSB0aGlzLl9pbml0RFRTID0gZGVmYXVsdFRpbWVTdGFtcDtcbiAgfVxuXG4gIHJlc2V0SW5pdFNlZ21lbnQoKSB7XG4gICAgdGhpcy5JU0dlbmVyYXRlZCA9IGZhbHNlO1xuICB9XG5cbiAgcmVtdXgoYXVkaW9UcmFjayx2aWRlb1RyYWNrLGlkM1RyYWNrLHRleHRUcmFjayx0aW1lT2Zmc2V0LCBjb250aWd1b3VzLGFjY3VyYXRlVGltZU9mZnNldCkge1xuICAgIC8vIGdlbmVyYXRlIEluaXQgU2VnbWVudCBpZiBuZWVkZWRcbiAgICBpZiAoIXRoaXMuSVNHZW5lcmF0ZWQpIHtcbiAgICAgIHRoaXMuZ2VuZXJhdGVJUyhhdWRpb1RyYWNrLHZpZGVvVHJhY2ssdGltZU9mZnNldCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuSVNHZW5lcmF0ZWQpIHtcbiAgICAgIC8vIFB1cnBvc2VmdWxseSByZW11eGluZyBhdWRpbyBiZWZvcmUgdmlkZW8sIHNvIHRoYXQgcmVtdXhWaWRlbyBjYW4gdXNlIG5leHRBdWRpb1B0cywgd2hpY2ggaXNcbiAgICAgIC8vIGNhbGN1bGF0ZWQgaW4gcmVtdXhBdWRpby5cbiAgICAgIC8vbG9nZ2VyLmxvZygnbmIgQUFDIHNhbXBsZXM6JyArIGF1ZGlvVHJhY2suc2FtcGxlcy5sZW5ndGgpO1xuICAgICAgaWYgKGF1ZGlvVHJhY2suc2FtcGxlcy5sZW5ndGgpIHtcbiAgICAgICAgbGV0IGF1ZGlvRGF0YSA9IHRoaXMucmVtdXhBdWRpbyhhdWRpb1RyYWNrLHRpbWVPZmZzZXQsY29udGlndW91cyxhY2N1cmF0ZVRpbWVPZmZzZXQpO1xuICAgICAgICAvL2xvZ2dlci5sb2coJ25iIEFWQyBzYW1wbGVzOicgKyB2aWRlb1RyYWNrLnNhbXBsZXMubGVuZ3RoKTtcbiAgICAgICAgaWYgKHZpZGVvVHJhY2suc2FtcGxlcy5sZW5ndGgpIHtcbiAgICAgICAgICBsZXQgYXVkaW9UcmFja0xlbmd0aDtcbiAgICAgICAgICBpZiAoYXVkaW9EYXRhKSB7XG4gICAgICAgICAgICBhdWRpb1RyYWNrTGVuZ3RoID0gYXVkaW9EYXRhLmVuZFBUUyAtIGF1ZGlvRGF0YS5zdGFydFBUUztcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5yZW11eFZpZGVvKHZpZGVvVHJhY2ssdGltZU9mZnNldCxjb250aWd1b3VzLGF1ZGlvVHJhY2tMZW5ndGgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgdmlkZW9EYXRhO1xuICAgICAgICAvL2xvZ2dlci5sb2coJ25iIEFWQyBzYW1wbGVzOicgKyB2aWRlb1RyYWNrLnNhbXBsZXMubGVuZ3RoKTtcbiAgICAgICAgaWYgKHZpZGVvVHJhY2suc2FtcGxlcy5sZW5ndGgpIHtcbiAgICAgICAgICB2aWRlb0RhdGEgPSB0aGlzLnJlbXV4VmlkZW8odmlkZW9UcmFjayx0aW1lT2Zmc2V0LGNvbnRpZ3VvdXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2aWRlb0RhdGEgJiYgYXVkaW9UcmFjay5jb2RlYykge1xuICAgICAgICAgIHRoaXMucmVtdXhFbXB0eUF1ZGlvKGF1ZGlvVHJhY2ssIHRpbWVPZmZzZXQsIGNvbnRpZ3VvdXMsIHZpZGVvRGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy9sb2dnZXIubG9nKCduYiBJRDMgc2FtcGxlczonICsgYXVkaW9UcmFjay5zYW1wbGVzLmxlbmd0aCk7XG4gICAgaWYgKGlkM1RyYWNrLnNhbXBsZXMubGVuZ3RoKSB7XG4gICAgICB0aGlzLnJlbXV4SUQzKGlkM1RyYWNrLHRpbWVPZmZzZXQpO1xuICAgIH1cbiAgICAvL2xvZ2dlci5sb2coJ25iIElEMyBzYW1wbGVzOicgKyBhdWRpb1RyYWNrLnNhbXBsZXMubGVuZ3RoKTtcbiAgICBpZiAodGV4dFRyYWNrLnNhbXBsZXMubGVuZ3RoKSB7XG4gICAgICB0aGlzLnJlbXV4VGV4dCh0ZXh0VHJhY2ssdGltZU9mZnNldCk7XG4gICAgfVxuICAgIC8vbm90aWZ5IGVuZCBvZiBwYXJzaW5nXG4gICAgdGhpcy5vYnNlcnZlci50cmlnZ2VyKEV2ZW50LkZSQUdfUEFSU0VEKTtcbiAgfVxuXG4gIGdlbmVyYXRlSVMoYXVkaW9UcmFjayx2aWRlb1RyYWNrLHRpbWVPZmZzZXQpIHtcbiAgICB2YXIgb2JzZXJ2ZXIgPSB0aGlzLm9ic2VydmVyLFxuICAgICAgICBhdWRpb1NhbXBsZXMgPSBhdWRpb1RyYWNrLnNhbXBsZXMsXG4gICAgICAgIHZpZGVvU2FtcGxlcyA9IHZpZGVvVHJhY2suc2FtcGxlcyxcbiAgICAgICAgdHlwZVN1cHBvcnRlZCA9IHRoaXMudHlwZVN1cHBvcnRlZCxcbiAgICAgICAgY29udGFpbmVyID0gJ2F1ZGlvL21wNCcsXG4gICAgICAgIHRyYWNrcyA9IHt9LFxuICAgICAgICBkYXRhID0geyB0cmFja3MgOiB0cmFja3MgfSxcbiAgICAgICAgY29tcHV0ZVBUU0RUUyA9ICh0aGlzLl9pbml0UFRTID09PSB1bmRlZmluZWQpLFxuICAgICAgICBpbml0UFRTLCBpbml0RFRTO1xuXG4gICAgaWYgKGNvbXB1dGVQVFNEVFMpIHtcbiAgICAgIGluaXRQVFMgPSBpbml0RFRTID0gSW5maW5pdHk7XG4gICAgfVxuICAgIGlmIChhdWRpb1RyYWNrLmNvbmZpZyAmJiBhdWRpb1NhbXBsZXMubGVuZ3RoKSB7XG4gICAgICAvLyBsZXQncyB1c2UgYXVkaW8gc2FtcGxpbmcgcmF0ZSBhcyBNUDQgdGltZSBzY2FsZS5cbiAgICAgIC8vIHJhdGlvbmFsZSBpcyB0aGF0IHRoZXJlIGlzIGEgaW50ZWdlciBuYiBvZiBhdWRpbyBmcmFtZXMgcGVyIGF1ZGlvIHNhbXBsZSAoMTAyNCBmb3IgQUFDKVxuICAgICAgLy8gdXNpbmcgYXVkaW8gc2FtcGxpbmcgcmF0ZSBoZXJlIGhlbHBzIGhhdmluZyBhbiBpbnRlZ2VyIE1QNCBmcmFtZSBkdXJhdGlvblxuICAgICAgLy8gdGhpcyBhdm9pZHMgcG90ZW50aWFsIHJvdW5kaW5nIGlzc3VlIGFuZCBBViBzeW5jIGlzc3VlXG4gICAgICBhdWRpb1RyYWNrLnRpbWVzY2FsZSA9IGF1ZGlvVHJhY2suc2FtcGxlcmF0ZTtcbiAgICAgIGxvZ2dlci5sb2cgKGBhdWRpbyBzYW1wbGluZyByYXRlIDogJHthdWRpb1RyYWNrLnNhbXBsZXJhdGV9YCk7XG4gICAgICBpZiAoIWF1ZGlvVHJhY2suaXNBQUMpIHtcbiAgICAgICAgaWYgKHR5cGVTdXBwb3J0ZWQubXBlZykgeyAvLyBDaHJvbWUgYW5kIFNhZmFyaVxuICAgICAgICAgIGNvbnRhaW5lciA9ICdhdWRpby9tcGVnJztcbiAgICAgICAgICBhdWRpb1RyYWNrLmNvZGVjID0gJyc7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZVN1cHBvcnRlZC5tcDMpIHsgLy8gRmlyZWZveFxuICAgICAgICAgIGF1ZGlvVHJhY2suY29kZWMgPSAnbXAzJztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdHJhY2tzLmF1ZGlvID0ge1xuICAgICAgICBjb250YWluZXIgOiBjb250YWluZXIsXG4gICAgICAgIGNvZGVjIDogIGF1ZGlvVHJhY2suY29kZWMsXG4gICAgICAgIGluaXRTZWdtZW50IDogIWF1ZGlvVHJhY2suaXNBQUMgJiYgdHlwZVN1cHBvcnRlZC5tcGVnID8gbmV3IFVpbnQ4QXJyYXkoKSA6IE1QNC5pbml0U2VnbWVudChbYXVkaW9UcmFja10pLFxuICAgICAgICBtZXRhZGF0YSA6IHtcbiAgICAgICAgICBjaGFubmVsQ291bnQgOiBhdWRpb1RyYWNrLmNoYW5uZWxDb3VudFxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgaWYgKGNvbXB1dGVQVFNEVFMpIHtcbiAgICAgICAgLy8gcmVtZW1iZXIgZmlyc3QgUFRTIG9mIHRoaXMgZGVtdXhpbmcgY29udGV4dC4gZm9yIGF1ZGlvLCBQVFMgPSBEVFNcbiAgICAgICAgaW5pdFBUUyA9IGluaXREVFMgPSBhdWRpb1NhbXBsZXNbMF0ucHRzIC0gYXVkaW9UcmFjay5pbnB1dFRpbWVTY2FsZSAqIHRpbWVPZmZzZXQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHZpZGVvVHJhY2suc3BzICYmIHZpZGVvVHJhY2sucHBzICYmIHZpZGVvU2FtcGxlcy5sZW5ndGgpIHtcbiAgICAgIC8vIGxldCdzIHVzZSBpbnB1dCB0aW1lIHNjYWxlIGFzIE1QNCB2aWRlbyB0aW1lc2NhbGVcbiAgICAgIC8vIHdlIHVzZSBpbnB1dCB0aW1lIHNjYWxlIHN0cmFpZ2h0IGF3YXkgdG8gYXZvaWQgcm91bmRpbmcgaXNzdWVzIG9uIGZyYW1lIGR1cmF0aW9uIC8gY3RzIGNvbXB1dGF0aW9uXG4gICAgICBjb25zdCBpbnB1dFRpbWVTY2FsZSA9IHZpZGVvVHJhY2suaW5wdXRUaW1lU2NhbGU7XG4gICAgICB2aWRlb1RyYWNrLnRpbWVzY2FsZSA9IGlucHV0VGltZVNjYWxlO1xuICAgICAgdHJhY2tzLnZpZGVvID0ge1xuICAgICAgICBjb250YWluZXIgOiAndmlkZW8vbXA0JyxcbiAgICAgICAgY29kZWMgOiAgdmlkZW9UcmFjay5jb2RlYyxcbiAgICAgICAgaW5pdFNlZ21lbnQgOiBNUDQuaW5pdFNlZ21lbnQoW3ZpZGVvVHJhY2tdKSxcbiAgICAgICAgbWV0YWRhdGEgOiB7XG4gICAgICAgICAgd2lkdGggOiB2aWRlb1RyYWNrLndpZHRoLFxuICAgICAgICAgIGhlaWdodCA6IHZpZGVvVHJhY2suaGVpZ2h0XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBpZiAoY29tcHV0ZVBUU0RUUykge1xuICAgICAgICBpbml0UFRTID0gTWF0aC5taW4oaW5pdFBUUyx2aWRlb1NhbXBsZXNbMF0ucHRzIC0gaW5wdXRUaW1lU2NhbGUgKiB0aW1lT2Zmc2V0KTtcbiAgICAgICAgaW5pdERUUyA9IE1hdGgubWluKGluaXREVFMsdmlkZW9TYW1wbGVzWzBdLmR0cyAtIGlucHV0VGltZVNjYWxlICogdGltZU9mZnNldCk7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXIudHJpZ2dlcihFdmVudC5JTklUX1BUU19GT1VORCwgeyBpbml0UFRTOiBpbml0UFRTfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYoT2JqZWN0LmtleXModHJhY2tzKS5sZW5ndGgpIHtcbiAgICAgIG9ic2VydmVyLnRyaWdnZXIoRXZlbnQuRlJBR19QQVJTSU5HX0lOSVRfU0VHTUVOVCxkYXRhKTtcbiAgICAgIHRoaXMuSVNHZW5lcmF0ZWQgPSB0cnVlO1xuICAgICAgaWYgKGNvbXB1dGVQVFNEVFMpIHtcbiAgICAgICAgdGhpcy5faW5pdFBUUyA9IGluaXRQVFM7XG4gICAgICAgIHRoaXMuX2luaXREVFMgPSBpbml0RFRTO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBvYnNlcnZlci50cmlnZ2VyKEV2ZW50LkVSUk9SLCB7dHlwZSA6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsIGRldGFpbHM6IEVycm9yRGV0YWlscy5GUkFHX1BBUlNJTkdfRVJST1IsIGZhdGFsOiBmYWxzZSwgcmVhc29uOiAnbm8gYXVkaW8vdmlkZW8gc2FtcGxlcyBmb3VuZCd9KTtcbiAgICB9XG4gIH1cblxuICByZW11eFZpZGVvKHRyYWNrLCB0aW1lT2Zmc2V0LCBjb250aWd1b3VzLCBhdWRpb1RyYWNrTGVuZ3RoKSB7XG4gICAgdmFyIG9mZnNldCA9IDgsXG4gICAgICAgIHRpbWVTY2FsZSA9IHRyYWNrLnRpbWVzY2FsZSxcbiAgICAgICAgbXA0U2FtcGxlRHVyYXRpb24sXG4gICAgICAgIG1kYXQsIG1vb2YsXG4gICAgICAgIGZpcnN0UFRTLCBmaXJzdERUUyxcbiAgICAgICAgbmV4dERUUyxcbiAgICAgICAgbGFzdFBUUywgbGFzdERUUyxcbiAgICAgICAgaW5wdXRTYW1wbGVzID0gdHJhY2suc2FtcGxlcyxcbiAgICAgICAgb3V0cHV0U2FtcGxlcyA9IFtdLFxuICAgICAgICBuYlNhbXBsZXMgPSBpbnB1dFNhbXBsZXMubGVuZ3RoLFxuICAgICAgICBwdHNOb3JtYWxpemUgPSB0aGlzLl9QVFNOb3JtYWxpemUsXG4gICAgICAgIGluaXREVFMgPSB0aGlzLl9pbml0RFRTO1xuXG4gIC8vIGZvciAobGV0IGkgPSAwOyBpIDwgdHJhY2suc2FtcGxlcy5sZW5ndGg7IGkrKykge1xuICAvLyAgIGxldCBhdmNTYW1wbGUgPSB0cmFjay5zYW1wbGVzW2ldO1xuICAvLyAgIGxldCB1bml0cyA9IGF2Y1NhbXBsZS51bml0cztcbiAgLy8gICBsZXQgdW5pdHNTdHJpbmcgPSAnJztcbiAgLy8gICBmb3IgKGxldCBqID0gMDsgaiA8IHVuaXRzLmxlbmd0aCA7IGorKykge1xuICAvLyAgICAgdW5pdHNTdHJpbmcgKz0gdW5pdHNbal0udHlwZSArICcsJztcbiAgLy8gICAgIGlmICh1bml0c1tqXS5kYXRhLmxlbmd0aCA8IDUwMCkge1xuICAvLyAgICAgICB1bml0c1N0cmluZyArPSBIZXguaGV4RHVtcCh1bml0c1tqXS5kYXRhKTtcbiAgLy8gICAgIH1cbiAgLy8gICB9XG4gIC8vICAgbG9nZ2VyLmxvZyhhdmNTYW1wbGUucHRzICsgJy8nICsgYXZjU2FtcGxlLmR0cyArICcsJyArIHVuaXRzU3RyaW5nICsgYXZjU2FtcGxlLnVuaXRzLmxlbmd0aCk7XG4gIC8vIH1cblxuICAgIC8vIHNvcnQgdmlkZW8gc2FtcGxlcyBieSBEVFMgdGhlbiBQVFMgdGhlbiBkZW11eCBpZCBvcmRlclxuICAgIGlucHV0U2FtcGxlcy5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgIGNvbnN0IGRlbHRhZHRzID0gYS5kdHMgLSBiLmR0cztcbiAgICAgIGNvbnN0IGRlbHRhcHRzID0gYS5wdHMgLSBiLnB0cztcbiAgICAgIHJldHVybiBkZWx0YWR0cyA/IGRlbHRhZHRzIDogZGVsdGFwdHMgPyBkZWx0YXB0cyA6IChhLmlkIC0gYi5pZCk7XG4gICAgfSk7XG5cbiAgICAvLyBoYW5kbGUgYnJva2VuIHN0cmVhbXMgd2l0aCBQVFMgPCBEVFMsIHRvbGVyYW5jZSB1cCAyMDBtcyAoMTgwMDAgaW4gOTBrSHogdGltZXNjYWxlKVxuICAgIGxldCBQVFNEVFNzaGlmdCA9IGlucHV0U2FtcGxlcy5yZWR1Y2UoIChwcmV2LCBjdXJyKSA9PiBNYXRoLm1heChNYXRoLm1pbihwcmV2LGN1cnIucHRzLWN1cnIuZHRzKSwtMTgwMDApLDApO1xuICAgIGlmIChQVFNEVFNzaGlmdCA8IDApIHtcbiAgICAgIGxvZ2dlci53YXJuKGBQVFMgPCBEVFMgZGV0ZWN0ZWQgaW4gdmlkZW8gc2FtcGxlcywgc2hpZnRpbmcgRFRTIGJ5ICR7TWF0aC5yb3VuZChQVFNEVFNzaGlmdC85MCl9IG1zIHRvIG92ZXJjb21lIHRoaXMgaXNzdWVgKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXRTYW1wbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlucHV0U2FtcGxlc1tpXS5kdHMgKz0gUFRTRFRTc2hpZnQ7XG4gICAgICB9XG4gICAgfVxuXG4gIC8vIFBUUyBpcyBjb2RlZCBvbiAzM2JpdHMsIGFuZCBjYW4gbG9vcCBmcm9tIC0yXjMyIHRvIDJeMzJcbiAgLy8gcHRzTm9ybWFsaXplIHdpbGwgbWFrZSBQVFMvRFRTIHZhbHVlIG1vbm90b25pYywgd2UgdXNlIGxhc3Qga25vd24gRFRTIHZhbHVlIGFzIHJlZmVyZW5jZSB2YWx1ZVxuICAgbGV0IG5leHRBdmNEdHM7XG4gICAvLyBjb250aWd1b3VzIGZyYWdtZW50cyBhcmUgY29uc2VjdXRpdmUgZnJhZ21lbnRzIGZyb20gc2FtZSBxdWFsaXR5IGxldmVsIChzYW1lIGxldmVsLCBuZXcgU04gPSBvbGQgU04gKyAxKVxuICAgIGlmIChjb250aWd1b3VzKSB7XG4gICAgICAvLyBpZiBwYXJzZWQgZnJhZ21lbnQgaXMgY29udGlndW91cyB3aXRoIGxhc3Qgb25lLCBsZXQncyB1c2UgbGFzdCBEVFMgdmFsdWUgYXMgcmVmZXJlbmNlXG4gICAgICBuZXh0QXZjRHRzID0gdGhpcy5uZXh0QXZjRHRzO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBpZiBub3QgY29udGlndW91cywgbGV0J3MgdXNlIHRhcmdldCB0aW1lT2Zmc2V0XG4gICAgICBuZXh0QXZjRHRzID0gdGltZU9mZnNldCp0aW1lU2NhbGU7XG4gICAgfVxuXG4gICAgLy8gY29tcHV0ZSBmaXJzdCBEVFMgYW5kIGxhc3QgRFRTLCBub3JtYWxpemUgdGhlbSBhZ2FpbnN0IHJlZmVyZW5jZSB2YWx1ZVxuICAgIGxldCBzYW1wbGUgPSBpbnB1dFNhbXBsZXNbMF07XG4gICAgZmlyc3REVFMgPSAgTWF0aC5tYXgocHRzTm9ybWFsaXplKHNhbXBsZS5kdHMgLSBpbml0RFRTLG5leHRBdmNEdHMpLDApO1xuICAgIGZpcnN0UFRTID0gIE1hdGgubWF4KHB0c05vcm1hbGl6ZShzYW1wbGUucHRzIC0gaW5pdERUUyxuZXh0QXZjRHRzKSwwKTtcblxuICAgIC8vIGNoZWNrIHRpbWVzdGFtcCBjb250aW51aXR5IGFjY3Jvc3MgY29uc2VjdXRpdmUgZnJhZ21lbnRzICh0aGlzIGlzIHRvIHJlbW92ZSBpbnRlci1mcmFnbWVudCBnYXAvaG9sZSlcbiAgICBsZXQgZGVsdGEgPSBNYXRoLnJvdW5kKChmaXJzdERUUyAtIG5leHRBdmNEdHMpIC8gOTApO1xuICAgIC8vIGlmIGZyYWdtZW50IGFyZSBjb250aWd1b3VzLCBkZXRlY3QgaG9sZS9vdmVybGFwcGluZyBiZXR3ZWVuIGZyYWdtZW50c1xuICAgIGlmIChjb250aWd1b3VzKSB7XG4gICAgICBpZiAoZGVsdGEpIHtcbiAgICAgICAgaWYgKGRlbHRhID4gMSkge1xuICAgICAgICAgIGxvZ2dlci5sb2coYEFWQzoke2RlbHRhfSBtcyBob2xlIGJldHdlZW4gZnJhZ21lbnRzIGRldGVjdGVkLGZpbGxpbmcgaXRgKTtcbiAgICAgICAgfSBlbHNlIGlmIChkZWx0YSA8IC0xKSB7XG4gICAgICAgICAgbG9nZ2VyLmxvZyhgQVZDOiR7KC1kZWx0YSl9IG1zIG92ZXJsYXBwaW5nIGJldHdlZW4gZnJhZ21lbnRzIGRldGVjdGVkYCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVtb3ZlIGhvbGUvZ2FwIDogc2V0IERUUyB0byBuZXh0IGV4cGVjdGVkIERUU1xuICAgICAgICBmaXJzdERUUyA9IG5leHRBdmNEdHM7XG4gICAgICAgIGlucHV0U2FtcGxlc1swXS5kdHMgPSBmaXJzdERUUyArIGluaXREVFM7XG4gICAgICAgIC8vIG9mZnNldCBQVFMgYXMgd2VsbCwgZW5zdXJlIHRoYXQgUFRTIGlzIHNtYWxsZXIgb3IgZXF1YWwgdGhhbiBuZXcgRFRTXG4gICAgICAgIGZpcnN0UFRTID0gTWF0aC5tYXgoZmlyc3RQVFMgLSBkZWx0YSwgbmV4dEF2Y0R0cyk7XG4gICAgICAgIGlucHV0U2FtcGxlc1swXS5wdHMgPSBmaXJzdFBUUyArIGluaXREVFM7XG4gICAgICAgIGxvZ2dlci5sb2coYFZpZGVvL1BUUy9EVFMgYWRqdXN0ZWQ6ICR7TWF0aC5yb3VuZChmaXJzdFBUUy85MCl9LyR7TWF0aC5yb3VuZChmaXJzdERUUy85MCl9LGRlbHRhOiR7ZGVsdGF9IG1zYCk7XG4gICAgICB9XG4gICAgfVxuICAgIG5leHREVFMgPSBmaXJzdERUUztcblxuICAgIC8vIGNvbXB1dGUgbGFzdFBUUy9sYXN0RFRTXG4gICAgc2FtcGxlID0gaW5wdXRTYW1wbGVzW2lucHV0U2FtcGxlcy5sZW5ndGgtMV07XG4gICAgbGFzdERUUyA9IE1hdGgubWF4KHB0c05vcm1hbGl6ZShzYW1wbGUuZHRzIC0gaW5pdERUUyxuZXh0QXZjRHRzKSAsMCk7XG4gICAgbGFzdFBUUyA9IE1hdGgubWF4KHB0c05vcm1hbGl6ZShzYW1wbGUucHRzIC0gaW5pdERUUyxuZXh0QXZjRHRzKSAsMCk7XG4gICAgbGFzdFBUUyA9IE1hdGgubWF4KGxhc3RQVFMsIGxhc3REVFMpO1xuXG4gICAgY29uc3QgaXNTYWZhcmkgPSB0aGlzLmlzU2FmYXJpO1xuICAgICAgLy8gb24gU2FmYXJpIGxldCdzIHNpZ25hbCB0aGUgc2FtZSBzYW1wbGUgZHVyYXRpb24gZm9yIGFsbCBzYW1wbGVzXG4gICAgICAvLyBzYW1wbGUgZHVyYXRpb24gKGFzIGV4cGVjdGVkIGJ5IHRydW4gTVA0IGJveGVzKSwgc2hvdWxkIGJlIHRoZSBkZWx0YSBiZXR3ZWVuIHNhbXBsZSBEVFNcbiAgICAgIC8vIHNldCB0aGlzIGNvbnN0YW50IGR1cmF0aW9uIGFzIGJlaW5nIHRoZSBhdmcgZGVsdGEgYmV0d2VlbiBjb25zZWN1dGl2ZSBEVFMuXG4gICAgaWYgKGlzU2FmYXJpKSB7XG4gICAgICBtcDRTYW1wbGVEdXJhdGlvbiA9IE1hdGgucm91bmQoKGxhc3REVFMtZmlyc3REVFMpLyhpbnB1dFNhbXBsZXMubGVuZ3RoLTEpKTtcbiAgICB9XG5cbiAgICBsZXQgbmJOYWx1ID0gMCwgbmFsdUxlbiA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDAgOyBpIDwgbmJTYW1wbGVzOyBpKyspIHtcbiAgICAgIC8vIGNvbXB1dGUgdG90YWwvYXZjIHNhbXBsZSBsZW5ndGggYW5kIG5iIG9mIE5BTCB1bml0c1xuICAgICAgbGV0IHNhbXBsZSA9IGlucHV0U2FtcGxlc1tpXSwgdW5pdHMgPSBzYW1wbGUudW5pdHMsIG5iVW5pdHMgPSB1bml0cy5sZW5ndGgsIHNhbXBsZUxlbiA9IDA7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG5iVW5pdHM7IGorKykge1xuICAgICAgICBzYW1wbGVMZW4gKz0gdW5pdHNbal0uZGF0YS5sZW5ndGg7XG4gICAgICB9XG4gICAgICBuYWx1TGVuICs9IHNhbXBsZUxlbjtcbiAgICAgIG5iTmFsdSArPSBuYlVuaXRzO1xuICAgICAgc2FtcGxlLmxlbmd0aCA9IHNhbXBsZUxlbjtcblxuICAgICAgLy8gbm9ybWFsaXplIFBUUy9EVFNcbiAgICAgIGlmIChpc1NhZmFyaSkge1xuICAgICAgICAvLyBzYW1wbGUgRFRTIGlzIGNvbXB1dGVkIHVzaW5nIGEgY29uc3RhbnQgZGVjb2Rpbmcgb2Zmc2V0IChtcDRTYW1wbGVEdXJhdGlvbikgYmV0d2VlbiBzYW1wbGVzXG4gICAgICAgIHNhbXBsZS5kdHMgPSBmaXJzdERUUyArIGkqbXA0U2FtcGxlRHVyYXRpb247XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBlbnN1cmUgc2FtcGxlIG1vbm90b25pYyBEVFNcbiAgICAgICAgc2FtcGxlLmR0cyA9IE1hdGgubWF4KHB0c05vcm1hbGl6ZShzYW1wbGUuZHRzIC0gaW5pdERUUywgbmV4dEF2Y0R0cyksZmlyc3REVFMpO1xuICAgICAgfVxuICAgICAgLy8gd2Ugbm9ybWFsaXplIFBUUyBhZ2FpbnN0IG5leHRBdmNEdHMsIHdlIGFsc28gc3Vic3RyYWN0IGluaXREVFMgKHNvbWUgc3RyZWFtcyBkb24ndCBzdGFydCBAIFBUUyBPKVxuICAgICAgLy8gYW5kIHdlIGVuc3VyZSB0aGF0IGNvbXB1dGVkIHZhbHVlIGlzIGdyZWF0ZXIgb3IgZXF1YWwgdGhhbiBzYW1wbGUgRFRTXG4gICAgICBzYW1wbGUucHRzID0gTWF0aC5tYXgocHRzTm9ybWFsaXplKHNhbXBsZS5wdHMgLSBpbml0RFRTLG5leHRBdmNEdHMpICwgc2FtcGxlLmR0cyk7XG4gICAgfVxuXG4gICAgLyogY29uY2F0ZW5hdGUgdGhlIHZpZGVvIGRhdGEgYW5kIGNvbnN0cnVjdCB0aGUgbWRhdCBpbiBwbGFjZVxuICAgICAgKG5lZWQgOCBtb3JlIGJ5dGVzIHRvIGZpbGwgbGVuZ3RoIGFuZCBtcGRhdCB0eXBlKSAqL1xuICAgIGxldCBtZGF0U2l6ZSA9IG5hbHVMZW4gKyAoNCAqIG5iTmFsdSkgKyA4O1xuICAgIHRyeSB7XG4gICAgICBtZGF0ID0gbmV3IFVpbnQ4QXJyYXkobWRhdFNpemUpO1xuICAgIH0gY2F0Y2goZXJyKSB7XG4gICAgICB0aGlzLm9ic2VydmVyLnRyaWdnZXIoRXZlbnQuRVJST1IsIHt0eXBlIDogRXJyb3JUeXBlcy5NVVhfRVJST1IsIGRldGFpbHM6IEVycm9yRGV0YWlscy5SRU1VWF9BTExPQ19FUlJPUiwgZmF0YWw6IGZhbHNlLCBieXRlcyA6IG1kYXRTaXplLCByZWFzb246IGBmYWlsIGFsbG9jYXRpbmcgdmlkZW8gbWRhdCAke21kYXRTaXplfWB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IHZpZXcgPSBuZXcgRGF0YVZpZXcobWRhdC5idWZmZXIpO1xuICAgIHZpZXcuc2V0VWludDMyKDAsIG1kYXRTaXplKTtcbiAgICBtZGF0LnNldChNUDQudHlwZXMubWRhdCwgNCk7XG5cbiAgICBmb3IgKGxldCBpID0gMCA7IGkgPCBuYlNhbXBsZXM7IGkrKykge1xuICAgICAgbGV0IGF2Y1NhbXBsZSA9IGlucHV0U2FtcGxlc1tpXSxcbiAgICAgICAgICBhdmNTYW1wbGVVbml0cyA9IGF2Y1NhbXBsZS51bml0cyxcbiAgICAgICAgICBtcDRTYW1wbGVMZW5ndGggPSAwLFxuICAgICAgICAgIGNvbXBvc2l0aW9uVGltZU9mZnNldDtcbiAgICAgIC8vIGNvbnZlcnQgTkFMVSBiaXRzdHJlYW0gdG8gTVA0IGZvcm1hdCAocHJlcGVuZCBOQUxVIHdpdGggc2l6ZSBmaWVsZClcbiAgICAgIGZvcihsZXQgaiA9IDAsIG5iVW5pdHMgPSBhdmNTYW1wbGVVbml0cy5sZW5ndGg7IGogPCBuYlVuaXRzIDsgaisrKSB7XG4gICAgICAgIGxldCB1bml0ID0gYXZjU2FtcGxlVW5pdHNbal0sXG4gICAgICAgICAgICB1bml0RGF0YSA9IHVuaXQuZGF0YSxcbiAgICAgICAgICAgIHVuaXREYXRhTGVuID0gdW5pdC5kYXRhLmJ5dGVMZW5ndGg7XG4gICAgICAgIHZpZXcuc2V0VWludDMyKG9mZnNldCwgdW5pdERhdGFMZW4pO1xuICAgICAgICBvZmZzZXQgKz0gNDtcbiAgICAgICAgbWRhdC5zZXQodW5pdERhdGEsIG9mZnNldCk7XG4gICAgICAgIG9mZnNldCArPSB1bml0RGF0YUxlbjtcbiAgICAgICAgbXA0U2FtcGxlTGVuZ3RoICs9IDQgKyB1bml0RGF0YUxlbjtcbiAgICAgIH1cblxuICAgICAgaWYoIWlzU2FmYXJpKSB7XG4gICAgICAgIC8vIGV4cGVjdGVkIHNhbXBsZSBkdXJhdGlvbiBpcyB0aGUgRGVjb2RpbmcgVGltZXN0YW1wIGRpZmYgb2YgY29uc2VjdXRpdmUgc2FtcGxlc1xuICAgICAgICBpZiAoaSA8IG5iU2FtcGxlcyAtIDEpIHtcbiAgICAgICAgICBtcDRTYW1wbGVEdXJhdGlvbiA9IGlucHV0U2FtcGxlc1tpKzFdLmR0cyAtIGF2Y1NhbXBsZS5kdHM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGV0IGNvbmZpZyA9IHRoaXMuY29uZmlnLFxuICAgICAgICAgICAgICBsYXN0RnJhbWVEdXJhdGlvbiA9IGF2Y1NhbXBsZS5kdHMgLSBpbnB1dFNhbXBsZXNbaSA+IDAgPyBpLTEgOiBpXS5kdHM7XG4gICAgICAgICAgaWYgKGNvbmZpZy5zdHJldGNoU2hvcnRWaWRlb1RyYWNrKSB7XG4gICAgICAgICAgICAvLyBJbiBzb21lIGNhc2VzLCBhIHNlZ21lbnQncyBhdWRpbyB0cmFjayBkdXJhdGlvbiBtYXkgZXhjZWVkIHRoZSB2aWRlbyB0cmFjayBkdXJhdGlvbi5cbiAgICAgICAgICAgIC8vIFNpbmNlIHdlJ3ZlIGFscmVhZHkgcmVtdXhlZCBhdWRpbywgYW5kIHdlIGtub3cgaG93IGxvbmcgdGhlIGF1ZGlvIHRyYWNrIGlzLCB3ZSBsb29rIHRvXG4gICAgICAgICAgICAvLyBzZWUgaWYgdGhlIGRlbHRhIHRvIHRoZSBuZXh0IHNlZ21lbnQgaXMgbG9uZ2VyIHRoYW4gdGhlIG1pbmltdW0gb2YgbWF4QnVmZmVySG9sZSBhbmRcbiAgICAgICAgICAgIC8vIG1heFNlZWtIb2xlLiBJZiBzbywgcGxheWJhY2sgd291bGQgcG90ZW50aWFsbHkgZ2V0IHN0dWNrLCBzbyB3ZSBhcnRpZmljaWFsbHkgaW5mbGF0ZVxuICAgICAgICAgICAgLy8gdGhlIGR1cmF0aW9uIG9mIHRoZSBsYXN0IGZyYW1lIHRvIG1pbmltaXplIGFueSBwb3RlbnRpYWwgZ2FwIGJldHdlZW4gc2VnbWVudHMuXG4gICAgICAgICAgICBsZXQgbWF4QnVmZmVySG9sZSA9IGNvbmZpZy5tYXhCdWZmZXJIb2xlLFxuICAgICAgICAgICAgICAgIG1heFNlZWtIb2xlID0gY29uZmlnLm1heFNlZWtIb2xlLFxuICAgICAgICAgICAgICAgIGdhcFRvbGVyYW5jZSA9IE1hdGguZmxvb3IoTWF0aC5taW4obWF4QnVmZmVySG9sZSwgbWF4U2Vla0hvbGUpICogdGltZVNjYWxlKSxcbiAgICAgICAgICAgICAgICBkZWx0YVRvRnJhbWVFbmQgPSAoYXVkaW9UcmFja0xlbmd0aCA/IGZpcnN0UFRTICsgYXVkaW9UcmFja0xlbmd0aCAqIHRpbWVTY2FsZSA6IHRoaXMubmV4dEF1ZGlvUHRzKSAtIGF2Y1NhbXBsZS5wdHM7XG4gICAgICAgICAgICBpZiAoZGVsdGFUb0ZyYW1lRW5kID4gZ2FwVG9sZXJhbmNlKSB7XG4gICAgICAgICAgICAgIC8vIFdlIHN1YnRyYWN0IGxhc3RGcmFtZUR1cmF0aW9uIGZyb20gZGVsdGFUb0ZyYW1lRW5kIHRvIHRyeSB0byBwcmV2ZW50IGFueSB2aWRlb1xuICAgICAgICAgICAgICAvLyBmcmFtZSBvdmVybGFwLiBtYXhCdWZmZXJIb2xlL21heFNlZWtIb2xlIHNob3VsZCBiZSA+PiBsYXN0RnJhbWVEdXJhdGlvbiBhbnl3YXkuXG4gICAgICAgICAgICAgIG1wNFNhbXBsZUR1cmF0aW9uID0gZGVsdGFUb0ZyYW1lRW5kIC0gbGFzdEZyYW1lRHVyYXRpb247XG4gICAgICAgICAgICAgIGlmIChtcDRTYW1wbGVEdXJhdGlvbiA8IDApIHtcbiAgICAgICAgICAgICAgICBtcDRTYW1wbGVEdXJhdGlvbiA9IGxhc3RGcmFtZUR1cmF0aW9uO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGxvZ2dlci5sb2coYEl0IGlzIGFwcHJveGltYXRlbHkgJHtkZWx0YVRvRnJhbWVFbmQvOTB9IG1zIHRvIHRoZSBuZXh0IHNlZ21lbnQ7IHVzaW5nIGR1cmF0aW9uICR7bXA0U2FtcGxlRHVyYXRpb24vOTB9IG1zIGZvciB0aGUgbGFzdCB2aWRlbyBmcmFtZS5gKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG1wNFNhbXBsZUR1cmF0aW9uID0gbGFzdEZyYW1lRHVyYXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1wNFNhbXBsZUR1cmF0aW9uID0gbGFzdEZyYW1lRHVyYXRpb247XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbXBvc2l0aW9uVGltZU9mZnNldCA9IE1hdGgucm91bmQoYXZjU2FtcGxlLnB0cyAtIGF2Y1NhbXBsZS5kdHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29tcG9zaXRpb25UaW1lT2Zmc2V0ID0gTWF0aC5tYXgoMCxtcDRTYW1wbGVEdXJhdGlvbipNYXRoLnJvdW5kKChhdmNTYW1wbGUucHRzIC0gYXZjU2FtcGxlLmR0cykvbXA0U2FtcGxlRHVyYXRpb24pKTtcbiAgICAgIH1cblxuXG4gICAgICAvL2NvbnNvbGUubG9nKCdQVFMvRFRTL2luaXREVFMvbm9ybVBUUy9ub3JtRFRTL3JlbGF0aXZlIFBUUyA6ICR7YXZjU2FtcGxlLnB0c30vJHthdmNTYW1wbGUuZHRzfS8ke2luaXREVFN9LyR7cHRzbm9ybX0vJHtkdHNub3JtfS8keyhhdmNTYW1wbGUucHRzLzQyOTQ5NjcyOTYpLnRvRml4ZWQoMyl9Jyk7XG4gICAgICBvdXRwdXRTYW1wbGVzLnB1c2goe1xuICAgICAgICBzaXplOiBtcDRTYW1wbGVMZW5ndGgsXG4gICAgICAgICAvLyBjb25zdGFudCBkdXJhdGlvblxuICAgICAgICBkdXJhdGlvbjogbXA0U2FtcGxlRHVyYXRpb24sXG4gICAgICAgIGN0czogY29tcG9zaXRpb25UaW1lT2Zmc2V0LFxuICAgICAgICBmbGFnczoge1xuICAgICAgICAgIGlzTGVhZGluZzogMCxcbiAgICAgICAgICBpc0RlcGVuZGVkT246IDAsXG4gICAgICAgICAgaGFzUmVkdW5kYW5jeTogMCxcbiAgICAgICAgICBkZWdyYWRQcmlvOiAwLFxuICAgICAgICAgIGRlcGVuZHNPbiA6IGF2Y1NhbXBsZS5rZXkgPyAyIDogMSxcbiAgICAgICAgICBpc05vblN5bmMgOiBhdmNTYW1wbGUua2V5ID8gMCA6IDFcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIC8vIG5leHQgQVZDIHNhbXBsZSBEVFMgc2hvdWxkIGJlIGVxdWFsIHRvIGxhc3Qgc2FtcGxlIERUUyArIGxhc3Qgc2FtcGxlIGR1cmF0aW9uIChpbiBQRVMgdGltZXNjYWxlKVxuICAgIHRoaXMubmV4dEF2Y0R0cyA9IGxhc3REVFMgKyBtcDRTYW1wbGVEdXJhdGlvbjtcbiAgICBsZXQgZHJvcHBlZCA9IHRyYWNrLmRyb3BwZWQ7XG4gICAgdHJhY2subGVuID0gMDtcbiAgICB0cmFjay5uYk5hbHUgPSAwO1xuICAgIHRyYWNrLmRyb3BwZWQgPSAwO1xuICAgIGlmKG91dHB1dFNhbXBsZXMubGVuZ3RoICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5pbmRleE9mKCdjaHJvbWUnKSA+IC0xKSB7XG4gICAgICBsZXQgZmxhZ3MgPSBvdXRwdXRTYW1wbGVzWzBdLmZsYWdzO1xuICAgIC8vIGNocm9tZSB3b3JrYXJvdW5kLCBtYXJrIGZpcnN0IHNhbXBsZSBhcyBiZWluZyBhIFJhbmRvbSBBY2Nlc3MgUG9pbnQgdG8gYXZvaWQgc291cmNlYnVmZmVyIGFwcGVuZCBpc3N1ZVxuICAgIC8vIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0yMjk0MTJcbiAgICAgIGZsYWdzLmRlcGVuZHNPbiA9IDI7XG4gICAgICBmbGFncy5pc05vblN5bmMgPSAwO1xuICAgIH1cbiAgICB0cmFjay5zYW1wbGVzID0gb3V0cHV0U2FtcGxlcztcbiAgICBtb29mID0gTVA0Lm1vb2YodHJhY2suc2VxdWVuY2VOdW1iZXIrKywgZmlyc3REVFMgLCB0cmFjayk7XG4gICAgdHJhY2suc2FtcGxlcyA9IFtdO1xuXG4gICAgbGV0IGRhdGEgPSB7XG4gICAgICBkYXRhMTogbW9vZixcbiAgICAgIGRhdGEyOiBtZGF0LFxuICAgICAgc3RhcnRQVFM6IGZpcnN0UFRTIC8gdGltZVNjYWxlLFxuICAgICAgZW5kUFRTOiAobGFzdFBUUyArICBtcDRTYW1wbGVEdXJhdGlvbikgLyB0aW1lU2NhbGUsXG4gICAgICBzdGFydERUUzogZmlyc3REVFMgLyB0aW1lU2NhbGUsXG4gICAgICBlbmREVFM6IHRoaXMubmV4dEF2Y0R0cyAvIHRpbWVTY2FsZSxcbiAgICAgIHR5cGU6ICd2aWRlbycsXG4gICAgICBuYjogb3V0cHV0U2FtcGxlcy5sZW5ndGgsXG4gICAgICBkcm9wcGVkIDogZHJvcHBlZFxuICAgIH07XG4gICAgdGhpcy5vYnNlcnZlci50cmlnZ2VyKEV2ZW50LkZSQUdfUEFSU0lOR19EQVRBLCBkYXRhKTtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIHJlbXV4QXVkaW8odHJhY2ssIHRpbWVPZmZzZXQsIGNvbnRpZ3VvdXMsYWNjdXJhdGVUaW1lT2Zmc2V0KSB7XG4gICAgY29uc3QgaW5wdXRUaW1lU2NhbGUgPSB0cmFjay5pbnB1dFRpbWVTY2FsZSxcbiAgICAgICAgICBtcDR0aW1lU2NhbGUgPSB0cmFjay50aW1lc2NhbGUsXG4gICAgICAgICAgc2NhbGVGYWN0b3IgPSBpbnB1dFRpbWVTY2FsZS9tcDR0aW1lU2NhbGUsXG4gICAgICAgICAgbXA0U2FtcGxlRHVyYXRpb24gPSB0cmFjay5pc0FBQyA/IDEwMjQgOiAxMTUyLFxuICAgICAgICAgIGlucHV0U2FtcGxlRHVyYXRpb24gPSBtcDRTYW1wbGVEdXJhdGlvbiAqIHNjYWxlRmFjdG9yLFxuICAgICAgICAgIHB0c05vcm1hbGl6ZSA9IHRoaXMuX1BUU05vcm1hbGl6ZSxcbiAgICAgICAgICBpbml0RFRTID0gdGhpcy5faW5pdERUUyxcbiAgICAgICAgICByYXdNUEVHID0gIXRyYWNrLmlzQUFDICYmIHRoaXMudHlwZVN1cHBvcnRlZC5tcGVnO1xuXG4gICAgdmFyIHZpZXcsXG4gICAgICAgIG9mZnNldCA9IHJhd01QRUcgPyAwIDogOCxcbiAgICAgICAgYXVkaW9TYW1wbGUsIG1wNFNhbXBsZSxcbiAgICAgICAgdW5pdCxcbiAgICAgICAgbWRhdCwgbW9vZixcbiAgICAgICAgZmlyc3RQVFMsIGZpcnN0RFRTLCBsYXN0RFRTLFxuICAgICAgICBwdHMsIGR0cywgcHRzbm9ybSwgZHRzbm9ybSxcbiAgICAgICAgb3V0cHV0U2FtcGxlcyA9IFtdLFxuICAgICAgICBpbnB1dFNhbXBsZXMgPSBbXSxcbiAgICAgICAgZmlsbEZyYW1lLCBuZXdTdGFtcCxcbiAgICAgICAgbmV4dEF1ZGlvUHRzO1xuXG4gICAgdHJhY2suc2FtcGxlcy5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgIHJldHVybiAoYS5wdHMtYi5wdHMpO1xuICAgIH0pO1xuICAgIGlucHV0U2FtcGxlcyA9IHRyYWNrLnNhbXBsZXM7XG5cbiAgICAvLyBmb3IgYXVkaW8gc2FtcGxlcywgYWxzbyBjb25zaWRlciBjb25zZWN1dGl2ZSBmcmFnbWVudHMgYXMgYmVpbmcgY29udGlndW91cyAoZXZlbiBpZiBhIGxldmVsIHN3aXRjaCBvY2N1cnMpLFxuICAgIC8vIGZvciBzYWtlIG9mIGNsYXJpdHk6XG4gICAgLy8gY29uc2VjdXRpdmUgZnJhZ21lbnRzIGFyZSBmcmFncyB3aXRoXG4gICAgLy8gIC0gbGVzcyB0aGFuIDEwMG1zIGdhcHMgYmV0d2VlbiBuZXcgdGltZSBvZmZzZXQgYW5kIG5leHQgZXhwZWN0ZWQgUFRTIE9SXG4gICAgLy8gIC0gbGVzcyB0aGFuIDIwIGF1ZGlvIGZyYW1lcyBkaXN0YW5jZVxuICAgIC8vIGNvbnRpZ3VvdXMgZnJhZ21lbnRzIGFyZSBjb25zZWN1dGl2ZSBmcmFnbWVudHMgZnJvbSBzYW1lIHF1YWxpdHkgbGV2ZWwgKHNhbWUgbGV2ZWwsIG5ldyBTTiA9IG9sZCBTTiArIDEpXG4gICAgLy8gdGhpcyBoZWxwcyBlbnN1cmluZyBhdWRpbyBjb250aW51aXR5XG4gICAgLy8gYW5kIHRoaXMgYWxzbyBhdm9pZHMgYXVkaW8gZ2xpdGNoZXMvY3V0IHdoZW4gc3dpdGNoaW5nIHF1YWxpdHksIG9yIHJlcG9ydGluZyB3cm9uZyBkdXJhdGlvbiBvbiBmaXJzdCBhdWRpbyBmcmFtZVxuXG4gICAgbmV4dEF1ZGlvUHRzID0gdGhpcy5uZXh0QXVkaW9QdHM7XG4gICAgY29udGlndW91cyB8PSAoaW5wdXRTYW1wbGVzLmxlbmd0aCAmJiBuZXh0QXVkaW9QdHMgJiZcbiAgICAgICAgICAgICAgICAgICAoTWF0aC5hYnModGltZU9mZnNldC1uZXh0QXVkaW9QdHMvaW5wdXRUaW1lU2NhbGUpIDwgMC4xIHx8XG4gICAgICAgICAgICAgICAgICAgIE1hdGguYWJzKChpbnB1dFNhbXBsZXNbMF0ucHRzLW5leHRBdWRpb1B0cy1pbml0RFRTKSkgPCAyMCppbnB1dFNhbXBsZUR1cmF0aW9uKVxuICAgICAgICAgICAgICAgICAgICApO1xuXG4gICAgaWYgKCFjb250aWd1b3VzKSB7XG4gICAgICAvLyBpZiBmcmFnbWVudHMgYXJlIG5vdCBjb250aWd1b3VzLCBsZXQncyB1c2UgdGltZU9mZnNldCB0byBjb21wdXRlIG5leHQgQXVkaW8gUFRTXG4gICAgICBuZXh0QXVkaW9QdHMgPSB0aW1lT2Zmc2V0KmlucHV0VGltZVNjYWxlO1xuICAgIH1cbiAgICAvLyBJZiB0aGUgYXVkaW8gdHJhY2sgaXMgbWlzc2luZyBzYW1wbGVzLCB0aGUgZnJhbWVzIHNlZW0gdG8gZ2V0IFwibGVmdC1zaGlmdGVkXCIgd2l0aGluIHRoZVxuICAgIC8vIHJlc3VsdGluZyBtcDQgc2VnbWVudCwgY2F1c2luZyBzeW5jIGlzc3VlcyBhbmQgbGVhdmluZyBnYXBzIGF0IHRoZSBlbmQgb2YgdGhlIGF1ZGlvIHNlZ21lbnQuXG4gICAgLy8gSW4gYW4gZWZmb3J0IHRvIHByZXZlbnQgdGhpcyBmcm9tIGhhcHBlbmluZywgd2UgaW5qZWN0IGZyYW1lcyBoZXJlIHdoZXJlIHRoZXJlIGFyZSBnYXBzLlxuICAgIC8vIFdoZW4gcG9zc2libGUsIHdlIGluamVjdCBhIHNpbGVudCBmcmFtZTsgd2hlbiB0aGF0J3Mgbm90IHBvc3NpYmxlLCB3ZSBkdXBsaWNhdGUgdGhlIGxhc3RcbiAgICAvLyBmcmFtZS5cblxuICAgIC8vIG9ubHkgaW5qZWN0L2Ryb3AgYXVkaW8gZnJhbWVzIGluIGNhc2UgdGltZSBvZmZzZXQgaXMgYWNjdXJhdGVcbiAgICBpZiAoYWNjdXJhdGVUaW1lT2Zmc2V0ICYmIHRyYWNrLmlzQUFDKSB7XG4gICAgICBmb3IgKGxldCBpID0gMCwgbmV4dFB0c05vcm0gPSBuZXh0QXVkaW9QdHM7IGkgPCBpbnB1dFNhbXBsZXMubGVuZ3RoOyApIHtcbiAgICAgICAgLy8gRmlyc3QsIGxldCdzIHNlZSBob3cgZmFyIG9mZiB0aGlzIGZyYW1lIGlzIGZyb20gd2hlcmUgd2UgZXhwZWN0IGl0IHRvIGJlXG4gICAgICAgIHZhciBzYW1wbGUgPSBpbnB1dFNhbXBsZXNbaV0sXG4gICAgICAgICAgICBwdHNOb3JtID0gcHRzTm9ybWFsaXplKHNhbXBsZS5wdHMgLSBpbml0RFRTLCBuZXh0QXVkaW9QdHMpLFxuICAgICAgICAgICAgZGVsdGEgPSBwdHNOb3JtIC0gbmV4dFB0c05vcm07XG5cbiAgICAgICAgLy8gSWYgd2UncmUgb3ZlcmxhcHBpbmcgYnkgbW9yZSB0aGFuIGEgZHVyYXRpb24sIGRyb3AgdGhpcyBzYW1wbGVcbiAgICAgICAgaWYgKGRlbHRhIDw9IC1pbnB1dFNhbXBsZUR1cmF0aW9uKSB7XG4gICAgICAgICAgbG9nZ2VyLndhcm4oYERyb3BwaW5nIDEgYXVkaW8gZnJhbWUgQCAkeyhuZXh0UHRzTm9ybS9pbnB1dFRpbWVTY2FsZSkudG9GaXhlZCgzKX1zIGR1ZSB0byAke01hdGguYWJzKDEwMDAqZGVsdGEvaW5wdXRUaW1lU2NhbGUpfSBtcyBvdmVybGFwLmApO1xuICAgICAgICAgIGlucHV0U2FtcGxlcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgdHJhY2subGVuIC09IHNhbXBsZS51bml0Lmxlbmd0aDtcbiAgICAgICAgICAvLyBEb24ndCB0b3VjaCBuZXh0UHRzTm9ybSBvciBpXG4gICAgICAgIH1cblxuICAgICAgICAvLyBJbnNlcnQgbWlzc2luZyBmcmFtZXMgaWY6XG4gICAgICAgIC8vIDE6IFdlJ3JlIG1vcmUgdGhhbiBvbmUgZnJhbWUgYXdheVxuICAgICAgICAvLyAyOiBOb3QgbW9yZSB0aGFuICMgb2Ygc2FtcGxlcyBhd2F5XG4gICAgICAgIC8vIDM6IGN1cnJlbnRUaW1lIChha2EgbmV4dFB0c05vcm0pIGlzIG5vdCAwXG4gICAgICAgIGVsc2UgaWYgKGRlbHRhID49IGlucHV0U2FtcGxlRHVyYXRpb24gJiYgZGVsdGEgPD0gKGlucHV0U2FtcGxlcy5sZW5ndGggKiBpbnB1dFNhbXBsZUR1cmF0aW9uKSAmJiBuZXh0UHRzTm9ybSkge1xuICAgICAgICAgIHZhciBtaXNzaW5nID0gTWF0aC5yb3VuZChkZWx0YSAvIGlucHV0U2FtcGxlRHVyYXRpb24pO1xuICAgICAgICAgIGxvZ2dlci53YXJuKGBJbmplY3RpbmcgJHttaXNzaW5nfSBhdWRpbyBmcmFtZSBAICR7KG5leHRQdHNOb3JtL2lucHV0VGltZVNjYWxlKS50b0ZpeGVkKDMpfXMgZHVlIHRvICR7MTAwMCpkZWx0YS9pbnB1dFRpbWVTY2FsZX0gbXMgZ2FwLmApO1xuICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWlzc2luZzsgaisrKSB7XG4gICAgICAgICAgICBuZXdTdGFtcCA9IG5leHRQdHNOb3JtICsgaW5pdERUUztcbiAgICAgICAgICAgIG5ld1N0YW1wID0gTWF0aC5tYXgobmV3U3RhbXAsIGluaXREVFMpO1xuICAgICAgICAgICAgZmlsbEZyYW1lID0gQUFDLmdldFNpbGVudEZyYW1lKHRyYWNrLm1hbmlmZXN0Q29kZWMgfHwgdHJhY2suY29kZWMsdHJhY2suY2hhbm5lbENvdW50KTtcbiAgICAgICAgICAgIGlmICghZmlsbEZyYW1lKSB7XG4gICAgICAgICAgICAgIGxvZ2dlci5sb2coJ1VuYWJsZSB0byBnZXQgc2lsZW50IGZyYW1lIGZvciBnaXZlbiBhdWRpbyBjb2RlYzsgZHVwbGljYXRpbmcgbGFzdCBmcmFtZSBpbnN0ZWFkLicpO1xuICAgICAgICAgICAgICBmaWxsRnJhbWUgPSBzYW1wbGUudW5pdC5zdWJhcnJheSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5wdXRTYW1wbGVzLnNwbGljZShpLCAwLCB7dW5pdDogZmlsbEZyYW1lLCBwdHM6IG5ld1N0YW1wLCBkdHM6IG5ld1N0YW1wfSk7XG4gICAgICAgICAgICB0cmFjay5sZW4gKz0gZmlsbEZyYW1lLmxlbmd0aDtcbiAgICAgICAgICAgIG5leHRQdHNOb3JtICs9IGlucHV0U2FtcGxlRHVyYXRpb247XG4gICAgICAgICAgICBpICs9IDE7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gQWRqdXN0IHNhbXBsZSB0byBuZXh0IGV4cGVjdGVkIHB0c1xuICAgICAgICAgIHNhbXBsZS5wdHMgPSBzYW1wbGUuZHRzID0gbmV4dFB0c05vcm0gKyBpbml0RFRTO1xuICAgICAgICAgIG5leHRQdHNOb3JtICs9IGlucHV0U2FtcGxlRHVyYXRpb247XG4gICAgICAgICAgaSArPSAxO1xuICAgICAgICB9XG4gICAgICAgIC8vIE90aGVyd2lzZSwganVzdCBhZGp1c3QgcHRzXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlmIChNYXRoLmFicyhkZWx0YSkgPiAoMC4xICogaW5wdXRTYW1wbGVEdXJhdGlvbikpIHtcbiAgICAgICAgICAgIC8vIGxvZ2dlci5sb2coYEludmFsaWQgZnJhbWUgZGVsdGEgJHtNYXRoLnJvdW5kKHB0c05vcm0gLSBuZXh0UHRzTm9ybSArIGlucHV0U2FtcGxlRHVyYXRpb24pfSBhdCBQVFMgJHtNYXRoLnJvdW5kKHB0c05vcm0gLyA5MCl9IChzaG91bGQgYmUgJHtNYXRoLnJvdW5kKGlucHV0U2FtcGxlRHVyYXRpb24pfSkuYCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5leHRQdHNOb3JtICs9IGlucHV0U2FtcGxlRHVyYXRpb247XG4gICAgICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICAgIHNhbXBsZS5wdHMgPSBzYW1wbGUuZHRzID0gaW5pdERUUyArIG5leHRBdWRpb1B0cztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2FtcGxlLnB0cyA9IHNhbXBsZS5kdHMgPSBpbnB1dFNhbXBsZXNbaSAtIDFdLnB0cyArIGlucHV0U2FtcGxlRHVyYXRpb247XG4gICAgICAgICAgfVxuICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuXG4gICAgZm9yIChsZXQgaiA9MCAsIG5iU2FtcGxlcyA9IGlucHV0U2FtcGxlcy5sZW5ndGg7IGogPCBuYlNhbXBsZXMgOyBqKyspIHtcbiAgICAgIGF1ZGlvU2FtcGxlID0gaW5wdXRTYW1wbGVzW2pdO1xuICAgICAgdW5pdCA9IGF1ZGlvU2FtcGxlLnVuaXQ7XG4gICAgICBwdHMgPSBhdWRpb1NhbXBsZS5wdHMgLSBpbml0RFRTO1xuICAgICAgZHRzID0gYXVkaW9TYW1wbGUuZHRzIC0gaW5pdERUUztcbiAgICAgIC8vbG9nZ2VyLmxvZyhgQXVkaW8vUFRTOiR7TWF0aC5yb3VuZChwdHMvOTApfWApO1xuICAgICAgLy8gaWYgbm90IGZpcnN0IHNhbXBsZVxuICAgICAgaWYgKGxhc3REVFMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwdHNub3JtID0gcHRzTm9ybWFsaXplKHB0cywgbGFzdERUUyk7XG4gICAgICAgIGR0c25vcm0gPSBwdHNOb3JtYWxpemUoZHRzLCBsYXN0RFRTKTtcbiAgICAgICAgbXA0U2FtcGxlLmR1cmF0aW9uID0gTWF0aC5yb3VuZCgoZHRzbm9ybSAtIGxhc3REVFMpIC8gc2NhbGVGYWN0b3IpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHRzbm9ybSA9IHB0c05vcm1hbGl6ZShwdHMsIG5leHRBdWRpb1B0cyk7XG4gICAgICAgIGR0c25vcm0gPSBwdHNOb3JtYWxpemUoZHRzLCBuZXh0QXVkaW9QdHMpO1xuICAgICAgICBsZXQgZGVsdGEgPSBNYXRoLnJvdW5kKDEwMDAgKiAocHRzbm9ybSAtIG5leHRBdWRpb1B0cykgLyBpbnB1dFRpbWVTY2FsZSksXG4gICAgICAgICAgICBudW1NaXNzaW5nRnJhbWVzID0gMDtcbiAgICAgICAgLy8gaWYgZnJhZ21lbnQgYXJlIGNvbnRpZ3VvdXMsIGRldGVjdCBob2xlL292ZXJsYXBwaW5nIGJldHdlZW4gZnJhZ21lbnRzXG4gICAgICAgIC8vIGNvbnRpZ3VvdXMgZnJhZ21lbnRzIGFyZSBjb25zZWN1dGl2ZSBmcmFnbWVudHMgZnJvbSBzYW1lIHF1YWxpdHkgbGV2ZWwgKHNhbWUgbGV2ZWwsIG5ldyBTTiA9IG9sZCBTTiArIDEpXG4gICAgICAgIGlmIChjb250aWd1b3VzICYmIHRyYWNrLmlzQUFDKSB7XG4gICAgICAgICAgLy8gbG9nIGRlbHRhXG4gICAgICAgICAgaWYgKGRlbHRhKSB7XG4gICAgICAgICAgICBpZiAoZGVsdGEgPiAwKSB7XG4gICAgICAgICAgICAgIG51bU1pc3NpbmdGcmFtZXMgPSBNYXRoLnJvdW5kKChwdHNub3JtIC0gbmV4dEF1ZGlvUHRzKSAvIGlucHV0U2FtcGxlRHVyYXRpb24pO1xuICAgICAgICAgICAgICBsb2dnZXIubG9nKGAke2RlbHRhfSBtcyBob2xlIGJldHdlZW4gQUFDIHNhbXBsZXMgZGV0ZWN0ZWQsZmlsbGluZyBpdGApO1xuICAgICAgICAgICAgICBpZiAobnVtTWlzc2luZ0ZyYW1lcyA+IDApIHtcbiAgICAgICAgICAgICAgICBmaWxsRnJhbWUgPSBBQUMuZ2V0U2lsZW50RnJhbWUodHJhY2subWFuaWZlc3RDb2RlYyB8fCB0cmFjay5jb2RlYyx0cmFjay5jaGFubmVsQ291bnQpO1xuICAgICAgICAgICAgICAgIGlmICghZmlsbEZyYW1lKSB7XG4gICAgICAgICAgICAgICAgICBmaWxsRnJhbWUgPSB1bml0LnN1YmFycmF5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRyYWNrLmxlbiArPSBudW1NaXNzaW5nRnJhbWVzICogZmlsbEZyYW1lLmxlbmd0aDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyBpZiB3ZSBoYXZlIGZyYW1lIG92ZXJsYXAsIG92ZXJsYXBwaW5nIGZvciBtb3JlIHRoYW4gaGFsZiBhIGZyYW1lIGR1cmFpb25cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZGVsdGEgPCAtMTIpIHtcbiAgICAgICAgICAgICAgLy8gZHJvcCBvdmVybGFwcGluZyBhdWRpbyBmcmFtZXMuLi4gYnJvd3NlciB3aWxsIGRlYWwgd2l0aCBpdFxuICAgICAgICAgICAgICBsb2dnZXIubG9nKGAkeygtZGVsdGEpfSBtcyBvdmVybGFwcGluZyBiZXR3ZWVuIEFBQyBzYW1wbGVzIGRldGVjdGVkLCBkcm9wIGZyYW1lYCk7XG4gICAgICAgICAgICAgIHRyYWNrLmxlbiAtPSB1bml0LmJ5dGVMZW5ndGg7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gc2V0IFBUUy9EVFMgdG8gZXhwZWN0ZWQgUFRTL0RUU1xuICAgICAgICAgICAgcHRzbm9ybSA9IGR0c25vcm0gPSBuZXh0QXVkaW9QdHM7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHJlbWVtYmVyIGZpcnN0IFBUUyBvZiBvdXIgYXVkaW9TYW1wbGVzLCBlbnN1cmUgdmFsdWUgaXMgcG9zaXRpdmVcbiAgICAgICAgZmlyc3RQVFMgPSBNYXRoLm1heCgwLCBwdHNub3JtKTtcbiAgICAgICAgZmlyc3REVFMgPSBNYXRoLm1heCgwLCBkdHNub3JtKTtcbiAgICAgICAgaWYodHJhY2subGVuID4gMCkge1xuICAgICAgICAgIC8qIGNvbmNhdGVuYXRlIHRoZSBhdWRpbyBkYXRhIGFuZCBjb25zdHJ1Y3QgdGhlIG1kYXQgaW4gcGxhY2VcbiAgICAgICAgICAgIChuZWVkIDggbW9yZSBieXRlcyB0byBmaWxsIGxlbmd0aCBhbmQgbWRhdCB0eXBlKSAqL1xuXG5cbiAgICAgICAgICBsZXQgbWRhdFNpemUgPSByYXdNUEVHID8gdHJhY2subGVuIDogdHJhY2subGVuICsgODtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgbWRhdCA9IG5ldyBVaW50OEFycmF5KG1kYXRTaXplKTtcbiAgICAgICAgICB9IGNhdGNoKGVycikge1xuICAgICAgICAgICAgdGhpcy5vYnNlcnZlci50cmlnZ2VyKEV2ZW50LkVSUk9SLCB7dHlwZSA6IEVycm9yVHlwZXMuTVVYX0VSUk9SLCBkZXRhaWxzOiBFcnJvckRldGFpbHMuUkVNVVhfQUxMT0NfRVJST1IsIGZhdGFsOiBmYWxzZSwgYnl0ZXMgOiBtZGF0U2l6ZSwgcmVhc29uOiBgZmFpbCBhbGxvY2F0aW5nIGF1ZGlvIG1kYXQgJHttZGF0U2l6ZX1gfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghcmF3TVBFRykge1xuICAgICAgICAgICAgdmlldyA9IG5ldyBEYXRhVmlldyhtZGF0LmJ1ZmZlcik7XG4gICAgICAgICAgICB2aWV3LnNldFVpbnQzMigwLCBtZGF0U2l6ZSk7XG4gICAgICAgICAgICBtZGF0LnNldChNUDQudHlwZXMubWRhdCwgNCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIG5vIGF1ZGlvIHNhbXBsZXNcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1NaXNzaW5nRnJhbWVzOyBpKyspIHtcbiAgICAgICAgICBuZXdTdGFtcCA9IHB0c25vcm0gLSAobnVtTWlzc2luZ0ZyYW1lcyAtIGkpICogaW5wdXRTYW1wbGVEdXJhdGlvbjtcbiAgICAgICAgICBmaWxsRnJhbWUgPSBBQUMuZ2V0U2lsZW50RnJhbWUodHJhY2subWFuaWZlc3RDb2RlYyB8fCB0cmFjay5jb2RlYyx0cmFjay5jaGFubmVsQ291bnQpO1xuICAgICAgICAgIGlmICghZmlsbEZyYW1lKSB7XG4gICAgICAgICAgICBsb2dnZXIubG9nKCdVbmFibGUgdG8gZ2V0IHNpbGVudCBmcmFtZSBmb3IgZ2l2ZW4gYXVkaW8gY29kZWM7IGR1cGxpY2F0aW5nIHRoaXMgZnJhbWUgaW5zdGVhZC4nKTtcbiAgICAgICAgICAgIGZpbGxGcmFtZSA9IHVuaXQuc3ViYXJyYXkoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbWRhdC5zZXQoZmlsbEZyYW1lLCBvZmZzZXQpO1xuICAgICAgICAgIG9mZnNldCArPSBmaWxsRnJhbWUuYnl0ZUxlbmd0aDtcbiAgICAgICAgICBtcDRTYW1wbGUgPSB7XG4gICAgICAgICAgICBzaXplOiBmaWxsRnJhbWUuYnl0ZUxlbmd0aCxcbiAgICAgICAgICAgIGN0czogMCxcbiAgICAgICAgICAgIGR1cmF0aW9uOiAxMDI0LFxuICAgICAgICAgICAgZmxhZ3M6IHtcbiAgICAgICAgICAgICAgaXNMZWFkaW5nOiAwLFxuICAgICAgICAgICAgICBpc0RlcGVuZGVkT246IDAsXG4gICAgICAgICAgICAgIGhhc1JlZHVuZGFuY3k6IDAsXG4gICAgICAgICAgICAgIGRlZ3JhZFByaW86IDAsXG4gICAgICAgICAgICAgIGRlcGVuZHNPbjogMSxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICAgIG91dHB1dFNhbXBsZXMucHVzaChtcDRTYW1wbGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBtZGF0LnNldCh1bml0LCBvZmZzZXQpO1xuICAgICAgbGV0IHVuaXRMZW4gPSB1bml0LmJ5dGVMZW5ndGg7XG4gICAgICBvZmZzZXQgKz0gdW5pdExlbjtcbiAgICAgIC8vY29uc29sZS5sb2coJ1BUUy9EVFMvaW5pdERUUy9ub3JtUFRTL25vcm1EVFMvcmVsYXRpdmUgUFRTIDogJHthdWRpb1NhbXBsZS5wdHN9LyR7YXVkaW9TYW1wbGUuZHRzfS8ke2luaXREVFN9LyR7cHRzbm9ybX0vJHtkdHNub3JtfS8keyhhdWRpb1NhbXBsZS5wdHMvNDI5NDk2NzI5NikudG9GaXhlZCgzKX0nKTtcbiAgICAgIG1wNFNhbXBsZSA9IHtcbiAgICAgICAgc2l6ZTogdW5pdExlbixcbiAgICAgICAgY3RzOiAwLFxuICAgICAgICBkdXJhdGlvbjogMCxcbiAgICAgICAgZmxhZ3M6IHtcbiAgICAgICAgICBpc0xlYWRpbmc6IDAsXG4gICAgICAgICAgaXNEZXBlbmRlZE9uOiAwLFxuICAgICAgICAgIGhhc1JlZHVuZGFuY3k6IDAsXG4gICAgICAgICAgZGVncmFkUHJpbzogMCxcbiAgICAgICAgICBkZXBlbmRzT246IDEsXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBvdXRwdXRTYW1wbGVzLnB1c2gobXA0U2FtcGxlKTtcbiAgICAgIGxhc3REVFMgPSBkdHNub3JtO1xuICAgIH1cbiAgICB2YXIgbGFzdFNhbXBsZUR1cmF0aW9uID0gMDtcbiAgICB2YXIgbmJTYW1wbGVzID0gb3V0cHV0U2FtcGxlcy5sZW5ndGg7XG4gICAgLy9zZXQgbGFzdCBzYW1wbGUgZHVyYXRpb24gYXMgYmVpbmcgaWRlbnRpY2FsIHRvIHByZXZpb3VzIHNhbXBsZVxuICAgIGlmIChuYlNhbXBsZXMgPj0gMikge1xuICAgICAgbGFzdFNhbXBsZUR1cmF0aW9uID0gb3V0cHV0U2FtcGxlc1tuYlNhbXBsZXMgLSAyXS5kdXJhdGlvbjtcbiAgICAgIG1wNFNhbXBsZS5kdXJhdGlvbiA9IGxhc3RTYW1wbGVEdXJhdGlvbjtcbiAgICB9XG4gICAgaWYgKG5iU2FtcGxlcykge1xuICAgICAgLy8gbmV4dCBhdWRpbyBzYW1wbGUgUFRTIHNob3VsZCBiZSBlcXVhbCB0byBsYXN0IHNhbXBsZSBQVFMgKyBkdXJhdGlvblxuICAgICAgdGhpcy5uZXh0QXVkaW9QdHMgPSBwdHNub3JtICsgc2NhbGVGYWN0b3IgKiBsYXN0U2FtcGxlRHVyYXRpb247XG4gICAgICAvL2xvZ2dlci5sb2coJ0F1ZGlvL1BUUy9QVFNlbmQ6JyArIGF1ZGlvU2FtcGxlLnB0cy50b0ZpeGVkKDApICsgJy8nICsgdGhpcy5uZXh0QWFjRHRzLnRvRml4ZWQoMCkpO1xuICAgICAgdHJhY2subGVuID0gMDtcbiAgICAgIHRyYWNrLnNhbXBsZXMgPSBvdXRwdXRTYW1wbGVzO1xuICAgICAgaWYgKHJhd01QRUcpIHtcbiAgICAgICAgbW9vZiA9IG5ldyBVaW50OEFycmF5KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtb29mID0gTVA0Lm1vb2YodHJhY2suc2VxdWVuY2VOdW1iZXIrKywgZmlyc3REVFMgLyBzY2FsZUZhY3RvciwgdHJhY2spO1xuICAgICAgfVxuICAgICAgdHJhY2suc2FtcGxlcyA9IFtdO1xuICAgICAgbGV0IGF1ZGlvRGF0YSA9IHtcbiAgICAgICAgZGF0YTE6IG1vb2YsXG4gICAgICAgIGRhdGEyOiBtZGF0LFxuICAgICAgICBzdGFydFBUUzogZmlyc3RQVFMgLyBpbnB1dFRpbWVTY2FsZSxcbiAgICAgICAgZW5kUFRTOiB0aGlzLm5leHRBdWRpb1B0cyAvIGlucHV0VGltZVNjYWxlLFxuICAgICAgICBzdGFydERUUzogZmlyc3REVFMgLyBpbnB1dFRpbWVTY2FsZSxcbiAgICAgICAgZW5kRFRTOiAoZHRzbm9ybSArIHNjYWxlRmFjdG9yICogbGFzdFNhbXBsZUR1cmF0aW9uKSAvIGlucHV0VGltZVNjYWxlLFxuICAgICAgICB0eXBlOiAnYXVkaW8nLFxuICAgICAgICBuYjogbmJTYW1wbGVzXG4gICAgICB9O1xuICAgICAgdGhpcy5vYnNlcnZlci50cmlnZ2VyKEV2ZW50LkZSQUdfUEFSU0lOR19EQVRBLCBhdWRpb0RhdGEpO1xuICAgICAgcmV0dXJuIGF1ZGlvRGF0YTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZW11eEVtcHR5QXVkaW8odHJhY2ssIHRpbWVPZmZzZXQsIGNvbnRpZ3VvdXMsIHZpZGVvRGF0YSkge1xuICAgIGxldCBpbnB1dFRpbWVTY2FsZSA9IHRyYWNrLmlucHV0VGltZVNjYWxlLFxuICAgICAgICBtcDR0aW1lU2NhbGUgPSB0cmFjay5zYW1wbGVyYXRlID8gdHJhY2suc2FtcGxlcmF0ZSA6IGlucHV0VGltZVNjYWxlLFxuICAgICAgICBzY2FsZUZhY3RvciA9IGlucHV0VGltZVNjYWxlL21wNHRpbWVTY2FsZSxcbiAgICAgICAgbmV4dEF1ZGlvUHRzID0gdGhpcy5uZXh0QXVkaW9QdHMsXG5cbiAgICAgICAgLy8gc3luYyB3aXRoIHZpZGVvJ3MgdGltZXN0YW1wXG4gICAgICAgIHN0YXJ0RFRTID0gKG5leHRBdWRpb1B0cyAhPT0gdW5kZWZpbmVkID8gbmV4dEF1ZGlvUHRzIDogdmlkZW9EYXRhLnN0YXJ0RFRTICogaW5wdXRUaW1lU2NhbGUpICsgdGhpcy5faW5pdERUUyxcbiAgICAgICAgZW5kRFRTID0gdmlkZW9EYXRhLmVuZERUUyAqIGlucHV0VGltZVNjYWxlICsgdGhpcy5faW5pdERUUyxcbiAgICAgICAgLy8gb25lIHNhbXBsZSdzIGR1cmF0aW9uIHZhbHVlXG4gICAgICAgIHNhbXBsZUR1cmF0aW9uID0gMTAyNCxcbiAgICAgICAgZnJhbWVEdXJhdGlvbiA9IHNjYWxlRmFjdG9yICogc2FtcGxlRHVyYXRpb24sXG5cbiAgICAgICAgLy8gc2FtcGxlcyBjb3VudCBvZiB0aGlzIHNlZ21lbnQncyBkdXJhdGlvblxuICAgICAgICBuYlNhbXBsZXMgPSBNYXRoLmNlaWwoKGVuZERUUyAtIHN0YXJ0RFRTKSAvIGZyYW1lRHVyYXRpb24pLFxuXG4gICAgICAgIC8vIHNpbGVudCBmcmFtZVxuICAgICAgICBzaWxlbnRGcmFtZSA9IEFBQy5nZXRTaWxlbnRGcmFtZSh0cmFjay5tYW5pZmVzdENvZGVjIHx8IHRyYWNrLmNvZGVjLHRyYWNrLmNoYW5uZWxDb3VudCk7XG5cbiAgICAgICAgbG9nZ2VyLndhcm4oJ3JlbXV4IGVtcHR5IEF1ZGlvJyk7XG4gICAgLy8gQ2FuJ3QgcmVtdXggaWYgd2UgY2FuJ3QgZ2VuZXJhdGUgYSBzaWxlbnQgZnJhbWUuLi5cbiAgICBpZiAoIXNpbGVudEZyYW1lKSB7XG4gICAgICBsb2dnZXIudHJhY2UoJ1VuYWJsZSB0byByZW11eEVtcHR5QXVkaW8gc2luY2Ugd2Ugd2VyZSB1bmFibGUgdG8gZ2V0IGEgc2lsZW50IGZyYW1lIGZvciBnaXZlbiBhdWRpbyBjb2RlYyEnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgc2FtcGxlcyA9IFtdO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBuYlNhbXBsZXM7IGkrKykge1xuICAgICAgdmFyIHN0YW1wID0gc3RhcnREVFMgKyBpICogZnJhbWVEdXJhdGlvbjtcbiAgICAgIHNhbXBsZXMucHVzaCh7dW5pdDogc2lsZW50RnJhbWUsIHB0czogc3RhbXAsIGR0czogc3RhbXB9KTtcbiAgICAgIHRyYWNrLmxlbiArPSBzaWxlbnRGcmFtZS5sZW5ndGg7XG4gICAgfVxuICAgIHRyYWNrLnNhbXBsZXMgPSBzYW1wbGVzO1xuXG4gICAgdGhpcy5yZW11eEF1ZGlvKHRyYWNrLCB0aW1lT2Zmc2V0LCBjb250aWd1b3VzKTtcbiAgfVxuXG4gIHJlbXV4SUQzKHRyYWNrLHRpbWVPZmZzZXQpIHtcbiAgICB2YXIgbGVuZ3RoID0gdHJhY2suc2FtcGxlcy5sZW5ndGgsIHNhbXBsZTtcbiAgICBjb25zdCBpbnB1dFRpbWVTY2FsZSA9IHRyYWNrLmlucHV0VGltZVNjYWxlO1xuICAgIGNvbnN0IGluaXRQVFMgPSB0aGlzLl9pbml0UFRTO1xuICAgIGNvbnN0IGluaXREVFMgPSB0aGlzLl9pbml0RFRTO1xuICAgIC8vIGNvbnN1bWUgc2FtcGxlc1xuICAgIGlmKGxlbmd0aCkge1xuICAgICAgZm9yKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIHNhbXBsZSA9IHRyYWNrLnNhbXBsZXNbaW5kZXhdO1xuICAgICAgICAvLyBzZXR0aW5nIGlkMyBwdHMsIGR0cyB0byByZWxhdGl2ZSB0aW1lXG4gICAgICAgIC8vIHVzaW5nIHRoaXMuX2luaXRQVFMgYW5kIHRoaXMuX2luaXREVFMgdG8gY2FsY3VsYXRlIHJlbGF0aXZlIHRpbWVcbiAgICAgICAgc2FtcGxlLnB0cyA9ICgoc2FtcGxlLnB0cyAtIGluaXRQVFMpIC8gaW5wdXRUaW1lU2NhbGUpO1xuICAgICAgICBzYW1wbGUuZHRzID0gKChzYW1wbGUuZHRzIC0gaW5pdERUUykgLyBpbnB1dFRpbWVTY2FsZSk7XG4gICAgICB9XG4gICAgICB0aGlzLm9ic2VydmVyLnRyaWdnZXIoRXZlbnQuRlJBR19QQVJTSU5HX01FVEFEQVRBLCB7XG4gICAgICAgIHNhbXBsZXM6dHJhY2suc2FtcGxlc1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdHJhY2suc2FtcGxlcyA9IFtdO1xuICAgIHRpbWVPZmZzZXQgPSB0aW1lT2Zmc2V0O1xuICB9XG5cbiAgcmVtdXhUZXh0KHRyYWNrLHRpbWVPZmZzZXQpIHtcbiAgICB0cmFjay5zYW1wbGVzLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgcmV0dXJuIChhLnB0cy1iLnB0cyk7XG4gICAgfSk7XG5cbiAgICB2YXIgbGVuZ3RoID0gdHJhY2suc2FtcGxlcy5sZW5ndGgsIHNhbXBsZTtcbiAgICBjb25zdCBpbnB1dFRpbWVTY2FsZSA9IHRyYWNrLmlucHV0VGltZVNjYWxlO1xuICAgIGNvbnN0IGluaXRQVFMgPSB0aGlzLl9pbml0UFRTO1xuICAgIC8vIGNvbnN1bWUgc2FtcGxlc1xuICAgIGlmKGxlbmd0aCkge1xuICAgICAgZm9yKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIHNhbXBsZSA9IHRyYWNrLnNhbXBsZXNbaW5kZXhdO1xuICAgICAgICAvLyBzZXR0aW5nIHRleHQgcHRzLCBkdHMgdG8gcmVsYXRpdmUgdGltZVxuICAgICAgICAvLyB1c2luZyB0aGlzLl9pbml0UFRTIGFuZCB0aGlzLl9pbml0RFRTIHRvIGNhbGN1bGF0ZSByZWxhdGl2ZSB0aW1lXG4gICAgICAgIHNhbXBsZS5wdHMgPSAoKHNhbXBsZS5wdHMgLSBpbml0UFRTKSAvIGlucHV0VGltZVNjYWxlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMub2JzZXJ2ZXIudHJpZ2dlcihFdmVudC5GUkFHX1BBUlNJTkdfVVNFUkRBVEEsIHtcbiAgICAgICAgc2FtcGxlczp0cmFjay5zYW1wbGVzXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0cmFjay5zYW1wbGVzID0gW107XG4gICAgdGltZU9mZnNldCA9IHRpbWVPZmZzZXQ7XG4gIH1cblxuICBfUFRTTm9ybWFsaXplKHZhbHVlLCByZWZlcmVuY2UpIHtcbiAgICB2YXIgb2Zmc2V0O1xuICAgIGlmIChyZWZlcmVuY2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBpZiAocmVmZXJlbmNlIDwgdmFsdWUpIHtcbiAgICAgIC8vIC0gMl4zM1xuICAgICAgb2Zmc2V0ID0gLTg1ODk5MzQ1OTI7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vICsgMl4zM1xuICAgICAgb2Zmc2V0ID0gODU4OTkzNDU5MjtcbiAgICB9XG4gICAgLyogUFRTIGlzIDMzYml0IChmcm9tIDAgdG8gMl4zMyAtMSlcbiAgICAgIGlmIGRpZmYgYmV0d2VlbiB2YWx1ZSBhbmQgcmVmZXJlbmNlIGlzIGJpZ2dlciB0aGFuIGhhbGYgb2YgdGhlIGFtcGxpdHVkZSAoMl4zMikgdGhlbiBpdCBtZWFucyB0aGF0XG4gICAgICBQVFMgbG9vcGluZyBvY2N1cmVkLiBmaWxsIHRoZSBnYXAgKi9cbiAgICB3aGlsZSAoTWF0aC5hYnModmFsdWUgLSByZWZlcmVuY2UpID4gNDI5NDk2NzI5Nikge1xuICAgICAgICB2YWx1ZSArPSBvZmZzZXQ7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IE1QNFJlbXV4ZXI7XG4iLCIvKipcbiAqIHBhc3N0aHJvdWdoIHJlbXV4ZXJcbiovXG5pbXBvcnQgRXZlbnQgZnJvbSAnLi4vZXZlbnRzJztcblxuY2xhc3MgUGFzc1Rocm91Z2hSZW11eGVyIHtcbiAgY29uc3RydWN0b3Iob2JzZXJ2ZXIpIHtcbiAgICB0aGlzLm9ic2VydmVyID0gb2JzZXJ2ZXI7XG4gIH1cblxuICBkZXN0cm95KCkge1xuICB9XG5cbiAgcmVzZXRUaW1lU3RhbXAoKSB7XG4gIH1cblxuICByZXNldEluaXRTZWdtZW50KCkge1xuICB9XG5cbiAgcmVtdXgoYXVkaW9UcmFjayx2aWRlb1RyYWNrLGlkM1RyYWNrLHRleHRUcmFjayx0aW1lT2Zmc2V0LCBjb250aWd1b3VzLGFjY3VyYXRlVGltZU9mZnNldCxyYXdEYXRhKSB7XG4gICAgdmFyIG9ic2VydmVyID0gdGhpcy5vYnNlcnZlcjtcbiAgICB2YXIgc3RyZWFtVHlwZSA9ICcnO1xuICAgIGlmIChhdWRpb1RyYWNrKSB7XG4gICAgICBzdHJlYW1UeXBlICs9ICdhdWRpbyc7XG4gICAgfVxuICAgIGlmICh2aWRlb1RyYWNrKSB7XG4gICAgICBzdHJlYW1UeXBlICs9ICd2aWRlbyc7XG4gICAgfVxuICAgIG9ic2VydmVyLnRyaWdnZXIoRXZlbnQuRlJBR19QQVJTSU5HX0RBVEEsIHtcbiAgICAgIGRhdGExOiByYXdEYXRhLFxuICAgICAgc3RhcnRQVFM6IHRpbWVPZmZzZXQsXG4gICAgICBzdGFydERUUzogdGltZU9mZnNldCxcbiAgICAgIHR5cGU6IHN0cmVhbVR5cGUsXG4gICAgICBuYjogMSxcbiAgICAgIGRyb3BwZWQgOiAwXG4gICAgfSk7XG4gICAgLy9ub3RpZnkgZW5kIG9mIHBhcnNpbmdcbiAgICBvYnNlcnZlci50cmlnZ2VyKEV2ZW50LkZSQUdfUEFSU0VEKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBQYXNzVGhyb3VnaFJlbXV4ZXI7XG4iLCJjb25zdCBERUNJTUFMX1JFU09MVVRJT05fUkVHRVggPSAvXihcXGQrKXgoXFxkKykkLztcbmNvbnN0IEFUVFJfTElTVF9SRUdFWCA9IC9cXHMqKC4rPylcXHMqPSgoPzpcXFwiLio/XFxcIil8Lio/KSg/Oix8JCkvZztcblxuLy8gYWRhcHRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9rYW5vbmdpbC9ub2RlLW0zdThwYXJzZS9ibG9iL21hc3Rlci9hdHRybGlzdC5qc1xuY2xhc3MgQXR0ckxpc3Qge1xuXG4gIGNvbnN0cnVjdG9yKGF0dHJzKSB7XG4gICAgaWYgKHR5cGVvZiBhdHRycyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGF0dHJzID0gQXR0ckxpc3QucGFyc2VBdHRyTGlzdChhdHRycyk7XG4gICAgfVxuICAgIGZvcih2YXIgYXR0ciBpbiBhdHRycyl7XG4gICAgICBpZihhdHRycy5oYXNPd25Qcm9wZXJ0eShhdHRyKSkge1xuICAgICAgICB0aGlzW2F0dHJdID0gYXR0cnNbYXR0cl07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZGVjaW1hbEludGVnZXIoYXR0ck5hbWUpIHtcbiAgICBjb25zdCBpbnRWYWx1ZSA9IHBhcnNlSW50KHRoaXNbYXR0ck5hbWVdLCAxMCk7XG4gICAgaWYgKGludFZhbHVlID4gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpIHtcbiAgICAgIHJldHVybiBJbmZpbml0eTtcbiAgICB9XG4gICAgcmV0dXJuIGludFZhbHVlO1xuICB9XG5cbiAgaGV4YWRlY2ltYWxJbnRlZ2VyKGF0dHJOYW1lKSB7XG4gICAgaWYodGhpc1thdHRyTmFtZV0pIHtcbiAgICAgIGxldCBzdHJpbmdWYWx1ZSA9ICh0aGlzW2F0dHJOYW1lXSB8fCAnMHgnKS5zbGljZSgyKTtcbiAgICAgIHN0cmluZ1ZhbHVlID0gKChzdHJpbmdWYWx1ZS5sZW5ndGggJiAxKSA/ICcwJyA6ICcnKSArIHN0cmluZ1ZhbHVlO1xuXG4gICAgICBjb25zdCB2YWx1ZSA9IG5ldyBVaW50OEFycmF5KHN0cmluZ1ZhbHVlLmxlbmd0aCAvIDIpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHJpbmdWYWx1ZS5sZW5ndGggLyAyOyBpKyspIHtcbiAgICAgICAgdmFsdWVbaV0gPSBwYXJzZUludChzdHJpbmdWYWx1ZS5zbGljZShpICogMiwgaSAqIDIgKyAyKSwgMTYpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICBoZXhhZGVjaW1hbEludGVnZXJBc051bWJlcihhdHRyTmFtZSkge1xuICAgIGNvbnN0IGludFZhbHVlID0gcGFyc2VJbnQodGhpc1thdHRyTmFtZV0sIDE2KTtcbiAgICBpZiAoaW50VmFsdWUgPiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUikge1xuICAgICAgcmV0dXJuIEluZmluaXR5O1xuICAgIH1cbiAgICByZXR1cm4gaW50VmFsdWU7XG4gIH1cblxuICBkZWNpbWFsRmxvYXRpbmdQb2ludChhdHRyTmFtZSkge1xuICAgIHJldHVybiBwYXJzZUZsb2F0KHRoaXNbYXR0ck5hbWVdKTtcbiAgfVxuXG4gIGVudW1lcmF0ZWRTdHJpbmcoYXR0ck5hbWUpIHtcbiAgICByZXR1cm4gdGhpc1thdHRyTmFtZV07XG4gIH1cblxuICBkZWNpbWFsUmVzb2x1dGlvbihhdHRyTmFtZSkge1xuICAgIGNvbnN0IHJlcyA9IERFQ0lNQUxfUkVTT0xVVElPTl9SRUdFWC5leGVjKHRoaXNbYXR0ck5hbWVdKTtcbiAgICBpZiAocmVzID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgd2lkdGg6IHBhcnNlSW50KHJlc1sxXSwgMTApLFxuICAgICAgaGVpZ2h0OiBwYXJzZUludChyZXNbMl0sIDEwKVxuICAgIH07XG4gIH1cblxuICBzdGF0aWMgcGFyc2VBdHRyTGlzdChpbnB1dCkge1xuICAgIHZhciBtYXRjaCwgYXR0cnMgPSB7fTtcbiAgICBBVFRSX0xJU1RfUkVHRVgubGFzdEluZGV4ID0gMDtcbiAgICB3aGlsZSAoKG1hdGNoID0gQVRUUl9MSVNUX1JFR0VYLmV4ZWMoaW5wdXQpKSAhPT0gbnVsbCkge1xuICAgICAgdmFyIHZhbHVlID0gbWF0Y2hbMl0sIHF1b3RlID0gJ1wiJztcblxuICAgICAgaWYgKHZhbHVlLmluZGV4T2YocXVvdGUpID09PSAwICYmXG4gICAgICAgICAgdmFsdWUubGFzdEluZGV4T2YocXVvdGUpID09PSAodmFsdWUubGVuZ3RoLTEpKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUuc2xpY2UoMSwgLTEpO1xuICAgICAgfVxuICAgICAgYXR0cnNbbWF0Y2hbMV1dID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBhdHRycztcbiAgfVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IEF0dHJMaXN0O1xuIiwidmFyIEJpbmFyeVNlYXJjaCA9IHtcbiAgICAvKipcbiAgICAgKiBTZWFyY2hlcyBmb3IgYW4gaXRlbSBpbiBhbiBhcnJheSB3aGljaCBtYXRjaGVzIGEgY2VydGFpbiBjb25kaXRpb24uXG4gICAgICogVGhpcyByZXF1aXJlcyB0aGUgY29uZGl0aW9uIHRvIG9ubHkgbWF0Y2ggb25lIGl0ZW0gaW4gdGhlIGFycmF5LFxuICAgICAqIGFuZCBmb3IgdGhlIGFycmF5IHRvIGJlIG9yZGVyZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBhcnJheSB0byBzZWFyY2guXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY29tcGFyaXNvbkZ1bmN0aW9uXG4gICAgICogICAgICBDYWxsZWQgYW5kIHByb3ZpZGVkIGEgY2FuZGlkYXRlIGl0ZW0gYXMgdGhlIGZpcnN0IGFyZ3VtZW50LlxuICAgICAqICAgICAgU2hvdWxkIHJldHVybjpcbiAgICAgKiAgICAgICAgICA+IC0xIGlmIHRoZSBpdGVtIHNob3VsZCBiZSBsb2NhdGVkIGF0IGEgbG93ZXIgaW5kZXggdGhhbiB0aGUgcHJvdmlkZWQgaXRlbS5cbiAgICAgKiAgICAgICAgICA+IDEgaWYgdGhlIGl0ZW0gc2hvdWxkIGJlIGxvY2F0ZWQgYXQgYSBoaWdoZXIgaW5kZXggdGhhbiB0aGUgcHJvdmlkZWQgaXRlbS5cbiAgICAgKiAgICAgICAgICA+IDAgaWYgdGhlIGl0ZW0gaXMgdGhlIGl0ZW0geW91J3JlIGxvb2tpbmcgZm9yLlxuICAgICAqXG4gICAgICogQHJldHVybiB7Kn0gVGhlIG9iamVjdCBpZiBpdCBpcyBmb3VuZCBvciBudWxsIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBzZWFyY2g6IGZ1bmN0aW9uKGxpc3QsIGNvbXBhcmlzb25GdW5jdGlvbikge1xuICAgICAgICB2YXIgbWluSW5kZXggPSAwO1xuICAgICAgICB2YXIgbWF4SW5kZXggPSBsaXN0Lmxlbmd0aCAtIDE7XG4gICAgICAgIHZhciBjdXJyZW50SW5kZXggPSBudWxsO1xuICAgICAgICB2YXIgY3VycmVudEVsZW1lbnQgPSBudWxsO1xuICAgICBcbiAgICAgICAgd2hpbGUgKG1pbkluZGV4IDw9IG1heEluZGV4KSB7XG4gICAgICAgICAgICBjdXJyZW50SW5kZXggPSAobWluSW5kZXggKyBtYXhJbmRleCkgLyAyIHwgMDtcbiAgICAgICAgICAgIGN1cnJlbnRFbGVtZW50ID0gbGlzdFtjdXJyZW50SW5kZXhdO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB2YXIgY29tcGFyaXNvblJlc3VsdCA9IGNvbXBhcmlzb25GdW5jdGlvbihjdXJyZW50RWxlbWVudCk7XG4gICAgICAgICAgICBpZiAoY29tcGFyaXNvblJlc3VsdCA+IDApIHtcbiAgICAgICAgICAgICAgICBtaW5JbmRleCA9IGN1cnJlbnRJbmRleCArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjb21wYXJpc29uUmVzdWx0IDwgMCkge1xuICAgICAgICAgICAgICAgIG1heEluZGV4ID0gY3VycmVudEluZGV4IC0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBjdXJyZW50RWxlbWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICBcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBCaW5hcnlTZWFyY2g7XG4iLCIvKipcbiAqXG4gKiBUaGlzIGNvZGUgd2FzIHBvcnRlZCBmcm9tIHRoZSBkYXNoLmpzIHByb2plY3QgYXQ6XG4gKiAgIGh0dHBzOi8vZ2l0aHViLmNvbS9EYXNoLUluZHVzdHJ5LUZvcnVtL2Rhc2guanMvYmxvYi9kZXZlbG9wbWVudC9leHRlcm5hbHMvY2VhNjA4LXBhcnNlci5qc1xuICogICBodHRwczovL2dpdGh1Yi5jb20vRGFzaC1JbmR1c3RyeS1Gb3J1bS9kYXNoLmpzL2NvbW1pdC84MjY5YjI2YTc2MWUwODUzYmIyMWQ3ODc4MGVkOTQ1MTQ0ZWNkZDRkI2RpZmYtNzFiYzI5NWEyZDZiNmI3MDkzYTFkMzI5MGQ1M2E0YjJcbiAqXG4gKiBUaGUgb3JpZ2luYWwgY29weXJpZ2h0IGFwcGVhcnMgYmVsb3c6XG4gKlxuICogVGhlIGNvcHlyaWdodCBpbiB0aGlzIHNvZnR3YXJlIGlzIGJlaW5nIG1hZGUgYXZhaWxhYmxlIHVuZGVyIHRoZSBCU0QgTGljZW5zZSxcbiAqIGluY2x1ZGVkIGJlbG93LiBUaGlzIHNvZnR3YXJlIG1heSBiZSBzdWJqZWN0IHRvIG90aGVyIHRoaXJkIHBhcnR5IGFuZCBjb250cmlidXRvclxuICogcmlnaHRzLCBpbmNsdWRpbmcgcGF0ZW50IHJpZ2h0cywgYW5kIG5vIHN1Y2ggcmlnaHRzIGFyZSBncmFudGVkIHVuZGVyIHRoaXMgbGljZW5zZS5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUtMjAxNiwgREFTSCBJbmR1c3RyeSBGb3J1bS5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0IG1vZGlmaWNhdGlvbixcbiAqIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcbiAqICAxLiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsIHRoaXNcbiAqICBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAqICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcbiAqICB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vclxuICogIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG4gKiAgMi4gTmVpdGhlciB0aGUgbmFtZSBvZiBEYXNoIEluZHVzdHJ5IEZvcnVtIG5vciB0aGUgbmFtZXMgb2YgaXRzXG4gKiAgY29udHJpYnV0b3JzIG1heSBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb20gdGhpcyBzb2Z0d2FyZVxuICogIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuICpcbiAqICBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIEFTIElTIEFORCBBTllcbiAqICBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEXG4gKiAgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELlxuICogIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgSE9MREVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsXG4gKiAgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVFxuICogIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1JcbiAqICBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSxcbiAqICBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpXG4gKiAgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEVcbiAqICBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAqL1xuICAgIC8qKlxuICAgICAqICBFeGNlcHRpb25zIGZyb20gcmVndWxhciBBU0NJSS4gQ29kZVBvaW50cyBhcmUgbWFwcGVkIHRvIFVURi0xNiBjb2Rlc1xuICAgICAqL1xuXG52YXIgc3BlY2lhbENlYTYwOENoYXJzQ29kZXMgPSB7XG4gICAgMHgyYSA6IDB4ZTEsIC8vIGxvd2VyY2FzZSBhLCBhY3V0ZSBhY2NlbnRcbiAgICAweDVjIDogMHhlOSwgLy8gbG93ZXJjYXNlIGUsIGFjdXRlIGFjY2VudFxuICAgIDB4NWUgOiAweGVkLCAvLyBsb3dlcmNhc2UgaSwgYWN1dGUgYWNjZW50XG4gICAgMHg1ZiA6IDB4ZjMsIC8vIGxvd2VyY2FzZSBvLCBhY3V0ZSBhY2NlbnRcbiAgICAweDYwIDogMHhmYSwgLy8gbG93ZXJjYXNlIHUsIGFjdXRlIGFjY2VudFxuICAgIDB4N2IgOiAweGU3LCAvLyBsb3dlcmNhc2UgYyB3aXRoIGNlZGlsbGFcbiAgICAweDdjIDogMHhmNywgLy8gZGl2aXNpb24gc3ltYm9sXG4gICAgMHg3ZCA6IDB4ZDEsIC8vIHVwcGVyY2FzZSBOIHRpbGRlXG4gICAgMHg3ZSA6IDB4ZjEsIC8vIGxvd2VyY2FzZSBuIHRpbGRlXG4gICAgMHg3ZiA6IDB4MjU4OCwgLy8gRnVsbCBibG9ja1xuICAgIC8vIFRISVMgQkxPQ0sgSU5DTFVERVMgVEhFIDE2IEVYVEVOREVEIChUV08tQllURSkgTElORSAyMSBDSEFSQUNURVJTXG4gICAgLy8gVEhBVCBDT01FIEZST00gSEkgQllURT0weDExIEFORCBMT1cgQkVUV0VFTiAweDMwIEFORCAweDNGXG4gICAgLy8gVEhJUyBNRUFOUyBUSEFUIFxceDUwIE1VU1QgQkUgQURERUQgVE8gVEhFIFZBTFVFU1xuICAgIDB4ODAgOiAweGFlLCAvLyBSZWdpc3RlcmVkIHN5bWJvbCAoUilcbiAgICAweDgxIDogMHhiMCwgLy8gZGVncmVlIHNpZ25cbiAgICAweDgyIDogMHhiZCwgLy8gMS8yIHN5bWJvbFxuICAgIDB4ODMgOiAweGJmLCAvLyBJbnZlcnRlZCAob3BlbikgcXVlc3Rpb24gbWFya1xuICAgIDB4ODQgOiAweDIxMjIsIC8vIFRyYWRlbWFyayBzeW1ib2wgKFRNKVxuICAgIDB4ODUgOiAweGEyLCAvLyBDZW50cyBzeW1ib2xcbiAgICAweDg2IDogMHhhMywgLy8gUG91bmRzIHN0ZXJsaW5nXG4gICAgMHg4NyA6IDB4MjY2YSwgLy8gTXVzaWMgOCd0aCBub3RlXG4gICAgMHg4OCA6IDB4ZTAsIC8vIGxvd2VyY2FzZSBhLCBncmF2ZSBhY2NlbnRcbiAgICAweDg5IDogMHgyMCwgLy8gdHJhbnNwYXJlbnQgc3BhY2UgKHJlZ3VsYXIpXG4gICAgMHg4YSA6IDB4ZTgsIC8vIGxvd2VyY2FzZSBlLCBncmF2ZSBhY2NlbnRcbiAgICAweDhiIDogMHhlMiwgLy8gbG93ZXJjYXNlIGEsIGNpcmN1bWZsZXggYWNjZW50XG4gICAgMHg4YyA6IDB4ZWEsIC8vIGxvd2VyY2FzZSBlLCBjaXJjdW1mbGV4IGFjY2VudFxuICAgIDB4OGQgOiAweGVlLCAvLyBsb3dlcmNhc2UgaSwgY2lyY3VtZmxleCBhY2NlbnRcbiAgICAweDhlIDogMHhmNCwgLy8gbG93ZXJjYXNlIG8sIGNpcmN1bWZsZXggYWNjZW50XG4gICAgMHg4ZiA6IDB4ZmIsIC8vIGxvd2VyY2FzZSB1LCBjaXJjdW1mbGV4IGFjY2VudFxuICAgIC8vIFRISVMgQkxPQ0sgSU5DTFVERVMgVEhFIDMyIEVYVEVOREVEIChUV08tQllURSkgTElORSAyMSBDSEFSQUNURVJTXG4gICAgLy8gVEhBVCBDT01FIEZST00gSEkgQllURT0weDEyIEFORCBMT1cgQkVUV0VFTiAweDIwIEFORCAweDNGXG4gICAgMHg5MCA6IDB4YzEsIC8vIGNhcGl0YWwgbGV0dGVyIEEgd2l0aCBhY3V0ZVxuICAgIDB4OTEgOiAweGM5LCAvLyBjYXBpdGFsIGxldHRlciBFIHdpdGggYWN1dGVcbiAgICAweDkyIDogMHhkMywgLy8gY2FwaXRhbCBsZXR0ZXIgTyB3aXRoIGFjdXRlXG4gICAgMHg5MyA6IDB4ZGEsIC8vIGNhcGl0YWwgbGV0dGVyIFUgd2l0aCBhY3V0ZVxuICAgIDB4OTQgOiAweGRjLCAvLyBjYXBpdGFsIGxldHRlciBVIHdpdGggZGlhcmVzaXNcbiAgICAweDk1IDogMHhmYywgLy8gbG93ZXJjYXNlIGxldHRlciBVIHdpdGggZGlhZXJlc2lzXG4gICAgMHg5NiA6IDB4MjAxOCwgLy8gb3BlbmluZyBzaW5nbGUgcXVvdGVcbiAgICAweDk3IDogMHhhMSwgLy8gaW52ZXJ0ZWQgZXhjbGFtYXRpb24gbWFya1xuICAgIDB4OTggOiAweDJhLCAvLyBhc3Rlcmlza1xuICAgIDB4OTkgOiAweDIwMTksIC8vIGNsb3Npbmcgc2luZ2xlIHF1b3RlXG4gICAgMHg5YSA6IDB4MjUwMSwgLy8gYm94IGRyYXdpbmdzIGhlYXZ5IGhvcml6b250YWxcbiAgICAweDliIDogMHhhOSwgLy8gY29weXJpZ2h0IHNpZ25cbiAgICAweDljIDogMHgyMTIwLCAvLyBTZXJ2aWNlIG1hcmtcbiAgICAweDlkIDogMHgyMDIyLCAvLyAocm91bmQpIGJ1bGxldFxuICAgIDB4OWUgOiAweDIwMWMsIC8vIExlZnQgZG91YmxlIHF1b3RhdGlvbiBtYXJrXG4gICAgMHg5ZiA6IDB4MjAxZCwgLy8gUmlnaHQgZG91YmxlIHF1b3RhdGlvbiBtYXJrXG4gICAgMHhhMCA6IDB4YzAsIC8vIHVwcGVyY2FzZSBBLCBncmF2ZSBhY2NlbnRcbiAgICAweGExIDogMHhjMiwgLy8gdXBwZXJjYXNlIEEsIGNpcmN1bWZsZXhcbiAgICAweGEyIDogMHhjNywgLy8gdXBwZXJjYXNlIEMgd2l0aCBjZWRpbGxhXG4gICAgMHhhMyA6IDB4YzgsIC8vIHVwcGVyY2FzZSBFLCBncmF2ZSBhY2NlbnRcbiAgICAweGE0IDogMHhjYSwgLy8gdXBwZXJjYXNlIEUsIGNpcmN1bWZsZXhcbiAgICAweGE1IDogMHhjYiwgLy8gY2FwaXRhbCBsZXR0ZXIgRSB3aXRoIGRpYXJlc2lzXG4gICAgMHhhNiA6IDB4ZWIsIC8vIGxvd2VyY2FzZSBsZXR0ZXIgZSB3aXRoIGRpYXJlc2lzXG4gICAgMHhhNyA6IDB4Y2UsIC8vIHVwcGVyY2FzZSBJLCBjaXJjdW1mbGV4XG4gICAgMHhhOCA6IDB4Y2YsIC8vIHVwcGVyY2FzZSBJLCB3aXRoIGRpYXJlc2lzXG4gICAgMHhhOSA6IDB4ZWYsIC8vIGxvd2VyY2FzZSBpLCB3aXRoIGRpYXJlc2lzXG4gICAgMHhhYSA6IDB4ZDQsIC8vIHVwcGVyY2FzZSBPLCBjaXJjdW1mbGV4XG4gICAgMHhhYiA6IDB4ZDksIC8vIHVwcGVyY2FzZSBVLCBncmF2ZSBhY2NlbnRcbiAgICAweGFjIDogMHhmOSwgLy8gbG93ZXJjYXNlIHUsIGdyYXZlIGFjY2VudFxuICAgIDB4YWQgOiAweGRiLCAvLyB1cHBlcmNhc2UgVSwgY2lyY3VtZmxleFxuICAgIDB4YWUgOiAweGFiLCAvLyBsZWZ0LXBvaW50aW5nIGRvdWJsZSBhbmdsZSBxdW90YXRpb24gbWFya1xuICAgIDB4YWYgOiAweGJiLCAvLyByaWdodC1wb2ludGluZyBkb3VibGUgYW5nbGUgcXVvdGF0aW9uIG1hcmtcbiAgICAvLyBUSElTIEJMT0NLIElOQ0xVREVTIFRIRSAzMiBFWFRFTkRFRCAoVFdPLUJZVEUpIExJTkUgMjEgQ0hBUkFDVEVSU1xuICAgIC8vIFRIQVQgQ09NRSBGUk9NIEhJIEJZVEU9MHgxMyBBTkQgTE9XIEJFVFdFRU4gMHgyMCBBTkQgMHgzRlxuICAgIDB4YjAgOiAweGMzLCAvLyBVcHBlcmNhc2UgQSwgdGlsZGVcbiAgICAweGIxIDogMHhlMywgLy8gTG93ZXJjYXNlIGEsIHRpbGRlXG4gICAgMHhiMiA6IDB4Y2QsIC8vIFVwcGVyY2FzZSBJLCBhY3V0ZSBhY2NlbnRcbiAgICAweGIzIDogMHhjYywgLy8gVXBwZXJjYXNlIEksIGdyYXZlIGFjY2VudFxuICAgIDB4YjQgOiAweGVjLCAvLyBMb3dlcmNhc2UgaSwgZ3JhdmUgYWNjZW50XG4gICAgMHhiNSA6IDB4ZDIsIC8vIFVwcGVyY2FzZSBPLCBncmF2ZSBhY2NlbnRcbiAgICAweGI2IDogMHhmMiwgLy8gTG93ZXJjYXNlIG8sIGdyYXZlIGFjY2VudFxuICAgIDB4YjcgOiAweGQ1LCAvLyBVcHBlcmNhc2UgTywgdGlsZGVcbiAgICAweGI4IDogMHhmNSwgLy8gTG93ZXJjYXNlIG8sIHRpbGRlXG4gICAgMHhiOSA6IDB4N2IsIC8vIE9wZW4gY3VybHkgYnJhY2VcbiAgICAweGJhIDogMHg3ZCwgLy8gQ2xvc2luZyBjdXJseSBicmFjZVxuICAgIDB4YmIgOiAweDVjLCAvLyBCYWNrc2xhc2hcbiAgICAweGJjIDogMHg1ZSwgLy8gQ2FyZXRcbiAgICAweGJkIDogMHg1ZiwgLy8gVW5kZXJzY29yZVxuICAgIDB4YmUgOiAweDdjLCAvLyBQaXBlICh2ZXJ0aWNhbCBsaW5lKVxuICAgIDB4YmYgOiAweDIyM2MsIC8vIFRpbGRlIG9wZXJhdG9yXG4gICAgMHhjMCA6IDB4YzQsIC8vIFVwcGVyY2FzZSBBLCB1bWxhdXRcbiAgICAweGMxIDogMHhlNCwgLy8gTG93ZXJjYXNlIEEsIHVtbGF1dFxuICAgIDB4YzIgOiAweGQ2LCAvLyBVcHBlcmNhc2UgTywgdW1sYXV0XG4gICAgMHhjMyA6IDB4ZjYsIC8vIExvd2VyY2FzZSBvLCB1bWxhdXRcbiAgICAweGM0IDogMHhkZiwgLy8gRXNzemV0dCAoc2hhcnAgUylcbiAgICAweGM1IDogMHhhNSwgLy8gWWVuIHN5bWJvbFxuICAgIDB4YzYgOiAweGE0LCAvLyBHZW5lcmljIGN1cnJlbmN5IHNpZ25cbiAgICAweGM3IDogMHgyNTAzLCAvLyBCb3ggZHJhd2luZ3MgaGVhdnkgdmVydGljYWxcbiAgICAweGM4IDogMHhjNSwgLy8gVXBwZXJjYXNlIEEsIHJpbmdcbiAgICAweGM5IDogMHhlNSwgLy8gTG93ZXJjYXNlIEEsIHJpbmdcbiAgICAweGNhIDogMHhkOCwgLy8gVXBwZXJjYXNlIE8sIHN0cm9rZVxuICAgIDB4Y2IgOiAweGY4LCAvLyBMb3dlcmNhc2Ugbywgc3Ryb2tcbiAgICAweGNjIDogMHgyNTBmLCAvLyBCb3ggZHJhd2luZ3MgaGVhdnkgZG93biBhbmQgcmlnaHRcbiAgICAweGNkIDogMHgyNTEzLCAvLyBCb3ggZHJhd2luZ3MgaGVhdnkgZG93biBhbmQgbGVmdFxuICAgIDB4Y2UgOiAweDI1MTcsIC8vIEJveCBkcmF3aW5ncyBoZWF2eSB1cCBhbmQgcmlnaHRcbiAgICAweGNmIDogMHgyNTFiIC8vIEJveCBkcmF3aW5ncyBoZWF2eSB1cCBhbmQgbGVmdFxufTtcblxuLyoqXG4gKiBVdGlsc1xuICovXG52YXIgZ2V0Q2hhckZvckJ5dGUgPSBmdW5jdGlvbihieXRlKSB7XG4gICAgdmFyIGNoYXJDb2RlID0gYnl0ZTtcbiAgICBpZiAoc3BlY2lhbENlYTYwOENoYXJzQ29kZXMuaGFzT3duUHJvcGVydHkoYnl0ZSkpIHtcbiAgICAgICAgY2hhckNvZGUgPSBzcGVjaWFsQ2VhNjA4Q2hhcnNDb2Rlc1tieXRlXTtcbiAgICB9XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY2hhckNvZGUpO1xufTtcblxudmFyIE5SX1JPV1MgPSAxNSxcbiAgICBOUl9DT0xTID0gMTAwO1xuLy8gVGFibGVzIHRvIGxvb2sgdXAgcm93IGZyb20gUEFDIGRhdGFcbnZhciByb3dzTG93Q2gxID0gezB4MTEgOiAxLCAweDEyIDogMywgMHgxNSA6IDUsIDB4MTYgOiA3LCAweDE3IDogOSwgMHgxMCA6IDExLCAweDEzIDogMTIsIDB4MTQgOiAxNH07XG52YXIgcm93c0hpZ2hDaDEgPSB7MHgxMSA6IDIsIDB4MTIgOiA0LCAweDE1IDogNiwgMHgxNiA6IDgsIDB4MTcgOiAxMCwgMHgxMyA6IDEzLCAweDE0IDogMTV9O1xudmFyIHJvd3NMb3dDaDIgPSB7MHgxOSA6IDEsIDB4MUEgOiAzLCAweDFEIDogNSwgMHgxRSA6IDcsIDB4MUYgOiA5LCAweDE4IDogMTEsIDB4MUIgOiAxMiwgMHgxQyA6IDE0fTtcbnZhciByb3dzSGlnaENoMiA9IHsweDE5IDogMiwgMHgxQSA6IDQsIDB4MUQgOiA2LCAweDFFIDogOCwgMHgxRiA6IDEwLCAweDFCIDogMTMsIDB4MUMgOiAxNX07XG5cbnZhciBiYWNrZ3JvdW5kQ29sb3JzID0gWyd3aGl0ZScsICdncmVlbicsICdibHVlJywgJ2N5YW4nLCAncmVkJywgJ3llbGxvdycsICdtYWdlbnRhJywgJ2JsYWNrJywgJ3RyYW5zcGFyZW50J107XG5cbi8qKlxuICogU2ltcGxlIGxvZ2dlciBjbGFzcyB0byBiZSBhYmxlIHRvIHdyaXRlIHdpdGggdGltZS1zdGFtcHMgYW5kIGZpbHRlciBvbiBsZXZlbC5cbiAqL1xudmFyIGxvZ2dlciA9IHtcbiAgICB2ZXJib3NlRmlsdGVyIDogeydEQVRBJyA6IDMsICdERUJVRycgOiAzLCAnSU5GTycgOiAyLCAnV0FSTklORycgOiAyLCAnVEVYVCcgOiAxLCAnRVJST1InIDogMH0sXG4gICAgdGltZSA6IG51bGwsXG4gICAgdmVyYm9zZUxldmVsIDogMCwgLy8gT25seSB3cml0ZSBlcnJvcnNcbiAgICBzZXRUaW1lIDogZnVuY3Rpb24obmV3VGltZSkge1xuICAgICAgICB0aGlzLnRpbWUgPSBuZXdUaW1lO1xuICAgIH0sXG4gICAgbG9nIDogZnVuY3Rpb24oc2V2ZXJpdHksIG1zZykge1xuICAgICAgICB2YXIgbWluTGV2ZWwgPSB0aGlzLnZlcmJvc2VGaWx0ZXJbc2V2ZXJpdHldO1xuICAgICAgICBpZiAodGhpcy52ZXJib3NlTGV2ZWwgPj0gbWluTGV2ZWwpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHRoaXMudGltZS50b0ZpeGVkKDMpICsgJyBbJyArIHNldmVyaXR5ICsgJ10gJyArIG1zZyk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG52YXIgbnVtQXJyYXlUb0hleEFycmF5ID0gZnVuY3Rpb24obnVtQXJyYXkpIHtcbiAgICB2YXIgaGV4QXJyYXkgPSBbXTtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IG51bUFycmF5Lmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGhleEFycmF5LnB1c2gobnVtQXJyYXlbal0udG9TdHJpbmcoMTYpKTtcbiAgICB9XG4gICAgcmV0dXJuIGhleEFycmF5O1xufTtcblxuY2xhc3MgUGVuU3RhdGUge1xuXG4gICAgY29uc3RydWN0b3IoZm9yZWdyb3VuZCwgdW5kZXJsaW5lLCBpdGFsaWNzLCBiYWNrZ3JvdW5kLCBmbGFzaCkge1xuICAgICAgICB0aGlzLmZvcmVncm91bmQgPSBmb3JlZ3JvdW5kIHx8ICd3aGl0ZSc7XG4gICAgICAgIHRoaXMudW5kZXJsaW5lID0gdW5kZXJsaW5lIHx8IGZhbHNlO1xuICAgICAgICB0aGlzLml0YWxpY3MgPSBpdGFsaWNzIHx8IGZhbHNlO1xuICAgICAgICB0aGlzLmJhY2tncm91bmQgPSBiYWNrZ3JvdW5kIHx8ICdibGFjayc7XG4gICAgICAgIHRoaXMuZmxhc2ggPSBmbGFzaCB8fCBmYWxzZTtcbiAgICB9XG5cbiAgICByZXNldCgpIHtcbiAgICAgICAgdGhpcy5mb3JlZ3JvdW5kID0gJ3doaXRlJztcbiAgICAgICAgdGhpcy51bmRlcmxpbmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pdGFsaWNzID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYmFja2dyb3VuZCA9ICdibGFjayc7XG4gICAgICAgIHRoaXMuZmxhc2ggPSBmYWxzZTtcbiAgICB9XG5cbiAgICBzZXRTdHlsZXMoc3R5bGVzKSB7XG4gICAgICAgIHZhciBhdHRyaWJzID0gWydmb3JlZ3JvdW5kJywgJ3VuZGVybGluZScsICdpdGFsaWNzJywgJ2JhY2tncm91bmQnLCAnZmxhc2gnXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAgOyBpIDwgYXR0cmlicy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHN0eWxlID0gYXR0cmlic1tpXTtcbiAgICAgICAgICAgIGlmIChzdHlsZXMuaGFzT3duUHJvcGVydHkoc3R5bGUpKSB7XG4gICAgICAgICAgICAgICAgdGhpc1tzdHlsZV0gPSBzdHlsZXNbc3R5bGVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaXNEZWZhdWx0KCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuZm9yZWdyb3VuZCA9PT0gJ3doaXRlJyAmJiAhdGhpcy51bmRlcmxpbmUgJiYgIXRoaXMuaXRhbGljcyAmJlxuICAgICAgICAgICAgICAgIHRoaXMuYmFja2dyb3VuZCA9PT0gJ2JsYWNrJyAmJiAhdGhpcy5mbGFzaCk7XG4gICAgfVxuXG4gICAgZXF1YWxzKG90aGVyKSB7XG4gICAgICAgIHJldHVybiAoICh0aGlzLmZvcmVncm91bmQgPT09IG90aGVyLmZvcmVncm91bmQpICYmXG4gICAgICAgICAgICAgICAgICh0aGlzLnVuZGVybGluZSA9PT0gb3RoZXIudW5kZXJsaW5lKSAmJlxuICAgICAgICAgICAgICAgICAodGhpcy5pdGFsaWNzID09PSBvdGhlci5pdGFsaWNzKSAmJlxuICAgICAgICAgICAgICAgICAodGhpcy5iYWNrZ3JvdW5kID09PSBvdGhlci5iYWNrZ3JvdW5kKSAmJlxuICAgICAgICAgICAgICAgICAodGhpcy5mbGFzaCA9PT0gb3RoZXIuZmxhc2gpICk7XG4gICAgfVxuXG4gICAgY29weShuZXdQZW5TdGF0ZSkge1xuICAgICAgICB0aGlzLmZvcmVncm91bmQgPSBuZXdQZW5TdGF0ZS5mb3JlZ3JvdW5kO1xuICAgICAgICB0aGlzLnVuZGVybGluZSA9IG5ld1BlblN0YXRlLnVuZGVybGluZTtcbiAgICAgICAgdGhpcy5pdGFsaWNzID0gbmV3UGVuU3RhdGUuaXRhbGljcztcbiAgICAgICAgdGhpcy5iYWNrZ3JvdW5kID0gbmV3UGVuU3RhdGUuYmFja2dyb3VuZDtcbiAgICAgICAgdGhpcy5mbGFzaCA9IG5ld1BlblN0YXRlLmZsYXNoO1xuICAgIH1cblxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gKCdjb2xvcj0nICsgdGhpcy5mb3JlZ3JvdW5kICsgJywgdW5kZXJsaW5lPScgKyB0aGlzLnVuZGVybGluZSArICcsIGl0YWxpY3M9JyArIHRoaXMuaXRhbGljcyArXG4gICAgICAgICAgICAnLCBiYWNrZ3JvdW5kPScgKyB0aGlzLmJhY2tncm91bmQgKyAnLCBmbGFzaD0nICsgdGhpcy5mbGFzaCk7XG4gICAgfVxufVxuXG4vKipcbiAqIFVuaWNvZGUgY2hhcmFjdGVyIHdpdGggc3R5bGluZyBhbmQgYmFja2dyb3VuZC5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5jbGFzcyBTdHlsZWRVbmljb2RlQ2hhclxue1xuXG4gICAgY29uc3RydWN0b3IodWNoYXIsIGZvcmVncm91bmQsIHVuZGVybGluZSwgaXRhbGljcywgYmFja2dyb3VuZCwgZmxhc2gpIHtcbiAgICAgICAgdGhpcy51Y2hhciA9IHVjaGFyIHx8ICcgJzsgLy8gdW5pY29kZSBjaGFyYWN0ZXJcbiAgICAgICAgdGhpcy5wZW5TdGF0ZSA9IG5ldyBQZW5TdGF0ZShmb3JlZ3JvdW5kLCB1bmRlcmxpbmUsaXRhbGljcywgYmFja2dyb3VuZCwgZmxhc2gpO1xuICAgIH1cblxuICAgIHJlc2V0KCkge1xuICAgICAgICB0aGlzLnVjaGFyID0gJyAnO1xuICAgICAgICB0aGlzLnBlblN0YXRlLnJlc2V0KCk7XG4gICAgfVxuXG4gICAgc2V0Q2hhcih1Y2hhciwgbmV3UGVuU3RhdGUpIHtcbiAgICAgICAgdGhpcy51Y2hhciA9IHVjaGFyO1xuICAgICAgICB0aGlzLnBlblN0YXRlLmNvcHkobmV3UGVuU3RhdGUpO1xuICAgIH1cblxuICAgIHNldFBlblN0YXRlKG5ld1BlblN0YXRlKSB7XG4gICAgICAgIHRoaXMucGVuU3RhdGUuY29weShuZXdQZW5TdGF0ZSk7XG4gICAgfVxuXG4gICAgZXF1YWxzKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnVjaGFyID09PSBvdGhlci51Y2hhciAmJiB0aGlzLnBlblN0YXRlLmVxdWFscyhvdGhlci5wZW5TdGF0ZSk7XG4gICAgfVxuXG4gICAgY29weShuZXdDaGFyKSB7XG4gICAgICAgIHRoaXMudWNoYXIgPSBuZXdDaGFyLnVjaGFyO1xuICAgICAgICB0aGlzLnBlblN0YXRlLmNvcHkobmV3Q2hhci5wZW5TdGF0ZSk7XG4gICAgfVxuXG4gICAgaXNFbXB0eSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudWNoYXIgPT09ICcgJyAmJiB0aGlzLnBlblN0YXRlLmlzRGVmYXVsdCgpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBDRUEtNjA4IHJvdyBjb25zaXN0aW5nIG9mIE5SX0NPTFMgaW5zdGFuY2VzIG9mIFN0eWxlZFVuaWNvZGVDaGFyLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmNsYXNzIFJvdyB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuY2hhcnMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAgOyBpIDwgTlJfQ09MUyA7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5jaGFycy5wdXNoKG5ldyBTdHlsZWRVbmljb2RlQ2hhcigpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgIHRoaXMuY3VyclBlblN0YXRlID0gbmV3IFBlblN0YXRlKCk7XG4gICAgfVxuXG4gICAgZXF1YWxzKG90aGVyKSB7XG4gICAgICAgIHZhciBlcXVhbCA9IHRydWU7XG4gICAgICAgIGZvciAodmFyIGkgPSAwIDsgaSA8IE5SX0NPTFM7IGkgKyspIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5jaGFyc1tpXS5lcXVhbHMob3RoZXIuY2hhcnNbaV0pKSB7XG4gICAgICAgICAgICAgICAgZXF1YWwgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXF1YWw7XG4gICAgfVxuXG4gICAgY29weShvdGhlcikge1xuICAgICAgICBmb3IgKHZhciBpID0gMCA7IGkgPCBOUl9DT0xTOyBpICsrKSB7XG4gICAgICAgICAgICB0aGlzLmNoYXJzW2ldLmNvcHkob3RoZXIuY2hhcnNbaV0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaXNFbXB0eSgpIHtcbiAgICAgICAgdmFyIGVtcHR5ID0gdHJ1ZTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAgOyBpIDwgTlJfQ09MUzsgaSArKykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmNoYXJzW2ldLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgICAgIGVtcHR5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVtcHR5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqICBTZXQgdGhlIGN1cnNvciB0byBhIHZhbGlkIGNvbHVtbi5cbiAgICAgKi9cbiAgICBzZXRDdXJzb3IoYWJzUG9zKSB7XG4gICAgICAgIGlmICh0aGlzLnBvcyAhPT0gYWJzUG9zKSB7XG4gICAgICAgICAgICB0aGlzLnBvcyA9IGFic1BvcztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wb3MgPCAwKSB7XG4gICAgICAgICAgICBsb2dnZXIubG9nKCdFUlJPUicsICdOZWdhdGl2ZSBjdXJzb3IgcG9zaXRpb24gJyArIHRoaXMucG9zKTtcbiAgICAgICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnBvcyA+IE5SX0NPTFMpIHtcbiAgICAgICAgICAgIGxvZ2dlci5sb2coJ0VSUk9SJywgJ1RvbyBsYXJnZSBjdXJzb3IgcG9zaXRpb24gJyArIHRoaXMucG9zKTtcbiAgICAgICAgICAgIHRoaXMucG9zID0gTlJfQ09MUztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1vdmUgdGhlIGN1cnNvciByZWxhdGl2ZSB0byBjdXJyZW50IHBvc2l0aW9uLlxuICAgICAqL1xuICAgIG1vdmVDdXJzb3IocmVsUG9zKSB7XG4gICAgICAgIHZhciBuZXdQb3MgPSB0aGlzLnBvcyArIHJlbFBvcztcbiAgICAgICAgaWYgKHJlbFBvcyA+IDEpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSB0aGlzLnBvcysxOyBpIDwgbmV3UG9zKzEgOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNoYXJzW2ldLnNldFBlblN0YXRlKHRoaXMuY3VyclBlblN0YXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldEN1cnNvcihuZXdQb3MpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEJhY2tzcGFjZSwgbW92ZSBvbmUgc3RlcCBiYWNrIGFuZCBjbGVhciBjaGFyYWN0ZXIuXG4gICAgICovXG4gICAgYmFja1NwYWNlKCkge1xuICAgICAgICB0aGlzLm1vdmVDdXJzb3IoLTEpO1xuICAgICAgICB0aGlzLmNoYXJzW3RoaXMucG9zXS5zZXRDaGFyKCcgJywgdGhpcy5jdXJyUGVuU3RhdGUpO1xuICAgIH1cblxuICAgIGluc2VydENoYXIoYnl0ZSkge1xuICAgICAgICBpZiAoYnl0ZSA+PSAweDkwKSB7IC8vRXh0ZW5kZWQgY2hhclxuICAgICAgICAgICAgdGhpcy5iYWNrU3BhY2UoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2hhciA9IGdldENoYXJGb3JCeXRlKGJ5dGUpO1xuICAgICAgICBpZiAodGhpcy5wb3MgPj0gTlJfQ09MUykge1xuICAgICAgICAgICAgbG9nZ2VyLmxvZygnV0FSTklORycsICdDYW5ub3QgaW5zZXJ0ICcgKyBieXRlLnRvU3RyaW5nKDE2KSArXG4gICAgICAgICAgICAgICAgICAgICAgICAnICgnICsgY2hhciArICcpIGF0IHBvc2l0aW9uICcgKyB0aGlzLnBvcyArICcuIFNraXBwaW5nIGl0IScpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2hhcnNbdGhpcy5wb3NdLnNldENoYXIoY2hhciwgdGhpcy5jdXJyUGVuU3RhdGUpO1xuICAgICAgICB0aGlzLm1vdmVDdXJzb3IoMSk7XG4gICAgfVxuXG4gICAgY2xlYXJGcm9tUG9zKHN0YXJ0UG9zKSB7XG4gICAgICAgIHZhciBpO1xuICAgICAgICBmb3IgKGkgPSBzdGFydFBvcyA7IGkgPCBOUl9DT0xTIDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLmNoYXJzW2ldLnJlc2V0KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjbGVhcigpIHtcbiAgICAgICAgdGhpcy5jbGVhckZyb21Qb3MoMCk7XG4gICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgdGhpcy5jdXJyUGVuU3RhdGUucmVzZXQoKTtcbiAgICB9XG5cbiAgICBjbGVhclRvRW5kT2ZSb3coKSB7XG4gICAgICAgIHRoaXMuY2xlYXJGcm9tUG9zKHRoaXMucG9zKTtcbiAgICB9XG5cbiAgICBnZXRUZXh0U3RyaW5nKCkge1xuICAgICAgICB2YXIgY2hhcnMgPSBbXTtcbiAgICAgICAgdmFyIGVtcHR5ID0gdHJ1ZTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAgOyBpIDwgTlJfQ09MUyA7IGkrKykge1xuICAgICAgICAgICAgdmFyIGNoYXIgPSB0aGlzLmNoYXJzW2ldLnVjaGFyO1xuICAgICAgICAgICAgaWYgKGNoYXIgIT09ICcgJykge1xuICAgICAgICAgICAgICAgIGVtcHR5ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGFycy5wdXNoKGNoYXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbXB0eSkge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGNoYXJzLmpvaW4oJycpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2V0UGVuU3R5bGVzKHN0eWxlcykge1xuICAgICAgICB0aGlzLmN1cnJQZW5TdGF0ZS5zZXRTdHlsZXMoc3R5bGVzKTtcbiAgICAgICAgdmFyIGN1cnJDaGFyID0gdGhpcy5jaGFyc1t0aGlzLnBvc107XG4gICAgICAgIGN1cnJDaGFyLnNldFBlblN0YXRlKHRoaXMuY3VyclBlblN0YXRlKTtcbiAgICB9XG59XG5cbi8qKlxuICogS2VlcCBhIENFQS02MDggc2NyZWVuIG9mIDMyeDE1IHN0eWxlZCBjaGFyYWN0ZXJzXG4gKiBAY29uc3RydWN0b3JcbiovXG5jbGFzcyBDYXB0aW9uU2NyZWVuIHtcblxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnJvd3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAgOyBpIDwgIE5SX1JPV1M7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5yb3dzLnB1c2gobmV3IFJvdygpKTsgLy8gTm90ZSB0aGF0IHdlIHVzZSB6ZXJvLWJhc2VkIG51bWJlcmluZyAoMC0xNClcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmN1cnJSb3cgPSBOUl9ST1dTIC0gMTtcbiAgICAgICAgdGhpcy5uclJvbGxVcFJvd3MgPSBudWxsO1xuICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgfVxuXG4gICAgcmVzZXQoKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwIDsgaSA8IE5SX1JPV1MgOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMucm93c1tpXS5jbGVhcigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY3VyclJvdyA9IE5SX1JPV1MgLSAxO1xuICAgIH1cblxuICAgIGVxdWFscyhvdGhlcikge1xuICAgICAgICB2YXIgZXF1YWwgPSB0cnVlO1xuICAgICAgICBmb3IgKHZhciBpID0gMCA7IGkgPCBOUl9ST1dTIDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMucm93c1tpXS5lcXVhbHMob3RoZXIucm93c1tpXSkpIHtcbiAgICAgICAgICAgICAgICBlcXVhbCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlcXVhbDtcbiAgICB9XG5cbiAgICBjb3B5KG90aGVyKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwIDsgaSA8IE5SX1JPV1MgOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMucm93c1tpXS5jb3B5KG90aGVyLnJvd3NbaV0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaXNFbXB0eSgpIHtcbiAgICAgICAgdmFyIGVtcHR5ID0gdHJ1ZTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAgOyBpIDwgTlJfUk9XUyA7IGkrKykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnJvd3NbaV0uaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICAgICAgZW1wdHkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZW1wdHk7XG4gICAgfVxuXG4gICAgYmFja1NwYWNlKCkge1xuICAgICAgICB2YXIgcm93ID0gdGhpcy5yb3dzW3RoaXMuY3VyclJvd107XG4gICAgICAgIHJvdy5iYWNrU3BhY2UoKTtcbiAgICB9XG5cbiAgICBjbGVhclRvRW5kT2ZSb3coKSB7XG4gICAgICAgIHZhciByb3cgPSB0aGlzLnJvd3NbdGhpcy5jdXJyUm93XTtcbiAgICAgICAgcm93LmNsZWFyVG9FbmRPZlJvdygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluc2VydCBhIGNoYXJhY3RlciAod2l0aG91dCBzdHlsaW5nKSBpbiB0aGUgY3VycmVudCByb3cuXG4gICAgICovXG4gICAgaW5zZXJ0Q2hhcihjaGFyKSB7XG4gICAgICAgIHZhciByb3cgPSB0aGlzLnJvd3NbdGhpcy5jdXJyUm93XTtcbiAgICAgICAgcm93Lmluc2VydENoYXIoY2hhcik7XG4gICAgfVxuXG4gICAgc2V0UGVuKHN0eWxlcykge1xuICAgICAgICB2YXIgcm93ID0gdGhpcy5yb3dzW3RoaXMuY3VyclJvd107XG4gICAgICAgIHJvdy5zZXRQZW5TdHlsZXMoc3R5bGVzKTtcbiAgICB9XG5cbiAgICBtb3ZlQ3Vyc29yKHJlbFBvcykge1xuICAgICAgICB2YXIgcm93ID0gdGhpcy5yb3dzW3RoaXMuY3VyclJvd107XG4gICAgICAgIHJvdy5tb3ZlQ3Vyc29yKHJlbFBvcyk7XG4gICAgfVxuXG4gICAgc2V0Q3Vyc29yKGFic1Bvcykge1xuICAgICAgICBsb2dnZXIubG9nKCdJTkZPJywgJ3NldEN1cnNvcjogJyArIGFic1Bvcyk7XG4gICAgICAgIHZhciByb3cgPSB0aGlzLnJvd3NbdGhpcy5jdXJyUm93XTtcbiAgICAgICAgcm93LnNldEN1cnNvcihhYnNQb3MpO1xuICAgIH1cblxuICAgIHNldFBBQyhwYWNEYXRhKSB7XG4gICAgICAgIGxvZ2dlci5sb2coJ0lORk8nLCAncGFjRGF0YSA9ICcgKyBKU09OLnN0cmluZ2lmeShwYWNEYXRhKSk7XG4gICAgICAgIHZhciBuZXdSb3cgPSBwYWNEYXRhLnJvdyAtIDE7XG4gICAgICAgIGlmICh0aGlzLm5yUm9sbFVwUm93cyAgJiYgbmV3Um93IDwgdGhpcy5uclJvbGxVcFJvd3MgLSAxKSB7XG4gICAgICAgICAgICAgICAgbmV3Um93ID0gdGhpcy5uclJvbGxVcFJvd3MtMTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vTWFrZSBzdXJlIHRoaXMgb25seSBhZmZlY3RzIFJvbGwtdXAgQ2FwdGlvbnMgYnkgY2hlY2tpbmcgdGhpcy5uclJvbGxVcFJvd3NcbiAgICAgICAgaWYgKHRoaXMubnJSb2xsVXBSb3dzICYmIHRoaXMuY3VyclJvdyAhPT0gbmV3Um93KSB7XG4gICAgICAgICAgLy9jbGVhciBhbGwgcm93cyBmaXJzdFxuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTlJfUk9XUzsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLnJvd3NbaV0uY2xlYXIoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvL0NvcHkgdGhpcy5uclJvbGxVcFJvd3Mgcm93cyBmcm9tIGxhc3RPdXRwdXRTY3JlZW4gYW5kIHBsYWNlIGl0IGluIHRoZSBuZXdSb3cgbG9jYXRpb25cbiAgICAgICAgICAvL3RvcFJvd0luZGV4IC0gdGhlIHN0YXJ0IG9mIHJvd3MgdG8gY29weSAoaW5jbHVzaXZlIGluZGV4KVxuICAgICAgICAgIHZhciB0b3BSb3dJbmRleCA9IHRoaXMuY3VyclJvdyArIDEgLSAodGhpcy5uclJvbGxVcFJvd3MpO1xuICAgICAgICAgIC8vV2Ugb25seSBjb3B5IGlmIHRoZSBsYXN0IHBvc2l0aW9uIHdhcyBhbHJlYWR5IHNob3duLlxuICAgICAgICAgIC8vV2UgdXNlIHRoZSBjdWVTdGFydFRpbWUgdmFsdWUgdG8gY2hlY2sgdGhpcy5cbiAgICAgICAgICBjb25zdCBsYXN0T3V0cHV0U2NyZWVuID0gdGhpcy5sYXN0T3V0cHV0U2NyZWVuO1xuICAgICAgICAgIGlmIChsYXN0T3V0cHV0U2NyZWVuKSB7XG4gICAgICAgICAgICB2YXIgcHJldkxpbmVUaW1lID0gbGFzdE91dHB1dFNjcmVlbi5yb3dzW3RvcFJvd0luZGV4XS5jdWVTdGFydFRpbWU7XG4gICAgICAgICAgICBpZihwcmV2TGluZVRpbWUgJiYgcHJldkxpbmVUaW1lIDwgbG9nZ2VyLnRpbWUpIHtcbiAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm5yUm9sbFVwUm93czsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yb3dzW25ld1Jvdy10aGlzLm5yUm9sbFVwUm93cytpKzFdLmNvcHkobGFzdE91dHB1dFNjcmVlbi5yb3dzW3RvcFJvd0luZGV4K2ldKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY3VyclJvdyA9IG5ld1JvdztcbiAgICAgICAgdmFyIHJvdyA9IHRoaXMucm93c1t0aGlzLmN1cnJSb3ddO1xuICAgICAgICBpZiAocGFjRGF0YS5pbmRlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBpbmRlbnQgPSBwYWNEYXRhLmluZGVudDtcbiAgICAgICAgICAgIHZhciBwcmV2UG9zID0gTWF0aC5tYXgoaW5kZW50LTEsIDApO1xuICAgICAgICAgICAgcm93LnNldEN1cnNvcihwYWNEYXRhLmluZGVudCk7XG4gICAgICAgICAgICBwYWNEYXRhLmNvbG9yID0gcm93LmNoYXJzW3ByZXZQb3NdLnBlblN0YXRlLmZvcmVncm91bmQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0eWxlcyA9IHtmb3JlZ3JvdW5kIDogcGFjRGF0YS5jb2xvciwgdW5kZXJsaW5lIDogcGFjRGF0YS51bmRlcmxpbmUsIGl0YWxpY3MgOiBwYWNEYXRhLml0YWxpY3MsIGJhY2tncm91bmQgOiAnYmxhY2snLCBmbGFzaCA6IGZhbHNlfTtcbiAgICAgICAgdGhpcy5zZXRQZW4oc3R5bGVzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgYmFja2dyb3VuZC9leHRyYSBmb3JlZ3JvdW5kLCBidXQgZmlyc3QgZG8gYmFja19zcGFjZSwgYW5kIHRoZW4gaW5zZXJ0IHNwYWNlIChiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSkuXG4gICAgICovXG4gICAgc2V0QmtnRGF0YShia2dEYXRhKSB7XG5cbiAgICAgICAgbG9nZ2VyLmxvZygnSU5GTycsICdia2dEYXRhID0gJyArIEpTT04uc3RyaW5naWZ5KGJrZ0RhdGEpKTtcbiAgICAgICAgdGhpcy5iYWNrU3BhY2UoKTtcbiAgICAgICAgdGhpcy5zZXRQZW4oYmtnRGF0YSk7XG4gICAgICAgIHRoaXMuaW5zZXJ0Q2hhcigweDIwKTsgLy9TcGFjZVxuICAgIH1cblxuICAgIHNldFJvbGxVcFJvd3MobnJSb3dzKSB7XG4gICAgICAgIHRoaXMubnJSb2xsVXBSb3dzID0gbnJSb3dzO1xuICAgIH1cblxuICAgIHJvbGxVcCgpIHtcbiAgICAgICAgaWYgKHRoaXMubnJSb2xsVXBSb3dzID09PSBudWxsKSB7XG4gICAgICAgICAgICBsb2dnZXIubG9nKCdERUJVRycsICdyb2xsX3VwIGJ1dCBuclJvbGxVcFJvd3Mgbm90IHNldCB5ZXQnKTtcbiAgICAgICAgICAgIHJldHVybjsgLy9Ob3QgcHJvcGVybHkgc2V0dXBcbiAgICAgICAgfVxuICAgICAgICBsb2dnZXIubG9nKCdURVhUJywgdGhpcy5nZXREaXNwbGF5VGV4dCgpKTtcbiAgICAgICAgdmFyIHRvcFJvd0luZGV4ID0gdGhpcy5jdXJyUm93ICsgMSAtIHRoaXMubnJSb2xsVXBSb3dzO1xuICAgICAgICB2YXIgdG9wUm93ID0gdGhpcy5yb3dzLnNwbGljZSh0b3BSb3dJbmRleCwgMSlbMF07XG4gICAgICAgIHRvcFJvdy5jbGVhcigpO1xuICAgICAgICB0aGlzLnJvd3Muc3BsaWNlKHRoaXMuY3VyclJvdywgMCwgdG9wUm93KTtcbiAgICAgICAgbG9nZ2VyLmxvZygnSU5GTycsICdSb2xsaW5nIHVwJyk7XG4gICAgICAgIC8vbG9nZ2VyLmxvZygnVEVYVCcsIHRoaXMuZ2V0X2Rpc3BsYXlfdGV4dCgpKVxuICAgIH1cblxuICAgLyoqXG4gICAgKiBHZXQgYWxsIG5vbi1lbXB0eSByb3dzIHdpdGggYXMgdW5pY29kZSB0ZXh0LlxuICAgICovXG4gICAgZ2V0RGlzcGxheVRleHQoYXNPbmVSb3cpIHtcbiAgICAgICAgYXNPbmVSb3cgPSBhc09uZVJvdyB8fCBmYWxzZTtcbiAgICAgICAgdmFyIGRpc3BsYXlUZXh0ID0gW107XG4gICAgICAgIHZhciB0ZXh0ID0gJyc7XG4gICAgICAgIHZhciByb3dOciA9IC0xO1xuICAgICAgICBmb3IgKHZhciBpID0gMCA7IGkgPCBOUl9ST1dTIDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcm93VGV4dCA9IHRoaXMucm93c1tpXS5nZXRUZXh0U3RyaW5nKCk7XG4gICAgICAgICAgICBpZiAocm93VGV4dCkge1xuICAgICAgICAgICAgICAgIHJvd05yID0gaSsxO1xuICAgICAgICAgICAgICAgIGlmIChhc09uZVJvdykge1xuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5VGV4dC5wdXNoKCdSb3cgJyArIHJvd05yICsgJzogXFwnJyArIHJvd1RleHQgKyAnXFwnJyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheVRleHQucHVzaChyb3dUZXh0LnRyaW0oKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChkaXNwbGF5VGV4dC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBpZiAoYXNPbmVSb3cpIHtcbiAgICAgICAgICAgICAgICB0ZXh0ID0gJ1snICsgZGlzcGxheVRleHQuam9pbignIHwgJykgKyAnXSc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRleHQgPSBkaXNwbGF5VGV4dC5qb2luKCdcXG4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGV4dDtcbiAgICB9XG5cbiAgICBnZXRUZXh0QW5kRm9ybWF0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yb3dzO1xuICAgIH1cbn1cblxuLy92YXIgbW9kZXMgPSBbJ01PREVfUk9MTC1VUCcsICdNT0RFX1BPUC1PTicsICdNT0RFX1BBSU5ULU9OJywgJ01PREVfVEVYVCddO1xuXG5jbGFzcyBDZWE2MDhDaGFubmVsXG57XG4gICAgY29uc3RydWN0b3IoY2hhbm5lbE51bWJlciwgb3V0cHV0RmlsdGVyKSB7XG5cbiAgICAgICAgdGhpcy5jaE5yID0gY2hhbm5lbE51bWJlcjtcbiAgICAgICAgdGhpcy5vdXRwdXRGaWx0ZXIgPSBvdXRwdXRGaWx0ZXI7XG4gICAgICAgIHRoaXMubW9kZSA9IG51bGw7XG4gICAgICAgIHRoaXMudmVyYm9zZSA9IDA7XG4gICAgICAgIHRoaXMuZGlzcGxheWVkTWVtb3J5ID0gbmV3IENhcHRpb25TY3JlZW4oKTtcbiAgICAgICAgdGhpcy5ub25EaXNwbGF5ZWRNZW1vcnkgPSBuZXcgQ2FwdGlvblNjcmVlbigpO1xuICAgICAgICB0aGlzLmxhc3RPdXRwdXRTY3JlZW4gPSBuZXcgQ2FwdGlvblNjcmVlbigpO1xuICAgICAgICB0aGlzLmN1cnJSb2xsVXBSb3cgPSB0aGlzLmRpc3BsYXllZE1lbW9yeS5yb3dzW05SX1JPV1MtMV07XG4gICAgICAgIHRoaXMud3JpdGVTY3JlZW4gPSB0aGlzLmRpc3BsYXllZE1lbW9yeTtcbiAgICAgICAgdGhpcy5tb2RlID0gbnVsbDtcbiAgICAgICAgdGhpcy5jdWVTdGFydFRpbWUgPSBudWxsOyAvLyBLZWVwcyB0cmFjayBvZiB3aGVyZSBhIGN1ZSBzdGFydGVkLlxuICAgIH1cblxuICAgIHJlc2V0KCkge1xuICAgICAgICB0aGlzLm1vZGUgPSBudWxsO1xuICAgICAgICB0aGlzLmRpc3BsYXllZE1lbW9yeS5yZXNldCgpO1xuICAgICAgICB0aGlzLm5vbkRpc3BsYXllZE1lbW9yeS5yZXNldCgpO1xuICAgICAgICB0aGlzLmxhc3RPdXRwdXRTY3JlZW4ucmVzZXQoKTtcbiAgICAgICAgdGhpcy5jdXJyUm9sbFVwUm93ID0gdGhpcy5kaXNwbGF5ZWRNZW1vcnkucm93c1tOUl9ST1dTLTFdO1xuICAgICAgICB0aGlzLndyaXRlU2NyZWVuID0gdGhpcy5kaXNwbGF5ZWRNZW1vcnk7XG4gICAgICAgIHRoaXMubW9kZSA9IG51bGw7XG4gICAgICAgIHRoaXMuY3VlU3RhcnRUaW1lID0gbnVsbDtcbiAgICAgICAgdGhpcy5sYXN0Q3VlRW5kVGltZSA9IG51bGw7XG4gICAgfVxuXG4gICAgZ2V0SGFuZGxlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3V0cHV0RmlsdGVyO1xuICAgIH1cblxuICAgIHNldEhhbmRsZXIobmV3SGFuZGxlcikge1xuICAgICAgICB0aGlzLm91dHB1dEZpbHRlciA9IG5ld0hhbmRsZXI7XG4gICAgfVxuXG4gICAgc2V0UEFDKHBhY0RhdGEpIHtcbiAgICAgICAgdGhpcy53cml0ZVNjcmVlbi5zZXRQQUMocGFjRGF0YSk7XG4gICAgfVxuXG4gICAgc2V0QmtnRGF0YShia2dEYXRhKSB7XG4gICAgICAgIHRoaXMud3JpdGVTY3JlZW4uc2V0QmtnRGF0YShia2dEYXRhKTtcbiAgICB9XG5cbiAgICBzZXRNb2RlKG5ld01vZGUpIHtcbiAgICAgICAgaWYgKG5ld01vZGUgPT09IHRoaXMubW9kZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubW9kZSA9IG5ld01vZGU7XG4gICAgICAgIGxvZ2dlci5sb2coJ0lORk8nLCAnTU9ERT0nICsgbmV3TW9kZSk7XG4gICAgICAgIGlmICh0aGlzLm1vZGUgPT09ICdNT0RFX1BPUC1PTicpIHtcbiAgICAgICAgICAgIHRoaXMud3JpdGVTY3JlZW4gPSB0aGlzLm5vbkRpc3BsYXllZE1lbW9yeTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMud3JpdGVTY3JlZW4gPSB0aGlzLmRpc3BsYXllZE1lbW9yeTtcbiAgICAgICAgICAgIHRoaXMud3JpdGVTY3JlZW4ucmVzZXQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5tb2RlICE9PSAnTU9ERV9ST0xMLVVQJykge1xuICAgICAgICAgICAgdGhpcy5kaXNwbGF5ZWRNZW1vcnkubnJSb2xsVXBSb3dzID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMubm9uRGlzcGxheWVkTWVtb3J5Lm5yUm9sbFVwUm93cyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tb2RlID0gbmV3TW9kZTtcbiAgICB9XG5cbiAgICBpbnNlcnRDaGFycyhjaGFycykge1xuICAgICAgICBmb3IgKHZhciBpID0gMCA7IGkgPCBjaGFycy5sZW5ndGggOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMud3JpdGVTY3JlZW4uaW5zZXJ0Q2hhcihjaGFyc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNjcmVlbiA9IHRoaXMud3JpdGVTY3JlZW4gPT09IHRoaXMuZGlzcGxheWVkTWVtb3J5ID8gJ0RJU1AnIDogJ05PTl9ESVNQJztcbiAgICAgICAgbG9nZ2VyLmxvZygnSU5GTycsIHNjcmVlbiArICc6ICcgKyB0aGlzLndyaXRlU2NyZWVuLmdldERpc3BsYXlUZXh0KHRydWUpKTtcbiAgICAgICAgaWYgKHRoaXMubW9kZSA9PT0gJ01PREVfUEFJTlQtT04nIHx8IHRoaXMubW9kZSA9PT0gJ01PREVfUk9MTC1VUCcpIHtcbiAgICAgICAgICAgIGxvZ2dlci5sb2coJ1RFWFQnLCAnRElTUExBWUVEOiAnICsgdGhpcy5kaXNwbGF5ZWRNZW1vcnkuZ2V0RGlzcGxheVRleHQodHJ1ZSkpO1xuICAgICAgICAgICAgdGhpcy5vdXRwdXREYXRhVXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjY1JDTCgpIHsgLy8gUmVzdW1lIENhcHRpb24gTG9hZGluZyAoc3dpdGNoIG1vZGUgdG8gUG9wIE9uKVxuICAgICAgICBsb2dnZXIubG9nKCdJTkZPJywgJ1JDTCAtIFJlc3VtZSBDYXB0aW9uIExvYWRpbmcnKTtcbiAgICAgICAgdGhpcy5zZXRNb2RlKCdNT0RFX1BPUC1PTicpO1xuICAgIH1cblxuICAgIGNjQlMoKSB7IC8vIEJhY2tTcGFjZVxuICAgICAgICBsb2dnZXIubG9nKCdJTkZPJywgJ0JTIC0gQmFja1NwYWNlJyk7XG4gICAgICAgIGlmICh0aGlzLm1vZGUgPT09ICdNT0RFX1RFWFQnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53cml0ZVNjcmVlbi5iYWNrU3BhY2UoKTtcbiAgICAgICAgaWYgKHRoaXMud3JpdGVTY3JlZW4gPT09IHRoaXMuZGlzcGxheWVkTWVtb3J5KSB7XG4gICAgICAgICAgICB0aGlzLm91dHB1dERhdGFVcGRhdGUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNjQU9GKCkgeyAvLyBSZXNlcnZlZCAoZm9ybWVybHkgQWxhcm0gT2ZmKVxuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY2NBT04oKSB7IC8vIFJlc2VydmVkIChmb3JtZXJseSBBbGFybSBPbilcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNjREVSKCkgeyAvLyBEZWxldGUgdG8gRW5kIG9mIFJvd1xuICAgICAgICBsb2dnZXIubG9nKCdJTkZPJywgJ0RFUi0gRGVsZXRlIHRvIEVuZCBvZiBSb3cnKTtcbiAgICAgICAgdGhpcy53cml0ZVNjcmVlbi5jbGVhclRvRW5kT2ZSb3coKTtcbiAgICAgICAgdGhpcy5vdXRwdXREYXRhVXBkYXRlKCk7XG4gICAgfVxuXG4gICAgY2NSVShuclJvd3MpIHsgLy9Sb2xsLVVwIENhcHRpb25zLTIsMyxvciA0IFJvd3NcbiAgICAgICAgbG9nZ2VyLmxvZygnSU5GTycsICdSVSgnICsgbnJSb3dzICsnKSAtIFJvbGwgVXAnKTtcbiAgICAgICAgdGhpcy53cml0ZVNjcmVlbiA9IHRoaXMuZGlzcGxheWVkTWVtb3J5O1xuICAgICAgICB0aGlzLnNldE1vZGUoJ01PREVfUk9MTC1VUCcpO1xuICAgICAgICB0aGlzLndyaXRlU2NyZWVuLnNldFJvbGxVcFJvd3MobnJSb3dzKTtcbiAgICB9XG5cbiAgICBjY0ZPTigpIHsgLy9GbGFzaCBPblxuICAgICAgICBsb2dnZXIubG9nKCdJTkZPJywgJ0ZPTiAtIEZsYXNoIE9uJyk7XG4gICAgICAgIHRoaXMud3JpdGVTY3JlZW4uc2V0UGVuKHtmbGFzaCA6IHRydWV9KTtcbiAgICB9XG5cbiAgICBjY1JEQygpIHsgLy8gUmVzdW1lIERpcmVjdCBDYXB0aW9uaW5nIChzd2l0Y2ggbW9kZSB0byBQYWludE9uKVxuICAgICAgICBsb2dnZXIubG9nKCdJTkZPJywgJ1JEQyAtIFJlc3VtZSBEaXJlY3QgQ2FwdGlvbmluZycpO1xuICAgICAgICB0aGlzLnNldE1vZGUoJ01PREVfUEFJTlQtT04nKTtcbiAgICB9XG5cbiAgICBjY1RSKCkgeyAvLyBUZXh0IFJlc3RhcnQgaW4gdGV4dCBtb2RlIChub3Qgc3VwcG9ydGVkLCBob3dldmVyKVxuICAgICAgICBsb2dnZXIubG9nKCdJTkZPJywgJ1RSJyk7XG4gICAgICAgIHRoaXMuc2V0TW9kZSgnTU9ERV9URVhUJyk7XG4gICAgfVxuXG4gICAgY2NSVEQoKSB7IC8vIFJlc3VtZSBUZXh0IERpc3BsYXkgaW4gVGV4dCBtb2RlIChub3Qgc3VwcG9ydGVkLCBob3dldmVyKVxuICAgICAgICBsb2dnZXIubG9nKCdJTkZPJywgJ1JURCcpO1xuICAgICAgICB0aGlzLnNldE1vZGUoJ01PREVfVEVYVCcpO1xuICAgIH1cblxuICAgIGNjRURNKCkgeyAvLyBFcmFzZSBEaXNwbGF5ZWQgTWVtb3J5XG4gICAgICAgIGxvZ2dlci5sb2coJ0lORk8nLCAnRURNIC0gRXJhc2UgRGlzcGxheWVkIE1lbW9yeScpO1xuICAgICAgICB0aGlzLmRpc3BsYXllZE1lbW9yeS5yZXNldCgpO1xuICAgICAgICB0aGlzLm91dHB1dERhdGFVcGRhdGUoKTtcbiAgICB9XG5cbiAgICBjY0NSKCkgeyAvLyBDYXJyaWFnZSBSZXR1cm5cbiAgICAgICAgbG9nZ2VyLmxvZygnQ1IgLSBDYXJyaWFnZSBSZXR1cm4nKTtcbiAgICAgICAgdGhpcy53cml0ZVNjcmVlbi5yb2xsVXAoKTtcbiAgICAgICAgdGhpcy5vdXRwdXREYXRhVXBkYXRlKCk7XG4gICAgfVxuXG4gICAgY2NFTk0oKSB7IC8vRXJhc2UgTm9uLURpc3BsYXllZCBNZW1vcnlcbiAgICAgICAgbG9nZ2VyLmxvZygnSU5GTycsICdFTk0gLSBFcmFzZSBOb24tZGlzcGxheWVkIE1lbW9yeScpO1xuICAgICAgICB0aGlzLm5vbkRpc3BsYXllZE1lbW9yeS5yZXNldCgpO1xuICAgIH1cblxuICAgIGNjRU9DKCkgeyAvL0VuZCBvZiBDYXB0aW9uIChGbGlwIE1lbW9yaWVzKVxuICAgICAgICBsb2dnZXIubG9nKCdJTkZPJywgJ0VPQyAtIEVuZCBPZiBDYXB0aW9uJyk7XG4gICAgICAgIGlmICh0aGlzLm1vZGUgPT09ICdNT0RFX1BPUC1PTicpIHtcbiAgICAgICAgICAgIHZhciB0bXAgPSB0aGlzLmRpc3BsYXllZE1lbW9yeTtcbiAgICAgICAgICAgIHRoaXMuZGlzcGxheWVkTWVtb3J5ID0gdGhpcy5ub25EaXNwbGF5ZWRNZW1vcnk7XG4gICAgICAgICAgICB0aGlzLm5vbkRpc3BsYXllZE1lbW9yeSA9IHRtcDtcbiAgICAgICAgICAgIHRoaXMud3JpdGVTY3JlZW4gPSB0aGlzLm5vbkRpc3BsYXllZE1lbW9yeTtcbiAgICAgICAgICAgIGxvZ2dlci5sb2coJ1RFWFQnLCAnRElTUDogJyArIHRoaXMuZGlzcGxheWVkTWVtb3J5LmdldERpc3BsYXlUZXh0KCkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3V0cHV0RGF0YVVwZGF0ZSgpO1xuICAgIH1cblxuICAgIGNjVE8obnJDb2xzKSB7IC8vIFRhYiBPZmZzZXQgMSwyLCBvciAzIGNvbHVtbnNcbiAgICAgICAgbG9nZ2VyLmxvZygnSU5GTycsICdUTygnICsgbnJDb2xzICsgJykgLSBUYWIgT2Zmc2V0Jyk7XG4gICAgICAgIHRoaXMud3JpdGVTY3JlZW4ubW92ZUN1cnNvcihuckNvbHMpO1xuICAgIH1cblxuICAgIGNjTUlEUk9XKHNlY29uZEJ5dGUpIHsgLy8gUGFyc2UgTUlEUk9XIGNvbW1hbmRcbiAgICAgICAgdmFyIHN0eWxlcyA9IHtmbGFzaCA6IGZhbHNlfTtcbiAgICAgICAgc3R5bGVzLnVuZGVybGluZSA9IHNlY29uZEJ5dGUgJSAyID09PSAxO1xuICAgICAgICBzdHlsZXMuaXRhbGljcyA9IHNlY29uZEJ5dGUgPj0gMHgyZTtcbiAgICAgICAgaWYgKCFzdHlsZXMuaXRhbGljcykge1xuICAgICAgICAgICAgdmFyIGNvbG9ySW5kZXggPSBNYXRoLmZsb29yKHNlY29uZEJ5dGUvMikgLSAweDEwO1xuICAgICAgICAgICAgdmFyIGNvbG9ycyA9IFsnd2hpdGUnLCAnZ3JlZW4nLCAnYmx1ZScsICdjeWFuJywgJ3JlZCcsICd5ZWxsb3cnLCAnbWFnZW50YSddO1xuICAgICAgICAgICAgc3R5bGVzLmZvcmVncm91bmQgPSBjb2xvcnNbY29sb3JJbmRleF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdHlsZXMuZm9yZWdyb3VuZCA9ICd3aGl0ZSc7XG4gICAgICAgIH1cbiAgICAgICAgbG9nZ2VyLmxvZygnSU5GTycsICdNSURST1c6ICcgKyBKU09OLnN0cmluZ2lmeShzdHlsZXMpKTtcbiAgICAgICAgdGhpcy53cml0ZVNjcmVlbi5zZXRQZW4oc3R5bGVzKTtcbiAgICB9XG5cbiAgICBvdXRwdXREYXRhVXBkYXRlKCkge1xuICAgICAgICB2YXIgdCA9IGxvZ2dlci50aW1lO1xuICAgICAgICBpZiAodCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm91dHB1dEZpbHRlcikge1xuICAgICAgICAgICAgaWYgKHRoaXMub3V0cHV0RmlsdGVyLnVwZGF0ZURhdGEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm91dHB1dEZpbHRlci51cGRhdGVEYXRhKHQsIHRoaXMuZGlzcGxheWVkTWVtb3J5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmN1ZVN0YXJ0VGltZSA9PT0gbnVsbCAmJiAhdGhpcy5kaXNwbGF5ZWRNZW1vcnkuaXNFbXB0eSgpKSB7IC8vIFN0YXJ0IG9mIGEgbmV3IGN1ZVxuICAgICAgICAgICAgICAgIHRoaXMuY3VlU3RhcnRUaW1lID0gdDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmRpc3BsYXllZE1lbW9yeS5lcXVhbHModGhpcy5sYXN0T3V0cHV0U2NyZWVuKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5vdXRwdXRGaWx0ZXIubmV3Q3VlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm91dHB1dEZpbHRlci5uZXdDdWUodGhpcy5jdWVTdGFydFRpbWUsIHQsIHRoaXMubGFzdE91dHB1dFNjcmVlbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdWVTdGFydFRpbWUgPSB0aGlzLmRpc3BsYXllZE1lbW9yeS5pc0VtcHR5KCkgPyBudWxsIDogdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmxhc3RPdXRwdXRTY3JlZW4uY29weSh0aGlzLmRpc3BsYXllZE1lbW9yeSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjdWVTcGxpdEF0VGltZSh0KSB7XG4gICAgICAgIGlmICh0aGlzLm91dHB1dEZpbHRlcikge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmRpc3BsYXllZE1lbW9yeS5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vdXRwdXRGaWx0ZXIubmV3Q3VlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3V0cHV0RmlsdGVyLm5ld0N1ZSh0aGlzLmN1ZVN0YXJ0VGltZSwgdCwgdGhpcy5kaXNwbGF5ZWRNZW1vcnkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmN1ZVN0YXJ0VGltZSA9IHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNsYXNzIENlYTYwOFBhcnNlciB7XG5cbiAgICBjb25zdHJ1Y3RvcihmaWVsZCwgb3V0MSwgb3V0Mikge1xuICAgICAgICB0aGlzLmZpZWxkID0gZmllbGQgfHwgMTtcbiAgICAgICAgdGhpcy5vdXRwdXRzID0gW291dDEsIG91dDJdO1xuICAgICAgICB0aGlzLmNoYW5uZWxzID0gW25ldyBDZWE2MDhDaGFubmVsKDEsIG91dDEpLCBuZXcgQ2VhNjA4Q2hhbm5lbCgyLCBvdXQyKV07XG4gICAgICAgIHRoaXMuY3VyckNoTnIgPSAtMTsgLy8gV2lsbCBiZSAxIG9yIDJcbiAgICAgICAgdGhpcy5sYXN0Q21kQSA9IG51bGw7IC8vIEZpcnN0IGJ5dGUgb2YgbGFzdCBjb21tYW5kXG4gICAgICAgIHRoaXMubGFzdENtZEIgPSBudWxsOyAvLyBTZWNvbmQgYnl0ZSBvZiBsYXN0IGNvbW1hbmRcbiAgICAgICAgdGhpcy5idWZmZXJlZERhdGEgPSBbXTtcbiAgICAgICAgdGhpcy5zdGFydFRpbWUgPSBudWxsO1xuICAgICAgICB0aGlzLmxhc3RUaW1lID0gbnVsbDtcbiAgICAgICAgdGhpcy5kYXRhQ291bnRlcnMgPSB7J3BhZGRpbmcnIDogMCwgJ2NoYXInIDogMCwgJ2NtZCcgOiAwLCAnb3RoZXInIDogMH07XG4gICAgfVxuXG4gICAgZ2V0SGFuZGxlcihpbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGFubmVsc1tpbmRleF0uZ2V0SGFuZGxlcigpO1xuICAgIH1cblxuICAgIHNldEhhbmRsZXIoaW5kZXgsIG5ld0hhbmRsZXIpIHtcbiAgICAgICAgdGhpcy5jaGFubmVsc1tpbmRleF0uc2V0SGFuZGxlcihuZXdIYW5kbGVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGQgZGF0YSBmb3IgdGltZSB0IGluIGZvcm1zIG9mIGxpc3Qgb2YgYnl0ZXMgKHVuc2lnbmVkIGludHMpLiBUaGUgYnl0ZXMgYXJlIHRyZWF0ZWQgYXMgcGFpcnMuXG4gICAgICovXG4gICAgYWRkRGF0YSh0LCBieXRlTGlzdCkge1xuICAgICAgICB2YXIgY21kRm91bmQsIGEsIGIsXG4gICAgICAgIGNoYXJzRm91bmQgPSBmYWxzZTtcblxuICAgICAgICB0aGlzLmxhc3RUaW1lID0gdDtcbiAgICAgICAgbG9nZ2VyLnNldFRpbWUodCk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAgOyBpIDwgYnl0ZUxpc3QubGVuZ3RoIDsgaSs9Mikge1xuICAgICAgICAgICAgYSA9IGJ5dGVMaXN0W2ldICYgMHg3ZjtcbiAgICAgICAgICAgIGIgPSBieXRlTGlzdFtpKzFdICYgMHg3ZjtcbiAgICAgICAgICAgIGlmIChhID09PSAwICYmIGIgPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGFDb3VudGVycy5wYWRkaW5nICs9IDI7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxvZ2dlci5sb2coJ0RBVEEnLCAnWycgKyBudW1BcnJheVRvSGV4QXJyYXkoW2J5dGVMaXN0W2ldLCBieXRlTGlzdFtpKzFdXSkgKyddIC0+ICgnICsgbnVtQXJyYXlUb0hleEFycmF5KFthLCBiXSkgKyAnKScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY21kRm91bmQgPSB0aGlzLnBhcnNlQ21kKGEsIGIpO1xuICAgICAgICAgICAgaWYgKCFjbWRGb3VuZCkge1xuICAgICAgICAgICAgICAgIGNtZEZvdW5kID0gdGhpcy5wYXJzZU1pZHJvdyhhLCBiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghY21kRm91bmQpIHtcbiAgICAgICAgICAgICAgICBjbWRGb3VuZCA9IHRoaXMucGFyc2VQQUMoYSwgYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWNtZEZvdW5kKSB7XG4gICAgICAgICAgICAgICAgY21kRm91bmQgPSB0aGlzLnBhcnNlQmFja2dyb3VuZEF0dHJpYnV0ZXMoYSwgYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWNtZEZvdW5kKSB7XG4gICAgICAgICAgICAgICAgY2hhcnNGb3VuZCA9IHRoaXMucGFyc2VDaGFycyhhLCBiKTtcbiAgICAgICAgICAgICAgICBpZiAoY2hhcnNGb3VuZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jdXJyQ2hOciAmJiB0aGlzLmN1cnJDaE5yID49MCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNoYW5uZWwgPSB0aGlzLmNoYW5uZWxzW3RoaXMuY3VyckNoTnItMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFubmVsLmluc2VydENoYXJzKGNoYXJzRm91bmQpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmxvZygnV0FSTklORycsICdObyBjaGFubmVsIGZvdW5kIHlldC4gVEVYVC1NT0RFPycpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNtZEZvdW5kKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhQ291bnRlcnMuY21kICs9IDI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNoYXJzRm91bmQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGFDb3VudGVycy5jaGFyICs9IDI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZGF0YUNvdW50ZXJzLm90aGVyICs9IDI7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmxvZygnV0FSTklORycsICdDb3VsZG5cXCd0IHBhcnNlIGNsZWFuZWQgZGF0YSAnICsgbnVtQXJyYXlUb0hleEFycmF5KFthLCBiXSkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICcgb3JpZzogJyArIG51bUFycmF5VG9IZXhBcnJheShbYnl0ZUxpc3RbaV0sIGJ5dGVMaXN0W2krMV1dKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXJzZSBDb21tYW5kLlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSBUZWxscyBpZiBhIGNvbW1hbmQgd2FzIGZvdW5kXG4gICAgICovXG4gICAgcGFyc2VDbWQoYSwgYikge1xuICAgICAgICB2YXIgY2hOciA9IG51bGw7XG5cbiAgICAgICAgdmFyIGNvbmQxID0gKGEgPT09IDB4MTQgfHwgYSA9PT0gMHgxQykgJiYgKDB4MjAgPD0gYiAmJiBiIDw9IDB4MkYpO1xuICAgICAgICB2YXIgY29uZDIgPSAoYSA9PT0gMHgxNyB8fCBhID09PSAweDFGKSAmJiAoMHgyMSA8PSBiICYmIGIgPD0gMHgyMyk7XG4gICAgICAgIGlmICghKGNvbmQxIHx8IGNvbmQyKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGEgPT09IHRoaXMubGFzdENtZEEgJiYgYiA9PT0gdGhpcy5sYXN0Q21kQikge1xuICAgICAgICAgICAgdGhpcy5sYXN0Q21kQSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmxhc3RDbWRCID0gbnVsbDsgLy8gUmVwZWF0ZWQgY29tbWFuZHMgYXJlIGRyb3BwZWQgKG9uY2UpXG4gICAgICAgICAgICBsb2dnZXIubG9nKCdERUJVRycsICdSZXBlYXRlZCBjb21tYW5kICgnICsgbnVtQXJyYXlUb0hleEFycmF5KFthLCBiXSkgKyAnKSBpcyBkcm9wcGVkJyk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhID09PSAweDE0IHx8IGEgPT09IDB4MTcpIHtcbiAgICAgICAgICAgIGNoTnIgPSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2hOciA9IDI7IC8vIChhID09PSAweDFDIHx8IGE9PT0gMHgxZilcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjaGFubmVsID0gdGhpcy5jaGFubmVsc1tjaE5yIC0gMV07XG5cbiAgICAgICAgaWYgKGEgPT09IDB4MTQgfHwgYSA9PT0gMHgxQykge1xuICAgICAgICAgICAgaWYgKGIgPT09IDB4MjApIHtcbiAgICAgICAgICAgICAgICBjaGFubmVsLmNjUkNMKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGIgPT09IDB4MjEpIHtcbiAgICAgICAgICAgICAgICBjaGFubmVsLmNjQlMoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyMikge1xuICAgICAgICAgICAgICAgIGNoYW5uZWwuY2NBT0YoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyMykge1xuICAgICAgICAgICAgICAgIGNoYW5uZWwuY2NBT04oKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyNCkge1xuICAgICAgICAgICAgICAgIGNoYW5uZWwuY2NERVIoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyNSkge1xuICAgICAgICAgICAgICAgIGNoYW5uZWwuY2NSVSgyKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyNikge1xuICAgICAgICAgICAgICAgIGNoYW5uZWwuY2NSVSgzKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyNykge1xuICAgICAgICAgICAgICAgIGNoYW5uZWwuY2NSVSg0KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyOCkge1xuICAgICAgICAgICAgICAgIGNoYW5uZWwuY2NGT04oKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyOSkge1xuICAgICAgICAgICAgICAgIGNoYW5uZWwuY2NSREMoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyQSkge1xuICAgICAgICAgICAgICAgIGNoYW5uZWwuY2NUUigpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChiID09PSAweDJCKSB7XG4gICAgICAgICAgICAgICAgY2hhbm5lbC5jY1JURCgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChiID09PSAweDJDKSB7XG4gICAgICAgICAgICAgICAgY2hhbm5lbC5jY0VETSgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChiID09PSAweDJEKSB7XG4gICAgICAgICAgICAgICAgY2hhbm5lbC5jY0NSKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGIgPT09IDB4MkUpIHtcbiAgICAgICAgICAgICAgICBjaGFubmVsLmNjRU5NKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGIgPT09IDB4MkYpIHtcbiAgICAgICAgICAgICAgICBjaGFubmVsLmNjRU9DKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7IC8vYSA9PSAweDE3IHx8IGEgPT0gMHgxRlxuICAgICAgICAgICAgY2hhbm5lbC5jY1RPKGIgLSAweDIwKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxhc3RDbWRBID0gYTtcbiAgICAgICAgdGhpcy5sYXN0Q21kQiA9IGI7XG4gICAgICAgIHRoaXMuY3VyckNoTnIgPSBjaE5yO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXJzZSBtaWRyb3cgc3R5bGluZyBjb21tYW5kXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgcGFyc2VNaWRyb3coYSwgYikge1xuICAgICAgICB2YXIgY2hOciA9IG51bGw7XG5cbiAgICAgICAgaWYgKCAoKGEgPT09IDB4MTEpIHx8IChhID09PSAweDE5KSkgJiYgMHgyMCA8PSBiICYmIGIgPD0gMHgyZikge1xuICAgICAgICAgICAgaWYgKGEgPT09IDB4MTEpIHtcbiAgICAgICAgICAgICAgICBjaE5yID0gMTtcbiAgICAgICAgICAgIH0gZWxzZSAge1xuICAgICAgICAgICAgICAgIGNoTnIgPSAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNoTnIgIT09IHRoaXMuY3VyckNoTnIpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIubG9nKCdFUlJPUicsICdNaXNtYXRjaCBjaGFubmVsIGluIG1pZHJvdyBwYXJzaW5nJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGNoYW5uZWwgPSB0aGlzLmNoYW5uZWxzW2NoTnItMV07XG4gICAgICAgICAgICBjaGFubmVsLmNjTUlEUk9XKGIpO1xuICAgICAgICAgICAgbG9nZ2VyLmxvZygnREVCVUcnLCAnTUlEUk9XICgnICsgbnVtQXJyYXlUb0hleEFycmF5KFthLCBiXSkgKyAnKScpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXJzZSBQcmVhYmxlIEFjY2VzcyBDb2RlcyAoVGFibGUgNTMpLlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSBUZWxscyBpZiBQQUMgZm91bmRcbiAgICAgKi9cbiAgICBwYXJzZVBBQyhhLCBiKSB7XG5cbiAgICAgICB2YXIgY2hOciA9IG51bGw7XG4gICAgICAgdmFyIHJvdyA9IG51bGw7XG5cbiAgICAgICAgdmFyIGNhc2UxID0gKCgweDExIDw9IGEgICYmIGEgPD0gMHgxNykgfHwgKDB4MTkgPD0gYSAmJiBhIDw9IDB4MUYpKSAmJiAoMHg0MCA8PSBiICYmIGIgPD0gMHg3Rik7XG4gICAgICAgIHZhciBjYXNlMiA9IChhID09PSAweDEwIHx8IGEgPT09IDB4MTgpICYmICgweDQwIDw9IGIgJiYgYiA8PSAweDVGKTtcbiAgICAgICAgaWYgKCEgKGNhc2UxIHx8IGNhc2UyKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGEgPT09IHRoaXMubGFzdENtZEEgJiYgYiA9PT0gdGhpcy5sYXN0Q21kQikge1xuICAgICAgICAgICAgdGhpcy5sYXN0Q21kQSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmxhc3RDbWRCID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiB0cnVlOyAvLyBSZXBlYXRlZCBjb21tYW5kcyBhcmUgZHJvcHBlZCAob25jZSlcbiAgICAgICAgfVxuXG4gICAgICAgIGNoTnIgPSAoYSA8PSAweDE3KSA/IDEgOiAyO1xuXG4gICAgICAgIGlmICgweDQwIDw9IGIgJiYgYiA8PSAweDVGKSB7XG4gICAgICAgICAgICByb3cgPSAoY2hOciA9PT0gMSkgPyByb3dzTG93Q2gxW2FdIDogcm93c0xvd0NoMlthXTtcbiAgICAgICAgfSBlbHNlIHsgLy8gMHg2MCA8PSBiIDw9IDB4N0ZcbiAgICAgICAgICAgIHJvdyA9IChjaE5yID09PSAxKSA/IHJvd3NIaWdoQ2gxW2FdIDogcm93c0hpZ2hDaDJbYV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBhY0RhdGEgPSB0aGlzLmludGVycHJldFBBQyhyb3csIGIpO1xuICAgICAgICB2YXIgY2hhbm5lbCA9IHRoaXMuY2hhbm5lbHNbY2hOci0xXTtcbiAgICAgICAgY2hhbm5lbC5zZXRQQUMocGFjRGF0YSk7XG4gICAgICAgIHRoaXMubGFzdENtZEEgPSBhO1xuICAgICAgICB0aGlzLmxhc3RDbWRCID0gYjtcbiAgICAgICAgdGhpcy5jdXJyQ2hOciA9IGNoTnI7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEludGVycHJldCB0aGUgc2Vjb25kIGJ5dGUgb2YgdGhlIHBhYywgYW5kIHJldHVybiB0aGUgaW5mb3JtYXRpb24uXG4gICAgICogQHJldHVybnMge09iamVjdH0gcGFjRGF0YSB3aXRoIHN0eWxlIHBhcmFtZXRlcnMuXG4gICAgICovXG4gICAgaW50ZXJwcmV0UEFDKHJvdywgYnl0ZSkge1xuICAgICAgICB2YXIgcGFjSW5kZXggPSBieXRlO1xuICAgICAgICB2YXIgcGFjRGF0YSA9IHtjb2xvciA6IG51bGwsIGl0YWxpY3MgOiBmYWxzZSwgaW5kZW50IDogbnVsbCwgdW5kZXJsaW5lIDogZmFsc2UsIHJvdyA6IHJvd307XG5cbiAgICAgICAgaWYgKGJ5dGUgPiAweDVGKSB7XG4gICAgICAgICAgICBwYWNJbmRleCA9IGJ5dGUgLSAweDYwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFjSW5kZXggPSBieXRlIC0gMHg0MDtcbiAgICAgICAgfVxuICAgICAgICBwYWNEYXRhLnVuZGVybGluZSA9IChwYWNJbmRleCAmIDEpID09PSAxO1xuICAgICAgICBpZiAocGFjSW5kZXggPD0gMHhkKSB7XG4gICAgICAgICAgICBwYWNEYXRhLmNvbG9yID0gWyd3aGl0ZScsICdncmVlbicsICdibHVlJywgJ2N5YW4nLCAncmVkJywgJ3llbGxvdycsICdtYWdlbnRhJywgJ3doaXRlJ11bTWF0aC5mbG9vcihwYWNJbmRleC8yKV07XG4gICAgICAgIH0gZWxzZSBpZiAocGFjSW5kZXggPD0gMHhmKSB7XG4gICAgICAgICAgICBwYWNEYXRhLml0YWxpY3MgPSB0cnVlO1xuICAgICAgICAgICAgcGFjRGF0YS5jb2xvciA9ICd3aGl0ZSc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYWNEYXRhLmluZGVudCA9IChNYXRoLmZsb29yKChwYWNJbmRleC0weDEwKS8yKSkqNDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFjRGF0YTsgLy8gTm90ZSB0aGF0IHJvdyBoYXMgemVybyBvZmZzZXQuIFRoZSBzcGVjIHVzZXMgMS5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXJzZSBjaGFyYWN0ZXJzLlxuICAgICAqIEByZXR1cm5zIEFuIGFycmF5IHdpdGggMSB0byAyIGNvZGVzIGNvcnJlc3BvbmRpbmcgdG8gY2hhcnMsIGlmIGZvdW5kLiBudWxsIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBwYXJzZUNoYXJzKGEsIGIpIHtcblxuICAgICAgIHZhciAgY2hhbm5lbE5yID0gbnVsbCxcbiAgICAgICAgICAgIGNoYXJDb2RlcyA9IG51bGwsXG4gICAgICAgICAgICBjaGFyQ29kZTEgPSBudWxsO1xuXG4gICAgICAgIGlmIChhID49IDB4MTkpIHtcbiAgICAgICAgICAgIGNoYW5uZWxOciA9IDI7XG4gICAgICAgICAgICBjaGFyQ29kZTEgPSBhIC0gODtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNoYW5uZWxOciA9IDE7XG4gICAgICAgICAgICBjaGFyQ29kZTEgPSBhO1xuICAgICAgICB9XG4gICAgICAgIGlmICgweDExIDw9IGNoYXJDb2RlMSAmJiBjaGFyQ29kZTEgPD0gMHgxMykge1xuICAgICAgICAgICAgLy8gU3BlY2lhbCBjaGFyYWN0ZXJcbiAgICAgICAgICAgIHZhciBvbmVDb2RlID0gYjtcbiAgICAgICAgICAgIGlmIChjaGFyQ29kZTEgPT09IDB4MTEpIHtcbiAgICAgICAgICAgICAgICBvbmVDb2RlID0gYiArIDB4NTA7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNoYXJDb2RlMSA9PT0gMHgxMikge1xuICAgICAgICAgICAgICAgIG9uZUNvZGUgPSBiICsgMHg3MDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb25lQ29kZSA9IGIgKyAweDkwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9nZ2VyLmxvZygnSU5GTycsICdTcGVjaWFsIGNoYXIgXFwnJyArIGdldENoYXJGb3JCeXRlKG9uZUNvZGUpICsgJ1xcJyBpbiBjaGFubmVsICcgKyBjaGFubmVsTnIpO1xuICAgICAgICAgICAgY2hhckNvZGVzID0gW29uZUNvZGVdO1xuICAgICAgICB9IGVsc2UgaWYgKDB4MjAgPD0gYSAmJiBhIDw9IDB4N2YpIHtcbiAgICAgICAgICAgIGNoYXJDb2RlcyA9IChiID09PSAwKSA/IFthXSA6IFthLCBiXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhckNvZGVzKSB7XG4gICAgICAgICAgICB2YXIgaGV4Q29kZXMgPSBudW1BcnJheVRvSGV4QXJyYXkoY2hhckNvZGVzKTtcbiAgICAgICAgICAgIGxvZ2dlci5sb2coJ0RFQlVHJywgJ0NoYXIgY29kZXMgPSAgJyArIGhleENvZGVzLmpvaW4oJywnKSk7XG4gICAgICAgICAgICB0aGlzLmxhc3RDbWRBID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMubGFzdENtZEIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaGFyQ29kZXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiBQYXJzZSBleHRlbmRlZCBiYWNrZ3JvdW5kIGF0dHJpYnV0ZXMgYXMgd2VsbCBhcyBuZXcgZm9yZWdyb3VuZCBjb2xvciBibGFjay5cbiAgICAqIEByZXR1cm5ze0Jvb2xlYW59IFRlbGxzIGlmIGJhY2tncm91bmQgYXR0cmlidXRlcyBhcmUgZm91bmRcbiAgICAqL1xuICAgIHBhcnNlQmFja2dyb3VuZEF0dHJpYnV0ZXMoYSwgYikge1xuICAgICAgIHZhciAgYmtnRGF0YSxcbiAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgY2hOcixcbiAgICAgICAgICAgIGNoYW5uZWw7XG5cbiAgICAgICAgdmFyIGNhc2UxID0gKGEgPT09IDB4MTAgfHwgYSA9PT0gMHgxOCkgJiYgKDB4MjAgPD0gYiAmJiBiIDw9IDB4MmYpO1xuICAgICAgICB2YXIgY2FzZTIgPSAoYSA9PT0gMHgxNyB8fCBhID09PSAweDFmKSAmJiAoMHgyZCA8PWIgJiYgYiA8PSAweDJmKTtcbiAgICAgICAgaWYgKCEoY2FzZTEgfHwgY2FzZTIpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgYmtnRGF0YSA9IHt9O1xuICAgICAgICBpZiAoYSAgPT09IDB4MTAgfHwgYSA9PT0gMHgxOCkge1xuICAgICAgICAgICAgaW5kZXggPSBNYXRoLmZsb29yKChiLTB4MjApLzIpO1xuICAgICAgICAgICAgYmtnRGF0YS5iYWNrZ3JvdW5kID0gYmFja2dyb3VuZENvbG9yc1tpbmRleF07XG4gICAgICAgICAgICBpZiAoYiAlIDIgPT09IDEpIHtcbiAgICAgICAgICAgICAgICBia2dEYXRhLmJhY2tncm91bmQgPSBia2dEYXRhLmJhY2tncm91bmQgKyAnX3NlbWknO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGIgPT09IDB4MmQpIHtcbiAgICAgICAgICAgIGJrZ0RhdGEuYmFja2dyb3VuZCA9ICd0cmFuc3BhcmVudCc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBia2dEYXRhLmZvcmVncm91bmQgPSAnYmxhY2snO1xuICAgICAgICAgICAgaWYgKGIgPT09IDB4MmYpIHtcbiAgICAgICAgICAgICAgICBia2dEYXRhLnVuZGVybGluZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2hOciA9IChhIDwgMHgxOCkgPyAxIDogMjtcbiAgICAgICAgY2hhbm5lbCA9IHRoaXMuY2hhbm5lbHNbY2hOci0xXTtcbiAgICAgICAgY2hhbm5lbC5zZXRCa2dEYXRhKGJrZ0RhdGEpO1xuICAgICAgICB0aGlzLmxhc3RDbWRBID0gbnVsbDtcbiAgICAgICAgdGhpcy5sYXN0Q21kQiA9IG51bGw7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlc2V0IHN0YXRlIG9mIHBhcnNlciBhbmQgaXRzIGNoYW5uZWxzLlxuICAgICAqL1xuICAgIHJlc2V0KCkge1xuICAgICAgICBmb3IgKHZhciBpPTAgOyBpIDwgdGhpcy5jaGFubmVscy5sZW5ndGggOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNoYW5uZWxzW2ldKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGFubmVsc1tpXS5yZXNldCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMubGFzdENtZEEgPSBudWxsO1xuICAgICAgICB0aGlzLmxhc3RDbWRCID0gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyIHRoZSBnZW5lcmF0aW9uIG9mIGEgY3VlLCBhbmQgdGhlIHN0YXJ0IG9mIGEgbmV3IG9uZSBpZiBkaXNwbGF5U2NyZWVucyBhcmUgbm90IGVtcHR5LlxuICAgICAqL1xuICAgIGN1ZVNwbGl0QXRUaW1lKHQpIHtcbiAgICAgICAgZm9yICh2YXIgaT0wIDsgaSA8IHRoaXMuY2hhbm5lbHMubGVuZ3RoIDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jaGFubmVsc1tpXSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2hhbm5lbHNbaV0uY3VlU3BsaXRBdFRpbWUodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IENlYTYwOFBhcnNlcjtcbiIsImltcG9ydCB7IGZpeExpbmVCcmVha3MgfSBmcm9tICcuL3Z0dHBhcnNlcic7XG5cbmNvbnN0IEN1ZXMgPSB7XG5cbiAgbmV3Q3VlOiBmdW5jdGlvbih0cmFjaywgc3RhcnRUaW1lLCBlbmRUaW1lLCBjYXB0aW9uU2NyZWVuKSB7XG4gICAgdmFyIHJvdztcbiAgICB2YXIgY3VlO1xuICAgIHZhciBpbmRlbnRpbmc7XG4gICAgdmFyIGluZGVudDtcbiAgICB2YXIgdGV4dDtcbiAgICB2YXIgVlRUQ3VlID0gd2luZG93LlZUVEN1ZSB8fCB3aW5kb3cuVGV4dFRyYWNrQ3VlO1xuXG4gICAgZm9yICh2YXIgcj0wOyByPGNhcHRpb25TY3JlZW4ucm93cy5sZW5ndGg7IHIrKylcbiAgICB7XG4gICAgICByb3cgPSBjYXB0aW9uU2NyZWVuLnJvd3Nbcl07XG4gICAgICBpbmRlbnRpbmcgPSB0cnVlO1xuICAgICAgaW5kZW50ID0gMDtcbiAgICAgIHRleHQgPSAnJztcblxuICAgICAgaWYgKCFyb3cuaXNFbXB0eSgpKVxuICAgICAge1xuICAgICAgICBmb3IgKHZhciBjPTA7IGM8cm93LmNoYXJzLmxlbmd0aDsgYysrKVxuICAgICAgICB7XG4gICAgICAgICAgaWYgKHJvdy5jaGFyc1tjXS51Y2hhci5tYXRjaCgvXFxzLykgJiYgaW5kZW50aW5nKVxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGluZGVudCsrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlXG4gICAgICAgICAge1xuICAgICAgICAgICAgdGV4dCArPSByb3cuY2hhcnNbY10udWNoYXI7XG4gICAgICAgICAgICBpbmRlbnRpbmcgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy9UbyBiZSB1c2VkIGZvciBjbGVhbmluZy11cCBvcnBoYW5lZCByb2xsLXVwIGNhcHRpb25zXG4gICAgICAgIHJvdy5jdWVTdGFydFRpbWUgPSBzdGFydFRpbWU7XG5cbiAgICAgICAgLy8gR2l2ZSBhIHNsaWdodCBidW1wIHRvIHRoZSBlbmRUaW1lIGlmIGl0J3MgZXF1YWwgdG8gc3RhcnRUaW1lIHRvIGF2b2lkIGEgU3ludGF4RXJyb3IgaW4gSUVcbiAgICAgICAgaWYgKHN0YXJ0VGltZSA9PT0gZW5kVGltZSlcbiAgICAgICAge1xuICAgICAgICAgIGVuZFRpbWUgKz0gMC4wMDAxO1xuICAgICAgICB9XG5cbiAgICAgICAgY3VlID0gbmV3IFZUVEN1ZShzdGFydFRpbWUsIGVuZFRpbWUsIGZpeExpbmVCcmVha3ModGV4dC50cmltKCkpKTtcblxuICAgICAgICBpZiAoaW5kZW50ID49IDE2KVxuICAgICAgICB7XG4gICAgICAgICAgaW5kZW50LS07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgaW5kZW50Kys7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBWVFRDdWUubGluZSBnZXQncyBmbGFrZXkgd2hlbiB1c2luZyBjb250cm9scywgc28gbGV0J3Mgbm93IGluY2x1ZGUgbGluZSAxMyYxNFxuICAgICAgICAvLyBhbHNvLCBkcm9wIGxpbmUgMSBzaW5jZSBpdCdzIHRvIGNsb3NlIHRvIHRoZSB0b3BcbiAgICAgICAgaWYgKG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL0ZpcmVmb3hcXC8vKSlcbiAgICAgICAge1xuICAgICAgICAgIGN1ZS5saW5lID0gciArIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgY3VlLmxpbmUgPSAociA+IDcgPyByIC0gMiA6IHIgKyAxKTtcbiAgICAgICAgfVxuICAgICAgICBjdWUuYWxpZ24gPSAnbGVmdCc7XG4gICAgICAgIC8vIENsYW1wIHRoZSBwb3NpdGlvbiBiZXR3ZWVuIDAgYW5kIDEwMCAtIGlmIG91dCBvZiB0aGVzZSBib3VuZHMsIEZpcmVmb3ggdGhyb3dzIGFuIGV4Y2VwdGlvbiBhbmQgY2FwdGlvbnMgYnJlYWtcbiAgICAgICAgY3VlLnBvc2l0aW9uID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMTAwLCAxMDAgKiAoaW5kZW50IC8gMzIpICsgKG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL0ZpcmVmb3hcXC8vKSA/IDUwIDogMCkpKTtcbiAgICAgICAgdHJhY2suYWRkQ3VlKGN1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ3VlcztcbiIsImltcG9ydCBCaW5hcnlTZWFyY2ggZnJvbSAnLi9iaW5hcnktc2VhcmNoJztcbmltcG9ydCB7bG9nZ2VyfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xuXG5leHBvcnQgZnVuY3Rpb24gZmluZEZpcnN0RnJhZ1dpdGhDQyhmcmFnbWVudHMsIGNjKSB7XG4gIGxldCBmaXJzdEZyYWcgPSBudWxsO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZnJhZ21lbnRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgY29uc3QgY3VycmVudEZyYWcgPSBmcmFnbWVudHNbaV07XG4gICAgaWYgKGN1cnJlbnRGcmFnICYmIGN1cnJlbnRGcmFnLmNjID09PSBjYykge1xuICAgICAgZmlyc3RGcmFnID0gY3VycmVudEZyYWc7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmlyc3RGcmFnO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZmluZEZyYWdXaXRoQ0MoZnJhZ21lbnRzLCBDQykge1xuICByZXR1cm4gQmluYXJ5U2VhcmNoLnNlYXJjaChmcmFnbWVudHMsIChjYW5kaWRhdGUpID0+IHtcbiAgICAgaWYgKGNhbmRpZGF0ZS5jYyA8IENDKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfSBlbHNlIGlmIChjYW5kaWRhdGUuY2MgPiBDQykge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICB9XG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2hvdWxkQWxpZ25PbkRpc2NvbnRpbnVpdGllcyhsYXN0RnJhZywgbGFzdExldmVsLCBkZXRhaWxzKSB7XG4gIGxldCBzaG91bGRBbGlnbiA9IGZhbHNlO1xuICBpZiAobGFzdExldmVsICYmIGxhc3RMZXZlbC5kZXRhaWxzICYmIGRldGFpbHMpIHtcbiAgICBpZiAoZGV0YWlscy5lbmRDQyA+IGRldGFpbHMuc3RhcnRDQyB8fCAobGFzdEZyYWcgJiYgbGFzdEZyYWcuY2MgPCBkZXRhaWxzLnN0YXJ0Q0MpKSB7XG4gICAgICBzaG91bGRBbGlnbiA9IHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBzaG91bGRBbGlnbjtcbn1cblxuLy8gRmluZCB0aGUgZmlyc3QgZnJhZyBpbiB0aGUgcHJldmlvdXMgbGV2ZWwgd2hpY2ggbWF0Y2hlcyB0aGUgQ0Mgb2YgdGhlIGZpcnN0IGZyYWcgb2YgdGhlIG5ldyBsZXZlbFxuZXhwb3J0IGZ1bmN0aW9uIGZpbmREaXNjb250aW51b3VzUmVmZXJlbmNlRnJhZyhwcmV2RGV0YWlscywgY3VyRGV0YWlscykge1xuICBjb25zdCBwcmV2RnJhZ3MgPSBwcmV2RGV0YWlscy5mcmFnbWVudHM7XG4gIGNvbnN0IGN1ckZyYWdzID0gY3VyRGV0YWlscy5mcmFnbWVudHM7XG5cbiAgaWYgKCFjdXJGcmFncy5sZW5ndGggfHwgIXByZXZGcmFncy5sZW5ndGgpIHtcbiAgICBsb2dnZXIubG9nKCdObyBmcmFnbWVudHMgdG8gYWxpZ24nKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBwcmV2U3RhcnRGcmFnID0gZmluZEZpcnN0RnJhZ1dpdGhDQyhwcmV2RnJhZ3MsIGN1ckZyYWdzWzBdLmNjKTtcblxuICBpZiAoIXByZXZTdGFydEZyYWcgfHwgKHByZXZTdGFydEZyYWcgJiYgIXByZXZTdGFydEZyYWcuc3RhcnRQVFMpKSB7XG4gICAgbG9nZ2VyLmxvZygnTm8gZnJhZyBpbiBwcmV2aW91cyBsZXZlbCB0byBhbGlnbiBvbicpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHJldHVybiBwcmV2U3RhcnRGcmFnO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYWRqdXN0UHRzQnlSZWZlcmVuY2VGcmFnKHJlZmVyZW5jZUZyYWcsIGRldGFpbHMpIHtcbiAgaWYgKCFyZWZlcmVuY2VGcmFnKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZGV0YWlscy5mcmFnbWVudHMuZm9yRWFjaCgoZnJhZywgaW5kZXgpID0+IHtcbiAgICBpZiAoZnJhZykge1xuICAgICAgZnJhZy5kdXJhdGlvbiA9IHJlZmVyZW5jZUZyYWcuZHVyYXRpb247XG4gICAgICBmcmFnLmVuZCA9IGZyYWcuZW5kUFRTID0gcmVmZXJlbmNlRnJhZy5lbmRQVFMgKyAoZnJhZy5kdXJhdGlvbiAqIGluZGV4KTtcbiAgICAgIGZyYWcuc3RhcnQgPSBmcmFnLnN0YXJ0UFRTID0gcmVmZXJlbmNlRnJhZy5zdGFydFBUUyArIGZyYWcuc3RhcnQ7XG4gICAgfVxuICB9KTtcbiAgZGV0YWlscy5QVFNLbm93biA9IHRydWU7XG59XG5cbi8vIElmIGEgY2hhbmdlIGluIENDIGlzIGRldGVjdGVkLCB0aGUgUFRTIGNhbiBubyBsb25nZXIgYmUgcmVsaWVkIHVwb25cbi8vIEF0dGVtcHQgdG8gYWxpZ24gdGhlIGxldmVsIGJ5IHVzaW5nIHRoZSBsYXN0IGxldmVsIC0gZmluZCB0aGUgbGFzdCBmcmFnIG1hdGNoaW5nIHRoZSBjdXJyZW50IENDIGFuZCB1c2UgaXQncyBQVFNcbi8vIGFzIGEgcmVmZXJlbmNlXG5leHBvcnQgZnVuY3Rpb24gYWxpZ25EaXNjb250aW51aXRpZXMobGFzdEZyYWcsIGxhc3RMZXZlbCwgZGV0YWlscykge1xuICBpZiAoc2hvdWxkQWxpZ25PbkRpc2NvbnRpbnVpdGllcyhsYXN0RnJhZywgbGFzdExldmVsLCBkZXRhaWxzKSkge1xuICAgIGxvZ2dlci5sb2coJ0FkanVzdGluZyBQVFMgdXNpbmcgbGFzdCBsZXZlbCBkdWUgdG8gQ0MgaW5jcmVhc2Ugd2l0aGluIGN1cnJlbnQgbGV2ZWwnKTtcbiAgICBjb25zdCByZWZlcmVuY2VGcmFnID0gZmluZERpc2NvbnRpbnVvdXNSZWZlcmVuY2VGcmFnKGxhc3RMZXZlbC5kZXRhaWxzLCBkZXRhaWxzKTtcbiAgICBhZGp1c3RQdHNCeVJlZmVyZW5jZUZyYWcocmVmZXJlbmNlRnJhZywgZGV0YWlscyk7XG4gIH1cbn1cbiIsIi8qXG4gKiBFV01BIEJhbmR3aWR0aCBFc3RpbWF0b3JcbiAqICAtIGhlYXZpbHkgaW5zcGlyZWQgZnJvbSBzaGFrYS1wbGF5ZXJcbiAqIFRyYWNrcyBiYW5kd2lkdGggc2FtcGxlcyBhbmQgZXN0aW1hdGVzIGF2YWlsYWJsZSBiYW5kd2lkdGguXG4gKiBCYXNlZCBvbiB0aGUgbWluaW11bSBvZiB0d28gZXhwb25lbnRpYWxseS13ZWlnaHRlZCBtb3ZpbmcgYXZlcmFnZXMgd2l0aFxuICogZGlmZmVyZW50IGhhbGYtbGl2ZXMuXG4gKi9cblxuaW1wb3J0IEVXTUEgZnJvbSAnLi4vdXRpbHMvZXdtYSc7XG5cblxuY2xhc3MgRXdtYUJhbmRXaWR0aEVzdGltYXRvciB7XG5cbiAgY29uc3RydWN0b3IoaGxzLHNsb3csZmFzdCxkZWZhdWx0RXN0aW1hdGUpIHtcbiAgICB0aGlzLmhscyA9IGhscztcbiAgICB0aGlzLmRlZmF1bHRFc3RpbWF0ZV8gPSBkZWZhdWx0RXN0aW1hdGU7XG4gICAgdGhpcy5taW5XZWlnaHRfID0gMC4wMDE7XG4gICAgdGhpcy5taW5EZWxheU1zXyA9IDUwO1xuICAgIHRoaXMuc2xvd18gPSBuZXcgRVdNQShzbG93KTtcbiAgICB0aGlzLmZhc3RfID0gbmV3IEVXTUEoZmFzdCk7XG4gIH1cblxuICBzYW1wbGUoZHVyYXRpb25NcyxudW1CeXRlcykge1xuICAgIGR1cmF0aW9uTXMgPSBNYXRoLm1heChkdXJhdGlvbk1zLCB0aGlzLm1pbkRlbGF5TXNfKTtcbiAgICB2YXIgYmFuZHdpZHRoID0gODAwMCogbnVtQnl0ZXMgLyBkdXJhdGlvbk1zLFxuICAgIC8vY29uc29sZS5sb2coJ2luc3RhbnQgYnc6JysgTWF0aC5yb3VuZChiYW5kd2lkdGgpKTtcbiAgICAvLyB3ZSB3ZWlnaHQgc2FtcGxlIHVzaW5nIGxvYWRpbmcgZHVyYXRpb24uLi4uXG4gICAgICAgIHdlaWdodCA9IGR1cmF0aW9uTXMgLyAxMDAwO1xuICAgIHRoaXMuZmFzdF8uc2FtcGxlKHdlaWdodCxiYW5kd2lkdGgpO1xuICAgIHRoaXMuc2xvd18uc2FtcGxlKHdlaWdodCxiYW5kd2lkdGgpO1xuICB9XG5cbiAgY2FuRXN0aW1hdGUoKSB7XG4gICAgbGV0IGZhc3QgPSB0aGlzLmZhc3RfO1xuICAgIHJldHVybiAoZmFzdCAmJiBmYXN0LmdldFRvdGFsV2VpZ2h0KCkgPj0gdGhpcy5taW5XZWlnaHRfKTtcbiAgfVxuXG5cbiAgZ2V0RXN0aW1hdGUoKSB7XG4gICAgaWYgKHRoaXMuY2FuRXN0aW1hdGUoKSkge1xuICAgICAgLy9jb25zb2xlLmxvZygnc2xvdyBlc3RpbWF0ZTonKyBNYXRoLnJvdW5kKHRoaXMuc2xvd18uZ2V0RXN0aW1hdGUoKSkpO1xuICAgICAgLy9jb25zb2xlLmxvZygnZmFzdCBlc3RpbWF0ZTonKyBNYXRoLnJvdW5kKHRoaXMuZmFzdF8uZ2V0RXN0aW1hdGUoKSkpO1xuICAgICAgLy8gVGFrZSB0aGUgbWluaW11bSBvZiB0aGVzZSB0d28gZXN0aW1hdGVzLiAgVGhpcyBzaG91bGQgaGF2ZSB0aGUgZWZmZWN0IG9mXG4gICAgICAvLyBhZGFwdGluZyBkb3duIHF1aWNrbHksIGJ1dCB1cCBtb3JlIHNsb3dseS5cbiAgICAgIHJldHVybiBNYXRoLm1pbih0aGlzLmZhc3RfLmdldEVzdGltYXRlKCksdGhpcy5zbG93Xy5nZXRFc3RpbWF0ZSgpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuZGVmYXVsdEVzdGltYXRlXztcbiAgICB9XG4gIH1cblxuICBkZXN0cm95KCkge1xuICB9XG59XG5leHBvcnQgZGVmYXVsdCBFd21hQmFuZFdpZHRoRXN0aW1hdG9yO1xuXG4iLCIvKlxuICogY29tcHV0ZSBhbiBFeHBvbmVudGlhbCBXZWlnaHRlZCBtb3ZpbmcgYXZlcmFnZVxuICogLSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Nb3ZpbmdfYXZlcmFnZSNFeHBvbmVudGlhbF9tb3ZpbmdfYXZlcmFnZVxuICogIC0gaGVhdmlseSBpbnNwaXJlZCBmcm9tIHNoYWthLXBsYXllclxuICovXG5cbmNsYXNzIEVXTUEge1xuXG4gLy8gIEFib3V0IGhhbGYgb2YgdGhlIGVzdGltYXRlZCB2YWx1ZSB3aWxsIGJlIGZyb20gdGhlIGxhc3QgfGhhbGZMaWZlfCBzYW1wbGVzIGJ5IHdlaWdodC5cbiAgY29uc3RydWN0b3IoaGFsZkxpZmUpIHtcbiAgICAvLyBMYXJnZXIgdmFsdWVzIG9mIGFscGhhIGV4cGlyZSBoaXN0b3JpY2FsIGRhdGEgbW9yZSBzbG93bHkuXG4gICAgdGhpcy5hbHBoYV8gPSBoYWxmTGlmZSA/IE1hdGguZXhwKE1hdGgubG9nKDAuNSkgLyBoYWxmTGlmZSkgOiAwO1xuICAgIHRoaXMuZXN0aW1hdGVfID0gMDtcbiAgICB0aGlzLnRvdGFsV2VpZ2h0XyA9IDA7XG4gIH1cblxuICBzYW1wbGUod2VpZ2h0LHZhbHVlKSB7XG4gICAgdmFyIGFkakFscGhhID0gTWF0aC5wb3codGhpcy5hbHBoYV8sIHdlaWdodCk7XG4gICAgdGhpcy5lc3RpbWF0ZV8gPSB2YWx1ZSAqICgxIC0gYWRqQWxwaGEpICsgYWRqQWxwaGEgKiB0aGlzLmVzdGltYXRlXztcbiAgICB0aGlzLnRvdGFsV2VpZ2h0XyArPSB3ZWlnaHQ7XG4gIH1cblxuICBnZXRUb3RhbFdlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy50b3RhbFdlaWdodF87XG4gIH1cblxuICBnZXRFc3RpbWF0ZSgpIHtcbiAgICBpZiAodGhpcy5hbHBoYV8pIHtcbiAgICAgIHZhciB6ZXJvRmFjdG9yID0gMSAtIE1hdGgucG93KHRoaXMuYWxwaGFfLCB0aGlzLnRvdGFsV2VpZ2h0Xyk7XG4gICAgICByZXR1cm4gdGhpcy5lc3RpbWF0ZV8gLyB6ZXJvRmFjdG9yO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5lc3RpbWF0ZV87XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEVXTUE7XG4iLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5jb25zdCBmYWtlTG9nZ2VyID0ge1xuICB0cmFjZTogbm9vcCxcbiAgZGVidWc6IG5vb3AsXG4gIGxvZzogbm9vcCxcbiAgd2Fybjogbm9vcCxcbiAgaW5mbzogbm9vcCxcbiAgZXJyb3I6IG5vb3Bcbn07XG5cbmxldCBleHBvcnRlZExvZ2dlciA9IGZha2VMb2dnZXI7XG5cbi8qZ2xvYmFscyBzZWxmOiBmYWxzZSAqL1xuXG4vL2xldCBsYXN0Q2FsbFRpbWU7XG4vLyBmdW5jdGlvbiBmb3JtYXRNc2dXaXRoVGltZUluZm8odHlwZSwgbXNnKSB7XG4vLyAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4vLyAgIGNvbnN0IGRpZmYgPSBsYXN0Q2FsbFRpbWUgPyAnKycgKyAobm93IC0gbGFzdENhbGxUaW1lKSA6ICcwJztcbi8vICAgbGFzdENhbGxUaW1lID0gbm93O1xuLy8gICBtc2cgPSAobmV3IERhdGUobm93KSkudG9JU09TdHJpbmcoKSArICcgfCBbJyArICB0eXBlICsgJ10gPiAnICsgbXNnICsgJyAoICcgKyBkaWZmICsgJyBtcyApJztcbi8vICAgcmV0dXJuIG1zZztcbi8vIH1cblxuZnVuY3Rpb24gZm9ybWF0TXNnKHR5cGUsIG1zZykge1xuICBtc2cgPSAnWycgKyAgdHlwZSArICddID4gJyArIG1zZztcbiAgcmV0dXJuIG1zZztcbn1cblxuZnVuY3Rpb24gY29uc29sZVByaW50Rm4odHlwZSkge1xuICBjb25zdCBmdW5jID0gc2VsZi5jb25zb2xlW3R5cGVdO1xuICBpZiAoZnVuYykge1xuICAgIHJldHVybiBmdW5jdGlvbiguLi5hcmdzKSB7XG4gICAgICBpZihhcmdzWzBdKSB7XG4gICAgICAgIGFyZ3NbMF0gPSBmb3JtYXRNc2codHlwZSwgYXJnc1swXSk7XG4gICAgICB9XG4gICAgICBmdW5jLmFwcGx5KHNlbGYuY29uc29sZSwgYXJncyk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gbm9vcDtcbn1cblxuZnVuY3Rpb24gZXhwb3J0TG9nZ2VyRnVuY3Rpb25zKGRlYnVnQ29uZmlnLCAuLi5mdW5jdGlvbnMpIHtcbiAgZnVuY3Rpb25zLmZvckVhY2goZnVuY3Rpb24odHlwZSkge1xuICAgIGV4cG9ydGVkTG9nZ2VyW3R5cGVdID0gZGVidWdDb25maWdbdHlwZV0gPyBkZWJ1Z0NvbmZpZ1t0eXBlXS5iaW5kKGRlYnVnQ29uZmlnKSA6IGNvbnNvbGVQcmludEZuKHR5cGUpO1xuICB9KTtcbn1cblxuZXhwb3J0IHZhciBlbmFibGVMb2dzID0gZnVuY3Rpb24oZGVidWdDb25maWcpIHtcbiAgaWYgKGRlYnVnQ29uZmlnID09PSB0cnVlIHx8IHR5cGVvZiBkZWJ1Z0NvbmZpZyA9PT0gJ29iamVjdCcpIHtcbiAgICBleHBvcnRMb2dnZXJGdW5jdGlvbnMoZGVidWdDb25maWcsXG4gICAgICAvLyBSZW1vdmUgb3V0IGZyb20gbGlzdCBoZXJlIHRvIGhhcmQtZGlzYWJsZSBhIGxvZy1sZXZlbFxuICAgICAgLy8ndHJhY2UnLFxuICAgICAgJ2RlYnVnJyxcbiAgICAgICdsb2cnLFxuICAgICAgJ2luZm8nLFxuICAgICAgJ3dhcm4nLFxuICAgICAgJ2Vycm9yJ1xuICAgICk7XG4gICAgLy8gU29tZSBicm93c2VycyBkb24ndCBhbGxvdyB0byB1c2UgYmluZCBvbiBjb25zb2xlIG9iamVjdCBhbnl3YXlcbiAgICAvLyBmYWxsYmFjayB0byBkZWZhdWx0IGlmIG5lZWRlZFxuICAgIHRyeSB7XG4gICAgIGV4cG9ydGVkTG9nZ2VyLmxvZygpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGV4cG9ydGVkTG9nZ2VyID0gZmFrZUxvZ2dlcjtcbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgZXhwb3J0ZWRMb2dnZXIgPSBmYWtlTG9nZ2VyO1xuICB9XG59O1xuXG5leHBvcnQgdmFyIGxvZ2dlciA9IGV4cG9ydGVkTG9nZ2VyO1xuIiwiLyoqXG4gKiAgVGltZVJhbmdlcyB0byBzdHJpbmcgaGVscGVyXG4gKi9cblxuY29uc3QgVGltZVJhbmdlcyA9IHtcbiAgdG9TdHJpbmcgOiBmdW5jdGlvbihyKSB7XG4gICAgdmFyIGxvZyA9ICcnLCBsZW4gPSByLmxlbmd0aDtcbiAgICBmb3IgKHZhciBpPTA7IGk8bGVuOyBpKyspIHtcbiAgICAgIGxvZyArPSAnWycgKyByLnN0YXJ0KGkpLnRvRml4ZWQoMykgKyAnLCcgKyByLmVuZChpKS50b0ZpeGVkKDMpICsgJ10nO1xuICAgIH1cbiAgICByZXR1cm4gbG9nO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRpbWVSYW5nZXM7XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzIHZ0dC5qcyBDb250cmlidXRvcnNcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmV4cG9ydCBkZWZhdWx0IChmdW5jdGlvbigpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5WVFRDdWUpIHtcbiAgICByZXR1cm4gd2luZG93LlZUVEN1ZTtcbiAgfVxuXG4gIHZhciBhdXRvS2V5d29yZCA9ICdhdXRvJztcbiAgdmFyIGRpcmVjdGlvblNldHRpbmcgPSB7XG4gICAgJyc6IHRydWUsXG4gICAgbHI6IHRydWUsXG4gICAgcmw6IHRydWVcbiAgfTtcbiAgdmFyIGFsaWduU2V0dGluZyA9IHtcbiAgICBzdGFydDogdHJ1ZSxcbiAgICBtaWRkbGU6IHRydWUsXG4gICAgZW5kOiB0cnVlLFxuICAgIGxlZnQ6IHRydWUsXG4gICAgcmlnaHQ6IHRydWVcbiAgfTtcblxuICBmdW5jdGlvbiBmaW5kRGlyZWN0aW9uU2V0dGluZyh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciBkaXIgPSBkaXJlY3Rpb25TZXR0aW5nW3ZhbHVlLnRvTG93ZXJDYXNlKCldO1xuICAgIHJldHVybiBkaXIgPyB2YWx1ZS50b0xvd2VyQ2FzZSgpIDogZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBmaW5kQWxpZ25TZXR0aW5nKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIGFsaWduID0gYWxpZ25TZXR0aW5nW3ZhbHVlLnRvTG93ZXJDYXNlKCldO1xuICAgIHJldHVybiBhbGlnbiA/IHZhbHVlLnRvTG93ZXJDYXNlKCkgOiBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGV4dGVuZChvYmopIHtcbiAgICB2YXIgaSA9IDE7XG4gICAgZm9yICg7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjb2JqID0gYXJndW1lbnRzW2ldO1xuICAgICAgZm9yICh2YXIgcCBpbiBjb2JqKSB7XG4gICAgICAgIG9ialtwXSA9IGNvYmpbcF07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIGZ1bmN0aW9uIFZUVEN1ZShzdGFydFRpbWUsIGVuZFRpbWUsIHRleHQpIHtcbiAgICB2YXIgY3VlID0gdGhpcztcbiAgICB2YXIgaXNJRTggPSAoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHJldHVybiAoL01TSUVcXHM4XFwuMC8pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gICAgfSkoKTtcbiAgICB2YXIgYmFzZU9iaiA9IHt9O1xuXG4gICAgaWYgKGlzSUU4KSB7XG4gICAgICBjdWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjdXN0b20nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYmFzZU9iai5lbnVtZXJhYmxlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTaGltIGltcGxlbWVudGF0aW9uIHNwZWNpZmljIHByb3BlcnRpZXMuIFRoZXNlIHByb3BlcnRpZXMgYXJlIG5vdCBpblxuICAgICAqIHRoZSBzcGVjLlxuICAgICAqL1xuXG4gICAgLy8gTGV0cyB1cyBrbm93IHdoZW4gdGhlIFZUVEN1ZSdzIGRhdGEgaGFzIGNoYW5nZWQgaW4gc3VjaCBhIHdheSB0aGF0IHdlIG5lZWRcbiAgICAvLyB0byByZWNvbXB1dGUgaXRzIGRpc3BsYXkgc3RhdGUuIFRoaXMgbGV0cyB1cyBjb21wdXRlIGl0cyBkaXNwbGF5IHN0YXRlXG4gICAgLy8gbGF6aWx5LlxuICAgIGN1ZS5oYXNCZWVuUmVzZXQgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIFZUVEN1ZSBhbmQgVGV4dFRyYWNrQ3VlIHByb3BlcnRpZXNcbiAgICAgKiBodHRwOi8vZGV2LnczLm9yZy9odG1sNS93ZWJ2dHQvI3Z0dGN1ZS1pbnRlcmZhY2VcbiAgICAgKi9cblxuICAgIHZhciBfaWQgPSAnJztcbiAgICB2YXIgX3BhdXNlT25FeGl0ID0gZmFsc2U7XG4gICAgdmFyIF9zdGFydFRpbWUgPSBzdGFydFRpbWU7XG4gICAgdmFyIF9lbmRUaW1lID0gZW5kVGltZTtcbiAgICB2YXIgX3RleHQgPSB0ZXh0O1xuICAgIHZhciBfcmVnaW9uID0gbnVsbDtcbiAgICB2YXIgX3ZlcnRpY2FsID0gJyc7XG4gICAgdmFyIF9zbmFwVG9MaW5lcyA9IHRydWU7XG4gICAgdmFyIF9saW5lID0gJ2F1dG8nO1xuICAgIHZhciBfbGluZUFsaWduID0gJ3N0YXJ0JztcbiAgICB2YXIgX3Bvc2l0aW9uID0gNTA7XG4gICAgdmFyIF9wb3NpdGlvbkFsaWduID0gJ21pZGRsZSc7XG4gICAgdmFyIF9zaXplID0gNTA7XG4gICAgdmFyIF9hbGlnbiA9ICdtaWRkbGUnO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSwgJ2lkJywgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9pZDtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBfaWQgPSAnJyArIHZhbHVlO1xuICAgICAgfVxuICAgIH0pKTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsICdwYXVzZU9uRXhpdCcsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfcGF1c2VPbkV4aXQ7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgX3BhdXNlT25FeGl0ID0gISF2YWx1ZTtcbiAgICAgIH1cbiAgICB9KSk7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLCAnc3RhcnRUaW1lJywgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9zdGFydFRpbWU7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdTdGFydCB0aW1lIG11c3QgYmUgc2V0IHRvIGEgbnVtYmVyLicpO1xuICAgICAgICB9XG4gICAgICAgIF9zdGFydFRpbWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5oYXNCZWVuUmVzZXQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pKTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsICdlbmRUaW1lJywgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9lbmRUaW1lO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRW5kIHRpbWUgbXVzdCBiZSBzZXQgdG8gYSBudW1iZXIuJyk7XG4gICAgICAgIH1cbiAgICAgICAgX2VuZFRpbWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5oYXNCZWVuUmVzZXQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pKTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsICd0ZXh0JywgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90ZXh0O1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIF90ZXh0ID0gJycgKyB2YWx1ZTtcbiAgICAgICAgdGhpcy5oYXNCZWVuUmVzZXQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pKTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsICdyZWdpb24nLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3JlZ2lvbjtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBfcmVnaW9uID0gdmFsdWU7XG4gICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSk7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLCAndmVydGljYWwnLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3ZlcnRpY2FsO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBzZXR0aW5nID0gZmluZERpcmVjdGlvblNldHRpbmcodmFsdWUpO1xuICAgICAgICAvLyBIYXZlIHRvIGNoZWNrIGZvciBmYWxzZSBiZWNhdXNlIHRoZSBzZXR0aW5nIGFuIGJlIGFuIGVtcHR5IHN0cmluZy5cbiAgICAgICAgaWYgKHNldHRpbmcgPT09IGZhbHNlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdBbiBpbnZhbGlkIG9yIGlsbGVnYWwgc3RyaW5nIHdhcyBzcGVjaWZpZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgX3ZlcnRpY2FsID0gc2V0dGluZztcbiAgICAgICAgdGhpcy5oYXNCZWVuUmVzZXQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pKTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsICdzbmFwVG9MaW5lcycsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfc25hcFRvTGluZXM7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgX3NuYXBUb0xpbmVzID0gISF2YWx1ZTtcbiAgICAgICAgdGhpcy5oYXNCZWVuUmVzZXQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pKTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsICdsaW5lJywgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9saW5lO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInICYmIHZhbHVlICE9PSBhdXRvS2V5d29yZCkge1xuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignQW4gaW52YWxpZCBudW1iZXIgb3IgaWxsZWdhbCBzdHJpbmcgd2FzIHNwZWNpZmllZC4nKTtcbiAgICAgICAgfVxuICAgICAgICBfbGluZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XG4gICAgICB9XG4gICAgfSkpO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSwgJ2xpbmVBbGlnbicsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfbGluZUFsaWduO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBzZXR0aW5nID0gZmluZEFsaWduU2V0dGluZyh2YWx1ZSk7XG4gICAgICAgIGlmICghc2V0dGluZykge1xuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignQW4gaW52YWxpZCBvciBpbGxlZ2FsIHN0cmluZyB3YXMgc3BlY2lmaWVkLicpO1xuICAgICAgICB9XG4gICAgICAgIF9saW5lQWxpZ24gPSBzZXR0aW5nO1xuICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XG4gICAgICB9XG4gICAgfSkpO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSwgJ3Bvc2l0aW9uJywgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9wb3NpdGlvbjtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPCAwIHx8IHZhbHVlID4gMTAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQb3NpdGlvbiBtdXN0IGJlIGJldHdlZW4gMCBhbmQgMTAwLicpO1xuICAgICAgICB9XG4gICAgICAgIF9wb3NpdGlvbiA9IHZhbHVlO1xuICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XG4gICAgICB9XG4gICAgfSkpO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSwgJ3Bvc2l0aW9uQWxpZ24nLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3Bvc2l0aW9uQWxpZ247XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIHNldHRpbmcgPSBmaW5kQWxpZ25TZXR0aW5nKHZhbHVlKTtcbiAgICAgICAgaWYgKCFzZXR0aW5nKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdBbiBpbnZhbGlkIG9yIGlsbGVnYWwgc3RyaW5nIHdhcyBzcGVjaWZpZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgX3Bvc2l0aW9uQWxpZ24gPSBzZXR0aW5nO1xuICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XG4gICAgICB9XG4gICAgfSkpO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSwgJ3NpemUnLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3NpemU7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlIDwgMCB8fCB2YWx1ZSA+IDEwMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU2l6ZSBtdXN0IGJlIGJldHdlZW4gMCBhbmQgMTAwLicpO1xuICAgICAgICB9XG4gICAgICAgIF9zaXplID0gdmFsdWU7XG4gICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSk7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLCAnYWxpZ24nLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX2FsaWduO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBzZXR0aW5nID0gZmluZEFsaWduU2V0dGluZyh2YWx1ZSk7XG4gICAgICAgIGlmICghc2V0dGluZykge1xuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignQW4gaW52YWxpZCBvciBpbGxlZ2FsIHN0cmluZyB3YXMgc3BlY2lmaWVkLicpO1xuICAgICAgICB9XG4gICAgICAgIF9hbGlnbiA9IHNldHRpbmc7XG4gICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSk7XG5cbiAgICAvKipcbiAgICAgKiBPdGhlciA8dHJhY2s+IHNwZWMgZGVmaW5lZCBwcm9wZXJ0aWVzXG4gICAgICovXG5cbiAgICAvLyBodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS90aGUtdmlkZW8tZWxlbWVudC5odG1sI3RleHQtdHJhY2stY3VlLWRpc3BsYXktc3RhdGVcbiAgICBjdWUuZGlzcGxheVN0YXRlID0gdW5kZWZpbmVkO1xuXG4gICAgaWYgKGlzSUU4KSB7XG4gICAgICByZXR1cm4gY3VlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBWVFRDdWUgbWV0aG9kc1xuICAgKi9cblxuICBWVFRDdWUucHJvdG90eXBlLmdldEN1ZUFzSFRNTCA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBBc3N1bWUgV2ViVlRULmNvbnZlcnRDdWVUb0RPTVRyZWUgaXMgb24gdGhlIGdsb2JhbC5cbiAgICB2YXIgV2ViVlRUID0gd2luZG93LldlYlZUVDtcbiAgICByZXR1cm4gV2ViVlRULmNvbnZlcnRDdWVUb0RPTVRyZWUod2luZG93LCB0aGlzLnRleHQpO1xuICB9O1xuXG4gIHJldHVybiBWVFRDdWU7XG59KSgpO1xuIiwiLypcbiAqIFNvdXJjZTogaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvdnR0LmpzL2Jsb2IvbWFzdGVyL2Rpc3QvdnR0LmpzI0wxNzE2XG4gKi9cblxuaW1wb3J0IFZUVEN1ZSBmcm9tICcuL3Z0dGN1ZSc7XG5cbmNvbnN0IFN0cmluZ0RlY29kZXIgPSBmdW5jdGlvbiBTdHJpbmdEZWNvZGVyKCkge1xuICByZXR1cm4ge1xuICAgIGRlY29kZTogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgZGF0YSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFcnJvciAtIGV4cGVjdGVkIHN0cmluZyBkYXRhLicpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChlbmNvZGVVUklDb21wb25lbnQoZGF0YSkpO1xuICAgICAgICB9LFxuICAgIH07XG4gIH07XG5cbmZ1bmN0aW9uIFZUVFBhcnNlcigpIHtcbiAgICB0aGlzLndpbmRvdyA9IHdpbmRvdztcbiAgICB0aGlzLnN0YXRlID0gJ0lOSVRJQUwnO1xuICAgIHRoaXMuYnVmZmVyID0gJyc7XG4gICAgdGhpcy5kZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIoKTtcbiAgICB0aGlzLnJlZ2lvbkxpc3QgPSBbXTtcbn1cblxuXG4vLyBUcnkgdG8gcGFyc2UgaW5wdXQgYXMgYSB0aW1lIHN0YW1wLlxuZnVuY3Rpb24gcGFyc2VUaW1lU3RhbXAoaW5wdXQpIHtcblxuICBmdW5jdGlvbiBjb21wdXRlU2Vjb25kcyhoLCBtLCBzLCBmKSB7XG4gICAgcmV0dXJuIChoIHwgMCkgKiAzNjAwICsgKG0gfCAwKSAqIDYwICsgKHMgfCAwKSArIChmIHwgMCkgLyAxMDAwO1xuICB9XG5cbiAgdmFyIG0gPSBpbnB1dC5tYXRjaCgvXihcXGQrKTooXFxkezJ9KSg6XFxkezJ9KT9cXC4oXFxkezN9KS8pO1xuICBpZiAoIW0pIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmIChtWzNdKSB7XG4gICAgLy8gVGltZXN0YW1wIHRha2VzIHRoZSBmb3JtIG9mIFtob3Vyc106W21pbnV0ZXNdOltzZWNvbmRzXS5bbWlsbGlzZWNvbmRzXVxuICAgIHJldHVybiBjb21wdXRlU2Vjb25kcyhtWzFdLCBtWzJdLCBtWzNdLnJlcGxhY2UoJzonLCAnJyksIG1bNF0pO1xuICB9IGVsc2UgaWYgKG1bMV0gPiA1OSkge1xuICAgIC8vIFRpbWVzdGFtcCB0YWtlcyB0aGUgZm9ybSBvZiBbaG91cnNdOlttaW51dGVzXS5bbWlsbGlzZWNvbmRzXVxuICAgIC8vIEZpcnN0IHBvc2l0aW9uIGlzIGhvdXJzIGFzIGl0J3Mgb3ZlciA1OS5cbiAgICByZXR1cm4gY29tcHV0ZVNlY29uZHMobVsxXSwgbVsyXSwgMCwgbVs0XSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gVGltZXN0YW1wIHRha2VzIHRoZSBmb3JtIG9mIFttaW51dGVzXTpbc2Vjb25kc10uW21pbGxpc2Vjb25kc11cbiAgICByZXR1cm4gY29tcHV0ZVNlY29uZHMoMCwgbVsxXSwgbVsyXSwgbVs0XSk7XG4gIH1cbn1cblxuLy8gQSBzZXR0aW5ncyBvYmplY3QgaG9sZHMga2V5L3ZhbHVlIHBhaXJzIGFuZCB3aWxsIGlnbm9yZSBhbnl0aGluZyBidXQgdGhlIGZpcnN0XG4vLyBhc3NpZ25tZW50IHRvIGEgc3BlY2lmaWMga2V5LlxuZnVuY3Rpb24gU2V0dGluZ3MoKSB7XG4gIHRoaXMudmFsdWVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbn1cblxuU2V0dGluZ3MucHJvdG90eXBlID0ge1xuICAvLyBPbmx5IGFjY2VwdCB0aGUgZmlyc3QgYXNzaWdubWVudCB0byBhbnkga2V5LlxuICBzZXQ6IGZ1bmN0aW9uKGssIHYpIHtcbiAgICBpZiAoIXRoaXMuZ2V0KGspICYmIHYgIT09ICcnKSB7XG4gICAgICB0aGlzLnZhbHVlc1trXSA9IHY7XG4gICAgfVxuICB9LFxuICAvLyBSZXR1cm4gdGhlIHZhbHVlIGZvciBhIGtleSwgb3IgYSBkZWZhdWx0IHZhbHVlLlxuICAvLyBJZiAnZGVmYXVsdEtleScgaXMgcGFzc2VkIHRoZW4gJ2RmbHQnIGlzIGFzc3VtZWQgdG8gYmUgYW4gb2JqZWN0IHdpdGhcbiAgLy8gYSBudW1iZXIgb2YgcG9zc2libGUgZGVmYXVsdCB2YWx1ZXMgYXMgcHJvcGVydGllcyB3aGVyZSAnZGVmYXVsdEtleScgaXNcbiAgLy8gdGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdGhhdCB3aWxsIGJlIGNob3Nlbjsgb3RoZXJ3aXNlIGl0J3MgYXNzdW1lZCB0byBiZVxuICAvLyBhIHNpbmdsZSB2YWx1ZS5cbiAgZ2V0OiBmdW5jdGlvbihrLCBkZmx0LCBkZWZhdWx0S2V5KSB7XG4gICAgaWYgKGRlZmF1bHRLZXkpIHtcbiAgICAgIHJldHVybiB0aGlzLmhhcyhrKSA/IHRoaXMudmFsdWVzW2tdIDogZGZsdFtkZWZhdWx0S2V5XTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuaGFzKGspID8gdGhpcy52YWx1ZXNba10gOiBkZmx0O1xuICB9LFxuICAvLyBDaGVjayB3aGV0aGVyIHdlIGhhdmUgYSB2YWx1ZSBmb3IgYSBrZXkuXG4gIGhhczogZnVuY3Rpb24oaykge1xuICAgIHJldHVybiBrIGluIHRoaXMudmFsdWVzO1xuICB9LFxuICAvLyBBY2NlcHQgYSBzZXR0aW5nIGlmIGl0cyBvbmUgb2YgdGhlIGdpdmVuIGFsdGVybmF0aXZlcy5cbiAgYWx0OiBmdW5jdGlvbihrLCB2LCBhKSB7XG4gICAgZm9yICh2YXIgbiA9IDA7IG4gPCBhLmxlbmd0aDsgKytuKSB7XG4gICAgICBpZiAodiA9PT0gYVtuXSkge1xuICAgICAgICB0aGlzLnNldChrLCB2KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICAvLyBBY2NlcHQgYSBzZXR0aW5nIGlmIGl0cyBhIHZhbGlkIChzaWduZWQpIGludGVnZXIuXG4gIGludGVnZXI6IGZ1bmN0aW9uKGssIHYpIHtcbiAgICBpZiAoL14tP1xcZCskLy50ZXN0KHYpKSB7IC8vIGludGVnZXJcbiAgICAgIHRoaXMuc2V0KGssIHBhcnNlSW50KHYsIDEwKSk7XG4gICAgfVxuICB9LFxuICAvLyBBY2NlcHQgYSBzZXR0aW5nIGlmIGl0cyBhIHZhbGlkIHBlcmNlbnRhZ2UuXG4gIHBlcmNlbnQ6IGZ1bmN0aW9uKGssIHYpIHtcbiAgICB2YXIgbTtcbiAgICBpZiAoKG0gPSB2Lm1hdGNoKC9eKFtcXGRdezEsM30pKFxcLltcXGRdKik/JSQvKSkpIHtcbiAgICAgIHYgPSBwYXJzZUZsb2F0KHYpO1xuICAgICAgaWYgKHYgPj0gMCAmJiB2IDw9IDEwMCkge1xuICAgICAgICB0aGlzLnNldChrLCB2KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxuLy8gSGVscGVyIGZ1bmN0aW9uIHRvIHBhcnNlIGlucHV0IGludG8gZ3JvdXBzIHNlcGFyYXRlZCBieSAnZ3JvdXBEZWxpbScsIGFuZFxuLy8gaW50ZXJwcmV0ZSBlYWNoIGdyb3VwIGFzIGEga2V5L3ZhbHVlIHBhaXIgc2VwYXJhdGVkIGJ5ICdrZXlWYWx1ZURlbGltJy5cbmZ1bmN0aW9uIHBhcnNlT3B0aW9ucyhpbnB1dCwgY2FsbGJhY2ssIGtleVZhbHVlRGVsaW0sIGdyb3VwRGVsaW0pIHtcbiAgdmFyIGdyb3VwcyA9IGdyb3VwRGVsaW0gPyBpbnB1dC5zcGxpdChncm91cERlbGltKSA6IFtpbnB1dF07XG4gIGZvciAodmFyIGkgaW4gZ3JvdXBzKSB7XG4gICAgaWYgKHR5cGVvZiBncm91cHNbaV0gIT09ICdzdHJpbmcnKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdmFyIGt2ID0gZ3JvdXBzW2ldLnNwbGl0KGtleVZhbHVlRGVsaW0pO1xuICAgIGlmIChrdi5sZW5ndGggIT09IDIpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB2YXIgayA9IGt2WzBdO1xuICAgIHZhciB2ID0ga3ZbMV07XG4gICAgY2FsbGJhY2soaywgdik7XG4gIH1cbn1cblxudmFyIGRlZmF1bHRzID0gbmV3IFZUVEN1ZSgwLCAwLCAwKTtcbi8vICdtaWRkbGUnIHdhcyBjaGFuZ2VkIHRvICdjZW50ZXInIGluIHRoZSBzcGVjOiBodHRwczovL2dpdGh1Yi5jb20vdzNjL3dlYnZ0dC9wdWxsLzI0NFxuLy8gQ2hyb21lIGFuZCBTYWZhcmkgZG9uJ3QgeWV0IHN1cHBvcnQgdGhpcyBjaGFuZ2UsIGJ1dCBGRiBkb2VzXG52YXIgY2VudGVyID0gZGVmYXVsdHMuYWxpZ24gPT09ICdtaWRkbGUnID8gJ21pZGRsZScgOiAnY2VudGVyJztcblxuZnVuY3Rpb24gcGFyc2VDdWUoaW5wdXQsIGN1ZSwgcmVnaW9uTGlzdCkge1xuICAvLyBSZW1lbWJlciB0aGUgb3JpZ2luYWwgaW5wdXQgaWYgd2UgbmVlZCB0byB0aHJvdyBhbiBlcnJvci5cbiAgdmFyIG9JbnB1dCA9IGlucHV0O1xuICAvLyA0LjEgV2ViVlRUIHRpbWVzdGFtcFxuICBmdW5jdGlvbiBjb25zdW1lVGltZVN0YW1wKCkge1xuICAgIHZhciB0cyA9IHBhcnNlVGltZVN0YW1wKGlucHV0KTtcbiAgICBpZiAodHMgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTWFsZm9ybWVkIHRpbWVzdGFtcDogJyArIG9JbnB1dCk7XG4gICAgfVxuICAgIC8vIFJlbW92ZSB0aW1lIHN0YW1wIGZyb20gaW5wdXQuXG4gICAgaW5wdXQgPSBpbnB1dC5yZXBsYWNlKC9eW15cXHNhLXpBLVotXSsvLCAnJyk7XG4gICAgcmV0dXJuIHRzO1xuICB9XG5cbiAgLy8gNC40LjIgV2ViVlRUIGN1ZSBzZXR0aW5nc1xuICBmdW5jdGlvbiBjb25zdW1lQ3VlU2V0dGluZ3MoaW5wdXQsIGN1ZSkge1xuICAgIHZhciBzZXR0aW5ncyA9IG5ldyBTZXR0aW5ncygpO1xuXG4gICAgcGFyc2VPcHRpb25zKGlucHV0LCBmdW5jdGlvbihrLCB2KSB7XG4gICAgICBzd2l0Y2ggKGspIHtcbiAgICAgICAgY2FzZSAncmVnaW9uJzpcbiAgICAgICAgICAvLyBGaW5kIHRoZSBsYXN0IHJlZ2lvbiB3ZSBwYXJzZWQgd2l0aCB0aGUgc2FtZSByZWdpb24gaWQuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IHJlZ2lvbkxpc3QubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGlmIChyZWdpb25MaXN0W2ldLmlkID09PSB2KSB7XG4gICAgICAgICAgICAgIHNldHRpbmdzLnNldChrLCByZWdpb25MaXN0W2ldLnJlZ2lvbik7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAndmVydGljYWwnOlxuICAgICAgICAgIHNldHRpbmdzLmFsdChrLCB2LCBbJ3JsJywgJ2xyJ10pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdsaW5lJzpcbiAgICAgICAgICB2YXIgdmFscyA9IHYuc3BsaXQoJywnKSxcbiAgICAgICAgICAgIHZhbHMwID0gdmFsc1swXTtcbiAgICAgICAgICBzZXR0aW5ncy5pbnRlZ2VyKGssIHZhbHMwKTtcbiAgICAgICAgICBpZiAoc2V0dGluZ3MucGVyY2VudChrLCB2YWxzMCkpIHtcbiAgICAgICAgICAgIHNldHRpbmdzLnNldCgnc25hcFRvTGluZXMnLCBmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNldHRpbmdzLmFsdChrLCB2YWxzMCwgWydhdXRvJ10pO1xuICAgICAgICAgIGlmICh2YWxzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgc2V0dGluZ3MuYWx0KCdsaW5lQWxpZ24nLCB2YWxzWzFdLCBbJ3N0YXJ0JywgY2VudGVyLCAnZW5kJ10pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAncG9zaXRpb24nOlxuICAgICAgICAgIHZhbHMgPSB2LnNwbGl0KCcsJyk7XG4gICAgICAgICAgc2V0dGluZ3MucGVyY2VudChrLCB2YWxzWzBdKTtcbiAgICAgICAgICBpZiAodmFscy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgIHNldHRpbmdzLmFsdCgncG9zaXRpb25BbGlnbicsIHZhbHNbMV0sIFsnc3RhcnQnLCBjZW50ZXIsICdlbmQnLCAnbGluZS1sZWZ0JywgJ2xpbmUtcmlnaHQnLCAnYXV0byddKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3NpemUnOlxuICAgICAgICAgIHNldHRpbmdzLnBlcmNlbnQoaywgdik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2FsaWduJzpcbiAgICAgICAgICBzZXR0aW5ncy5hbHQoaywgdiwgWydzdGFydCcsIGNlbnRlciwgJ2VuZCcsICdsZWZ0JywgJ3JpZ2h0J10pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0sIC86LywgL1xccy8pO1xuXG4gICAgLy8gQXBwbHkgZGVmYXVsdCB2YWx1ZXMgZm9yIGFueSBtaXNzaW5nIGZpZWxkcy5cbiAgICBjdWUucmVnaW9uID0gc2V0dGluZ3MuZ2V0KCdyZWdpb24nLCBudWxsKTtcbiAgICBjdWUudmVydGljYWwgPSBzZXR0aW5ncy5nZXQoJ3ZlcnRpY2FsJywgJycpO1xuICAgIHZhciBsaW5lID0gc2V0dGluZ3MuZ2V0KCdsaW5lJywgJ2F1dG8nKTtcbiAgICBpZiAobGluZSA9PT0gJ2F1dG8nICYmIGRlZmF1bHRzLmxpbmUgPT09IC0xKSB7XG4gICAgICAvLyBzZXQgbnVtZXJpYyBsaW5lIG51bWJlciBmb3IgU2FmYXJpXG4gICAgICBsaW5lID0gLTE7XG4gICAgfVxuICAgIGN1ZS5saW5lID0gbGluZTtcbiAgICBjdWUubGluZUFsaWduID0gc2V0dGluZ3MuZ2V0KCdsaW5lQWxpZ24nLCAnc3RhcnQnKTtcbiAgICBjdWUuc25hcFRvTGluZXMgPSBzZXR0aW5ncy5nZXQoJ3NuYXBUb0xpbmVzJywgdHJ1ZSk7XG4gICAgY3VlLnNpemUgPSBzZXR0aW5ncy5nZXQoJ3NpemUnLCAxMDApO1xuICAgIGN1ZS5hbGlnbiA9IHNldHRpbmdzLmdldCgnYWxpZ24nLCBjZW50ZXIpO1xuICAgIHZhciBwb3NpdGlvbiA9IHNldHRpbmdzLmdldCgncG9zaXRpb24nLCAnYXV0bycpO1xuICAgIGlmIChwb3NpdGlvbiA9PT0gJ2F1dG8nICYmIGRlZmF1bHRzLnBvc2l0aW9uID09PSA1MCkge1xuICAgICAgLy8gc2V0IG51bWVyaWMgcG9zaXRpb24gZm9yIFNhZmFyaVxuICAgICAgcG9zaXRpb24gPSBjdWUuYWxpZ24gPT09ICdzdGFydCcgfHwgY3VlLmFsaWduID09PSAnbGVmdCcgPyAwIDogY3VlLmFsaWduID09PSAnZW5kJyB8fCBjdWUuYWxpZ24gPT09ICdyaWdodCcgPyAxMDAgOiA1MDtcbiAgICB9XG4gICAgY3VlLnBvc2l0aW9uID0gcG9zaXRpb247XG4gIH1cblxuICBmdW5jdGlvbiBza2lwV2hpdGVzcGFjZSgpIHtcbiAgICBpbnB1dCA9IGlucHV0LnJlcGxhY2UoL15cXHMrLywgJycpO1xuICB9XG5cbiAgLy8gNC4xIFdlYlZUVCBjdWUgdGltaW5ncy5cbiAgc2tpcFdoaXRlc3BhY2UoKTtcbiAgY3VlLnN0YXJ0VGltZSA9IGNvbnN1bWVUaW1lU3RhbXAoKTsgICAvLyAoMSkgY29sbGVjdCBjdWUgc3RhcnQgdGltZVxuICBza2lwV2hpdGVzcGFjZSgpO1xuICBpZiAoaW5wdXQuc3Vic3RyKDAsIDMpICE9PSAnLS0+JykgeyAgICAgLy8gKDMpIG5leHQgY2hhcmFjdGVycyBtdXN0IG1hdGNoICctLT4nXG4gICAgdGhyb3cgbmV3IEVycm9yKCdNYWxmb3JtZWQgdGltZSBzdGFtcCAodGltZSBzdGFtcHMgbXVzdCBiZSBzZXBhcmF0ZWQgYnkgXFwnLS0+XFwnKTogJyArXG4gICAgICBvSW5wdXQpO1xuICB9XG4gIGlucHV0ID0gaW5wdXQuc3Vic3RyKDMpO1xuICBza2lwV2hpdGVzcGFjZSgpO1xuICBjdWUuZW5kVGltZSA9IGNvbnN1bWVUaW1lU3RhbXAoKTsgICAgIC8vICg1KSBjb2xsZWN0IGN1ZSBlbmQgdGltZVxuXG4gIC8vIDQuMSBXZWJWVFQgY3VlIHNldHRpbmdzIGxpc3QuXG4gIHNraXBXaGl0ZXNwYWNlKCk7XG4gIGNvbnN1bWVDdWVTZXR0aW5ncyhpbnB1dCwgY3VlKTtcbn1cblxuZnVuY3Rpb24gZml4TGluZUJyZWFrcyhpbnB1dCkge1xuICByZXR1cm4gaW5wdXQucmVwbGFjZSgvPGJyKD86IFxcLyk/Pi9naSwgJ1xcbicpO1xufVxuXG5WVFRQYXJzZXIucHJvdG90eXBlID0ge1xuICBwYXJzZTogZnVuY3Rpb24oZGF0YSkge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIC8vIElmIHRoZXJlIGlzIG5vIGRhdGEgdGhlbiB3ZSB3b24ndCBkZWNvZGUgaXQsIGJ1dCB3aWxsIGp1c3QgdHJ5IHRvIHBhcnNlXG4gICAgLy8gd2hhdGV2ZXIgaXMgaW4gYnVmZmVyIGFscmVhZHkuIFRoaXMgbWF5IG9jY3VyIGluIGNpcmN1bXN0YW5jZXMsIGZvclxuICAgIC8vIGV4YW1wbGUgd2hlbiBmbHVzaCgpIGlzIGNhbGxlZC5cbiAgICBpZiAoZGF0YSkge1xuICAgICAgLy8gVHJ5IHRvIGRlY29kZSB0aGUgZGF0YSB0aGF0IHdlIHJlY2VpdmVkLlxuICAgICAgc2VsZi5idWZmZXIgKz0gc2VsZi5kZWNvZGVyLmRlY29kZShkYXRhLCB7c3RyZWFtOiB0cnVlfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29sbGVjdE5leHRMaW5lKCkge1xuICAgICAgdmFyIGJ1ZmZlciA9IHNlbGYuYnVmZmVyO1xuICAgICAgdmFyIHBvcyA9IDA7XG5cbiAgICAgIGJ1ZmZlciA9IGZpeExpbmVCcmVha3MoYnVmZmVyKTtcblxuICAgICAgd2hpbGUgKHBvcyA8IGJ1ZmZlci5sZW5ndGggJiYgYnVmZmVyW3Bvc10gIT09ICdcXHInICYmIGJ1ZmZlcltwb3NdICE9PSAnXFxuJykge1xuICAgICAgICArK3BvcztcbiAgICAgIH1cbiAgICAgIHZhciBsaW5lID0gYnVmZmVyLnN1YnN0cigwLCBwb3MpO1xuICAgICAgLy8gQWR2YW5jZSB0aGUgYnVmZmVyIGVhcmx5IGluIGNhc2Ugd2UgZmFpbCBiZWxvdy5cbiAgICAgIGlmIChidWZmZXJbcG9zXSA9PT0gJ1xccicpIHtcbiAgICAgICAgKytwb3M7XG4gICAgICB9XG4gICAgICBpZiAoYnVmZmVyW3Bvc10gPT09ICdcXG4nKSB7XG4gICAgICAgICsrcG9zO1xuICAgICAgfVxuICAgICAgc2VsZi5idWZmZXIgPSBidWZmZXIuc3Vic3RyKHBvcyk7XG4gICAgICByZXR1cm4gbGluZTtcbiAgICB9XG5cbiAgICAvLyAzLjIgV2ViVlRUIG1ldGFkYXRhIGhlYWRlciBzeW50YXhcbiAgICBmdW5jdGlvbiBwYXJzZUhlYWRlcihpbnB1dCkge1xuICAgICAgcGFyc2VPcHRpb25zKGlucHV0LCBmdW5jdGlvbihrLCB2KSB7XG4gICAgICAgIHN3aXRjaCAoaykge1xuICAgICAgICAgIGNhc2UgJ1JlZ2lvbic6XG4gICAgICAgICAgICAvLyAzLjMgV2ViVlRUIHJlZ2lvbiBtZXRhZGF0YSBoZWFkZXIgc3ludGF4XG4gICAgICAgICAgICBjb25zb2xlLmxvZygncGFyc2UgcmVnaW9uJywgdik7XG4gICAgICAgICAgICAvL3BhcnNlUmVnaW9uKHYpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0sIC86Lyk7XG4gICAgfVxuXG4gICAgLy8gNS4xIFdlYlZUVCBmaWxlIHBhcnNpbmcuXG4gICAgdHJ5IHtcbiAgICAgIHZhciBsaW5lO1xuICAgICAgaWYgKHNlbGYuc3RhdGUgPT09ICdJTklUSUFMJykge1xuICAgICAgICAvLyBXZSBjYW4ndCBzdGFydCBwYXJzaW5nIHVudGlsIHdlIGhhdmUgdGhlIGZpcnN0IGxpbmUuXG4gICAgICAgIGlmICghL1xcclxcbnxcXG4vLnRlc3Qoc2VsZi5idWZmZXIpKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBsaW5lID0gY29sbGVjdE5leHRMaW5lKCk7XG5cbiAgICAgICAgdmFyIG0gPSBsaW5lLm1hdGNoKC9eV0VCVlRUKFsgXFx0XS4qKT8kLyk7XG4gICAgICAgIGlmICghbSB8fCAhbVswXSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWFsZm9ybWVkIFdlYlZUVCBzaWduYXR1cmUuJyk7XG4gICAgICAgIH1cblxuICAgICAgICBzZWxmLnN0YXRlID0gJ0hFQURFUic7XG4gICAgICB9XG5cbiAgICAgIHZhciBhbHJlYWR5Q29sbGVjdGVkTGluZSA9IGZhbHNlO1xuICAgICAgd2hpbGUgKHNlbGYuYnVmZmVyKSB7XG4gICAgICAgIC8vIFdlIGNhbid0IHBhcnNlIGEgbGluZSB1bnRpbCB3ZSBoYXZlIHRoZSBmdWxsIGxpbmUuXG4gICAgICAgIGlmICghL1xcclxcbnxcXG4vLnRlc3Qoc2VsZi5idWZmZXIpKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWFscmVhZHlDb2xsZWN0ZWRMaW5lKSB7XG4gICAgICAgICAgbGluZSA9IGNvbGxlY3ROZXh0TGluZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFscmVhZHlDb2xsZWN0ZWRMaW5lID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBzd2l0Y2ggKHNlbGYuc3RhdGUpIHtcbiAgICAgICAgICBjYXNlICdIRUFERVInOlxuICAgICAgICAgICAgLy8gMTMtMTggLSBBbGxvdyBhIGhlYWRlciAobWV0YWRhdGEpIHVuZGVyIHRoZSBXRUJWVFQgbGluZS5cbiAgICAgICAgICAgIGlmICgvOi8udGVzdChsaW5lKSkge1xuICAgICAgICAgICAgICBwYXJzZUhlYWRlcihsaW5lKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIWxpbmUpIHtcbiAgICAgICAgICAgICAgLy8gQW4gZW1wdHkgbGluZSB0ZXJtaW5hdGVzIHRoZSBoZWFkZXIgYW5kIHN0YXJ0cyB0aGUgYm9keSAoY3VlcykuXG4gICAgICAgICAgICAgIHNlbGYuc3RhdGUgPSAnSUQnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgY2FzZSAnTk9URSc6XG4gICAgICAgICAgICAvLyBJZ25vcmUgTk9URSBibG9ja3MuXG4gICAgICAgICAgICBpZiAoIWxpbmUpIHtcbiAgICAgICAgICAgICAgc2VsZi5zdGF0ZSA9ICdJRCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICBjYXNlICdJRCc6XG4gICAgICAgICAgICAvLyBDaGVjayBmb3IgdGhlIHN0YXJ0IG9mIE5PVEUgYmxvY2tzLlxuICAgICAgICAgICAgaWYgKC9eTk9URSgkfFsgXFx0XSkvLnRlc3QobGluZSkpIHtcbiAgICAgICAgICAgICAgc2VsZi5zdGF0ZSA9ICdOT1RFJztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyAxOS0yOSAtIEFsbG93IGFueSBudW1iZXIgb2YgbGluZSB0ZXJtaW5hdG9ycywgdGhlbiBpbml0aWFsaXplIG5ldyBjdWUgdmFsdWVzLlxuICAgICAgICAgICAgaWYgKCFsaW5lKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZi5jdWUgPSBuZXcgVlRUQ3VlKDAsIDAsICcnKTtcbiAgICAgICAgICAgIHNlbGYuc3RhdGUgPSAnQ1VFJztcbiAgICAgICAgICAgIC8vIDMwLTM5IC0gQ2hlY2sgaWYgc2VsZiBsaW5lIGNvbnRhaW5zIGFuIG9wdGlvbmFsIGlkZW50aWZpZXIgb3IgdGltaW5nIGRhdGEuXG4gICAgICAgICAgICBpZiAobGluZS5pbmRleE9mKCctLT4nKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgc2VsZi5jdWUuaWQgPSBsaW5lO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAvLyBQcm9jZXNzIGxpbmUgYXMgc3RhcnQgb2YgYSBjdWUuXG4gICAgICAgICAgLypmYWxscyB0aHJvdWdoKi9cbiAgICAgICAgICBjYXNlICdDVUUnOlxuICAgICAgICAgICAgLy8gNDAgLSBDb2xsZWN0IGN1ZSB0aW1pbmdzIGFuZCBzZXR0aW5ncy5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHBhcnNlQ3VlKGxpbmUsIHNlbGYuY3VlLCBzZWxmLnJlZ2lvbkxpc3QpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAvLyBJbiBjYXNlIG9mIGFuIGVycm9yIGlnbm9yZSByZXN0IG9mIHRoZSBjdWUuXG4gICAgICAgICAgICAgIHNlbGYuY3VlID0gbnVsbDtcbiAgICAgICAgICAgICAgc2VsZi5zdGF0ZSA9ICdCQURDVUUnO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGYuc3RhdGUgPSAnQ1VFVEVYVCc7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICBjYXNlICdDVUVURVhUJzpcbiAgICAgICAgICAgIHZhciBoYXNTdWJzdHJpbmcgPSBsaW5lLmluZGV4T2YoJy0tPicpICE9PSAtMTtcbiAgICAgICAgICAgIC8vIDM0IC0gSWYgd2UgaGF2ZSBhbiBlbXB0eSBsaW5lIHRoZW4gcmVwb3J0IHRoZSBjdWUuXG4gICAgICAgICAgICAvLyAzNSAtIElmIHdlIGhhdmUgdGhlIHNwZWNpYWwgc3Vic3RyaW5nICctLT4nIHRoZW4gcmVwb3J0IHRoZSBjdWUsXG4gICAgICAgICAgICAvLyBidXQgZG8gbm90IGNvbGxlY3QgdGhlIGxpbmUgYXMgd2UgbmVlZCB0byBwcm9jZXNzIHRoZSBjdXJyZW50XG4gICAgICAgICAgICAvLyBvbmUgYXMgYSBuZXcgY3VlLlxuICAgICAgICAgICAgaWYgKCFsaW5lIHx8IGhhc1N1YnN0cmluZyAmJiAoYWxyZWFkeUNvbGxlY3RlZExpbmUgPSB0cnVlKSkge1xuICAgICAgICAgICAgICAvLyBXZSBhcmUgZG9uZSBwYXJzaW5nIHNlbGYgY3VlLlxuICAgICAgICAgICAgICBpZiAoc2VsZi5vbmN1ZSkge1xuICAgICAgICAgICAgICAgIHNlbGYub25jdWUoc2VsZi5jdWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHNlbGYuY3VlID0gbnVsbDtcbiAgICAgICAgICAgICAgc2VsZi5zdGF0ZSA9ICdJRCc7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlbGYuY3VlLnRleHQpIHtcbiAgICAgICAgICAgICAgc2VsZi5jdWUudGV4dCArPSAnXFxuJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGYuY3VlLnRleHQgKz0gbGluZTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIGNhc2UgJ0JBRENVRSc6IC8vIEJBRENVRVxuICAgICAgICAgICAgLy8gNTQtNjIgLSBDb2xsZWN0IGFuZCBkaXNjYXJkIHRoZSByZW1haW5pbmcgY3VlLlxuICAgICAgICAgICAgaWYgKCFsaW5lKSB7XG4gICAgICAgICAgICAgIHNlbGYuc3RhdGUgPSAnSUQnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG5cbiAgICAgIC8vIElmIHdlIGFyZSBjdXJyZW50bHkgcGFyc2luZyBhIGN1ZSwgcmVwb3J0IHdoYXQgd2UgaGF2ZS5cbiAgICAgIGlmIChzZWxmLnN0YXRlID09PSAnQ1VFVEVYVCcgJiYgc2VsZi5jdWUgJiYgc2VsZi5vbmN1ZSkge1xuICAgICAgICBzZWxmLm9uY3VlKHNlbGYuY3VlKTtcbiAgICAgIH1cbiAgICAgIHNlbGYuY3VlID0gbnVsbDtcbiAgICAgIC8vIEVudGVyIEJBRFdFQlZUVCBzdGF0ZSBpZiBoZWFkZXIgd2FzIG5vdCBwYXJzZWQgY29ycmVjdGx5IG90aGVyd2lzZVxuICAgICAgLy8gYW5vdGhlciBleGNlcHRpb24gb2NjdXJyZWQgc28gZW50ZXIgQkFEQ1VFIHN0YXRlLlxuICAgICAgc2VsZi5zdGF0ZSA9IHNlbGYuc3RhdGUgPT09ICdJTklUSUFMJyA/ICdCQURXRUJWVFQnIDogJ0JBRENVRSc7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBmbHVzaDogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRyeSB7XG4gICAgICAvLyBGaW5pc2ggZGVjb2RpbmcgdGhlIHN0cmVhbS5cbiAgICAgIHNlbGYuYnVmZmVyICs9IHNlbGYuZGVjb2Rlci5kZWNvZGUoKTtcbiAgICAgIC8vIFN5bnRoZXNpemUgdGhlIGVuZCBvZiB0aGUgY3VycmVudCBjdWUgb3IgcmVnaW9uLlxuICAgICAgaWYgKHNlbGYuY3VlIHx8IHNlbGYuc3RhdGUgPT09ICdIRUFERVInKSB7XG4gICAgICAgIHNlbGYuYnVmZmVyICs9ICdcXG5cXG4nO1xuICAgICAgICBzZWxmLnBhcnNlKCk7XG4gICAgICB9XG4gICAgICAvLyBJZiB3ZSd2ZSBmbHVzaGVkLCBwYXJzZWQsIGFuZCB3ZSdyZSBzdGlsbCBvbiB0aGUgSU5JVElBTCBzdGF0ZSB0aGVuXG4gICAgICAvLyB0aGF0IG1lYW5zIHdlIGRvbid0IGhhdmUgZW5vdWdoIG9mIHRoZSBzdHJlYW0gdG8gcGFyc2UgdGhlIGZpcnN0XG4gICAgICAvLyBsaW5lLlxuICAgICAgaWYgKHNlbGYuc3RhdGUgPT09ICdJTklUSUFMJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01hbGZvcm1lZCBXZWJWVFQgc2lnbmF0dXJlLicpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IGU7XG4gICAgfVxuICAgIGlmIChzZWxmLm9uZmx1c2gpIHtcbiAgICAgIHNlbGYub25mbHVzaCgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxufTtcblxuZXhwb3J0IHsgZml4TGluZUJyZWFrcyB9O1xuXG5leHBvcnQgZGVmYXVsdCBWVFRQYXJzZXI7XG4iLCJpbXBvcnQgVlRUUGFyc2VyIGZyb20gJy4vdnR0cGFyc2VyJztcblxuLy8gU3RyaW5nLnByb3RvdHlwZS5zdGFydHNXaXRoIGlzIG5vdCBzdXBwb3J0ZWQgaW4gSUUxMVxuY29uc3Qgc3RhcnRzV2l0aCA9IGZ1bmN0aW9uKGlucHV0U3RyaW5nLCBzZWFyY2hTdHJpbmcsIHBvc2l0aW9uKSB7XG4gIHJldHVybiBpbnB1dFN0cmluZy5zdWJzdHIocG9zaXRpb24gfHwgMCwgc2VhcmNoU3RyaW5nLmxlbmd0aCkgPT09IHNlYXJjaFN0cmluZztcbn07XG5cbmNvbnN0IGN1ZVN0cmluZzJtaWxsaXMgPSBmdW5jdGlvbih0aW1lU3RyaW5nKSB7XG4gICAgbGV0IHRzID0gcGFyc2VJbnQodGltZVN0cmluZy5zdWJzdHIoLTMpKTtcbiAgICBsZXQgc2VjcyA9IHBhcnNlSW50KHRpbWVTdHJpbmcuc3Vic3RyKC02LDIpKTtcbiAgICBsZXQgbWlucyA9IHBhcnNlSW50KHRpbWVTdHJpbmcuc3Vic3RyKC05LDIpKTtcbiAgICBsZXQgaG91cnMgPSB0aW1lU3RyaW5nLmxlbmd0aCA+IDkgPyBwYXJzZUludCh0aW1lU3RyaW5nLnN1YnN0cigwLCB0aW1lU3RyaW5nLmluZGV4T2YoJzonKSkpIDogMDtcblxuICAgIGlmIChpc05hTih0cykgfHwgaXNOYU4oc2VjcykgfHwgaXNOYU4obWlucykgfHwgaXNOYU4oaG91cnMpKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICB0cyArPSAxMDAwICogc2VjcztcbiAgICB0cyArPSA2MCoxMDAwICogbWlucztcbiAgICB0cyArPSA2MCo2MCoxMDAwICogaG91cnM7XG5cbiAgICByZXR1cm4gdHM7XG59O1xuXG5jb25zdCBjYWxjdWxhdGVPZmZzZXQgPSBmdW5jdGlvbih2dHRDQ3MsIGNjLCBwcmVzZW50YXRpb25UaW1lKSB7XG4gICAgbGV0IGN1cnJDQyA9IHZ0dENDc1tjY107XG4gICAgbGV0IHByZXZDQyA9IHZ0dENDc1tjdXJyQ0MucHJldkNDXTtcblxuICAgIC8vIFRoaXMgaXMgdGhlIGZpcnN0IGRpc2NvbnRpbnVpdHkgb3IgY3VlcyBoYXZlIGJlZW4gcHJvY2Vzc2VkIHNpbmNlIHRoZSBsYXN0IGRpc2NvbnRpbnVpdHlcbiAgICAvLyBPZmZzZXQgPSBjdXJyZW50IGRpc2NvbnRpbnVpdHkgdGltZVxuICAgIGlmICghcHJldkNDIHx8ICghcHJldkNDLm5ldyAmJiBjdXJyQ0MubmV3KSkge1xuICAgICAgICB2dHRDQ3MuY2NPZmZzZXQgPSB2dHRDQ3MucHJlc2VudGF0aW9uT2Zmc2V0ID0gY3VyckNDLnN0YXJ0O1xuICAgICAgICBjdXJyQ0MubmV3ID0gZmFsc2U7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBUaGVyZSBoYXZlIGJlZW4gZGlzY29udGludWl0aWVzIHNpbmNlIGN1ZXMgd2VyZSBsYXN0IHBhcnNlZC5cbiAgICAvLyBPZmZzZXQgPSB0aW1lIGVsYXBzZWRcbiAgICB3aGlsZSAocHJldkNDICYmIHByZXZDQy5uZXcpIHtcbiAgICAgICAgdnR0Q0NzLmNjT2Zmc2V0ICs9IGN1cnJDQy5zdGFydCAtIHByZXZDQy5zdGFydDtcbiAgICAgICAgY3VyckNDLm5ldyA9IGZhbHNlO1xuICAgICAgICBjdXJyQ0MgPSBwcmV2Q0M7XG4gICAgICAgIHByZXZDQyA9IHZ0dENDc1tjdXJyQ0MucHJldkNDXTtcbiAgICB9XG5cbiAgICB2dHRDQ3MucHJlc2VudGF0aW9uT2Zmc2V0ID0gcHJlc2VudGF0aW9uVGltZTtcbn07XG5cbmNvbnN0IFdlYlZUVFBhcnNlciA9IHtcbiAgICBwYXJzZTogZnVuY3Rpb24odnR0Qnl0ZUFycmF5LCBzeW5jUFRTLCB2dHRDQ3MsIGNjLCBjYWxsQmFjaywgZXJyb3JDYWxsQmFjaykge1xuICAgICAgICAvLyBDb252ZXJ0IGJ5dGVBcnJheSBpbnRvIHN0cmluZywgcmVwbGFjaW5nIGFueSBzb21ld2hhdCBleG90aWMgbGluZWZlZWRzIHdpdGggXCJcXG5cIiwgdGhlbiBzcGxpdCBvbiB0aGF0IGNoYXJhY3Rlci5cbiAgICAgICAgbGV0IHJlID0gL1xcclxcbnxcXG5cXHJ8XFxufFxcci9nO1xuICAgICAgICBsZXQgdnR0TGluZXMgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIG5ldyBVaW50OEFycmF5KHZ0dEJ5dGVBcnJheSkpLnRyaW0oKS5yZXBsYWNlKHJlLCAnXFxuJykuc3BsaXQoJ1xcbicpO1xuICAgICAgICBsZXQgY3VlVGltZSA9ICcwMDowMC4wMDAnO1xuICAgICAgICBsZXQgbXBlZ1RzID0gMDtcbiAgICAgICAgbGV0IGxvY2FsVGltZSA9IDA7XG4gICAgICAgIGxldCBwcmVzZW50YXRpb25UaW1lID0gMDtcbiAgICAgICAgbGV0IGN1ZXMgPSBbXTtcbiAgICAgICAgbGV0IHBhcnNpbmdFcnJvcjtcbiAgICAgICAgbGV0IGluSGVhZGVyID0gdHJ1ZTtcbiAgICAgICAgLy8gbGV0IFZUVEN1ZSA9IFZUVEN1ZSB8fCB3aW5kb3cuVGV4dFRyYWNrQ3VlO1xuXG4gICAgICAgIC8vIENyZWF0ZSBwYXJzZXIgb2JqZWN0IHVzaW5nIFZUVEN1ZSB3aXRoIFRleHRUcmFja0N1ZSBmYWxsYmFjayBvbiBjZXJ0YWluIGJyb3dzZXJzLlxuICAgICAgICBsZXQgcGFyc2VyID0gbmV3IFZUVFBhcnNlcigpO1xuXG4gICAgICAgIHBhcnNlci5vbmN1ZSA9IGZ1bmN0aW9uKGN1ZSkge1xuICAgICAgICAgICAgLy8gQWRqdXN0IGN1ZSB0aW1pbmc7IGNsYW1wIGN1ZXMgdG8gc3RhcnQgbm8gZWFybGllciB0aGFuIC0gYW5kIGRyb3AgY3VlcyB0aGF0IGRvbid0IGVuZCBhZnRlciAtIDAgb24gdGltZWxpbmUuXG4gICAgICAgICAgICBsZXQgY3VyckNDID0gdnR0Q0NzW2NjXTtcbiAgICAgICAgICAgIGxldCBjdWVPZmZzZXQgPSB2dHRDQ3MuY2NPZmZzZXQ7XG5cbiAgICAgICAgICAgIC8vIFVwZGF0ZSBvZmZzZXRzIGZvciBuZXcgZGlzY29udGludWl0aWVzXG4gICAgICAgICAgICBpZiAoY3VyckNDICYmIGN1cnJDQy5uZXcpIHtcbiAgICAgICAgICAgICAgICBpZiAobG9jYWxUaW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdoZW4gbG9jYWwgdGltZSBpcyBwcm92aWRlZCwgb2Zmc2V0ID0gZGlzY29udGludWl0eSBzdGFydCB0aW1lIC0gbG9jYWwgdGltZVxuICAgICAgICAgICAgICAgICAgICBjdWVPZmZzZXQgPSB2dHRDQ3MuY2NPZmZzZXQgPSBjdXJyQ0Muc3RhcnQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsY3VsYXRlT2Zmc2V0KHZ0dENDcywgY2MsIHByZXNlbnRhdGlvblRpbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHByZXNlbnRhdGlvblRpbWUgJiYgIWxvY2FsVGltZSkge1xuICAgICAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgTVBFR1RTIGJ1dCBubyBMT0NBTCB0aW1lLCBvZmZzZXQgPSBwcmVzZW50YXRpb24gdGltZSArIGRpc2NvbnRpbnVpdHkgb2Zmc2V0XG4gICAgICAgICAgICAgICAgY3VlT2Zmc2V0ID0gcHJlc2VudGF0aW9uVGltZSArIHZ0dENDcy5jY09mZnNldCAtIHZ0dENDcy5wcmVzZW50YXRpb25PZmZzZXQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGN1ZS5zdGFydFRpbWUgKz0gY3VlT2Zmc2V0IC0gbG9jYWxUaW1lO1xuICAgICAgICAgICAgY3VlLmVuZFRpbWUgKz0gY3VlT2Zmc2V0IC0gbG9jYWxUaW1lO1xuXG4gICAgICAgICAgICAvLyBGaXggZW5jb2Rpbmcgb2Ygc3BlY2lhbCBjaGFyYWN0ZXJzLiBUT0RPOiBUZXN0IHdpdGggYWxsIHNvcnRzIG9mIHdlaXJkIGNoYXJhY3RlcnMuXG4gICAgICAgICAgICBjdWUudGV4dCA9IGRlY29kZVVSSUNvbXBvbmVudChlc2NhcGUoY3VlLnRleHQpKTtcbiAgICAgICAgICAgIGlmIChjdWUuZW5kVGltZSA+IDApIHtcbiAgICAgICAgICAgICAgY3Vlcy5wdXNoKGN1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgcGFyc2VyLm9ucGFyc2luZ2Vycm9yID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgcGFyc2luZ0Vycm9yID0gZTtcbiAgICAgICAgfTtcblxuICAgICAgICBwYXJzZXIub25mbHVzaCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKHBhcnNpbmdFcnJvciAmJiBlcnJvckNhbGxCYWNrKSB7XG4gICAgICAgICAgICAgICAgZXJyb3JDYWxsQmFjayhwYXJzaW5nRXJyb3IpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhbGxCYWNrKGN1ZXMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEdvIHRocm91Z2ggY29udGVudHMgbGluZSBieSBsaW5lLlxuICAgICAgICB2dHRMaW5lcy5mb3JFYWNoKGxpbmUgPT4ge1xuICAgICAgICAgICAgaWYgKGluSGVhZGVyKSB7XG4gICAgICAgICAgICAgICAgLy8gTG9vayBmb3IgWC1USU1FU1RBTVAtTUFQIGluIGhlYWRlci5cbiAgICAgICAgICAgICAgICBpZiAoc3RhcnRzV2l0aChsaW5lLCAnWC1USU1FU1RBTVAtTUFQPScpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE9uY2UgZm91bmQsIG5vIG1vcmUgYXJlIGFsbG93ZWQgYW55d2F5LCBzbyBzdG9wIHNlYXJjaGluZy5cbiAgICAgICAgICAgICAgICAgICAgaW5IZWFkZXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgLy8gRXh0cmFjdCBMT0NBTCBhbmQgTVBFR1RTLlxuICAgICAgICAgICAgICAgICAgICBsaW5lLnN1YnN0cigxNikuc3BsaXQoJywnKS5mb3JFYWNoKHRpbWVzdGFtcCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhcnRzV2l0aCh0aW1lc3RhbXAsICdMT0NBTDonKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjdWVUaW1lID0gdGltZXN0YW1wLnN1YnN0cig2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RhcnRzV2l0aCh0aW1lc3RhbXAsICdNUEVHVFM6JykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbXBlZ1RzID0gcGFyc2VJbnQodGltZXN0YW1wLnN1YnN0cig3KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHN1YnRpdGxlIG9mZnNldCBpbiBtaWxsaXNlY29uZHMuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBzeW5jIFBUUyBpcyBsZXNzIHRoYW4gemVybywgd2UgaGF2ZSBhIDMzLWJpdCB3cmFwYXJvdW5kLCB3aGljaCBpcyBmaXhlZCBieSBhZGRpbmcgMl4zMyA9IDg1ODk5MzQ1OTIuXG4gICAgICAgICAgICAgICAgICAgICAgICBzeW5jUFRTID0gc3luY1BUUyA8IDAgPyBzeW5jUFRTICsgODU4OTkzNDU5MiA6IHN5bmNQVFM7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBZGp1c3QgTVBFR1RTIGJ5IHN5bmMgUFRTLlxuICAgICAgICAgICAgICAgICAgICAgICAgbXBlZ1RzIC09IHN5bmNQVFM7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDb252ZXJ0IGN1ZSB0aW1lIHRvIHNlY29uZHNcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsVGltZSA9IGN1ZVN0cmluZzJtaWxsaXMoY3VlVGltZSkgLyAxMDAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29udmVydCBNUEVHVFMgdG8gc2Vjb25kcyBmcm9tIDkwa0h6LlxuICAgICAgICAgICAgICAgICAgICAgICAgcHJlc2VudGF0aW9uVGltZSA9IG1wZWdUcyAvIDkwMDAwO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobG9jYWxUaW1lID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNpbmdFcnJvciA9IG5ldyBFcnJvcihgTWFsZm9ybWVkIFgtVElNRVNUQU1QLU1BUDogJHtsaW5lfWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNpbmdFcnJvciA9IG5ldyBFcnJvcihgTWFsZm9ybWVkIFgtVElNRVNUQU1QLU1BUDogJHtsaW5lfWApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFJldHVybiB3aXRob3V0IHBhcnNpbmcgWC1USU1FU1RBTVAtTUFQIGxpbmUuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGxpbmUgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICBpbkhlYWRlciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFBhcnNlIGxpbmUgYnkgZGVmYXVsdC5cbiAgICAgICAgICAgIHBhcnNlci5wYXJzZShsaW5lKydcXG4nKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcGFyc2VyLmZsdXNoKCk7XG4gICAgfVxufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IFdlYlZUVFBhcnNlcjtcbiIsIi8qKlxuICogWEhSIGJhc2VkIGxvZ2dlclxuKi9cblxuaW1wb3J0IHtsb2dnZXJ9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XG5cbmNsYXNzIFhockxvYWRlciB7XG5cbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgaWYgKGNvbmZpZyAmJiBjb25maWcueGhyU2V0dXApIHtcbiAgICAgIHRoaXMueGhyU2V0dXAgPSBjb25maWcueGhyU2V0dXA7XG4gICAgfVxuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmFib3J0KCk7XG4gICAgdGhpcy5sb2FkZXIgPSBudWxsO1xuICB9XG5cbiAgYWJvcnQoKSB7XG4gICAgdmFyIGxvYWRlciA9IHRoaXMubG9hZGVyO1xuICAgIGlmIChsb2FkZXIgJiYgbG9hZGVyLnJlYWR5U3RhdGUgIT09IDQpIHtcbiAgICAgIHRoaXMuc3RhdHMuYWJvcnRlZCA9IHRydWU7XG4gICAgICBsb2FkZXIuYWJvcnQoKTtcbiAgICB9XG5cbiAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMucmVxdWVzdFRpbWVvdXQpO1xuICAgIHRoaXMucmVxdWVzdFRpbWVvdXQgPSBudWxsO1xuICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGhpcy5yZXRyeVRpbWVvdXQpO1xuICAgIHRoaXMucmV0cnlUaW1lb3V0ID0gbnVsbDtcbiAgfVxuXG4gIGxvYWQoY29udGV4dCwgY29uZmlnLCBjYWxsYmFja3MpIHtcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgIHRoaXMuY2FsbGJhY2tzID0gY2FsbGJhY2tzO1xuICAgIHRoaXMuc3RhdHMgPSB7dHJlcXVlc3Q6IHBlcmZvcm1hbmNlLm5vdygpLCByZXRyeTogMH07XG4gICAgdGhpcy5yZXRyeURlbGF5ID0gY29uZmlnLnJldHJ5RGVsYXk7XG4gICAgdGhpcy5sb2FkSW50ZXJuYWwoKTtcbiAgfVxuXG4gIGxvYWRJbnRlcm5hbCgpIHtcbiAgICB2YXIgeGhyLCBjb250ZXh0ID0gdGhpcy5jb250ZXh0O1xuXG4gICAgaWYgKHR5cGVvZiBYRG9tYWluUmVxdWVzdCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICB4aHIgPSB0aGlzLmxvYWRlciA9IG5ldyBYRG9tYWluUmVxdWVzdCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgeGhyID0gdGhpcy5sb2FkZXIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICB9XG4gICAgbGV0IHN0YXRzID0gdGhpcy5zdGF0cztcbiAgICBzdGF0cy50Zmlyc3QgPSAwO1xuICAgIHN0YXRzLmxvYWRlZCA9IDA7XG4gICAgY29uc3QgeGhyU2V0dXAgPSB0aGlzLnhoclNldHVwO1xuXG4gICAgdHJ5IHtcbiAgICAgIGlmICh4aHJTZXR1cCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHhoclNldHVwKHhociwgY29udGV4dC51cmwpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgLy8gZml4IHhoclNldHVwOiAoeGhyLCB1cmwpID0+IHt4aHIuc2V0UmVxdWVzdEhlYWRlcihcIkNvbnRlbnQtTGFuZ3VhZ2VcIiwgXCJ0ZXN0XCIpO31cbiAgICAgICAgICAvLyBub3Qgd29ya2luZywgYXMgeGhyLnNldFJlcXVlc3RIZWFkZXIgZXhwZWN0cyB4aHIucmVhZHlTdGF0ZSA9PT0gT1BFTlxuICAgICAgICAgIHhoci5vcGVuKCdHRVQnLCBjb250ZXh0LnVybCwgdHJ1ZSk7XG4gICAgICAgICAgeGhyU2V0dXAoeGhyLCBjb250ZXh0LnVybCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICgheGhyLnJlYWR5U3RhdGUpIHtcbiAgICAgICAgeGhyLm9wZW4oJ0dFVCcsIGNvbnRleHQudXJsLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBJRTExIHRocm93cyBhbiBleGNlcHRpb24gb24geGhyLm9wZW4gaWYgYXR0ZW1wdGluZyB0byBhY2Nlc3MgYW4gSFRUUCByZXNvdXJjZSBvdmVyIEhUVFBTXG4gICAgICB0aGlzLmNhbGxiYWNrcy5vbkVycm9yKHsgY29kZSA6IHhoci5zdGF0dXMsIHRleHQ6IGUubWVzc2FnZSB9LCBjb250ZXh0KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoY29udGV4dC5yYW5nZUVuZCkge1xuICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ1JhbmdlJywnYnl0ZXM9JyArIGNvbnRleHQucmFuZ2VTdGFydCArICctJyArIChjb250ZXh0LnJhbmdlRW5kLTEpKTtcbiAgICB9XG4gICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IHRoaXMucmVhZHlzdGF0ZWNoYW5nZS5iaW5kKHRoaXMpO1xuICAgIHhoci5vbnByb2dyZXNzID0gdGhpcy5sb2FkcHJvZ3Jlc3MuYmluZCh0aGlzKTtcbiAgICB4aHIucmVzcG9uc2VUeXBlID0gY29udGV4dC5yZXNwb25zZVR5cGU7XG5cbiAgICAvLyBzZXR1cCB0aW1lb3V0IGJlZm9yZSB3ZSBwZXJmb3JtIHJlcXVlc3RcbiAgICB0aGlzLnJlcXVlc3RUaW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQodGhpcy5sb2FkdGltZW91dC5iaW5kKHRoaXMpLCB0aGlzLmNvbmZpZy50aW1lb3V0KTtcbiAgICB4aHIuc2VuZCgpO1xuICB9XG5cbiAgcmVhZHlzdGF0ZWNoYW5nZShldmVudCkge1xuICAgIHZhciB4aHIgPSBldmVudC5jdXJyZW50VGFyZ2V0LFxuICAgICAgICByZWFkeVN0YXRlID0geGhyLnJlYWR5U3RhdGUsXG4gICAgICAgIHN0YXRzID0gdGhpcy5zdGF0cyxcbiAgICAgICAgY29udGV4dCA9IHRoaXMuY29udGV4dCxcbiAgICAgICAgY29uZmlnID0gdGhpcy5jb25maWc7XG5cbiAgICAvLyBkb24ndCBwcm9jZWVkIGlmIHhociBoYXMgYmVlbiBhYm9ydGVkXG4gICAgaWYgKHN0YXRzLmFib3J0ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyA+PSBIRUFERVJTX1JFQ0VJVkVEXG4gICAgaWYgKHJlYWR5U3RhdGUgPj0yKSB7XG4gICAgICAvLyBjbGVhciB4aHIgdGltZW91dCBhbmQgcmVhcm0gaXQgaWYgcmVhZHlTdGF0ZSBsZXNzIHRoYW4gNFxuICAgICAgd2luZG93LmNsZWFyVGltZW91dCh0aGlzLnJlcXVlc3RUaW1lb3V0KTtcbiAgICAgIGlmIChzdGF0cy50Zmlyc3QgPT09IDApIHtcbiAgICAgICAgc3RhdHMudGZpcnN0ID0gTWF0aC5tYXgocGVyZm9ybWFuY2Uubm93KCksIHN0YXRzLnRyZXF1ZXN0KTtcbiAgICAgIH1cbiAgICAgIGlmIChyZWFkeVN0YXRlID09PSA0KSB7XG4gICAgICAgIGxldCBzdGF0dXMgPSB4aHIuc3RhdHVzO1xuICAgICAgICAvLyBodHRwIHN0YXR1cyBiZXR3ZWVuIDIwMCB0byAyOTkgYXJlIGFsbCBzdWNjZXNzZnVsXG4gICAgICAgIGlmIChzdGF0dXMgPj0gMjAwICYmIHN0YXR1cyA8IDMwMCkgIHtcbiAgICAgICAgICBzdGF0cy50bG9hZCA9IE1hdGgubWF4KHN0YXRzLnRmaXJzdCxwZXJmb3JtYW5jZS5ub3coKSk7XG4gICAgICAgICAgbGV0IGRhdGEsbGVuO1xuICAgICAgICAgIGlmIChjb250ZXh0LnJlc3BvbnNlVHlwZSA9PT0gJ2FycmF5YnVmZmVyJykge1xuICAgICAgICAgICAgZGF0YSA9IHhoci5yZXNwb25zZTtcbiAgICAgICAgICAgIGxlbiA9IGRhdGEuYnl0ZUxlbmd0aDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGF0YSA9IHhoci5yZXNwb25zZVRleHQ7XG4gICAgICAgICAgICBsZW4gPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3RhdHMubG9hZGVkID0gc3RhdHMudG90YWwgPSBsZW47XG4gICAgICAgICAgbGV0IHJlc3BvbnNlID0geyB1cmwgOiB4aHIucmVzcG9uc2VVUkwsIGRhdGEgOiBkYXRhIH07XG4gICAgICAgICAgdGhpcy5jYWxsYmFja3Mub25TdWNjZXNzKHJlc3BvbnNlLCBzdGF0cywgY29udGV4dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBpZiBtYXggbmIgb2YgcmV0cmllcyByZWFjaGVkIG9yIGlmIGh0dHAgc3RhdHVzIGJldHdlZW4gNDAwIGFuZCA0OTkgKHN1Y2ggZXJyb3IgY2Fubm90IGJlIHJlY292ZXJlZCwgcmV0cnlpbmcgaXMgdXNlbGVzcyksIHJldHVybiBlcnJvclxuICAgICAgICAgIGlmIChzdGF0cy5yZXRyeSA+PSBjb25maWcubWF4UmV0cnkgfHwgKHN0YXR1cyA+PSA0MDAgJiYgc3RhdHVzIDwgNDk5KSkge1xuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGAke3N0YXR1c30gd2hpbGUgbG9hZGluZyAke2NvbnRleHQudXJsfWAgKTtcbiAgICAgICAgICAgIHRoaXMuY2FsbGJhY2tzLm9uRXJyb3IoeyBjb2RlIDogc3RhdHVzLCB0ZXh0IDogeGhyLnN0YXR1c1RleHR9LCBjb250ZXh0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gcmV0cnlcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKGAke3N0YXR1c30gd2hpbGUgbG9hZGluZyAke2NvbnRleHQudXJsfSwgcmV0cnlpbmcgaW4gJHt0aGlzLnJldHJ5RGVsYXl9Li4uYCk7XG4gICAgICAgICAgICAvLyBhYm9ydHMgYW5kIHJlc2V0cyBpbnRlcm5hbCBzdGF0ZVxuICAgICAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgICAgICAgICAvLyBzY2hlZHVsZSByZXRyeVxuICAgICAgICAgICAgdGhpcy5yZXRyeVRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dCh0aGlzLmxvYWRJbnRlcm5hbC5iaW5kKHRoaXMpLCB0aGlzLnJldHJ5RGVsYXkpO1xuICAgICAgICAgICAgLy8gc2V0IGV4cG9uZW50aWFsIGJhY2tvZmZcbiAgICAgICAgICAgIHRoaXMucmV0cnlEZWxheSA9IE1hdGgubWluKDIgKiB0aGlzLnJldHJ5RGVsYXksIGNvbmZpZy5tYXhSZXRyeURlbGF5KTtcbiAgICAgICAgICAgIHN0YXRzLnJldHJ5Kys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyByZWFkeVN0YXRlID49IDIgQU5EIHJlYWR5U3RhdGUgIT09NCAocmVhZHlTdGF0ZSA9IEhFQURFUlNfUkVDRUlWRUQgfHwgTE9BRElORykgcmVhcm0gdGltZW91dCBhcyB4aHIgbm90IGZpbmlzaGVkIHlldFxuICAgICAgICB0aGlzLnJlcXVlc3RUaW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQodGhpcy5sb2FkdGltZW91dC5iaW5kKHRoaXMpLCBjb25maWcudGltZW91dCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgbG9hZHRpbWVvdXQoKSB7XG4gICAgbG9nZ2VyLndhcm4oYHRpbWVvdXQgd2hpbGUgbG9hZGluZyAke3RoaXMuY29udGV4dC51cmx9YCApO1xuICAgIHRoaXMuY2FsbGJhY2tzLm9uVGltZW91dCh0aGlzLnN0YXRzLCB0aGlzLmNvbnRleHQpO1xuICB9XG5cbiAgbG9hZHByb2dyZXNzKGV2ZW50KSB7XG4gICAgdmFyIHN0YXRzID0gdGhpcy5zdGF0cztcbiAgICBzdGF0cy5sb2FkZWQgPSBldmVudC5sb2FkZWQ7XG4gICAgaWYgKGV2ZW50Lmxlbmd0aENvbXB1dGFibGUpIHtcbiAgICAgIHN0YXRzLnRvdGFsID0gZXZlbnQudG90YWw7XG4gICAgfVxuICAgIGxldCBvblByb2dyZXNzID0gdGhpcy5jYWxsYmFja3Mub25Qcm9ncmVzcztcbiAgICBpZiAob25Qcm9ncmVzcykge1xuICAgICAgLy8gbGFzdCBhcmdzIGlzIHRvIHByb3ZpZGUgb24gcHJvZ3Jlc3MgZGF0YVxuICAgICAgb25Qcm9ncmVzcyhzdGF0cywgdGhpcy5jb250ZXh0LCBudWxsKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgWGhyTG9hZGVyO1xuIl19
