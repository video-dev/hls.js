(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.Hls = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      } else {
        // At least give some kind of context to the user
        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
        err.context = er;
        throw err;
      }
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    args = Array.prototype.slice.call(arguments, 1);
    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else if (listeners) {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.prototype.listenerCount = function(type) {
  if (this._events) {
    var evlistener = this._events[type];

    if (isFunction(evlistener))
      return 1;
    else if (evlistener)
      return evlistener.length;
  }
  return 0;
};

EventEmitter.listenerCount = function(emitter, type) {
  return emitter.listenerCount(type);
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],2:[function(require,module,exports){
// see https://tools.ietf.org/html/rfc1808

/* jshint ignore:start */
(function(root) { 
/* jshint ignore:end */

  var URL_REGEX = /^((?:[^\/;?#]+:)?)(\/\/[^\/\;?#]*)?(.*?)??(;.*?)?(\?.*?)?(#.*?)?$/;
  var FIRST_SEGMENT_REGEX = /^([^\/;?#]*)(.*)$/;
  var SLASH_DOT_REGEX = /(?:\/|^)\.(?=\/)/g;
  var SLASH_DOT_DOT_REGEX = /(?:\/|^)\.\.\/(?!\.\.\/).*?(?=\/)/g;

  var URLToolkit = { // jshint ignore:line
    // If opts.alwaysNormalize is true then the path will always be normalized even when it starts with / or //
    // E.g
    // With opts.alwaysNormalize = false (default, spec compliant)
    // http://a.com/b/cd + /e/f/../g => http://a.com/e/f/../g
    // With opts.alwaysNormalize = true (default, not spec compliant)
    // http://a.com/b/cd + /e/f/../g => http://a.com/e/g
    buildAbsoluteURL: function(baseURL, relativeURL, opts) {
      opts = opts || {};
      // remove any remaining space and CRLF
      baseURL = baseURL.trim();
      relativeURL = relativeURL.trim();
      if (!relativeURL) {
        // 2a) If the embedded URL is entirely empty, it inherits the
        // entire base URL (i.e., is set equal to the base URL)
        // and we are done.
        if (!opts.alwaysNormalize) {
          return baseURL;
        }
        var basePartsForNormalise = this.parseURL(baseURL);
        if (!baseParts) {
          throw new Error('Error trying to parse base URL.');
        }
        basePartsForNormalise.path = URLToolkit.normalizePath(basePartsForNormalise.path);
        return URLToolkit.buildURLFromParts(basePartsForNormalise);
      }
      var relativeParts = this.parseURL(relativeURL);
      if (!relativeParts) {
        throw new Error('Error trying to parse relative URL.');
      }
      if (relativeParts.scheme) {
        // 2b) If the embedded URL starts with a scheme name, it is
        // interpreted as an absolute URL and we are done.
        if (!opts.alwaysNormalize) {
          return relativeURL;
        }
        relativeParts.path = URLToolkit.normalizePath(relativeParts.path);
        return URLToolkit.buildURLFromParts(relativeParts);
      }
      var baseParts = this.parseURL(baseURL);
      if (!baseParts) {
        throw new Error('Error trying to parse base URL.');
      }
      if (!baseParts.netLoc && baseParts.path && baseParts.path[0] !== '/') {
        // If netLoc missing and path doesn't start with '/', assume everthing before the first '/' is the netLoc
        // This causes 'example.com/a' to be handled as '//example.com/a' instead of '/example.com/a'
        var pathParts = FIRST_SEGMENT_REGEX.exec(baseParts.path);
        baseParts.netLoc = pathParts[1];
        baseParts.path = pathParts[2];
      }
      if (baseParts.netLoc && !baseParts.path) {
        baseParts.path = '/';
      }
      var builtParts = {
        // 2c) Otherwise, the embedded URL inherits the scheme of
        // the base URL.
        scheme: baseParts.scheme,
        netLoc: relativeParts.netLoc,
        path: null,
        params: relativeParts.params,
        query: relativeParts.query,
        fragment: relativeParts.fragment
      };
      if (!relativeParts.netLoc) {
        // 3) If the embedded URL's <net_loc> is non-empty, we skip to
        // Step 7.  Otherwise, the embedded URL inherits the <net_loc>
        // (if any) of the base URL.
        builtParts.netLoc = baseParts.netLoc;
        // 4) If the embedded URL path is preceded by a slash "/", the
        // path is not relative and we skip to Step 7.
        if (relativeParts.path[0] !== '/') {
          if (!relativeParts.path) {
            // 5) If the embedded URL path is empty (and not preceded by a
            // slash), then the embedded URL inherits the base URL path
            builtParts.path = baseParts.path;
            // 5a) if the embedded URL's <params> is non-empty, we skip to
            // step 7; otherwise, it inherits the <params> of the base
            // URL (if any) and
            if (!relativeParts.params) {
              builtParts.params = baseParts.params;
              // 5b) if the embedded URL's <query> is non-empty, we skip to
              // step 7; otherwise, it inherits the <query> of the base
              // URL (if any) and we skip to step 7.
              if (!relativeParts.query) {
                builtParts.query = baseParts.query;
              }
            }
          } else {
            // 6) The last segment of the base URL's path (anything
            // following the rightmost slash "/", or the entire path if no
            // slash is present) is removed and the embedded URL's path is
            // appended in its place.
            var baseURLPath = baseParts.path;
            var newPath = baseURLPath.substring(0, baseURLPath.lastIndexOf('/') + 1) + relativeParts.path;
            builtParts.path = URLToolkit.normalizePath(newPath);
          }
        }
      }
      if (builtParts.path === null) {
        builtParts.path = opts.alwaysNormalize ? URLToolkit.normalizePath(relativeParts.path) : relativeParts.path;
      }
      return URLToolkit.buildURLFromParts(builtParts);
    },
    parseURL: function(url) {
      var parts = URL_REGEX.exec(url);
      if (!parts) {
        return null;
      }
      return {
        scheme: parts[1] || '',
        netLoc: parts[2] || '',
        path: parts[3] || '',
        params: parts[4] || '',
        query: parts[5] || '',
        fragment: parts[6] || ''
      };
    },
    normalizePath: function(path) {
      // The following operations are
      // then applied, in order, to the new path:
      // 6a) All occurrences of "./", where "." is a complete path
      // segment, are removed.
      // 6b) If the path ends with "." as a complete path segment,
      // that "." is removed.
      path = path.split('').reverse().join('').replace(SLASH_DOT_REGEX, '');
      // 6c) All occurrences of "<segment>/../", where <segment> is a
      // complete path segment not equal to "..", are removed.
      // Removal of these path segments is performed iteratively,
      // removing the leftmost matching pattern on each iteration,
      // until no matching pattern remains.
      // 6d) If the path ends with "<segment>/..", where <segment> is a
      // complete path segment not equal to "..", that
      // "<segment>/.." is removed.
      while (path.length !== (path = path.replace(SLASH_DOT_DOT_REGEX, '')).length) {} // jshint ignore:line
      return path.split('').reverse().join('');
    },
    buildURLFromParts: function(parts) {
      return parts.scheme + parts.netLoc + parts.path + parts.params + parts.query + parts.fragment;
    }
  };

/* jshint ignore:start */
  if(typeof exports === 'object' && typeof module === 'object')
    module.exports = URLToolkit;
  else if(typeof define === 'function' && define.amd)
    define([], function() { return URLToolkit; });
  else if(typeof exports === 'object')
    exports["URLToolkit"] = URLToolkit;
  else
    root["URLToolkit"] = URLToolkit;
})(this);
/* jshint ignore:end */

},{}],3:[function(require,module,exports){
var bundleFn = arguments[3];
var sources = arguments[4];
var cache = arguments[5];

var stringify = JSON.stringify;

module.exports = function (fn, options) {
    var wkey;
    var cacheKeys = Object.keys(cache);

    for (var i = 0, l = cacheKeys.length; i < l; i++) {
        var key = cacheKeys[i];
        var exp = cache[key].exports;
        // Using babel as a transpiler to use esmodule, the export will always
        // be an object with the default export as a property of it. To ensure
        // the existing api and babel esmodule exports are both supported we
        // check for both
        if (exp === fn || exp && exp.default === fn) {
            wkey = key;
            break;
        }
    }

    if (!wkey) {
        wkey = Math.floor(Math.pow(16, 8) * Math.random()).toString(16);
        var wcache = {};
        for (var i = 0, l = cacheKeys.length; i < l; i++) {
            var key = cacheKeys[i];
            wcache[key] = key;
        }
        sources[wkey] = [
            Function(['require','module','exports'], '(' + fn + ')(self)'),
            wcache
        ];
    }
    var skey = Math.floor(Math.pow(16, 8) * Math.random()).toString(16);

    var scache = {}; scache[wkey] = wkey;
    sources[skey] = [
        Function(['require'], (
            // try to call default if defined to also support babel esmodule
            // exports
            'var f = require(' + stringify(wkey) + ');' +
            '(f.default ? f.default : f)(self);'
        )),
        scache
    ];

    var workerSources = {};
    resolveSources(skey);

    function resolveSources(key) {
        workerSources[key] = true;

        for (var depPath in sources[key][1]) {
            var depKey = sources[key][1][depPath];
            if (!workerSources[depKey]) {
                resolveSources(depKey);
            }
        }
    }

    var src = '(' + bundleFn + ')({'
        + Object.keys(workerSources).map(function (key) {
            return stringify(key) + ':['
                + sources[key][0]
                + ',' + stringify(sources[key][1]) + ']'
            ;
        }).join(',')
        + '},{},[' + stringify(skey) + '])'
    ;

    var URL = window.URL || window.webkitURL || window.mozURL || window.msURL;

    var blob = new Blob([src], { type: 'text/javascript' });
    if (options && options.bare) { return blob; }
    var workerUrl = URL.createObjectURL(blob);
    var worker = new Worker(workerUrl);
    worker.objectURL = workerUrl;
    return worker;
};

},{}],4:[function(require,module,exports){
/**
 * HLS config
 */
'use strict';

Object.defineProperty(exports, "__esModule", {
      value: true
});
exports.hlsDefaultConfig = undefined;

var _abrController = require('./controller/abr-controller');

var _abrController2 = _interopRequireDefault(_abrController);

var _bufferController = require('./controller/buffer-controller');

var _bufferController2 = _interopRequireDefault(_bufferController);

var _capLevelController = require('./controller/cap-level-controller');

var _capLevelController2 = _interopRequireDefault(_capLevelController);

var _fpsController = require('./controller/fps-controller');

var _fpsController2 = _interopRequireDefault(_fpsController);

var _xhrLoader = require('./utils/xhr-loader');

var _xhrLoader2 = _interopRequireDefault(_xhrLoader);

var _audioTrackController = require('./controller/audio-track-controller');

var _audioTrackController2 = _interopRequireDefault(_audioTrackController);

var _audioStreamController = require('./controller/audio-stream-controller');

var _audioStreamController2 = _interopRequireDefault(_audioStreamController);

var _cues = require('./utils/cues');

var _cues2 = _interopRequireDefault(_cues);

var _timelineController = require('./controller/timeline-controller');

var _timelineController2 = _interopRequireDefault(_timelineController);

var _subtitleTrackController = require('./controller/subtitle-track-controller');

var _subtitleTrackController2 = _interopRequireDefault(_subtitleTrackController);

var _subtitleStreamController = require('./controller/subtitle-stream-controller');

var _subtitleStreamController2 = _interopRequireDefault(_subtitleStreamController);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

//#endif

//#endif

//#if subtitle

//import FetchLoader from './utils/fetch-loader';
//#if altaudio
var hlsDefaultConfig = exports.hlsDefaultConfig = {
      autoStartLoad: true, // used by stream-controller
      startPosition: -1, // used by stream-controller
      defaultAudioCodec: undefined, // used by stream-controller
      debug: false, // used by logger
      capLevelOnFPSDrop: false, // used by fps-controller
      capLevelToPlayerSize: false, // used by cap-level-controller
      initialLiveManifestSize: 1, // used by stream-controller
      maxBufferLength: 30, // used by stream-controller
      maxBufferSize: 60 * 1000 * 1000, // used by stream-controller
      maxBufferHole: 0.5, // used by stream-controller
      maxSeekHole: 2, // used by stream-controller
      lowBufferWatchdogPeriod: 0.5, // used by stream-controller
      highBufferWatchdogPeriod: 3, // used by stream-controller
      nudgeOffset: 0.1, // used by stream-controller
      nudgeMaxRetry: 3, // used by stream-controller
      maxFragLookUpTolerance: 0.25, // used by stream-controller
      liveSyncDurationCount: 3, // used by stream-controller
      liveMaxLatencyDurationCount: Infinity, // used by stream-controller
      liveSyncDuration: undefined, // used by stream-controller
      liveMaxLatencyDuration: undefined, // used by stream-controller
      maxMaxBufferLength: 600, // used by stream-controller
      enableWorker: true, // used by demuxer
      enableSoftwareAES: true, // used by decrypter
      manifestLoadingTimeOut: 10000, // used by playlist-loader
      manifestLoadingMaxRetry: 1, // used by playlist-loader
      manifestLoadingRetryDelay: 1000, // used by playlist-loader
      manifestLoadingMaxRetryTimeout: 64000, // used by playlist-loader
      startLevel: undefined, // used by level-controller
      levelLoadingTimeOut: 10000, // used by playlist-loader
      levelLoadingMaxRetry: 4, // used by playlist-loader
      levelLoadingRetryDelay: 1000, // used by playlist-loader
      levelLoadingMaxRetryTimeout: 64000, // used by playlist-loader
      fragLoadingTimeOut: 20000, // used by fragment-loader
      fragLoadingMaxRetry: 6, // used by fragment-loader
      fragLoadingRetryDelay: 1000, // used by fragment-loader
      fragLoadingMaxRetryTimeout: 64000, // used by fragment-loader
      fragLoadingLoopThreshold: 3, // used by stream-controller
      startFragPrefetch: false, // used by stream-controller
      fpsDroppedMonitoringPeriod: 5000, // used by fps-controller
      fpsDroppedMonitoringThreshold: 0.2, // used by fps-controller
      appendErrorMaxRetry: 3, // used by buffer-controller
      loader: _xhrLoader2.default,
      //loader: FetchLoader,
      fLoader: undefined,
      pLoader: undefined,
      xhrSetup: undefined,
      fetchSetup: undefined,
      abrController: _abrController2.default,
      bufferController: _bufferController2.default,
      capLevelController: _capLevelController2.default,
      fpsController: _fpsController2.default,
      //#if altaudio
      audioStreamController: _audioStreamController2.default,
      audioTrackController: _audioTrackController2.default,
      //#endif
      //#if subtitle
      subtitleStreamController: _subtitleStreamController2.default,
      subtitleTrackController: _subtitleTrackController2.default,
      timelineController: _timelineController2.default,
      cueHandler: _cues2.default,
      enableCEA708Captions: true, // used by timeline-controller
      enableWebVTT: true, // used by timeline-controller
      captionsTextTrack1Label: 'English', // used by timeline-controller
      captionsTextTrack1LanguageCode: 'en', // used by timeline-controller
      captionsTextTrack2Label: 'Spanish', // used by timeline-controller
      captionsTextTrack2LanguageCode: 'es', // used by timeline-controller
      //#endif
      stretchShortVideoTrack: false, // used by mp4-remuxer
      forceKeyFrameOnDiscontinuity: true, // used by ts-demuxer
      abrEwmaFastLive: 3, // used by abr-controller
      abrEwmaSlowLive: 9, // used by abr-controller
      abrEwmaFastVoD: 3, // used by abr-controller
      abrEwmaSlowVoD: 9, // used by abr-controller
      abrEwmaDefaultEstimate: 5e5, // 500 kbps  // used by abr-controller
      abrBandWidthFactor: 0.95, // used by abr-controller
      abrBandWidthUpFactor: 0.7, // used by abr-controller
      abrMaxWithRealBitrate: false, // used by abr-controller
      maxStarvationDelay: 4, // used by abr-controller
      maxLoadingDelay: 4, // used by abr-controller
      minAutoBitrate: 0 // used by hls
};

},{"./controller/abr-controller":5,"./controller/audio-stream-controller":6,"./controller/audio-track-controller":7,"./controller/buffer-controller":8,"./controller/cap-level-controller":9,"./controller/fps-controller":10,"./controller/subtitle-stream-controller":14,"./controller/subtitle-track-controller":15,"./controller/timeline-controller":16,"./utils/cues":50,"./utils/xhr-loader":59}],5:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _eventHandler = require('../event-handler');

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _bufferHelper = require('../helper/buffer-helper');

var _bufferHelper2 = _interopRequireDefault(_bufferHelper);

var _errors = require('../errors');

var _logger = require('../utils/logger');

var _ewmaBandwidthEstimator = require('../utils/ewma-bandwidth-estimator');

var _ewmaBandwidthEstimator2 = _interopRequireDefault(_ewmaBandwidthEstimator);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * simple ABR Controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *  - compute next level based on last fragment bw heuristics
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *  - implement an abandon rules triggered if we have less than 2 frag buffered and if computed bw shows that we risk buffer stalling
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

var AbrController = function (_EventHandler) {
  _inherits(AbrController, _EventHandler);

  function AbrController(hls) {
    _classCallCheck(this, AbrController);

    var _this = _possibleConstructorReturn(this, (AbrController.__proto__ || Object.getPrototypeOf(AbrController)).call(this, hls, _events2.default.FRAG_LOADING, _events2.default.FRAG_LOADED, _events2.default.FRAG_BUFFERED, _events2.default.ERROR));

    _this.lastLoadedFragLevel = 0;
    _this._nextAutoLevel = -1;
    _this.hls = hls;
    _this.timer = null;
    _this._bwEstimator = null;
    _this.onCheck = _this._abandonRulesCheck.bind(_this);
    return _this;
  }

  _createClass(AbrController, [{
    key: 'destroy',
    value: function destroy() {
      this.clearTimer();
      _eventHandler2.default.prototype.destroy.call(this);
    }
  }, {
    key: 'onFragLoading',
    value: function onFragLoading(data) {
      var frag = data.frag;
      if (frag.type === 'main') {
        if (!this.timer) {
          this.timer = setInterval(this.onCheck, 100);
        }
        // lazy init of bw Estimator, rationale is that we use different params for Live/VoD
        // so we need to wait for stream manifest / playlist type to instantiate it.
        if (!this._bwEstimator) {
          var hls = this.hls,
              level = data.frag.level,
              isLive = hls.levels[level].details.live,
              config = hls.config,
              ewmaFast = void 0,
              ewmaSlow = void 0;

          if (isLive) {
            ewmaFast = config.abrEwmaFastLive;
            ewmaSlow = config.abrEwmaSlowLive;
          } else {
            ewmaFast = config.abrEwmaFastVoD;
            ewmaSlow = config.abrEwmaSlowVoD;
          }
          this._bwEstimator = new _ewmaBandwidthEstimator2.default(hls, ewmaSlow, ewmaFast, config.abrEwmaDefaultEstimate);
        }
        this.fragCurrent = frag;
      }
    }
  }, {
    key: '_abandonRulesCheck',
    value: function _abandonRulesCheck() {
      /*
        monitor fragment retrieval time...
        we compute expected time of arrival of the complete fragment.
        we compare it to expected time of buffer starvation
      */
      var hls = this.hls,
          v = hls.media,
          frag = this.fragCurrent,
          loader = frag.loader,
          minAutoLevel = hls.minAutoLevel;

      // if loader has been destroyed or loading has been aborted, stop timer and return
      if (!loader || loader.stats && loader.stats.aborted) {
        _logger.logger.warn('frag loader destroy or aborted, disarm abandonRules');
        this.clearTimer();
        return;
      }
      var stats = loader.stats;
      /* only monitor frag retrieval time if
      (video not paused OR first fragment being loaded(ready state === HAVE_NOTHING = 0)) AND autoswitching enabled AND not lowest level (=> means that we have several levels) */
      if (v && (!v.paused && v.playbackRate !== 0 || !v.readyState) && frag.autoLevel && frag.level) {
        var requestDelay = performance.now() - stats.trequest,
            playbackRate = Math.abs(v.playbackRate);
        // monitor fragment load progress after half of expected fragment duration,to stabilize bitrate
        if (requestDelay > 500 * frag.duration / playbackRate) {
          var levels = hls.levels,
              loadRate = Math.max(1, stats.bw ? stats.bw / 8 : stats.loaded * 1000 / requestDelay),
              // byte/s; at least 1 byte/s to avoid division by zero
          // compute expected fragment length using frag duration and level bitrate. also ensure that expected len is gte than already loaded size
          level = levels[frag.level],
              levelBitrate = level.realBitrate ? Math.max(level.realBitrate, level.bitrate) : level.bitrate,
              expectedLen = stats.total ? stats.total : Math.max(stats.loaded, Math.round(frag.duration * levelBitrate / 8)),
              pos = v.currentTime,
              fragLoadedDelay = (expectedLen - stats.loaded) / loadRate,
              bufferStarvationDelay = (_bufferHelper2.default.bufferInfo(v, pos, hls.config.maxBufferHole).end - pos) / playbackRate;
          // consider emergency switch down only if we have less than 2 frag buffered AND
          // time to finish loading current fragment is bigger than buffer starvation delay
          // ie if we risk buffer starvation if bw does not increase quickly
          if (bufferStarvationDelay < 2 * frag.duration / playbackRate && fragLoadedDelay > bufferStarvationDelay) {
            var fragLevelNextLoadedDelay = void 0,
                nextLoadLevel = void 0;
            // lets iterate through lower level and try to find the biggest one that could avoid rebuffering
            // we start from current level - 1 and we step down , until we find a matching level
            for (nextLoadLevel = frag.level - 1; nextLoadLevel > minAutoLevel; nextLoadLevel--) {
              // compute time to load next fragment at lower level
              // 0.8 : consider only 80% of current bw to be conservative
              // 8 = bits per byte (bps/Bps)
              var levelNextBitrate = levels[nextLoadLevel].realBitrate ? Math.max(levels[nextLoadLevel].realBitrate, levels[nextLoadLevel].bitrate) : levels[nextLoadLevel].bitrate;
              fragLevelNextLoadedDelay = frag.duration * levelNextBitrate / (8 * 0.8 * loadRate);
              if (fragLevelNextLoadedDelay < bufferStarvationDelay) {
                // we found a lower level that be rebuffering free with current estimated bw !
                break;
              }
            }
            // only emergency switch down if it takes less time to load new fragment at lowest level instead
            // of finishing loading current one ...
            if (fragLevelNextLoadedDelay < fragLoadedDelay) {
              _logger.logger.warn('loading too slow, abort fragment loading and switch to level ' + nextLoadLevel + ':fragLoadedDelay[' + nextLoadLevel + ']<fragLoadedDelay[' + (frag.level - 1) + '];bufferStarvationDelay:' + fragLevelNextLoadedDelay.toFixed(1) + '<' + fragLoadedDelay.toFixed(1) + ':' + bufferStarvationDelay.toFixed(1));
              // force next load level in auto mode
              hls.nextLoadLevel = nextLoadLevel;
              // update bw estimate for this fragment before cancelling load (this will help reducing the bw)
              this._bwEstimator.sample(requestDelay, stats.loaded);
              //abort fragment loading
              loader.abort();
              // stop abandon rules timer
              this.clearTimer();
              hls.trigger(_events2.default.FRAG_LOAD_EMERGENCY_ABORTED, { frag: frag, stats: stats });
            }
          }
        }
      }
    }
  }, {
    key: 'onFragLoaded',
    value: function onFragLoaded(data) {
      var frag = data.frag;
      if (frag.type === 'main' && !isNaN(frag.sn)) {
        // stop monitoring bw once frag loaded
        this.clearTimer();
        // store level id after successful fragment load
        this.lastLoadedFragLevel = frag.level;
        // reset forced auto level value so that next level will be selected
        this._nextAutoLevel = -1;

        // compute level average bitrate
        if (this.hls.config.abrMaxWithRealBitrate) {
          var level = this.hls.levels[frag.level];
          var loadedBytes = (level.loaded ? level.loaded.bytes : 0) + data.stats.loaded;
          var loadedDuration = (level.loaded ? level.loaded.duration : 0) + data.frag.duration;
          level.loaded = { bytes: loadedBytes, duration: loadedDuration };
          level.realBitrate = Math.round(8 * loadedBytes / loadedDuration);
        }
        // if fragment has been loaded to perform a bitrate test,
        if (data.frag.bitrateTest) {
          var stats = data.stats;
          stats.tparsed = stats.tbuffered = stats.tload;
          this.onFragBuffered(data);
        }
      }
    }
  }, {
    key: 'onFragBuffered',
    value: function onFragBuffered(data) {
      var stats = data.stats,
          frag = data.frag;
      // only update stats on first frag buffering
      // if same frag is loaded multiple times, it might be in browser cache, and loaded quickly
      // and leading to wrong bw estimation
      // on bitrate test, also only update stats once (if tload = tbuffered == on FRAG_LOADED)
      if (stats.aborted !== true && frag.loadCounter === 1 && frag.type === 'main' && !isNaN(frag.sn) && (!frag.bitrateTest || stats.tload === stats.tbuffered)) {
        // use tparsed-trequest instead of tbuffered-trequest to compute fragLoadingProcessing; rationale is that  buffer appending only happens once media is attached
        // in case we use config.startFragPrefetch while media is not attached yet, fragment might be parsed while media not attached yet, but it will only be buffered on media attached
        // as a consequence it could happen really late in the process. meaning that appending duration might appears huge ... leading to underestimated throughput estimation
        var fragLoadingProcessingMs = stats.tparsed - stats.trequest;
        _logger.logger.log('latency/loading/parsing/append/kbps:' + Math.round(stats.tfirst - stats.trequest) + '/' + Math.round(stats.tload - stats.tfirst) + '/' + Math.round(stats.tparsed - stats.tload) + '/' + Math.round(stats.tbuffered - stats.tparsed) + '/' + Math.round(8 * stats.loaded / (stats.tbuffered - stats.trequest)));
        this._bwEstimator.sample(fragLoadingProcessingMs, stats.loaded);
        stats.bwEstimate = this._bwEstimator.getEstimate();
        // if fragment has been loaded to perform a bitrate test, (hls.startLevel = -1), store bitrate test delay duration
        if (frag.bitrateTest) {
          this.bitrateTestDelay = fragLoadingProcessingMs / 1000;
        } else {
          this.bitrateTestDelay = 0;
        }
      }
    }
  }, {
    key: 'onError',
    value: function onError(data) {
      // stop timer in case of frag loading error
      switch (data.details) {
        case _errors.ErrorDetails.FRAG_LOAD_ERROR:
        case _errors.ErrorDetails.FRAG_LOAD_TIMEOUT:
          this.clearTimer();
          break;
        default:
          break;
      }
    }
  }, {
    key: 'clearTimer',
    value: function clearTimer() {
      clearInterval(this.timer);
      this.timer = null;
    }

    // return next auto level

  }, {
    key: '_findBestLevel',
    value: function _findBestLevel(currentLevel, currentFragDuration, currentBw, minAutoLevel, maxAutoLevel, maxFetchDuration, bwFactor, bwUpFactor, levels) {
      for (var i = maxAutoLevel; i >= minAutoLevel; i--) {
        var levelInfo = levels[i],
            levelDetails = levelInfo.details,
            avgDuration = levelDetails ? levelDetails.totalduration / levelDetails.fragments.length : currentFragDuration,
            live = levelDetails ? levelDetails.live : false,
            adjustedbw = void 0;
        // follow algorithm captured from stagefright :
        // https://android.googlesource.com/platform/frameworks/av/+/master/media/libstagefright/httplive/LiveSession.cpp
        // Pick the highest bandwidth stream below or equal to estimated bandwidth.
        // consider only 80% of the available bandwidth, but if we are switching up,
        // be even more conservative (70%) to avoid overestimating and immediately
        // switching back.
        if (i <= currentLevel) {
          adjustedbw = bwFactor * currentBw;
        } else {
          adjustedbw = bwUpFactor * currentBw;
        }
        var bitrate = levels[i].realBitrate ? Math.max(levels[i].realBitrate, levels[i].bitrate) : levels[i].bitrate,
            fetchDuration = bitrate * avgDuration / adjustedbw;

        _logger.logger.trace('level/adjustedbw/bitrate/avgDuration/maxFetchDuration/fetchDuration: ' + i + '/' + Math.round(adjustedbw) + '/' + bitrate + '/' + avgDuration + '/' + maxFetchDuration + '/' + fetchDuration);
        // if adjusted bw is greater than level bitrate AND
        if (adjustedbw > bitrate && (
        // fragment fetchDuration unknown OR live stream OR fragment fetchDuration less than max allowed fetch duration, then this level matches
        // we don't account for max Fetch Duration for live streams, this is to avoid switching down when near the edge of live sliding window ...
        // special case to support startLevel = -1 (bitrateTest) on live streams : in that case we should not exit loop so that _findBestLevel will return -1
        !fetchDuration || live && !this.bitrateTestDelay || fetchDuration < maxFetchDuration)) {
          // as we are looping from highest to lowest, this will return the best achievable quality level
          return i;
        }
      }
      // not enough time budget even with quality level 0 ... rebuffering might happen
      return -1;
    }
  }, {
    key: 'nextAutoLevel',
    get: function get() {
      var forcedAutoLevel = this._nextAutoLevel;
      var bwEstimator = this._bwEstimator;
      // in case next auto level has been forced, and bw not available or not reliable, return forced value
      if (forcedAutoLevel !== -1 && (!bwEstimator || !bwEstimator.canEstimate())) {
        return forcedAutoLevel;
      }
      // compute next level using ABR logic
      var nextABRAutoLevel = this._nextABRAutoLevel;
      // if forced auto level has been defined, use it to cap ABR computed quality level
      if (forcedAutoLevel !== -1) {
        nextABRAutoLevel = Math.min(forcedAutoLevel, nextABRAutoLevel);
      }
      return nextABRAutoLevel;
    },
    set: function set(nextLevel) {
      this._nextAutoLevel = nextLevel;
    }
  }, {
    key: '_nextABRAutoLevel',
    get: function get() {
      var hls = this.hls,
          maxAutoLevel = hls.maxAutoLevel,
          levels = hls.levels,
          config = hls.config,
          minAutoLevel = hls.minAutoLevel;
      var v = hls.media,
          currentLevel = this.lastLoadedFragLevel,
          currentFragDuration = this.fragCurrent ? this.fragCurrent.duration : 0,
          pos = v ? v.currentTime : 0,

      // playbackRate is the absolute value of the playback rate; if v.playbackRate is 0, we use 1 to load as
      // if we're playing back at the normal rate.
      playbackRate = v && v.playbackRate !== 0 ? Math.abs(v.playbackRate) : 1.0,
          avgbw = this._bwEstimator ? this._bwEstimator.getEstimate() : config.abrEwmaDefaultEstimate,

      // bufferStarvationDelay is the wall-clock time left until the playback buffer is exhausted.
      bufferStarvationDelay = (_bufferHelper2.default.bufferInfo(v, pos, config.maxBufferHole).end - pos) / playbackRate;

      // First, look to see if we can find a level matching with our avg bandwidth AND that could also guarantee no rebuffering at all
      var bestLevel = this._findBestLevel(currentLevel, currentFragDuration, avgbw, minAutoLevel, maxAutoLevel, bufferStarvationDelay, config.abrBandWidthFactor, config.abrBandWidthUpFactor, levels);
      if (bestLevel >= 0) {
        return bestLevel;
      } else {
        _logger.logger.trace('rebuffering expected to happen, lets try to find a quality level minimizing the rebuffering');
        // not possible to get rid of rebuffering ... let's try to find level that will guarantee less than maxStarvationDelay of rebuffering
        // if no matching level found, logic will return 0
        var maxStarvationDelay = currentFragDuration ? Math.min(currentFragDuration, config.maxStarvationDelay) : config.maxStarvationDelay,
            bwFactor = config.abrBandWidthFactor,
            bwUpFactor = config.abrBandWidthUpFactor;
        if (bufferStarvationDelay === 0) {
          // in case buffer is empty, let's check if previous fragment was loaded to perform a bitrate test
          var bitrateTestDelay = this.bitrateTestDelay;
          if (bitrateTestDelay) {
            // if it is the case, then we need to adjust our max starvation delay using maxLoadingDelay config value
            // max video loading delay used in  automatic start level selection :
            // in that mode ABR controller will ensure that video loading time (ie the time to fetch the first fragment at lowest quality level +
            // the time to fetch the fragment at the appropriate quality level is less than ```maxLoadingDelay``` )
            // cap maxLoadingDelay and ensure it is not bigger 'than bitrate test' frag duration
            var maxLoadingDelay = currentFragDuration ? Math.min(currentFragDuration, config.maxLoadingDelay) : config.maxLoadingDelay;
            maxStarvationDelay = maxLoadingDelay - bitrateTestDelay;
            _logger.logger.trace('bitrate test took ' + Math.round(1000 * bitrateTestDelay) + 'ms, set first fragment max fetchDuration to ' + Math.round(1000 * maxStarvationDelay) + ' ms');
            // don't use conservative factor on bitrate test
            bwFactor = bwUpFactor = 1;
          }
        }
        bestLevel = this._findBestLevel(currentLevel, currentFragDuration, avgbw, minAutoLevel, maxAutoLevel, bufferStarvationDelay + maxStarvationDelay, bwFactor, bwUpFactor, levels);
        return Math.max(bestLevel, 0);
      }
    }
  }]);

  return AbrController;
}(_eventHandler2.default);

exports.default = AbrController;

},{"../errors":33,"../event-handler":34,"../events":35,"../helper/buffer-helper":37,"../utils/ewma-bandwidth-estimator":52,"../utils/logger":54}],6:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _binarySearch = require('../utils/binary-search');

var _binarySearch2 = _interopRequireDefault(_binarySearch);

var _bufferHelper = require('../helper/buffer-helper');

var _bufferHelper2 = _interopRequireDefault(_bufferHelper);

var _demuxer = require('../demux/demuxer');

var _demuxer2 = _interopRequireDefault(_demuxer);

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _eventHandler = require('../event-handler');

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _levelHelper = require('../helper/level-helper');

var _levelHelper2 = _interopRequireDefault(_levelHelper);

var _timeRanges = require('../utils/timeRanges');

var _timeRanges2 = _interopRequireDefault(_timeRanges);

var _errors = require('../errors');

var _logger = require('../utils/logger');

var _discontinuities = require('../utils/discontinuities');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Audio Stream Controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

var State = {
    STOPPED: 'STOPPED',
    STARTING: 'STARTING',
    IDLE: 'IDLE',
    PAUSED: 'PAUSED',
    KEY_LOADING: 'KEY_LOADING',
    FRAG_LOADING: 'FRAG_LOADING',
    FRAG_LOADING_WAITING_RETRY: 'FRAG_LOADING_WAITING_RETRY',
    WAITING_TRACK: 'WAITING_TRACK',
    PARSING: 'PARSING',
    PARSED: 'PARSED',
    BUFFER_FLUSHING: 'BUFFER_FLUSHING',
    ENDED: 'ENDED',
    ERROR: 'ERROR',
    WAITING_INIT_PTS: 'WAITING_INIT_PTS'
};

var AudioStreamController = function (_EventHandler) {
    _inherits(AudioStreamController, _EventHandler);

    function AudioStreamController(hls) {
        _classCallCheck(this, AudioStreamController);

        var _this2 = _possibleConstructorReturn(this, (AudioStreamController.__proto__ || Object.getPrototypeOf(AudioStreamController)).call(this, hls, _events2.default.MEDIA_ATTACHED, _events2.default.MEDIA_DETACHING, _events2.default.AUDIO_TRACKS_UPDATED, _events2.default.AUDIO_TRACK_SWITCHING, _events2.default.AUDIO_TRACK_LOADED, _events2.default.KEY_LOADED, _events2.default.FRAG_LOADED, _events2.default.FRAG_PARSING_INIT_SEGMENT, _events2.default.FRAG_PARSING_DATA, _events2.default.FRAG_PARSED, _events2.default.ERROR, _events2.default.BUFFER_CREATED, _events2.default.BUFFER_APPENDED, _events2.default.BUFFER_FLUSHED, _events2.default.INIT_PTS_FOUND));

        _this2.config = hls.config;
        _this2.audioCodecSwap = false;
        _this2.ticks = 0;
        _this2._state = State.STOPPED;
        _this2.ontick = _this2.tick.bind(_this2);
        _this2.initPTS = [];
        _this2.waitingFragment = null;
        _this2.videoTrackCC = null;
        return _this2;
    }

    _createClass(AudioStreamController, [{
        key: 'destroy',
        value: function destroy() {
            this.stopLoad();
            if (this.timer) {
                clearInterval(this.timer);
                this.timer = null;
            }
            _eventHandler2.default.prototype.destroy.call(this);
            this.state = State.STOPPED;
        }

        //Signal that video PTS was found

    }, {
        key: 'onInitPtsFound',
        value: function onInitPtsFound(data) {
            var demuxerId = data.id,
                cc = data.frag.cc,
                initPTS = data.initPTS;
            if (demuxerId === 'main') {
                //Always update the new INIT PTS
                //Can change due level switch
                this.initPTS[cc] = initPTS;
                this.videoTrackCC = cc;
                _logger.logger.log('InitPTS for cc:' + cc + ' found from video track:' + initPTS);

                //If we are waiting we need to demux/remux the waiting frag
                //With the new initPTS
                if (this.state === State.WAITING_INIT_PTS) {
                    this.tick();
                }
            }
        }
    }, {
        key: 'startLoad',
        value: function startLoad(startPosition) {
            if (this.tracks) {
                var lastCurrentTime = this.lastCurrentTime;
                this.stopLoad();
                if (!this.timer) {
                    this.timer = setInterval(this.ontick, 100);
                }
                this.fragLoadError = 0;
                if (lastCurrentTime > 0 && startPosition === -1) {
                    _logger.logger.log('audio:override startPosition with lastCurrentTime @' + lastCurrentTime.toFixed(3));
                    this.state = State.IDLE;
                } else {
                    this.lastCurrentTime = this.startPosition ? this.startPosition : startPosition;
                    this.state = State.STARTING;
                }
                this.nextLoadPosition = this.startPosition = this.lastCurrentTime;
                this.tick();
            } else {
                this.startPosition = startPosition;
                this.state = State.STOPPED;
            }
        }
    }, {
        key: 'stopLoad',
        value: function stopLoad() {
            var frag = this.fragCurrent;
            if (frag) {
                if (frag.loader) {
                    frag.loader.abort();
                }
                this.fragCurrent = null;
            }
            this.fragPrevious = null;
            if (this.demuxer) {
                this.demuxer.destroy();
                this.demuxer = null;
            }
            this.state = State.STOPPED;
        }
    }, {
        key: 'tick',
        value: function tick() {
            this.ticks++;
            if (this.ticks === 1) {
                this.doTick();
                if (this.ticks > 1) {
                    setTimeout(this.tick, 1);
                }
                this.ticks = 0;
            }
        }
    }, {
        key: 'doTick',
        value: function doTick() {
            var pos,
                track,
                trackDetails,
                hls = this.hls,
                config = hls.config;
            //logger.log('audioStream:' + this.state);
            switch (this.state) {
                case State.ERROR:
                //don't do anything in error state to avoid breaking further ...
                case State.PAUSED:
                //don't do anything in paused state either ...
                case State.BUFFER_FLUSHING:
                    break;
                case State.STARTING:
                    this.state = State.WAITING_TRACK;
                    this.loadedmetadata = false;
                    break;
                case State.IDLE:
                    var tracks = this.tracks;
                    // audio tracks not received => exit loop
                    if (!tracks) {
                        break;
                    }
                    // if video not attached AND
                    // start fragment already requested OR start frag prefetch disable
                    // exit loop
                    // => if media not attached but start frag prefetch is enabled and start frag not requested yet, we will not exit loop
                    if (!this.media && (this.startFragRequested || !config.startFragPrefetch)) {
                        break;
                    }
                    // determine next candidate fragment to be loaded, based on current position and
                    //  end of buffer position
                    // if we have not yet loaded any fragment, start loading from start position
                    if (this.loadedmetadata) {
                        pos = this.media.currentTime;
                    } else {
                        pos = this.nextLoadPosition;
                        if (pos === undefined) {
                            break;
                        }
                    }
                    var media = this.mediaBuffer ? this.mediaBuffer : this.media,
                        bufferInfo = _bufferHelper2.default.bufferInfo(media, pos, config.maxBufferHole),
                        bufferLen = bufferInfo.len,
                        bufferEnd = bufferInfo.end,
                        fragPrevious = this.fragPrevious,
                        maxBufLen = config.maxMaxBufferLength,
                        audioSwitch = this.audioSwitch,
                        trackId = this.trackId;

                    // if buffer length is less than maxBufLen try to load a new fragment
                    if ((bufferLen < maxBufLen || audioSwitch) && trackId < tracks.length) {
                        trackDetails = tracks[trackId].details;
                        // if track info not retrieved yet, switch state and wait for track retrieval
                        if (typeof trackDetails === 'undefined') {
                            this.state = State.WAITING_TRACK;
                            break;
                        }

                        // we just got done loading the final fragment, check if we need to finalize media stream
                        if (!audioSwitch && !trackDetails.live && fragPrevious && fragPrevious.sn === trackDetails.endSN) {
                            // if we are not seeking or if we are seeking but everything (almost) til the end is buffered, let's signal eos
                            // we don't compare exactly media.duration === bufferInfo.end as there could be some subtle media duration difference when switching
                            // between different renditions. using half frag duration should help cope with these cases.
                            if (!this.media.seeking || this.media.duration - bufferEnd < fragPrevious.duration / 2) {
                                // Finalize the media stream
                                this.hls.trigger(_events2.default.BUFFER_EOS, { type: 'audio' });
                                this.state = State.ENDED;
                                break;
                            }
                        }

                        // find fragment index, contiguous with end of buffer position
                        var fragments = trackDetails.fragments,
                            fragLen = fragments.length,
                            start = fragments[0].start,
                            end = fragments[fragLen - 1].start + fragments[fragLen - 1].duration,
                            frag = void 0;

                        // When switching audio track, reload audio as close as possible to currentTime
                        if (audioSwitch) {
                            if (trackDetails.live && !trackDetails.PTSKnown) {
                                _logger.logger.log('switching audiotrack, live stream, unknown PTS,load first fragment');
                                bufferEnd = 0;
                            } else {
                                bufferEnd = pos;
                                // if currentTime (pos) is less than alt audio playlist start time, it means that alt audio is ahead of currentTime
                                if (trackDetails.PTSKnown && pos < start) {
                                    // if everything is buffered from pos to start or if audio buffer upfront, let's seek to start
                                    if (bufferInfo.end > start || bufferInfo.nextStart) {
                                        _logger.logger.log('alt audio track ahead of main track, seek to start of alt audio track');
                                        this.media.currentTime = start + 0.05;
                                    } else {
                                        return;
                                    }
                                }
                            }
                        }
                        if (trackDetails.initSegment && !trackDetails.initSegment.data) {
                            frag = trackDetails.initSegment;
                        }
                        // if bufferEnd before start of playlist, load first fragment
                        else if (bufferEnd <= start) {
                                frag = fragments[0];
                                if (this.videoTrackCC !== null && frag.cc !== this.videoTrackCC) {
                                    // Ensure we find a fragment which matches the continuity of the video track
                                    frag = (0, _discontinuities.findFragWithCC)(fragments, this.videoTrackCC);
                                }
                                if (trackDetails.live && frag.loadIdx && frag.loadIdx === this.fragLoadIdx) {
                                    // we just loaded this first fragment, and we are still lagging behind the start of the live playlist
                                    // let's force seek to start
                                    var nextBuffered = bufferInfo.nextStart ? bufferInfo.nextStart : start;
                                    _logger.logger.log('no alt audio available @currentTime:' + this.media.currentTime + ', seeking @' + (nextBuffered + 0.05));
                                    this.media.currentTime = nextBuffered + 0.05;
                                    return;
                                }
                            } else {
                                var foundFrag = void 0;
                                var maxFragLookUpTolerance = config.maxFragLookUpTolerance;
                                var fragNext = fragPrevious ? fragments[fragPrevious.sn - fragments[0].sn + 1] : undefined;
                                var fragmentWithinToleranceTest = function fragmentWithinToleranceTest(candidate) {
                                    // offset should be within fragment boundary - config.maxFragLookUpTolerance
                                    // this is to cope with situations like
                                    // bufferEnd = 9.991
                                    // frag[] : [0,10]
                                    // frag[1] : [10,20]
                                    // bufferEnd is within frag[0] range ... although what we are expecting is to return frag[1] here
                                    //              frag start               frag start+duration
                                    //                  |-----------------------------|
                                    //              <--->                         <--->
                                    //  ...--------><-----------------------------><---------....
                                    // previous frag         matching fragment         next frag
                                    //  return -1             return 0                 return 1
                                    //logger.log(`level/sn/start/end/bufEnd:${level}/${candidate.sn}/${candidate.start}/${(candidate.start+candidate.duration)}/${bufferEnd}`);
                                    // Set the lookup tolerance to be small enough to detect the current segment - ensures we don't skip over very small segments
                                    var candidateLookupTolerance = Math.min(maxFragLookUpTolerance, candidate.duration);
                                    if (candidate.start + candidate.duration - candidateLookupTolerance <= bufferEnd) {
                                        return 1;
                                    } // if maxFragLookUpTolerance will have negative value then don't return -1 for first element
                                    else if (candidate.start - candidateLookupTolerance > bufferEnd && candidate.start) {
                                            return -1;
                                        }
                                    return 0;
                                };

                                if (bufferEnd < end) {
                                    if (bufferEnd > end - maxFragLookUpTolerance) {
                                        maxFragLookUpTolerance = 0;
                                    }
                                    // Prefer the next fragment if it's within tolerance
                                    if (fragNext && !fragmentWithinToleranceTest(fragNext)) {
                                        foundFrag = fragNext;
                                    } else {
                                        foundFrag = _binarySearch2.default.search(fragments, fragmentWithinToleranceTest);
                                    }
                                } else {
                                    // reach end of playlist
                                    foundFrag = fragments[fragLen - 1];
                                }
                                if (foundFrag) {
                                    frag = foundFrag;
                                    start = foundFrag.start;
                                    //logger.log('find SN matching with pos:' +  bufferEnd + ':' + frag.sn);
                                    if (fragPrevious && frag.level === fragPrevious.level && frag.sn === fragPrevious.sn) {
                                        if (frag.sn < trackDetails.endSN) {
                                            frag = fragments[frag.sn + 1 - trackDetails.startSN];
                                            _logger.logger.log('SN just loaded, load next one: ' + frag.sn);
                                        } else {
                                            frag = null;
                                        }
                                    }
                                }
                            }
                        if (frag) {
                            //logger.log('      loading frag ' + i +',pos/bufEnd:' + pos.toFixed(3) + '/' + bufferEnd.toFixed(3));
                            if (frag.decryptdata && frag.decryptdata.uri != null && frag.decryptdata.key == null) {
                                _logger.logger.log('Loading key for ' + frag.sn + ' of [' + trackDetails.startSN + ' ,' + trackDetails.endSN + '],track ' + trackId);
                                this.state = State.KEY_LOADING;
                                hls.trigger(_events2.default.KEY_LOADING, { frag: frag });
                            } else {
                                _logger.logger.log('Loading ' + frag.sn + ', cc: ' + frag.cc + ' of [' + trackDetails.startSN + ' ,' + trackDetails.endSN + '],track ' + trackId + ', currentTime:' + pos + ',bufferEnd:' + bufferEnd.toFixed(3));
                                // ensure that we are not reloading the same fragments in loop ...
                                if (this.fragLoadIdx !== undefined) {
                                    this.fragLoadIdx++;
                                } else {
                                    this.fragLoadIdx = 0;
                                }
                                if (frag.loadCounter) {
                                    frag.loadCounter++;
                                    var maxThreshold = config.fragLoadingLoopThreshold;
                                    // if this frag has already been loaded 3 times, and if it has been reloaded recently
                                    if (frag.loadCounter > maxThreshold && Math.abs(this.fragLoadIdx - frag.loadIdx) < maxThreshold) {
                                        hls.trigger(_events2.default.ERROR, {
                                            type: _errors.ErrorTypes.MEDIA_ERROR,
                                            details: _errors.ErrorDetails.FRAG_LOOP_LOADING_ERROR,
                                            fatal: false,
                                            frag: frag
                                        });
                                        return;
                                    }
                                } else {
                                    frag.loadCounter = 1;
                                }
                                frag.loadIdx = this.fragLoadIdx;
                                this.fragCurrent = frag;
                                this.startFragRequested = true;
                                if (!isNaN(frag.sn)) {
                                    this.nextLoadPosition = frag.start + frag.duration;
                                }
                                hls.trigger(_events2.default.FRAG_LOADING, { frag: frag });
                                this.state = State.FRAG_LOADING;
                            }
                        }
                    }
                    break;
                case State.WAITING_TRACK:
                    track = this.tracks[this.trackId];
                    // check if playlist is already loaded
                    if (track && track.details) {
                        this.state = State.IDLE;
                    }
                    break;
                case State.FRAG_LOADING_WAITING_RETRY:
                    var now = performance.now();
                    var retryDate = this.retryDate;
                    media = this.media;
                    var isSeeking = media && media.seeking;
                    // if current time is gt than retryDate, or if media seeking let's switch to IDLE state to retry loading
                    if (!retryDate || now >= retryDate || isSeeking) {
                        _logger.logger.log('audioStreamController: retryDate reached, switch back to IDLE state');
                        this.state = State.IDLE;
                    }
                    break;
                case State.WAITING_INIT_PTS:
                    if (this.initPTS[this.videoTrackCC] === undefined) {
                        break;
                    }

                    // Ensure we don't get stuck in the WAITING_INIT_PTS state if the waiting frag CC doesn't match any initPTS
                    var waitingFrag = this.waitingFragment;
                    if (waitingFrag) {
                        var waitingFragCC = waitingFrag.frag.cc;
                        if (this.videoTrackCC !== waitingFragCC) {
                            _logger.logger.warn('Waiting fragment CC (' + waitingFragCC + ') does not match video track CC (' + this.videoTrackCC + ')');
                            this.waitingFragment = null;
                            this.state = State.IDLE;
                        } else {
                            this.state = State.FRAG_LOADING;
                            this.onFragLoaded(this.waitingFragment);
                            this.waitingFragment = null;
                        }
                    } else {
                        this.state = State.IDLE;
                    }

                    break;
                case State.STOPPED:
                case State.FRAG_LOADING:
                case State.PARSING:
                case State.PARSED:
                case State.ENDED:
                    break;
                default:
                    break;
            }
        }
    }, {
        key: 'onMediaAttached',
        value: function onMediaAttached(data) {
            var media = this.media = this.mediaBuffer = data.media;
            this.onvseeking = this.onMediaSeeking.bind(this);
            this.onvended = this.onMediaEnded.bind(this);
            media.addEventListener('seeking', this.onvseeking);
            media.addEventListener('ended', this.onvended);
            var config = this.config;
            if (this.tracks && config.autoStartLoad) {
                this.startLoad(config.startPosition);
            }
        }
    }, {
        key: 'onMediaDetaching',
        value: function onMediaDetaching() {
            var media = this.media;
            if (media && media.ended) {
                _logger.logger.log('MSE detaching and video ended, reset startPosition');
                this.startPosition = this.lastCurrentTime = 0;
            }

            // reset fragment loading counter on MSE detaching to avoid reporting FRAG_LOOP_LOADING_ERROR after error recovery
            var tracks = this.tracks;
            if (tracks) {
                // reset fragment load counter
                tracks.forEach(function (track) {
                    if (track.details) {
                        track.details.fragments.forEach(function (fragment) {
                            fragment.loadCounter = undefined;
                        });
                    }
                });
            }
            // remove video listeners
            if (media) {
                media.removeEventListener('seeking', this.onvseeking);
                media.removeEventListener('ended', this.onvended);
                this.onvseeking = this.onvseeked = this.onvended = null;
            }
            this.media = this.mediaBuffer = null;
            this.loadedmetadata = false;
            this.stopLoad();
        }
    }, {
        key: 'onMediaSeeking',
        value: function onMediaSeeking() {
            if (this.state === State.ENDED) {
                // switch to IDLE state to check for potential new fragment
                this.state = State.IDLE;
            }
            if (this.media) {
                this.lastCurrentTime = this.media.currentTime;
            }
            // avoid reporting fragment loop loading error in case user is seeking several times on same position
            if (this.fragLoadIdx !== undefined) {
                this.fragLoadIdx += 2 * this.config.fragLoadingLoopThreshold;
            }
            // tick to speed up processing
            this.tick();
        }
    }, {
        key: 'onMediaEnded',
        value: function onMediaEnded() {
            // reset startPosition and lastCurrentTime to restart playback @ stream beginning
            this.startPosition = this.lastCurrentTime = 0;
        }
    }, {
        key: 'onAudioTracksUpdated',
        value: function onAudioTracksUpdated(data) {
            _logger.logger.log('audio tracks updated');
            this.tracks = data.audioTracks;
        }
    }, {
        key: 'onAudioTrackSwitching',
        value: function onAudioTrackSwitching(data) {
            // if any URL found on new audio track, it is an alternate audio track
            var altAudio = !!data.url;
            this.trackId = data.id;

            this.fragCurrent = null;
            this.state = State.PAUSED;
            this.waitingFragment = null;
            // destroy useless demuxer when switching audio to main
            if (!altAudio) {
                if (this.demuxer) {
                    this.demuxer.destroy();
                    this.demuxer = null;
                }
            } else {
                // switching to audio track, start timer if not already started
                if (!this.timer) {
                    this.timer = setInterval(this.ontick, 100);
                }
            }

            //should we switch tracks ?
            if (altAudio) {
                this.audioSwitch = true;
                //main audio track are handled by stream-controller, just do something if switching to alt audio track
                this.state = State.IDLE;
                // increase fragment load Index to avoid frag loop loading error after buffer flush
                if (this.fragLoadIdx !== undefined) {
                    this.fragLoadIdx += 2 * this.config.fragLoadingLoopThreshold;
                }
            }
            this.tick();
        }
    }, {
        key: 'onAudioTrackLoaded',
        value: function onAudioTrackLoaded(data) {
            var newDetails = data.details,
                trackId = data.id,
                track = this.tracks[trackId],
                duration = newDetails.totalduration,
                sliding = 0;

            _logger.logger.log('track ' + trackId + ' loaded [' + newDetails.startSN + ',' + newDetails.endSN + '],duration:' + duration);

            if (newDetails.live) {
                var curDetails = track.details;
                if (curDetails && newDetails.fragments.length > 0) {
                    // we already have details for that level, merge them
                    _levelHelper2.default.mergeDetails(curDetails, newDetails);
                    sliding = newDetails.fragments[0].start;
                    // TODO
                    //this.liveSyncPosition = this.computeLivePosition(sliding, curDetails);
                    if (newDetails.PTSKnown) {
                        _logger.logger.log('live audio playlist sliding:' + sliding.toFixed(3));
                    } else {
                        _logger.logger.log('live audio playlist - outdated PTS, unknown sliding');
                    }
                } else {
                    newDetails.PTSKnown = false;
                    _logger.logger.log('live audio playlist - first load, unknown sliding');
                }
            } else {
                newDetails.PTSKnown = false;
            }
            track.details = newDetails;

            // compute start position
            if (!this.startFragRequested) {
                // compute start position if set to -1. use it straight away if value is defined
                if (this.startPosition === -1) {
                    // first, check if start time offset has been set in playlist, if yes, use this value
                    var startTimeOffset = newDetails.startTimeOffset;
                    if (!isNaN(startTimeOffset)) {
                        _logger.logger.log('start time offset found in playlist, adjust startPosition to ' + startTimeOffset);
                        this.startPosition = startTimeOffset;
                    } else {
                        this.startPosition = 0;
                    }
                }
                this.nextLoadPosition = this.startPosition;
            }
            // only switch batck to IDLE state if we were waiting for track to start downloading a new fragment
            if (this.state === State.WAITING_TRACK) {
                this.state = State.IDLE;
            }
            //trigger handler right now
            this.tick();
        }
    }, {
        key: 'onKeyLoaded',
        value: function onKeyLoaded() {
            if (this.state === State.KEY_LOADING) {
                this.state = State.IDLE;
                this.tick();
            }
        }
    }, {
        key: 'onFragLoaded',
        value: function onFragLoaded(data) {
            var fragCurrent = this.fragCurrent,
                fragLoaded = data.frag;
            if (this.state === State.FRAG_LOADING && fragCurrent && fragLoaded.type === 'audio' && fragLoaded.level === fragCurrent.level && fragLoaded.sn === fragCurrent.sn) {
                var track = this.tracks[this.trackId],
                    details = track.details,
                    duration = details.totalduration,
                    trackId = fragCurrent.level,
                    sn = fragCurrent.sn,
                    cc = fragCurrent.cc,
                    audioCodec = this.config.defaultAudioCodec || track.audioCodec || 'mp4a.40.2',
                    stats = this.stats = data.stats;
                if (sn === 'initSegment') {
                    this.state = State.IDLE;

                    stats.tparsed = stats.tbuffered = performance.now();
                    details.initSegment.data = data.payload;
                    this.hls.trigger(_events2.default.FRAG_BUFFERED, { stats: stats, frag: fragCurrent, id: 'audio' });
                    this.tick();
                } else {
                    this.state = State.PARSING;
                    // transmux the MPEG-TS data to ISO-BMFF segments
                    this.appended = false;
                    if (!this.demuxer) {
                        this.demuxer = new _demuxer2.default(this.hls, 'audio');
                    }
                    //Check if we have video initPTS
                    // If not we need to wait for it
                    var initPTS = this.initPTS[cc];
                    var initSegmentData = details.initSegment ? details.initSegment.data : [];
                    if (details.initSegment || initPTS !== undefined) {
                        this.pendingBuffering = true;
                        _logger.logger.log('Demuxing ' + sn + ' of [' + details.startSN + ' ,' + details.endSN + '],track ' + trackId);
                        // time Offset is accurate if level PTS is known, or if playlist is not sliding (not live)
                        var accurateTimeOffset = false; //details.PTSKnown || !details.live;
                        this.demuxer.push(data.payload, initSegmentData, audioCodec, null, fragCurrent, duration, accurateTimeOffset, initPTS);
                    } else {
                        _logger.logger.log('unknown video PTS for continuity counter ' + cc + ', waiting for video PTS before demuxing audio frag ' + sn + ' of [' + details.startSN + ' ,' + details.endSN + '],track ' + trackId);
                        this.waitingFragment = data;
                        this.state = State.WAITING_INIT_PTS;
                    }
                }
            }
            this.fragLoadError = 0;
        }
    }, {
        key: 'onFragParsingInitSegment',
        value: function onFragParsingInitSegment(data) {
            var fragCurrent = this.fragCurrent;
            var fragNew = data.frag;
            if (fragCurrent && data.id === 'audio' && fragNew.sn === fragCurrent.sn && fragNew.level === fragCurrent.level && this.state === State.PARSING) {
                var tracks = data.tracks,
                    track = void 0;

                // delete any video track found on audio demuxer
                if (tracks.video) {
                    delete tracks.video;
                }

                // include levelCodec in audio and video tracks
                track = tracks.audio;
                if (track) {
                    track.levelCodec = track.codec;
                    track.id = data.id;
                    this.hls.trigger(_events2.default.BUFFER_CODECS, tracks);
                    _logger.logger.log('audio track:audio,container:' + track.container + ',codecs[level/parsed]=[' + track.levelCodec + '/' + track.codec + ']');
                    var initSegment = track.initSegment;
                    if (initSegment) {
                        var appendObj = { type: 'audio', data: initSegment, parent: 'audio', content: 'initSegment' };
                        if (this.audioSwitch) {
                            this.pendingData = [appendObj];
                        } else {
                            this.appended = true;
                            // arm pending Buffering flag before appending a segment
                            this.pendingBuffering = true;
                            this.hls.trigger(_events2.default.BUFFER_APPENDING, appendObj);
                        }
                    }
                    //trigger handler right now
                    this.tick();
                }
            }
        }
    }, {
        key: 'onFragParsingData',
        value: function onFragParsingData(data) {
            var _this3 = this;

            var fragCurrent = this.fragCurrent;
            var fragNew = data.frag;
            if (fragCurrent && data.id === 'audio' && data.type === 'audio' && fragNew.sn === fragCurrent.sn && fragNew.level === fragCurrent.level && this.state === State.PARSING) {
                var trackId = this.trackId,
                    track = this.tracks[trackId],
                    hls = this.hls;

                if (isNaN(data.endPTS)) {
                    data.endPTS = data.startPTS + fragCurrent.duration;
                    data.endDTS = data.startDTS + fragCurrent.duration;
                }

                _logger.logger.log('parsed ' + data.type + ',PTS:[' + data.startPTS.toFixed(3) + ',' + data.endPTS.toFixed(3) + '],DTS:[' + data.startDTS.toFixed(3) + '/' + data.endDTS.toFixed(3) + '],nb:' + data.nb);
                _levelHelper2.default.updateFragPTSDTS(track.details, fragCurrent, data.startPTS, data.endPTS);

                var audioSwitch = this.audioSwitch,
                    media = this.media,
                    appendOnBufferFlush = false;
                //Only flush audio from old audio tracks when PTS is known on new audio track
                if (audioSwitch && media) {
                    if (media.readyState) {
                        var currentTime = media.currentTime;
                        _logger.logger.log('switching audio track : currentTime:' + currentTime);
                        if (currentTime >= data.startPTS) {
                            _logger.logger.log('switching audio track : flushing all audio');
                            this.state = State.BUFFER_FLUSHING;
                            hls.trigger(_events2.default.BUFFER_FLUSHING, {
                                startOffset: 0,
                                endOffset: Number.POSITIVE_INFINITY,
                                type: 'audio'
                            });
                            appendOnBufferFlush = true;
                            //Lets announce that the initial audio track switch flush occur
                            this.audioSwitch = false;
                            hls.trigger(_events2.default.AUDIO_TRACK_SWITCHED, { id: trackId });
                        }
                    } else {
                        //Lets announce that the initial audio track switch flush occur
                        this.audioSwitch = false;
                        hls.trigger(_events2.default.AUDIO_TRACK_SWITCHED, { id: trackId });
                    }
                }

                var pendingData = this.pendingData;
                if (!this.audioSwitch) {
                    [data.data1, data.data2].forEach(function (buffer) {
                        if (buffer && buffer.length) {
                            pendingData.push({ type: data.type, data: buffer, parent: 'audio', content: 'data' });
                        }
                    });
                    if (!appendOnBufferFlush && pendingData.length) {
                        pendingData.forEach(function (appendObj) {
                            // only append in PARSING state (rationale is that an appending error could happen synchronously on first segment appending)
                            // in that case it is useless to append following segments
                            if (_this3.state === State.PARSING) {
                                // arm pending Buffering flag before appending a segment
                                _this3.pendingBuffering = true;
                                _this3.hls.trigger(_events2.default.BUFFER_APPENDING, appendObj);
                            }
                        });
                        this.pendingData = [];
                        this.appended = true;
                    }
                }
                //trigger handler right now
                this.tick();
            }
        }
    }, {
        key: 'onFragParsed',
        value: function onFragParsed(data) {
            var fragCurrent = this.fragCurrent;
            var fragNew = data.frag;
            if (fragCurrent && data.id === 'audio' && fragNew.sn === fragCurrent.sn && fragNew.level === fragCurrent.level && this.state === State.PARSING) {
                this.stats.tparsed = performance.now();
                this.state = State.PARSED;
                this._checkAppendedParsed();
            }
        }
    }, {
        key: 'onBufferCreated',
        value: function onBufferCreated(data) {
            var audioTrack = data.tracks.audio;
            if (audioTrack) {
                this.mediaBuffer = audioTrack.buffer;
                this.loadedmetadata = true;
            }
        }
    }, {
        key: 'onBufferAppended',
        value: function onBufferAppended(data) {
            if (data.parent === 'audio') {
                var state = this.state;
                if (state === State.PARSING || state === State.PARSED) {
                    // check if all buffers have been appended
                    this.pendingBuffering = data.pending > 0;
                    this._checkAppendedParsed();
                }
            }
        }
    }, {
        key: '_checkAppendedParsed',
        value: function _checkAppendedParsed() {
            //trigger handler right now
            if (this.state === State.PARSED && (!this.appended || !this.pendingBuffering)) {
                var frag = this.fragCurrent,
                    stats = this.stats,
                    hls = this.hls;
                if (frag) {
                    this.fragPrevious = frag;
                    stats.tbuffered = performance.now();
                    hls.trigger(_events2.default.FRAG_BUFFERED, { stats: stats, frag: frag, id: 'audio' });
                    var media = this.mediaBuffer ? this.mediaBuffer : this.media;
                    _logger.logger.log('audio buffered : ' + _timeRanges2.default.toString(media.buffered));
                    if (this.audioSwitch && this.appended) {
                        this.audioSwitch = false;
                        hls.trigger(_events2.default.AUDIO_TRACK_SWITCHED, { id: this.trackId });
                    }
                    this.state = State.IDLE;
                }
                this.tick();
            }
        }
    }, {
        key: 'onError',
        value: function onError(data) {
            var frag = data.frag;
            // don't handle frag error not related to audio fragment
            // if (frag && frag.type !== 'audio') {
            //     return;
            // }

            var details = data.details,
                hls = this.hls,
                _this = this,
                levelId = void 0,
                level = void 0,
                levelError = false;

            var selTrackId = hls.audioTrackController.trackId;

            switch (data.details) {
                case _errors.ErrorDetails.FRAG_LOAD_ERROR:
                case _errors.ErrorDetails.FRAG_LOAD_TIMEOUT:
                    if (!data.fatal) {
                        var loadError = this.fragLoadError;
                        if (loadError) {
                            loadError++;
                        } else {
                            loadError = 1;
                        }
                        var config = this.config;
                        if (loadError <= config.fragLoadingMaxRetry) {

                            //checking if there are different group track ids for redundant track functionality
                            var redundantTrackAvailable = false;
                            for (var i in hls.audioTrackController.tracks) {
                                if (hls.audioTrackController.tracks[i].groupId !== hls.audioTrackController.tracks[selTrackId].groupId) {
                                    redundantTrackAvailable = true;
                                    break;
                                }
                            }

                            //setting backup track | log
                            if (redundantTrackAvailable) {
                                var redundantTrackId = hls.audioTrackController.tracks.length / 2 + selTrackId;
                                hls.audioTrackController.trackId = redundantTrackId;
                                _this.trackId = redundantTrackId;
                            } else {
                                _logger.logger.warn('audioStreamController: no backup audio tracks available');
                            }

                            this.fragLoadError = loadError;
                            // reset load counter to avoid frag loop loading error
                            frag.loadCounter = 0;
                            // exponential backoff capped to config.fragLoadingMaxRetryTimeout
                            var delay = Math.min(Math.pow(2, loadError - 1) * config.fragLoadingRetryDelay, config.fragLoadingMaxRetryTimeout);
                            _logger.logger.warn('audioStreamController: frag loading failed, retry in ' + delay + ' ms');
                            this.retryDate = performance.now() + delay;
                            // retry loading state
                            this.state = State.FRAG_LOADING_WAITING_RETRY;
                        } else {
                            _logger.logger.error('audioStreamController: ' + data.details + ' reaches max retry, redispatch as fatal ...');
                            // switch error to fatal
                            data.fatal = true;
                            this.state = State.ERROR;
                        }
                    }
                    break;
                case _errors.ErrorDetails.FRAG_LOOP_LOADING_ERROR:
                case _errors.ErrorDetails.AUDIO_TRACK_LOAD_ERROR:
                case _errors.ErrorDetails.AUDIO_TRACK_LOAD_TIMEOUT:
                case _errors.ErrorDetails.KEY_LOAD_ERROR:
                case _errors.ErrorDetails.KEY_LOAD_TIMEOUT:
                    //  when in ERROR state, don't switch back to IDLE state in case a non-fatal error is received
                    if (this.state !== State.ERROR) {
                        // if fatal error, stop processing, otherwise move to IDLE to retry loading
                        this.state = data.fatal ? State.ERROR : State.IDLE;
                        _logger.logger.warn('audioStreamController: ' + data.details + ' while loading frag,switch to ' + this.state + ' state ...');
                    }
                    break;
                case _errors.ErrorDetails.BUFFER_FULL_ERROR:
                    // if in appending state
                    if (data.parent === 'audio' && (this.state === State.PARSING || this.state === State.PARSED)) {
                        var media = this.mediaBuffer,
                            currentTime = this.media.currentTime,
                            mediaBuffered = media && _bufferHelper2.default.isBuffered(media, currentTime) && _bufferHelper2.default.isBuffered(media, currentTime + 0.5);
                        // reduce max buf len if current position is buffered
                        if (mediaBuffered) {
                            var _config = this.config;
                            if (_config.maxMaxBufferLength >= _config.maxBufferLength) {
                                // reduce max buffer length as it might be too high. we do this to avoid loop flushing ...
                                _config.maxMaxBufferLength /= 2;
                                _logger.logger.warn('audio:reduce max buffer length to ' + _config.maxMaxBufferLength + 's');
                                // increase fragment load Index to avoid frag loop loading error after buffer flush
                                this.fragLoadIdx += 2 * _config.fragLoadingLoopThreshold;
                            }
                            this.state = State.IDLE;
                        } else {
                            // current position is not buffered, but browser is still complaining about buffer full error
                            // this happens on IE/Edge, refer to https://github.com/video-dev/hls.js/pull/708
                            // in that case flush the whole audio buffer to recover
                            _logger.logger.warn('buffer full error also media.currentTime is not buffered, flush audio buffer');
                            this.fragCurrent = null;
                            // flush everything
                            this.state = State.BUFFER_FLUSHING;
                            this.hls.trigger(_events2.default.BUFFER_FLUSHING, {
                                startOffset: 0,
                                endOffset: Number.POSITIVE_INFINITY,
                                type: 'audio'
                            });
                        }
                    }
                    break;
                default:
                    break;
            }
        }
    }, {
        key: 'onBufferFlushed',
        value: function onBufferFlushed() {
            var _this4 = this;

            var pendingData = this.pendingData;
            if (pendingData && pendingData.length) {
                _logger.logger.log('appending pending audio data on Buffer Flushed');
                pendingData.forEach(function (appendObj) {
                    _this4.hls.trigger(_events2.default.BUFFER_APPENDING, appendObj);
                });
                this.appended = true;
                this.pendingData = [];
                this.state = State.PARSED;
            } else {
                // move to IDLE once flush complete. this should trigger new fragment loading
                this.state = State.IDLE;
                // reset reference to frag
                this.fragPrevious = null;
                this.tick();
            }
        }
    }, {
        key: 'state',
        set: function set(nextState) {
            if (this.state !== nextState) {
                var previousState = this.state;
                this._state = nextState;
                _logger.logger.log('audio stream:' + previousState + '->' + nextState);
            }
        },
        get: function get() {
            return this._state;
        }
    }]);

    return AudioStreamController;
}(_eventHandler2.default);

exports.default = AudioStreamController;

},{"../demux/demuxer":25,"../errors":33,"../event-handler":34,"../events":35,"../helper/buffer-helper":37,"../helper/level-helper":38,"../utils/binary-search":48,"../utils/discontinuities":51,"../utils/logger":54,"../utils/timeRanges":55}],7:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _eventHandler = require('../event-handler');

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _logger = require('../utils/logger');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * audio track controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

var AudioTrackController = function (_EventHandler) {
  _inherits(AudioTrackController, _EventHandler);

  function AudioTrackController(hls) {
    _classCallCheck(this, AudioTrackController);

    var _this = _possibleConstructorReturn(this, (AudioTrackController.__proto__ || Object.getPrototypeOf(AudioTrackController)).call(this, hls, _events2.default.MANIFEST_LOADING, _events2.default.MANIFEST_LOADED, _events2.default.AUDIO_TRACK_LOADED));

    _this.ticks = 0;
    _this.ontick = _this.tick.bind(_this);
    return _this;
  }

  _createClass(AudioTrackController, [{
    key: 'destroy',
    value: function destroy() {
      _eventHandler2.default.prototype.destroy.call(this);
    }
  }, {
    key: 'tick',
    value: function tick() {
      this.ticks++;
      if (this.ticks === 1) {
        this.doTick();
        if (this.ticks > 1) {
          setTimeout(this.tick, 1);
        }
        this.ticks = 0;
      }
    }
  }, {
    key: 'doTick',
    value: function doTick() {
      this.updateTrack(this.trackId);
    }
  }, {
    key: 'onManifestLoading',
    value: function onManifestLoading() {
      // reset audio tracks on manifest loading
      this.tracks = [];
      this.trackId = -1;
    }
  }, {
    key: 'onManifestLoaded',
    value: function onManifestLoaded(data) {
      var _this2 = this;

      var tracks = data.audioTracks || [];
      var defaultFound = false;
      this.tracks = tracks;
      this.hls.trigger(_events2.default.AUDIO_TRACKS_UPDATED, { audioTracks: tracks });
      // loop through available audio tracks and autoselect default if needed
      var id = 0;
      tracks.forEach(function (track) {
        if (track.default && !defaultFound) {
          _this2.audioTrack = id;
          defaultFound = true;
          return;
        }
        id++;
      });
      if (defaultFound === false && tracks.length) {
        _logger.logger.log('no default audio track defined, use first audio track as default');
        this.audioTrack = 0;
      }
    }
  }, {
    key: 'onAudioTrackLoaded',
    value: function onAudioTrackLoaded(data) {
      if (data.id < this.tracks.length) {
        _logger.logger.log('audioTrack ' + data.id + ' loaded');
        this.tracks[data.id].details = data.details;
        // check if current playlist is a live playlist
        if (data.details.live && !this.timer) {
          // if live playlist we will have to reload it periodically
          // set reload period to playlist target duration
          this.timer = setInterval(this.ontick, 1000 * data.details.targetduration);
        }
        if (!data.details.live && this.timer) {
          // playlist is not live and timer is armed : stopping it
          clearInterval(this.timer);
          this.timer = null;
        }
      }
    }

    /** get alternate audio tracks list from playlist **/

  }, {
    key: 'setAudioTrackInternal',
    value: function setAudioTrackInternal(newId) {

      // check if level idx is valid
      if (newId >= 0 && newId < this.tracks.length) {
        // stopping live reloading timer if any
        if (this.timer) {
          clearInterval(this.timer);
          this.timer = null;
        }
        this.trackId = newId;
        _logger.logger.log('switching to audioTrack ' + newId);
        var audioTrack = this.tracks[newId],
            hls = this.hls,
            type = audioTrack.type,
            url = audioTrack.url,
            eventObj = { id: newId, type: type, url: url };
        // keep AUDIO_TRACK_SWITCH for legacy reason
        hls.trigger(_events2.default.AUDIO_TRACK_SWITCH, eventObj);
        hls.trigger(_events2.default.AUDIO_TRACK_SWITCHING, eventObj);
        // check if we need to load playlist for this audio Track
        var details = audioTrack.details;
        if (url && (details === undefined || details.live === true)) {
          // track not retrieved yet, or live playlist we need to (re)load it
          _logger.logger.log('(re)loading playlist for audioTrack ' + newId);
          hls.trigger(_events2.default.AUDIO_TRACK_LOADING, { url: url, id: newId });
        }
      }
    }

    // onError(err){
    // }


  }, {
    key: 'updateTrack',
    value: function updateTrack(newId) {
      // check if level idx is valid
      if (newId >= 0 && newId < this.tracks.length) {
        // stopping live reloading timer if any
        if (this.timer) {
          clearInterval(this.timer);
          this.timer = null;
        }
        this.trackId = newId;
        _logger.logger.log('updating audioTrack ' + newId);
        var audioTrack = this.tracks[newId],
            url = audioTrack.url;
        // check if we need to load playlist for this audio Track
        var details = audioTrack.details;
        if (url && (details === undefined || details.live === true)) {
          // track not retrieved yet, or live playlist we need to (re)load it
          _logger.logger.log('(re)loading playlist for audioTrack ' + newId);
          this.hls.trigger(_events2.default.AUDIO_TRACK_LOADING, { url: url, id: newId });
        }
      }
    }
  }, {
    key: 'audioTracks',
    get: function get() {
      return this.tracks;
    }

    /** get index of the selected audio track (index in audio track lists) **/

  }, {
    key: 'audioTrack',
    get: function get() {
      return this.trackId;
    }

    /** select an audio track, based on its index in audio track lists**/
    ,
    set: function set(audioTrackId) {
      if (this.trackId !== audioTrackId || this.tracks[audioTrackId].details === undefined) {
        this.setAudioTrackInternal(audioTrackId);
      }
    }
  }]);

  return AudioTrackController;
}(_eventHandler2.default);

exports.default = AudioTrackController;

},{"../event-handler":34,"../events":35,"../utils/logger":54}],8:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _eventHandler = require('../event-handler');

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _logger = require('../utils/logger');

var _errors = require('../errors');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Buffer Controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

var BufferController = function (_EventHandler) {
  _inherits(BufferController, _EventHandler);

  function BufferController(hls) {
    _classCallCheck(this, BufferController);

    // the value that we have set mediasource.duration to
    // (the actual duration may be tweaked slighly by the browser)
    var _this = _possibleConstructorReturn(this, (BufferController.__proto__ || Object.getPrototypeOf(BufferController)).call(this, hls, _events2.default.MEDIA_ATTACHING, _events2.default.MEDIA_DETACHING, _events2.default.MANIFEST_PARSED, _events2.default.BUFFER_RESET, _events2.default.BUFFER_APPENDING, _events2.default.BUFFER_CODECS, _events2.default.BUFFER_EOS, _events2.default.BUFFER_FLUSHING, _events2.default.LEVEL_PTS_UPDATED, _events2.default.LEVEL_UPDATED));

    _this._msDuration = null;
    // the value that we want to set mediaSource.duration to
    _this._levelDuration = null;

    // Source Buffer listeners
    _this.onsbue = _this.onSBUpdateEnd.bind(_this);
    _this.onsbe = _this.onSBUpdateError.bind(_this);
    _this.pendingTracks = {};
    _this.tracks = {};
    return _this;
  }

  _createClass(BufferController, [{
    key: 'destroy',
    value: function destroy() {
      _eventHandler2.default.prototype.destroy.call(this);
    }
  }, {
    key: 'onLevelPtsUpdated',
    value: function onLevelPtsUpdated(data) {
      var type = data.type;
      var audioTrack = this.tracks.audio;

      // Adjusting `SourceBuffer.timestampOffset` (desired point in the timeline where the next frames should be appended)
      // in Chrome browser when we detect MPEG audio container and time delta between level PTS and `SourceBuffer.timestampOffset`
      // is greater than 100ms (this is enough to handle seek for VOD or level change for LIVE videos). At the time of change we issue
      // `SourceBuffer.abort()` and adjusting `SourceBuffer.timestampOffset` if `SourceBuffer.updating` is false or awaiting `updateend`
      // event if SB is in updating state.
      // More info here: https://github.com/video-dev/hls.js/issues/332#issuecomment-257986486

      if (type === 'audio' && audioTrack && audioTrack.container === 'audio/mpeg') {
        // Chrome audio mp3 track
        var audioBuffer = this.sourceBuffer.audio;
        var delta = Math.abs(audioBuffer.timestampOffset - data.start);

        // adjust timestamp offset if time delta is greater than 100ms
        if (delta > 0.1) {
          var updating = audioBuffer.updating;

          try {
            audioBuffer.abort();
          } catch (err) {
            updating = true;
            _logger.logger.warn('can not abort audio buffer: ' + err);
          }

          if (!updating) {
            _logger.logger.warn('change mpeg audio timestamp offset from ' + audioBuffer.timestampOffset + ' to ' + data.start);
            audioBuffer.timestampOffset = data.start;
          } else {
            this.audioTimestampOffset = data.start;
          }
        }
      }
    }
  }, {
    key: 'onManifestParsed',
    value: function onManifestParsed(data) {
      var audioExpected = data.audio,
          videoExpected = data.video || data.levels.length && data.audio,
          sourceBufferNb = 0;
      // in case of alt audio 2 BUFFER_CODECS events will be triggered, one per stream controller
      // sourcebuffers will be created all at once when the expected nb of tracks will be reached
      // in case alt audio is not used, only one BUFFER_CODEC event will be fired from main stream controller
      // it will contain the expected nb of source buffers, no need to compute it
      if (data.altAudio && (audioExpected || videoExpected)) {
        sourceBufferNb = (audioExpected ? 1 : 0) + (videoExpected ? 1 : 0);
        _logger.logger.log(sourceBufferNb + ' sourceBuffer(s) expected');
      }
      this.sourceBufferNb = sourceBufferNb;
    }
  }, {
    key: 'onMediaAttaching',
    value: function onMediaAttaching(data) {
      var media = this.media = data.media;
      if (media) {
        // setup the media source
        var ms = this.mediaSource = new MediaSource();
        //Media Source listeners
        this.onmso = this.onMediaSourceOpen.bind(this);
        this.onmse = this.onMediaSourceEnded.bind(this);
        this.onmsc = this.onMediaSourceClose.bind(this);
        ms.addEventListener('sourceopen', this.onmso);
        ms.addEventListener('sourceended', this.onmse);
        ms.addEventListener('sourceclose', this.onmsc);
        // link video and media Source
        media.src = URL.createObjectURL(ms);
      }
    }
  }, {
    key: 'onMediaDetaching',
    value: function onMediaDetaching() {
      _logger.logger.log('media source detaching');
      var ms = this.mediaSource;
      if (ms) {
        if (ms.readyState === 'open') {
          try {
            // endOfStream could trigger exception if any sourcebuffer is in updating state
            // we don't really care about checking sourcebuffer state here,
            // as we are anyway detaching the MediaSource
            // let's just avoid this exception to propagate
            ms.endOfStream();
          } catch (err) {
            _logger.logger.warn('onMediaDetaching:' + err.message + ' while calling endOfStream');
          }
        }
        ms.removeEventListener('sourceopen', this.onmso);
        ms.removeEventListener('sourceended', this.onmse);
        ms.removeEventListener('sourceclose', this.onmsc);

        // Detach properly the MediaSource from the HTMLMediaElement as
        // suggested in https://github.com/w3c/media-source/issues/53.
        if (this.media) {
          URL.revokeObjectURL(this.media.src);
          this.media.removeAttribute('src');
          this.media.load();
        }

        this.mediaSource = null;
        this.media = null;
        this.pendingTracks = {};
        this.tracks = {};
        this.sourceBuffer = {};
        this.flushRange = [];
        this.segments = [];
        this.appended = 0;
      }
      this.onmso = this.onmse = this.onmsc = null;
      this.hls.trigger(_events2.default.MEDIA_DETACHED);
    }
  }, {
    key: 'onMediaSourceOpen',
    value: function onMediaSourceOpen() {
      _logger.logger.log('media source opened');
      this.hls.trigger(_events2.default.MEDIA_ATTACHED, { media: this.media });
      var mediaSource = this.mediaSource;
      if (mediaSource) {
        // once received, don't listen anymore to sourceopen event
        mediaSource.removeEventListener('sourceopen', this.onmso);
      }
      this.checkPendingTracks();
    }
  }, {
    key: 'checkPendingTracks',
    value: function checkPendingTracks() {
      // if any buffer codecs pending, check if we have enough to create sourceBuffers
      var pendingTracks = this.pendingTracks,
          pendingTracksNb = Object.keys(pendingTracks).length;
      // if any pending tracks and (if nb of pending tracks gt or equal than expected nb or if unknown expected nb)
      if (pendingTracksNb && (this.sourceBufferNb <= pendingTracksNb || this.sourceBufferNb === 0)) {
        // ok, let's create them now !
        this.createSourceBuffers(pendingTracks);
        this.pendingTracks = {};
        // append any pending segments now !
        this.doAppending();
      }
    }
  }, {
    key: 'onMediaSourceClose',
    value: function onMediaSourceClose() {
      _logger.logger.log('media source closed');
    }
  }, {
    key: 'onMediaSourceEnded',
    value: function onMediaSourceEnded() {
      _logger.logger.log('media source ended');
    }
  }, {
    key: 'onSBUpdateEnd',
    value: function onSBUpdateEnd() {
      // update timestampOffset
      if (this.audioTimestampOffset) {
        var audioBuffer = this.sourceBuffer.audio;
        _logger.logger.warn('change mpeg audio timestamp offset from ' + audioBuffer.timestampOffset + ' to ' + this.audioTimestampOffset);
        audioBuffer.timestampOffset = this.audioTimestampOffset;
        delete this.audioTimestampOffset;
      }

      if (this._needsFlush) {
        this.doFlush();
      }

      if (this._needsEos) {
        this.checkEos();
      }
      this.appending = false;
      var parent = this.parent;
      // count nb of pending segments waiting for appending on this sourcebuffer
      var pending = this.segments.reduce(function (counter, segment) {
        return segment.parent === parent ? counter + 1 : counter;
      }, 0);
      this.hls.trigger(_events2.default.BUFFER_APPENDED, { parent: parent, pending: pending });

      // don't append in flushing mode
      if (!this._needsFlush) {
        this.doAppending();
      }

      this.updateMediaElementDuration();
    }
  }, {
    key: 'onSBUpdateError',
    value: function onSBUpdateError(event) {
      _logger.logger.error('sourceBuffer error:', event);
      // according to http://www.w3.org/TR/media-source/#sourcebuffer-append-error
      // this error might not always be fatal (it is fatal if decode error is set, in that case
      // it will be followed by a mediaElement error ...)
      this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.BUFFER_APPENDING_ERROR, fatal: false });
      // we don't need to do more than that, as accordin to the spec, updateend will be fired just after
    }
  }, {
    key: 'onBufferReset',
    value: function onBufferReset() {
      var sourceBuffer = this.sourceBuffer;
      for (var type in sourceBuffer) {
        var sb = sourceBuffer[type];
        try {
          this.mediaSource.removeSourceBuffer(sb);
          sb.removeEventListener('updateend', this.onsbue);
          sb.removeEventListener('error', this.onsbe);
        } catch (err) {}
      }
      this.sourceBuffer = {};
      this.flushRange = [];
      this.segments = [];
      this.appended = 0;
    }
  }, {
    key: 'onBufferCodecs',
    value: function onBufferCodecs(tracks) {
      // if source buffer(s) not created yet, appended buffer tracks in this.pendingTracks
      // if sourcebuffers already created, do nothing ...
      if (Object.keys(this.sourceBuffer).length === 0) {
        for (var trackName in tracks) {
          this.pendingTracks[trackName] = tracks[trackName];
        }
        var mediaSource = this.mediaSource;
        if (mediaSource && mediaSource.readyState === 'open') {
          // try to create sourcebuffers if mediasource opened
          this.checkPendingTracks();
        }
      }
    }
  }, {
    key: 'createSourceBuffers',
    value: function createSourceBuffers(tracks) {
      var sourceBuffer = this.sourceBuffer,
          mediaSource = this.mediaSource;

      for (var trackName in tracks) {
        if (!sourceBuffer[trackName]) {
          var track = tracks[trackName];
          // use levelCodec as first priority
          var codec = track.levelCodec || track.codec;
          var mimeType = track.container + ';codecs=' + codec;
          _logger.logger.log('creating sourceBuffer(' + mimeType + ')');
          try {
            var sb = sourceBuffer[trackName] = mediaSource.addSourceBuffer(mimeType);
            sb.addEventListener('updateend', this.onsbue);
            sb.addEventListener('error', this.onsbe);
            this.tracks[trackName] = { codec: codec, container: track.container };
            track.buffer = sb;
          } catch (err) {
            _logger.logger.error('error while trying to add sourceBuffer:' + err.message);
            this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.BUFFER_ADD_CODEC_ERROR, fatal: false, err: err, mimeType: mimeType });
          }
        }
      }
      this.hls.trigger(_events2.default.BUFFER_CREATED, { tracks: tracks });
    }
  }, {
    key: 'onBufferAppending',
    value: function onBufferAppending(data) {
      if (!this._needsFlush) {
        if (!this.segments) {
          this.segments = [data];
        } else {
          this.segments.push(data);
        }
        this.doAppending();
      }
    }
  }, {
    key: 'onBufferAppendFail',
    value: function onBufferAppendFail(data) {
      _logger.logger.error('sourceBuffer error:', data.event);
      // according to http://www.w3.org/TR/media-source/#sourcebuffer-append-error
      // this error might not always be fatal (it is fatal if decode error is set, in that case
      // it will be followed by a mediaElement error ...)
      this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.BUFFER_APPENDING_ERROR, fatal: false });
    }

    // on BUFFER_EOS mark matching sourcebuffer(s) as ended and trigger checkEos()

  }, {
    key: 'onBufferEos',
    value: function onBufferEos(data) {
      var sb = this.sourceBuffer;
      var dataType = data.type;
      for (var type in sb) {
        if (!dataType || type === dataType) {
          if (!sb[type].ended) {
            sb[type].ended = true;
            _logger.logger.log(type + ' sourceBuffer now EOS');
          }
        }
      }
      this.checkEos();
    }

    // if all source buffers are marked as ended, signal endOfStream() to MediaSource.

  }, {
    key: 'checkEos',
    value: function checkEos() {
      var sb = this.sourceBuffer,
          mediaSource = this.mediaSource;
      if (!mediaSource || mediaSource.readyState !== 'open') {
        this._needsEos = false;
        return;
      }
      for (var type in sb) {
        var sbobj = sb[type];
        if (!sbobj.ended) {
          return;
        }
        if (sbobj.updating) {
          this._needsEos = true;
          return;
        }
      }
      _logger.logger.log('all media data available, signal endOfStream() to MediaSource and stop loading fragment');
      //Notify the media element that it now has all of the media data
      try {
        mediaSource.endOfStream();
      } catch (e) {
        _logger.logger.warn('exception while calling mediaSource.endOfStream()');
      }
      this._needsEos = false;
    }
  }, {
    key: 'onBufferFlushing',
    value: function onBufferFlushing(data) {
      this.flushRange.push({ start: data.startOffset, end: data.endOffset, type: data.type });
      // attempt flush immediatly
      this.flushBufferCounter = 0;
      this.doFlush();
    }
  }, {
    key: 'onLevelUpdated',
    value: function onLevelUpdated(event) {
      var details = event.details;
      if (details.fragments.length === 0) {
        return;
      }
      this._levelDuration = details.totalduration + details.fragments[0].start;
      this.updateMediaElementDuration();
    }

    // https://github.com/video-dev/hls.js/issues/355

  }, {
    key: 'updateMediaElementDuration',
    value: function updateMediaElementDuration() {
      var media = this.media,
          mediaSource = this.mediaSource,
          sourceBuffer = this.sourceBuffer,
          levelDuration = this._levelDuration;
      if (levelDuration === null || !media || !mediaSource || !sourceBuffer || media.readyState === 0 || mediaSource.readyState !== 'open') {
        return;
      }
      for (var type in sourceBuffer) {
        if (sourceBuffer[type].updating) {
          // can't set duration whilst a buffer is updating
          return;
        }
      }
      if (this._msDuration === null) {
        // initialise to the value that the media source is reporting
        this._msDuration = mediaSource.duration;
      }
      var duration = media.duration;
      // levelDuration was the last value we set.
      // not using mediaSource.duration as the browser may tweak this value
      // only update mediasource duration if its value increase, this is to avoid
      // flushing already buffered portion when switching between quality level
      if (levelDuration > this._msDuration && levelDuration > duration || duration === Infinity || isNaN(duration)) {
        _logger.logger.log('Updating mediasource duration to ' + levelDuration.toFixed(3));
        this._msDuration = mediaSource.duration = levelDuration;
      }
    }
  }, {
    key: 'doFlush',
    value: function doFlush() {
      // loop through all buffer ranges to flush
      while (this.flushRange.length) {
        var range = this.flushRange[0];
        // flushBuffer will abort any buffer append in progress and flush Audio/Video Buffer
        if (this.flushBuffer(range.start, range.end, range.type)) {
          // range flushed, remove from flush array
          this.flushRange.shift();
          this.flushBufferCounter = 0;
        } else {
          this._needsFlush = true;
          // avoid looping, wait for SB update end to retrigger a flush
          return;
        }
      }
      if (this.flushRange.length === 0) {
        // everything flushed
        this._needsFlush = false;

        // let's recompute this.appended, which is used to avoid flush looping
        var appended = 0;
        var sourceBuffer = this.sourceBuffer;
        try {
          for (var type in sourceBuffer) {
            appended += sourceBuffer[type].buffered.length;
          }
        } catch (error) {
          // error could be thrown while accessing buffered, in case sourcebuffer has already been removed from MediaSource
          // this is harmess at this stage, catch this to avoid reporting an internal exception
          _logger.logger.error('error while accessing sourceBuffer.buffered');
        }
        this.appended = appended;
        this.hls.trigger(_events2.default.BUFFER_FLUSHED);
      }
    }
  }, {
    key: 'doAppending',
    value: function doAppending() {
      var hls = this.hls,
          sourceBuffer = this.sourceBuffer,
          segments = this.segments;
      if (Object.keys(sourceBuffer).length) {
        if (this.media.error) {
          this.segments = [];
          _logger.logger.error('trying to append although a media error occured, flush segment and abort');
          return;
        }
        if (this.appending) {
          //logger.log(`sb appending in progress`);
          return;
        }
        if (segments && segments.length) {
          var segment = segments.shift();
          try {
            var type = segment.type,
                sb = sourceBuffer[type];
            if (sb) {
              if (!sb.updating) {
                // reset sourceBuffer ended flag before appending segment
                sb.ended = false;
                //logger.log(`appending ${segment.content} ${type} SB, size:${segment.data.length}, ${segment.parent}`);
                this.parent = segment.parent;
                sb.appendBuffer(segment.data);
                this.appendError = 0;
                this.appended++;
                this.appending = true;
              } else {
                segments.unshift(segment);
              }
            } else {
              // in case we don't have any source buffer matching with this segment type,
              // it means that Mediasource fails to create sourcebuffer
              // discard this segment, and trigger update end
              this.onSBUpdateEnd();
            }
          } catch (err) {
            // in case any error occured while appending, put back segment in segments table
            _logger.logger.error('error while trying to append buffer:' + err.message);
            segments.unshift(segment);
            var event = { type: _errors.ErrorTypes.MEDIA_ERROR, parent: segment.parent };
            if (err.code !== 22) {
              if (this.appendError) {
                this.appendError++;
              } else {
                this.appendError = 1;
              }
              event.details = _errors.ErrorDetails.BUFFER_APPEND_ERROR;
              /* with UHD content, we could get loop of quota exceeded error until
                browser is able to evict some data from sourcebuffer. retrying help recovering this
              */
              if (this.appendError > hls.config.appendErrorMaxRetry) {
                _logger.logger.log('fail ' + hls.config.appendErrorMaxRetry + ' times to append segment in sourceBuffer');
                segments = [];
                event.fatal = true;
                hls.trigger(_events2.default.ERROR, event);
                return;
              } else {
                event.fatal = false;
                hls.trigger(_events2.default.ERROR, event);
              }
            } else {
              // QuotaExceededError: http://www.w3.org/TR/html5/infrastructure.html#quotaexceedederror
              // let's stop appending any segments, and report BUFFER_FULL_ERROR error
              this.segments = [];
              event.details = _errors.ErrorDetails.BUFFER_FULL_ERROR;
              event.fatal = false;
              hls.trigger(_events2.default.ERROR, event);
              return;
            }
          }
        }
      }
    }

    /*
      flush specified buffered range,
      return true once range has been flushed.
      as sourceBuffer.remove() is asynchronous, flushBuffer will be retriggered on sourceBuffer update end
    */

  }, {
    key: 'flushBuffer',
    value: function flushBuffer(startOffset, endOffset, typeIn) {
      var sb,
          i,
          bufStart,
          bufEnd,
          flushStart,
          flushEnd,
          sourceBuffer = this.sourceBuffer;
      if (Object.keys(sourceBuffer).length) {
        _logger.logger.log('flushBuffer,pos/start/end: ' + this.media.currentTime.toFixed(3) + '/' + startOffset + '/' + endOffset);
        // safeguard to avoid infinite looping : don't try to flush more than the nb of appended segments
        if (this.flushBufferCounter < this.appended) {
          for (var type in sourceBuffer) {
            // check if sourcebuffer type is defined (typeIn): if yes, let's only flush this one
            // if no, let's flush all sourcebuffers
            if (typeIn && type !== typeIn) {
              continue;
            }
            sb = sourceBuffer[type];
            // we are going to flush buffer, mark source buffer as 'not ended'
            sb.ended = false;
            if (!sb.updating) {
              try {
                for (i = 0; i < sb.buffered.length; i++) {
                  bufStart = sb.buffered.start(i);
                  bufEnd = sb.buffered.end(i);
                  // workaround firefox not able to properly flush multiple buffered range.
                  if (navigator.userAgent.toLowerCase().indexOf('firefox') !== -1 && endOffset === Number.POSITIVE_INFINITY) {
                    flushStart = startOffset;
                    flushEnd = endOffset;
                  } else {
                    flushStart = Math.max(bufStart, startOffset);
                    flushEnd = Math.min(bufEnd, endOffset);
                  }
                  /* sometimes sourcebuffer.remove() does not flush
                     the exact expected time range.
                     to avoid rounding issues/infinite loop,
                     only flush buffer range of length greater than 500ms.
                  */
                  if (Math.min(flushEnd, bufEnd) - flushStart > 0.5) {
                    this.flushBufferCounter++;
                    _logger.logger.log('flush ' + type + ' [' + flushStart + ',' + flushEnd + '], of [' + bufStart + ',' + bufEnd + '], pos:' + this.media.currentTime);
                    sb.remove(flushStart, flushEnd);
                    return false;
                  }
                }
              } catch (e) {
                _logger.logger.warn('exception while accessing sourcebuffer, it might have been removed from MediaSource');
              }
            } else {
              //logger.log('abort ' + type + ' append in progress');
              // this will abort any appending in progress
              //sb.abort();
              _logger.logger.warn('cannot flush, sb updating in progress');
              return false;
            }
          }
        } else {
          _logger.logger.warn('abort flushing too many retries');
        }
        _logger.logger.log('buffer flushed');
      }
      // everything flushed !
      return true;
    }
  }]);

  return BufferController;
}(_eventHandler2.default);

exports.default = BufferController;

},{"../errors":33,"../event-handler":34,"../events":35,"../utils/logger":54}],9:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _eventHandler = require('../event-handler');

var _eventHandler2 = _interopRequireDefault(_eventHandler);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * cap stream level to media size dimension controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

var CapLevelController = function (_EventHandler) {
  _inherits(CapLevelController, _EventHandler);

  function CapLevelController(hls) {
    _classCallCheck(this, CapLevelController);

    return _possibleConstructorReturn(this, (CapLevelController.__proto__ || Object.getPrototypeOf(CapLevelController)).call(this, hls, _events2.default.FPS_DROP_LEVEL_CAPPING, _events2.default.MEDIA_ATTACHING, _events2.default.MANIFEST_PARSED));
  }

  _createClass(CapLevelController, [{
    key: 'destroy',
    value: function destroy() {
      if (this.hls.config.capLevelToPlayerSize) {
        this.media = this.restrictedLevels = null;
        this.autoLevelCapping = Number.POSITIVE_INFINITY;
        if (this.timer) {
          this.timer = clearInterval(this.timer);
        }
      }
    }
  }, {
    key: 'onFpsDropLevelCapping',
    value: function onFpsDropLevelCapping(data) {
      // Don't add a restricted level more than once
      if (CapLevelController.isLevelAllowed(data.droppedLevel, this.restrictedLevels)) {
        this.restrictedLevels.push(data.droppedLevel);
      }
    }
  }, {
    key: 'onMediaAttaching',
    value: function onMediaAttaching(data) {
      this.media = data.media instanceof HTMLVideoElement ? data.media : null;
    }
  }, {
    key: 'onManifestParsed',
    value: function onManifestParsed(data) {
      var hls = this.hls;
      this.restrictedLevels = [];
      if (hls.config.capLevelToPlayerSize) {
        this.autoLevelCapping = Number.POSITIVE_INFINITY;
        this.levels = data.levels;
        hls.firstLevel = this.getMaxLevel(data.firstLevel);
        clearInterval(this.timer);
        this.timer = setInterval(this.detectPlayerSize.bind(this), 1000);
        this.detectPlayerSize();
      }
    }
  }, {
    key: 'detectPlayerSize',
    value: function detectPlayerSize() {
      if (this.media) {
        var levelsLength = this.levels ? this.levels.length : 0;
        if (levelsLength) {
          var hls = this.hls;
          hls.autoLevelCapping = this.getMaxLevel(levelsLength - 1);
          if (hls.autoLevelCapping > this.autoLevelCapping) {
            // if auto level capping has a higher value for the previous one, flush the buffer using nextLevelSwitch
            // usually happen when the user go to the fullscreen mode.
            hls.streamController.nextLevelSwitch();
          }
          this.autoLevelCapping = hls.autoLevelCapping;
        }
      }
    }

    /*
    * returns level should be the one with the dimensions equal or greater than the media (player) dimensions (so the video will be downscaled)
    */

  }, {
    key: 'getMaxLevel',
    value: function getMaxLevel(capLevelIndex) {
      var _this2 = this;

      if (!this.levels) {
        return -1;
      }

      var validLevels = this.levels.filter(function (level, index) {
        return CapLevelController.isLevelAllowed(index, _this2.restrictedLevels) && index <= capLevelIndex;
      });

      return CapLevelController.getMaxLevelByMediaSize(validLevels, this.mediaWidth, this.mediaHeight);
    }
  }, {
    key: 'mediaWidth',
    get: function get() {
      var width = void 0;
      var media = this.media;
      if (media) {
        width = media.width || media.clientWidth || media.offsetWidth;
        width *= CapLevelController.contentScaleFactor;
      }
      return width;
    }
  }, {
    key: 'mediaHeight',
    get: function get() {
      var height = void 0;
      var media = this.media;
      if (media) {
        height = media.height || media.clientHeight || media.offsetHeight;
        height *= CapLevelController.contentScaleFactor;
      }
      return height;
    }
  }], [{
    key: 'isLevelAllowed',
    value: function isLevelAllowed(level) {
      var restrictedLevels = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

      return restrictedLevels.indexOf(level) === -1;
    }
  }, {
    key: 'getMaxLevelByMediaSize',
    value: function getMaxLevelByMediaSize(levels, width, height) {
      if (!levels || levels && !levels.length) {
        return -1;
      }

      // Levels can have the same dimensions but differing bandwidths - since levels are ordered, we can look to the next
      // to determine whether we've chosen the greatest bandwidth for the media's dimensions
      var atGreatestBandiwdth = function atGreatestBandiwdth(curLevel, nextLevel) {
        if (!nextLevel) {
          return true;
        }
        return curLevel.width !== nextLevel.width || curLevel.height !== nextLevel.height;
      };

      // If we run through the loop without breaking, the media's dimensions are greater than every level, so default to
      // the max level
      var maxLevelIndex = levels.length - 1;

      for (var i = 0; i < levels.length; i += 1) {
        var level = levels[i];
        if ((level.width >= width || level.height >= height) && atGreatestBandiwdth(level, levels[i + 1])) {
          maxLevelIndex = i;
          break;
        }
      }

      return maxLevelIndex;
    }
  }, {
    key: 'contentScaleFactor',
    get: function get() {
      var pixelRatio = 1;
      try {
        pixelRatio = window.devicePixelRatio;
      } catch (e) {}
      return pixelRatio;
    }
  }]);

  return CapLevelController;
}(_eventHandler2.default);

exports.default = CapLevelController;

},{"../event-handler":34,"../events":35}],10:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _eventHandler = require('../event-handler');

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _logger = require('../utils/logger');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * FPS Controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

var FPSController = function (_EventHandler) {
  _inherits(FPSController, _EventHandler);

  function FPSController(hls) {
    _classCallCheck(this, FPSController);

    return _possibleConstructorReturn(this, (FPSController.__proto__ || Object.getPrototypeOf(FPSController)).call(this, hls, _events2.default.MEDIA_ATTACHING));
  }

  _createClass(FPSController, [{
    key: 'destroy',
    value: function destroy() {
      if (this.timer) {
        clearInterval(this.timer);
      }
      this.isVideoPlaybackQualityAvailable = false;
    }
  }, {
    key: 'onMediaAttaching',
    value: function onMediaAttaching(data) {
      var config = this.hls.config;
      if (config.capLevelOnFPSDrop) {
        var video = this.video = data.media instanceof HTMLVideoElement ? data.media : null;
        if (typeof video.getVideoPlaybackQuality === 'function') {
          this.isVideoPlaybackQualityAvailable = true;
        }
        clearInterval(this.timer);
        this.timer = setInterval(this.checkFPSInterval.bind(this), config.fpsDroppedMonitoringPeriod);
      }
    }
  }, {
    key: 'checkFPS',
    value: function checkFPS(video, decodedFrames, droppedFrames) {
      var currentTime = performance.now();
      if (decodedFrames) {
        if (this.lastTime) {
          var currentPeriod = currentTime - this.lastTime,
              currentDropped = droppedFrames - this.lastDroppedFrames,
              currentDecoded = decodedFrames - this.lastDecodedFrames,
              droppedFPS = 1000 * currentDropped / currentPeriod,
              hls = this.hls;
          hls.trigger(_events2.default.FPS_DROP, { currentDropped: currentDropped, currentDecoded: currentDecoded, totalDroppedFrames: droppedFrames });
          if (droppedFPS > 0) {
            //logger.log('checkFPS : droppedFPS/decodedFPS:' + droppedFPS/(1000 * currentDecoded / currentPeriod));
            if (currentDropped > hls.config.fpsDroppedMonitoringThreshold * currentDecoded) {
              var currentLevel = hls.currentLevel;
              _logger.logger.warn('drop FPS ratio greater than max allowed value for currentLevel: ' + currentLevel);
              if (currentLevel > 0 && (hls.autoLevelCapping === -1 || hls.autoLevelCapping >= currentLevel)) {
                currentLevel = currentLevel - 1;
                hls.trigger(_events2.default.FPS_DROP_LEVEL_CAPPING, { level: currentLevel, droppedLevel: hls.currentLevel });
                hls.autoLevelCapping = currentLevel;
                hls.streamController.nextLevelSwitch();
              }
            }
          }
        }
        this.lastTime = currentTime;
        this.lastDroppedFrames = droppedFrames;
        this.lastDecodedFrames = decodedFrames;
      }
    }
  }, {
    key: 'checkFPSInterval',
    value: function checkFPSInterval() {
      var video = this.video;
      if (video) {
        if (this.isVideoPlaybackQualityAvailable) {
          var videoPlaybackQuality = video.getVideoPlaybackQuality();
          this.checkFPS(video, videoPlaybackQuality.totalVideoFrames, videoPlaybackQuality.droppedVideoFrames);
        } else {
          this.checkFPS(video, video.webkitDecodedFrameCount, video.webkitDroppedFrameCount);
        }
      }
    }
  }]);

  return FPSController;
}(_eventHandler2.default);

exports.default = FPSController;

},{"../event-handler":34,"../events":35,"../utils/logger":54}],11:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _eventHandler = require('../event-handler');

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _id = require('../demux/id3');

var _id2 = _interopRequireDefault(_id);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * id3 metadata track controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

var ID3TrackController = function (_EventHandler) {
  _inherits(ID3TrackController, _EventHandler);

  function ID3TrackController(hls) {
    _classCallCheck(this, ID3TrackController);

    var _this = _possibleConstructorReturn(this, (ID3TrackController.__proto__ || Object.getPrototypeOf(ID3TrackController)).call(this, hls, _events2.default.MEDIA_ATTACHED, _events2.default.MEDIA_DETACHING, _events2.default.FRAG_PARSING_METADATA));

    _this.id3Track = undefined;
    _this.media = undefined;
    return _this;
  }

  _createClass(ID3TrackController, [{
    key: 'destroy',
    value: function destroy() {
      _eventHandler2.default.prototype.destroy.call(this);
    }

    // Add ID3 metatadata text track.

  }, {
    key: 'onMediaAttached',
    value: function onMediaAttached(data) {
      this.media = data.media;
      if (!this.media) {
        return;
      }

      this.id3Track = this.media.addTextTrack('metadata', 'id3');
      this.id3Track.mode = 'hidden';
    }
  }, {
    key: 'onMediaDetaching',
    value: function onMediaDetaching() {
      this.media = undefined;
    }
  }, {
    key: 'onFragParsingMetadata',
    value: function onFragParsingMetadata(data) {
      var fragment = data.frag;
      var samples = data.samples;

      // Attempt to recreate Safari functionality by creating
      // WebKitDataCue objects when available and store the decoded
      // ID3 data in the value property of the cue
      var Cue = window.WebKitDataCue || window.VTTCue || window.TextTrackCue;

      for (var i = 0; i < samples.length; i++) {
        var frames = _id2.default.getID3Frames(samples[i].data);
        if (frames) {
          var startTime = samples[i].pts;
          var endTime = i < samples.length - 1 ? samples[i + 1].pts : fragment.endPTS;

          // Give a slight bump to the endTime if it's equal to startTime to avoid a SyntaxError in IE
          if (startTime === endTime) {
            endTime += 0.0001;
          }

          for (var j = 0; j < frames.length; j++) {
            var frame = frames[j];
            // Safari doesn't put the timestamp frame in the TextTrack
            if (!_id2.default.isTimeStampFrame(frame)) {
              var cue = new Cue(startTime, endTime, '');
              cue.value = frame;
              this.id3Track.addCue(cue);
            }
          }
        }
      }
    }
  }]);

  return ID3TrackController;
}(_eventHandler2.default);

exports.default = ID3TrackController;

},{"../demux/id3":27,"../event-handler":34,"../events":35}],12:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _eventHandler = require('../event-handler');

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _logger = require('../utils/logger');

var _errors = require('../errors');

var _bufferHelper = require('../helper/buffer-helper');

var _bufferHelper2 = _interopRequireDefault(_bufferHelper);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Level Controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

var LevelController = function (_EventHandler) {
  _inherits(LevelController, _EventHandler);

  function LevelController(hls) {
    _classCallCheck(this, LevelController);

    var _this = _possibleConstructorReturn(this, (LevelController.__proto__ || Object.getPrototypeOf(LevelController)).call(this, hls, _events2.default.MANIFEST_LOADED, _events2.default.LEVEL_LOADED, _events2.default.FRAG_LOADED, _events2.default.ERROR));

    _this.ontick = _this.tick.bind(_this);
    _this._manualLevel = -1;
    return _this;
  }

  _createClass(LevelController, [{
    key: 'destroy',
    value: function destroy() {
      if (this.timer) {
        clearTimeout(this.timer);
        this.timer = null;
      }
      this._manualLevel = -1;
    }
  }, {
    key: 'startLoad',
    value: function startLoad() {
      this.canload = true;
      var levels = this._levels;
      // clean up live level details to force reload them, and reset load errors
      if (levels) {
        levels.forEach(function (level) {
          level.loadError = 0;
          var levelDetails = level.details;
          if (levelDetails && levelDetails.live) {
            level.details = undefined;
          }
        });
      }
      // speed up live playlist refresh if timer exists
      if (this.timer) {
        this.tick();
      }
    }
  }, {
    key: 'stopLoad',
    value: function stopLoad() {
      this.canload = false;
    }
  }, {
    key: 'onManifestLoaded',
    value: function onManifestLoaded(data) {
      var levels0 = [],
          levels = [],
          bitrateStart,
          bitrateSet = {},
          videoCodecFound = false,
          audioCodecFound = false,
          hls = this.hls,
          brokenmp4inmp3 = /chrome|firefox/.test(navigator.userAgent.toLowerCase()),
          checkSupported = function checkSupported(type, codec) {
        return MediaSource.isTypeSupported(type + '/mp4;codecs=' + codec);
      };

      // regroup redundant level together
      data.levels.forEach(function (level) {
        if (level.videoCodec) {
          videoCodecFound = true;
        }
        // erase audio codec info if browser does not support mp4a.40.34. demuxer will autodetect codec and fallback to mpeg/audio
        if (brokenmp4inmp3 && level.audioCodec && level.audioCodec.indexOf('mp4a.40.34') !== -1) {
          level.audioCodec = undefined;
        }
        if (level.audioCodec || level.attrs && level.attrs.AUDIO) {
          audioCodecFound = true;
        }
        var redundantLevelId = bitrateSet[level.bitrate];
        if (redundantLevelId === undefined) {
          bitrateSet[level.bitrate] = levels0.length;
          level.url = [level.url];
          level.urlId = 0;
          levels0.push(level);
        } else {
          levels0[redundantLevelId].url.push(level.url);
        }
      });

      // remove audio-only level if we also have levels with audio+video codecs signalled
      if (videoCodecFound && audioCodecFound) {
        levels0.forEach(function (level) {
          if (level.videoCodec) {
            levels.push(level);
          }
        });
      } else {
        levels = levels0;
      }
      // only keep level with supported audio/video codecs
      levels = levels.filter(function (level) {
        var audioCodec = level.audioCodec,
            videoCodec = level.videoCodec;
        return (!audioCodec || checkSupported('audio', audioCodec)) && (!videoCodec || checkSupported('video', videoCodec));
      });

      if (levels.length) {
        // start bitrate is the first bitrate of the manifest
        bitrateStart = levels[0].bitrate;
        // sort level on bitrate
        levels.sort(function (a, b) {
          return a.bitrate - b.bitrate;
        });
        this._levels = levels;
        // find index of first level in sorted levels
        for (var i = 0; i < levels.length; i++) {
          if (levels[i].bitrate === bitrateStart) {
            this._firstLevel = i;
            _logger.logger.log('manifest loaded,' + levels.length + ' level(s) found, first bitrate:' + bitrateStart);
            break;
          }
        }
        hls.trigger(_events2.default.MANIFEST_PARSED, { levels: levels, firstLevel: this._firstLevel, stats: data.stats, audio: audioCodecFound, video: videoCodecFound, altAudio: data.audioTracks.length > 0 });
      } else {
        hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.MANIFEST_INCOMPATIBLE_CODECS_ERROR, fatal: true, url: hls.url, reason: 'no level with compatible codecs found in manifest' });
      }
      return;
    }
  }, {
    key: 'setLevelInternal',
    value: function setLevelInternal(newLevel) {
      var levels = this._levels;
      var hls = this.hls;
      // check if level idx is valid
      if (newLevel >= 0 && newLevel < levels.length) {
        // stopping live reloading timer if any
        if (this.timer) {
          clearTimeout(this.timer);
          this.timer = null;
        }
        if (this._level !== newLevel) {
          _logger.logger.log('switching to level ' + newLevel);
          this._level = newLevel;
          var levelProperties = levels[newLevel];
          levelProperties.level = newLevel;
          // LEVEL_SWITCH to be deprecated in next major release
          hls.trigger(_events2.default.LEVEL_SWITCH, levelProperties);
          hls.trigger(_events2.default.LEVEL_SWITCHING, levelProperties);
        }
        var level = levels[newLevel],
            levelDetails = level.details;
        // check if we need to load playlist for this level
        if (!levelDetails || levelDetails.live === true) {
          // level not retrieved yet, or live playlist we need to (re)load it
          var urlId = level.urlId;
          hls.trigger(_events2.default.LEVEL_LOADING, { url: level.url[urlId], level: newLevel, id: urlId });
        }
      } else {
        // invalid level id given, trigger error
        hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.OTHER_ERROR, details: _errors.ErrorDetails.LEVEL_SWITCH_ERROR, level: newLevel, fatal: false, reason: 'invalid level idx' });
      }
    }
  }, {
    key: 'onError',
    value: function onError(data) {
      if (data.fatal) {
        return;
      }

      var details = data.details,
          hls = this.hls,
          levelId = void 0,
          level = void 0,
          levelError = false;
      // try to recover not fatal errors
      switch (details) {
        case _errors.ErrorDetails.FRAG_LOAD_ERROR:
        case _errors.ErrorDetails.FRAG_LOAD_TIMEOUT:
        case _errors.ErrorDetails.FRAG_LOOP_LOADING_ERROR:
        case _errors.ErrorDetails.KEY_LOAD_ERROR:
        case _errors.ErrorDetails.KEY_LOAD_TIMEOUT:
          levelId = data.frag.level;
          break;
        case _errors.ErrorDetails.LEVEL_LOAD_ERROR:
        case _errors.ErrorDetails.LEVEL_LOAD_TIMEOUT:
          levelId = data.context.level;
          levelError = true;
          break;
        case _errors.ErrorDetails.REMUX_ALLOC_ERROR:
          levelId = data.level;
          break;
        default:
          break;
      }
      /* try to switch to a redundant stream if any available.
       * if no redundant stream available, emergency switch down (if in auto mode and current level not 0)
       * otherwise, we cannot recover this network error ...
       */
      if (levelId !== undefined) {
        level = this._levels[levelId];
        if (!level.loadError) {
          level.loadError = 1;
        } else {
          level.loadError++;
        }
        // if any redundant streams available and if we haven't try them all (level.loadError is reseted on successful frag/level load.
        // if level.loadError reaches nbRedundantLevel it means that we tried them all, no hope  => let's switch down
        var nbRedundantLevel = level.url.length;
        if (nbRedundantLevel > 1 && level.loadError < nbRedundantLevel) {
          level.urlId = (level.urlId + 1) % nbRedundantLevel;
          level.details = undefined;
          _logger.logger.warn('level controller,' + details + ' for level ' + levelId + ': switching to redundant stream id ' + level.urlId);
        } else {
          // we could try to recover if in auto mode and current level not lowest level (0)
          var recoverable = this._manualLevel === -1 && levelId;
          if (recoverable) {
            _logger.logger.warn('level controller,' + details + ': switch-down for next fragment');
            hls.nextAutoLevel = Math.max(0, levelId - 1);
          } else if (level && level.details && level.details.live) {
            _logger.logger.warn('level controller,' + details + ' on live stream, discard');
            if (levelError) {
              // reset this._level so that another call to set level() will retrigger a frag load
              this._level = undefined;
            }
            // other errors are handled by stream controller
          } else if (details === _errors.ErrorDetails.LEVEL_LOAD_ERROR || details === _errors.ErrorDetails.LEVEL_LOAD_TIMEOUT) {
            var media = hls.media,

            // 0.5 : tolerance needed as some browsers stalls playback before reaching buffered end
            mediaBuffered = media && _bufferHelper2.default.isBuffered(media, media.currentTime) && _bufferHelper2.default.isBuffered(media, media.currentTime + 0.5);
            if (mediaBuffered) {
              var retryDelay = hls.config.levelLoadingRetryDelay;
              _logger.logger.warn('level controller,' + details + ', but media buffered, retry in ' + retryDelay + 'ms');
              this.timer = setTimeout(this.ontick, retryDelay);
              // boolean used to inform stream controller not to switch back to IDLE on non fatal error
              data.levelRetry = true;
            } else {
              _logger.logger.error('cannot recover ' + details + ' error');
              this._level = undefined;
              // stopping live reloading timer if any
              if (this.timer) {
                clearTimeout(this.timer);
                this.timer = null;
              }
              // switch error to fatal
              data.fatal = true;
            }
          }
        }
      }
    }

    // reset level load error counter on successful frag loaded

  }, {
    key: 'onFragLoaded',
    value: function onFragLoaded(data) {
      var fragLoaded = data.frag;
      if (fragLoaded && fragLoaded.type === 'main') {
        var level = this._levels[fragLoaded.level];
        if (level) {
          level.loadError = 0;
        }
      }
    }
  }, {
    key: 'onLevelLoaded',
    value: function onLevelLoaded(data) {
      var levelId = data.level;
      // only process level loaded events matching with expected level
      if (levelId === this._level) {
        var curLevel = this._levels[levelId];
        // reset level load error counter on successful level loaded
        curLevel.loadError = 0;
        var newDetails = data.details;
        // if current playlist is a live playlist, arm a timer to reload it
        if (newDetails.live) {
          var reloadInterval = 1000 * (newDetails.averagetargetduration ? newDetails.averagetargetduration : newDetails.targetduration),
              curDetails = curLevel.details;
          if (curDetails && newDetails.endSN === curDetails.endSN) {
            // follow HLS Spec, If the client reloads a Playlist file and finds that it has not
            // changed then it MUST wait for a period of one-half the target
            // duration before retrying.
            reloadInterval /= 2;
            _logger.logger.log('same live playlist, reload twice faster');
          }
          // decrement reloadInterval with level loading delay
          reloadInterval -= performance.now() - data.stats.trequest;
          // in any case, don't reload more than every second
          reloadInterval = Math.max(1000, Math.round(reloadInterval));
          _logger.logger.log('live playlist, reload in ' + reloadInterval + ' ms');
          this.timer = setTimeout(this.ontick, reloadInterval);
        } else {
          this.timer = null;
        }
      }
    }
  }, {
    key: 'tick',
    value: function tick() {
      var levelId = this._level;
      if (levelId !== undefined && this.canload) {
        var level = this._levels[levelId];
        if (level && level.url) {
          var urlId = level.urlId;
          this.hls.trigger(_events2.default.LEVEL_LOADING, { url: level.url[urlId], level: levelId, id: urlId });
        }
      }
    }
  }, {
    key: 'levels',
    get: function get() {
      return this._levels;
    }
  }, {
    key: 'level',
    get: function get() {
      return this._level;
    },
    set: function set(newLevel) {
      var levels = this._levels;
      if (levels && levels.length > newLevel) {
        if (this._level !== newLevel || levels[newLevel].details === undefined) {
          this.setLevelInternal(newLevel);
        }
      }
    }
  }, {
    key: 'manualLevel',
    get: function get() {
      return this._manualLevel;
    },
    set: function set(newLevel) {
      this._manualLevel = newLevel;
      if (this._startLevel === undefined) {
        this._startLevel = newLevel;
      }
      if (newLevel !== -1) {
        this.level = newLevel;
      }
    }
  }, {
    key: 'firstLevel',
    get: function get() {
      return this._firstLevel;
    },
    set: function set(newLevel) {
      this._firstLevel = newLevel;
    }
  }, {
    key: 'startLevel',
    get: function get() {
      // hls.startLevel takes precedence over config.startLevel
      // if none of these values are defined, fallback on this._firstLevel (first quality level appearing in variant manifest)
      if (this._startLevel === undefined) {
        var configStartLevel = this.hls.config.startLevel;
        if (configStartLevel !== undefined) {
          return configStartLevel;
        } else {
          return this._firstLevel;
        }
      } else {
        return this._startLevel;
      }
    },
    set: function set(newLevel) {
      this._startLevel = newLevel;
    }
  }, {
    key: 'nextLoadLevel',
    get: function get() {
      if (this._manualLevel !== -1) {
        return this._manualLevel;
      } else {
        return this.hls.nextAutoLevel;
      }
    },
    set: function set(nextLevel) {
      this.level = nextLevel;
      if (this._manualLevel === -1) {
        this.hls.nextAutoLevel = nextLevel;
      }
    }
  }]);

  return LevelController;
}(_eventHandler2.default);

exports.default = LevelController;

},{"../errors":33,"../event-handler":34,"../events":35,"../helper/buffer-helper":37,"../utils/logger":54}],13:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _binarySearch = require('../utils/binary-search');

var _binarySearch2 = _interopRequireDefault(_binarySearch);

var _bufferHelper = require('../helper/buffer-helper');

var _bufferHelper2 = _interopRequireDefault(_bufferHelper);

var _demuxer = require('../demux/demuxer');

var _demuxer2 = _interopRequireDefault(_demuxer);

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _eventHandler = require('../event-handler');

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _levelHelper = require('../helper/level-helper');

var _levelHelper2 = _interopRequireDefault(_levelHelper);

var _timeRanges = require('../utils/timeRanges');

var _timeRanges2 = _interopRequireDefault(_timeRanges);

var _errors = require('../errors');

var _logger = require('../utils/logger');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Stream Controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

var State = {
  STOPPED: 'STOPPED',
  IDLE: 'IDLE',
  KEY_LOADING: 'KEY_LOADING',
  FRAG_LOADING: 'FRAG_LOADING',
  FRAG_LOADING_WAITING_RETRY: 'FRAG_LOADING_WAITING_RETRY',
  WAITING_LEVEL: 'WAITING_LEVEL',
  PARSING: 'PARSING',
  PARSED: 'PARSED',
  BUFFER_FLUSHING: 'BUFFER_FLUSHING',
  ENDED: 'ENDED',
  ERROR: 'ERROR'
};

var StreamController = function (_EventHandler) {
  _inherits(StreamController, _EventHandler);

  function StreamController(hls) {
    _classCallCheck(this, StreamController);

    var _this = _possibleConstructorReturn(this, (StreamController.__proto__ || Object.getPrototypeOf(StreamController)).call(this, hls, _events2.default.MEDIA_ATTACHED, _events2.default.MEDIA_DETACHING, _events2.default.MANIFEST_LOADING, _events2.default.MANIFEST_PARSED, _events2.default.LEVEL_LOADED, _events2.default.KEY_LOADED, _events2.default.FRAG_LOADED, _events2.default.FRAG_LOAD_EMERGENCY_ABORTED, _events2.default.FRAG_PARSING_INIT_SEGMENT, _events2.default.FRAG_PARSING_DATA, _events2.default.FRAG_PARSED, _events2.default.ERROR, _events2.default.AUDIO_TRACK_SWITCHING, _events2.default.AUDIO_TRACK_SWITCHED, _events2.default.BUFFER_CREATED, _events2.default.BUFFER_APPENDED, _events2.default.BUFFER_FLUSHED));

    _this.config = hls.config;
    _this.audioCodecSwap = false;
    _this.ticks = 0;
    _this._state = State.STOPPED;
    _this.ontick = _this.tick.bind(_this);
    return _this;
  }

  _createClass(StreamController, [{
    key: 'destroy',
    value: function destroy() {
      this.stopLoad();
      if (this.timer) {
        clearInterval(this.timer);
        this.timer = null;
      }
      _eventHandler2.default.prototype.destroy.call(this);
      this.state = State.STOPPED;
    }
  }, {
    key: 'startLoad',
    value: function startLoad(startPosition) {
      if (this.levels) {
        var lastCurrentTime = this.lastCurrentTime,
            hls = this.hls;
        this.stopLoad();
        if (!this.timer) {
          this.timer = setInterval(this.ontick, 100);
        }
        this.level = -1;
        this.fragLoadError = 0;
        if (!this.startFragRequested) {
          // determine load level
          var startLevel = hls.startLevel;
          if (startLevel === -1) {
            // -1 : guess start Level by doing a bitrate test by loading first fragment of lowest quality level
            startLevel = 0;
            this.bitrateTest = true;
          }
          // set new level to playlist loader : this will trigger start level load
          // hls.nextLoadLevel remains until it is set to a new value or until a new frag is successfully loaded
          this.level = hls.nextLoadLevel = startLevel;
          this.loadedmetadata = false;
        }
        // if startPosition undefined but lastCurrentTime set, set startPosition to last currentTime
        if (lastCurrentTime > 0 && startPosition === -1) {
          _logger.logger.log('override startPosition with lastCurrentTime @' + lastCurrentTime.toFixed(3));
          startPosition = lastCurrentTime;
        }
        this.state = State.IDLE;
        this.nextLoadPosition = this.startPosition = this.lastCurrentTime = startPosition;
        this.tick();
      } else {
        this.forceStartLoad = true;
        this.state = State.STOPPED;
      }
    }
  }, {
    key: 'stopLoad',
    value: function stopLoad() {
      var frag = this.fragCurrent;
      if (frag) {
        if (frag.loader) {
          frag.loader.abort();
        }
        this.fragCurrent = null;
      }
      this.fragPrevious = null;
      if (this.demuxer) {
        this.demuxer.destroy();
        this.demuxer = null;
      }
      this.state = State.STOPPED;
      this.forceStartLoad = false;
    }
  }, {
    key: 'tick',
    value: function tick() {
      this.ticks++;
      if (this.ticks === 1) {
        this.doTick();
        if (this.ticks > 1) {
          setTimeout(this.tick, 1);
        }
        this.ticks = 0;
      }
    }
  }, {
    key: 'doTick',
    value: function doTick() {
      switch (this.state) {
        case State.ERROR:
          //don't do anything in error state to avoid breaking further ...
          break;
        case State.BUFFER_FLUSHING:
          // in buffer flushing state, reset fragLoadError counter
          this.fragLoadError = 0;
          break;
        case State.IDLE:
          this._doTickIdle();
          break;
        case State.WAITING_LEVEL:
          var level = this.levels[this.level];
          // check if playlist is already loaded
          if (level && level.details) {
            this.state = State.IDLE;
          }
          break;
        case State.FRAG_LOADING_WAITING_RETRY:
          var now = performance.now();
          var retryDate = this.retryDate;
          // if current time is gt than retryDate, or if media seeking let's switch to IDLE state to retry loading
          if (!retryDate || now >= retryDate || this.media && this.media.seeking) {
            _logger.logger.log('mediaController: retryDate reached, switch back to IDLE state');
            this.state = State.IDLE;
          }
          break;
        case State.ERROR:
        case State.STOPPED:
        case State.FRAG_LOADING:
        case State.PARSING:
        case State.PARSED:
        case State.ENDED:
          break;
        default:
          break;
      }
      // check buffer
      this._checkBuffer();
      // check/update current fragment
      this._checkFragmentChanged();
    }

    // Ironically the "idle" state is the on we do the most logic in it seems ....
    // NOTE: Maybe we could rather schedule a check for buffer length after half of the currently
    //       played segment, or on pause/play/seek instead of naively checking every 100ms?

  }, {
    key: '_doTickIdle',
    value: function _doTickIdle() {
      var hls = this.hls,
          config = hls.config,
          media = this.media;

      // if video not attached AND
      // start fragment already requested OR start frag prefetch disable
      // exit loop
      // => if start level loaded and media not attached but start frag prefetch is enabled and start frag not requested yet, we will not exit loop
      if (this.levelLastLoaded !== undefined && !media && (this.startFragRequested || !config.startFragPrefetch)) {
        return;
      }

      // if we have not yet loaded any fragment, start loading from start position
      var pos = void 0;
      if (this.loadedmetadata) {
        pos = media.currentTime;
      } else {
        pos = this.nextLoadPosition;
      }
      // determine next load level
      var level = hls.nextLoadLevel,
          levelInfo = this.levels[level];

      if (!levelInfo) {
        return;
      }

      var levelBitrate = levelInfo.bitrate,
          maxBufLen = void 0;

      // compute max Buffer Length that we could get from this load level, based on level bitrate. don't buffer more than 60 MB and more than 30s
      if (levelBitrate) {
        maxBufLen = Math.max(8 * config.maxBufferSize / levelBitrate, config.maxBufferLength);
      } else {
        maxBufLen = config.maxBufferLength;
      }
      maxBufLen = Math.min(maxBufLen, config.maxMaxBufferLength);

      // determine next candidate fragment to be loaded, based on current position and end of buffer position
      // ensure up to `config.maxMaxBufferLength` of buffer upfront

      var bufferInfo = _bufferHelper2.default.bufferInfo(this.mediaBuffer ? this.mediaBuffer : media, pos, config.maxBufferHole),
          bufferLen = bufferInfo.len;
      // Stay idle if we are still with buffer margins
      if (bufferLen >= maxBufLen) {
        return;
      }

      // if buffer length is less than maxBufLen try to load a new fragment ...
      _logger.logger.trace('buffer length of ' + bufferLen.toFixed(3) + ' is below max of ' + maxBufLen.toFixed(3) + '. checking for more payload ...');

      // set next load level : this will trigger a playlist load if needed
      this.level = hls.nextLoadLevel = level;

      var levelDetails = levelInfo.details;
      // if level info not retrieved yet, switch state and wait for level retrieval
      // if live playlist, ensure that new playlist has been refreshed to avoid loading/try to load
      // a useless and outdated fragment (that might even introduce load error if it is already out of the live playlist)
      if (typeof levelDetails === 'undefined' || levelDetails.live && this.levelLastLoaded !== level) {
        this.state = State.WAITING_LEVEL;
        return;
      }

      // we just got done loading the final fragment, and currentPos is buffered, and there is no other buffered range after ...
      // rationale is that in case there are any buffered rangesafter, it means that there are unbuffered portion in between
      // so we should not switch to ENDED in that case, to be able to buffer themx
      var fragPrevious = this.fragPrevious;
      if (!levelDetails.live && fragPrevious && fragPrevious.sn === levelDetails.endSN && bufferLen && !bufferInfo.nextStart) {
        // fragPrevious is last fragment. retrieve level duration using last frag start offset + duration
        // real duration might be lower than initial duration if there are drifts between real frag duration and playlist signaling
        var duration = Math.min(media.duration, fragPrevious.start + fragPrevious.duration);
        // if everything (almost) til the end is buffered, let's signal eos
        // we don't compare exactly media.duration === bufferInfo.end as there could be some subtle media duration difference (audio/video offsets...)
        // tolerate up to one frag duration to cope with these cases.
        // also cope with almost zero last frag duration (max last frag duration with 200ms) refer to https://github.com/video-dev/hls.js/pull/657
        if (duration - Math.max(bufferInfo.end, fragPrevious.start) <= Math.max(0.2, fragPrevious.duration)) {
          // Finalize the media stream
          var data = {};
          if (this.altAudio) {
            data.type = 'video';
          }
          this.hls.trigger(_events2.default.BUFFER_EOS, data);
          this.state = State.ENDED;
          return;
        }
      }

      // if we have the levelDetails for the selected variant, lets continue enrichen our stream (load keys/fragments or trigger EOS, etc..)
      this._fetchPayloadOrEos(pos, bufferInfo, levelDetails);
    }
  }, {
    key: '_fetchPayloadOrEos',
    value: function _fetchPayloadOrEos(pos, bufferInfo, levelDetails) {
      var fragPrevious = this.fragPrevious,
          level = this.level,
          fragments = levelDetails.fragments,
          fragLen = fragments.length;

      // empty playlist
      if (fragLen === 0) {
        return;
      }

      // find fragment index, contiguous with end of buffer position
      var start = fragments[0].start,
          end = fragments[fragLen - 1].start + fragments[fragLen - 1].duration,
          bufferEnd = bufferInfo.end,
          frag = void 0;

      if (levelDetails.initSegment && !levelDetails.initSegment.data) {
        frag = levelDetails.initSegment;
      } else {
        // in case of live playlist we need to ensure that requested position is not located before playlist start
        if (levelDetails.live) {
          var initialLiveManifestSize = this.config.initialLiveManifestSize;
          if (fragLen < initialLiveManifestSize) {
            _logger.logger.warn('Can not start playback of a level, reason: not enough fragments ' + fragLen + ' < ' + initialLiveManifestSize);
            return;
          }

          frag = this._ensureFragmentAtLivePoint(levelDetails, bufferEnd, start, end, fragPrevious, fragments, fragLen);
          // if it explicitely returns null don't load any fragment and exit function now
          if (frag === null) {
            return;
          }
        } else {
          // VoD playlist: if bufferEnd before start of playlist, load first fragment
          if (bufferEnd < start) {
            frag = fragments[0];
          }
        }
      }
      if (!frag) {
        frag = this._findFragment(start, fragPrevious, fragLen, fragments, bufferEnd, end, levelDetails);
      }
      if (frag) {
        this._loadFragmentOrKey(frag, level, levelDetails, pos, bufferEnd);
      }
      return;
    }
  }, {
    key: '_ensureFragmentAtLivePoint',
    value: function _ensureFragmentAtLivePoint(levelDetails, bufferEnd, start, end, fragPrevious, fragments, fragLen) {
      var config = this.hls.config,
          media = this.media;

      var frag = void 0;

      // check if requested position is within seekable boundaries :
      //logger.log(`start/pos/bufEnd/seeking:${start.toFixed(3)}/${pos.toFixed(3)}/${bufferEnd.toFixed(3)}/${this.media.seeking}`);
      var maxLatency = config.liveMaxLatencyDuration !== undefined ? config.liveMaxLatencyDuration : config.liveMaxLatencyDurationCount * levelDetails.targetduration;

      if (bufferEnd < Math.max(start - config.maxFragLookUpTolerance, end - maxLatency)) {
        var liveSyncPosition = this.liveSyncPosition = this.computeLivePosition(start, levelDetails);
        _logger.logger.log('buffer end: ' + bufferEnd.toFixed(3) + ' is located too far from the end of live sliding playlist, reset currentTime to : ' + liveSyncPosition.toFixed(3));
        bufferEnd = liveSyncPosition;
        if (media && media.readyState && media.duration > liveSyncPosition) {
          media.currentTime = liveSyncPosition;
        }
        this.nextLoadPosition = liveSyncPosition;
      }

      // if end of buffer greater than live edge, don't load any fragment
      // this could happen if live playlist intermittently slides in the past.
      // level 1 loaded [182580161,182580167]
      // level 1 loaded [182580162,182580169]
      // Loading 182580168 of [182580162 ,182580169],level 1 ..
      // Loading 182580169 of [182580162 ,182580169],level 1 ..
      // level 1 loaded [182580162,182580168] <============= here we should have bufferEnd > end. in that case break to avoid reloading 182580168
      // level 1 loaded [182580164,182580171]
      //
      // don't return null in case media not loaded yet (readystate === 0)
      if (levelDetails.PTSKnown && bufferEnd > end && media && media.readyState) {
        return null;
      }

      if (this.startFragRequested && !levelDetails.PTSKnown) {
        /* we are switching level on live playlist, but we don't have any PTS info for that quality level ...
           try to load frag matching with next SN.
           even if SN are not synchronized between playlists, loading this frag will help us
           compute playlist sliding and find the right one after in case it was not the right consecutive one */
        if (fragPrevious) {
          var targetSN = fragPrevious.sn + 1;
          if (targetSN >= levelDetails.startSN && targetSN <= levelDetails.endSN) {
            frag = fragments[targetSN - levelDetails.startSN];
            _logger.logger.log('live playlist, switching playlist, load frag with next SN: ' + frag.sn);
          }
        }
        if (!frag) {
          /* we have no idea about which fragment should be loaded.
             so let's load mid fragment. it will help computing playlist sliding and find the right one
          */
          frag = fragments[Math.min(fragLen - 1, Math.round(fragLen / 2))];
          _logger.logger.log('live playlist, switching playlist, unknown, load middle frag : ' + frag.sn);
        }
      }
      return frag;
    }
  }, {
    key: '_findFragment',
    value: function _findFragment(start, fragPrevious, fragLen, fragments, bufferEnd, end, levelDetails) {
      var config = this.hls.config;
      var frag = void 0;
      var foundFrag = void 0;
      var maxFragLookUpTolerance = config.maxFragLookUpTolerance;
      var fragNext = fragPrevious ? fragments[fragPrevious.sn - fragments[0].sn + 1] : undefined;
      var fragmentWithinToleranceTest = function fragmentWithinToleranceTest(candidate) {
        // offset should be within fragment boundary - config.maxFragLookUpTolerance
        // this is to cope with situations like
        // bufferEnd = 9.991
        // frag[] : [0,10]
        // frag[1] : [10,20]
        // bufferEnd is within frag[0] range ... although what we are expecting is to return frag[1] here
        //              frag start               frag start+duration
        //                  |-----------------------------|
        //              <--->                         <--->
        //  ...--------><-----------------------------><---------....
        // previous frag         matching fragment         next frag
        //  return -1             return 0                 return 1
        //logger.log(`level/sn/start/end/bufEnd:${level}/${candidate.sn}/${candidate.start}/${(candidate.start+candidate.duration)}/${bufferEnd}`);
        // Set the lookup tolerance to be small enough to detect the current segment - ensures we don't skip over very small segments
        var candidateLookupTolerance = Math.min(maxFragLookUpTolerance, candidate.duration);
        if (candidate.start + candidate.duration - candidateLookupTolerance <= bufferEnd) {
          return 1;
        } // if maxFragLookUpTolerance will have negative value then don't return -1 for first element
        else if (candidate.start - candidateLookupTolerance > bufferEnd && candidate.start) {
            return -1;
          }
        return 0;
      };

      if (bufferEnd < end) {
        if (bufferEnd > end - maxFragLookUpTolerance) {
          maxFragLookUpTolerance = 0;
        }
        // Prefer the next fragment if it's within tolerance
        if (fragNext && !fragmentWithinToleranceTest(fragNext)) {
          foundFrag = fragNext;
        } else {
          foundFrag = _binarySearch2.default.search(fragments, fragmentWithinToleranceTest);
        }
      } else {
        // reach end of playlist
        foundFrag = fragments[fragLen - 1];
      }
      if (foundFrag) {
        frag = foundFrag;
        var curSNIdx = frag.sn - levelDetails.startSN;
        var sameLevel = fragPrevious && frag.level === fragPrevious.level;
        var prevFrag = fragments[curSNIdx - 1];
        var nextFrag = fragments[curSNIdx + 1];
        //logger.log('find SN matching with pos:' +  bufferEnd + ':' + frag.sn);
        if (fragPrevious && frag.sn === fragPrevious.sn) {
          if (sameLevel && !frag.backtracked) {
            if (frag.sn < levelDetails.endSN) {
              var deltaPTS = fragPrevious.deltaPTS;
              // if there is a significant delta between audio and video, larger than max allowed hole,
              // and if previous remuxed fragment did not start with a keyframe. (fragPrevious.dropped)
              // let's try to load previous fragment again to get last keyframe
              // then we will reload again current fragment (that way we should be able to fill the buffer hole ...)
              if (deltaPTS && deltaPTS > config.maxBufferHole && fragPrevious.dropped && curSNIdx) {
                frag = prevFrag;
                _logger.logger.warn('SN just loaded, with large PTS gap between audio and video, maybe frag is not starting with a keyframe ? load previous one to try to overcome this');
                // decrement previous frag load counter to avoid frag loop loading error when next fragment will get reloaded
                fragPrevious.loadCounter--;
              } else {
                frag = nextFrag;
                _logger.logger.log('SN just loaded, load next one: ' + frag.sn);
              }
            } else {
              frag = null;
            }
          } else if (frag.backtracked) {
            // Only backtrack a max of 1 consecutive fragment to prevent sliding back too far when little or no frags start with keyframes
            if (nextFrag && nextFrag.backtracked) {
              _logger.logger.warn('Already backtracked from fragment ' + nextFrag.sn + ', will not backtrack to fragment ' + frag.sn + '. Loading fragment ' + nextFrag.sn);
              frag = nextFrag;
            } else {
              // If a fragment has dropped frames and it's in a same level/sequence, load the previous fragment to try and find the keyframe
              // Reset the dropped count now since it won't be reset until we parse the fragment again, which prevents infinite backtracking on the same segment
              _logger.logger.warn('Loaded fragment with dropped frames, backtracking 1 segment to find a keyframe');
              frag.dropped = 0;
              if (prevFrag) {
                if (prevFrag.loadCounter) {
                  prevFrag.loadCounter--;
                }
                frag = prevFrag;
                frag.backtracked = true;
              } else if (curSNIdx) {
                // can't backtrack on very first fragment
                frag = null;
              }
            }
          }
        }
      }
      return frag;
    }
  }, {
    key: '_loadFragmentOrKey',
    value: function _loadFragmentOrKey(frag, level, levelDetails, pos, bufferEnd) {
      var hls = this.hls,
          config = hls.config;

      //logger.log('loading frag ' + i +',pos/bufEnd:' + pos.toFixed(3) + '/' + bufferEnd.toFixed(3));
      if (frag.decryptdata && frag.decryptdata.uri != null && frag.decryptdata.key == null) {
        _logger.logger.log('Loading key for ' + frag.sn + ' of [' + levelDetails.startSN + ' ,' + levelDetails.endSN + '],level ' + level);
        this.state = State.KEY_LOADING;
        hls.trigger(_events2.default.KEY_LOADING, { frag: frag });
      } else {
        _logger.logger.log('Loading ' + frag.sn + ' of [' + levelDetails.startSN + ' ,' + levelDetails.endSN + '],level ' + level + ', currentTime:' + pos.toFixed(3) + ',bufferEnd:' + bufferEnd.toFixed(3));
        // ensure that we are not reloading the same fragments in loop ...
        if (this.fragLoadIdx !== undefined) {
          this.fragLoadIdx++;
        } else {
          this.fragLoadIdx = 0;
        }
        if (frag.loadCounter) {
          frag.loadCounter++;
          var maxThreshold = config.fragLoadingLoopThreshold;
          // if this frag has already been loaded 3 times, and if it has been reloaded recently
          if (frag.loadCounter > maxThreshold && Math.abs(this.fragLoadIdx - frag.loadIdx) < maxThreshold) {
            hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.FRAG_LOOP_LOADING_ERROR, fatal: false, frag: frag });
            return;
          }
        } else {
          frag.loadCounter = 1;
        }
        frag.loadIdx = this.fragLoadIdx;
        this.fragCurrent = frag;
        this.startFragRequested = true;
        if (!isNaN(frag.sn)) {
          this.nextLoadPosition = frag.start + frag.duration;
        }
        frag.autoLevel = hls.autoLevelEnabled;
        frag.bitrateTest = this.bitrateTest;
        hls.trigger(_events2.default.FRAG_LOADING, { frag: frag });
        // lazy demuxer init, as this could take some time ... do it during frag loading
        if (!this.demuxer) {
          this.demuxer = new _demuxer2.default(hls, 'main');
        }
        this.state = State.FRAG_LOADING;
        return;
      }
    }
  }, {
    key: 'getBufferedFrag',
    value: function getBufferedFrag(position) {
      return _binarySearch2.default.search(this._bufferedFrags, function (frag) {
        if (position < frag.startPTS) {
          return -1;
        } else if (position > frag.endPTS) {
          return 1;
        }
        return 0;
      });
    }
  }, {
    key: 'followingBufferedFrag',
    value: function followingBufferedFrag(frag) {
      if (frag) {
        // try to get range of next fragment (500ms after this range)
        return this.getBufferedFrag(frag.endPTS + 0.5);
      }
      return null;
    }
  }, {
    key: '_checkFragmentChanged',
    value: function _checkFragmentChanged() {
      var fragPlayingCurrent,
          currentTime,
          video = this.media;
      if (video && video.readyState && video.seeking === false) {
        currentTime = video.currentTime;
        /* if video element is in seeked state, currentTime can only increase.
          (assuming that playback rate is positive ...)
          As sometimes currentTime jumps back to zero after a
          media decode error, check this, to avoid seeking back to
          wrong position after a media decode error
        */
        if (currentTime > video.playbackRate * this.lastCurrentTime) {
          this.lastCurrentTime = currentTime;
        }
        if (_bufferHelper2.default.isBuffered(video, currentTime)) {
          fragPlayingCurrent = this.getBufferedFrag(currentTime);
        } else if (_bufferHelper2.default.isBuffered(video, currentTime + 0.1)) {
          /* ensure that FRAG_CHANGED event is triggered at startup,
            when first video frame is displayed and playback is paused.
            add a tolerance of 100ms, in case current position is not buffered,
            check if current pos+100ms is buffered and use that buffer range
            for FRAG_CHANGED event reporting */
          fragPlayingCurrent = this.getBufferedFrag(currentTime + 0.1);
        }
        if (fragPlayingCurrent) {
          var fragPlaying = fragPlayingCurrent;
          if (fragPlaying !== this.fragPlaying) {
            this.hls.trigger(_events2.default.FRAG_CHANGED, { frag: fragPlaying });
            var fragPlayingLevel = fragPlaying.level;
            if (!this.fragPlaying || this.fragPlaying.level !== fragPlayingLevel) {
              this.hls.trigger(_events2.default.LEVEL_SWITCHED, { level: fragPlayingLevel });
            }
            this.fragPlaying = fragPlaying;
          }
        }
      }
    }

    /*
      on immediate level switch :
       - pause playback if playing
       - cancel any pending load request
       - and trigger a buffer flush
    */

  }, {
    key: 'immediateLevelSwitch',
    value: function immediateLevelSwitch() {
      _logger.logger.log('immediateLevelSwitch');
      if (!this.immediateSwitch) {
        this.immediateSwitch = true;
        var media = this.media,
            previouslyPaused = void 0;
        if (media) {
          previouslyPaused = media.paused;
          media.pause();
        } else {
          // don't restart playback after instant level switch in case media not attached
          previouslyPaused = true;
        }
        this.previouslyPaused = previouslyPaused;
      }
      var fragCurrent = this.fragCurrent;
      if (fragCurrent && fragCurrent.loader) {
        fragCurrent.loader.abort();
      }
      this.fragCurrent = null;
      // increase fragment load Index to avoid frag loop loading error after buffer flush
      this.fragLoadIdx += 2 * this.config.fragLoadingLoopThreshold;
      // flush everything
      this.flushMainBuffer(0, Number.POSITIVE_INFINITY);
    }

    /*
       on immediate level switch end, after new fragment has been buffered :
        - nudge video decoder by slightly adjusting video currentTime (if currentTime buffered)
        - resume the playback if needed
    */

  }, {
    key: 'immediateLevelSwitchEnd',
    value: function immediateLevelSwitchEnd() {
      var media = this.media;
      if (media && media.buffered.length) {
        this.immediateSwitch = false;
        if (_bufferHelper2.default.isBuffered(media, media.currentTime)) {
          // only nudge if currentTime is buffered
          media.currentTime -= 0.0001;
        }
        if (!this.previouslyPaused) {
          media.play();
        }
      }
    }
  }, {
    key: 'nextLevelSwitch',
    value: function nextLevelSwitch() {
      /* try to switch ASAP without breaking video playback :
         in order to ensure smooth but quick level switching,
        we need to find the next flushable buffer range
        we should take into account new segment fetch time
      */
      var media = this.media;
      // ensure that media is defined and that metadata are available (to retrieve currentTime)
      if (media && media.readyState) {
        var fetchdelay = void 0,
            fragPlayingCurrent = void 0,
            nextBufferedFrag = void 0;
        // increase fragment load Index to avoid frag loop loading error after buffer flush
        this.fragLoadIdx += 2 * this.config.fragLoadingLoopThreshold;
        fragPlayingCurrent = this.getBufferedFrag(media.currentTime);
        if (fragPlayingCurrent && fragPlayingCurrent.startPTS > 1) {
          // flush buffer preceding current fragment (flush until current fragment start offset)
          // minus 1s to avoid video freezing, that could happen if we flush keyframe of current video ...
          this.flushMainBuffer(0, fragPlayingCurrent.startPTS - 1);
        }
        if (!media.paused) {
          // add a safety delay of 1s
          var nextLevelId = this.hls.nextLoadLevel,
              nextLevel = this.levels[nextLevelId],
              fragLastKbps = this.fragLastKbps;
          if (fragLastKbps && this.fragCurrent) {
            fetchdelay = this.fragCurrent.duration * nextLevel.bitrate / (1000 * fragLastKbps) + 1;
          } else {
            fetchdelay = 0;
          }
        } else {
          fetchdelay = 0;
        }
        //logger.log('fetchdelay:'+fetchdelay);
        // find buffer range that will be reached once new fragment will be fetched
        nextBufferedFrag = this.getBufferedFrag(media.currentTime + fetchdelay);
        if (nextBufferedFrag) {
          // we can flush buffer range following this one without stalling playback
          nextBufferedFrag = this.followingBufferedFrag(nextBufferedFrag);
          if (nextBufferedFrag) {
            // if we are here, we can also cancel any loading/demuxing in progress, as they are useless
            var fragCurrent = this.fragCurrent;
            if (fragCurrent && fragCurrent.loader) {
              fragCurrent.loader.abort();
            }
            this.fragCurrent = null;
            // start flush position is the start PTS of next buffered frag.
            // we use frag.naxStartPTS which is max(audio startPTS, video startPTS).
            // in case there is a small PTS Delta between audio and video, using maxStartPTS avoids flushing last samples from current fragment
            this.flushMainBuffer(nextBufferedFrag.maxStartPTS, Number.POSITIVE_INFINITY);
          }
        }
      }
    }
  }, {
    key: 'flushMainBuffer',
    value: function flushMainBuffer(startOffset, endOffset) {
      this.state = State.BUFFER_FLUSHING;
      var flushScope = { startOffset: startOffset, endOffset: endOffset };
      // if alternate audio tracks are used, only flush video, otherwise flush everything
      if (this.altAudio) {
        flushScope.type = 'video';
      }
      this.hls.trigger(_events2.default.BUFFER_FLUSHING, flushScope);
    }
  }, {
    key: 'onMediaAttached',
    value: function onMediaAttached(data) {
      var media = this.media = this.mediaBuffer = data.media;
      this.onvseeking = this.onMediaSeeking.bind(this);
      this.onvseeked = this.onMediaSeeked.bind(this);
      this.onvended = this.onMediaEnded.bind(this);
      media.addEventListener('seeking', this.onvseeking);
      media.addEventListener('seeked', this.onvseeked);
      media.addEventListener('ended', this.onvended);
      var config = this.config;
      if (this.levels && config.autoStartLoad) {
        this.hls.startLoad(config.startPosition);
      }
    }
  }, {
    key: 'onMediaDetaching',
    value: function onMediaDetaching() {
      var media = this.media;
      if (media && media.ended) {
        _logger.logger.log('MSE detaching and video ended, reset startPosition');
        this.startPosition = this.lastCurrentTime = 0;
      }

      // reset fragment loading counter on MSE detaching to avoid reporting FRAG_LOOP_LOADING_ERROR after error recovery
      var levels = this.levels;
      if (levels) {
        // reset fragment load counter
        levels.forEach(function (level) {
          if (level.details) {
            level.details.fragments.forEach(function (fragment) {
              fragment.loadCounter = undefined;
              fragment.backtracked = undefined;
            });
          }
        });
      }
      // remove video listeners
      if (media) {
        media.removeEventListener('seeking', this.onvseeking);
        media.removeEventListener('seeked', this.onvseeked);
        media.removeEventListener('ended', this.onvended);
        this.onvseeking = this.onvseeked = this.onvended = null;
      }
      this.media = this.mediaBuffer = null;
      this.loadedmetadata = false;
      this.stopLoad();
    }
  }, {
    key: 'onMediaSeeking',
    value: function onMediaSeeking() {
      var media = this.media,
          currentTime = media ? media.currentTime : undefined,
          config = this.config;
      if (!isNaN(currentTime)) {
        _logger.logger.log('media seeking to ' + currentTime.toFixed(3));
      }
      var mediaBuffer = this.mediaBuffer ? this.mediaBuffer : media;
      var bufferInfo = _bufferHelper2.default.bufferInfo(mediaBuffer, currentTime, this.config.maxBufferHole);
      if (this.state === State.FRAG_LOADING) {
        var fragCurrent = this.fragCurrent;
        // check if we are seeking to a unbuffered area AND if frag loading is in progress
        if (bufferInfo.len === 0 && fragCurrent) {
          var tolerance = config.maxFragLookUpTolerance,
              fragStartOffset = fragCurrent.start - tolerance,
              fragEndOffset = fragCurrent.start + fragCurrent.duration + tolerance;
          // check if we seek position will be out of currently loaded frag range : if out cancel frag load, if in, don't do anything
          if (currentTime < fragStartOffset || currentTime > fragEndOffset) {
            if (fragCurrent.loader) {
              _logger.logger.log('seeking outside of buffer while fragment load in progress, cancel fragment load');
              fragCurrent.loader.abort();
            }
            this.fragCurrent = null;
            this.fragPrevious = null;
            // switch to IDLE state to load new fragment
            this.state = State.IDLE;
          } else {
            _logger.logger.log('seeking outside of buffer but within currently loaded fragment range');
          }
        }
      } else if (this.state === State.ENDED) {
        // if seeking to unbuffered area, clean up fragPrevious
        if (bufferInfo.len === 0) {
          this.fragPrevious = 0;
        }
        // switch to IDLE state to check for potential new fragment
        this.state = State.IDLE;
      }
      if (media) {
        this.lastCurrentTime = currentTime;
      }
      // avoid reporting fragment loop loading error in case user is seeking several times on same position
      if (this.state !== State.FRAG_LOADING && this.fragLoadIdx !== undefined) {
        this.fragLoadIdx += 2 * config.fragLoadingLoopThreshold;
      }
      // in case seeking occurs although no media buffered, adjust startPosition and nextLoadPosition to seek target
      if (!this.loadedmetadata) {
        this.nextLoadPosition = this.startPosition = currentTime;
      }
      // tick to speed up processing
      this.tick();
    }
  }, {
    key: 'onMediaSeeked',
    value: function onMediaSeeked() {
      var media = this.media,
          currentTime = media ? media.currentTime : undefined;
      if (!isNaN(currentTime)) {
        _logger.logger.log('media seeked to ' + currentTime.toFixed(3));
      }
      // tick to speed up FRAGMENT_PLAYING triggering
      this.tick();
    }
  }, {
    key: 'onMediaEnded',
    value: function onMediaEnded() {
      _logger.logger.log('media ended');
      // reset startPosition and lastCurrentTime to restart playback @ stream beginning
      this.startPosition = this.lastCurrentTime = 0;
    }
  }, {
    key: 'onManifestLoading',
    value: function onManifestLoading() {
      // reset buffer on manifest loading
      _logger.logger.log('trigger BUFFER_RESET');
      this.hls.trigger(_events2.default.BUFFER_RESET);
      this._bufferedFrags = [];
      this.stalled = false;
      this.startPosition = this.lastCurrentTime = 0;
    }
  }, {
    key: 'onManifestParsed',
    value: function onManifestParsed(data) {
      var aac = false,
          heaac = false,
          codec;
      data.levels.forEach(function (level) {
        // detect if we have different kind of audio codecs used amongst playlists
        codec = level.audioCodec;
        if (codec) {
          if (codec.indexOf('mp4a.40.2') !== -1) {
            aac = true;
          }
          if (codec.indexOf('mp4a.40.5') !== -1) {
            heaac = true;
          }
        }
      });
      this.audioCodecSwitch = aac && heaac;
      if (this.audioCodecSwitch) {
        _logger.logger.log('both AAC/HE-AAC audio found in levels; declaring level codec as HE-AAC');
      }
      this.levels = data.levels;
      this.startLevelLoaded = false;
      this.startFragRequested = false;
      var config = this.config;
      if (config.autoStartLoad || this.forceStartLoad) {
        this.hls.startLoad(config.startPosition);
      }
    }
  }, {
    key: 'onLevelLoaded',
    value: function onLevelLoaded(data) {
      var newDetails = data.details,
          newLevelId = data.level,
          curLevel = this.levels[newLevelId],
          duration = newDetails.totalduration,
          sliding = 0;

      _logger.logger.log('level ' + newLevelId + ' loaded [' + newDetails.startSN + ',' + newDetails.endSN + '],duration:' + duration);
      this.levelLastLoaded = newLevelId;

      if (newDetails.live) {
        var curDetails = curLevel.details;
        if (curDetails && newDetails.fragments.length > 0) {
          // we already have details for that level, merge them
          _levelHelper2.default.mergeDetails(curDetails, newDetails);
          sliding = newDetails.fragments[0].start;
          this.liveSyncPosition = this.computeLivePosition(sliding, curDetails);
          if (newDetails.PTSKnown) {
            _logger.logger.log('live playlist sliding:' + sliding.toFixed(3));
          } else {
            _logger.logger.log('live playlist - outdated PTS, unknown sliding');
          }
        } else {
          newDetails.PTSKnown = false;
          _logger.logger.log('live playlist - first load, unknown sliding');
        }
      } else {
        newDetails.PTSKnown = false;
      }
      // override level info
      curLevel.details = newDetails;
      this.hls.trigger(_events2.default.LEVEL_UPDATED, { details: newDetails, level: newLevelId });

      if (this.startFragRequested === false) {
        // compute start position if set to -1. use it straight away if value is defined
        if (this.startPosition === -1 || this.lastCurrentTime === -1) {
          // first, check if start time offset has been set in playlist, if yes, use this value
          var startTimeOffset = newDetails.startTimeOffset;
          if (!isNaN(startTimeOffset)) {
            if (startTimeOffset < 0) {
              _logger.logger.log('negative start time offset ' + startTimeOffset + ', count from end of last fragment');
              startTimeOffset = sliding + duration + startTimeOffset;
            }
            _logger.logger.log('start time offset found in playlist, adjust startPosition to ' + startTimeOffset);
            this.startPosition = startTimeOffset;
          } else {
            // if live playlist, set start position to be fragment N-this.config.liveSyncDurationCount (usually 3)
            if (newDetails.live) {
              this.startPosition = this.computeLivePosition(sliding, newDetails);
              _logger.logger.log('configure startPosition to ' + this.startPosition);
            } else {
              this.startPosition = 0;
            }
          }
          this.lastCurrentTime = this.startPosition;
        }
        this.nextLoadPosition = this.startPosition;
      }
      // only switch batck to IDLE state if we were waiting for level to start downloading a new fragment
      if (this.state === State.WAITING_LEVEL) {
        this.state = State.IDLE;
      }
      //trigger handler right now
      this.tick();
    }
  }, {
    key: 'onKeyLoaded',
    value: function onKeyLoaded() {
      if (this.state === State.KEY_LOADING) {
        this.state = State.IDLE;
        this.tick();
      }
    }
  }, {
    key: 'onFragLoaded',
    value: function onFragLoaded(data) {
      var fragCurrent = this.fragCurrent,
          fragLoaded = data.frag;
      if (this.state === State.FRAG_LOADING && fragCurrent && fragLoaded.type === 'main' && fragLoaded.level === fragCurrent.level && fragLoaded.sn === fragCurrent.sn) {
        var stats = data.stats,
            currentLevel = this.levels[fragCurrent.level],
            details = currentLevel.details;
        _logger.logger.log('Loaded  ' + fragCurrent.sn + ' of [' + details.startSN + ' ,' + details.endSN + '],level ' + fragCurrent.level);
        // reset frag bitrate test in any case after frag loaded event
        this.bitrateTest = false;
        this.stats = stats;
        // if this frag was loaded to perform a bitrate test AND if hls.nextLoadLevel is greater than 0
        // then this means that we should be able to load a fragment at a higher quality level
        if (fragLoaded.bitrateTest === true && this.hls.nextLoadLevel) {
          // switch back to IDLE state ... we just loaded a fragment to determine adequate start bitrate and initialize autoswitch algo
          this.state = State.IDLE;
          this.startFragRequested = false;
          stats.tparsed = stats.tbuffered = performance.now();
          this.hls.trigger(_events2.default.FRAG_BUFFERED, { stats: stats, frag: fragCurrent, id: 'main' });
          this.tick();
        } else if (fragLoaded.sn === 'initSegment') {
          this.state = State.IDLE;
          stats.tparsed = stats.tbuffered = performance.now();
          details.initSegment.data = data.payload;
          this.hls.trigger(_events2.default.FRAG_BUFFERED, { stats: stats, frag: fragCurrent, id: 'main' });
          this.tick();
        } else {
          this.state = State.PARSING;
          // transmux the MPEG-TS data to ISO-BMFF segments
          var duration = details.totalduration,
              level = fragCurrent.level,
              sn = fragCurrent.sn,
              audioCodec = this.config.defaultAudioCodec || currentLevel.audioCodec;
          if (this.audioCodecSwap) {
            _logger.logger.log('swapping playlist audio codec');
            if (audioCodec === undefined) {
              audioCodec = this.lastAudioCodec;
            }
            if (audioCodec) {
              if (audioCodec.indexOf('mp4a.40.5') !== -1) {
                audioCodec = 'mp4a.40.2';
              } else {
                audioCodec = 'mp4a.40.5';
              }
            }
          }
          this.pendingBuffering = true;
          this.appended = false;
          _logger.logger.log('Parsing ' + sn + ' of [' + details.startSN + ' ,' + details.endSN + '],level ' + level + ', cc ' + fragCurrent.cc);
          var demuxer = this.demuxer;
          if (!demuxer) {
            demuxer = this.demuxer = new _demuxer2.default(this.hls, 'main');
          }
          // time Offset is accurate if level PTS is known, or if playlist is not sliding (not live) and if media is not seeking (this is to overcome potential timestamp drifts between playlists and fragments)
          var media = this.media;
          var mediaSeeking = media && media.seeking;
          var accurateTimeOffset = !mediaSeeking && (details.PTSKnown || !details.live);
          var initSegmentData = details.initSegment ? details.initSegment.data : [];
          demuxer.push(data.payload, initSegmentData, audioCodec, currentLevel.videoCodec, fragCurrent, duration, accurateTimeOffset, undefined);
        }
      }
      this.fragLoadError = 0;
    }
  }, {
    key: 'onFragParsingInitSegment',
    value: function onFragParsingInitSegment(data) {
      var fragCurrent = this.fragCurrent;
      var fragNew = data.frag;
      if (fragCurrent && data.id === 'main' && fragNew.sn === fragCurrent.sn && fragNew.level === fragCurrent.level && this.state === State.PARSING) {
        var tracks = data.tracks,
            trackName,
            track;

        // if audio track is expected to come from audio stream controller, discard any coming from main
        if (tracks.audio && this.altAudio) {
          delete tracks.audio;
        }
        // include levelCodec in audio and video tracks
        track = tracks.audio;
        if (track) {
          var audioCodec = this.levels[this.level].audioCodec,
              ua = navigator.userAgent.toLowerCase();
          if (audioCodec && this.audioCodecSwap) {
            _logger.logger.log('swapping playlist audio codec');
            if (audioCodec.indexOf('mp4a.40.5') !== -1) {
              audioCodec = 'mp4a.40.2';
            } else {
              audioCodec = 'mp4a.40.5';
            }
          }
          // in case AAC and HE-AAC audio codecs are signalled in manifest
          // force HE-AAC , as it seems that most browsers prefers that way,
          // except for mono streams OR on FF
          // these conditions might need to be reviewed ...
          if (this.audioCodecSwitch) {
            // don't force HE-AAC if mono stream
            if (track.metadata.channelCount !== 1 &&
            // don't force HE-AAC if firefox
            ua.indexOf('firefox') === -1) {
              audioCodec = 'mp4a.40.5';
            }
          }
          // HE-AAC is broken on Android, always signal audio codec as AAC even if variant manifest states otherwise
          if (ua.indexOf('android') !== -1 && track.container !== 'audio/mpeg') {
            // Exclude mpeg audio
            audioCodec = 'mp4a.40.2';
            _logger.logger.log('Android: force audio codec to ' + audioCodec);
          }
          track.levelCodec = audioCodec;
          track.id = data.id;
        }
        track = tracks.video;
        if (track) {
          track.levelCodec = this.levels[this.level].videoCodec;
          track.id = data.id;
        }
        this.hls.trigger(_events2.default.BUFFER_CODECS, tracks);
        // loop through tracks that are going to be provided to bufferController
        for (trackName in tracks) {
          track = tracks[trackName];
          _logger.logger.log('main track:' + trackName + ',container:' + track.container + ',codecs[level/parsed]=[' + track.levelCodec + '/' + track.codec + ']');
          var initSegment = track.initSegment;
          if (initSegment) {
            this.appended = true;
            // arm pending Buffering flag before appending a segment
            this.pendingBuffering = true;
            this.hls.trigger(_events2.default.BUFFER_APPENDING, { type: trackName, data: initSegment, parent: 'main', content: 'initSegment' });
          }
        }
        //trigger handler right now
        this.tick();
      }
    }
  }, {
    key: 'onFragParsingData',
    value: function onFragParsingData(data) {
      var _this2 = this;

      var fragCurrent = this.fragCurrent;
      var fragNew = data.frag;
      if (fragCurrent && data.id === 'main' && fragNew.sn === fragCurrent.sn && fragNew.level === fragCurrent.level && !(data.type === 'audio' && this.altAudio) && // filter out main audio if audio track is loaded through audio stream controller
      this.state === State.PARSING) {
        var level = this.levels[this.level],
            frag = fragCurrent;
        if (isNaN(data.endPTS)) {
          data.endPTS = data.startPTS + fragCurrent.duration;
          data.endDTS = data.startDTS + fragCurrent.duration;
        }

        _logger.logger.log('Parsed ' + data.type + ',PTS:[' + data.startPTS.toFixed(3) + ',' + data.endPTS.toFixed(3) + '],DTS:[' + data.startDTS.toFixed(3) + '/' + data.endDTS.toFixed(3) + '],nb:' + data.nb + ',dropped:' + (data.dropped || 0));

        // Detect gaps in a fragment  and try to fix it by finding a keyframe in the previous fragment (see _findFragments)
        if (data.type === 'video') {
          frag.dropped = data.dropped;
          if (frag.dropped) {
            if (!frag.backtracked) {
              _logger.logger.warn('missing video frame(s), backtracking fragment');
              // Return back to the IDLE state without appending to buffer
              // Causes findFragments to backtrack a segment and find the keyframe
              // Audio fragments arriving before video sets the nextLoadPosition, causing _findFragments to skip the backtracked fragment
              frag.backtracked = true;
              this.nextLoadPosition = data.startPTS;
              this.state = State.IDLE;
              this.fragPrevious = frag;
              this.tick();
              return;
            } else {
              _logger.logger.warn('Already backtracked on this fragment, appending with the gap');
            }
          } else {
            // Only reset the backtracked flag if we've loaded the frag without any dropped frames
            frag.backtracked = false;
          }
        }

        var drift = _levelHelper2.default.updateFragPTSDTS(level.details, frag, data.startPTS, data.endPTS, data.startDTS, data.endDTS),
            hls = this.hls;
        hls.trigger(_events2.default.LEVEL_PTS_UPDATED, { details: level.details, level: this.level, drift: drift, type: data.type, start: data.startPTS, end: data.endPTS });

        // has remuxer dropped video frames located before first keyframe ?
        [data.data1, data.data2].forEach(function (buffer) {
          // only append in PARSING state (rationale is that an appending error could happen synchronously on first segment appending)
          // in that case it is useless to append following segments
          if (buffer && buffer.length && _this2.state === State.PARSING) {
            _this2.appended = true;
            // arm pending Buffering flag before appending a segment
            _this2.pendingBuffering = true;
            hls.trigger(_events2.default.BUFFER_APPENDING, { type: data.type, data: buffer, parent: 'main', content: 'data' });
          }
        });
        //trigger handler right now
        this.tick();
      }
    }
  }, {
    key: 'onFragParsed',
    value: function onFragParsed(data) {
      var fragCurrent = this.fragCurrent;
      var fragNew = data.frag;
      if (fragCurrent && data.id === 'main' && fragNew.sn === fragCurrent.sn && fragNew.level === fragCurrent.level && this.state === State.PARSING) {
        this.stats.tparsed = performance.now();
        this.state = State.PARSED;
        this._checkAppendedParsed();
      }
    }
  }, {
    key: 'onAudioTrackSwitching',
    value: function onAudioTrackSwitching(data) {
      // if any URL found on new audio track, it is an alternate audio track
      var altAudio = !!data.url,
          trackId = data.id;
      // if we switch on main audio, ensure that main fragment scheduling is synced with media.buffered
      // don't do anything if we switch to alt audio: audio stream controller is handling it.
      // we will just have to change buffer scheduling on audioTrackSwitched
      if (!altAudio) {
        if (this.mediaBuffer !== this.media) {
          _logger.logger.log('switching on main audio, use media.buffered to schedule main fragment loading');
          this.mediaBuffer = this.media;
          var fragCurrent = this.fragCurrent;
          // we need to refill audio buffer from main: cancel any frag loading to speed up audio switch
          if (fragCurrent.loader) {
            _logger.logger.log('switching to main audio track, cancel main fragment load');
            fragCurrent.loader.abort();
          }
          this.fragCurrent = null;
          this.fragPrevious = null;
          // destroy demuxer to force init segment generation (following audio switch)
          if (this.demuxer) {
            this.demuxer.destroy();
            this.demuxer = null;
          }
          // switch to IDLE state to load new fragment
          this.state = State.IDLE;
        }
        var hls = this.hls;
        // switching to main audio, flush all audio and trigger track switched
        hls.trigger(_events2.default.BUFFER_FLUSHING, { startOffset: 0, endOffset: Number.POSITIVE_INFINITY, type: 'audio' });
        hls.trigger(_events2.default.AUDIO_TRACK_SWITCHED, { id: trackId });
        this.altAudio = false;
      }
    }
  }, {
    key: 'onAudioTrackSwitched',
    value: function onAudioTrackSwitched(data) {
      var trackId = data.id,
          altAudio = !!this.hls.audioTracks[trackId].url;
      if (altAudio) {
        var videoBuffer = this.videoBuffer;
        // if we switched on alternate audio, ensure that main fragment scheduling is synced with video sourcebuffer buffered
        if (videoBuffer && this.mediaBuffer !== videoBuffer) {
          _logger.logger.log('switching on alternate audio, use video.buffered to schedule main fragment loading');
          this.mediaBuffer = videoBuffer;
        }
      }
      this.altAudio = altAudio;
      this.tick();
    }
  }, {
    key: 'onBufferCreated',
    value: function onBufferCreated(data) {
      var tracks = data.tracks,
          mediaTrack = void 0,
          name = void 0,
          alternate = false;
      for (var type in tracks) {
        var track = tracks[type];
        if (track.id === 'main') {
          name = type;
          mediaTrack = track;
          // keep video source buffer reference
          if (type === 'video') {
            this.videoBuffer = tracks[type].buffer;
          }
        } else {
          alternate = true;
        }
      }
      if (alternate && mediaTrack) {
        _logger.logger.log('alternate track found, use ' + name + '.buffered to schedule main fragment loading');
        this.mediaBuffer = mediaTrack.buffer;
      } else {
        this.mediaBuffer = this.media;
      }
    }
  }, {
    key: 'onBufferAppended',
    value: function onBufferAppended(data) {
      if (data.parent === 'main') {
        var state = this.state;
        if (state === State.PARSING || state === State.PARSED) {
          // check if all buffers have been appended
          this.pendingBuffering = data.pending > 0;
          this._checkAppendedParsed();
        }
      }
    }
  }, {
    key: '_checkAppendedParsed',
    value: function _checkAppendedParsed() {
      //trigger handler right now
      if (this.state === State.PARSED && (!this.appended || !this.pendingBuffering)) {
        var frag = this.fragCurrent;
        if (frag) {
          var media = this.mediaBuffer ? this.mediaBuffer : this.media;
          _logger.logger.log('main buffered : ' + _timeRanges2.default.toString(media.buffered));
          // filter fragments potentially evicted from buffer. this is to avoid memleak on live streams
          var bufferedFrags = this._bufferedFrags.filter(function (frag) {
            return _bufferHelper2.default.isBuffered(media, (frag.startPTS + frag.endPTS) / 2);
          });
          // push new range
          bufferedFrags.push(frag);
          // sort frags, as we use BinarySearch for lookup in getBufferedFrag ...
          this._bufferedFrags = bufferedFrags.sort(function (a, b) {
            return a.startPTS - b.startPTS;
          });
          this.fragPrevious = frag;
          var stats = this.stats;
          stats.tbuffered = performance.now();
          // we should get rid of this.fragLastKbps
          this.fragLastKbps = Math.round(8 * stats.total / (stats.tbuffered - stats.tfirst));
          this.hls.trigger(_events2.default.FRAG_BUFFERED, { stats: stats, frag: frag, id: 'main' });
          this.state = State.IDLE;
        }
        this.tick();
      }
    }
  }, {
    key: 'onError',
    value: function onError(data) {
      var frag = data.frag || this.fragCurrent;
      // don't handle frag error not related to main fragment
      if (frag && frag.type !== 'main') {
        return;
      }
      var media = this.media,

      // 0.5 : tolerance needed as some browsers stalls playback before reaching buffered end
      mediaBuffered = media && _bufferHelper2.default.isBuffered(media, media.currentTime) && _bufferHelper2.default.isBuffered(media, media.currentTime + 0.5);
      switch (data.details) {
        case _errors.ErrorDetails.FRAG_LOAD_ERROR:
        case _errors.ErrorDetails.FRAG_LOAD_TIMEOUT:
        case _errors.ErrorDetails.KEY_LOAD_ERROR:
        case _errors.ErrorDetails.KEY_LOAD_TIMEOUT:
          if (!data.fatal) {
            var loadError = this.fragLoadError;
            if (loadError) {
              loadError++;
            } else {
              loadError = 1;
            }
            var config = this.config;
            // keep retrying / don't raise fatal network error if current position is buffered or if in automode with current level not 0
            if (loadError <= config.fragLoadingMaxRetry || mediaBuffered || frag.autoLevel && frag.level) {
              this.fragLoadError = loadError;
              // reset load counter to avoid frag loop loading error
              frag.loadCounter = 0;
              // exponential backoff capped to config.fragLoadingMaxRetryTimeout
              var delay = Math.min(Math.pow(2, loadError - 1) * config.fragLoadingRetryDelay, config.fragLoadingMaxRetryTimeout);
              _logger.logger.warn('mediaController: frag loading failed, retry in ' + delay + ' ms');
              this.retryDate = performance.now() + delay;
              // retry loading state
              // if loadedmetadata is not set, it means that we are emergency switch down on first frag
              // in that case, reset startFragRequested flag
              if (!this.loadedmetadata) {
                this.startFragRequested = false;
                this.nextLoadPosition = this.startPosition;
              }
              this.state = State.FRAG_LOADING_WAITING_RETRY;
            } else {
              _logger.logger.error('mediaController: ' + data.details + ' reaches max retry, redispatch as fatal ...');
              // switch error to fatal
              data.fatal = true;
              this.state = State.ERROR;
            }
          }
          break;
        case _errors.ErrorDetails.FRAG_LOOP_LOADING_ERROR:
          if (!data.fatal) {
            // if buffer is not empty
            if (mediaBuffered) {
              // try to reduce max buffer length : rationale is that we could get
              // frag loop loading error because of buffer eviction
              this._reduceMaxBufferLength(frag.duration);
              this.state = State.IDLE;
            } else {
              // buffer empty. report as fatal if in manual mode or if lowest level.
              // level controller takes care of emergency switch down logic
              if (!frag.autoLevel || frag.level === 0) {
                // switch error to fatal
                data.fatal = true;
                this.state = State.ERROR;
              }
            }
          }
          break;
        case _errors.ErrorDetails.LEVEL_LOAD_ERROR:
        case _errors.ErrorDetails.LEVEL_LOAD_TIMEOUT:
          if (this.state !== State.ERROR) {
            if (data.fatal) {
              // if fatal error, stop processing
              this.state = State.ERROR;
              _logger.logger.warn('streamController: ' + data.details + ',switch to ' + this.state + ' state ...');
            } else {
              // in case of non fatal error while loading level, if level controller is not retrying to load level , switch back to IDLE
              if (!data.levelRetry && this.state === State.WAITING_LEVEL) {
                this.state = State.IDLE;
              }
            }
          }
          break;
        case _errors.ErrorDetails.BUFFER_FULL_ERROR:
          // if in appending state
          if (data.parent === 'main' && (this.state === State.PARSING || this.state === State.PARSED)) {
            // reduce max buf len if current position is buffered
            if (mediaBuffered) {
              this._reduceMaxBufferLength(this.config.maxBufferLength);
              this.state = State.IDLE;
            } else {
              // current position is not buffered, but browser is still complaining about buffer full error
              // this happens on IE/Edge, refer to https://github.com/video-dev/hls.js/pull/708
              // in that case flush the whole buffer to recover
              _logger.logger.warn('buffer full error also media.currentTime is not buffered, flush everything');
              this.fragCurrent = null;
              // flush everything
              this.flushMainBuffer(0, Number.POSITIVE_INFINITY);
            }
          }
          break;
        default:
          break;
      }
    }
  }, {
    key: '_reduceMaxBufferLength',
    value: function _reduceMaxBufferLength(minLength) {
      var config = this.config;
      if (config.maxMaxBufferLength >= minLength) {
        // reduce max buffer length as it might be too high. we do this to avoid loop flushing ...
        config.maxMaxBufferLength /= 2;
        _logger.logger.warn('main:reduce max buffer length to ' + config.maxMaxBufferLength + 's');
        // increase fragment load Index to avoid frag loop loading error after buffer flush
        this.fragLoadIdx += 2 * config.fragLoadingLoopThreshold;
      }
    }
  }, {
    key: '_checkBuffer',
    value: function _checkBuffer() {
      var media = this.media,
          config = this.config;
      // if ready state different from HAVE_NOTHING (numeric value 0), we are allowed to seek
      if (media && media.readyState) {
        var currentTime = media.currentTime,
            mediaBuffer = this.mediaBuffer ? this.mediaBuffer : media,
            buffered = mediaBuffer.buffered;
        // adjust currentTime to start position on loaded metadata
        if (!this.loadedmetadata && buffered.length) {
          this.loadedmetadata = true;
          // only adjust currentTime if different from startPosition or if startPosition not buffered
          // at that stage, there should be only one buffered range, as we reach that code after first fragment has been buffered
          var startPosition = media.seeking ? currentTime : this.startPosition,
              startPositionBuffered = _bufferHelper2.default.isBuffered(mediaBuffer, startPosition),
              firstbufferedPosition = buffered.start(0);
          // if currentTime not matching with expected startPosition or startPosition not buffered
          if (currentTime !== startPosition || !startPositionBuffered && Math.abs(startPosition - firstbufferedPosition) < config.maxSeekHole) {
            _logger.logger.log('target start position:' + startPosition);
            // if startPosition not buffered, let's seek to buffered.start(0)
            if (!startPositionBuffered) {
              startPosition = firstbufferedPosition;
              _logger.logger.log('target start position not buffered, seek to buffered.start(0) ' + startPosition);
            }
            _logger.logger.log('adjust currentTime from ' + currentTime + ' to ' + startPosition);
            media.currentTime = startPosition;
          }
        } else if (this.immediateSwitch) {
          this.immediateLevelSwitchEnd();
        } else {
          var bufferInfo = _bufferHelper2.default.bufferInfo(media, currentTime, 0),
              expectedPlaying = !(media.paused || // not playing when media is paused
          media.ended || // not playing when media is ended
          media.buffered.length === 0),
              // not playing if nothing buffered
          jumpThreshold = 0.5,
              // tolerance needed as some browsers stalls playback before reaching buffered range end
          playheadMoving = currentTime !== this.lastCurrentTime;

          if (playheadMoving) {
            // played moving, but was previously stalled => now not stuck anymore
            if (this.stallReported) {
              _logger.logger.warn('playback not stuck anymore @' + currentTime + ', after ' + Math.round(performance.now() - this.stalled) + 'ms');
              this.stallReported = false;
            }
            this.stalled = undefined;
            this.nudgeRetry = 0;
          } else {
            // playhead not moving
            if (expectedPlaying) {
              // playhead not moving BUT media expected to play
              var tnow = performance.now();
              var hls = this.hls;
              if (!this.stalled) {
                // stall just detected, store current time
                this.stalled = tnow;
                this.stallReported = false;
              } else {
                // playback already stalled, check stalling duration
                // if stalling for more than a given threshold, let's try to recover
                var stalledDuration = tnow - this.stalled;
                var bufferLen = bufferInfo.len;
                var nudgeRetry = this.nudgeRetry || 0;
                // have we reached stall deadline ?
                if (bufferLen <= jumpThreshold && stalledDuration > config.lowBufferWatchdogPeriod * 1000) {
                  // report stalled error once
                  if (!this.stallReported) {
                    this.stallReported = true;
                    _logger.logger.warn('playback stalling in low buffer @' + currentTime);
                    hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.BUFFER_STALLED_ERROR, fatal: false, buffer: bufferLen });
                  }
                  // if buffer len is below threshold, try to jump to start of next buffer range if close
                  // no buffer available @ currentTime, check if next buffer is close (within a config.maxSeekHole second range)
                  var nextBufferStart = bufferInfo.nextStart,
                      delta = nextBufferStart - currentTime;
                  if (nextBufferStart && delta < config.maxSeekHole && delta > 0) {
                    this.nudgeRetry = ++nudgeRetry;
                    var nudgeOffset = nudgeRetry * config.nudgeOffset;
                    // next buffer is close ! adjust currentTime to nextBufferStart
                    // this will ensure effective video decoding
                    _logger.logger.log('adjust currentTime from ' + media.currentTime + ' to next buffered @ ' + nextBufferStart + ' + nudge ' + nudgeOffset);
                    media.currentTime = nextBufferStart + nudgeOffset;
                    // reset stalled so to rearm watchdog timer
                    this.stalled = undefined;
                    hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.BUFFER_SEEK_OVER_HOLE, fatal: false, hole: nextBufferStart + nudgeOffset - currentTime });
                  }
                } else if (bufferLen > jumpThreshold && stalledDuration > config.highBufferWatchdogPeriod * 1000) {
                  // report stalled error once
                  if (!this.stallReported) {
                    this.stallReported = true;
                    _logger.logger.warn('playback stalling in high buffer @' + currentTime);
                    hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.BUFFER_STALLED_ERROR, fatal: false, buffer: bufferLen });
                  }
                  // reset stalled so to rearm watchdog timer
                  this.stalled = undefined;
                  this.nudgeRetry = ++nudgeRetry;
                  if (nudgeRetry < config.nudgeMaxRetry) {
                    var _currentTime = media.currentTime;
                    var targetTime = _currentTime + nudgeRetry * config.nudgeOffset;
                    _logger.logger.log('adjust currentTime from ' + _currentTime + ' to ' + targetTime);
                    // playback stalled in buffered area ... let's nudge currentTime to try to overcome this
                    media.currentTime = targetTime;
                    hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.BUFFER_NUDGE_ON_STALL, fatal: false });
                  } else {
                    _logger.logger.error('still stuck in high buffer @' + currentTime + ' after ' + config.nudgeMaxRetry + ', raise fatal error');
                    hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.BUFFER_STALLED_ERROR, fatal: true });
                  }
                }
              }
            }
          }
        }
      }
    }
  }, {
    key: 'onFragLoadEmergencyAborted',
    value: function onFragLoadEmergencyAborted() {
      this.state = State.IDLE;
      // if loadedmetadata is not set, it means that we are emergency switch down on first frag
      // in that case, reset startFragRequested flag
      if (!this.loadedmetadata) {
        this.startFragRequested = false;
        this.nextLoadPosition = this.startPosition;
      }
      this.tick();
    }
  }, {
    key: 'onBufferFlushed',
    value: function onBufferFlushed() {
      /* after successful buffer flushing, filter flushed fragments from bufferedFrags
        use mediaBuffered instead of media (so that we will check against video.buffered ranges in case of alt audio track)
      */
      var media = this.mediaBuffer ? this.mediaBuffer : this.media;
      this._bufferedFrags = this._bufferedFrags.filter(function (frag) {
        return _bufferHelper2.default.isBuffered(media, (frag.startPTS + frag.endPTS) / 2);
      });

      // increase fragment load Index to avoid frag loop loading error after buffer flush
      this.fragLoadIdx += 2 * this.config.fragLoadingLoopThreshold;
      // move to IDLE once flush complete. this should trigger new fragment loading
      this.state = State.IDLE;
      // reset reference to frag
      this.fragPrevious = null;
    }
  }, {
    key: 'swapAudioCodec',
    value: function swapAudioCodec() {
      this.audioCodecSwap = !this.audioCodecSwap;
    }
  }, {
    key: 'computeLivePosition',
    value: function computeLivePosition(sliding, levelDetails) {
      var targetLatency = this.config.liveSyncDuration !== undefined ? this.config.liveSyncDuration : this.config.liveSyncDurationCount * levelDetails.targetduration;
      return sliding + Math.max(0, levelDetails.totalduration - targetLatency);
    }
  }, {
    key: 'state',
    set: function set(nextState) {
      if (this.state !== nextState) {
        var previousState = this.state;
        this._state = nextState;
        _logger.logger.log('main stream:' + previousState + '->' + nextState);
        this.hls.trigger(_events2.default.STREAM_STATE_TRANSITION, { previousState: previousState, nextState: nextState });
      }
    },
    get: function get() {
      return this._state;
    }
  }, {
    key: 'currentLevel',
    get: function get() {
      var media = this.media;
      if (media) {
        var frag = this.getBufferedFrag(media.currentTime);
        if (frag) {
          return frag.level;
        }
      }
      return -1;
    }
  }, {
    key: 'nextBufferedFrag',
    get: function get() {
      var media = this.media;
      if (media) {
        // first get end range of current fragment
        return this.followingBufferedFrag(this.getBufferedFrag(media.currentTime));
      } else {
        return null;
      }
    }
  }, {
    key: 'nextLevel',
    get: function get() {
      var frag = this.nextBufferedFrag;
      if (frag) {
        return frag.level;
      } else {
        return -1;
      }
    }
  }, {
    key: 'liveSyncPosition',
    get: function get() {
      return this._liveSyncPosition;
    },
    set: function set(value) {
      this._liveSyncPosition = value;
    }
  }]);

  return StreamController;
}(_eventHandler2.default);

exports.default = StreamController;

},{"../demux/demuxer":25,"../errors":33,"../event-handler":34,"../events":35,"../helper/buffer-helper":37,"../helper/level-helper":38,"../utils/binary-search":48,"../utils/logger":54,"../utils/timeRanges":55}],14:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _eventHandler = require('../event-handler');

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _logger = require('../utils/logger');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Subtitle Stream Controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

var SubtitleStreamController = function (_EventHandler) {
  _inherits(SubtitleStreamController, _EventHandler);

  function SubtitleStreamController(hls) {
    _classCallCheck(this, SubtitleStreamController);

    var _this = _possibleConstructorReturn(this, (SubtitleStreamController.__proto__ || Object.getPrototypeOf(SubtitleStreamController)).call(this, hls, _events2.default.ERROR, _events2.default.SUBTITLE_TRACKS_UPDATED, _events2.default.SUBTITLE_TRACK_SWITCH, _events2.default.SUBTITLE_TRACK_LOADED, _events2.default.SUBTITLE_FRAG_PROCESSED));

    _this.config = hls.config;
    _this.vttFragSNsProcessed = {};
    _this.vttFragQueues = undefined;
    _this.currentlyProcessing = null;
    _this.currentTrackId = -1;
    return _this;
  }

  _createClass(SubtitleStreamController, [{
    key: 'destroy',
    value: function destroy() {
      _eventHandler2.default.prototype.destroy.call(this);
    }

    // Remove all queued items and create a new, empty queue for each track.

  }, {
    key: 'clearVttFragQueues',
    value: function clearVttFragQueues() {
      var _this2 = this;

      this.vttFragQueues = {};
      this.tracks.forEach(function (track) {
        _this2.vttFragQueues[track.id] = [];
      });
    }

    // If no frag is being processed and queue isn't empty, initiate processing of next frag in line.

  }, {
    key: 'nextFrag',
    value: function nextFrag() {
      if (this.currentlyProcessing === null && this.currentTrackId > -1 && this.vttFragQueues[this.currentTrackId].length) {
        var frag = this.currentlyProcessing = this.vttFragQueues[this.currentTrackId].shift();
        this.hls.trigger(_events2.default.FRAG_LOADING, { frag: frag });
      }
    }

    // When fragment has finished processing, add sn to list of completed if successful.

  }, {
    key: 'onSubtitleFragProcessed',
    value: function onSubtitleFragProcessed(data) {
      if (data.success) {
        this.vttFragSNsProcessed[data.frag.trackId].push(data.frag.sn);
      }
      this.currentlyProcessing = null;
      this.nextFrag();
    }

    // If something goes wrong, procede to next frag, if we were processing one.

  }, {
    key: 'onError',
    value: function onError(data) {
      var frag = data.frag;
      // don't handle frag error not related to subtitle fragment
      if (frag && frag.type !== 'subtitle') {
        return;
      }
      if (this.currentlyProcessing) {
        this.currentlyProcessing = null;
        this.nextFrag();
      }
    }

    // Got all new subtitle tracks.

  }, {
    key: 'onSubtitleTracksUpdated',
    value: function onSubtitleTracksUpdated(data) {
      var _this3 = this;

      _logger.logger.log('subtitle tracks updated');
      this.tracks = data.subtitleTracks;
      this.clearVttFragQueues();
      this.vttFragSNsProcessed = {};
      this.tracks.forEach(function (track) {
        _this3.vttFragSNsProcessed[track.id] = [];
      });
    }
  }, {
    key: 'onSubtitleTrackSwitch',
    value: function onSubtitleTrackSwitch(data) {
      this.currentTrackId = data.id;
      this.clearVttFragQueues();
    }

    // Got a new set of subtitle fragments.

  }, {
    key: 'onSubtitleTrackLoaded',
    value: function onSubtitleTrackLoaded(data) {
      var processedFragSNs = this.vttFragSNsProcessed[data.id],
          fragQueue = this.vttFragQueues[data.id],
          currentFragSN = !!this.currentlyProcessing ? this.currentlyProcessing.sn : -1;

      var alreadyProcessed = function alreadyProcessed(frag) {
        return processedFragSNs.indexOf(frag.sn) > -1;
      };

      var alreadyInQueue = function alreadyInQueue(frag) {
        return fragQueue.some(function (fragInQueue) {
          return fragInQueue.sn === frag.sn;
        });
      };

      // Add all fragments that haven't been, aren't currently being and aren't waiting to be processed, to queue.
      data.details.fragments.forEach(function (frag) {
        if (!(alreadyProcessed(frag) || frag.sn === currentFragSN || alreadyInQueue(frag))) {
          // Frags don't know their subtitle track ID, so let's just add that...
          frag.trackId = data.id;
          fragQueue.push(frag);
        }
      });

      this.nextFrag();
    }
  }]);

  return SubtitleStreamController;
}(_eventHandler2.default);

exports.default = SubtitleStreamController;

},{"../event-handler":34,"../events":35,"../utils/logger":54}],15:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _eventHandler = require('../event-handler');

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _logger = require('../utils/logger');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * audio track controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

function filterSubtitleTracks(textTrackList) {
  var tracks = [];
  for (var i = 0; i < textTrackList.length; i++) {
    if (textTrackList[i].kind === 'subtitles') {
      tracks.push(textTrackList[i]);
    }
  }
  return tracks;
}

var SubtitleTrackController = function (_EventHandler) {
  _inherits(SubtitleTrackController, _EventHandler);

  function SubtitleTrackController(hls) {
    _classCallCheck(this, SubtitleTrackController);

    var _this = _possibleConstructorReturn(this, (SubtitleTrackController.__proto__ || Object.getPrototypeOf(SubtitleTrackController)).call(this, hls, _events2.default.MEDIA_ATTACHED, _events2.default.MEDIA_DETACHING, _events2.default.MANIFEST_LOADING, _events2.default.MANIFEST_LOADED, _events2.default.SUBTITLE_TRACK_LOADED));

    _this.tracks = [];
    _this.trackId = -1;
    _this.media = undefined;
    return _this;
  }

  _createClass(SubtitleTrackController, [{
    key: '_onTextTracksChanged',
    value: function _onTextTracksChanged() {
      // Media is undefined when switching streams via loadSource()
      if (!this.media) {
        return;
      }

      var trackId = -1;
      var tracks = filterSubtitleTracks(this.media.textTracks);
      for (var id = 0; id < tracks.length; id++) {
        if (tracks[id].mode === 'showing') {
          trackId = id;
        }
      }

      // Setting current subtitleTrack will invoke code.
      this.subtitleTrack = trackId;
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      _eventHandler2.default.prototype.destroy.call(this);
    }

    // Listen for subtitle track change, then extract the current track ID.

  }, {
    key: 'onMediaAttached',
    value: function onMediaAttached(data) {
      this.media = data.media;
      if (!this.media) {
        return;
      }

      this.trackChangeListener = this._onTextTracksChanged.bind(this);
      this.media.textTracks.addEventListener('change', this.trackChangeListener);
    }
  }, {
    key: 'onMediaDetaching',
    value: function onMediaDetaching() {
      if (!this.media) {
        return;
      }

      this.media.textTracks.removeEventListener('change', this.trackChangeListener);

      this.media = undefined;
    }

    // Reset subtitle tracks on manifest loading

  }, {
    key: 'onManifestLoading',
    value: function onManifestLoading() {
      this.tracks = [];
      this.trackId = -1;
    }

    // Fired whenever a new manifest is loaded.

  }, {
    key: 'onManifestLoaded',
    value: function onManifestLoaded(data) {
      var _this2 = this;

      var tracks = data.subtitles || [];
      var defaultFound = false;
      this.tracks = tracks;
      this.trackId = -1;
      this.hls.trigger(_events2.default.SUBTITLE_TRACKS_UPDATED, { subtitleTracks: tracks });

      // loop through available subtitle tracks and autoselect default if needed
      // TODO: improve selection logic to handle forced, etc
      tracks.forEach(function (track) {
        if (track.default) {
          _this2.subtitleTrack = track.id;
          defaultFound = true;
        }
      });
    }

    // Trigger subtitle track playlist reload.

  }, {
    key: 'onTick',
    value: function onTick() {
      var trackId = this.trackId;
      var subtitleTrack = this.tracks[trackId];
      if (!subtitleTrack) {
        return;
      }

      var details = subtitleTrack.details;
      // check if we need to load playlist for this subtitle Track
      if (details === undefined || details.live === true) {
        // track not retrieved yet, or live playlist we need to (re)load it
        _logger.logger.log('(re)loading playlist for subtitle track ' + trackId);
        this.hls.trigger(_events2.default.SUBTITLE_TRACK_LOADING, { url: subtitleTrack.url, id: trackId });
      }
    }
  }, {
    key: 'onSubtitleTrackLoaded',
    value: function onSubtitleTrackLoaded(data) {
      var _this3 = this;

      if (data.id < this.tracks.length) {
        _logger.logger.log('subtitle track ' + data.id + ' loaded');
        this.tracks[data.id].details = data.details;
        // check if current playlist is a live playlist
        if (data.details.live && !this.timer) {
          // if live playlist we will have to reload it periodically
          // set reload period to playlist target duration
          this.timer = setInterval(function () {
            _this3.onTick();
          }, 1000 * data.details.targetduration, this);
        }
        if (!data.details.live && this.timer) {
          // playlist is not live and timer is armed : stopping it
          clearInterval(this.timer);
          this.timer = null;
        }
      }
    }

    /** get alternate subtitle tracks list from playlist **/

  }, {
    key: 'setSubtitleTrackInternal',
    value: function setSubtitleTrackInternal(newId) {
      // check if level idx is valid
      if (newId >= 0 && newId < this.tracks.length) {
        // stopping live reloading timer if any
        if (this.timer) {
          clearInterval(this.timer);
          this.timer = null;
        }
        this.trackId = newId;
        _logger.logger.log('switching to subtitle track ' + newId);
        var subtitleTrack = this.tracks[newId];
        this.hls.trigger(_events2.default.SUBTITLE_TRACK_SWITCH, { id: newId });
        // check if we need to load playlist for this subtitle Track
        var details = subtitleTrack.details;
        if (details === undefined || details.live === true) {
          // track not retrieved yet, or live playlist we need to (re)load it
          _logger.logger.log('(re)loading playlist for subtitle track ' + newId);
          this.hls.trigger(_events2.default.SUBTITLE_TRACK_LOADING, { url: subtitleTrack.url, id: newId });
        }
      }
    }
  }, {
    key: 'subtitleTracks',
    get: function get() {
      return this.tracks;
    }

    /** get index of the selected subtitle track (index in subtitle track lists) **/

  }, {
    key: 'subtitleTrack',
    get: function get() {
      return this.trackId;
    }

    /** select a subtitle track, based on its index in subtitle track lists**/
    ,
    set: function set(subtitleTrackId) {
      if (this.trackId !== subtitleTrackId) {
        // || this.tracks[subtitleTrackId].details === undefined) {
        this.setSubtitleTrackInternal(subtitleTrackId);
      }
    }
  }]);

  return SubtitleTrackController;
}(_eventHandler2.default);

exports.default = SubtitleTrackController;

},{"../event-handler":34,"../events":35,"../utils/logger":54}],16:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _eventHandler = require('../event-handler');

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _cea608Parser = require('../utils/cea-608-parser');

var _cea608Parser2 = _interopRequireDefault(_cea608Parser);

var _webvttParser = require('../utils/webvtt-parser');

var _webvttParser2 = _interopRequireDefault(_webvttParser);

var _logger = require('../utils/logger');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Timeline Controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

function clearCurrentCues(track) {
  if (track && track.cues) {
    while (track.cues.length > 0) {
      track.removeCue(track.cues[0]);
    }
  }
}

function reuseVttTextTrack(inUseTrack, manifestTrack) {
  return inUseTrack && inUseTrack.label === manifestTrack.name && !(inUseTrack.textTrack1 || inUseTrack.textTrack2);
}

function intersection(x1, x2, y1, y2) {
  return Math.min(x2, y2) - Math.max(x1, y1);
}

var TimelineController = function (_EventHandler) {
  _inherits(TimelineController, _EventHandler);

  function TimelineController(hls) {
    _classCallCheck(this, TimelineController);

    var _this = _possibleConstructorReturn(this, (TimelineController.__proto__ || Object.getPrototypeOf(TimelineController)).call(this, hls, _events2.default.MEDIA_ATTACHING, _events2.default.MEDIA_DETACHING, _events2.default.FRAG_PARSING_USERDATA, _events2.default.MANIFEST_LOADING, _events2.default.MANIFEST_LOADED, _events2.default.FRAG_LOADED, _events2.default.LEVEL_SWITCHING, _events2.default.INIT_PTS_FOUND));

    _this.hls = hls;
    _this.config = hls.config;
    _this.enabled = true;
    _this.Cues = hls.config.cueHandler;
    _this.textTracks = [];
    _this.tracks = [];
    _this.unparsedVttFrags = [];
    _this.initPTS = undefined;
    _this.cueRanges = [];

    if (_this.config.enableCEA708Captions) {
      var self = _this;
      var sendAddTrackEvent = function sendAddTrackEvent(track, media) {
        var e = null;
        try {
          e = new window.Event('addtrack');
        } catch (err) {
          //for IE11
          e = document.createEvent('Event');
          e.initEvent('addtrack', false, false);
        }
        e.track = track;
        media.dispatchEvent(e);
      };

      var channel1 = {
        'newCue': function newCue(startTime, endTime, screen) {
          if (!self.textTrack1) {
            //Enable reuse of existing text track.
            var existingTrack1 = self.getExistingTrack('1');
            if (!existingTrack1) {
              var textTrack1 = self.createTextTrack('captions', self.config.captionsTextTrack1Label, self.config.captionsTextTrack1LanguageCode);
              if (textTrack1) {
                textTrack1.textTrack1 = true;
                self.textTrack1 = textTrack1;
              }
            } else {
              self.textTrack1 = existingTrack1;
              clearCurrentCues(self.textTrack1);

              sendAddTrackEvent(self.textTrack1, self.media);
            }
          }
          self.addCues('textTrack1', startTime, endTime, screen);
        }
      };

      var channel2 = {
        'newCue': function newCue(startTime, endTime, screen) {
          if (!self.textTrack2) {
            //Enable reuse of existing text track.
            var existingTrack2 = self.getExistingTrack('2');
            if (!existingTrack2) {
              var textTrack2 = self.createTextTrack('captions', self.config.captionsTextTrack2Label, self.config.captionsTextTrack1LanguageCode);
              if (textTrack2) {
                textTrack2.textTrack2 = true;
                self.textTrack2 = textTrack2;
              }
            } else {
              self.textTrack2 = existingTrack2;
              clearCurrentCues(self.textTrack2);

              sendAddTrackEvent(self.textTrack2, self.media);
            }
          }
          self.addCues('textTrack2', startTime, endTime, screen);
        }
      };

      _this.cea608Parser = new _cea608Parser2.default(0, channel1, channel2);
    }
    return _this;
  }

  _createClass(TimelineController, [{
    key: 'addCues',
    value: function addCues(channel, startTime, endTime, screen) {
      // skip cues which overlap more than 50% with previously parsed time ranges
      var ranges = this.cueRanges;
      var merged = false;
      for (var i = ranges.length; i--;) {
        var cueRange = ranges[i];
        var overlap = intersection(cueRange[0], cueRange[1], startTime, endTime);
        if (overlap >= 0) {
          cueRange[0] = Math.min(cueRange[0], startTime);
          cueRange[1] = Math.max(cueRange[1], endTime);
          merged = true;
          if (overlap / (endTime - startTime) > 0.5) {
            return;
          }
        }
      }
      if (!merged) {
        ranges.push([startTime, endTime]);
      }
      this.Cues.newCue(this[channel], startTime, endTime, screen);
    }

    // Triggered when an initial PTS is found; used for synchronisation of WebVTT.

  }, {
    key: 'onInitPtsFound',
    value: function onInitPtsFound(data) {
      var _this2 = this;

      if (typeof this.initPTS === 'undefined') {
        this.initPTS = data.initPTS;
      }

      // Due to asynchrony, initial PTS may arrive later than the first VTT fragments are loaded.
      // Parse any unparsed fragments upon receiving the initial PTS.
      if (this.unparsedVttFrags.length) {
        this.unparsedVttFrags.forEach(function (frag) {
          _this2.onFragLoaded(frag);
        });
        this.unparsedVttFrags = [];
      }
    }
  }, {
    key: 'getExistingTrack',
    value: function getExistingTrack(channelNumber) {
      var media = this.media;
      if (media) {
        for (var i = 0; i < media.textTracks.length; i++) {
          var textTrack = media.textTracks[i];
          var propName = 'textTrack' + channelNumber;
          if (textTrack[propName] === true) {
            return textTrack;
          }
        }
      }
      return null;
    }
  }, {
    key: 'createTextTrack',
    value: function createTextTrack(kind, label, lang) {
      var media = this.media;
      if (media) {
        return media.addTextTrack(kind, label, lang);
      }
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      _eventHandler2.default.prototype.destroy.call(this);
    }
  }, {
    key: 'onMediaAttaching',
    value: function onMediaAttaching(data) {
      this.media = data.media;
    }
  }, {
    key: 'onMediaDetaching',
    value: function onMediaDetaching() {
      clearCurrentCues(this.textTrack1);
      clearCurrentCues(this.textTrack2);
    }
  }, {
    key: 'onManifestLoading',
    value: function onManifestLoading() {
      this.lastSn = -1; // Detect discontiguity in fragment parsing
      this.prevCC = -1;
      this.vttCCs = { ccOffset: 0, presentationOffset: 0 }; // Detect discontinuity in subtitle manifests

      // clear outdated subtitles
      var media = this.media;
      if (media) {
        var textTracks = media.textTracks;
        if (textTracks) {
          for (var i = 0; i < textTracks.length; i++) {
            clearCurrentCues(textTracks[i]);
          }
        }
      }
    }
  }, {
    key: 'onManifestLoaded',
    value: function onManifestLoaded(data) {
      var _this3 = this;

      this.textTracks = [];
      this.unparsedVttFrags = this.unparsedVttFrags || [];
      this.initPTS = undefined;
      this.cueRanges = [];

      if (this.config.enableWebVTT) {
        this.tracks = data.subtitles || [];
        var inUseTracks = this.media ? this.media.textTracks : [];

        this.tracks.forEach(function (track, index) {
          var textTrack = void 0;
          if (index < inUseTracks.length) {
            var inUseTrack = inUseTracks[index];
            // Reuse tracks with the same label, but do not reuse 608/708 tracks
            if (reuseVttTextTrack(inUseTrack, track)) {
              textTrack = inUseTrack;
            }
          }
          if (!textTrack) {
            textTrack = _this3.createTextTrack('subtitles', track.name, track.lang);
          }
          textTrack.mode = track.default ? 'showing' : 'hidden';
          _this3.textTracks.push(textTrack);
        });
      }
    }
  }, {
    key: 'onLevelSwitching',
    value: function onLevelSwitching() {
      this.enabled = this.hls.currentLevel.closedCaptions !== 'NONE';
    }
  }, {
    key: 'onFragLoaded',
    value: function onFragLoaded(data) {
      var frag = data.frag,
          payload = data.payload;
      if (frag.type === 'main') {
        var sn = frag.sn;
        // if this frag isn't contiguous, clear the parser so cues with bad start/end times aren't added to the textTrack
        if (sn !== this.lastSn + 1) {
          var cea608Parser = this.cea608Parser;
          if (cea608Parser) {
            cea608Parser.reset();
          }
        }
        this.lastSn = sn;
      }
      // If fragment is subtitle type, parse as WebVTT.
      else if (frag.type === 'subtitle') {
          if (payload.byteLength) {
            // We need an initial synchronisation PTS. Store fragments as long as none has arrived.
            if (typeof this.initPTS === 'undefined') {
              this.unparsedVttFrags.push(data);
              return;
            }
            var vttCCs = this.vttCCs;
            if (!vttCCs[frag.cc]) {
              vttCCs[frag.cc] = { start: frag.start, prevCC: this.prevCC, new: true };
              this.prevCC = frag.cc;
            }
            var textTracks = this.textTracks,
                hls = this.hls;

            // Parse the WebVTT file contents.
            _webvttParser2.default.parse(payload, this.initPTS, vttCCs, frag.cc, function (cues) {
              var currentTrack = textTracks[frag.trackId];
              // Add cues and trigger event with success true.
              cues.forEach(function (cue) {
                // Sometimes there are cue overlaps on segmented vtts so the same
                // cue can appear more than once in different vtt files.
                // This avoid showing duplicated cues with same timecode and text.
                if (!currentTrack.cues.getCueById(cue.id)) {
                  currentTrack.addCue(cue);
                }
              });
              hls.trigger(_events2.default.SUBTITLE_FRAG_PROCESSED, { success: true, frag: frag });
            }, function (e) {
              // Something went wrong while parsing. Trigger event with success false.
              _logger.logger.log('Failed to parse VTT cue: ' + e);
              hls.trigger(_events2.default.SUBTITLE_FRAG_PROCESSED, { success: false, frag: frag });
            });
          } else {
            // In case there is no payload, finish unsuccessfully.
            this.hls.trigger(_events2.default.SUBTITLE_FRAG_PROCESSED, { success: false, frag: frag });
          }
        }
    }
  }, {
    key: 'onFragParsingUserdata',
    value: function onFragParsingUserdata(data) {
      // push all of the CEA-708 messages into the interpreter
      // immediately. It will create the proper timestamps based on our PTS value
      if (this.enabled && this.config.enableCEA708Captions) {
        for (var i = 0; i < data.samples.length; i++) {
          var ccdatas = this.extractCea608Data(data.samples[i].bytes);
          this.cea608Parser.addData(data.samples[i].pts, ccdatas);
        }
      }
    }
  }, {
    key: 'extractCea608Data',
    value: function extractCea608Data(byteArray) {
      var count = byteArray[0] & 31;
      var position = 2;
      var tmpByte, ccbyte1, ccbyte2, ccValid, ccType;
      var actualCCBytes = [];

      for (var j = 0; j < count; j++) {
        tmpByte = byteArray[position++];
        ccbyte1 = 0x7F & byteArray[position++];
        ccbyte2 = 0x7F & byteArray[position++];
        ccValid = (4 & tmpByte) !== 0;
        ccType = 3 & tmpByte;

        if (ccbyte1 === 0 && ccbyte2 === 0) {
          continue;
        }

        if (ccValid) {
          if (ccType === 0) // || ccType === 1
            {
              actualCCBytes.push(ccbyte1);
              actualCCBytes.push(ccbyte2);
            }
        }
      }
      return actualCCBytes;
    }
  }]);

  return TimelineController;
}(_eventHandler2.default);

exports.default = TimelineController;

},{"../event-handler":34,"../events":35,"../utils/cea-608-parser":49,"../utils/logger":54,"../utils/webvtt-parser":58}],17:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var AESCrypto = function () {
  function AESCrypto(subtle, iv) {
    _classCallCheck(this, AESCrypto);

    this.subtle = subtle;
    this.aesIV = iv;
  }

  _createClass(AESCrypto, [{
    key: 'decrypt',
    value: function decrypt(data, key) {
      return this.subtle.decrypt({ name: 'AES-CBC', iv: this.aesIV }, key, data);
    }
  }]);

  return AESCrypto;
}();

exports.default = AESCrypto;

},{}],18:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var AESDecryptor = function () {
  function AESDecryptor() {
    _classCallCheck(this, AESDecryptor);

    // Static after running initTable
    this.rcon = [0x0, 0x1, 0x2, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];
    this.subMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)];
    this.invSubMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)];
    this.sBox = new Uint32Array(256);
    this.invSBox = new Uint32Array(256);

    // Changes during runtime
    this.key = new Uint32Array(0);

    this.initTable();
  }

  // Using view.getUint32() also swaps the byte order.


  _createClass(AESDecryptor, [{
    key: 'uint8ArrayToUint32Array_',
    value: function uint8ArrayToUint32Array_(arrayBuffer) {
      var view = new DataView(arrayBuffer);
      var newArray = new Uint32Array(4);
      for (var i = 0; i < 4; i++) {
        newArray[i] = view.getUint32(i * 4);
      }
      return newArray;
    }
  }, {
    key: 'initTable',
    value: function initTable() {
      var sBox = this.sBox;
      var invSBox = this.invSBox;
      var subMix = this.subMix;
      var subMix0 = subMix[0];
      var subMix1 = subMix[1];
      var subMix2 = subMix[2];
      var subMix3 = subMix[3];
      var invSubMix = this.invSubMix;
      var invSubMix0 = invSubMix[0];
      var invSubMix1 = invSubMix[1];
      var invSubMix2 = invSubMix[2];
      var invSubMix3 = invSubMix[3];

      var d = new Uint32Array(256);
      var x = 0;
      var xi = 0;
      var i = 0;
      for (i = 0; i < 256; i++) {
        if (i < 128) {
          d[i] = i << 1;
        } else {
          d[i] = i << 1 ^ 0x11b;
        }
      }

      for (i = 0; i < 256; i++) {
        var sx = xi ^ xi << 1 ^ xi << 2 ^ xi << 3 ^ xi << 4;
        sx = sx >>> 8 ^ sx & 0xff ^ 0x63;
        sBox[x] = sx;
        invSBox[sx] = x;

        // Compute multiplication
        var x2 = d[x];
        var x4 = d[x2];
        var x8 = d[x4];

        // Compute sub/invSub bytes, mix columns tables
        var t = d[sx] * 0x101 ^ sx * 0x1010100;
        subMix0[x] = t << 24 | t >>> 8;
        subMix1[x] = t << 16 | t >>> 16;
        subMix2[x] = t << 8 | t >>> 24;
        subMix3[x] = t;

        // Compute inv sub bytes, inv mix columns tables
        t = x8 * 0x1010101 ^ x4 * 0x10001 ^ x2 * 0x101 ^ x * 0x1010100;
        invSubMix0[sx] = t << 24 | t >>> 8;
        invSubMix1[sx] = t << 16 | t >>> 16;
        invSubMix2[sx] = t << 8 | t >>> 24;
        invSubMix3[sx] = t;

        // Compute next counter
        if (!x) {
          x = xi = 1;
        } else {
          x = x2 ^ d[d[d[x8 ^ x2]]];
          xi ^= d[d[xi]];
        }
      }
    }
  }, {
    key: 'expandKey',
    value: function expandKey(keyBuffer) {
      // convert keyBuffer to Uint32Array
      var key = this.uint8ArrayToUint32Array_(keyBuffer);
      var sameKey = true;
      var offset = 0;

      while (offset < key.length && sameKey) {
        sameKey = key[offset] === this.key[offset];
        offset++;
      }

      if (sameKey) {
        return;
      }

      this.key = key;
      var keySize = this.keySize = key.length;

      if (keySize !== 4 && keySize !== 6 && keySize !== 8) {
        throw new Error('Invalid aes key size=' + keySize);
      }

      var ksRows = this.ksRows = (keySize + 6 + 1) * 4;
      var ksRow = void 0;
      var invKsRow = void 0;

      var keySchedule = this.keySchedule = new Uint32Array(ksRows);
      var invKeySchedule = this.invKeySchedule = new Uint32Array(ksRows);
      var sbox = this.sBox;
      var rcon = this.rcon;

      var invSubMix = this.invSubMix;
      var invSubMix0 = invSubMix[0];
      var invSubMix1 = invSubMix[1];
      var invSubMix2 = invSubMix[2];
      var invSubMix3 = invSubMix[3];

      var prev = void 0;
      var t = void 0;

      for (ksRow = 0; ksRow < ksRows; ksRow++) {
        if (ksRow < keySize) {
          prev = keySchedule[ksRow] = key[ksRow];
          continue;
        }
        t = prev;

        if (ksRow % keySize === 0) {
          // Rot word
          t = t << 8 | t >>> 24;

          // Sub word
          t = sbox[t >>> 24] << 24 | sbox[t >>> 16 & 0xff] << 16 | sbox[t >>> 8 & 0xff] << 8 | sbox[t & 0xff];

          // Mix Rcon
          t ^= rcon[ksRow / keySize | 0] << 24;
        } else if (keySize > 6 && ksRow % keySize === 4) {
          // Sub word
          t = sbox[t >>> 24] << 24 | sbox[t >>> 16 & 0xff] << 16 | sbox[t >>> 8 & 0xff] << 8 | sbox[t & 0xff];
        }

        keySchedule[ksRow] = prev = (keySchedule[ksRow - keySize] ^ t) >>> 0;
      }

      for (invKsRow = 0; invKsRow < ksRows; invKsRow++) {
        ksRow = ksRows - invKsRow;
        if (invKsRow & 3) {
          t = keySchedule[ksRow];
        } else {
          t = keySchedule[ksRow - 4];
        }

        if (invKsRow < 4 || ksRow <= 4) {
          invKeySchedule[invKsRow] = t;
        } else {
          invKeySchedule[invKsRow] = invSubMix0[sbox[t >>> 24]] ^ invSubMix1[sbox[t >>> 16 & 0xff]] ^ invSubMix2[sbox[t >>> 8 & 0xff]] ^ invSubMix3[sbox[t & 0xff]];
        }

        invKeySchedule[invKsRow] = invKeySchedule[invKsRow] >>> 0;
      }
    }

    // Adding this as a method greatly improves performance.

  }, {
    key: 'networkToHostOrderSwap',
    value: function networkToHostOrderSwap(word) {
      return word << 24 | (word & 0xff00) << 8 | (word & 0xff0000) >> 8 | word >>> 24;
    }
  }, {
    key: 'decrypt',
    value: function decrypt(inputArrayBuffer, offset, aesIV) {
      var nRounds = this.keySize + 6;
      var invKeySchedule = this.invKeySchedule;
      var invSBOX = this.invSBox;

      var invSubMix = this.invSubMix;
      var invSubMix0 = invSubMix[0];
      var invSubMix1 = invSubMix[1];
      var invSubMix2 = invSubMix[2];
      var invSubMix3 = invSubMix[3];

      var initVector = this.uint8ArrayToUint32Array_(aesIV);
      var initVector0 = initVector[0];
      var initVector1 = initVector[1];
      var initVector2 = initVector[2];
      var initVector3 = initVector[3];

      var inputInt32 = new Int32Array(inputArrayBuffer);
      var outputInt32 = new Int32Array(inputInt32.length);

      var t0 = void 0,
          t1 = void 0,
          t2 = void 0,
          t3 = void 0;
      var s0 = void 0,
          s1 = void 0,
          s2 = void 0,
          s3 = void 0;
      var inputWords0 = void 0,
          inputWords1 = void 0,
          inputWords2 = void 0,
          inputWords3 = void 0;

      var ksRow, i;
      var swapWord = this.networkToHostOrderSwap;

      while (offset < inputInt32.length) {
        inputWords0 = swapWord(inputInt32[offset]);
        inputWords1 = swapWord(inputInt32[offset + 1]);
        inputWords2 = swapWord(inputInt32[offset + 2]);
        inputWords3 = swapWord(inputInt32[offset + 3]);

        s0 = inputWords0 ^ invKeySchedule[0];
        s1 = inputWords3 ^ invKeySchedule[1];
        s2 = inputWords2 ^ invKeySchedule[2];
        s3 = inputWords1 ^ invKeySchedule[3];

        ksRow = 4;

        // Iterate through the rounds of decryption
        for (i = 1; i < nRounds; i++) {
          t0 = invSubMix0[s0 >>> 24] ^ invSubMix1[s1 >> 16 & 0xff] ^ invSubMix2[s2 >> 8 & 0xff] ^ invSubMix3[s3 & 0xff] ^ invKeySchedule[ksRow];
          t1 = invSubMix0[s1 >>> 24] ^ invSubMix1[s2 >> 16 & 0xff] ^ invSubMix2[s3 >> 8 & 0xff] ^ invSubMix3[s0 & 0xff] ^ invKeySchedule[ksRow + 1];
          t2 = invSubMix0[s2 >>> 24] ^ invSubMix1[s3 >> 16 & 0xff] ^ invSubMix2[s0 >> 8 & 0xff] ^ invSubMix3[s1 & 0xff] ^ invKeySchedule[ksRow + 2];
          t3 = invSubMix0[s3 >>> 24] ^ invSubMix1[s0 >> 16 & 0xff] ^ invSubMix2[s1 >> 8 & 0xff] ^ invSubMix3[s2 & 0xff] ^ invKeySchedule[ksRow + 3];
          // Update state
          s0 = t0;
          s1 = t1;
          s2 = t2;
          s3 = t3;

          ksRow = ksRow + 4;
        }

        // Shift rows, sub bytes, add round key
        t0 = invSBOX[s0 >>> 24] << 24 ^ invSBOX[s1 >> 16 & 0xff] << 16 ^ invSBOX[s2 >> 8 & 0xff] << 8 ^ invSBOX[s3 & 0xff] ^ invKeySchedule[ksRow];
        t1 = invSBOX[s1 >>> 24] << 24 ^ invSBOX[s2 >> 16 & 0xff] << 16 ^ invSBOX[s3 >> 8 & 0xff] << 8 ^ invSBOX[s0 & 0xff] ^ invKeySchedule[ksRow + 1];
        t2 = invSBOX[s2 >>> 24] << 24 ^ invSBOX[s3 >> 16 & 0xff] << 16 ^ invSBOX[s0 >> 8 & 0xff] << 8 ^ invSBOX[s1 & 0xff] ^ invKeySchedule[ksRow + 2];
        t3 = invSBOX[s3 >>> 24] << 24 ^ invSBOX[s0 >> 16 & 0xff] << 16 ^ invSBOX[s1 >> 8 & 0xff] << 8 ^ invSBOX[s2 & 0xff] ^ invKeySchedule[ksRow + 3];
        ksRow = ksRow + 3;

        // Write
        outputInt32[offset] = swapWord(t0 ^ initVector0);
        outputInt32[offset + 1] = swapWord(t3 ^ initVector1);
        outputInt32[offset + 2] = swapWord(t2 ^ initVector2);
        outputInt32[offset + 3] = swapWord(t1 ^ initVector3);

        // reset initVector to last 4 unsigned int
        initVector0 = inputWords0;
        initVector1 = inputWords1;
        initVector2 = inputWords2;
        initVector3 = inputWords3;

        offset = offset + 4;
      }

      return outputInt32.buffer;
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      this.key = undefined;
      this.keySize = undefined;
      this.ksRows = undefined;

      this.sBox = undefined;
      this.invSBox = undefined;
      this.subMix = undefined;
      this.invSubMix = undefined;
      this.keySchedule = undefined;
      this.invKeySchedule = undefined;

      this.rcon = undefined;
    }
  }]);

  return AESDecryptor;
}();

exports.default = AESDecryptor;

},{}],19:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _aesCrypto = require('./aes-crypto');

var _aesCrypto2 = _interopRequireDefault(_aesCrypto);

var _fastAesKey = require('./fast-aes-key');

var _fastAesKey2 = _interopRequireDefault(_fastAesKey);

var _aesDecryptor = require('./aes-decryptor');

var _aesDecryptor2 = _interopRequireDefault(_aesDecryptor);

var _errors = require('../errors');

var _logger = require('../utils/logger');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/*globals self: false */

var Decrypter = function () {
  function Decrypter(observer, config) {
    _classCallCheck(this, Decrypter);

    this.observer = observer;
    this.config = config;
    this.logEnabled = true;
    try {
      var browserCrypto = crypto ? crypto : self.crypto;
      this.subtle = browserCrypto.subtle || browserCrypto.webkitSubtle;
    } catch (e) {}
    this.disableWebCrypto = !this.subtle;
  }

  _createClass(Decrypter, [{
    key: 'isSync',
    value: function isSync() {
      return this.disableWebCrypto && this.config.enableSoftwareAES;
    }
  }, {
    key: 'decrypt',
    value: function decrypt(data, key, iv, callback) {
      var _this = this;

      if (this.disableWebCrypto && this.config.enableSoftwareAES) {
        if (this.logEnabled) {
          _logger.logger.log('JS AES decrypt');
          this.logEnabled = false;
        }
        var decryptor = this.decryptor;
        if (!decryptor) {
          this.decryptor = decryptor = new _aesDecryptor2.default();
        }
        decryptor.expandKey(key);
        callback(decryptor.decrypt(data, 0, iv));
      } else {
        if (this.logEnabled) {
          _logger.logger.log('WebCrypto AES decrypt');
          this.logEnabled = false;
        }
        var subtle = this.subtle;
        if (this.key !== key) {
          this.key = key;
          this.fastAesKey = new _fastAesKey2.default(subtle, key);
        }

        this.fastAesKey.expandKey().then(function (aesKey) {
          // decrypt using web crypto
          var crypto = new _aesCrypto2.default(subtle, iv);
          crypto.decrypt(data, aesKey).catch(function (err) {
            _this.onWebCryptoError(err, data, key, iv, callback);
          }).then(function (result) {
            callback(result);
          });
        }).catch(function (err) {
          _this.onWebCryptoError(err, data, key, iv, callback);
        });
      }
    }
  }, {
    key: 'onWebCryptoError',
    value: function onWebCryptoError(err, data, key, iv, callback) {
      if (this.config.enableSoftwareAES) {
        _logger.logger.log('WebCrypto Error, disable WebCrypto API');
        this.disableWebCrypto = true;
        this.logEnabled = true;
        this.decrypt(data, key, iv, callback);
      } else {
        _logger.logger.error('decrypting error : ' + err.message);
        this.observer.trigger(Event.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.FRAG_DECRYPT_ERROR, fatal: true, reason: err.message });
      }
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      var decryptor = this.decryptor;
      if (decryptor) {
        decryptor.destroy();
        this.decryptor = undefined;
      }
    }
  }]);

  return Decrypter;
}();

exports.default = Decrypter;

},{"../errors":33,"../utils/logger":54,"./aes-crypto":17,"./aes-decryptor":18,"./fast-aes-key":20}],20:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var FastAESKey = function () {
  function FastAESKey(subtle, key) {
    _classCallCheck(this, FastAESKey);

    this.subtle = subtle;
    this.key = key;
  }

  _createClass(FastAESKey, [{
    key: 'expandKey',
    value: function expandKey() {
      return this.subtle.importKey('raw', this.key, { name: 'AES-CBC' }, false, ['encrypt', 'decrypt']);
    }
  }]);

  return FastAESKey;
}();

exports.default = FastAESKey;

},{}],21:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * AAC demuxer
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */


var _adts = require('./adts');

var _adts2 = _interopRequireDefault(_adts);

var _logger = require('../utils/logger');

var _id = require('../demux/id3');

var _id2 = _interopRequireDefault(_id);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var AACDemuxer = function () {
  function AACDemuxer(observer, remuxer, config) {
    _classCallCheck(this, AACDemuxer);

    this.observer = observer;
    this.config = config;
    this.remuxer = remuxer;
  }

  _createClass(AACDemuxer, [{
    key: 'resetInitSegment',
    value: function resetInitSegment(initSegment, audioCodec, videoCodec, duration) {
      this._audioTrack = { container: 'audio/adts', type: 'audio', id: -1, sequenceNumber: 0, isAAC: true, samples: [], len: 0, manifestCodec: audioCodec, duration: duration, inputTimeScale: 90000 };
    }
  }, {
    key: 'resetTimeStamp',
    value: function resetTimeStamp() {}
  }, {
    key: 'append',


    // feed incoming data to the front of the parsing pipeline
    value: function append(data, timeOffset, contiguous, accurateTimeOffset) {
      var track = this._audioTrack,
          id3Data = _id2.default.getID3Data(data, 0),
          pts = 90 * _id2.default.getTimeStamp(id3Data),
          frameIndex = 0,
          stamp = pts,
          length = data.length,
          offset = id3Data.length;

      var id3Samples = [{ pts: stamp, dts: stamp, data: id3Data }];

      while (offset < length - 1) {
        if (_adts2.default.isHeader(data, offset) && offset + 5 < length) {
          _adts2.default.initTrackConfig(track, this.observer, data, offset, track.manifestCodec);
          var frame = _adts2.default.appendFrame(track, data, offset, pts, frameIndex);
          if (frame) {
            offset += frame.length;
            stamp = frame.sample.pts;
            frameIndex++;
          } else {
            _logger.logger.log('Unable to parse AAC frame');
            break;
          }
        } else if (_id2.default.isHeader(data, offset)) {
          id3Data = _id2.default.getID3Data(data, offset);
          id3Samples.push({ pts: stamp, dts: stamp, data: id3Data });
          offset += id3Data.length;
        } else {
          //nothing found, keep looking
          offset++;
        }
      }

      this.remuxer.remux(track, { samples: [] }, { samples: id3Samples, inputTimeScale: 90000 }, { samples: [] }, timeOffset, contiguous, accurateTimeOffset);
    }
  }, {
    key: 'destroy',
    value: function destroy() {}
  }], [{
    key: 'probe',
    value: function probe(data) {
      // check if data contains ID3 timestamp and ADTS sync word
      var offset, length;
      var id3Data = _id2.default.getID3Data(data, 0);
      if (id3Data && _id2.default.getTimeStamp(id3Data) !== undefined) {
        // Look for ADTS header | 1111 1111 | 1111 X00X | where X can be either 0 or 1
        // Layer bits (position 14 and 15) in header should be always 0 for ADTS
        // More info https://wiki.multimedia.cx/index.php?title=ADTS
        for (offset = id3Data.length, length = Math.min(data.length - 1, offset + 100); offset < length; offset++) {
          if (_adts2.default.probe(data, offset)) {
            _logger.logger.log('ADTS sync word found !');
            return true;
          }
        }
      }
      return false;
    }
  }]);

  return AACDemuxer;
}();

exports.default = AACDemuxer;

},{"../demux/id3":27,"../utils/logger":54,"./adts":22}],22:[function(require,module,exports){
'use strict';

var _logger = require('../utils/logger');

var _errors = require('../errors');

/**
 *  ADTS parser helper
 */
var ADTS = {
  getAudioConfig: function getAudioConfig(observer, data, offset, audioCodec) {
    var adtsObjectType,
        // :int
    adtsSampleingIndex,
        // :int
    adtsExtensionSampleingIndex,
        // :int
    adtsChanelConfig,
        // :int
    config,
        userAgent = navigator.userAgent.toLowerCase(),
        manifestCodec = audioCodec,
        adtsSampleingRates = [96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050, 16000, 12000, 11025, 8000, 7350];
    // byte 2
    adtsObjectType = ((data[offset + 2] & 0xC0) >>> 6) + 1;
    adtsSampleingIndex = (data[offset + 2] & 0x3C) >>> 2;
    if (adtsSampleingIndex > adtsSampleingRates.length - 1) {
      observer.trigger(Event.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.FRAG_PARSING_ERROR, fatal: true, reason: 'invalid ADTS sampling index:' + adtsSampleingIndex });
      return;
    }
    adtsChanelConfig = (data[offset + 2] & 0x01) << 2;
    // byte 3
    adtsChanelConfig |= (data[offset + 3] & 0xC0) >>> 6;
    _logger.logger.log('manifest codec:' + audioCodec + ',ADTS data:type:' + adtsObjectType + ',sampleingIndex:' + adtsSampleingIndex + '[' + adtsSampleingRates[adtsSampleingIndex] + 'Hz],channelConfig:' + adtsChanelConfig);
    // firefox: freq less than 24kHz = AAC SBR (HE-AAC)
    if (/firefox/i.test(userAgent)) {
      if (adtsSampleingIndex >= 6) {
        adtsObjectType = 5;
        config = new Array(4);
        // HE-AAC uses SBR (Spectral Band Replication) , high frequencies are constructed from low frequencies
        // there is a factor 2 between frame sample rate and output sample rate
        // multiply frequency by 2 (see table below, equivalent to substract 3)
        adtsExtensionSampleingIndex = adtsSampleingIndex - 3;
      } else {
        adtsObjectType = 2;
        config = new Array(2);
        adtsExtensionSampleingIndex = adtsSampleingIndex;
      }
      // Android : always use AAC
    } else if (userAgent.indexOf('android') !== -1) {
      adtsObjectType = 2;
      config = new Array(2);
      adtsExtensionSampleingIndex = adtsSampleingIndex;
    } else {
      /*  for other browsers (Chrome/Vivaldi/Opera ...)
          always force audio type to be HE-AAC SBR, as some browsers do not support audio codec switch properly (like Chrome ...)
      */
      adtsObjectType = 5;
      config = new Array(4);
      // if (manifest codec is HE-AAC or HE-AACv2) OR (manifest codec not specified AND frequency less than 24kHz)
      if (audioCodec && (audioCodec.indexOf('mp4a.40.29') !== -1 || audioCodec.indexOf('mp4a.40.5') !== -1) || !audioCodec && adtsSampleingIndex >= 6) {
        // HE-AAC uses SBR (Spectral Band Replication) , high frequencies are constructed from low frequencies
        // there is a factor 2 between frame sample rate and output sample rate
        // multiply frequency by 2 (see table below, equivalent to substract 3)
        adtsExtensionSampleingIndex = adtsSampleingIndex - 3;
      } else {
        // if (manifest codec is AAC) AND (frequency less than 24kHz AND nb channel is 1) OR (manifest codec not specified and mono audio)
        // Chrome fails to play back with low frequency AAC LC mono when initialized with HE-AAC.  This is not a problem with stereo.
        if (audioCodec && audioCodec.indexOf('mp4a.40.2') !== -1 && adtsSampleingIndex >= 6 && adtsChanelConfig === 1 || !audioCodec && adtsChanelConfig === 1) {
          adtsObjectType = 2;
          config = new Array(2);
        }
        adtsExtensionSampleingIndex = adtsSampleingIndex;
      }
    }
    /* refer to http://wiki.multimedia.cx/index.php?title=MPEG-4_Audio#Audio_Specific_Config
        ISO 14496-3 (AAC).pdf - Table 1.13  Syntax of AudioSpecificConfig()
      Audio Profile / Audio Object Type
      0: Null
      1: AAC Main
      2: AAC LC (Low Complexity)
      3: AAC SSR (Scalable Sample Rate)
      4: AAC LTP (Long Term Prediction)
      5: SBR (Spectral Band Replication)
      6: AAC Scalable
     sampling freq
      0: 96000 Hz
      1: 88200 Hz
      2: 64000 Hz
      3: 48000 Hz
      4: 44100 Hz
      5: 32000 Hz
      6: 24000 Hz
      7: 22050 Hz
      8: 16000 Hz
      9: 12000 Hz
      10: 11025 Hz
      11: 8000 Hz
      12: 7350 Hz
      13: Reserved
      14: Reserved
      15: frequency is written explictly
      Channel Configurations
      These are the channel configurations:
      0: Defined in AOT Specifc Config
      1: 1 channel: front-center
      2: 2 channels: front-left, front-right
    */
    // audioObjectType = profile => profile, the MPEG-4 Audio Object Type minus 1
    config[0] = adtsObjectType << 3;
    // samplingFrequencyIndex
    config[0] |= (adtsSampleingIndex & 0x0E) >> 1;
    config[1] |= (adtsSampleingIndex & 0x01) << 7;
    // channelConfiguration
    config[1] |= adtsChanelConfig << 3;
    if (adtsObjectType === 5) {
      // adtsExtensionSampleingIndex
      config[1] |= (adtsExtensionSampleingIndex & 0x0E) >> 1;
      config[2] = (adtsExtensionSampleingIndex & 0x01) << 7;
      // adtsObjectType (force to 2, chrome is checking that object type is less than 5 ???
      //    https://chromium.googlesource.com/chromium/src.git/+/master/media/formats/mp4/aac.cc
      config[2] |= 2 << 2;
      config[3] = 0;
    }
    return { config: config, samplerate: adtsSampleingRates[adtsSampleingIndex], channelCount: adtsChanelConfig, codec: 'mp4a.40.' + adtsObjectType, manifestCodec: manifestCodec };
  },

  isHeaderPattern: function isHeaderPattern(data, offset) {
    return data[offset] === 0xff && (data[offset + 1] & 0xf6) === 0xf0;
  },

  getHeaderLength: function getHeaderLength(data, offset) {
    return !!(data[offset + 1] & 0x01) ? 7 : 9;
  },

  getFullFrameLength: function getFullFrameLength(data, offset) {
    return (data[offset + 3] & 0x03) << 11 | data[offset + 4] << 3 | (data[offset + 5] & 0xE0) >>> 5;
  },

  isHeader: function isHeader(data, offset) {
    // Look for ADTS header | 1111 1111 | 1111 X00X | where X can be either 0 or 1
    // Layer bits (position 14 and 15) in header should be always 0 for ADTS
    // More info https://wiki.multimedia.cx/index.php?title=ADTS
    if (offset + 1 < data.length && this.isHeaderPattern(data, offset)) {
      return true;
    }
    return false;
  },

  probe: function probe(data, offset) {
    // same as isHeader but we also check that ADTS frame follows last ADTS frame 
    // or end of data is reached
    if (offset + 1 < data.length && this.isHeaderPattern(data, offset)) {
      // ADTS header Length
      var headerLength = this.getHeaderLength(data, offset);
      // ADTS frame Length
      var frameLength = headerLength;
      if (offset + 5 < data.length) {
        frameLength = this.getFullFrameLength(data, offset);
      }
      var newOffset = offset + frameLength;
      if (newOffset === data.length || newOffset + 1 < data.length && this.isHeaderPattern(data, newOffset)) {
        return true;
      }
    }
    return false;
  },

  initTrackConfig: function initTrackConfig(track, observer, data, offset, audioCodec) {
    if (!track.samplerate) {
      var config = this.getAudioConfig(observer, data, offset, audioCodec);
      track.config = config.config;
      track.samplerate = config.samplerate;
      track.channelCount = config.channelCount;
      track.codec = config.codec;
      track.manifestCodec = config.manifestCodec;
      _logger.logger.log('parsed codec:' + track.codec + ',rate:' + config.samplerate + ',nb channel:' + config.channelCount);
    }
  },

  getFrameDuration: function getFrameDuration(samplerate) {
    return 1024 * 90000 / samplerate;
  },

  appendFrame: function appendFrame(track, data, offset, pts, frameIndex) {
    var frameDuration = this.getFrameDuration(track.samplerate);
    var header = this.parseFrameHeader(data, offset, pts, frameIndex, frameDuration);
    if (header) {
      var stamp = header.stamp;
      var headerLength = header.headerLength;
      var frameLength = header.frameLength;

      //logger.log(`AAC frame, offset/length/total/pts:${offset+headerLength}/${frameLength}/${data.byteLength}/${(stamp/90).toFixed(0)}`);
      var aacSample = { unit: data.subarray(offset + headerLength, offset + headerLength + frameLength), pts: stamp, dts: stamp };

      track.samples.push(aacSample);
      track.len += frameLength;

      return { sample: aacSample, length: frameLength + headerLength };
    }

    return undefined;
  },

  parseFrameHeader: function parseFrameHeader(data, offset, pts, frameIndex, frameDuration) {
    var headerLength, frameLength, stamp;
    var length = data.length;

    // The protection skip bit tells us if we have 2 bytes of CRC data at the end of the ADTS header
    headerLength = this.getHeaderLength(data, offset);
    // retrieve frame size
    frameLength = this.getFullFrameLength(data, offset);
    frameLength -= headerLength;

    if (frameLength > 0 && offset + headerLength + frameLength <= length) {
      stamp = pts + frameIndex * frameDuration;
      //logger.log(`AAC frame, offset/length/total/pts:${offset+headerLength}/${frameLength}/${data.byteLength}/${(stamp/90).toFixed(0)}`);
      return { headerLength: headerLength, frameLength: frameLength, stamp: stamp };
    }

    return undefined;
  }
};

module.exports = ADTS;

},{"../errors":33,"../utils/logger":54}],23:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*  inline demuxer.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *   probe fragments and instantiate appropriate demuxer depending on content type (TSDemuxer, AACDemuxer, ...)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _errors = require('../errors');

var _decrypter = require('../crypt/decrypter');

var _decrypter2 = _interopRequireDefault(_decrypter);

var _aacdemuxer = require('../demux/aacdemuxer');

var _aacdemuxer2 = _interopRequireDefault(_aacdemuxer);

var _mp4demuxer = require('../demux/mp4demuxer');

var _mp4demuxer2 = _interopRequireDefault(_mp4demuxer);

var _tsdemuxer = require('../demux/tsdemuxer');

var _tsdemuxer2 = _interopRequireDefault(_tsdemuxer);

var _mp3demuxer = require('../demux/mp3demuxer');

var _mp3demuxer2 = _interopRequireDefault(_mp3demuxer);

var _mp4Remuxer = require('../remux/mp4-remuxer');

var _mp4Remuxer2 = _interopRequireDefault(_mp4Remuxer);

var _passthroughRemuxer = require('../remux/passthrough-remuxer');

var _passthroughRemuxer2 = _interopRequireDefault(_passthroughRemuxer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var DemuxerInline = function () {
  function DemuxerInline(observer, typeSupported, config, vendor) {
    _classCallCheck(this, DemuxerInline);

    this.observer = observer;
    this.typeSupported = typeSupported;
    this.config = config;
    this.vendor = vendor;
  }

  _createClass(DemuxerInline, [{
    key: 'destroy',
    value: function destroy() {
      var demuxer = this.demuxer;
      if (demuxer) {
        demuxer.destroy();
      }
    }
  }, {
    key: 'push',
    value: function push(data, decryptdata, initSegment, audioCodec, videoCodec, timeOffset, discontinuity, trackSwitch, contiguous, duration, accurateTimeOffset, defaultInitPTS) {
      if (data.byteLength > 0 && decryptdata != null && decryptdata.key != null && decryptdata.method === 'AES-128') {
        var decrypter = this.decrypter;
        if (decrypter == null) {
          decrypter = this.decrypter = new _decrypter2.default(this.observer, this.config);
        }
        var localthis = this;
        // performance.now() not available on WebWorker, at least on Safari Desktop
        var startTime;
        try {
          startTime = performance.now();
        } catch (error) {
          startTime = Date.now();
        }
        decrypter.decrypt(data, decryptdata.key.buffer, decryptdata.iv.buffer, function (decryptedData) {
          var endTime;
          try {
            endTime = performance.now();
          } catch (error) {
            endTime = Date.now();
          }
          localthis.observer.trigger(_events2.default.FRAG_DECRYPTED, { stats: { tstart: startTime, tdecrypt: endTime } });
          localthis.pushDecrypted(new Uint8Array(decryptedData), decryptdata, new Uint8Array(initSegment), audioCodec, videoCodec, timeOffset, discontinuity, trackSwitch, contiguous, duration, accurateTimeOffset, defaultInitPTS);
        });
      } else {
        this.pushDecrypted(new Uint8Array(data), decryptdata, new Uint8Array(initSegment), audioCodec, videoCodec, timeOffset, discontinuity, trackSwitch, contiguous, duration, accurateTimeOffset, defaultInitPTS);
      }
    }
  }, {
    key: 'pushDecrypted',
    value: function pushDecrypted(data, decryptdata, initSegment, audioCodec, videoCodec, timeOffset, discontinuity, trackSwitch, contiguous, duration, accurateTimeOffset, defaultInitPTS) {
      var demuxer = this.demuxer;
      if (!demuxer ||
      // in case of continuity change, we might switch from content type (AAC container to TS container for example)
      // so let's check that current demuxer is still valid
      discontinuity && !this.probe(data)) {
        var observer = this.observer;
        var typeSupported = this.typeSupported;
        var config = this.config;
        // probing order is AAC/MP3/TS/MP4
        var muxConfig = [{ demux: _aacdemuxer2.default, remux: _mp4Remuxer2.default }, { demux: _mp3demuxer2.default, remux: _mp4Remuxer2.default }, { demux: _tsdemuxer2.default, remux: _mp4Remuxer2.default }, { demux: _mp4demuxer2.default, remux: _passthroughRemuxer2.default }];

        // probe for content type
        for (var i = 0, len = muxConfig.length; i < len; i++) {
          var mux = muxConfig[i];
          var probe = mux.demux.probe;
          if (probe(data)) {
            var _remuxer = this.remuxer = new mux.remux(observer, config, typeSupported, this.vendor);
            demuxer = new mux.demux(observer, _remuxer, config, typeSupported);
            this.probe = probe;
            break;
          }
        }
        if (!demuxer) {
          observer.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.FRAG_PARSING_ERROR, fatal: true, reason: 'no demux matching with content found' });
          return;
        }
        this.demuxer = demuxer;
      }
      var remuxer = this.remuxer;

      if (discontinuity || trackSwitch) {
        demuxer.resetInitSegment(initSegment, audioCodec, videoCodec, duration);
        remuxer.resetInitSegment();
      }
      if (discontinuity) {
        demuxer.resetTimeStamp(defaultInitPTS);
        remuxer.resetTimeStamp(defaultInitPTS);
      }
      if (typeof demuxer.setDecryptData === 'function') {
        demuxer.setDecryptData(decryptdata);
      }
      demuxer.append(data, timeOffset, contiguous, accurateTimeOffset);
    }
  }]);

  return DemuxerInline;
}();

exports.default = DemuxerInline;

},{"../crypt/decrypter":19,"../demux/aacdemuxer":21,"../demux/mp3demuxer":28,"../demux/mp4demuxer":29,"../demux/tsdemuxer":32,"../errors":33,"../events":35,"../remux/mp4-remuxer":45,"../remux/passthrough-remuxer":46}],24:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _demuxerInline = require('../demux/demuxer-inline');

var _demuxerInline2 = _interopRequireDefault(_demuxerInline);

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _logger = require('../utils/logger');

var _events3 = require('events');

var _events4 = _interopRequireDefault(_events3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* demuxer web worker.
 *  - listen to worker message, and trigger DemuxerInline upon reception of Fragments.
 *  - provides MP4 Boxes back to main thread using [transferable objects](https://developers.google.com/web/updates/2011/12/Transferable-Objects-Lightning-Fast) in order to minimize message passing overhead.
 */

var DemuxerWorker = function DemuxerWorker(self) {
  // observer setup
  var observer = new _events4.default();
  observer.trigger = function trigger(event) {
    for (var _len = arguments.length, data = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      data[_key - 1] = arguments[_key];
    }

    observer.emit.apply(observer, [event, event].concat(data));
  };

  observer.off = function off(event) {
    for (var _len2 = arguments.length, data = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      data[_key2 - 1] = arguments[_key2];
    }

    observer.removeListener.apply(observer, [event].concat(data));
  };

  var forwardMessage = function forwardMessage(ev, data) {
    self.postMessage({ event: ev, data: data });
  };

  self.addEventListener('message', function (ev) {
    var data = ev.data;
    //console.log('demuxer cmd:' + data.cmd);
    switch (data.cmd) {
      case 'init':
        var config = JSON.parse(data.config);
        self.demuxer = new _demuxerInline2.default(observer, data.typeSupported, config, data.vendor);
        try {
          (0, _logger.enableLogs)(config.debug === true);
        } catch (err) {
          console.warn('demuxerWorker: unable to enable logs');
        }
        // signal end of worker init
        forwardMessage('init', null);
        break;
      case 'demux':
        self.demuxer.push(data.data, data.decryptdata, data.initSegment, data.audioCodec, data.videoCodec, data.timeOffset, data.discontinuity, data.trackSwitch, data.contiguous, data.duration, data.accurateTimeOffset, data.defaultInitPTS);
        break;
      default:
        break;
    }
  });

  // forward events to main thread
  observer.on(_events2.default.FRAG_DECRYPTED, forwardMessage);
  observer.on(_events2.default.FRAG_PARSING_INIT_SEGMENT, forwardMessage);
  observer.on(_events2.default.FRAG_PARSED, forwardMessage);
  observer.on(_events2.default.ERROR, forwardMessage);
  observer.on(_events2.default.FRAG_PARSING_METADATA, forwardMessage);
  observer.on(_events2.default.FRAG_PARSING_USERDATA, forwardMessage);
  observer.on(_events2.default.INIT_PTS_FOUND, forwardMessage);

  // special case for FRAG_PARSING_DATA: pass data1/data2 as transferable object (no copy)
  observer.on(_events2.default.FRAG_PARSING_DATA, function (ev, data) {
    var transferable = [];
    var message = { event: ev, data: data };
    if (data.data1) {
      message.data1 = data.data1.buffer;
      transferable.push(data.data1.buffer);
      delete data.data1;
    }
    if (data.data2) {
      message.data2 = data.data2.buffer;
      transferable.push(data.data2.buffer);
      delete data.data2;
    }
    self.postMessage(message, transferable);
  });
};

exports.default = DemuxerWorker;

},{"../demux/demuxer-inline":23,"../events":35,"../utils/logger":54,"events":1}],25:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _demuxerInline = require('../demux/demuxer-inline');

var _demuxerInline2 = _interopRequireDefault(_demuxerInline);

var _demuxerWorker = require('../demux/demuxer-worker');

var _demuxerWorker2 = _interopRequireDefault(_demuxerWorker);

var _logger = require('../utils/logger');

var _errors = require('../errors');

var _events3 = require('events');

var _events4 = _interopRequireDefault(_events3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Demuxer = function () {
  function Demuxer(hls, id) {
    _classCallCheck(this, Demuxer);

    this.hls = hls;
    this.id = id;
    // observer setup
    var observer = this.observer = new _events4.default();
    var config = hls.config;
    observer.trigger = function trigger(event) {
      for (var _len = arguments.length, data = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        data[_key - 1] = arguments[_key];
      }

      observer.emit.apply(observer, [event, event].concat(data));
    };

    observer.off = function off(event) {
      for (var _len2 = arguments.length, data = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        data[_key2 - 1] = arguments[_key2];
      }

      observer.removeListener.apply(observer, [event].concat(data));
    };

    var forwardMessage = function (ev, data) {
      data = data || {};
      data.frag = this.frag;
      data.id = this.id;
      hls.trigger(ev, data);
    }.bind(this);

    // forward events to main thread
    observer.on(_events2.default.FRAG_DECRYPTED, forwardMessage);
    observer.on(_events2.default.FRAG_PARSING_INIT_SEGMENT, forwardMessage);
    observer.on(_events2.default.FRAG_PARSING_DATA, forwardMessage);
    observer.on(_events2.default.FRAG_PARSED, forwardMessage);
    observer.on(_events2.default.ERROR, forwardMessage);
    observer.on(_events2.default.FRAG_PARSING_METADATA, forwardMessage);
    observer.on(_events2.default.FRAG_PARSING_USERDATA, forwardMessage);
    observer.on(_events2.default.INIT_PTS_FOUND, forwardMessage);

    var typeSupported = {
      mp4: MediaSource.isTypeSupported('video/mp4'),
      mpeg: MediaSource.isTypeSupported('audio/mpeg'),
      mp3: MediaSource.isTypeSupported('audio/mp4; codecs="mp3"')
    };
    // navigator.vendor is not always available in Web Worker
    // refer to https://developer.mozilla.org/en-US/docs/Web/API/WorkerGlobalScope/navigator
    var vendor = navigator.vendor;
    if (config.enableWorker && typeof Worker !== 'undefined') {
      _logger.logger.log('demuxing in webworker');
      var w = void 0;
      try {
        var work = require('webworkify');
        w = this.w = work(_demuxerWorker2.default);
        this.onwmsg = this.onWorkerMessage.bind(this);
        w.addEventListener('message', this.onwmsg);
        w.onerror = function (event) {
          hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.OTHER_ERROR, details: _errors.ErrorDetails.INTERNAL_EXCEPTION, fatal: true, event: 'demuxerWorker', err: { message: event.message + ' (' + event.filename + ':' + event.lineno + ')' } });
        };
        w.postMessage({ cmd: 'init', typeSupported: typeSupported, vendor: vendor, id: id, config: JSON.stringify(config) });
      } catch (err) {
        _logger.logger.error('error while initializing DemuxerWorker, fallback on DemuxerInline');
        if (w) {
          // revoke the Object URL that was used to create demuxer worker, so as not to leak it
          URL.revokeObjectURL(w.objectURL);
        }
        this.demuxer = new _demuxerInline2.default(observer, typeSupported, config, vendor);
        this.w = undefined;
      }
    } else {
      this.demuxer = new _demuxerInline2.default(observer, typeSupported, config, vendor);
    }
  }

  _createClass(Demuxer, [{
    key: 'destroy',
    value: function destroy() {
      var w = this.w;
      if (w) {
        w.removeEventListener('message', this.onwmsg);
        w.terminate();
        this.w = null;
      } else {
        var demuxer = this.demuxer;
        if (demuxer) {
          demuxer.destroy();
          this.demuxer = null;
        }
      }
      var observer = this.observer;
      if (observer) {
        observer.removeAllListeners();
        this.observer = null;
      }
    }
  }, {
    key: 'push',
    value: function push(data, initSegment, audioCodec, videoCodec, frag, duration, accurateTimeOffset, defaultInitPTS) {
      var w = this.w;
      var timeOffset = !isNaN(frag.startDTS) ? frag.startDTS : frag.start;
      var decryptdata = frag.decryptdata;
      var lastFrag = this.frag;
      var discontinuity = !(lastFrag && frag.cc === lastFrag.cc);
      var trackSwitch = !(lastFrag && frag.level === lastFrag.level);
      var nextSN = lastFrag && frag.sn === lastFrag.sn + 1;
      var contiguous = !trackSwitch && nextSN;
      if (discontinuity) {
        _logger.logger.log(this.id + ':discontinuity detected');
      }
      if (trackSwitch) {
        _logger.logger.log(this.id + ':switch detected');
      }
      this.frag = frag;
      if (w) {
        // post fragment payload as transferable objects (no copy)
        w.postMessage({ cmd: 'demux', data: data, decryptdata: decryptdata, initSegment: initSegment, audioCodec: audioCodec, videoCodec: videoCodec, timeOffset: timeOffset, discontinuity: discontinuity, trackSwitch: trackSwitch, contiguous: contiguous, duration: duration, accurateTimeOffset: accurateTimeOffset, defaultInitPTS: defaultInitPTS }, [data]);
      } else {
        var demuxer = this.demuxer;
        if (demuxer) {
          demuxer.push(data, decryptdata, initSegment, audioCodec, videoCodec, timeOffset, discontinuity, trackSwitch, contiguous, duration, accurateTimeOffset, defaultInitPTS);
        }
      }
    }
  }, {
    key: 'onWorkerMessage',
    value: function onWorkerMessage(ev) {
      var data = ev.data,
          hls = this.hls;
      //console.log('onWorkerMessage:' + data.event);
      switch (data.event) {
        case 'init':
          // revoke the Object URL that was used to create demuxer worker, so as not to leak it
          URL.revokeObjectURL(this.w.objectURL);
          break;
        // special case for FRAG_PARSING_DATA: data1 and data2 are transferable objects
        case _events2.default.FRAG_PARSING_DATA:
          data.data.data1 = new Uint8Array(data.data1);
          if (data.data2) {
            data.data.data2 = new Uint8Array(data.data2);
          }
        /* falls through */
        default:
          data.data = data.data || {};
          data.data.frag = this.frag;
          data.data.id = this.id;
          hls.trigger(data.event, data.data);
          break;
      }
    }
  }]);

  return Demuxer;
}();

exports.default = Demuxer;

},{"../demux/demuxer-inline":23,"../demux/demuxer-worker":24,"../errors":33,"../events":35,"../utils/logger":54,"events":1,"webworkify":3}],26:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Parser for exponential Golomb codes, a variable-bitwidth number encoding scheme used by h264.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */

var _logger = require('../utils/logger');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ExpGolomb = function () {
  function ExpGolomb(data) {
    _classCallCheck(this, ExpGolomb);

    this.data = data;
    // the number of bytes left to examine in this.data
    this.bytesAvailable = data.byteLength;
    // the current word being examined
    this.word = 0; // :uint
    // the number of bits left to examine in the current word
    this.bitsAvailable = 0; // :uint
  }

  // ():void


  _createClass(ExpGolomb, [{
    key: 'loadWord',
    value: function loadWord() {
      var data = this.data,
          bytesAvailable = this.bytesAvailable,
          position = data.byteLength - bytesAvailable,
          workingBytes = new Uint8Array(4),
          availableBytes = Math.min(4, bytesAvailable);
      if (availableBytes === 0) {
        throw new Error('no bytes available');
      }
      workingBytes.set(data.subarray(position, position + availableBytes));
      this.word = new DataView(workingBytes.buffer).getUint32(0);
      // track the amount of this.data that has been processed
      this.bitsAvailable = availableBytes * 8;
      this.bytesAvailable -= availableBytes;
    }

    // (count:int):void

  }, {
    key: 'skipBits',
    value: function skipBits(count) {
      var skipBytes; // :int
      if (this.bitsAvailable > count) {
        this.word <<= count;
        this.bitsAvailable -= count;
      } else {
        count -= this.bitsAvailable;
        skipBytes = count >> 3;
        count -= skipBytes >> 3;
        this.bytesAvailable -= skipBytes;
        this.loadWord();
        this.word <<= count;
        this.bitsAvailable -= count;
      }
    }

    // (size:int):uint

  }, {
    key: 'readBits',
    value: function readBits(size) {
      var bits = Math.min(this.bitsAvailable, size),
          // :uint
      valu = this.word >>> 32 - bits; // :uint
      if (size > 32) {
        _logger.logger.error('Cannot read more than 32 bits at a time');
      }
      this.bitsAvailable -= bits;
      if (this.bitsAvailable > 0) {
        this.word <<= bits;
      } else if (this.bytesAvailable > 0) {
        this.loadWord();
      }
      bits = size - bits;
      if (bits > 0 && this.bitsAvailable) {
        return valu << bits | this.readBits(bits);
      } else {
        return valu;
      }
    }

    // ():uint

  }, {
    key: 'skipLZ',
    value: function skipLZ() {
      var leadingZeroCount; // :uint
      for (leadingZeroCount = 0; leadingZeroCount < this.bitsAvailable; ++leadingZeroCount) {
        if (0 !== (this.word & 0x80000000 >>> leadingZeroCount)) {
          // the first bit of working word is 1
          this.word <<= leadingZeroCount;
          this.bitsAvailable -= leadingZeroCount;
          return leadingZeroCount;
        }
      }
      // we exhausted word and still have not found a 1
      this.loadWord();
      return leadingZeroCount + this.skipLZ();
    }

    // ():void

  }, {
    key: 'skipUEG',
    value: function skipUEG() {
      this.skipBits(1 + this.skipLZ());
    }

    // ():void

  }, {
    key: 'skipEG',
    value: function skipEG() {
      this.skipBits(1 + this.skipLZ());
    }

    // ():uint

  }, {
    key: 'readUEG',
    value: function readUEG() {
      var clz = this.skipLZ(); // :uint
      return this.readBits(clz + 1) - 1;
    }

    // ():int

  }, {
    key: 'readEG',
    value: function readEG() {
      var valu = this.readUEG(); // :int
      if (0x01 & valu) {
        // the number is odd if the low order bit is set
        return 1 + valu >>> 1; // add 1 to make it even, and divide by 2
      } else {
        return -1 * (valu >>> 1); // divide by two then make it negative
      }
    }

    // Some convenience functions
    // :Boolean

  }, {
    key: 'readBoolean',
    value: function readBoolean() {
      return 1 === this.readBits(1);
    }

    // ():int

  }, {
    key: 'readUByte',
    value: function readUByte() {
      return this.readBits(8);
    }

    // ():int

  }, {
    key: 'readUShort',
    value: function readUShort() {
      return this.readBits(16);
    }
    // ():int

  }, {
    key: 'readUInt',
    value: function readUInt() {
      return this.readBits(32);
    }

    /**
     * Advance the ExpGolomb decoder past a scaling list. The scaling
     * list is optionally transmitted as part of a sequence parameter
     * set and is not relevant to transmuxing.
     * @param count {number} the number of entries in this scaling list
     * @see Recommendation ITU-T H.264, Section 7.3.2.1.1.1
     */

  }, {
    key: 'skipScalingList',
    value: function skipScalingList(count) {
      var lastScale = 8,
          nextScale = 8,
          j,
          deltaScale;
      for (j = 0; j < count; j++) {
        if (nextScale !== 0) {
          deltaScale = this.readEG();
          nextScale = (lastScale + deltaScale + 256) % 256;
        }
        lastScale = nextScale === 0 ? lastScale : nextScale;
      }
    }

    /**
     * Read a sequence parameter set and return some interesting video
     * properties. A sequence parameter set is the H264 metadata that
     * describes the properties of upcoming video frames.
     * @param data {Uint8Array} the bytes of a sequence parameter set
     * @return {object} an object with configuration parsed from the
     * sequence parameter set, including the dimensions of the
     * associated video frames.
     */

  }, {
    key: 'readSPS',
    value: function readSPS() {
      var frameCropLeftOffset = 0,
          frameCropRightOffset = 0,
          frameCropTopOffset = 0,
          frameCropBottomOffset = 0,
          profileIdc,
          profileCompat,
          levelIdc,
          numRefFramesInPicOrderCntCycle,
          picWidthInMbsMinus1,
          picHeightInMapUnitsMinus1,
          frameMbsOnlyFlag,
          scalingListCount,
          i,
          readUByte = this.readUByte.bind(this),
          readBits = this.readBits.bind(this),
          readUEG = this.readUEG.bind(this),
          readBoolean = this.readBoolean.bind(this),
          skipBits = this.skipBits.bind(this),
          skipEG = this.skipEG.bind(this),
          skipUEG = this.skipUEG.bind(this),
          skipScalingList = this.skipScalingList.bind(this);

      readUByte();
      profileIdc = readUByte(); // profile_idc
      profileCompat = readBits(5); // constraint_set[0-4]_flag, u(5)
      skipBits(3); // reserved_zero_3bits u(3),
      levelIdc = readUByte(); //level_idc u(8)
      skipUEG(); // seq_parameter_set_id
      // some profiles have more optional data we don't need
      if (profileIdc === 100 || profileIdc === 110 || profileIdc === 122 || profileIdc === 244 || profileIdc === 44 || profileIdc === 83 || profileIdc === 86 || profileIdc === 118 || profileIdc === 128) {
        var chromaFormatIdc = readUEG();
        if (chromaFormatIdc === 3) {
          skipBits(1); // separate_colour_plane_flag
        }
        skipUEG(); // bit_depth_luma_minus8
        skipUEG(); // bit_depth_chroma_minus8
        skipBits(1); // qpprime_y_zero_transform_bypass_flag
        if (readBoolean()) {
          // seq_scaling_matrix_present_flag
          scalingListCount = chromaFormatIdc !== 3 ? 8 : 12;
          for (i = 0; i < scalingListCount; i++) {
            if (readBoolean()) {
              // seq_scaling_list_present_flag[ i ]
              if (i < 6) {
                skipScalingList(16);
              } else {
                skipScalingList(64);
              }
            }
          }
        }
      }
      skipUEG(); // log2_max_frame_num_minus4
      var picOrderCntType = readUEG();
      if (picOrderCntType === 0) {
        readUEG(); //log2_max_pic_order_cnt_lsb_minus4
      } else if (picOrderCntType === 1) {
        skipBits(1); // delta_pic_order_always_zero_flag
        skipEG(); // offset_for_non_ref_pic
        skipEG(); // offset_for_top_to_bottom_field
        numRefFramesInPicOrderCntCycle = readUEG();
        for (i = 0; i < numRefFramesInPicOrderCntCycle; i++) {
          skipEG(); // offset_for_ref_frame[ i ]
        }
      }
      skipUEG(); // max_num_ref_frames
      skipBits(1); // gaps_in_frame_num_value_allowed_flag
      picWidthInMbsMinus1 = readUEG();
      picHeightInMapUnitsMinus1 = readUEG();
      frameMbsOnlyFlag = readBits(1);
      if (frameMbsOnlyFlag === 0) {
        skipBits(1); // mb_adaptive_frame_field_flag
      }
      skipBits(1); // direct_8x8_inference_flag
      if (readBoolean()) {
        // frame_cropping_flag
        frameCropLeftOffset = readUEG();
        frameCropRightOffset = readUEG();
        frameCropTopOffset = readUEG();
        frameCropBottomOffset = readUEG();
      }
      var pixelRatio = [1, 1];
      if (readBoolean()) {
        // vui_parameters_present_flag
        if (readBoolean()) {
          // aspect_ratio_info_present_flag
          var aspectRatioIdc = readUByte();
          switch (aspectRatioIdc) {
            case 1:
              pixelRatio = [1, 1];break;
            case 2:
              pixelRatio = [12, 11];break;
            case 3:
              pixelRatio = [10, 11];break;
            case 4:
              pixelRatio = [16, 11];break;
            case 5:
              pixelRatio = [40, 33];break;
            case 6:
              pixelRatio = [24, 11];break;
            case 7:
              pixelRatio = [20, 11];break;
            case 8:
              pixelRatio = [32, 11];break;
            case 9:
              pixelRatio = [80, 33];break;
            case 10:
              pixelRatio = [18, 11];break;
            case 11:
              pixelRatio = [15, 11];break;
            case 12:
              pixelRatio = [64, 33];break;
            case 13:
              pixelRatio = [160, 99];break;
            case 14:
              pixelRatio = [4, 3];break;
            case 15:
              pixelRatio = [3, 2];break;
            case 16:
              pixelRatio = [2, 1];break;
            case 255:
              {
                pixelRatio = [readUByte() << 8 | readUByte(), readUByte() << 8 | readUByte()];
                break;
              }
          }
        }
      }
      return {
        width: Math.ceil((picWidthInMbsMinus1 + 1) * 16 - frameCropLeftOffset * 2 - frameCropRightOffset * 2),
        height: (2 - frameMbsOnlyFlag) * (picHeightInMapUnitsMinus1 + 1) * 16 - (frameMbsOnlyFlag ? 2 : 4) * (frameCropTopOffset + frameCropBottomOffset),
        pixelRatio: pixelRatio
      };
    }
  }, {
    key: 'readSliceType',
    value: function readSliceType() {
      // skip NALu type
      this.readUByte();
      // discard first_mb_in_slice
      this.readUEG();
      // return slice_type
      return this.readUEG();
    }
  }]);

  return ExpGolomb;
}();

exports.default = ExpGolomb;

},{"../utils/logger":54}],27:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * ID3 parser
 */
var ID3 = function () {
  function ID3() {
    _classCallCheck(this, ID3);
  }

  _createClass(ID3, null, [{
    key: 'isHeader',

    /**
     * Returns true if an ID3 header can be found at offset in data
     * @param {Uint8Array} data - The data to search in
     * @param {number} offset - The offset at which to start searching
     * @return {boolean} - True if an ID3 header is found
     */
    value: function isHeader(data, offset) {
      /*
      * http://id3.org/id3v2.3.0
      * [0]     = 'I'
      * [1]     = 'D'
      * [2]     = '3'
      * [3,4]   = {Version}
      * [5]     = {Flags}
      * [6-9]   = {ID3 Size}
      *
      * An ID3v2 tag can be detected with the following pattern:
      *  $49 44 33 yy yy xx zz zz zz zz
      * Where yy is less than $FF, xx is the 'flags' byte and zz is less than $80
      */
      if (offset + 10 <= data.length) {
        //look for 'ID3' identifier
        if (data[offset] === 0x49 && data[offset + 1] === 0x44 && data[offset + 2] === 0x33) {
          //check version is within range
          if (data[offset + 3] < 0xFF && data[offset + 4] < 0xFF) {
            //check size is within range
            if (data[offset + 6] < 0x80 && data[offset + 7] < 0x80 && data[offset + 8] < 0x80 && data[offset + 9] < 0x80) {
              return true;
            }
          }
        }
      }

      return false;
    }

    /**
     * Returns true if an ID3 footer can be found at offset in data
     * @param {Uint8Array} data - The data to search in
     * @param {number} offset - The offset at which to start searching
     * @return {boolean} - True if an ID3 footer is found
     */

  }, {
    key: 'isFooter',
    value: function isFooter(data, offset) {
      /*
      * The footer is a copy of the header, but with a different identifier
      */
      if (offset + 10 <= data.length) {
        //look for '3DI' identifier
        if (data[offset] === 0x33 && data[offset + 1] === 0x44 && data[offset + 2] === 0x49) {
          //check version is within range
          if (data[offset + 3] < 0xFF && data[offset + 4] < 0xFF) {
            //check size is within range
            if (data[offset + 6] < 0x80 && data[offset + 7] < 0x80 && data[offset + 8] < 0x80 && data[offset + 9] < 0x80) {
              return true;
            }
          }
        }
      }

      return false;
    }

    /**
     * Returns any adjacent ID3 tags found in data starting at offset, as one block of data
     * @param {Uint8Array} data - The data to search in
     * @param {number} offset - The offset at which to start searching
     * @return {Uint8Array} - The block of data containing any ID3 tags found
     */

  }, {
    key: 'getID3Data',
    value: function getID3Data(data, offset) {
      var front = offset;
      var length = 0;

      while (ID3.isHeader(data, offset)) {
        //ID3 header is 10 bytes
        length += 10;

        var size = ID3._readSize(data, offset + 6);
        length += size;

        if (ID3.isFooter(data, offset + 10)) {
          //ID3 footer is 10 bytes
          length += 10;
        }

        offset += length;
      }

      if (length > 0) {
        return data.subarray(front, front + length);
      }

      return undefined;
    }
  }, {
    key: '_readSize',
    value: function _readSize(data, offset) {
      var size = 0;
      size = (data[offset] & 0x7f) << 21;
      size |= (data[offset + 1] & 0x7f) << 14;
      size |= (data[offset + 2] & 0x7f) << 7;
      size |= data[offset + 3] & 0x7f;
      return size;
    }

    /**
     * Searches for the Elementary Stream timestamp found in the ID3 data chunk
     * @param {Uint8Array} data - Block of data containing one or more ID3 tags
     * @return {number} - The timestamp
     */

  }, {
    key: 'getTimeStamp',
    value: function getTimeStamp(data) {
      var frames = ID3.getID3Frames(data);
      for (var i = 0; i < frames.length; i++) {
        var frame = frames[i];
        if (ID3.isTimeStampFrame(frame)) {
          return ID3._readTimeStamp(frame);
        }
      }

      return undefined;
    }

    /**
     * Returns true if the ID3 frame is an Elementary Stream timestamp frame
     * @param {ID3 frame} frame
     */

  }, {
    key: 'isTimeStampFrame',
    value: function isTimeStampFrame(frame) {
      return frame && frame.key === 'PRIV' && frame.info === 'com.apple.streaming.transportStreamTimestamp';
    }
  }, {
    key: '_getFrameData',
    value: function _getFrameData(data) {
      /*
      Frame ID       $xx xx xx xx (four characters)
      Size           $xx xx xx xx
      Flags          $xx xx
      */
      var type = String.fromCharCode(data[0], data[1], data[2], data[3]);
      var size = ID3._readSize(data, 4);

      //skip frame id, size, and flags
      var offset = 10;

      return { type: type, size: size, data: data.subarray(offset, offset + size) };
    }

    /**
     * Returns an array of ID3 frames found in all the ID3 tags in the id3Data
     * @param {Uint8Array} id3Data - The ID3 data containing one or more ID3 tags
     * @return {ID3 frame[]} - Array of ID3 frame objects
     */

  }, {
    key: 'getID3Frames',
    value: function getID3Frames(id3Data) {
      var offset = 0;
      var frames = [];

      while (ID3.isHeader(id3Data, offset)) {
        var size = ID3._readSize(id3Data, offset + 6);
        //skip past ID3 header
        offset += 10;
        var end = offset + size;
        //loop through frames in the ID3 tag
        while (offset + 8 < end) {
          var frameData = ID3._getFrameData(id3Data.subarray(offset));
          var frame = ID3._decodeFrame(frameData);
          if (frame) {
            frames.push(frame);
          }
          //skip frame header and frame data
          offset += frameData.size + 10;
        }

        if (ID3.isFooter(id3Data, offset)) {
          offset += 10;
        }
      }

      return frames;
    }
  }, {
    key: '_decodeFrame',
    value: function _decodeFrame(frame) {
      if (frame.type === 'PRIV') {
        return ID3._decodePrivFrame(frame);
      } else if (frame.type[0] === 'T') {
        return ID3._decodeTextFrame(frame);
      } else if (frame.type[0] === 'W') {
        return ID3._decodeURLFrame(frame);
      }

      return undefined;
    }
  }, {
    key: '_readTimeStamp',
    value: function _readTimeStamp(timeStampFrame) {
      if (timeStampFrame.data.byteLength === 8) {
        var data = new Uint8Array(timeStampFrame.data);
        // timestamp is 33 bit expressed as a big-endian eight-octet number,
        // with the upper 31 bits set to zero.
        var pts33Bit = data[3] & 0x1;
        var timestamp = (data[4] << 23) + (data[5] << 15) + (data[6] << 7) + data[7];
        timestamp /= 45;

        if (pts33Bit) {
          timestamp += 47721858.84; // 2^32 / 90
        }

        return Math.round(timestamp);
      }

      return undefined;
    }
  }, {
    key: '_decodePrivFrame',
    value: function _decodePrivFrame(frame) {
      /*
      Format: <text string>\0<binary data>
      */
      if (frame.size < 2) {
        return undefined;
      }

      var owner = ID3._utf8ArrayToStr(frame.data);
      var privateData = new Uint8Array(frame.data.subarray(owner.length + 1));

      return { key: frame.type, info: owner, data: privateData.buffer };
    }
  }, {
    key: '_decodeTextFrame',
    value: function _decodeTextFrame(frame) {
      if (frame.size < 2) {
        return undefined;
      }

      if (frame.type === 'TXXX') {
        /*
        Format:
        [0]   = {Text Encoding}
        [1-?] = {Description}\0{Value}
        */
        var index = 1;
        var description = ID3._utf8ArrayToStr(frame.data.subarray(index));

        index += description.length + 1;
        var value = ID3._utf8ArrayToStr(frame.data.subarray(index));

        return { key: frame.type, info: description, data: value };
      } else {
        /*
        Format:
        [0]   = {Text Encoding}
        [1-?] = {Value}
        */
        var text = ID3._utf8ArrayToStr(frame.data.subarray(1));
        return { key: frame.type, data: text };
      }
    }
  }, {
    key: '_decodeURLFrame',
    value: function _decodeURLFrame(frame) {
      if (frame.type === 'WXXX') {
        /*
        Format:
        [0]   = {Text Encoding}
        [1-?] = {Description}\0{URL}
        */
        if (frame.size < 2) {
          return undefined;
        }

        var index = 1;
        var description = ID3._utf8ArrayToStr(frame.data.subarray(index));

        index += description.length + 1;
        var value = ID3._utf8ArrayToStr(frame.data.subarray(index));

        return { key: frame.type, info: description, data: value };
      } else {
        /*
        Format:
        [0-?] = {URL}
        */
        var url = ID3._utf8ArrayToStr(frame.data);
        return { key: frame.type, data: url };
      }
    }

    // http://stackoverflow.com/questions/8936984/uint8array-to-string-in-javascript/22373197
    // http://www.onicos.com/staff/iz/amuse/javascript/expert/utf.txt
    /* utf.js - UTF-8 <=> UTF-16 convertion
     *
     * Copyright (C) 1999 Masanao Izumo <iz@onicos.co.jp>
     * Version: 1.0
     * LastModified: Dec 25 1999
     * This library is free.  You can redistribute it and/or modify it.
     */

  }, {
    key: '_utf8ArrayToStr',
    value: function _utf8ArrayToStr(array) {

      var char2 = void 0;
      var char3 = void 0;
      var out = '';
      var i = 0;
      var length = array.length;

      while (i < length) {
        var c = array[i++];
        switch (c >> 4) {
          case 0:
            return out;
          case 1:case 2:case 3:case 4:case 5:case 6:case 7:
            // 0xxxxxxx
            out += String.fromCharCode(c);
            break;
          case 12:case 13:
            // 110x xxxx   10xx xxxx
            char2 = array[i++];
            out += String.fromCharCode((c & 0x1F) << 6 | char2 & 0x3F);
            break;
          case 14:
            // 1110 xxxx  10xx xxxx  10xx xxxx
            char2 = array[i++];
            char3 = array[i++];
            out += String.fromCharCode((c & 0x0F) << 12 | (char2 & 0x3F) << 6 | (char3 & 0x3F) << 0);
            break;
        }
      }

      return out;
    }
  }]);

  return ID3;
}();

exports.default = ID3;

},{}],28:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * MP3 demuxer
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */


var _id = require('../demux/id3');

var _id2 = _interopRequireDefault(_id);

var _logger = require('../utils/logger');

var _mpegaudio = require('./mpegaudio');

var _mpegaudio2 = _interopRequireDefault(_mpegaudio);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var MP3Demuxer = function () {
  function MP3Demuxer(observer, remuxer, config) {
    _classCallCheck(this, MP3Demuxer);

    this.observer = observer;
    this.config = config;
    this.remuxer = remuxer;
  }

  _createClass(MP3Demuxer, [{
    key: 'resetInitSegment',
    value: function resetInitSegment(initSegment, audioCodec, videoCodec, duration) {
      this._audioTrack = { container: 'audio/mpeg', type: 'audio', id: -1, sequenceNumber: 0, isAAC: false, samples: [], len: 0, manifestCodec: audioCodec, duration: duration, inputTimeScale: 90000 };
    }
  }, {
    key: 'resetTimeStamp',
    value: function resetTimeStamp() {}
  }, {
    key: 'append',


    // feed incoming data to the front of the parsing pipeline
    value: function append(data, timeOffset, contiguous, accurateTimeOffset) {
      var id3Data = _id2.default.getID3Data(data, 0);
      var pts = 90 * _id2.default.getTimeStamp(id3Data);
      var offset = id3Data.length;
      var length = data.length;
      var frameIndex = 0,
          stamp = 0;
      var track = this._audioTrack;

      var id3Samples = [{ pts: pts, dts: pts, data: id3Data }];

      while (offset < length) {
        if (_mpegaudio2.default.isHeader(data, offset)) {
          var frame = _mpegaudio2.default.appendFrame(track, data, offset, pts, frameIndex);
          if (frame) {
            offset += frame.length;
            stamp = frame.sample.pts;
            frameIndex++;
          } else {
            //logger.log('Unable to parse Mpeg audio frame');
            break;
          }
        } else if (_id2.default.isHeader(data, offset)) {
          id3Data = _id2.default.getID3Data(data, offset);
          id3Samples.push({ pts: stamp, dts: stamp, data: id3Data });
          offset += id3Data.length;
        } else {
          //nothing found, keep looking
          offset++;
        }
      }

      this.remuxer.remux(track, { samples: [] }, { samples: id3Samples, inputTimeScale: 90000 }, { samples: [] }, timeOffset, contiguous, accurateTimeOffset);
    }
  }, {
    key: 'destroy',
    value: function destroy() {}
  }], [{
    key: 'probe',
    value: function probe(data) {
      // check if data contains ID3 timestamp and MPEG sync word
      var offset, length;
      var id3Data = _id2.default.getID3Data(data, 0);
      if (id3Data && _id2.default.getTimeStamp(id3Data) !== undefined) {
        // Look for MPEG header | 1111 1111 | 111X XYZX | where X can be either 0 or 1 and Y or Z should be 1
        // Layer bits (position 14 and 15) in header should be always different from 0 (Layer I or Layer II or Layer III)
        // More info http://www.mp3-tech.org/programmer/frame_header.html
        for (offset = id3Data.length, length = Math.min(data.length - 1, offset + 100); offset < length; offset++) {
          if (_mpegaudio2.default.probe(data, offset)) {
            _logger.logger.log('MPEG Audio sync word found !');
            return true;
          }
        }
      }
      return false;
    }
  }]);

  return MP3Demuxer;
}();

exports.default = MP3Demuxer;

},{"../demux/id3":27,"../utils/logger":54,"./mpegaudio":30}],29:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * MP4 demuxer
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */
//import {logger} from '../utils/logger';


var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var UINT32_MAX = Math.pow(2, 32) - 1;

var MP4Demuxer = function () {
  function MP4Demuxer(observer, remuxer) {
    _classCallCheck(this, MP4Demuxer);

    this.observer = observer;
    this.remuxer = remuxer;
  }

  _createClass(MP4Demuxer, [{
    key: 'resetTimeStamp',
    value: function resetTimeStamp(initPTS) {
      this.initPTS = initPTS;
    }
  }, {
    key: 'resetInitSegment',
    value: function resetInitSegment(initSegment, audioCodec, videoCodec, duration) {
      //jshint unused:false
      if (initSegment && initSegment.byteLength) {
        var initData = this.initData = MP4Demuxer.parseInitSegment(initSegment);
        var tracks = {};
        if (initData.audio) {
          tracks.audio = { container: 'audio/mp4', codec: audioCodec, initSegment: duration ? initSegment : null };
        }
        if (initData.video) {
          tracks.video = { container: 'video/mp4', codec: videoCodec, initSegment: duration ? initSegment : null };
        }
        this.observer.trigger(_events2.default.FRAG_PARSING_INIT_SEGMENT, { tracks: tracks });
      } else {
        if (audioCodec) {
          this.audioCodec = audioCodec;
        }
        if (videoCodec) {
          this.videoCodec = videoCodec;
        }
      }
    }
  }, {
    key: 'append',


    // feed incoming data to the front of the parsing pipeline
    value: function append(data, timeOffset, contiguous, accurateTimeOffset) {
      var initData = this.initData;
      if (!initData) {
        this.resetInitSegment(data, this.audioCodec, this.videoCodec);
        initData = this.initData;
      }
      var startDTS = void 0,
          initPTS = this.initPTS;
      if (initPTS === undefined) {
        var _startDTS = MP4Demuxer.getStartDTS(initData, data);
        this.initPTS = initPTS = _startDTS - timeOffset;
        this.observer.trigger(_events2.default.INIT_PTS_FOUND, { initPTS: initPTS });
      }
      MP4Demuxer.offsetStartDTS(initData, data, initPTS);
      startDTS = MP4Demuxer.getStartDTS(initData, data);
      this.remuxer.remux(initData.audio, initData.video, null, null, startDTS, contiguous, accurateTimeOffset, data);
    }
  }, {
    key: 'destroy',
    value: function destroy() {}
  }], [{
    key: 'probe',
    value: function probe(data) {
      if (data.length >= 8) {
        var dataType = MP4Demuxer.bin2str(data.subarray(4, 8));
        return ['moof', 'ftyp', 'styp'].indexOf(dataType) >= 0;
      }
      return false;
    }
  }, {
    key: 'bin2str',
    value: function bin2str(buffer) {
      return String.fromCharCode.apply(null, buffer);
    }
  }, {
    key: 'readUint32',
    value: function readUint32(buffer, offset) {
      if (buffer.data) {
        offset += buffer.start;
        buffer = buffer.data;
      }

      var val = buffer[offset] << 24 | buffer[offset + 1] << 16 | buffer[offset + 2] << 8 | buffer[offset + 3];
      return val < 0 ? 4294967296 + val : val;
    }
  }, {
    key: 'writeUint32',
    value: function writeUint32(buffer, offset, value) {
      if (buffer.data) {
        offset += buffer.start;
        buffer = buffer.data;
      }
      buffer[offset] = value >> 24;
      buffer[offset + 1] = value >> 16 & 0xff;
      buffer[offset + 2] = value >> 8 & 0xff;
      buffer[offset + 3] = value & 0xff;
    }

    // Find the data for a box specified by its path

  }, {
    key: 'findBox',
    value: function findBox(data, path) {
      var results = [],
          i,
          size,
          type,
          end,
          subresults,
          start,
          endbox;

      if (data.data) {
        start = data.start;
        end = data.end;
        data = data.data;
      } else {
        start = 0;
        end = data.byteLength;
      }

      if (!path.length) {
        // short-circuit the search for empty paths
        return null;
      }

      for (i = start; i < end;) {
        size = MP4Demuxer.readUint32(data, i);
        type = MP4Demuxer.bin2str(data.subarray(i + 4, i + 8));
        endbox = size > 1 ? i + size : end;

        if (type === path[0]) {

          if (path.length === 1) {
            // this is the end of the path and we've found the box we were
            // looking for
            results.push({ data: data, start: i + 8, end: endbox });
          } else {
            // recursively search for the next box along the path
            subresults = MP4Demuxer.findBox({ data: data, start: i + 8, end: endbox }, path.slice(1));
            if (subresults.length) {
              results = results.concat(subresults);
            }
          }
        }
        i = endbox;
      }

      // we've finished searching all of data
      return results;
    }

    /**
     * Parses an MP4 initialization segment and extracts stream type and
     * timescale values for any declared tracks. Timescale values indicate the
     * number of clock ticks per second to assume for time-based values
     * elsewhere in the MP4.
     *
     * To determine the start time of an MP4, you need two pieces of
     * information: the timescale unit and the earliest base media decode
     * time. Multiple timescales can be specified within an MP4 but the
     * base media decode time is always expressed in the timescale from
     * the media header box for the track:
     * ```
     * moov > trak > mdia > mdhd.timescale
     * moov > trak > mdia > hdlr
     * ```
     * @param init {Uint8Array} the bytes of the init segment
     * @return {object} a hash of track type to timescale values or null if
     * the init segment is malformed.
     */

  }, {
    key: 'parseInitSegment',
    value: function parseInitSegment(initSegment) {
      var result = [];
      var traks = MP4Demuxer.findBox(initSegment, ['moov', 'trak']);

      traks.forEach(function (trak) {
        var tkhd = MP4Demuxer.findBox(trak, ['tkhd'])[0];
        if (tkhd) {
          var version = tkhd.data[tkhd.start];
          var index = version === 0 ? 12 : 20;
          var trackId = MP4Demuxer.readUint32(tkhd, index);

          var mdhd = MP4Demuxer.findBox(trak, ['mdia', 'mdhd'])[0];
          if (mdhd) {
            version = mdhd.data[mdhd.start];
            index = version === 0 ? 12 : 20;
            var timescale = MP4Demuxer.readUint32(mdhd, index);

            var hdlr = MP4Demuxer.findBox(trak, ['mdia', 'hdlr'])[0];
            if (hdlr) {
              var hdlrType = MP4Demuxer.bin2str(hdlr.data.subarray(hdlr.start + 8, hdlr.start + 12));
              var type = { 'soun': 'audio', 'vide': 'video' }[hdlrType];
              if (type) {
                result[trackId] = { timescale: timescale, type: type };
                result[type] = { timescale: timescale, id: trackId };
              }
            }
          }
        }
      });
      return result;
    }

    /**
     * Determine the base media decode start time, in seconds, for an MP4
     * fragment. If multiple fragments are specified, the earliest time is
     * returned.
     *
     * The base media decode time can be parsed from track fragment
     * metadata:
     * ```
     * moof > traf > tfdt.baseMediaDecodeTime
     * ```
     * It requires the timescale value from the mdhd to interpret.
     *
     * @param timescale {object} a hash of track ids to timescale values.
     * @return {number} the earliest base media decode start time for the
     * fragment, in seconds
     */

  }, {
    key: 'getStartDTS',
    value: function getStartDTS(initData, fragment) {
      var trafs, baseTimes, result;

      // we need info from two childrend of each track fragment box
      trafs = MP4Demuxer.findBox(fragment, ['moof', 'traf']);

      // determine the start times for each track
      baseTimes = [].concat.apply([], trafs.map(function (traf) {
        return MP4Demuxer.findBox(traf, ['tfhd']).map(function (tfhd) {
          var id, scale, baseTime;

          // get the track id from the tfhd
          id = MP4Demuxer.readUint32(tfhd, 4);
          // assume a 90kHz clock if no timescale was specified
          scale = initData[id].timescale || 90e3;

          // get the base media decode time from the tfdt
          baseTime = MP4Demuxer.findBox(traf, ['tfdt']).map(function (tfdt) {
            var version, result;

            version = tfdt.data[tfdt.start];
            result = MP4Demuxer.readUint32(tfdt, 4);
            if (version === 1) {
              result *= Math.pow(2, 32);

              result += MP4Demuxer.readUint32(tfdt, 8);
            }
            return result;
          })[0];
          baseTime = baseTime || Infinity;

          // convert base time to seconds
          return baseTime / scale;
        });
      }));

      // return the minimum
      result = Math.min.apply(null, baseTimes);
      return isFinite(result) ? result : 0;
    }
  }, {
    key: 'offsetStartDTS',
    value: function offsetStartDTS(initData, fragment, timeOffset) {
      MP4Demuxer.findBox(fragment, ['moof', 'traf']).map(function (traf) {
        return MP4Demuxer.findBox(traf, ['tfhd']).map(function (tfhd) {
          // get the track id from the tfhd
          var id = MP4Demuxer.readUint32(tfhd, 4);
          // assume a 90kHz clock if no timescale was specified
          var timescale = initData[id].timescale || 90e3;

          // get the base media decode time from the tfdt
          MP4Demuxer.findBox(traf, ['tfdt']).map(function (tfdt) {
            var version = tfdt.data[tfdt.start];
            var baseMediaDecodeTime = MP4Demuxer.readUint32(tfdt, 4);
            if (version === 0) {
              MP4Demuxer.writeUint32(tfdt, 4, baseMediaDecodeTime - timeOffset * timescale);
            } else {
              baseMediaDecodeTime *= Math.pow(2, 32);
              baseMediaDecodeTime += MP4Demuxer.readUint32(tfdt, 8);
              baseMediaDecodeTime -= timeOffset * timescale;
              var upper = Math.floor(baseMediaDecodeTime / (UINT32_MAX + 1));
              var lower = Math.floor(baseMediaDecodeTime % (UINT32_MAX + 1));
              MP4Demuxer.writeUint32(tfdt, 4, upper);
              MP4Demuxer.writeUint32(tfdt, 8, lower);
            }
          });
        });
      });
    }
  }]);

  return MP4Demuxer;
}();

exports.default = MP4Demuxer;

},{"../events":35}],30:[function(require,module,exports){
"use strict";

/**
 *  MPEG parser helper
 */

var MpegAudio = {

    BitratesMap: [32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448, 32, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 32, 48, 56, 64, 80, 96, 112, 128, 144, 160, 176, 192, 224, 256, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160],

    SamplingRateMap: [44100, 48000, 32000, 22050, 24000, 16000, 11025, 12000, 8000],

    appendFrame: function appendFrame(track, data, offset, pts, frameIndex) {
        // Using http://www.datavoyage.com/mpgscript/mpeghdr.htm as a reference
        if (offset + 24 > data.length) {
            return undefined;
        }

        var header = this.parseHeader(data, offset);
        if (header && offset + header.frameLength <= data.length) {
            var frameDuration = 1152 * 90000 / header.sampleRate;
            var stamp = pts + frameIndex * frameDuration;
            var sample = { unit: data.subarray(offset, offset + header.frameLength), pts: stamp, dts: stamp };

            track.config = [];
            track.channelCount = header.channelCount;
            track.samplerate = header.sampleRate;
            track.samples.push(sample);
            track.len += header.frameLength;

            return { sample: sample, length: header.frameLength };
        }

        return undefined;
    },

    parseHeader: function parseHeader(data, offset) {
        var headerB = data[offset + 1] >> 3 & 3;
        var headerC = data[offset + 1] >> 1 & 3;
        var headerE = data[offset + 2] >> 4 & 15;
        var headerF = data[offset + 2] >> 2 & 3;
        var headerG = !!(data[offset + 2] & 2);
        if (headerB !== 1 && headerE !== 0 && headerE !== 15 && headerF !== 3) {
            var columnInBitrates = headerB === 3 ? 3 - headerC : headerC === 3 ? 3 : 4;
            var bitRate = MpegAudio.BitratesMap[columnInBitrates * 14 + headerE - 1] * 1000;
            var columnInSampleRates = headerB === 3 ? 0 : headerB === 2 ? 1 : 2;
            var sampleRate = MpegAudio.SamplingRateMap[columnInSampleRates * 3 + headerF];
            var padding = headerG ? 1 : 0;
            var channelCount = data[offset + 3] >> 6 === 3 ? 1 : 2; // If bits of channel mode are `11` then it is a single channel (Mono)
            var frameLength = headerC === 3 ? (headerB === 3 ? 12 : 6) * bitRate / sampleRate + padding << 2 : (headerB === 3 ? 144 : 72) * bitRate / sampleRate + padding | 0;

            return { sampleRate: sampleRate, channelCount: channelCount, frameLength: frameLength };
        }

        return undefined;
    },

    isHeaderPattern: function isHeaderPattern(data, offset) {
        return data[offset] === 0xff && (data[offset + 1] & 0xe0) === 0xe0 && (data[offset + 1] & 0x06) !== 0x00;
    },

    isHeader: function isHeader(data, offset) {
        // Look for MPEG header | 1111 1111 | 111X XYZX | where X can be either 0 or 1 and Y or Z should be 1
        // Layer bits (position 14 and 15) in header should be always different from 0 (Layer I or Layer II or Layer III)
        // More info http://www.mp3-tech.org/programmer/frame_header.html
        if (offset + 1 < data.length && this.isHeaderPattern(data, offset)) {
            return true;
        }
        return false;
    },

    probe: function probe(data, offset) {
        // same as isHeader but we also check that MPEG frame follows last MPEG frame 
        // or end of data is reached
        if (offset + 1 < data.length && this.isHeaderPattern(data, offset)) {
            // MPEG header Length
            var headerLength = 4;
            // MPEG frame Length
            var header = this.parseHeader(data, offset);
            var frameLength = headerLength;
            if (header && header.frameLength) {
                frameLength = header.frameLength;
            }
            var newOffset = offset + frameLength;
            if (newOffset === data.length || newOffset + 1 < data.length && this.isHeaderPattern(data, newOffset)) {
                return true;
            }
        }
        return false;
    }
};

module.exports = MpegAudio;

},{}],31:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * SAMPLE-AES decrypter
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */

var _decrypter = require('../crypt/decrypter');

var _decrypter2 = _interopRequireDefault(_decrypter);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var SampleAesDecrypter = function () {
  function SampleAesDecrypter(observer, config, decryptdata, discardEPB) {
    _classCallCheck(this, SampleAesDecrypter);

    this.decryptdata = decryptdata;
    this.discardEPB = discardEPB;
    this.decrypter = new _decrypter2.default(observer, config);
  }

  _createClass(SampleAesDecrypter, [{
    key: 'decryptBuffer',
    value: function decryptBuffer(encryptedData, callback) {
      this.decrypter.decrypt(encryptedData, this.decryptdata.key.buffer, this.decryptdata.iv.buffer, callback);
    }

    // AAC - encrypt all full 16 bytes blocks starting from offset 16

  }, {
    key: 'decryptAacSample',
    value: function decryptAacSample(samples, sampleIndex, callback, sync) {
      var curUnit = samples[sampleIndex].unit;
      var encryptedData = curUnit.subarray(16, curUnit.length - curUnit.length % 16);
      var encryptedBuffer = encryptedData.buffer.slice(encryptedData.byteOffset, encryptedData.byteOffset + encryptedData.length);

      var localthis = this;
      this.decryptBuffer(encryptedBuffer, function (decryptedData) {
        decryptedData = new Uint8Array(decryptedData);
        curUnit.set(decryptedData, 16);

        if (!sync) {
          localthis.decryptAacSamples(samples, sampleIndex + 1, callback);
        }
      });
    }
  }, {
    key: 'decryptAacSamples',
    value: function decryptAacSamples(samples, sampleIndex, callback) {
      for (;; sampleIndex++) {
        if (sampleIndex >= samples.length) {
          callback();
          return;
        }

        if (samples[sampleIndex].unit.length < 32) {
          continue;
        }

        var sync = this.decrypter.isSync();

        this.decryptAacSample(samples, sampleIndex, callback, sync);

        if (!sync) {
          return;
        }
      }
    }

    // AVC - encrypt one 16 bytes block out of ten, starting from offset 32

  }, {
    key: 'getAvcEncryptedData',
    value: function getAvcEncryptedData(decodedData) {
      var encryptedDataLen = Math.floor((decodedData.length - 48) / 160) * 16 + 16;
      var encryptedData = new Int8Array(encryptedDataLen);
      var outputPos = 0;
      for (var inputPos = 32; inputPos <= decodedData.length - 16; inputPos += 160, outputPos += 16) {
        encryptedData.set(decodedData.subarray(inputPos, inputPos + 16), outputPos);
      }
      return encryptedData;
    }
  }, {
    key: 'getAvcDecryptedUnit',
    value: function getAvcDecryptedUnit(decodedData, decryptedData) {
      decryptedData = new Uint8Array(decryptedData);
      var inputPos = 0;
      for (var outputPos = 32; outputPos <= decodedData.length - 16; outputPos += 160, inputPos += 16) {
        decodedData.set(decryptedData.subarray(inputPos, inputPos + 16), outputPos);
      }
      return decodedData;
    }
  }, {
    key: 'decryptAvcSample',
    value: function decryptAvcSample(samples, sampleIndex, unitIndex, callback, curUnit, sync) {
      var decodedData = this.discardEPB(curUnit.data);
      var encryptedData = this.getAvcEncryptedData(decodedData);
      var localthis = this;

      this.decryptBuffer(encryptedData.buffer, function (decryptedData) {
        curUnit.data = localthis.getAvcDecryptedUnit(decodedData, decryptedData);

        if (!sync) {
          localthis.decryptAvcSamples(samples, sampleIndex, unitIndex + 1, callback);
        }
      });
    }
  }, {
    key: 'decryptAvcSamples',
    value: function decryptAvcSamples(samples, sampleIndex, unitIndex, callback) {
      for (;; sampleIndex++, unitIndex = 0) {
        if (sampleIndex >= samples.length) {
          callback();
          return;
        }

        var curUnits = samples[sampleIndex].units;
        for (;; unitIndex++) {
          if (unitIndex >= curUnits.length) {
            break;
          }

          var curUnit = curUnits[unitIndex];
          if (curUnit.length <= 48 || curUnit.type !== 1 && curUnit.type !== 5) {
            continue;
          }

          var sync = this.decrypter.isSync();

          this.decryptAvcSample(samples, sampleIndex, unitIndex, callback, curUnit, sync);

          if (!sync) {
            return;
          }
        }
      }
    }
  }]);

  return SampleAesDecrypter;
}();

exports.default = SampleAesDecrypter;

},{"../crypt/decrypter":19}],32:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * highly optimized TS demuxer:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * parse PAT, PMT
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * extract PES packet from audio and video PIDs
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * extract AVC/H264 NAL units and AAC/ADTS samples from PES packet
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * trigger the remuxer upon parsing completion
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * it also tries to workaround as best as it can audio codec switch (HE-AAC to AAC and vice versa), without having to restart the MediaSource.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * it also controls the remuxing process :
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * upon discontinuity or level switch detection, it will also notifies the remuxer so that it can reset its state.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */

// import Hex from '../utils/hex';


var _adts = require('./adts');

var _adts2 = _interopRequireDefault(_adts);

var _mpegaudio = require('./mpegaudio');

var _mpegaudio2 = _interopRequireDefault(_mpegaudio);

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _expGolomb = require('./exp-golomb');

var _expGolomb2 = _interopRequireDefault(_expGolomb);

var _sampleAes = require('./sample-aes');

var _sampleAes2 = _interopRequireDefault(_sampleAes);

var _logger = require('../utils/logger');

var _errors = require('../errors');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var TSDemuxer = function () {
  function TSDemuxer(observer, remuxer, config, typeSupported) {
    _classCallCheck(this, TSDemuxer);

    this.observer = observer;
    this.config = config;
    this.typeSupported = typeSupported;
    this.remuxer = remuxer;
    this.sampleAes = null;
  }

  _createClass(TSDemuxer, [{
    key: 'setDecryptData',
    value: function setDecryptData(decryptdata) {
      if (decryptdata != null && decryptdata.key != null && decryptdata.method === 'SAMPLE-AES') {
        this.sampleAes = new _sampleAes2.default(this.observer, this.config, decryptdata, this.discardEPB);
      } else {
        this.sampleAes = null;
      }
    }
  }, {
    key: 'resetInitSegment',
    value: function resetInitSegment(initSegment, audioCodec, videoCodec, duration) {
      this.pmtParsed = false;
      this._pmtId = -1;
      this._avcTrack = { container: 'video/mp2t', type: 'video', id: -1, inputTimeScale: 90000, sequenceNumber: 0, samples: [], len: 0, dropped: 0 };
      this._audioTrack = { container: 'video/mp2t', type: 'audio', id: -1, inputTimeScale: 90000, duration: duration, sequenceNumber: 0, samples: [], len: 0, isAAC: true };
      this._id3Track = { type: 'id3', id: -1, inputTimeScale: 90000, sequenceNumber: 0, samples: [], len: 0 };
      this._txtTrack = { type: 'text', id: -1, inputTimeScale: 90000, sequenceNumber: 0, samples: [], len: 0 };
      // flush any partial content
      this.aacOverFlow = null;
      this.aacLastPTS = null;
      this.avcSample = null;
      this.audioCodec = audioCodec;
      this.videoCodec = videoCodec;
      this._duration = duration;
    }
  }, {
    key: 'resetTimeStamp',
    value: function resetTimeStamp() {}

    // feed incoming data to the front of the parsing pipeline

  }, {
    key: 'append',
    value: function append(data, timeOffset, contiguous, accurateTimeOffset) {
      var start,
          len = data.length,
          stt,
          pid,
          atf,
          offset,
          pes,
          unknownPIDs = false;
      this.contiguous = contiguous;
      var pmtParsed = this.pmtParsed,
          avcTrack = this._avcTrack,
          audioTrack = this._audioTrack,
          id3Track = this._id3Track,
          avcId = avcTrack.id,
          audioId = audioTrack.id,
          id3Id = id3Track.id,
          pmtId = this._pmtId,
          avcData = avcTrack.pesData,
          audioData = audioTrack.pesData,
          id3Data = id3Track.pesData,
          parsePAT = this._parsePAT,
          parsePMT = this._parsePMT,
          parsePES = this._parsePES,
          parseAVCPES = this._parseAVCPES.bind(this),
          parseAACPES = this._parseAACPES.bind(this),
          parseMPEGPES = this._parseMPEGPES.bind(this),
          parseID3PES = this._parseID3PES.bind(this);

      // don't parse last TS packet if incomplete
      len -= len % 188;
      // loop through TS packets
      for (start = 0; start < len; start += 188) {
        if (data[start] === 0x47) {
          stt = !!(data[start + 1] & 0x40);
          // pid is a 13-bit field starting at the last bit of TS[1]
          pid = ((data[start + 1] & 0x1f) << 8) + data[start + 2];
          atf = (data[start + 3] & 0x30) >> 4;
          // if an adaption field is present, its length is specified by the fifth byte of the TS packet header.
          if (atf > 1) {
            offset = start + 5 + data[start + 4];
            // continue if there is only adaptation field
            if (offset === start + 188) {
              continue;
            }
          } else {
            offset = start + 4;
          }
          switch (pid) {
            case avcId:
              if (stt) {
                if (avcData && (pes = parsePES(avcData))) {
                  parseAVCPES(pes, false);
                }
                avcData = { data: [], size: 0 };
              }
              if (avcData) {
                avcData.data.push(data.subarray(offset, start + 188));
                avcData.size += start + 188 - offset;
              }
              break;
            case audioId:
              if (stt) {
                if (audioData && (pes = parsePES(audioData))) {
                  if (audioTrack.isAAC) {
                    parseAACPES(pes);
                  } else {
                    parseMPEGPES(pes);
                  }
                }
                audioData = { data: [], size: 0 };
              }
              if (audioData) {
                audioData.data.push(data.subarray(offset, start + 188));
                audioData.size += start + 188 - offset;
              }
              break;
            case id3Id:
              if (stt) {
                if (id3Data && (pes = parsePES(id3Data))) {
                  parseID3PES(pes);
                }
                id3Data = { data: [], size: 0 };
              }
              if (id3Data) {
                id3Data.data.push(data.subarray(offset, start + 188));
                id3Data.size += start + 188 - offset;
              }
              break;
            case 0:
              if (stt) {
                offset += data[offset] + 1;
              }
              pmtId = this._pmtId = parsePAT(data, offset);
              break;
            case pmtId:
              if (stt) {
                offset += data[offset] + 1;
              }
              var parsedPIDs = parsePMT(data, offset, this.typeSupported.mpeg === true || this.typeSupported.mp3 === true, this.sampleAes != null);

              // only update track id if track PID found while parsing PMT
              // this is to avoid resetting the PID to -1 in case
              // track PID transiently disappears from the stream
              // this could happen in case of transient missing audio samples for example
              avcId = parsedPIDs.avc;
              if (avcId > 0) {
                avcTrack.id = avcId;
              }
              audioId = parsedPIDs.audio;
              if (audioId > 0) {
                audioTrack.id = audioId;
                audioTrack.isAAC = parsedPIDs.isAAC;
              }
              id3Id = parsedPIDs.id3;
              if (id3Id > 0) {
                id3Track.id = id3Id;
              }
              if (unknownPIDs && !pmtParsed) {
                _logger.logger.log('reparse from beginning');
                unknownPIDs = false;
                // we set it to -188, the += 188 in the for loop will reset start to 0
                start = -188;
              }
              pmtParsed = this.pmtParsed = true;
              break;
            case 17:
            case 0x1fff:
              break;
            default:
              unknownPIDs = true;
              break;
          }
        } else {
          this.observer.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.FRAG_PARSING_ERROR, fatal: false, reason: 'TS packet did not start with 0x47' });
        }
      }
      // try to parse last PES packets
      if (avcData && (pes = parsePES(avcData))) {
        parseAVCPES(pes, true);
        avcTrack.pesData = null;
      } else {
        // either avcData null or PES truncated, keep it for next frag parsing
        avcTrack.pesData = avcData;
      }

      if (audioData && (pes = parsePES(audioData))) {
        if (audioTrack.isAAC) {
          parseAACPES(pes);
        } else {
          parseMPEGPES(pes);
        }
        audioTrack.pesData = null;
      } else {
        if (audioData && audioData.size) {
          _logger.logger.log('last AAC PES packet truncated,might overlap between fragments');
        }
        // either audioData null or PES truncated, keep it for next frag parsing
        audioTrack.pesData = audioData;
      }

      if (id3Data && (pes = parsePES(id3Data))) {
        parseID3PES(pes);
        id3Track.pesData = null;
      } else {
        // either id3Data null or PES truncated, keep it for next frag parsing
        id3Track.pesData = id3Data;
      }

      if (this.sampleAes == null) {
        this.remuxer.remux(audioTrack, avcTrack, id3Track, this._txtTrack, timeOffset, contiguous, accurateTimeOffset);
      } else {
        this.decryptAndRemux(audioTrack, avcTrack, id3Track, this._txtTrack, timeOffset, contiguous, accurateTimeOffset);
      }
    }
  }, {
    key: 'decryptAndRemux',
    value: function decryptAndRemux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset) {
      if (audioTrack.samples && audioTrack.isAAC) {
        var localthis = this;
        this.sampleAes.decryptAacSamples(audioTrack.samples, 0, function () {
          localthis.decryptAndRemuxAvc(audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset);
        });
      } else {
        this.decryptAndRemuxAvc(audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset);
      }
    }
  }, {
    key: 'decryptAndRemuxAvc',
    value: function decryptAndRemuxAvc(audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset) {
      if (videoTrack.samples) {
        var localthis = this;
        this.sampleAes.decryptAvcSamples(videoTrack.samples, 0, 0, function () {
          localthis.remuxer.remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset);
        });
      } else {
        this.remuxer.remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset);
      }
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      this._initPTS = this._initDTS = undefined;
      this._duration = 0;
    }
  }, {
    key: '_parsePAT',
    value: function _parsePAT(data, offset) {
      // skip the PSI header and parse the first PMT entry
      return (data[offset + 10] & 0x1F) << 8 | data[offset + 11];
      //logger.log('PMT PID:'  + this._pmtId);
    }
  }, {
    key: '_parsePMT',
    value: function _parsePMT(data, offset, mpegSupported, isSampleAes) {
      var sectionLength,
          tableEnd,
          programInfoLength,
          pid,
          result = { audio: -1, avc: -1, id3: -1, isAAC: true };
      sectionLength = (data[offset + 1] & 0x0f) << 8 | data[offset + 2];
      tableEnd = offset + 3 + sectionLength - 4;
      // to determine where the table is, we have to figure out how
      // long the program info descriptors are
      programInfoLength = (data[offset + 10] & 0x0f) << 8 | data[offset + 11];
      // advance the offset to the first entry in the mapping table
      offset += 12 + programInfoLength;
      while (offset < tableEnd) {
        pid = (data[offset + 1] & 0x1F) << 8 | data[offset + 2];
        switch (data[offset]) {
          case 0xcf:
            // SAMPLE-AES AAC
            if (!isSampleAes) {
              _logger.logger.log('unkown stream type:' + data[offset]);
              break;
            }
          /* falls through */

          // ISO/IEC 13818-7 ADTS AAC (MPEG-2 lower bit-rate audio)
          case 0x0f:
            //logger.log('AAC PID:'  + pid);
            if (result.audio === -1) {
              result.audio = pid;
            }
            break;

          // Packetized metadata (ID3)
          case 0x15:
            //logger.log('ID3 PID:'  + pid);
            if (result.id3 === -1) {
              result.id3 = pid;
            }
            break;

          case 0xdb:
            // SAMPLE-AES AVC
            if (!isSampleAes) {
              _logger.logger.log('unkown stream type:' + data[offset]);
              break;
            }
          /* falls through */

          // ITU-T Rec. H.264 and ISO/IEC 14496-10 (lower bit-rate video)
          case 0x1b:
            //logger.log('AVC PID:'  + pid);
            if (result.avc === -1) {
              result.avc = pid;
            }
            break;

          // ISO/IEC 11172-3 (MPEG-1 audio)
          // or ISO/IEC 13818-3 (MPEG-2 halved sample rate audio)
          case 0x03:
          case 0x04:
            //logger.log('MPEG PID:'  + pid);
            if (!mpegSupported) {
              _logger.logger.log('MPEG audio found, not supported in this browser for now');
            } else if (result.audio === -1) {
              result.audio = pid;
              result.isAAC = false;
            }
            break;

          case 0x24:
            _logger.logger.warn('HEVC stream type found, not supported for now');
            break;

          default:
            _logger.logger.log('unkown stream type:' + data[offset]);
            break;
        }
        // move to the next table entry
        // skip past the elementary stream descriptors, if present
        offset += ((data[offset + 3] & 0x0F) << 8 | data[offset + 4]) + 5;
      }
      return result;
    }
  }, {
    key: '_parsePES',
    value: function _parsePES(stream) {
      var i = 0,
          frag,
          pesFlags,
          pesPrefix,
          pesLen,
          pesHdrLen,
          pesData,
          pesPts,
          pesDts,
          payloadStartOffset,
          data = stream.data;
      // safety check
      if (!stream || stream.size === 0) {
        return null;
      }

      // we might need up to 19 bytes to read PES header
      // if first chunk of data is less than 19 bytes, let's merge it with following ones until we get 19 bytes
      // usually only one merge is needed (and this is rare ...)
      while (data[0].length < 19 && data.length > 1) {
        var newData = new Uint8Array(data[0].length + data[1].length);
        newData.set(data[0]);
        newData.set(data[1], data[0].length);
        data[0] = newData;
        data.splice(1, 1);
      }
      //retrieve PTS/DTS from first fragment
      frag = data[0];
      pesPrefix = (frag[0] << 16) + (frag[1] << 8) + frag[2];
      if (pesPrefix === 1) {
        pesLen = (frag[4] << 8) + frag[5];
        // if PES parsed length is not zero and greater than total received length, stop parsing. PES might be truncated
        // minus 6 : PES header size
        if (pesLen && pesLen > stream.size - 6) {
          return null;
        }
        pesFlags = frag[7];
        if (pesFlags & 0xC0) {
          /* PES header described here : http://dvd.sourceforge.net/dvdinfo/pes-hdr.html
              as PTS / DTS is 33 bit we cannot use bitwise operator in JS,
              as Bitwise operators treat their operands as a sequence of 32 bits */
          pesPts = (frag[9] & 0x0E) * 536870912 + // 1 << 29
          (frag[10] & 0xFF) * 4194304 + // 1 << 22
          (frag[11] & 0xFE) * 16384 + // 1 << 14
          (frag[12] & 0xFF) * 128 + // 1 << 7
          (frag[13] & 0xFE) / 2;
          // check if greater than 2^32 -1
          if (pesPts > 4294967295) {
            // decrement 2^33
            pesPts -= 8589934592;
          }
          if (pesFlags & 0x40) {
            pesDts = (frag[14] & 0x0E) * 536870912 + // 1 << 29
            (frag[15] & 0xFF) * 4194304 + // 1 << 22
            (frag[16] & 0xFE) * 16384 + // 1 << 14
            (frag[17] & 0xFF) * 128 + // 1 << 7
            (frag[18] & 0xFE) / 2;
            // check if greater than 2^32 -1
            if (pesDts > 4294967295) {
              // decrement 2^33
              pesDts -= 8589934592;
            }
            if (pesPts - pesDts > 60 * 90000) {
              _logger.logger.warn(Math.round((pesPts - pesDts) / 90000) + 's delta between PTS and DTS, align them');
              pesPts = pesDts;
            }
          } else {
            pesDts = pesPts;
          }
        }
        pesHdrLen = frag[8];
        // 9 bytes : 6 bytes for PES header + 3 bytes for PES extension
        payloadStartOffset = pesHdrLen + 9;

        stream.size -= payloadStartOffset;
        //reassemble PES packet
        pesData = new Uint8Array(stream.size);
        for (var j = 0, dataLen = data.length; j < dataLen; j++) {
          frag = data[j];
          var len = frag.byteLength;
          if (payloadStartOffset) {
            if (payloadStartOffset > len) {
              // trim full frag if PES header bigger than frag
              payloadStartOffset -= len;
              continue;
            } else {
              // trim partial frag if PES header smaller than frag
              frag = frag.subarray(payloadStartOffset);
              len -= payloadStartOffset;
              payloadStartOffset = 0;
            }
          }
          pesData.set(frag, i);
          i += len;
        }
        if (pesLen) {
          // payload size : remove PES header + PES extension
          pesLen -= pesHdrLen + 3;
        }
        return { data: pesData, pts: pesPts, dts: pesDts, len: pesLen };
      } else {
        return null;
      }
    }
  }, {
    key: 'pushAccesUnit',
    value: function pushAccesUnit(avcSample, avcTrack) {
      if (avcSample.units.length && avcSample.frame) {
        var samples = avcTrack.samples;
        var nbSamples = samples.length;
        // only push AVC sample if starting with a keyframe is not mandatory OR
        //    if keyframe already found in this fragment OR
        //       keyframe found in last fragment (track.sps) AND
        //          samples already appended (we already found a keyframe in this fragment) OR fragment is contiguous
        if (!this.config.forceKeyFrameOnDiscontinuity || avcSample.key === true || avcTrack.sps && (nbSamples || this.contiguous)) {
          avcSample.id = nbSamples;
          samples.push(avcSample);
        } else {
          // dropped samples, track it
          avcTrack.dropped++;
        }
      }
      if (avcSample.debug.length) {
        _logger.logger.log(avcSample.pts + '/' + avcSample.dts + ':' + avcSample.debug);
      }
    }
  }, {
    key: '_parseAVCPES',
    value: function _parseAVCPES(pes, last) {
      var _this = this;

      //logger.log('parse new PES');
      var track = this._avcTrack,
          units = this._parseAVCNALu(pes.data),
          debug = false,
          expGolombDecoder,
          avcSample = this.avcSample,
          push,
          spsfound = false,
          i,
          pushAccesUnit = this.pushAccesUnit.bind(this),
          createAVCSample = function createAVCSample(key, pts, dts, debug) {
        return { key: key, pts: pts, dts: dts, units: [], debug: debug };
      };
      //free pes.data to save up some memory
      pes.data = null;

      // if new NAL units found and last sample still there, let's push ...
      // this helps parsing streams with missing AUD
      if (avcSample && units.length) {
        pushAccesUnit(avcSample, track);
        avcSample = this.avcSample = createAVCSample(false, pes.pts, pes.dts, '');
      }

      units.forEach(function (unit) {
        switch (unit.type) {
          //NDR
          case 1:
            push = true;
            if (debug && avcSample) {
              avcSample.debug += 'NDR ';
            }
            avcSample.frame = true;
            var data = unit.data;
            // only check slice type to detect KF in case SPS found in same packet (any keyframe is preceded by SPS ...)
            if (spsfound && data.length > 4) {
              // retrieve slice type by parsing beginning of NAL unit (follow H264 spec, slice_header definition) to detect keyframe embedded in NDR
              var sliceType = new _expGolomb2.default(data).readSliceType();
              // 2 : I slice, 4 : SI slice, 7 : I slice, 9: SI slice
              // SI slice : A slice that is coded using intra prediction only and using quantisation of the prediction samples.
              // An SI slice can be coded such that its decoded samples can be constructed identically to an SP slice.
              // I slice: A slice that is not an SI slice that is decoded using intra prediction only.
              //if (sliceType === 2 || sliceType === 7) {
              if (sliceType === 2 || sliceType === 4 || sliceType === 7 || sliceType === 9) {
                avcSample.key = true;
              }
            }
            break;
          //IDR
          case 5:
            push = true;
            // handle PES not starting with AUD
            if (!avcSample) {
              avcSample = _this.avcSample = createAVCSample(true, pes.pts, pes.dts, '');
            }
            if (debug) {
              avcSample.debug += 'IDR ';
            }
            avcSample.key = true;
            avcSample.frame = true;
            break;
          //SEI
          case 6:
            push = true;
            if (debug && avcSample) {
              avcSample.debug += 'SEI ';
            }
            expGolombDecoder = new _expGolomb2.default(_this.discardEPB(unit.data));

            // skip frameType
            expGolombDecoder.readUByte();

            var payloadType = 0;
            var payloadSize = 0;
            var endOfCaptions = false;
            var b = 0;

            while (!endOfCaptions && expGolombDecoder.bytesAvailable > 1) {
              payloadType = 0;
              do {
                b = expGolombDecoder.readUByte();
                payloadType += b;
              } while (b === 0xFF);

              // Parse payload size.
              payloadSize = 0;
              do {
                b = expGolombDecoder.readUByte();
                payloadSize += b;
              } while (b === 0xFF);

              // TODO: there can be more than one payload in an SEI packet...
              // TODO: need to read type and size in a while loop to get them all
              if (payloadType === 4 && expGolombDecoder.bytesAvailable !== 0) {

                endOfCaptions = true;

                var countryCode = expGolombDecoder.readUByte();

                if (countryCode === 181) {
                  var providerCode = expGolombDecoder.readUShort();

                  if (providerCode === 49) {
                    var userStructure = expGolombDecoder.readUInt();

                    if (userStructure === 0x47413934) {
                      var userDataType = expGolombDecoder.readUByte();

                      // Raw CEA-608 bytes wrapped in CEA-708 packet
                      if (userDataType === 3) {
                        var firstByte = expGolombDecoder.readUByte();
                        var secondByte = expGolombDecoder.readUByte();

                        var totalCCs = 31 & firstByte;
                        var byteArray = [firstByte, secondByte];

                        for (i = 0; i < totalCCs; i++) {
                          // 3 bytes per CC
                          byteArray.push(expGolombDecoder.readUByte());
                          byteArray.push(expGolombDecoder.readUByte());
                          byteArray.push(expGolombDecoder.readUByte());
                        }

                        _this._insertSampleInOrder(_this._txtTrack.samples, { type: 3, pts: pes.pts, bytes: byteArray });
                      }
                    }
                  }
                }
              } else if (payloadSize < expGolombDecoder.bytesAvailable) {
                for (i = 0; i < payloadSize; i++) {
                  expGolombDecoder.readUByte();
                }
              }
            }
            break;
          //SPS
          case 7:
            push = true;
            spsfound = true;
            if (debug && avcSample) {
              avcSample.debug += 'SPS ';
            }
            if (!track.sps) {
              expGolombDecoder = new _expGolomb2.default(unit.data);
              var config = expGolombDecoder.readSPS();
              track.width = config.width;
              track.height = config.height;
              track.pixelRatio = config.pixelRatio;
              track.sps = [unit.data];
              track.duration = _this._duration;
              var codecarray = unit.data.subarray(1, 4);
              var codecstring = 'avc1.';
              for (i = 0; i < 3; i++) {
                var h = codecarray[i].toString(16);
                if (h.length < 2) {
                  h = '0' + h;
                }
                codecstring += h;
              }
              track.codec = codecstring;
            }
            break;
          //PPS
          case 8:
            push = true;
            if (debug && avcSample) {
              avcSample.debug += 'PPS ';
            }
            if (!track.pps) {
              track.pps = [unit.data];
            }
            break;
          // AUD
          case 9:
            push = false;
            if (avcSample) {
              pushAccesUnit(avcSample, track);
            }
            avcSample = _this.avcSample = createAVCSample(false, pes.pts, pes.dts, debug ? 'AUD ' : '');
            break;
          // Filler Data
          case 12:
            push = false;
            break;
          default:
            push = false;
            if (avcSample) {
              avcSample.debug += 'unknown NAL ' + unit.type + ' ';
            }
            break;
        }
        if (avcSample && push) {
          var _units = avcSample.units;
          _units.push(unit);
        }
      });
      // if last PES packet, push samples
      if (last && avcSample) {
        pushAccesUnit(avcSample, track);
        this.avcSample = null;
      }
    }
  }, {
    key: '_insertSampleInOrder',
    value: function _insertSampleInOrder(arr, data) {
      var len = arr.length;
      if (len > 0) {
        if (data.pts >= arr[len - 1].pts) {
          arr.push(data);
        } else {
          for (var pos = len - 1; pos >= 0; pos--) {
            if (data.pts < arr[pos].pts) {
              arr.splice(pos, 0, data);
              break;
            }
          }
        }
      } else {
        arr.push(data);
      }
    }
  }, {
    key: '_getLastNalUnit',
    value: function _getLastNalUnit() {
      var avcSample = this.avcSample,
          lastUnit = void 0;
      // try to fallback to previous sample if current one is empty
      if (!avcSample || avcSample.units.length === 0) {
        var track = this._avcTrack,
            samples = track.samples;
        avcSample = samples[samples.length - 1];
      }
      if (avcSample) {
        var units = avcSample.units;
        lastUnit = units[units.length - 1];
      }
      return lastUnit;
    }
  }, {
    key: '_parseAVCNALu',
    value: function _parseAVCNALu(array) {
      var i = 0,
          len = array.byteLength,
          value,
          overflow,
          track = this._avcTrack,
          state = track.naluState || 0,
          lastState = state;
      var units = [],
          unit,
          unitType,
          lastUnitStart = -1,
          lastUnitType;
      //logger.log('PES:' + Hex.hexDump(array));

      if (state === -1) {
        // special use case where we found 3 or 4-byte start codes exactly at the end of previous PES packet
        lastUnitStart = 0;
        // NALu type is value read from offset 0
        lastUnitType = array[0] & 0x1f;
        state = 0;
        i = 1;
      }

      while (i < len) {
        value = array[i++];
        // optimization. state 0 and 1 are the predominant case. let's handle them outside of the switch/case
        if (!state) {
          state = value ? 0 : 1;
          continue;
        }
        if (state === 1) {
          state = value ? 0 : 2;
          continue;
        }
        // here we have state either equal to 2 or 3
        if (!value) {
          state = 3;
        } else if (value === 1) {
          if (lastUnitStart >= 0) {
            unit = { data: array.subarray(lastUnitStart, i - state - 1), type: lastUnitType };
            //logger.log('pushing NALU, type/size:' + unit.type + '/' + unit.data.byteLength);
            units.push(unit);
          } else {
            // lastUnitStart is undefined => this is the first start code found in this PES packet
            // first check if start code delimiter is overlapping between 2 PES packets,
            // ie it started in last packet (lastState not zero)
            // and ended at the beginning of this PES packet (i <= 4 - lastState)
            var lastUnit = this._getLastNalUnit();
            if (lastUnit) {
              if (lastState && i <= 4 - lastState) {
                // start delimiter overlapping between PES packets
                // strip start delimiter bytes from the end of last NAL unit
                // check if lastUnit had a state different from zero
                if (lastUnit.state) {
                  // strip last bytes
                  lastUnit.data = lastUnit.data.subarray(0, lastUnit.data.byteLength - lastState);
                }
              }
              // If NAL units are not starting right at the beginning of the PES packet, push preceding data into previous NAL unit.
              overflow = i - state - 1;
              if (overflow > 0) {
                //logger.log('first NALU found with overflow:' + overflow);
                var tmp = new Uint8Array(lastUnit.data.byteLength + overflow);
                tmp.set(lastUnit.data, 0);
                tmp.set(array.subarray(0, overflow), lastUnit.data.byteLength);
                lastUnit.data = tmp;
              }
            }
          }
          // check if we can read unit type
          if (i < len) {
            unitType = array[i] & 0x1f;
            //logger.log('find NALU @ offset:' + i + ',type:' + unitType);
            lastUnitStart = i;
            lastUnitType = unitType;
            state = 0;
          } else {
            // not enough byte to read unit type. let's read it on next PES parsing
            state = -1;
          }
        } else {
          state = 0;
        }
      }
      if (lastUnitStart >= 0 && state >= 0) {
        unit = { data: array.subarray(lastUnitStart, len), type: lastUnitType, state: state };
        units.push(unit);
        //logger.log('pushing NALU, type/size/state:' + unit.type + '/' + unit.data.byteLength + '/' + state);
      }
      // no NALu found
      if (units.length === 0) {
        // append pes.data to previous NAL unit
        var _lastUnit = this._getLastNalUnit();
        if (_lastUnit) {
          var _tmp = new Uint8Array(_lastUnit.data.byteLength + array.byteLength);
          _tmp.set(_lastUnit.data, 0);
          _tmp.set(array, _lastUnit.data.byteLength);
          _lastUnit.data = _tmp;
        }
      }
      track.naluState = state;
      return units;
    }

    /**
     * remove Emulation Prevention bytes from a RBSP
     */

  }, {
    key: 'discardEPB',
    value: function discardEPB(data) {
      var length = data.byteLength,
          EPBPositions = [],
          i = 1,
          newLength,
          newData;

      // Find all `Emulation Prevention Bytes`
      while (i < length - 2) {
        if (data[i] === 0 && data[i + 1] === 0 && data[i + 2] === 0x03) {
          EPBPositions.push(i + 2);
          i += 2;
        } else {
          i++;
        }
      }

      // If no Emulation Prevention Bytes were found just return the original
      // array
      if (EPBPositions.length === 0) {
        return data;
      }

      // Create a new array to hold the NAL unit data
      newLength = length - EPBPositions.length;
      newData = new Uint8Array(newLength);
      var sourceIndex = 0;

      for (i = 0; i < newLength; sourceIndex++, i++) {
        if (sourceIndex === EPBPositions[0]) {
          // Skip this byte
          sourceIndex++;
          // Remove this position index
          EPBPositions.shift();
        }
        newData[i] = data[sourceIndex];
      }
      return newData;
    }
  }, {
    key: '_parseAACPES',
    value: function _parseAACPES(pes) {
      var track = this._audioTrack,
          data = pes.data,
          pts = pes.pts,
          startOffset = 0,
          aacOverFlow = this.aacOverFlow,
          aacLastPTS = this.aacLastPTS,
          frameDuration,
          frameIndex,
          offset,
          stamp,
          len;
      if (aacOverFlow) {
        var tmp = new Uint8Array(aacOverFlow.byteLength + data.byteLength);
        tmp.set(aacOverFlow, 0);
        tmp.set(data, aacOverFlow.byteLength);
        //logger.log(`AAC: append overflowing ${aacOverFlow.byteLength} bytes to beginning of new PES`);
        data = tmp;
      }
      // look for ADTS header (0xFFFx)
      for (offset = startOffset, len = data.length; offset < len - 1; offset++) {
        if (_adts2.default.isHeader(data, offset)) {
          break;
        }
      }
      // if ADTS header does not start straight from the beginning of the PES payload, raise an error
      if (offset) {
        var reason, fatal;
        if (offset < len - 1) {
          reason = 'AAC PES did not start with ADTS header,offset:' + offset;
          fatal = false;
        } else {
          reason = 'no ADTS header found in AAC PES';
          fatal = true;
        }
        _logger.logger.warn('parsing error:' + reason);
        this.observer.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.FRAG_PARSING_ERROR, fatal: fatal, reason: reason });
        if (fatal) {
          return;
        }
      }

      _adts2.default.initTrackConfig(track, this.observer, data, offset, this.audioCodec);
      frameIndex = 0;
      frameDuration = _adts2.default.getFrameDuration(track.samplerate);

      // if last AAC frame is overflowing, we should ensure timestamps are contiguous:
      // first sample PTS should be equal to last sample PTS + frameDuration
      if (aacOverFlow && aacLastPTS) {
        var newPTS = aacLastPTS + frameDuration;
        if (Math.abs(newPTS - pts) > 1) {
          _logger.logger.log('AAC: align PTS for overlapping frames by ' + Math.round((newPTS - pts) / 90));
          pts = newPTS;
        }
      }

      //scan for aac samples
      while (offset < len) {
        if (_adts2.default.isHeader(data, offset) && offset + 5 < len) {
          var frame = _adts2.default.appendFrame(track, data, offset, pts, frameIndex);
          if (frame) {
            //logger.log(`${Math.round(frame.sample.pts)} : AAC`);
            offset += frame.length;
            stamp = frame.sample.pts;
            frameIndex++;
          } else {
            //logger.log('Unable to parse AAC frame');
            break;
          }
        } else {
          //nothing found, keep looking
          offset++;
        }
      }

      if (offset < len) {
        aacOverFlow = data.subarray(offset, len);
        //logger.log(`AAC: overflow detected:${len-offset}`);
      } else {
        aacOverFlow = null;
      }
      this.aacOverFlow = aacOverFlow;
      this.aacLastPTS = stamp;
    }
  }, {
    key: '_parseMPEGPES',
    value: function _parseMPEGPES(pes) {
      var data = pes.data;
      var length = data.length;
      var frameIndex = 0;
      var offset = 0;
      var pts = pes.pts;

      while (offset < length) {
        if (_mpegaudio2.default.isHeader(data, offset)) {
          var frame = _mpegaudio2.default.appendFrame(this._audioTrack, data, offset, pts, frameIndex);
          if (frame) {
            offset += frame.length;
            frameIndex++;
          } else {
            //logger.log('Unable to parse Mpeg audio frame');
            break;
          }
        } else {
          //nothing found, keep looking
          offset++;
        }
      }
    }
  }, {
    key: '_parseID3PES',
    value: function _parseID3PES(pes) {
      this._id3Track.samples.push(pes);
    }
  }], [{
    key: 'probe',
    value: function probe(data) {
      // a TS fragment should contain at least 3 TS packets, a PAT, a PMT, and one PID, each starting with 0x47
      if (data.length >= 3 * 188 && data[0] === 0x47 && data[188] === 0x47 && data[2 * 188] === 0x47) {
        return true;
      } else {
        return false;
      }
    }
  }]);

  return TSDemuxer;
}();

exports.default = TSDemuxer;

},{"../errors":33,"../events":35,"../utils/logger":54,"./adts":22,"./exp-golomb":26,"./mpegaudio":30,"./sample-aes":31}],33:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
var ErrorTypes = exports.ErrorTypes = {
  // Identifier for a network error (loading error / timeout ...)
  NETWORK_ERROR: 'networkError',
  // Identifier for a media Error (video/parsing/mediasource error)
  MEDIA_ERROR: 'mediaError',
  // Identifier for a mux Error (demuxing/remuxing)
  MUX_ERROR: 'muxError',
  // Identifier for all other errors
  OTHER_ERROR: 'otherError'
};

var ErrorDetails = exports.ErrorDetails = {
  // Identifier for a manifest load error - data: { url : faulty URL, response : { code: error code, text: error text }}
  MANIFEST_LOAD_ERROR: 'manifestLoadError',
  // Identifier for a manifest load timeout - data: { url : faulty URL, response : { code: error code, text: error text }}
  MANIFEST_LOAD_TIMEOUT: 'manifestLoadTimeOut',
  // Identifier for a manifest parsing error - data: { url : faulty URL, reason : error reason}
  MANIFEST_PARSING_ERROR: 'manifestParsingError',
  // Identifier for a manifest with only incompatible codecs error - data: { url : faulty URL, reason : error reason}
  MANIFEST_INCOMPATIBLE_CODECS_ERROR: 'manifestIncompatibleCodecsError',
  // Identifier for a level load error - data: { url : faulty URL, response : { code: error code, text: error text }}
  LEVEL_LOAD_ERROR: 'levelLoadError',
  // Identifier for a level load timeout - data: { url : faulty URL, response : { code: error code, text: error text }}
  LEVEL_LOAD_TIMEOUT: 'levelLoadTimeOut',
  // Identifier for a level switch error - data: { level : faulty level Id, event : error description}
  LEVEL_SWITCH_ERROR: 'levelSwitchError',
  // Identifier for an audio track load error - data: { url : faulty URL, response : { code: error code, text: error text }}
  AUDIO_TRACK_LOAD_ERROR: 'audioTrackLoadError',
  // Identifier for an audio track load timeout - data: { url : faulty URL, response : { code: error code, text: error text }}
  AUDIO_TRACK_LOAD_TIMEOUT: 'audioTrackLoadTimeOut',
  // Identifier for fragment load error - data: { frag : fragment object, response : { code: error code, text: error text }}
  FRAG_LOAD_ERROR: 'fragLoadError',
  // Identifier for fragment loop loading error - data: { frag : fragment object}
  FRAG_LOOP_LOADING_ERROR: 'fragLoopLoadingError',
  // Identifier for fragment load timeout error - data: { frag : fragment object}
  FRAG_LOAD_TIMEOUT: 'fragLoadTimeOut',
  // Identifier for a fragment decryption error event - data: {id : demuxer Id,frag: fragment object, reason : parsing error description }
  FRAG_DECRYPT_ERROR: 'fragDecryptError',
  // Identifier for a fragment parsing error event - data: { id : demuxer Id, reason : parsing error description }
  // will be renamed DEMUX_PARSING_ERROR and switched to MUX_ERROR in the next major release
  FRAG_PARSING_ERROR: 'fragParsingError',
  // Identifier for a remux alloc error event - data: { id : demuxer Id, frag : fragment object, bytes : nb of bytes on which allocation failed , reason : error text }
  REMUX_ALLOC_ERROR: 'remuxAllocError',
  // Identifier for decrypt key load error - data: { frag : fragment object, response : { code: error code, text: error text }}
  KEY_LOAD_ERROR: 'keyLoadError',
  // Identifier for decrypt key load timeout error - data: { frag : fragment object}
  KEY_LOAD_TIMEOUT: 'keyLoadTimeOut',
  // Triggered when an exception occurs while adding a sourceBuffer to MediaSource - data : {  err : exception , mimeType : mimeType }
  BUFFER_ADD_CODEC_ERROR: 'bufferAddCodecError',
  // Identifier for a buffer append error - data: append error description
  BUFFER_APPEND_ERROR: 'bufferAppendError',
  // Identifier for a buffer appending error event - data: appending error description
  BUFFER_APPENDING_ERROR: 'bufferAppendingError',
  // Identifier for a buffer stalled error event
  BUFFER_STALLED_ERROR: 'bufferStalledError',
  // Identifier for a buffer full event
  BUFFER_FULL_ERROR: 'bufferFullError',
  // Identifier for a buffer seek over hole event
  BUFFER_SEEK_OVER_HOLE: 'bufferSeekOverHole',
  // Identifier for a buffer nudge on stall (playback is stuck although currentTime is in a buffered area)
  BUFFER_NUDGE_ON_STALL: 'bufferNudgeOnStall',
  // Identifier for an internal exception happening inside hls.js while handling an event
  INTERNAL_EXCEPTION: 'internalException',
  // Malformed WebVTT contents
  WEBVTT_EXCEPTION: 'webVTTException'
};

},{}],34:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     * All objects in the event handling chain should inherit from this class
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */

var _logger = require('./utils/logger');

var _errors = require('./errors');

var _events = require('./events');

var _events2 = _interopRequireDefault(_events);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var EventHandler = function () {
  function EventHandler(hls) {
    _classCallCheck(this, EventHandler);

    this.hls = hls;
    this.onEvent = this.onEvent.bind(this);

    for (var _len = arguments.length, events = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      events[_key - 1] = arguments[_key];
    }

    this.handledEvents = events;
    this.useGenericHandler = true;

    this.registerListeners();
  }

  _createClass(EventHandler, [{
    key: 'destroy',
    value: function destroy() {
      this.unregisterListeners();
    }
  }, {
    key: 'isEventHandler',
    value: function isEventHandler() {
      return _typeof(this.handledEvents) === 'object' && this.handledEvents.length && typeof this.onEvent === 'function';
    }
  }, {
    key: 'registerListeners',
    value: function registerListeners() {
      if (this.isEventHandler()) {
        this.handledEvents.forEach(function (event) {
          if (event === 'hlsEventGeneric') {
            throw new Error('Forbidden event name: ' + event);
          }
          this.hls.on(event, this.onEvent);
        }, this);
      }
    }
  }, {
    key: 'unregisterListeners',
    value: function unregisterListeners() {
      if (this.isEventHandler()) {
        this.handledEvents.forEach(function (event) {
          this.hls.off(event, this.onEvent);
        }, this);
      }
    }

    /**
     * arguments: event (string), data (any)
     */

  }, {
    key: 'onEvent',
    value: function onEvent(event, data) {
      this.onEventGeneric(event, data);
    }
  }, {
    key: 'onEventGeneric',
    value: function onEventGeneric(event, data) {
      var eventToFunction = function eventToFunction(event, data) {
        var funcName = 'on' + event.replace('hls', '');
        if (typeof this[funcName] !== 'function') {
          throw new Error('Event ' + event + ' has no generic handler in this ' + this.constructor.name + ' class (tried ' + funcName + ')');
        }
        return this[funcName].bind(this, data);
      };
      try {
        eventToFunction.call(this, event, data).call();
      } catch (err) {
        _logger.logger.error('internal error happened while processing ' + event + ':' + err.message);
        this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.OTHER_ERROR, details: _errors.ErrorDetails.INTERNAL_EXCEPTION, fatal: false, event: event, err: err });
      }
    }
  }]);

  return EventHandler;
}();

exports.default = EventHandler;

},{"./errors":33,"./events":35,"./utils/logger":54}],35:[function(require,module,exports){
'use strict';

module.exports = {
  // fired before MediaSource is attaching to media element - data: { media }
  MEDIA_ATTACHING: 'hlsMediaAttaching',
  // fired when MediaSource has been succesfully attached to media element - data: { }
  MEDIA_ATTACHED: 'hlsMediaAttached',
  // fired before detaching MediaSource from media element - data: { }
  MEDIA_DETACHING: 'hlsMediaDetaching',
  // fired when MediaSource has been detached from media element - data: { }
  MEDIA_DETACHED: 'hlsMediaDetached',
  // fired when we buffer is going to be reset - data: { }
  BUFFER_RESET: 'hlsBufferReset',
  // fired when we know about the codecs that we need buffers for to push into - data: {tracks : { container, codec, levelCodec, initSegment, metadata }}
  BUFFER_CODECS: 'hlsBufferCodecs',
  // fired when sourcebuffers have been created - data: { tracks : tracks }
  BUFFER_CREATED: 'hlsBufferCreated',
  // fired when we append a segment to the buffer - data: { segment: segment object }
  BUFFER_APPENDING: 'hlsBufferAppending',
  // fired when we are done with appending a media segment to the buffer - data : { parent : segment parent that triggered BUFFER_APPENDING, pending : nb of segments waiting for appending for this segment parent}
  BUFFER_APPENDED: 'hlsBufferAppended',
  // fired when the stream is finished and we want to notify the media buffer that there will be no more data - data: { }
  BUFFER_EOS: 'hlsBufferEos',
  // fired when the media buffer should be flushed - data { startOffset, endOffset }
  BUFFER_FLUSHING: 'hlsBufferFlushing',
  // fired when the media buffer has been flushed - data: { }
  BUFFER_FLUSHED: 'hlsBufferFlushed',
  // fired to signal that a manifest loading starts - data: { url : manifestURL}
  MANIFEST_LOADING: 'hlsManifestLoading',
  // fired after manifest has been loaded - data: { levels : [available quality levels], audioTracks : [ available audio tracks], url : manifestURL, stats : { trequest, tfirst, tload, mtime}}
  MANIFEST_LOADED: 'hlsManifestLoaded',
  // fired after manifest has been parsed - data: { levels : [available quality levels], firstLevel : index of first quality level appearing in Manifest}
  MANIFEST_PARSED: 'hlsManifestParsed',
  // fired when a level switch is requested - data: { level : id of new level } // deprecated in favor LEVEL_SWITCHING
  LEVEL_SWITCH: 'hlsLevelSwitch',
  // fired when a level switch is requested - data: { level : id of new level }
  LEVEL_SWITCHING: 'hlsLevelSwitching',
  // fired when a level switch is effective - data: { level : id of new level }
  LEVEL_SWITCHED: 'hlsLevelSwitched',
  // fired when a level playlist loading starts - data: { url : level URL, level : id of level being loaded}
  LEVEL_LOADING: 'hlsLevelLoading',
  // fired when a level playlist loading finishes - data: { details : levelDetails object, level : id of loaded level, stats : { trequest, tfirst, tload, mtime} }
  LEVEL_LOADED: 'hlsLevelLoaded',
  // fired when a level's details have been updated based on previous details, after it has been loaded - data: { details : levelDetails object, level : id of updated level }
  LEVEL_UPDATED: 'hlsLevelUpdated',
  // fired when a level's PTS information has been updated after parsing a fragment - data: { details : levelDetails object, level : id of updated level, drift: PTS drift observed when parsing last fragment }
  LEVEL_PTS_UPDATED: 'hlsLevelPtsUpdated',
  // fired to notify that audio track lists has been updated - data: { audioTracks : audioTracks }
  AUDIO_TRACKS_UPDATED: 'hlsAudioTracksUpdated',
  // fired when an audio track switch occurs - data: { id : audio track id } // deprecated in favor AUDIO_TRACK_SWITCHING
  AUDIO_TRACK_SWITCH: 'hlsAudioTrackSwitch',
  // fired when an audio track switching is requested - data: { id : audio track id }
  AUDIO_TRACK_SWITCHING: 'hlsAudioTrackSwitching',
  // fired when an audio track switch actually occurs - data: { id : audio track id }
  AUDIO_TRACK_SWITCHED: 'hlsAudioTrackSwitched',
  // fired when an audio track loading starts - data: { url : audio track URL, id : audio track id }
  AUDIO_TRACK_LOADING: 'hlsAudioTrackLoading',
  // fired when an audio track loading finishes - data: { details : levelDetails object, id : audio track id, stats : { trequest, tfirst, tload, mtime } }
  AUDIO_TRACK_LOADED: 'hlsAudioTrackLoaded',
  // fired to notify that subtitle track lists has been updated - data: { subtitleTracks : subtitleTracks }
  SUBTITLE_TRACKS_UPDATED: 'hlsSubtitleTracksUpdated',
  // fired when an subtitle track switch occurs - data: { id : subtitle track id }
  SUBTITLE_TRACK_SWITCH: 'hlsSubtitleTrackSwitch',
  // fired when a subtitle track loading starts - data: { url : subtitle track URL, id : subtitle track id }
  SUBTITLE_TRACK_LOADING: 'hlsSubtitleTrackLoading',
  // fired when a subtitle track loading finishes - data: { details : levelDetails object, id : subtitle track id, stats : { trequest, tfirst, tload, mtime } }
  SUBTITLE_TRACK_LOADED: 'hlsSubtitleTrackLoaded',
  // fired when a subtitle fragment has been processed - data: { success : boolean, frag : the processed frag }
  SUBTITLE_FRAG_PROCESSED: 'hlsSubtitleFragProcessed',
  // fired when the first timestamp is found - data: { id : demuxer id, initPTS: initPTS, frag : fragment object }
  INIT_PTS_FOUND: 'hlsInitPtsFound',
  // fired when a fragment loading starts - data: { frag : fragment object }
  FRAG_LOADING: 'hlsFragLoading',
  // fired when a fragment loading is progressing - data: { frag : fragment object, { trequest, tfirst, loaded } }
  FRAG_LOAD_PROGRESS: 'hlsFragLoadProgress',
  // Identifier for fragment load aborting for emergency switch down - data: { frag : fragment object }
  FRAG_LOAD_EMERGENCY_ABORTED: 'hlsFragLoadEmergencyAborted',
  // fired when a fragment loading is completed - data: { frag : fragment object, payload : fragment payload, stats : { trequest, tfirst, tload, length } }
  FRAG_LOADED: 'hlsFragLoaded',
  // fired when a fragment has finished decrypting - data: { id : demuxer id, frag: fragment object, stats : { tstart, tdecrypt } }
  FRAG_DECRYPTED: 'hlsFragDecrypted',
  // fired when Init Segment has been extracted from fragment - data: { id : demuxer id, frag: fragment object, moov : moov MP4 box, codecs : codecs found while parsing fragment }
  FRAG_PARSING_INIT_SEGMENT: 'hlsFragParsingInitSegment',
  // fired when parsing sei text is completed - data: { id : demuxer id, frag: fragment object, samples : [ sei samples pes ] }
  FRAG_PARSING_USERDATA: 'hlsFragParsingUserdata',
  // fired when parsing id3 is completed - data: { id : demuxer id, frag: fragment object, samples : [ id3 samples pes ] }
  FRAG_PARSING_METADATA: 'hlsFragParsingMetadata',
  // fired when data have been extracted from fragment - data: { id : demuxer id, frag: fragment object, data1 : moof MP4 box or TS fragments, data2 : mdat MP4 box or null}
  FRAG_PARSING_DATA: 'hlsFragParsingData',
  // fired when fragment parsing is completed - data: { id : demuxer id, frag: fragment object }
  FRAG_PARSED: 'hlsFragParsed',
  // fired when fragment remuxed MP4 boxes have all been appended into SourceBuffer - data: { id : demuxer id, frag : fragment object, stats : { trequest, tfirst, tload, tparsed, tbuffered, length, bwEstimate } }
  FRAG_BUFFERED: 'hlsFragBuffered',
  // fired when fragment matching with current media position is changing - data : { id : demuxer id, frag : fragment object }
  FRAG_CHANGED: 'hlsFragChanged',
  // Identifier for a FPS drop event - data: { curentDropped, currentDecoded, totalDroppedFrames }
  FPS_DROP: 'hlsFpsDrop',
  //triggered when FPS drop triggers auto level capping - data: { level, droppedlevel }
  FPS_DROP_LEVEL_CAPPING: 'hlsFpsDropLevelCapping',
  // Identifier for an error event - data: { type : error type, details : error details, fatal : if true, hls.js cannot/will not try to recover, if false, hls.js will try to recover,other error specific data }
  ERROR: 'hlsError',
  // fired when hls.js instance starts destroying. Different from MEDIA_DETACHED as one could want to detach and reattach a media to the instance of hls.js to handle mid-rolls for example - data: { }
  DESTROYING: 'hlsDestroying',
  // fired when a decrypt key loading starts - data: { frag : fragment object }
  KEY_LOADING: 'hlsKeyLoading',
  // fired when a decrypt key loading is completed - data: { frag : fragment object, payload : key payload, stats : { trequest, tfirst, tload, length } }
  KEY_LOADED: 'hlsKeyLoaded',
  // fired upon stream controller state transitions - data: { previousState, nextState }
  STREAM_STATE_TRANSITION: 'hlsStreamStateTransition'
};

},{}],36:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 *  AAC helper
 */

var AAC = function () {
  function AAC() {
    _classCallCheck(this, AAC);
  }

  _createClass(AAC, null, [{
    key: 'getSilentFrame',
    value: function getSilentFrame(codec, channelCount) {
      switch (codec) {
        case 'mp4a.40.2':
          if (channelCount === 1) {
            return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x23, 0x80]);
          } else if (channelCount === 2) {
            return new Uint8Array([0x21, 0x00, 0x49, 0x90, 0x02, 0x19, 0x00, 0x23, 0x80]);
          } else if (channelCount === 3) {
            return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x8e]);
          } else if (channelCount === 4) {
            return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x80, 0x2c, 0x80, 0x08, 0x02, 0x38]);
          } else if (channelCount === 5) {
            return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x82, 0x30, 0x04, 0x99, 0x00, 0x21, 0x90, 0x02, 0x38]);
          } else if (channelCount === 6) {
            return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x82, 0x30, 0x04, 0x99, 0x00, 0x21, 0x90, 0x02, 0x00, 0xb2, 0x00, 0x20, 0x08, 0xe0]);
          }
          break;
        // handle HE-AAC below (mp4a.40.5 / mp4a.40.29)
        default:
          if (channelCount === 1) {
            // ffmpeg -y -f lavfi -i "aevalsrc=0:d=0.05" -c:a libfdk_aac -profile:a aac_he -b:a 4k output.aac && hexdump -v -e '16/1 "0x%x," "\n"' -v output.aac
            return new Uint8Array([0x1, 0x40, 0x22, 0x80, 0xa3, 0x4e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0, 0x0, 0x1c, 0x6, 0xf1, 0xc1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5e]);
          } else if (channelCount === 2) {
            // ffmpeg -y -f lavfi -i "aevalsrc=0|0:d=0.05" -c:a libfdk_aac -profile:a aac_he_v2 -b:a 4k output.aac && hexdump -v -e '16/1 "0x%x," "\n"' -v output.aac
            return new Uint8Array([0x1, 0x40, 0x22, 0x80, 0xa3, 0x5e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0, 0x0, 0x0, 0x95, 0x0, 0x6, 0xf1, 0xa1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5e]);
          } else if (channelCount === 3) {
            // ffmpeg -y -f lavfi -i "aevalsrc=0|0|0:d=0.05" -c:a libfdk_aac -profile:a aac_he_v2 -b:a 4k output.aac && hexdump -v -e '16/1 "0x%x," "\n"' -v output.aac
            return new Uint8Array([0x1, 0x40, 0x22, 0x80, 0xa3, 0x5e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0, 0x0, 0x0, 0x95, 0x0, 0x6, 0xf1, 0xa1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5e]);
          }
          break;
      }
      return null;
    }
  }]);

  return AAC;
}();

exports.default = AAC;

},{}],37:[function(require,module,exports){
"use strict";

/**
 * Buffer Helper utils, providing methods dealing buffer length retrieval
*/

var BufferHelper = {
  isBuffered: function isBuffered(media, position) {
    if (media) {
      var buffered = media.buffered;
      for (var i = 0; i < buffered.length; i++) {
        if (position >= buffered.start(i) && position <= buffered.end(i)) {
          return true;
        }
      }
    }
    return false;
  },

  bufferInfo: function bufferInfo(media, pos, maxHoleDuration) {
    if (media) {
      var vbuffered = media.buffered,
          buffered = [],
          i;
      for (i = 0; i < vbuffered.length; i++) {
        buffered.push({ start: vbuffered.start(i), end: vbuffered.end(i) });
      }
      return this.bufferedInfo(buffered, pos, maxHoleDuration);
    } else {
      return { len: 0, start: pos, end: pos, nextStart: undefined };
    }
  },

  bufferedInfo: function bufferedInfo(buffered, pos, maxHoleDuration) {
    var buffered2 = [],

    // bufferStart and bufferEnd are buffer boundaries around current video position
    bufferLen,
        bufferStart,
        bufferEnd,
        bufferStartNext,
        i;
    // sort on buffer.start/smaller end (IE does not always return sorted buffered range)
    buffered.sort(function (a, b) {
      var diff = a.start - b.start;
      if (diff) {
        return diff;
      } else {
        return b.end - a.end;
      }
    });
    // there might be some small holes between buffer time range
    // consider that holes smaller than maxHoleDuration are irrelevant and build another
    // buffer time range representations that discards those holes
    for (i = 0; i < buffered.length; i++) {
      var buf2len = buffered2.length;
      if (buf2len) {
        var buf2end = buffered2[buf2len - 1].end;
        // if small hole (value between 0 or maxHoleDuration ) or overlapping (negative)
        if (buffered[i].start - buf2end < maxHoleDuration) {
          // merge overlapping time ranges
          // update lastRange.end only if smaller than item.end
          // e.g.  [ 1, 15] with  [ 2,8] => [ 1,15] (no need to modify lastRange.end)
          // whereas [ 1, 8] with  [ 2,15] => [ 1,15] ( lastRange should switch from [1,8] to [1,15])
          if (buffered[i].end > buf2end) {
            buffered2[buf2len - 1].end = buffered[i].end;
          }
        } else {
          // big hole
          buffered2.push(buffered[i]);
        }
      } else {
        // first value
        buffered2.push(buffered[i]);
      }
    }
    for (i = 0, bufferLen = 0, bufferStart = bufferEnd = pos; i < buffered2.length; i++) {
      var start = buffered2[i].start,
          end = buffered2[i].end;
      //logger.log('buf start/end:' + buffered.start(i) + '/' + buffered.end(i));
      if (pos + maxHoleDuration >= start && pos < end) {
        // play position is inside this buffer TimeRange, retrieve end of buffer position and buffer length
        bufferStart = start;
        bufferEnd = end;
        bufferLen = bufferEnd - pos;
      } else if (pos + maxHoleDuration < start) {
        bufferStartNext = start;
        break;
      }
    }
    return { len: bufferLen, start: bufferStart, end: bufferEnd, nextStart: bufferStartNext };
  }
};

module.exports = BufferHelper;

},{}],38:[function(require,module,exports){
'use strict';

var _logger = require('../utils/logger');

var LevelHelper = {

  mergeDetails: function mergeDetails(oldDetails, newDetails) {
    var start = Math.max(oldDetails.startSN, newDetails.startSN) - newDetails.startSN,
        end = Math.min(oldDetails.endSN, newDetails.endSN) - newDetails.startSN,
        delta = newDetails.startSN - oldDetails.startSN,
        oldfragments = oldDetails.fragments,
        newfragments = newDetails.fragments,
        ccOffset = 0,
        PTSFrag;

    // check if old/new playlists have fragments in common
    if (end < start) {
      newDetails.PTSKnown = false;
      return;
    }
    // loop through overlapping SN and update startPTS , cc, and duration if any found
    for (var i = start; i <= end; i++) {
      var oldFrag = oldfragments[delta + i],
          newFrag = newfragments[i];
      if (newFrag && oldFrag) {
        ccOffset = oldFrag.cc - newFrag.cc;
        if (!isNaN(oldFrag.startPTS)) {
          newFrag.start = newFrag.startPTS = oldFrag.startPTS;
          newFrag.endPTS = oldFrag.endPTS;
          newFrag.duration = oldFrag.duration;
          newFrag.backtracked = oldFrag.backtracked;
          newFrag.dropped = oldFrag.dropped;
          PTSFrag = newFrag;
        }
      }
    }

    if (ccOffset) {
      _logger.logger.log('discontinuity sliding from playlist, take drift into account');
      for (i = 0; i < newfragments.length; i++) {
        newfragments[i].cc += ccOffset;
      }
    }

    // if at least one fragment contains PTS info, recompute PTS information for all fragments
    if (PTSFrag) {
      LevelHelper.updateFragPTSDTS(newDetails, PTSFrag, PTSFrag.startPTS, PTSFrag.endPTS, PTSFrag.startDTS, PTSFrag.endDTS);
    } else {
      // ensure that delta is within oldfragments range
      // also adjust sliding in case delta is 0 (we could have old=[50-60] and new=old=[50-61])
      // in that case we also need to adjust start offset of all fragments
      if (delta >= 0 && delta < oldfragments.length) {
        // adjust start by sliding offset
        var sliding = oldfragments[delta].start;
        for (i = 0; i < newfragments.length; i++) {
          newfragments[i].start += sliding;
        }
      }
    }
    // if we are here, it means we have fragments overlapping between
    // old and new level. reliable PTS info is thus relying on old level
    newDetails.PTSKnown = oldDetails.PTSKnown;
    return;
  },

  updateFragPTSDTS: function updateFragPTSDTS(details, frag, startPTS, endPTS, startDTS, endDTS) {
    // update frag PTS/DTS
    var maxStartPTS = startPTS;
    if (!isNaN(frag.startPTS)) {
      // delta PTS between audio and video
      var deltaPTS = Math.abs(frag.startPTS - startPTS);
      if (isNaN(frag.deltaPTS)) {
        frag.deltaPTS = deltaPTS;
      } else {
        frag.deltaPTS = Math.max(deltaPTS, frag.deltaPTS);
      }
      maxStartPTS = Math.max(startPTS, frag.startPTS);
      startPTS = Math.min(startPTS, frag.startPTS);
      endPTS = Math.max(endPTS, frag.endPTS);
      startDTS = Math.min(startDTS, frag.startDTS);
      endDTS = Math.max(endDTS, frag.endDTS);
    }

    var drift = startPTS - frag.start;
    frag.start = frag.startPTS = startPTS;
    frag.maxStartPTS = maxStartPTS;
    frag.endPTS = endPTS;
    frag.startDTS = startDTS;
    frag.endDTS = endDTS;
    frag.duration = endPTS - startPTS;

    var sn = frag.sn;
    // exit if sn out of range
    if (!details || sn < details.startSN || sn > details.endSN) {
      return 0;
    }
    var fragIdx, fragments, i;
    fragIdx = sn - details.startSN;
    fragments = details.fragments;
    frag = fragments[fragIdx];
    // adjust fragment PTS/duration from seqnum-1 to frag 0
    for (i = fragIdx; i > 0; i--) {
      LevelHelper.updatePTS(fragments, i, i - 1);
    }

    // adjust fragment PTS/duration from seqnum to last frag
    for (i = fragIdx; i < fragments.length - 1; i++) {
      LevelHelper.updatePTS(fragments, i, i + 1);
    }
    details.PTSKnown = true;
    //logger.log(`                                            frag start/end:${startPTS.toFixed(3)}/${endPTS.toFixed(3)}`);

    return drift;
  },

  updatePTS: function updatePTS(fragments, fromIdx, toIdx) {
    var fragFrom = fragments[fromIdx],
        fragTo = fragments[toIdx],
        fragToPTS = fragTo.startPTS;
    // if we know startPTS[toIdx]
    if (!isNaN(fragToPTS)) {
      // update fragment duration.
      // it helps to fix drifts between playlist reported duration and fragment real duration
      if (toIdx > fromIdx) {
        fragFrom.duration = fragToPTS - fragFrom.start;
        if (fragFrom.duration < 0) {
          _logger.logger.warn('negative duration computed for frag ' + fragFrom.sn + ',level ' + fragFrom.level + ', there should be some duration drift between playlist and fragment!');
        }
      } else {
        fragTo.duration = fragFrom.start - fragToPTS;
        if (fragTo.duration < 0) {
          _logger.logger.warn('negative duration computed for frag ' + fragTo.sn + ',level ' + fragTo.level + ', there should be some duration drift between playlist and fragment!');
        }
      }
    } else {
      // we dont know startPTS[toIdx]
      if (toIdx > fromIdx) {
        fragTo.start = fragFrom.start + fragFrom.duration;
      } else {
        fragTo.start = Math.max(fragFrom.start - fragTo.duration, 0);
      }
    }
  }
}; /**
    * Level Helper class, providing methods dealing with playlist sliding and drift
   */

module.exports = LevelHelper;

},{"../utils/logger":54}],39:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * HLS interface
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */


var _urlToolkit = require('url-toolkit');

var _urlToolkit2 = _interopRequireDefault(_urlToolkit);

var _events = require('./events');

var _events2 = _interopRequireDefault(_events);

var _errors = require('./errors');

var _playlistLoader = require('./loader/playlist-loader');

var _playlistLoader2 = _interopRequireDefault(_playlistLoader);

var _fragmentLoader = require('./loader/fragment-loader');

var _fragmentLoader2 = _interopRequireDefault(_fragmentLoader);

var _keyLoader = require('./loader/key-loader');

var _keyLoader2 = _interopRequireDefault(_keyLoader);

var _streamController = require('./controller/stream-controller');

var _streamController2 = _interopRequireDefault(_streamController);

var _levelController = require('./controller/level-controller');

var _levelController2 = _interopRequireDefault(_levelController);

var _id3TrackController = require('./controller/id3-track-controller');

var _id3TrackController2 = _interopRequireDefault(_id3TrackController);

var _logger = require('./utils/logger');

var _events3 = require('events');

var _events4 = _interopRequireDefault(_events3);

var _config = require('./config');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Hls = function () {
  _createClass(Hls, null, [{
    key: 'isSupported',
    value: function isSupported() {
      var mediaSource = window.MediaSource = window.MediaSource || window.WebKitMediaSource;
      var sourceBuffer = window.SourceBuffer = window.SourceBuffer || window.WebKitSourceBuffer;
      var isTypeSupported = mediaSource && typeof mediaSource.isTypeSupported === 'function' && mediaSource.isTypeSupported('video/mp4; codecs="avc1.42E01E,mp4a.40.2"');

      // if SourceBuffer is exposed ensure its API is valid
      // safari and old version of Chrome doe not expose SourceBuffer globally so checking SourceBuffer.prototype is impossible
      var sourceBufferValidAPI = !sourceBuffer || sourceBuffer.prototype && typeof sourceBuffer.prototype.appendBuffer === 'function' && typeof sourceBuffer.prototype.remove === 'function';
      return isTypeSupported && sourceBufferValidAPI;
    }
  }, {
    key: 'version',
    get: function get() {
      // replaced with browserify-versionify transform
      return '__VERSION__';
    }
  }, {
    key: 'Events',
    get: function get() {
      return _events2.default;
    }
  }, {
    key: 'ErrorTypes',
    get: function get() {
      return _errors.ErrorTypes;
    }
  }, {
    key: 'ErrorDetails',
    get: function get() {
      return _errors.ErrorDetails;
    }
  }, {
    key: 'DefaultConfig',
    get: function get() {
      if (!Hls.defaultConfig) {
        return _config.hlsDefaultConfig;
      }
      return Hls.defaultConfig;
    },
    set: function set(defaultConfig) {
      Hls.defaultConfig = defaultConfig;
    }
  }]);

  function Hls() {
    var _this = this;

    var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, Hls);

    var defaultConfig = Hls.DefaultConfig;

    if ((config.liveSyncDurationCount || config.liveMaxLatencyDurationCount) && (config.liveSyncDuration || config.liveMaxLatencyDuration)) {
      throw new Error('Illegal hls.js config: don\'t mix up liveSyncDurationCount/liveMaxLatencyDurationCount and liveSyncDuration/liveMaxLatencyDuration');
    }

    for (var prop in defaultConfig) {
      if (prop in config) {
        continue;
      }
      config[prop] = defaultConfig[prop];
    }

    if (config.liveMaxLatencyDurationCount !== undefined && config.liveMaxLatencyDurationCount <= config.liveSyncDurationCount) {
      throw new Error('Illegal hls.js config: "liveMaxLatencyDurationCount" must be gt "liveSyncDurationCount"');
    }

    if (config.liveMaxLatencyDuration !== undefined && (config.liveMaxLatencyDuration <= config.liveSyncDuration || config.liveSyncDuration === undefined)) {
      throw new Error('Illegal hls.js config: "liveMaxLatencyDuration" must be gt "liveSyncDuration"');
    }

    (0, _logger.enableLogs)(config.debug);
    this.config = config;
    this._autoLevelCapping = -1;
    // observer setup
    var observer = this.observer = new _events4.default();
    observer.trigger = function trigger(event) {
      for (var _len = arguments.length, data = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        data[_key - 1] = arguments[_key];
      }

      observer.emit.apply(observer, [event, event].concat(data));
    };

    observer.off = function off(event) {
      for (var _len2 = arguments.length, data = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        data[_key2 - 1] = arguments[_key2];
      }

      observer.removeListener.apply(observer, [event].concat(data));
    };
    this.on = observer.on.bind(observer);
    this.off = observer.off.bind(observer);
    this.trigger = observer.trigger.bind(observer);

    // core controllers and network loaders
    var abrController = this.abrController = new config.abrController(this);
    var bufferController = new config.bufferController(this);
    var capLevelController = new config.capLevelController(this);
    var fpsController = new config.fpsController(this);
    var playListLoader = new _playlistLoader2.default(this);
    var fragmentLoader = new _fragmentLoader2.default(this);
    var keyLoader = new _keyLoader2.default(this);
    var id3TrackController = new _id3TrackController2.default(this);

    // network controllers
    var levelController = this.levelController = new _levelController2.default(this);
    var streamController = this.streamController = new _streamController2.default(this);
    var networkControllers = [levelController, streamController];

    // optional audio stream controller
    var Controller = config.audioStreamController;
    if (Controller) {
      networkControllers.push(new Controller(this));
    }
    this.networkControllers = networkControllers;

    var coreComponents = [playListLoader, fragmentLoader, keyLoader, abrController, bufferController, capLevelController, fpsController, id3TrackController];

    // optional audio track and subtitle controller
    Controller = config.audioTrackController;
    if (Controller) {
      var audioTrackController = new Controller(this);
      this.audioTrackController = audioTrackController;
      coreComponents.push(audioTrackController);
    }

    Controller = config.subtitleTrackController;
    if (Controller) {
      var subtitleTrackController = new Controller(this);
      this.subtitleTrackController = subtitleTrackController;
      coreComponents.push(subtitleTrackController);
    }

    // optional subtitle controller
    [config.subtitleStreamController, config.timelineController].forEach(function (Controller) {
      if (Controller) {
        coreComponents.push(new Controller(_this));
      }
    });
    this.coreComponents = coreComponents;
  }

  _createClass(Hls, [{
    key: 'destroy',
    value: function destroy() {
      _logger.logger.log('destroy');
      this.trigger(_events2.default.DESTROYING);
      this.detachMedia();
      this.coreComponents.concat(this.networkControllers).forEach(function (component) {
        component.destroy();
      });
      this.url = null;
      this.observer.removeAllListeners();
      this._autoLevelCapping = -1;
    }
  }, {
    key: 'attachMedia',
    value: function attachMedia(media) {
      _logger.logger.log('attachMedia');
      this.media = media;
      this.trigger(_events2.default.MEDIA_ATTACHING, { media: media });
    }
  }, {
    key: 'detachMedia',
    value: function detachMedia() {
      _logger.logger.log('detachMedia');
      this.trigger(_events2.default.MEDIA_DETACHING);
      this.media = null;
    }
  }, {
    key: 'loadSource',
    value: function loadSource(url) {
      url = _urlToolkit2.default.buildAbsoluteURL(window.location.href, url, { alwaysNormalize: true });
      _logger.logger.log('loadSource:' + url);
      this.url = url;
      // when attaching to a source URL, trigger a playlist load
      this.trigger(_events2.default.MANIFEST_LOADING, { url: url });
    }
  }, {
    key: 'startLoad',
    value: function startLoad() {
      var startPosition = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : -1;

      _logger.logger.log('startLoad(' + startPosition + ')');
      this.networkControllers.forEach(function (controller) {
        controller.startLoad(startPosition);
      });
    }
  }, {
    key: 'stopLoad',
    value: function stopLoad() {
      _logger.logger.log('stopLoad');
      this.networkControllers.forEach(function (controller) {
        controller.stopLoad();
      });
    }
  }, {
    key: 'swapAudioCodec',
    value: function swapAudioCodec() {
      _logger.logger.log('swapAudioCodec');
      this.streamController.swapAudioCodec();
    }
  }, {
    key: 'recoverMediaError',
    value: function recoverMediaError() {
      _logger.logger.log('recoverMediaError');
      var media = this.media;
      this.detachMedia();
      this.attachMedia(media);
    }

    /** Return all quality levels **/

  }, {
    key: 'levels',
    get: function get() {
      return this.levelController.levels;
    }

    /** Return current playback quality level **/

  }, {
    key: 'currentLevel',
    get: function get() {
      return this.streamController.currentLevel;
    }

    /* set quality level immediately (-1 for automatic level selection) */
    ,
    set: function set(newLevel) {
      _logger.logger.log('set currentLevel:' + newLevel);
      this.loadLevel = newLevel;
      this.streamController.immediateLevelSwitch();
    }

    /** Return next playback quality level (quality level of next fragment) **/

  }, {
    key: 'nextLevel',
    get: function get() {
      return this.streamController.nextLevel;
    }

    /* set quality level for next fragment (-1 for automatic level selection) */
    ,
    set: function set(newLevel) {
      _logger.logger.log('set nextLevel:' + newLevel);
      this.levelController.manualLevel = newLevel;
      this.streamController.nextLevelSwitch();
    }

    /** Return the quality level of current/last loaded fragment **/

  }, {
    key: 'loadLevel',
    get: function get() {
      return this.levelController.level;
    }

    /* set quality level for current/next loaded fragment (-1 for automatic level selection) */
    ,
    set: function set(newLevel) {
      _logger.logger.log('set loadLevel:' + newLevel);
      this.levelController.manualLevel = newLevel;
    }

    /** Return the quality level of next loaded fragment **/

  }, {
    key: 'nextLoadLevel',
    get: function get() {
      return this.levelController.nextLoadLevel;
    }

    /** set quality level of next loaded fragment **/
    ,
    set: function set(level) {
      this.levelController.nextLoadLevel = level;
    }

    /** Return first level (index of first level referenced in manifest)
    **/

  }, {
    key: 'firstLevel',
    get: function get() {
      return Math.max(this.levelController.firstLevel, this.minAutoLevel);
    }

    /** set first level (index of first level referenced in manifest)
    **/
    ,
    set: function set(newLevel) {
      _logger.logger.log('set firstLevel:' + newLevel);
      this.levelController.firstLevel = newLevel;
    }

    /** Return start level (level of first fragment that will be played back)
        if not overrided by user, first level appearing in manifest will be used as start level
        if -1 : automatic start level selection, playback will start from level matching download bandwidth (determined from download of first segment)
    **/

  }, {
    key: 'startLevel',
    get: function get() {
      return this.levelController.startLevel;
    }

    /** set  start level (level of first fragment that will be played back)
        if not overrided by user, first level appearing in manifest will be used as start level
        if -1 : automatic start level selection, playback will start from level matching download bandwidth (determined from download of first segment)
    **/
    ,
    set: function set(newLevel) {
      _logger.logger.log('set startLevel:' + newLevel);
      var hls = this;
      // if not in automatic start level detection, ensure startLevel is greater than minAutoLevel
      if (newLevel !== -1) {
        newLevel = Math.max(newLevel, hls.minAutoLevel);
      }
      hls.levelController.startLevel = newLevel;
    }

    /** Return the capping/max level value that could be used by automatic level selection algorithm **/

  }, {
    key: 'autoLevelCapping',
    get: function get() {
      return this._autoLevelCapping;
    }

    /** set the capping/max level value that could be used by automatic level selection algorithm **/
    ,
    set: function set(newLevel) {
      _logger.logger.log('set autoLevelCapping:' + newLevel);
      this._autoLevelCapping = newLevel;
    }

    /* check if we are in automatic level selection mode */

  }, {
    key: 'autoLevelEnabled',
    get: function get() {
      return this.levelController.manualLevel === -1;
    }

    /* return manual level */

  }, {
    key: 'manualLevel',
    get: function get() {
      return this.levelController.manualLevel;
    }

    /* return min level selectable in auto mode according to config.minAutoBitrate */

  }, {
    key: 'minAutoLevel',
    get: function get() {
      var hls = this,
          levels = hls.levels,
          minAutoBitrate = hls.config.minAutoBitrate,
          len = levels ? levels.length : 0;
      for (var i = 0; i < len; i++) {
        var levelNextBitrate = levels[i].realBitrate ? Math.max(levels[i].realBitrate, levels[i].bitrate) : levels[i].bitrate;
        if (levelNextBitrate > minAutoBitrate) {
          return i;
        }
      }
      return 0;
    }

    /* return max level selectable in auto mode according to autoLevelCapping */

  }, {
    key: 'maxAutoLevel',
    get: function get() {
      var hls = this;
      var levels = hls.levels;
      var autoLevelCapping = hls.autoLevelCapping;
      var maxAutoLevel = void 0;
      if (autoLevelCapping === -1 && levels && levels.length) {
        maxAutoLevel = levels.length - 1;
      } else {
        maxAutoLevel = autoLevelCapping;
      }
      return maxAutoLevel;
    }

    // return next auto level

  }, {
    key: 'nextAutoLevel',
    get: function get() {
      var hls = this;
      // ensure next auto level is between  min and max auto level
      return Math.min(Math.max(hls.abrController.nextAutoLevel, hls.minAutoLevel), hls.maxAutoLevel);
    }

    // this setter is used to force next auto level
    // this is useful to force a switch down in auto mode : in case of load error on level N, hls.js can set nextAutoLevel to N-1 for example)
    // forced value is valid for one fragment. upon succesful frag loading at forced level, this value will be resetted to -1 by ABR controller
    ,
    set: function set(nextLevel) {
      var hls = this;
      hls.abrController.nextAutoLevel = Math.max(hls.minAutoLevel, nextLevel);
    }

    /** get alternate audio tracks list from playlist **/

  }, {
    key: 'audioTracks',
    get: function get() {
      var audioTrackController = this.audioTrackController;
      return audioTrackController ? audioTrackController.audioTracks : [];
    }

    /** get index of the selected audio track (index in audio track lists) **/

  }, {
    key: 'audioTrack',
    get: function get() {
      var audioTrackController = this.audioTrackController;
      return audioTrackController ? audioTrackController.audioTrack : -1;
    }

    /** select an audio track, based on its index in audio track lists**/
    ,
    set: function set(audioTrackId) {
      var audioTrackController = this.audioTrackController;
      if (audioTrackController) {
        audioTrackController.audioTrack = audioTrackId;
      }
    }
  }, {
    key: 'liveSyncPosition',
    get: function get() {
      return this.streamController.liveSyncPosition;
    }

    /** get alternate subtitle tracks list from playlist **/

  }, {
    key: 'subtitleTracks',
    get: function get() {
      var subtitleTrackController = this.subtitleTrackController;
      return subtitleTrackController ? subtitleTrackController.subtitleTracks : [];
    }

    /** get index of the selected subtitle track (index in subtitle track lists) **/

  }, {
    key: 'subtitleTrack',
    get: function get() {
      var subtitleTrackController = this.subtitleTrackController;
      return subtitleTrackController ? subtitleTrackController.subtitleTrack : -1;
    }

    /** select an subtitle track, based on its index in subtitle track lists**/
    ,
    set: function set(subtitleTrackId) {
      var subtitleTrackController = this.subtitleTrackController;
      if (subtitleTrackController) {
        subtitleTrackController.subtitleTrack = subtitleTrackId;
      }
    }
  }]);

  return Hls;
}();

exports.default = Hls;

},{"./config":4,"./controller/id3-track-controller":11,"./controller/level-controller":12,"./controller/stream-controller":13,"./errors":33,"./events":35,"./loader/fragment-loader":41,"./loader/key-loader":42,"./loader/playlist-loader":43,"./utils/logger":54,"events":1,"url-toolkit":2}],40:[function(require,module,exports){
'use strict';

// This is mostly for support of the es6 module export
// syntax with the babel compiler, it looks like it doesnt support
// function exports like we are used to in node/commonjs
module.exports = require('./hls.js').default;

},{"./hls.js":39}],41:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _eventHandler = require('../event-handler');

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _errors = require('../errors');

var _logger = require('../utils/logger');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Fragment Loader
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

var FragmentLoader = function (_EventHandler) {
  _inherits(FragmentLoader, _EventHandler);

  function FragmentLoader(hls) {
    _classCallCheck(this, FragmentLoader);

    var _this = _possibleConstructorReturn(this, (FragmentLoader.__proto__ || Object.getPrototypeOf(FragmentLoader)).call(this, hls, _events2.default.FRAG_LOADING));

    _this.loaders = {};
    return _this;
  }

  _createClass(FragmentLoader, [{
    key: 'destroy',
    value: function destroy() {
      var loaders = this.loaders;
      for (var loaderName in loaders) {
        var loader = loaders[loaderName];
        if (loader) {
          loader.destroy();
        }
      }
      this.loaders = {};
      _eventHandler2.default.prototype.destroy.call(this);
    }
  }, {
    key: 'onFragLoading',
    value: function onFragLoading(data) {
      var frag = data.frag,
          type = frag.type,
          loader = this.loaders[type],
          config = this.hls.config;

      frag.loaded = 0;
      if (loader) {
        _logger.logger.warn('abort previous fragment loader for type:' + type);
        loader.abort();
      }
      loader = this.loaders[type] = frag.loader = typeof config.fLoader !== 'undefined' ? new config.fLoader(config) : new config.loader(config);

      var loaderContext = void 0,
          loaderConfig = void 0,
          loaderCallbacks = void 0;
      loaderContext = { url: frag.url, frag: frag, responseType: 'arraybuffer', progressData: false };
      var start = frag.byteRangeStartOffset,
          end = frag.byteRangeEndOffset;
      if (!isNaN(start) && !isNaN(end)) {
        loaderContext.rangeStart = start;
        loaderContext.rangeEnd = end;
      }
      loaderConfig = { timeout: config.fragLoadingTimeOut, maxRetry: 0, retryDelay: 0, maxRetryDelay: config.fragLoadingMaxRetryTimeout };
      loaderCallbacks = { onSuccess: this.loadsuccess.bind(this), onError: this.loaderror.bind(this), onTimeout: this.loadtimeout.bind(this), onProgress: this.loadprogress.bind(this) };
      loader.load(loaderContext, loaderConfig, loaderCallbacks);
    }
  }, {
    key: 'loadsuccess',
    value: function loadsuccess(response, stats, context) {
      var networkDetails = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

      var payload = response.data,
          frag = context.frag;
      // detach fragment loader on load success
      frag.loader = undefined;
      this.loaders[frag.type] = undefined;
      this.hls.trigger(_events2.default.FRAG_LOADED, { payload: payload, frag: frag, stats: stats, networkDetails: networkDetails });
    }
  }, {
    key: 'loaderror',
    value: function loaderror(response, context) {
      var networkDetails = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

      var loader = context.loader;
      if (loader) {
        loader.abort();
      }
      this.loaders[context.type] = undefined;
      this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.NETWORK_ERROR, details: _errors.ErrorDetails.FRAG_LOAD_ERROR, fatal: false, frag: context.frag, response: response, networkDetails: networkDetails });
    }
  }, {
    key: 'loadtimeout',
    value: function loadtimeout(stats, context) {
      var networkDetails = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

      var loader = context.loader;
      if (loader) {
        loader.abort();
      }
      this.loaders[context.type] = undefined;
      this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.NETWORK_ERROR, details: _errors.ErrorDetails.FRAG_LOAD_TIMEOUT, fatal: false, frag: context.frag, networkDetails: networkDetails });
    }

    // data will be used for progressive parsing

  }, {
    key: 'loadprogress',
    value: function loadprogress(stats, context, data) {
      var networkDetails = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
      // jshint ignore:line
      var frag = context.frag;
      frag.loaded = stats.loaded;
      this.hls.trigger(_events2.default.FRAG_LOAD_PROGRESS, { frag: frag, stats: stats, networkDetails: networkDetails });
    }
  }]);

  return FragmentLoader;
}(_eventHandler2.default);

exports.default = FragmentLoader;

},{"../errors":33,"../event-handler":34,"../events":35,"../utils/logger":54}],42:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _eventHandler = require('../event-handler');

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _errors = require('../errors');

var _logger = require('../utils/logger');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Decrypt key Loader
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

var KeyLoader = function (_EventHandler) {
  _inherits(KeyLoader, _EventHandler);

  function KeyLoader(hls) {
    _classCallCheck(this, KeyLoader);

    var _this = _possibleConstructorReturn(this, (KeyLoader.__proto__ || Object.getPrototypeOf(KeyLoader)).call(this, hls, _events2.default.KEY_LOADING));

    _this.loaders = {};
    _this.decryptkey = null;
    _this.decrypturl = null;
    return _this;
  }

  _createClass(KeyLoader, [{
    key: 'destroy',
    value: function destroy() {
      for (var loaderName in this.loaders) {
        var loader = this.loaders[loaderName];
        if (loader) {
          loader.destroy();
        }
      }
      this.loaders = {};
      _eventHandler2.default.prototype.destroy.call(this);
    }
  }, {
    key: 'onKeyLoading',
    value: function onKeyLoading(data) {
      var frag = data.frag,
          type = frag.type,
          loader = this.loaders[type],
          decryptdata = frag.decryptdata,
          uri = decryptdata.uri;
      // if uri is different from previous one or if decrypt key not retrieved yet
      if (uri !== this.decrypturl || this.decryptkey === null) {
        var config = this.hls.config;

        if (loader) {
          _logger.logger.warn('abort previous key loader for type:' + type);
          loader.abort();
        }
        frag.loader = this.loaders[type] = new config.loader(config);
        this.decrypturl = uri;
        this.decryptkey = null;

        var loaderContext = void 0,
            loaderConfig = void 0,
            loaderCallbacks = void 0;
        loaderContext = { url: uri, frag: frag, responseType: 'arraybuffer' };
        loaderConfig = { timeout: config.fragLoadingTimeOut, maxRetry: config.fragLoadingMaxRetry, retryDelay: config.fragLoadingRetryDelay, maxRetryDelay: config.fragLoadingMaxRetryTimeout };
        loaderCallbacks = { onSuccess: this.loadsuccess.bind(this), onError: this.loaderror.bind(this), onTimeout: this.loadtimeout.bind(this) };
        frag.loader.load(loaderContext, loaderConfig, loaderCallbacks);
      } else if (this.decryptkey) {
        // we already loaded this key, return it
        decryptdata.key = this.decryptkey;
        this.hls.trigger(_events2.default.KEY_LOADED, { frag: frag });
      }
    }
  }, {
    key: 'loadsuccess',
    value: function loadsuccess(response, stats, context) {
      var frag = context.frag;
      this.decryptkey = frag.decryptdata.key = new Uint8Array(response.data);
      // detach fragment loader on load success
      frag.loader = undefined;
      this.loaders[frag.type] = undefined;
      this.hls.trigger(_events2.default.KEY_LOADED, { frag: frag });
    }
  }, {
    key: 'loaderror',
    value: function loaderror(response, context) {
      var frag = context.frag,
          loader = frag.loader;
      if (loader) {
        loader.abort();
      }
      this.loaders[context.type] = undefined;
      this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.NETWORK_ERROR, details: _errors.ErrorDetails.KEY_LOAD_ERROR, fatal: false, frag: frag, response: response });
    }
  }, {
    key: 'loadtimeout',
    value: function loadtimeout(stats, context) {
      var frag = context.frag,
          loader = frag.loader;
      if (loader) {
        loader.abort();
      }
      this.loaders[context.type] = undefined;
      this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.NETWORK_ERROR, details: _errors.ErrorDetails.KEY_LOAD_TIMEOUT, fatal: false, frag: frag });
    }
  }]);

  return KeyLoader;
}(_eventHandler2.default);

exports.default = KeyLoader;

},{"../errors":33,"../event-handler":34,"../events":35,"../utils/logger":54}],43:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Playlist Loader
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */

var _urlToolkit = require('url-toolkit');

var _urlToolkit2 = _interopRequireDefault(_urlToolkit);

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _eventHandler = require('../event-handler');

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _errors = require('../errors');

var _attrList = require('../utils/attr-list');

var _attrList2 = _interopRequireDefault(_attrList);

var _logger = require('../utils/logger');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// https://regex101.com is your friend
var MASTER_PLAYLIST_REGEX = /#EXT-X-STREAM-INF:([^\n\r]*)[\r\n]+([^\r\n]+)/g;
var MASTER_PLAYLIST_MEDIA_REGEX = /#EXT-X-MEDIA:(.*)/g;

var LEVEL_PLAYLIST_REGEX_FAST = new RegExp([/#EXTINF:(\d*(?:\.\d+)?)(?:,(.*)\s+)?/.source, // duration (#EXTINF:<duration>,<title>), group 1 => duration, group 2 => title
/|(?!#)(\S+)/.source, // segment URI, group 3 => the URI (note newline is not eaten)
/|#EXT-X-BYTERANGE:*(.+)/.source, // next segment's byterange, group 4 => range spec (x@y)
/|#EXT-X-PROGRAM-DATE-TIME:(.+)/.source, // next segment's program date/time group 5 => the datetime spec
/|#.*/.source // All other non-segment oriented tags will match with all groups empty
].join(''), 'g');

var LEVEL_PLAYLIST_REGEX_SLOW = /(?:(?:#(EXTM3U))|(?:#EXT-X-(PLAYLIST-TYPE):(.+))|(?:#EXT-X-(MEDIA-SEQUENCE): *(\d+))|(?:#EXT-X-(TARGETDURATION): *(\d+))|(?:#EXT-X-(KEY):(.+))|(?:#EXT-X-(START):(.+))|(?:#EXT-X-(ENDLIST))|(?:#EXT-X-(DISCONTINUITY-SEQ)UENCE:(\d+))|(?:#EXT-X-(DIS)CONTINUITY))|(?:#EXT-X-(VERSION):(\d+))|(?:#EXT-X-(MAP):(.+))|(?:(#)(.*):(.*))|(?:(#)(.*))(?:.*)\r?\n?/;

var LevelKey = function () {
  function LevelKey() {
    _classCallCheck(this, LevelKey);

    this.method = null;
    this.key = null;
    this.iv = null;
    this._uri = null;
  }

  _createClass(LevelKey, [{
    key: 'uri',
    get: function get() {
      if (!this._uri && this.reluri) {
        this._uri = _urlToolkit2.default.buildAbsoluteURL(this.baseuri, this.reluri, { alwaysNormalize: true });
      }
      return this._uri;
    }
  }]);

  return LevelKey;
}();

var Fragment = function () {
  function Fragment() {
    _classCallCheck(this, Fragment);

    this._url = null;
    this._byteRange = null;
    this._decryptdata = null;
    this.tagList = [];
  }

  _createClass(Fragment, [{
    key: 'createInitializationVector',


    /**
     * Utility method for parseLevelPlaylist to create an initialization vector for a given segment
     * @returns {Uint8Array}
     */
    value: function createInitializationVector(segmentNumber) {
      var uint8View = new Uint8Array(16);

      for (var i = 12; i < 16; i++) {
        uint8View[i] = segmentNumber >> 8 * (15 - i) & 0xff;
      }

      return uint8View;
    }

    /**
     * Utility method for parseLevelPlaylist to get a fragment's decryption data from the currently parsed encryption key data
     * @param levelkey - a playlist's encryption info
     * @param segmentNumber - the fragment's segment number
     * @returns {*} - an object to be applied as a fragment's decryptdata
     */

  }, {
    key: 'fragmentDecryptdataFromLevelkey',
    value: function fragmentDecryptdataFromLevelkey(levelkey, segmentNumber) {
      var decryptdata = levelkey;

      if (levelkey && levelkey.method && levelkey.uri && !levelkey.iv) {
        decryptdata = new LevelKey();
        decryptdata.method = levelkey.method;
        decryptdata.baseuri = levelkey.baseuri;
        decryptdata.reluri = levelkey.reluri;
        decryptdata.iv = this.createInitializationVector(segmentNumber);
      }

      return decryptdata;
    }
  }, {
    key: 'cloneObj',
    value: function cloneObj(obj) {
      return JSON.parse(JSON.stringify(obj));
    }
  }, {
    key: 'url',
    get: function get() {
      if (!this._url && this.relurl) {
        this._url = _urlToolkit2.default.buildAbsoluteURL(this.baseurl, this.relurl, { alwaysNormalize: true });
      }
      return this._url;
    },
    set: function set(value) {
      this._url = value;
    }
  }, {
    key: 'programDateTime',
    get: function get() {
      if (!this._programDateTime && this.rawProgramDateTime) {
        this._programDateTime = new Date(Date.parse(this.rawProgramDateTime));
      }
      return this._programDateTime;
    }
  }, {
    key: 'byteRange',
    get: function get() {
      if (!this._byteRange) {
        var byteRange = this._byteRange = [];
        if (this.rawByteRange) {
          var params = this.rawByteRange.split('@', 2);
          if (params.length === 1) {
            var lastByteRangeEndOffset = this.lastByteRangeEndOffset;
            byteRange[0] = lastByteRangeEndOffset ? lastByteRangeEndOffset : 0;
          } else {
            byteRange[0] = parseInt(params[1]);
          }
          byteRange[1] = parseInt(params[0]) + byteRange[0];
        }
      }
      return this._byteRange;
    }
  }, {
    key: 'byteRangeStartOffset',
    get: function get() {
      return this.byteRange[0];
    }
  }, {
    key: 'byteRangeEndOffset',
    get: function get() {
      return this.byteRange[1];
    }
  }, {
    key: 'decryptdata',
    get: function get() {
      if (!this._decryptdata) {
        this._decryptdata = this.fragmentDecryptdataFromLevelkey(this.levelkey, this.sn);
      }
      return this._decryptdata;
    }
  }]);

  return Fragment;
}();

var PlaylistLoader = function (_EventHandler) {
  _inherits(PlaylistLoader, _EventHandler);

  function PlaylistLoader(hls) {
    _classCallCheck(this, PlaylistLoader);

    var _this = _possibleConstructorReturn(this, (PlaylistLoader.__proto__ || Object.getPrototypeOf(PlaylistLoader)).call(this, hls, _events2.default.MANIFEST_LOADING, _events2.default.LEVEL_LOADING, _events2.default.AUDIO_TRACK_LOADING, _events2.default.SUBTITLE_TRACK_LOADING));

    _this.loaders = {};
    return _this;
  }

  _createClass(PlaylistLoader, [{
    key: 'destroy',
    value: function destroy() {
      for (var loaderName in this.loaders) {
        var loader = this.loaders[loaderName];
        if (loader) {
          loader.destroy();
        }
      }
      this.loaders = {};
      _eventHandler2.default.prototype.destroy.call(this);
    }
  }, {
    key: 'onManifestLoading',
    value: function onManifestLoading(data) {
      this.load(data.url, { type: 'manifest' });
    }
  }, {
    key: 'onLevelLoading',
    value: function onLevelLoading(data) {
      this.load(data.url, { type: 'level', level: data.level, id: data.id });
    }
  }, {
    key: 'onAudioTrackLoading',
    value: function onAudioTrackLoading(data) {
      this.load(data.url, { type: 'audioTrack', id: data.id });
    }
  }, {
    key: 'onSubtitleTrackLoading',
    value: function onSubtitleTrackLoading(data) {
      this.load(data.url, { type: 'subtitleTrack', id: data.id });
    }
  }, {
    key: 'load',
    value: function load(url, context) {
      var loader = this.loaders[context.type];
      if (loader) {
        var loaderContext = loader.context;
        if (loaderContext && loaderContext.url === url) {
          _logger.logger.trace('playlist request ongoing');
          return;
        } else {
          _logger.logger.warn('abort previous loader for type:' + context.type);
          loader.abort();
        }
      }
      var config = this.hls.config,
          retry = void 0,
          timeout = void 0,
          retryDelay = void 0,
          maxRetryDelay = void 0;
      if (context.type === 'manifest') {
        retry = config.manifestLoadingMaxRetry;
        timeout = config.manifestLoadingTimeOut;
        retryDelay = config.manifestLoadingRetryDelay;
        maxRetryDelay = config.manifestLoadingMaxRetryTimeout;
      } else {
        retry = config.levelLoadingMaxRetry;
        timeout = config.levelLoadingTimeOut;
        retryDelay = config.levelLoadingRetryDelay;
        maxRetryDelay = config.levelLoadingMaxRetryTimeout;
        _logger.logger.log('loading playlist for ' + context.type + ' ' + (context.level || context.id));
      }
      loader = this.loaders[context.type] = context.loader = typeof config.pLoader !== 'undefined' ? new config.pLoader(config) : new config.loader(config);
      context.url = url;
      context.responseType = '';

      var loaderConfig = void 0,
          loaderCallbacks = void 0;
      loaderConfig = { timeout: timeout, maxRetry: retry, retryDelay: retryDelay, maxRetryDelay: maxRetryDelay };
      loaderCallbacks = { onSuccess: this.loadsuccess.bind(this), onError: this.loaderror.bind(this), onTimeout: this.loadtimeout.bind(this) };
      loader.load(context, loaderConfig, loaderCallbacks);
    }
  }, {
    key: 'resolve',
    value: function resolve(url, baseUrl) {
      return _urlToolkit2.default.buildAbsoluteURL(baseUrl, url, { alwaysNormalize: true });
    }
  }, {
    key: 'parseMasterPlaylist',
    value: function parseMasterPlaylist(string, baseurl) {
      var levels = [],
          result = void 0;
      MASTER_PLAYLIST_REGEX.lastIndex = 0;
      while ((result = MASTER_PLAYLIST_REGEX.exec(string)) != null) {
        var level = {};

        var attrs = level.attrs = new _attrList2.default(result[1]);
        level.url = this.resolve(result[2], baseurl);

        var resolution = attrs.decimalResolution('RESOLUTION');
        if (resolution) {
          level.width = resolution.width;
          level.height = resolution.height;
        }
        level.bitrate = attrs.decimalInteger('AVERAGE-BANDWIDTH') || attrs.decimalInteger('BANDWIDTH');
        level.name = attrs.NAME;

        var codecs = attrs.CODECS;
        if (codecs) {
          codecs = codecs.split(/[ ,]+/);
          for (var i = 0; i < codecs.length; i++) {
            var codec = codecs[i];
            if (codec.indexOf('avc1') !== -1) {
              level.videoCodec = this.avc1toavcoti(codec);
            } else if (codec.indexOf('hvc1') !== -1) {
              level.videoCodec = codec;
            } else {
              level.audioCodec = codec;
            }
          }
        }

        levels.push(level);
      }
      return levels;
    }
  }, {
    key: 'parseMasterPlaylistMedia',
    value: function parseMasterPlaylistMedia(string, baseurl, type) {
      var audioCodec = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

      var result = void 0,
          medias = [],
          id = 0;
      MASTER_PLAYLIST_MEDIA_REGEX.lastIndex = 0;
      while ((result = MASTER_PLAYLIST_MEDIA_REGEX.exec(string)) != null) {
        var media = {};
        var attrs = new _attrList2.default(result[1]);
        if (attrs.TYPE === type) {
          media.groupId = attrs['GROUP-ID'];
          media.name = attrs.NAME;
          media.type = type;
          media.default = attrs.DEFAULT === 'YES';
          media.autoselect = attrs.AUTOSELECT === 'YES';
          media.forced = attrs.FORCED === 'YES';
          if (attrs.URI) {
            media.url = this.resolve(attrs.URI, baseurl);
          }
          media.lang = attrs.LANGUAGE;
          if (!media.name) {
            media.name = media.lang;
          }
          if (audioCodec) {
            media.audioCodec = audioCodec;
          }
          media.id = id++;
          medias.push(media);
        }
      }
      return medias;
    }
  }, {
    key: 'avc1toavcoti',
    value: function avc1toavcoti(codec) {
      var result,
          avcdata = codec.split('.');
      if (avcdata.length > 2) {
        result = avcdata.shift() + '.';
        result += parseInt(avcdata.shift()).toString(16);
        result += ('000' + parseInt(avcdata.shift()).toString(16)).substr(-4);
      } else {
        result = codec;
      }
      return result;
    }
  }, {
    key: 'parseLevelPlaylist',
    value: function parseLevelPlaylist(string, baseurl, id, type) {
      var currentSN = 0,
          totalduration = 0,
          level = { type: null, version: null, url: baseurl, fragments: [], live: true, startSN: 0 },
          levelkey = new LevelKey(),
          cc = 0,
          prevFrag = null,
          frag = new Fragment(),
          result,
          i;

      LEVEL_PLAYLIST_REGEX_FAST.lastIndex = 0;

      while ((result = LEVEL_PLAYLIST_REGEX_FAST.exec(string)) !== null) {
        var duration = result[1];
        if (duration) {
          // INF
          frag.duration = parseFloat(duration);
          // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939
          var title = (' ' + result[2]).slice(1);
          frag.title = title ? title : null;
          frag.tagList.push(title ? ['INF', duration, title] : ['INF', duration]);
        } else if (result[3]) {
          // url
          if (!isNaN(frag.duration)) {
            var sn = currentSN++;
            frag.type = type;
            frag.start = totalduration;
            frag.levelkey = levelkey;
            frag.sn = sn;
            frag.level = id;
            frag.cc = cc;
            frag.baseurl = baseurl;
            // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939
            frag.relurl = (' ' + result[3]).slice(1);

            level.fragments.push(frag);
            prevFrag = frag;
            totalduration += frag.duration;

            frag = new Fragment();
          }
        } else if (result[4]) {
          // X-BYTERANGE
          frag.rawByteRange = (' ' + result[4]).slice(1);
          if (prevFrag) {
            var lastByteRangeEndOffset = prevFrag.byteRangeEndOffset;
            if (lastByteRangeEndOffset) {
              frag.lastByteRangeEndOffset = lastByteRangeEndOffset;
            }
          }
        } else if (result[5]) {
          // PROGRAM-DATE-TIME
          // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939
          frag.rawProgramDateTime = (' ' + result[5]).slice(1);
          frag.tagList.push(['PROGRAM-DATE-TIME', frag.rawProgramDateTime]);
        } else {
          result = result[0].match(LEVEL_PLAYLIST_REGEX_SLOW);
          for (i = 1; i < result.length; i++) {
            if (result[i] !== undefined) {
              break;
            }
          }

          // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939
          var value1 = (' ' + result[i + 1]).slice(1);
          var value2 = (' ' + result[i + 2]).slice(1);

          switch (result[i]) {
            case '#':
              frag.tagList.push(value2 ? [value1, value2] : [value1]);
              break;
            case 'PLAYLIST-TYPE':
              level.type = value1.toUpperCase();
              break;
            case 'MEDIA-SEQUENCE':
              currentSN = level.startSN = parseInt(value1);
              break;
            case 'TARGETDURATION':
              level.targetduration = parseFloat(value1);
              break;
            case 'VERSION':
              level.version = parseInt(value1);
              break;
            case 'EXTM3U':
              break;
            case 'ENDLIST':
              level.live = false;
              break;
            case 'DIS':
              cc++;
              frag.tagList.push(['DIS']);
              break;
            case 'DISCONTINUITY-SEQ':
              cc = parseInt(value1);
              break;
            case 'KEY':
              // https://tools.ietf.org/html/draft-pantos-http-live-streaming-08#section-3.4.4
              var decryptparams = value1;
              var keyAttrs = new _attrList2.default(decryptparams);
              var decryptmethod = keyAttrs.enumeratedString('METHOD'),
                  decrypturi = keyAttrs.URI,
                  decryptiv = keyAttrs.hexadecimalInteger('IV');
              if (decryptmethod) {
                levelkey = new LevelKey();
                if (decrypturi && ['AES-128', 'SAMPLE-AES'].indexOf(decryptmethod) >= 0) {
                  levelkey.method = decryptmethod;
                  // URI to get the key
                  levelkey.baseuri = baseurl;
                  levelkey.reluri = decrypturi;
                  levelkey.key = null;
                  // Initialization Vector (IV)
                  levelkey.iv = decryptiv;
                }
              }
              break;
            case 'START':
              var startParams = value1;
              var startAttrs = new _attrList2.default(startParams);
              var startTimeOffset = startAttrs.decimalFloatingPoint('TIME-OFFSET');
              //TIME-OFFSET can be 0
              if (!isNaN(startTimeOffset)) {
                level.startTimeOffset = startTimeOffset;
              }
              break;
            case 'MAP':
              var mapAttrs = new _attrList2.default(value1);
              frag.relurl = mapAttrs.URI;
              frag.rawByteRange = mapAttrs.BYTERANGE;
              frag.baseurl = baseurl;
              frag.level = id;
              frag.type = type;
              frag.sn = 'initSegment';
              level.initSegment = frag;
              frag = new Fragment();
              break;
            default:
              _logger.logger.warn('line parsed but not handled: ' + result);
              break;
          }
        }
      }
      frag = prevFrag;
      //logger.log('found ' + level.fragments.length + ' fragments');
      if (frag && !frag.relurl) {
        level.fragments.pop();
        totalduration -= frag.duration;
      }
      level.totalduration = totalduration;
      level.averagetargetduration = totalduration / level.fragments.length;
      level.endSN = currentSN - 1;
      return level;
    }
  }, {
    key: 'loadsuccess',
    value: function loadsuccess(response, stats, context) {
      var networkDetails = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

      var string = response.data,
          url = response.url,
          type = context.type,
          id = context.id,
          level = context.level,
          hls = this.hls;

      this.loaders[type] = undefined;
      // responseURL not supported on some browsers (it is used to detect URL redirection)
      // data-uri mode also not supported (but no need to detect redirection)
      if (url === undefined || url.indexOf('data:') === 0) {
        // fallback to initial URL
        url = context.url;
      }
      stats.tload = performance.now();
      //stats.mtime = new Date(target.getResponseHeader('Last-Modified'));
      if (string.indexOf('#EXTM3U') === 0) {
        if (string.indexOf('#EXTINF:') > 0) {
          var isLevel = type !== 'audioTrack' && type !== 'subtitleTrack',
              levelId = !isNaN(level) ? level : !isNaN(id) ? id : 0,
              levelDetails = this.parseLevelPlaylist(string, url, levelId, type === 'audioTrack' ? 'audio' : type === 'subtitleTrack' ? 'subtitle' : 'main');
          levelDetails.tload = stats.tload;
          if (type === 'manifest') {
            // first request, stream manifest (no master playlist), fire manifest loaded event with level details
            hls.trigger(_events2.default.MANIFEST_LOADED, { levels: [{ url: url, details: levelDetails }], audioTracks: [], url: url, stats: stats, networkDetails: networkDetails });
          }
          stats.tparsed = performance.now();
          if (levelDetails.targetduration) {
            if (isLevel) {
              hls.trigger(_events2.default.LEVEL_LOADED, { details: levelDetails, level: level || 0, id: id || 0, stats: stats, networkDetails: networkDetails });
            } else {
              if (type === 'audioTrack') {
                hls.trigger(_events2.default.AUDIO_TRACK_LOADED, { details: levelDetails, id: id, stats: stats, networkDetails: networkDetails });
              } else if (type === 'subtitleTrack') {
                hls.trigger(_events2.default.SUBTITLE_TRACK_LOADED, { details: levelDetails, id: id, stats: stats, networkDetails: networkDetails });
              }
            }
          } else {
            hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.NETWORK_ERROR, details: _errors.ErrorDetails.MANIFEST_PARSING_ERROR, fatal: true, url: url, reason: 'invalid targetduration', networkDetails: networkDetails });
          }
        } else {
          var levels = this.parseMasterPlaylist(string, url);
          // multi level playlist, parse level info
          if (levels.length) {
            var audioTracks = this.parseMasterPlaylistMedia(string, url, 'AUDIO', levels[0].audioCodec);
            var subtitles = this.parseMasterPlaylistMedia(string, url, 'SUBTITLES');
            if (audioTracks.length) {
              // check if we have found an audio track embedded in main playlist (audio track without URI attribute)
              var embeddedAudioFound = false;
              audioTracks.forEach(function (audioTrack) {
                if (!audioTrack.url) {
                  embeddedAudioFound = true;
                }
              });
              // if no embedded audio track defined, but audio codec signaled in quality level, we need to signal this main audio track
              // this could happen with playlists with alt audio rendition in which quality levels (main) contains both audio+video. but with mixed audio track not signaled
              if (embeddedAudioFound === false && levels[0].audioCodec && !levels[0].attrs.AUDIO) {
                _logger.logger.log('audio codec signaled in quality level, but no embedded audio track signaled, create one');
                audioTracks.unshift({ type: 'main', name: 'main' });
              }
            }
            hls.trigger(_events2.default.MANIFEST_LOADED, { levels: levels, audioTracks: audioTracks, subtitles: subtitles, url: url, stats: stats, networkDetails: networkDetails });
          } else {
            hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.NETWORK_ERROR, details: _errors.ErrorDetails.MANIFEST_PARSING_ERROR, fatal: true, url: url, reason: 'no level found in manifest', networkDetails: networkDetails });
          }
        }
      } else {
        hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.NETWORK_ERROR, details: _errors.ErrorDetails.MANIFEST_PARSING_ERROR, fatal: true, url: url, reason: 'no EXTM3U delimiter', networkDetails: networkDetails });
      }
    }
  }, {
    key: 'loaderror',
    value: function loaderror(response, context) {
      var networkDetails = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

      var details,
          fatal,
          loader = context.loader;
      switch (context.type) {
        case 'manifest':
          details = _errors.ErrorDetails.MANIFEST_LOAD_ERROR;
          fatal = true;
          break;
        case 'level':
          details = _errors.ErrorDetails.LEVEL_LOAD_ERROR;
          fatal = false;
          break;
        case 'audioTrack':
          details = _errors.ErrorDetails.AUDIO_TRACK_LOAD_ERROR;
          fatal = false;
          break;
      }
      if (loader) {
        loader.abort();
        this.loaders[context.type] = undefined;
      }
      this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.NETWORK_ERROR, details: details, fatal: fatal, url: loader.url, loader: loader, response: response, context: context, networkDetails: networkDetails });
    }
  }, {
    key: 'loadtimeout',
    value: function loadtimeout(stats, context) {
      var networkDetails = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

      var details,
          fatal,
          loader = context.loader;
      switch (context.type) {
        case 'manifest':
          details = _errors.ErrorDetails.MANIFEST_LOAD_TIMEOUT;
          fatal = true;
          break;
        case 'level':
          details = _errors.ErrorDetails.LEVEL_LOAD_TIMEOUT;
          fatal = false;
          break;
        case 'audioTrack':
          details = _errors.ErrorDetails.AUDIO_TRACK_LOAD_TIMEOUT;
          fatal = false;
          break;
      }
      if (loader) {
        loader.abort();
        this.loaders[context.type] = undefined;
      }
      this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.NETWORK_ERROR, details: details, fatal: fatal, url: loader.url, loader: loader, context: context, networkDetails: networkDetails });
    }
  }]);

  return PlaylistLoader;
}(_eventHandler2.default);

exports.default = PlaylistLoader;

},{"../errors":33,"../event-handler":34,"../events":35,"../utils/attr-list":47,"../utils/logger":54,"url-toolkit":2}],44:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Generate MP4 Box
*/

//import Hex from '../utils/hex';

var UINT32_MAX = Math.pow(2, 32) - 1;

var MP4 = function () {
  function MP4() {
    _classCallCheck(this, MP4);
  }

  _createClass(MP4, null, [{
    key: 'init',
    value: function init() {
      MP4.types = {
        avc1: [], // codingname
        avcC: [],
        btrt: [],
        dinf: [],
        dref: [],
        esds: [],
        ftyp: [],
        hdlr: [],
        mdat: [],
        mdhd: [],
        mdia: [],
        mfhd: [],
        minf: [],
        moof: [],
        moov: [],
        mp4a: [],
        '.mp3': [],
        mvex: [],
        mvhd: [],
        pasp: [],
        sdtp: [],
        stbl: [],
        stco: [],
        stsc: [],
        stsd: [],
        stsz: [],
        stts: [],
        tfdt: [],
        tfhd: [],
        traf: [],
        trak: [],
        trun: [],
        trex: [],
        tkhd: [],
        vmhd: [],
        smhd: []
      };

      var i;
      for (i in MP4.types) {
        if (MP4.types.hasOwnProperty(i)) {
          MP4.types[i] = [i.charCodeAt(0), i.charCodeAt(1), i.charCodeAt(2), i.charCodeAt(3)];
        }
      }

      var videoHdlr = new Uint8Array([0x00, // version 0
      0x00, 0x00, 0x00, // flags
      0x00, 0x00, 0x00, 0x00, // pre_defined
      0x76, 0x69, 0x64, 0x65, // handler_type: 'vide'
      0x00, 0x00, 0x00, 0x00, // reserved
      0x00, 0x00, 0x00, 0x00, // reserved
      0x00, 0x00, 0x00, 0x00, // reserved
      0x56, 0x69, 0x64, 0x65, 0x6f, 0x48, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'VideoHandler'
      ]);

      var audioHdlr = new Uint8Array([0x00, // version 0
      0x00, 0x00, 0x00, // flags
      0x00, 0x00, 0x00, 0x00, // pre_defined
      0x73, 0x6f, 0x75, 0x6e, // handler_type: 'soun'
      0x00, 0x00, 0x00, 0x00, // reserved
      0x00, 0x00, 0x00, 0x00, // reserved
      0x00, 0x00, 0x00, 0x00, // reserved
      0x53, 0x6f, 0x75, 0x6e, 0x64, 0x48, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'SoundHandler'
      ]);

      MP4.HDLR_TYPES = {
        'video': videoHdlr,
        'audio': audioHdlr
      };

      var dref = new Uint8Array([0x00, // version 0
      0x00, 0x00, 0x00, // flags
      0x00, 0x00, 0x00, 0x01, // entry_count
      0x00, 0x00, 0x00, 0x0c, // entry_size
      0x75, 0x72, 0x6c, 0x20, // 'url' type
      0x00, // version 0
      0x00, 0x00, 0x01 // entry_flags
      ]);

      var stco = new Uint8Array([0x00, // version
      0x00, 0x00, 0x00, // flags
      0x00, 0x00, 0x00, 0x00 // entry_count
      ]);

      MP4.STTS = MP4.STSC = MP4.STCO = stco;

      MP4.STSZ = new Uint8Array([0x00, // version
      0x00, 0x00, 0x00, // flags
      0x00, 0x00, 0x00, 0x00, // sample_size
      0x00, 0x00, 0x00, 0x00]);
      MP4.VMHD = new Uint8Array([0x00, // version
      0x00, 0x00, 0x01, // flags
      0x00, 0x00, // graphicsmode
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00 // opcolor
      ]);
      MP4.SMHD = new Uint8Array([0x00, // version
      0x00, 0x00, 0x00, // flags
      0x00, 0x00, // balance
      0x00, 0x00 // reserved
      ]);

      MP4.STSD = new Uint8Array([0x00, // version 0
      0x00, 0x00, 0x00, // flags
      0x00, 0x00, 0x00, 0x01]); // entry_count

      var majorBrand = new Uint8Array([105, 115, 111, 109]); // isom
      var avc1Brand = new Uint8Array([97, 118, 99, 49]); // avc1
      var minorVersion = new Uint8Array([0, 0, 0, 1]);

      MP4.FTYP = MP4.box(MP4.types.ftyp, majorBrand, minorVersion, majorBrand, avc1Brand);
      MP4.DINF = MP4.box(MP4.types.dinf, MP4.box(MP4.types.dref, dref));
    }
  }, {
    key: 'box',
    value: function box(type) {
      var payload = Array.prototype.slice.call(arguments, 1),
          size = 8,
          i = payload.length,
          len = i,
          result;
      // calculate the total size we need to allocate
      while (i--) {
        size += payload[i].byteLength;
      }
      result = new Uint8Array(size);
      result[0] = size >> 24 & 0xff;
      result[1] = size >> 16 & 0xff;
      result[2] = size >> 8 & 0xff;
      result[3] = size & 0xff;
      result.set(type, 4);
      // copy the payload into the result
      for (i = 0, size = 8; i < len; i++) {
        // copy payload[i] array @ offset size
        result.set(payload[i], size);
        size += payload[i].byteLength;
      }
      return result;
    }
  }, {
    key: 'hdlr',
    value: function hdlr(type) {
      return MP4.box(MP4.types.hdlr, MP4.HDLR_TYPES[type]);
    }
  }, {
    key: 'mdat',
    value: function mdat(data) {
      return MP4.box(MP4.types.mdat, data);
    }
  }, {
    key: 'mdhd',
    value: function mdhd(timescale, duration) {
      duration *= timescale;
      var upperWordDuration = Math.floor(duration / (UINT32_MAX + 1));
      var lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));
      return MP4.box(MP4.types.mdhd, new Uint8Array([0x01, // version 1
      0x00, 0x00, 0x00, // flags
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // creation_time
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, // modification_time
      timescale >> 24 & 0xFF, timescale >> 16 & 0xFF, timescale >> 8 & 0xFF, timescale & 0xFF, // timescale
      upperWordDuration >> 24, upperWordDuration >> 16 & 0xFF, upperWordDuration >> 8 & 0xFF, upperWordDuration & 0xFF, lowerWordDuration >> 24, lowerWordDuration >> 16 & 0xFF, lowerWordDuration >> 8 & 0xFF, lowerWordDuration & 0xFF, 0x55, 0xc4, // 'und' language (undetermined)
      0x00, 0x00]));
    }
  }, {
    key: 'mdia',
    value: function mdia(track) {
      return MP4.box(MP4.types.mdia, MP4.mdhd(track.timescale, track.duration), MP4.hdlr(track.type), MP4.minf(track));
    }
  }, {
    key: 'mfhd',
    value: function mfhd(sequenceNumber) {
      return MP4.box(MP4.types.mfhd, new Uint8Array([0x00, 0x00, 0x00, 0x00, // flags
      sequenceNumber >> 24, sequenceNumber >> 16 & 0xFF, sequenceNumber >> 8 & 0xFF, sequenceNumber & 0xFF]) // sequence_number
      );
    }
  }, {
    key: 'minf',
    value: function minf(track) {
      if (track.type === 'audio') {
        return MP4.box(MP4.types.minf, MP4.box(MP4.types.smhd, MP4.SMHD), MP4.DINF, MP4.stbl(track));
      } else {
        return MP4.box(MP4.types.minf, MP4.box(MP4.types.vmhd, MP4.VMHD), MP4.DINF, MP4.stbl(track));
      }
    }
  }, {
    key: 'moof',
    value: function moof(sn, baseMediaDecodeTime, track) {
      return MP4.box(MP4.types.moof, MP4.mfhd(sn), MP4.traf(track, baseMediaDecodeTime));
    }
    /**
     * @param tracks... (optional) {array} the tracks associated with this movie
     */

  }, {
    key: 'moov',
    value: function moov(tracks) {
      var i = tracks.length,
          boxes = [];

      while (i--) {
        boxes[i] = MP4.trak(tracks[i]);
      }

      return MP4.box.apply(null, [MP4.types.moov, MP4.mvhd(tracks[0].timescale, tracks[0].duration)].concat(boxes).concat(MP4.mvex(tracks)));
    }
  }, {
    key: 'mvex',
    value: function mvex(tracks) {
      var i = tracks.length,
          boxes = [];

      while (i--) {
        boxes[i] = MP4.trex(tracks[i]);
      }
      return MP4.box.apply(null, [MP4.types.mvex].concat(boxes));
    }
  }, {
    key: 'mvhd',
    value: function mvhd(timescale, duration) {
      duration *= timescale;
      var upperWordDuration = Math.floor(duration / (UINT32_MAX + 1));
      var lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));
      var bytes = new Uint8Array([0x01, // version 1
      0x00, 0x00, 0x00, // flags
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // creation_time
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, // modification_time
      timescale >> 24 & 0xFF, timescale >> 16 & 0xFF, timescale >> 8 & 0xFF, timescale & 0xFF, // timescale
      upperWordDuration >> 24, upperWordDuration >> 16 & 0xFF, upperWordDuration >> 8 & 0xFF, upperWordDuration & 0xFF, lowerWordDuration >> 24, lowerWordDuration >> 16 & 0xFF, lowerWordDuration >> 8 & 0xFF, lowerWordDuration & 0xFF, 0x00, 0x01, 0x00, 0x00, // 1.0 rate
      0x01, 0x00, // 1.0 volume
      0x00, 0x00, // reserved
      0x00, 0x00, 0x00, 0x00, // reserved
      0x00, 0x00, 0x00, 0x00, // reserved
      0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, // transformation: unity matrix
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // pre_defined
      0xff, 0xff, 0xff, 0xff // next_track_ID
      ]);
      return MP4.box(MP4.types.mvhd, bytes);
    }
  }, {
    key: 'sdtp',
    value: function sdtp(track) {
      var samples = track.samples || [],
          bytes = new Uint8Array(4 + samples.length),
          flags,
          i;
      // leave the full box header (4 bytes) all zero
      // write the sample table
      for (i = 0; i < samples.length; i++) {
        flags = samples[i].flags;
        bytes[i + 4] = flags.dependsOn << 4 | flags.isDependedOn << 2 | flags.hasRedundancy;
      }

      return MP4.box(MP4.types.sdtp, bytes);
    }
  }, {
    key: 'stbl',
    value: function stbl(track) {
      return MP4.box(MP4.types.stbl, MP4.stsd(track), MP4.box(MP4.types.stts, MP4.STTS), MP4.box(MP4.types.stsc, MP4.STSC), MP4.box(MP4.types.stsz, MP4.STSZ), MP4.box(MP4.types.stco, MP4.STCO));
    }
  }, {
    key: 'avc1',
    value: function avc1(track) {
      var sps = [],
          pps = [],
          i,
          data,
          len;
      // assemble the SPSs

      for (i = 0; i < track.sps.length; i++) {
        data = track.sps[i];
        len = data.byteLength;
        sps.push(len >>> 8 & 0xFF);
        sps.push(len & 0xFF);
        sps = sps.concat(Array.prototype.slice.call(data)); // SPS
      }

      // assemble the PPSs
      for (i = 0; i < track.pps.length; i++) {
        data = track.pps[i];
        len = data.byteLength;
        pps.push(len >>> 8 & 0xFF);
        pps.push(len & 0xFF);
        pps = pps.concat(Array.prototype.slice.call(data));
      }

      var avcc = MP4.box(MP4.types.avcC, new Uint8Array([0x01, // version
      sps[3], // profile
      sps[4], // profile compat
      sps[5], // level
      0xfc | 3, // lengthSizeMinusOne, hard-coded to 4 bytes
      0xE0 | track.sps.length // 3bit reserved (111) + numOfSequenceParameterSets
      ].concat(sps).concat([track.pps.length // numOfPictureParameterSets
      ]).concat(pps))),
          // "PPS"
      width = track.width,
          height = track.height,
          hSpacing = track.pixelRatio[0],
          vSpacing = track.pixelRatio[1];
      //console.log('avcc:' + Hex.hexDump(avcc));
      return MP4.box(MP4.types.avc1, new Uint8Array([0x00, 0x00, 0x00, // reserved
      0x00, 0x00, 0x00, // reserved
      0x00, 0x01, // data_reference_index
      0x00, 0x00, // pre_defined
      0x00, 0x00, // reserved
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // pre_defined
      width >> 8 & 0xFF, width & 0xff, // width
      height >> 8 & 0xFF, height & 0xff, // height
      0x00, 0x48, 0x00, 0x00, // horizresolution
      0x00, 0x48, 0x00, 0x00, // vertresolution
      0x00, 0x00, 0x00, 0x00, // reserved
      0x00, 0x01, // frame_count
      0x12, 0x64, 0x61, 0x69, 0x6C, //dailymotion/hls.js
      0x79, 0x6D, 0x6F, 0x74, 0x69, 0x6F, 0x6E, 0x2F, 0x68, 0x6C, 0x73, 0x2E, 0x6A, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // compressorname
      0x00, 0x18, // depth = 24
      0x11, 0x11]), // pre_defined = -1
      avcc, MP4.box(MP4.types.btrt, new Uint8Array([0x00, 0x1c, 0x9c, 0x80, // bufferSizeDB
      0x00, 0x2d, 0xc6, 0xc0, // maxBitrate
      0x00, 0x2d, 0xc6, 0xc0])), // avgBitrate
      MP4.box(MP4.types.pasp, new Uint8Array([hSpacing >> 24, // hSpacing
      hSpacing >> 16 & 0xFF, hSpacing >> 8 & 0xFF, hSpacing & 0xFF, vSpacing >> 24, // vSpacing
      vSpacing >> 16 & 0xFF, vSpacing >> 8 & 0xFF, vSpacing & 0xFF])));
    }
  }, {
    key: 'esds',
    value: function esds(track) {
      var configlen = track.config.length;
      return new Uint8Array([0x00, // version 0
      0x00, 0x00, 0x00, // flags

      0x03, // descriptor_type
      0x17 + configlen, // length
      0x00, 0x01, //es_id
      0x00, // stream_priority

      0x04, // descriptor_type
      0x0f + configlen, // length
      0x40, //codec : mpeg4_audio
      0x15, // stream_type
      0x00, 0x00, 0x00, // buffer_size
      0x00, 0x00, 0x00, 0x00, // maxBitrate
      0x00, 0x00, 0x00, 0x00, // avgBitrate

      0x05 // descriptor_type
      ].concat([configlen]).concat(track.config).concat([0x06, 0x01, 0x02])); // GASpecificConfig)); // length + audio config descriptor
    }
  }, {
    key: 'mp4a',
    value: function mp4a(track) {
      var samplerate = track.samplerate;
      return MP4.box(MP4.types.mp4a, new Uint8Array([0x00, 0x00, 0x00, // reserved
      0x00, 0x00, 0x00, // reserved
      0x00, 0x01, // data_reference_index
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // reserved
      0x00, track.channelCount, // channelcount
      0x00, 0x10, // sampleSize:16bits
      0x00, 0x00, 0x00, 0x00, // reserved2
      samplerate >> 8 & 0xFF, samplerate & 0xff, //
      0x00, 0x00]), MP4.box(MP4.types.esds, MP4.esds(track)));
    }
  }, {
    key: 'mp3',
    value: function mp3(track) {
      var samplerate = track.samplerate;
      return MP4.box(MP4.types['.mp3'], new Uint8Array([0x00, 0x00, 0x00, // reserved
      0x00, 0x00, 0x00, // reserved
      0x00, 0x01, // data_reference_index
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // reserved
      0x00, track.channelCount, // channelcount
      0x00, 0x10, // sampleSize:16bits
      0x00, 0x00, 0x00, 0x00, // reserved2
      samplerate >> 8 & 0xFF, samplerate & 0xff, //
      0x00, 0x00]));
    }
  }, {
    key: 'stsd',
    value: function stsd(track) {
      if (track.type === 'audio') {
        if (!track.isAAC && track.codec === 'mp3') {
          return MP4.box(MP4.types.stsd, MP4.STSD, MP4.mp3(track));
        }
        return MP4.box(MP4.types.stsd, MP4.STSD, MP4.mp4a(track));
      } else {
        return MP4.box(MP4.types.stsd, MP4.STSD, MP4.avc1(track));
      }
    }
  }, {
    key: 'tkhd',
    value: function tkhd(track) {
      var id = track.id,
          duration = track.duration * track.timescale,
          width = track.width,
          height = track.height,
          upperWordDuration = Math.floor(duration / (UINT32_MAX + 1)),
          lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));
      return MP4.box(MP4.types.tkhd, new Uint8Array([0x01, // version 1
      0x00, 0x00, 0x07, // flags
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // creation_time
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, // modification_time
      id >> 24 & 0xFF, id >> 16 & 0xFF, id >> 8 & 0xFF, id & 0xFF, // track_ID
      0x00, 0x00, 0x00, 0x00, // reserved
      upperWordDuration >> 24, upperWordDuration >> 16 & 0xFF, upperWordDuration >> 8 & 0xFF, upperWordDuration & 0xFF, lowerWordDuration >> 24, lowerWordDuration >> 16 & 0xFF, lowerWordDuration >> 8 & 0xFF, lowerWordDuration & 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // reserved
      0x00, 0x00, // layer
      0x00, 0x00, // alternate_group
      0x00, 0x00, // non-audio track volume
      0x00, 0x00, // reserved
      0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, // transformation: unity matrix
      width >> 8 & 0xFF, width & 0xFF, 0x00, 0x00, // width
      height >> 8 & 0xFF, height & 0xFF, 0x00, 0x00 // height
      ]));
    }
  }, {
    key: 'traf',
    value: function traf(track, baseMediaDecodeTime) {
      var sampleDependencyTable = MP4.sdtp(track),
          id = track.id,
          upperWordBaseMediaDecodeTime = Math.floor(baseMediaDecodeTime / (UINT32_MAX + 1)),
          lowerWordBaseMediaDecodeTime = Math.floor(baseMediaDecodeTime % (UINT32_MAX + 1));
      return MP4.box(MP4.types.traf, MP4.box(MP4.types.tfhd, new Uint8Array([0x00, // version 0
      0x00, 0x00, 0x00, // flags
      id >> 24, id >> 16 & 0XFF, id >> 8 & 0XFF, id & 0xFF]) // track_ID
      ), MP4.box(MP4.types.tfdt, new Uint8Array([0x01, // version 1
      0x00, 0x00, 0x00, // flags
      upperWordBaseMediaDecodeTime >> 24, upperWordBaseMediaDecodeTime >> 16 & 0XFF, upperWordBaseMediaDecodeTime >> 8 & 0XFF, upperWordBaseMediaDecodeTime & 0xFF, lowerWordBaseMediaDecodeTime >> 24, lowerWordBaseMediaDecodeTime >> 16 & 0XFF, lowerWordBaseMediaDecodeTime >> 8 & 0XFF, lowerWordBaseMediaDecodeTime & 0xFF])), MP4.trun(track, sampleDependencyTable.length + 16 + // tfhd
      20 + // tfdt
      8 + // traf header
      16 + // mfhd
      8 + // moof header
      8), // mdat header
      sampleDependencyTable);
    }

    /**
     * Generate a track box.
     * @param track {object} a track definition
     * @return {Uint8Array} the track box
     */

  }, {
    key: 'trak',
    value: function trak(track) {
      track.duration = track.duration || 0xffffffff;
      return MP4.box(MP4.types.trak, MP4.tkhd(track), MP4.mdia(track));
    }
  }, {
    key: 'trex',
    value: function trex(track) {
      var id = track.id;
      return MP4.box(MP4.types.trex, new Uint8Array([0x00, // version 0
      0x00, 0x00, 0x00, // flags
      id >> 24, id >> 16 & 0XFF, id >> 8 & 0XFF, id & 0xFF, // track_ID
      0x00, 0x00, 0x00, 0x01, // default_sample_description_index
      0x00, 0x00, 0x00, 0x00, // default_sample_duration
      0x00, 0x00, 0x00, 0x00, // default_sample_size
      0x00, 0x01, 0x00, 0x01 // default_sample_flags
      ]));
    }
  }, {
    key: 'trun',
    value: function trun(track, offset) {
      var samples = track.samples || [],
          len = samples.length,
          arraylen = 12 + 16 * len,
          array = new Uint8Array(arraylen),
          i,
          sample,
          duration,
          size,
          flags,
          cts;
      offset += 8 + arraylen;
      array.set([0x00, // version 0
      0x00, 0x0f, 0x01, // flags
      len >>> 24 & 0xFF, len >>> 16 & 0xFF, len >>> 8 & 0xFF, len & 0xFF, // sample_count
      offset >>> 24 & 0xFF, offset >>> 16 & 0xFF, offset >>> 8 & 0xFF, offset & 0xFF // data_offset
      ], 0);
      for (i = 0; i < len; i++) {
        sample = samples[i];
        duration = sample.duration;
        size = sample.size;
        flags = sample.flags;
        cts = sample.cts;
        array.set([duration >>> 24 & 0xFF, duration >>> 16 & 0xFF, duration >>> 8 & 0xFF, duration & 0xFF, // sample_duration
        size >>> 24 & 0xFF, size >>> 16 & 0xFF, size >>> 8 & 0xFF, size & 0xFF, // sample_size
        flags.isLeading << 2 | flags.dependsOn, flags.isDependedOn << 6 | flags.hasRedundancy << 4 | flags.paddingValue << 1 | flags.isNonSync, flags.degradPrio & 0xF0 << 8, flags.degradPrio & 0x0F, // sample_flags
        cts >>> 24 & 0xFF, cts >>> 16 & 0xFF, cts >>> 8 & 0xFF, cts & 0xFF // sample_composition_time_offset
        ], 12 + 16 * i);
      }
      return MP4.box(MP4.types.trun, array);
    }
  }, {
    key: 'initSegment',
    value: function initSegment(tracks) {
      if (!MP4.types) {
        MP4.init();
      }
      var movie = MP4.moov(tracks),
          result;
      result = new Uint8Array(MP4.FTYP.byteLength + movie.byteLength);
      result.set(MP4.FTYP);
      result.set(movie, MP4.FTYP.byteLength);
      return result;
    }
  }]);

  return MP4;
}();

exports.default = MP4;

},{}],45:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     * fMP4 remuxer
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */

var _aac = require('../helper/aac');

var _aac2 = _interopRequireDefault(_aac);

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _logger = require('../utils/logger');

var _mp4Generator = require('../remux/mp4-generator');

var _mp4Generator2 = _interopRequireDefault(_mp4Generator);

var _errors = require('../errors');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// 10 seconds
var MAX_SILENT_FRAME_DURATION = 10 * 1000;

var MP4Remuxer = function () {
  function MP4Remuxer(observer, config, typeSupported, vendor) {
    _classCallCheck(this, MP4Remuxer);

    this.observer = observer;
    this.config = config;
    this.typeSupported = typeSupported;
    var userAgent = navigator.userAgent;
    this.isSafari = vendor && vendor.indexOf('Apple') > -1 && userAgent && !userAgent.match('CriOS');
    this.ISGenerated = false;
  }

  _createClass(MP4Remuxer, [{
    key: 'destroy',
    value: function destroy() {}
  }, {
    key: 'resetTimeStamp',
    value: function resetTimeStamp(defaultTimeStamp) {
      this._initPTS = this._initDTS = defaultTimeStamp;
    }
  }, {
    key: 'resetInitSegment',
    value: function resetInitSegment() {
      this.ISGenerated = false;
    }
  }, {
    key: 'remux',
    value: function remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset) {
      // generate Init Segment if needed
      if (!this.ISGenerated) {
        this.generateIS(audioTrack, videoTrack, timeOffset);
      } else {
        if (accurateTimeOffset) {
          // check timestamp consistency. it there is more than 10s gap between expected PTS/DTS, recompute initPTS/DTS
          var refPTS = this._initPTS;
          var ptsNormalize = this._PTSNormalize;
          var timeScale = audioTrack.inputTimeScale || videoTrack.inputTimeScale;
          var initPTS = Infinity,
              initDTS = Infinity;
          var samples = audioTrack.samples;
          if (samples.length) {
            initPTS = initDTS = ptsNormalize(samples[0].pts - timeScale * timeOffset, refPTS);
          }
          samples = videoTrack.samples;
          if (samples.length) {
            var sample = samples[0];
            initPTS = Math.min(initPTS, ptsNormalize(sample.pts - timeScale * timeOffset, refPTS));
            initDTS = Math.min(initDTS, ptsNormalize(sample.dts - timeScale * timeOffset, refPTS));
          }
          if (initPTS !== Infinity) {
            var initPTSDelta = refPTS - initPTS;
            if (Math.abs(initPTSDelta) > 10 * timeScale) {
              _logger.logger.warn('timestamp inconsistency, ' + (initPTSDelta / timeScale).toFixed(3) + 's delta against expected value: missing discontinuity ? reset initPTS/initDTS');
              this._initPTS = initPTS;
              this._initDTS = initDTS;
              this.observer.trigger(_events2.default.INIT_PTS_FOUND, { initPTS: initPTS });
            }
          }
        }
      }

      if (this.ISGenerated) {
        // Purposefully remuxing audio before video, so that remuxVideo can use nextAudioPts, which is
        // calculated in remuxAudio.
        //logger.log('nb AAC samples:' + audioTrack.samples.length);
        if (audioTrack.samples.length) {
          // if initSegment was generated without video samples, regenerate it again
          if (!audioTrack.timescale) {
            _logger.logger.warn('regenerate InitSegment as audio detected');
            this.generateIS(audioTrack, videoTrack, timeOffset);
          }
          var audioData = this.remuxAudio(audioTrack, timeOffset, contiguous, accurateTimeOffset);
          //logger.log('nb AVC samples:' + videoTrack.samples.length);
          if (videoTrack.samples.length) {
            var audioTrackLength = void 0;
            if (audioData) {
              audioTrackLength = audioData.endPTS - audioData.startPTS;
            }
            // if initSegment was generated without video samples, regenerate it again
            if (!videoTrack.timescale) {
              _logger.logger.warn('regenerate InitSegment as video detected');
              this.generateIS(audioTrack, videoTrack, timeOffset);
            }
            this.remuxVideo(videoTrack, timeOffset, contiguous, audioTrackLength, accurateTimeOffset);
          }
        } else {
          var videoData = void 0;
          //logger.log('nb AVC samples:' + videoTrack.samples.length);
          if (videoTrack.samples.length) {
            videoData = this.remuxVideo(videoTrack, timeOffset, contiguous, accurateTimeOffset);
          }
          if (videoData && audioTrack.codec) {
            this.remuxEmptyAudio(audioTrack, timeOffset, contiguous, videoData);
          }
        }
      }
      //logger.log('nb ID3 samples:' + audioTrack.samples.length);
      if (id3Track.samples.length) {
        this.remuxID3(id3Track, timeOffset);
      }
      //logger.log('nb ID3 samples:' + audioTrack.samples.length);
      if (textTrack.samples.length) {
        this.remuxText(textTrack, timeOffset);
      }
      //notify end of parsing
      this.observer.trigger(_events2.default.FRAG_PARSED);
    }
  }, {
    key: 'generateIS',
    value: function generateIS(audioTrack, videoTrack, timeOffset) {
      var observer = this.observer,
          audioSamples = audioTrack.samples,
          videoSamples = videoTrack.samples,
          typeSupported = this.typeSupported,
          container = 'audio/mp4',
          tracks = {},
          data = { tracks: tracks },
          computePTSDTS = this._initPTS === undefined,
          initPTS,
          initDTS;

      if (computePTSDTS) {
        initPTS = initDTS = Infinity;
      }
      if (audioTrack.config && audioSamples.length) {
        // let's use audio sampling rate as MP4 time scale.
        // rationale is that there is a integer nb of audio frames per audio sample (1024 for AAC)
        // using audio sampling rate here helps having an integer MP4 frame duration
        // this avoids potential rounding issue and AV sync issue
        audioTrack.timescale = audioTrack.samplerate;
        _logger.logger.log('audio sampling rate : ' + audioTrack.samplerate);
        if (!audioTrack.isAAC) {
          if (typeSupported.mpeg) {
            // Chrome and Safari
            container = 'audio/mpeg';
            audioTrack.codec = '';
          } else if (typeSupported.mp3) {
            // Firefox
            audioTrack.codec = 'mp3';
          }
        }
        tracks.audio = {
          container: container,
          codec: audioTrack.codec,
          initSegment: !audioTrack.isAAC && typeSupported.mpeg ? new Uint8Array() : _mp4Generator2.default.initSegment([audioTrack]),
          metadata: {
            channelCount: audioTrack.channelCount
          }
        };
        if (computePTSDTS) {
          // remember first PTS of this demuxing context. for audio, PTS = DTS
          initPTS = initDTS = audioSamples[0].pts - audioTrack.inputTimeScale * timeOffset;
        }
      }

      if (videoTrack.sps && videoTrack.pps && videoSamples.length) {
        // let's use input time scale as MP4 video timescale
        // we use input time scale straight away to avoid rounding issues on frame duration / cts computation
        var inputTimeScale = videoTrack.inputTimeScale;
        videoTrack.timescale = inputTimeScale;
        tracks.video = {
          container: 'video/mp4',
          codec: videoTrack.codec,
          initSegment: _mp4Generator2.default.initSegment([videoTrack]),
          metadata: {
            width: videoTrack.width,
            height: videoTrack.height
          }
        };
        if (computePTSDTS) {
          initPTS = Math.min(initPTS, videoSamples[0].pts - inputTimeScale * timeOffset);
          initDTS = Math.min(initDTS, videoSamples[0].dts - inputTimeScale * timeOffset);
          this.observer.trigger(_events2.default.INIT_PTS_FOUND, { initPTS: initPTS });
        }
      }

      if (Object.keys(tracks).length) {
        observer.trigger(_events2.default.FRAG_PARSING_INIT_SEGMENT, data);
        this.ISGenerated = true;
        if (computePTSDTS) {
          this._initPTS = initPTS;
          this._initDTS = initDTS;
        }
      } else {
        observer.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.FRAG_PARSING_ERROR, fatal: false, reason: 'no audio/video samples found' });
      }
    }
  }, {
    key: 'remuxVideo',
    value: function remuxVideo(track, timeOffset, contiguous, audioTrackLength, accurateTimeOffset) {
      var offset = 8,
          timeScale = track.timescale,
          mp4SampleDuration,
          mdat,
          moof,
          firstPTS,
          firstDTS,
          nextDTS,
          lastPTS,
          lastDTS,
          inputSamples = track.samples,
          outputSamples = [],
          nbSamples = inputSamples.length,
          ptsNormalize = this._PTSNormalize,
          initDTS = this._initDTS;

      // for (let i = 0; i < track.samples.length; i++) {
      //   let avcSample = track.samples[i];
      //   let units = avcSample.units;
      //   let unitsString = '';
      //   for (let j = 0; j < units.length ; j++) {
      //     unitsString += units[j].type + ',';
      //     if (units[j].data.length < 500) {
      //       unitsString += Hex.hexDump(units[j].data);
      //     }
      //   }
      //   logger.log(avcSample.pts + '/' + avcSample.dts + ',' + unitsString + avcSample.units.length);
      // }

      // if parsed fragment is contiguous with last one, let's use last DTS value as reference
      var nextAvcDts = this.nextAvcDts;

      var isSafari = this.isSafari;

      // Safari does not like overlapping DTS on consecutive fragments. let's use nextAvcDts to overcome this if fragments are consecutive
      if (isSafari) {
        // also consider consecutive fragments as being contiguous (even if a level switch occurs),
        // for sake of clarity:
        // consecutive fragments are frags with
        //  - less than 100ms gaps between new time offset (if accurate) and next expected PTS OR
        //  - less than 200 ms PTS gaps (timeScale/5)
        contiguous |= inputSamples.length && nextAvcDts && (accurateTimeOffset && Math.abs(timeOffset - nextAvcDts / timeScale) < 0.1 || Math.abs(inputSamples[0].pts - nextAvcDts - initDTS) < timeScale / 5);
      }

      if (!contiguous) {
        // if not contiguous, let's use target timeOffset
        nextAvcDts = timeOffset * timeScale;
      }

      // PTS is coded on 33bits, and can loop from -2^32 to 2^32
      // ptsNormalize will make PTS/DTS value monotonic, we use last known DTS value as reference value
      inputSamples.forEach(function (sample) {
        sample.pts = ptsNormalize(sample.pts - initDTS, nextAvcDts);
        sample.dts = ptsNormalize(sample.dts - initDTS, nextAvcDts);
      });

      // sort video samples by DTS then PTS then demux id order
      inputSamples.sort(function (a, b) {
        var deltadts = a.dts - b.dts;
        var deltapts = a.pts - b.pts;
        return deltadts ? deltadts : deltapts ? deltapts : a.id - b.id;
      });

      // handle broken streams with PTS < DTS, tolerance up 200ms (18000 in 90kHz timescale)
      var PTSDTSshift = inputSamples.reduce(function (prev, curr) {
        return Math.max(Math.min(prev, curr.pts - curr.dts), -18000);
      }, 0);
      if (PTSDTSshift < 0) {
        _logger.logger.warn('PTS < DTS detected in video samples, shifting DTS by ' + Math.round(PTSDTSshift / 90) + ' ms to overcome this issue');
        for (var i = 0; i < inputSamples.length; i++) {
          inputSamples[i].dts += PTSDTSshift;
        }
      }

      // compute first DTS and last DTS, normalize them against reference value
      var sample = inputSamples[0];
      firstDTS = Math.max(sample.dts, 0);
      firstPTS = Math.max(sample.pts, 0);

      // check timestamp continuity accross consecutive fragments (this is to remove inter-fragment gap/hole)
      var delta = Math.round((firstDTS - nextAvcDts) / 90);
      // if fragment are contiguous, detect hole/overlapping between fragments
      if (contiguous) {
        if (delta) {
          if (delta > 1) {
            _logger.logger.log('AVC:' + delta + ' ms hole between fragments detected,filling it');
          } else if (delta < -1) {
            _logger.logger.log('AVC:' + -delta + ' ms overlapping between fragments detected');
          }
          // remove hole/gap : set DTS to next expected DTS
          firstDTS = nextAvcDts;
          inputSamples[0].dts = firstDTS;
          // offset PTS as well, ensure that PTS is smaller or equal than new DTS
          firstPTS = Math.max(firstPTS - delta, nextAvcDts);
          inputSamples[0].pts = firstPTS;
          _logger.logger.log('Video/PTS/DTS adjusted: ' + Math.round(firstPTS / 90) + '/' + Math.round(firstDTS / 90) + ',delta:' + delta + ' ms');
        }
      }
      nextDTS = firstDTS;

      // compute lastPTS/lastDTS
      sample = inputSamples[inputSamples.length - 1];
      lastDTS = Math.max(sample.dts, 0);
      lastPTS = Math.max(sample.pts, 0, lastDTS);

      // on Safari let's signal the same sample duration for all samples
      // sample duration (as expected by trun MP4 boxes), should be the delta between sample DTS
      // set this constant duration as being the avg delta between consecutive DTS.
      if (isSafari) {
        mp4SampleDuration = Math.round((lastDTS - firstDTS) / (inputSamples.length - 1));
      }

      var nbNalu = 0,
          naluLen = 0;
      for (var _i = 0; _i < nbSamples; _i++) {
        // compute total/avc sample length and nb of NAL units
        var _sample = inputSamples[_i],
            units = _sample.units,
            nbUnits = units.length,
            sampleLen = 0;
        for (var j = 0; j < nbUnits; j++) {
          sampleLen += units[j].data.length;
        }
        naluLen += sampleLen;
        nbNalu += nbUnits;
        _sample.length = sampleLen;

        // normalize PTS/DTS
        if (isSafari) {
          // sample DTS is computed using a constant decoding offset (mp4SampleDuration) between samples
          _sample.dts = firstDTS + _i * mp4SampleDuration;
        } else {
          // ensure sample monotonic DTS
          _sample.dts = Math.max(_sample.dts, firstDTS);
        }
        // ensure that computed value is greater or equal than sample DTS
        _sample.pts = Math.max(_sample.pts, _sample.dts);
      }

      /* concatenate the video data and construct the mdat in place
        (need 8 more bytes to fill length and mpdat type) */
      var mdatSize = naluLen + 4 * nbNalu + 8;
      try {
        mdat = new Uint8Array(mdatSize);
      } catch (err) {
        this.observer.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MUX_ERROR, details: _errors.ErrorDetails.REMUX_ALLOC_ERROR, fatal: false, bytes: mdatSize, reason: 'fail allocating video mdat ' + mdatSize });
        return;
      }
      var view = new DataView(mdat.buffer);
      view.setUint32(0, mdatSize);
      mdat.set(_mp4Generator2.default.types.mdat, 4);

      for (var _i2 = 0; _i2 < nbSamples; _i2++) {
        var avcSample = inputSamples[_i2],
            avcSampleUnits = avcSample.units,
            mp4SampleLength = 0,
            compositionTimeOffset = void 0;
        // convert NALU bitstream to MP4 format (prepend NALU with size field)
        for (var _j = 0, _nbUnits = avcSampleUnits.length; _j < _nbUnits; _j++) {
          var unit = avcSampleUnits[_j],
              unitData = unit.data,
              unitDataLen = unit.data.byteLength;
          view.setUint32(offset, unitDataLen);
          offset += 4;
          mdat.set(unitData, offset);
          offset += unitDataLen;
          mp4SampleLength += 4 + unitDataLen;
        }

        if (!isSafari) {
          // expected sample duration is the Decoding Timestamp diff of consecutive samples
          if (_i2 < nbSamples - 1) {
            mp4SampleDuration = inputSamples[_i2 + 1].dts - avcSample.dts;
          } else {
            var config = this.config,
                lastFrameDuration = avcSample.dts - inputSamples[_i2 > 0 ? _i2 - 1 : _i2].dts;
            if (config.stretchShortVideoTrack) {
              // In some cases, a segment's audio track duration may exceed the video track duration.
              // Since we've already remuxed audio, and we know how long the audio track is, we look to
              // see if the delta to the next segment is longer than the minimum of maxBufferHole and
              // maxSeekHole. If so, playback would potentially get stuck, so we artificially inflate
              // the duration of the last frame to minimize any potential gap between segments.
              var maxBufferHole = config.maxBufferHole,
                  maxSeekHole = config.maxSeekHole,
                  gapTolerance = Math.floor(Math.min(maxBufferHole, maxSeekHole) * timeScale),
                  deltaToFrameEnd = (audioTrackLength ? firstPTS + audioTrackLength * timeScale : this.nextAudioPts) - avcSample.pts;
              if (deltaToFrameEnd > gapTolerance) {
                // We subtract lastFrameDuration from deltaToFrameEnd to try to prevent any video
                // frame overlap. maxBufferHole/maxSeekHole should be >> lastFrameDuration anyway.
                mp4SampleDuration = deltaToFrameEnd - lastFrameDuration;
                if (mp4SampleDuration < 0) {
                  mp4SampleDuration = lastFrameDuration;
                }
                _logger.logger.log('It is approximately ' + deltaToFrameEnd / 90 + ' ms to the next segment; using duration ' + mp4SampleDuration / 90 + ' ms for the last video frame.');
              } else {
                mp4SampleDuration = lastFrameDuration;
              }
            } else {
              mp4SampleDuration = lastFrameDuration;
            }
          }
          compositionTimeOffset = Math.round(avcSample.pts - avcSample.dts);
        } else {
          compositionTimeOffset = Math.max(0, mp4SampleDuration * Math.round((avcSample.pts - avcSample.dts) / mp4SampleDuration));
        }

        //console.log('PTS/DTS/initDTS/normPTS/normDTS/relative PTS : ${avcSample.pts}/${avcSample.dts}/${initDTS}/${ptsnorm}/${dtsnorm}/${(avcSample.pts/4294967296).toFixed(3)}');
        outputSamples.push({
          size: mp4SampleLength,
          // constant duration
          duration: mp4SampleDuration,
          cts: compositionTimeOffset,
          flags: {
            isLeading: 0,
            isDependedOn: 0,
            hasRedundancy: 0,
            degradPrio: 0,
            dependsOn: avcSample.key ? 2 : 1,
            isNonSync: avcSample.key ? 0 : 1
          }
        });
      }
      // next AVC sample DTS should be equal to last sample DTS + last sample duration (in PES timescale)
      this.nextAvcDts = lastDTS + mp4SampleDuration;
      var dropped = track.dropped;
      track.len = 0;
      track.nbNalu = 0;
      track.dropped = 0;
      if (outputSamples.length && navigator.userAgent.toLowerCase().indexOf('chrome') > -1) {
        var flags = outputSamples[0].flags;
        // chrome workaround, mark first sample as being a Random Access Point to avoid sourcebuffer append issue
        // https://code.google.com/p/chromium/issues/detail?id=229412
        flags.dependsOn = 2;
        flags.isNonSync = 0;
      }
      track.samples = outputSamples;
      moof = _mp4Generator2.default.moof(track.sequenceNumber++, firstDTS, track);
      track.samples = [];

      var data = {
        data1: moof,
        data2: mdat,
        startPTS: firstPTS / timeScale,
        endPTS: (lastPTS + mp4SampleDuration) / timeScale,
        startDTS: firstDTS / timeScale,
        endDTS: this.nextAvcDts / timeScale,
        type: 'video',
        nb: outputSamples.length,
        dropped: dropped
      };
      this.observer.trigger(_events2.default.FRAG_PARSING_DATA, data);
      return data;
    }
  }, {
    key: 'remuxAudio',
    value: function remuxAudio(track, timeOffset, contiguous, accurateTimeOffset) {
      var inputTimeScale = track.inputTimeScale,
          mp4timeScale = track.timescale,
          scaleFactor = inputTimeScale / mp4timeScale,
          mp4SampleDuration = track.isAAC ? 1024 : 1152,
          inputSampleDuration = mp4SampleDuration * scaleFactor,
          ptsNormalize = this._PTSNormalize,
          initDTS = this._initDTS,
          rawMPEG = !track.isAAC && this.typeSupported.mpeg;

      var offset,
          mp4Sample,
          fillFrame,
          mdat,
          moof,
          firstPTS,
          lastPTS,
          inputSamples = track.samples,
          outputSamples = [],
          nextAudioPts = this.nextAudioPts;

      // for audio samples, also consider consecutive fragments as being contiguous (even if a level switch occurs),
      // for sake of clarity:
      // consecutive fragments are frags with
      //  - less than 100ms gaps between new time offset (if accurate) and next expected PTS OR
      //  - less than 20 audio frames distance
      // contiguous fragments are consecutive fragments from same quality level (same level, new SN = old SN + 1)
      // this helps ensuring audio continuity
      // and this also avoids audio glitches/cut when switching quality, or reporting wrong duration on first audio frame
      contiguous |= inputSamples.length && nextAudioPts && (accurateTimeOffset && Math.abs(timeOffset - nextAudioPts / inputTimeScale) < 0.1 || Math.abs(inputSamples[0].pts - nextAudioPts - initDTS) < 20 * inputSampleDuration);

      if (!contiguous) {
        // if fragments are not contiguous, let's use timeOffset to compute next Audio PTS
        nextAudioPts = timeOffset * inputTimeScale;
      }

      // compute normalized PTS
      inputSamples.forEach(function (sample) {
        sample.pts = sample.dts = ptsNormalize(sample.pts - initDTS, nextAudioPts);
      });

      // sort based on normalized PTS (this is to avoid sorting issues in case timestamp
      // reloop in the middle of our samples array)
      inputSamples.sort(function (a, b) {
        return a.pts - b.pts;
      });

      // If the audio track is missing samples, the frames seem to get "left-shifted" within the
      // resulting mp4 segment, causing sync issues and leaving gaps at the end of the audio segment.
      // In an effort to prevent this from happening, we inject frames here where there are gaps.
      // When possible, we inject a silent frame; when that's not possible, we duplicate the last
      // frame.

      // only inject/drop audio frames in case time offset is accurate
      if (accurateTimeOffset && track.isAAC) {
        for (var i = 0, nextPts = nextAudioPts; i < inputSamples.length;) {
          // First, let's see how far off this frame is from where we expect it to be
          var sample = inputSamples[i],
              delta;
          var pts = sample.pts;
          delta = pts - nextPts;

          var duration = Math.abs(1000 * delta / inputTimeScale);

          // If we're overlapping by more than a duration, drop this sample
          if (delta <= -inputSampleDuration) {
            _logger.logger.warn('Dropping 1 audio frame @ ' + (nextPts / inputTimeScale).toFixed(3) + 's due to ' + duration + ' ms overlap.');
            inputSamples.splice(i, 1);
            track.len -= sample.unit.length;
            // Don't touch nextPtsNorm or i
          }

          // Insert missing frames if:
          // 1: We're more than one frame away
          // 2: Not more than MAX_SILENT_FRAME_DURATION away
          // 3: currentTime (aka nextPtsNorm) is not 0
          else if (delta >= inputSampleDuration && duration < MAX_SILENT_FRAME_DURATION && nextPts) {
              var missing = Math.round(delta / inputSampleDuration);
              _logger.logger.warn('Injecting ' + missing + ' audio frame @ ' + (nextPts / inputTimeScale).toFixed(3) + 's due to ' + Math.round(1000 * delta / inputTimeScale) + ' ms gap.');
              for (var j = 0; j < missing; j++) {
                var newStamp = Math.max(nextPts, 0);
                fillFrame = _aac2.default.getSilentFrame(track.manifestCodec || track.codec, track.channelCount);
                if (!fillFrame) {
                  _logger.logger.log('Unable to get silent frame for given audio codec; duplicating last frame instead.');
                  fillFrame = sample.unit.subarray();
                }
                inputSamples.splice(i, 0, { unit: fillFrame, pts: newStamp, dts: newStamp });
                track.len += fillFrame.length;
                nextPts += inputSampleDuration;
                i++;
              }

              // Adjust sample to next expected pts
              sample.pts = sample.dts = nextPts;
              nextPts += inputSampleDuration;
              i++;
            } else {
              // Otherwise, just adjust pts
              if (Math.abs(delta) > 0.1 * inputSampleDuration) {
                //logger.log(`Invalid frame delta ${Math.round(delta + inputSampleDuration)} at PTS ${Math.round(pts / 90)} (should be ${Math.round(inputSampleDuration)}).`);
              }
              sample.pts = sample.dts = nextPts;
              nextPts += inputSampleDuration;
              i++;
            }
        }
      }

      for (var _j2 = 0, _nbSamples = inputSamples.length; _j2 < _nbSamples; _j2++) {
        var audioSample = inputSamples[_j2];
        var unit = audioSample.unit;
        var _pts = audioSample.pts;
        //logger.log(`Audio/PTS:${Math.round(pts/90)}`);
        // if not first sample
        if (lastPTS !== undefined) {
          mp4Sample.duration = Math.round((_pts - lastPTS) / scaleFactor);
        } else {
          var _delta = Math.round(1000 * (_pts - nextAudioPts) / inputTimeScale),
              numMissingFrames = 0;
          // if fragment are contiguous, detect hole/overlapping between fragments
          // contiguous fragments are consecutive fragments from same quality level (same level, new SN = old SN + 1)
          if (contiguous && track.isAAC) {
            // log delta
            if (_delta) {
              if (_delta > 0 && _delta < MAX_SILENT_FRAME_DURATION) {
                numMissingFrames = Math.round((_pts - nextAudioPts) / inputSampleDuration);
                _logger.logger.log(_delta + ' ms hole between AAC samples detected,filling it');
                if (numMissingFrames > 0) {
                  fillFrame = _aac2.default.getSilentFrame(track.manifestCodec || track.codec, track.channelCount);
                  if (!fillFrame) {
                    fillFrame = unit.subarray();
                  }
                  track.len += numMissingFrames * fillFrame.length;
                }
                // if we have frame overlap, overlapping for more than half a frame duraion
              } else if (_delta < -12) {
                // drop overlapping audio frames... browser will deal with it
                _logger.logger.log('drop overlapping AAC sample, expected/parsed/delta:' + (nextAudioPts / inputTimeScale).toFixed(3) + 's/' + (_pts / inputTimeScale).toFixed(3) + 's/' + -_delta + 'ms');
                track.len -= unit.byteLength;
                continue;
              }
              // set PTS/DTS to expected PTS/DTS
              _pts = nextAudioPts;
            }
          }
          // remember first PTS of our audioSamples, ensure value is positive
          firstPTS = Math.max(0, _pts);
          if (track.len > 0) {
            /* concatenate the audio data and construct the mdat in place
              (need 8 more bytes to fill length and mdat type) */
            var mdatSize = rawMPEG ? track.len : track.len + 8;
            offset = rawMPEG ? 0 : 8;
            try {
              mdat = new Uint8Array(mdatSize);
            } catch (err) {
              this.observer.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MUX_ERROR, details: _errors.ErrorDetails.REMUX_ALLOC_ERROR, fatal: false, bytes: mdatSize, reason: 'fail allocating audio mdat ' + mdatSize });
              return;
            }
            if (!rawMPEG) {
              var view = new DataView(mdat.buffer);
              view.setUint32(0, mdatSize);
              mdat.set(_mp4Generator2.default.types.mdat, 4);
            }
          } else {
            // no audio samples
            return;
          }
          for (var _i3 = 0; _i3 < numMissingFrames; _i3++) {
            fillFrame = _aac2.default.getSilentFrame(track.manifestCodec || track.codec, track.channelCount);
            if (!fillFrame) {
              _logger.logger.log('Unable to get silent frame for given audio codec; duplicating this frame instead.');
              fillFrame = unit.subarray();
            }
            mdat.set(fillFrame, offset);
            offset += fillFrame.byteLength;
            mp4Sample = {
              size: fillFrame.byteLength,
              cts: 0,
              duration: 1024,
              flags: {
                isLeading: 0,
                isDependedOn: 0,
                hasRedundancy: 0,
                degradPrio: 0,
                dependsOn: 1
              }
            };
            outputSamples.push(mp4Sample);
          }
        }
        mdat.set(unit, offset);
        var unitLen = unit.byteLength;
        offset += unitLen;
        //console.log('PTS/DTS/initDTS/normPTS/normDTS/relative PTS : ${audioSample.pts}/${audioSample.dts}/${initDTS}/${ptsnorm}/${dtsnorm}/${(audioSample.pts/4294967296).toFixed(3)}');
        mp4Sample = {
          size: unitLen,
          cts: 0,
          duration: 0,
          flags: {
            isLeading: 0,
            isDependedOn: 0,
            hasRedundancy: 0,
            degradPrio: 0,
            dependsOn: 1
          }
        };
        outputSamples.push(mp4Sample);
        lastPTS = _pts;
      }
      var lastSampleDuration = 0;
      var nbSamples = outputSamples.length;
      //set last sample duration as being identical to previous sample
      if (nbSamples >= 2) {
        lastSampleDuration = outputSamples[nbSamples - 2].duration;
        mp4Sample.duration = lastSampleDuration;
      }
      if (nbSamples) {
        // next audio sample PTS should be equal to last sample PTS + duration
        this.nextAudioPts = nextAudioPts = lastPTS + scaleFactor * lastSampleDuration;
        //logger.log('Audio/PTS/PTSend:' + audioSample.pts.toFixed(0) + '/' + this.nextAacDts.toFixed(0));
        track.len = 0;
        track.samples = outputSamples;
        if (rawMPEG) {
          moof = new Uint8Array();
        } else {
          moof = _mp4Generator2.default.moof(track.sequenceNumber++, firstPTS / scaleFactor, track);
        }
        track.samples = [];
        var start = firstPTS / inputTimeScale;
        var end = nextAudioPts / inputTimeScale;
        var audioData = {
          data1: moof,
          data2: mdat,
          startPTS: start,
          endPTS: end,
          startDTS: start,
          endDTS: end,
          type: 'audio',
          nb: nbSamples
        };
        this.observer.trigger(_events2.default.FRAG_PARSING_DATA, audioData);
        return audioData;
      }
      return null;
    }
  }, {
    key: 'remuxEmptyAudio',
    value: function remuxEmptyAudio(track, timeOffset, contiguous, videoData) {
      var inputTimeScale = track.inputTimeScale,
          mp4timeScale = track.samplerate ? track.samplerate : inputTimeScale,
          scaleFactor = inputTimeScale / mp4timeScale,
          nextAudioPts = this.nextAudioPts,


      // sync with video's timestamp
      startDTS = (nextAudioPts !== undefined ? nextAudioPts : videoData.startDTS * inputTimeScale) + this._initDTS,
          endDTS = videoData.endDTS * inputTimeScale + this._initDTS,

      // one sample's duration value
      sampleDuration = 1024,
          frameDuration = scaleFactor * sampleDuration,


      // samples count of this segment's duration
      nbSamples = Math.ceil((endDTS - startDTS) / frameDuration),


      // silent frame
      silentFrame = _aac2.default.getSilentFrame(track.manifestCodec || track.codec, track.channelCount);

      _logger.logger.warn('remux empty Audio');
      // Can't remux if we can't generate a silent frame...
      if (!silentFrame) {
        _logger.logger.trace('Unable to remuxEmptyAudio since we were unable to get a silent frame for given audio codec!');
        return;
      }

      var samples = [];
      for (var i = 0; i < nbSamples; i++) {
        var stamp = startDTS + i * frameDuration;
        samples.push({ unit: silentFrame, pts: stamp, dts: stamp });
        track.len += silentFrame.length;
      }
      track.samples = samples;

      this.remuxAudio(track, timeOffset, contiguous);
    }
  }, {
    key: 'remuxID3',
    value: function remuxID3(track, timeOffset) {
      var length = track.samples.length,
          sample;
      var inputTimeScale = track.inputTimeScale;
      var initPTS = this._initPTS;
      var initDTS = this._initDTS;
      // consume samples
      if (length) {
        for (var index = 0; index < length; index++) {
          sample = track.samples[index];
          // setting id3 pts, dts to relative time
          // using this._initPTS and this._initDTS to calculate relative time
          sample.pts = (sample.pts - initPTS) / inputTimeScale;
          sample.dts = (sample.dts - initDTS) / inputTimeScale;
        }
        this.observer.trigger(_events2.default.FRAG_PARSING_METADATA, {
          samples: track.samples
        });
      }

      track.samples = [];
      timeOffset = timeOffset;
    }
  }, {
    key: 'remuxText',
    value: function remuxText(track, timeOffset) {
      track.samples.sort(function (a, b) {
        return a.pts - b.pts;
      });

      var length = track.samples.length,
          sample;
      var inputTimeScale = track.inputTimeScale;
      var initPTS = this._initPTS;
      // consume samples
      if (length) {
        for (var index = 0; index < length; index++) {
          sample = track.samples[index];
          // setting text pts, dts to relative time
          // using this._initPTS and this._initDTS to calculate relative time
          sample.pts = (sample.pts - initPTS) / inputTimeScale;
        }
        this.observer.trigger(_events2.default.FRAG_PARSING_USERDATA, {
          samples: track.samples
        });
      }

      track.samples = [];
      timeOffset = timeOffset;
    }
  }, {
    key: '_PTSNormalize',
    value: function _PTSNormalize(value, reference) {
      var offset;
      if (reference === undefined) {
        return value;
      }
      if (reference < value) {
        // - 2^33
        offset = -8589934592;
      } else {
        // + 2^33
        offset = 8589934592;
      }
      /* PTS is 33bit (from 0 to 2^33 -1)
        if diff between value and reference is bigger than half of the amplitude (2^32) then it means that
        PTS looping occured. fill the gap */
      while (Math.abs(value - reference) > 4294967296) {
        value += offset;
      }
      return value;
    }
  }]);

  return MP4Remuxer;
}();

exports.default = MP4Remuxer;

},{"../errors":33,"../events":35,"../helper/aac":36,"../remux/mp4-generator":44,"../utils/logger":54}],46:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * passthrough remuxer
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */


var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var PassThroughRemuxer = function () {
  function PassThroughRemuxer(observer) {
    _classCallCheck(this, PassThroughRemuxer);

    this.observer = observer;
  }

  _createClass(PassThroughRemuxer, [{
    key: 'destroy',
    value: function destroy() {}
  }, {
    key: 'resetTimeStamp',
    value: function resetTimeStamp() {}
  }, {
    key: 'resetInitSegment',
    value: function resetInitSegment() {}
  }, {
    key: 'remux',
    value: function remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset, rawData) {
      var observer = this.observer;
      var streamType = '';
      if (audioTrack) {
        streamType += 'audio';
      }
      if (videoTrack) {
        streamType += 'video';
      }
      observer.trigger(_events2.default.FRAG_PARSING_DATA, {
        data1: rawData,
        startPTS: timeOffset,
        startDTS: timeOffset,
        type: streamType,
        nb: 1,
        dropped: 0
      });
      //notify end of parsing
      observer.trigger(_events2.default.FRAG_PARSED);
    }
  }]);

  return PassThroughRemuxer;
}();

exports.default = PassThroughRemuxer;

},{"../events":35}],47:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var DECIMAL_RESOLUTION_REGEX = /^(\d+)x(\d+)$/;
var ATTR_LIST_REGEX = /\s*(.+?)\s*=((?:\".*?\")|.*?)(?:,|$)/g;

// adapted from https://github.com/kanongil/node-m3u8parse/blob/master/attrlist.js

var AttrList = function () {
  function AttrList(attrs) {
    _classCallCheck(this, AttrList);

    if (typeof attrs === 'string') {
      attrs = AttrList.parseAttrList(attrs);
    }
    for (var attr in attrs) {
      if (attrs.hasOwnProperty(attr)) {
        this[attr] = attrs[attr];
      }
    }
  }

  _createClass(AttrList, [{
    key: 'decimalInteger',
    value: function decimalInteger(attrName) {
      var intValue = parseInt(this[attrName], 10);
      if (intValue > Number.MAX_SAFE_INTEGER) {
        return Infinity;
      }
      return intValue;
    }
  }, {
    key: 'hexadecimalInteger',
    value: function hexadecimalInteger(attrName) {
      if (this[attrName]) {
        var stringValue = (this[attrName] || '0x').slice(2);
        stringValue = (stringValue.length & 1 ? '0' : '') + stringValue;

        var value = new Uint8Array(stringValue.length / 2);
        for (var i = 0; i < stringValue.length / 2; i++) {
          value[i] = parseInt(stringValue.slice(i * 2, i * 2 + 2), 16);
        }
        return value;
      } else {
        return null;
      }
    }
  }, {
    key: 'hexadecimalIntegerAsNumber',
    value: function hexadecimalIntegerAsNumber(attrName) {
      var intValue = parseInt(this[attrName], 16);
      if (intValue > Number.MAX_SAFE_INTEGER) {
        return Infinity;
      }
      return intValue;
    }
  }, {
    key: 'decimalFloatingPoint',
    value: function decimalFloatingPoint(attrName) {
      return parseFloat(this[attrName]);
    }
  }, {
    key: 'enumeratedString',
    value: function enumeratedString(attrName) {
      return this[attrName];
    }
  }, {
    key: 'decimalResolution',
    value: function decimalResolution(attrName) {
      var res = DECIMAL_RESOLUTION_REGEX.exec(this[attrName]);
      if (res === null) {
        return undefined;
      }
      return {
        width: parseInt(res[1], 10),
        height: parseInt(res[2], 10)
      };
    }
  }], [{
    key: 'parseAttrList',
    value: function parseAttrList(input) {
      var match,
          attrs = {};
      ATTR_LIST_REGEX.lastIndex = 0;
      while ((match = ATTR_LIST_REGEX.exec(input)) !== null) {
        var value = match[2],
            quote = '"';

        if (value.indexOf(quote) === 0 && value.lastIndexOf(quote) === value.length - 1) {
          value = value.slice(1, -1);
        }
        attrs[match[1]] = value;
      }
      return attrs;
    }
  }]);

  return AttrList;
}();

exports.default = AttrList;

},{}],48:[function(require,module,exports){
"use strict";

var BinarySearch = {
    /**
     * Searches for an item in an array which matches a certain condition.
     * This requires the condition to only match one item in the array,
     * and for the array to be ordered.
     *
     * @param {Array} list The array to search.
     * @param {Function} comparisonFunction
     *      Called and provided a candidate item as the first argument.
     *      Should return:
     *          > -1 if the item should be located at a lower index than the provided item.
     *          > 1 if the item should be located at a higher index than the provided item.
     *          > 0 if the item is the item you're looking for.
     *
     * @return {*} The object if it is found or null otherwise.
     */
    search: function search(list, comparisonFunction) {
        var minIndex = 0;
        var maxIndex = list.length - 1;
        var currentIndex = null;
        var currentElement = null;

        while (minIndex <= maxIndex) {
            currentIndex = (minIndex + maxIndex) / 2 | 0;
            currentElement = list[currentIndex];

            var comparisonResult = comparisonFunction(currentElement);
            if (comparisonResult > 0) {
                minIndex = currentIndex + 1;
            } else if (comparisonResult < 0) {
                maxIndex = currentIndex - 1;
            } else {
                return currentElement;
            }
        }

        return null;
    }
};

module.exports = BinarySearch;

},{}],49:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 *
 * This code was ported from the dash.js project at:
 *   https://github.com/Dash-Industry-Forum/dash.js/blob/development/externals/cea608-parser.js
 *   https://github.com/Dash-Industry-Forum/dash.js/commit/8269b26a761e0853bb21d78780ed945144ecdd4d#diff-71bc295a2d6b6b7093a1d3290d53a4b2
 *
 * The original copyright appears below:
 *
 * The copyright in this software is being made available under the BSD License,
 * included below. This software may be subject to other third party and contributor
 * rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2015-2016, DASH Industry Forum.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *  1. Redistributions of source code must retain the above copyright notice, this
 *  list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *  this list of conditions and the following disclaimer in the documentation and/or
 *  other materials provided with the distribution.
 *  2. Neither the name of Dash Industry Forum nor the names of its
 *  contributors may be used to endorse or promote products derived from this software
 *  without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY
 *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 *  POSSIBILITY OF SUCH DAMAGE.
 */
/**
 *  Exceptions from regular ASCII. CodePoints are mapped to UTF-16 codes
 */

var specialCea608CharsCodes = {
    0x2a: 0xe1, // lowercase a, acute accent
    0x5c: 0xe9, // lowercase e, acute accent
    0x5e: 0xed, // lowercase i, acute accent
    0x5f: 0xf3, // lowercase o, acute accent
    0x60: 0xfa, // lowercase u, acute accent
    0x7b: 0xe7, // lowercase c with cedilla
    0x7c: 0xf7, // division symbol
    0x7d: 0xd1, // uppercase N tilde
    0x7e: 0xf1, // lowercase n tilde
    0x7f: 0x2588, // Full block
    // THIS BLOCK INCLUDES THE 16 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS
    // THAT COME FROM HI BYTE=0x11 AND LOW BETWEEN 0x30 AND 0x3F
    // THIS MEANS THAT \x50 MUST BE ADDED TO THE VALUES
    0x80: 0xae, // Registered symbol (R)
    0x81: 0xb0, // degree sign
    0x82: 0xbd, // 1/2 symbol
    0x83: 0xbf, // Inverted (open) question mark
    0x84: 0x2122, // Trademark symbol (TM)
    0x85: 0xa2, // Cents symbol
    0x86: 0xa3, // Pounds sterling
    0x87: 0x266a, // Music 8'th note
    0x88: 0xe0, // lowercase a, grave accent
    0x89: 0x20, // transparent space (regular)
    0x8a: 0xe8, // lowercase e, grave accent
    0x8b: 0xe2, // lowercase a, circumflex accent
    0x8c: 0xea, // lowercase e, circumflex accent
    0x8d: 0xee, // lowercase i, circumflex accent
    0x8e: 0xf4, // lowercase o, circumflex accent
    0x8f: 0xfb, // lowercase u, circumflex accent
    // THIS BLOCK INCLUDES THE 32 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS
    // THAT COME FROM HI BYTE=0x12 AND LOW BETWEEN 0x20 AND 0x3F
    0x90: 0xc1, // capital letter A with acute
    0x91: 0xc9, // capital letter E with acute
    0x92: 0xd3, // capital letter O with acute
    0x93: 0xda, // capital letter U with acute
    0x94: 0xdc, // capital letter U with diaresis
    0x95: 0xfc, // lowercase letter U with diaeresis
    0x96: 0x2018, // opening single quote
    0x97: 0xa1, // inverted exclamation mark
    0x98: 0x2a, // asterisk
    0x99: 0x2019, // closing single quote
    0x9a: 0x2501, // box drawings heavy horizontal
    0x9b: 0xa9, // copyright sign
    0x9c: 0x2120, // Service mark
    0x9d: 0x2022, // (round) bullet
    0x9e: 0x201c, // Left double quotation mark
    0x9f: 0x201d, // Right double quotation mark
    0xa0: 0xc0, // uppercase A, grave accent
    0xa1: 0xc2, // uppercase A, circumflex
    0xa2: 0xc7, // uppercase C with cedilla
    0xa3: 0xc8, // uppercase E, grave accent
    0xa4: 0xca, // uppercase E, circumflex
    0xa5: 0xcb, // capital letter E with diaresis
    0xa6: 0xeb, // lowercase letter e with diaresis
    0xa7: 0xce, // uppercase I, circumflex
    0xa8: 0xcf, // uppercase I, with diaresis
    0xa9: 0xef, // lowercase i, with diaresis
    0xaa: 0xd4, // uppercase O, circumflex
    0xab: 0xd9, // uppercase U, grave accent
    0xac: 0xf9, // lowercase u, grave accent
    0xad: 0xdb, // uppercase U, circumflex
    0xae: 0xab, // left-pointing double angle quotation mark
    0xaf: 0xbb, // right-pointing double angle quotation mark
    // THIS BLOCK INCLUDES THE 32 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS
    // THAT COME FROM HI BYTE=0x13 AND LOW BETWEEN 0x20 AND 0x3F
    0xb0: 0xc3, // Uppercase A, tilde
    0xb1: 0xe3, // Lowercase a, tilde
    0xb2: 0xcd, // Uppercase I, acute accent
    0xb3: 0xcc, // Uppercase I, grave accent
    0xb4: 0xec, // Lowercase i, grave accent
    0xb5: 0xd2, // Uppercase O, grave accent
    0xb6: 0xf2, // Lowercase o, grave accent
    0xb7: 0xd5, // Uppercase O, tilde
    0xb8: 0xf5, // Lowercase o, tilde
    0xb9: 0x7b, // Open curly brace
    0xba: 0x7d, // Closing curly brace
    0xbb: 0x5c, // Backslash
    0xbc: 0x5e, // Caret
    0xbd: 0x5f, // Underscore
    0xbe: 0x7c, // Pipe (vertical line)
    0xbf: 0x223c, // Tilde operator
    0xc0: 0xc4, // Uppercase A, umlaut
    0xc1: 0xe4, // Lowercase A, umlaut
    0xc2: 0xd6, // Uppercase O, umlaut
    0xc3: 0xf6, // Lowercase o, umlaut
    0xc4: 0xdf, // Esszett (sharp S)
    0xc5: 0xa5, // Yen symbol
    0xc6: 0xa4, // Generic currency sign
    0xc7: 0x2503, // Box drawings heavy vertical
    0xc8: 0xc5, // Uppercase A, ring
    0xc9: 0xe5, // Lowercase A, ring
    0xca: 0xd8, // Uppercase O, stroke
    0xcb: 0xf8, // Lowercase o, strok
    0xcc: 0x250f, // Box drawings heavy down and right
    0xcd: 0x2513, // Box drawings heavy down and left
    0xce: 0x2517, // Box drawings heavy up and right
    0xcf: 0x251b // Box drawings heavy up and left
};

/**
 * Utils
 */
var getCharForByte = function getCharForByte(byte) {
    var charCode = byte;
    if (specialCea608CharsCodes.hasOwnProperty(byte)) {
        charCode = specialCea608CharsCodes[byte];
    }
    return String.fromCharCode(charCode);
};

var NR_ROWS = 15,
    NR_COLS = 100;
// Tables to look up row from PAC data
var rowsLowCh1 = { 0x11: 1, 0x12: 3, 0x15: 5, 0x16: 7, 0x17: 9, 0x10: 11, 0x13: 12, 0x14: 14 };
var rowsHighCh1 = { 0x11: 2, 0x12: 4, 0x15: 6, 0x16: 8, 0x17: 10, 0x13: 13, 0x14: 15 };
var rowsLowCh2 = { 0x19: 1, 0x1A: 3, 0x1D: 5, 0x1E: 7, 0x1F: 9, 0x18: 11, 0x1B: 12, 0x1C: 14 };
var rowsHighCh2 = { 0x19: 2, 0x1A: 4, 0x1D: 6, 0x1E: 8, 0x1F: 10, 0x1B: 13, 0x1C: 15 };

var backgroundColors = ['white', 'green', 'blue', 'cyan', 'red', 'yellow', 'magenta', 'black', 'transparent'];

/**
 * Simple logger class to be able to write with time-stamps and filter on level.
 */
var logger = {
    verboseFilter: { 'DATA': 3, 'DEBUG': 3, 'INFO': 2, 'WARNING': 2, 'TEXT': 1, 'ERROR': 0 },
    time: null,
    verboseLevel: 0, // Only write errors
    setTime: function setTime(newTime) {
        this.time = newTime;
    },
    log: function log(severity, msg) {
        var minLevel = this.verboseFilter[severity];
        if (this.verboseLevel >= minLevel) {
            console.log(this.time + ' [' + severity + '] ' + msg);
        }
    }
};

var numArrayToHexArray = function numArrayToHexArray(numArray) {
    var hexArray = [];
    for (var j = 0; j < numArray.length; j++) {
        hexArray.push(numArray[j].toString(16));
    }
    return hexArray;
};

var PenState = function () {
    function PenState(foreground, underline, italics, background, flash) {
        _classCallCheck(this, PenState);

        this.foreground = foreground || 'white';
        this.underline = underline || false;
        this.italics = italics || false;
        this.background = background || 'black';
        this.flash = flash || false;
    }

    _createClass(PenState, [{
        key: 'reset',
        value: function reset() {
            this.foreground = 'white';
            this.underline = false;
            this.italics = false;
            this.background = 'black';
            this.flash = false;
        }
    }, {
        key: 'setStyles',
        value: function setStyles(styles) {
            var attribs = ['foreground', 'underline', 'italics', 'background', 'flash'];
            for (var i = 0; i < attribs.length; i++) {
                var style = attribs[i];
                if (styles.hasOwnProperty(style)) {
                    this[style] = styles[style];
                }
            }
        }
    }, {
        key: 'isDefault',
        value: function isDefault() {
            return this.foreground === 'white' && !this.underline && !this.italics && this.background === 'black' && !this.flash;
        }
    }, {
        key: 'equals',
        value: function equals(other) {
            return this.foreground === other.foreground && this.underline === other.underline && this.italics === other.italics && this.background === other.background && this.flash === other.flash;
        }
    }, {
        key: 'copy',
        value: function copy(newPenState) {
            this.foreground = newPenState.foreground;
            this.underline = newPenState.underline;
            this.italics = newPenState.italics;
            this.background = newPenState.background;
            this.flash = newPenState.flash;
        }
    }, {
        key: 'toString',
        value: function toString() {
            return 'color=' + this.foreground + ', underline=' + this.underline + ', italics=' + this.italics + ', background=' + this.background + ', flash=' + this.flash;
        }
    }]);

    return PenState;
}();

/**
 * Unicode character with styling and background.
 * @constructor
 */


var StyledUnicodeChar = function () {
    function StyledUnicodeChar(uchar, foreground, underline, italics, background, flash) {
        _classCallCheck(this, StyledUnicodeChar);

        this.uchar = uchar || ' '; // unicode character
        this.penState = new PenState(foreground, underline, italics, background, flash);
    }

    _createClass(StyledUnicodeChar, [{
        key: 'reset',
        value: function reset() {
            this.uchar = ' ';
            this.penState.reset();
        }
    }, {
        key: 'setChar',
        value: function setChar(uchar, newPenState) {
            this.uchar = uchar;
            this.penState.copy(newPenState);
        }
    }, {
        key: 'setPenState',
        value: function setPenState(newPenState) {
            this.penState.copy(newPenState);
        }
    }, {
        key: 'equals',
        value: function equals(other) {
            return this.uchar === other.uchar && this.penState.equals(other.penState);
        }
    }, {
        key: 'copy',
        value: function copy(newChar) {
            this.uchar = newChar.uchar;
            this.penState.copy(newChar.penState);
        }
    }, {
        key: 'isEmpty',
        value: function isEmpty() {
            return this.uchar === ' ' && this.penState.isDefault();
        }
    }]);

    return StyledUnicodeChar;
}();

/**
 * CEA-608 row consisting of NR_COLS instances of StyledUnicodeChar.
 * @constructor
 */


var Row = function () {
    function Row() {
        _classCallCheck(this, Row);

        this.chars = [];
        for (var i = 0; i < NR_COLS; i++) {
            this.chars.push(new StyledUnicodeChar());
        }
        this.pos = 0;
        this.currPenState = new PenState();
    }

    _createClass(Row, [{
        key: 'equals',
        value: function equals(other) {
            var equal = true;
            for (var i = 0; i < NR_COLS; i++) {
                if (!this.chars[i].equals(other.chars[i])) {
                    equal = false;
                    break;
                }
            }
            return equal;
        }
    }, {
        key: 'copy',
        value: function copy(other) {
            for (var i = 0; i < NR_COLS; i++) {
                this.chars[i].copy(other.chars[i]);
            }
        }
    }, {
        key: 'isEmpty',
        value: function isEmpty() {
            var empty = true;
            for (var i = 0; i < NR_COLS; i++) {
                if (!this.chars[i].isEmpty()) {
                    empty = false;
                    break;
                }
            }
            return empty;
        }

        /**
         *  Set the cursor to a valid column.
         */

    }, {
        key: 'setCursor',
        value: function setCursor(absPos) {
            if (this.pos !== absPos) {
                this.pos = absPos;
            }
            if (this.pos < 0) {
                logger.log('ERROR', 'Negative cursor position ' + this.pos);
                this.pos = 0;
            } else if (this.pos > NR_COLS) {
                logger.log('ERROR', 'Too large cursor position ' + this.pos);
                this.pos = NR_COLS;
            }
        }

        /**
         * Move the cursor relative to current position.
         */

    }, {
        key: 'moveCursor',
        value: function moveCursor(relPos) {
            var newPos = this.pos + relPos;
            if (relPos > 1) {
                for (var i = this.pos + 1; i < newPos + 1; i++) {
                    this.chars[i].setPenState(this.currPenState);
                }
            }
            this.setCursor(newPos);
        }

        /**
         * Backspace, move one step back and clear character.
         */

    }, {
        key: 'backSpace',
        value: function backSpace() {
            this.moveCursor(-1);
            this.chars[this.pos].setChar(' ', this.currPenState);
        }
    }, {
        key: 'insertChar',
        value: function insertChar(byte) {
            if (byte >= 0x90) {
                //Extended char
                this.backSpace();
            }
            var char = getCharForByte(byte);
            if (this.pos >= NR_COLS) {
                logger.log('ERROR', 'Cannot insert ' + byte.toString(16) + ' (' + char + ') at position ' + this.pos + '. Skipping it!');
                return;
            }
            this.chars[this.pos].setChar(char, this.currPenState);
            this.moveCursor(1);
        }
    }, {
        key: 'clearFromPos',
        value: function clearFromPos(startPos) {
            var i;
            for (i = startPos; i < NR_COLS; i++) {
                this.chars[i].reset();
            }
        }
    }, {
        key: 'clear',
        value: function clear() {
            this.clearFromPos(0);
            this.pos = 0;
            this.currPenState.reset();
        }
    }, {
        key: 'clearToEndOfRow',
        value: function clearToEndOfRow() {
            this.clearFromPos(this.pos);
        }
    }, {
        key: 'getTextString',
        value: function getTextString() {
            var chars = [];
            var empty = true;
            for (var i = 0; i < NR_COLS; i++) {
                var char = this.chars[i].uchar;
                if (char !== ' ') {
                    empty = false;
                }
                chars.push(char);
            }
            if (empty) {
                return '';
            } else {
                return chars.join('');
            }
        }
    }, {
        key: 'setPenStyles',
        value: function setPenStyles(styles) {
            this.currPenState.setStyles(styles);
            var currChar = this.chars[this.pos];
            currChar.setPenState(this.currPenState);
        }
    }]);

    return Row;
}();

/**
 * Keep a CEA-608 screen of 32x15 styled characters
 * @constructor
*/


var CaptionScreen = function () {
    function CaptionScreen() {
        _classCallCheck(this, CaptionScreen);

        this.rows = [];
        for (var i = 0; i < NR_ROWS; i++) {
            this.rows.push(new Row()); // Note that we use zero-based numbering (0-14)
        }
        this.currRow = NR_ROWS - 1;
        this.nrRollUpRows = null;
        this.reset();
    }

    _createClass(CaptionScreen, [{
        key: 'reset',
        value: function reset() {
            for (var i = 0; i < NR_ROWS; i++) {
                this.rows[i].clear();
            }
            this.currRow = NR_ROWS - 1;
        }
    }, {
        key: 'equals',
        value: function equals(other) {
            var equal = true;
            for (var i = 0; i < NR_ROWS; i++) {
                if (!this.rows[i].equals(other.rows[i])) {
                    equal = false;
                    break;
                }
            }
            return equal;
        }
    }, {
        key: 'copy',
        value: function copy(other) {
            for (var i = 0; i < NR_ROWS; i++) {
                this.rows[i].copy(other.rows[i]);
            }
        }
    }, {
        key: 'isEmpty',
        value: function isEmpty() {
            var empty = true;
            for (var i = 0; i < NR_ROWS; i++) {
                if (!this.rows[i].isEmpty()) {
                    empty = false;
                    break;
                }
            }
            return empty;
        }
    }, {
        key: 'backSpace',
        value: function backSpace() {
            var row = this.rows[this.currRow];
            row.backSpace();
        }
    }, {
        key: 'clearToEndOfRow',
        value: function clearToEndOfRow() {
            var row = this.rows[this.currRow];
            row.clearToEndOfRow();
        }

        /**
         * Insert a character (without styling) in the current row.
         */

    }, {
        key: 'insertChar',
        value: function insertChar(char) {
            var row = this.rows[this.currRow];
            row.insertChar(char);
        }
    }, {
        key: 'setPen',
        value: function setPen(styles) {
            var row = this.rows[this.currRow];
            row.setPenStyles(styles);
        }
    }, {
        key: 'moveCursor',
        value: function moveCursor(relPos) {
            var row = this.rows[this.currRow];
            row.moveCursor(relPos);
        }
    }, {
        key: 'setCursor',
        value: function setCursor(absPos) {
            logger.log('INFO', 'setCursor: ' + absPos);
            var row = this.rows[this.currRow];
            row.setCursor(absPos);
        }
    }, {
        key: 'setPAC',
        value: function setPAC(pacData) {
            logger.log('INFO', 'pacData = ' + JSON.stringify(pacData));
            var newRow = pacData.row - 1;
            if (this.nrRollUpRows && newRow < this.nrRollUpRows - 1) {
                newRow = this.nrRollUpRows - 1;
            }

            //Make sure this only affects Roll-up Captions by checking this.nrRollUpRows
            if (this.nrRollUpRows && this.currRow !== newRow) {
                //clear all rows first
                for (var i = 0; i < NR_ROWS; i++) {
                    this.rows[i].clear();
                }

                //Copy this.nrRollUpRows rows from lastOutputScreen and place it in the newRow location
                //topRowIndex - the start of rows to copy (inclusive index)
                var topRowIndex = this.currRow + 1 - this.nrRollUpRows;
                //We only copy if the last position was already shown.
                //We use the cueStartTime value to check this.
                var lastOutputScreen = this.lastOutputScreen;
                if (lastOutputScreen) {
                    var prevLineTime = lastOutputScreen.rows[topRowIndex].cueStartTime;
                    if (prevLineTime && prevLineTime < logger.time) {
                        for (var _i = 0; _i < this.nrRollUpRows; _i++) {
                            this.rows[newRow - this.nrRollUpRows + _i + 1].copy(lastOutputScreen.rows[topRowIndex + _i]);
                        }
                    }
                }
            }

            this.currRow = newRow;
            var row = this.rows[this.currRow];
            if (pacData.indent !== null) {
                var indent = pacData.indent;
                var prevPos = Math.max(indent - 1, 0);
                row.setCursor(pacData.indent);
                pacData.color = row.chars[prevPos].penState.foreground;
            }
            var styles = { foreground: pacData.color, underline: pacData.underline, italics: pacData.italics, background: 'black', flash: false };
            this.setPen(styles);
        }

        /**
         * Set background/extra foreground, but first do back_space, and then insert space (backwards compatibility).
         */

    }, {
        key: 'setBkgData',
        value: function setBkgData(bkgData) {

            logger.log('INFO', 'bkgData = ' + JSON.stringify(bkgData));
            this.backSpace();
            this.setPen(bkgData);
            this.insertChar(0x20); //Space
        }
    }, {
        key: 'setRollUpRows',
        value: function setRollUpRows(nrRows) {
            this.nrRollUpRows = nrRows;
        }
    }, {
        key: 'rollUp',
        value: function rollUp() {
            if (this.nrRollUpRows === null) {
                logger.log('DEBUG', 'roll_up but nrRollUpRows not set yet');
                return; //Not properly setup
            }
            logger.log('TEXT', this.getDisplayText());
            var topRowIndex = this.currRow + 1 - this.nrRollUpRows;
            var topRow = this.rows.splice(topRowIndex, 1)[0];
            topRow.clear();
            this.rows.splice(this.currRow, 0, topRow);
            logger.log('INFO', 'Rolling up');
            //logger.log('TEXT', this.get_display_text())
        }

        /**
         * Get all non-empty rows with as unicode text.
         */

    }, {
        key: 'getDisplayText',
        value: function getDisplayText(asOneRow) {
            asOneRow = asOneRow || false;
            var displayText = [];
            var text = '';
            var rowNr = -1;
            for (var i = 0; i < NR_ROWS; i++) {
                var rowText = this.rows[i].getTextString();
                if (rowText) {
                    rowNr = i + 1;
                    if (asOneRow) {
                        displayText.push('Row ' + rowNr + ': \'' + rowText + '\'');
                    } else {
                        displayText.push(rowText.trim());
                    }
                }
            }
            if (displayText.length > 0) {
                if (asOneRow) {
                    text = '[' + displayText.join(' | ') + ']';
                } else {
                    text = displayText.join('\n');
                }
            }
            return text;
        }
    }, {
        key: 'getTextAndFormat',
        value: function getTextAndFormat() {
            return this.rows;
        }
    }]);

    return CaptionScreen;
}();

//var modes = ['MODE_ROLL-UP', 'MODE_POP-ON', 'MODE_PAINT-ON', 'MODE_TEXT'];

var Cea608Channel = function () {
    function Cea608Channel(channelNumber, outputFilter) {
        _classCallCheck(this, Cea608Channel);

        this.chNr = channelNumber;
        this.outputFilter = outputFilter;
        this.mode = null;
        this.verbose = 0;
        this.displayedMemory = new CaptionScreen();
        this.nonDisplayedMemory = new CaptionScreen();
        this.lastOutputScreen = new CaptionScreen();
        this.currRollUpRow = this.displayedMemory.rows[NR_ROWS - 1];
        this.writeScreen = this.displayedMemory;
        this.mode = null;
        this.cueStartTime = null; // Keeps track of where a cue started.
    }

    _createClass(Cea608Channel, [{
        key: 'reset',
        value: function reset() {
            this.mode = null;
            this.displayedMemory.reset();
            this.nonDisplayedMemory.reset();
            this.lastOutputScreen.reset();
            this.currRollUpRow = this.displayedMemory.rows[NR_ROWS - 1];
            this.writeScreen = this.displayedMemory;
            this.mode = null;
            this.cueStartTime = null;
            this.lastCueEndTime = null;
        }
    }, {
        key: 'getHandler',
        value: function getHandler() {
            return this.outputFilter;
        }
    }, {
        key: 'setHandler',
        value: function setHandler(newHandler) {
            this.outputFilter = newHandler;
        }
    }, {
        key: 'setPAC',
        value: function setPAC(pacData) {
            this.writeScreen.setPAC(pacData);
        }
    }, {
        key: 'setBkgData',
        value: function setBkgData(bkgData) {
            this.writeScreen.setBkgData(bkgData);
        }
    }, {
        key: 'setMode',
        value: function setMode(newMode) {
            if (newMode === this.mode) {
                return;
            }
            this.mode = newMode;
            logger.log('INFO', 'MODE=' + newMode);
            if (this.mode === 'MODE_POP-ON') {
                this.writeScreen = this.nonDisplayedMemory;
            } else {
                this.writeScreen = this.displayedMemory;
                this.writeScreen.reset();
            }
            if (this.mode !== 'MODE_ROLL-UP') {
                this.displayedMemory.nrRollUpRows = null;
                this.nonDisplayedMemory.nrRollUpRows = null;
            }
            this.mode = newMode;
        }
    }, {
        key: 'insertChars',
        value: function insertChars(chars) {
            for (var i = 0; i < chars.length; i++) {
                this.writeScreen.insertChar(chars[i]);
            }
            var screen = this.writeScreen === this.displayedMemory ? 'DISP' : 'NON_DISP';
            logger.log('INFO', screen + ': ' + this.writeScreen.getDisplayText(true));
            if (this.mode === 'MODE_PAINT-ON' || this.mode === 'MODE_ROLL-UP') {
                logger.log('TEXT', 'DISPLAYED: ' + this.displayedMemory.getDisplayText(true));
                this.outputDataUpdate();
            }
        }
    }, {
        key: 'ccRCL',
        value: function ccRCL() {
            // Resume Caption Loading (switch mode to Pop On)
            logger.log('INFO', 'RCL - Resume Caption Loading');
            this.setMode('MODE_POP-ON');
        }
    }, {
        key: 'ccBS',
        value: function ccBS() {
            // BackSpace
            logger.log('INFO', 'BS - BackSpace');
            if (this.mode === 'MODE_TEXT') {
                return;
            }
            this.writeScreen.backSpace();
            if (this.writeScreen === this.displayedMemory) {
                this.outputDataUpdate();
            }
        }
    }, {
        key: 'ccAOF',
        value: function ccAOF() {
            // Reserved (formerly Alarm Off)
            return;
        }
    }, {
        key: 'ccAON',
        value: function ccAON() {
            // Reserved (formerly Alarm On)
            return;
        }
    }, {
        key: 'ccDER',
        value: function ccDER() {
            // Delete to End of Row
            logger.log('INFO', 'DER- Delete to End of Row');
            this.writeScreen.clearToEndOfRow();
            this.outputDataUpdate();
        }
    }, {
        key: 'ccRU',
        value: function ccRU(nrRows) {
            //Roll-Up Captions-2,3,or 4 Rows
            logger.log('INFO', 'RU(' + nrRows + ') - Roll Up');
            this.writeScreen = this.displayedMemory;
            this.setMode('MODE_ROLL-UP');
            this.writeScreen.setRollUpRows(nrRows);
        }
    }, {
        key: 'ccFON',
        value: function ccFON() {
            //Flash On
            logger.log('INFO', 'FON - Flash On');
            this.writeScreen.setPen({ flash: true });
        }
    }, {
        key: 'ccRDC',
        value: function ccRDC() {
            // Resume Direct Captioning (switch mode to PaintOn)
            logger.log('INFO', 'RDC - Resume Direct Captioning');
            this.setMode('MODE_PAINT-ON');
        }
    }, {
        key: 'ccTR',
        value: function ccTR() {
            // Text Restart in text mode (not supported, however)
            logger.log('INFO', 'TR');
            this.setMode('MODE_TEXT');
        }
    }, {
        key: 'ccRTD',
        value: function ccRTD() {
            // Resume Text Display in Text mode (not supported, however)
            logger.log('INFO', 'RTD');
            this.setMode('MODE_TEXT');
        }
    }, {
        key: 'ccEDM',
        value: function ccEDM() {
            // Erase Displayed Memory
            logger.log('INFO', 'EDM - Erase Displayed Memory');
            this.displayedMemory.reset();
            this.outputDataUpdate();
        }
    }, {
        key: 'ccCR',
        value: function ccCR() {
            // Carriage Return
            logger.log('CR - Carriage Return');
            this.writeScreen.rollUp();
            this.outputDataUpdate();
        }
    }, {
        key: 'ccENM',
        value: function ccENM() {
            //Erase Non-Displayed Memory
            logger.log('INFO', 'ENM - Erase Non-displayed Memory');
            this.nonDisplayedMemory.reset();
        }
    }, {
        key: 'ccEOC',
        value: function ccEOC() {
            //End of Caption (Flip Memories)
            logger.log('INFO', 'EOC - End Of Caption');
            if (this.mode === 'MODE_POP-ON') {
                var tmp = this.displayedMemory;
                this.displayedMemory = this.nonDisplayedMemory;
                this.nonDisplayedMemory = tmp;
                this.writeScreen = this.nonDisplayedMemory;
                logger.log('TEXT', 'DISP: ' + this.displayedMemory.getDisplayText());
            }
            this.outputDataUpdate();
        }
    }, {
        key: 'ccTO',
        value: function ccTO(nrCols) {
            // Tab Offset 1,2, or 3 columns
            logger.log('INFO', 'TO(' + nrCols + ') - Tab Offset');
            this.writeScreen.moveCursor(nrCols);
        }
    }, {
        key: 'ccMIDROW',
        value: function ccMIDROW(secondByte) {
            // Parse MIDROW command
            var styles = { flash: false };
            styles.underline = secondByte % 2 === 1;
            styles.italics = secondByte >= 0x2e;
            if (!styles.italics) {
                var colorIndex = Math.floor(secondByte / 2) - 0x10;
                var colors = ['white', 'green', 'blue', 'cyan', 'red', 'yellow', 'magenta'];
                styles.foreground = colors[colorIndex];
            } else {
                styles.foreground = 'white';
            }
            logger.log('INFO', 'MIDROW: ' + JSON.stringify(styles));
            this.writeScreen.setPen(styles);
        }
    }, {
        key: 'outputDataUpdate',
        value: function outputDataUpdate() {
            var t = logger.time;
            if (t === null) {
                return;
            }
            if (this.outputFilter) {
                if (this.outputFilter.updateData) {
                    this.outputFilter.updateData(t, this.displayedMemory);
                }
                if (this.cueStartTime === null && !this.displayedMemory.isEmpty()) {
                    // Start of a new cue
                    this.cueStartTime = t;
                } else {
                    if (!this.displayedMemory.equals(this.lastOutputScreen)) {
                        if (this.outputFilter.newCue) {
                            this.outputFilter.newCue(this.cueStartTime, t, this.lastOutputScreen);
                        }
                        this.cueStartTime = this.displayedMemory.isEmpty() ? null : t;
                    }
                }
                this.lastOutputScreen.copy(this.displayedMemory);
            }
        }
    }, {
        key: 'cueSplitAtTime',
        value: function cueSplitAtTime(t) {
            if (this.outputFilter) {
                if (!this.displayedMemory.isEmpty()) {
                    if (this.outputFilter.newCue) {
                        this.outputFilter.newCue(this.cueStartTime, t, this.displayedMemory);
                    }
                    this.cueStartTime = t;
                }
            }
        }
    }]);

    return Cea608Channel;
}();

var Cea608Parser = function () {
    function Cea608Parser(field, out1, out2) {
        _classCallCheck(this, Cea608Parser);

        this.field = field || 1;
        this.outputs = [out1, out2];
        this.channels = [new Cea608Channel(1, out1), new Cea608Channel(2, out2)];
        this.currChNr = -1; // Will be 1 or 2
        this.lastCmdA = null; // First byte of last command
        this.lastCmdB = null; // Second byte of last command
        this.bufferedData = [];
        this.startTime = null;
        this.lastTime = null;
        this.dataCounters = { 'padding': 0, 'char': 0, 'cmd': 0, 'other': 0 };
    }

    _createClass(Cea608Parser, [{
        key: 'getHandler',
        value: function getHandler(index) {
            return this.channels[index].getHandler();
        }
    }, {
        key: 'setHandler',
        value: function setHandler(index, newHandler) {
            this.channels[index].setHandler(newHandler);
        }

        /**
         * Add data for time t in forms of list of bytes (unsigned ints). The bytes are treated as pairs.
         */

    }, {
        key: 'addData',
        value: function addData(t, byteList) {
            var cmdFound,
                a,
                b,
                charsFound = false;

            this.lastTime = t;
            logger.setTime(t);

            for (var i = 0; i < byteList.length; i += 2) {
                a = byteList[i] & 0x7f;
                b = byteList[i + 1] & 0x7f;
                if (a === 0 && b === 0) {
                    this.dataCounters.padding += 2;
                    continue;
                } else {
                    logger.log('DATA', '[' + numArrayToHexArray([byteList[i], byteList[i + 1]]) + '] -> (' + numArrayToHexArray([a, b]) + ')');
                }
                cmdFound = this.parseCmd(a, b);
                if (!cmdFound) {
                    cmdFound = this.parseMidrow(a, b);
                }
                if (!cmdFound) {
                    cmdFound = this.parsePAC(a, b);
                }
                if (!cmdFound) {
                    cmdFound = this.parseBackgroundAttributes(a, b);
                }
                if (!cmdFound) {
                    charsFound = this.parseChars(a, b);
                    if (charsFound) {
                        if (this.currChNr && this.currChNr >= 0) {
                            var channel = this.channels[this.currChNr - 1];
                            channel.insertChars(charsFound);
                        } else {
                            logger.log('WARNING', 'No channel found yet. TEXT-MODE?');
                        }
                    }
                }
                if (cmdFound) {
                    this.dataCounters.cmd += 2;
                } else if (charsFound) {
                    this.dataCounters.char += 2;
                } else {
                    this.dataCounters.other += 2;
                    logger.log('WARNING', 'Couldn\'t parse cleaned data ' + numArrayToHexArray([a, b]) + ' orig: ' + numArrayToHexArray([byteList[i], byteList[i + 1]]));
                }
            }
        }

        /**
         * Parse Command.
         * @returns {Boolean} Tells if a command was found
         */

    }, {
        key: 'parseCmd',
        value: function parseCmd(a, b) {
            var chNr = null;

            var cond1 = (a === 0x14 || a === 0x1C) && 0x20 <= b && b <= 0x2F;
            var cond2 = (a === 0x17 || a === 0x1F) && 0x21 <= b && b <= 0x23;
            if (!(cond1 || cond2)) {
                return false;
            }

            if (a === this.lastCmdA && b === this.lastCmdB) {
                this.lastCmdA = null;
                this.lastCmdB = null; // Repeated commands are dropped (once)
                logger.log('DEBUG', 'Repeated command (' + numArrayToHexArray([a, b]) + ') is dropped');
                return true;
            }

            if (a === 0x14 || a === 0x17) {
                chNr = 1;
            } else {
                chNr = 2; // (a === 0x1C || a=== 0x1f)
            }

            var channel = this.channels[chNr - 1];

            if (a === 0x14 || a === 0x1C) {
                if (b === 0x20) {
                    channel.ccRCL();
                } else if (b === 0x21) {
                    channel.ccBS();
                } else if (b === 0x22) {
                    channel.ccAOF();
                } else if (b === 0x23) {
                    channel.ccAON();
                } else if (b === 0x24) {
                    channel.ccDER();
                } else if (b === 0x25) {
                    channel.ccRU(2);
                } else if (b === 0x26) {
                    channel.ccRU(3);
                } else if (b === 0x27) {
                    channel.ccRU(4);
                } else if (b === 0x28) {
                    channel.ccFON();
                } else if (b === 0x29) {
                    channel.ccRDC();
                } else if (b === 0x2A) {
                    channel.ccTR();
                } else if (b === 0x2B) {
                    channel.ccRTD();
                } else if (b === 0x2C) {
                    channel.ccEDM();
                } else if (b === 0x2D) {
                    channel.ccCR();
                } else if (b === 0x2E) {
                    channel.ccENM();
                } else if (b === 0x2F) {
                    channel.ccEOC();
                }
            } else {
                //a == 0x17 || a == 0x1F
                channel.ccTO(b - 0x20);
            }
            this.lastCmdA = a;
            this.lastCmdB = b;
            this.currChNr = chNr;
            return true;
        }

        /**
         * Parse midrow styling command
         * @returns {Boolean}
         */

    }, {
        key: 'parseMidrow',
        value: function parseMidrow(a, b) {
            var chNr = null;

            if ((a === 0x11 || a === 0x19) && 0x20 <= b && b <= 0x2f) {
                if (a === 0x11) {
                    chNr = 1;
                } else {
                    chNr = 2;
                }
                if (chNr !== this.currChNr) {
                    logger.log('ERROR', 'Mismatch channel in midrow parsing');
                    return false;
                }
                var channel = this.channels[chNr - 1];
                channel.ccMIDROW(b);
                logger.log('DEBUG', 'MIDROW (' + numArrayToHexArray([a, b]) + ')');
                return true;
            }
            return false;
        }
        /**
         * Parse Preable Access Codes (Table 53).
         * @returns {Boolean} Tells if PAC found
         */

    }, {
        key: 'parsePAC',
        value: function parsePAC(a, b) {

            var chNr = null;
            var row = null;

            var case1 = (0x11 <= a && a <= 0x17 || 0x19 <= a && a <= 0x1F) && 0x40 <= b && b <= 0x7F;
            var case2 = (a === 0x10 || a === 0x18) && 0x40 <= b && b <= 0x5F;
            if (!(case1 || case2)) {
                return false;
            }

            if (a === this.lastCmdA && b === this.lastCmdB) {
                this.lastCmdA = null;
                this.lastCmdB = null;
                return true; // Repeated commands are dropped (once)
            }

            chNr = a <= 0x17 ? 1 : 2;

            if (0x40 <= b && b <= 0x5F) {
                row = chNr === 1 ? rowsLowCh1[a] : rowsLowCh2[a];
            } else {
                // 0x60 <= b <= 0x7F
                row = chNr === 1 ? rowsHighCh1[a] : rowsHighCh2[a];
            }
            var pacData = this.interpretPAC(row, b);
            var channel = this.channels[chNr - 1];
            channel.setPAC(pacData);
            this.lastCmdA = a;
            this.lastCmdB = b;
            this.currChNr = chNr;
            return true;
        }

        /**
         * Interpret the second byte of the pac, and return the information.
         * @returns {Object} pacData with style parameters.
         */

    }, {
        key: 'interpretPAC',
        value: function interpretPAC(row, byte) {
            var pacIndex = byte;
            var pacData = { color: null, italics: false, indent: null, underline: false, row: row };

            if (byte > 0x5F) {
                pacIndex = byte - 0x60;
            } else {
                pacIndex = byte - 0x40;
            }
            pacData.underline = (pacIndex & 1) === 1;
            if (pacIndex <= 0xd) {
                pacData.color = ['white', 'green', 'blue', 'cyan', 'red', 'yellow', 'magenta', 'white'][Math.floor(pacIndex / 2)];
            } else if (pacIndex <= 0xf) {
                pacData.italics = true;
                pacData.color = 'white';
            } else {
                pacData.indent = Math.floor((pacIndex - 0x10) / 2) * 4;
            }
            return pacData; // Note that row has zero offset. The spec uses 1.
        }

        /**
         * Parse characters.
         * @returns An array with 1 to 2 codes corresponding to chars, if found. null otherwise.
         */

    }, {
        key: 'parseChars',
        value: function parseChars(a, b) {

            var channelNr = null,
                charCodes = null,
                charCode1 = null;

            if (a >= 0x19) {
                channelNr = 2;
                charCode1 = a - 8;
            } else {
                channelNr = 1;
                charCode1 = a;
            }
            if (0x11 <= charCode1 && charCode1 <= 0x13) {
                // Special character
                var oneCode = b;
                if (charCode1 === 0x11) {
                    oneCode = b + 0x50;
                } else if (charCode1 === 0x12) {
                    oneCode = b + 0x70;
                } else {
                    oneCode = b + 0x90;
                }
                logger.log('INFO', 'Special char \'' + getCharForByte(oneCode) + '\' in channel ' + channelNr);
                charCodes = [oneCode];
            } else if (0x20 <= a && a <= 0x7f) {
                charCodes = b === 0 ? [a] : [a, b];
            }
            if (charCodes) {
                var hexCodes = numArrayToHexArray(charCodes);
                logger.log('DEBUG', 'Char codes =  ' + hexCodes.join(','));
                this.lastCmdA = null;
                this.lastCmdB = null;
            }
            return charCodes;
        }

        /**
        * Parse extended background attributes as well as new foreground color black.
        * @returns{Boolean} Tells if background attributes are found
        */

    }, {
        key: 'parseBackgroundAttributes',
        value: function parseBackgroundAttributes(a, b) {
            var bkgData, index, chNr, channel;

            var case1 = (a === 0x10 || a === 0x18) && 0x20 <= b && b <= 0x2f;
            var case2 = (a === 0x17 || a === 0x1f) && 0x2d <= b && b <= 0x2f;
            if (!(case1 || case2)) {
                return false;
            }
            bkgData = {};
            if (a === 0x10 || a === 0x18) {
                index = Math.floor((b - 0x20) / 2);
                bkgData.background = backgroundColors[index];
                if (b % 2 === 1) {
                    bkgData.background = bkgData.background + '_semi';
                }
            } else if (b === 0x2d) {
                bkgData.background = 'transparent';
            } else {
                bkgData.foreground = 'black';
                if (b === 0x2f) {
                    bkgData.underline = true;
                }
            }
            chNr = a < 0x18 ? 1 : 2;
            channel = this.channels[chNr - 1];
            channel.setBkgData(bkgData);
            this.lastCmdA = null;
            this.lastCmdB = null;
            return true;
        }

        /**
         * Reset state of parser and its channels.
         */

    }, {
        key: 'reset',
        value: function reset() {
            for (var i = 0; i < this.channels.length; i++) {
                if (this.channels[i]) {
                    this.channels[i].reset();
                }
            }
            this.lastCmdA = null;
            this.lastCmdB = null;
        }

        /**
         * Trigger the generation of a cue, and the start of a new one if displayScreens are not empty.
         */

    }, {
        key: 'cueSplitAtTime',
        value: function cueSplitAtTime(t) {
            for (var i = 0; i < this.channels.length; i++) {
                if (this.channels[i]) {
                    this.channels[i].cueSplitAtTime(t);
                }
            }
        }
    }]);

    return Cea608Parser;
}();

exports.default = Cea608Parser;

},{}],50:[function(require,module,exports){
'use strict';

var _vttparser = require('./vttparser');

var Cues = {

  newCue: function newCue(track, startTime, endTime, captionScreen) {
    var row;
    var cue;
    var indenting;
    var indent;
    var text;
    var VTTCue = window.VTTCue || window.TextTrackCue;

    for (var r = 0; r < captionScreen.rows.length; r++) {
      row = captionScreen.rows[r];
      indenting = true;
      indent = 0;
      text = '';

      if (!row.isEmpty()) {
        for (var c = 0; c < row.chars.length; c++) {
          if (row.chars[c].uchar.match(/\s/) && indenting) {
            indent++;
          } else {
            text += row.chars[c].uchar;
            indenting = false;
          }
        }
        //To be used for cleaning-up orphaned roll-up captions
        row.cueStartTime = startTime;

        // Give a slight bump to the endTime if it's equal to startTime to avoid a SyntaxError in IE
        if (startTime === endTime) {
          endTime += 0.0001;
        }

        cue = new VTTCue(startTime, endTime, (0, _vttparser.fixLineBreaks)(text.trim()));

        if (indent >= 16) {
          indent--;
        } else {
          indent++;
        }

        // VTTCue.line get's flakey when using controls, so let's now include line 13&14
        // also, drop line 1 since it's to close to the top
        if (navigator.userAgent.match(/Firefox\//)) {
          cue.line = r + 1;
        } else {
          cue.line = r > 7 ? r - 2 : r + 1;
        }
        cue.align = 'left';
        // Clamp the position between 0 and 100 - if out of these bounds, Firefox throws an exception and captions break
        cue.position = Math.max(0, Math.min(100, 100 * (indent / 32) + (navigator.userAgent.match(/Firefox\//) ? 50 : 0)));
        track.addCue(cue);
      }
    }
  }

};

module.exports = Cues;

},{"./vttparser":57}],51:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.findFragWithCC = findFragWithCC;

var _binarySearch = require('./binary-search');

var _binarySearch2 = _interopRequireDefault(_binarySearch);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function findFragWithCC(fragments, CC) {
   return _binarySearch2.default.search(fragments, function (candidate) {
      if (candidate.cc < CC) {
         return 1;
      } else if (candidate.cc > CC) {
         return -1;
      } else {
         return 0;
      }
   });
}

},{"./binary-search":48}],52:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * EWMA Bandwidth Estimator
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *  - heavily inspired from shaka-player
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Tracks bandwidth samples and estimates available bandwidth.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Based on the minimum of two exponentially-weighted moving averages with
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * different half-lives.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */

var _ewma = require('../utils/ewma');

var _ewma2 = _interopRequireDefault(_ewma);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var EwmaBandWidthEstimator = function () {
  function EwmaBandWidthEstimator(hls, slow, fast, defaultEstimate) {
    _classCallCheck(this, EwmaBandWidthEstimator);

    this.hls = hls;
    this.defaultEstimate_ = defaultEstimate;
    this.minWeight_ = 0.001;
    this.minDelayMs_ = 50;
    this.slow_ = new _ewma2.default(slow);
    this.fast_ = new _ewma2.default(fast);
  }

  _createClass(EwmaBandWidthEstimator, [{
    key: 'sample',
    value: function sample(durationMs, numBytes) {
      durationMs = Math.max(durationMs, this.minDelayMs_);
      var bandwidth = 8000 * numBytes / durationMs,

      //console.log('instant bw:'+ Math.round(bandwidth));
      // we weight sample using loading duration....
      weight = durationMs / 1000;
      this.fast_.sample(weight, bandwidth);
      this.slow_.sample(weight, bandwidth);
    }
  }, {
    key: 'canEstimate',
    value: function canEstimate() {
      var fast = this.fast_;
      return fast && fast.getTotalWeight() >= this.minWeight_;
    }
  }, {
    key: 'getEstimate',
    value: function getEstimate() {
      if (this.canEstimate()) {
        //console.log('slow estimate:'+ Math.round(this.slow_.getEstimate()));
        //console.log('fast estimate:'+ Math.round(this.fast_.getEstimate()));
        // Take the minimum of these two estimates.  This should have the effect of
        // adapting down quickly, but up more slowly.
        return Math.min(this.fast_.getEstimate(), this.slow_.getEstimate());
      } else {
        return this.defaultEstimate_;
      }
    }
  }, {
    key: 'destroy',
    value: function destroy() {}
  }]);

  return EwmaBandWidthEstimator;
}();

exports.default = EwmaBandWidthEstimator;

},{"../utils/ewma":53}],53:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/*
 * compute an Exponential Weighted moving average
 * - https://en.wikipedia.org/wiki/Moving_average#Exponential_moving_average
 *  - heavily inspired from shaka-player
 */

var EWMA = function () {

  //  About half of the estimated value will be from the last |halfLife| samples by weight.
  function EWMA(halfLife) {
    _classCallCheck(this, EWMA);

    // Larger values of alpha expire historical data more slowly.
    this.alpha_ = halfLife ? Math.exp(Math.log(0.5) / halfLife) : 0;
    this.estimate_ = 0;
    this.totalWeight_ = 0;
  }

  _createClass(EWMA, [{
    key: "sample",
    value: function sample(weight, value) {
      var adjAlpha = Math.pow(this.alpha_, weight);
      this.estimate_ = value * (1 - adjAlpha) + adjAlpha * this.estimate_;
      this.totalWeight_ += weight;
    }
  }, {
    key: "getTotalWeight",
    value: function getTotalWeight() {
      return this.totalWeight_;
    }
  }, {
    key: "getEstimate",
    value: function getEstimate() {
      if (this.alpha_) {
        var zeroFactor = 1 - Math.pow(this.alpha_, this.totalWeight_);
        return this.estimate_ / zeroFactor;
      } else {
        return this.estimate_;
      }
    }
  }]);

  return EWMA;
}();

exports.default = EWMA;

},{}],54:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function noop() {}

var fakeLogger = {
  trace: noop,
  debug: noop,
  log: noop,
  warn: noop,
  info: noop,
  error: noop
};

var exportedLogger = fakeLogger;

/*globals self: false */

//let lastCallTime;
// function formatMsgWithTimeInfo(type, msg) {
//   const now = Date.now();
//   const diff = lastCallTime ? '+' + (now - lastCallTime) : '0';
//   lastCallTime = now;
//   msg = (new Date(now)).toISOString() + ' | [' +  type + '] > ' + msg + ' ( ' + diff + ' ms )';
//   return msg;
// }

function formatMsg(type, msg) {
  msg = '[' + type + '] > ' + msg;
  return msg;
}

function consolePrintFn(type) {
  var func = self.console[type];
  if (func) {
    return function () {
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      if (args[0]) {
        args[0] = formatMsg(type, args[0]);
      }
      func.apply(self.console, args);
    };
  }
  return noop;
}

function exportLoggerFunctions(debugConfig) {
  for (var _len2 = arguments.length, functions = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    functions[_key2 - 1] = arguments[_key2];
  }

  functions.forEach(function (type) {
    exportedLogger[type] = debugConfig[type] ? debugConfig[type].bind(debugConfig) : consolePrintFn(type);
  });
}

var enableLogs = exports.enableLogs = function enableLogs(debugConfig) {
  if (debugConfig === true || (typeof debugConfig === 'undefined' ? 'undefined' : _typeof(debugConfig)) === 'object') {
    exportLoggerFunctions(debugConfig,
    // Remove out from list here to hard-disable a log-level
    //'trace',
    'debug', 'log', 'info', 'warn', 'error');
    // Some browsers don't allow to use bind on console object anyway
    // fallback to default if needed
    try {
      exportedLogger.log();
    } catch (e) {
      exportedLogger = fakeLogger;
    }
  } else {
    exportedLogger = fakeLogger;
  }
};

var logger = exports.logger = exportedLogger;

},{}],55:[function(require,module,exports){
'use strict';

/**
 *  TimeRanges to string helper
 */

var TimeRanges = {
  toString: function toString(r) {
    var log = '',
        len = r.length;
    for (var i = 0; i < len; i++) {
      log += '[' + r.start(i).toFixed(3) + ',' + r.end(i).toFixed(3) + ']';
    }
    return log;
  }
};

module.exports = TimeRanges;

},{}],56:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

/**
 * Copyright 2013 vtt.js Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

exports.default = function () {
  if (typeof window !== 'undefined' && window.VTTCue) {
    return window.VTTCue;
  }

  var autoKeyword = 'auto';
  var directionSetting = {
    '': true,
    lr: true,
    rl: true
  };
  var alignSetting = {
    start: true,
    middle: true,
    end: true,
    left: true,
    right: true
  };

  function findDirectionSetting(value) {
    if (typeof value !== 'string') {
      return false;
    }
    var dir = directionSetting[value.toLowerCase()];
    return dir ? value.toLowerCase() : false;
  }

  function findAlignSetting(value) {
    if (typeof value !== 'string') {
      return false;
    }
    var align = alignSetting[value.toLowerCase()];
    return align ? value.toLowerCase() : false;
  }

  function extend(obj) {
    var i = 1;
    for (; i < arguments.length; i++) {
      var cobj = arguments[i];
      for (var p in cobj) {
        obj[p] = cobj[p];
      }
    }

    return obj;
  }

  function VTTCue(startTime, endTime, text) {
    var cue = this;
    var isIE8 = function () {
      if (typeof navigator === 'undefined') {
        return;
      }
      return (/MSIE\s8\.0/.test(navigator.userAgent)
      );
    }();
    var baseObj = {};

    if (isIE8) {
      cue = document.createElement('custom');
    } else {
      baseObj.enumerable = true;
    }

    /**
     * Shim implementation specific properties. These properties are not in
     * the spec.
     */

    // Lets us know when the VTTCue's data has changed in such a way that we need
    // to recompute its display state. This lets us compute its display state
    // lazily.
    cue.hasBeenReset = false;

    /**
     * VTTCue and TextTrackCue properties
     * http://dev.w3.org/html5/webvtt/#vttcue-interface
     */

    var _id = '';
    var _pauseOnExit = false;
    var _startTime = startTime;
    var _endTime = endTime;
    var _text = text;
    var _region = null;
    var _vertical = '';
    var _snapToLines = true;
    var _line = 'auto';
    var _lineAlign = 'start';
    var _position = 50;
    var _positionAlign = 'middle';
    var _size = 50;
    var _align = 'middle';

    Object.defineProperty(cue, 'id', extend({}, baseObj, {
      get: function get() {
        return _id;
      },
      set: function set(value) {
        _id = '' + value;
      }
    }));

    Object.defineProperty(cue, 'pauseOnExit', extend({}, baseObj, {
      get: function get() {
        return _pauseOnExit;
      },
      set: function set(value) {
        _pauseOnExit = !!value;
      }
    }));

    Object.defineProperty(cue, 'startTime', extend({}, baseObj, {
      get: function get() {
        return _startTime;
      },
      set: function set(value) {
        if (typeof value !== 'number') {
          throw new TypeError('Start time must be set to a number.');
        }
        _startTime = value;
        this.hasBeenReset = true;
      }
    }));

    Object.defineProperty(cue, 'endTime', extend({}, baseObj, {
      get: function get() {
        return _endTime;
      },
      set: function set(value) {
        if (typeof value !== 'number') {
          throw new TypeError('End time must be set to a number.');
        }
        _endTime = value;
        this.hasBeenReset = true;
      }
    }));

    Object.defineProperty(cue, 'text', extend({}, baseObj, {
      get: function get() {
        return _text;
      },
      set: function set(value) {
        _text = '' + value;
        this.hasBeenReset = true;
      }
    }));

    Object.defineProperty(cue, 'region', extend({}, baseObj, {
      get: function get() {
        return _region;
      },
      set: function set(value) {
        _region = value;
        this.hasBeenReset = true;
      }
    }));

    Object.defineProperty(cue, 'vertical', extend({}, baseObj, {
      get: function get() {
        return _vertical;
      },
      set: function set(value) {
        var setting = findDirectionSetting(value);
        // Have to check for false because the setting an be an empty string.
        if (setting === false) {
          throw new SyntaxError('An invalid or illegal string was specified.');
        }
        _vertical = setting;
        this.hasBeenReset = true;
      }
    }));

    Object.defineProperty(cue, 'snapToLines', extend({}, baseObj, {
      get: function get() {
        return _snapToLines;
      },
      set: function set(value) {
        _snapToLines = !!value;
        this.hasBeenReset = true;
      }
    }));

    Object.defineProperty(cue, 'line', extend({}, baseObj, {
      get: function get() {
        return _line;
      },
      set: function set(value) {
        if (typeof value !== 'number' && value !== autoKeyword) {
          throw new SyntaxError('An invalid number or illegal string was specified.');
        }
        _line = value;
        this.hasBeenReset = true;
      }
    }));

    Object.defineProperty(cue, 'lineAlign', extend({}, baseObj, {
      get: function get() {
        return _lineAlign;
      },
      set: function set(value) {
        var setting = findAlignSetting(value);
        if (!setting) {
          throw new SyntaxError('An invalid or illegal string was specified.');
        }
        _lineAlign = setting;
        this.hasBeenReset = true;
      }
    }));

    Object.defineProperty(cue, 'position', extend({}, baseObj, {
      get: function get() {
        return _position;
      },
      set: function set(value) {
        if (value < 0 || value > 100) {
          throw new Error('Position must be between 0 and 100.');
        }
        _position = value;
        this.hasBeenReset = true;
      }
    }));

    Object.defineProperty(cue, 'positionAlign', extend({}, baseObj, {
      get: function get() {
        return _positionAlign;
      },
      set: function set(value) {
        var setting = findAlignSetting(value);
        if (!setting) {
          throw new SyntaxError('An invalid or illegal string was specified.');
        }
        _positionAlign = setting;
        this.hasBeenReset = true;
      }
    }));

    Object.defineProperty(cue, 'size', extend({}, baseObj, {
      get: function get() {
        return _size;
      },
      set: function set(value) {
        if (value < 0 || value > 100) {
          throw new Error('Size must be between 0 and 100.');
        }
        _size = value;
        this.hasBeenReset = true;
      }
    }));

    Object.defineProperty(cue, 'align', extend({}, baseObj, {
      get: function get() {
        return _align;
      },
      set: function set(value) {
        var setting = findAlignSetting(value);
        if (!setting) {
          throw new SyntaxError('An invalid or illegal string was specified.');
        }
        _align = setting;
        this.hasBeenReset = true;
      }
    }));

    /**
     * Other <track> spec defined properties
     */

    // http://www.whatwg.org/specs/web-apps/current-work/multipage/the-video-element.html#text-track-cue-display-state
    cue.displayState = undefined;

    if (isIE8) {
      return cue;
    }
  }

  /**
   * VTTCue methods
   */

  VTTCue.prototype.getCueAsHTML = function () {
    // Assume WebVTT.convertCueToDOMTree is on the global.
    var WebVTT = window.WebVTT;
    return WebVTT.convertCueToDOMTree(window, this.text);
  };

  return VTTCue;
}();

},{}],57:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fixLineBreaks = undefined;

var _vttcue = require('./vttcue');

var _vttcue2 = _interopRequireDefault(_vttcue);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var StringDecoder = function StringDecoder() {
  return {
    decode: function decode(data) {
      if (!data) {
        return '';
      }
      if (typeof data !== 'string') {
        throw new Error('Error - expected string data.');
      }
      return decodeURIComponent(encodeURIComponent(data));
    }
  };
}; /*
    * Source: https://github.com/mozilla/vtt.js/blob/master/dist/vtt.js#L1716
    */

function VTTParser() {
  this.window = window;
  this.state = 'INITIAL';
  this.buffer = '';
  this.decoder = new StringDecoder();
  this.regionList = [];
}

// Try to parse input as a time stamp.
function parseTimeStamp(input) {

  function computeSeconds(h, m, s, f) {
    return (h | 0) * 3600 + (m | 0) * 60 + (s | 0) + (f | 0) / 1000;
  }

  var m = input.match(/^(\d+):(\d{2})(:\d{2})?\.(\d{3})/);
  if (!m) {
    return null;
  }

  if (m[3]) {
    // Timestamp takes the form of [hours]:[minutes]:[seconds].[milliseconds]
    return computeSeconds(m[1], m[2], m[3].replace(':', ''), m[4]);
  } else if (m[1] > 59) {
    // Timestamp takes the form of [hours]:[minutes].[milliseconds]
    // First position is hours as it's over 59.
    return computeSeconds(m[1], m[2], 0, m[4]);
  } else {
    // Timestamp takes the form of [minutes]:[seconds].[milliseconds]
    return computeSeconds(0, m[1], m[2], m[4]);
  }
}

// A settings object holds key/value pairs and will ignore anything but the first
// assignment to a specific key.
function Settings() {
  this.values = Object.create(null);
}

Settings.prototype = {
  // Only accept the first assignment to any key.
  set: function set(k, v) {
    if (!this.get(k) && v !== '') {
      this.values[k] = v;
    }
  },
  // Return the value for a key, or a default value.
  // If 'defaultKey' is passed then 'dflt' is assumed to be an object with
  // a number of possible default values as properties where 'defaultKey' is
  // the key of the property that will be chosen; otherwise it's assumed to be
  // a single value.
  get: function get(k, dflt, defaultKey) {
    if (defaultKey) {
      return this.has(k) ? this.values[k] : dflt[defaultKey];
    }
    return this.has(k) ? this.values[k] : dflt;
  },
  // Check whether we have a value for a key.
  has: function has(k) {
    return k in this.values;
  },
  // Accept a setting if its one of the given alternatives.
  alt: function alt(k, v, a) {
    for (var n = 0; n < a.length; ++n) {
      if (v === a[n]) {
        this.set(k, v);
        break;
      }
    }
  },
  // Accept a setting if its a valid (signed) integer.
  integer: function integer(k, v) {
    if (/^-?\d+$/.test(v)) {
      // integer
      this.set(k, parseInt(v, 10));
    }
  },
  // Accept a setting if its a valid percentage.
  percent: function percent(k, v) {
    var m;
    if (m = v.match(/^([\d]{1,3})(\.[\d]*)?%$/)) {
      v = parseFloat(v);
      if (v >= 0 && v <= 100) {
        this.set(k, v);
        return true;
      }
    }
    return false;
  }
};

// Helper function to parse input into groups separated by 'groupDelim', and
// interprete each group as a key/value pair separated by 'keyValueDelim'.
function parseOptions(input, callback, keyValueDelim, groupDelim) {
  var groups = groupDelim ? input.split(groupDelim) : [input];
  for (var i in groups) {
    if (typeof groups[i] !== 'string') {
      continue;
    }
    var kv = groups[i].split(keyValueDelim);
    if (kv.length !== 2) {
      continue;
    }
    var k = kv[0];
    var v = kv[1];
    callback(k, v);
  }
}

var defaults = new _vttcue2.default(0, 0, 0);
// 'middle' was changed to 'center' in the spec: https://github.com/w3c/webvtt/pull/244
// Chrome and Safari don't yet support this change, but FF does
var center = defaults.align === 'middle' ? 'middle' : 'center';

function parseCue(input, cue, regionList) {
  // Remember the original input if we need to throw an error.
  var oInput = input;
  // 4.1 WebVTT timestamp
  function consumeTimeStamp() {
    var ts = parseTimeStamp(input);
    if (ts === null) {
      throw new Error('Malformed timestamp: ' + oInput);
    }
    // Remove time stamp from input.
    input = input.replace(/^[^\sa-zA-Z-]+/, '');
    return ts;
  }

  // 4.4.2 WebVTT cue settings
  function consumeCueSettings(input, cue) {
    var settings = new Settings();

    parseOptions(input, function (k, v) {
      switch (k) {
        case 'region':
          // Find the last region we parsed with the same region id.
          for (var i = regionList.length - 1; i >= 0; i--) {
            if (regionList[i].id === v) {
              settings.set(k, regionList[i].region);
              break;
            }
          }
          break;
        case 'vertical':
          settings.alt(k, v, ['rl', 'lr']);
          break;
        case 'line':
          var vals = v.split(','),
              vals0 = vals[0];
          settings.integer(k, vals0);
          if (settings.percent(k, vals0)) {
            settings.set('snapToLines', false);
          }
          settings.alt(k, vals0, ['auto']);
          if (vals.length === 2) {
            settings.alt('lineAlign', vals[1], ['start', center, 'end']);
          }
          break;
        case 'position':
          vals = v.split(',');
          settings.percent(k, vals[0]);
          if (vals.length === 2) {
            settings.alt('positionAlign', vals[1], ['start', center, 'end', 'line-left', 'line-right', 'auto']);
          }
          break;
        case 'size':
          settings.percent(k, v);
          break;
        case 'align':
          settings.alt(k, v, ['start', center, 'end', 'left', 'right']);
          break;
      }
    }, /:/, /\s/);

    // Apply default values for any missing fields.
    cue.region = settings.get('region', null);
    cue.vertical = settings.get('vertical', '');
    var line = settings.get('line', 'auto');
    if (line === 'auto' && defaults.line === -1) {
      // set numeric line number for Safari
      line = -1;
    }
    cue.line = line;
    cue.lineAlign = settings.get('lineAlign', 'start');
    cue.snapToLines = settings.get('snapToLines', true);
    cue.size = settings.get('size', 100);
    cue.align = settings.get('align', center);
    var position = settings.get('position', 'auto');
    if (position === 'auto' && defaults.position === 50) {
      // set numeric position for Safari
      position = cue.align === 'start' || cue.align === 'left' ? 0 : cue.align === 'end' || cue.align === 'right' ? 100 : 50;
    }
    cue.position = position;
  }

  function skipWhitespace() {
    input = input.replace(/^\s+/, '');
  }

  // 4.1 WebVTT cue timings.
  skipWhitespace();
  cue.startTime = consumeTimeStamp(); // (1) collect cue start time
  skipWhitespace();
  if (input.substr(0, 3) !== '-->') {
    // (3) next characters must match '-->'
    throw new Error('Malformed time stamp (time stamps must be separated by \'-->\'): ' + oInput);
  }
  input = input.substr(3);
  skipWhitespace();
  cue.endTime = consumeTimeStamp(); // (5) collect cue end time

  // 4.1 WebVTT cue settings list.
  skipWhitespace();
  consumeCueSettings(input, cue);
}

function fixLineBreaks(input) {
  return input.replace(/<br(?: \/)?>/gi, '\n');
}

VTTParser.prototype = {
  parse: function parse(data) {
    var self = this;

    // If there is no data then we won't decode it, but will just try to parse
    // whatever is in buffer already. This may occur in circumstances, for
    // example when flush() is called.
    if (data) {
      // Try to decode the data that we received.
      self.buffer += self.decoder.decode(data, { stream: true });
    }

    function collectNextLine() {
      var buffer = self.buffer;
      var pos = 0;

      buffer = fixLineBreaks(buffer);

      while (pos < buffer.length && buffer[pos] !== '\r' && buffer[pos] !== '\n') {
        ++pos;
      }
      var line = buffer.substr(0, pos);
      // Advance the buffer early in case we fail below.
      if (buffer[pos] === '\r') {
        ++pos;
      }
      if (buffer[pos] === '\n') {
        ++pos;
      }
      self.buffer = buffer.substr(pos);
      return line;
    }

    // 3.2 WebVTT metadata header syntax
    function parseHeader(input) {
      parseOptions(input, function (k, v) {
        switch (k) {
          case 'Region':
            // 3.3 WebVTT region metadata header syntax
            console.log('parse region', v);
            //parseRegion(v);
            break;
        }
      }, /:/);
    }

    // 5.1 WebVTT file parsing.
    try {
      var line;
      if (self.state === 'INITIAL') {
        // We can't start parsing until we have the first line.
        if (!/\r\n|\n/.test(self.buffer)) {
          return this;
        }

        line = collectNextLine();

        var m = line.match(/^WEBVTT([ \t].*)?$/);
        if (!m || !m[0]) {
          throw new Error('Malformed WebVTT signature.');
        }

        self.state = 'HEADER';
      }

      var alreadyCollectedLine = false;
      while (self.buffer) {
        // We can't parse a line until we have the full line.
        if (!/\r\n|\n/.test(self.buffer)) {
          return this;
        }

        if (!alreadyCollectedLine) {
          line = collectNextLine();
        } else {
          alreadyCollectedLine = false;
        }

        switch (self.state) {
          case 'HEADER':
            // 13-18 - Allow a header (metadata) under the WEBVTT line.
            if (/:/.test(line)) {
              parseHeader(line);
            } else if (!line) {
              // An empty line terminates the header and starts the body (cues).
              self.state = 'ID';
            }
            continue;
          case 'NOTE':
            // Ignore NOTE blocks.
            if (!line) {
              self.state = 'ID';
            }
            continue;
          case 'ID':
            // Check for the start of NOTE blocks.
            if (/^NOTE($|[ \t])/.test(line)) {
              self.state = 'NOTE';
              break;
            }
            // 19-29 - Allow any number of line terminators, then initialize new cue values.
            if (!line) {
              continue;
            }
            self.cue = new _vttcue2.default(0, 0, '');
            self.state = 'CUE';
            // 30-39 - Check if self line contains an optional identifier or timing data.
            if (line.indexOf('-->') === -1) {
              self.cue.id = line;
              continue;
            }
          // Process line as start of a cue.
          /*falls through*/
          case 'CUE':
            // 40 - Collect cue timings and settings.
            try {
              parseCue(line, self.cue, self.regionList);
            } catch (e) {
              // In case of an error ignore rest of the cue.
              self.cue = null;
              self.state = 'BADCUE';
              continue;
            }
            self.state = 'CUETEXT';
            continue;
          case 'CUETEXT':
            var hasSubstring = line.indexOf('-->') !== -1;
            // 34 - If we have an empty line then report the cue.
            // 35 - If we have the special substring '-->' then report the cue,
            // but do not collect the line as we need to process the current
            // one as a new cue.
            if (!line || hasSubstring && (alreadyCollectedLine = true)) {
              // We are done parsing self cue.
              if (self.oncue) {
                self.oncue(self.cue);
              }
              self.cue = null;
              self.state = 'ID';
              continue;
            }
            if (self.cue.text) {
              self.cue.text += '\n';
            }
            self.cue.text += line;
            continue;
          case 'BADCUE':
            // BADCUE
            // 54-62 - Collect and discard the remaining cue.
            if (!line) {
              self.state = 'ID';
            }
            continue;
        }
      }
    } catch (e) {

      // If we are currently parsing a cue, report what we have.
      if (self.state === 'CUETEXT' && self.cue && self.oncue) {
        self.oncue(self.cue);
      }
      self.cue = null;
      // Enter BADWEBVTT state if header was not parsed correctly otherwise
      // another exception occurred so enter BADCUE state.
      self.state = self.state === 'INITIAL' ? 'BADWEBVTT' : 'BADCUE';
    }
    return this;
  },
  flush: function flush() {
    var self = this;
    try {
      // Finish decoding the stream.
      self.buffer += self.decoder.decode();
      // Synthesize the end of the current cue or region.
      if (self.cue || self.state === 'HEADER') {
        self.buffer += '\n\n';
        self.parse();
      }
      // If we've flushed, parsed, and we're still on the INITIAL state then
      // that means we don't have enough of the stream to parse the first
      // line.
      if (self.state === 'INITIAL') {
        throw new Error('Malformed WebVTT signature.');
      }
    } catch (e) {
      throw e;
    }
    if (self.onflush) {
      self.onflush();
    }
    return this;
  }
};

exports.fixLineBreaks = fixLineBreaks;
exports.default = VTTParser;

},{"./vttcue":56}],58:[function(require,module,exports){
'use strict';

var _vttparser = require('./vttparser');

var _vttparser2 = _interopRequireDefault(_vttparser);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// String.prototype.startsWith is not supported in IE11
var startsWith = function startsWith(inputString, searchString, position) {
    return inputString.substr(position || 0, searchString.length) === searchString;
};

var cueString2millis = function cueString2millis(timeString) {
    var ts = parseInt(timeString.substr(-3));
    var secs = parseInt(timeString.substr(-6, 2));
    var mins = parseInt(timeString.substr(-9, 2));
    var hours = timeString.length > 9 ? parseInt(timeString.substr(0, timeString.indexOf(':'))) : 0;

    if (isNaN(ts) || isNaN(secs) || isNaN(mins) || isNaN(hours)) {
        return -1;
    }

    ts += 1000 * secs;
    ts += 60 * 1000 * mins;
    ts += 60 * 60 * 1000 * hours;

    return ts;
};

// From https://github.com/darkskyapp/string-hash
var hash = function hash(text) {
    var hash = 5381;
    var i = text.length;
    while (i) {
        hash = hash * 33 ^ text.charCodeAt(--i);
    }
    return (hash >>> 0).toString();
};

var calculateOffset = function calculateOffset(vttCCs, cc, presentationTime) {
    var currCC = vttCCs[cc];
    var prevCC = vttCCs[currCC.prevCC];

    // This is the first discontinuity or cues have been processed since the last discontinuity
    // Offset = current discontinuity time
    if (!prevCC || !prevCC.new && currCC.new) {
        vttCCs.ccOffset = vttCCs.presentationOffset = currCC.start;
        currCC.new = false;
        return;
    }

    // There have been discontinuities since cues were last parsed.
    // Offset = time elapsed
    while (prevCC && prevCC.new) {
        vttCCs.ccOffset += currCC.start - prevCC.start;
        currCC.new = false;
        currCC = prevCC;
        prevCC = vttCCs[currCC.prevCC];
    }

    vttCCs.presentationOffset = presentationTime;
};

var WebVTTParser = {
    parse: function parse(vttByteArray, syncPTS, vttCCs, cc, callBack, errorCallBack) {
        // Convert byteArray into string, replacing any somewhat exotic linefeeds with "\n", then split on that character.
        var re = /\r\n|\n\r|\n|\r/g;
        var vttLines = String.fromCharCode.apply(null, new Uint8Array(vttByteArray)).trim().replace(re, '\n').split('\n');
        var cueTime = '00:00.000';
        var mpegTs = 0;
        var localTime = 0;
        var presentationTime = 0;
        var cues = [];
        var parsingError = void 0;
        var inHeader = true;
        // let VTTCue = VTTCue || window.TextTrackCue;

        // Create parser object using VTTCue with TextTrackCue fallback on certain browsers.
        var parser = new _vttparser2.default();

        parser.oncue = function (cue) {
            // Adjust cue timing; clamp cues to start no earlier than - and drop cues that don't end after - 0 on timeline.
            var currCC = vttCCs[cc];
            var cueOffset = vttCCs.ccOffset;

            // Update offsets for new discontinuities
            if (currCC && currCC.new) {
                if (localTime !== undefined) {
                    // When local time is provided, offset = discontinuity start time - local time
                    cueOffset = vttCCs.ccOffset = currCC.start;
                } else {
                    calculateOffset(vttCCs, cc, presentationTime);
                }
            }

            if (presentationTime) {
                // If we have MPEGTS, offset = presentation time + discontinuity offset
                cueOffset = presentationTime + vttCCs.ccOffset - vttCCs.presentationOffset;
            }

            cue.startTime += cueOffset - localTime;
            cue.endTime += cueOffset - localTime;

            // Create a unique hash id for a cue based on start/end times and text.
            // This helps timeline-controller to avoid showing repeated captions.
            cue.id = hash(cue.startTime) + hash(cue.endTime) + hash(cue.text);

            // Fix encoding of special characters. TODO: Test with all sorts of weird characters.
            cue.text = decodeURIComponent(escape(cue.text));
            if (cue.endTime > 0) {
                cues.push(cue);
            }
        };

        parser.onparsingerror = function (e) {
            parsingError = e;
        };

        parser.onflush = function () {
            if (parsingError && errorCallBack) {
                errorCallBack(parsingError);
                return;
            }
            callBack(cues);
        };

        // Go through contents line by line.
        vttLines.forEach(function (line) {
            if (inHeader) {
                // Look for X-TIMESTAMP-MAP in header.
                if (startsWith(line, 'X-TIMESTAMP-MAP=')) {
                    // Once found, no more are allowed anyway, so stop searching.
                    inHeader = false;
                    // Extract LOCAL and MPEGTS.
                    line.substr(16).split(',').forEach(function (timestamp) {
                        if (startsWith(timestamp, 'LOCAL:')) {
                            cueTime = timestamp.substr(6);
                        } else if (startsWith(timestamp, 'MPEGTS:')) {
                            mpegTs = parseInt(timestamp.substr(7));
                        }
                    });
                    try {
                        // Calculate subtitle offset in milliseconds.
                        // If sync PTS is less than zero, we have a 33-bit wraparound, which is fixed by adding 2^33 = 8589934592.
                        syncPTS = syncPTS < 0 ? syncPTS + 8589934592 : syncPTS;
                        // Adjust MPEGTS by sync PTS.
                        mpegTs -= syncPTS;
                        // Convert cue time to seconds
                        localTime = cueString2millis(cueTime) / 1000;
                        // Convert MPEGTS to seconds from 90kHz.
                        presentationTime = mpegTs / 90000;

                        if (localTime === -1) {
                            parsingError = new Error('Malformed X-TIMESTAMP-MAP: ' + line);
                        }
                    } catch (e) {
                        parsingError = new Error('Malformed X-TIMESTAMP-MAP: ' + line);
                    }
                    // Return without parsing X-TIMESTAMP-MAP line.
                    return;
                } else if (line === '') {
                    inHeader = false;
                }
            }
            // Parse line by default.
            parser.parse(line + '\n');
        });

        parser.flush();
    }
};

module.exports = WebVTTParser;

},{"./vttparser":57}],59:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * XHR based logger
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */

var _logger = require('../utils/logger');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var XhrLoader = function () {
  function XhrLoader(config) {
    _classCallCheck(this, XhrLoader);

    if (config && config.xhrSetup) {
      this.xhrSetup = config.xhrSetup;
    }
  }

  _createClass(XhrLoader, [{
    key: 'destroy',
    value: function destroy() {
      this.abort();
      this.loader = null;
    }
  }, {
    key: 'abort',
    value: function abort() {
      var loader = this.loader;
      if (loader && loader.readyState !== 4) {
        this.stats.aborted = true;
        loader.abort();
      }

      window.clearTimeout(this.requestTimeout);
      this.requestTimeout = null;
      window.clearTimeout(this.retryTimeout);
      this.retryTimeout = null;
    }
  }, {
    key: 'load',
    value: function load(context, config, callbacks) {
      this.context = context;
      this.config = config;
      this.callbacks = callbacks;
      this.stats = { trequest: performance.now(), retry: 0 };
      this.retryDelay = config.retryDelay;
      this.loadInternal();
    }
  }, {
    key: 'loadInternal',
    value: function loadInternal() {
      var xhr,
          context = this.context;

      if (typeof XDomainRequest !== 'undefined') {
        xhr = this.loader = new XDomainRequest();
      } else {
        xhr = this.loader = new XMLHttpRequest();
      }
      var stats = this.stats;
      stats.tfirst = 0;
      stats.loaded = 0;
      var xhrSetup = this.xhrSetup;

      try {
        if (xhrSetup) {
          try {
            xhrSetup(xhr, context.url);
          } catch (e) {
            // fix xhrSetup: (xhr, url) => {xhr.setRequestHeader("Content-Language", "test");}
            // not working, as xhr.setRequestHeader expects xhr.readyState === OPEN
            xhr.open('GET', context.url, true);
            xhrSetup(xhr, context.url);
          }
        }
        if (!xhr.readyState) {
          xhr.open('GET', context.url, true);
        }
      } catch (e) {
        // IE11 throws an exception on xhr.open if attempting to access an HTTP resource over HTTPS
        this.callbacks.onError({ code: xhr.status, text: e.message }, context, xhr);
        return;
      }

      if (context.rangeEnd) {
        xhr.setRequestHeader('Range', 'bytes=' + context.rangeStart + '-' + (context.rangeEnd - 1));
      }
      xhr.onreadystatechange = this.readystatechange.bind(this);
      xhr.onprogress = this.loadprogress.bind(this);
      xhr.responseType = context.responseType;

      // setup timeout before we perform request
      this.requestTimeout = window.setTimeout(this.loadtimeout.bind(this), this.config.timeout);
      xhr.send();
    }
  }, {
    key: 'readystatechange',
    value: function readystatechange(event) {
      var xhr = event.currentTarget,
          readyState = xhr.readyState,
          stats = this.stats,
          context = this.context,
          config = this.config;

      // don't proceed if xhr has been aborted
      if (stats.aborted) {
        return;
      }

      // >= HEADERS_RECEIVED
      if (readyState >= 2) {
        // clear xhr timeout and rearm it if readyState less than 4
        window.clearTimeout(this.requestTimeout);
        if (stats.tfirst === 0) {
          stats.tfirst = Math.max(performance.now(), stats.trequest);
        }
        if (readyState === 4) {
          var status = xhr.status;
          // http status between 200 to 299 are all successful
          if (status >= 200 && status < 300) {
            stats.tload = Math.max(stats.tfirst, performance.now());
            var data = void 0,
                len = void 0;
            if (context.responseType === 'arraybuffer') {
              data = xhr.response;
              len = data.byteLength;
            } else {
              data = xhr.responseText;
              len = data.length;
            }
            stats.loaded = stats.total = len;
            var response = { url: xhr.responseURL, data: data };
            this.callbacks.onSuccess(response, stats, context, xhr);
          } else {
            // if max nb of retries reached or if http status between 400 and 499 (such error cannot be recovered, retrying is useless), return error
            if (stats.retry >= config.maxRetry || status >= 400 && status < 499) {
              _logger.logger.error(status + ' while loading ' + context.url);
              this.callbacks.onError({ code: status, text: xhr.statusText }, context, xhr);
            } else {
              // retry
              _logger.logger.warn(status + ' while loading ' + context.url + ', retrying in ' + this.retryDelay + '...');
              // aborts and resets internal state
              this.destroy();
              // schedule retry
              this.retryTimeout = window.setTimeout(this.loadInternal.bind(this), this.retryDelay);
              // set exponential backoff
              this.retryDelay = Math.min(2 * this.retryDelay, config.maxRetryDelay);
              stats.retry++;
            }
          }
        } else {
          // readyState >= 2 AND readyState !==4 (readyState = HEADERS_RECEIVED || LOADING) rearm timeout as xhr not finished yet
          this.requestTimeout = window.setTimeout(this.loadtimeout.bind(this), config.timeout);
        }
      }
    }
  }, {
    key: 'loadtimeout',
    value: function loadtimeout() {
      _logger.logger.warn('timeout while loading ' + this.context.url);
      this.callbacks.onTimeout(this.stats, this.context, null);
    }
  }, {
    key: 'loadprogress',
    value: function loadprogress(event) {
      var xhr = event.currentTarget,
          stats = this.stats;

      stats.loaded = event.loaded;
      if (event.lengthComputable) {
        stats.total = event.total;
      }
      var onProgress = this.callbacks.onProgress;
      if (onProgress) {
        // third arg is to provide on progress data
        onProgress(stats, this.context, null, xhr);
      }
    }
  }]);

  return XhrLoader;
}();

exports.default = XhrLoader;

},{"../utils/logger":54}]},{},[40])(40)
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvZXZlbnRzL2V2ZW50cy5qcyIsIm5vZGVfbW9kdWxlcy91cmwtdG9vbGtpdC9zcmMvdXJsLXRvb2xraXQuanMiLCJub2RlX21vZHVsZXMvd2Vid29ya2lmeS9pbmRleC5qcyIsInNyY1xcY29uZmlnLmpzIiwic3JjXFxjb250cm9sbGVyXFxhYnItY29udHJvbGxlci5qcyIsInNyY1xcY29udHJvbGxlclxcYXVkaW8tc3RyZWFtLWNvbnRyb2xsZXIuanMiLCJzcmNcXGNvbnRyb2xsZXJcXGF1ZGlvLXRyYWNrLWNvbnRyb2xsZXIuanMiLCJzcmNcXGNvbnRyb2xsZXJcXGJ1ZmZlci1jb250cm9sbGVyLmpzIiwic3JjXFxjb250cm9sbGVyXFxjYXAtbGV2ZWwtY29udHJvbGxlci5qcyIsInNyY1xcY29udHJvbGxlclxcZnBzLWNvbnRyb2xsZXIuanMiLCJzcmNcXGNvbnRyb2xsZXJcXGlkMy10cmFjay1jb250cm9sbGVyLmpzIiwic3JjXFxjb250cm9sbGVyXFxsZXZlbC1jb250cm9sbGVyLmpzIiwic3JjXFxjb250cm9sbGVyXFxzdHJlYW0tY29udHJvbGxlci5qcyIsInNyY1xcY29udHJvbGxlclxcc3VidGl0bGUtc3RyZWFtLWNvbnRyb2xsZXIuanMiLCJzcmNcXGNvbnRyb2xsZXJcXHN1YnRpdGxlLXRyYWNrLWNvbnRyb2xsZXIuanMiLCJzcmNcXGNvbnRyb2xsZXJcXHRpbWVsaW5lLWNvbnRyb2xsZXIuanMiLCJzcmNcXGNyeXB0XFxhZXMtY3J5cHRvLmpzIiwic3JjXFxjcnlwdFxcYWVzLWRlY3J5cHRvci5qcyIsInNyY1xcY3J5cHRcXGRlY3J5cHRlci5qcyIsInNyY1xcY3J5cHRcXGZhc3QtYWVzLWtleS5qcyIsInNyY1xcZGVtdXhcXGFhY2RlbXV4ZXIuanMiLCJzcmNcXGRlbXV4XFxhZHRzLmpzIiwic3JjXFxkZW11eFxcZGVtdXhlci1pbmxpbmUuanMiLCJzcmNcXGRlbXV4XFxkZW11eGVyLXdvcmtlci5qcyIsInNyY1xcZGVtdXhcXGRlbXV4ZXIuanMiLCJzcmNcXGRlbXV4XFxleHAtZ29sb21iLmpzIiwic3JjXFxkZW11eFxcaWQzLmpzIiwic3JjXFxkZW11eFxcbXAzZGVtdXhlci5qcyIsInNyY1xcZGVtdXhcXG1wNGRlbXV4ZXIuanMiLCJzcmNcXGRlbXV4XFxtcGVnYXVkaW8uanMiLCJzcmNcXGRlbXV4XFxzYW1wbGUtYWVzLmpzIiwic3JjXFxkZW11eFxcdHNkZW11eGVyLmpzIiwic3JjXFxlcnJvcnMuanMiLCJzcmNcXGV2ZW50LWhhbmRsZXIuanMiLCJzcmNcXGV2ZW50cy5qcyIsInNyY1xcaGVscGVyXFxhYWMuanMiLCJzcmNcXGhlbHBlclxcYnVmZmVyLWhlbHBlci5qcyIsInNyY1xcaGVscGVyXFxsZXZlbC1oZWxwZXIuanMiLCJzcmNcXGhscy5qcyIsInNyY1xcaW5kZXguanMiLCJzcmNcXGxvYWRlclxcZnJhZ21lbnQtbG9hZGVyLmpzIiwic3JjXFxsb2FkZXJcXGtleS1sb2FkZXIuanMiLCJzcmNcXGxvYWRlclxccGxheWxpc3QtbG9hZGVyLmpzIiwic3JjXFxyZW11eFxcbXA0LWdlbmVyYXRvci5qcyIsInNyY1xccmVtdXhcXG1wNC1yZW11eGVyLmpzIiwic3JjXFxyZW11eFxccGFzc3Rocm91Z2gtcmVtdXhlci5qcyIsInNyY1xcdXRpbHNcXGF0dHItbGlzdC5qcyIsInNyY1xcdXRpbHNcXGJpbmFyeS1zZWFyY2guanMiLCJzcmNcXHV0aWxzXFxjZWEtNjA4LXBhcnNlci5qcyIsInNyY1xcdXRpbHNcXGN1ZXMuanMiLCJzcmNcXHV0aWxzXFxkaXNjb250aW51aXRpZXMuanMiLCJzcmNcXHV0aWxzXFxld21hLWJhbmR3aWR0aC1lc3RpbWF0b3IuanMiLCJzcmNcXHV0aWxzXFxld21hLmpzIiwic3JjXFx1dGlsc1xcbG9nZ2VyLmpzIiwic3JjXFx1dGlsc1xcdGltZVJhbmdlcy5qcyIsInNyY1xcdXRpbHNcXHZ0dGN1ZS5qcyIsInNyY1xcdXRpbHNcXHZ0dHBhcnNlci5qcyIsInNyY1xcdXRpbHNcXHdlYnZ0dC1wYXJzZXIuanMiLCJzcmNcXHV0aWxzXFx4aHItbG9hZGVyLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25LQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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LENBQWtCLElBQWxCLENBQXVCLElBQXZCLENBQWxCLEVBQWdELEtBQUssVUFBckQsQ0FBcEI7QUFDQTtBQUNBLG1CQUFLLFVBQUwsR0FBa0IsS0FBSyxHQUFMLENBQVMsSUFBSSxLQUFLLFVBQWxCLEVBQThCLE9BQU8sYUFBckMsQ0FBbEI7QUFDQSxvQkFBTSxLQUFOO0FBQ0Q7QUFDRjtBQUNGLFNBakNELE1BaUNPO0FBQ0w7QUFDQSxlQUFLLGNBQUwsR0FBc0IsT0FBTyxVQUFQLENBQWtCLEtBQUssV0FBTCxDQUFpQixJQUFqQixDQUFzQixJQUF0QixDQUFsQixFQUErQyxPQUFPLE9BQXRELENBQXRCO0FBQ0Q7QUFDRjtBQUNGOzs7a0NBRWE7QUFDWixxQkFBTyxJQUFQLDRCQUFxQyxLQUFLLE9BQUwsQ0FBYSxHQUFsRDtBQUNBLFdBQUssU0FBTCxDQUFlLFNBQWYsQ0FBeUIsS0FBSyxLQUE5QixFQUFxQyxLQUFLLE9BQTFDLEVBQW1ELElBQW5EO0FBQ0Q7OztpQ0FFWSxLLEVBQU87QUFDbEIsVUFBSSxNQUFNLE1BQU0sYUFBaEI7QUFBQSxVQUNJLFFBQVEsS0FBSyxLQURqQjs7QUFHQSxZQUFNLE1BQU4sR0FBZSxNQUFNLE1BQXJCO0FBQ0EsVUFBSSxNQUFNLGdCQUFWLEVBQTRCO0FBQzFCLGNBQU0sS0FBTixHQUFjLE1BQU0sS0FBcEI7QUFDRDtBQUNELFVBQUksYUFBYSxLQUFLLFNBQUwsQ0FBZSxVQUFoQztBQUNBLFVBQUksVUFBSixFQUFnQjtBQUNkO0FBQ0EsbUJBQVcsS0FBWCxFQUFrQixLQUFLLE9BQXZCLEVBQWdDLElBQWhDLEVBQXNDLEdBQXRDO0FBQ0Q7QUFDRjs7Ozs7O2tCQUdZLFMiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgdGhpcy5fZXZlbnRzID0gdGhpcy5fZXZlbnRzIHx8IHt9O1xuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSB0aGlzLl9tYXhMaXN0ZW5lcnMgfHwgdW5kZWZpbmVkO1xufVxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuMTAueFxuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzID0gdW5kZWZpbmVkO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fbWF4TGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuXG4vLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuIDEwIGxpc3RlbmVycyBhcmVcbi8vIGFkZGVkIHRvIGl0LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2ggaGVscHMgZmluZGluZyBtZW1vcnkgbGVha3MuXG5FdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycyA9IDEwO1xuXG4vLyBPYnZpb3VzbHkgbm90IGFsbCBFbWl0dGVycyBzaG91bGQgYmUgbGltaXRlZCB0byAxMC4gVGhpcyBmdW5jdGlvbiBhbGxvd3Ncbi8vIHRoYXQgdG8gYmUgaW5jcmVhc2VkLiBTZXQgdG8gemVybyBmb3IgdW5saW1pdGVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbihuKSB7XG4gIGlmICghaXNOdW1iZXIobikgfHwgbiA8IDAgfHwgaXNOYU4obikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCduIG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXInKTtcbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciBlciwgaGFuZGxlciwgbGVuLCBhcmdzLCBpLCBsaXN0ZW5lcnM7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgdGhpcy5fZXZlbnRzID0ge307XG5cbiAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuICBpZiAodHlwZSA9PT0gJ2Vycm9yJykge1xuICAgIGlmICghdGhpcy5fZXZlbnRzLmVycm9yIHx8XG4gICAgICAgIChpc09iamVjdCh0aGlzLl9ldmVudHMuZXJyb3IpICYmICF0aGlzLl9ldmVudHMuZXJyb3IubGVuZ3RoKSkge1xuICAgICAgZXIgPSBhcmd1bWVudHNbMV07XG4gICAgICBpZiAoZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEF0IGxlYXN0IGdpdmUgc29tZSBraW5kIG9mIGNvbnRleHQgdG8gdGhlIHVzZXJcbiAgICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcignVW5jYXVnaHQsIHVuc3BlY2lmaWVkIFwiZXJyb3JcIiBldmVudC4gKCcgKyBlciArICcpJyk7XG4gICAgICAgIGVyci5jb250ZXh0ID0gZXI7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBoYW5kbGVyID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChpc1VuZGVmaW5lZChoYW5kbGVyKSlcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKGlzRnVuY3Rpb24oaGFuZGxlcikpIHtcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIC8vIGZhc3QgY2FzZXNcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0pO1xuICAgICAgICBicmVhaztcbiAgICAgIC8vIHNsb3dlclxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgIGhhbmRsZXIuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGhhbmRsZXIpKSB7XG4gICAgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgbGlzdGVuZXJzID0gaGFuZGxlci5zbGljZSgpO1xuICAgIGxlbiA9IGxpc3RlbmVycy5sZW5ndGg7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKVxuICAgICAgbGlzdGVuZXJzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIG07XG5cbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuXG4gIC8vIFRvIGF2b2lkIHJlY3Vyc2lvbiBpbiB0aGUgY2FzZSB0aGF0IHR5cGUgPT09IFwibmV3TGlzdGVuZXJcIiEgQmVmb3JlXG4gIC8vIGFkZGluZyBpdCB0byB0aGUgbGlzdGVuZXJzLCBmaXJzdCBlbWl0IFwibmV3TGlzdGVuZXJcIi5cbiAgaWYgKHRoaXMuX2V2ZW50cy5uZXdMaXN0ZW5lcilcbiAgICB0aGlzLmVtaXQoJ25ld0xpc3RlbmVyJywgdHlwZSxcbiAgICAgICAgICAgICAgaXNGdW5jdGlvbihsaXN0ZW5lci5saXN0ZW5lcikgP1xuICAgICAgICAgICAgICBsaXN0ZW5lci5saXN0ZW5lciA6IGxpc3RlbmVyKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICAvLyBPcHRpbWl6ZSB0aGUgY2FzZSBvZiBvbmUgbGlzdGVuZXIuIERvbid0IG5lZWQgdGhlIGV4dHJhIGFycmF5IG9iamVjdC5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgZWxzZSBpZiAoaXNPYmplY3QodGhpcy5fZXZlbnRzW3R5cGVdKSlcbiAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBhcnJheSwganVzdCBhcHBlbmQuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdLnB1c2gobGlzdGVuZXIpO1xuICBlbHNlXG4gICAgLy8gQWRkaW5nIHRoZSBzZWNvbmQgZWxlbWVudCwgbmVlZCB0byBjaGFuZ2UgdG8gYXJyYXkuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gW3RoaXMuX2V2ZW50c1t0eXBlXSwgbGlzdGVuZXJdO1xuXG4gIC8vIENoZWNrIGZvciBsaXN0ZW5lciBsZWFrXG4gIGlmIChpc09iamVjdCh0aGlzLl9ldmVudHNbdHlwZV0pICYmICF0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkKSB7XG4gICAgaWYgKCFpc1VuZGVmaW5lZCh0aGlzLl9tYXhMaXN0ZW5lcnMpKSB7XG4gICAgICBtID0gdGhpcy5fbWF4TGlzdGVuZXJzO1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gICAgfVxuXG4gICAgaWYgKG0gJiYgbSA+IDAgJiYgdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aCA+IG0pIHtcbiAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQgPSB0cnVlO1xuICAgICAgY29uc29sZS5lcnJvcignKG5vZGUpIHdhcm5pbmc6IHBvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgJyArXG4gICAgICAgICAgICAgICAgICAgICdsZWFrIGRldGVjdGVkLiAlZCBsaXN0ZW5lcnMgYWRkZWQuICcgK1xuICAgICAgICAgICAgICAgICAgICAnVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gaW5jcmVhc2UgbGltaXQuJyxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aCk7XG4gICAgICBpZiAodHlwZW9mIGNvbnNvbGUudHJhY2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gbm90IHN1cHBvcnRlZCBpbiBJRSAxMFxuICAgICAgICBjb25zb2xlLnRyYWNlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIHZhciBmaXJlZCA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIGcoKSB7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBnKTtcblxuICAgIGlmICghZmlyZWQpIHtcbiAgICAgIGZpcmVkID0gdHJ1ZTtcbiAgICAgIGxpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9XG5cbiAgZy5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICB0aGlzLm9uKHR5cGUsIGcpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gZW1pdHMgYSAncmVtb3ZlTGlzdGVuZXInIGV2ZW50IGlmZiB0aGUgbGlzdGVuZXIgd2FzIHJlbW92ZWRcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgbGlzdCwgcG9zaXRpb24sIGxlbmd0aCwgaTtcblxuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICByZXR1cm4gdGhpcztcblxuICBsaXN0ID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuICBsZW5ndGggPSBsaXN0Lmxlbmd0aDtcbiAgcG9zaXRpb24gPSAtMTtcblxuICBpZiAobGlzdCA9PT0gbGlzdGVuZXIgfHxcbiAgICAgIChpc0Z1bmN0aW9uKGxpc3QubGlzdGVuZXIpICYmIGxpc3QubGlzdGVuZXIgPT09IGxpc3RlbmVyKSkge1xuICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgaWYgKHRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0ZW5lcik7XG5cbiAgfSBlbHNlIGlmIChpc09iamVjdChsaXN0KSkge1xuICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tID4gMDspIHtcbiAgICAgIGlmIChsaXN0W2ldID09PSBsaXN0ZW5lciB8fFxuICAgICAgICAgIChsaXN0W2ldLmxpc3RlbmVyICYmIGxpc3RbaV0ubGlzdGVuZXIgPT09IGxpc3RlbmVyKSkge1xuICAgICAgICBwb3NpdGlvbiA9IGk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwb3NpdGlvbiA8IDApXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgbGlzdC5sZW5ndGggPSAwO1xuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGlzdC5zcGxpY2UocG9zaXRpb24sIDEpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIGtleSwgbGlzdGVuZXJzO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIC8vIG5vdCBsaXN0ZW5pbmcgZm9yIHJlbW92ZUxpc3RlbmVyLCBubyBuZWVkIHRvIGVtaXRcbiAgaWYgKCF0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMClcbiAgICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgIGVsc2UgaWYgKHRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBlbWl0IHJlbW92ZUxpc3RlbmVyIGZvciBhbGwgbGlzdGVuZXJzIG9uIGFsbCBldmVudHNcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICBmb3IgKGtleSBpbiB0aGlzLl9ldmVudHMpIHtcbiAgICAgIGlmIChrZXkgPT09ICdyZW1vdmVMaXN0ZW5lcicpIGNvbnRpbnVlO1xuICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoa2V5KTtcbiAgICB9XG4gICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3JlbW92ZUxpc3RlbmVyJyk7XG4gICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgaWYgKGlzRnVuY3Rpb24obGlzdGVuZXJzKSkge1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzKTtcbiAgfSBlbHNlIGlmIChsaXN0ZW5lcnMpIHtcbiAgICAvLyBMSUZPIG9yZGVyXG4gICAgd2hpbGUgKGxpc3RlbmVycy5sZW5ndGgpXG4gICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyc1tsaXN0ZW5lcnMubGVuZ3RoIC0gMV0pO1xuICB9XG4gIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIHJldDtcbiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICByZXQgPSBbXTtcbiAgZWxzZSBpZiAoaXNGdW5jdGlvbih0aGlzLl9ldmVudHNbdHlwZV0pKVxuICAgIHJldCA9IFt0aGlzLl9ldmVudHNbdHlwZV1dO1xuICBlbHNlXG4gICAgcmV0ID0gdGhpcy5fZXZlbnRzW3R5cGVdLnNsaWNlKCk7XG4gIHJldHVybiByZXQ7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbih0eXBlKSB7XG4gIGlmICh0aGlzLl9ldmVudHMpIHtcbiAgICB2YXIgZXZsaXN0ZW5lciA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICAgIGlmIChpc0Z1bmN0aW9uKGV2bGlzdGVuZXIpKVxuICAgICAgcmV0dXJuIDE7XG4gICAgZWxzZSBpZiAoZXZsaXN0ZW5lcilcbiAgICAgIHJldHVybiBldmxpc3RlbmVyLmxlbmd0aDtcbiAgfVxuICByZXR1cm4gMDtcbn07XG5cbkV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSkge1xuICByZXR1cm4gZW1pdHRlci5saXN0ZW5lckNvdW50KHR5cGUpO1xufTtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuIiwiLy8gc2VlIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMxODA4XHJcblxyXG4vKiBqc2hpbnQgaWdub3JlOnN0YXJ0ICovXHJcbihmdW5jdGlvbihyb290KSB7IFxyXG4vKiBqc2hpbnQgaWdub3JlOmVuZCAqL1xyXG5cclxuICB2YXIgVVJMX1JFR0VYID0gL14oKD86W15cXC87PyNdKzopPykoXFwvXFwvW15cXC9cXDs/I10qKT8oLio/KT8/KDsuKj8pPyhcXD8uKj8pPygjLio/KT8kLztcclxuICB2YXIgRklSU1RfU0VHTUVOVF9SRUdFWCA9IC9eKFteXFwvOz8jXSopKC4qKSQvO1xyXG4gIHZhciBTTEFTSF9ET1RfUkVHRVggPSAvKD86XFwvfF4pXFwuKD89XFwvKS9nO1xyXG4gIHZhciBTTEFTSF9ET1RfRE9UX1JFR0VYID0gLyg/OlxcL3xeKVxcLlxcLlxcLyg/IVxcLlxcLlxcLykuKj8oPz1cXC8pL2c7XHJcblxyXG4gIHZhciBVUkxUb29sa2l0ID0geyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcclxuICAgIC8vIElmIG9wdHMuYWx3YXlzTm9ybWFsaXplIGlzIHRydWUgdGhlbiB0aGUgcGF0aCB3aWxsIGFsd2F5cyBiZSBub3JtYWxpemVkIGV2ZW4gd2hlbiBpdCBzdGFydHMgd2l0aCAvIG9yIC8vXHJcbiAgICAvLyBFLmdcclxuICAgIC8vIFdpdGggb3B0cy5hbHdheXNOb3JtYWxpemUgPSBmYWxzZSAoZGVmYXVsdCwgc3BlYyBjb21wbGlhbnQpXHJcbiAgICAvLyBodHRwOi8vYS5jb20vYi9jZCArIC9lL2YvLi4vZyA9PiBodHRwOi8vYS5jb20vZS9mLy4uL2dcclxuICAgIC8vIFdpdGggb3B0cy5hbHdheXNOb3JtYWxpemUgPSB0cnVlIChkZWZhdWx0LCBub3Qgc3BlYyBjb21wbGlhbnQpXHJcbiAgICAvLyBodHRwOi8vYS5jb20vYi9jZCArIC9lL2YvLi4vZyA9PiBodHRwOi8vYS5jb20vZS9nXHJcbiAgICBidWlsZEFic29sdXRlVVJMOiBmdW5jdGlvbihiYXNlVVJMLCByZWxhdGl2ZVVSTCwgb3B0cykge1xyXG4gICAgICBvcHRzID0gb3B0cyB8fCB7fTtcclxuICAgICAgLy8gcmVtb3ZlIGFueSByZW1haW5pbmcgc3BhY2UgYW5kIENSTEZcclxuICAgICAgYmFzZVVSTCA9IGJhc2VVUkwudHJpbSgpO1xyXG4gICAgICByZWxhdGl2ZVVSTCA9IHJlbGF0aXZlVVJMLnRyaW0oKTtcclxuICAgICAgaWYgKCFyZWxhdGl2ZVVSTCkge1xyXG4gICAgICAgIC8vIDJhKSBJZiB0aGUgZW1iZWRkZWQgVVJMIGlzIGVudGlyZWx5IGVtcHR5LCBpdCBpbmhlcml0cyB0aGVcclxuICAgICAgICAvLyBlbnRpcmUgYmFzZSBVUkwgKGkuZS4sIGlzIHNldCBlcXVhbCB0byB0aGUgYmFzZSBVUkwpXHJcbiAgICAgICAgLy8gYW5kIHdlIGFyZSBkb25lLlxyXG4gICAgICAgIGlmICghb3B0cy5hbHdheXNOb3JtYWxpemUpIHtcclxuICAgICAgICAgIHJldHVybiBiYXNlVVJMO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgYmFzZVBhcnRzRm9yTm9ybWFsaXNlID0gdGhpcy5wYXJzZVVSTChiYXNlVVJMKTtcclxuICAgICAgICBpZiAoIWJhc2VQYXJ0cykge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFcnJvciB0cnlpbmcgdG8gcGFyc2UgYmFzZSBVUkwuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJhc2VQYXJ0c0Zvck5vcm1hbGlzZS5wYXRoID0gVVJMVG9vbGtpdC5ub3JtYWxpemVQYXRoKGJhc2VQYXJ0c0Zvck5vcm1hbGlzZS5wYXRoKTtcclxuICAgICAgICByZXR1cm4gVVJMVG9vbGtpdC5idWlsZFVSTEZyb21QYXJ0cyhiYXNlUGFydHNGb3JOb3JtYWxpc2UpO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciByZWxhdGl2ZVBhcnRzID0gdGhpcy5wYXJzZVVSTChyZWxhdGl2ZVVSTCk7XHJcbiAgICAgIGlmICghcmVsYXRpdmVQYXJ0cykge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXJyb3IgdHJ5aW5nIHRvIHBhcnNlIHJlbGF0aXZlIFVSTC4nKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAocmVsYXRpdmVQYXJ0cy5zY2hlbWUpIHtcclxuICAgICAgICAvLyAyYikgSWYgdGhlIGVtYmVkZGVkIFVSTCBzdGFydHMgd2l0aCBhIHNjaGVtZSBuYW1lLCBpdCBpc1xyXG4gICAgICAgIC8vIGludGVycHJldGVkIGFzIGFuIGFic29sdXRlIFVSTCBhbmQgd2UgYXJlIGRvbmUuXHJcbiAgICAgICAgaWYgKCFvcHRzLmFsd2F5c05vcm1hbGl6ZSkge1xyXG4gICAgICAgICAgcmV0dXJuIHJlbGF0aXZlVVJMO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZWxhdGl2ZVBhcnRzLnBhdGggPSBVUkxUb29sa2l0Lm5vcm1hbGl6ZVBhdGgocmVsYXRpdmVQYXJ0cy5wYXRoKTtcclxuICAgICAgICByZXR1cm4gVVJMVG9vbGtpdC5idWlsZFVSTEZyb21QYXJ0cyhyZWxhdGl2ZVBhcnRzKTtcclxuICAgICAgfVxyXG4gICAgICB2YXIgYmFzZVBhcnRzID0gdGhpcy5wYXJzZVVSTChiYXNlVVJMKTtcclxuICAgICAgaWYgKCFiYXNlUGFydHMpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Vycm9yIHRyeWluZyB0byBwYXJzZSBiYXNlIFVSTC4nKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoIWJhc2VQYXJ0cy5uZXRMb2MgJiYgYmFzZVBhcnRzLnBhdGggJiYgYmFzZVBhcnRzLnBhdGhbMF0gIT09ICcvJykge1xyXG4gICAgICAgIC8vIElmIG5ldExvYyBtaXNzaW5nIGFuZCBwYXRoIGRvZXNuJ3Qgc3RhcnQgd2l0aCAnLycsIGFzc3VtZSBldmVydGhpbmcgYmVmb3JlIHRoZSBmaXJzdCAnLycgaXMgdGhlIG5ldExvY1xyXG4gICAgICAgIC8vIFRoaXMgY2F1c2VzICdleGFtcGxlLmNvbS9hJyB0byBiZSBoYW5kbGVkIGFzICcvL2V4YW1wbGUuY29tL2EnIGluc3RlYWQgb2YgJy9leGFtcGxlLmNvbS9hJ1xyXG4gICAgICAgIHZhciBwYXRoUGFydHMgPSBGSVJTVF9TRUdNRU5UX1JFR0VYLmV4ZWMoYmFzZVBhcnRzLnBhdGgpO1xyXG4gICAgICAgIGJhc2VQYXJ0cy5uZXRMb2MgPSBwYXRoUGFydHNbMV07XHJcbiAgICAgICAgYmFzZVBhcnRzLnBhdGggPSBwYXRoUGFydHNbMl07XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGJhc2VQYXJ0cy5uZXRMb2MgJiYgIWJhc2VQYXJ0cy5wYXRoKSB7XHJcbiAgICAgICAgYmFzZVBhcnRzLnBhdGggPSAnLyc7XHJcbiAgICAgIH1cclxuICAgICAgdmFyIGJ1aWx0UGFydHMgPSB7XHJcbiAgICAgICAgLy8gMmMpIE90aGVyd2lzZSwgdGhlIGVtYmVkZGVkIFVSTCBpbmhlcml0cyB0aGUgc2NoZW1lIG9mXHJcbiAgICAgICAgLy8gdGhlIGJhc2UgVVJMLlxyXG4gICAgICAgIHNjaGVtZTogYmFzZVBhcnRzLnNjaGVtZSxcclxuICAgICAgICBuZXRMb2M6IHJlbGF0aXZlUGFydHMubmV0TG9jLFxyXG4gICAgICAgIHBhdGg6IG51bGwsXHJcbiAgICAgICAgcGFyYW1zOiByZWxhdGl2ZVBhcnRzLnBhcmFtcyxcclxuICAgICAgICBxdWVyeTogcmVsYXRpdmVQYXJ0cy5xdWVyeSxcclxuICAgICAgICBmcmFnbWVudDogcmVsYXRpdmVQYXJ0cy5mcmFnbWVudFxyXG4gICAgICB9O1xyXG4gICAgICBpZiAoIXJlbGF0aXZlUGFydHMubmV0TG9jKSB7XHJcbiAgICAgICAgLy8gMykgSWYgdGhlIGVtYmVkZGVkIFVSTCdzIDxuZXRfbG9jPiBpcyBub24tZW1wdHksIHdlIHNraXAgdG9cclxuICAgICAgICAvLyBTdGVwIDcuICBPdGhlcndpc2UsIHRoZSBlbWJlZGRlZCBVUkwgaW5oZXJpdHMgdGhlIDxuZXRfbG9jPlxyXG4gICAgICAgIC8vIChpZiBhbnkpIG9mIHRoZSBiYXNlIFVSTC5cclxuICAgICAgICBidWlsdFBhcnRzLm5ldExvYyA9IGJhc2VQYXJ0cy5uZXRMb2M7XHJcbiAgICAgICAgLy8gNCkgSWYgdGhlIGVtYmVkZGVkIFVSTCBwYXRoIGlzIHByZWNlZGVkIGJ5IGEgc2xhc2ggXCIvXCIsIHRoZVxyXG4gICAgICAgIC8vIHBhdGggaXMgbm90IHJlbGF0aXZlIGFuZCB3ZSBza2lwIHRvIFN0ZXAgNy5cclxuICAgICAgICBpZiAocmVsYXRpdmVQYXJ0cy5wYXRoWzBdICE9PSAnLycpIHtcclxuICAgICAgICAgIGlmICghcmVsYXRpdmVQYXJ0cy5wYXRoKSB7XHJcbiAgICAgICAgICAgIC8vIDUpIElmIHRoZSBlbWJlZGRlZCBVUkwgcGF0aCBpcyBlbXB0eSAoYW5kIG5vdCBwcmVjZWRlZCBieSBhXHJcbiAgICAgICAgICAgIC8vIHNsYXNoKSwgdGhlbiB0aGUgZW1iZWRkZWQgVVJMIGluaGVyaXRzIHRoZSBiYXNlIFVSTCBwYXRoXHJcbiAgICAgICAgICAgIGJ1aWx0UGFydHMucGF0aCA9IGJhc2VQYXJ0cy5wYXRoO1xyXG4gICAgICAgICAgICAvLyA1YSkgaWYgdGhlIGVtYmVkZGVkIFVSTCdzIDxwYXJhbXM+IGlzIG5vbi1lbXB0eSwgd2Ugc2tpcCB0b1xyXG4gICAgICAgICAgICAvLyBzdGVwIDc7IG90aGVyd2lzZSwgaXQgaW5oZXJpdHMgdGhlIDxwYXJhbXM+IG9mIHRoZSBiYXNlXHJcbiAgICAgICAgICAgIC8vIFVSTCAoaWYgYW55KSBhbmRcclxuICAgICAgICAgICAgaWYgKCFyZWxhdGl2ZVBhcnRzLnBhcmFtcykge1xyXG4gICAgICAgICAgICAgIGJ1aWx0UGFydHMucGFyYW1zID0gYmFzZVBhcnRzLnBhcmFtcztcclxuICAgICAgICAgICAgICAvLyA1YikgaWYgdGhlIGVtYmVkZGVkIFVSTCdzIDxxdWVyeT4gaXMgbm9uLWVtcHR5LCB3ZSBza2lwIHRvXHJcbiAgICAgICAgICAgICAgLy8gc3RlcCA3OyBvdGhlcndpc2UsIGl0IGluaGVyaXRzIHRoZSA8cXVlcnk+IG9mIHRoZSBiYXNlXHJcbiAgICAgICAgICAgICAgLy8gVVJMIChpZiBhbnkpIGFuZCB3ZSBza2lwIHRvIHN0ZXAgNy5cclxuICAgICAgICAgICAgICBpZiAoIXJlbGF0aXZlUGFydHMucXVlcnkpIHtcclxuICAgICAgICAgICAgICAgIGJ1aWx0UGFydHMucXVlcnkgPSBiYXNlUGFydHMucXVlcnk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyA2KSBUaGUgbGFzdCBzZWdtZW50IG9mIHRoZSBiYXNlIFVSTCdzIHBhdGggKGFueXRoaW5nXHJcbiAgICAgICAgICAgIC8vIGZvbGxvd2luZyB0aGUgcmlnaHRtb3N0IHNsYXNoIFwiL1wiLCBvciB0aGUgZW50aXJlIHBhdGggaWYgbm9cclxuICAgICAgICAgICAgLy8gc2xhc2ggaXMgcHJlc2VudCkgaXMgcmVtb3ZlZCBhbmQgdGhlIGVtYmVkZGVkIFVSTCdzIHBhdGggaXNcclxuICAgICAgICAgICAgLy8gYXBwZW5kZWQgaW4gaXRzIHBsYWNlLlxyXG4gICAgICAgICAgICB2YXIgYmFzZVVSTFBhdGggPSBiYXNlUGFydHMucGF0aDtcclxuICAgICAgICAgICAgdmFyIG5ld1BhdGggPSBiYXNlVVJMUGF0aC5zdWJzdHJpbmcoMCwgYmFzZVVSTFBhdGgubGFzdEluZGV4T2YoJy8nKSArIDEpICsgcmVsYXRpdmVQYXJ0cy5wYXRoO1xyXG4gICAgICAgICAgICBidWlsdFBhcnRzLnBhdGggPSBVUkxUb29sa2l0Lm5vcm1hbGl6ZVBhdGgobmV3UGF0aCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGlmIChidWlsdFBhcnRzLnBhdGggPT09IG51bGwpIHtcclxuICAgICAgICBidWlsdFBhcnRzLnBhdGggPSBvcHRzLmFsd2F5c05vcm1hbGl6ZSA/IFVSTFRvb2xraXQubm9ybWFsaXplUGF0aChyZWxhdGl2ZVBhcnRzLnBhdGgpIDogcmVsYXRpdmVQYXJ0cy5wYXRoO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBVUkxUb29sa2l0LmJ1aWxkVVJMRnJvbVBhcnRzKGJ1aWx0UGFydHMpO1xyXG4gICAgfSxcclxuICAgIHBhcnNlVVJMOiBmdW5jdGlvbih1cmwpIHtcclxuICAgICAgdmFyIHBhcnRzID0gVVJMX1JFR0VYLmV4ZWModXJsKTtcclxuICAgICAgaWYgKCFwYXJ0cykge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgc2NoZW1lOiBwYXJ0c1sxXSB8fCAnJyxcclxuICAgICAgICBuZXRMb2M6IHBhcnRzWzJdIHx8ICcnLFxyXG4gICAgICAgIHBhdGg6IHBhcnRzWzNdIHx8ICcnLFxyXG4gICAgICAgIHBhcmFtczogcGFydHNbNF0gfHwgJycsXHJcbiAgICAgICAgcXVlcnk6IHBhcnRzWzVdIHx8ICcnLFxyXG4gICAgICAgIGZyYWdtZW50OiBwYXJ0c1s2XSB8fCAnJ1xyXG4gICAgICB9O1xyXG4gICAgfSxcclxuICAgIG5vcm1hbGl6ZVBhdGg6IGZ1bmN0aW9uKHBhdGgpIHtcclxuICAgICAgLy8gVGhlIGZvbGxvd2luZyBvcGVyYXRpb25zIGFyZVxyXG4gICAgICAvLyB0aGVuIGFwcGxpZWQsIGluIG9yZGVyLCB0byB0aGUgbmV3IHBhdGg6XHJcbiAgICAgIC8vIDZhKSBBbGwgb2NjdXJyZW5jZXMgb2YgXCIuL1wiLCB3aGVyZSBcIi5cIiBpcyBhIGNvbXBsZXRlIHBhdGhcclxuICAgICAgLy8gc2VnbWVudCwgYXJlIHJlbW92ZWQuXHJcbiAgICAgIC8vIDZiKSBJZiB0aGUgcGF0aCBlbmRzIHdpdGggXCIuXCIgYXMgYSBjb21wbGV0ZSBwYXRoIHNlZ21lbnQsXHJcbiAgICAgIC8vIHRoYXQgXCIuXCIgaXMgcmVtb3ZlZC5cclxuICAgICAgcGF0aCA9IHBhdGguc3BsaXQoJycpLnJldmVyc2UoKS5qb2luKCcnKS5yZXBsYWNlKFNMQVNIX0RPVF9SRUdFWCwgJycpO1xyXG4gICAgICAvLyA2YykgQWxsIG9jY3VycmVuY2VzIG9mIFwiPHNlZ21lbnQ+Ly4uL1wiLCB3aGVyZSA8c2VnbWVudD4gaXMgYVxyXG4gICAgICAvLyBjb21wbGV0ZSBwYXRoIHNlZ21lbnQgbm90IGVxdWFsIHRvIFwiLi5cIiwgYXJlIHJlbW92ZWQuXHJcbiAgICAgIC8vIFJlbW92YWwgb2YgdGhlc2UgcGF0aCBzZWdtZW50cyBpcyBwZXJmb3JtZWQgaXRlcmF0aXZlbHksXHJcbiAgICAgIC8vIHJlbW92aW5nIHRoZSBsZWZ0bW9zdCBtYXRjaGluZyBwYXR0ZXJuIG9uIGVhY2ggaXRlcmF0aW9uLFxyXG4gICAgICAvLyB1bnRpbCBubyBtYXRjaGluZyBwYXR0ZXJuIHJlbWFpbnMuXHJcbiAgICAgIC8vIDZkKSBJZiB0aGUgcGF0aCBlbmRzIHdpdGggXCI8c2VnbWVudD4vLi5cIiwgd2hlcmUgPHNlZ21lbnQ+IGlzIGFcclxuICAgICAgLy8gY29tcGxldGUgcGF0aCBzZWdtZW50IG5vdCBlcXVhbCB0byBcIi4uXCIsIHRoYXRcclxuICAgICAgLy8gXCI8c2VnbWVudD4vLi5cIiBpcyByZW1vdmVkLlxyXG4gICAgICB3aGlsZSAocGF0aC5sZW5ndGggIT09IChwYXRoID0gcGF0aC5yZXBsYWNlKFNMQVNIX0RPVF9ET1RfUkVHRVgsICcnKSkubGVuZ3RoKSB7fSAvLyBqc2hpbnQgaWdub3JlOmxpbmVcclxuICAgICAgcmV0dXJuIHBhdGguc3BsaXQoJycpLnJldmVyc2UoKS5qb2luKCcnKTtcclxuICAgIH0sXHJcbiAgICBidWlsZFVSTEZyb21QYXJ0czogZnVuY3Rpb24ocGFydHMpIHtcclxuICAgICAgcmV0dXJuIHBhcnRzLnNjaGVtZSArIHBhcnRzLm5ldExvYyArIHBhcnRzLnBhdGggKyBwYXJ0cy5wYXJhbXMgKyBwYXJ0cy5xdWVyeSArIHBhcnRzLmZyYWdtZW50O1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4vKiBqc2hpbnQgaWdub3JlOnN0YXJ0ICovXHJcbiAgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBVUkxUb29sa2l0O1xyXG4gIGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxyXG4gICAgZGVmaW5lKFtdLCBmdW5jdGlvbigpIHsgcmV0dXJuIFVSTFRvb2xraXQ7IH0pO1xyXG4gIGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxyXG4gICAgZXhwb3J0c1tcIlVSTFRvb2xraXRcIl0gPSBVUkxUb29sa2l0O1xyXG4gIGVsc2VcclxuICAgIHJvb3RbXCJVUkxUb29sa2l0XCJdID0gVVJMVG9vbGtpdDtcclxufSkodGhpcyk7XHJcbi8qIGpzaGludCBpZ25vcmU6ZW5kICovXHJcbiIsInZhciBidW5kbGVGbiA9IGFyZ3VtZW50c1szXTtcbnZhciBzb3VyY2VzID0gYXJndW1lbnRzWzRdO1xudmFyIGNhY2hlID0gYXJndW1lbnRzWzVdO1xuXG52YXIgc3RyaW5naWZ5ID0gSlNPTi5zdHJpbmdpZnk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGZuLCBvcHRpb25zKSB7XG4gICAgdmFyIHdrZXk7XG4gICAgdmFyIGNhY2hlS2V5cyA9IE9iamVjdC5rZXlzKGNhY2hlKTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2FjaGVLZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIga2V5ID0gY2FjaGVLZXlzW2ldO1xuICAgICAgICB2YXIgZXhwID0gY2FjaGVba2V5XS5leHBvcnRzO1xuICAgICAgICAvLyBVc2luZyBiYWJlbCBhcyBhIHRyYW5zcGlsZXIgdG8gdXNlIGVzbW9kdWxlLCB0aGUgZXhwb3J0IHdpbGwgYWx3YXlzXG4gICAgICAgIC8vIGJlIGFuIG9iamVjdCB3aXRoIHRoZSBkZWZhdWx0IGV4cG9ydCBhcyBhIHByb3BlcnR5IG9mIGl0LiBUbyBlbnN1cmVcbiAgICAgICAgLy8gdGhlIGV4aXN0aW5nIGFwaSBhbmQgYmFiZWwgZXNtb2R1bGUgZXhwb3J0cyBhcmUgYm90aCBzdXBwb3J0ZWQgd2VcbiAgICAgICAgLy8gY2hlY2sgZm9yIGJvdGhcbiAgICAgICAgaWYgKGV4cCA9PT0gZm4gfHwgZXhwICYmIGV4cC5kZWZhdWx0ID09PSBmbikge1xuICAgICAgICAgICAgd2tleSA9IGtleTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCF3a2V5KSB7XG4gICAgICAgIHdrZXkgPSBNYXRoLmZsb29yKE1hdGgucG93KDE2LCA4KSAqIE1hdGgucmFuZG9tKCkpLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgdmFyIHdjYWNoZSA9IHt9O1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNhY2hlS2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBjYWNoZUtleXNbaV07XG4gICAgICAgICAgICB3Y2FjaGVba2V5XSA9IGtleTtcbiAgICAgICAgfVxuICAgICAgICBzb3VyY2VzW3drZXldID0gW1xuICAgICAgICAgICAgRnVuY3Rpb24oWydyZXF1aXJlJywnbW9kdWxlJywnZXhwb3J0cyddLCAnKCcgKyBmbiArICcpKHNlbGYpJyksXG4gICAgICAgICAgICB3Y2FjaGVcbiAgICAgICAgXTtcbiAgICB9XG4gICAgdmFyIHNrZXkgPSBNYXRoLmZsb29yKE1hdGgucG93KDE2LCA4KSAqIE1hdGgucmFuZG9tKCkpLnRvU3RyaW5nKDE2KTtcblxuICAgIHZhciBzY2FjaGUgPSB7fTsgc2NhY2hlW3drZXldID0gd2tleTtcbiAgICBzb3VyY2VzW3NrZXldID0gW1xuICAgICAgICBGdW5jdGlvbihbJ3JlcXVpcmUnXSwgKFxuICAgICAgICAgICAgLy8gdHJ5IHRvIGNhbGwgZGVmYXVsdCBpZiBkZWZpbmVkIHRvIGFsc28gc3VwcG9ydCBiYWJlbCBlc21vZHVsZVxuICAgICAgICAgICAgLy8gZXhwb3J0c1xuICAgICAgICAgICAgJ3ZhciBmID0gcmVxdWlyZSgnICsgc3RyaW5naWZ5KHdrZXkpICsgJyk7JyArXG4gICAgICAgICAgICAnKGYuZGVmYXVsdCA/IGYuZGVmYXVsdCA6IGYpKHNlbGYpOydcbiAgICAgICAgKSksXG4gICAgICAgIHNjYWNoZVxuICAgIF07XG5cbiAgICB2YXIgd29ya2VyU291cmNlcyA9IHt9O1xuICAgIHJlc29sdmVTb3VyY2VzKHNrZXkpO1xuXG4gICAgZnVuY3Rpb24gcmVzb2x2ZVNvdXJjZXMoa2V5KSB7XG4gICAgICAgIHdvcmtlclNvdXJjZXNba2V5XSA9IHRydWU7XG5cbiAgICAgICAgZm9yICh2YXIgZGVwUGF0aCBpbiBzb3VyY2VzW2tleV1bMV0pIHtcbiAgICAgICAgICAgIHZhciBkZXBLZXkgPSBzb3VyY2VzW2tleV1bMV1bZGVwUGF0aF07XG4gICAgICAgICAgICBpZiAoIXdvcmtlclNvdXJjZXNbZGVwS2V5XSkge1xuICAgICAgICAgICAgICAgIHJlc29sdmVTb3VyY2VzKGRlcEtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgc3JjID0gJygnICsgYnVuZGxlRm4gKyAnKSh7J1xuICAgICAgICArIE9iamVjdC5rZXlzKHdvcmtlclNvdXJjZXMpLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gc3RyaW5naWZ5KGtleSkgKyAnOlsnXG4gICAgICAgICAgICAgICAgKyBzb3VyY2VzW2tleV1bMF1cbiAgICAgICAgICAgICAgICArICcsJyArIHN0cmluZ2lmeShzb3VyY2VzW2tleV1bMV0pICsgJ10nXG4gICAgICAgICAgICA7XG4gICAgICAgIH0pLmpvaW4oJywnKVxuICAgICAgICArICd9LHt9LFsnICsgc3RyaW5naWZ5KHNrZXkpICsgJ10pJ1xuICAgIDtcblxuICAgIHZhciBVUkwgPSB3aW5kb3cuVVJMIHx8IHdpbmRvdy53ZWJraXRVUkwgfHwgd2luZG93Lm1velVSTCB8fCB3aW5kb3cubXNVUkw7XG5cbiAgICB2YXIgYmxvYiA9IG5ldyBCbG9iKFtzcmNdLCB7IHR5cGU6ICd0ZXh0L2phdmFzY3JpcHQnIH0pO1xuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuYmFyZSkgeyByZXR1cm4gYmxvYjsgfVxuICAgIHZhciB3b3JrZXJVcmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuICAgIHZhciB3b3JrZXIgPSBuZXcgV29ya2VyKHdvcmtlclVybCk7XG4gICAgd29ya2VyLm9iamVjdFVSTCA9IHdvcmtlclVybDtcbiAgICByZXR1cm4gd29ya2VyO1xufTtcbiIsIi8qKlxyXG4gKiBITFMgY29uZmlnXHJcbiAqL1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG5pbXBvcnQgQWJyQ29udHJvbGxlciBmcm9tICAgICcuL2NvbnRyb2xsZXIvYWJyLWNvbnRyb2xsZXInO1xyXG5pbXBvcnQgQnVmZmVyQ29udHJvbGxlciBmcm9tICAnLi9jb250cm9sbGVyL2J1ZmZlci1jb250cm9sbGVyJztcclxuaW1wb3J0IENhcExldmVsQ29udHJvbGxlciBmcm9tICAnLi9jb250cm9sbGVyL2NhcC1sZXZlbC1jb250cm9sbGVyJztcclxuaW1wb3J0IEZQU0NvbnRyb2xsZXIgZnJvbSAnLi9jb250cm9sbGVyL2Zwcy1jb250cm9sbGVyJztcclxuaW1wb3J0IFhockxvYWRlciBmcm9tICcuL3V0aWxzL3hoci1sb2FkZXInO1xyXG4vL2ltcG9ydCBGZXRjaExvYWRlciBmcm9tICcuL3V0aWxzL2ZldGNoLWxvYWRlcic7XHJcbi8vI2lmIGFsdGF1ZGlvXHJcbmltcG9ydCBBdWRpb1RyYWNrQ29udHJvbGxlciBmcm9tICcuL2NvbnRyb2xsZXIvYXVkaW8tdHJhY2stY29udHJvbGxlcic7XHJcbmltcG9ydCBBdWRpb1N0cmVhbUNvbnRyb2xsZXIgZnJvbSAgJy4vY29udHJvbGxlci9hdWRpby1zdHJlYW0tY29udHJvbGxlcic7XHJcbi8vI2VuZGlmXHJcblxyXG4vLyNpZiBzdWJ0aXRsZVxyXG5pbXBvcnQgQ3VlcyBmcm9tICcuL3V0aWxzL2N1ZXMnO1xyXG5pbXBvcnQgVGltZWxpbmVDb250cm9sbGVyIGZyb20gJy4vY29udHJvbGxlci90aW1lbGluZS1jb250cm9sbGVyJztcclxuaW1wb3J0IFN1YnRpdGxlVHJhY2tDb250cm9sbGVyIGZyb20gJy4vY29udHJvbGxlci9zdWJ0aXRsZS10cmFjay1jb250cm9sbGVyJztcclxuaW1wb3J0IFN1YnRpdGxlU3RyZWFtQ29udHJvbGxlciBmcm9tICAnLi9jb250cm9sbGVyL3N1YnRpdGxlLXN0cmVhbS1jb250cm9sbGVyJztcclxuLy8jZW5kaWZcclxuXHJcbmV4cG9ydCB2YXIgaGxzRGVmYXVsdENvbmZpZyA9IHtcclxuICAgICAgYXV0b1N0YXJ0TG9hZDogdHJ1ZSwgICAgICAgICAgICAgICAgICAgIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcclxuICAgICAgc3RhcnRQb3NpdGlvbjogLTEsICAgICAgICAgICAgICAgICAgICAgIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcclxuICAgICAgZGVmYXVsdEF1ZGlvQ29kZWM6IHVuZGVmaW5lZCwgICAgICAgICAgIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcclxuICAgICAgZGVidWc6IGZhbHNlLCAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHVzZWQgYnkgbG9nZ2VyXHJcbiAgICAgIGNhcExldmVsT25GUFNEcm9wOiBmYWxzZSwgICAgICAgICAgICAgICAvLyB1c2VkIGJ5IGZwcy1jb250cm9sbGVyXHJcbiAgICAgIGNhcExldmVsVG9QbGF5ZXJTaXplOiBmYWxzZSwgICAgICAgICAgICAvLyB1c2VkIGJ5IGNhcC1sZXZlbC1jb250cm9sbGVyXHJcbiAgICAgIGluaXRpYWxMaXZlTWFuaWZlc3RTaXplOiAxLCAgICAgICAgICAgICAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXHJcbiAgICAgIG1heEJ1ZmZlckxlbmd0aDogMzAsICAgICAgICAgICAgICAgICAgICAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXHJcbiAgICAgIG1heEJ1ZmZlclNpemU6IDYwICogMTAwMCAqIDEwMDAsICAgICAgICAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXHJcbiAgICAgIG1heEJ1ZmZlckhvbGU6IDAuNSwgICAgICAgICAgICAgICAgICAgICAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXHJcbiAgICAgIG1heFNlZWtIb2xlOiAyLCAgICAgICAgICAgICAgICAgICAgICAgICAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXHJcbiAgICAgIGxvd0J1ZmZlcldhdGNoZG9nUGVyaW9kOiAwLjUsICAgICAgICAgICAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXHJcbiAgICAgIGhpZ2hCdWZmZXJXYXRjaGRvZ1BlcmlvZDogMywgICAgICAgICAgICAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXHJcbiAgICAgIG51ZGdlT2Zmc2V0OiAwLjEsICAgICAgICAgICAgICAgICAgICAgICAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXHJcbiAgICAgIG51ZGdlTWF4UmV0cnkgOiAzLCAgICAgICAgICAgICAgICAgICAgICAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXHJcbiAgICAgIG1heEZyYWdMb29rVXBUb2xlcmFuY2U6IDAuMjUsICAgICAgICAgICAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXHJcbiAgICAgIGxpdmVTeW5jRHVyYXRpb25Db3VudDozLCAgICAgICAgICAgICAgICAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXHJcbiAgICAgIGxpdmVNYXhMYXRlbmN5RHVyYXRpb25Db3VudDogSW5maW5pdHksICAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXHJcbiAgICAgIGxpdmVTeW5jRHVyYXRpb246IHVuZGVmaW5lZCwgICAgICAgICAgICAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXHJcbiAgICAgIGxpdmVNYXhMYXRlbmN5RHVyYXRpb246IHVuZGVmaW5lZCwgICAgICAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXHJcbiAgICAgIG1heE1heEJ1ZmZlckxlbmd0aDogNjAwLCAgICAgICAgICAgICAgICAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXHJcbiAgICAgIGVuYWJsZVdvcmtlcjogdHJ1ZSwgICAgICAgICAgICAgICAgICAgICAvLyB1c2VkIGJ5IGRlbXV4ZXJcclxuICAgICAgZW5hYmxlU29mdHdhcmVBRVM6IHRydWUsICAgICAgICAgICAgICAgIC8vIHVzZWQgYnkgZGVjcnlwdGVyXHJcbiAgICAgIG1hbmlmZXN0TG9hZGluZ1RpbWVPdXQ6IDEwMDAwLCAgICAgICAgICAvLyB1c2VkIGJ5IHBsYXlsaXN0LWxvYWRlclxyXG4gICAgICBtYW5pZmVzdExvYWRpbmdNYXhSZXRyeTogMSwgICAgICAgICAgICAgLy8gdXNlZCBieSBwbGF5bGlzdC1sb2FkZXJcclxuICAgICAgbWFuaWZlc3RMb2FkaW5nUmV0cnlEZWxheTogMTAwMCwgICAgICAgIC8vIHVzZWQgYnkgcGxheWxpc3QtbG9hZGVyXHJcbiAgICAgIG1hbmlmZXN0TG9hZGluZ01heFJldHJ5VGltZW91dDogNjQwMDAsICAvLyB1c2VkIGJ5IHBsYXlsaXN0LWxvYWRlclxyXG4gICAgICBzdGFydExldmVsOiB1bmRlZmluZWQsICAgICAgICAgICAgICAgICAgLy8gdXNlZCBieSBsZXZlbC1jb250cm9sbGVyXHJcbiAgICAgIGxldmVsTG9hZGluZ1RpbWVPdXQ6IDEwMDAwLCAgICAgICAgICAgICAvLyB1c2VkIGJ5IHBsYXlsaXN0LWxvYWRlclxyXG4gICAgICBsZXZlbExvYWRpbmdNYXhSZXRyeTogNCwgICAgICAgICAgICAgICAgLy8gdXNlZCBieSBwbGF5bGlzdC1sb2FkZXJcclxuICAgICAgbGV2ZWxMb2FkaW5nUmV0cnlEZWxheTogMTAwMCwgICAgICAgICAgIC8vIHVzZWQgYnkgcGxheWxpc3QtbG9hZGVyXHJcbiAgICAgIGxldmVsTG9hZGluZ01heFJldHJ5VGltZW91dDogNjQwMDAsICAgICAvLyB1c2VkIGJ5IHBsYXlsaXN0LWxvYWRlclxyXG4gICAgICBmcmFnTG9hZGluZ1RpbWVPdXQ6IDIwMDAwLCAgICAgICAgICAgICAgLy8gdXNlZCBieSBmcmFnbWVudC1sb2FkZXJcclxuICAgICAgZnJhZ0xvYWRpbmdNYXhSZXRyeTogNiwgICAgICAgICAgICAgICAgIC8vIHVzZWQgYnkgZnJhZ21lbnQtbG9hZGVyXHJcbiAgICAgIGZyYWdMb2FkaW5nUmV0cnlEZWxheTogMTAwMCwgICAgICAgICAgICAvLyB1c2VkIGJ5IGZyYWdtZW50LWxvYWRlclxyXG4gICAgICBmcmFnTG9hZGluZ01heFJldHJ5VGltZW91dDogNjQwMDAsICAgICAgLy8gdXNlZCBieSBmcmFnbWVudC1sb2FkZXJcclxuICAgICAgZnJhZ0xvYWRpbmdMb29wVGhyZXNob2xkOiAzLCAgICAgICAgICAgIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcclxuICAgICAgc3RhcnRGcmFnUHJlZmV0Y2g6IGZhbHNlLCAgICAgICAgICAgICAgIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcclxuICAgICAgZnBzRHJvcHBlZE1vbml0b3JpbmdQZXJpb2Q6IDUwMDAsICAgICAgIC8vIHVzZWQgYnkgZnBzLWNvbnRyb2xsZXJcclxuICAgICAgZnBzRHJvcHBlZE1vbml0b3JpbmdUaHJlc2hvbGQ6IDAuMiwgICAgIC8vIHVzZWQgYnkgZnBzLWNvbnRyb2xsZXJcclxuICAgICAgYXBwZW5kRXJyb3JNYXhSZXRyeTogMywgICAgICAgICAgICAgICAgIC8vIHVzZWQgYnkgYnVmZmVyLWNvbnRyb2xsZXJcclxuICAgICAgbG9hZGVyOiBYaHJMb2FkZXIsXHJcbiAgICAgIC8vbG9hZGVyOiBGZXRjaExvYWRlcixcclxuICAgICAgZkxvYWRlcjogdW5kZWZpbmVkLFxyXG4gICAgICBwTG9hZGVyOiB1bmRlZmluZWQsXHJcbiAgICAgIHhoclNldHVwOiB1bmRlZmluZWQsXHJcbiAgICAgIGZldGNoU2V0dXA6IHVuZGVmaW5lZCxcclxuICAgICAgYWJyQ29udHJvbGxlcjogQWJyQ29udHJvbGxlcixcclxuICAgICAgYnVmZmVyQ29udHJvbGxlcjogQnVmZmVyQ29udHJvbGxlcixcclxuICAgICAgY2FwTGV2ZWxDb250cm9sbGVyOiBDYXBMZXZlbENvbnRyb2xsZXIsXHJcbiAgICAgIGZwc0NvbnRyb2xsZXI6IEZQU0NvbnRyb2xsZXIsXHJcbi8vI2lmIGFsdGF1ZGlvXHJcbiAgICAgIGF1ZGlvU3RyZWFtQ29udHJvbGxlcjogQXVkaW9TdHJlYW1Db250cm9sbGVyLFxyXG4gICAgICBhdWRpb1RyYWNrQ29udHJvbGxlciA6IEF1ZGlvVHJhY2tDb250cm9sbGVyLFxyXG4vLyNlbmRpZlxyXG4vLyNpZiBzdWJ0aXRsZVxyXG4gICAgICBzdWJ0aXRsZVN0cmVhbUNvbnRyb2xsZXI6IFN1YnRpdGxlU3RyZWFtQ29udHJvbGxlcixcclxuICAgICAgc3VidGl0bGVUcmFja0NvbnRyb2xsZXI6IFN1YnRpdGxlVHJhY2tDb250cm9sbGVyLFxyXG4gICAgICB0aW1lbGluZUNvbnRyb2xsZXI6IFRpbWVsaW5lQ29udHJvbGxlcixcclxuICAgICAgY3VlSGFuZGxlcjogQ3VlcyxcclxuICAgICAgZW5hYmxlQ0VBNzA4Q2FwdGlvbnM6IHRydWUsICAgICAgICAgICAgICAgLy8gdXNlZCBieSB0aW1lbGluZS1jb250cm9sbGVyXHJcbiAgICAgIGVuYWJsZVdlYlZUVDogdHJ1ZSwgICAgICAgICAgICAgICAgICAgICAgIC8vIHVzZWQgYnkgdGltZWxpbmUtY29udHJvbGxlclxyXG4gICAgICBjYXB0aW9uc1RleHRUcmFjazFMYWJlbDogJ0VuZ2xpc2gnLCAgICAgICAvLyB1c2VkIGJ5IHRpbWVsaW5lLWNvbnRyb2xsZXJcclxuICAgICAgY2FwdGlvbnNUZXh0VHJhY2sxTGFuZ3VhZ2VDb2RlOiAnZW4nLCAgICAgIC8vIHVzZWQgYnkgdGltZWxpbmUtY29udHJvbGxlclxyXG4gICAgICBjYXB0aW9uc1RleHRUcmFjazJMYWJlbDogJ1NwYW5pc2gnLCAgICAgICAvLyB1c2VkIGJ5IHRpbWVsaW5lLWNvbnRyb2xsZXJcclxuICAgICAgY2FwdGlvbnNUZXh0VHJhY2syTGFuZ3VhZ2VDb2RlOiAnZXMnLCAgICAgLy8gdXNlZCBieSB0aW1lbGluZS1jb250cm9sbGVyXHJcbi8vI2VuZGlmXHJcbiAgICAgIHN0cmV0Y2hTaG9ydFZpZGVvVHJhY2s6IGZhbHNlLCAgICAgICAgICAgIC8vIHVzZWQgYnkgbXA0LXJlbXV4ZXJcclxuICAgICAgZm9yY2VLZXlGcmFtZU9uRGlzY29udGludWl0eTogdHJ1ZSwgICAgICAgLy8gdXNlZCBieSB0cy1kZW11eGVyXHJcbiAgICAgIGFickV3bWFGYXN0TGl2ZTogMywgICAgICAgICAgICAgICAgICAgICAgIC8vIHVzZWQgYnkgYWJyLWNvbnRyb2xsZXJcclxuICAgICAgYWJyRXdtYVNsb3dMaXZlOiA5LCAgICAgICAgICAgICAgICAgICAgICAgLy8gdXNlZCBieSBhYnItY29udHJvbGxlclxyXG4gICAgICBhYnJFd21hRmFzdFZvRDogMywgICAgICAgICAgICAgICAgICAgICAgICAvLyB1c2VkIGJ5IGFici1jb250cm9sbGVyXHJcbiAgICAgIGFickV3bWFTbG93Vm9EOiA5LCAgICAgICAgICAgICAgICAgICAgICAgIC8vIHVzZWQgYnkgYWJyLWNvbnRyb2xsZXJcclxuICAgICAgYWJyRXdtYURlZmF1bHRFc3RpbWF0ZTogNWU1LCAvLyA1MDAga2JwcyAgLy8gdXNlZCBieSBhYnItY29udHJvbGxlclxyXG4gICAgICBhYnJCYW5kV2lkdGhGYWN0b3IgOiAwLjk1LCAgICAgICAgICAgICAgICAvLyB1c2VkIGJ5IGFici1jb250cm9sbGVyXHJcbiAgICAgIGFickJhbmRXaWR0aFVwRmFjdG9yIDogMC43LCAgICAgICAgICAgICAgIC8vIHVzZWQgYnkgYWJyLWNvbnRyb2xsZXJcclxuICAgICAgYWJyTWF4V2l0aFJlYWxCaXRyYXRlIDogZmFsc2UsICAgICAgICAgICAgLy8gdXNlZCBieSBhYnItY29udHJvbGxlclxyXG4gICAgICBtYXhTdGFydmF0aW9uRGVsYXkgOiA0LCAgICAgICAgICAgICAgICAgICAvLyB1c2VkIGJ5IGFici1jb250cm9sbGVyXHJcbiAgICAgIG1heExvYWRpbmdEZWxheSA6IDQsICAgICAgICAgICAgICAgICAgICAgIC8vIHVzZWQgYnkgYWJyLWNvbnRyb2xsZXJcclxuICAgICAgbWluQXV0b0JpdHJhdGU6IDAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdXNlZCBieSBobHNcclxuICAgIH07XHJcbiIsIi8qXHJcbiAqIHNpbXBsZSBBQlIgQ29udHJvbGxlclxyXG4gKiAgLSBjb21wdXRlIG5leHQgbGV2ZWwgYmFzZWQgb24gbGFzdCBmcmFnbWVudCBidyBoZXVyaXN0aWNzXHJcbiAqICAtIGltcGxlbWVudCBhbiBhYmFuZG9uIHJ1bGVzIHRyaWdnZXJlZCBpZiB3ZSBoYXZlIGxlc3MgdGhhbiAyIGZyYWcgYnVmZmVyZWQgYW5kIGlmIGNvbXB1dGVkIGJ3IHNob3dzIHRoYXQgd2UgcmlzayBidWZmZXIgc3RhbGxpbmdcclxuICovXHJcblxyXG5pbXBvcnQgRXZlbnQgZnJvbSAnLi4vZXZlbnRzJztcclxuaW1wb3J0IEV2ZW50SGFuZGxlciBmcm9tICcuLi9ldmVudC1oYW5kbGVyJztcclxuaW1wb3J0IEJ1ZmZlckhlbHBlciBmcm9tICcuLi9oZWxwZXIvYnVmZmVyLWhlbHBlcic7XHJcbmltcG9ydCB7RXJyb3JEZXRhaWxzfSBmcm9tICcuLi9lcnJvcnMnO1xyXG5pbXBvcnQge2xvZ2dlcn0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcclxuaW1wb3J0IEV3bWFCYW5kV2lkdGhFc3RpbWF0b3IgZnJvbSAnLi4vdXRpbHMvZXdtYS1iYW5kd2lkdGgtZXN0aW1hdG9yJztcclxuXHJcbmNsYXNzIEFickNvbnRyb2xsZXIgZXh0ZW5kcyBFdmVudEhhbmRsZXIge1xyXG5cclxuICBjb25zdHJ1Y3RvcihobHMpIHtcclxuICAgIHN1cGVyKGhscywgRXZlbnQuRlJBR19MT0FESU5HLFxyXG4gICAgICAgICAgICAgICBFdmVudC5GUkFHX0xPQURFRCxcclxuICAgICAgICAgICAgICAgRXZlbnQuRlJBR19CVUZGRVJFRCxcclxuICAgICAgICAgICAgICAgRXZlbnQuRVJST1IpO1xyXG4gICAgdGhpcy5sYXN0TG9hZGVkRnJhZ0xldmVsID0gMDtcclxuICAgIHRoaXMuX25leHRBdXRvTGV2ZWwgPSAtMTtcclxuICAgIHRoaXMuaGxzID0gaGxzO1xyXG4gICAgdGhpcy50aW1lciA9IG51bGw7XHJcbiAgICB0aGlzLl9id0VzdGltYXRvciA9IG51bGw7XHJcbiAgICB0aGlzLm9uQ2hlY2sgPSB0aGlzLl9hYmFuZG9uUnVsZXNDaGVjay5iaW5kKHRoaXMpO1xyXG4gIH1cclxuXHJcbiAgZGVzdHJveSgpIHtcclxuICAgIHRoaXMuY2xlYXJUaW1lcigpO1xyXG4gICAgRXZlbnRIYW5kbGVyLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XHJcbiAgfVxyXG5cclxuICBvbkZyYWdMb2FkaW5nKGRhdGEpIHtcclxuICAgIGxldCBmcmFnID0gZGF0YS5mcmFnO1xyXG4gICAgaWYgKGZyYWcudHlwZSA9PT0gJ21haW4nKSB7XHJcbiAgICAgIGlmICghdGhpcy50aW1lcikge1xyXG4gICAgICAgIHRoaXMudGltZXIgPSBzZXRJbnRlcnZhbCh0aGlzLm9uQ2hlY2ssIDEwMCk7XHJcbiAgICAgIH1cclxuICAgICAgLy8gbGF6eSBpbml0IG9mIGJ3IEVzdGltYXRvciwgcmF0aW9uYWxlIGlzIHRoYXQgd2UgdXNlIGRpZmZlcmVudCBwYXJhbXMgZm9yIExpdmUvVm9EXHJcbiAgICAgIC8vIHNvIHdlIG5lZWQgdG8gd2FpdCBmb3Igc3RyZWFtIG1hbmlmZXN0IC8gcGxheWxpc3QgdHlwZSB0byBpbnN0YW50aWF0ZSBpdC5cclxuICAgICAgaWYgKCF0aGlzLl9id0VzdGltYXRvcikge1xyXG4gICAgICAgIGxldCBobHMgPSB0aGlzLmhscyxcclxuICAgICAgICAgICAgbGV2ZWwgPSBkYXRhLmZyYWcubGV2ZWwsXHJcbiAgICAgICAgICAgIGlzTGl2ZSA9IGhscy5sZXZlbHNbbGV2ZWxdLmRldGFpbHMubGl2ZSxcclxuICAgICAgICAgICAgY29uZmlnID0gaGxzLmNvbmZpZyxcclxuICAgICAgICAgICAgZXdtYUZhc3QsIGV3bWFTbG93O1xyXG5cclxuICAgICAgICBpZiAoaXNMaXZlKSB7XHJcbiAgICAgICAgICBld21hRmFzdCA9IGNvbmZpZy5hYnJFd21hRmFzdExpdmU7XHJcbiAgICAgICAgICBld21hU2xvdyA9IGNvbmZpZy5hYnJFd21hU2xvd0xpdmU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGV3bWFGYXN0ID0gY29uZmlnLmFickV3bWFGYXN0Vm9EO1xyXG4gICAgICAgICAgZXdtYVNsb3cgPSBjb25maWcuYWJyRXdtYVNsb3dWb0Q7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2J3RXN0aW1hdG9yID0gbmV3IEV3bWFCYW5kV2lkdGhFc3RpbWF0b3IoaGxzLGV3bWFTbG93LGV3bWFGYXN0LGNvbmZpZy5hYnJFd21hRGVmYXVsdEVzdGltYXRlKTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLmZyYWdDdXJyZW50ID0gZnJhZztcclxuICAgIH1cclxuICB9XHJcblxyXG4gIF9hYmFuZG9uUnVsZXNDaGVjaygpIHtcclxuICAgIC8qXHJcbiAgICAgIG1vbml0b3IgZnJhZ21lbnQgcmV0cmlldmFsIHRpbWUuLi5cclxuICAgICAgd2UgY29tcHV0ZSBleHBlY3RlZCB0aW1lIG9mIGFycml2YWwgb2YgdGhlIGNvbXBsZXRlIGZyYWdtZW50LlxyXG4gICAgICB3ZSBjb21wYXJlIGl0IHRvIGV4cGVjdGVkIHRpbWUgb2YgYnVmZmVyIHN0YXJ2YXRpb25cclxuICAgICovXHJcbiAgICBsZXQgaGxzID0gdGhpcy5obHMsIHYgPSBobHMubWVkaWEsZnJhZyA9IHRoaXMuZnJhZ0N1cnJlbnQsIGxvYWRlciA9IGZyYWcubG9hZGVyLCBtaW5BdXRvTGV2ZWwgPSBobHMubWluQXV0b0xldmVsO1xyXG5cclxuICAgIC8vIGlmIGxvYWRlciBoYXMgYmVlbiBkZXN0cm95ZWQgb3IgbG9hZGluZyBoYXMgYmVlbiBhYm9ydGVkLCBzdG9wIHRpbWVyIGFuZCByZXR1cm5cclxuICAgIGlmKCFsb2FkZXIgfHwgKCBsb2FkZXIuc3RhdHMgJiYgbG9hZGVyLnN0YXRzLmFib3J0ZWQpKSB7XHJcbiAgICAgIGxvZ2dlci53YXJuKCdmcmFnIGxvYWRlciBkZXN0cm95IG9yIGFib3J0ZWQsIGRpc2FybSBhYmFuZG9uUnVsZXMnKTtcclxuICAgICAgdGhpcy5jbGVhclRpbWVyKCk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGxldCBzdGF0cyA9IGxvYWRlci5zdGF0cztcclxuICAgIC8qIG9ubHkgbW9uaXRvciBmcmFnIHJldHJpZXZhbCB0aW1lIGlmXHJcbiAgICAodmlkZW8gbm90IHBhdXNlZCBPUiBmaXJzdCBmcmFnbWVudCBiZWluZyBsb2FkZWQocmVhZHkgc3RhdGUgPT09IEhBVkVfTk9USElORyA9IDApKSBBTkQgYXV0b3N3aXRjaGluZyBlbmFibGVkIEFORCBub3QgbG93ZXN0IGxldmVsICg9PiBtZWFucyB0aGF0IHdlIGhhdmUgc2V2ZXJhbCBsZXZlbHMpICovXHJcbiAgICBpZiAodiAmJiAoKCF2LnBhdXNlZCAmJiAodi5wbGF5YmFja1JhdGUgIT09IDApKSB8fCAhdi5yZWFkeVN0YXRlKSAmJiBmcmFnLmF1dG9MZXZlbCAmJiBmcmFnLmxldmVsKSB7XHJcbiAgICAgIGxldCByZXF1ZXN0RGVsYXkgPSBwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXRzLnRyZXF1ZXN0LFxyXG4gICAgICAgICAgcGxheWJhY2tSYXRlID0gTWF0aC5hYnModi5wbGF5YmFja1JhdGUpO1xyXG4gICAgICAvLyBtb25pdG9yIGZyYWdtZW50IGxvYWQgcHJvZ3Jlc3MgYWZ0ZXIgaGFsZiBvZiBleHBlY3RlZCBmcmFnbWVudCBkdXJhdGlvbix0byBzdGFiaWxpemUgYml0cmF0ZVxyXG4gICAgICBpZiAocmVxdWVzdERlbGF5ID4gKDUwMCAqIGZyYWcuZHVyYXRpb24gLyBwbGF5YmFja1JhdGUpKSB7XHJcbiAgICAgICAgbGV0IGxldmVscyA9IGhscy5sZXZlbHMsXHJcbiAgICAgICAgICAgIGxvYWRSYXRlID0gTWF0aC5tYXgoMSwgc3RhdHMuYncgPyBzdGF0cy5idyAvIDggOiBzdGF0cy5sb2FkZWQgKiAxMDAwIC8gcmVxdWVzdERlbGF5KSwgLy8gYnl0ZS9zOyBhdCBsZWFzdCAxIGJ5dGUvcyB0byBhdm9pZCBkaXZpc2lvbiBieSB6ZXJvXHJcbiAgICAgICAgICAgIC8vIGNvbXB1dGUgZXhwZWN0ZWQgZnJhZ21lbnQgbGVuZ3RoIHVzaW5nIGZyYWcgZHVyYXRpb24gYW5kIGxldmVsIGJpdHJhdGUuIGFsc28gZW5zdXJlIHRoYXQgZXhwZWN0ZWQgbGVuIGlzIGd0ZSB0aGFuIGFscmVhZHkgbG9hZGVkIHNpemVcclxuICAgICAgICAgICAgbGV2ZWwgPSBsZXZlbHNbZnJhZy5sZXZlbF0sXHJcbiAgICAgICAgICAgIGxldmVsQml0cmF0ZSA9IGxldmVsLnJlYWxCaXRyYXRlID8gTWF0aC5tYXgobGV2ZWwucmVhbEJpdHJhdGUsbGV2ZWwuYml0cmF0ZSkgOiBsZXZlbC5iaXRyYXRlLFxyXG4gICAgICAgICAgICBleHBlY3RlZExlbiA9IHN0YXRzLnRvdGFsID8gc3RhdHMudG90YWwgOiBNYXRoLm1heChzdGF0cy5sb2FkZWQsIE1hdGgucm91bmQoZnJhZy5kdXJhdGlvbiAqIGxldmVsQml0cmF0ZSAvIDgpKSxcclxuICAgICAgICAgICAgcG9zID0gdi5jdXJyZW50VGltZSxcclxuICAgICAgICAgICAgZnJhZ0xvYWRlZERlbGF5ID0gKGV4cGVjdGVkTGVuIC0gc3RhdHMubG9hZGVkKSAvIGxvYWRSYXRlLFxyXG4gICAgICAgICAgICBidWZmZXJTdGFydmF0aW9uRGVsYXkgPSAoQnVmZmVySGVscGVyLmJ1ZmZlckluZm8odixwb3MsaGxzLmNvbmZpZy5tYXhCdWZmZXJIb2xlKS5lbmQgLSBwb3MpIC8gcGxheWJhY2tSYXRlO1xyXG4gICAgICAgIC8vIGNvbnNpZGVyIGVtZXJnZW5jeSBzd2l0Y2ggZG93biBvbmx5IGlmIHdlIGhhdmUgbGVzcyB0aGFuIDIgZnJhZyBidWZmZXJlZCBBTkRcclxuICAgICAgICAvLyB0aW1lIHRvIGZpbmlzaCBsb2FkaW5nIGN1cnJlbnQgZnJhZ21lbnQgaXMgYmlnZ2VyIHRoYW4gYnVmZmVyIHN0YXJ2YXRpb24gZGVsYXlcclxuICAgICAgICAvLyBpZSBpZiB3ZSByaXNrIGJ1ZmZlciBzdGFydmF0aW9uIGlmIGJ3IGRvZXMgbm90IGluY3JlYXNlIHF1aWNrbHlcclxuICAgICAgICBpZiAoKGJ1ZmZlclN0YXJ2YXRpb25EZWxheSA8ICgyICogZnJhZy5kdXJhdGlvbiAvIHBsYXliYWNrUmF0ZSkpICYmIChmcmFnTG9hZGVkRGVsYXkgPiBidWZmZXJTdGFydmF0aW9uRGVsYXkpKSB7XHJcbiAgICAgICAgICBsZXQgZnJhZ0xldmVsTmV4dExvYWRlZERlbGF5LCBuZXh0TG9hZExldmVsO1xyXG4gICAgICAgICAgLy8gbGV0cyBpdGVyYXRlIHRocm91Z2ggbG93ZXIgbGV2ZWwgYW5kIHRyeSB0byBmaW5kIHRoZSBiaWdnZXN0IG9uZSB0aGF0IGNvdWxkIGF2b2lkIHJlYnVmZmVyaW5nXHJcbiAgICAgICAgICAvLyB3ZSBzdGFydCBmcm9tIGN1cnJlbnQgbGV2ZWwgLSAxIGFuZCB3ZSBzdGVwIGRvd24gLCB1bnRpbCB3ZSBmaW5kIGEgbWF0Y2hpbmcgbGV2ZWxcclxuICAgICAgICAgIGZvciAobmV4dExvYWRMZXZlbCA9IGZyYWcubGV2ZWwgLSAxIDsgbmV4dExvYWRMZXZlbCA+IG1pbkF1dG9MZXZlbCA7IG5leHRMb2FkTGV2ZWwtLSkge1xyXG4gICAgICAgICAgICAvLyBjb21wdXRlIHRpbWUgdG8gbG9hZCBuZXh0IGZyYWdtZW50IGF0IGxvd2VyIGxldmVsXHJcbiAgICAgICAgICAgIC8vIDAuOCA6IGNvbnNpZGVyIG9ubHkgODAlIG9mIGN1cnJlbnQgYncgdG8gYmUgY29uc2VydmF0aXZlXHJcbiAgICAgICAgICAgIC8vIDggPSBiaXRzIHBlciBieXRlIChicHMvQnBzKVxyXG4gICAgICAgICAgICBsZXQgbGV2ZWxOZXh0Qml0cmF0ZSA9IGxldmVsc1tuZXh0TG9hZExldmVsXS5yZWFsQml0cmF0ZSA/IE1hdGgubWF4KGxldmVsc1tuZXh0TG9hZExldmVsXS5yZWFsQml0cmF0ZSxsZXZlbHNbbmV4dExvYWRMZXZlbF0uYml0cmF0ZSkgOiBsZXZlbHNbbmV4dExvYWRMZXZlbF0uYml0cmF0ZTtcclxuICAgICAgICAgICAgZnJhZ0xldmVsTmV4dExvYWRlZERlbGF5ID0gZnJhZy5kdXJhdGlvbiAqIGxldmVsTmV4dEJpdHJhdGUgLyAoOCAqIDAuOCAqIGxvYWRSYXRlKTtcclxuICAgICAgICAgICAgaWYgKGZyYWdMZXZlbE5leHRMb2FkZWREZWxheSA8IGJ1ZmZlclN0YXJ2YXRpb25EZWxheSkge1xyXG4gICAgICAgICAgICAgIC8vIHdlIGZvdW5kIGEgbG93ZXIgbGV2ZWwgdGhhdCBiZSByZWJ1ZmZlcmluZyBmcmVlIHdpdGggY3VycmVudCBlc3RpbWF0ZWQgYncgIVxyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICAvLyBvbmx5IGVtZXJnZW5jeSBzd2l0Y2ggZG93biBpZiBpdCB0YWtlcyBsZXNzIHRpbWUgdG8gbG9hZCBuZXcgZnJhZ21lbnQgYXQgbG93ZXN0IGxldmVsIGluc3RlYWRcclxuICAgICAgICAgIC8vIG9mIGZpbmlzaGluZyBsb2FkaW5nIGN1cnJlbnQgb25lIC4uLlxyXG4gICAgICAgICAgaWYgKGZyYWdMZXZlbE5leHRMb2FkZWREZWxheSA8IGZyYWdMb2FkZWREZWxheSkge1xyXG4gICAgICAgICAgICBsb2dnZXIud2FybihgbG9hZGluZyB0b28gc2xvdywgYWJvcnQgZnJhZ21lbnQgbG9hZGluZyBhbmQgc3dpdGNoIHRvIGxldmVsICR7bmV4dExvYWRMZXZlbH06ZnJhZ0xvYWRlZERlbGF5WyR7bmV4dExvYWRMZXZlbH1dPGZyYWdMb2FkZWREZWxheVske2ZyYWcubGV2ZWwtMX1dO2J1ZmZlclN0YXJ2YXRpb25EZWxheToke2ZyYWdMZXZlbE5leHRMb2FkZWREZWxheS50b0ZpeGVkKDEpfTwke2ZyYWdMb2FkZWREZWxheS50b0ZpeGVkKDEpfToke2J1ZmZlclN0YXJ2YXRpb25EZWxheS50b0ZpeGVkKDEpfWApO1xyXG4gICAgICAgICAgICAvLyBmb3JjZSBuZXh0IGxvYWQgbGV2ZWwgaW4gYXV0byBtb2RlXHJcbiAgICAgICAgICAgIGhscy5uZXh0TG9hZExldmVsID0gbmV4dExvYWRMZXZlbDtcclxuICAgICAgICAgICAgLy8gdXBkYXRlIGJ3IGVzdGltYXRlIGZvciB0aGlzIGZyYWdtZW50IGJlZm9yZSBjYW5jZWxsaW5nIGxvYWQgKHRoaXMgd2lsbCBoZWxwIHJlZHVjaW5nIHRoZSBidylcclxuICAgICAgICAgICAgdGhpcy5fYndFc3RpbWF0b3Iuc2FtcGxlKHJlcXVlc3REZWxheSxzdGF0cy5sb2FkZWQpO1xyXG4gICAgICAgICAgICAvL2Fib3J0IGZyYWdtZW50IGxvYWRpbmdcclxuICAgICAgICAgICAgbG9hZGVyLmFib3J0KCk7XHJcbiAgICAgICAgICAgIC8vIHN0b3AgYWJhbmRvbiBydWxlcyB0aW1lclxyXG4gICAgICAgICAgICB0aGlzLmNsZWFyVGltZXIoKTtcclxuICAgICAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnQuRlJBR19MT0FEX0VNRVJHRU5DWV9BQk9SVEVELCB7ZnJhZzogZnJhZywgc3RhdHM6IHN0YXRzIH0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgb25GcmFnTG9hZGVkKGRhdGEpIHtcclxuICAgIGxldCBmcmFnID0gZGF0YS5mcmFnO1xyXG4gICAgaWYgKGZyYWcudHlwZSA9PT0gJ21haW4nICYmICFpc05hTihmcmFnLnNuKSkge1xyXG4gICAgICAvLyBzdG9wIG1vbml0b3JpbmcgYncgb25jZSBmcmFnIGxvYWRlZFxyXG4gICAgICB0aGlzLmNsZWFyVGltZXIoKTtcclxuICAgICAgLy8gc3RvcmUgbGV2ZWwgaWQgYWZ0ZXIgc3VjY2Vzc2Z1bCBmcmFnbWVudCBsb2FkXHJcbiAgICAgIHRoaXMubGFzdExvYWRlZEZyYWdMZXZlbCA9IGZyYWcubGV2ZWw7XHJcbiAgICAgIC8vIHJlc2V0IGZvcmNlZCBhdXRvIGxldmVsIHZhbHVlIHNvIHRoYXQgbmV4dCBsZXZlbCB3aWxsIGJlIHNlbGVjdGVkXHJcbiAgICAgIHRoaXMuX25leHRBdXRvTGV2ZWwgPSAtMTtcclxuXHJcbiAgICAgIC8vIGNvbXB1dGUgbGV2ZWwgYXZlcmFnZSBiaXRyYXRlXHJcbiAgICAgIGlmICh0aGlzLmhscy5jb25maWcuYWJyTWF4V2l0aFJlYWxCaXRyYXRlKSB7XHJcbiAgICAgICAgY29uc3QgbGV2ZWwgPSB0aGlzLmhscy5sZXZlbHNbZnJhZy5sZXZlbF07XHJcbiAgICAgICAgbGV0IGxvYWRlZEJ5dGVzID0gKGxldmVsLmxvYWRlZCA/IGxldmVsLmxvYWRlZC5ieXRlcyA6IDApICsgZGF0YS5zdGF0cy5sb2FkZWQ7XHJcbiAgICAgICAgbGV0IGxvYWRlZER1cmF0aW9uID0gKGxldmVsLmxvYWRlZCA/IGxldmVsLmxvYWRlZC5kdXJhdGlvbiA6IDApICsgZGF0YS5mcmFnLmR1cmF0aW9uO1xyXG4gICAgICAgIGxldmVsLmxvYWRlZCA9IHsgYnl0ZXMgOiBsb2FkZWRCeXRlcywgZHVyYXRpb24gOiBsb2FkZWREdXJhdGlvbiB9O1xyXG4gICAgICAgIGxldmVsLnJlYWxCaXRyYXRlID0gTWF0aC5yb3VuZCg4KmxvYWRlZEJ5dGVzL2xvYWRlZER1cmF0aW9uKTtcclxuICAgICAgfVxyXG4gICAgICAvLyBpZiBmcmFnbWVudCBoYXMgYmVlbiBsb2FkZWQgdG8gcGVyZm9ybSBhIGJpdHJhdGUgdGVzdCxcclxuICAgICAgaWYgKGRhdGEuZnJhZy5iaXRyYXRlVGVzdCkge1xyXG4gICAgICAgIGxldCBzdGF0cyA9IGRhdGEuc3RhdHM7XHJcbiAgICAgICAgc3RhdHMudHBhcnNlZCA9IHN0YXRzLnRidWZmZXJlZCA9IHN0YXRzLnRsb2FkO1xyXG4gICAgICAgIHRoaXMub25GcmFnQnVmZmVyZWQoZGF0YSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIG9uRnJhZ0J1ZmZlcmVkKGRhdGEpIHtcclxuICAgIHZhciBzdGF0cyA9IGRhdGEuc3RhdHMsIGZyYWcgPSBkYXRhLmZyYWc7XHJcbiAgICAvLyBvbmx5IHVwZGF0ZSBzdGF0cyBvbiBmaXJzdCBmcmFnIGJ1ZmZlcmluZ1xyXG4gICAgLy8gaWYgc2FtZSBmcmFnIGlzIGxvYWRlZCBtdWx0aXBsZSB0aW1lcywgaXQgbWlnaHQgYmUgaW4gYnJvd3NlciBjYWNoZSwgYW5kIGxvYWRlZCBxdWlja2x5XHJcbiAgICAvLyBhbmQgbGVhZGluZyB0byB3cm9uZyBidyBlc3RpbWF0aW9uXHJcbiAgICAvLyBvbiBiaXRyYXRlIHRlc3QsIGFsc28gb25seSB1cGRhdGUgc3RhdHMgb25jZSAoaWYgdGxvYWQgPSB0YnVmZmVyZWQgPT0gb24gRlJBR19MT0FERUQpXHJcbiAgICBpZiAoc3RhdHMuYWJvcnRlZCAhPT0gdHJ1ZSAmJiBmcmFnLmxvYWRDb3VudGVyID09PSAxICYmIGZyYWcudHlwZSA9PT0gJ21haW4nICYmICFpc05hTihmcmFnLnNuKSAmJiAoKCFmcmFnLmJpdHJhdGVUZXN0IHx8IHN0YXRzLnRsb2FkID09PSBzdGF0cy50YnVmZmVyZWQpKSkge1xyXG4gICAgICAvLyB1c2UgdHBhcnNlZC10cmVxdWVzdCBpbnN0ZWFkIG9mIHRidWZmZXJlZC10cmVxdWVzdCB0byBjb21wdXRlIGZyYWdMb2FkaW5nUHJvY2Vzc2luZzsgcmF0aW9uYWxlIGlzIHRoYXQgIGJ1ZmZlciBhcHBlbmRpbmcgb25seSBoYXBwZW5zIG9uY2UgbWVkaWEgaXMgYXR0YWNoZWRcclxuICAgICAgLy8gaW4gY2FzZSB3ZSB1c2UgY29uZmlnLnN0YXJ0RnJhZ1ByZWZldGNoIHdoaWxlIG1lZGlhIGlzIG5vdCBhdHRhY2hlZCB5ZXQsIGZyYWdtZW50IG1pZ2h0IGJlIHBhcnNlZCB3aGlsZSBtZWRpYSBub3QgYXR0YWNoZWQgeWV0LCBidXQgaXQgd2lsbCBvbmx5IGJlIGJ1ZmZlcmVkIG9uIG1lZGlhIGF0dGFjaGVkXHJcbiAgICAgIC8vIGFzIGEgY29uc2VxdWVuY2UgaXQgY291bGQgaGFwcGVuIHJlYWxseSBsYXRlIGluIHRoZSBwcm9jZXNzLiBtZWFuaW5nIHRoYXQgYXBwZW5kaW5nIGR1cmF0aW9uIG1pZ2h0IGFwcGVhcnMgaHVnZSAuLi4gbGVhZGluZyB0byB1bmRlcmVzdGltYXRlZCB0aHJvdWdocHV0IGVzdGltYXRpb25cclxuICAgICAgbGV0IGZyYWdMb2FkaW5nUHJvY2Vzc2luZ01zID0gc3RhdHMudHBhcnNlZCAtIHN0YXRzLnRyZXF1ZXN0O1xyXG4gICAgICBsb2dnZXIubG9nKGBsYXRlbmN5L2xvYWRpbmcvcGFyc2luZy9hcHBlbmQva2Jwczoke01hdGgucm91bmQoc3RhdHMudGZpcnN0LXN0YXRzLnRyZXF1ZXN0KX0vJHtNYXRoLnJvdW5kKHN0YXRzLnRsb2FkLXN0YXRzLnRmaXJzdCl9LyR7TWF0aC5yb3VuZChzdGF0cy50cGFyc2VkLXN0YXRzLnRsb2FkKX0vJHtNYXRoLnJvdW5kKHN0YXRzLnRidWZmZXJlZC1zdGF0cy50cGFyc2VkKX0vJHtNYXRoLnJvdW5kKDgqc3RhdHMubG9hZGVkLyhzdGF0cy50YnVmZmVyZWQtc3RhdHMudHJlcXVlc3QpKX1gKTtcclxuICAgICAgdGhpcy5fYndFc3RpbWF0b3Iuc2FtcGxlKGZyYWdMb2FkaW5nUHJvY2Vzc2luZ01zLHN0YXRzLmxvYWRlZCk7XHJcbiAgICAgIHN0YXRzLmJ3RXN0aW1hdGUgPSB0aGlzLl9id0VzdGltYXRvci5nZXRFc3RpbWF0ZSgpO1xyXG4gICAgICAvLyBpZiBmcmFnbWVudCBoYXMgYmVlbiBsb2FkZWQgdG8gcGVyZm9ybSBhIGJpdHJhdGUgdGVzdCwgKGhscy5zdGFydExldmVsID0gLTEpLCBzdG9yZSBiaXRyYXRlIHRlc3QgZGVsYXkgZHVyYXRpb25cclxuICAgICAgaWYgKGZyYWcuYml0cmF0ZVRlc3QpIHtcclxuICAgICAgICB0aGlzLmJpdHJhdGVUZXN0RGVsYXkgPSBmcmFnTG9hZGluZ1Byb2Nlc3NpbmdNcy8xMDAwO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMuYml0cmF0ZVRlc3REZWxheSA9IDA7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIG9uRXJyb3IoZGF0YSkge1xyXG4gICAgLy8gc3RvcCB0aW1lciBpbiBjYXNlIG9mIGZyYWcgbG9hZGluZyBlcnJvclxyXG4gICAgc3dpdGNoKGRhdGEuZGV0YWlscykge1xyXG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5GUkFHX0xPQURfRVJST1I6XHJcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkZSQUdfTE9BRF9USU1FT1VUOlxyXG4gICAgICAgIHRoaXMuY2xlYXJUaW1lcigpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBkZWZhdWx0OlxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiBjbGVhclRpbWVyKCkge1xyXG4gICAgY2xlYXJJbnRlcnZhbCh0aGlzLnRpbWVyKTtcclxuICAgIHRoaXMudGltZXIgPSBudWxsO1xyXG4gfVxyXG5cclxuICAvLyByZXR1cm4gbmV4dCBhdXRvIGxldmVsXHJcbiAgZ2V0IG5leHRBdXRvTGV2ZWwoKSB7XHJcbiAgICBjb25zdCBmb3JjZWRBdXRvTGV2ZWwgPSB0aGlzLl9uZXh0QXV0b0xldmVsO1xyXG4gICAgY29uc3QgYndFc3RpbWF0b3IgPSB0aGlzLl9id0VzdGltYXRvcjtcclxuICAgIC8vIGluIGNhc2UgbmV4dCBhdXRvIGxldmVsIGhhcyBiZWVuIGZvcmNlZCwgYW5kIGJ3IG5vdCBhdmFpbGFibGUgb3Igbm90IHJlbGlhYmxlLCByZXR1cm4gZm9yY2VkIHZhbHVlXHJcbiAgICBpZiAoZm9yY2VkQXV0b0xldmVsICE9PSAtMSAmJiAoIWJ3RXN0aW1hdG9yIHx8ICFid0VzdGltYXRvci5jYW5Fc3RpbWF0ZSgpKSkge1xyXG4gICAgICByZXR1cm4gZm9yY2VkQXV0b0xldmVsO1xyXG4gICAgfVxyXG4gICAgLy8gY29tcHV0ZSBuZXh0IGxldmVsIHVzaW5nIEFCUiBsb2dpY1xyXG4gICAgbGV0IG5leHRBQlJBdXRvTGV2ZWwgPSB0aGlzLl9uZXh0QUJSQXV0b0xldmVsO1xyXG4gICAgLy8gaWYgZm9yY2VkIGF1dG8gbGV2ZWwgaGFzIGJlZW4gZGVmaW5lZCwgdXNlIGl0IHRvIGNhcCBBQlIgY29tcHV0ZWQgcXVhbGl0eSBsZXZlbFxyXG4gICAgaWYgKGZvcmNlZEF1dG9MZXZlbCAhPT0gLTEpIHtcclxuICAgICAgbmV4dEFCUkF1dG9MZXZlbCA9IE1hdGgubWluKGZvcmNlZEF1dG9MZXZlbCxuZXh0QUJSQXV0b0xldmVsKTtcclxuICAgIH1cclxuICAgIHJldHVybiBuZXh0QUJSQXV0b0xldmVsO1xyXG4gIH1cclxuICBnZXQgX25leHRBQlJBdXRvTGV2ZWwoKSB7XHJcbiAgICB2YXIgaGxzID0gdGhpcy5obHMsIG1heEF1dG9MZXZlbCA9IGhscy5tYXhBdXRvTGV2ZWwsIGxldmVscyA9IGhscy5sZXZlbHMsIGNvbmZpZyA9IGhscy5jb25maWcsIG1pbkF1dG9MZXZlbCA9IGhscy5taW5BdXRvTGV2ZWw7XHJcbiAgICBjb25zdCB2ID0gaGxzLm1lZGlhLFxyXG4gICAgICAgICAgY3VycmVudExldmVsID0gdGhpcy5sYXN0TG9hZGVkRnJhZ0xldmVsLFxyXG4gICAgICAgICAgY3VycmVudEZyYWdEdXJhdGlvbiA9IHRoaXMuZnJhZ0N1cnJlbnQgPyB0aGlzLmZyYWdDdXJyZW50LmR1cmF0aW9uIDogMCxcclxuICAgICAgICAgIHBvcyA9ICh2ID8gdi5jdXJyZW50VGltZSA6IDApLFxyXG4gICAgICAgICAgLy8gcGxheWJhY2tSYXRlIGlzIHRoZSBhYnNvbHV0ZSB2YWx1ZSBvZiB0aGUgcGxheWJhY2sgcmF0ZTsgaWYgdi5wbGF5YmFja1JhdGUgaXMgMCwgd2UgdXNlIDEgdG8gbG9hZCBhc1xyXG4gICAgICAgICAgLy8gaWYgd2UncmUgcGxheWluZyBiYWNrIGF0IHRoZSBub3JtYWwgcmF0ZS5cclxuICAgICAgICAgIHBsYXliYWNrUmF0ZSA9ICgodiAmJiAodi5wbGF5YmFja1JhdGUgIT09IDApKSA/IE1hdGguYWJzKHYucGxheWJhY2tSYXRlKSA6IDEuMCksXHJcbiAgICAgICAgICBhdmdidyA9IHRoaXMuX2J3RXN0aW1hdG9yID8gdGhpcy5fYndFc3RpbWF0b3IuZ2V0RXN0aW1hdGUoKSA6IGNvbmZpZy5hYnJFd21hRGVmYXVsdEVzdGltYXRlLFxyXG4gICAgICAgICAgLy8gYnVmZmVyU3RhcnZhdGlvbkRlbGF5IGlzIHRoZSB3YWxsLWNsb2NrIHRpbWUgbGVmdCB1bnRpbCB0aGUgcGxheWJhY2sgYnVmZmVyIGlzIGV4aGF1c3RlZC5cclxuICAgICAgICAgIGJ1ZmZlclN0YXJ2YXRpb25EZWxheSA9IChCdWZmZXJIZWxwZXIuYnVmZmVySW5mbyh2LCBwb3MsIGNvbmZpZy5tYXhCdWZmZXJIb2xlKS5lbmQgLSBwb3MpIC8gcGxheWJhY2tSYXRlO1xyXG5cclxuICAgIC8vIEZpcnN0LCBsb29rIHRvIHNlZSBpZiB3ZSBjYW4gZmluZCBhIGxldmVsIG1hdGNoaW5nIHdpdGggb3VyIGF2ZyBiYW5kd2lkdGggQU5EIHRoYXQgY291bGQgYWxzbyBndWFyYW50ZWUgbm8gcmVidWZmZXJpbmcgYXQgYWxsXHJcbiAgICBsZXQgYmVzdExldmVsID0gdGhpcy5fZmluZEJlc3RMZXZlbChjdXJyZW50TGV2ZWwsY3VycmVudEZyYWdEdXJhdGlvbixhdmdidyxtaW5BdXRvTGV2ZWwsbWF4QXV0b0xldmVsLGJ1ZmZlclN0YXJ2YXRpb25EZWxheSxjb25maWcuYWJyQmFuZFdpZHRoRmFjdG9yLGNvbmZpZy5hYnJCYW5kV2lkdGhVcEZhY3RvcixsZXZlbHMpO1xyXG4gICAgaWYgKGJlc3RMZXZlbCA+PSAwKSB7XHJcbiAgICAgIHJldHVybiBiZXN0TGV2ZWw7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBsb2dnZXIudHJhY2UoJ3JlYnVmZmVyaW5nIGV4cGVjdGVkIHRvIGhhcHBlbiwgbGV0cyB0cnkgdG8gZmluZCBhIHF1YWxpdHkgbGV2ZWwgbWluaW1pemluZyB0aGUgcmVidWZmZXJpbmcnKTtcclxuICAgICAgLy8gbm90IHBvc3NpYmxlIHRvIGdldCByaWQgb2YgcmVidWZmZXJpbmcgLi4uIGxldCdzIHRyeSB0byBmaW5kIGxldmVsIHRoYXQgd2lsbCBndWFyYW50ZWUgbGVzcyB0aGFuIG1heFN0YXJ2YXRpb25EZWxheSBvZiByZWJ1ZmZlcmluZ1xyXG4gICAgICAvLyBpZiBubyBtYXRjaGluZyBsZXZlbCBmb3VuZCwgbG9naWMgd2lsbCByZXR1cm4gMFxyXG4gICAgICBsZXQgbWF4U3RhcnZhdGlvbkRlbGF5ID0gY3VycmVudEZyYWdEdXJhdGlvbiA/IE1hdGgubWluKGN1cnJlbnRGcmFnRHVyYXRpb24sY29uZmlnLm1heFN0YXJ2YXRpb25EZWxheSkgOiBjb25maWcubWF4U3RhcnZhdGlvbkRlbGF5LFxyXG4gICAgICAgICAgYndGYWN0b3IgPSBjb25maWcuYWJyQmFuZFdpZHRoRmFjdG9yLFxyXG4gICAgICAgICAgYndVcEZhY3RvciA9IGNvbmZpZy5hYnJCYW5kV2lkdGhVcEZhY3RvcjtcclxuICAgICAgaWYgKGJ1ZmZlclN0YXJ2YXRpb25EZWxheSA9PT0gMCkge1xyXG4gICAgICAgIC8vIGluIGNhc2UgYnVmZmVyIGlzIGVtcHR5LCBsZXQncyBjaGVjayBpZiBwcmV2aW91cyBmcmFnbWVudCB3YXMgbG9hZGVkIHRvIHBlcmZvcm0gYSBiaXRyYXRlIHRlc3RcclxuICAgICAgICBsZXQgYml0cmF0ZVRlc3REZWxheSA9IHRoaXMuYml0cmF0ZVRlc3REZWxheTtcclxuICAgICAgICBpZiAoYml0cmF0ZVRlc3REZWxheSkge1xyXG4gICAgICAgICAgLy8gaWYgaXQgaXMgdGhlIGNhc2UsIHRoZW4gd2UgbmVlZCB0byBhZGp1c3Qgb3VyIG1heCBzdGFydmF0aW9uIGRlbGF5IHVzaW5nIG1heExvYWRpbmdEZWxheSBjb25maWcgdmFsdWVcclxuICAgICAgICAgIC8vIG1heCB2aWRlbyBsb2FkaW5nIGRlbGF5IHVzZWQgaW4gIGF1dG9tYXRpYyBzdGFydCBsZXZlbCBzZWxlY3Rpb24gOlxyXG4gICAgICAgICAgLy8gaW4gdGhhdCBtb2RlIEFCUiBjb250cm9sbGVyIHdpbGwgZW5zdXJlIHRoYXQgdmlkZW8gbG9hZGluZyB0aW1lIChpZSB0aGUgdGltZSB0byBmZXRjaCB0aGUgZmlyc3QgZnJhZ21lbnQgYXQgbG93ZXN0IHF1YWxpdHkgbGV2ZWwgK1xyXG4gICAgICAgICAgLy8gdGhlIHRpbWUgdG8gZmV0Y2ggdGhlIGZyYWdtZW50IGF0IHRoZSBhcHByb3ByaWF0ZSBxdWFsaXR5IGxldmVsIGlzIGxlc3MgdGhhbiBgYGBtYXhMb2FkaW5nRGVsYXlgYGAgKVxyXG4gICAgICAgICAgLy8gY2FwIG1heExvYWRpbmdEZWxheSBhbmQgZW5zdXJlIGl0IGlzIG5vdCBiaWdnZXIgJ3RoYW4gYml0cmF0ZSB0ZXN0JyBmcmFnIGR1cmF0aW9uXHJcbiAgICAgICAgICBjb25zdCBtYXhMb2FkaW5nRGVsYXkgPSBjdXJyZW50RnJhZ0R1cmF0aW9uID8gTWF0aC5taW4oY3VycmVudEZyYWdEdXJhdGlvbixjb25maWcubWF4TG9hZGluZ0RlbGF5KSA6IGNvbmZpZy5tYXhMb2FkaW5nRGVsYXk7XHJcbiAgICAgICAgICBtYXhTdGFydmF0aW9uRGVsYXkgPSBtYXhMb2FkaW5nRGVsYXkgLSBiaXRyYXRlVGVzdERlbGF5O1xyXG4gICAgICAgICAgbG9nZ2VyLnRyYWNlKGBiaXRyYXRlIHRlc3QgdG9vayAke01hdGgucm91bmQoMTAwMCpiaXRyYXRlVGVzdERlbGF5KX1tcywgc2V0IGZpcnN0IGZyYWdtZW50IG1heCBmZXRjaER1cmF0aW9uIHRvICR7TWF0aC5yb3VuZCgxMDAwKm1heFN0YXJ2YXRpb25EZWxheSl9IG1zYCk7XHJcbiAgICAgICAgICAvLyBkb24ndCB1c2UgY29uc2VydmF0aXZlIGZhY3RvciBvbiBiaXRyYXRlIHRlc3RcclxuICAgICAgICAgIGJ3RmFjdG9yID0gYndVcEZhY3RvciA9IDE7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGJlc3RMZXZlbCA9IHRoaXMuX2ZpbmRCZXN0TGV2ZWwoY3VycmVudExldmVsLGN1cnJlbnRGcmFnRHVyYXRpb24sYXZnYncsbWluQXV0b0xldmVsLG1heEF1dG9MZXZlbCxidWZmZXJTdGFydmF0aW9uRGVsYXkrbWF4U3RhcnZhdGlvbkRlbGF5LGJ3RmFjdG9yLGJ3VXBGYWN0b3IsbGV2ZWxzKTtcclxuICAgICAgcmV0dXJuIE1hdGgubWF4KGJlc3RMZXZlbCwwKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIF9maW5kQmVzdExldmVsKGN1cnJlbnRMZXZlbCxjdXJyZW50RnJhZ0R1cmF0aW9uLGN1cnJlbnRCdyxtaW5BdXRvTGV2ZWwsbWF4QXV0b0xldmVsLG1heEZldGNoRHVyYXRpb24sYndGYWN0b3IsYndVcEZhY3RvcixsZXZlbHMpIHtcclxuICAgIGZvciAobGV0IGkgPSBtYXhBdXRvTGV2ZWw7IGkgPj0gbWluQXV0b0xldmVsOyBpLS0pIHtcclxuICAgICAgbGV0IGxldmVsSW5mbyA9IGxldmVsc1tpXSxcclxuICAgICAgICAgIGxldmVsRGV0YWlscyA9IGxldmVsSW5mby5kZXRhaWxzLFxyXG4gICAgICAgICAgYXZnRHVyYXRpb24gPSBsZXZlbERldGFpbHMgPyBsZXZlbERldGFpbHMudG90YWxkdXJhdGlvbi9sZXZlbERldGFpbHMuZnJhZ21lbnRzLmxlbmd0aCA6IGN1cnJlbnRGcmFnRHVyYXRpb24sXHJcbiAgICAgICAgICBsaXZlID0gbGV2ZWxEZXRhaWxzID8gbGV2ZWxEZXRhaWxzLmxpdmUgOiBmYWxzZSxcclxuICAgICAgICAgIGFkanVzdGVkYnc7XHJcbiAgICAvLyBmb2xsb3cgYWxnb3JpdGhtIGNhcHR1cmVkIGZyb20gc3RhZ2VmcmlnaHQgOlxyXG4gICAgLy8gaHR0cHM6Ly9hbmRyb2lkLmdvb2dsZXNvdXJjZS5jb20vcGxhdGZvcm0vZnJhbWV3b3Jrcy9hdi8rL21hc3Rlci9tZWRpYS9saWJzdGFnZWZyaWdodC9odHRwbGl2ZS9MaXZlU2Vzc2lvbi5jcHBcclxuICAgIC8vIFBpY2sgdGhlIGhpZ2hlc3QgYmFuZHdpZHRoIHN0cmVhbSBiZWxvdyBvciBlcXVhbCB0byBlc3RpbWF0ZWQgYmFuZHdpZHRoLlxyXG4gICAgLy8gY29uc2lkZXIgb25seSA4MCUgb2YgdGhlIGF2YWlsYWJsZSBiYW5kd2lkdGgsIGJ1dCBpZiB3ZSBhcmUgc3dpdGNoaW5nIHVwLFxyXG4gICAgLy8gYmUgZXZlbiBtb3JlIGNvbnNlcnZhdGl2ZSAoNzAlKSB0byBhdm9pZCBvdmVyZXN0aW1hdGluZyBhbmQgaW1tZWRpYXRlbHlcclxuICAgIC8vIHN3aXRjaGluZyBiYWNrLlxyXG4gICAgICBpZiAoaSA8PSBjdXJyZW50TGV2ZWwpIHtcclxuICAgICAgICBhZGp1c3RlZGJ3ID0gYndGYWN0b3IgKiBjdXJyZW50Qnc7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgYWRqdXN0ZWRidyA9IGJ3VXBGYWN0b3IgKiBjdXJyZW50Qnc7XHJcbiAgICAgIH1cclxuICAgICAgY29uc3QgYml0cmF0ZSA9IGxldmVsc1tpXS5yZWFsQml0cmF0ZSA/IE1hdGgubWF4KGxldmVsc1tpXS5yZWFsQml0cmF0ZSxsZXZlbHNbaV0uYml0cmF0ZSkgOiBsZXZlbHNbaV0uYml0cmF0ZSxcclxuICAgICAgICAgICAgZmV0Y2hEdXJhdGlvbiA9IGJpdHJhdGUgKiBhdmdEdXJhdGlvbiAvIGFkanVzdGVkYnc7XHJcblxyXG4gICAgbG9nZ2VyLnRyYWNlKGBsZXZlbC9hZGp1c3RlZGJ3L2JpdHJhdGUvYXZnRHVyYXRpb24vbWF4RmV0Y2hEdXJhdGlvbi9mZXRjaER1cmF0aW9uOiAke2l9LyR7TWF0aC5yb3VuZChhZGp1c3RlZGJ3KX0vJHtiaXRyYXRlfS8ke2F2Z0R1cmF0aW9ufS8ke21heEZldGNoRHVyYXRpb259LyR7ZmV0Y2hEdXJhdGlvbn1gKTtcclxuICAgICAgLy8gaWYgYWRqdXN0ZWQgYncgaXMgZ3JlYXRlciB0aGFuIGxldmVsIGJpdHJhdGUgQU5EXHJcbiAgICAgIGlmIChhZGp1c3RlZGJ3ID4gYml0cmF0ZSAmJlxyXG4gICAgICAvLyBmcmFnbWVudCBmZXRjaER1cmF0aW9uIHVua25vd24gT1IgbGl2ZSBzdHJlYW0gT1IgZnJhZ21lbnQgZmV0Y2hEdXJhdGlvbiBsZXNzIHRoYW4gbWF4IGFsbG93ZWQgZmV0Y2ggZHVyYXRpb24sIHRoZW4gdGhpcyBsZXZlbCBtYXRjaGVzXHJcbiAgICAgIC8vIHdlIGRvbid0IGFjY291bnQgZm9yIG1heCBGZXRjaCBEdXJhdGlvbiBmb3IgbGl2ZSBzdHJlYW1zLCB0aGlzIGlzIHRvIGF2b2lkIHN3aXRjaGluZyBkb3duIHdoZW4gbmVhciB0aGUgZWRnZSBvZiBsaXZlIHNsaWRpbmcgd2luZG93IC4uLlxyXG4gICAgICAvLyBzcGVjaWFsIGNhc2UgdG8gc3VwcG9ydCBzdGFydExldmVsID0gLTEgKGJpdHJhdGVUZXN0KSBvbiBsaXZlIHN0cmVhbXMgOiBpbiB0aGF0IGNhc2Ugd2Ugc2hvdWxkIG5vdCBleGl0IGxvb3Agc28gdGhhdCBfZmluZEJlc3RMZXZlbCB3aWxsIHJldHVybiAtMVxyXG4gICAgICAgICghZmV0Y2hEdXJhdGlvbiB8fMKgKGxpdmUgICYmICF0aGlzLmJpdHJhdGVUZXN0RGVsYXkpIHx8IGZldGNoRHVyYXRpb24gPCBtYXhGZXRjaER1cmF0aW9uKSApIHtcclxuICAgICAgICAvLyBhcyB3ZSBhcmUgbG9vcGluZyBmcm9tIGhpZ2hlc3QgdG8gbG93ZXN0LCB0aGlzIHdpbGwgcmV0dXJuIHRoZSBiZXN0IGFjaGlldmFibGUgcXVhbGl0eSBsZXZlbFxyXG4gICAgICAgIHJldHVybiBpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBub3QgZW5vdWdoIHRpbWUgYnVkZ2V0IGV2ZW4gd2l0aCBxdWFsaXR5IGxldmVsIDAgLi4uIHJlYnVmZmVyaW5nIG1pZ2h0IGhhcHBlblxyXG4gICAgcmV0dXJuIC0xO1xyXG4gIH1cclxuXHJcbiAgc2V0IG5leHRBdXRvTGV2ZWwobmV4dExldmVsKSB7XHJcbiAgICB0aGlzLl9uZXh0QXV0b0xldmVsID0gbmV4dExldmVsO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgQWJyQ29udHJvbGxlcjtcclxuXHJcbiIsIi8qXHJcbiAqIEF1ZGlvIFN0cmVhbSBDb250cm9sbGVyXHJcbiAqL1xyXG5cclxuaW1wb3J0IEJpbmFyeVNlYXJjaCBmcm9tICcuLi91dGlscy9iaW5hcnktc2VhcmNoJztcclxuaW1wb3J0IEJ1ZmZlckhlbHBlciBmcm9tICcuLi9oZWxwZXIvYnVmZmVyLWhlbHBlcic7XHJcbmltcG9ydCBEZW11eGVyIGZyb20gJy4uL2RlbXV4L2RlbXV4ZXInO1xyXG5pbXBvcnQgRXZlbnQgZnJvbSAnLi4vZXZlbnRzJztcclxuaW1wb3J0IEV2ZW50SGFuZGxlciBmcm9tICcuLi9ldmVudC1oYW5kbGVyJztcclxuaW1wb3J0IExldmVsSGVscGVyIGZyb20gJy4uL2hlbHBlci9sZXZlbC1oZWxwZXInO1xyXG5pbXBvcnQgVGltZVJhbmdlcyBmcm9tICcuLi91dGlscy90aW1lUmFuZ2VzJztcclxuaW1wb3J0IHtFcnJvclR5cGVzLCBFcnJvckRldGFpbHN9IGZyb20gJy4uL2Vycm9ycyc7XHJcbmltcG9ydCB7bG9nZ2VyfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xyXG5pbXBvcnQge2ZpbmRGcmFnV2l0aENDfSBmcm9tICcuLi91dGlscy9kaXNjb250aW51aXRpZXMnO1xyXG5cclxuY29uc3QgU3RhdGUgPSB7XHJcbiAgICBTVE9QUEVEOiAnU1RPUFBFRCcsXHJcbiAgICBTVEFSVElORzogJ1NUQVJUSU5HJyxcclxuICAgIElETEU6ICdJRExFJyxcclxuICAgIFBBVVNFRDogJ1BBVVNFRCcsXHJcbiAgICBLRVlfTE9BRElORzogJ0tFWV9MT0FESU5HJyxcclxuICAgIEZSQUdfTE9BRElORzogJ0ZSQUdfTE9BRElORycsXHJcbiAgICBGUkFHX0xPQURJTkdfV0FJVElOR19SRVRSWTogJ0ZSQUdfTE9BRElOR19XQUlUSU5HX1JFVFJZJyxcclxuICAgIFdBSVRJTkdfVFJBQ0s6ICdXQUlUSU5HX1RSQUNLJyxcclxuICAgIFBBUlNJTkc6ICdQQVJTSU5HJyxcclxuICAgIFBBUlNFRDogJ1BBUlNFRCcsXHJcbiAgICBCVUZGRVJfRkxVU0hJTkc6ICdCVUZGRVJfRkxVU0hJTkcnLFxyXG4gICAgRU5ERUQ6ICdFTkRFRCcsXHJcbiAgICBFUlJPUjogJ0VSUk9SJyxcclxuICAgIFdBSVRJTkdfSU5JVF9QVFM6ICdXQUlUSU5HX0lOSVRfUFRTJ1xyXG59O1xyXG5cclxuY2xhc3MgQXVkaW9TdHJlYW1Db250cm9sbGVyIGV4dGVuZHMgRXZlbnRIYW5kbGVyIHtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihobHMpIHtcclxuICAgICAgICBzdXBlcihobHMsXHJcbiAgICAgICAgICAgIEV2ZW50Lk1FRElBX0FUVEFDSEVELFxyXG4gICAgICAgICAgICBFdmVudC5NRURJQV9ERVRBQ0hJTkcsXHJcbiAgICAgICAgICAgIEV2ZW50LkFVRElPX1RSQUNLU19VUERBVEVELFxyXG4gICAgICAgICAgICBFdmVudC5BVURJT19UUkFDS19TV0lUQ0hJTkcsXHJcbiAgICAgICAgICAgIEV2ZW50LkFVRElPX1RSQUNLX0xPQURFRCxcclxuICAgICAgICAgICAgRXZlbnQuS0VZX0xPQURFRCxcclxuICAgICAgICAgICAgRXZlbnQuRlJBR19MT0FERUQsXHJcbiAgICAgICAgICAgIEV2ZW50LkZSQUdfUEFSU0lOR19JTklUX1NFR01FTlQsXHJcbiAgICAgICAgICAgIEV2ZW50LkZSQUdfUEFSU0lOR19EQVRBLFxyXG4gICAgICAgICAgICBFdmVudC5GUkFHX1BBUlNFRCxcclxuICAgICAgICAgICAgRXZlbnQuRVJST1IsXHJcbiAgICAgICAgICAgIEV2ZW50LkJVRkZFUl9DUkVBVEVELFxyXG4gICAgICAgICAgICBFdmVudC5CVUZGRVJfQVBQRU5ERUQsXHJcbiAgICAgICAgICAgIEV2ZW50LkJVRkZFUl9GTFVTSEVELFxyXG4gICAgICAgICAgICBFdmVudC5JTklUX1BUU19GT1VORCk7XHJcblxyXG4gICAgICAgIHRoaXMuY29uZmlnID0gaGxzLmNvbmZpZztcclxuICAgICAgICB0aGlzLmF1ZGlvQ29kZWNTd2FwID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy50aWNrcyA9IDA7XHJcbiAgICAgICAgdGhpcy5fc3RhdGUgPSBTdGF0ZS5TVE9QUEVEO1xyXG4gICAgICAgIHRoaXMub250aWNrID0gdGhpcy50aWNrLmJpbmQodGhpcyk7XHJcbiAgICAgICAgdGhpcy5pbml0UFRTID0gW107XHJcbiAgICAgICAgdGhpcy53YWl0aW5nRnJhZ21lbnQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMudmlkZW9UcmFja0NDID0gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBkZXN0cm95KCkge1xyXG4gICAgICAgIHRoaXMuc3RvcExvYWQoKTtcclxuICAgICAgICBpZiAodGhpcy50aW1lcikge1xyXG4gICAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMudGltZXIpO1xyXG4gICAgICAgICAgICB0aGlzLnRpbWVyID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgRXZlbnRIYW5kbGVyLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLlNUT1BQRUQ7XHJcbiAgICB9XHJcblxyXG4gICAgLy9TaWduYWwgdGhhdCB2aWRlbyBQVFMgd2FzIGZvdW5kXHJcbiAgICBvbkluaXRQdHNGb3VuZChkYXRhKSB7XHJcbiAgICAgICAgdmFyIGRlbXV4ZXJJZCA9IGRhdGEuaWQsIGNjID0gZGF0YS5mcmFnLmNjLCBpbml0UFRTID0gZGF0YS5pbml0UFRTO1xyXG4gICAgICAgIGlmIChkZW11eGVySWQgPT09ICdtYWluJykge1xyXG4gICAgICAgICAgICAvL0Fsd2F5cyB1cGRhdGUgdGhlIG5ldyBJTklUIFBUU1xyXG4gICAgICAgICAgICAvL0NhbiBjaGFuZ2UgZHVlIGxldmVsIHN3aXRjaFxyXG4gICAgICAgICAgICB0aGlzLmluaXRQVFNbY2NdID0gaW5pdFBUUztcclxuICAgICAgICAgICAgdGhpcy52aWRlb1RyYWNrQ0MgPSBjYztcclxuICAgICAgICAgICAgbG9nZ2VyLmxvZyhgSW5pdFBUUyBmb3IgY2M6JHtjY30gZm91bmQgZnJvbSB2aWRlbyB0cmFjazoke2luaXRQVFN9YCk7XHJcblxyXG4gICAgICAgICAgICAvL0lmIHdlIGFyZSB3YWl0aW5nIHdlIG5lZWQgdG8gZGVtdXgvcmVtdXggdGhlIHdhaXRpbmcgZnJhZ1xyXG4gICAgICAgICAgICAvL1dpdGggdGhlIG5ldyBpbml0UFRTXHJcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlID09PSBTdGF0ZS5XQUlUSU5HX0lOSVRfUFRTKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRpY2soKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBzdGFydExvYWQoc3RhcnRQb3NpdGlvbikge1xyXG4gICAgICAgIGlmICh0aGlzLnRyYWNrcykge1xyXG4gICAgICAgICAgICB2YXIgbGFzdEN1cnJlbnRUaW1lID0gdGhpcy5sYXN0Q3VycmVudFRpbWU7XHJcbiAgICAgICAgICAgIHRoaXMuc3RvcExvYWQoKTtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLnRpbWVyKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRpbWVyID0gc2V0SW50ZXJ2YWwodGhpcy5vbnRpY2ssIDEwMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5mcmFnTG9hZEVycm9yID0gMDtcclxuICAgICAgICAgICAgaWYgKGxhc3RDdXJyZW50VGltZSA+IDAgJiYgc3RhcnRQb3NpdGlvbiA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIGxvZ2dlci5sb2coYGF1ZGlvOm92ZXJyaWRlIHN0YXJ0UG9zaXRpb24gd2l0aCBsYXN0Q3VycmVudFRpbWUgQCR7bGFzdEN1cnJlbnRUaW1lLnRvRml4ZWQoMyl9YCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubGFzdEN1cnJlbnRUaW1lID0gdGhpcy5zdGFydFBvc2l0aW9uID8gdGhpcy5zdGFydFBvc2l0aW9uIDogc3RhcnRQb3NpdGlvbjtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5TVEFSVElORztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLm5leHRMb2FkUG9zaXRpb24gPSB0aGlzLnN0YXJ0UG9zaXRpb24gPSB0aGlzLmxhc3RDdXJyZW50VGltZTtcclxuICAgICAgICAgICAgdGhpcy50aWNrKCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5zdGFydFBvc2l0aW9uID0gc3RhcnRQb3NpdGlvbjtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLlNUT1BQRUQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHN0b3BMb2FkKCkge1xyXG4gICAgICAgIHZhciBmcmFnID0gdGhpcy5mcmFnQ3VycmVudDtcclxuICAgICAgICBpZiAoZnJhZykge1xyXG4gICAgICAgICAgICBpZiAoZnJhZy5sb2FkZXIpIHtcclxuICAgICAgICAgICAgICAgIGZyYWcubG9hZGVyLmFib3J0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5mcmFnQ3VycmVudCA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZnJhZ1ByZXZpb3VzID0gbnVsbDtcclxuICAgICAgICBpZiAodGhpcy5kZW11eGVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGVtdXhlci5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgIHRoaXMuZGVtdXhlciA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5TVE9QUEVEO1xyXG4gICAgfVxyXG5cclxuICAgIHNldCBzdGF0ZShuZXh0U3RhdGUpIHtcclxuICAgICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gbmV4dFN0YXRlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHByZXZpb3VzU3RhdGUgPSB0aGlzLnN0YXRlO1xyXG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IG5leHRTdGF0ZTtcclxuICAgICAgICAgICAgbG9nZ2VyLmxvZyhgYXVkaW8gc3RyZWFtOiR7cHJldmlvdXNTdGF0ZX0tPiR7bmV4dFN0YXRlfWApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBnZXQgc3RhdGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXRlO1xyXG4gICAgfVxyXG5cclxuICAgIHRpY2soKSB7XHJcbiAgICAgICAgdGhpcy50aWNrcysrO1xyXG4gICAgICAgIGlmICh0aGlzLnRpY2tzID09PSAxKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZG9UaWNrKCk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnRpY2tzID4gMSkge1xyXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCh0aGlzLnRpY2ssIDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMudGlja3MgPSAwO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBkb1RpY2soKSB7XHJcbiAgICAgICAgdmFyIHBvcywgdHJhY2ssIHRyYWNrRGV0YWlscywgaGxzID0gdGhpcy5obHMsIGNvbmZpZyA9IGhscy5jb25maWc7XHJcbiAgICAgICAgLy9sb2dnZXIubG9nKCdhdWRpb1N0cmVhbTonICsgdGhpcy5zdGF0ZSk7XHJcbiAgICAgICAgc3dpdGNoICh0aGlzLnN0YXRlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgU3RhdGUuRVJST1I6XHJcbiAgICAgICAgICAgIC8vZG9uJ3QgZG8gYW55dGhpbmcgaW4gZXJyb3Igc3RhdGUgdG8gYXZvaWQgYnJlYWtpbmcgZnVydGhlciAuLi5cclxuICAgICAgICAgICAgY2FzZSBTdGF0ZS5QQVVTRUQ6XHJcbiAgICAgICAgICAgIC8vZG9uJ3QgZG8gYW55dGhpbmcgaW4gcGF1c2VkIHN0YXRlIGVpdGhlciAuLi5cclxuICAgICAgICAgICAgY2FzZSBTdGF0ZS5CVUZGRVJfRkxVU0hJTkc6XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBTdGF0ZS5TVEFSVElORzpcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5XQUlUSU5HX1RSQUNLO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2FkZWRtZXRhZGF0YSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgU3RhdGUuSURMRTpcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRyYWNrcyA9IHRoaXMudHJhY2tzO1xyXG4gICAgICAgICAgICAgICAgLy8gYXVkaW8gdHJhY2tzIG5vdCByZWNlaXZlZCA9PiBleGl0IGxvb3BcclxuICAgICAgICAgICAgICAgIGlmICghdHJhY2tzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBpZiB2aWRlbyBub3QgYXR0YWNoZWQgQU5EXHJcbiAgICAgICAgICAgICAgICAvLyBzdGFydCBmcmFnbWVudCBhbHJlYWR5IHJlcXVlc3RlZCBPUiBzdGFydCBmcmFnIHByZWZldGNoIGRpc2FibGVcclxuICAgICAgICAgICAgICAgIC8vIGV4aXQgbG9vcFxyXG4gICAgICAgICAgICAgICAgLy8gPT4gaWYgbWVkaWEgbm90IGF0dGFjaGVkIGJ1dCBzdGFydCBmcmFnIHByZWZldGNoIGlzIGVuYWJsZWQgYW5kIHN0YXJ0IGZyYWcgbm90IHJlcXVlc3RlZCB5ZXQsIHdlIHdpbGwgbm90IGV4aXQgbG9vcFxyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLm1lZGlhICYmXHJcbiAgICAgICAgICAgICAgICAgICAgKHRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkIHx8ICFjb25maWcuc3RhcnRGcmFnUHJlZmV0Y2gpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBkZXRlcm1pbmUgbmV4dCBjYW5kaWRhdGUgZnJhZ21lbnQgdG8gYmUgbG9hZGVkLCBiYXNlZCBvbiBjdXJyZW50IHBvc2l0aW9uIGFuZFxyXG4gICAgICAgICAgICAgICAgLy8gIGVuZCBvZiBidWZmZXIgcG9zaXRpb25cclxuICAgICAgICAgICAgICAgIC8vIGlmIHdlIGhhdmUgbm90IHlldCBsb2FkZWQgYW55IGZyYWdtZW50LCBzdGFydCBsb2FkaW5nIGZyb20gc3RhcnQgcG9zaXRpb25cclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmxvYWRlZG1ldGFkYXRhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcG9zID0gdGhpcy5tZWRpYS5jdXJyZW50VGltZTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcG9zID0gdGhpcy5uZXh0TG9hZFBvc2l0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3MgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBsZXQgbWVkaWEgPSB0aGlzLm1lZGlhQnVmZmVyID8gdGhpcy5tZWRpYUJ1ZmZlciA6IHRoaXMubWVkaWEsXHJcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVySW5mbyA9IEJ1ZmZlckhlbHBlci5idWZmZXJJbmZvKG1lZGlhLCBwb3MsIGNvbmZpZy5tYXhCdWZmZXJIb2xlKSxcclxuICAgICAgICAgICAgICAgICAgICBidWZmZXJMZW4gPSBidWZmZXJJbmZvLmxlbixcclxuICAgICAgICAgICAgICAgICAgICBidWZmZXJFbmQgPSBidWZmZXJJbmZvLmVuZCxcclxuICAgICAgICAgICAgICAgICAgICBmcmFnUHJldmlvdXMgPSB0aGlzLmZyYWdQcmV2aW91cyxcclxuICAgICAgICAgICAgICAgICAgICBtYXhCdWZMZW4gPSBjb25maWcubWF4TWF4QnVmZmVyTGVuZ3RoLFxyXG4gICAgICAgICAgICAgICAgICAgIGF1ZGlvU3dpdGNoID0gdGhpcy5hdWRpb1N3aXRjaCxcclxuICAgICAgICAgICAgICAgICAgICB0cmFja0lkID0gdGhpcy50cmFja0lkO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIGlmIGJ1ZmZlciBsZW5ndGggaXMgbGVzcyB0aGFuIG1heEJ1ZkxlbiB0cnkgdG8gbG9hZCBhIG5ldyBmcmFnbWVudFxyXG4gICAgICAgICAgICAgICAgaWYgKChidWZmZXJMZW4gPCBtYXhCdWZMZW4gfHwgYXVkaW9Td2l0Y2gpICYmIHRyYWNrSWQgPCB0cmFja3MubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJhY2tEZXRhaWxzID0gdHJhY2tzW3RyYWNrSWRdLmRldGFpbHM7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdHJhY2sgaW5mbyBub3QgcmV0cmlldmVkIHlldCwgc3dpdGNoIHN0YXRlIGFuZCB3YWl0IGZvciB0cmFjayByZXRyaWV2YWxcclxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRyYWNrRGV0YWlscyA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLldBSVRJTkdfVFJBQ0s7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gd2UganVzdCBnb3QgZG9uZSBsb2FkaW5nIHRoZSBmaW5hbCBmcmFnbWVudCwgY2hlY2sgaWYgd2UgbmVlZCB0byBmaW5hbGl6ZSBtZWRpYSBzdHJlYW1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWF1ZGlvU3dpdGNoICYmICF0cmFja0RldGFpbHMubGl2ZSAmJiBmcmFnUHJldmlvdXMgJiYgZnJhZ1ByZXZpb3VzLnNuID09PSB0cmFja0RldGFpbHMuZW5kU04pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgd2UgYXJlIG5vdCBzZWVraW5nIG9yIGlmIHdlIGFyZSBzZWVraW5nIGJ1dCBldmVyeXRoaW5nIChhbG1vc3QpIHRpbCB0aGUgZW5kIGlzIGJ1ZmZlcmVkLCBsZXQncyBzaWduYWwgZW9zXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIGRvbid0IGNvbXBhcmUgZXhhY3RseSBtZWRpYS5kdXJhdGlvbiA9PT0gYnVmZmVySW5mby5lbmQgYXMgdGhlcmUgY291bGQgYmUgc29tZSBzdWJ0bGUgbWVkaWEgZHVyYXRpb24gZGlmZmVyZW5jZSB3aGVuIHN3aXRjaGluZ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBiZXR3ZWVuIGRpZmZlcmVudCByZW5kaXRpb25zLiB1c2luZyBoYWxmIGZyYWcgZHVyYXRpb24gc2hvdWxkIGhlbHAgY29wZSB3aXRoIHRoZXNlIGNhc2VzLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMubWVkaWEuc2Vla2luZyB8fCAodGhpcy5tZWRpYS5kdXJhdGlvbiAtIGJ1ZmZlckVuZCkgPCBmcmFnUHJldmlvdXMuZHVyYXRpb24gLyAyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGaW5hbGl6ZSB0aGUgbWVkaWEgc3RyZWFtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkJVRkZFUl9FT1MsIHt0eXBlOiAnYXVkaW8nfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuRU5ERUQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZmluZCBmcmFnbWVudCBpbmRleCwgY29udGlndW91cyB3aXRoIGVuZCBvZiBidWZmZXIgcG9zaXRpb25cclxuICAgICAgICAgICAgICAgICAgICBsZXQgZnJhZ21lbnRzID0gdHJhY2tEZXRhaWxzLmZyYWdtZW50cyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZnJhZ0xlbiA9IGZyYWdtZW50cy5sZW5ndGgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gZnJhZ21lbnRzWzBdLnN0YXJ0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQgPSBmcmFnbWVudHNbZnJhZ0xlbiAtIDFdLnN0YXJ0ICsgZnJhZ21lbnRzW2ZyYWdMZW4gLSAxXS5kdXJhdGlvbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgZnJhZztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gV2hlbiBzd2l0Y2hpbmcgYXVkaW8gdHJhY2ssIHJlbG9hZCBhdWRpbyBhcyBjbG9zZSBhcyBwb3NzaWJsZSB0byBjdXJyZW50VGltZVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhdWRpb1N3aXRjaCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHJhY2tEZXRhaWxzLmxpdmUgJiYgIXRyYWNrRGV0YWlscy5QVFNLbm93bikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmxvZyhgc3dpdGNoaW5nIGF1ZGlvdHJhY2ssIGxpdmUgc3RyZWFtLCB1bmtub3duIFBUUyxsb2FkIGZpcnN0IGZyYWdtZW50YCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWZmZXJFbmQgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyRW5kID0gcG9zO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgY3VycmVudFRpbWUgKHBvcykgaXMgbGVzcyB0aGFuIGFsdCBhdWRpbyBwbGF5bGlzdCBzdGFydCB0aW1lLCBpdCBtZWFucyB0aGF0IGFsdCBhdWRpbyBpcyBhaGVhZCBvZiBjdXJyZW50VGltZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRyYWNrRGV0YWlscy5QVFNLbm93biAmJiBwb3MgPCBzdGFydCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIGV2ZXJ5dGhpbmcgaXMgYnVmZmVyZWQgZnJvbSBwb3MgdG8gc3RhcnQgb3IgaWYgYXVkaW8gYnVmZmVyIHVwZnJvbnQsIGxldCdzIHNlZWsgdG8gc3RhcnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYnVmZmVySW5mby5lbmQgPiBzdGFydCB8fCBidWZmZXJJbmZvLm5leHRTdGFydCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIubG9nKCdhbHQgYXVkaW8gdHJhY2sgYWhlYWQgb2YgbWFpbiB0cmFjaywgc2VlayB0byBzdGFydCBvZiBhbHQgYXVkaW8gdHJhY2snKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tZWRpYS5jdXJyZW50VGltZSA9IHN0YXJ0ICsgMC4wNTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0cmFja0RldGFpbHMuaW5pdFNlZ21lbnQgJiYgIXRyYWNrRGV0YWlscy5pbml0U2VnbWVudC5kYXRhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyYWcgPSB0cmFja0RldGFpbHMuaW5pdFNlZ21lbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIGJ1ZmZlckVuZCBiZWZvcmUgc3RhcnQgb2YgcGxheWxpc3QsIGxvYWQgZmlyc3QgZnJhZ21lbnRcclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChidWZmZXJFbmQgPD0gc3RhcnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZnJhZyA9IGZyYWdtZW50c1swXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudmlkZW9UcmFja0NDICE9PSBudWxsICYmIGZyYWcuY2MgIT09IHRoaXMudmlkZW9UcmFja0NDKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBFbnN1cmUgd2UgZmluZCBhIGZyYWdtZW50IHdoaWNoIG1hdGNoZXMgdGhlIGNvbnRpbnVpdHkgb2YgdGhlIHZpZGVvIHRyYWNrXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcmFnID0gZmluZEZyYWdXaXRoQ0MoZnJhZ21lbnRzLCB0aGlzLnZpZGVvVHJhY2tDQyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRyYWNrRGV0YWlscy5saXZlICYmIGZyYWcubG9hZElkeCAmJiBmcmFnLmxvYWRJZHggPT09IHRoaXMuZnJhZ0xvYWRJZHgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIGp1c3QgbG9hZGVkIHRoaXMgZmlyc3QgZnJhZ21lbnQsIGFuZCB3ZSBhcmUgc3RpbGwgbGFnZ2luZyBiZWhpbmQgdGhlIHN0YXJ0IG9mIHRoZSBsaXZlIHBsYXlsaXN0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBsZXQncyBmb3JjZSBzZWVrIHRvIHN0YXJ0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXh0QnVmZmVyZWQgPSBidWZmZXJJbmZvLm5leHRTdGFydCA/IGJ1ZmZlckluZm8ubmV4dFN0YXJ0IDogc3RhcnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIubG9nKGBubyBhbHQgYXVkaW8gYXZhaWxhYmxlIEBjdXJyZW50VGltZToke3RoaXMubWVkaWEuY3VycmVudFRpbWV9LCBzZWVraW5nIEAke25leHRCdWZmZXJlZCArIDAuMDV9YCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1lZGlhLmN1cnJlbnRUaW1lID0gbmV4dEJ1ZmZlcmVkICsgMC4wNTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBmb3VuZEZyYWc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBtYXhGcmFnTG9va1VwVG9sZXJhbmNlID0gY29uZmlnLm1heEZyYWdMb29rVXBUb2xlcmFuY2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZyYWdOZXh0ID0gZnJhZ1ByZXZpb3VzID8gZnJhZ21lbnRzW2ZyYWdQcmV2aW91cy5zbiAtIGZyYWdtZW50c1swXS5zbiArIDFdIDogdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZnJhZ21lbnRXaXRoaW5Ub2xlcmFuY2VUZXN0ID0gKGNhbmRpZGF0ZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb2Zmc2V0IHNob3VsZCBiZSB3aXRoaW4gZnJhZ21lbnQgYm91bmRhcnkgLSBjb25maWcubWF4RnJhZ0xvb2tVcFRvbGVyYW5jZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBpcyB0byBjb3BlIHdpdGggc2l0dWF0aW9ucyBsaWtlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBidWZmZXJFbmQgPSA5Ljk5MVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZnJhZ1vDmF0gOiBbMCwxMF1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZyYWdbMV0gOiBbMTAsMjBdXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBidWZmZXJFbmQgaXMgd2l0aGluIGZyYWdbMF0gcmFuZ2UgLi4uIGFsdGhvdWdoIHdoYXQgd2UgYXJlIGV4cGVjdGluZyBpcyB0byByZXR1cm4gZnJhZ1sxXSBoZXJlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgZnJhZyBzdGFydCAgICAgICAgICAgICAgIGZyYWcgc3RhcnQrZHVyYXRpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICAgfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgIDwtLS0+ICAgICAgICAgICAgICAgICAgICAgICAgIDwtLS0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgLi4uLS0tLS0tLS0+PC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tPjwtLS0tLS0tLS0uLi4uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBwcmV2aW91cyBmcmFnICAgICAgICAgbWF0Y2hpbmcgZnJhZ21lbnQgICAgICAgICBuZXh0IGZyYWdcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICByZXR1cm4gLTEgICAgICAgICAgICAgcmV0dXJuIDAgICAgICAgICAgICAgICAgIHJldHVybiAxXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2xvZ2dlci5sb2coYGxldmVsL3NuL3N0YXJ0L2VuZC9idWZFbmQ6JHtsZXZlbH0vJHtjYW5kaWRhdGUuc259LyR7Y2FuZGlkYXRlLnN0YXJ0fS8keyhjYW5kaWRhdGUuc3RhcnQrY2FuZGlkYXRlLmR1cmF0aW9uKX0vJHtidWZmZXJFbmR9YCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTZXQgdGhlIGxvb2t1cCB0b2xlcmFuY2UgdG8gYmUgc21hbGwgZW5vdWdoIHRvIGRldGVjdCB0aGUgY3VycmVudCBzZWdtZW50IC0gZW5zdXJlcyB3ZSBkb24ndCBza2lwIG92ZXIgdmVyeSBzbWFsbCBzZWdtZW50c1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNhbmRpZGF0ZUxvb2t1cFRvbGVyYW5jZSA9IE1hdGgubWluKG1heEZyYWdMb29rVXBUb2xlcmFuY2UsIGNhbmRpZGF0ZS5kdXJhdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGNhbmRpZGF0ZS5zdGFydCArIGNhbmRpZGF0ZS5kdXJhdGlvbiAtIGNhbmRpZGF0ZUxvb2t1cFRvbGVyYW5jZSkgPD0gYnVmZmVyRW5kKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9Ly8gaWYgbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSB3aWxsIGhhdmUgbmVnYXRpdmUgdmFsdWUgdGhlbiBkb24ndCByZXR1cm4gLTEgZm9yIGZpcnN0IGVsZW1lbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNhbmRpZGF0ZS5zdGFydCAtIGNhbmRpZGF0ZUxvb2t1cFRvbGVyYW5jZSA+IGJ1ZmZlckVuZCAmJiBjYW5kaWRhdGUuc3RhcnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChidWZmZXJFbmQgPCBlbmQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChidWZmZXJFbmQgPiBlbmQgLSBtYXhGcmFnTG9va1VwVG9sZXJhbmNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBQcmVmZXIgdGhlIG5leHQgZnJhZ21lbnQgaWYgaXQncyB3aXRoaW4gdG9sZXJhbmNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZnJhZ05leHQgJiYgIWZyYWdtZW50V2l0aGluVG9sZXJhbmNlVGVzdChmcmFnTmV4dCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3VuZEZyYWcgPSBmcmFnTmV4dDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm91bmRGcmFnID0gQmluYXJ5U2VhcmNoLnNlYXJjaChmcmFnbWVudHMsIGZyYWdtZW50V2l0aGluVG9sZXJhbmNlVGVzdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZWFjaCBlbmQgb2YgcGxheWxpc3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kRnJhZyA9IGZyYWdtZW50c1tmcmFnTGVuIC0gMV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZvdW5kRnJhZykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhZyA9IGZvdW5kRnJhZztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gZm91bmRGcmFnLnN0YXJ0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9sb2dnZXIubG9nKCdmaW5kIFNOIG1hdGNoaW5nIHdpdGggcG9zOicgKyAgYnVmZmVyRW5kICsgJzonICsgZnJhZy5zbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZnJhZ1ByZXZpb3VzICYmIGZyYWcubGV2ZWwgPT09IGZyYWdQcmV2aW91cy5sZXZlbCAmJiBmcmFnLnNuID09PSBmcmFnUHJldmlvdXMuc24pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZnJhZy5zbiA8IHRyYWNrRGV0YWlscy5lbmRTTikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcmFnID0gZnJhZ21lbnRzW2ZyYWcuc24gKyAxIC0gdHJhY2tEZXRhaWxzLnN0YXJ0U05dO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIubG9nKGBTTiBqdXN0IGxvYWRlZCwgbG9hZCBuZXh0IG9uZTogJHtmcmFnLnNufWApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyYWcgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoZnJhZykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2xvZ2dlci5sb2coJyAgICAgIGxvYWRpbmcgZnJhZyAnICsgaSArJyxwb3MvYnVmRW5kOicgKyBwb3MudG9GaXhlZCgzKSArICcvJyArIGJ1ZmZlckVuZC50b0ZpeGVkKDMpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZyYWcuZGVjcnlwdGRhdGEgJiYgKGZyYWcuZGVjcnlwdGRhdGEudXJpICE9IG51bGwpICYmIChmcmFnLmRlY3J5cHRkYXRhLmtleSA9PSBudWxsKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmxvZyhgTG9hZGluZyBrZXkgZm9yICR7ZnJhZy5zbn0gb2YgWyR7dHJhY2tEZXRhaWxzLnN0YXJ0U059ICwke3RyYWNrRGV0YWlscy5lbmRTTn1dLHRyYWNrICR7dHJhY2tJZH1gKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5LRVlfTE9BRElORztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhscy50cmlnZ2VyKEV2ZW50LktFWV9MT0FESU5HLCB7ZnJhZzogZnJhZ30pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmxvZyhgTG9hZGluZyAke2ZyYWcuc259LCBjYzogJHtmcmFnLmNjfSBvZiBbJHt0cmFja0RldGFpbHMuc3RhcnRTTn0gLCR7dHJhY2tEZXRhaWxzLmVuZFNOfV0sdHJhY2sgJHt0cmFja0lkfSwgY3VycmVudFRpbWU6JHtwb3N9LGJ1ZmZlckVuZDoke2J1ZmZlckVuZC50b0ZpeGVkKDMpfWApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZW5zdXJlIHRoYXQgd2UgYXJlIG5vdCByZWxvYWRpbmcgdGhlIHNhbWUgZnJhZ21lbnRzIGluIGxvb3AgLi4uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5mcmFnTG9hZElkeCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5mcmFnTG9hZElkeCsrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZyYWdMb2FkSWR4ID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmcmFnLmxvYWRDb3VudGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhZy5sb2FkQ291bnRlcisrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBtYXhUaHJlc2hvbGQgPSBjb25maWcuZnJhZ0xvYWRpbmdMb29wVGhyZXNob2xkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoaXMgZnJhZyBoYXMgYWxyZWFkeSBiZWVuIGxvYWRlZCAzIHRpbWVzLCBhbmQgaWYgaXQgaGFzIGJlZW4gcmVsb2FkZWQgcmVjZW50bHlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZnJhZy5sb2FkQ291bnRlciA+IG1heFRocmVzaG9sZCAmJiAoTWF0aC5hYnModGhpcy5mcmFnTG9hZElkeCAtIGZyYWcubG9hZElkeCkgPCBtYXhUaHJlc2hvbGQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhscy50cmlnZ2VyKEV2ZW50LkVSUk9SLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLkZSQUdfTE9PUF9MT0FESU5HX0VSUk9SLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmF0YWw6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhZzogZnJhZ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhZy5sb2FkQ291bnRlciA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcmFnLmxvYWRJZHggPSB0aGlzLmZyYWdMb2FkSWR4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5mcmFnQ3VycmVudCA9IGZyYWc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzTmFOKGZyYWcuc24pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXh0TG9hZFBvc2l0aW9uID0gZnJhZy5zdGFydCArIGZyYWcuZHVyYXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBobHMudHJpZ2dlcihFdmVudC5GUkFHX0xPQURJTkcsIHtmcmFnOiBmcmFnfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuRlJBR19MT0FESU5HO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgU3RhdGUuV0FJVElOR19UUkFDSzpcclxuICAgICAgICAgICAgICAgIHRyYWNrID0gdGhpcy50cmFja3NbdGhpcy50cmFja0lkXTtcclxuICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlmIHBsYXlsaXN0IGlzIGFscmVhZHkgbG9hZGVkXHJcbiAgICAgICAgICAgICAgICBpZiAodHJhY2sgJiYgdHJhY2suZGV0YWlscykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgU3RhdGUuRlJBR19MT0FESU5HX1dBSVRJTkdfUkVUUlk6XHJcbiAgICAgICAgICAgICAgICB2YXIgbm93ID0gcGVyZm9ybWFuY2Uubm93KCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmV0cnlEYXRlID0gdGhpcy5yZXRyeURhdGU7XHJcbiAgICAgICAgICAgICAgICBtZWRpYSA9IHRoaXMubWVkaWE7XHJcbiAgICAgICAgICAgICAgICB2YXIgaXNTZWVraW5nID0gbWVkaWEgJiYgbWVkaWEuc2Vla2luZztcclxuICAgICAgICAgICAgICAgIC8vIGlmIGN1cnJlbnQgdGltZSBpcyBndCB0aGFuIHJldHJ5RGF0ZSwgb3IgaWYgbWVkaWEgc2Vla2luZyBsZXQncyBzd2l0Y2ggdG8gSURMRSBzdGF0ZSB0byByZXRyeSBsb2FkaW5nXHJcbiAgICAgICAgICAgICAgICBpZiAoIXJldHJ5RGF0ZSB8fCAobm93ID49IHJldHJ5RGF0ZSkgfHwgaXNTZWVraW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmxvZyhgYXVkaW9TdHJlYW1Db250cm9sbGVyOiByZXRyeURhdGUgcmVhY2hlZCwgc3dpdGNoIGJhY2sgdG8gSURMRSBzdGF0ZWApO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgU3RhdGUuV0FJVElOR19JTklUX1BUUzpcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmluaXRQVFNbdGhpcy52aWRlb1RyYWNrQ0NdID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBFbnN1cmUgd2UgZG9uJ3QgZ2V0IHN0dWNrIGluIHRoZSBXQUlUSU5HX0lOSVRfUFRTIHN0YXRlIGlmIHRoZSB3YWl0aW5nIGZyYWcgQ0MgZG9lc24ndCBtYXRjaCBhbnkgaW5pdFBUU1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgd2FpdGluZ0ZyYWcgPSB0aGlzLndhaXRpbmdGcmFnbWVudDtcclxuICAgICAgICAgICAgICAgIGlmICh3YWl0aW5nRnJhZykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHdhaXRpbmdGcmFnQ0MgPSB3YWl0aW5nRnJhZy5mcmFnLmNjO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnZpZGVvVHJhY2tDQyAhPT0gd2FpdGluZ0ZyYWdDQykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIud2FybihgV2FpdGluZyBmcmFnbWVudCBDQyAoJHt3YWl0aW5nRnJhZ0NDfSkgZG9lcyBub3QgbWF0Y2ggdmlkZW8gdHJhY2sgQ0MgKCR7dGhpcy52aWRlb1RyYWNrQ0N9KWApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLndhaXRpbmdGcmFnbWVudCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5GUkFHX0xPQURJTkc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub25GcmFnTG9hZGVkKHRoaXMud2FpdGluZ0ZyYWdtZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy53YWl0aW5nRnJhZ21lbnQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgU3RhdGUuU1RPUFBFRDpcclxuICAgICAgICAgICAgY2FzZSBTdGF0ZS5GUkFHX0xPQURJTkc6XHJcbiAgICAgICAgICAgIGNhc2UgU3RhdGUuUEFSU0lORzpcclxuICAgICAgICAgICAgY2FzZSBTdGF0ZS5QQVJTRUQ6XHJcbiAgICAgICAgICAgIGNhc2UgU3RhdGUuRU5ERUQ6XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBvbk1lZGlhQXR0YWNoZWQoZGF0YSkge1xyXG4gICAgICAgIHZhciBtZWRpYSA9IHRoaXMubWVkaWEgPSB0aGlzLm1lZGlhQnVmZmVyID0gZGF0YS5tZWRpYTtcclxuICAgICAgICB0aGlzLm9udnNlZWtpbmcgPSB0aGlzLm9uTWVkaWFTZWVraW5nLmJpbmQodGhpcyk7XHJcbiAgICAgICAgdGhpcy5vbnZlbmRlZCA9IHRoaXMub25NZWRpYUVuZGVkLmJpbmQodGhpcyk7XHJcbiAgICAgICAgbWVkaWEuYWRkRXZlbnRMaXN0ZW5lcignc2Vla2luZycsIHRoaXMub252c2Vla2luZyk7XHJcbiAgICAgICAgbWVkaWEuYWRkRXZlbnRMaXN0ZW5lcignZW5kZWQnLCB0aGlzLm9udmVuZGVkKTtcclxuICAgICAgICBsZXQgY29uZmlnID0gdGhpcy5jb25maWc7XHJcbiAgICAgICAgaWYgKHRoaXMudHJhY2tzICYmIGNvbmZpZy5hdXRvU3RhcnRMb2FkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhcnRMb2FkKGNvbmZpZy5zdGFydFBvc2l0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgb25NZWRpYURldGFjaGluZygpIHtcclxuICAgICAgICB2YXIgbWVkaWEgPSB0aGlzLm1lZGlhO1xyXG4gICAgICAgIGlmIChtZWRpYSAmJiBtZWRpYS5lbmRlZCkge1xyXG4gICAgICAgICAgICBsb2dnZXIubG9nKCdNU0UgZGV0YWNoaW5nIGFuZCB2aWRlbyBlbmRlZCwgcmVzZXQgc3RhcnRQb3NpdGlvbicpO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXJ0UG9zaXRpb24gPSB0aGlzLmxhc3RDdXJyZW50VGltZSA9IDA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyByZXNldCBmcmFnbWVudCBsb2FkaW5nIGNvdW50ZXIgb24gTVNFIGRldGFjaGluZyB0byBhdm9pZCByZXBvcnRpbmcgRlJBR19MT09QX0xPQURJTkdfRVJST1IgYWZ0ZXIgZXJyb3IgcmVjb3ZlcnlcclxuICAgICAgICB2YXIgdHJhY2tzID0gdGhpcy50cmFja3M7XHJcbiAgICAgICAgaWYgKHRyYWNrcykge1xyXG4gICAgICAgICAgICAvLyByZXNldCBmcmFnbWVudCBsb2FkIGNvdW50ZXJcclxuICAgICAgICAgICAgdHJhY2tzLmZvckVhY2godHJhY2sgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRyYWNrLmRldGFpbHMpIHtcclxuICAgICAgICAgICAgICAgICAgICB0cmFjay5kZXRhaWxzLmZyYWdtZW50cy5mb3JFYWNoKGZyYWdtZW50ID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnQubG9hZENvdW50ZXIgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyByZW1vdmUgdmlkZW8gbGlzdGVuZXJzXHJcbiAgICAgICAgaWYgKG1lZGlhKSB7XHJcbiAgICAgICAgICAgIG1lZGlhLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3NlZWtpbmcnLCB0aGlzLm9udnNlZWtpbmcpO1xyXG4gICAgICAgICAgICBtZWRpYS5yZW1vdmVFdmVudExpc3RlbmVyKCdlbmRlZCcsIHRoaXMub252ZW5kZWQpO1xyXG4gICAgICAgICAgICB0aGlzLm9udnNlZWtpbmcgPSB0aGlzLm9udnNlZWtlZCA9IHRoaXMub252ZW5kZWQgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLm1lZGlhID0gdGhpcy5tZWRpYUJ1ZmZlciA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5sb2FkZWRtZXRhZGF0YSA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuc3RvcExvYWQoKTtcclxuICAgIH1cclxuXHJcbiAgICBvbk1lZGlhU2Vla2luZygpIHtcclxuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuRU5ERUQpIHtcclxuICAgICAgICAgICAgLy8gc3dpdGNoIHRvIElETEUgc3RhdGUgdG8gY2hlY2sgZm9yIHBvdGVudGlhbCBuZXcgZnJhZ21lbnRcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLm1lZGlhKSB7XHJcbiAgICAgICAgICAgIHRoaXMubGFzdEN1cnJlbnRUaW1lID0gdGhpcy5tZWRpYS5jdXJyZW50VGltZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gYXZvaWQgcmVwb3J0aW5nIGZyYWdtZW50IGxvb3AgbG9hZGluZyBlcnJvciBpbiBjYXNlIHVzZXIgaXMgc2Vla2luZyBzZXZlcmFsIHRpbWVzIG9uIHNhbWUgcG9zaXRpb25cclxuICAgICAgICBpZiAodGhpcy5mcmFnTG9hZElkeCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZnJhZ0xvYWRJZHggKz0gMiAqIHRoaXMuY29uZmlnLmZyYWdMb2FkaW5nTG9vcFRocmVzaG9sZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gdGljayB0byBzcGVlZCB1cCBwcm9jZXNzaW5nXHJcbiAgICAgICAgdGhpcy50aWNrKCk7XHJcbiAgICB9XHJcblxyXG4gICAgb25NZWRpYUVuZGVkKCkge1xyXG4gICAgICAgIC8vIHJlc2V0IHN0YXJ0UG9zaXRpb24gYW5kIGxhc3RDdXJyZW50VGltZSB0byByZXN0YXJ0IHBsYXliYWNrIEAgc3RyZWFtIGJlZ2lubmluZ1xyXG4gICAgICAgIHRoaXMuc3RhcnRQb3NpdGlvbiA9IHRoaXMubGFzdEN1cnJlbnRUaW1lID0gMDtcclxuICAgIH1cclxuXHJcblxyXG4gICAgb25BdWRpb1RyYWNrc1VwZGF0ZWQoZGF0YSkge1xyXG4gICAgICAgIGxvZ2dlci5sb2coJ2F1ZGlvIHRyYWNrcyB1cGRhdGVkJyk7XHJcbiAgICAgICAgdGhpcy50cmFja3MgPSBkYXRhLmF1ZGlvVHJhY2tzO1xyXG4gICAgfVxyXG5cclxuICAgIG9uQXVkaW9UcmFja1N3aXRjaGluZyhkYXRhKSB7XHJcbiAgICAgICAgLy8gaWYgYW55IFVSTCBmb3VuZCBvbiBuZXcgYXVkaW8gdHJhY2ssIGl0IGlzIGFuIGFsdGVybmF0ZSBhdWRpbyB0cmFja1xyXG4gICAgICAgIHZhciBhbHRBdWRpbyA9ICEhZGF0YS51cmw7XHJcbiAgICAgICAgdGhpcy50cmFja0lkID0gZGF0YS5pZDtcclxuXHJcbiAgICAgICAgdGhpcy5mcmFnQ3VycmVudCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLlBBVVNFRDtcclxuICAgICAgICB0aGlzLndhaXRpbmdGcmFnbWVudCA9IG51bGw7XHJcbiAgICAgICAgLy8gZGVzdHJveSB1c2VsZXNzIGRlbXV4ZXIgd2hlbiBzd2l0Y2hpbmcgYXVkaW8gdG8gbWFpblxyXG4gICAgICAgIGlmICghYWx0QXVkaW8pIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuZGVtdXhlcikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kZW11eGVyLmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGVtdXhlciA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBzd2l0Y2hpbmcgdG8gYXVkaW8gdHJhY2ssIHN0YXJ0IHRpbWVyIGlmIG5vdCBhbHJlYWR5IHN0YXJ0ZWRcclxuICAgICAgICAgICAgaWYgKCF0aGlzLnRpbWVyKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRpbWVyID0gc2V0SW50ZXJ2YWwodGhpcy5vbnRpY2ssIDEwMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vc2hvdWxkIHdlIHN3aXRjaCB0cmFja3MgP1xyXG4gICAgICAgIGlmIChhbHRBdWRpbykge1xyXG4gICAgICAgICAgICB0aGlzLmF1ZGlvU3dpdGNoID0gdHJ1ZTtcclxuICAgICAgICAgICAgLy9tYWluIGF1ZGlvIHRyYWNrIGFyZSBoYW5kbGVkIGJ5IHN0cmVhbS1jb250cm9sbGVyLCBqdXN0IGRvIHNvbWV0aGluZyBpZiBzd2l0Y2hpbmcgdG8gYWx0IGF1ZGlvIHRyYWNrXHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xyXG4gICAgICAgICAgICAvLyBpbmNyZWFzZSBmcmFnbWVudCBsb2FkIEluZGV4IHRvIGF2b2lkIGZyYWcgbG9vcCBsb2FkaW5nIGVycm9yIGFmdGVyIGJ1ZmZlciBmbHVzaFxyXG4gICAgICAgICAgICBpZiAodGhpcy5mcmFnTG9hZElkeCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmZyYWdMb2FkSWR4ICs9IDIgKiB0aGlzLmNvbmZpZy5mcmFnTG9hZGluZ0xvb3BUaHJlc2hvbGQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy50aWNrKCk7XHJcbiAgICB9XHJcblxyXG4gICAgb25BdWRpb1RyYWNrTG9hZGVkKGRhdGEpIHtcclxuICAgICAgICB2YXIgbmV3RGV0YWlscyA9IGRhdGEuZGV0YWlscyxcclxuICAgICAgICAgICAgdHJhY2tJZCA9IGRhdGEuaWQsXHJcbiAgICAgICAgICAgIHRyYWNrID0gdGhpcy50cmFja3NbdHJhY2tJZF0sXHJcbiAgICAgICAgICAgIGR1cmF0aW9uID0gbmV3RGV0YWlscy50b3RhbGR1cmF0aW9uLFxyXG4gICAgICAgICAgICBzbGlkaW5nID0gMDtcclxuXHJcbiAgICAgICAgbG9nZ2VyLmxvZyhgdHJhY2sgJHt0cmFja0lkfSBsb2FkZWQgWyR7bmV3RGV0YWlscy5zdGFydFNOfSwke25ld0RldGFpbHMuZW5kU059XSxkdXJhdGlvbjoke2R1cmF0aW9ufWApO1xyXG5cclxuICAgICAgICBpZiAobmV3RGV0YWlscy5saXZlKSB7XHJcbiAgICAgICAgICAgIHZhciBjdXJEZXRhaWxzID0gdHJhY2suZGV0YWlscztcclxuICAgICAgICAgICAgaWYgKGN1ckRldGFpbHMgJiYgbmV3RGV0YWlscy5mcmFnbWVudHMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgLy8gd2UgYWxyZWFkeSBoYXZlIGRldGFpbHMgZm9yIHRoYXQgbGV2ZWwsIG1lcmdlIHRoZW1cclxuICAgICAgICAgICAgICAgIExldmVsSGVscGVyLm1lcmdlRGV0YWlscyhjdXJEZXRhaWxzLCBuZXdEZXRhaWxzKTtcclxuICAgICAgICAgICAgICAgIHNsaWRpbmcgPSBuZXdEZXRhaWxzLmZyYWdtZW50c1swXS5zdGFydDtcclxuICAgICAgICAgICAgICAgIC8vIFRPRE9cclxuICAgICAgICAgICAgICAgIC8vdGhpcy5saXZlU3luY1Bvc2l0aW9uID0gdGhpcy5jb21wdXRlTGl2ZVBvc2l0aW9uKHNsaWRpbmcsIGN1ckRldGFpbHMpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG5ld0RldGFpbHMuUFRTS25vd24pIHtcclxuICAgICAgICAgICAgICAgICAgICBsb2dnZXIubG9nKGBsaXZlIGF1ZGlvIHBsYXlsaXN0IHNsaWRpbmc6JHtzbGlkaW5nLnRvRml4ZWQoMyl9YCk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci5sb2coJ2xpdmUgYXVkaW8gcGxheWxpc3QgLSBvdXRkYXRlZCBQVFMsIHVua25vd24gc2xpZGluZycpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbmV3RGV0YWlscy5QVFNLbm93biA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgbG9nZ2VyLmxvZygnbGl2ZSBhdWRpbyBwbGF5bGlzdCAtIGZpcnN0IGxvYWQsIHVua25vd24gc2xpZGluZycpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgbmV3RGV0YWlscy5QVFNLbm93biA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0cmFjay5kZXRhaWxzID0gbmV3RGV0YWlscztcclxuXHJcbiAgICAgICAgLy8gY29tcHV0ZSBzdGFydCBwb3NpdGlvblxyXG4gICAgICAgIGlmICghdGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQpIHtcclxuICAgICAgICAgICAgLy8gY29tcHV0ZSBzdGFydCBwb3NpdGlvbiBpZiBzZXQgdG8gLTEuIHVzZSBpdCBzdHJhaWdodCBhd2F5IGlmIHZhbHVlIGlzIGRlZmluZWRcclxuICAgICAgICAgICAgaWYgKHRoaXMuc3RhcnRQb3NpdGlvbiA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIC8vIGZpcnN0LCBjaGVjayBpZiBzdGFydCB0aW1lIG9mZnNldCBoYXMgYmVlbiBzZXQgaW4gcGxheWxpc3QsIGlmIHllcywgdXNlIHRoaXMgdmFsdWVcclxuICAgICAgICAgICAgICAgIGxldCBzdGFydFRpbWVPZmZzZXQgPSBuZXdEZXRhaWxzLnN0YXJ0VGltZU9mZnNldDtcclxuICAgICAgICAgICAgICAgIGlmICghaXNOYU4oc3RhcnRUaW1lT2Zmc2V0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci5sb2coYHN0YXJ0IHRpbWUgb2Zmc2V0IGZvdW5kIGluIHBsYXlsaXN0LCBhZGp1c3Qgc3RhcnRQb3NpdGlvbiB0byAke3N0YXJ0VGltZU9mZnNldH1gKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0UG9zaXRpb24gPSBzdGFydFRpbWVPZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRQb3NpdGlvbiA9IDA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5uZXh0TG9hZFBvc2l0aW9uID0gdGhpcy5zdGFydFBvc2l0aW9uO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBvbmx5IHN3aXRjaCBiYXRjayB0byBJRExFIHN0YXRlIGlmIHdlIHdlcmUgd2FpdGluZyBmb3IgdHJhY2sgdG8gc3RhcnQgZG93bmxvYWRpbmcgYSBuZXcgZnJhZ21lbnRcclxuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuV0FJVElOR19UUkFDSykge1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy90cmlnZ2VyIGhhbmRsZXIgcmlnaHQgbm93XHJcbiAgICAgICAgdGhpcy50aWNrKCk7XHJcbiAgICB9XHJcblxyXG4gICAgb25LZXlMb2FkZWQoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLktFWV9MT0FESU5HKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xyXG4gICAgICAgICAgICB0aGlzLnRpY2soKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgb25GcmFnTG9hZGVkKGRhdGEpIHtcclxuICAgICAgICB2YXIgZnJhZ0N1cnJlbnQgPSB0aGlzLmZyYWdDdXJyZW50LFxyXG4gICAgICAgICAgICBmcmFnTG9hZGVkID0gZGF0YS5mcmFnO1xyXG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09PSBTdGF0ZS5GUkFHX0xPQURJTkcgJiZcclxuICAgICAgICAgICAgZnJhZ0N1cnJlbnQgJiZcclxuICAgICAgICAgICAgZnJhZ0xvYWRlZC50eXBlID09PSAnYXVkaW8nICYmXHJcbiAgICAgICAgICAgIGZyYWdMb2FkZWQubGV2ZWwgPT09IGZyYWdDdXJyZW50LmxldmVsICYmXHJcbiAgICAgICAgICAgIGZyYWdMb2FkZWQuc24gPT09IGZyYWdDdXJyZW50LnNuKSB7XHJcbiAgICAgICAgICAgIHZhciB0cmFjayA9IHRoaXMudHJhY2tzW3RoaXMudHJhY2tJZF0sXHJcbiAgICAgICAgICAgICAgICBkZXRhaWxzID0gdHJhY2suZGV0YWlscyxcclxuICAgICAgICAgICAgICAgIGR1cmF0aW9uID0gZGV0YWlscy50b3RhbGR1cmF0aW9uLFxyXG4gICAgICAgICAgICAgICAgdHJhY2tJZCA9IGZyYWdDdXJyZW50LmxldmVsLFxyXG4gICAgICAgICAgICAgICAgc24gPSBmcmFnQ3VycmVudC5zbixcclxuICAgICAgICAgICAgICAgIGNjID0gZnJhZ0N1cnJlbnQuY2MsXHJcbiAgICAgICAgICAgICAgICBhdWRpb0NvZGVjID0gdGhpcy5jb25maWcuZGVmYXVsdEF1ZGlvQ29kZWMgfHwgdHJhY2suYXVkaW9Db2RlYyB8fCAnbXA0YS40MC4yJyxcclxuICAgICAgICAgICAgICAgIHN0YXRzID0gdGhpcy5zdGF0cyA9IGRhdGEuc3RhdHM7XHJcbiAgICAgICAgICAgIGlmIChzbiA9PT0gJ2luaXRTZWdtZW50Jykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XHJcblxyXG4gICAgICAgICAgICAgICAgc3RhdHMudHBhcnNlZCA9IHN0YXRzLnRidWZmZXJlZCA9IHBlcmZvcm1hbmNlLm5vdygpO1xyXG4gICAgICAgICAgICAgICAgZGV0YWlscy5pbml0U2VnbWVudC5kYXRhID0gZGF0YS5wYXlsb2FkO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5GUkFHX0JVRkZFUkVELCB7c3RhdHM6IHN0YXRzLCBmcmFnOiBmcmFnQ3VycmVudCwgaWQ6ICdhdWRpbyd9KTtcclxuICAgICAgICAgICAgICAgIHRoaXMudGljaygpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLlBBUlNJTkc7XHJcbiAgICAgICAgICAgICAgICAvLyB0cmFuc211eCB0aGUgTVBFRy1UUyBkYXRhIHRvIElTTy1CTUZGIHNlZ21lbnRzXHJcbiAgICAgICAgICAgICAgICB0aGlzLmFwcGVuZGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuZGVtdXhlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVtdXhlciA9IG5ldyBEZW11eGVyKHRoaXMuaGxzLCAnYXVkaW8nKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vQ2hlY2sgaWYgd2UgaGF2ZSB2aWRlbyBpbml0UFRTXHJcbiAgICAgICAgICAgICAgICAvLyBJZiBub3Qgd2UgbmVlZCB0byB3YWl0IGZvciBpdFxyXG4gICAgICAgICAgICAgICAgbGV0IGluaXRQVFMgPSB0aGlzLmluaXRQVFNbY2NdO1xyXG4gICAgICAgICAgICAgICAgbGV0IGluaXRTZWdtZW50RGF0YSA9IGRldGFpbHMuaW5pdFNlZ21lbnQgPyBkZXRhaWxzLmluaXRTZWdtZW50LmRhdGEgOiBbXTtcclxuICAgICAgICAgICAgICAgIGlmIChkZXRhaWxzLmluaXRTZWdtZW50IHx8IGluaXRQVFMgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ0J1ZmZlcmluZyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmxvZyhgRGVtdXhpbmcgJHtzbn0gb2YgWyR7ZGV0YWlscy5zdGFydFNOfSAsJHtkZXRhaWxzLmVuZFNOfV0sdHJhY2sgJHt0cmFja0lkfWApO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHRpbWUgT2Zmc2V0IGlzIGFjY3VyYXRlIGlmIGxldmVsIFBUUyBpcyBrbm93biwgb3IgaWYgcGxheWxpc3QgaXMgbm90IHNsaWRpbmcgKG5vdCBsaXZlKVxyXG4gICAgICAgICAgICAgICAgICAgIGxldCBhY2N1cmF0ZVRpbWVPZmZzZXQgPSBmYWxzZTsgLy9kZXRhaWxzLlBUU0tub3duIHx8ICFkZXRhaWxzLmxpdmU7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZW11eGVyLnB1c2goZGF0YS5wYXlsb2FkLCBpbml0U2VnbWVudERhdGEsIGF1ZGlvQ29kZWMsIG51bGwsIGZyYWdDdXJyZW50LCBkdXJhdGlvbiwgYWNjdXJhdGVUaW1lT2Zmc2V0LCBpbml0UFRTKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmxvZyhgdW5rbm93biB2aWRlbyBQVFMgZm9yIGNvbnRpbnVpdHkgY291bnRlciAke2NjfSwgd2FpdGluZyBmb3IgdmlkZW8gUFRTIGJlZm9yZSBkZW11eGluZyBhdWRpbyBmcmFnICR7c259IG9mIFske2RldGFpbHMuc3RhcnRTTn0gLCR7ZGV0YWlscy5lbmRTTn1dLHRyYWNrICR7dHJhY2tJZH1gKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLndhaXRpbmdGcmFnbWVudCA9IGRhdGE7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLldBSVRJTkdfSU5JVF9QVFM7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5mcmFnTG9hZEVycm9yID0gMDtcclxuICAgIH1cclxuXHJcbiAgICBvbkZyYWdQYXJzaW5nSW5pdFNlZ21lbnQoZGF0YSkge1xyXG4gICAgICAgIGNvbnN0IGZyYWdDdXJyZW50ID0gdGhpcy5mcmFnQ3VycmVudDtcclxuICAgICAgICBjb25zdCBmcmFnTmV3ID0gZGF0YS5mcmFnO1xyXG4gICAgICAgIGlmIChmcmFnQ3VycmVudCAmJlxyXG4gICAgICAgICAgICBkYXRhLmlkID09PSAnYXVkaW8nICYmXHJcbiAgICAgICAgICAgIGZyYWdOZXcuc24gPT09IGZyYWdDdXJyZW50LnNuICYmXHJcbiAgICAgICAgICAgIGZyYWdOZXcubGV2ZWwgPT09IGZyYWdDdXJyZW50LmxldmVsICYmXHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPT09IFN0YXRlLlBBUlNJTkcpIHtcclxuICAgICAgICAgICAgbGV0IHRyYWNrcyA9IGRhdGEudHJhY2tzLCB0cmFjaztcclxuXHJcbiAgICAgICAgICAgIC8vIGRlbGV0ZSBhbnkgdmlkZW8gdHJhY2sgZm91bmQgb24gYXVkaW8gZGVtdXhlclxyXG4gICAgICAgICAgICBpZiAodHJhY2tzLnZpZGVvKSB7XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgdHJhY2tzLnZpZGVvO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBpbmNsdWRlIGxldmVsQ29kZWMgaW4gYXVkaW8gYW5kIHZpZGVvIHRyYWNrc1xyXG4gICAgICAgICAgICB0cmFjayA9IHRyYWNrcy5hdWRpbztcclxuICAgICAgICAgICAgaWYgKHRyYWNrKSB7XHJcbiAgICAgICAgICAgICAgICB0cmFjay5sZXZlbENvZGVjID0gdHJhY2suY29kZWM7XHJcbiAgICAgICAgICAgICAgICB0cmFjay5pZCA9IGRhdGEuaWQ7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkJVRkZFUl9DT0RFQ1MsIHRyYWNrcyk7XHJcbiAgICAgICAgICAgICAgICBsb2dnZXIubG9nKGBhdWRpbyB0cmFjazphdWRpbyxjb250YWluZXI6JHt0cmFjay5jb250YWluZXJ9LGNvZGVjc1tsZXZlbC9wYXJzZWRdPVske3RyYWNrLmxldmVsQ29kZWN9LyR7dHJhY2suY29kZWN9XWApO1xyXG4gICAgICAgICAgICAgICAgbGV0IGluaXRTZWdtZW50ID0gdHJhY2suaW5pdFNlZ21lbnQ7XHJcbiAgICAgICAgICAgICAgICBpZiAoaW5pdFNlZ21lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgYXBwZW5kT2JqID0ge3R5cGU6ICdhdWRpbycsIGRhdGE6IGluaXRTZWdtZW50LCBwYXJlbnQ6ICdhdWRpbycsIGNvbnRlbnQ6ICdpbml0U2VnbWVudCd9O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmF1ZGlvU3dpdGNoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ0RhdGEgPSBbYXBwZW5kT2JqXTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcGVuZGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXJtIHBlbmRpbmcgQnVmZmVyaW5nIGZsYWcgYmVmb3JlIGFwcGVuZGluZyBhIHNlZ21lbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nQnVmZmVyaW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5CVUZGRVJfQVBQRU5ESU5HLCBhcHBlbmRPYmopO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vdHJpZ2dlciBoYW5kbGVyIHJpZ2h0IG5vd1xyXG4gICAgICAgICAgICAgICAgdGhpcy50aWNrKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgb25GcmFnUGFyc2luZ0RhdGEoZGF0YSkge1xyXG4gICAgICAgIGNvbnN0IGZyYWdDdXJyZW50ID0gdGhpcy5mcmFnQ3VycmVudDtcclxuICAgICAgICBjb25zdCBmcmFnTmV3ID0gZGF0YS5mcmFnO1xyXG4gICAgICAgIGlmIChmcmFnQ3VycmVudCAmJlxyXG4gICAgICAgICAgICBkYXRhLmlkID09PSAnYXVkaW8nICYmXHJcbiAgICAgICAgICAgIGRhdGEudHlwZSA9PT0gJ2F1ZGlvJyAmJlxyXG4gICAgICAgICAgICBmcmFnTmV3LnNuID09PSBmcmFnQ3VycmVudC5zbiAmJlxyXG4gICAgICAgICAgICBmcmFnTmV3LmxldmVsID09PSBmcmFnQ3VycmVudC5sZXZlbCAmJlxyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID09PSBTdGF0ZS5QQVJTSU5HKSB7XHJcbiAgICAgICAgICAgIGxldCB0cmFja0lkID0gdGhpcy50cmFja0lkLFxyXG4gICAgICAgICAgICAgICAgdHJhY2sgPSB0aGlzLnRyYWNrc1t0cmFja0lkXSxcclxuICAgICAgICAgICAgICAgIGhscyA9IHRoaXMuaGxzO1xyXG5cclxuICAgICAgICAgICAgaWYgKGlzTmFOKGRhdGEuZW5kUFRTKSkge1xyXG4gICAgICAgICAgICAgICAgZGF0YS5lbmRQVFMgPSBkYXRhLnN0YXJ0UFRTICsgZnJhZ0N1cnJlbnQuZHVyYXRpb247XHJcbiAgICAgICAgICAgICAgICBkYXRhLmVuZERUUyA9IGRhdGEuc3RhcnREVFMgKyBmcmFnQ3VycmVudC5kdXJhdGlvbjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgbG9nZ2VyLmxvZyhgcGFyc2VkICR7ZGF0YS50eXBlfSxQVFM6WyR7ZGF0YS5zdGFydFBUUy50b0ZpeGVkKDMpfSwke2RhdGEuZW5kUFRTLnRvRml4ZWQoMyl9XSxEVFM6WyR7ZGF0YS5zdGFydERUUy50b0ZpeGVkKDMpfS8ke2RhdGEuZW5kRFRTLnRvRml4ZWQoMyl9XSxuYjoke2RhdGEubmJ9YCk7XHJcbiAgICAgICAgICAgIExldmVsSGVscGVyLnVwZGF0ZUZyYWdQVFNEVFModHJhY2suZGV0YWlscywgZnJhZ0N1cnJlbnQsIGRhdGEuc3RhcnRQVFMsIGRhdGEuZW5kUFRTKTtcclxuXHJcbiAgICAgICAgICAgIGxldCBhdWRpb1N3aXRjaCA9IHRoaXMuYXVkaW9Td2l0Y2gsIG1lZGlhID0gdGhpcy5tZWRpYSwgYXBwZW5kT25CdWZmZXJGbHVzaCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAvL09ubHkgZmx1c2ggYXVkaW8gZnJvbSBvbGQgYXVkaW8gdHJhY2tzIHdoZW4gUFRTIGlzIGtub3duIG9uIG5ldyBhdWRpbyB0cmFja1xyXG4gICAgICAgICAgICBpZiAoYXVkaW9Td2l0Y2ggJiYgbWVkaWEpIHtcclxuICAgICAgICAgICAgICAgIGlmIChtZWRpYS5yZWFkeVN0YXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGN1cnJlbnRUaW1lID0gbWVkaWEuY3VycmVudFRpbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmxvZygnc3dpdGNoaW5nIGF1ZGlvIHRyYWNrIDogY3VycmVudFRpbWU6JyArIGN1cnJlbnRUaW1lKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudFRpbWUgPj0gZGF0YS5zdGFydFBUUykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIubG9nKCdzd2l0Y2hpbmcgYXVkaW8gdHJhY2sgOiBmbHVzaGluZyBhbGwgYXVkaW8nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkJVRkZFUl9GTFVTSElORztcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnQuQlVGRkVSX0ZMVVNISU5HLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydE9mZnNldDogMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZE9mZnNldDogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2F1ZGlvJ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXBwZW5kT25CdWZmZXJGbHVzaCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vTGV0cyBhbm5vdW5jZSB0aGF0IHRoZSBpbml0aWFsIGF1ZGlvIHRyYWNrIHN3aXRjaCBmbHVzaCBvY2N1clxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmF1ZGlvU3dpdGNoID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhscy50cmlnZ2VyKEV2ZW50LkFVRElPX1RSQUNLX1NXSVRDSEVELCB7aWQ6IHRyYWNrSWR9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vTGV0cyBhbm5vdW5jZSB0aGF0IHRoZSBpbml0aWFsIGF1ZGlvIHRyYWNrIHN3aXRjaCBmbHVzaCBvY2N1clxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXVkaW9Td2l0Y2ggPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICBobHMudHJpZ2dlcihFdmVudC5BVURJT19UUkFDS19TV0lUQ0hFRCwge2lkOiB0cmFja0lkfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgICAgICBsZXQgcGVuZGluZ0RhdGEgPSB0aGlzLnBlbmRpbmdEYXRhO1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuYXVkaW9Td2l0Y2gpIHtcclxuICAgICAgICAgICAgICAgIFtkYXRhLmRhdGExLCBkYXRhLmRhdGEyXS5mb3JFYWNoKGJ1ZmZlciA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJ1ZmZlciAmJiBidWZmZXIubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBlbmRpbmdEYXRhLnB1c2goe3R5cGU6IGRhdGEudHlwZSwgZGF0YTogYnVmZmVyLCBwYXJlbnQ6ICdhdWRpbycsIGNvbnRlbnQ6ICdkYXRhJ30pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFhcHBlbmRPbkJ1ZmZlckZsdXNoICYmIHBlbmRpbmdEYXRhLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBlbmRpbmdEYXRhLmZvckVhY2goYXBwZW5kT2JqID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gb25seSBhcHBlbmQgaW4gUEFSU0lORyBzdGF0ZSAocmF0aW9uYWxlIGlzIHRoYXQgYW4gYXBwZW5kaW5nIGVycm9yIGNvdWxkIGhhcHBlbiBzeW5jaHJvbm91c2x5IG9uIGZpcnN0IHNlZ21lbnQgYXBwZW5kaW5nKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpbiB0aGF0IGNhc2UgaXQgaXMgdXNlbGVzcyB0byBhcHBlbmQgZm9sbG93aW5nIHNlZ21lbnRzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlID09PSBTdGF0ZS5QQVJTSU5HKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhcm0gcGVuZGluZyBCdWZmZXJpbmcgZmxhZyBiZWZvcmUgYXBwZW5kaW5nIGEgc2VnbWVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nQnVmZmVyaW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuQlVGRkVSX0FQUEVORElORywgYXBwZW5kT2JqKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ0RhdGEgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcGVuZGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvL3RyaWdnZXIgaGFuZGxlciByaWdodCBub3dcclxuICAgICAgICAgICAgdGhpcy50aWNrKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIG9uRnJhZ1BhcnNlZChkYXRhKSB7XHJcbiAgICAgICAgY29uc3QgZnJhZ0N1cnJlbnQgPSB0aGlzLmZyYWdDdXJyZW50O1xyXG4gICAgICAgIGNvbnN0IGZyYWdOZXcgPSBkYXRhLmZyYWc7XHJcbiAgICAgICAgaWYgKGZyYWdDdXJyZW50ICYmXHJcbiAgICAgICAgICAgIGRhdGEuaWQgPT09ICdhdWRpbycgJiZcclxuICAgICAgICAgICAgZnJhZ05ldy5zbiA9PT0gZnJhZ0N1cnJlbnQuc24gJiZcclxuICAgICAgICAgICAgZnJhZ05ldy5sZXZlbCA9PT0gZnJhZ0N1cnJlbnQubGV2ZWwgJiZcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9PT0gU3RhdGUuUEFSU0lORykge1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRzLnRwYXJzZWQgPSBwZXJmb3JtYW5jZS5ub3coKTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLlBBUlNFRDtcclxuICAgICAgICAgICAgdGhpcy5fY2hlY2tBcHBlbmRlZFBhcnNlZCgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcblxyXG4gICAgb25CdWZmZXJDcmVhdGVkKGRhdGEpIHtcclxuICAgICAgICBsZXQgYXVkaW9UcmFjayA9IGRhdGEudHJhY2tzLmF1ZGlvO1xyXG4gICAgICAgIGlmIChhdWRpb1RyYWNrKSB7XHJcbiAgICAgICAgICAgIHRoaXMubWVkaWFCdWZmZXIgPSBhdWRpb1RyYWNrLmJ1ZmZlcjtcclxuICAgICAgICAgICAgdGhpcy5sb2FkZWRtZXRhZGF0YSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIG9uQnVmZmVyQXBwZW5kZWQoZGF0YSkge1xyXG4gICAgICAgIGlmIChkYXRhLnBhcmVudCA9PT0gJ2F1ZGlvJykge1xyXG4gICAgICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuc3RhdGU7XHJcbiAgICAgICAgICAgIGlmIChzdGF0ZSA9PT0gU3RhdGUuUEFSU0lORyB8fCBzdGF0ZSA9PT0gU3RhdGUuUEFSU0VEKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBjaGVjayBpZiBhbGwgYnVmZmVycyBoYXZlIGJlZW4gYXBwZW5kZWRcclxuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ0J1ZmZlcmluZyA9IChkYXRhLnBlbmRpbmcgPiAwKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2NoZWNrQXBwZW5kZWRQYXJzZWQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBfY2hlY2tBcHBlbmRlZFBhcnNlZCgpIHtcclxuICAgICAgICAvL3RyaWdnZXIgaGFuZGxlciByaWdodCBub3dcclxuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuUEFSU0VEICYmICghdGhpcy5hcHBlbmRlZCB8fCAhdGhpcy5wZW5kaW5nQnVmZmVyaW5nKSkge1xyXG4gICAgICAgICAgICBsZXQgZnJhZyA9IHRoaXMuZnJhZ0N1cnJlbnQsIHN0YXRzID0gdGhpcy5zdGF0cywgaGxzID0gdGhpcy5obHM7XHJcbiAgICAgICAgICAgIGlmIChmcmFnKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmZyYWdQcmV2aW91cyA9IGZyYWc7XHJcbiAgICAgICAgICAgICAgICBzdGF0cy50YnVmZmVyZWQgPSBwZXJmb3JtYW5jZS5ub3coKTtcclxuICAgICAgICAgICAgICAgIGhscy50cmlnZ2VyKEV2ZW50LkZSQUdfQlVGRkVSRUQsIHtzdGF0czogc3RhdHMsIGZyYWc6IGZyYWcsIGlkOiAnYXVkaW8nfSk7XHJcbiAgICAgICAgICAgICAgICBsZXQgbWVkaWEgPSB0aGlzLm1lZGlhQnVmZmVyID8gdGhpcy5tZWRpYUJ1ZmZlciA6IHRoaXMubWVkaWE7XHJcbiAgICAgICAgICAgICAgICBsb2dnZXIubG9nKGBhdWRpbyBidWZmZXJlZCA6ICR7VGltZVJhbmdlcy50b1N0cmluZyhtZWRpYS5idWZmZXJlZCl9YCk7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5hdWRpb1N3aXRjaCAmJiB0aGlzLmFwcGVuZGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdWRpb1N3aXRjaCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGhscy50cmlnZ2VyKEV2ZW50LkFVRElPX1RSQUNLX1NXSVRDSEVELCB7aWQ6IHRoaXMudHJhY2tJZH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy50aWNrKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIG9uRXJyb3IoZGF0YSkge1xyXG4gICAgICAgIGxldCBmcmFnID0gZGF0YS5mcmFnO1xyXG4gICAgICAgIC8vIGRvbid0IGhhbmRsZSBmcmFnIGVycm9yIG5vdCByZWxhdGVkIHRvIGF1ZGlvIGZyYWdtZW50XHJcbiAgICAgICAgLy8gaWYgKGZyYWcgJiYgZnJhZy50eXBlICE9PSAnYXVkaW8nKSB7XHJcbiAgICAgICAgLy8gICAgIHJldHVybjtcclxuICAgICAgICAvLyB9XHJcblxyXG4gICAgICAgIGxldCBkZXRhaWxzID0gZGF0YS5kZXRhaWxzLFxyXG4gICAgICAgICAgICBobHMgPSB0aGlzLmhscyxcclxuICAgICAgICAgICAgX3RoaXMgPSB0aGlzLFxyXG4gICAgICAgICAgICBsZXZlbElkLCBsZXZlbCwgbGV2ZWxFcnJvciA9IGZhbHNlO1xyXG5cclxuICAgICAgICBsZXQgc2VsVHJhY2tJZCA9IGhscy5hdWRpb1RyYWNrQ29udHJvbGxlci50cmFja0lkO1xyXG5cclxuICAgICAgICBzd2l0Y2ggKGRhdGEuZGV0YWlscykge1xyXG4gICAgICAgICAgICBjYXNlIEVycm9yRGV0YWlscy5GUkFHX0xPQURfRVJST1I6XHJcbiAgICAgICAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkZSQUdfTE9BRF9USU1FT1VUOlxyXG4gICAgICAgICAgICAgICAgaWYgKCFkYXRhLmZhdGFsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxvYWRFcnJvciA9IHRoaXMuZnJhZ0xvYWRFcnJvcjtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobG9hZEVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvYWRFcnJvcisrO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvYWRFcnJvciA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGxldCBjb25maWcgPSB0aGlzLmNvbmZpZztcclxuICAgICAgICAgICAgICAgICAgICBpZiAobG9hZEVycm9yIDw9IGNvbmZpZy5mcmFnTG9hZGluZ01heFJldHJ5KSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2NoZWNraW5nIGlmIHRoZXJlIGFyZSBkaWZmZXJlbnQgZ3JvdXAgdHJhY2sgaWRzIGZvciByZWR1bmRhbnQgdHJhY2sgZnVuY3Rpb25hbGl0eVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcmVkdW5kYW50VHJhY2tBdmFpbGFibGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSBpbiBobHMuYXVkaW9UcmFja0NvbnRyb2xsZXIudHJhY2tzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihobHMuYXVkaW9UcmFja0NvbnRyb2xsZXIudHJhY2tzW2ldLmdyb3VwSWQgIT09IGhscy5hdWRpb1RyYWNrQ29udHJvbGxlci50cmFja3Nbc2VsVHJhY2tJZF0uZ3JvdXBJZCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVkdW5kYW50VHJhY2tBdmFpbGFibGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3NldHRpbmcgYmFja3VwIHRyYWNrIHwgbG9nXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHJlZHVuZGFudFRyYWNrQXZhaWxhYmxlKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCByZWR1bmRhbnRUcmFja0lkID0gKChobHMuYXVkaW9UcmFja0NvbnRyb2xsZXIudHJhY2tzLmxlbmd0aCAvIDIgKSkgKyBzZWxUcmFja0lkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGxzLmF1ZGlvVHJhY2tDb250cm9sbGVyLnRyYWNrSWQgPSByZWR1bmRhbnRUcmFja0lkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMudHJhY2tJZCA9IHJlZHVuZGFudFRyYWNrSWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIud2FybihgYXVkaW9TdHJlYW1Db250cm9sbGVyOiBubyBiYWNrdXAgYXVkaW8gdHJhY2tzIGF2YWlsYWJsZWApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZyYWdMb2FkRXJyb3IgPSBsb2FkRXJyb3I7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlc2V0IGxvYWQgY291bnRlciB0byBhdm9pZCBmcmFnIGxvb3AgbG9hZGluZyBlcnJvclxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmcmFnLmxvYWRDb3VudGVyID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXhwb25lbnRpYWwgYmFja29mZiBjYXBwZWQgdG8gY29uZmlnLmZyYWdMb2FkaW5nTWF4UmV0cnlUaW1lb3V0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkZWxheSA9IE1hdGgubWluKE1hdGgucG93KDIsIGxvYWRFcnJvciAtIDEpICogY29uZmlnLmZyYWdMb2FkaW5nUmV0cnlEZWxheSwgY29uZmlnLmZyYWdMb2FkaW5nTWF4UmV0cnlUaW1lb3V0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLndhcm4oYGF1ZGlvU3RyZWFtQ29udHJvbGxlcjogZnJhZyBsb2FkaW5nIGZhaWxlZCwgcmV0cnkgaW4gJHtkZWxheX0gbXNgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXRyeURhdGUgPSBwZXJmb3JtYW5jZS5ub3coKSArIGRlbGF5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZXRyeSBsb2FkaW5nIHN0YXRlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5GUkFHX0xPQURJTkdfV0FJVElOR19SRVRSWTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoYGF1ZGlvU3RyZWFtQ29udHJvbGxlcjogJHtkYXRhLmRldGFpbHN9IHJlYWNoZXMgbWF4IHJldHJ5LCByZWRpc3BhdGNoIGFzIGZhdGFsIC4uLmApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzd2l0Y2ggZXJyb3IgdG8gZmF0YWxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5mYXRhbCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5FUlJPUjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBFcnJvckRldGFpbHMuRlJBR19MT09QX0xPQURJTkdfRVJST1I6XHJcbiAgICAgICAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkFVRElPX1RSQUNLX0xPQURfRVJST1I6XHJcbiAgICAgICAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkFVRElPX1RSQUNLX0xPQURfVElNRU9VVDpcclxuICAgICAgICAgICAgY2FzZSBFcnJvckRldGFpbHMuS0VZX0xPQURfRVJST1I6XHJcbiAgICAgICAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLktFWV9MT0FEX1RJTUVPVVQ6XHJcbiAgICAgICAgICAgICAgICAvLyAgd2hlbiBpbiBFUlJPUiBzdGF0ZSwgZG9uJ3Qgc3dpdGNoIGJhY2sgdG8gSURMRSBzdGF0ZSBpbiBjYXNlIGEgbm9uLWZhdGFsIGVycm9yIGlzIHJlY2VpdmVkXHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gU3RhdGUuRVJST1IpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBpZiBmYXRhbCBlcnJvciwgc3RvcCBwcm9jZXNzaW5nLCBvdGhlcndpc2UgbW92ZSB0byBJRExFIHRvIHJldHJ5IGxvYWRpbmdcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gZGF0YS5mYXRhbCA/IFN0YXRlLkVSUk9SIDogU3RhdGUuSURMRTtcclxuICAgICAgICAgICAgICAgICAgICBsb2dnZXIud2FybihgYXVkaW9TdHJlYW1Db250cm9sbGVyOiAke2RhdGEuZGV0YWlsc30gd2hpbGUgbG9hZGluZyBmcmFnLHN3aXRjaCB0byAke3RoaXMuc3RhdGV9IHN0YXRlIC4uLmApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkJVRkZFUl9GVUxMX0VSUk9SOlxyXG4gICAgICAgICAgICAgICAgLy8gaWYgaW4gYXBwZW5kaW5nIHN0YXRlXHJcbiAgICAgICAgICAgICAgICBpZiAoZGF0YS5wYXJlbnQgPT09ICdhdWRpbycgJiYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLlBBUlNJTkcgfHwgdGhpcy5zdGF0ZSA9PT0gU3RhdGUuUEFSU0VEKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1lZGlhID0gdGhpcy5tZWRpYUJ1ZmZlcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFRpbWUgPSB0aGlzLm1lZGlhLmN1cnJlbnRUaW1lLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtZWRpYUJ1ZmZlcmVkID0gbWVkaWEgJiYgQnVmZmVySGVscGVyLmlzQnVmZmVyZWQobWVkaWEsIGN1cnJlbnRUaW1lKSAmJiBCdWZmZXJIZWxwZXIuaXNCdWZmZXJlZChtZWRpYSwgY3VycmVudFRpbWUgKyAwLjUpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlZHVjZSBtYXggYnVmIGxlbiBpZiBjdXJyZW50IHBvc2l0aW9uIGlzIGJ1ZmZlcmVkXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1lZGlhQnVmZmVyZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY29uZmlnID0gdGhpcy5jb25maWc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb25maWcubWF4TWF4QnVmZmVyTGVuZ3RoID49IGNvbmZpZy5tYXhCdWZmZXJMZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlZHVjZSBtYXggYnVmZmVyIGxlbmd0aCBhcyBpdCBtaWdodCBiZSB0b28gaGlnaC4gd2UgZG8gdGhpcyB0byBhdm9pZCBsb29wIGZsdXNoaW5nIC4uLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnLm1heE1heEJ1ZmZlckxlbmd0aCAvPSAyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLndhcm4oYGF1ZGlvOnJlZHVjZSBtYXggYnVmZmVyIGxlbmd0aCB0byAke2NvbmZpZy5tYXhNYXhCdWZmZXJMZW5ndGh9c2ApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW5jcmVhc2UgZnJhZ21lbnQgbG9hZCBJbmRleCB0byBhdm9pZCBmcmFnIGxvb3AgbG9hZGluZyBlcnJvciBhZnRlciBidWZmZXIgZmx1c2hcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZnJhZ0xvYWRJZHggKz0gMiAqIGNvbmZpZy5mcmFnTG9hZGluZ0xvb3BUaHJlc2hvbGQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY3VycmVudCBwb3NpdGlvbiBpcyBub3QgYnVmZmVyZWQsIGJ1dCBicm93c2VyIGlzIHN0aWxsIGNvbXBsYWluaW5nIGFib3V0IGJ1ZmZlciBmdWxsIGVycm9yXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgaGFwcGVucyBvbiBJRS9FZGdlLCByZWZlciB0byBodHRwczovL2dpdGh1Yi5jb20vdmlkZW8tZGV2L2hscy5qcy9wdWxsLzcwOFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpbiB0aGF0IGNhc2UgZmx1c2ggdGhlIHdob2xlIGF1ZGlvIGJ1ZmZlciB0byByZWNvdmVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci53YXJuKCdidWZmZXIgZnVsbCBlcnJvciBhbHNvIG1lZGlhLmN1cnJlbnRUaW1lIGlzIG5vdCBidWZmZXJlZCwgZmx1c2ggYXVkaW8gYnVmZmVyJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZnJhZ0N1cnJlbnQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBmbHVzaCBldmVyeXRoaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5CVUZGRVJfRkxVU0hJTkc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuQlVGRkVSX0ZMVVNISU5HLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydE9mZnNldDogMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZE9mZnNldDogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2F1ZGlvJ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBvbkJ1ZmZlckZsdXNoZWQoKSB7XHJcbiAgICAgICAgbGV0IHBlbmRpbmdEYXRhID0gdGhpcy5wZW5kaW5nRGF0YTtcclxuICAgICAgICBpZiAocGVuZGluZ0RhdGEgJiYgcGVuZGluZ0RhdGEubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGxvZ2dlci5sb2coJ2FwcGVuZGluZyBwZW5kaW5nIGF1ZGlvIGRhdGEgb24gQnVmZmVyIEZsdXNoZWQnKTtcclxuICAgICAgICAgICAgcGVuZGluZ0RhdGEuZm9yRWFjaChhcHBlbmRPYmogPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5CVUZGRVJfQVBQRU5ESU5HLCBhcHBlbmRPYmopO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdGhpcy5hcHBlbmRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ0RhdGEgPSBbXTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLlBBUlNFRDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBtb3ZlIHRvIElETEUgb25jZSBmbHVzaCBjb21wbGV0ZS4gdGhpcyBzaG91bGQgdHJpZ2dlciBuZXcgZnJhZ21lbnQgbG9hZGluZ1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcclxuICAgICAgICAgICAgLy8gcmVzZXQgcmVmZXJlbmNlIHRvIGZyYWdcclxuICAgICAgICAgICAgdGhpcy5mcmFnUHJldmlvdXMgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLnRpY2soKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0IGRlZmF1bHQgQXVkaW9TdHJlYW1Db250cm9sbGVyO1xyXG5cclxuIiwiLypcclxuICogYXVkaW8gdHJhY2sgY29udHJvbGxlclxyXG4qL1xyXG5cclxuaW1wb3J0IEV2ZW50IGZyb20gJy4uL2V2ZW50cyc7XHJcbmltcG9ydCBFdmVudEhhbmRsZXIgZnJvbSAnLi4vZXZlbnQtaGFuZGxlcic7XHJcbmltcG9ydCB7bG9nZ2VyfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xyXG5cclxuY2xhc3MgQXVkaW9UcmFja0NvbnRyb2xsZXIgZXh0ZW5kcyBFdmVudEhhbmRsZXIge1xyXG5cclxuICBjb25zdHJ1Y3RvcihobHMpIHtcclxuICAgIHN1cGVyKGhscywgRXZlbnQuTUFOSUZFU1RfTE9BRElORyxcclxuICAgICAgICAgICAgICAgRXZlbnQuTUFOSUZFU1RfTE9BREVELFxyXG4gICAgICAgICAgICAgICBFdmVudC5BVURJT19UUkFDS19MT0FERUQpO1xyXG4gICAgdGhpcy50aWNrcyA9IDA7XHJcbiAgICB0aGlzLm9udGljayA9IHRoaXMudGljay5iaW5kKHRoaXMpO1xyXG4gIH1cclxuXHJcbiAgZGVzdHJveSgpIHtcclxuICAgIEV2ZW50SGFuZGxlci5wcm90b3R5cGUuZGVzdHJveS5jYWxsKHRoaXMpO1xyXG4gIH1cclxuICB0aWNrKCkge1xyXG4gICAgdGhpcy50aWNrcysrO1xyXG4gICAgaWYgKHRoaXMudGlja3MgPT09IDEpIHtcclxuICAgICAgdGhpcy5kb1RpY2soKTtcclxuICAgICAgaWYgKHRoaXMudGlja3MgPiAxKSB7XHJcbiAgICAgICAgc2V0VGltZW91dCh0aGlzLnRpY2ssIDEpO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMudGlja3MgPSAwO1xyXG4gICAgfVxyXG4gIH1cclxuICBkb1RpY2soKSB7XHJcbiAgICB0aGlzLnVwZGF0ZVRyYWNrKHRoaXMudHJhY2tJZCk7XHJcbiAgfVxyXG4gIG9uTWFuaWZlc3RMb2FkaW5nKCkge1xyXG4gICAgLy8gcmVzZXQgYXVkaW8gdHJhY2tzIG9uIG1hbmlmZXN0IGxvYWRpbmdcclxuICAgIHRoaXMudHJhY2tzID0gW107XHJcbiAgICB0aGlzLnRyYWNrSWQgPSAtMTtcclxuICB9XHJcblxyXG4gIG9uTWFuaWZlc3RMb2FkZWQoZGF0YSkge1xyXG4gICAgbGV0IHRyYWNrcyA9IGRhdGEuYXVkaW9UcmFja3MgfHwgW107XHJcbiAgICBsZXQgZGVmYXVsdEZvdW5kID0gZmFsc2U7XHJcbiAgICB0aGlzLnRyYWNrcyA9IHRyYWNrcztcclxuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuQVVESU9fVFJBQ0tTX1VQREFURUQsIHthdWRpb1RyYWNrcyA6IHRyYWNrc30pO1xyXG4gICAgLy8gbG9vcCB0aHJvdWdoIGF2YWlsYWJsZSBhdWRpbyB0cmFja3MgYW5kIGF1dG9zZWxlY3QgZGVmYXVsdCBpZiBuZWVkZWRcclxuICAgIGxldCBpZCA9IDA7XHJcbiAgICB0cmFja3MuZm9yRWFjaCh0cmFjayA9PiB7XHJcbiAgICAgIGlmKHRyYWNrLmRlZmF1bHQpIHtcclxuICAgICAgICB0aGlzLmF1ZGlvVHJhY2sgPSBpZDtcclxuICAgICAgICBkZWZhdWx0Rm91bmQgPSB0cnVlO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBpZCsrO1xyXG4gICAgfSk7XHJcbiAgICBpZiAoZGVmYXVsdEZvdW5kID09PSBmYWxzZSAmJiB0cmFja3MubGVuZ3RoKSB7XHJcbiAgICAgIGxvZ2dlci5sb2coJ25vIGRlZmF1bHQgYXVkaW8gdHJhY2sgZGVmaW5lZCwgdXNlIGZpcnN0IGF1ZGlvIHRyYWNrIGFzIGRlZmF1bHQnKTtcclxuICAgICAgdGhpcy5hdWRpb1RyYWNrID0gMDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIG9uQXVkaW9UcmFja0xvYWRlZChkYXRhKSB7XHJcbiAgICBpZiAoZGF0YS5pZCA8IHRoaXMudHJhY2tzLmxlbmd0aCkge1xyXG4gICAgICBsb2dnZXIubG9nKGBhdWRpb1RyYWNrICR7ZGF0YS5pZH0gbG9hZGVkYCk7XHJcbiAgICAgIHRoaXMudHJhY2tzW2RhdGEuaWRdLmRldGFpbHMgPSBkYXRhLmRldGFpbHM7XHJcbiAgICAgIC8vIGNoZWNrIGlmIGN1cnJlbnQgcGxheWxpc3QgaXMgYSBsaXZlIHBsYXlsaXN0XHJcbiAgICAgIGlmIChkYXRhLmRldGFpbHMubGl2ZSAmJiAhdGhpcy50aW1lcikge1xyXG4gICAgICAgIC8vIGlmIGxpdmUgcGxheWxpc3Qgd2Ugd2lsbCBoYXZlIHRvIHJlbG9hZCBpdCBwZXJpb2RpY2FsbHlcclxuICAgICAgICAvLyBzZXQgcmVsb2FkIHBlcmlvZCB0byBwbGF5bGlzdCB0YXJnZXQgZHVyYXRpb25cclxuICAgICAgICB0aGlzLnRpbWVyID0gc2V0SW50ZXJ2YWwodGhpcy5vbnRpY2ssIDEwMDAgKiBkYXRhLmRldGFpbHMudGFyZ2V0ZHVyYXRpb24pO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICghZGF0YS5kZXRhaWxzLmxpdmUgJiYgdGhpcy50aW1lcikge1xyXG4gICAgICAgIC8vIHBsYXlsaXN0IGlzIG5vdCBsaXZlIGFuZCB0aW1lciBpcyBhcm1lZCA6IHN0b3BwaW5nIGl0XHJcbiAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLnRpbWVyKTtcclxuICAgICAgICB0aGlzLnRpbWVyID0gbnVsbDtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqIGdldCBhbHRlcm5hdGUgYXVkaW8gdHJhY2tzIGxpc3QgZnJvbSBwbGF5bGlzdCAqKi9cclxuICBnZXQgYXVkaW9UcmFja3MoKSB7XHJcbiAgICByZXR1cm4gdGhpcy50cmFja3M7XHJcbiAgfVxyXG5cclxuICAvKiogZ2V0IGluZGV4IG9mIHRoZSBzZWxlY3RlZCBhdWRpbyB0cmFjayAoaW5kZXggaW4gYXVkaW8gdHJhY2sgbGlzdHMpICoqL1xyXG4gIGdldCBhdWRpb1RyYWNrKCkge1xyXG4gICByZXR1cm4gdGhpcy50cmFja0lkO1xyXG4gIH1cclxuXHJcbiAgLyoqIHNlbGVjdCBhbiBhdWRpbyB0cmFjaywgYmFzZWQgb24gaXRzIGluZGV4IGluIGF1ZGlvIHRyYWNrIGxpc3RzKiovXHJcbiAgc2V0IGF1ZGlvVHJhY2soYXVkaW9UcmFja0lkKSB7XHJcbiAgICBpZiAodGhpcy50cmFja0lkICE9PSBhdWRpb1RyYWNrSWQgfHwgdGhpcy50cmFja3NbYXVkaW9UcmFja0lkXS5kZXRhaWxzID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgdGhpcy5zZXRBdWRpb1RyYWNrSW50ZXJuYWwoYXVkaW9UcmFja0lkKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gc2V0QXVkaW9UcmFja0ludGVybmFsKG5ld0lkKSB7XHJcblxyXG4gICAgLy8gY2hlY2sgaWYgbGV2ZWwgaWR4IGlzIHZhbGlkXHJcbiAgICBpZiAobmV3SWQgPj0gMCAmJiBuZXdJZCA8IHRoaXMudHJhY2tzLmxlbmd0aCkge1xyXG4gICAgICAvLyBzdG9wcGluZyBsaXZlIHJlbG9hZGluZyB0aW1lciBpZiBhbnlcclxuICAgICAgaWYgKHRoaXMudGltZXIpIHtcclxuICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy50aW1lcik7XHJcbiAgICAgICB0aGlzLnRpbWVyID0gbnVsbDtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLnRyYWNrSWQgPSBuZXdJZDtcclxuICAgICAgbG9nZ2VyLmxvZyhgc3dpdGNoaW5nIHRvIGF1ZGlvVHJhY2sgJHtuZXdJZH1gKTtcclxuICAgICAgbGV0IGF1ZGlvVHJhY2sgPSB0aGlzLnRyYWNrc1tuZXdJZF0sXHJcbiAgICAgICAgICBobHMgPSB0aGlzLmhscyxcclxuICAgICAgICAgIHR5cGUgPSBhdWRpb1RyYWNrLnR5cGUsXHJcbiAgICAgICAgICB1cmwgPSBhdWRpb1RyYWNrLnVybCxcclxuICAgICAgICAgIGV2ZW50T2JqID0ge2lkOiBuZXdJZCwgdHlwZSA6IHR5cGUsIHVybCA6IHVybH07XHJcbiAgICAgIC8vIGtlZXAgQVVESU9fVFJBQ0tfU1dJVENIIGZvciBsZWdhY3kgcmVhc29uXHJcbiAgICAgIGhscy50cmlnZ2VyKEV2ZW50LkFVRElPX1RSQUNLX1NXSVRDSCwgZXZlbnRPYmopO1xyXG4gICAgICBobHMudHJpZ2dlcihFdmVudC5BVURJT19UUkFDS19TV0lUQ0hJTkcsIGV2ZW50T2JqKTtcclxuICAgICAgIC8vIGNoZWNrIGlmIHdlIG5lZWQgdG8gbG9hZCBwbGF5bGlzdCBmb3IgdGhpcyBhdWRpbyBUcmFja1xyXG4gICAgICAgbGV0IGRldGFpbHMgPSBhdWRpb1RyYWNrLmRldGFpbHM7XHJcbiAgICAgIGlmICh1cmwgJiYgKGRldGFpbHMgPT09IHVuZGVmaW5lZCB8fCBkZXRhaWxzLmxpdmUgPT09IHRydWUpKSB7XHJcbiAgICAgICAgLy8gdHJhY2sgbm90IHJldHJpZXZlZCB5ZXQsIG9yIGxpdmUgcGxheWxpc3Qgd2UgbmVlZCB0byAocmUpbG9hZCBpdFxyXG4gICAgICAgIGxvZ2dlci5sb2coYChyZSlsb2FkaW5nIHBsYXlsaXN0IGZvciBhdWRpb1RyYWNrICR7bmV3SWR9YCk7XHJcbiAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnQuQVVESU9fVFJBQ0tfTE9BRElORywge3VybDogdXJsLCBpZDogbmV3SWR9KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gb25FcnJvcihlcnIpe1xyXG4gIC8vIH1cclxuXHJcblxyXG4gIHVwZGF0ZVRyYWNrKG5ld0lkKSB7XHJcbiAgICAvLyBjaGVjayBpZiBsZXZlbCBpZHggaXMgdmFsaWRcclxuICAgIGlmIChuZXdJZCA+PSAwICYmIG5ld0lkIDwgdGhpcy50cmFja3MubGVuZ3RoKSB7XHJcbiAgICAgIC8vIHN0b3BwaW5nIGxpdmUgcmVsb2FkaW5nIHRpbWVyIGlmIGFueVxyXG4gICAgICBpZiAodGhpcy50aW1lcikge1xyXG4gICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLnRpbWVyKTtcclxuICAgICAgIHRoaXMudGltZXIgPSBudWxsO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMudHJhY2tJZCA9IG5ld0lkO1xyXG4gICAgICBsb2dnZXIubG9nKGB1cGRhdGluZyBhdWRpb1RyYWNrICR7bmV3SWR9YCk7XHJcbiAgICAgIGxldCBhdWRpb1RyYWNrID0gdGhpcy50cmFja3NbbmV3SWRdLCB1cmwgPSBhdWRpb1RyYWNrLnVybDtcclxuICAgICAgIC8vIGNoZWNrIGlmIHdlIG5lZWQgdG8gbG9hZCBwbGF5bGlzdCBmb3IgdGhpcyBhdWRpbyBUcmFja1xyXG4gICAgICAgbGV0IGRldGFpbHMgPSBhdWRpb1RyYWNrLmRldGFpbHM7XHJcbiAgICAgIGlmICh1cmwgJiYgKGRldGFpbHMgPT09IHVuZGVmaW5lZCB8fCBkZXRhaWxzLmxpdmUgPT09IHRydWUpKSB7XHJcbiAgICAgICAgLy8gdHJhY2sgbm90IHJldHJpZXZlZCB5ZXQsIG9yIGxpdmUgcGxheWxpc3Qgd2UgbmVlZCB0byAocmUpbG9hZCBpdFxyXG4gICAgICAgIGxvZ2dlci5sb2coYChyZSlsb2FkaW5nIHBsYXlsaXN0IGZvciBhdWRpb1RyYWNrICR7bmV3SWR9YCk7XHJcbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5BVURJT19UUkFDS19MT0FESU5HLCB7dXJsOiB1cmwsIGlkOiBuZXdJZH0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBBdWRpb1RyYWNrQ29udHJvbGxlcjtcclxuIiwiLypcclxuICogQnVmZmVyIENvbnRyb2xsZXJcclxuKi9cclxuXHJcbmltcG9ydCBFdmVudCBmcm9tICcuLi9ldmVudHMnO1xyXG5pbXBvcnQgRXZlbnRIYW5kbGVyIGZyb20gJy4uL2V2ZW50LWhhbmRsZXInO1xyXG5pbXBvcnQge2xvZ2dlcn0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcclxuaW1wb3J0IHtFcnJvclR5cGVzLCBFcnJvckRldGFpbHN9IGZyb20gJy4uL2Vycm9ycyc7XHJcblxyXG5cclxuY2xhc3MgQnVmZmVyQ29udHJvbGxlciBleHRlbmRzIEV2ZW50SGFuZGxlciB7XHJcblxyXG4gIGNvbnN0cnVjdG9yKGhscykge1xyXG4gICAgc3VwZXIoaGxzLFxyXG4gICAgICBFdmVudC5NRURJQV9BVFRBQ0hJTkcsXHJcbiAgICAgIEV2ZW50Lk1FRElBX0RFVEFDSElORyxcclxuICAgICAgRXZlbnQuTUFOSUZFU1RfUEFSU0VELFxyXG4gICAgICBFdmVudC5CVUZGRVJfUkVTRVQsXHJcbiAgICAgIEV2ZW50LkJVRkZFUl9BUFBFTkRJTkcsXHJcbiAgICAgIEV2ZW50LkJVRkZFUl9DT0RFQ1MsXHJcbiAgICAgIEV2ZW50LkJVRkZFUl9FT1MsXHJcbiAgICAgIEV2ZW50LkJVRkZFUl9GTFVTSElORyxcclxuICAgICAgRXZlbnQuTEVWRUxfUFRTX1VQREFURUQsXHJcbiAgICAgIEV2ZW50LkxFVkVMX1VQREFURUQpO1xyXG5cclxuICAgIC8vIHRoZSB2YWx1ZSB0aGF0IHdlIGhhdmUgc2V0IG1lZGlhc291cmNlLmR1cmF0aW9uIHRvXHJcbiAgICAvLyAodGhlIGFjdHVhbCBkdXJhdGlvbiBtYXkgYmUgdHdlYWtlZCBzbGlnaGx5IGJ5IHRoZSBicm93c2VyKVxyXG4gICAgdGhpcy5fbXNEdXJhdGlvbiA9IG51bGw7XHJcbiAgICAvLyB0aGUgdmFsdWUgdGhhdCB3ZSB3YW50IHRvIHNldCBtZWRpYVNvdXJjZS5kdXJhdGlvbiB0b1xyXG4gICAgdGhpcy5fbGV2ZWxEdXJhdGlvbiA9IG51bGw7XHJcblxyXG4gICAgLy8gU291cmNlIEJ1ZmZlciBsaXN0ZW5lcnNcclxuICAgIHRoaXMub25zYnVlID0gdGhpcy5vblNCVXBkYXRlRW5kLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzLm9uc2JlICA9IHRoaXMub25TQlVwZGF0ZUVycm9yLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzLnBlbmRpbmdUcmFja3MgPSB7fTtcclxuICAgIHRoaXMudHJhY2tzID0ge307XHJcbiAgfVxyXG5cclxuICBkZXN0cm95KCkge1xyXG4gICAgRXZlbnRIYW5kbGVyLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XHJcbiAgfVxyXG5cclxuICBvbkxldmVsUHRzVXBkYXRlZChkYXRhKSB7XHJcbiAgICBsZXQgdHlwZSA9IGRhdGEudHlwZTtcclxuICAgIGxldCBhdWRpb1RyYWNrID0gdGhpcy50cmFja3MuYXVkaW87XHJcblxyXG4gICAgLy8gQWRqdXN0aW5nIGBTb3VyY2VCdWZmZXIudGltZXN0YW1wT2Zmc2V0YCAoZGVzaXJlZCBwb2ludCBpbiB0aGUgdGltZWxpbmUgd2hlcmUgdGhlIG5leHQgZnJhbWVzIHNob3VsZCBiZSBhcHBlbmRlZClcclxuICAgIC8vIGluIENocm9tZSBicm93c2VyIHdoZW4gd2UgZGV0ZWN0IE1QRUcgYXVkaW8gY29udGFpbmVyIGFuZCB0aW1lIGRlbHRhIGJldHdlZW4gbGV2ZWwgUFRTIGFuZCBgU291cmNlQnVmZmVyLnRpbWVzdGFtcE9mZnNldGBcclxuICAgIC8vIGlzIGdyZWF0ZXIgdGhhbiAxMDBtcyAodGhpcyBpcyBlbm91Z2ggdG8gaGFuZGxlIHNlZWsgZm9yIFZPRCBvciBsZXZlbCBjaGFuZ2UgZm9yIExJVkUgdmlkZW9zKS4gQXQgdGhlIHRpbWUgb2YgY2hhbmdlIHdlIGlzc3VlXHJcbiAgICAvLyBgU291cmNlQnVmZmVyLmFib3J0KClgIGFuZCBhZGp1c3RpbmcgYFNvdXJjZUJ1ZmZlci50aW1lc3RhbXBPZmZzZXRgIGlmIGBTb3VyY2VCdWZmZXIudXBkYXRpbmdgIGlzIGZhbHNlIG9yIGF3YWl0aW5nIGB1cGRhdGVlbmRgXHJcbiAgICAvLyBldmVudCBpZiBTQiBpcyBpbiB1cGRhdGluZyBzdGF0ZS5cclxuICAgIC8vIE1vcmUgaW5mbyBoZXJlOiBodHRwczovL2dpdGh1Yi5jb20vdmlkZW8tZGV2L2hscy5qcy9pc3N1ZXMvMzMyI2lzc3VlY29tbWVudC0yNTc5ODY0ODZcclxuXHJcbiAgICBpZiAodHlwZSA9PT0gJ2F1ZGlvJyAmJiBhdWRpb1RyYWNrICYmIGF1ZGlvVHJhY2suY29udGFpbmVyID09PSAnYXVkaW8vbXBlZycpIHsgLy8gQ2hyb21lIGF1ZGlvIG1wMyB0cmFja1xyXG4gICAgICBsZXQgYXVkaW9CdWZmZXIgPSB0aGlzLnNvdXJjZUJ1ZmZlci5hdWRpbztcclxuICAgICAgbGV0IGRlbHRhID0gTWF0aC5hYnMoYXVkaW9CdWZmZXIudGltZXN0YW1wT2Zmc2V0IC0gZGF0YS5zdGFydCk7XHJcblxyXG4gICAgICAvLyBhZGp1c3QgdGltZXN0YW1wIG9mZnNldCBpZiB0aW1lIGRlbHRhIGlzIGdyZWF0ZXIgdGhhbiAxMDBtc1xyXG4gICAgICBpZiAoZGVsdGEgPiAwLjEpIHtcclxuICAgICAgICBsZXQgdXBkYXRpbmcgPSBhdWRpb0J1ZmZlci51cGRhdGluZztcclxuXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIGF1ZGlvQnVmZmVyLmFib3J0KCk7XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICB1cGRhdGluZyA9IHRydWU7XHJcbiAgICAgICAgICBsb2dnZXIud2FybignY2FuIG5vdCBhYm9ydCBhdWRpbyBidWZmZXI6ICcgKyBlcnIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCF1cGRhdGluZykge1xyXG4gICAgICAgICAgbG9nZ2VyLndhcm4oJ2NoYW5nZSBtcGVnIGF1ZGlvIHRpbWVzdGFtcCBvZmZzZXQgZnJvbSAnICsgYXVkaW9CdWZmZXIudGltZXN0YW1wT2Zmc2V0ICsgJyB0byAnICsgZGF0YS5zdGFydCk7XHJcbiAgICAgICAgICBhdWRpb0J1ZmZlci50aW1lc3RhbXBPZmZzZXQgPSBkYXRhLnN0YXJ0O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB0aGlzLmF1ZGlvVGltZXN0YW1wT2Zmc2V0ID0gZGF0YS5zdGFydDtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIG9uTWFuaWZlc3RQYXJzZWQoZGF0YSkge1xyXG4gICAgbGV0IGF1ZGlvRXhwZWN0ZWQgPSBkYXRhLmF1ZGlvLFxyXG4gICAgICAgIHZpZGVvRXhwZWN0ZWQgPSBkYXRhLnZpZGVvIHx8IChkYXRhLmxldmVscy5sZW5ndGggJiYgZGF0YS5hdWRpbyksXHJcbiAgICAgICAgc291cmNlQnVmZmVyTmIgPSAwO1xyXG4gICAgLy8gaW4gY2FzZSBvZiBhbHQgYXVkaW8gMiBCVUZGRVJfQ09ERUNTIGV2ZW50cyB3aWxsIGJlIHRyaWdnZXJlZCwgb25lIHBlciBzdHJlYW0gY29udHJvbGxlclxyXG4gICAgLy8gc291cmNlYnVmZmVycyB3aWxsIGJlIGNyZWF0ZWQgYWxsIGF0IG9uY2Ugd2hlbiB0aGUgZXhwZWN0ZWQgbmIgb2YgdHJhY2tzIHdpbGwgYmUgcmVhY2hlZFxyXG4gICAgLy8gaW4gY2FzZSBhbHQgYXVkaW8gaXMgbm90IHVzZWQsIG9ubHkgb25lIEJVRkZFUl9DT0RFQyBldmVudCB3aWxsIGJlIGZpcmVkIGZyb20gbWFpbiBzdHJlYW0gY29udHJvbGxlclxyXG4gICAgLy8gaXQgd2lsbCBjb250YWluIHRoZSBleHBlY3RlZCBuYiBvZiBzb3VyY2UgYnVmZmVycywgbm8gbmVlZCB0byBjb21wdXRlIGl0XHJcbiAgICBpZiAoZGF0YS5hbHRBdWRpbyAmJiAoYXVkaW9FeHBlY3RlZCB8fCB2aWRlb0V4cGVjdGVkKSkge1xyXG4gICAgICBzb3VyY2VCdWZmZXJOYiA9IChhdWRpb0V4cGVjdGVkID8gMSA6IDApICsgKHZpZGVvRXhwZWN0ZWQgPyAxIDogMCk7XHJcbiAgICAgIGxvZ2dlci5sb2coYCR7c291cmNlQnVmZmVyTmJ9IHNvdXJjZUJ1ZmZlcihzKSBleHBlY3RlZGApO1xyXG4gICAgfVxyXG4gICAgdGhpcy5zb3VyY2VCdWZmZXJOYiA9IHNvdXJjZUJ1ZmZlck5iO1xyXG4gIH1cclxuXHJcbiAgb25NZWRpYUF0dGFjaGluZyhkYXRhKSB7XHJcbiAgICBsZXQgbWVkaWEgPSB0aGlzLm1lZGlhID0gZGF0YS5tZWRpYTtcclxuICAgIGlmIChtZWRpYSkge1xyXG4gICAgICAvLyBzZXR1cCB0aGUgbWVkaWEgc291cmNlXHJcbiAgICAgIHZhciBtcyA9IHRoaXMubWVkaWFTb3VyY2UgPSBuZXcgTWVkaWFTb3VyY2UoKTtcclxuICAgICAgLy9NZWRpYSBTb3VyY2UgbGlzdGVuZXJzXHJcbiAgICAgIHRoaXMub25tc28gPSB0aGlzLm9uTWVkaWFTb3VyY2VPcGVuLmJpbmQodGhpcyk7XHJcbiAgICAgIHRoaXMub25tc2UgPSB0aGlzLm9uTWVkaWFTb3VyY2VFbmRlZC5iaW5kKHRoaXMpO1xyXG4gICAgICB0aGlzLm9ubXNjID0gdGhpcy5vbk1lZGlhU291cmNlQ2xvc2UuYmluZCh0aGlzKTtcclxuICAgICAgbXMuYWRkRXZlbnRMaXN0ZW5lcignc291cmNlb3BlbicsIHRoaXMub25tc28pO1xyXG4gICAgICBtcy5hZGRFdmVudExpc3RlbmVyKCdzb3VyY2VlbmRlZCcsIHRoaXMub25tc2UpO1xyXG4gICAgICBtcy5hZGRFdmVudExpc3RlbmVyKCdzb3VyY2VjbG9zZScsIHRoaXMub25tc2MpO1xyXG4gICAgICAvLyBsaW5rIHZpZGVvIGFuZCBtZWRpYSBTb3VyY2VcclxuICAgICAgbWVkaWEuc3JjID0gVVJMLmNyZWF0ZU9iamVjdFVSTChtcyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBvbk1lZGlhRGV0YWNoaW5nKCkge1xyXG4gICAgbG9nZ2VyLmxvZygnbWVkaWEgc291cmNlIGRldGFjaGluZycpO1xyXG4gICAgdmFyIG1zID0gdGhpcy5tZWRpYVNvdXJjZTtcclxuICAgIGlmIChtcykge1xyXG4gICAgICBpZiAobXMucmVhZHlTdGF0ZSA9PT0gJ29wZW4nKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIC8vIGVuZE9mU3RyZWFtIGNvdWxkIHRyaWdnZXIgZXhjZXB0aW9uIGlmIGFueSBzb3VyY2VidWZmZXIgaXMgaW4gdXBkYXRpbmcgc3RhdGVcclxuICAgICAgICAgIC8vIHdlIGRvbid0IHJlYWxseSBjYXJlIGFib3V0IGNoZWNraW5nIHNvdXJjZWJ1ZmZlciBzdGF0ZSBoZXJlLFxyXG4gICAgICAgICAgLy8gYXMgd2UgYXJlIGFueXdheSBkZXRhY2hpbmcgdGhlIE1lZGlhU291cmNlXHJcbiAgICAgICAgICAvLyBsZXQncyBqdXN0IGF2b2lkIHRoaXMgZXhjZXB0aW9uIHRvIHByb3BhZ2F0ZVxyXG4gICAgICAgICAgbXMuZW5kT2ZTdHJlYW0oKTtcclxuICAgICAgICB9IGNhdGNoKGVycikge1xyXG4gICAgICAgICAgbG9nZ2VyLndhcm4oYG9uTWVkaWFEZXRhY2hpbmc6JHtlcnIubWVzc2FnZX0gd2hpbGUgY2FsbGluZyBlbmRPZlN0cmVhbWApO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBtcy5yZW1vdmVFdmVudExpc3RlbmVyKCdzb3VyY2VvcGVuJywgdGhpcy5vbm1zbyk7XHJcbiAgICAgIG1zLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3NvdXJjZWVuZGVkJywgdGhpcy5vbm1zZSk7XHJcbiAgICAgIG1zLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3NvdXJjZWNsb3NlJywgdGhpcy5vbm1zYyk7XHJcblxyXG4gICAgICAvLyBEZXRhY2ggcHJvcGVybHkgdGhlIE1lZGlhU291cmNlIGZyb20gdGhlIEhUTUxNZWRpYUVsZW1lbnQgYXNcclxuICAgICAgLy8gc3VnZ2VzdGVkIGluIGh0dHBzOi8vZ2l0aHViLmNvbS93M2MvbWVkaWEtc291cmNlL2lzc3Vlcy81My5cclxuICAgICAgaWYgKHRoaXMubWVkaWEpIHtcclxuICAgICAgICBVUkwucmV2b2tlT2JqZWN0VVJMKHRoaXMubWVkaWEuc3JjKTtcclxuICAgICAgICB0aGlzLm1lZGlhLnJlbW92ZUF0dHJpYnV0ZSgnc3JjJyk7XHJcbiAgICAgICAgdGhpcy5tZWRpYS5sb2FkKCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMubWVkaWFTb3VyY2UgPSBudWxsO1xyXG4gICAgICB0aGlzLm1lZGlhID0gbnVsbDtcclxuICAgICAgdGhpcy5wZW5kaW5nVHJhY2tzID0ge307XHJcbiAgICAgIHRoaXMudHJhY2tzID0ge307XHJcbiAgICAgIHRoaXMuc291cmNlQnVmZmVyID0ge307XHJcbiAgICAgIHRoaXMuZmx1c2hSYW5nZSA9IFtdO1xyXG4gICAgICB0aGlzLnNlZ21lbnRzID0gW107XHJcbiAgICAgIHRoaXMuYXBwZW5kZWQgPSAwO1xyXG4gICAgfVxyXG4gICAgdGhpcy5vbm1zbyA9IHRoaXMub25tc2UgPSB0aGlzLm9ubXNjID0gbnVsbDtcclxuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuTUVESUFfREVUQUNIRUQpO1xyXG4gIH1cclxuXHJcbiAgb25NZWRpYVNvdXJjZU9wZW4oKSB7XHJcbiAgICBsb2dnZXIubG9nKCdtZWRpYSBzb3VyY2Ugb3BlbmVkJyk7XHJcbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50Lk1FRElBX0FUVEFDSEVELCB7IG1lZGlhIDogdGhpcy5tZWRpYSB9KTtcclxuICAgIGxldCBtZWRpYVNvdXJjZSA9IHRoaXMubWVkaWFTb3VyY2U7XHJcbiAgICBpZiAobWVkaWFTb3VyY2UpIHtcclxuICAgICAgLy8gb25jZSByZWNlaXZlZCwgZG9uJ3QgbGlzdGVuIGFueW1vcmUgdG8gc291cmNlb3BlbiBldmVudFxyXG4gICAgICBtZWRpYVNvdXJjZS5yZW1vdmVFdmVudExpc3RlbmVyKCdzb3VyY2VvcGVuJywgdGhpcy5vbm1zbyk7XHJcbiAgICB9XHJcbiAgICB0aGlzLmNoZWNrUGVuZGluZ1RyYWNrcygpO1xyXG4gIH1cclxuXHJcbiAgY2hlY2tQZW5kaW5nVHJhY2tzKCkge1xyXG4gICAgLy8gaWYgYW55IGJ1ZmZlciBjb2RlY3MgcGVuZGluZywgY2hlY2sgaWYgd2UgaGF2ZSBlbm91Z2ggdG8gY3JlYXRlIHNvdXJjZUJ1ZmZlcnNcclxuICAgIGxldCBwZW5kaW5nVHJhY2tzID0gdGhpcy5wZW5kaW5nVHJhY2tzLFxyXG4gICAgICAgIHBlbmRpbmdUcmFja3NOYiA9IE9iamVjdC5rZXlzKHBlbmRpbmdUcmFja3MpLmxlbmd0aDtcclxuICAgIC8vIGlmIGFueSBwZW5kaW5nIHRyYWNrcyBhbmQgKGlmIG5iIG9mIHBlbmRpbmcgdHJhY2tzIGd0IG9yIGVxdWFsIHRoYW4gZXhwZWN0ZWQgbmIgb3IgaWYgdW5rbm93biBleHBlY3RlZCBuYilcclxuICAgIGlmIChwZW5kaW5nVHJhY2tzTmIgJiYgKFxyXG4gICAgICAgIHRoaXMuc291cmNlQnVmZmVyTmIgPD0gcGVuZGluZ1RyYWNrc05iIHx8XHJcbiAgICAgICAgdGhpcy5zb3VyY2VCdWZmZXJOYiA9PT0gMCkpIHtcclxuICAgICAgLy8gb2ssIGxldCdzIGNyZWF0ZSB0aGVtIG5vdyAhXHJcbiAgICAgIHRoaXMuY3JlYXRlU291cmNlQnVmZmVycyhwZW5kaW5nVHJhY2tzKTtcclxuICAgICAgdGhpcy5wZW5kaW5nVHJhY2tzID0ge307XHJcbiAgICAgIC8vIGFwcGVuZCBhbnkgcGVuZGluZyBzZWdtZW50cyBub3cgIVxyXG4gICAgICB0aGlzLmRvQXBwZW5kaW5nKCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBvbk1lZGlhU291cmNlQ2xvc2UoKSB7XHJcbiAgICBsb2dnZXIubG9nKCdtZWRpYSBzb3VyY2UgY2xvc2VkJyk7XHJcbiAgfVxyXG5cclxuICBvbk1lZGlhU291cmNlRW5kZWQoKSB7XHJcbiAgICBsb2dnZXIubG9nKCdtZWRpYSBzb3VyY2UgZW5kZWQnKTtcclxuICB9XHJcblxyXG5cclxuICBvblNCVXBkYXRlRW5kKCkge1xyXG4gICAgLy8gdXBkYXRlIHRpbWVzdGFtcE9mZnNldFxyXG4gICAgaWYgKHRoaXMuYXVkaW9UaW1lc3RhbXBPZmZzZXQpIHtcclxuICAgICAgbGV0IGF1ZGlvQnVmZmVyID0gdGhpcy5zb3VyY2VCdWZmZXIuYXVkaW87XHJcbiAgICAgIGxvZ2dlci53YXJuKCdjaGFuZ2UgbXBlZyBhdWRpbyB0aW1lc3RhbXAgb2Zmc2V0IGZyb20gJyArIGF1ZGlvQnVmZmVyLnRpbWVzdGFtcE9mZnNldCArICcgdG8gJyArIHRoaXMuYXVkaW9UaW1lc3RhbXBPZmZzZXQpO1xyXG4gICAgICBhdWRpb0J1ZmZlci50aW1lc3RhbXBPZmZzZXQgPSB0aGlzLmF1ZGlvVGltZXN0YW1wT2Zmc2V0O1xyXG4gICAgICBkZWxldGUgdGhpcy5hdWRpb1RpbWVzdGFtcE9mZnNldDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5fbmVlZHNGbHVzaCkge1xyXG4gICAgICB0aGlzLmRvRmx1c2goKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5fbmVlZHNFb3MpIHtcclxuICAgICAgdGhpcy5jaGVja0VvcygpO1xyXG4gICAgfVxyXG4gICAgdGhpcy5hcHBlbmRpbmcgPSBmYWxzZTtcclxuICAgIGxldCBwYXJlbnQgPSB0aGlzLnBhcmVudDtcclxuICAgIC8vIGNvdW50IG5iIG9mIHBlbmRpbmcgc2VnbWVudHMgd2FpdGluZyBmb3IgYXBwZW5kaW5nIG9uIHRoaXMgc291cmNlYnVmZmVyXHJcbiAgICBsZXQgcGVuZGluZyA9IHRoaXMuc2VnbWVudHMucmVkdWNlKCAoY291bnRlciwgc2VnbWVudCkgPT4gKHNlZ21lbnQucGFyZW50ID09PSBwYXJlbnQpID8gY291bnRlciArIDEgOiBjb3VudGVyICwgMCk7XHJcbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkJVRkZFUl9BUFBFTkRFRCwgeyBwYXJlbnQgOiBwYXJlbnQsIHBlbmRpbmcgOiBwZW5kaW5nIH0pO1xyXG5cclxuICAgIC8vIGRvbid0IGFwcGVuZCBpbiBmbHVzaGluZyBtb2RlXHJcbiAgICBpZiAoIXRoaXMuX25lZWRzRmx1c2gpIHtcclxuICAgICAgdGhpcy5kb0FwcGVuZGluZygpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMudXBkYXRlTWVkaWFFbGVtZW50RHVyYXRpb24oKTtcclxuICB9XHJcblxyXG4gIG9uU0JVcGRhdGVFcnJvcihldmVudCkge1xyXG4gICAgbG9nZ2VyLmVycm9yKCdzb3VyY2VCdWZmZXIgZXJyb3I6JywgZXZlbnQpO1xyXG4gICAgLy8gYWNjb3JkaW5nIHRvIGh0dHA6Ly93d3cudzMub3JnL1RSL21lZGlhLXNvdXJjZS8jc291cmNlYnVmZmVyLWFwcGVuZC1lcnJvclxyXG4gICAgLy8gdGhpcyBlcnJvciBtaWdodCBub3QgYWx3YXlzIGJlIGZhdGFsIChpdCBpcyBmYXRhbCBpZiBkZWNvZGUgZXJyb3IgaXMgc2V0LCBpbiB0aGF0IGNhc2VcclxuICAgIC8vIGl0IHdpbGwgYmUgZm9sbG93ZWQgYnkgYSBtZWRpYUVsZW1lbnQgZXJyb3IgLi4uKVxyXG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5FUlJPUiwge3R5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsIGRldGFpbHM6IEVycm9yRGV0YWlscy5CVUZGRVJfQVBQRU5ESU5HX0VSUk9SLCBmYXRhbDogZmFsc2V9KTtcclxuICAgIC8vIHdlIGRvbid0IG5lZWQgdG8gZG8gbW9yZSB0aGFuIHRoYXQsIGFzIGFjY29yZGluIHRvIHRoZSBzcGVjLCB1cGRhdGVlbmQgd2lsbCBiZSBmaXJlZCBqdXN0IGFmdGVyXHJcbiAgfVxyXG5cclxuICBvbkJ1ZmZlclJlc2V0KCkge1xyXG4gICAgdmFyIHNvdXJjZUJ1ZmZlciA9IHRoaXMuc291cmNlQnVmZmVyO1xyXG4gICAgZm9yKHZhciB0eXBlIGluIHNvdXJjZUJ1ZmZlcikge1xyXG4gICAgICB2YXIgc2IgPSBzb3VyY2VCdWZmZXJbdHlwZV07XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgdGhpcy5tZWRpYVNvdXJjZS5yZW1vdmVTb3VyY2VCdWZmZXIoc2IpO1xyXG4gICAgICAgIHNiLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3VwZGF0ZWVuZCcsIHRoaXMub25zYnVlKTtcclxuICAgICAgICBzYi5yZW1vdmVFdmVudExpc3RlbmVyKCdlcnJvcicsIHRoaXMub25zYmUpO1xyXG4gICAgICB9IGNhdGNoKGVycikge1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICB0aGlzLnNvdXJjZUJ1ZmZlciA9IHt9O1xyXG4gICAgdGhpcy5mbHVzaFJhbmdlID0gW107XHJcbiAgICB0aGlzLnNlZ21lbnRzID0gW107XHJcbiAgICB0aGlzLmFwcGVuZGVkID0gMDtcclxuICB9XHJcblxyXG4gIG9uQnVmZmVyQ29kZWNzKHRyYWNrcykge1xyXG4gICAgLy8gaWYgc291cmNlIGJ1ZmZlcihzKSBub3QgY3JlYXRlZCB5ZXQsIGFwcGVuZGVkIGJ1ZmZlciB0cmFja3MgaW4gdGhpcy5wZW5kaW5nVHJhY2tzXHJcbiAgICAvLyBpZiBzb3VyY2VidWZmZXJzIGFscmVhZHkgY3JlYXRlZCwgZG8gbm90aGluZyAuLi5cclxuICAgIGlmIChPYmplY3Qua2V5cyh0aGlzLnNvdXJjZUJ1ZmZlcikubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgIGZvciAodmFyIHRyYWNrTmFtZSBpbiB0cmFja3MpIHsgdGhpcy5wZW5kaW5nVHJhY2tzW3RyYWNrTmFtZV0gPSB0cmFja3NbdHJhY2tOYW1lXTsgfVxyXG4gICAgICBsZXQgbWVkaWFTb3VyY2UgPSB0aGlzLm1lZGlhU291cmNlO1xyXG4gICAgICBpZiAobWVkaWFTb3VyY2UgJiYgbWVkaWFTb3VyY2UucmVhZHlTdGF0ZSA9PT0gJ29wZW4nKSB7XHJcbiAgICAgICAgLy8gdHJ5IHRvIGNyZWF0ZSBzb3VyY2VidWZmZXJzIGlmIG1lZGlhc291cmNlIG9wZW5lZFxyXG4gICAgICAgIHRoaXMuY2hlY2tQZW5kaW5nVHJhY2tzKCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG5cclxuICBjcmVhdGVTb3VyY2VCdWZmZXJzKHRyYWNrcykge1xyXG4gICAgdmFyIHNvdXJjZUJ1ZmZlciA9IHRoaXMuc291cmNlQnVmZmVyLG1lZGlhU291cmNlID0gdGhpcy5tZWRpYVNvdXJjZTtcclxuXHJcbiAgICBmb3IgKGxldCB0cmFja05hbWUgaW4gdHJhY2tzKSB7XHJcbiAgICAgIGlmKCFzb3VyY2VCdWZmZXJbdHJhY2tOYW1lXSkge1xyXG4gICAgICAgIGxldCB0cmFjayA9IHRyYWNrc1t0cmFja05hbWVdO1xyXG4gICAgICAgIC8vIHVzZSBsZXZlbENvZGVjIGFzIGZpcnN0IHByaW9yaXR5XHJcbiAgICAgICAgbGV0IGNvZGVjID0gdHJhY2subGV2ZWxDb2RlYyB8fCB0cmFjay5jb2RlYztcclxuICAgICAgICBsZXQgbWltZVR5cGUgPSBgJHt0cmFjay5jb250YWluZXJ9O2NvZGVjcz0ke2NvZGVjfWA7XHJcbiAgICAgICAgbG9nZ2VyLmxvZyhgY3JlYXRpbmcgc291cmNlQnVmZmVyKCR7bWltZVR5cGV9KWApO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBsZXQgc2IgPSBzb3VyY2VCdWZmZXJbdHJhY2tOYW1lXSA9IG1lZGlhU291cmNlLmFkZFNvdXJjZUJ1ZmZlcihtaW1lVHlwZSk7XHJcbiAgICAgICAgICBzYi5hZGRFdmVudExpc3RlbmVyKCd1cGRhdGVlbmQnLCB0aGlzLm9uc2J1ZSk7XHJcbiAgICAgICAgICBzYi5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIHRoaXMub25zYmUpO1xyXG4gICAgICAgICAgdGhpcy50cmFja3NbdHJhY2tOYW1lXSA9IHtjb2RlYzogY29kZWMsIGNvbnRhaW5lcjogdHJhY2suY29udGFpbmVyfTtcclxuICAgICAgICAgIHRyYWNrLmJ1ZmZlciA9IHNiO1xyXG4gICAgICAgIH0gY2F0Y2goZXJyKSB7XHJcbiAgICAgICAgICBsb2dnZXIuZXJyb3IoYGVycm9yIHdoaWxlIHRyeWluZyB0byBhZGQgc291cmNlQnVmZmVyOiR7ZXJyLm1lc3NhZ2V9YCk7XHJcbiAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkVSUk9SLCB7dHlwZTogRXJyb3JUeXBlcy5NRURJQV9FUlJPUiwgZGV0YWlsczogRXJyb3JEZXRhaWxzLkJVRkZFUl9BRERfQ09ERUNfRVJST1IsIGZhdGFsOiBmYWxzZSwgZXJyOiBlcnIsIG1pbWVUeXBlIDogbWltZVR5cGV9KTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuQlVGRkVSX0NSRUFURUQsIHsgdHJhY2tzIDogdHJhY2tzIH0gKTtcclxuICB9XHJcblxyXG4gIG9uQnVmZmVyQXBwZW5kaW5nKGRhdGEpIHtcclxuICAgIGlmICghdGhpcy5fbmVlZHNGbHVzaCkge1xyXG4gICAgICBpZiAoIXRoaXMuc2VnbWVudHMpIHtcclxuICAgICAgICB0aGlzLnNlZ21lbnRzID0gWyBkYXRhIF07XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5zZWdtZW50cy5wdXNoKGRhdGEpO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuZG9BcHBlbmRpbmcoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIG9uQnVmZmVyQXBwZW5kRmFpbChkYXRhKSB7XHJcbiAgICBsb2dnZXIuZXJyb3IoJ3NvdXJjZUJ1ZmZlciBlcnJvcjonLGRhdGEuZXZlbnQpO1xyXG4gICAgLy8gYWNjb3JkaW5nIHRvIGh0dHA6Ly93d3cudzMub3JnL1RSL21lZGlhLXNvdXJjZS8jc291cmNlYnVmZmVyLWFwcGVuZC1lcnJvclxyXG4gICAgLy8gdGhpcyBlcnJvciBtaWdodCBub3QgYWx3YXlzIGJlIGZhdGFsIChpdCBpcyBmYXRhbCBpZiBkZWNvZGUgZXJyb3IgaXMgc2V0LCBpbiB0aGF0IGNhc2VcclxuICAgIC8vIGl0IHdpbGwgYmUgZm9sbG93ZWQgYnkgYSBtZWRpYUVsZW1lbnQgZXJyb3IgLi4uKVxyXG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5FUlJPUiwge3R5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsIGRldGFpbHM6IEVycm9yRGV0YWlscy5CVUZGRVJfQVBQRU5ESU5HX0VSUk9SLCBmYXRhbDogZmFsc2V9KTtcclxuICB9XHJcblxyXG4gIC8vIG9uIEJVRkZFUl9FT1MgbWFyayBtYXRjaGluZyBzb3VyY2VidWZmZXIocykgYXMgZW5kZWQgYW5kIHRyaWdnZXIgY2hlY2tFb3MoKVxyXG4gIG9uQnVmZmVyRW9zKGRhdGEpIHtcclxuICAgIHZhciBzYiA9IHRoaXMuc291cmNlQnVmZmVyO1xyXG4gICAgbGV0IGRhdGFUeXBlID0gZGF0YS50eXBlO1xyXG4gICAgZm9yKGxldCB0eXBlIGluIHNiKSB7XHJcbiAgICAgIGlmICghZGF0YVR5cGUgfHwgdHlwZSA9PT0gZGF0YVR5cGUpIHtcclxuICAgICAgICBpZiAoIXNiW3R5cGVdLmVuZGVkKSB7XHJcbiAgICAgICAgICBzYlt0eXBlXS5lbmRlZCA9IHRydWU7XHJcbiAgICAgICAgICBsb2dnZXIubG9nKGAke3R5cGV9IHNvdXJjZUJ1ZmZlciBub3cgRU9TYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICB0aGlzLmNoZWNrRW9zKCk7XHJcbiAgfVxyXG5cclxuIC8vIGlmIGFsbCBzb3VyY2UgYnVmZmVycyBhcmUgbWFya2VkIGFzIGVuZGVkLCBzaWduYWwgZW5kT2ZTdHJlYW0oKSB0byBNZWRpYVNvdXJjZS5cclxuIGNoZWNrRW9zKCkge1xyXG4gICAgdmFyIHNiID0gdGhpcy5zb3VyY2VCdWZmZXIsIG1lZGlhU291cmNlID0gdGhpcy5tZWRpYVNvdXJjZTtcclxuICAgIGlmICghbWVkaWFTb3VyY2UgfHwgbWVkaWFTb3VyY2UucmVhZHlTdGF0ZSAhPT0gJ29wZW4nKSB7XHJcbiAgICAgIHRoaXMuX25lZWRzRW9zID0gZmFsc2U7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGZvcihsZXQgdHlwZSBpbiBzYikge1xyXG4gICAgICBsZXQgc2JvYmogPSBzYlt0eXBlXTtcclxuICAgICAgaWYgKCFzYm9iai5lbmRlZCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBpZihzYm9iai51cGRhdGluZykge1xyXG4gICAgICAgIHRoaXMuX25lZWRzRW9zID0gdHJ1ZTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGxvZ2dlci5sb2coJ2FsbCBtZWRpYSBkYXRhIGF2YWlsYWJsZSwgc2lnbmFsIGVuZE9mU3RyZWFtKCkgdG8gTWVkaWFTb3VyY2UgYW5kIHN0b3AgbG9hZGluZyBmcmFnbWVudCcpO1xyXG4gICAgLy9Ob3RpZnkgdGhlIG1lZGlhIGVsZW1lbnQgdGhhdCBpdCBub3cgaGFzIGFsbCBvZiB0aGUgbWVkaWEgZGF0YVxyXG4gICAgdHJ5IHtcclxuICAgICAgbWVkaWFTb3VyY2UuZW5kT2ZTdHJlYW0oKTtcclxuICAgIH0gY2F0Y2goZSkge1xyXG4gICAgICBsb2dnZXIud2FybignZXhjZXB0aW9uIHdoaWxlIGNhbGxpbmcgbWVkaWFTb3VyY2UuZW5kT2ZTdHJlYW0oKScpO1xyXG4gICAgfVxyXG4gICAgdGhpcy5fbmVlZHNFb3MgPSBmYWxzZTtcclxuIH1cclxuXHJcblxyXG4gIG9uQnVmZmVyRmx1c2hpbmcoZGF0YSkge1xyXG4gICAgdGhpcy5mbHVzaFJhbmdlLnB1c2goe3N0YXJ0OiBkYXRhLnN0YXJ0T2Zmc2V0LCBlbmQ6IGRhdGEuZW5kT2Zmc2V0LCB0eXBlIDogZGF0YS50eXBlfSk7XHJcbiAgICAvLyBhdHRlbXB0IGZsdXNoIGltbWVkaWF0bHlcclxuICAgIHRoaXMuZmx1c2hCdWZmZXJDb3VudGVyID0gMDtcclxuICAgIHRoaXMuZG9GbHVzaCgpO1xyXG4gIH1cclxuXHJcbiAgb25MZXZlbFVwZGF0ZWQoZXZlbnQpIHtcclxuICAgIGxldCBkZXRhaWxzID0gZXZlbnQuZGV0YWlscztcclxuICAgIGlmIChkZXRhaWxzLmZyYWdtZW50cy5sZW5ndGggPT09IDApIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgdGhpcy5fbGV2ZWxEdXJhdGlvbiA9IGRldGFpbHMudG90YWxkdXJhdGlvbiArIGRldGFpbHMuZnJhZ21lbnRzWzBdLnN0YXJ0O1xyXG4gICAgdGhpcy51cGRhdGVNZWRpYUVsZW1lbnREdXJhdGlvbigpO1xyXG4gIH1cclxuXHJcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3ZpZGVvLWRldi9obHMuanMvaXNzdWVzLzM1NVxyXG4gIHVwZGF0ZU1lZGlhRWxlbWVudER1cmF0aW9uKCkge1xyXG4gICAgbGV0IG1lZGlhID0gdGhpcy5tZWRpYSxcclxuICAgICAgICBtZWRpYVNvdXJjZSA9IHRoaXMubWVkaWFTb3VyY2UsXHJcbiAgICAgICAgc291cmNlQnVmZmVyID0gdGhpcy5zb3VyY2VCdWZmZXIsXHJcbiAgICAgICAgbGV2ZWxEdXJhdGlvbiA9IHRoaXMuX2xldmVsRHVyYXRpb247XHJcbiAgICBpZiAobGV2ZWxEdXJhdGlvbiA9PT0gbnVsbCB8fCAhbWVkaWEgfHwgIW1lZGlhU291cmNlIHx8ICFzb3VyY2VCdWZmZXIgfHwgbWVkaWEucmVhZHlTdGF0ZSA9PT0gMCB8fCBtZWRpYVNvdXJjZS5yZWFkeVN0YXRlICE9PSAnb3BlbicpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgZm9yIChsZXQgdHlwZSBpbiBzb3VyY2VCdWZmZXIpIHtcclxuICAgICAgaWYgKHNvdXJjZUJ1ZmZlclt0eXBlXS51cGRhdGluZykge1xyXG4gICAgICAgIC8vIGNhbid0IHNldCBkdXJhdGlvbiB3aGlsc3QgYSBidWZmZXIgaXMgdXBkYXRpbmdcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGlmICh0aGlzLl9tc0R1cmF0aW9uID09PSBudWxsKSB7XHJcbiAgICAgIC8vIGluaXRpYWxpc2UgdG8gdGhlIHZhbHVlIHRoYXQgdGhlIG1lZGlhIHNvdXJjZSBpcyByZXBvcnRpbmdcclxuICAgICAgdGhpcy5fbXNEdXJhdGlvbiA9IG1lZGlhU291cmNlLmR1cmF0aW9uO1xyXG4gICAgfVxyXG4gICAgbGV0IGR1cmF0aW9uID0gbWVkaWEuZHVyYXRpb247XHJcbiAgICAvLyBsZXZlbER1cmF0aW9uIHdhcyB0aGUgbGFzdCB2YWx1ZSB3ZSBzZXQuXHJcbiAgICAvLyBub3QgdXNpbmcgbWVkaWFTb3VyY2UuZHVyYXRpb24gYXMgdGhlIGJyb3dzZXIgbWF5IHR3ZWFrIHRoaXMgdmFsdWVcclxuICAgIC8vIG9ubHkgdXBkYXRlIG1lZGlhc291cmNlIGR1cmF0aW9uIGlmIGl0cyB2YWx1ZSBpbmNyZWFzZSwgdGhpcyBpcyB0byBhdm9pZFxyXG4gICAgLy8gZmx1c2hpbmcgYWxyZWFkeSBidWZmZXJlZCBwb3J0aW9uIHdoZW4gc3dpdGNoaW5nIGJldHdlZW4gcXVhbGl0eSBsZXZlbFxyXG4gICAgaWYgKChsZXZlbER1cmF0aW9uID4gdGhpcy5fbXNEdXJhdGlvbiAmJiBsZXZlbER1cmF0aW9uID4gZHVyYXRpb24pIHx8IChkdXJhdGlvbiA9PT0gSW5maW5pdHkgfHwgaXNOYU4oZHVyYXRpb24pICkpIHtcclxuICAgICAgbG9nZ2VyLmxvZyhgVXBkYXRpbmcgbWVkaWFzb3VyY2UgZHVyYXRpb24gdG8gJHtsZXZlbER1cmF0aW9uLnRvRml4ZWQoMyl9YCk7XHJcbiAgICAgIHRoaXMuX21zRHVyYXRpb24gPSBtZWRpYVNvdXJjZS5kdXJhdGlvbiA9IGxldmVsRHVyYXRpb247XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBkb0ZsdXNoKCkge1xyXG4gICAgLy8gbG9vcCB0aHJvdWdoIGFsbCBidWZmZXIgcmFuZ2VzIHRvIGZsdXNoXHJcbiAgICB3aGlsZSh0aGlzLmZsdXNoUmFuZ2UubGVuZ3RoKSB7XHJcbiAgICAgIHZhciByYW5nZSA9IHRoaXMuZmx1c2hSYW5nZVswXTtcclxuICAgICAgLy8gZmx1c2hCdWZmZXIgd2lsbCBhYm9ydCBhbnkgYnVmZmVyIGFwcGVuZCBpbiBwcm9ncmVzcyBhbmQgZmx1c2ggQXVkaW8vVmlkZW8gQnVmZmVyXHJcbiAgICAgIGlmICh0aGlzLmZsdXNoQnVmZmVyKHJhbmdlLnN0YXJ0LCByYW5nZS5lbmQsIHJhbmdlLnR5cGUpKSB7XHJcbiAgICAgICAgLy8gcmFuZ2UgZmx1c2hlZCwgcmVtb3ZlIGZyb20gZmx1c2ggYXJyYXlcclxuICAgICAgICB0aGlzLmZsdXNoUmFuZ2Uuc2hpZnQoKTtcclxuICAgICAgICB0aGlzLmZsdXNoQnVmZmVyQ291bnRlciA9IDA7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5fbmVlZHNGbHVzaCA9IHRydWU7XHJcbiAgICAgICAgLy8gYXZvaWQgbG9vcGluZywgd2FpdCBmb3IgU0IgdXBkYXRlIGVuZCB0byByZXRyaWdnZXIgYSBmbHVzaFxyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMuZmx1c2hSYW5nZS5sZW5ndGggPT09IDApIHtcclxuICAgICAgLy8gZXZlcnl0aGluZyBmbHVzaGVkXHJcbiAgICAgIHRoaXMuX25lZWRzRmx1c2ggPSBmYWxzZTtcclxuXHJcbiAgICAgIC8vIGxldCdzIHJlY29tcHV0ZSB0aGlzLmFwcGVuZGVkLCB3aGljaCBpcyB1c2VkIHRvIGF2b2lkIGZsdXNoIGxvb3BpbmdcclxuICAgICAgdmFyIGFwcGVuZGVkID0gMDtcclxuICAgICAgdmFyIHNvdXJjZUJ1ZmZlciA9IHRoaXMuc291cmNlQnVmZmVyO1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGZvciAodmFyIHR5cGUgaW4gc291cmNlQnVmZmVyKSB7XHJcbiAgICAgICAgICBhcHBlbmRlZCArPSBzb3VyY2VCdWZmZXJbdHlwZV0uYnVmZmVyZWQubGVuZ3RoO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBjYXRjaChlcnJvcikge1xyXG4gICAgICAgIC8vIGVycm9yIGNvdWxkIGJlIHRocm93biB3aGlsZSBhY2Nlc3NpbmcgYnVmZmVyZWQsIGluIGNhc2Ugc291cmNlYnVmZmVyIGhhcyBhbHJlYWR5IGJlZW4gcmVtb3ZlZCBmcm9tIE1lZGlhU291cmNlXHJcbiAgICAgICAgLy8gdGhpcyBpcyBoYXJtZXNzIGF0IHRoaXMgc3RhZ2UsIGNhdGNoIHRoaXMgdG8gYXZvaWQgcmVwb3J0aW5nIGFuIGludGVybmFsIGV4Y2VwdGlvblxyXG4gICAgICAgIGxvZ2dlci5lcnJvcignZXJyb3Igd2hpbGUgYWNjZXNzaW5nIHNvdXJjZUJ1ZmZlci5idWZmZXJlZCcpO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuYXBwZW5kZWQgPSBhcHBlbmRlZDtcclxuICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5CVUZGRVJfRkxVU0hFRCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBkb0FwcGVuZGluZygpIHtcclxuICAgIHZhciBobHMgPSB0aGlzLmhscywgc291cmNlQnVmZmVyID0gdGhpcy5zb3VyY2VCdWZmZXIsIHNlZ21lbnRzID0gdGhpcy5zZWdtZW50cztcclxuICAgIGlmIChPYmplY3Qua2V5cyhzb3VyY2VCdWZmZXIpLmxlbmd0aCkge1xyXG4gICAgICBpZiAodGhpcy5tZWRpYS5lcnJvcikge1xyXG4gICAgICAgIHRoaXMuc2VnbWVudHMgPSBbXTtcclxuICAgICAgICBsb2dnZXIuZXJyb3IoJ3RyeWluZyB0byBhcHBlbmQgYWx0aG91Z2ggYSBtZWRpYSBlcnJvciBvY2N1cmVkLCBmbHVzaCBzZWdtZW50IGFuZCBhYm9ydCcpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBpZiAodGhpcy5hcHBlbmRpbmcpIHtcclxuICAgICAgICAvL2xvZ2dlci5sb2coYHNiIGFwcGVuZGluZyBpbiBwcm9ncmVzc2ApO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBpZiAoc2VnbWVudHMgJiYgc2VnbWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgbGV0IHNlZ21lbnQgPSBzZWdtZW50cy5zaGlmdCgpO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBsZXQgdHlwZSA9IHNlZ21lbnQudHlwZSwgc2IgPSBzb3VyY2VCdWZmZXJbdHlwZV07XHJcbiAgICAgICAgICBpZihzYikge1xyXG4gICAgICAgICAgICBpZighc2IudXBkYXRpbmcpIHtcclxuICAgICAgICAgICAgICAvLyByZXNldCBzb3VyY2VCdWZmZXIgZW5kZWQgZmxhZyBiZWZvcmUgYXBwZW5kaW5nIHNlZ21lbnRcclxuICAgICAgICAgICAgICBzYi5lbmRlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgIC8vbG9nZ2VyLmxvZyhgYXBwZW5kaW5nICR7c2VnbWVudC5jb250ZW50fSAke3R5cGV9IFNCLCBzaXplOiR7c2VnbWVudC5kYXRhLmxlbmd0aH0sICR7c2VnbWVudC5wYXJlbnR9YCk7XHJcbiAgICAgICAgICAgICAgdGhpcy5wYXJlbnQgPSBzZWdtZW50LnBhcmVudDtcclxuICAgICAgICAgICAgICBzYi5hcHBlbmRCdWZmZXIoc2VnbWVudC5kYXRhKTtcclxuICAgICAgICAgICAgICB0aGlzLmFwcGVuZEVycm9yID0gMDtcclxuICAgICAgICAgICAgICB0aGlzLmFwcGVuZGVkKys7XHJcbiAgICAgICAgICAgICAgdGhpcy5hcHBlbmRpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIHNlZ21lbnRzLnVuc2hpZnQoc2VnbWVudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIGluIGNhc2Ugd2UgZG9uJ3QgaGF2ZSBhbnkgc291cmNlIGJ1ZmZlciBtYXRjaGluZyB3aXRoIHRoaXMgc2VnbWVudCB0eXBlLFxyXG4gICAgICAgICAgICAvLyBpdCBtZWFucyB0aGF0IE1lZGlhc291cmNlIGZhaWxzIHRvIGNyZWF0ZSBzb3VyY2VidWZmZXJcclxuICAgICAgICAgICAgLy8gZGlzY2FyZCB0aGlzIHNlZ21lbnQsIGFuZCB0cmlnZ2VyIHVwZGF0ZSBlbmRcclxuICAgICAgICAgICAgdGhpcy5vblNCVXBkYXRlRW5kKCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBjYXRjaChlcnIpIHtcclxuICAgICAgICAgIC8vIGluIGNhc2UgYW55IGVycm9yIG9jY3VyZWQgd2hpbGUgYXBwZW5kaW5nLCBwdXQgYmFjayBzZWdtZW50IGluIHNlZ21lbnRzIHRhYmxlXHJcbiAgICAgICAgICBsb2dnZXIuZXJyb3IoYGVycm9yIHdoaWxlIHRyeWluZyB0byBhcHBlbmQgYnVmZmVyOiR7ZXJyLm1lc3NhZ2V9YCk7XHJcbiAgICAgICAgICBzZWdtZW50cy51bnNoaWZ0KHNlZ21lbnQpO1xyXG4gICAgICAgICAgdmFyIGV2ZW50ID0ge3R5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsIHBhcmVudCA6IHNlZ21lbnQucGFyZW50fTtcclxuICAgICAgICAgIGlmKGVyci5jb2RlICE9PSAyMikge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5hcHBlbmRFcnJvcikge1xyXG4gICAgICAgICAgICAgIHRoaXMuYXBwZW5kRXJyb3IrKztcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICB0aGlzLmFwcGVuZEVycm9yID0gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBldmVudC5kZXRhaWxzID0gRXJyb3JEZXRhaWxzLkJVRkZFUl9BUFBFTkRfRVJST1I7XHJcbiAgICAgICAgICAgIC8qIHdpdGggVUhEIGNvbnRlbnQsIHdlIGNvdWxkIGdldCBsb29wIG9mIHF1b3RhIGV4Y2VlZGVkIGVycm9yIHVudGlsXHJcbiAgICAgICAgICAgICAgYnJvd3NlciBpcyBhYmxlIHRvIGV2aWN0IHNvbWUgZGF0YSBmcm9tIHNvdXJjZWJ1ZmZlci4gcmV0cnlpbmcgaGVscCByZWNvdmVyaW5nIHRoaXNcclxuICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgaWYgKHRoaXMuYXBwZW5kRXJyb3IgPiBobHMuY29uZmlnLmFwcGVuZEVycm9yTWF4UmV0cnkpIHtcclxuICAgICAgICAgICAgICBsb2dnZXIubG9nKGBmYWlsICR7aGxzLmNvbmZpZy5hcHBlbmRFcnJvck1heFJldHJ5fSB0aW1lcyB0byBhcHBlbmQgc2VnbWVudCBpbiBzb3VyY2VCdWZmZXJgKTtcclxuICAgICAgICAgICAgICBzZWdtZW50cyA9IFtdO1xyXG4gICAgICAgICAgICAgIGV2ZW50LmZhdGFsID0gdHJ1ZTtcclxuICAgICAgICAgICAgICBobHMudHJpZ2dlcihFdmVudC5FUlJPUiwgZXZlbnQpO1xyXG4gICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBldmVudC5mYXRhbCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgIGhscy50cmlnZ2VyKEV2ZW50LkVSUk9SLCBldmVudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIFF1b3RhRXhjZWVkZWRFcnJvcjogaHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvaW5mcmFzdHJ1Y3R1cmUuaHRtbCNxdW90YWV4Y2VlZGVkZXJyb3JcclxuICAgICAgICAgICAgLy8gbGV0J3Mgc3RvcCBhcHBlbmRpbmcgYW55IHNlZ21lbnRzLCBhbmQgcmVwb3J0IEJVRkZFUl9GVUxMX0VSUk9SIGVycm9yXHJcbiAgICAgICAgICAgIHRoaXMuc2VnbWVudHMgPSBbXTtcclxuICAgICAgICAgICAgZXZlbnQuZGV0YWlscyA9IEVycm9yRGV0YWlscy5CVUZGRVJfRlVMTF9FUlJPUjtcclxuICAgICAgICAgICAgZXZlbnQuZmF0YWwgPSBmYWxzZTtcclxuICAgICAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnQuRVJST1IsZXZlbnQpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKlxyXG4gICAgZmx1c2ggc3BlY2lmaWVkIGJ1ZmZlcmVkIHJhbmdlLFxyXG4gICAgcmV0dXJuIHRydWUgb25jZSByYW5nZSBoYXMgYmVlbiBmbHVzaGVkLlxyXG4gICAgYXMgc291cmNlQnVmZmVyLnJlbW92ZSgpIGlzIGFzeW5jaHJvbm91cywgZmx1c2hCdWZmZXIgd2lsbCBiZSByZXRyaWdnZXJlZCBvbiBzb3VyY2VCdWZmZXIgdXBkYXRlIGVuZFxyXG4gICovXHJcbiAgZmx1c2hCdWZmZXIoc3RhcnRPZmZzZXQsIGVuZE9mZnNldCwgdHlwZUluKSB7XHJcbiAgICB2YXIgc2IsIGksIGJ1ZlN0YXJ0LCBidWZFbmQsIGZsdXNoU3RhcnQsIGZsdXNoRW5kLCBzb3VyY2VCdWZmZXIgPSB0aGlzLnNvdXJjZUJ1ZmZlcjtcclxuICAgIGlmIChPYmplY3Qua2V5cyhzb3VyY2VCdWZmZXIpLmxlbmd0aCkge1xyXG4gICAgICBsb2dnZXIubG9nKGBmbHVzaEJ1ZmZlcixwb3Mvc3RhcnQvZW5kOiAke3RoaXMubWVkaWEuY3VycmVudFRpbWUudG9GaXhlZCgzKX0vJHtzdGFydE9mZnNldH0vJHtlbmRPZmZzZXR9YCk7XHJcbiAgICAgIC8vIHNhZmVndWFyZCB0byBhdm9pZCBpbmZpbml0ZSBsb29waW5nIDogZG9uJ3QgdHJ5IHRvIGZsdXNoIG1vcmUgdGhhbiB0aGUgbmIgb2YgYXBwZW5kZWQgc2VnbWVudHNcclxuICAgICAgaWYgKHRoaXMuZmx1c2hCdWZmZXJDb3VudGVyIDwgdGhpcy5hcHBlbmRlZCkge1xyXG4gICAgICAgIGZvciAodmFyIHR5cGUgaW4gc291cmNlQnVmZmVyKSB7XHJcbiAgICAgICAgICAvLyBjaGVjayBpZiBzb3VyY2VidWZmZXIgdHlwZSBpcyBkZWZpbmVkICh0eXBlSW4pOiBpZiB5ZXMsIGxldCdzIG9ubHkgZmx1c2ggdGhpcyBvbmVcclxuICAgICAgICAgIC8vIGlmIG5vLCBsZXQncyBmbHVzaCBhbGwgc291cmNlYnVmZmVyc1xyXG4gICAgICAgICAgaWYgKHR5cGVJbiAmJiB0eXBlICE9PSB0eXBlSW4pIHtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBzYiA9IHNvdXJjZUJ1ZmZlclt0eXBlXTtcclxuICAgICAgICAgIC8vIHdlIGFyZSBnb2luZyB0byBmbHVzaCBidWZmZXIsIG1hcmsgc291cmNlIGJ1ZmZlciBhcyAnbm90IGVuZGVkJ1xyXG4gICAgICAgICAgc2IuZW5kZWQgPSBmYWxzZTtcclxuICAgICAgICAgIGlmICghc2IudXBkYXRpbmcpIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2IuYnVmZmVyZWQubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGJ1ZlN0YXJ0ID0gc2IuYnVmZmVyZWQuc3RhcnQoaSk7XHJcbiAgICAgICAgICAgICAgICBidWZFbmQgPSBzYi5idWZmZXJlZC5lbmQoaSk7XHJcbiAgICAgICAgICAgICAgICAvLyB3b3JrYXJvdW5kIGZpcmVmb3ggbm90IGFibGUgdG8gcHJvcGVybHkgZmx1c2ggbXVsdGlwbGUgYnVmZmVyZWQgcmFuZ2UuXHJcbiAgICAgICAgICAgICAgICBpZiAobmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ2ZpcmVmb3gnKSAhPT0gLTEgJiYgZW5kT2Zmc2V0ID09PSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpIHtcclxuICAgICAgICAgICAgICAgICAgZmx1c2hTdGFydCA9IHN0YXJ0T2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgICBmbHVzaEVuZCA9IGVuZE9mZnNldDtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgIGZsdXNoU3RhcnQgPSBNYXRoLm1heChidWZTdGFydCwgc3RhcnRPZmZzZXQpO1xyXG4gICAgICAgICAgICAgICAgICBmbHVzaEVuZCA9IE1hdGgubWluKGJ1ZkVuZCwgZW5kT2Zmc2V0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8qIHNvbWV0aW1lcyBzb3VyY2VidWZmZXIucmVtb3ZlKCkgZG9lcyBub3QgZmx1c2hcclxuICAgICAgICAgICAgICAgICAgIHRoZSBleGFjdCBleHBlY3RlZCB0aW1lIHJhbmdlLlxyXG4gICAgICAgICAgICAgICAgICAgdG8gYXZvaWQgcm91bmRpbmcgaXNzdWVzL2luZmluaXRlIGxvb3AsXHJcbiAgICAgICAgICAgICAgICAgICBvbmx5IGZsdXNoIGJ1ZmZlciByYW5nZSBvZiBsZW5ndGggZ3JlYXRlciB0aGFuIDUwMG1zLlxyXG4gICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGlmIChNYXRoLm1pbihmbHVzaEVuZCxidWZFbmQpIC0gZmx1c2hTdGFydCA+IDAuNSApIHtcclxuICAgICAgICAgICAgICAgICAgdGhpcy5mbHVzaEJ1ZmZlckNvdW50ZXIrKztcclxuICAgICAgICAgICAgICAgICAgbG9nZ2VyLmxvZyhgZmx1c2ggJHt0eXBlfSBbJHtmbHVzaFN0YXJ0fSwke2ZsdXNoRW5kfV0sIG9mIFske2J1ZlN0YXJ0fSwke2J1ZkVuZH1dLCBwb3M6JHt0aGlzLm1lZGlhLmN1cnJlbnRUaW1lfWApO1xyXG4gICAgICAgICAgICAgICAgICBzYi5yZW1vdmUoZmx1c2hTdGFydCwgZmx1c2hFbmQpO1xyXG4gICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGNhdGNoKGUpIHtcclxuICAgICAgICAgICAgICBsb2dnZXIud2FybignZXhjZXB0aW9uIHdoaWxlIGFjY2Vzc2luZyBzb3VyY2VidWZmZXIsIGl0IG1pZ2h0IGhhdmUgYmVlbiByZW1vdmVkIGZyb20gTWVkaWFTb3VyY2UnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy9sb2dnZXIubG9nKCdhYm9ydCAnICsgdHlwZSArICcgYXBwZW5kIGluIHByb2dyZXNzJyk7XHJcbiAgICAgICAgICAgIC8vIHRoaXMgd2lsbCBhYm9ydCBhbnkgYXBwZW5kaW5nIGluIHByb2dyZXNzXHJcbiAgICAgICAgICAgIC8vc2IuYWJvcnQoKTtcclxuICAgICAgICAgICAgbG9nZ2VyLndhcm4oJ2Nhbm5vdCBmbHVzaCwgc2IgdXBkYXRpbmcgaW4gcHJvZ3Jlc3MnKTtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBsb2dnZXIud2FybignYWJvcnQgZmx1c2hpbmcgdG9vIG1hbnkgcmV0cmllcycpO1xyXG4gICAgICB9XHJcbiAgICAgIGxvZ2dlci5sb2coJ2J1ZmZlciBmbHVzaGVkJyk7XHJcbiAgICB9XHJcbiAgICAvLyBldmVyeXRoaW5nIGZsdXNoZWQgIVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBCdWZmZXJDb250cm9sbGVyO1xyXG4iLCIvKlxyXG4gKiBjYXAgc3RyZWFtIGxldmVsIHRvIG1lZGlhIHNpemUgZGltZW5zaW9uIGNvbnRyb2xsZXJcclxuKi9cclxuXHJcbmltcG9ydCBFdmVudCBmcm9tICcuLi9ldmVudHMnO1xyXG5pbXBvcnQgRXZlbnRIYW5kbGVyIGZyb20gJy4uL2V2ZW50LWhhbmRsZXInO1xyXG5cclxuY2xhc3MgQ2FwTGV2ZWxDb250cm9sbGVyIGV4dGVuZHMgRXZlbnRIYW5kbGVyIHtcclxuXHRjb25zdHJ1Y3RvcihobHMpIHtcclxuICAgIHN1cGVyKGhscyxcclxuICAgICAgRXZlbnQuRlBTX0RST1BfTEVWRUxfQ0FQUElORyxcclxuICAgICAgRXZlbnQuTUVESUFfQVRUQUNISU5HLFxyXG4gICAgICBFdmVudC5NQU5JRkVTVF9QQVJTRUQpO1xyXG5cdH1cclxuXHJcblx0ZGVzdHJveSgpIHtcclxuICAgIGlmICh0aGlzLmhscy5jb25maWcuY2FwTGV2ZWxUb1BsYXllclNpemUpIHtcclxuICAgICAgdGhpcy5tZWRpYSA9IHRoaXMucmVzdHJpY3RlZExldmVscyA9IG51bGw7XHJcbiAgICAgIHRoaXMuYXV0b0xldmVsQ2FwcGluZyA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcclxuICAgICAgaWYgKHRoaXMudGltZXIpIHtcclxuICAgICAgICB0aGlzLnRpbWVyID0gY2xlYXJJbnRlcnZhbCh0aGlzLnRpbWVyKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgb25GcHNEcm9wTGV2ZWxDYXBwaW5nKGRhdGEpIHtcclxuXHQgIC8vIERvbid0IGFkZCBhIHJlc3RyaWN0ZWQgbGV2ZWwgbW9yZSB0aGFuIG9uY2VcclxuICAgIGlmIChDYXBMZXZlbENvbnRyb2xsZXIuaXNMZXZlbEFsbG93ZWQoZGF0YS5kcm9wcGVkTGV2ZWwsIHRoaXMucmVzdHJpY3RlZExldmVscykpIHtcclxuICAgICAgdGhpcy5yZXN0cmljdGVkTGV2ZWxzLnB1c2goZGF0YS5kcm9wcGVkTGV2ZWwpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcblx0b25NZWRpYUF0dGFjaGluZyhkYXRhKSB7XHJcbiAgICB0aGlzLm1lZGlhID0gZGF0YS5tZWRpYSBpbnN0YW5jZW9mIEhUTUxWaWRlb0VsZW1lbnQgPyBkYXRhLm1lZGlhIDogbnVsbDtcclxuICB9XHJcblxyXG4gIG9uTWFuaWZlc3RQYXJzZWQoZGF0YSkge1xyXG4gICAgY29uc3QgaGxzID0gdGhpcy5obHM7XHJcbiAgICB0aGlzLnJlc3RyaWN0ZWRMZXZlbHMgPSBbXTtcclxuICAgIGlmIChobHMuY29uZmlnLmNhcExldmVsVG9QbGF5ZXJTaXplKSB7XHJcbiAgICAgIHRoaXMuYXV0b0xldmVsQ2FwcGluZyA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcclxuICAgICAgdGhpcy5sZXZlbHMgPSBkYXRhLmxldmVscztcclxuICAgICAgaGxzLmZpcnN0TGV2ZWwgPSB0aGlzLmdldE1heExldmVsKGRhdGEuZmlyc3RMZXZlbCk7XHJcbiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy50aW1lcik7XHJcbiAgICAgIHRoaXMudGltZXIgPSBzZXRJbnRlcnZhbCh0aGlzLmRldGVjdFBsYXllclNpemUuYmluZCh0aGlzKSwgMTAwMCk7XHJcbiAgICAgIHRoaXMuZGV0ZWN0UGxheWVyU2l6ZSgpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZGV0ZWN0UGxheWVyU2l6ZSgpIHtcclxuICAgIGlmICh0aGlzLm1lZGlhKSB7XHJcbiAgICAgIGxldCBsZXZlbHNMZW5ndGggPSB0aGlzLmxldmVscyA/IHRoaXMubGV2ZWxzLmxlbmd0aCA6IDA7XHJcbiAgICAgIGlmIChsZXZlbHNMZW5ndGgpIHtcclxuICAgICAgICBjb25zdCBobHMgPSB0aGlzLmhscztcclxuICAgICAgICBobHMuYXV0b0xldmVsQ2FwcGluZyA9IHRoaXMuZ2V0TWF4TGV2ZWwobGV2ZWxzTGVuZ3RoIC0gMSk7XHJcbiAgICAgICAgaWYgKGhscy5hdXRvTGV2ZWxDYXBwaW5nID4gdGhpcy5hdXRvTGV2ZWxDYXBwaW5nKSB7XHJcbiAgICAgICAgICAvLyBpZiBhdXRvIGxldmVsIGNhcHBpbmcgaGFzIGEgaGlnaGVyIHZhbHVlIGZvciB0aGUgcHJldmlvdXMgb25lLCBmbHVzaCB0aGUgYnVmZmVyIHVzaW5nIG5leHRMZXZlbFN3aXRjaFxyXG4gICAgICAgICAgLy8gdXN1YWxseSBoYXBwZW4gd2hlbiB0aGUgdXNlciBnbyB0byB0aGUgZnVsbHNjcmVlbiBtb2RlLlxyXG4gICAgICAgICAgaGxzLnN0cmVhbUNvbnRyb2xsZXIubmV4dExldmVsU3dpdGNoKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuYXV0b0xldmVsQ2FwcGluZyA9IGhscy5hdXRvTGV2ZWxDYXBwaW5nO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKlxyXG4gICogcmV0dXJucyBsZXZlbCBzaG91bGQgYmUgdGhlIG9uZSB3aXRoIHRoZSBkaW1lbnNpb25zIGVxdWFsIG9yIGdyZWF0ZXIgdGhhbiB0aGUgbWVkaWEgKHBsYXllcikgZGltZW5zaW9ucyAoc28gdGhlIHZpZGVvIHdpbGwgYmUgZG93bnNjYWxlZClcclxuICAqL1xyXG4gIGdldE1heExldmVsKGNhcExldmVsSW5kZXgpIHtcclxuICAgIGlmICghdGhpcy5sZXZlbHMpIHtcclxuICAgICAgcmV0dXJuIC0xO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHZhbGlkTGV2ZWxzID0gdGhpcy5sZXZlbHMuZmlsdGVyKChsZXZlbCwgaW5kZXgpID0+XHJcbiAgICAgIENhcExldmVsQ29udHJvbGxlci5pc0xldmVsQWxsb3dlZChpbmRleCwgdGhpcy5yZXN0cmljdGVkTGV2ZWxzKSAmJiBpbmRleCA8PSBjYXBMZXZlbEluZGV4XHJcbiAgICApO1xyXG5cclxuICAgIHJldHVybiBDYXBMZXZlbENvbnRyb2xsZXIuZ2V0TWF4TGV2ZWxCeU1lZGlhU2l6ZSh2YWxpZExldmVscywgdGhpcy5tZWRpYVdpZHRoLCB0aGlzLm1lZGlhSGVpZ2h0KTtcclxuICB9XHJcblxyXG4gIGdldCBtZWRpYVdpZHRoKCkge1xyXG4gICAgbGV0IHdpZHRoO1xyXG4gICAgY29uc3QgbWVkaWEgPSB0aGlzLm1lZGlhO1xyXG4gICAgaWYgKG1lZGlhKSB7XHJcbiAgICAgIHdpZHRoID0gbWVkaWEud2lkdGggfHwgbWVkaWEuY2xpZW50V2lkdGggfHwgbWVkaWEub2Zmc2V0V2lkdGg7XHJcbiAgICAgIHdpZHRoICo9IENhcExldmVsQ29udHJvbGxlci5jb250ZW50U2NhbGVGYWN0b3I7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gd2lkdGg7XHJcbiAgfVxyXG5cclxuICBnZXQgbWVkaWFIZWlnaHQoKSB7XHJcbiAgICBsZXQgaGVpZ2h0O1xyXG4gICAgY29uc3QgbWVkaWEgPSB0aGlzLm1lZGlhO1xyXG4gICAgaWYgKG1lZGlhKSB7XHJcbiAgICAgIGhlaWdodCA9IG1lZGlhLmhlaWdodCB8fCBtZWRpYS5jbGllbnRIZWlnaHQgfHwgbWVkaWEub2Zmc2V0SGVpZ2h0O1xyXG4gICAgICBoZWlnaHQgKj0gQ2FwTGV2ZWxDb250cm9sbGVyLmNvbnRlbnRTY2FsZUZhY3RvcjtcclxuICAgIH1cclxuICAgIHJldHVybiBoZWlnaHQ7XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgZ2V0IGNvbnRlbnRTY2FsZUZhY3RvcigpIHtcclxuICAgIGxldCBwaXhlbFJhdGlvID0gMTtcclxuICAgIHRyeSB7XHJcbiAgICAgIHBpeGVsUmF0aW8gPSAgd2luZG93LmRldmljZVBpeGVsUmF0aW87XHJcbiAgICB9IGNhdGNoKGUpIHt9XHJcbiAgICByZXR1cm4gcGl4ZWxSYXRpbztcclxuICB9XHJcblxyXG4gIHN0YXRpYyBpc0xldmVsQWxsb3dlZChsZXZlbCwgcmVzdHJpY3RlZExldmVscyA9IFtdKSB7XHJcbiAgICByZXR1cm4gcmVzdHJpY3RlZExldmVscy5pbmRleE9mKGxldmVsKSA9PT0gLTE7XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgZ2V0TWF4TGV2ZWxCeU1lZGlhU2l6ZShsZXZlbHMsIHdpZHRoLCBoZWlnaHQpIHtcclxuICAgIGlmICghbGV2ZWxzIHx8IChsZXZlbHMgJiYgIWxldmVscy5sZW5ndGgpKSB7XHJcbiAgICAgIHJldHVybiAtMTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBMZXZlbHMgY2FuIGhhdmUgdGhlIHNhbWUgZGltZW5zaW9ucyBidXQgZGlmZmVyaW5nIGJhbmR3aWR0aHMgLSBzaW5jZSBsZXZlbHMgYXJlIG9yZGVyZWQsIHdlIGNhbiBsb29rIHRvIHRoZSBuZXh0XHJcbiAgICAvLyB0byBkZXRlcm1pbmUgd2hldGhlciB3ZSd2ZSBjaG9zZW4gdGhlIGdyZWF0ZXN0IGJhbmR3aWR0aCBmb3IgdGhlIG1lZGlhJ3MgZGltZW5zaW9uc1xyXG4gICAgY29uc3QgYXRHcmVhdGVzdEJhbmRpd2R0aCA9IChjdXJMZXZlbCwgbmV4dExldmVsKSA9PiB7XHJcbiAgICAgIGlmICghbmV4dExldmVsKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGN1ckxldmVsLndpZHRoICE9PSBuZXh0TGV2ZWwud2lkdGggfHwgY3VyTGV2ZWwuaGVpZ2h0ICE9PSBuZXh0TGV2ZWwuaGVpZ2h0O1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBJZiB3ZSBydW4gdGhyb3VnaCB0aGUgbG9vcCB3aXRob3V0IGJyZWFraW5nLCB0aGUgbWVkaWEncyBkaW1lbnNpb25zIGFyZSBncmVhdGVyIHRoYW4gZXZlcnkgbGV2ZWwsIHNvIGRlZmF1bHQgdG9cclxuICAgIC8vIHRoZSBtYXggbGV2ZWxcclxuICAgIGxldCBtYXhMZXZlbEluZGV4ID0gbGV2ZWxzLmxlbmd0aCAtIDE7XHJcblxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZXZlbHMubGVuZ3RoOyBpKz0gMSkge1xyXG4gICAgICBjb25zdCBsZXZlbCA9IGxldmVsc1tpXTtcclxuICAgICAgaWYgKChsZXZlbC53aWR0aCA+PSB3aWR0aCB8fCBsZXZlbC5oZWlnaHQgPj0gaGVpZ2h0KSAmJiBhdEdyZWF0ZXN0QmFuZGl3ZHRoKGxldmVsLCBsZXZlbHNbaSArIDFdKSkge1xyXG4gICAgICAgIG1heExldmVsSW5kZXggPSBpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG1heExldmVsSW5kZXg7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBDYXBMZXZlbENvbnRyb2xsZXI7XHJcbiIsIi8qXHJcbiAqIEZQUyBDb250cm9sbGVyXHJcbiovXHJcblxyXG5pbXBvcnQgRXZlbnQgZnJvbSAnLi4vZXZlbnRzJztcclxuaW1wb3J0IEV2ZW50SGFuZGxlciBmcm9tICcuLi9ldmVudC1oYW5kbGVyJztcclxuaW1wb3J0IHtsb2dnZXJ9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XHJcblxyXG5jbGFzcyBGUFNDb250cm9sbGVyIGV4dGVuZHMgRXZlbnRIYW5kbGVye1xyXG5cclxuICBjb25zdHJ1Y3RvcihobHMpIHtcclxuICAgIHN1cGVyKGhscywgRXZlbnQuTUVESUFfQVRUQUNISU5HKTtcclxuICB9XHJcblxyXG4gIGRlc3Ryb3koKSB7XHJcbiAgICBpZiAodGhpcy50aW1lcikge1xyXG4gICAgICBjbGVhckludGVydmFsKHRoaXMudGltZXIpO1xyXG4gICAgfVxyXG4gICAgdGhpcy5pc1ZpZGVvUGxheWJhY2tRdWFsaXR5QXZhaWxhYmxlID0gZmFsc2U7XHJcbiAgfVxyXG5cclxuICBvbk1lZGlhQXR0YWNoaW5nKGRhdGEpIHtcclxuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuaGxzLmNvbmZpZztcclxuICAgIGlmIChjb25maWcuY2FwTGV2ZWxPbkZQU0Ryb3ApIHtcclxuICAgICAgY29uc3QgdmlkZW8gPSB0aGlzLnZpZGVvID0gZGF0YS5tZWRpYSBpbnN0YW5jZW9mIEhUTUxWaWRlb0VsZW1lbnQgPyBkYXRhLm1lZGlhIDogbnVsbDtcclxuICAgICAgaWYgKHR5cGVvZiB2aWRlby5nZXRWaWRlb1BsYXliYWNrUXVhbGl0eSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIHRoaXMuaXNWaWRlb1BsYXliYWNrUXVhbGl0eUF2YWlsYWJsZSA9IHRydWU7XHJcbiAgICAgIH1cclxuICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLnRpbWVyKTtcclxuICAgICAgdGhpcy50aW1lciA9IHNldEludGVydmFsKHRoaXMuY2hlY2tGUFNJbnRlcnZhbC5iaW5kKHRoaXMpLCBjb25maWcuZnBzRHJvcHBlZE1vbml0b3JpbmdQZXJpb2QpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgY2hlY2tGUFModmlkZW8sIGRlY29kZWRGcmFtZXMsIGRyb3BwZWRGcmFtZXMpIHtcclxuICAgIGxldCBjdXJyZW50VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xyXG4gICAgaWYgKGRlY29kZWRGcmFtZXMpIHtcclxuICAgICAgaWYgKHRoaXMubGFzdFRpbWUpIHtcclxuICAgICAgICBsZXQgY3VycmVudFBlcmlvZCA9IGN1cnJlbnRUaW1lIC0gdGhpcy5sYXN0VGltZSxcclxuICAgICAgICAgICAgY3VycmVudERyb3BwZWQgPSBkcm9wcGVkRnJhbWVzIC0gdGhpcy5sYXN0RHJvcHBlZEZyYW1lcyxcclxuICAgICAgICAgICAgY3VycmVudERlY29kZWQgPSBkZWNvZGVkRnJhbWVzIC0gdGhpcy5sYXN0RGVjb2RlZEZyYW1lcyxcclxuICAgICAgICAgICAgZHJvcHBlZEZQUyA9IDEwMDAgKiBjdXJyZW50RHJvcHBlZCAvIGN1cnJlbnRQZXJpb2QsXHJcbiAgICAgICAgICAgIGhscyA9IHRoaXMuaGxzO1xyXG4gICAgICAgIGhscy50cmlnZ2VyKEV2ZW50LkZQU19EUk9QLCB7Y3VycmVudERyb3BwZWQ6IGN1cnJlbnREcm9wcGVkLCBjdXJyZW50RGVjb2RlZDogY3VycmVudERlY29kZWQsIHRvdGFsRHJvcHBlZEZyYW1lczogZHJvcHBlZEZyYW1lc30pO1xyXG4gICAgICAgIGlmIChkcm9wcGVkRlBTID4gMCkge1xyXG4gICAgICAgICAgLy9sb2dnZXIubG9nKCdjaGVja0ZQUyA6IGRyb3BwZWRGUFMvZGVjb2RlZEZQUzonICsgZHJvcHBlZEZQUy8oMTAwMCAqIGN1cnJlbnREZWNvZGVkIC8gY3VycmVudFBlcmlvZCkpO1xyXG4gICAgICAgICAgaWYgKGN1cnJlbnREcm9wcGVkID4gaGxzLmNvbmZpZy5mcHNEcm9wcGVkTW9uaXRvcmluZ1RocmVzaG9sZCAqIGN1cnJlbnREZWNvZGVkKSB7XHJcbiAgICAgICAgICAgIGxldCBjdXJyZW50TGV2ZWwgPSBobHMuY3VycmVudExldmVsO1xyXG4gICAgICAgICAgICBsb2dnZXIud2FybignZHJvcCBGUFMgcmF0aW8gZ3JlYXRlciB0aGFuIG1heCBhbGxvd2VkIHZhbHVlIGZvciBjdXJyZW50TGV2ZWw6ICcgKyBjdXJyZW50TGV2ZWwpO1xyXG4gICAgICAgICAgICBpZiAoY3VycmVudExldmVsID4gMCAmJiAoaGxzLmF1dG9MZXZlbENhcHBpbmcgPT09IC0xIHx8IGhscy5hdXRvTGV2ZWxDYXBwaW5nID49IGN1cnJlbnRMZXZlbCkpIHtcclxuICAgICAgICAgICAgICBjdXJyZW50TGV2ZWwgPSBjdXJyZW50TGV2ZWwgLSAxO1xyXG4gICAgICAgICAgICAgIGhscy50cmlnZ2VyKEV2ZW50LkZQU19EUk9QX0xFVkVMX0NBUFBJTkcsIHtsZXZlbDogY3VycmVudExldmVsLCBkcm9wcGVkTGV2ZWw6IGhscy5jdXJyZW50TGV2ZWx9KTtcclxuICAgICAgICAgICAgICBobHMuYXV0b0xldmVsQ2FwcGluZyA9IGN1cnJlbnRMZXZlbDtcclxuICAgICAgICAgICAgICBobHMuc3RyZWFtQ29udHJvbGxlci5uZXh0TGV2ZWxTd2l0Y2goKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICB0aGlzLmxhc3RUaW1lID0gY3VycmVudFRpbWU7XHJcbiAgICAgIHRoaXMubGFzdERyb3BwZWRGcmFtZXMgPSBkcm9wcGVkRnJhbWVzO1xyXG4gICAgICB0aGlzLmxhc3REZWNvZGVkRnJhbWVzID0gZGVjb2RlZEZyYW1lcztcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGNoZWNrRlBTSW50ZXJ2YWwoKSB7XHJcbiAgICBjb25zdCB2aWRlbyA9IHRoaXMudmlkZW87XHJcbiAgICBpZiAodmlkZW8pIHtcclxuICAgICAgaWYgKHRoaXMuaXNWaWRlb1BsYXliYWNrUXVhbGl0eUF2YWlsYWJsZSkge1xyXG4gICAgICAgIGxldCB2aWRlb1BsYXliYWNrUXVhbGl0eSA9IHZpZGVvLmdldFZpZGVvUGxheWJhY2tRdWFsaXR5KCk7XHJcbiAgICAgICAgdGhpcy5jaGVja0ZQUyh2aWRlbywgdmlkZW9QbGF5YmFja1F1YWxpdHkudG90YWxWaWRlb0ZyYW1lcywgdmlkZW9QbGF5YmFja1F1YWxpdHkuZHJvcHBlZFZpZGVvRnJhbWVzKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLmNoZWNrRlBTKHZpZGVvLCB2aWRlby53ZWJraXREZWNvZGVkRnJhbWVDb3VudCwgdmlkZW8ud2Via2l0RHJvcHBlZEZyYW1lQ291bnQpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBGUFNDb250cm9sbGVyO1xyXG5cclxuIiwiLypcclxuICogaWQzIG1ldGFkYXRhIHRyYWNrIGNvbnRyb2xsZXJcclxuKi9cclxuXHJcbmltcG9ydCBFdmVudCBmcm9tICcuLi9ldmVudHMnO1xyXG5pbXBvcnQgRXZlbnRIYW5kbGVyIGZyb20gJy4uL2V2ZW50LWhhbmRsZXInO1xyXG5pbXBvcnQgSUQzIGZyb20gJy4uL2RlbXV4L2lkMyc7XHJcblxyXG5jbGFzcyBJRDNUcmFja0NvbnRyb2xsZXIgZXh0ZW5kcyBFdmVudEhhbmRsZXIge1xyXG5cclxuICBjb25zdHJ1Y3RvcihobHMpIHtcclxuICAgIHN1cGVyKGhscyxcclxuICAgICAgICAgICAgICAgRXZlbnQuTUVESUFfQVRUQUNIRUQsXHJcbiAgICAgICAgICAgICAgIEV2ZW50Lk1FRElBX0RFVEFDSElORyxcclxuICAgICAgICAgICAgICAgRXZlbnQuRlJBR19QQVJTSU5HX01FVEFEQVRBKTtcclxuICAgIHRoaXMuaWQzVHJhY2sgPSB1bmRlZmluZWQ7XHJcbiAgICB0aGlzLm1lZGlhID0gdW5kZWZpbmVkO1xyXG4gIH1cclxuXHJcbiAgZGVzdHJveSgpIHtcclxuICAgIEV2ZW50SGFuZGxlci5wcm90b3R5cGUuZGVzdHJveS5jYWxsKHRoaXMpO1xyXG4gIH1cclxuXHJcbiAgLy8gQWRkIElEMyBtZXRhdGFkYXRhIHRleHQgdHJhY2suXHJcbiAgb25NZWRpYUF0dGFjaGVkKGRhdGEpIHtcclxuICAgIHRoaXMubWVkaWEgPSBkYXRhLm1lZGlhO1xyXG4gICAgaWYgKCF0aGlzLm1lZGlhKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmlkM1RyYWNrID0gdGhpcy5tZWRpYS5hZGRUZXh0VHJhY2soJ21ldGFkYXRhJywgJ2lkMycpO1xyXG4gICAgdGhpcy5pZDNUcmFjay5tb2RlID0gJ2hpZGRlbic7XHJcbiAgfVxyXG5cclxuICBvbk1lZGlhRGV0YWNoaW5nKCkge1xyXG4gICAgdGhpcy5tZWRpYSA9IHVuZGVmaW5lZDtcclxuICB9XHJcblxyXG4gIG9uRnJhZ1BhcnNpbmdNZXRhZGF0YShkYXRhKSB7XHJcbiAgICBjb25zdCBmcmFnbWVudCA9IGRhdGEuZnJhZztcclxuICAgIGNvbnN0IHNhbXBsZXMgPSBkYXRhLnNhbXBsZXM7XHJcblxyXG4gICAgLy8gQXR0ZW1wdCB0byByZWNyZWF0ZSBTYWZhcmkgZnVuY3Rpb25hbGl0eSBieSBjcmVhdGluZ1xyXG4gICAgLy8gV2ViS2l0RGF0YUN1ZSBvYmplY3RzIHdoZW4gYXZhaWxhYmxlIGFuZCBzdG9yZSB0aGUgZGVjb2RlZFxyXG4gICAgLy8gSUQzIGRhdGEgaW4gdGhlIHZhbHVlIHByb3BlcnR5IG9mIHRoZSBjdWVcclxuICAgIGxldCBDdWUgPSB3aW5kb3cuV2ViS2l0RGF0YUN1ZSB8fCB3aW5kb3cuVlRUQ3VlIHx8IHdpbmRvdy5UZXh0VHJhY2tDdWU7XHJcblxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzYW1wbGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGNvbnN0IGZyYW1lcyA9IElEMy5nZXRJRDNGcmFtZXMoc2FtcGxlc1tpXS5kYXRhKTtcclxuICAgICAgaWYgKGZyYW1lcykge1xyXG4gICAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHNhbXBsZXNbaV0ucHRzO1xyXG4gICAgICAgIGxldCBlbmRUaW1lID0gaSA8IHNhbXBsZXMubGVuZ3RoIC0gMSA/IHNhbXBsZXNbaSsxXS5wdHMgOiBmcmFnbWVudC5lbmRQVFM7XHJcblxyXG4gICAgICAgIC8vIEdpdmUgYSBzbGlnaHQgYnVtcCB0byB0aGUgZW5kVGltZSBpZiBpdCdzIGVxdWFsIHRvIHN0YXJ0VGltZSB0byBhdm9pZCBhIFN5bnRheEVycm9yIGluIElFXHJcbiAgICAgICAgaWYgKHN0YXJ0VGltZSA9PT0gZW5kVGltZSkge1xyXG4gICAgICAgICAgZW5kVGltZSArPSAwLjAwMDE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IobGV0IGogPSAwOyBqIDwgZnJhbWVzLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICBjb25zdCBmcmFtZSA9IGZyYW1lc1tqXTtcclxuICAgICAgICAgIC8vIFNhZmFyaSBkb2Vzbid0IHB1dCB0aGUgdGltZXN0YW1wIGZyYW1lIGluIHRoZSBUZXh0VHJhY2tcclxuICAgICAgICAgIGlmICghSUQzLmlzVGltZVN0YW1wRnJhbWUoZnJhbWUpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGN1ZSA9IG5ldyBDdWUoc3RhcnRUaW1lLCBlbmRUaW1lLCAnJyk7XHJcbiAgICAgICAgICAgIGN1ZS52YWx1ZSA9IGZyYW1lO1xyXG4gICAgICAgICAgICB0aGlzLmlkM1RyYWNrLmFkZEN1ZShjdWUpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgSUQzVHJhY2tDb250cm9sbGVyO1xyXG4iLCIvKlxyXG4gKiBMZXZlbCBDb250cm9sbGVyXHJcbiovXHJcblxyXG5pbXBvcnQgRXZlbnQgZnJvbSAnLi4vZXZlbnRzJztcclxuaW1wb3J0IEV2ZW50SGFuZGxlciBmcm9tICcuLi9ldmVudC1oYW5kbGVyJztcclxuaW1wb3J0IHtsb2dnZXJ9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XHJcbmltcG9ydCB7RXJyb3JUeXBlcywgRXJyb3JEZXRhaWxzfSBmcm9tICcuLi9lcnJvcnMnO1xyXG5pbXBvcnQgQnVmZmVySGVscGVyIGZyb20gJy4uL2hlbHBlci9idWZmZXItaGVscGVyJztcclxuXHJcbmNsYXNzIExldmVsQ29udHJvbGxlciBleHRlbmRzIEV2ZW50SGFuZGxlciB7XHJcblxyXG4gIGNvbnN0cnVjdG9yKGhscykge1xyXG4gICAgc3VwZXIoaGxzLFxyXG4gICAgICBFdmVudC5NQU5JRkVTVF9MT0FERUQsXHJcbiAgICAgIEV2ZW50LkxFVkVMX0xPQURFRCxcclxuICAgICAgRXZlbnQuRlJBR19MT0FERUQsXHJcbiAgICAgIEV2ZW50LkVSUk9SKTtcclxuICAgIHRoaXMub250aWNrID0gdGhpcy50aWNrLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzLl9tYW51YWxMZXZlbCA9IC0xO1xyXG4gIH1cclxuXHJcbiAgZGVzdHJveSgpIHtcclxuICAgIGlmICh0aGlzLnRpbWVyKSB7XHJcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVyKTtcclxuICAgICAgdGhpcy50aW1lciA9IG51bGw7XHJcbiAgICB9XHJcbiAgICB0aGlzLl9tYW51YWxMZXZlbCA9IC0xO1xyXG4gIH1cclxuXHJcbiAgc3RhcnRMb2FkKCkge1xyXG4gICAgdGhpcy5jYW5sb2FkID0gdHJ1ZTtcclxuICAgIGxldCBsZXZlbHMgPSB0aGlzLl9sZXZlbHM7XHJcbiAgICAvLyBjbGVhbiB1cCBsaXZlIGxldmVsIGRldGFpbHMgdG8gZm9yY2UgcmVsb2FkIHRoZW0sIGFuZCByZXNldCBsb2FkIGVycm9yc1xyXG4gICAgaWYobGV2ZWxzKSB7XHJcbiAgICAgIGxldmVscy5mb3JFYWNoKGxldmVsID0+IHtcclxuICAgICAgICBsZXZlbC5sb2FkRXJyb3IgPSAwO1xyXG4gICAgICAgIGNvbnN0IGxldmVsRGV0YWlscyA9IGxldmVsLmRldGFpbHM7XHJcbiAgICAgICAgaWYgKGxldmVsRGV0YWlscyAmJiBsZXZlbERldGFpbHMubGl2ZSkge1xyXG4gICAgICAgICAgbGV2ZWwuZGV0YWlscyA9IHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLy8gc3BlZWQgdXAgbGl2ZSBwbGF5bGlzdCByZWZyZXNoIGlmIHRpbWVyIGV4aXN0c1xyXG4gICAgaWYgKHRoaXMudGltZXIpIHtcclxuICAgICAgdGhpcy50aWNrKCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBzdG9wTG9hZCgpIHtcclxuICAgIHRoaXMuY2FubG9hZCA9IGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgb25NYW5pZmVzdExvYWRlZChkYXRhKSB7XHJcbiAgICB2YXIgbGV2ZWxzMCA9IFtdLFxyXG4gICAgICAgIGxldmVscyA9IFtdLFxyXG4gICAgICAgIGJpdHJhdGVTdGFydCxcclxuICAgICAgICBiaXRyYXRlU2V0ID0ge30sXHJcbiAgICAgICAgdmlkZW9Db2RlY0ZvdW5kID0gZmFsc2UsXHJcbiAgICAgICAgYXVkaW9Db2RlY0ZvdW5kID0gZmFsc2UsXHJcbiAgICAgICAgaGxzID0gdGhpcy5obHMsXHJcbiAgICAgICAgYnJva2VubXA0aW5tcDMgPSAvY2hyb21lfGZpcmVmb3gvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpKSxcclxuICAgICAgICBjaGVja1N1cHBvcnRlZCA9IGZ1bmN0aW9uKHR5cGUsY29kZWMpIHsgcmV0dXJuIE1lZGlhU291cmNlLmlzVHlwZVN1cHBvcnRlZChgJHt0eXBlfS9tcDQ7Y29kZWNzPSR7Y29kZWN9YCk7fTtcclxuXHJcbiAgICAvLyByZWdyb3VwIHJlZHVuZGFudCBsZXZlbCB0b2dldGhlclxyXG4gICAgZGF0YS5sZXZlbHMuZm9yRWFjaChsZXZlbCA9PiB7XHJcbiAgICAgIGlmKGxldmVsLnZpZGVvQ29kZWMpIHtcclxuICAgICAgICB2aWRlb0NvZGVjRm91bmQgPSB0cnVlO1xyXG4gICAgICB9XHJcbiAgICAgIC8vIGVyYXNlIGF1ZGlvIGNvZGVjIGluZm8gaWYgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IG1wNGEuNDAuMzQuIGRlbXV4ZXIgd2lsbCBhdXRvZGV0ZWN0IGNvZGVjIGFuZCBmYWxsYmFjayB0byBtcGVnL2F1ZGlvXHJcbiAgICAgIGlmKGJyb2tlbm1wNGlubXAzICYmIGxldmVsLmF1ZGlvQ29kZWMgJiYgbGV2ZWwuYXVkaW9Db2RlYy5pbmRleE9mKCdtcDRhLjQwLjM0JykgIT09IC0xKSB7XHJcbiAgICAgICAgbGV2ZWwuYXVkaW9Db2RlYyA9IHVuZGVmaW5lZDtcclxuICAgICAgfVxyXG4gICAgICBpZihsZXZlbC5hdWRpb0NvZGVjIHx8IChsZXZlbC5hdHRycyAmJiBsZXZlbC5hdHRycy5BVURJTykpIHtcclxuICAgICAgICBhdWRpb0NvZGVjRm91bmQgPSB0cnVlO1xyXG4gICAgICB9XHJcbiAgICAgIGxldCByZWR1bmRhbnRMZXZlbElkID0gYml0cmF0ZVNldFtsZXZlbC5iaXRyYXRlXTtcclxuICAgICAgaWYgKHJlZHVuZGFudExldmVsSWQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIGJpdHJhdGVTZXRbbGV2ZWwuYml0cmF0ZV0gPSBsZXZlbHMwLmxlbmd0aDtcclxuICAgICAgICBsZXZlbC51cmwgPSBbbGV2ZWwudXJsXTtcclxuICAgICAgICBsZXZlbC51cmxJZCA9IDA7XHJcbiAgICAgICAgbGV2ZWxzMC5wdXNoKGxldmVsKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBsZXZlbHMwW3JlZHVuZGFudExldmVsSWRdLnVybC5wdXNoKGxldmVsLnVybCk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIC8vIHJlbW92ZSBhdWRpby1vbmx5IGxldmVsIGlmIHdlIGFsc28gaGF2ZSBsZXZlbHMgd2l0aCBhdWRpbyt2aWRlbyBjb2RlY3Mgc2lnbmFsbGVkXHJcbiAgICBpZih2aWRlb0NvZGVjRm91bmQgJiYgYXVkaW9Db2RlY0ZvdW5kKSB7XHJcbiAgICAgIGxldmVsczAuZm9yRWFjaChsZXZlbCA9PiB7XHJcbiAgICAgICAgaWYobGV2ZWwudmlkZW9Db2RlYykge1xyXG4gICAgICAgICAgbGV2ZWxzLnB1c2gobGV2ZWwpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBsZXZlbHMgPSBsZXZlbHMwO1xyXG4gICAgfVxyXG4gICAgLy8gb25seSBrZWVwIGxldmVsIHdpdGggc3VwcG9ydGVkIGF1ZGlvL3ZpZGVvIGNvZGVjc1xyXG4gICAgbGV2ZWxzID0gbGV2ZWxzLmZpbHRlcihmdW5jdGlvbihsZXZlbCkge1xyXG4gICAgbGV0IGF1ZGlvQ29kZWMgPSBsZXZlbC5hdWRpb0NvZGVjLCB2aWRlb0NvZGVjID0gbGV2ZWwudmlkZW9Db2RlYztcclxuICAgICAgcmV0dXJuICghYXVkaW9Db2RlYyB8fCBjaGVja1N1cHBvcnRlZCgnYXVkaW8nLGF1ZGlvQ29kZWMpKSAmJlxyXG4gICAgICAgICAgICAgKCF2aWRlb0NvZGVjIHx8IGNoZWNrU3VwcG9ydGVkKCd2aWRlbycsdmlkZW9Db2RlYykpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaWYobGV2ZWxzLmxlbmd0aCkge1xyXG4gICAgICAvLyBzdGFydCBiaXRyYXRlIGlzIHRoZSBmaXJzdCBiaXRyYXRlIG9mIHRoZSBtYW5pZmVzdFxyXG4gICAgICBiaXRyYXRlU3RhcnQgPSBsZXZlbHNbMF0uYml0cmF0ZTtcclxuICAgICAgLy8gc29ydCBsZXZlbCBvbiBiaXRyYXRlXHJcbiAgICAgIGxldmVscy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgcmV0dXJuIGEuYml0cmF0ZSAtIGIuYml0cmF0ZTtcclxuICAgICAgfSk7XHJcbiAgICAgIHRoaXMuX2xldmVscyA9IGxldmVscztcclxuICAgICAgLy8gZmluZCBpbmRleCBvZiBmaXJzdCBsZXZlbCBpbiBzb3J0ZWQgbGV2ZWxzXHJcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGV2ZWxzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKGxldmVsc1tpXS5iaXRyYXRlID09PSBiaXRyYXRlU3RhcnQpIHtcclxuICAgICAgICAgIHRoaXMuX2ZpcnN0TGV2ZWwgPSBpO1xyXG4gICAgICAgICAgbG9nZ2VyLmxvZyhgbWFuaWZlc3QgbG9hZGVkLCR7bGV2ZWxzLmxlbmd0aH0gbGV2ZWwocykgZm91bmQsIGZpcnN0IGJpdHJhdGU6JHtiaXRyYXRlU3RhcnR9YCk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgaGxzLnRyaWdnZXIoRXZlbnQuTUFOSUZFU1RfUEFSU0VELCB7bGV2ZWxzOiBsZXZlbHMsIGZpcnN0TGV2ZWw6IHRoaXMuX2ZpcnN0TGV2ZWwsIHN0YXRzOiBkYXRhLnN0YXRzLCBhdWRpbyA6IGF1ZGlvQ29kZWNGb3VuZCwgdmlkZW8gOiB2aWRlb0NvZGVjRm91bmQsIGFsdEF1ZGlvIDogZGF0YS5hdWRpb1RyYWNrcy5sZW5ndGggPiAwfSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBobHMudHJpZ2dlcihFdmVudC5FUlJPUiwge3R5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsIGRldGFpbHM6IEVycm9yRGV0YWlscy5NQU5JRkVTVF9JTkNPTVBBVElCTEVfQ09ERUNTX0VSUk9SLCBmYXRhbDogdHJ1ZSwgdXJsOiBobHMudXJsLCByZWFzb246ICdubyBsZXZlbCB3aXRoIGNvbXBhdGlibGUgY29kZWNzIGZvdW5kIGluIG1hbmlmZXN0J30pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgZ2V0IGxldmVscygpIHtcclxuICAgIHJldHVybiB0aGlzLl9sZXZlbHM7XHJcbiAgfVxyXG5cclxuICBnZXQgbGV2ZWwoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fbGV2ZWw7XHJcbiAgfVxyXG5cclxuICBzZXQgbGV2ZWwobmV3TGV2ZWwpIHtcclxuICAgIGxldCBsZXZlbHMgPSB0aGlzLl9sZXZlbHM7XHJcbiAgICBpZiAobGV2ZWxzICYmIGxldmVscy5sZW5ndGggPiBuZXdMZXZlbCkge1xyXG4gICAgICBpZiAodGhpcy5fbGV2ZWwgIT09IG5ld0xldmVsIHx8IGxldmVsc1tuZXdMZXZlbF0uZGV0YWlscyA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgdGhpcy5zZXRMZXZlbEludGVybmFsKG5ld0xldmVsKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiBzZXRMZXZlbEludGVybmFsKG5ld0xldmVsKSB7XHJcbiAgICBjb25zdCBsZXZlbHMgPSB0aGlzLl9sZXZlbHM7XHJcbiAgICBjb25zdCBobHMgPSB0aGlzLmhscztcclxuICAgIC8vIGNoZWNrIGlmIGxldmVsIGlkeCBpcyB2YWxpZFxyXG4gICAgaWYgKG5ld0xldmVsID49IDAgJiYgbmV3TGV2ZWwgPCBsZXZlbHMubGVuZ3RoKSB7XHJcbiAgICAgIC8vIHN0b3BwaW5nIGxpdmUgcmVsb2FkaW5nIHRpbWVyIGlmIGFueVxyXG4gICAgICBpZiAodGhpcy50aW1lcikge1xyXG4gICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZXIpO1xyXG4gICAgICAgdGhpcy50aW1lciA9IG51bGw7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHRoaXMuX2xldmVsICE9PSBuZXdMZXZlbCkge1xyXG4gICAgICAgIGxvZ2dlci5sb2coYHN3aXRjaGluZyB0byBsZXZlbCAke25ld0xldmVsfWApO1xyXG4gICAgICAgIHRoaXMuX2xldmVsID0gbmV3TGV2ZWw7XHJcbiAgICAgICAgdmFyIGxldmVsUHJvcGVydGllcyA9IGxldmVsc1tuZXdMZXZlbF07XHJcbiAgICAgICAgbGV2ZWxQcm9wZXJ0aWVzLmxldmVsID0gbmV3TGV2ZWw7XHJcbiAgICAgICAgLy8gTEVWRUxfU1dJVENIIHRvIGJlIGRlcHJlY2F0ZWQgaW4gbmV4dCBtYWpvciByZWxlYXNlXHJcbiAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnQuTEVWRUxfU1dJVENILCBsZXZlbFByb3BlcnRpZXMpO1xyXG4gICAgICAgIGhscy50cmlnZ2VyKEV2ZW50LkxFVkVMX1NXSVRDSElORywgbGV2ZWxQcm9wZXJ0aWVzKTtcclxuICAgICAgfVxyXG4gICAgICB2YXIgbGV2ZWwgPSBsZXZlbHNbbmV3TGV2ZWxdLCBsZXZlbERldGFpbHMgPSBsZXZlbC5kZXRhaWxzO1xyXG4gICAgICAgLy8gY2hlY2sgaWYgd2UgbmVlZCB0byBsb2FkIHBsYXlsaXN0IGZvciB0aGlzIGxldmVsXHJcbiAgICAgIGlmICghbGV2ZWxEZXRhaWxzIHx8IGxldmVsRGV0YWlscy5saXZlID09PSB0cnVlKSB7XHJcbiAgICAgICAgLy8gbGV2ZWwgbm90IHJldHJpZXZlZCB5ZXQsIG9yIGxpdmUgcGxheWxpc3Qgd2UgbmVlZCB0byAocmUpbG9hZCBpdFxyXG4gICAgICAgIHZhciB1cmxJZCA9IGxldmVsLnVybElkO1xyXG4gICAgICAgIGhscy50cmlnZ2VyKEV2ZW50LkxFVkVMX0xPQURJTkcsIHt1cmw6IGxldmVsLnVybFt1cmxJZF0sIGxldmVsOiBuZXdMZXZlbCwgaWQ6IHVybElkfSk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIGludmFsaWQgbGV2ZWwgaWQgZ2l2ZW4sIHRyaWdnZXIgZXJyb3JcclxuICAgICAgaGxzLnRyaWdnZXIoRXZlbnQuRVJST1IsIHt0eXBlIDogRXJyb3JUeXBlcy5PVEhFUl9FUlJPUiwgZGV0YWlsczogRXJyb3JEZXRhaWxzLkxFVkVMX1NXSVRDSF9FUlJPUiwgbGV2ZWw6IG5ld0xldmVsLCBmYXRhbDogZmFsc2UsIHJlYXNvbjogJ2ludmFsaWQgbGV2ZWwgaWR4J30pO1xyXG4gICAgfVxyXG4gfVxyXG5cclxuICBnZXQgbWFudWFsTGV2ZWwoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fbWFudWFsTGV2ZWw7XHJcbiAgfVxyXG5cclxuICBzZXQgbWFudWFsTGV2ZWwobmV3TGV2ZWwpIHtcclxuICAgIHRoaXMuX21hbnVhbExldmVsID0gbmV3TGV2ZWw7XHJcbiAgICBpZiAodGhpcy5fc3RhcnRMZXZlbCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHRoaXMuX3N0YXJ0TGV2ZWwgPSBuZXdMZXZlbDtcclxuICAgIH1cclxuICAgIGlmIChuZXdMZXZlbCAhPT0gLTEpIHtcclxuICAgICAgdGhpcy5sZXZlbCA9IG5ld0xldmVsO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZ2V0IGZpcnN0TGV2ZWwoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fZmlyc3RMZXZlbDtcclxuICB9XHJcblxyXG4gIHNldCBmaXJzdExldmVsKG5ld0xldmVsKSB7XHJcbiAgICB0aGlzLl9maXJzdExldmVsID0gbmV3TGV2ZWw7XHJcbiAgfVxyXG5cclxuICBnZXQgc3RhcnRMZXZlbCgpIHtcclxuICAgIC8vIGhscy5zdGFydExldmVsIHRha2VzIHByZWNlZGVuY2Ugb3ZlciBjb25maWcuc3RhcnRMZXZlbFxyXG4gICAgLy8gaWYgbm9uZSBvZiB0aGVzZSB2YWx1ZXMgYXJlIGRlZmluZWQsIGZhbGxiYWNrIG9uIHRoaXMuX2ZpcnN0TGV2ZWwgKGZpcnN0IHF1YWxpdHkgbGV2ZWwgYXBwZWFyaW5nIGluIHZhcmlhbnQgbWFuaWZlc3QpXHJcbiAgICBpZiAodGhpcy5fc3RhcnRMZXZlbCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIGxldCBjb25maWdTdGFydExldmVsID0gdGhpcy5obHMuY29uZmlnLnN0YXJ0TGV2ZWw7XHJcbiAgICAgIGlmIChjb25maWdTdGFydExldmVsICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICByZXR1cm4gY29uZmlnU3RhcnRMZXZlbDtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZmlyc3RMZXZlbDtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuIHRoaXMuX3N0YXJ0TGV2ZWw7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBzZXQgc3RhcnRMZXZlbChuZXdMZXZlbCkge1xyXG4gICAgdGhpcy5fc3RhcnRMZXZlbCA9IG5ld0xldmVsO1xyXG4gIH1cclxuXHJcbiAgb25FcnJvcihkYXRhKSB7XHJcbiAgICBpZihkYXRhLmZhdGFsKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBsZXQgZGV0YWlscyA9IGRhdGEuZGV0YWlscywgaGxzID0gdGhpcy5obHMsIGxldmVsSWQsIGxldmVsLCBsZXZlbEVycm9yID0gZmFsc2U7XHJcbiAgICAvLyB0cnkgdG8gcmVjb3ZlciBub3QgZmF0YWwgZXJyb3JzXHJcbiAgICBzd2l0Y2goZGV0YWlscykge1xyXG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5GUkFHX0xPQURfRVJST1I6XHJcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkZSQUdfTE9BRF9USU1FT1VUOlxyXG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5GUkFHX0xPT1BfTE9BRElOR19FUlJPUjpcclxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuS0VZX0xPQURfRVJST1I6XHJcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLktFWV9MT0FEX1RJTUVPVVQ6XHJcbiAgICAgICAgIGxldmVsSWQgPSBkYXRhLmZyYWcubGV2ZWw7XHJcbiAgICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5MRVZFTF9MT0FEX0VSUk9SOlxyXG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5MRVZFTF9MT0FEX1RJTUVPVVQ6XHJcbiAgICAgICAgbGV2ZWxJZCA9IGRhdGEuY29udGV4dC5sZXZlbDtcclxuICAgICAgICBsZXZlbEVycm9yID0gdHJ1ZTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuUkVNVVhfQUxMT0NfRVJST1I6XHJcbiAgICAgICAgbGV2ZWxJZCA9IGRhdGEubGV2ZWw7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgICAvKiB0cnkgdG8gc3dpdGNoIHRvIGEgcmVkdW5kYW50IHN0cmVhbSBpZiBhbnkgYXZhaWxhYmxlLlxyXG4gICAgICogaWYgbm8gcmVkdW5kYW50IHN0cmVhbSBhdmFpbGFibGUsIGVtZXJnZW5jeSBzd2l0Y2ggZG93biAoaWYgaW4gYXV0byBtb2RlIGFuZCBjdXJyZW50IGxldmVsIG5vdCAwKVxyXG4gICAgICogb3RoZXJ3aXNlLCB3ZSBjYW5ub3QgcmVjb3ZlciB0aGlzIG5ldHdvcmsgZXJyb3IgLi4uXHJcbiAgICAgKi9cclxuICAgIGlmIChsZXZlbElkICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgbGV2ZWwgPSB0aGlzLl9sZXZlbHNbbGV2ZWxJZF07XHJcbiAgICAgIGlmKCFsZXZlbC5sb2FkRXJyb3IpIHtcclxuICAgICAgICBsZXZlbC5sb2FkRXJyb3IgPSAxO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGxldmVsLmxvYWRFcnJvcisrO1xyXG4gICAgICB9XHJcbiAgICAgIC8vIGlmIGFueSByZWR1bmRhbnQgc3RyZWFtcyBhdmFpbGFibGUgYW5kIGlmIHdlIGhhdmVuJ3QgdHJ5IHRoZW0gYWxsIChsZXZlbC5sb2FkRXJyb3IgaXMgcmVzZXRlZCBvbiBzdWNjZXNzZnVsIGZyYWcvbGV2ZWwgbG9hZC5cclxuICAgICAgLy8gaWYgbGV2ZWwubG9hZEVycm9yIHJlYWNoZXMgbmJSZWR1bmRhbnRMZXZlbCBpdCBtZWFucyB0aGF0IHdlIHRyaWVkIHRoZW0gYWxsLCBubyBob3BlICA9PiBsZXQncyBzd2l0Y2ggZG93blxyXG4gICAgICBjb25zdCBuYlJlZHVuZGFudExldmVsID0gbGV2ZWwudXJsLmxlbmd0aDtcclxuICAgICBpZiAobmJSZWR1bmRhbnRMZXZlbCA+IDEgJiYgbGV2ZWwubG9hZEVycm9yIDwgbmJSZWR1bmRhbnRMZXZlbCkge1xyXG4gICAgICAgIGxldmVsLnVybElkID0gKGxldmVsLnVybElkICsgMSkgJSBuYlJlZHVuZGFudExldmVsO1xyXG4gICAgICAgIGxldmVsLmRldGFpbHMgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgbG9nZ2VyLndhcm4oYGxldmVsIGNvbnRyb2xsZXIsJHtkZXRhaWxzfSBmb3IgbGV2ZWwgJHtsZXZlbElkfTogc3dpdGNoaW5nIHRvIHJlZHVuZGFudCBzdHJlYW0gaWQgJHtsZXZlbC51cmxJZH1gKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyB3ZSBjb3VsZCB0cnkgdG8gcmVjb3ZlciBpZiBpbiBhdXRvIG1vZGUgYW5kIGN1cnJlbnQgbGV2ZWwgbm90IGxvd2VzdCBsZXZlbCAoMClcclxuICAgICAgICBsZXQgcmVjb3ZlcmFibGUgPSAoKHRoaXMuX21hbnVhbExldmVsID09PSAtMSkgJiYgbGV2ZWxJZCk7XHJcbiAgICAgICAgaWYgKHJlY292ZXJhYmxlKSB7XHJcbiAgICAgICAgICBsb2dnZXIud2FybihgbGV2ZWwgY29udHJvbGxlciwke2RldGFpbHN9OiBzd2l0Y2gtZG93biBmb3IgbmV4dCBmcmFnbWVudGApO1xyXG4gICAgICAgICAgaGxzLm5leHRBdXRvTGV2ZWwgPSBNYXRoLm1heCgwLGxldmVsSWQtMSk7XHJcbiAgICAgICAgfSBlbHNlIGlmKGxldmVsICYmIGxldmVsLmRldGFpbHMgJiYgbGV2ZWwuZGV0YWlscy5saXZlKSB7XHJcbiAgICAgICAgICBsb2dnZXIud2FybihgbGV2ZWwgY29udHJvbGxlciwke2RldGFpbHN9IG9uIGxpdmUgc3RyZWFtLCBkaXNjYXJkYCk7XHJcbiAgICAgICAgICBpZiAobGV2ZWxFcnJvcikge1xyXG4gICAgICAgICAgICAvLyByZXNldCB0aGlzLl9sZXZlbCBzbyB0aGF0IGFub3RoZXIgY2FsbCB0byBzZXQgbGV2ZWwoKSB3aWxsIHJldHJpZ2dlciBhIGZyYWcgbG9hZFxyXG4gICAgICAgICAgICB0aGlzLl9sZXZlbCA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIC8vIG90aGVyIGVycm9ycyBhcmUgaGFuZGxlZCBieSBzdHJlYW0gY29udHJvbGxlclxyXG4gICAgICAgIH0gZWxzZSBpZiAoZGV0YWlscyA9PT0gRXJyb3JEZXRhaWxzLkxFVkVMX0xPQURfRVJST1IgfHxcclxuICAgICAgICAgICAgICAgICAgIGRldGFpbHMgPT09IEVycm9yRGV0YWlscy5MRVZFTF9MT0FEX1RJTUVPVVQpIHtcclxuICAgICAgICAgIGxldCBtZWRpYSA9IGhscy5tZWRpYSxcclxuICAgICAgICAgICAgLy8gMC41IDogdG9sZXJhbmNlIG5lZWRlZCBhcyBzb21lIGJyb3dzZXJzIHN0YWxscyBwbGF5YmFjayBiZWZvcmUgcmVhY2hpbmcgYnVmZmVyZWQgZW5kXHJcbiAgICAgICAgICAgICAgbWVkaWFCdWZmZXJlZCA9IG1lZGlhICYmIEJ1ZmZlckhlbHBlci5pc0J1ZmZlcmVkKG1lZGlhLG1lZGlhLmN1cnJlbnRUaW1lKSAmJiBCdWZmZXJIZWxwZXIuaXNCdWZmZXJlZChtZWRpYSxtZWRpYS5jdXJyZW50VGltZSswLjUpO1xyXG4gICAgICAgICAgaWYgKG1lZGlhQnVmZmVyZWQpIHtcclxuICAgICAgICAgICAgbGV0IHJldHJ5RGVsYXkgPSBobHMuY29uZmlnLmxldmVsTG9hZGluZ1JldHJ5RGVsYXk7XHJcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKGBsZXZlbCBjb250cm9sbGVyLCR7ZGV0YWlsc30sIGJ1dCBtZWRpYSBidWZmZXJlZCwgcmV0cnkgaW4gJHtyZXRyeURlbGF5fW1zYCk7XHJcbiAgICAgICAgICAgIHRoaXMudGltZXIgPSBzZXRUaW1lb3V0KHRoaXMub250aWNrLHJldHJ5RGVsYXkpO1xyXG4gICAgICAgICAgICAvLyBib29sZWFuIHVzZWQgdG8gaW5mb3JtIHN0cmVhbSBjb250cm9sbGVyIG5vdCB0byBzd2l0Y2ggYmFjayB0byBJRExFIG9uIG5vbiBmYXRhbCBlcnJvclxyXG4gICAgICAgICAgICBkYXRhLmxldmVsUmV0cnkgPSB0cnVlO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGBjYW5ub3QgcmVjb3ZlciAke2RldGFpbHN9IGVycm9yYCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2xldmVsID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAvLyBzdG9wcGluZyBsaXZlIHJlbG9hZGluZyB0aW1lciBpZiBhbnlcclxuICAgICAgICAgICAgaWYgKHRoaXMudGltZXIpIHtcclxuICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lcik7XHJcbiAgICAgICAgICAgICAgdGhpcy50aW1lciA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gc3dpdGNoIGVycm9yIHRvIGZhdGFsXHJcbiAgICAgICAgICAgIGRhdGEuZmF0YWwgPSB0cnVlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gcmVzZXQgbGV2ZWwgbG9hZCBlcnJvciBjb3VudGVyIG9uIHN1Y2Nlc3NmdWwgZnJhZyBsb2FkZWRcclxuICBvbkZyYWdMb2FkZWQoZGF0YSkge1xyXG4gICAgY29uc3QgZnJhZ0xvYWRlZCA9IGRhdGEuZnJhZztcclxuICAgIGlmIChmcmFnTG9hZGVkICYmIGZyYWdMb2FkZWQudHlwZSA9PT0gJ21haW4nKSB7XHJcbiAgICAgIGNvbnN0IGxldmVsID0gdGhpcy5fbGV2ZWxzW2ZyYWdMb2FkZWQubGV2ZWxdO1xyXG4gICAgICBpZiAobGV2ZWwpIHtcclxuICAgICAgICBsZXZlbC5sb2FkRXJyb3IgPSAwO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBvbkxldmVsTG9hZGVkKGRhdGEpIHtcclxuICAgIGNvbnN0IGxldmVsSWQgPSBkYXRhLmxldmVsO1xyXG4gICAgIC8vIG9ubHkgcHJvY2VzcyBsZXZlbCBsb2FkZWQgZXZlbnRzIG1hdGNoaW5nIHdpdGggZXhwZWN0ZWQgbGV2ZWxcclxuICAgIGlmIChsZXZlbElkID09PSB0aGlzLl9sZXZlbCkge1xyXG4gICAgICBsZXQgY3VyTGV2ZWwgPSB0aGlzLl9sZXZlbHNbbGV2ZWxJZF07XHJcbiAgICAgIC8vIHJlc2V0IGxldmVsIGxvYWQgZXJyb3IgY291bnRlciBvbiBzdWNjZXNzZnVsIGxldmVsIGxvYWRlZFxyXG4gICAgICBjdXJMZXZlbC5sb2FkRXJyb3IgPSAwO1xyXG4gICAgICBsZXQgbmV3RGV0YWlscyA9IGRhdGEuZGV0YWlscztcclxuICAgICAgLy8gaWYgY3VycmVudCBwbGF5bGlzdCBpcyBhIGxpdmUgcGxheWxpc3QsIGFybSBhIHRpbWVyIHRvIHJlbG9hZCBpdFxyXG4gICAgICBpZiAobmV3RGV0YWlscy5saXZlKSB7XHJcbiAgICAgICAgbGV0IHJlbG9hZEludGVydmFsID0gMTAwMCooIG5ld0RldGFpbHMuYXZlcmFnZXRhcmdldGR1cmF0aW9uID8gbmV3RGV0YWlscy5hdmVyYWdldGFyZ2V0ZHVyYXRpb24gOiBuZXdEZXRhaWxzLnRhcmdldGR1cmF0aW9uKSxcclxuICAgICAgICAgICAgY3VyRGV0YWlscyA9IGN1ckxldmVsLmRldGFpbHM7XHJcbiAgICAgICAgaWYgKGN1ckRldGFpbHMgJiYgbmV3RGV0YWlscy5lbmRTTiA9PT0gY3VyRGV0YWlscy5lbmRTTikge1xyXG4gICAgICAgICAgLy8gZm9sbG93IEhMUyBTcGVjLCBJZiB0aGUgY2xpZW50IHJlbG9hZHMgYSBQbGF5bGlzdCBmaWxlIGFuZCBmaW5kcyB0aGF0IGl0IGhhcyBub3RcclxuICAgICAgICAgIC8vIGNoYW5nZWQgdGhlbiBpdCBNVVNUIHdhaXQgZm9yIGEgcGVyaW9kIG9mIG9uZS1oYWxmIHRoZSB0YXJnZXRcclxuICAgICAgICAgIC8vIGR1cmF0aW9uIGJlZm9yZSByZXRyeWluZy5cclxuICAgICAgICAgIHJlbG9hZEludGVydmFsIC89MjtcclxuICAgICAgICAgIGxvZ2dlci5sb2coYHNhbWUgbGl2ZSBwbGF5bGlzdCwgcmVsb2FkIHR3aWNlIGZhc3RlcmApO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBkZWNyZW1lbnQgcmVsb2FkSW50ZXJ2YWwgd2l0aCBsZXZlbCBsb2FkaW5nIGRlbGF5XHJcbiAgICAgICAgcmVsb2FkSW50ZXJ2YWwgLT0gcGVyZm9ybWFuY2Uubm93KCkgLSBkYXRhLnN0YXRzLnRyZXF1ZXN0O1xyXG4gICAgICAgIC8vIGluIGFueSBjYXNlLCBkb24ndCByZWxvYWQgbW9yZSB0aGFuIGV2ZXJ5IHNlY29uZFxyXG4gICAgICAgIHJlbG9hZEludGVydmFsID0gTWF0aC5tYXgoMTAwMCxNYXRoLnJvdW5kKHJlbG9hZEludGVydmFsKSk7XHJcbiAgICAgICAgbG9nZ2VyLmxvZyhgbGl2ZSBwbGF5bGlzdCwgcmVsb2FkIGluICR7cmVsb2FkSW50ZXJ2YWx9IG1zYCk7XHJcbiAgICAgICAgdGhpcy50aW1lciA9IHNldFRpbWVvdXQodGhpcy5vbnRpY2sscmVsb2FkSW50ZXJ2YWwpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMudGltZXIgPSBudWxsO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICB0aWNrKCkge1xyXG4gICAgdmFyIGxldmVsSWQgPSB0aGlzLl9sZXZlbDtcclxuICAgIGlmIChsZXZlbElkICE9PSB1bmRlZmluZWQgJiYgdGhpcy5jYW5sb2FkKSB7XHJcbiAgICAgIHZhciBsZXZlbCA9IHRoaXMuX2xldmVsc1tsZXZlbElkXTtcclxuICAgICAgaWYgKGxldmVsICYmIGxldmVsLnVybCkge1xyXG4gICAgICAgIHZhciB1cmxJZCA9IGxldmVsLnVybElkO1xyXG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuTEVWRUxfTE9BRElORywge3VybDogbGV2ZWwudXJsW3VybElkXSwgbGV2ZWw6IGxldmVsSWQsIGlkOiB1cmxJZH0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBnZXQgbmV4dExvYWRMZXZlbCgpIHtcclxuICAgIGlmICh0aGlzLl9tYW51YWxMZXZlbCAhPT0gLTEpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuX21hbnVhbExldmVsO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICByZXR1cm4gdGhpcy5obHMubmV4dEF1dG9MZXZlbDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHNldCBuZXh0TG9hZExldmVsKG5leHRMZXZlbCkge1xyXG4gICAgdGhpcy5sZXZlbCA9IG5leHRMZXZlbDtcclxuICAgIGlmICh0aGlzLl9tYW51YWxMZXZlbCA9PT0gLTEpIHtcclxuICAgICAgdGhpcy5obHMubmV4dEF1dG9MZXZlbCA9IG5leHRMZXZlbDtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IExldmVsQ29udHJvbGxlcjtcclxuXHJcbiIsIi8qXHJcbiAqIFN0cmVhbSBDb250cm9sbGVyXHJcbiovXHJcblxyXG5pbXBvcnQgQmluYXJ5U2VhcmNoIGZyb20gJy4uL3V0aWxzL2JpbmFyeS1zZWFyY2gnO1xyXG5pbXBvcnQgQnVmZmVySGVscGVyIGZyb20gJy4uL2hlbHBlci9idWZmZXItaGVscGVyJztcclxuaW1wb3J0IERlbXV4ZXIgZnJvbSAnLi4vZGVtdXgvZGVtdXhlcic7XHJcbmltcG9ydCBFdmVudCBmcm9tICcuLi9ldmVudHMnO1xyXG5pbXBvcnQgRXZlbnRIYW5kbGVyIGZyb20gJy4uL2V2ZW50LWhhbmRsZXInO1xyXG5pbXBvcnQgTGV2ZWxIZWxwZXIgZnJvbSAnLi4vaGVscGVyL2xldmVsLWhlbHBlcic7XHJcbmltcG9ydCBUaW1lUmFuZ2VzIGZyb20gJy4uL3V0aWxzL3RpbWVSYW5nZXMnO1xyXG5pbXBvcnQge0Vycm9yVHlwZXMsIEVycm9yRGV0YWlsc30gZnJvbSAnLi4vZXJyb3JzJztcclxuaW1wb3J0IHtsb2dnZXJ9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XHJcblxyXG5jb25zdCBTdGF0ZSA9IHtcclxuICBTVE9QUEVEIDogJ1NUT1BQRUQnLFxyXG4gIElETEUgOiAnSURMRScsXHJcbiAgS0VZX0xPQURJTkcgOiAnS0VZX0xPQURJTkcnLFxyXG4gIEZSQUdfTE9BRElORyA6ICdGUkFHX0xPQURJTkcnLFxyXG4gIEZSQUdfTE9BRElOR19XQUlUSU5HX1JFVFJZIDogJ0ZSQUdfTE9BRElOR19XQUlUSU5HX1JFVFJZJyxcclxuICBXQUlUSU5HX0xFVkVMIDogJ1dBSVRJTkdfTEVWRUwnLFxyXG4gIFBBUlNJTkcgOiAnUEFSU0lORycsXHJcbiAgUEFSU0VEIDogJ1BBUlNFRCcsXHJcbiAgQlVGRkVSX0ZMVVNISU5HIDogJ0JVRkZFUl9GTFVTSElORycsXHJcbiAgRU5ERUQgOiAnRU5ERUQnLFxyXG4gIEVSUk9SIDogJ0VSUk9SJ1xyXG59O1xyXG5cclxuY2xhc3MgU3RyZWFtQ29udHJvbGxlciBleHRlbmRzIEV2ZW50SGFuZGxlciB7XHJcblxyXG4gIGNvbnN0cnVjdG9yKGhscykge1xyXG4gICAgc3VwZXIoaGxzLFxyXG4gICAgICBFdmVudC5NRURJQV9BVFRBQ0hFRCxcclxuICAgICAgRXZlbnQuTUVESUFfREVUQUNISU5HLFxyXG4gICAgICBFdmVudC5NQU5JRkVTVF9MT0FESU5HLFxyXG4gICAgICBFdmVudC5NQU5JRkVTVF9QQVJTRUQsXHJcbiAgICAgIEV2ZW50LkxFVkVMX0xPQURFRCxcclxuICAgICAgRXZlbnQuS0VZX0xPQURFRCxcclxuICAgICAgRXZlbnQuRlJBR19MT0FERUQsXHJcbiAgICAgIEV2ZW50LkZSQUdfTE9BRF9FTUVSR0VOQ1lfQUJPUlRFRCxcclxuICAgICAgRXZlbnQuRlJBR19QQVJTSU5HX0lOSVRfU0VHTUVOVCxcclxuICAgICAgRXZlbnQuRlJBR19QQVJTSU5HX0RBVEEsXHJcbiAgICAgIEV2ZW50LkZSQUdfUEFSU0VELFxyXG4gICAgICBFdmVudC5FUlJPUixcclxuICAgICAgRXZlbnQuQVVESU9fVFJBQ0tfU1dJVENISU5HLFxyXG4gICAgICBFdmVudC5BVURJT19UUkFDS19TV0lUQ0hFRCxcclxuICAgICAgRXZlbnQuQlVGRkVSX0NSRUFURUQsXHJcbiAgICAgIEV2ZW50LkJVRkZFUl9BUFBFTkRFRCxcclxuICAgICAgRXZlbnQuQlVGRkVSX0ZMVVNIRUQpO1xyXG5cclxuICAgIHRoaXMuY29uZmlnID0gaGxzLmNvbmZpZztcclxuICAgIHRoaXMuYXVkaW9Db2RlY1N3YXAgPSBmYWxzZTtcclxuICAgIHRoaXMudGlja3MgPSAwO1xyXG4gICAgdGhpcy5fc3RhdGUgPSBTdGF0ZS5TVE9QUEVEO1xyXG4gICAgdGhpcy5vbnRpY2sgPSB0aGlzLnRpY2suYmluZCh0aGlzKTtcclxuICB9XHJcblxyXG4gIGRlc3Ryb3koKSB7XHJcbiAgICB0aGlzLnN0b3BMb2FkKCk7XHJcbiAgICBpZiAodGhpcy50aW1lcikge1xyXG4gICAgICBjbGVhckludGVydmFsKHRoaXMudGltZXIpO1xyXG4gICAgICB0aGlzLnRpbWVyID0gbnVsbDtcclxuICAgIH1cclxuICAgIEV2ZW50SGFuZGxlci5wcm90b3R5cGUuZGVzdHJveS5jYWxsKHRoaXMpO1xyXG4gICAgdGhpcy5zdGF0ZSA9IFN0YXRlLlNUT1BQRUQ7XHJcbiAgfVxyXG5cclxuICBzdGFydExvYWQoc3RhcnRQb3NpdGlvbikge1xyXG4gICAgaWYgKHRoaXMubGV2ZWxzKSB7XHJcbiAgICAgIGxldCBsYXN0Q3VycmVudFRpbWUgPSB0aGlzLmxhc3RDdXJyZW50VGltZSwgaGxzID0gdGhpcy5obHM7XHJcbiAgICAgIHRoaXMuc3RvcExvYWQoKTtcclxuICAgICAgaWYgKCF0aGlzLnRpbWVyKSB7XHJcbiAgICAgICAgdGhpcy50aW1lciA9IHNldEludGVydmFsKHRoaXMub250aWNrLCAxMDApO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMubGV2ZWwgPSAtMTtcclxuICAgICAgdGhpcy5mcmFnTG9hZEVycm9yID0gMDtcclxuICAgICAgaWYgKCF0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCkge1xyXG4gICAgICAgIC8vIGRldGVybWluZSBsb2FkIGxldmVsXHJcbiAgICAgICAgbGV0IHN0YXJ0TGV2ZWwgPSBobHMuc3RhcnRMZXZlbDtcclxuICAgICAgICBpZiAoc3RhcnRMZXZlbCA9PT0gLTEpIHtcclxuICAgICAgICAgIC8vIC0xIDogZ3Vlc3Mgc3RhcnQgTGV2ZWwgYnkgZG9pbmcgYSBiaXRyYXRlIHRlc3QgYnkgbG9hZGluZyBmaXJzdCBmcmFnbWVudCBvZiBsb3dlc3QgcXVhbGl0eSBsZXZlbFxyXG4gICAgICAgICAgc3RhcnRMZXZlbCA9IDA7XHJcbiAgICAgICAgICB0aGlzLmJpdHJhdGVUZXN0ID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gc2V0IG5ldyBsZXZlbCB0byBwbGF5bGlzdCBsb2FkZXIgOiB0aGlzIHdpbGwgdHJpZ2dlciBzdGFydCBsZXZlbCBsb2FkXHJcbiAgICAgICAgLy8gaGxzLm5leHRMb2FkTGV2ZWwgcmVtYWlucyB1bnRpbCBpdCBpcyBzZXQgdG8gYSBuZXcgdmFsdWUgb3IgdW50aWwgYSBuZXcgZnJhZyBpcyBzdWNjZXNzZnVsbHkgbG9hZGVkXHJcbiAgICAgICAgdGhpcy5sZXZlbCA9IGhscy5uZXh0TG9hZExldmVsID0gc3RhcnRMZXZlbDtcclxuICAgICAgICB0aGlzLmxvYWRlZG1ldGFkYXRhID0gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgICAgLy8gaWYgc3RhcnRQb3NpdGlvbiB1bmRlZmluZWQgYnV0IGxhc3RDdXJyZW50VGltZSBzZXQsIHNldCBzdGFydFBvc2l0aW9uIHRvIGxhc3QgY3VycmVudFRpbWVcclxuICAgICAgaWYgKGxhc3RDdXJyZW50VGltZSA+IDAgJiYgc3RhcnRQb3NpdGlvbiA9PT0gLTEpIHtcclxuICAgICAgICBsb2dnZXIubG9nKGBvdmVycmlkZSBzdGFydFBvc2l0aW9uIHdpdGggbGFzdEN1cnJlbnRUaW1lIEAke2xhc3RDdXJyZW50VGltZS50b0ZpeGVkKDMpfWApO1xyXG4gICAgICAgIHN0YXJ0UG9zaXRpb24gPSBsYXN0Q3VycmVudFRpbWU7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XHJcbiAgICAgIHRoaXMubmV4dExvYWRQb3NpdGlvbiA9IHRoaXMuc3RhcnRQb3NpdGlvbiA9IHRoaXMubGFzdEN1cnJlbnRUaW1lID0gc3RhcnRQb3NpdGlvbjtcclxuICAgICAgdGhpcy50aWNrKCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLmZvcmNlU3RhcnRMb2FkID0gdHJ1ZTtcclxuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLlNUT1BQRUQ7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBzdG9wTG9hZCgpIHtcclxuICAgIHZhciBmcmFnID0gdGhpcy5mcmFnQ3VycmVudDtcclxuICAgIGlmIChmcmFnKSB7XHJcbiAgICAgIGlmIChmcmFnLmxvYWRlcikge1xyXG4gICAgICAgIGZyYWcubG9hZGVyLmFib3J0KCk7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5mcmFnQ3VycmVudCA9IG51bGw7XHJcbiAgICB9XHJcbiAgICB0aGlzLmZyYWdQcmV2aW91cyA9IG51bGw7XHJcbiAgICBpZiAodGhpcy5kZW11eGVyKSB7XHJcbiAgICAgIHRoaXMuZGVtdXhlci5kZXN0cm95KCk7XHJcbiAgICAgIHRoaXMuZGVtdXhlciA9IG51bGw7XHJcbiAgICB9XHJcbiAgICB0aGlzLnN0YXRlID0gU3RhdGUuU1RPUFBFRDtcclxuICAgIHRoaXMuZm9yY2VTdGFydExvYWQgPSBmYWxzZTtcclxuICB9XHJcblxyXG4gIHRpY2soKSB7XHJcbiAgICB0aGlzLnRpY2tzKys7XHJcbiAgICBpZiAodGhpcy50aWNrcyA9PT0gMSkge1xyXG4gICAgICB0aGlzLmRvVGljaygpO1xyXG4gICAgICBpZiAodGhpcy50aWNrcyA+IDEpIHtcclxuICAgICAgICBzZXRUaW1lb3V0KHRoaXMudGljaywgMSk7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy50aWNrcyA9IDA7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBkb1RpY2soKSB7XHJcbiAgICBzd2l0Y2godGhpcy5zdGF0ZSkge1xyXG4gICAgICBjYXNlIFN0YXRlLkVSUk9SOlxyXG4gICAgICAgIC8vZG9uJ3QgZG8gYW55dGhpbmcgaW4gZXJyb3Igc3RhdGUgdG8gYXZvaWQgYnJlYWtpbmcgZnVydGhlciAuLi5cclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSBTdGF0ZS5CVUZGRVJfRkxVU0hJTkc6XHJcbiAgICAgIC8vIGluIGJ1ZmZlciBmbHVzaGluZyBzdGF0ZSwgcmVzZXQgZnJhZ0xvYWRFcnJvciBjb3VudGVyXHJcbiAgICAgICAgdGhpcy5mcmFnTG9hZEVycm9yID0gMDtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSBTdGF0ZS5JRExFOlxyXG4gICAgICAgIHRoaXMuX2RvVGlja0lkbGUoKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSBTdGF0ZS5XQUlUSU5HX0xFVkVMOlxyXG4gICAgICAgIHZhciBsZXZlbCA9IHRoaXMubGV2ZWxzW3RoaXMubGV2ZWxdO1xyXG4gICAgICAgIC8vIGNoZWNrIGlmIHBsYXlsaXN0IGlzIGFscmVhZHkgbG9hZGVkXHJcbiAgICAgICAgaWYgKGxldmVsICYmIGxldmVsLmRldGFpbHMpIHtcclxuICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xyXG4gICAgICAgIH1cclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSBTdGF0ZS5GUkFHX0xPQURJTkdfV0FJVElOR19SRVRSWTpcclxuICAgICAgICB2YXIgbm93ID0gcGVyZm9ybWFuY2Uubm93KCk7XHJcbiAgICAgICAgdmFyIHJldHJ5RGF0ZSA9IHRoaXMucmV0cnlEYXRlO1xyXG4gICAgICAgIC8vIGlmIGN1cnJlbnQgdGltZSBpcyBndCB0aGFuIHJldHJ5RGF0ZSwgb3IgaWYgbWVkaWEgc2Vla2luZyBsZXQncyBzd2l0Y2ggdG8gSURMRSBzdGF0ZSB0byByZXRyeSBsb2FkaW5nXHJcbiAgICAgICAgaWYoIXJldHJ5RGF0ZSB8fCAobm93ID49IHJldHJ5RGF0ZSkgfHwgKHRoaXMubWVkaWEgJiYgdGhpcy5tZWRpYS5zZWVraW5nKSkge1xyXG4gICAgICAgICAgbG9nZ2VyLmxvZyhgbWVkaWFDb250cm9sbGVyOiByZXRyeURhdGUgcmVhY2hlZCwgc3dpdGNoIGJhY2sgdG8gSURMRSBzdGF0ZWApO1xyXG4gICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIFN0YXRlLkVSUk9SOlxyXG4gICAgICBjYXNlIFN0YXRlLlNUT1BQRUQ6XHJcbiAgICAgIGNhc2UgU3RhdGUuRlJBR19MT0FESU5HOlxyXG4gICAgICBjYXNlIFN0YXRlLlBBUlNJTkc6XHJcbiAgICAgIGNhc2UgU3RhdGUuUEFSU0VEOlxyXG4gICAgICBjYXNlIFN0YXRlLkVOREVEOlxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBkZWZhdWx0OlxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gICAgLy8gY2hlY2sgYnVmZmVyXHJcbiAgICB0aGlzLl9jaGVja0J1ZmZlcigpO1xyXG4gICAgLy8gY2hlY2svdXBkYXRlIGN1cnJlbnQgZnJhZ21lbnRcclxuICAgIHRoaXMuX2NoZWNrRnJhZ21lbnRDaGFuZ2VkKCk7XHJcbiAgfVxyXG5cclxuICAvLyBJcm9uaWNhbGx5IHRoZSBcImlkbGVcIiBzdGF0ZSBpcyB0aGUgb24gd2UgZG8gdGhlIG1vc3QgbG9naWMgaW4gaXQgc2VlbXMgLi4uLlxyXG4gIC8vIE5PVEU6IE1heWJlIHdlIGNvdWxkIHJhdGhlciBzY2hlZHVsZSBhIGNoZWNrIGZvciBidWZmZXIgbGVuZ3RoIGFmdGVyIGhhbGYgb2YgdGhlIGN1cnJlbnRseVxyXG4gIC8vICAgICAgIHBsYXllZCBzZWdtZW50LCBvciBvbiBwYXVzZS9wbGF5L3NlZWsgaW5zdGVhZCBvZiBuYWl2ZWx5IGNoZWNraW5nIGV2ZXJ5IDEwMG1zP1xyXG4gIF9kb1RpY2tJZGxlKCkge1xyXG4gICAgY29uc3QgaGxzID0gdGhpcy5obHMsXHJcbiAgICAgICAgICBjb25maWcgPSBobHMuY29uZmlnLFxyXG4gICAgICAgICAgbWVkaWEgPSB0aGlzLm1lZGlhO1xyXG5cclxuICAgIC8vIGlmIHZpZGVvIG5vdCBhdHRhY2hlZCBBTkRcclxuICAgIC8vIHN0YXJ0IGZyYWdtZW50IGFscmVhZHkgcmVxdWVzdGVkIE9SIHN0YXJ0IGZyYWcgcHJlZmV0Y2ggZGlzYWJsZVxyXG4gICAgLy8gZXhpdCBsb29wXHJcbiAgICAvLyA9PiBpZiBzdGFydCBsZXZlbCBsb2FkZWQgYW5kIG1lZGlhIG5vdCBhdHRhY2hlZCBidXQgc3RhcnQgZnJhZyBwcmVmZXRjaCBpcyBlbmFibGVkIGFuZCBzdGFydCBmcmFnIG5vdCByZXF1ZXN0ZWQgeWV0LCB3ZSB3aWxsIG5vdCBleGl0IGxvb3BcclxuICAgIGlmICh0aGlzLmxldmVsTGFzdExvYWRlZCAhPT0gdW5kZWZpbmVkICYmICFtZWRpYSAmJlxyXG4gICAgICAodGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgfHwgIWNvbmZpZy5zdGFydEZyYWdQcmVmZXRjaCkpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGlmIHdlIGhhdmUgbm90IHlldCBsb2FkZWQgYW55IGZyYWdtZW50LCBzdGFydCBsb2FkaW5nIGZyb20gc3RhcnQgcG9zaXRpb25cclxuICAgIGxldCBwb3M7XHJcbiAgICBpZiAodGhpcy5sb2FkZWRtZXRhZGF0YSkge1xyXG4gICAgICBwb3MgPSBtZWRpYS5jdXJyZW50VGltZTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHBvcyA9IHRoaXMubmV4dExvYWRQb3NpdGlvbjtcclxuICAgIH1cclxuICAgIC8vIGRldGVybWluZSBuZXh0IGxvYWQgbGV2ZWxcclxuICAgIGxldCBsZXZlbCA9IGhscy5uZXh0TG9hZExldmVsLFxyXG4gICAgICAgIGxldmVsSW5mbyA9IHRoaXMubGV2ZWxzW2xldmVsXTtcclxuXHJcbiAgICBpZiAoIWxldmVsSW5mbykge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IGxldmVsQml0cmF0ZSA9IGxldmVsSW5mby5iaXRyYXRlLFxyXG4gICAgICAgIG1heEJ1ZkxlbjtcclxuXHJcbiAgICAvLyBjb21wdXRlIG1heCBCdWZmZXIgTGVuZ3RoIHRoYXQgd2UgY291bGQgZ2V0IGZyb20gdGhpcyBsb2FkIGxldmVsLCBiYXNlZCBvbiBsZXZlbCBiaXRyYXRlLiBkb24ndCBidWZmZXIgbW9yZSB0aGFuIDYwIE1CIGFuZCBtb3JlIHRoYW4gMzBzXHJcbiAgICBpZiAobGV2ZWxCaXRyYXRlKSB7XHJcbiAgICAgIG1heEJ1ZkxlbiA9IE1hdGgubWF4KDggKiBjb25maWcubWF4QnVmZmVyU2l6ZSAvIGxldmVsQml0cmF0ZSwgY29uZmlnLm1heEJ1ZmZlckxlbmd0aCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBtYXhCdWZMZW4gPSBjb25maWcubWF4QnVmZmVyTGVuZ3RoO1xyXG4gICAgfVxyXG4gICAgbWF4QnVmTGVuID0gTWF0aC5taW4obWF4QnVmTGVuLCBjb25maWcubWF4TWF4QnVmZmVyTGVuZ3RoKTtcclxuXHJcbiAgICAvLyBkZXRlcm1pbmUgbmV4dCBjYW5kaWRhdGUgZnJhZ21lbnQgdG8gYmUgbG9hZGVkLCBiYXNlZCBvbiBjdXJyZW50IHBvc2l0aW9uIGFuZCBlbmQgb2YgYnVmZmVyIHBvc2l0aW9uXHJcbiAgICAvLyBlbnN1cmUgdXAgdG8gYGNvbmZpZy5tYXhNYXhCdWZmZXJMZW5ndGhgIG9mIGJ1ZmZlciB1cGZyb250XHJcblxyXG4gICAgY29uc3QgYnVmZmVySW5mbyA9IEJ1ZmZlckhlbHBlci5idWZmZXJJbmZvKHRoaXMubWVkaWFCdWZmZXIgPyB0aGlzLm1lZGlhQnVmZmVyIDogbWVkaWEsIHBvcywgY29uZmlnLm1heEJ1ZmZlckhvbGUpLFxyXG4gICAgICAgICAgYnVmZmVyTGVuID0gYnVmZmVySW5mby5sZW47XHJcbiAgICAvLyBTdGF5IGlkbGUgaWYgd2UgYXJlIHN0aWxsIHdpdGggYnVmZmVyIG1hcmdpbnNcclxuICAgIGlmIChidWZmZXJMZW4gPj0gbWF4QnVmTGVuKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBpZiBidWZmZXIgbGVuZ3RoIGlzIGxlc3MgdGhhbiBtYXhCdWZMZW4gdHJ5IHRvIGxvYWQgYSBuZXcgZnJhZ21lbnQgLi4uXHJcbiAgICBsb2dnZXIudHJhY2UoYGJ1ZmZlciBsZW5ndGggb2YgJHtidWZmZXJMZW4udG9GaXhlZCgzKX0gaXMgYmVsb3cgbWF4IG9mICR7bWF4QnVmTGVuLnRvRml4ZWQoMyl9LiBjaGVja2luZyBmb3IgbW9yZSBwYXlsb2FkIC4uLmApO1xyXG5cclxuICAgIC8vIHNldCBuZXh0IGxvYWQgbGV2ZWwgOiB0aGlzIHdpbGwgdHJpZ2dlciBhIHBsYXlsaXN0IGxvYWQgaWYgbmVlZGVkXHJcbiAgICB0aGlzLmxldmVsID0gaGxzLm5leHRMb2FkTGV2ZWwgPSBsZXZlbDtcclxuXHJcbiAgICBjb25zdCBsZXZlbERldGFpbHMgPSBsZXZlbEluZm8uZGV0YWlscztcclxuICAgIC8vIGlmIGxldmVsIGluZm8gbm90IHJldHJpZXZlZCB5ZXQsIHN3aXRjaCBzdGF0ZSBhbmQgd2FpdCBmb3IgbGV2ZWwgcmV0cmlldmFsXHJcbiAgICAvLyBpZiBsaXZlIHBsYXlsaXN0LCBlbnN1cmUgdGhhdCBuZXcgcGxheWxpc3QgaGFzIGJlZW4gcmVmcmVzaGVkIHRvIGF2b2lkIGxvYWRpbmcvdHJ5IHRvIGxvYWRcclxuICAgIC8vIGEgdXNlbGVzcyBhbmQgb3V0ZGF0ZWQgZnJhZ21lbnQgKHRoYXQgbWlnaHQgZXZlbiBpbnRyb2R1Y2UgbG9hZCBlcnJvciBpZiBpdCBpcyBhbHJlYWR5IG91dCBvZiB0aGUgbGl2ZSBwbGF5bGlzdClcclxuICAgIGlmICh0eXBlb2YgbGV2ZWxEZXRhaWxzID09PSAndW5kZWZpbmVkJyB8fCBsZXZlbERldGFpbHMubGl2ZSAmJiB0aGlzLmxldmVsTGFzdExvYWRlZCAhPT0gbGV2ZWwpIHtcclxuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLldBSVRJTkdfTEVWRUw7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICAvLyB3ZSBqdXN0IGdvdCBkb25lIGxvYWRpbmcgdGhlIGZpbmFsIGZyYWdtZW50LCBhbmQgY3VycmVudFBvcyBpcyBidWZmZXJlZCwgYW5kIHRoZXJlIGlzIG5vIG90aGVyIGJ1ZmZlcmVkIHJhbmdlIGFmdGVyIC4uLlxyXG4gICAgLy8gcmF0aW9uYWxlIGlzIHRoYXQgaW4gY2FzZSB0aGVyZSBhcmUgYW55IGJ1ZmZlcmVkIHJhbmdlc2FmdGVyLCBpdCBtZWFucyB0aGF0IHRoZXJlIGFyZSB1bmJ1ZmZlcmVkIHBvcnRpb24gaW4gYmV0d2VlblxyXG4gICAgLy8gc28gd2Ugc2hvdWxkIG5vdCBzd2l0Y2ggdG8gRU5ERUQgaW4gdGhhdCBjYXNlLCB0byBiZSBhYmxlIHRvIGJ1ZmZlciB0aGVteFxyXG4gICAgbGV0IGZyYWdQcmV2aW91cyA9IHRoaXMuZnJhZ1ByZXZpb3VzO1xyXG4gICAgaWYgKCFsZXZlbERldGFpbHMubGl2ZSAmJiBmcmFnUHJldmlvdXMgJiYgZnJhZ1ByZXZpb3VzLnNuID09PSBsZXZlbERldGFpbHMuZW5kU04gJiYgYnVmZmVyTGVuICYmICFidWZmZXJJbmZvLm5leHRTdGFydCkge1xyXG4gICAgICAgIC8vIGZyYWdQcmV2aW91cyBpcyBsYXN0IGZyYWdtZW50LiByZXRyaWV2ZSBsZXZlbCBkdXJhdGlvbiB1c2luZyBsYXN0IGZyYWcgc3RhcnQgb2Zmc2V0ICsgZHVyYXRpb25cclxuICAgICAgICAvLyByZWFsIGR1cmF0aW9uIG1pZ2h0IGJlIGxvd2VyIHRoYW4gaW5pdGlhbCBkdXJhdGlvbiBpZiB0aGVyZSBhcmUgZHJpZnRzIGJldHdlZW4gcmVhbCBmcmFnIGR1cmF0aW9uIGFuZCBwbGF5bGlzdCBzaWduYWxpbmdcclxuICAgICAgICBjb25zdCBkdXJhdGlvbiA9IE1hdGgubWluKG1lZGlhLmR1cmF0aW9uLGZyYWdQcmV2aW91cy5zdGFydCArIGZyYWdQcmV2aW91cy5kdXJhdGlvbik7XHJcbiAgICAgICAgLy8gaWYgZXZlcnl0aGluZyAoYWxtb3N0KSB0aWwgdGhlIGVuZCBpcyBidWZmZXJlZCwgbGV0J3Mgc2lnbmFsIGVvc1xyXG4gICAgICAgIC8vIHdlIGRvbid0IGNvbXBhcmUgZXhhY3RseSBtZWRpYS5kdXJhdGlvbiA9PT0gYnVmZmVySW5mby5lbmQgYXMgdGhlcmUgY291bGQgYmUgc29tZSBzdWJ0bGUgbWVkaWEgZHVyYXRpb24gZGlmZmVyZW5jZSAoYXVkaW8vdmlkZW8gb2Zmc2V0cy4uLilcclxuICAgICAgICAvLyB0b2xlcmF0ZSB1cCB0byBvbmUgZnJhZyBkdXJhdGlvbiB0byBjb3BlIHdpdGggdGhlc2UgY2FzZXMuXHJcbiAgICAgICAgLy8gYWxzbyBjb3BlIHdpdGggYWxtb3N0IHplcm8gbGFzdCBmcmFnIGR1cmF0aW9uIChtYXggbGFzdCBmcmFnIGR1cmF0aW9uIHdpdGggMjAwbXMpIHJlZmVyIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS92aWRlby1kZXYvaGxzLmpzL3B1bGwvNjU3XHJcbiAgICAgICAgaWYgKGR1cmF0aW9uIC0gTWF0aC5tYXgoYnVmZmVySW5mby5lbmQsZnJhZ1ByZXZpb3VzLnN0YXJ0KSA8PSBNYXRoLm1heCgwLjIsZnJhZ1ByZXZpb3VzLmR1cmF0aW9uKSkge1xyXG4gICAgICAgICAgLy8gRmluYWxpemUgdGhlIG1lZGlhIHN0cmVhbVxyXG4gICAgICAgICAgbGV0IGRhdGEgPSB7fTtcclxuICAgICAgICAgIGlmICh0aGlzLmFsdEF1ZGlvKSB7XHJcbiAgICAgICAgICAgIGRhdGEudHlwZSA9ICd2aWRlbyc7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkJVRkZFUl9FT1MsZGF0YSk7XHJcbiAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuRU5ERUQ7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBpZiB3ZSBoYXZlIHRoZSBsZXZlbERldGFpbHMgZm9yIHRoZSBzZWxlY3RlZCB2YXJpYW50LCBsZXRzIGNvbnRpbnVlIGVucmljaGVuIG91ciBzdHJlYW0gKGxvYWQga2V5cy9mcmFnbWVudHMgb3IgdHJpZ2dlciBFT1MsIGV0Yy4uKVxyXG4gICAgdGhpcy5fZmV0Y2hQYXlsb2FkT3JFb3MocG9zLCBidWZmZXJJbmZvLCBsZXZlbERldGFpbHMpO1xyXG4gIH1cclxuXHJcbiAgX2ZldGNoUGF5bG9hZE9yRW9zKHBvcywgYnVmZmVySW5mbywgbGV2ZWxEZXRhaWxzKSB7XHJcbiAgICBjb25zdCBmcmFnUHJldmlvdXMgPSB0aGlzLmZyYWdQcmV2aW91cyxcclxuICAgICAgICAgIGxldmVsID0gdGhpcy5sZXZlbCxcclxuICAgICAgICAgIGZyYWdtZW50cyA9IGxldmVsRGV0YWlscy5mcmFnbWVudHMsXHJcbiAgICAgICAgICBmcmFnTGVuID0gZnJhZ21lbnRzLmxlbmd0aDtcclxuXHJcbiAgICAvLyBlbXB0eSBwbGF5bGlzdFxyXG4gICAgaWYgKGZyYWdMZW4gPT09IDApIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGZpbmQgZnJhZ21lbnQgaW5kZXgsIGNvbnRpZ3VvdXMgd2l0aCBlbmQgb2YgYnVmZmVyIHBvc2l0aW9uXHJcbiAgICBsZXQgc3RhcnQgPSBmcmFnbWVudHNbMF0uc3RhcnQsXHJcbiAgICAgICAgZW5kID0gZnJhZ21lbnRzW2ZyYWdMZW4tMV0uc3RhcnQgKyBmcmFnbWVudHNbZnJhZ0xlbi0xXS5kdXJhdGlvbixcclxuICAgICAgICBidWZmZXJFbmQgPSBidWZmZXJJbmZvLmVuZCxcclxuICAgICAgICBmcmFnO1xyXG5cclxuICAgIGlmIChsZXZlbERldGFpbHMuaW5pdFNlZ21lbnQgJiYgIWxldmVsRGV0YWlscy5pbml0U2VnbWVudC5kYXRhKSB7XHJcbiAgICAgIGZyYWcgPSBsZXZlbERldGFpbHMuaW5pdFNlZ21lbnQ7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBpbiBjYXNlIG9mIGxpdmUgcGxheWxpc3Qgd2UgbmVlZCB0byBlbnN1cmUgdGhhdCByZXF1ZXN0ZWQgcG9zaXRpb24gaXMgbm90IGxvY2F0ZWQgYmVmb3JlIHBsYXlsaXN0IHN0YXJ0XHJcbiAgICAgIGlmIChsZXZlbERldGFpbHMubGl2ZSkge1xyXG4gICAgICAgIGxldCBpbml0aWFsTGl2ZU1hbmlmZXN0U2l6ZSA9IHRoaXMuY29uZmlnLmluaXRpYWxMaXZlTWFuaWZlc3RTaXplO1xyXG4gICAgICAgIGlmKGZyYWdMZW4gPCBpbml0aWFsTGl2ZU1hbmlmZXN0U2l6ZSl7XHJcbiAgICAgICAgICBsb2dnZXIud2FybihgQ2FuIG5vdCBzdGFydCBwbGF5YmFjayBvZiBhIGxldmVsLCByZWFzb246IG5vdCBlbm91Z2ggZnJhZ21lbnRzICR7ZnJhZ0xlbn0gPCAke2luaXRpYWxMaXZlTWFuaWZlc3RTaXplfWApO1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnJhZyA9IHRoaXMuX2Vuc3VyZUZyYWdtZW50QXRMaXZlUG9pbnQobGV2ZWxEZXRhaWxzLCBidWZmZXJFbmQsIHN0YXJ0LCBlbmQsIGZyYWdQcmV2aW91cywgZnJhZ21lbnRzLCBmcmFnTGVuKTtcclxuICAgICAgICAvLyBpZiBpdCBleHBsaWNpdGVseSByZXR1cm5zIG51bGwgZG9uJ3QgbG9hZCBhbnkgZnJhZ21lbnQgYW5kIGV4aXQgZnVuY3Rpb24gbm93XHJcbiAgICAgICAgaWYgKGZyYWcgPT09IG51bGwpIHtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIFZvRCBwbGF5bGlzdDogaWYgYnVmZmVyRW5kIGJlZm9yZSBzdGFydCBvZiBwbGF5bGlzdCwgbG9hZCBmaXJzdCBmcmFnbWVudFxyXG4gICAgICAgIGlmIChidWZmZXJFbmQgPCBzdGFydCkge1xyXG4gICAgICAgICAgZnJhZyA9IGZyYWdtZW50c1swXTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGlmICghZnJhZykge1xyXG4gICAgICBmcmFnID0gdGhpcy5fZmluZEZyYWdtZW50KHN0YXJ0LCBmcmFnUHJldmlvdXMsIGZyYWdMZW4sIGZyYWdtZW50cywgYnVmZmVyRW5kLCBlbmQsIGxldmVsRGV0YWlscyk7XHJcbiAgICB9XHJcbiAgICBpZihmcmFnKSB7XHJcbiAgICAgIHRoaXMuX2xvYWRGcmFnbWVudE9yS2V5KGZyYWcsIGxldmVsLCBsZXZlbERldGFpbHMsIHBvcywgYnVmZmVyRW5kKTtcclxuICAgIH1cclxuICAgIHJldHVybjtcclxuICB9XHJcblxyXG4gIF9lbnN1cmVGcmFnbWVudEF0TGl2ZVBvaW50KGxldmVsRGV0YWlscywgYnVmZmVyRW5kLCBzdGFydCwgZW5kLCBmcmFnUHJldmlvdXMsIGZyYWdtZW50cywgZnJhZ0xlbikge1xyXG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5obHMuY29uZmlnLCBtZWRpYSA9IHRoaXMubWVkaWE7XHJcblxyXG4gICAgbGV0IGZyYWc7XHJcblxyXG4gICAgLy8gY2hlY2sgaWYgcmVxdWVzdGVkIHBvc2l0aW9uIGlzIHdpdGhpbiBzZWVrYWJsZSBib3VuZGFyaWVzIDpcclxuICAgIC8vbG9nZ2VyLmxvZyhgc3RhcnQvcG9zL2J1ZkVuZC9zZWVraW5nOiR7c3RhcnQudG9GaXhlZCgzKX0vJHtwb3MudG9GaXhlZCgzKX0vJHtidWZmZXJFbmQudG9GaXhlZCgzKX0vJHt0aGlzLm1lZGlhLnNlZWtpbmd9YCk7XHJcbiAgICBsZXQgbWF4TGF0ZW5jeSA9IGNvbmZpZy5saXZlTWF4TGF0ZW5jeUR1cmF0aW9uICE9PSB1bmRlZmluZWQgPyBjb25maWcubGl2ZU1heExhdGVuY3lEdXJhdGlvbiA6IGNvbmZpZy5saXZlTWF4TGF0ZW5jeUR1cmF0aW9uQ291bnQqbGV2ZWxEZXRhaWxzLnRhcmdldGR1cmF0aW9uO1xyXG5cclxuICAgIGlmIChidWZmZXJFbmQgPCBNYXRoLm1heChzdGFydC1jb25maWcubWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSwgZW5kIC0gbWF4TGF0ZW5jeSkpIHtcclxuICAgICAgICBsZXQgbGl2ZVN5bmNQb3NpdGlvbiA9IHRoaXMubGl2ZVN5bmNQb3NpdGlvbiA9IHRoaXMuY29tcHV0ZUxpdmVQb3NpdGlvbihzdGFydCwgbGV2ZWxEZXRhaWxzKTtcclxuICAgICAgICBsb2dnZXIubG9nKGBidWZmZXIgZW5kOiAke2J1ZmZlckVuZC50b0ZpeGVkKDMpfSBpcyBsb2NhdGVkIHRvbyBmYXIgZnJvbSB0aGUgZW5kIG9mIGxpdmUgc2xpZGluZyBwbGF5bGlzdCwgcmVzZXQgY3VycmVudFRpbWUgdG8gOiAke2xpdmVTeW5jUG9zaXRpb24udG9GaXhlZCgzKX1gKTtcclxuICAgICAgICBidWZmZXJFbmQgPSBsaXZlU3luY1Bvc2l0aW9uO1xyXG4gICAgICAgIGlmIChtZWRpYSAmJiBtZWRpYS5yZWFkeVN0YXRlICYmIG1lZGlhLmR1cmF0aW9uID4gbGl2ZVN5bmNQb3NpdGlvbikge1xyXG4gICAgICAgICAgbWVkaWEuY3VycmVudFRpbWUgPSBsaXZlU3luY1Bvc2l0aW9uO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLm5leHRMb2FkUG9zaXRpb24gPSBsaXZlU3luY1Bvc2l0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGlmIGVuZCBvZiBidWZmZXIgZ3JlYXRlciB0aGFuIGxpdmUgZWRnZSwgZG9uJ3QgbG9hZCBhbnkgZnJhZ21lbnRcclxuICAgIC8vIHRoaXMgY291bGQgaGFwcGVuIGlmIGxpdmUgcGxheWxpc3QgaW50ZXJtaXR0ZW50bHkgc2xpZGVzIGluIHRoZSBwYXN0LlxyXG4gICAgLy8gbGV2ZWwgMSBsb2FkZWQgWzE4MjU4MDE2MSwxODI1ODAxNjddXHJcbiAgICAvLyBsZXZlbCAxIGxvYWRlZCBbMTgyNTgwMTYyLDE4MjU4MDE2OV1cclxuICAgIC8vIExvYWRpbmcgMTgyNTgwMTY4IG9mIFsxODI1ODAxNjIgLDE4MjU4MDE2OV0sbGV2ZWwgMSAuLlxyXG4gICAgLy8gTG9hZGluZyAxODI1ODAxNjkgb2YgWzE4MjU4MDE2MiAsMTgyNTgwMTY5XSxsZXZlbCAxIC4uXHJcbiAgICAvLyBsZXZlbCAxIGxvYWRlZCBbMTgyNTgwMTYyLDE4MjU4MDE2OF0gPD09PT09PT09PT09PT0gaGVyZSB3ZSBzaG91bGQgaGF2ZSBidWZmZXJFbmQgPiBlbmQuIGluIHRoYXQgY2FzZSBicmVhayB0byBhdm9pZCByZWxvYWRpbmcgMTgyNTgwMTY4XHJcbiAgICAvLyBsZXZlbCAxIGxvYWRlZCBbMTgyNTgwMTY0LDE4MjU4MDE3MV1cclxuICAgIC8vXHJcbiAgICAvLyBkb24ndCByZXR1cm4gbnVsbCBpbiBjYXNlIG1lZGlhIG5vdCBsb2FkZWQgeWV0IChyZWFkeXN0YXRlID09PSAwKVxyXG4gICAgaWYgKGxldmVsRGV0YWlscy5QVFNLbm93biAmJiBidWZmZXJFbmQgPiBlbmQgJiYgbWVkaWEgJiYgbWVkaWEucmVhZHlTdGF0ZSkge1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgJiYgIWxldmVsRGV0YWlscy5QVFNLbm93bikge1xyXG4gICAgICAvKiB3ZSBhcmUgc3dpdGNoaW5nIGxldmVsIG9uIGxpdmUgcGxheWxpc3QsIGJ1dCB3ZSBkb24ndCBoYXZlIGFueSBQVFMgaW5mbyBmb3IgdGhhdCBxdWFsaXR5IGxldmVsIC4uLlxyXG4gICAgICAgICB0cnkgdG8gbG9hZCBmcmFnIG1hdGNoaW5nIHdpdGggbmV4dCBTTi5cclxuICAgICAgICAgZXZlbiBpZiBTTiBhcmUgbm90IHN5bmNocm9uaXplZCBiZXR3ZWVuIHBsYXlsaXN0cywgbG9hZGluZyB0aGlzIGZyYWcgd2lsbCBoZWxwIHVzXHJcbiAgICAgICAgIGNvbXB1dGUgcGxheWxpc3Qgc2xpZGluZyBhbmQgZmluZCB0aGUgcmlnaHQgb25lIGFmdGVyIGluIGNhc2UgaXQgd2FzIG5vdCB0aGUgcmlnaHQgY29uc2VjdXRpdmUgb25lICovXHJcbiAgICAgIGlmIChmcmFnUHJldmlvdXMpIHtcclxuICAgICAgICB2YXIgdGFyZ2V0U04gPSBmcmFnUHJldmlvdXMuc24gKyAxO1xyXG4gICAgICAgIGlmICh0YXJnZXRTTiA+PSBsZXZlbERldGFpbHMuc3RhcnRTTiAmJiB0YXJnZXRTTiA8PSBsZXZlbERldGFpbHMuZW5kU04pIHtcclxuICAgICAgICAgIGZyYWcgPSBmcmFnbWVudHNbdGFyZ2V0U04gLSBsZXZlbERldGFpbHMuc3RhcnRTTl07XHJcbiAgICAgICAgICBsb2dnZXIubG9nKGBsaXZlIHBsYXlsaXN0LCBzd2l0Y2hpbmcgcGxheWxpc3QsIGxvYWQgZnJhZyB3aXRoIG5leHQgU046ICR7ZnJhZy5zbn1gKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgaWYgKCFmcmFnKSB7XHJcbiAgICAgICAgLyogd2UgaGF2ZSBubyBpZGVhIGFib3V0IHdoaWNoIGZyYWdtZW50IHNob3VsZCBiZSBsb2FkZWQuXHJcbiAgICAgICAgICAgc28gbGV0J3MgbG9hZCBtaWQgZnJhZ21lbnQuIGl0IHdpbGwgaGVscCBjb21wdXRpbmcgcGxheWxpc3Qgc2xpZGluZyBhbmQgZmluZCB0aGUgcmlnaHQgb25lXHJcbiAgICAgICAgKi9cclxuICAgICAgICBmcmFnID0gZnJhZ21lbnRzW01hdGgubWluKGZyYWdMZW4gLSAxLCBNYXRoLnJvdW5kKGZyYWdMZW4gLyAyKSldO1xyXG4gICAgICAgIGxvZ2dlci5sb2coYGxpdmUgcGxheWxpc3QsIHN3aXRjaGluZyBwbGF5bGlzdCwgdW5rbm93biwgbG9hZCBtaWRkbGUgZnJhZyA6ICR7ZnJhZy5zbn1gKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZyYWc7XHJcbiAgfVxyXG5cclxuICBfZmluZEZyYWdtZW50KHN0YXJ0LCBmcmFnUHJldmlvdXMsIGZyYWdMZW4sIGZyYWdtZW50cywgYnVmZmVyRW5kLCBlbmQsIGxldmVsRGV0YWlscykge1xyXG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5obHMuY29uZmlnO1xyXG4gICAgbGV0IGZyYWc7XHJcbiAgICBsZXQgZm91bmRGcmFnO1xyXG4gICAgbGV0IG1heEZyYWdMb29rVXBUb2xlcmFuY2UgPSBjb25maWcubWF4RnJhZ0xvb2tVcFRvbGVyYW5jZTtcclxuICAgIGNvbnN0IGZyYWdOZXh0ID0gZnJhZ1ByZXZpb3VzID8gZnJhZ21lbnRzW2ZyYWdQcmV2aW91cy5zbiAtIGZyYWdtZW50c1swXS5zbiArIDFdIDogdW5kZWZpbmVkO1xyXG4gICAgbGV0IGZyYWdtZW50V2l0aGluVG9sZXJhbmNlVGVzdCA9IChjYW5kaWRhdGUpID0+IHtcclxuICAgICAgLy8gb2Zmc2V0IHNob3VsZCBiZSB3aXRoaW4gZnJhZ21lbnQgYm91bmRhcnkgLSBjb25maWcubWF4RnJhZ0xvb2tVcFRvbGVyYW5jZVxyXG4gICAgICAvLyB0aGlzIGlzIHRvIGNvcGUgd2l0aCBzaXR1YXRpb25zIGxpa2VcclxuICAgICAgLy8gYnVmZmVyRW5kID0gOS45OTFcclxuICAgICAgLy8gZnJhZ1vDmF0gOiBbMCwxMF1cclxuICAgICAgLy8gZnJhZ1sxXSA6IFsxMCwyMF1cclxuICAgICAgLy8gYnVmZmVyRW5kIGlzIHdpdGhpbiBmcmFnWzBdIHJhbmdlIC4uLiBhbHRob3VnaCB3aGF0IHdlIGFyZSBleHBlY3RpbmcgaXMgdG8gcmV0dXJuIGZyYWdbMV0gaGVyZVxyXG4gICAgICAvLyAgICAgICAgICAgICAgZnJhZyBzdGFydCAgICAgICAgICAgICAgIGZyYWcgc3RhcnQrZHVyYXRpb25cclxuICAgICAgLy8gICAgICAgICAgICAgICAgICB8LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18XHJcbiAgICAgIC8vICAgICAgICAgICAgICA8LS0tPiAgICAgICAgICAgICAgICAgICAgICAgICA8LS0tPlxyXG4gICAgICAvLyAgLi4uLS0tLS0tLS0+PC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tPjwtLS0tLS0tLS0uLi4uXHJcbiAgICAgIC8vIHByZXZpb3VzIGZyYWcgICAgICAgICBtYXRjaGluZyBmcmFnbWVudCAgICAgICAgIG5leHQgZnJhZ1xyXG4gICAgICAvLyAgcmV0dXJuIC0xICAgICAgICAgICAgIHJldHVybiAwICAgICAgICAgICAgICAgICByZXR1cm4gMVxyXG4gICAgICAvL2xvZ2dlci5sb2coYGxldmVsL3NuL3N0YXJ0L2VuZC9idWZFbmQ6JHtsZXZlbH0vJHtjYW5kaWRhdGUuc259LyR7Y2FuZGlkYXRlLnN0YXJ0fS8keyhjYW5kaWRhdGUuc3RhcnQrY2FuZGlkYXRlLmR1cmF0aW9uKX0vJHtidWZmZXJFbmR9YCk7XHJcbiAgICAgIC8vIFNldCB0aGUgbG9va3VwIHRvbGVyYW5jZSB0byBiZSBzbWFsbCBlbm91Z2ggdG8gZGV0ZWN0IHRoZSBjdXJyZW50IHNlZ21lbnQgLSBlbnN1cmVzIHdlIGRvbid0IHNraXAgb3ZlciB2ZXJ5IHNtYWxsIHNlZ21lbnRzXHJcbiAgICAgIGxldCBjYW5kaWRhdGVMb29rdXBUb2xlcmFuY2UgPSBNYXRoLm1pbihtYXhGcmFnTG9va1VwVG9sZXJhbmNlLCBjYW5kaWRhdGUuZHVyYXRpb24pO1xyXG4gICAgICBpZiAoY2FuZGlkYXRlLnN0YXJ0ICsgY2FuZGlkYXRlLmR1cmF0aW9uIC0gY2FuZGlkYXRlTG9va3VwVG9sZXJhbmNlIDw9IGJ1ZmZlckVuZCkge1xyXG4gICAgICAgIHJldHVybiAxO1xyXG4gICAgICB9IC8vIGlmIG1heEZyYWdMb29rVXBUb2xlcmFuY2Ugd2lsbCBoYXZlIG5lZ2F0aXZlIHZhbHVlIHRoZW4gZG9uJ3QgcmV0dXJuIC0xIGZvciBmaXJzdCBlbGVtZW50XHJcbiAgICAgIGVsc2UgaWYgKGNhbmRpZGF0ZS5zdGFydCAtIGNhbmRpZGF0ZUxvb2t1cFRvbGVyYW5jZSA+IGJ1ZmZlckVuZCAmJiBjYW5kaWRhdGUuc3RhcnQpIHtcclxuICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIDA7XHJcbiAgICB9O1xyXG5cclxuICAgIGlmIChidWZmZXJFbmQgPCBlbmQpIHtcclxuICAgICAgaWYgKGJ1ZmZlckVuZCA+IGVuZCAtIG1heEZyYWdMb29rVXBUb2xlcmFuY2UpIHtcclxuICAgICAgICBtYXhGcmFnTG9va1VwVG9sZXJhbmNlID0gMDtcclxuICAgICAgfVxyXG4gICAgICAvLyBQcmVmZXIgdGhlIG5leHQgZnJhZ21lbnQgaWYgaXQncyB3aXRoaW4gdG9sZXJhbmNlXHJcbiAgICAgIGlmIChmcmFnTmV4dCAmJiAhZnJhZ21lbnRXaXRoaW5Ub2xlcmFuY2VUZXN0KGZyYWdOZXh0KSkge1xyXG4gICAgICAgIGZvdW5kRnJhZyA9IGZyYWdOZXh0O1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGZvdW5kRnJhZyA9IEJpbmFyeVNlYXJjaC5zZWFyY2goZnJhZ21lbnRzLCBmcmFnbWVudFdpdGhpblRvbGVyYW5jZVRlc3QpO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyByZWFjaCBlbmQgb2YgcGxheWxpc3RcclxuICAgICAgZm91bmRGcmFnID0gZnJhZ21lbnRzW2ZyYWdMZW4tMV07XHJcbiAgICB9XHJcbiAgICBpZiAoZm91bmRGcmFnKSB7XHJcbiAgICAgIGZyYWcgPSBmb3VuZEZyYWc7XHJcbiAgICAgIGNvbnN0IGN1clNOSWR4ID0gZnJhZy5zbiAtIGxldmVsRGV0YWlscy5zdGFydFNOO1xyXG4gICAgICBjb25zdCBzYW1lTGV2ZWwgPSBmcmFnUHJldmlvdXMgJiYgZnJhZy5sZXZlbCA9PT0gZnJhZ1ByZXZpb3VzLmxldmVsO1xyXG4gICAgICBjb25zdCBwcmV2RnJhZyA9IGZyYWdtZW50c1tjdXJTTklkeCAtIDFdO1xyXG4gICAgICBjb25zdCBuZXh0RnJhZyA9IGZyYWdtZW50c1tjdXJTTklkeCArIDFdO1xyXG4gICAgICAvL2xvZ2dlci5sb2coJ2ZpbmQgU04gbWF0Y2hpbmcgd2l0aCBwb3M6JyArICBidWZmZXJFbmQgKyAnOicgKyBmcmFnLnNuKTtcclxuICAgICAgaWYgKGZyYWdQcmV2aW91cyAmJiBmcmFnLnNuID09PSBmcmFnUHJldmlvdXMuc24pIHtcclxuICAgICAgICBpZiAoc2FtZUxldmVsICYmICFmcmFnLmJhY2t0cmFja2VkKSB7XHJcbiAgICAgICAgICBpZiAoZnJhZy5zbiA8IGxldmVsRGV0YWlscy5lbmRTTikge1xyXG4gICAgICAgICAgICBsZXQgZGVsdGFQVFMgPSBmcmFnUHJldmlvdXMuZGVsdGFQVFM7XHJcbiAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIGEgc2lnbmlmaWNhbnQgZGVsdGEgYmV0d2VlbiBhdWRpbyBhbmQgdmlkZW8sIGxhcmdlciB0aGFuIG1heCBhbGxvd2VkIGhvbGUsXHJcbiAgICAgICAgICAgIC8vIGFuZCBpZiBwcmV2aW91cyByZW11eGVkIGZyYWdtZW50IGRpZCBub3Qgc3RhcnQgd2l0aCBhIGtleWZyYW1lLiAoZnJhZ1ByZXZpb3VzLmRyb3BwZWQpXHJcbiAgICAgICAgICAgIC8vIGxldCdzIHRyeSB0byBsb2FkIHByZXZpb3VzIGZyYWdtZW50IGFnYWluIHRvIGdldCBsYXN0IGtleWZyYW1lXHJcbiAgICAgICAgICAgIC8vIHRoZW4gd2Ugd2lsbCByZWxvYWQgYWdhaW4gY3VycmVudCBmcmFnbWVudCAodGhhdCB3YXkgd2Ugc2hvdWxkIGJlIGFibGUgdG8gZmlsbCB0aGUgYnVmZmVyIGhvbGUgLi4uKVxyXG4gICAgICAgICAgICBpZiAoZGVsdGFQVFMgJiYgZGVsdGFQVFMgPiBjb25maWcubWF4QnVmZmVySG9sZSAmJiBmcmFnUHJldmlvdXMuZHJvcHBlZCAmJiBjdXJTTklkeCkge1xyXG4gICAgICAgICAgICAgIGZyYWcgPSBwcmV2RnJhZztcclxuICAgICAgICAgICAgICBsb2dnZXIud2FybihgU04ganVzdCBsb2FkZWQsIHdpdGggbGFyZ2UgUFRTIGdhcCBiZXR3ZWVuIGF1ZGlvIGFuZCB2aWRlbywgbWF5YmUgZnJhZyBpcyBub3Qgc3RhcnRpbmcgd2l0aCBhIGtleWZyYW1lID8gbG9hZCBwcmV2aW91cyBvbmUgdG8gdHJ5IHRvIG92ZXJjb21lIHRoaXNgKTtcclxuICAgICAgICAgICAgICAvLyBkZWNyZW1lbnQgcHJldmlvdXMgZnJhZyBsb2FkIGNvdW50ZXIgdG8gYXZvaWQgZnJhZyBsb29wIGxvYWRpbmcgZXJyb3Igd2hlbiBuZXh0IGZyYWdtZW50IHdpbGwgZ2V0IHJlbG9hZGVkXHJcbiAgICAgICAgICAgICAgZnJhZ1ByZXZpb3VzLmxvYWRDb3VudGVyLS07XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgZnJhZyA9IG5leHRGcmFnO1xyXG4gICAgICAgICAgICAgIGxvZ2dlci5sb2coYFNOIGp1c3QgbG9hZGVkLCBsb2FkIG5leHQgb25lOiAke2ZyYWcuc259YCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGZyYWcgPSBudWxsO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSBpZiAoZnJhZy5iYWNrdHJhY2tlZCkge1xyXG4gICAgICAgICAgLy8gT25seSBiYWNrdHJhY2sgYSBtYXggb2YgMSBjb25zZWN1dGl2ZSBmcmFnbWVudCB0byBwcmV2ZW50IHNsaWRpbmcgYmFjayB0b28gZmFyIHdoZW4gbGl0dGxlIG9yIG5vIGZyYWdzIHN0YXJ0IHdpdGgga2V5ZnJhbWVzXHJcbiAgICAgICAgICBpZiAobmV4dEZyYWcgJiYgbmV4dEZyYWcuYmFja3RyYWNrZWQpIHtcclxuICAgICAgICAgICAgbG9nZ2VyLndhcm4oYEFscmVhZHkgYmFja3RyYWNrZWQgZnJvbSBmcmFnbWVudCAke25leHRGcmFnLnNufSwgd2lsbCBub3QgYmFja3RyYWNrIHRvIGZyYWdtZW50ICR7ZnJhZy5zbn0uIExvYWRpbmcgZnJhZ21lbnQgJHtuZXh0RnJhZy5zbn1gKTtcclxuICAgICAgICAgICAgZnJhZyA9IG5leHRGcmFnO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gSWYgYSBmcmFnbWVudCBoYXMgZHJvcHBlZCBmcmFtZXMgYW5kIGl0J3MgaW4gYSBzYW1lIGxldmVsL3NlcXVlbmNlLCBsb2FkIHRoZSBwcmV2aW91cyBmcmFnbWVudCB0byB0cnkgYW5kIGZpbmQgdGhlIGtleWZyYW1lXHJcbiAgICAgICAgICAgIC8vIFJlc2V0IHRoZSBkcm9wcGVkIGNvdW50IG5vdyBzaW5jZSBpdCB3b24ndCBiZSByZXNldCB1bnRpbCB3ZSBwYXJzZSB0aGUgZnJhZ21lbnQgYWdhaW4sIHdoaWNoIHByZXZlbnRzIGluZmluaXRlIGJhY2t0cmFja2luZyBvbiB0aGUgc2FtZSBzZWdtZW50XHJcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKCdMb2FkZWQgZnJhZ21lbnQgd2l0aCBkcm9wcGVkIGZyYW1lcywgYmFja3RyYWNraW5nIDEgc2VnbWVudCB0byBmaW5kIGEga2V5ZnJhbWUnKTtcclxuICAgICAgICAgICAgZnJhZy5kcm9wcGVkID0gMDtcclxuICAgICAgICAgICAgaWYgKHByZXZGcmFnKSB7XHJcbiAgICAgICAgICAgICAgaWYgKHByZXZGcmFnLmxvYWRDb3VudGVyKSB7XHJcbiAgICAgICAgICAgICAgICBwcmV2RnJhZy5sb2FkQ291bnRlci0tO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBmcmFnID0gcHJldkZyYWc7XHJcbiAgICAgICAgICAgICAgZnJhZy5iYWNrdHJhY2tlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY3VyU05JZHgpIHtcclxuICAgICAgICAgICAgICAvLyBjYW4ndCBiYWNrdHJhY2sgb24gdmVyeSBmaXJzdCBmcmFnbWVudFxyXG4gICAgICAgICAgICAgIGZyYWcgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZnJhZztcclxuICB9XHJcblxyXG4gIF9sb2FkRnJhZ21lbnRPcktleShmcmFnLCBsZXZlbCwgbGV2ZWxEZXRhaWxzLCBwb3MsIGJ1ZmZlckVuZCkge1xyXG4gICAgY29uc3QgaGxzID0gdGhpcy5obHMsXHJcbiAgICAgICAgICBjb25maWcgPSBobHMuY29uZmlnO1xyXG5cclxuICAgIC8vbG9nZ2VyLmxvZygnbG9hZGluZyBmcmFnICcgKyBpICsnLHBvcy9idWZFbmQ6JyArIHBvcy50b0ZpeGVkKDMpICsgJy8nICsgYnVmZmVyRW5kLnRvRml4ZWQoMykpO1xyXG4gICAgaWYgKChmcmFnLmRlY3J5cHRkYXRhICYmIGZyYWcuZGVjcnlwdGRhdGEudXJpICE9IG51bGwpICYmIChmcmFnLmRlY3J5cHRkYXRhLmtleSA9PSBudWxsKSkge1xyXG4gICAgICBsb2dnZXIubG9nKGBMb2FkaW5nIGtleSBmb3IgJHtmcmFnLnNufSBvZiBbJHtsZXZlbERldGFpbHMuc3RhcnRTTn0gLCR7bGV2ZWxEZXRhaWxzLmVuZFNOfV0sbGV2ZWwgJHtsZXZlbH1gKTtcclxuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLktFWV9MT0FESU5HO1xyXG4gICAgICBobHMudHJpZ2dlcihFdmVudC5LRVlfTE9BRElORywge2ZyYWc6IGZyYWd9KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGxvZ2dlci5sb2coYExvYWRpbmcgJHtmcmFnLnNufSBvZiBbJHtsZXZlbERldGFpbHMuc3RhcnRTTn0gLCR7bGV2ZWxEZXRhaWxzLmVuZFNOfV0sbGV2ZWwgJHtsZXZlbH0sIGN1cnJlbnRUaW1lOiR7cG9zLnRvRml4ZWQoMyl9LGJ1ZmZlckVuZDoke2J1ZmZlckVuZC50b0ZpeGVkKDMpfWApO1xyXG4gICAgICAvLyBlbnN1cmUgdGhhdCB3ZSBhcmUgbm90IHJlbG9hZGluZyB0aGUgc2FtZSBmcmFnbWVudHMgaW4gbG9vcCAuLi5cclxuICAgICAgaWYgKHRoaXMuZnJhZ0xvYWRJZHggIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHRoaXMuZnJhZ0xvYWRJZHgrKztcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLmZyYWdMb2FkSWR4ID0gMDtcclxuICAgICAgfVxyXG4gICAgICBpZiAoZnJhZy5sb2FkQ291bnRlcikge1xyXG4gICAgICAgIGZyYWcubG9hZENvdW50ZXIrKztcclxuICAgICAgICBsZXQgbWF4VGhyZXNob2xkID0gY29uZmlnLmZyYWdMb2FkaW5nTG9vcFRocmVzaG9sZDtcclxuICAgICAgICAvLyBpZiB0aGlzIGZyYWcgaGFzIGFscmVhZHkgYmVlbiBsb2FkZWQgMyB0aW1lcywgYW5kIGlmIGl0IGhhcyBiZWVuIHJlbG9hZGVkIHJlY2VudGx5XHJcbiAgICAgICAgaWYgKGZyYWcubG9hZENvdW50ZXIgPiBtYXhUaHJlc2hvbGQgJiYgKE1hdGguYWJzKHRoaXMuZnJhZ0xvYWRJZHggLSBmcmFnLmxvYWRJZHgpIDwgbWF4VGhyZXNob2xkKSkge1xyXG4gICAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnQuRVJST1IsIHt0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLCBkZXRhaWxzOiBFcnJvckRldGFpbHMuRlJBR19MT09QX0xPQURJTkdfRVJST1IsIGZhdGFsOiBmYWxzZSwgZnJhZzogZnJhZ30pO1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBmcmFnLmxvYWRDb3VudGVyID0gMTtcclxuICAgICAgfVxyXG4gICAgICBmcmFnLmxvYWRJZHggPSB0aGlzLmZyYWdMb2FkSWR4O1xyXG4gICAgICB0aGlzLmZyYWdDdXJyZW50ID0gZnJhZztcclxuICAgICAgdGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgPSB0cnVlO1xyXG4gICAgICBpZiAoIWlzTmFOKGZyYWcuc24pKSB7XHJcbiAgICAgICAgdGhpcy5uZXh0TG9hZFBvc2l0aW9uID0gZnJhZy5zdGFydCArIGZyYWcuZHVyYXRpb247XHJcbiAgICAgIH1cclxuICAgICAgZnJhZy5hdXRvTGV2ZWwgPSBobHMuYXV0b0xldmVsRW5hYmxlZDtcclxuICAgICAgZnJhZy5iaXRyYXRlVGVzdCA9IHRoaXMuYml0cmF0ZVRlc3Q7XHJcbiAgICAgIGhscy50cmlnZ2VyKEV2ZW50LkZSQUdfTE9BRElORywge2ZyYWc6IGZyYWd9KTtcclxuICAgICAgLy8gbGF6eSBkZW11eGVyIGluaXQsIGFzIHRoaXMgY291bGQgdGFrZSBzb21lIHRpbWUgLi4uIGRvIGl0IGR1cmluZyBmcmFnIGxvYWRpbmdcclxuICAgICAgaWYgKCF0aGlzLmRlbXV4ZXIpIHtcclxuICAgICAgICB0aGlzLmRlbXV4ZXIgPSBuZXcgRGVtdXhlcihobHMsJ21haW4nKTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuRlJBR19MT0FESU5HO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBzZXQgc3RhdGUobmV4dFN0YXRlKSB7XHJcbiAgICBpZiAodGhpcy5zdGF0ZSAhPT0gbmV4dFN0YXRlKSB7XHJcbiAgICAgIGNvbnN0IHByZXZpb3VzU3RhdGUgPSB0aGlzLnN0YXRlO1xyXG4gICAgICB0aGlzLl9zdGF0ZSA9IG5leHRTdGF0ZTtcclxuICAgICAgbG9nZ2VyLmxvZyhgbWFpbiBzdHJlYW06JHtwcmV2aW91c1N0YXRlfS0+JHtuZXh0U3RhdGV9YCk7XHJcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuU1RSRUFNX1NUQVRFX1RSQU5TSVRJT04sIHtwcmV2aW91c1N0YXRlLCBuZXh0U3RhdGV9KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGdldCBzdGF0ZSgpIHtcclxuICAgIHJldHVybiB0aGlzLl9zdGF0ZTtcclxuICB9XHJcblxyXG4gIGdldEJ1ZmZlcmVkRnJhZyhwb3NpdGlvbikge1xyXG4gICAgcmV0dXJuIEJpbmFyeVNlYXJjaC5zZWFyY2godGhpcy5fYnVmZmVyZWRGcmFncywgZnVuY3Rpb24oZnJhZykge1xyXG4gICAgICBpZiAocG9zaXRpb24gPCBmcmFnLnN0YXJ0UFRTKSB7XHJcbiAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID4gZnJhZy5lbmRQVFMpIHtcclxuICAgICAgICByZXR1cm4gMTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gMDtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgZ2V0IGN1cnJlbnRMZXZlbCgpIHtcclxuICAgIGxldCBtZWRpYSA9IHRoaXMubWVkaWE7XHJcbiAgICBpZiAobWVkaWEpIHtcclxuICAgICAgY29uc3QgZnJhZyA9IHRoaXMuZ2V0QnVmZmVyZWRGcmFnKG1lZGlhLmN1cnJlbnRUaW1lKTtcclxuICAgICAgaWYgKGZyYWcpIHtcclxuICAgICAgICByZXR1cm4gZnJhZy5sZXZlbDtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIC0xO1xyXG4gIH1cclxuXHJcbiAgZ2V0IG5leHRCdWZmZXJlZEZyYWcoKSB7XHJcbiAgICBsZXQgbWVkaWEgPSB0aGlzLm1lZGlhO1xyXG4gICAgaWYgKG1lZGlhKSB7XHJcbiAgICAgIC8vIGZpcnN0IGdldCBlbmQgcmFuZ2Ugb2YgY3VycmVudCBmcmFnbWVudFxyXG4gICAgICByZXR1cm4gdGhpcy5mb2xsb3dpbmdCdWZmZXJlZEZyYWcodGhpcy5nZXRCdWZmZXJlZEZyYWcobWVkaWEuY3VycmVudFRpbWUpKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZm9sbG93aW5nQnVmZmVyZWRGcmFnKGZyYWcpIHtcclxuICAgIGlmIChmcmFnKSB7XHJcbiAgICAgIC8vIHRyeSB0byBnZXQgcmFuZ2Ugb2YgbmV4dCBmcmFnbWVudCAoNTAwbXMgYWZ0ZXIgdGhpcyByYW5nZSlcclxuICAgICAgcmV0dXJuIHRoaXMuZ2V0QnVmZmVyZWRGcmFnKGZyYWcuZW5kUFRTICsgMC41KTtcclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuXHJcbiAgZ2V0IG5leHRMZXZlbCgpIHtcclxuICAgIGNvbnN0IGZyYWcgPSB0aGlzLm5leHRCdWZmZXJlZEZyYWc7XHJcbiAgICBpZiAoZnJhZykge1xyXG4gICAgICByZXR1cm4gZnJhZy5sZXZlbDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiAtMTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIF9jaGVja0ZyYWdtZW50Q2hhbmdlZCgpIHtcclxuICAgIHZhciBmcmFnUGxheWluZ0N1cnJlbnQsIGN1cnJlbnRUaW1lLCB2aWRlbyA9IHRoaXMubWVkaWE7XHJcbiAgICBpZiAodmlkZW8gJiYgdmlkZW8ucmVhZHlTdGF0ZSAmJiB2aWRlby5zZWVraW5nID09PSBmYWxzZSkge1xyXG4gICAgICBjdXJyZW50VGltZSA9IHZpZGVvLmN1cnJlbnRUaW1lO1xyXG4gICAgICAvKiBpZiB2aWRlbyBlbGVtZW50IGlzIGluIHNlZWtlZCBzdGF0ZSwgY3VycmVudFRpbWUgY2FuIG9ubHkgaW5jcmVhc2UuXHJcbiAgICAgICAgKGFzc3VtaW5nIHRoYXQgcGxheWJhY2sgcmF0ZSBpcyBwb3NpdGl2ZSAuLi4pXHJcbiAgICAgICAgQXMgc29tZXRpbWVzIGN1cnJlbnRUaW1lIGp1bXBzIGJhY2sgdG8gemVybyBhZnRlciBhXHJcbiAgICAgICAgbWVkaWEgZGVjb2RlIGVycm9yLCBjaGVjayB0aGlzLCB0byBhdm9pZCBzZWVraW5nIGJhY2sgdG9cclxuICAgICAgICB3cm9uZyBwb3NpdGlvbiBhZnRlciBhIG1lZGlhIGRlY29kZSBlcnJvclxyXG4gICAgICAqL1xyXG4gICAgICBpZihjdXJyZW50VGltZSA+IHZpZGVvLnBsYXliYWNrUmF0ZSp0aGlzLmxhc3RDdXJyZW50VGltZSkge1xyXG4gICAgICAgIHRoaXMubGFzdEN1cnJlbnRUaW1lID0gY3VycmVudFRpbWU7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKEJ1ZmZlckhlbHBlci5pc0J1ZmZlcmVkKHZpZGVvLGN1cnJlbnRUaW1lKSkge1xyXG4gICAgICAgIGZyYWdQbGF5aW5nQ3VycmVudCA9IHRoaXMuZ2V0QnVmZmVyZWRGcmFnKGN1cnJlbnRUaW1lKTtcclxuICAgICAgfSBlbHNlIGlmIChCdWZmZXJIZWxwZXIuaXNCdWZmZXJlZCh2aWRlbyxjdXJyZW50VGltZSArIDAuMSkpIHtcclxuICAgICAgICAvKiBlbnN1cmUgdGhhdCBGUkFHX0NIQU5HRUQgZXZlbnQgaXMgdHJpZ2dlcmVkIGF0IHN0YXJ0dXAsXHJcbiAgICAgICAgICB3aGVuIGZpcnN0IHZpZGVvIGZyYW1lIGlzIGRpc3BsYXllZCBhbmQgcGxheWJhY2sgaXMgcGF1c2VkLlxyXG4gICAgICAgICAgYWRkIGEgdG9sZXJhbmNlIG9mIDEwMG1zLCBpbiBjYXNlIGN1cnJlbnQgcG9zaXRpb24gaXMgbm90IGJ1ZmZlcmVkLFxyXG4gICAgICAgICAgY2hlY2sgaWYgY3VycmVudCBwb3MrMTAwbXMgaXMgYnVmZmVyZWQgYW5kIHVzZSB0aGF0IGJ1ZmZlciByYW5nZVxyXG4gICAgICAgICAgZm9yIEZSQUdfQ0hBTkdFRCBldmVudCByZXBvcnRpbmcgKi9cclxuICAgICAgICBmcmFnUGxheWluZ0N1cnJlbnQgPSB0aGlzLmdldEJ1ZmZlcmVkRnJhZyhjdXJyZW50VGltZSArIDAuMSk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGZyYWdQbGF5aW5nQ3VycmVudCkge1xyXG4gICAgICAgIHZhciBmcmFnUGxheWluZyA9IGZyYWdQbGF5aW5nQ3VycmVudDtcclxuICAgICAgICBpZiAoZnJhZ1BsYXlpbmcgIT09IHRoaXMuZnJhZ1BsYXlpbmcpIHtcclxuICAgICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuRlJBR19DSEFOR0VELCB7ZnJhZzogZnJhZ1BsYXlpbmd9KTtcclxuICAgICAgICAgIGNvbnN0IGZyYWdQbGF5aW5nTGV2ZWwgPSBmcmFnUGxheWluZy5sZXZlbDtcclxuICAgICAgICAgIGlmICghdGhpcy5mcmFnUGxheWluZyB8fCB0aGlzLmZyYWdQbGF5aW5nLmxldmVsICE9PSBmcmFnUGxheWluZ0xldmVsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuTEVWRUxfU1dJVENIRUQsIHtsZXZlbDogZnJhZ1BsYXlpbmdMZXZlbH0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgdGhpcy5mcmFnUGxheWluZyA9IGZyYWdQbGF5aW5nO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLypcclxuICAgIG9uIGltbWVkaWF0ZSBsZXZlbCBzd2l0Y2ggOlxyXG4gICAgIC0gcGF1c2UgcGxheWJhY2sgaWYgcGxheWluZ1xyXG4gICAgIC0gY2FuY2VsIGFueSBwZW5kaW5nIGxvYWQgcmVxdWVzdFxyXG4gICAgIC0gYW5kIHRyaWdnZXIgYSBidWZmZXIgZmx1c2hcclxuICAqL1xyXG4gIGltbWVkaWF0ZUxldmVsU3dpdGNoKCkge1xyXG4gICAgbG9nZ2VyLmxvZygnaW1tZWRpYXRlTGV2ZWxTd2l0Y2gnKTtcclxuICAgIGlmICghdGhpcy5pbW1lZGlhdGVTd2l0Y2gpIHtcclxuICAgICAgdGhpcy5pbW1lZGlhdGVTd2l0Y2ggPSB0cnVlO1xyXG4gICAgICBsZXQgbWVkaWEgPSB0aGlzLm1lZGlhLCBwcmV2aW91c2x5UGF1c2VkO1xyXG4gICAgICBpZiAobWVkaWEpIHtcclxuICAgICAgICBwcmV2aW91c2x5UGF1c2VkID0gbWVkaWEucGF1c2VkO1xyXG4gICAgICAgIG1lZGlhLnBhdXNlKCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gZG9uJ3QgcmVzdGFydCBwbGF5YmFjayBhZnRlciBpbnN0YW50IGxldmVsIHN3aXRjaCBpbiBjYXNlIG1lZGlhIG5vdCBhdHRhY2hlZFxyXG4gICAgICAgIHByZXZpb3VzbHlQYXVzZWQgPSB0cnVlO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMucHJldmlvdXNseVBhdXNlZCA9IHByZXZpb3VzbHlQYXVzZWQ7XHJcbiAgICB9XHJcbiAgICB2YXIgZnJhZ0N1cnJlbnQgPSB0aGlzLmZyYWdDdXJyZW50O1xyXG4gICAgaWYgKGZyYWdDdXJyZW50ICYmIGZyYWdDdXJyZW50LmxvYWRlcikge1xyXG4gICAgICBmcmFnQ3VycmVudC5sb2FkZXIuYWJvcnQoKTtcclxuICAgIH1cclxuICAgIHRoaXMuZnJhZ0N1cnJlbnQgPSBudWxsO1xyXG4gICAgLy8gaW5jcmVhc2UgZnJhZ21lbnQgbG9hZCBJbmRleCB0byBhdm9pZCBmcmFnIGxvb3AgbG9hZGluZyBlcnJvciBhZnRlciBidWZmZXIgZmx1c2hcclxuICAgIHRoaXMuZnJhZ0xvYWRJZHggKz0gMiAqIHRoaXMuY29uZmlnLmZyYWdMb2FkaW5nTG9vcFRocmVzaG9sZDtcclxuICAgIC8vIGZsdXNoIGV2ZXJ5dGhpbmdcclxuICAgIHRoaXMuZmx1c2hNYWluQnVmZmVyKDAsTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKTtcclxuICB9XHJcblxyXG4gIC8qXHJcbiAgICAgb24gaW1tZWRpYXRlIGxldmVsIHN3aXRjaCBlbmQsIGFmdGVyIG5ldyBmcmFnbWVudCBoYXMgYmVlbiBidWZmZXJlZCA6XHJcbiAgICAgIC0gbnVkZ2UgdmlkZW8gZGVjb2RlciBieSBzbGlnaHRseSBhZGp1c3RpbmcgdmlkZW8gY3VycmVudFRpbWUgKGlmIGN1cnJlbnRUaW1lIGJ1ZmZlcmVkKVxyXG4gICAgICAtIHJlc3VtZSB0aGUgcGxheWJhY2sgaWYgbmVlZGVkXHJcbiAgKi9cclxuICBpbW1lZGlhdGVMZXZlbFN3aXRjaEVuZCgpIHtcclxuICAgIGxldCBtZWRpYSA9IHRoaXMubWVkaWE7XHJcbiAgICBpZiAobWVkaWEgJiYgbWVkaWEuYnVmZmVyZWQubGVuZ3RoKSB7XHJcbiAgICAgIHRoaXMuaW1tZWRpYXRlU3dpdGNoID0gZmFsc2U7XHJcbiAgICAgIGlmKEJ1ZmZlckhlbHBlci5pc0J1ZmZlcmVkKG1lZGlhLG1lZGlhLmN1cnJlbnRUaW1lKSkge1xyXG4gICAgICAgIC8vIG9ubHkgbnVkZ2UgaWYgY3VycmVudFRpbWUgaXMgYnVmZmVyZWRcclxuICAgICAgICBtZWRpYS5jdXJyZW50VGltZSAtPSAwLjAwMDE7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKCF0aGlzLnByZXZpb3VzbHlQYXVzZWQpIHtcclxuICAgICAgICBtZWRpYS5wbGF5KCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIG5leHRMZXZlbFN3aXRjaCgpIHtcclxuICAgIC8qIHRyeSB0byBzd2l0Y2ggQVNBUCB3aXRob3V0IGJyZWFraW5nIHZpZGVvIHBsYXliYWNrIDpcclxuICAgICAgIGluIG9yZGVyIHRvIGVuc3VyZSBzbW9vdGggYnV0IHF1aWNrIGxldmVsIHN3aXRjaGluZyxcclxuICAgICAgd2UgbmVlZCB0byBmaW5kIHRoZSBuZXh0IGZsdXNoYWJsZSBidWZmZXIgcmFuZ2VcclxuICAgICAgd2Ugc2hvdWxkIHRha2UgaW50byBhY2NvdW50IG5ldyBzZWdtZW50IGZldGNoIHRpbWVcclxuICAgICovXHJcbiAgICBsZXQgbWVkaWEgPSB0aGlzLm1lZGlhO1xyXG4gICAgLy8gZW5zdXJlIHRoYXQgbWVkaWEgaXMgZGVmaW5lZCBhbmQgdGhhdCBtZXRhZGF0YSBhcmUgYXZhaWxhYmxlICh0byByZXRyaWV2ZSBjdXJyZW50VGltZSlcclxuICAgIGlmIChtZWRpYSAmJiBtZWRpYS5yZWFkeVN0YXRlKSB7XHJcbiAgICAgIGxldCBmZXRjaGRlbGF5LCBmcmFnUGxheWluZ0N1cnJlbnQsIG5leHRCdWZmZXJlZEZyYWc7XHJcbiAgICAgIC8vIGluY3JlYXNlIGZyYWdtZW50IGxvYWQgSW5kZXggdG8gYXZvaWQgZnJhZyBsb29wIGxvYWRpbmcgZXJyb3IgYWZ0ZXIgYnVmZmVyIGZsdXNoXHJcbiAgICAgIHRoaXMuZnJhZ0xvYWRJZHggKz0gMiAqIHRoaXMuY29uZmlnLmZyYWdMb2FkaW5nTG9vcFRocmVzaG9sZDtcclxuICAgICAgZnJhZ1BsYXlpbmdDdXJyZW50ID0gdGhpcy5nZXRCdWZmZXJlZEZyYWcobWVkaWEuY3VycmVudFRpbWUpO1xyXG4gICAgICBpZiAoZnJhZ1BsYXlpbmdDdXJyZW50ICYmIGZyYWdQbGF5aW5nQ3VycmVudC5zdGFydFBUUyA+IDEpIHtcclxuICAgICAgICAvLyBmbHVzaCBidWZmZXIgcHJlY2VkaW5nIGN1cnJlbnQgZnJhZ21lbnQgKGZsdXNoIHVudGlsIGN1cnJlbnQgZnJhZ21lbnQgc3RhcnQgb2Zmc2V0KVxyXG4gICAgICAgIC8vIG1pbnVzIDFzIHRvIGF2b2lkIHZpZGVvIGZyZWV6aW5nLCB0aGF0IGNvdWxkIGhhcHBlbiBpZiB3ZSBmbHVzaCBrZXlmcmFtZSBvZiBjdXJyZW50IHZpZGVvIC4uLlxyXG4gICAgICAgIHRoaXMuZmx1c2hNYWluQnVmZmVyKDAsZnJhZ1BsYXlpbmdDdXJyZW50LnN0YXJ0UFRTIC0gMSk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKCFtZWRpYS5wYXVzZWQpIHtcclxuICAgICAgICAvLyBhZGQgYSBzYWZldHkgZGVsYXkgb2YgMXNcclxuICAgICAgICB2YXIgbmV4dExldmVsSWQgPSB0aGlzLmhscy5uZXh0TG9hZExldmVsLG5leHRMZXZlbCA9IHRoaXMubGV2ZWxzW25leHRMZXZlbElkXSwgZnJhZ0xhc3RLYnBzID0gdGhpcy5mcmFnTGFzdEticHM7XHJcbiAgICAgICAgaWYgKGZyYWdMYXN0S2JwcyAmJiB0aGlzLmZyYWdDdXJyZW50KSB7XHJcbiAgICAgICAgICBmZXRjaGRlbGF5ID0gdGhpcy5mcmFnQ3VycmVudC5kdXJhdGlvbiAqIG5leHRMZXZlbC5iaXRyYXRlIC8gKDEwMDAgKiBmcmFnTGFzdEticHMpICsgMTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgZmV0Y2hkZWxheSA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGZldGNoZGVsYXkgPSAwO1xyXG4gICAgICB9XHJcbiAgICAgIC8vbG9nZ2VyLmxvZygnZmV0Y2hkZWxheTonK2ZldGNoZGVsYXkpO1xyXG4gICAgICAvLyBmaW5kIGJ1ZmZlciByYW5nZSB0aGF0IHdpbGwgYmUgcmVhY2hlZCBvbmNlIG5ldyBmcmFnbWVudCB3aWxsIGJlIGZldGNoZWRcclxuICAgICAgbmV4dEJ1ZmZlcmVkRnJhZyA9IHRoaXMuZ2V0QnVmZmVyZWRGcmFnKG1lZGlhLmN1cnJlbnRUaW1lICsgZmV0Y2hkZWxheSk7XHJcbiAgICAgIGlmIChuZXh0QnVmZmVyZWRGcmFnKSB7XHJcbiAgICAgICAgLy8gd2UgY2FuIGZsdXNoIGJ1ZmZlciByYW5nZSBmb2xsb3dpbmcgdGhpcyBvbmUgd2l0aG91dCBzdGFsbGluZyBwbGF5YmFja1xyXG4gICAgICAgIG5leHRCdWZmZXJlZEZyYWcgPSB0aGlzLmZvbGxvd2luZ0J1ZmZlcmVkRnJhZyhuZXh0QnVmZmVyZWRGcmFnKTtcclxuICAgICAgICBpZiAobmV4dEJ1ZmZlcmVkRnJhZykge1xyXG4gICAgICAgICAgLy8gaWYgd2UgYXJlIGhlcmUsIHdlIGNhbiBhbHNvIGNhbmNlbCBhbnkgbG9hZGluZy9kZW11eGluZyBpbiBwcm9ncmVzcywgYXMgdGhleSBhcmUgdXNlbGVzc1xyXG4gICAgICAgICAgdmFyIGZyYWdDdXJyZW50ID0gdGhpcy5mcmFnQ3VycmVudDtcclxuICAgICAgICAgIGlmIChmcmFnQ3VycmVudCAmJiBmcmFnQ3VycmVudC5sb2FkZXIpIHtcclxuICAgICAgICAgICAgZnJhZ0N1cnJlbnQubG9hZGVyLmFib3J0KCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICB0aGlzLmZyYWdDdXJyZW50ID0gbnVsbDtcclxuICAgICAgICAgIC8vIHN0YXJ0IGZsdXNoIHBvc2l0aW9uIGlzIHRoZSBzdGFydCBQVFMgb2YgbmV4dCBidWZmZXJlZCBmcmFnLlxyXG4gICAgICAgICAgLy8gd2UgdXNlIGZyYWcubmF4U3RhcnRQVFMgd2hpY2ggaXMgbWF4KGF1ZGlvIHN0YXJ0UFRTLCB2aWRlbyBzdGFydFBUUykuXHJcbiAgICAgICAgICAvLyBpbiBjYXNlIHRoZXJlIGlzIGEgc21hbGwgUFRTIERlbHRhIGJldHdlZW4gYXVkaW8gYW5kIHZpZGVvLCB1c2luZyBtYXhTdGFydFBUUyBhdm9pZHMgZmx1c2hpbmcgbGFzdCBzYW1wbGVzIGZyb20gY3VycmVudCBmcmFnbWVudFxyXG4gICAgICAgICAgdGhpcy5mbHVzaE1haW5CdWZmZXIobmV4dEJ1ZmZlcmVkRnJhZy5tYXhTdGFydFBUUyAsIE51bWJlci5QT1NJVElWRV9JTkZJTklUWSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmbHVzaE1haW5CdWZmZXIoc3RhcnRPZmZzZXQsZW5kT2Zmc2V0KSB7XHJcbiAgICB0aGlzLnN0YXRlID0gU3RhdGUuQlVGRkVSX0ZMVVNISU5HO1xyXG4gICAgbGV0IGZsdXNoU2NvcGUgPSB7c3RhcnRPZmZzZXQ6IHN0YXJ0T2Zmc2V0LCBlbmRPZmZzZXQ6IGVuZE9mZnNldH07XHJcbiAgICAvLyBpZiBhbHRlcm5hdGUgYXVkaW8gdHJhY2tzIGFyZSB1c2VkLCBvbmx5IGZsdXNoIHZpZGVvLCBvdGhlcndpc2UgZmx1c2ggZXZlcnl0aGluZ1xyXG4gICAgaWYgKHRoaXMuYWx0QXVkaW8pIHtcclxuICAgICAgZmx1c2hTY29wZS50eXBlID0gJ3ZpZGVvJztcclxuICAgIH1cclxuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuQlVGRkVSX0ZMVVNISU5HLCBmbHVzaFNjb3BlKTtcclxuICB9XHJcblxyXG4gIG9uTWVkaWFBdHRhY2hlZChkYXRhKSB7XHJcbiAgICB2YXIgbWVkaWEgPSB0aGlzLm1lZGlhID0gdGhpcy5tZWRpYUJ1ZmZlciA9IGRhdGEubWVkaWE7XHJcbiAgICB0aGlzLm9udnNlZWtpbmcgPSB0aGlzLm9uTWVkaWFTZWVraW5nLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzLm9udnNlZWtlZCA9IHRoaXMub25NZWRpYVNlZWtlZC5iaW5kKHRoaXMpO1xyXG4gICAgdGhpcy5vbnZlbmRlZCA9IHRoaXMub25NZWRpYUVuZGVkLmJpbmQodGhpcyk7XHJcbiAgICBtZWRpYS5hZGRFdmVudExpc3RlbmVyKCdzZWVraW5nJywgdGhpcy5vbnZzZWVraW5nKTtcclxuICAgIG1lZGlhLmFkZEV2ZW50TGlzdGVuZXIoJ3NlZWtlZCcsIHRoaXMub252c2Vla2VkKTtcclxuICAgIG1lZGlhLmFkZEV2ZW50TGlzdGVuZXIoJ2VuZGVkJywgdGhpcy5vbnZlbmRlZCk7XHJcbiAgICBsZXQgY29uZmlnID0gdGhpcy5jb25maWc7XHJcbiAgICBpZih0aGlzLmxldmVscyAmJiBjb25maWcuYXV0b1N0YXJ0TG9hZCkge1xyXG4gICAgICB0aGlzLmhscy5zdGFydExvYWQoY29uZmlnLnN0YXJ0UG9zaXRpb24pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgb25NZWRpYURldGFjaGluZygpIHtcclxuICAgIHZhciBtZWRpYSA9IHRoaXMubWVkaWE7XHJcbiAgICBpZiAobWVkaWEgJiYgbWVkaWEuZW5kZWQpIHtcclxuICAgICAgbG9nZ2VyLmxvZygnTVNFIGRldGFjaGluZyBhbmQgdmlkZW8gZW5kZWQsIHJlc2V0IHN0YXJ0UG9zaXRpb24nKTtcclxuICAgICAgdGhpcy5zdGFydFBvc2l0aW9uID0gdGhpcy5sYXN0Q3VycmVudFRpbWUgPSAwO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHJlc2V0IGZyYWdtZW50IGxvYWRpbmcgY291bnRlciBvbiBNU0UgZGV0YWNoaW5nIHRvIGF2b2lkIHJlcG9ydGluZyBGUkFHX0xPT1BfTE9BRElOR19FUlJPUiBhZnRlciBlcnJvciByZWNvdmVyeVxyXG4gICAgdmFyIGxldmVscyA9IHRoaXMubGV2ZWxzO1xyXG4gICAgaWYgKGxldmVscykge1xyXG4gICAgICAvLyByZXNldCBmcmFnbWVudCBsb2FkIGNvdW50ZXJcclxuICAgICAgICBsZXZlbHMuZm9yRWFjaChsZXZlbCA9PiB7XHJcbiAgICAgICAgICBpZihsZXZlbC5kZXRhaWxzKSB7XHJcbiAgICAgICAgICAgIGxldmVsLmRldGFpbHMuZnJhZ21lbnRzLmZvckVhY2goZnJhZ21lbnQgPT4ge1xyXG4gICAgICAgICAgICAgIGZyYWdtZW50LmxvYWRDb3VudGVyID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgIGZyYWdtZW50LmJhY2t0cmFja2VkID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvLyByZW1vdmUgdmlkZW8gbGlzdGVuZXJzXHJcbiAgICBpZiAobWVkaWEpIHtcclxuICAgICAgbWVkaWEucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Vla2luZycsIHRoaXMub252c2Vla2luZyk7XHJcbiAgICAgIG1lZGlhLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3NlZWtlZCcsIHRoaXMub252c2Vla2VkKTtcclxuICAgICAgbWVkaWEucmVtb3ZlRXZlbnRMaXN0ZW5lcignZW5kZWQnLCB0aGlzLm9udmVuZGVkKTtcclxuICAgICAgdGhpcy5vbnZzZWVraW5nID0gdGhpcy5vbnZzZWVrZWQgID0gdGhpcy5vbnZlbmRlZCA9IG51bGw7XHJcbiAgICB9XHJcbiAgICB0aGlzLm1lZGlhID0gdGhpcy5tZWRpYUJ1ZmZlciA9IG51bGw7XHJcbiAgICB0aGlzLmxvYWRlZG1ldGFkYXRhID0gZmFsc2U7XHJcbiAgICB0aGlzLnN0b3BMb2FkKCk7XHJcbiAgfVxyXG5cclxuICBvbk1lZGlhU2Vla2luZygpIHtcclxuICAgIGxldCBtZWRpYSA9IHRoaXMubWVkaWEsIGN1cnJlbnRUaW1lID0gbWVkaWEgPyBtZWRpYS5jdXJyZW50VGltZSA6IHVuZGVmaW5lZCwgY29uZmlnID0gdGhpcy5jb25maWc7XHJcbiAgICBpZiAoIWlzTmFOKGN1cnJlbnRUaW1lKSkge1xyXG4gICAgICBsb2dnZXIubG9nKGBtZWRpYSBzZWVraW5nIHRvICR7Y3VycmVudFRpbWUudG9GaXhlZCgzKX1gKTtcclxuICAgIH1cclxuICAgIGxldCBtZWRpYUJ1ZmZlciA9IHRoaXMubWVkaWFCdWZmZXIgPyB0aGlzLm1lZGlhQnVmZmVyIDogbWVkaWE7XHJcbiAgICBsZXQgYnVmZmVySW5mbyA9IEJ1ZmZlckhlbHBlci5idWZmZXJJbmZvKG1lZGlhQnVmZmVyLGN1cnJlbnRUaW1lLHRoaXMuY29uZmlnLm1heEJ1ZmZlckhvbGUpO1xyXG4gICAgaWYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLkZSQUdfTE9BRElORykge1xyXG4gICAgICBsZXQgZnJhZ0N1cnJlbnQgPSB0aGlzLmZyYWdDdXJyZW50O1xyXG4gICAgICAvLyBjaGVjayBpZiB3ZSBhcmUgc2Vla2luZyB0byBhIHVuYnVmZmVyZWQgYXJlYSBBTkQgaWYgZnJhZyBsb2FkaW5nIGlzIGluIHByb2dyZXNzXHJcbiAgICAgIGlmIChidWZmZXJJbmZvLmxlbiA9PT0gMCAmJiBmcmFnQ3VycmVudCkge1xyXG4gICAgICAgIGxldCB0b2xlcmFuY2UgPSBjb25maWcubWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSxcclxuICAgICAgICAgICAgZnJhZ1N0YXJ0T2Zmc2V0ID0gZnJhZ0N1cnJlbnQuc3RhcnQgLSB0b2xlcmFuY2UsXHJcbiAgICAgICAgICAgIGZyYWdFbmRPZmZzZXQgPSBmcmFnQ3VycmVudC5zdGFydCArIGZyYWdDdXJyZW50LmR1cmF0aW9uICsgdG9sZXJhbmNlO1xyXG4gICAgICAgIC8vIGNoZWNrIGlmIHdlIHNlZWsgcG9zaXRpb24gd2lsbCBiZSBvdXQgb2YgY3VycmVudGx5IGxvYWRlZCBmcmFnIHJhbmdlIDogaWYgb3V0IGNhbmNlbCBmcmFnIGxvYWQsIGlmIGluLCBkb24ndCBkbyBhbnl0aGluZ1xyXG4gICAgICAgIGlmIChjdXJyZW50VGltZSA8IGZyYWdTdGFydE9mZnNldCB8fCBjdXJyZW50VGltZSA+IGZyYWdFbmRPZmZzZXQpIHtcclxuICAgICAgICAgIGlmIChmcmFnQ3VycmVudC5sb2FkZXIpIHtcclxuICAgICAgICAgICAgbG9nZ2VyLmxvZygnc2Vla2luZyBvdXRzaWRlIG9mIGJ1ZmZlciB3aGlsZSBmcmFnbWVudCBsb2FkIGluIHByb2dyZXNzLCBjYW5jZWwgZnJhZ21lbnQgbG9hZCcpO1xyXG4gICAgICAgICAgICBmcmFnQ3VycmVudC5sb2FkZXIuYWJvcnQoKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHRoaXMuZnJhZ0N1cnJlbnQgPSBudWxsO1xyXG4gICAgICAgICAgdGhpcy5mcmFnUHJldmlvdXMgPSBudWxsO1xyXG4gICAgICAgICAgLy8gc3dpdGNoIHRvIElETEUgc3RhdGUgdG8gbG9hZCBuZXcgZnJhZ21lbnRcclxuICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBsb2dnZXIubG9nKCdzZWVraW5nIG91dHNpZGUgb2YgYnVmZmVyIGJ1dCB3aXRoaW4gY3VycmVudGx5IGxvYWRlZCBmcmFnbWVudCByYW5nZScpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmICh0aGlzLnN0YXRlID09PSBTdGF0ZS5FTkRFRCkge1xyXG4gICAgICAgIC8vIGlmIHNlZWtpbmcgdG8gdW5idWZmZXJlZCBhcmVhLCBjbGVhbiB1cCBmcmFnUHJldmlvdXNcclxuICAgICAgICBpZiAoYnVmZmVySW5mby5sZW4gPT09IDApIHtcclxuICAgICAgICAgIHRoaXMuZnJhZ1ByZXZpb3VzID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gc3dpdGNoIHRvIElETEUgc3RhdGUgdG8gY2hlY2sgZm9yIHBvdGVudGlhbCBuZXcgZnJhZ21lbnRcclxuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcclxuICAgIH1cclxuICAgIGlmIChtZWRpYSkge1xyXG4gICAgICB0aGlzLmxhc3RDdXJyZW50VGltZSA9IGN1cnJlbnRUaW1lO1xyXG4gICAgfVxyXG4gICAgLy8gYXZvaWQgcmVwb3J0aW5nIGZyYWdtZW50IGxvb3AgbG9hZGluZyBlcnJvciBpbiBjYXNlIHVzZXIgaXMgc2Vla2luZyBzZXZlcmFsIHRpbWVzIG9uIHNhbWUgcG9zaXRpb25cclxuICAgIGlmICh0aGlzLnN0YXRlICE9PSBTdGF0ZS5GUkFHX0xPQURJTkcgJiYgdGhpcy5mcmFnTG9hZElkeCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHRoaXMuZnJhZ0xvYWRJZHggKz0gMiAqIGNvbmZpZy5mcmFnTG9hZGluZ0xvb3BUaHJlc2hvbGQ7XHJcbiAgICB9XHJcbiAgICAvLyBpbiBjYXNlIHNlZWtpbmcgb2NjdXJzIGFsdGhvdWdoIG5vIG1lZGlhIGJ1ZmZlcmVkLCBhZGp1c3Qgc3RhcnRQb3NpdGlvbiBhbmQgbmV4dExvYWRQb3NpdGlvbiB0byBzZWVrIHRhcmdldFxyXG4gICAgaWYoIXRoaXMubG9hZGVkbWV0YWRhdGEpIHtcclxuICAgICAgdGhpcy5uZXh0TG9hZFBvc2l0aW9uID0gdGhpcy5zdGFydFBvc2l0aW9uID0gY3VycmVudFRpbWU7XHJcbiAgICB9XHJcbiAgICAvLyB0aWNrIHRvIHNwZWVkIHVwIHByb2Nlc3NpbmdcclxuICAgIHRoaXMudGljaygpO1xyXG4gIH1cclxuXHJcbiAgb25NZWRpYVNlZWtlZCgpIHtcclxuICAgIGNvbnN0IG1lZGlhID0gdGhpcy5tZWRpYSwgY3VycmVudFRpbWUgPSBtZWRpYSA/IG1lZGlhLmN1cnJlbnRUaW1lIDogdW5kZWZpbmVkO1xyXG4gICAgaWYgKCFpc05hTihjdXJyZW50VGltZSkpIHtcclxuICAgICAgbG9nZ2VyLmxvZyhgbWVkaWEgc2Vla2VkIHRvICR7Y3VycmVudFRpbWUudG9GaXhlZCgzKX1gKTtcclxuICAgIH1cclxuICAgIC8vIHRpY2sgdG8gc3BlZWQgdXAgRlJBR01FTlRfUExBWUlORyB0cmlnZ2VyaW5nXHJcbiAgICB0aGlzLnRpY2soKTtcclxuICB9XHJcblxyXG4gIG9uTWVkaWFFbmRlZCgpIHtcclxuICAgIGxvZ2dlci5sb2coJ21lZGlhIGVuZGVkJyk7XHJcbiAgICAvLyByZXNldCBzdGFydFBvc2l0aW9uIGFuZCBsYXN0Q3VycmVudFRpbWUgdG8gcmVzdGFydCBwbGF5YmFjayBAIHN0cmVhbSBiZWdpbm5pbmdcclxuICAgIHRoaXMuc3RhcnRQb3NpdGlvbiA9IHRoaXMubGFzdEN1cnJlbnRUaW1lID0gMDtcclxuICB9XHJcblxyXG5cclxuICBvbk1hbmlmZXN0TG9hZGluZygpIHtcclxuICAgIC8vIHJlc2V0IGJ1ZmZlciBvbiBtYW5pZmVzdCBsb2FkaW5nXHJcbiAgICBsb2dnZXIubG9nKCd0cmlnZ2VyIEJVRkZFUl9SRVNFVCcpO1xyXG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5CVUZGRVJfUkVTRVQpO1xyXG4gICAgdGhpcy5fYnVmZmVyZWRGcmFncyA9IFtdO1xyXG4gICAgdGhpcy5zdGFsbGVkID0gZmFsc2U7XHJcbiAgICB0aGlzLnN0YXJ0UG9zaXRpb24gPSB0aGlzLmxhc3RDdXJyZW50VGltZSA9IDA7XHJcbiAgfVxyXG5cclxuICBvbk1hbmlmZXN0UGFyc2VkKGRhdGEpIHtcclxuICAgIHZhciBhYWMgPSBmYWxzZSwgaGVhYWMgPSBmYWxzZSwgY29kZWM7XHJcbiAgICBkYXRhLmxldmVscy5mb3JFYWNoKGxldmVsID0+IHtcclxuICAgICAgLy8gZGV0ZWN0IGlmIHdlIGhhdmUgZGlmZmVyZW50IGtpbmQgb2YgYXVkaW8gY29kZWNzIHVzZWQgYW1vbmdzdCBwbGF5bGlzdHNcclxuICAgICAgY29kZWMgPSBsZXZlbC5hdWRpb0NvZGVjO1xyXG4gICAgICBpZiAoY29kZWMpIHtcclxuICAgICAgICBpZiAoY29kZWMuaW5kZXhPZignbXA0YS40MC4yJykgIT09IC0xKSB7XHJcbiAgICAgICAgICBhYWMgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY29kZWMuaW5kZXhPZignbXA0YS40MC41JykgIT09IC0xKSB7XHJcbiAgICAgICAgICBoZWFhYyA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICAgIHRoaXMuYXVkaW9Db2RlY1N3aXRjaCA9IChhYWMgJiYgaGVhYWMpO1xyXG4gICAgaWYgKHRoaXMuYXVkaW9Db2RlY1N3aXRjaCkge1xyXG4gICAgICBsb2dnZXIubG9nKCdib3RoIEFBQy9IRS1BQUMgYXVkaW8gZm91bmQgaW4gbGV2ZWxzOyBkZWNsYXJpbmcgbGV2ZWwgY29kZWMgYXMgSEUtQUFDJyk7XHJcbiAgICB9XHJcbiAgICB0aGlzLmxldmVscyA9IGRhdGEubGV2ZWxzO1xyXG4gICAgdGhpcy5zdGFydExldmVsTG9hZGVkID0gZmFsc2U7XHJcbiAgICB0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCA9IGZhbHNlO1xyXG4gICAgbGV0IGNvbmZpZyA9IHRoaXMuY29uZmlnO1xyXG4gICAgaWYgKGNvbmZpZy5hdXRvU3RhcnRMb2FkIHx8IHRoaXMuZm9yY2VTdGFydExvYWQpIHtcclxuICAgICAgdGhpcy5obHMuc3RhcnRMb2FkKGNvbmZpZy5zdGFydFBvc2l0aW9uKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIG9uTGV2ZWxMb2FkZWQoZGF0YSkge1xyXG4gICAgdmFyIG5ld0RldGFpbHMgPSBkYXRhLmRldGFpbHMsXHJcbiAgICAgICAgbmV3TGV2ZWxJZCA9IGRhdGEubGV2ZWwsXHJcbiAgICAgICAgY3VyTGV2ZWwgPSB0aGlzLmxldmVsc1tuZXdMZXZlbElkXSxcclxuICAgICAgICBkdXJhdGlvbiA9IG5ld0RldGFpbHMudG90YWxkdXJhdGlvbixcclxuICAgICAgICBzbGlkaW5nID0gMDtcclxuXHJcbiAgICBsb2dnZXIubG9nKGBsZXZlbCAke25ld0xldmVsSWR9IGxvYWRlZCBbJHtuZXdEZXRhaWxzLnN0YXJ0U059LCR7bmV3RGV0YWlscy5lbmRTTn1dLGR1cmF0aW9uOiR7ZHVyYXRpb259YCk7XHJcbiAgICB0aGlzLmxldmVsTGFzdExvYWRlZCA9IG5ld0xldmVsSWQ7XHJcblxyXG4gICAgaWYgKG5ld0RldGFpbHMubGl2ZSkge1xyXG4gICAgICB2YXIgY3VyRGV0YWlscyA9IGN1ckxldmVsLmRldGFpbHM7XHJcbiAgICAgIGlmIChjdXJEZXRhaWxzICYmIG5ld0RldGFpbHMuZnJhZ21lbnRzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAvLyB3ZSBhbHJlYWR5IGhhdmUgZGV0YWlscyBmb3IgdGhhdCBsZXZlbCwgbWVyZ2UgdGhlbVxyXG4gICAgICAgIExldmVsSGVscGVyLm1lcmdlRGV0YWlscyhjdXJEZXRhaWxzLG5ld0RldGFpbHMpO1xyXG4gICAgICAgIHNsaWRpbmcgPSBuZXdEZXRhaWxzLmZyYWdtZW50c1swXS5zdGFydDtcclxuICAgICAgICB0aGlzLmxpdmVTeW5jUG9zaXRpb24gPSB0aGlzLmNvbXB1dGVMaXZlUG9zaXRpb24oc2xpZGluZywgY3VyRGV0YWlscyk7XHJcbiAgICAgICAgaWYgKG5ld0RldGFpbHMuUFRTS25vd24pIHtcclxuICAgICAgICAgIGxvZ2dlci5sb2coYGxpdmUgcGxheWxpc3Qgc2xpZGluZzoke3NsaWRpbmcudG9GaXhlZCgzKX1gKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgbG9nZ2VyLmxvZygnbGl2ZSBwbGF5bGlzdCAtIG91dGRhdGVkIFBUUywgdW5rbm93biBzbGlkaW5nJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIG5ld0RldGFpbHMuUFRTS25vd24gPSBmYWxzZTtcclxuICAgICAgICBsb2dnZXIubG9nKCdsaXZlIHBsYXlsaXN0IC0gZmlyc3QgbG9hZCwgdW5rbm93biBzbGlkaW5nJyk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIG5ld0RldGFpbHMuUFRTS25vd24gPSBmYWxzZTtcclxuICAgIH1cclxuICAgIC8vIG92ZXJyaWRlIGxldmVsIGluZm9cclxuICAgIGN1ckxldmVsLmRldGFpbHMgPSBuZXdEZXRhaWxzO1xyXG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5MRVZFTF9VUERBVEVELCB7IGRldGFpbHM6IG5ld0RldGFpbHMsIGxldmVsOiBuZXdMZXZlbElkIH0pO1xyXG5cclxuICAgIGlmICh0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCA9PT0gZmFsc2UpIHtcclxuICAgIC8vIGNvbXB1dGUgc3RhcnQgcG9zaXRpb24gaWYgc2V0IHRvIC0xLiB1c2UgaXQgc3RyYWlnaHQgYXdheSBpZiB2YWx1ZSBpcyBkZWZpbmVkXHJcbiAgICAgIGlmICh0aGlzLnN0YXJ0UG9zaXRpb24gPT09IC0xIHx8wqB0aGlzLmxhc3RDdXJyZW50VGltZSA9PT0gLTEpIHtcclxuICAgICAgICAvLyBmaXJzdCwgY2hlY2sgaWYgc3RhcnQgdGltZSBvZmZzZXQgaGFzIGJlZW4gc2V0IGluIHBsYXlsaXN0LCBpZiB5ZXMsIHVzZSB0aGlzIHZhbHVlXHJcbiAgICAgICAgbGV0IHN0YXJ0VGltZU9mZnNldCA9IG5ld0RldGFpbHMuc3RhcnRUaW1lT2Zmc2V0O1xyXG4gICAgICAgIGlmKCFpc05hTihzdGFydFRpbWVPZmZzZXQpKSB7XHJcbiAgICAgICAgICBpZiAoc3RhcnRUaW1lT2Zmc2V0IDwgMCkge1xyXG4gICAgICAgICAgICBsb2dnZXIubG9nKGBuZWdhdGl2ZSBzdGFydCB0aW1lIG9mZnNldCAke3N0YXJ0VGltZU9mZnNldH0sIGNvdW50IGZyb20gZW5kIG9mIGxhc3QgZnJhZ21lbnRgKTtcclxuICAgICAgICAgICAgc3RhcnRUaW1lT2Zmc2V0ID0gc2xpZGluZyArIGR1cmF0aW9uICsgc3RhcnRUaW1lT2Zmc2V0O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgbG9nZ2VyLmxvZyhgc3RhcnQgdGltZSBvZmZzZXQgZm91bmQgaW4gcGxheWxpc3QsIGFkanVzdCBzdGFydFBvc2l0aW9uIHRvICR7c3RhcnRUaW1lT2Zmc2V0fWApO1xyXG4gICAgICAgICAgdGhpcy5zdGFydFBvc2l0aW9uID0gc3RhcnRUaW1lT2Zmc2V0O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAvLyBpZiBsaXZlIHBsYXlsaXN0LCBzZXQgc3RhcnQgcG9zaXRpb24gdG8gYmUgZnJhZ21lbnQgTi10aGlzLmNvbmZpZy5saXZlU3luY0R1cmF0aW9uQ291bnQgKHVzdWFsbHkgMylcclxuICAgICAgICAgIGlmIChuZXdEZXRhaWxzLmxpdmUpIHtcclxuICAgICAgICAgICAgdGhpcy5zdGFydFBvc2l0aW9uID0gdGhpcy5jb21wdXRlTGl2ZVBvc2l0aW9uKHNsaWRpbmcsIG5ld0RldGFpbHMpO1xyXG4gICAgICAgICAgICBsb2dnZXIubG9nKGBjb25maWd1cmUgc3RhcnRQb3NpdGlvbiB0byAke3RoaXMuc3RhcnRQb3NpdGlvbn1gKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhcnRQb3NpdGlvbiA9IDA7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubGFzdEN1cnJlbnRUaW1lID0gdGhpcy5zdGFydFBvc2l0aW9uO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMubmV4dExvYWRQb3NpdGlvbiA9IHRoaXMuc3RhcnRQb3NpdGlvbjtcclxuICAgIH1cclxuICAgIC8vIG9ubHkgc3dpdGNoIGJhdGNrIHRvIElETEUgc3RhdGUgaWYgd2Ugd2VyZSB3YWl0aW5nIGZvciBsZXZlbCB0byBzdGFydCBkb3dubG9hZGluZyBhIG5ldyBmcmFnbWVudFxyXG4gICAgaWYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLldBSVRJTkdfTEVWRUwpIHtcclxuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XHJcbiAgICB9XHJcbiAgICAvL3RyaWdnZXIgaGFuZGxlciByaWdodCBub3dcclxuICAgIHRoaXMudGljaygpO1xyXG4gIH1cclxuXHJcbiAgb25LZXlMb2FkZWQoKSB7XHJcbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuS0VZX0xPQURJTkcpIHtcclxuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XHJcbiAgICAgIHRoaXMudGljaygpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgb25GcmFnTG9hZGVkKGRhdGEpIHtcclxuICAgIHZhciBmcmFnQ3VycmVudCA9IHRoaXMuZnJhZ0N1cnJlbnQsXHJcbiAgICAgICAgZnJhZ0xvYWRlZCA9IGRhdGEuZnJhZztcclxuICAgIGlmICh0aGlzLnN0YXRlID09PSBTdGF0ZS5GUkFHX0xPQURJTkcgJiZcclxuICAgICAgICBmcmFnQ3VycmVudCAmJlxyXG4gICAgICAgIGZyYWdMb2FkZWQudHlwZSA9PT0gJ21haW4nICYmXHJcbiAgICAgICAgZnJhZ0xvYWRlZC5sZXZlbCA9PT0gZnJhZ0N1cnJlbnQubGV2ZWwgJiZcclxuICAgICAgICBmcmFnTG9hZGVkLnNuID09PSBmcmFnQ3VycmVudC5zbikge1xyXG4gICAgICBsZXQgc3RhdHMgPSBkYXRhLnN0YXRzLFxyXG4gICAgICAgICAgY3VycmVudExldmVsID0gdGhpcy5sZXZlbHNbZnJhZ0N1cnJlbnQubGV2ZWxdLFxyXG4gICAgICAgICAgZGV0YWlscyA9IGN1cnJlbnRMZXZlbC5kZXRhaWxzO1xyXG4gICAgICBsb2dnZXIubG9nKGBMb2FkZWQgICR7ZnJhZ0N1cnJlbnQuc259IG9mIFske2RldGFpbHMuc3RhcnRTTn0gLCR7ZGV0YWlscy5lbmRTTn1dLGxldmVsICR7ZnJhZ0N1cnJlbnQubGV2ZWx9YCk7XHJcbiAgICAgIC8vIHJlc2V0IGZyYWcgYml0cmF0ZSB0ZXN0IGluIGFueSBjYXNlIGFmdGVyIGZyYWcgbG9hZGVkIGV2ZW50XHJcbiAgICAgIHRoaXMuYml0cmF0ZVRlc3QgPSBmYWxzZTtcclxuICAgICAgdGhpcy5zdGF0cyA9IHN0YXRzO1xyXG4gICAgICAvLyBpZiB0aGlzIGZyYWcgd2FzIGxvYWRlZCB0byBwZXJmb3JtIGEgYml0cmF0ZSB0ZXN0IEFORCBpZiBobHMubmV4dExvYWRMZXZlbCBpcyBncmVhdGVyIHRoYW4gMFxyXG4gICAgICAvLyB0aGVuIHRoaXMgbWVhbnMgdGhhdCB3ZSBzaG91bGQgYmUgYWJsZSB0byBsb2FkIGEgZnJhZ21lbnQgYXQgYSBoaWdoZXIgcXVhbGl0eSBsZXZlbFxyXG4gICAgICBpZiAoZnJhZ0xvYWRlZC5iaXRyYXRlVGVzdCA9PT0gdHJ1ZSAmJiB0aGlzLmhscy5uZXh0TG9hZExldmVsKSB7XHJcbiAgICAgICAgLy8gc3dpdGNoIGJhY2sgdG8gSURMRSBzdGF0ZSAuLi4gd2UganVzdCBsb2FkZWQgYSBmcmFnbWVudCB0byBkZXRlcm1pbmUgYWRlcXVhdGUgc3RhcnQgYml0cmF0ZSBhbmQgaW5pdGlhbGl6ZSBhdXRvc3dpdGNoIGFsZ29cclxuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcclxuICAgICAgICB0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCA9IGZhbHNlO1xyXG4gICAgICAgIHN0YXRzLnRwYXJzZWQgPSBzdGF0cy50YnVmZmVyZWQgPSBwZXJmb3JtYW5jZS5ub3coKTtcclxuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkZSQUdfQlVGRkVSRUQsIHtzdGF0czogc3RhdHMsIGZyYWc6IGZyYWdDdXJyZW50LCBpZCA6ICdtYWluJ30pO1xyXG4gICAgICAgIHRoaXMudGljaygpO1xyXG4gICAgICB9IGVsc2UgaWYgKGZyYWdMb2FkZWQuc24gPT09ICdpbml0U2VnbWVudCcpIHtcclxuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcclxuICAgICAgICBzdGF0cy50cGFyc2VkID0gc3RhdHMudGJ1ZmZlcmVkID0gcGVyZm9ybWFuY2Uubm93KCk7XHJcbiAgICAgICAgZGV0YWlscy5pbml0U2VnbWVudC5kYXRhID0gZGF0YS5wYXlsb2FkO1xyXG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuRlJBR19CVUZGRVJFRCwge3N0YXRzOiBzdGF0cywgZnJhZzogZnJhZ0N1cnJlbnQsIGlkIDogJ21haW4nfSk7XHJcbiAgICAgICAgdGhpcy50aWNrKCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLlBBUlNJTkc7XHJcbiAgICAgICAgLy8gdHJhbnNtdXggdGhlIE1QRUctVFMgZGF0YSB0byBJU08tQk1GRiBzZWdtZW50c1xyXG4gICAgICAgIGxldCBkdXJhdGlvbiA9IGRldGFpbHMudG90YWxkdXJhdGlvbixcclxuICAgICAgICAgICAgbGV2ZWwgPSBmcmFnQ3VycmVudC5sZXZlbCxcclxuICAgICAgICAgICAgc24gPSBmcmFnQ3VycmVudC5zbixcclxuICAgICAgICAgICAgYXVkaW9Db2RlYyA9IHRoaXMuY29uZmlnLmRlZmF1bHRBdWRpb0NvZGVjIHx8IGN1cnJlbnRMZXZlbC5hdWRpb0NvZGVjO1xyXG4gICAgICAgIGlmKHRoaXMuYXVkaW9Db2RlY1N3YXApIHtcclxuICAgICAgICAgIGxvZ2dlci5sb2coJ3N3YXBwaW5nIHBsYXlsaXN0IGF1ZGlvIGNvZGVjJyk7XHJcbiAgICAgICAgICBpZihhdWRpb0NvZGVjID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgYXVkaW9Db2RlYyA9IHRoaXMubGFzdEF1ZGlvQ29kZWM7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZihhdWRpb0NvZGVjKSB7XHJcbiAgICAgICAgICAgIGlmKGF1ZGlvQ29kZWMuaW5kZXhPZignbXA0YS40MC41JykgIT09LTEpIHtcclxuICAgICAgICAgICAgICBhdWRpb0NvZGVjID0gJ21wNGEuNDAuMic7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgYXVkaW9Db2RlYyA9ICdtcDRhLjQwLjUnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucGVuZGluZ0J1ZmZlcmluZyA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5hcHBlbmRlZCA9IGZhbHNlO1xyXG4gICAgICAgIGxvZ2dlci5sb2coYFBhcnNpbmcgJHtzbn0gb2YgWyR7ZGV0YWlscy5zdGFydFNOfSAsJHtkZXRhaWxzLmVuZFNOfV0sbGV2ZWwgJHtsZXZlbH0sIGNjICR7ZnJhZ0N1cnJlbnQuY2N9YCk7XHJcbiAgICAgICAgbGV0IGRlbXV4ZXIgPSB0aGlzLmRlbXV4ZXI7XHJcbiAgICAgICAgaWYgKCFkZW11eGVyKSB7XHJcbiAgICAgICAgICBkZW11eGVyID0gdGhpcy5kZW11eGVyID0gbmV3IERlbXV4ZXIodGhpcy5obHMsJ21haW4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gdGltZSBPZmZzZXQgaXMgYWNjdXJhdGUgaWYgbGV2ZWwgUFRTIGlzIGtub3duLCBvciBpZiBwbGF5bGlzdCBpcyBub3Qgc2xpZGluZyAobm90IGxpdmUpIGFuZCBpZiBtZWRpYSBpcyBub3Qgc2Vla2luZyAodGhpcyBpcyB0byBvdmVyY29tZSBwb3RlbnRpYWwgdGltZXN0YW1wIGRyaWZ0cyBiZXR3ZWVuIHBsYXlsaXN0cyBhbmQgZnJhZ21lbnRzKVxyXG4gICAgICAgIGxldCBtZWRpYSA9IHRoaXMubWVkaWE7XHJcbiAgICAgICAgbGV0IG1lZGlhU2Vla2luZyA9IG1lZGlhICYmIG1lZGlhLnNlZWtpbmc7XHJcbiAgICAgICAgbGV0IGFjY3VyYXRlVGltZU9mZnNldCA9ICFtZWRpYVNlZWtpbmcgJiYgKGRldGFpbHMuUFRTS25vd24gfHwgIWRldGFpbHMubGl2ZSk7XHJcbiAgICAgICAgbGV0IGluaXRTZWdtZW50RGF0YSA9IGRldGFpbHMuaW5pdFNlZ21lbnQgPyBkZXRhaWxzLmluaXRTZWdtZW50LmRhdGEgOiBbXTtcclxuICAgICAgICBkZW11eGVyLnB1c2goZGF0YS5wYXlsb2FkLCBpbml0U2VnbWVudERhdGEsYXVkaW9Db2RlYywgY3VycmVudExldmVsLnZpZGVvQ29kZWMsIGZyYWdDdXJyZW50LCBkdXJhdGlvbiwgYWNjdXJhdGVUaW1lT2Zmc2V0LHVuZGVmaW5lZCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHRoaXMuZnJhZ0xvYWRFcnJvciA9IDA7XHJcbiAgfVxyXG5cclxuICBvbkZyYWdQYXJzaW5nSW5pdFNlZ21lbnQoZGF0YSkge1xyXG4gICAgY29uc3QgZnJhZ0N1cnJlbnQgPSB0aGlzLmZyYWdDdXJyZW50O1xyXG4gICAgY29uc3QgZnJhZ05ldyA9IGRhdGEuZnJhZztcclxuICAgIGlmIChmcmFnQ3VycmVudCAmJlxyXG4gICAgICAgIGRhdGEuaWQgPT09ICdtYWluJyAmJlxyXG4gICAgICAgIGZyYWdOZXcuc24gPT09IGZyYWdDdXJyZW50LnNuICYmXHJcbiAgICAgICAgZnJhZ05ldy5sZXZlbCA9PT0gZnJhZ0N1cnJlbnQubGV2ZWwgJiZcclxuICAgICAgICB0aGlzLnN0YXRlID09PSBTdGF0ZS5QQVJTSU5HKSB7XHJcbiAgICAgIHZhciB0cmFja3MgPSBkYXRhLnRyYWNrcywgdHJhY2tOYW1lLCB0cmFjaztcclxuXHJcbiAgICAgIC8vIGlmIGF1ZGlvIHRyYWNrIGlzIGV4cGVjdGVkIHRvIGNvbWUgZnJvbSBhdWRpbyBzdHJlYW0gY29udHJvbGxlciwgZGlzY2FyZCBhbnkgY29taW5nIGZyb20gbWFpblxyXG4gICAgICBpZiAodHJhY2tzLmF1ZGlvICYmIHRoaXMuYWx0QXVkaW8pIHtcclxuICAgICAgICBkZWxldGUgdHJhY2tzLmF1ZGlvO1xyXG4gICAgICB9XHJcbiAgICAgIC8vIGluY2x1ZGUgbGV2ZWxDb2RlYyBpbiBhdWRpbyBhbmQgdmlkZW8gdHJhY2tzXHJcbiAgICAgIHRyYWNrID0gdHJhY2tzLmF1ZGlvO1xyXG4gICAgICBpZih0cmFjaykge1xyXG4gICAgICAgIHZhciBhdWRpb0NvZGVjID0gdGhpcy5sZXZlbHNbdGhpcy5sZXZlbF0uYXVkaW9Db2RlYyxcclxuICAgICAgICAgICAgdWEgPSBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgaWYoYXVkaW9Db2RlYyAmJiB0aGlzLmF1ZGlvQ29kZWNTd2FwKSB7XHJcbiAgICAgICAgICBsb2dnZXIubG9nKCdzd2FwcGluZyBwbGF5bGlzdCBhdWRpbyBjb2RlYycpO1xyXG4gICAgICAgICAgaWYoYXVkaW9Db2RlYy5pbmRleE9mKCdtcDRhLjQwLjUnKSAhPT0tMSkge1xyXG4gICAgICAgICAgICBhdWRpb0NvZGVjID0gJ21wNGEuNDAuMic7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBhdWRpb0NvZGVjID0gJ21wNGEuNDAuNSc7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGluIGNhc2UgQUFDIGFuZCBIRS1BQUMgYXVkaW8gY29kZWNzIGFyZSBzaWduYWxsZWQgaW4gbWFuaWZlc3RcclxuICAgICAgICAvLyBmb3JjZSBIRS1BQUMgLCBhcyBpdCBzZWVtcyB0aGF0IG1vc3QgYnJvd3NlcnMgcHJlZmVycyB0aGF0IHdheSxcclxuICAgICAgICAvLyBleGNlcHQgZm9yIG1vbm8gc3RyZWFtcyBPUiBvbiBGRlxyXG4gICAgICAgIC8vIHRoZXNlIGNvbmRpdGlvbnMgbWlnaHQgbmVlZCB0byBiZSByZXZpZXdlZCAuLi5cclxuICAgICAgICBpZiAodGhpcy5hdWRpb0NvZGVjU3dpdGNoKSB7XHJcbiAgICAgICAgICAgIC8vIGRvbid0IGZvcmNlIEhFLUFBQyBpZiBtb25vIHN0cmVhbVxyXG4gICAgICAgICAgIGlmKHRyYWNrLm1ldGFkYXRhLmNoYW5uZWxDb3VudCAhPT0gMSAmJlxyXG4gICAgICAgICAgICAvLyBkb24ndCBmb3JjZSBIRS1BQUMgaWYgZmlyZWZveFxyXG4gICAgICAgICAgICB1YS5pbmRleE9mKCdmaXJlZm94JykgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgYXVkaW9Db2RlYyA9ICdtcDRhLjQwLjUnO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBIRS1BQUMgaXMgYnJva2VuIG9uIEFuZHJvaWQsIGFsd2F5cyBzaWduYWwgYXVkaW8gY29kZWMgYXMgQUFDIGV2ZW4gaWYgdmFyaWFudCBtYW5pZmVzdCBzdGF0ZXMgb3RoZXJ3aXNlXHJcbiAgICAgICAgaWYodWEuaW5kZXhPZignYW5kcm9pZCcpICE9PSAtMSAmJiB0cmFjay5jb250YWluZXIgIT09ICdhdWRpby9tcGVnJykgeyAvLyBFeGNsdWRlIG1wZWcgYXVkaW9cclxuICAgICAgICAgIGF1ZGlvQ29kZWMgPSAnbXA0YS40MC4yJztcclxuICAgICAgICAgIGxvZ2dlci5sb2coYEFuZHJvaWQ6IGZvcmNlIGF1ZGlvIGNvZGVjIHRvICR7YXVkaW9Db2RlY31gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdHJhY2subGV2ZWxDb2RlYyA9IGF1ZGlvQ29kZWM7XHJcbiAgICAgICAgdHJhY2suaWQgPSBkYXRhLmlkO1xyXG4gICAgICB9XHJcbiAgICAgIHRyYWNrID0gdHJhY2tzLnZpZGVvO1xyXG4gICAgICBpZih0cmFjaykge1xyXG4gICAgICAgIHRyYWNrLmxldmVsQ29kZWMgPSB0aGlzLmxldmVsc1t0aGlzLmxldmVsXS52aWRlb0NvZGVjO1xyXG4gICAgICAgIHRyYWNrLmlkID0gZGF0YS5pZDtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkJVRkZFUl9DT0RFQ1MsdHJhY2tzKTtcclxuICAgICAgLy8gbG9vcCB0aHJvdWdoIHRyYWNrcyB0aGF0IGFyZSBnb2luZyB0byBiZSBwcm92aWRlZCB0byBidWZmZXJDb250cm9sbGVyXHJcbiAgICAgIGZvciAodHJhY2tOYW1lIGluIHRyYWNrcykge1xyXG4gICAgICAgIHRyYWNrID0gdHJhY2tzW3RyYWNrTmFtZV07XHJcbiAgICAgICAgbG9nZ2VyLmxvZyhgbWFpbiB0cmFjazoke3RyYWNrTmFtZX0sY29udGFpbmVyOiR7dHJhY2suY29udGFpbmVyfSxjb2RlY3NbbGV2ZWwvcGFyc2VkXT1bJHt0cmFjay5sZXZlbENvZGVjfS8ke3RyYWNrLmNvZGVjfV1gKTtcclxuICAgICAgICB2YXIgaW5pdFNlZ21lbnQgPSB0cmFjay5pbml0U2VnbWVudDtcclxuICAgICAgICBpZiAoaW5pdFNlZ21lbnQpIHtcclxuICAgICAgICAgIHRoaXMuYXBwZW5kZWQgPSB0cnVlO1xyXG4gICAgICAgICAgLy8gYXJtIHBlbmRpbmcgQnVmZmVyaW5nIGZsYWcgYmVmb3JlIGFwcGVuZGluZyBhIHNlZ21lbnRcclxuICAgICAgICAgIHRoaXMucGVuZGluZ0J1ZmZlcmluZyA9IHRydWU7XHJcbiAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkJVRkZFUl9BUFBFTkRJTkcsIHt0eXBlOiB0cmFja05hbWUsIGRhdGE6IGluaXRTZWdtZW50LCBwYXJlbnQgOiAnbWFpbicsIGNvbnRlbnQgOiAnaW5pdFNlZ21lbnQnfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIC8vdHJpZ2dlciBoYW5kbGVyIHJpZ2h0IG5vd1xyXG4gICAgICB0aGlzLnRpY2soKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIG9uRnJhZ1BhcnNpbmdEYXRhKGRhdGEpIHtcclxuICAgIGNvbnN0IGZyYWdDdXJyZW50ID0gdGhpcy5mcmFnQ3VycmVudDtcclxuICAgIGNvbnN0IGZyYWdOZXcgPSBkYXRhLmZyYWc7XHJcbiAgICBpZiAoZnJhZ0N1cnJlbnQgJiZcclxuICAgICAgICBkYXRhLmlkID09PSAnbWFpbicgJiZcclxuICAgICAgICBmcmFnTmV3LnNuID09PSBmcmFnQ3VycmVudC5zbiAmJlxyXG4gICAgICAgIGZyYWdOZXcubGV2ZWwgPT09IGZyYWdDdXJyZW50LmxldmVsICYmXHJcbiAgICAgICAgIShkYXRhLnR5cGUgPT09ICdhdWRpbycgJiYgdGhpcy5hbHRBdWRpbykgJiYgLy8gZmlsdGVyIG91dCBtYWluIGF1ZGlvIGlmIGF1ZGlvIHRyYWNrIGlzIGxvYWRlZCB0aHJvdWdoIGF1ZGlvIHN0cmVhbSBjb250cm9sbGVyXHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9PT0gU3RhdGUuUEFSU0lORykge1xyXG4gICAgICB2YXIgbGV2ZWwgPSB0aGlzLmxldmVsc1t0aGlzLmxldmVsXSxcclxuICAgICAgICAgIGZyYWcgPSBmcmFnQ3VycmVudDtcclxuICAgICAgICAgIGlmIChpc05hTihkYXRhLmVuZFBUUykpIHtcclxuICAgICAgICAgICAgZGF0YS5lbmRQVFMgPSBkYXRhLnN0YXJ0UFRTICsgZnJhZ0N1cnJlbnQuZHVyYXRpb247XHJcbiAgICAgICAgICAgIGRhdGEuZW5kRFRTID0gZGF0YS5zdGFydERUUyArIGZyYWdDdXJyZW50LmR1cmF0aW9uO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgbG9nZ2VyLmxvZyhgUGFyc2VkICR7ZGF0YS50eXBlfSxQVFM6WyR7ZGF0YS5zdGFydFBUUy50b0ZpeGVkKDMpfSwke2RhdGEuZW5kUFRTLnRvRml4ZWQoMyl9XSxEVFM6WyR7ZGF0YS5zdGFydERUUy50b0ZpeGVkKDMpfS8ke2RhdGEuZW5kRFRTLnRvRml4ZWQoMyl9XSxuYjoke2RhdGEubmJ9LGRyb3BwZWQ6JHtkYXRhLmRyb3BwZWQgfHwgMH1gKTtcclxuXHJcbiAgICAgIC8vIERldGVjdCBnYXBzIGluIGEgZnJhZ21lbnQgIGFuZCB0cnkgdG8gZml4IGl0IGJ5IGZpbmRpbmcgYSBrZXlmcmFtZSBpbiB0aGUgcHJldmlvdXMgZnJhZ21lbnQgKHNlZSBfZmluZEZyYWdtZW50cylcclxuICAgICAgaWYoZGF0YS50eXBlID09PSAndmlkZW8nKSB7XHJcbiAgICAgICAgZnJhZy5kcm9wcGVkID0gZGF0YS5kcm9wcGVkO1xyXG4gICAgICAgIGlmIChmcmFnLmRyb3BwZWQpIHtcclxuICAgICAgICAgIGlmICghZnJhZy5iYWNrdHJhY2tlZCkge1xyXG4gICAgICAgICAgICBsb2dnZXIud2FybignbWlzc2luZyB2aWRlbyBmcmFtZShzKSwgYmFja3RyYWNraW5nIGZyYWdtZW50Jyk7XHJcbiAgICAgICAgICAgIC8vIFJldHVybiBiYWNrIHRvIHRoZSBJRExFIHN0YXRlIHdpdGhvdXQgYXBwZW5kaW5nIHRvIGJ1ZmZlclxyXG4gICAgICAgICAgICAvLyBDYXVzZXMgZmluZEZyYWdtZW50cyB0byBiYWNrdHJhY2sgYSBzZWdtZW50IGFuZCBmaW5kIHRoZSBrZXlmcmFtZVxyXG4gICAgICAgICAgICAvLyBBdWRpbyBmcmFnbWVudHMgYXJyaXZpbmcgYmVmb3JlIHZpZGVvIHNldHMgdGhlIG5leHRMb2FkUG9zaXRpb24sIGNhdXNpbmcgX2ZpbmRGcmFnbWVudHMgdG8gc2tpcCB0aGUgYmFja3RyYWNrZWQgZnJhZ21lbnRcclxuICAgICAgICAgICAgZnJhZy5iYWNrdHJhY2tlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMubmV4dExvYWRQb3NpdGlvbiA9IGRhdGEuc3RhcnRQVFM7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xyXG4gICAgICAgICAgICB0aGlzLmZyYWdQcmV2aW91cyA9IGZyYWc7XHJcbiAgICAgICAgICAgIHRoaXMudGljaygpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBsb2dnZXIud2FybignQWxyZWFkeSBiYWNrdHJhY2tlZCBvbiB0aGlzIGZyYWdtZW50LCBhcHBlbmRpbmcgd2l0aCB0aGUgZ2FwJyk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIC8vIE9ubHkgcmVzZXQgdGhlIGJhY2t0cmFja2VkIGZsYWcgaWYgd2UndmUgbG9hZGVkIHRoZSBmcmFnIHdpdGhvdXQgYW55IGRyb3BwZWQgZnJhbWVzXHJcbiAgICAgICAgICBmcmFnLmJhY2t0cmFja2VkID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgZHJpZnQgPSBMZXZlbEhlbHBlci51cGRhdGVGcmFnUFRTRFRTKGxldmVsLmRldGFpbHMsZnJhZyxkYXRhLnN0YXJ0UFRTLGRhdGEuZW5kUFRTLGRhdGEuc3RhcnREVFMsZGF0YS5lbmREVFMpLFxyXG4gICAgICAgICAgaGxzID0gdGhpcy5obHM7XHJcbiAgICAgIGhscy50cmlnZ2VyKEV2ZW50LkxFVkVMX1BUU19VUERBVEVELCB7ZGV0YWlsczogbGV2ZWwuZGV0YWlscywgbGV2ZWw6IHRoaXMubGV2ZWwsIGRyaWZ0OiBkcmlmdCwgdHlwZTogZGF0YS50eXBlLCBzdGFydDogZGF0YS5zdGFydFBUUywgZW5kOiBkYXRhLmVuZFBUU30pO1xyXG5cclxuICAgICAgLy8gaGFzIHJlbXV4ZXIgZHJvcHBlZCB2aWRlbyBmcmFtZXMgbG9jYXRlZCBiZWZvcmUgZmlyc3Qga2V5ZnJhbWUgP1xyXG4gICAgICBbZGF0YS5kYXRhMSwgZGF0YS5kYXRhMl0uZm9yRWFjaChidWZmZXIgPT4ge1xyXG4gICAgICAgIC8vIG9ubHkgYXBwZW5kIGluIFBBUlNJTkcgc3RhdGUgKHJhdGlvbmFsZSBpcyB0aGF0IGFuIGFwcGVuZGluZyBlcnJvciBjb3VsZCBoYXBwZW4gc3luY2hyb25vdXNseSBvbiBmaXJzdCBzZWdtZW50IGFwcGVuZGluZylcclxuICAgICAgICAvLyBpbiB0aGF0IGNhc2UgaXQgaXMgdXNlbGVzcyB0byBhcHBlbmQgZm9sbG93aW5nIHNlZ21lbnRzXHJcbiAgICAgICAgaWYgKGJ1ZmZlciAmJiBidWZmZXIubGVuZ3RoICYmIHRoaXMuc3RhdGUgPT09IFN0YXRlLlBBUlNJTkcpIHtcclxuICAgICAgICAgIHRoaXMuYXBwZW5kZWQgPSB0cnVlO1xyXG4gICAgICAgICAgLy8gYXJtIHBlbmRpbmcgQnVmZmVyaW5nIGZsYWcgYmVmb3JlIGFwcGVuZGluZyBhIHNlZ21lbnRcclxuICAgICAgICAgIHRoaXMucGVuZGluZ0J1ZmZlcmluZyA9IHRydWU7XHJcbiAgICAgICAgICBobHMudHJpZ2dlcihFdmVudC5CVUZGRVJfQVBQRU5ESU5HLCB7dHlwZTogZGF0YS50eXBlLCBkYXRhOiBidWZmZXIsIHBhcmVudCA6ICdtYWluJyxjb250ZW50IDogJ2RhdGEnfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgICAgLy90cmlnZ2VyIGhhbmRsZXIgcmlnaHQgbm93XHJcbiAgICAgIHRoaXMudGljaygpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgb25GcmFnUGFyc2VkKGRhdGEpIHtcclxuICAgIGNvbnN0IGZyYWdDdXJyZW50ID0gdGhpcy5mcmFnQ3VycmVudDtcclxuICAgIGNvbnN0IGZyYWdOZXcgPSBkYXRhLmZyYWc7XHJcbiAgICBpZiAoZnJhZ0N1cnJlbnQgJiZcclxuICAgICAgICBkYXRhLmlkID09PSAnbWFpbicgJiZcclxuICAgICAgICBmcmFnTmV3LnNuID09PSBmcmFnQ3VycmVudC5zbiAmJlxyXG4gICAgICAgIGZyYWdOZXcubGV2ZWwgPT09IGZyYWdDdXJyZW50LmxldmVsICYmXHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9PT0gU3RhdGUuUEFSU0lORykge1xyXG4gICAgICB0aGlzLnN0YXRzLnRwYXJzZWQgPSBwZXJmb3JtYW5jZS5ub3coKTtcclxuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLlBBUlNFRDtcclxuICAgICAgdGhpcy5fY2hlY2tBcHBlbmRlZFBhcnNlZCgpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgb25BdWRpb1RyYWNrU3dpdGNoaW5nKGRhdGEpIHtcclxuICAgIC8vIGlmIGFueSBVUkwgZm91bmQgb24gbmV3IGF1ZGlvIHRyYWNrLCBpdCBpcyBhbiBhbHRlcm5hdGUgYXVkaW8gdHJhY2tcclxuICAgIHZhciBhbHRBdWRpbyA9ICEhZGF0YS51cmwsXHJcbiAgICAgICAgdHJhY2tJZCA9IGRhdGEuaWQ7XHJcbiAgICAvLyBpZiB3ZSBzd2l0Y2ggb24gbWFpbiBhdWRpbywgZW5zdXJlIHRoYXQgbWFpbiBmcmFnbWVudCBzY2hlZHVsaW5nIGlzIHN5bmNlZCB3aXRoIG1lZGlhLmJ1ZmZlcmVkXHJcbiAgICAvLyBkb24ndCBkbyBhbnl0aGluZyBpZiB3ZSBzd2l0Y2ggdG8gYWx0IGF1ZGlvOiBhdWRpbyBzdHJlYW0gY29udHJvbGxlciBpcyBoYW5kbGluZyBpdC5cclxuICAgIC8vIHdlIHdpbGwganVzdCBoYXZlIHRvIGNoYW5nZSBidWZmZXIgc2NoZWR1bGluZyBvbiBhdWRpb1RyYWNrU3dpdGNoZWRcclxuICAgIGlmICghYWx0QXVkaW8pIHtcclxuICAgICAgaWYgKHRoaXMubWVkaWFCdWZmZXIgIT09IHRoaXMubWVkaWEpIHtcclxuICAgICAgICBsb2dnZXIubG9nKGBzd2l0Y2hpbmcgb24gbWFpbiBhdWRpbywgdXNlIG1lZGlhLmJ1ZmZlcmVkIHRvIHNjaGVkdWxlIG1haW4gZnJhZ21lbnQgbG9hZGluZ2ApO1xyXG4gICAgICAgIHRoaXMubWVkaWFCdWZmZXIgPSB0aGlzLm1lZGlhO1xyXG4gICAgICAgIGxldCBmcmFnQ3VycmVudCA9IHRoaXMuZnJhZ0N1cnJlbnQ7XHJcbiAgICAgICAgLy8gd2UgbmVlZCB0byByZWZpbGwgYXVkaW8gYnVmZmVyIGZyb20gbWFpbjogY2FuY2VsIGFueSBmcmFnIGxvYWRpbmcgdG8gc3BlZWQgdXAgYXVkaW8gc3dpdGNoXHJcbiAgICAgICAgaWYgKGZyYWdDdXJyZW50LmxvYWRlcikge1xyXG4gICAgICAgICAgbG9nZ2VyLmxvZygnc3dpdGNoaW5nIHRvIG1haW4gYXVkaW8gdHJhY2ssIGNhbmNlbCBtYWluIGZyYWdtZW50IGxvYWQnKTtcclxuICAgICAgICAgIGZyYWdDdXJyZW50LmxvYWRlci5hYm9ydCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmZyYWdDdXJyZW50ID0gbnVsbDtcclxuICAgICAgICB0aGlzLmZyYWdQcmV2aW91cyA9IG51bGw7XHJcbiAgICAgICAgLy8gZGVzdHJveSBkZW11eGVyIHRvIGZvcmNlIGluaXQgc2VnbWVudCBnZW5lcmF0aW9uIChmb2xsb3dpbmcgYXVkaW8gc3dpdGNoKVxyXG4gICAgICAgIGlmICh0aGlzLmRlbXV4ZXIpIHtcclxuICAgICAgICAgIHRoaXMuZGVtdXhlci5kZXN0cm95KCk7XHJcbiAgICAgICAgICB0aGlzLmRlbXV4ZXIgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBzd2l0Y2ggdG8gSURMRSBzdGF0ZSB0byBsb2FkIG5ldyBmcmFnbWVudFxyXG4gICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xyXG4gICAgICB9XHJcbiAgICAgIGxldCBobHMgPSB0aGlzLmhscztcclxuICAgICAgLy8gc3dpdGNoaW5nIHRvIG1haW4gYXVkaW8sIGZsdXNoIGFsbCBhdWRpbyBhbmQgdHJpZ2dlciB0cmFjayBzd2l0Y2hlZFxyXG4gICAgICBobHMudHJpZ2dlcihFdmVudC5CVUZGRVJfRkxVU0hJTkcsIHtzdGFydE9mZnNldDogMCAsIGVuZE9mZnNldDogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLCB0eXBlIDogJ2F1ZGlvJ30pO1xyXG4gICAgICBobHMudHJpZ2dlcihFdmVudC5BVURJT19UUkFDS19TV0lUQ0hFRCwge2lkIDogdHJhY2tJZH0pO1xyXG4gICAgICB0aGlzLmFsdEF1ZGlvID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBvbkF1ZGlvVHJhY2tTd2l0Y2hlZChkYXRhKSB7XHJcbiAgICB2YXIgdHJhY2tJZCA9IGRhdGEuaWQsXHJcbiAgICBhbHRBdWRpbyA9ICEhdGhpcy5obHMuYXVkaW9UcmFja3NbdHJhY2tJZF0udXJsO1xyXG4gICAgaWYgKGFsdEF1ZGlvKSB7XHJcbiAgICAgIGxldCB2aWRlb0J1ZmZlciA9IHRoaXMudmlkZW9CdWZmZXI7XHJcbiAgICAgIC8vIGlmIHdlIHN3aXRjaGVkIG9uIGFsdGVybmF0ZSBhdWRpbywgZW5zdXJlIHRoYXQgbWFpbiBmcmFnbWVudCBzY2hlZHVsaW5nIGlzIHN5bmNlZCB3aXRoIHZpZGVvIHNvdXJjZWJ1ZmZlciBidWZmZXJlZFxyXG4gICAgICBpZiAodmlkZW9CdWZmZXIgJiYgdGhpcy5tZWRpYUJ1ZmZlciAhPT0gdmlkZW9CdWZmZXIpIHtcclxuICAgICAgICBsb2dnZXIubG9nKGBzd2l0Y2hpbmcgb24gYWx0ZXJuYXRlIGF1ZGlvLCB1c2UgdmlkZW8uYnVmZmVyZWQgdG8gc2NoZWR1bGUgbWFpbiBmcmFnbWVudCBsb2FkaW5nYCk7XHJcbiAgICAgICAgdGhpcy5tZWRpYUJ1ZmZlciA9IHZpZGVvQnVmZmVyO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICB0aGlzLmFsdEF1ZGlvID0gYWx0QXVkaW87XHJcbiAgICB0aGlzLnRpY2soKTtcclxuICB9XHJcblxyXG5cclxuXHJcbiAgb25CdWZmZXJDcmVhdGVkKGRhdGEpIHtcclxuICAgIGxldCB0cmFja3MgPSBkYXRhLnRyYWNrcywgbWVkaWFUcmFjaywgbmFtZSwgYWx0ZXJuYXRlID0gZmFsc2U7XHJcbiAgICBmb3IodmFyIHR5cGUgaW4gdHJhY2tzKSB7XHJcbiAgICAgIGxldCB0cmFjayA9IHRyYWNrc1t0eXBlXTtcclxuICAgICAgaWYgKHRyYWNrLmlkID09PSAnbWFpbicpIHtcclxuICAgICAgICBuYW1lID0gdHlwZTtcclxuICAgICAgICBtZWRpYVRyYWNrID0gdHJhY2s7XHJcbiAgICAgICAgLy8ga2VlcCB2aWRlbyBzb3VyY2UgYnVmZmVyIHJlZmVyZW5jZVxyXG4gICAgICAgIGlmICh0eXBlID09PSAndmlkZW8nKSB7XHJcbiAgICAgICAgICB0aGlzLnZpZGVvQnVmZmVyID0gdHJhY2tzW3R5cGVdLmJ1ZmZlcjtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgYWx0ZXJuYXRlID0gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGFsdGVybmF0ZSAmJiBtZWRpYVRyYWNrKSB7XHJcbiAgICAgIGxvZ2dlci5sb2coYGFsdGVybmF0ZSB0cmFjayBmb3VuZCwgdXNlICR7bmFtZX0uYnVmZmVyZWQgdG8gc2NoZWR1bGUgbWFpbiBmcmFnbWVudCBsb2FkaW5nYCk7XHJcbiAgICAgIHRoaXMubWVkaWFCdWZmZXIgPSBtZWRpYVRyYWNrLmJ1ZmZlcjtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMubWVkaWFCdWZmZXIgPSB0aGlzLm1lZGlhO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgb25CdWZmZXJBcHBlbmRlZChkYXRhKSB7XHJcbiAgICBpZiAoZGF0YS5wYXJlbnQgPT09ICdtYWluJykge1xyXG4gICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuc3RhdGU7XHJcbiAgICAgIGlmIChzdGF0ZSA9PT0gU3RhdGUuUEFSU0lORyB8fCBzdGF0ZSA9PT0gU3RhdGUuUEFSU0VEKSB7XHJcbiAgICAgICAgLy8gY2hlY2sgaWYgYWxsIGJ1ZmZlcnMgaGF2ZSBiZWVuIGFwcGVuZGVkXHJcbiAgICAgICAgdGhpcy5wZW5kaW5nQnVmZmVyaW5nID0gKGRhdGEucGVuZGluZyA+IDApO1xyXG4gICAgICAgIHRoaXMuX2NoZWNrQXBwZW5kZWRQYXJzZWQoKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgX2NoZWNrQXBwZW5kZWRQYXJzZWQoKSB7XHJcbiAgICAvL3RyaWdnZXIgaGFuZGxlciByaWdodCBub3dcclxuICAgIGlmICh0aGlzLnN0YXRlID09PSBTdGF0ZS5QQVJTRUQgJiYgKCF0aGlzLmFwcGVuZGVkIHx8ICF0aGlzLnBlbmRpbmdCdWZmZXJpbmcpKSB7XHJcbiAgICAgIGNvbnN0IGZyYWcgPSB0aGlzLmZyYWdDdXJyZW50O1xyXG4gICAgICBpZiAoZnJhZykge1xyXG4gICAgICAgIGNvbnN0IG1lZGlhID0gdGhpcy5tZWRpYUJ1ZmZlciA/IHRoaXMubWVkaWFCdWZmZXIgOiB0aGlzLm1lZGlhO1xyXG4gICAgICAgIGxvZ2dlci5sb2coYG1haW4gYnVmZmVyZWQgOiAke1RpbWVSYW5nZXMudG9TdHJpbmcobWVkaWEuYnVmZmVyZWQpfWApO1xyXG4gICAgICAgIC8vIGZpbHRlciBmcmFnbWVudHMgcG90ZW50aWFsbHkgZXZpY3RlZCBmcm9tIGJ1ZmZlci4gdGhpcyBpcyB0byBhdm9pZCBtZW1sZWFrIG9uIGxpdmUgc3RyZWFtc1xyXG4gICAgICAgIGxldCBidWZmZXJlZEZyYWdzID0gdGhpcy5fYnVmZmVyZWRGcmFncy5maWx0ZXIoZnJhZyA9PiB7cmV0dXJuIEJ1ZmZlckhlbHBlci5pc0J1ZmZlcmVkKG1lZGlhLChmcmFnLnN0YXJ0UFRTICsgZnJhZy5lbmRQVFMpIC8gMik7fSk7XHJcbiAgICAgICAgLy8gcHVzaCBuZXcgcmFuZ2VcclxuICAgICAgICBidWZmZXJlZEZyYWdzLnB1c2goZnJhZyk7XHJcbiAgICAgICAgLy8gc29ydCBmcmFncywgYXMgd2UgdXNlIEJpbmFyeVNlYXJjaCBmb3IgbG9va3VwIGluIGdldEJ1ZmZlcmVkRnJhZyAuLi5cclxuICAgICAgICB0aGlzLl9idWZmZXJlZEZyYWdzID0gYnVmZmVyZWRGcmFncy5zb3J0KGZ1bmN0aW9uKGEsYikge3JldHVybiAoYS5zdGFydFBUUyAtIGIuc3RhcnRQVFMpO30pO1xyXG4gICAgICAgIHRoaXMuZnJhZ1ByZXZpb3VzID0gZnJhZztcclxuICAgICAgICBjb25zdCBzdGF0cyA9IHRoaXMuc3RhdHM7XHJcbiAgICAgICAgc3RhdHMudGJ1ZmZlcmVkID0gcGVyZm9ybWFuY2Uubm93KCk7XHJcbiAgICAgICAgLy8gd2Ugc2hvdWxkIGdldCByaWQgb2YgdGhpcy5mcmFnTGFzdEticHNcclxuICAgICAgICB0aGlzLmZyYWdMYXN0S2JwcyA9IE1hdGgucm91bmQoOCAqIHN0YXRzLnRvdGFsIC8gKHN0YXRzLnRidWZmZXJlZCAtIHN0YXRzLnRmaXJzdCkpO1xyXG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuRlJBR19CVUZGRVJFRCwge3N0YXRzOiBzdGF0cywgZnJhZzogZnJhZywgaWQgOiAnbWFpbid9KTtcclxuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLnRpY2soKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIG9uRXJyb3IoZGF0YSkge1xyXG4gICAgbGV0IGZyYWcgPSBkYXRhLmZyYWcgfHzCoHRoaXMuZnJhZ0N1cnJlbnQ7XHJcbiAgICAvLyBkb24ndCBoYW5kbGUgZnJhZyBlcnJvciBub3QgcmVsYXRlZCB0byBtYWluIGZyYWdtZW50XHJcbiAgICBpZiAoZnJhZyAmJiBmcmFnLnR5cGUgIT09ICdtYWluJykge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBsZXQgbWVkaWEgPSB0aGlzLm1lZGlhLFxyXG4gICAgICAgIC8vIDAuNSA6IHRvbGVyYW5jZSBuZWVkZWQgYXMgc29tZSBicm93c2VycyBzdGFsbHMgcGxheWJhY2sgYmVmb3JlIHJlYWNoaW5nIGJ1ZmZlcmVkIGVuZFxyXG4gICAgICAgIG1lZGlhQnVmZmVyZWQgPSBtZWRpYSAmJiBCdWZmZXJIZWxwZXIuaXNCdWZmZXJlZChtZWRpYSxtZWRpYS5jdXJyZW50VGltZSkgJiYgQnVmZmVySGVscGVyLmlzQnVmZmVyZWQobWVkaWEsbWVkaWEuY3VycmVudFRpbWUrMC41KTtcclxuICAgIHN3aXRjaChkYXRhLmRldGFpbHMpIHtcclxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuRlJBR19MT0FEX0VSUk9SOlxyXG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5GUkFHX0xPQURfVElNRU9VVDpcclxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuS0VZX0xPQURfRVJST1I6XHJcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLktFWV9MT0FEX1RJTUVPVVQ6XHJcbiAgICAgICAgaWYoIWRhdGEuZmF0YWwpIHtcclxuICAgICAgICAgIHZhciBsb2FkRXJyb3IgPSB0aGlzLmZyYWdMb2FkRXJyb3I7XHJcbiAgICAgICAgICBpZihsb2FkRXJyb3IpIHtcclxuICAgICAgICAgICAgbG9hZEVycm9yKys7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBsb2FkRXJyb3I9MTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGxldCBjb25maWcgPSB0aGlzLmNvbmZpZztcclxuICAgICAgICAgIC8vIGtlZXAgcmV0cnlpbmcgLyBkb24ndCByYWlzZSBmYXRhbCBuZXR3b3JrIGVycm9yIGlmIGN1cnJlbnQgcG9zaXRpb24gaXMgYnVmZmVyZWQgb3IgaWYgaW4gYXV0b21vZGUgd2l0aCBjdXJyZW50IGxldmVsIG5vdCAwXHJcbiAgICAgICAgICBpZiAobG9hZEVycm9yIDw9IGNvbmZpZy5mcmFnTG9hZGluZ01heFJldHJ5IHx8IG1lZGlhQnVmZmVyZWQgfHwgKGZyYWcuYXV0b0xldmVsICYmIGZyYWcubGV2ZWwpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZnJhZ0xvYWRFcnJvciA9IGxvYWRFcnJvcjtcclxuICAgICAgICAgICAgLy8gcmVzZXQgbG9hZCBjb3VudGVyIHRvIGF2b2lkIGZyYWcgbG9vcCBsb2FkaW5nIGVycm9yXHJcbiAgICAgICAgICAgIGZyYWcubG9hZENvdW50ZXIgPSAwO1xyXG4gICAgICAgICAgICAvLyBleHBvbmVudGlhbCBiYWNrb2ZmIGNhcHBlZCB0byBjb25maWcuZnJhZ0xvYWRpbmdNYXhSZXRyeVRpbWVvdXRcclxuICAgICAgICAgICAgdmFyIGRlbGF5ID0gTWF0aC5taW4oTWF0aC5wb3coMixsb2FkRXJyb3ItMSkqY29uZmlnLmZyYWdMb2FkaW5nUmV0cnlEZWxheSxjb25maWcuZnJhZ0xvYWRpbmdNYXhSZXRyeVRpbWVvdXQpO1xyXG4gICAgICAgICAgICBsb2dnZXIud2FybihgbWVkaWFDb250cm9sbGVyOiBmcmFnIGxvYWRpbmcgZmFpbGVkLCByZXRyeSBpbiAke2RlbGF5fSBtc2ApO1xyXG4gICAgICAgICAgICB0aGlzLnJldHJ5RGF0ZSA9IHBlcmZvcm1hbmNlLm5vdygpICsgZGVsYXk7XHJcbiAgICAgICAgICAgIC8vIHJldHJ5IGxvYWRpbmcgc3RhdGVcclxuICAgICAgICAgICAgLy8gaWYgbG9hZGVkbWV0YWRhdGEgaXMgbm90IHNldCwgaXQgbWVhbnMgdGhhdCB3ZSBhcmUgZW1lcmdlbmN5IHN3aXRjaCBkb3duIG9uIGZpcnN0IGZyYWdcclxuICAgICAgICAgICAgLy8gaW4gdGhhdCBjYXNlLCByZXNldCBzdGFydEZyYWdSZXF1ZXN0ZWQgZmxhZ1xyXG4gICAgICAgICAgICBpZighdGhpcy5sb2FkZWRtZXRhZGF0YSkge1xyXG4gICAgICAgICAgICAgIHRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgdGhpcy5uZXh0TG9hZFBvc2l0aW9uID0gdGhpcy5zdGFydFBvc2l0aW9uO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5GUkFHX0xPQURJTkdfV0FJVElOR19SRVRSWTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcihgbWVkaWFDb250cm9sbGVyOiAke2RhdGEuZGV0YWlsc30gcmVhY2hlcyBtYXggcmV0cnksIHJlZGlzcGF0Y2ggYXMgZmF0YWwgLi4uYCk7XHJcbiAgICAgICAgICAgIC8vIHN3aXRjaCBlcnJvciB0byBmYXRhbFxyXG4gICAgICAgICAgICBkYXRhLmZhdGFsID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkVSUk9SO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuRlJBR19MT09QX0xPQURJTkdfRVJST1I6XHJcbiAgICAgICAgaWYoIWRhdGEuZmF0YWwpIHtcclxuICAgICAgICAgIC8vIGlmIGJ1ZmZlciBpcyBub3QgZW1wdHlcclxuICAgICAgICAgIGlmIChtZWRpYUJ1ZmZlcmVkKSB7XHJcbiAgICAgICAgICAgIC8vIHRyeSB0byByZWR1Y2UgbWF4IGJ1ZmZlciBsZW5ndGggOiByYXRpb25hbGUgaXMgdGhhdCB3ZSBjb3VsZCBnZXRcclxuICAgICAgICAgICAgLy8gZnJhZyBsb29wIGxvYWRpbmcgZXJyb3IgYmVjYXVzZSBvZiBidWZmZXIgZXZpY3Rpb25cclxuICAgICAgICAgICAgdGhpcy5fcmVkdWNlTWF4QnVmZmVyTGVuZ3RoKGZyYWcuZHVyYXRpb24pO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIGJ1ZmZlciBlbXB0eS4gcmVwb3J0IGFzIGZhdGFsIGlmIGluIG1hbnVhbCBtb2RlIG9yIGlmIGxvd2VzdCBsZXZlbC5cclxuICAgICAgICAgICAgLy8gbGV2ZWwgY29udHJvbGxlciB0YWtlcyBjYXJlIG9mIGVtZXJnZW5jeSBzd2l0Y2ggZG93biBsb2dpY1xyXG4gICAgICAgICAgICBpZiAoIWZyYWcuYXV0b0xldmVsIHx8IGZyYWcubGV2ZWwgPT09IDApIHtcclxuICAgICAgICAgICAgICAvLyBzd2l0Y2ggZXJyb3IgdG8gZmF0YWxcclxuICAgICAgICAgICAgICBkYXRhLmZhdGFsID0gdHJ1ZTtcclxuICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuRVJST1I7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkxFVkVMX0xPQURfRVJST1I6XHJcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkxFVkVMX0xPQURfVElNRU9VVDpcclxuICAgICAgICBpZih0aGlzLnN0YXRlICE9PSBTdGF0ZS5FUlJPUikge1xyXG4gICAgICAgICAgaWYgKGRhdGEuZmF0YWwpIHtcclxuICAgICAgICAgICAvLyBpZiBmYXRhbCBlcnJvciwgc3RvcCBwcm9jZXNzaW5nXHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5FUlJPUjtcclxuICAgICAgICAgICAgbG9nZ2VyLndhcm4oYHN0cmVhbUNvbnRyb2xsZXI6ICR7ZGF0YS5kZXRhaWxzfSxzd2l0Y2ggdG8gJHt0aGlzLnN0YXRlfSBzdGF0ZSAuLi5gKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIGluIGNhc2Ugb2Ygbm9uIGZhdGFsIGVycm9yIHdoaWxlIGxvYWRpbmcgbGV2ZWwsIGlmIGxldmVsIGNvbnRyb2xsZXIgaXMgbm90IHJldHJ5aW5nIHRvIGxvYWQgbGV2ZWwgLCBzd2l0Y2ggYmFjayB0byBJRExFXHJcbiAgICAgICAgICAgIGlmICghZGF0YS5sZXZlbFJldHJ5ICYmIHRoaXMuc3RhdGUgPT09IFN0YXRlLldBSVRJTkdfTEVWRUwpIHtcclxuICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuQlVGRkVSX0ZVTExfRVJST1I6XHJcbiAgICAgICAgLy8gaWYgaW4gYXBwZW5kaW5nIHN0YXRlXHJcbiAgICAgICAgaWYgKGRhdGEucGFyZW50ID09PSAnbWFpbicgJiYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLlBBUlNJTkcgfHzCoHRoaXMuc3RhdGUgPT09IFN0YXRlLlBBUlNFRCkpIHtcclxuICAgICAgICAgIC8vIHJlZHVjZSBtYXggYnVmIGxlbiBpZiBjdXJyZW50IHBvc2l0aW9uIGlzIGJ1ZmZlcmVkXHJcbiAgICAgICAgICBpZiAobWVkaWFCdWZmZXJlZCkge1xyXG4gICAgICAgICAgICB0aGlzLl9yZWR1Y2VNYXhCdWZmZXJMZW5ndGgodGhpcy5jb25maWcubWF4QnVmZmVyTGVuZ3RoKTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBjdXJyZW50IHBvc2l0aW9uIGlzIG5vdCBidWZmZXJlZCwgYnV0IGJyb3dzZXIgaXMgc3RpbGwgY29tcGxhaW5pbmcgYWJvdXQgYnVmZmVyIGZ1bGwgZXJyb3JcclxuICAgICAgICAgICAgLy8gdGhpcyBoYXBwZW5zIG9uIElFL0VkZ2UsIHJlZmVyIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS92aWRlby1kZXYvaGxzLmpzL3B1bGwvNzA4XHJcbiAgICAgICAgICAgIC8vIGluIHRoYXQgY2FzZSBmbHVzaCB0aGUgd2hvbGUgYnVmZmVyIHRvIHJlY292ZXJcclxuICAgICAgICAgICAgbG9nZ2VyLndhcm4oJ2J1ZmZlciBmdWxsIGVycm9yIGFsc28gbWVkaWEuY3VycmVudFRpbWUgaXMgbm90IGJ1ZmZlcmVkLCBmbHVzaCBldmVyeXRoaW5nJyk7XHJcbiAgICAgICAgICAgIHRoaXMuZnJhZ0N1cnJlbnQgPSBudWxsO1xyXG4gICAgICAgICAgICAvLyBmbHVzaCBldmVyeXRoaW5nXHJcbiAgICAgICAgICAgIHRoaXMuZmx1c2hNYWluQnVmZmVyKDAsTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBfcmVkdWNlTWF4QnVmZmVyTGVuZ3RoKG1pbkxlbmd0aCkge1xyXG4gICAgbGV0IGNvbmZpZyA9IHRoaXMuY29uZmlnO1xyXG4gICAgaWYgKGNvbmZpZy5tYXhNYXhCdWZmZXJMZW5ndGggPj0gbWluTGVuZ3RoKSB7XHJcbiAgICAgIC8vIHJlZHVjZSBtYXggYnVmZmVyIGxlbmd0aCBhcyBpdCBtaWdodCBiZSB0b28gaGlnaC4gd2UgZG8gdGhpcyB0byBhdm9pZCBsb29wIGZsdXNoaW5nIC4uLlxyXG4gICAgICBjb25maWcubWF4TWF4QnVmZmVyTGVuZ3RoLz0yO1xyXG4gICAgICBsb2dnZXIud2FybihgbWFpbjpyZWR1Y2UgbWF4IGJ1ZmZlciBsZW5ndGggdG8gJHtjb25maWcubWF4TWF4QnVmZmVyTGVuZ3RofXNgKTtcclxuICAgICAgLy8gaW5jcmVhc2UgZnJhZ21lbnQgbG9hZCBJbmRleCB0byBhdm9pZCBmcmFnIGxvb3AgbG9hZGluZyBlcnJvciBhZnRlciBidWZmZXIgZmx1c2hcclxuICAgICAgdGhpcy5mcmFnTG9hZElkeCArPSAyICogY29uZmlnLmZyYWdMb2FkaW5nTG9vcFRocmVzaG9sZDtcclxuICAgIH1cclxuICB9XHJcblxyXG5fY2hlY2tCdWZmZXIoKSB7XHJcbiAgICB2YXIgbWVkaWEgPSB0aGlzLm1lZGlhLFxyXG4gICAgICAgIGNvbmZpZyA9IHRoaXMuY29uZmlnO1xyXG4gICAgLy8gaWYgcmVhZHkgc3RhdGUgZGlmZmVyZW50IGZyb20gSEFWRV9OT1RISU5HIChudW1lcmljIHZhbHVlIDApLCB3ZSBhcmUgYWxsb3dlZCB0byBzZWVrXHJcbiAgICBpZihtZWRpYSAmJiBtZWRpYS5yZWFkeVN0YXRlKSB7XHJcbiAgICAgICAgbGV0IGN1cnJlbnRUaW1lID0gbWVkaWEuY3VycmVudFRpbWUsXHJcbiAgICAgICAgICAgIG1lZGlhQnVmZmVyID0gdGhpcy5tZWRpYUJ1ZmZlciA/IHRoaXMubWVkaWFCdWZmZXIgOiBtZWRpYSxcclxuICAgICAgICAgICAgIGJ1ZmZlcmVkID0gbWVkaWFCdWZmZXIuYnVmZmVyZWQ7XHJcbiAgICAgIC8vIGFkanVzdCBjdXJyZW50VGltZSB0byBzdGFydCBwb3NpdGlvbiBvbiBsb2FkZWQgbWV0YWRhdGFcclxuICAgICAgaWYoIXRoaXMubG9hZGVkbWV0YWRhdGEgJiYgYnVmZmVyZWQubGVuZ3RoKSB7XHJcbiAgICAgICAgdGhpcy5sb2FkZWRtZXRhZGF0YSA9IHRydWU7XHJcbiAgICAgICAgLy8gb25seSBhZGp1c3QgY3VycmVudFRpbWUgaWYgZGlmZmVyZW50IGZyb20gc3RhcnRQb3NpdGlvbiBvciBpZiBzdGFydFBvc2l0aW9uIG5vdCBidWZmZXJlZFxyXG4gICAgICAgIC8vIGF0IHRoYXQgc3RhZ2UsIHRoZXJlIHNob3VsZCBiZSBvbmx5IG9uZSBidWZmZXJlZCByYW5nZSwgYXMgd2UgcmVhY2ggdGhhdCBjb2RlIGFmdGVyIGZpcnN0IGZyYWdtZW50IGhhcyBiZWVuIGJ1ZmZlcmVkXHJcbiAgICAgICAgbGV0IHN0YXJ0UG9zaXRpb24gPSBtZWRpYS5zZWVraW5nID8gY3VycmVudFRpbWUgOiB0aGlzLnN0YXJ0UG9zaXRpb24sXHJcbiAgICAgICAgICAgIHN0YXJ0UG9zaXRpb25CdWZmZXJlZCA9IEJ1ZmZlckhlbHBlci5pc0J1ZmZlcmVkKG1lZGlhQnVmZmVyLHN0YXJ0UG9zaXRpb24pLFxyXG4gICAgICAgICAgICBmaXJzdGJ1ZmZlcmVkUG9zaXRpb24gPSBidWZmZXJlZC5zdGFydCgwKTtcclxuICAgICAgICAvLyBpZiBjdXJyZW50VGltZSBub3QgbWF0Y2hpbmcgd2l0aCBleHBlY3RlZCBzdGFydFBvc2l0aW9uIG9yIHN0YXJ0UG9zaXRpb24gbm90IGJ1ZmZlcmVkXHJcbiAgICAgICAgaWYgKGN1cnJlbnRUaW1lICE9PSBzdGFydFBvc2l0aW9uIHx8XHJcbiAgICAgICAgICAoIXN0YXJ0UG9zaXRpb25CdWZmZXJlZCAmJiAoTWF0aC5hYnMoc3RhcnRQb3NpdGlvbi1maXJzdGJ1ZmZlcmVkUG9zaXRpb24pIDwgY29uZmlnLm1heFNlZWtIb2xlKSkpIHtcclxuICAgICAgICAgIGxvZ2dlci5sb2coYHRhcmdldCBzdGFydCBwb3NpdGlvbjoke3N0YXJ0UG9zaXRpb259YCk7XHJcbiAgICAgICAgICAvLyBpZiBzdGFydFBvc2l0aW9uIG5vdCBidWZmZXJlZCwgbGV0J3Mgc2VlayB0byBidWZmZXJlZC5zdGFydCgwKVxyXG4gICAgICAgICAgaWYoIXN0YXJ0UG9zaXRpb25CdWZmZXJlZCkge1xyXG4gICAgICAgICAgICBzdGFydFBvc2l0aW9uID0gZmlyc3RidWZmZXJlZFBvc2l0aW9uO1xyXG4gICAgICAgICAgICBsb2dnZXIubG9nKGB0YXJnZXQgc3RhcnQgcG9zaXRpb24gbm90IGJ1ZmZlcmVkLCBzZWVrIHRvIGJ1ZmZlcmVkLnN0YXJ0KDApICR7c3RhcnRQb3NpdGlvbn1gKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGxvZ2dlci5sb2coYGFkanVzdCBjdXJyZW50VGltZSBmcm9tICR7Y3VycmVudFRpbWV9IHRvICR7c3RhcnRQb3NpdGlvbn1gKTtcclxuICAgICAgICAgIG1lZGlhLmN1cnJlbnRUaW1lID0gc3RhcnRQb3NpdGlvbjtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5pbW1lZGlhdGVTd2l0Y2gpIHtcclxuICAgICAgICB0aGlzLmltbWVkaWF0ZUxldmVsU3dpdGNoRW5kKCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbGV0IGJ1ZmZlckluZm8gPSBCdWZmZXJIZWxwZXIuYnVmZmVySW5mbyhtZWRpYSxjdXJyZW50VGltZSwwKSxcclxuICAgICAgICAgICAgZXhwZWN0ZWRQbGF5aW5nID0gIShtZWRpYS5wYXVzZWQgfHwgLy8gbm90IHBsYXlpbmcgd2hlbiBtZWRpYSBpcyBwYXVzZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZWRpYS5lbmRlZCAgfHwgLy8gbm90IHBsYXlpbmcgd2hlbiBtZWRpYSBpcyBlbmRlZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lZGlhLmJ1ZmZlcmVkLmxlbmd0aCA9PT0gMCksIC8vIG5vdCBwbGF5aW5nIGlmIG5vdGhpbmcgYnVmZmVyZWRcclxuICAgICAgICAgICAganVtcFRocmVzaG9sZCA9IDAuNSwgLy8gdG9sZXJhbmNlIG5lZWRlZCBhcyBzb21lIGJyb3dzZXJzIHN0YWxscyBwbGF5YmFjayBiZWZvcmUgcmVhY2hpbmcgYnVmZmVyZWQgcmFuZ2UgZW5kXHJcbiAgICAgICAgICAgIHBsYXloZWFkTW92aW5nID0gY3VycmVudFRpbWUgIT09IHRoaXMubGFzdEN1cnJlbnRUaW1lO1xyXG5cclxuICAgICAgICBpZiAocGxheWhlYWRNb3ZpbmcpIHtcclxuICAgICAgICAgIC8vIHBsYXllZCBtb3ZpbmcsIGJ1dCB3YXMgcHJldmlvdXNseSBzdGFsbGVkID0+IG5vdyBub3Qgc3R1Y2sgYW55bW9yZVxyXG4gICAgICAgICAgaWYgKHRoaXMuc3RhbGxSZXBvcnRlZCkge1xyXG4gICAgICAgICAgICBsb2dnZXIud2FybihgcGxheWJhY2sgbm90IHN0dWNrIGFueW1vcmUgQCR7Y3VycmVudFRpbWV9LCBhZnRlciAke01hdGgucm91bmQocGVyZm9ybWFuY2Uubm93KCktdGhpcy5zdGFsbGVkKX1tc2ApO1xyXG4gICAgICAgICAgICB0aGlzLnN0YWxsUmVwb3J0ZWQgPSBmYWxzZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHRoaXMuc3RhbGxlZCA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgIHRoaXMubnVkZ2VSZXRyeSA9IDA7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIC8vIHBsYXloZWFkIG5vdCBtb3ZpbmdcclxuICAgICAgICAgIGlmKGV4cGVjdGVkUGxheWluZykge1xyXG4gICAgICAgICAgICAvLyBwbGF5aGVhZCBub3QgbW92aW5nIEJVVCBtZWRpYSBleHBlY3RlZCB0byBwbGF5XHJcbiAgICAgICAgICAgIGNvbnN0IHRub3cgPSBwZXJmb3JtYW5jZS5ub3coKTtcclxuICAgICAgICAgICAgY29uc3QgaGxzID0gdGhpcy5obHM7XHJcbiAgICAgICAgICAgIGlmKCF0aGlzLnN0YWxsZWQpIHtcclxuICAgICAgICAgICAgICAvLyBzdGFsbCBqdXN0IGRldGVjdGVkLCBzdG9yZSBjdXJyZW50IHRpbWVcclxuICAgICAgICAgICAgICB0aGlzLnN0YWxsZWQgPSB0bm93O1xyXG4gICAgICAgICAgICAgIHRoaXMuc3RhbGxSZXBvcnRlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIC8vIHBsYXliYWNrIGFscmVhZHkgc3RhbGxlZCwgY2hlY2sgc3RhbGxpbmcgZHVyYXRpb25cclxuICAgICAgICAgICAgICAvLyBpZiBzdGFsbGluZyBmb3IgbW9yZSB0aGFuIGEgZ2l2ZW4gdGhyZXNob2xkLCBsZXQncyB0cnkgdG8gcmVjb3ZlclxyXG4gICAgICAgICAgICAgIGNvbnN0IHN0YWxsZWREdXJhdGlvbiA9IHRub3cgLSB0aGlzLnN0YWxsZWQ7XHJcbiAgICAgICAgICAgICAgY29uc3QgYnVmZmVyTGVuID0gYnVmZmVySW5mby5sZW47XHJcbiAgICAgICAgICAgICAgbGV0IG51ZGdlUmV0cnkgPSB0aGlzLm51ZGdlUmV0cnkgfHwgMDtcclxuICAgICAgICAgICAgICAvLyBoYXZlIHdlIHJlYWNoZWQgc3RhbGwgZGVhZGxpbmUgP1xyXG4gICAgICAgICAgICAgIGlmIChidWZmZXJMZW4gPD0ganVtcFRocmVzaG9sZCAmJiBzdGFsbGVkRHVyYXRpb24gPiBjb25maWcubG93QnVmZmVyV2F0Y2hkb2dQZXJpb2QgKiAxMDAwKSB7XHJcbiAgICAgICAgICAgICAgICAvLyByZXBvcnQgc3RhbGxlZCBlcnJvciBvbmNlXHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuc3RhbGxSZXBvcnRlZCkge1xyXG4gICAgICAgICAgICAgICAgICB0aGlzLnN0YWxsUmVwb3J0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICBsb2dnZXIud2FybihgcGxheWJhY2sgc3RhbGxpbmcgaW4gbG93IGJ1ZmZlciBAJHtjdXJyZW50VGltZX1gKTtcclxuICAgICAgICAgICAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnQuRVJST1IsIHt0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLCBkZXRhaWxzOiBFcnJvckRldGFpbHMuQlVGRkVSX1NUQUxMRURfRVJST1IsIGZhdGFsOiBmYWxzZSwgYnVmZmVyIDogYnVmZmVyTGVufSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBpZiBidWZmZXIgbGVuIGlzIGJlbG93IHRocmVzaG9sZCwgdHJ5IHRvIGp1bXAgdG8gc3RhcnQgb2YgbmV4dCBidWZmZXIgcmFuZ2UgaWYgY2xvc2VcclxuICAgICAgICAgICAgICAgIC8vIG5vIGJ1ZmZlciBhdmFpbGFibGUgQCBjdXJyZW50VGltZSwgY2hlY2sgaWYgbmV4dCBidWZmZXIgaXMgY2xvc2UgKHdpdGhpbiBhIGNvbmZpZy5tYXhTZWVrSG9sZSBzZWNvbmQgcmFuZ2UpXHJcbiAgICAgICAgICAgICAgICB2YXIgbmV4dEJ1ZmZlclN0YXJ0ID0gYnVmZmVySW5mby5uZXh0U3RhcnQsIGRlbHRhID0gbmV4dEJ1ZmZlclN0YXJ0LWN1cnJlbnRUaW1lO1xyXG4gICAgICAgICAgICAgICAgaWYobmV4dEJ1ZmZlclN0YXJ0ICYmXHJcbiAgICAgICAgICAgICAgICAgICAoZGVsdGEgPCBjb25maWcubWF4U2Vla0hvbGUpICYmXHJcbiAgICAgICAgICAgICAgICAgICAoZGVsdGEgPiAwKSkge1xyXG4gICAgICAgICAgICAgICAgICB0aGlzLm51ZGdlUmV0cnkgPSArK251ZGdlUmV0cnk7XHJcbiAgICAgICAgICAgICAgICAgIGNvbnN0IG51ZGdlT2Zmc2V0ID0gbnVkZ2VSZXRyeSAqIGNvbmZpZy5udWRnZU9mZnNldDtcclxuICAgICAgICAgICAgICAgICAgLy8gbmV4dCBidWZmZXIgaXMgY2xvc2UgISBhZGp1c3QgY3VycmVudFRpbWUgdG8gbmV4dEJ1ZmZlclN0YXJ0XHJcbiAgICAgICAgICAgICAgICAgIC8vIHRoaXMgd2lsbCBlbnN1cmUgZWZmZWN0aXZlIHZpZGVvIGRlY29kaW5nXHJcbiAgICAgICAgICAgICAgICAgIGxvZ2dlci5sb2coYGFkanVzdCBjdXJyZW50VGltZSBmcm9tICR7bWVkaWEuY3VycmVudFRpbWV9IHRvIG5leHQgYnVmZmVyZWQgQCAke25leHRCdWZmZXJTdGFydH0gKyBudWRnZSAke251ZGdlT2Zmc2V0fWApO1xyXG4gICAgICAgICAgICAgICAgICBtZWRpYS5jdXJyZW50VGltZSA9IG5leHRCdWZmZXJTdGFydCArIG51ZGdlT2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgICAvLyByZXNldCBzdGFsbGVkIHNvIHRvIHJlYXJtIHdhdGNoZG9nIHRpbWVyXHJcbiAgICAgICAgICAgICAgICAgIHRoaXMuc3RhbGxlZCA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnQuRVJST1IsIHt0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLCBkZXRhaWxzOiBFcnJvckRldGFpbHMuQlVGRkVSX1NFRUtfT1ZFUl9IT0xFLCBmYXRhbDogZmFsc2UsIGhvbGUgOiBuZXh0QnVmZmVyU3RhcnQgKyBudWRnZU9mZnNldCAtIGN1cnJlbnRUaW1lfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChidWZmZXJMZW4gPiBqdW1wVGhyZXNob2xkICYmIHN0YWxsZWREdXJhdGlvbiA+IGNvbmZpZy5oaWdoQnVmZmVyV2F0Y2hkb2dQZXJpb2QgKiAxMDAwKSB7XHJcbiAgICAgICAgICAgICAgICAvLyByZXBvcnQgc3RhbGxlZCBlcnJvciBvbmNlXHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuc3RhbGxSZXBvcnRlZCkge1xyXG4gICAgICAgICAgICAgICAgICB0aGlzLnN0YWxsUmVwb3J0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICBsb2dnZXIud2FybihgcGxheWJhY2sgc3RhbGxpbmcgaW4gaGlnaCBidWZmZXIgQCR7Y3VycmVudFRpbWV9YCk7XHJcbiAgICAgICAgICAgICAgICAgIGhscy50cmlnZ2VyKEV2ZW50LkVSUk9SLCB7dHlwZTogRXJyb3JUeXBlcy5NRURJQV9FUlJPUiwgZGV0YWlsczogRXJyb3JEZXRhaWxzLkJVRkZFUl9TVEFMTEVEX0VSUk9SLCBmYXRhbDogZmFsc2UsIGJ1ZmZlciA6IGJ1ZmZlckxlbn0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gcmVzZXQgc3RhbGxlZCBzbyB0byByZWFybSB3YXRjaGRvZyB0aW1lclxyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGFsbGVkID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5udWRnZVJldHJ5ID0gKytudWRnZVJldHJ5O1xyXG4gICAgICAgICAgICAgICAgaWYgKG51ZGdlUmV0cnkgPCBjb25maWcubnVkZ2VNYXhSZXRyeSkge1xyXG4gICAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50VGltZSA9IG1lZGlhLmN1cnJlbnRUaW1lO1xyXG4gICAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXRUaW1lID0gY3VycmVudFRpbWUgKyBudWRnZVJldHJ5ICogY29uZmlnLm51ZGdlT2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgICBsb2dnZXIubG9nKGBhZGp1c3QgY3VycmVudFRpbWUgZnJvbSAke2N1cnJlbnRUaW1lfSB0byAke3RhcmdldFRpbWV9YCk7XHJcbiAgICAgICAgICAgICAgICAgIC8vIHBsYXliYWNrIHN0YWxsZWQgaW4gYnVmZmVyZWQgYXJlYSAuLi4gbGV0J3MgbnVkZ2UgY3VycmVudFRpbWUgdG8gdHJ5IHRvIG92ZXJjb21lIHRoaXNcclxuICAgICAgICAgICAgICAgICAgbWVkaWEuY3VycmVudFRpbWUgPSB0YXJnZXRUaW1lO1xyXG4gICAgICAgICAgICAgICAgICBobHMudHJpZ2dlcihFdmVudC5FUlJPUiwge3R5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsIGRldGFpbHM6IEVycm9yRGV0YWlscy5CVUZGRVJfTlVER0VfT05fU1RBTEwsIGZhdGFsOiBmYWxzZX0pO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGBzdGlsbCBzdHVjayBpbiBoaWdoIGJ1ZmZlciBAJHtjdXJyZW50VGltZX0gYWZ0ZXIgJHtjb25maWcubnVkZ2VNYXhSZXRyeX0sIHJhaXNlIGZhdGFsIGVycm9yYCk7XHJcbiAgICAgICAgICAgICAgICAgIGhscy50cmlnZ2VyKEV2ZW50LkVSUk9SLCB7dHlwZTogRXJyb3JUeXBlcy5NRURJQV9FUlJPUiwgZGV0YWlsczogRXJyb3JEZXRhaWxzLkJVRkZFUl9TVEFMTEVEX0VSUk9SLCBmYXRhbDogdHJ1ZX0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgb25GcmFnTG9hZEVtZXJnZW5jeUFib3J0ZWQoKSB7XHJcbiAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcclxuICAgIC8vIGlmIGxvYWRlZG1ldGFkYXRhIGlzIG5vdCBzZXQsIGl0IG1lYW5zIHRoYXQgd2UgYXJlIGVtZXJnZW5jeSBzd2l0Y2ggZG93biBvbiBmaXJzdCBmcmFnXHJcbiAgICAvLyBpbiB0aGF0IGNhc2UsIHJlc2V0IHN0YXJ0RnJhZ1JlcXVlc3RlZCBmbGFnXHJcbiAgICBpZighdGhpcy5sb2FkZWRtZXRhZGF0YSkge1xyXG4gICAgICB0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCA9IGZhbHNlO1xyXG4gICAgICB0aGlzLm5leHRMb2FkUG9zaXRpb24gPSB0aGlzLnN0YXJ0UG9zaXRpb247XHJcbiAgICB9XHJcbiAgICB0aGlzLnRpY2soKTtcclxuICB9XHJcblxyXG4gIG9uQnVmZmVyRmx1c2hlZCgpIHtcclxuICAgIC8qIGFmdGVyIHN1Y2Nlc3NmdWwgYnVmZmVyIGZsdXNoaW5nLCBmaWx0ZXIgZmx1c2hlZCBmcmFnbWVudHMgZnJvbSBidWZmZXJlZEZyYWdzXHJcbiAgICAgIHVzZSBtZWRpYUJ1ZmZlcmVkIGluc3RlYWQgb2YgbWVkaWEgKHNvIHRoYXQgd2Ugd2lsbCBjaGVjayBhZ2FpbnN0IHZpZGVvLmJ1ZmZlcmVkIHJhbmdlcyBpbiBjYXNlIG9mIGFsdCBhdWRpbyB0cmFjaylcclxuICAgICovXHJcbiAgICBjb25zdCBtZWRpYSA9IHRoaXMubWVkaWFCdWZmZXIgPyB0aGlzLm1lZGlhQnVmZmVyIDogdGhpcy5tZWRpYTtcclxuICAgIHRoaXMuX2J1ZmZlcmVkRnJhZ3MgPSB0aGlzLl9idWZmZXJlZEZyYWdzLmZpbHRlcihmcmFnID0+IHtyZXR1cm4gQnVmZmVySGVscGVyLmlzQnVmZmVyZWQobWVkaWEsKGZyYWcuc3RhcnRQVFMgKyBmcmFnLmVuZFBUUykgLyAyKTt9KTtcclxuXHJcbiAgICAvLyBpbmNyZWFzZSBmcmFnbWVudCBsb2FkIEluZGV4IHRvIGF2b2lkIGZyYWcgbG9vcCBsb2FkaW5nIGVycm9yIGFmdGVyIGJ1ZmZlciBmbHVzaFxyXG4gICAgdGhpcy5mcmFnTG9hZElkeCArPSAyICogdGhpcy5jb25maWcuZnJhZ0xvYWRpbmdMb29wVGhyZXNob2xkO1xyXG4gICAgLy8gbW92ZSB0byBJRExFIG9uY2UgZmx1c2ggY29tcGxldGUuIHRoaXMgc2hvdWxkIHRyaWdnZXIgbmV3IGZyYWdtZW50IGxvYWRpbmdcclxuICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xyXG4gICAgLy8gcmVzZXQgcmVmZXJlbmNlIHRvIGZyYWdcclxuICAgIHRoaXMuZnJhZ1ByZXZpb3VzID0gbnVsbDtcclxuICB9XHJcblxyXG4gIHN3YXBBdWRpb0NvZGVjKCkge1xyXG4gICAgdGhpcy5hdWRpb0NvZGVjU3dhcCA9ICF0aGlzLmF1ZGlvQ29kZWNTd2FwO1xyXG4gIH1cclxuXHJcbiAgY29tcHV0ZUxpdmVQb3NpdGlvbihzbGlkaW5nLCBsZXZlbERldGFpbHMpIHtcclxuICAgIGxldCB0YXJnZXRMYXRlbmN5ID0gdGhpcy5jb25maWcubGl2ZVN5bmNEdXJhdGlvbiAhPT0gdW5kZWZpbmVkID8gdGhpcy5jb25maWcubGl2ZVN5bmNEdXJhdGlvbiA6IHRoaXMuY29uZmlnLmxpdmVTeW5jRHVyYXRpb25Db3VudCAqIGxldmVsRGV0YWlscy50YXJnZXRkdXJhdGlvbjtcclxuICAgIHJldHVybiBzbGlkaW5nICsgTWF0aC5tYXgoMCwgbGV2ZWxEZXRhaWxzLnRvdGFsZHVyYXRpb24gLSB0YXJnZXRMYXRlbmN5KTtcclxuICB9XHJcblxyXG4gIGdldCBsaXZlU3luY1Bvc2l0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2xpdmVTeW5jUG9zaXRpb247XHJcbiAgfVxyXG5cclxuICBzZXQgbGl2ZVN5bmNQb3NpdGlvbih2YWx1ZSkge1xyXG4gICAgdGhpcy5fbGl2ZVN5bmNQb3NpdGlvbiA9IHZhbHVlO1xyXG4gIH1cclxufVxyXG5leHBvcnQgZGVmYXVsdCBTdHJlYW1Db250cm9sbGVyO1xyXG5cclxuIiwiLypcclxuICogU3VidGl0bGUgU3RyZWFtIENvbnRyb2xsZXJcclxuKi9cclxuXHJcbmltcG9ydCBFdmVudCBmcm9tICcuLi9ldmVudHMnO1xyXG5pbXBvcnQgRXZlbnRIYW5kbGVyIGZyb20gJy4uL2V2ZW50LWhhbmRsZXInO1xyXG5pbXBvcnQge2xvZ2dlcn0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcclxuXHJcbmNsYXNzIFN1YnRpdGxlU3RyZWFtQ29udHJvbGxlciBleHRlbmRzIEV2ZW50SGFuZGxlciB7XHJcblxyXG4gIGNvbnN0cnVjdG9yKGhscykge1xyXG4gICAgc3VwZXIoaGxzLFxyXG4gICAgICBFdmVudC5FUlJPUixcclxuICAgICAgRXZlbnQuU1VCVElUTEVfVFJBQ0tTX1VQREFURUQsXHJcbiAgICAgIEV2ZW50LlNVQlRJVExFX1RSQUNLX1NXSVRDSCxcclxuICAgICAgRXZlbnQuU1VCVElUTEVfVFJBQ0tfTE9BREVELFxyXG4gICAgICBFdmVudC5TVUJUSVRMRV9GUkFHX1BST0NFU1NFRCk7XHJcbiAgICB0aGlzLmNvbmZpZyA9IGhscy5jb25maWc7XHJcbiAgICB0aGlzLnZ0dEZyYWdTTnNQcm9jZXNzZWQgPSB7fTtcclxuICAgIHRoaXMudnR0RnJhZ1F1ZXVlcyA9IHVuZGVmaW5lZDtcclxuICAgIHRoaXMuY3VycmVudGx5UHJvY2Vzc2luZyA9IG51bGw7XHJcbiAgICB0aGlzLmN1cnJlbnRUcmFja0lkID0gLTE7XHJcbiAgfVxyXG5cclxuICBkZXN0cm95KCkge1xyXG4gICAgRXZlbnRIYW5kbGVyLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XHJcbiAgfVxyXG5cclxuICAvLyBSZW1vdmUgYWxsIHF1ZXVlZCBpdGVtcyBhbmQgY3JlYXRlIGEgbmV3LCBlbXB0eSBxdWV1ZSBmb3IgZWFjaCB0cmFjay5cclxuICBjbGVhclZ0dEZyYWdRdWV1ZXMoKSB7XHJcbiAgICB0aGlzLnZ0dEZyYWdRdWV1ZXMgPSB7fTtcclxuICAgIHRoaXMudHJhY2tzLmZvckVhY2godHJhY2sgPT4ge1xyXG4gICAgICB0aGlzLnZ0dEZyYWdRdWV1ZXNbdHJhY2suaWRdID0gW107XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8vIElmIG5vIGZyYWcgaXMgYmVpbmcgcHJvY2Vzc2VkIGFuZCBxdWV1ZSBpc24ndCBlbXB0eSwgaW5pdGlhdGUgcHJvY2Vzc2luZyBvZiBuZXh0IGZyYWcgaW4gbGluZS5cclxuICBuZXh0RnJhZygpIHtcclxuICAgIGlmKHRoaXMuY3VycmVudGx5UHJvY2Vzc2luZyA9PT0gbnVsbCAmJiB0aGlzLmN1cnJlbnRUcmFja0lkID4gLTEgJiYgdGhpcy52dHRGcmFnUXVldWVzW3RoaXMuY3VycmVudFRyYWNrSWRdLmxlbmd0aCkge1xyXG4gICAgICBsZXQgZnJhZyA9IHRoaXMuY3VycmVudGx5UHJvY2Vzc2luZyA9IHRoaXMudnR0RnJhZ1F1ZXVlc1t0aGlzLmN1cnJlbnRUcmFja0lkXS5zaGlmdCgpO1xyXG4gICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkZSQUdfTE9BRElORywge2ZyYWd9KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIFdoZW4gZnJhZ21lbnQgaGFzIGZpbmlzaGVkIHByb2Nlc3NpbmcsIGFkZCBzbiB0byBsaXN0IG9mIGNvbXBsZXRlZCBpZiBzdWNjZXNzZnVsLlxyXG4gIG9uU3VidGl0bGVGcmFnUHJvY2Vzc2VkKGRhdGEpIHtcclxuICAgIGlmKGRhdGEuc3VjY2Vzcykge1xyXG4gICAgICB0aGlzLnZ0dEZyYWdTTnNQcm9jZXNzZWRbZGF0YS5mcmFnLnRyYWNrSWRdLnB1c2goZGF0YS5mcmFnLnNuKTtcclxuICAgIH1cclxuICAgIHRoaXMuY3VycmVudGx5UHJvY2Vzc2luZyA9IG51bGw7XHJcbiAgICB0aGlzLm5leHRGcmFnKCk7XHJcbiAgfVxyXG5cclxuICAvLyBJZiBzb21ldGhpbmcgZ29lcyB3cm9uZywgcHJvY2VkZSB0byBuZXh0IGZyYWcsIGlmIHdlIHdlcmUgcHJvY2Vzc2luZyBvbmUuXHJcbiAgb25FcnJvcihkYXRhKSB7XHJcbiAgICBsZXQgZnJhZyA9IGRhdGEuZnJhZztcclxuICAgIC8vIGRvbid0IGhhbmRsZSBmcmFnIGVycm9yIG5vdCByZWxhdGVkIHRvIHN1YnRpdGxlIGZyYWdtZW50XHJcbiAgICBpZiAoZnJhZyAmJiBmcmFnLnR5cGUgIT09ICdzdWJ0aXRsZScpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgaWYodGhpcy5jdXJyZW50bHlQcm9jZXNzaW5nKSB7XHJcbiAgICAgIHRoaXMuY3VycmVudGx5UHJvY2Vzc2luZyA9IG51bGw7XHJcbiAgICAgIHRoaXMubmV4dEZyYWcoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIEdvdCBhbGwgbmV3IHN1YnRpdGxlIHRyYWNrcy5cclxuICBvblN1YnRpdGxlVHJhY2tzVXBkYXRlZChkYXRhKSB7XHJcbiAgICBsb2dnZXIubG9nKCdzdWJ0aXRsZSB0cmFja3MgdXBkYXRlZCcpO1xyXG4gICAgdGhpcy50cmFja3MgPSBkYXRhLnN1YnRpdGxlVHJhY2tzO1xyXG4gICAgdGhpcy5jbGVhclZ0dEZyYWdRdWV1ZXMoKTtcclxuICAgIHRoaXMudnR0RnJhZ1NOc1Byb2Nlc3NlZCA9IHt9O1xyXG4gICAgdGhpcy50cmFja3MuZm9yRWFjaCh0cmFjayA9PiB7XHJcbiAgICAgIHRoaXMudnR0RnJhZ1NOc1Byb2Nlc3NlZFt0cmFjay5pZF0gPSBbXTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgb25TdWJ0aXRsZVRyYWNrU3dpdGNoKGRhdGEpIHtcclxuICAgIHRoaXMuY3VycmVudFRyYWNrSWQgPSBkYXRhLmlkO1xyXG4gICAgdGhpcy5jbGVhclZ0dEZyYWdRdWV1ZXMoKTtcclxuICB9XHJcblxyXG4gIC8vIEdvdCBhIG5ldyBzZXQgb2Ygc3VidGl0bGUgZnJhZ21lbnRzLlxyXG4gIG9uU3VidGl0bGVUcmFja0xvYWRlZChkYXRhKSB7XHJcbiAgICBjb25zdCBwcm9jZXNzZWRGcmFnU05zID0gdGhpcy52dHRGcmFnU05zUHJvY2Vzc2VkW2RhdGEuaWRdLFxyXG4gICAgICAgIGZyYWdRdWV1ZSA9IHRoaXMudnR0RnJhZ1F1ZXVlc1tkYXRhLmlkXSxcclxuICAgICAgICBjdXJyZW50RnJhZ1NOID0gISF0aGlzLmN1cnJlbnRseVByb2Nlc3NpbmcgPyB0aGlzLmN1cnJlbnRseVByb2Nlc3Npbmcuc24gOiAtMTtcclxuXHJcbiAgICBjb25zdCBhbHJlYWR5UHJvY2Vzc2VkID0gZnVuY3Rpb24oZnJhZykge1xyXG4gICAgICByZXR1cm4gcHJvY2Vzc2VkRnJhZ1NOcy5pbmRleE9mKGZyYWcuc24pID4gLTE7XHJcbiAgICB9O1xyXG5cclxuICAgIGNvbnN0IGFscmVhZHlJblF1ZXVlID0gZnVuY3Rpb24oZnJhZykge1xyXG4gICAgICByZXR1cm4gZnJhZ1F1ZXVlLnNvbWUoZnJhZ0luUXVldWUgPT4ge3JldHVybiBmcmFnSW5RdWV1ZS5zbiA9PT0gZnJhZy5zbjt9KTtcclxuICAgIH07XHJcblxyXG4gICAgLy8gQWRkIGFsbCBmcmFnbWVudHMgdGhhdCBoYXZlbid0IGJlZW4sIGFyZW4ndCBjdXJyZW50bHkgYmVpbmcgYW5kIGFyZW4ndCB3YWl0aW5nIHRvIGJlIHByb2Nlc3NlZCwgdG8gcXVldWUuXHJcbiAgICBkYXRhLmRldGFpbHMuZnJhZ21lbnRzLmZvckVhY2goZnJhZyA9PsKge1xyXG4gICAgICBpZighKGFscmVhZHlQcm9jZXNzZWQoZnJhZykgfHwgZnJhZy5zbiA9PT0gY3VycmVudEZyYWdTTiB8fCBhbHJlYWR5SW5RdWV1ZShmcmFnKSkpIHtcclxuICAgICAgICAvLyBGcmFncyBkb24ndCBrbm93IHRoZWlyIHN1YnRpdGxlIHRyYWNrIElELCBzbyBsZXQncyBqdXN0IGFkZCB0aGF0Li4uXHJcbiAgICAgICAgZnJhZy50cmFja0lkID0gZGF0YS5pZDtcclxuICAgICAgICBmcmFnUXVldWUucHVzaChmcmFnKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy5uZXh0RnJhZygpO1xyXG4gIH1cclxufVxyXG5leHBvcnQgZGVmYXVsdCBTdWJ0aXRsZVN0cmVhbUNvbnRyb2xsZXI7XHJcblxyXG4iLCIvKlxyXG4gKiBhdWRpbyB0cmFjayBjb250cm9sbGVyXHJcbiovXHJcblxyXG5pbXBvcnQgRXZlbnQgZnJvbSAnLi4vZXZlbnRzJztcclxuaW1wb3J0IEV2ZW50SGFuZGxlciBmcm9tICcuLi9ldmVudC1oYW5kbGVyJztcclxuaW1wb3J0IHtsb2dnZXJ9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XHJcblxyXG5mdW5jdGlvbiBmaWx0ZXJTdWJ0aXRsZVRyYWNrcyh0ZXh0VHJhY2tMaXN0KSB7XHJcbiAgbGV0IHRyYWNrcyA9IFtdO1xyXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdGV4dFRyYWNrTGlzdC5sZW5ndGg7IGkrKykge1xyXG4gICAgaWYgKHRleHRUcmFja0xpc3RbaV0ua2luZCA9PT0gJ3N1YnRpdGxlcycpIHtcclxuICAgICAgdHJhY2tzLnB1c2godGV4dFRyYWNrTGlzdFtpXSk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiB0cmFja3M7XHJcbn1cclxuXHJcbmNsYXNzIFN1YnRpdGxlVHJhY2tDb250cm9sbGVyIGV4dGVuZHMgRXZlbnRIYW5kbGVyIHtcclxuXHJcbiAgY29uc3RydWN0b3IoaGxzKSB7XHJcbiAgICBzdXBlcihobHMsXHJcbiAgICAgICAgICAgICAgIEV2ZW50Lk1FRElBX0FUVEFDSEVELFxyXG4gICAgICAgICAgICAgICBFdmVudC5NRURJQV9ERVRBQ0hJTkcsXHJcbiAgICAgICAgICAgICAgIEV2ZW50Lk1BTklGRVNUX0xPQURJTkcsXHJcbiAgICAgICAgICAgICAgIEV2ZW50Lk1BTklGRVNUX0xPQURFRCxcclxuICAgICAgICAgICAgICAgRXZlbnQuU1VCVElUTEVfVFJBQ0tfTE9BREVEKTtcclxuICAgIHRoaXMudHJhY2tzID0gW107XHJcbiAgICB0aGlzLnRyYWNrSWQgPSAtMTtcclxuICAgIHRoaXMubWVkaWEgPSB1bmRlZmluZWQ7XHJcbiAgfVxyXG5cclxuICBfb25UZXh0VHJhY2tzQ2hhbmdlZCgpIHtcclxuICAgIC8vIE1lZGlhIGlzIHVuZGVmaW5lZCB3aGVuIHN3aXRjaGluZyBzdHJlYW1zIHZpYSBsb2FkU291cmNlKClcclxuICAgIGlmICghdGhpcy5tZWRpYSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IHRyYWNrSWQgPSAtMTtcclxuICAgIGxldCB0cmFja3MgPSBmaWx0ZXJTdWJ0aXRsZVRyYWNrcyh0aGlzLm1lZGlhLnRleHRUcmFja3MpO1xyXG4gICAgZm9yIChsZXQgaWQgPSAwOyBpZCA8IHRyYWNrcy5sZW5ndGg7IGlkKyspIHtcclxuICAgICAgaWYgKHRyYWNrc1tpZF0ubW9kZSA9PT0gJ3Nob3dpbmcnKSB7XHJcbiAgICAgICAgdHJhY2tJZCA9IGlkO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gU2V0dGluZyBjdXJyZW50IHN1YnRpdGxlVHJhY2sgd2lsbCBpbnZva2UgY29kZS5cclxuICAgIHRoaXMuc3VidGl0bGVUcmFjayA9IHRyYWNrSWQ7XHJcbiAgfVxyXG5cclxuICBkZXN0cm95KCkge1xyXG4gICAgRXZlbnRIYW5kbGVyLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XHJcbiAgfVxyXG5cclxuICAvLyBMaXN0ZW4gZm9yIHN1YnRpdGxlIHRyYWNrIGNoYW5nZSwgdGhlbiBleHRyYWN0IHRoZSBjdXJyZW50IHRyYWNrIElELlxyXG4gIG9uTWVkaWFBdHRhY2hlZChkYXRhKSB7XHJcbiAgICB0aGlzLm1lZGlhID0gZGF0YS5tZWRpYTtcclxuICAgIGlmICghdGhpcy5tZWRpYSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy50cmFja0NoYW5nZUxpc3RlbmVyID0gdGhpcy5fb25UZXh0VHJhY2tzQ2hhbmdlZC5iaW5kKHRoaXMpO1xyXG4gICAgdGhpcy5tZWRpYS50ZXh0VHJhY2tzLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHRoaXMudHJhY2tDaGFuZ2VMaXN0ZW5lcik7XHJcbiAgfVxyXG5cclxuICBvbk1lZGlhRGV0YWNoaW5nKCkge1xyXG4gICAgaWYgKCF0aGlzLm1lZGlhKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLm1lZGlhLnRleHRUcmFja3MucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdGhpcy50cmFja0NoYW5nZUxpc3RlbmVyKTtcclxuXHJcbiAgICB0aGlzLm1lZGlhID0gdW5kZWZpbmVkO1xyXG4gIH1cclxuXHJcbiAgLy8gUmVzZXQgc3VidGl0bGUgdHJhY2tzIG9uIG1hbmlmZXN0IGxvYWRpbmdcclxuICBvbk1hbmlmZXN0TG9hZGluZygpIHtcclxuICAgIHRoaXMudHJhY2tzID0gW107XHJcbiAgICB0aGlzLnRyYWNrSWQgPSAtMTtcclxuICB9XHJcblxyXG4gIC8vIEZpcmVkIHdoZW5ldmVyIGEgbmV3IG1hbmlmZXN0IGlzIGxvYWRlZC5cclxuICBvbk1hbmlmZXN0TG9hZGVkKGRhdGEpIHtcclxuICAgIGxldCB0cmFja3MgPSBkYXRhLnN1YnRpdGxlcyB8fCBbXTtcclxuICAgIGxldCBkZWZhdWx0Rm91bmQgPSBmYWxzZTtcclxuICAgIHRoaXMudHJhY2tzID0gdHJhY2tzO1xyXG4gICAgdGhpcy50cmFja0lkID0gLTE7XHJcbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LlNVQlRJVExFX1RSQUNLU19VUERBVEVELCB7c3VidGl0bGVUcmFja3MgOiB0cmFja3N9KTtcclxuXHJcbiAgICAvLyBsb29wIHRocm91Z2ggYXZhaWxhYmxlIHN1YnRpdGxlIHRyYWNrcyBhbmQgYXV0b3NlbGVjdCBkZWZhdWx0IGlmIG5lZWRlZFxyXG4gICAgLy8gVE9ETzogaW1wcm92ZSBzZWxlY3Rpb24gbG9naWMgdG8gaGFuZGxlIGZvcmNlZCwgZXRjXHJcbiAgICB0cmFja3MuZm9yRWFjaCh0cmFjayA9PiB7XHJcbiAgICAgIGlmICh0cmFjay5kZWZhdWx0KSB7XHJcbiAgICAgICAgdGhpcy5zdWJ0aXRsZVRyYWNrID0gdHJhY2suaWQ7XHJcbiAgICAgICAgZGVmYXVsdEZvdW5kID0gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvLyBUcmlnZ2VyIHN1YnRpdGxlIHRyYWNrIHBsYXlsaXN0IHJlbG9hZC5cclxuICBvblRpY2soKSB7XHJcbiAgICBjb25zdCB0cmFja0lkID0gdGhpcy50cmFja0lkO1xyXG4gICAgY29uc3Qgc3VidGl0bGVUcmFjayA9IHRoaXMudHJhY2tzW3RyYWNrSWRdO1xyXG4gICAgaWYgKCFzdWJ0aXRsZVRyYWNrKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBkZXRhaWxzID0gc3VidGl0bGVUcmFjay5kZXRhaWxzO1xyXG4gICAgLy8gY2hlY2sgaWYgd2UgbmVlZCB0byBsb2FkIHBsYXlsaXN0IGZvciB0aGlzIHN1YnRpdGxlIFRyYWNrXHJcbiAgICBpZiAoZGV0YWlscyA9PT0gdW5kZWZpbmVkIHx8IGRldGFpbHMubGl2ZSA9PT0gdHJ1ZSkge1xyXG4gICAgICAvLyB0cmFjayBub3QgcmV0cmlldmVkIHlldCwgb3IgbGl2ZSBwbGF5bGlzdCB3ZSBuZWVkIHRvIChyZSlsb2FkIGl0XHJcbiAgICAgIGxvZ2dlci5sb2coYChyZSlsb2FkaW5nIHBsYXlsaXN0IGZvciBzdWJ0aXRsZSB0cmFjayAke3RyYWNrSWR9YCk7XHJcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuU1VCVElUTEVfVFJBQ0tfTE9BRElORywge3VybDogc3VidGl0bGVUcmFjay51cmwsIGlkOiB0cmFja0lkfSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBvblN1YnRpdGxlVHJhY2tMb2FkZWQoZGF0YSkge1xyXG4gICAgaWYgKGRhdGEuaWQgPCB0aGlzLnRyYWNrcy5sZW5ndGgpIHtcclxuICAgICAgbG9nZ2VyLmxvZyhgc3VidGl0bGUgdHJhY2sgJHtkYXRhLmlkfSBsb2FkZWRgKTtcclxuICAgICAgdGhpcy50cmFja3NbZGF0YS5pZF0uZGV0YWlscyA9IGRhdGEuZGV0YWlscztcclxuICAgICAgLy8gY2hlY2sgaWYgY3VycmVudCBwbGF5bGlzdCBpcyBhIGxpdmUgcGxheWxpc3RcclxuICAgICAgaWYgKGRhdGEuZGV0YWlscy5saXZlICYmICF0aGlzLnRpbWVyKSB7XHJcbiAgICAgICAgLy8gaWYgbGl2ZSBwbGF5bGlzdCB3ZSB3aWxsIGhhdmUgdG8gcmVsb2FkIGl0IHBlcmlvZGljYWxseVxyXG4gICAgICAgIC8vIHNldCByZWxvYWQgcGVyaW9kIHRvIHBsYXlsaXN0IHRhcmdldCBkdXJhdGlvblxyXG4gICAgICAgIHRoaXMudGltZXIgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XHJcbiAgICAgICAgICB0aGlzLm9uVGljaygpO1xyXG4gICAgICAgIH0sIDEwMDAgKiBkYXRhLmRldGFpbHMudGFyZ2V0ZHVyYXRpb24sIHRoaXMpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICghZGF0YS5kZXRhaWxzLmxpdmUgJiYgdGhpcy50aW1lcikge1xyXG4gICAgICAgIC8vIHBsYXlsaXN0IGlzIG5vdCBsaXZlIGFuZCB0aW1lciBpcyBhcm1lZCA6IHN0b3BwaW5nIGl0XHJcbiAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLnRpbWVyKTtcclxuICAgICAgICB0aGlzLnRpbWVyID0gbnVsbDtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqIGdldCBhbHRlcm5hdGUgc3VidGl0bGUgdHJhY2tzIGxpc3QgZnJvbSBwbGF5bGlzdCAqKi9cclxuICBnZXQgc3VidGl0bGVUcmFja3MoKSB7XHJcbiAgICByZXR1cm4gdGhpcy50cmFja3M7XHJcbiAgfVxyXG5cclxuICAvKiogZ2V0IGluZGV4IG9mIHRoZSBzZWxlY3RlZCBzdWJ0aXRsZSB0cmFjayAoaW5kZXggaW4gc3VidGl0bGUgdHJhY2sgbGlzdHMpICoqL1xyXG4gIGdldCBzdWJ0aXRsZVRyYWNrKCkge1xyXG4gICByZXR1cm4gdGhpcy50cmFja0lkO1xyXG4gIH1cclxuXHJcbiAgLyoqIHNlbGVjdCBhIHN1YnRpdGxlIHRyYWNrLCBiYXNlZCBvbiBpdHMgaW5kZXggaW4gc3VidGl0bGUgdHJhY2sgbGlzdHMqKi9cclxuICBzZXQgc3VidGl0bGVUcmFjayhzdWJ0aXRsZVRyYWNrSWQpIHtcclxuICAgIGlmICh0aGlzLnRyYWNrSWQgIT09IHN1YnRpdGxlVHJhY2tJZCkgey8vIHx8IHRoaXMudHJhY2tzW3N1YnRpdGxlVHJhY2tJZF0uZGV0YWlscyA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHRoaXMuc2V0U3VidGl0bGVUcmFja0ludGVybmFsKHN1YnRpdGxlVHJhY2tJZCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuIHNldFN1YnRpdGxlVHJhY2tJbnRlcm5hbChuZXdJZCkge1xyXG4gICAgLy8gY2hlY2sgaWYgbGV2ZWwgaWR4IGlzIHZhbGlkXHJcbiAgICBpZiAobmV3SWQgPj0gMCAmJiBuZXdJZCA8IHRoaXMudHJhY2tzLmxlbmd0aCkge1xyXG4gICAgICAvLyBzdG9wcGluZyBsaXZlIHJlbG9hZGluZyB0aW1lciBpZiBhbnlcclxuICAgICAgaWYgKHRoaXMudGltZXIpIHtcclxuICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy50aW1lcik7XHJcbiAgICAgICB0aGlzLnRpbWVyID0gbnVsbDtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLnRyYWNrSWQgPSBuZXdJZDtcclxuICAgICAgbG9nZ2VyLmxvZyhgc3dpdGNoaW5nIHRvIHN1YnRpdGxlIHRyYWNrICR7bmV3SWR9YCk7XHJcbiAgICAgIGxldCBzdWJ0aXRsZVRyYWNrID0gdGhpcy50cmFja3NbbmV3SWRdO1xyXG4gICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LlNVQlRJVExFX1RSQUNLX1NXSVRDSCwge2lkOiBuZXdJZH0pO1xyXG4gICAgICAgLy8gY2hlY2sgaWYgd2UgbmVlZCB0byBsb2FkIHBsYXlsaXN0IGZvciB0aGlzIHN1YnRpdGxlIFRyYWNrXHJcbiAgICAgIGxldCBkZXRhaWxzID0gc3VidGl0bGVUcmFjay5kZXRhaWxzO1xyXG4gICAgICBpZiAoZGV0YWlscyA9PT0gdW5kZWZpbmVkIHx8IGRldGFpbHMubGl2ZSA9PT0gdHJ1ZSkge1xyXG4gICAgICAgIC8vIHRyYWNrIG5vdCByZXRyaWV2ZWQgeWV0LCBvciBsaXZlIHBsYXlsaXN0IHdlIG5lZWQgdG8gKHJlKWxvYWQgaXRcclxuICAgICAgICBsb2dnZXIubG9nKGAocmUpbG9hZGluZyBwbGF5bGlzdCBmb3Igc3VidGl0bGUgdHJhY2sgJHtuZXdJZH1gKTtcclxuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LlNVQlRJVExFX1RSQUNLX0xPQURJTkcsIHt1cmw6IHN1YnRpdGxlVHJhY2sudXJsLCBpZDogbmV3SWR9KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgU3VidGl0bGVUcmFja0NvbnRyb2xsZXI7XHJcbiIsIi8qXHJcbiAqIFRpbWVsaW5lIENvbnRyb2xsZXJcclxuKi9cclxuXHJcbmltcG9ydCBFdmVudCBmcm9tICcuLi9ldmVudHMnO1xyXG5pbXBvcnQgRXZlbnRIYW5kbGVyIGZyb20gJy4uL2V2ZW50LWhhbmRsZXInO1xyXG5pbXBvcnQgQ2VhNjA4UGFyc2VyIGZyb20gJy4uL3V0aWxzL2NlYS02MDgtcGFyc2VyJztcclxuaW1wb3J0IFdlYlZUVFBhcnNlciBmcm9tICcuLi91dGlscy93ZWJ2dHQtcGFyc2VyJztcclxuaW1wb3J0IHtsb2dnZXJ9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XHJcblxyXG5mdW5jdGlvbiBjbGVhckN1cnJlbnRDdWVzKHRyYWNrKSB7XHJcbiAgaWYgKHRyYWNrICYmIHRyYWNrLmN1ZXMpIHtcclxuICAgIHdoaWxlICh0cmFjay5jdWVzLmxlbmd0aCA+IDApIHtcclxuICAgICAgdHJhY2sucmVtb3ZlQ3VlKHRyYWNrLmN1ZXNbMF0pO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gcmV1c2VWdHRUZXh0VHJhY2soaW5Vc2VUcmFjaywgbWFuaWZlc3RUcmFjaykge1xyXG4gIHJldHVybiBpblVzZVRyYWNrICYmIGluVXNlVHJhY2subGFiZWwgPT09IG1hbmlmZXN0VHJhY2submFtZSAmJiAhKGluVXNlVHJhY2sudGV4dFRyYWNrMSB8fCBpblVzZVRyYWNrLnRleHRUcmFjazIpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBpbnRlcnNlY3Rpb24oeDEsIHgyLCB5MSwgeTIpIHtcclxuICByZXR1cm4gTWF0aC5taW4oeDIsIHkyKSAtIE1hdGgubWF4KHgxLCB5MSk7XHJcbn1cclxuXHJcbmNsYXNzIFRpbWVsaW5lQ29udHJvbGxlciBleHRlbmRzIEV2ZW50SGFuZGxlciB7XHJcblxyXG4gIGNvbnN0cnVjdG9yKGhscykge1xyXG4gICAgc3VwZXIoaGxzLCBFdmVudC5NRURJQV9BVFRBQ0hJTkcsXHJcbiAgICAgICAgICAgICAgICBFdmVudC5NRURJQV9ERVRBQ0hJTkcsXHJcbiAgICAgICAgICAgICAgICBFdmVudC5GUkFHX1BBUlNJTkdfVVNFUkRBVEEsXHJcbiAgICAgICAgICAgICAgICBFdmVudC5NQU5JRkVTVF9MT0FESU5HLFxyXG4gICAgICAgICAgICAgICAgRXZlbnQuTUFOSUZFU1RfTE9BREVELFxyXG4gICAgICAgICAgICAgICAgRXZlbnQuRlJBR19MT0FERUQsXHJcbiAgICAgICAgICAgICAgICBFdmVudC5MRVZFTF9TV0lUQ0hJTkcsXHJcbiAgICAgICAgICAgICAgICBFdmVudC5JTklUX1BUU19GT1VORCk7XHJcblxyXG4gICAgdGhpcy5obHMgPSBobHM7XHJcbiAgICB0aGlzLmNvbmZpZyA9IGhscy5jb25maWc7XHJcbiAgICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xyXG4gICAgdGhpcy5DdWVzID0gaGxzLmNvbmZpZy5jdWVIYW5kbGVyO1xyXG4gICAgdGhpcy50ZXh0VHJhY2tzID0gW107XHJcbiAgICB0aGlzLnRyYWNrcyA9IFtdO1xyXG4gICAgdGhpcy51bnBhcnNlZFZ0dEZyYWdzID0gW107XHJcbiAgICB0aGlzLmluaXRQVFMgPSB1bmRlZmluZWQ7XHJcbiAgICB0aGlzLmN1ZVJhbmdlcyA9IFtdO1xyXG5cclxuICAgIGlmICh0aGlzLmNvbmZpZy5lbmFibGVDRUE3MDhDYXB0aW9ucylcclxuICAgIHtcclxuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICB2YXIgc2VuZEFkZFRyYWNrRXZlbnQgPSBmdW5jdGlvbiAodHJhY2ssIG1lZGlhKVxyXG4gICAgICB7XHJcbiAgICAgICAgdmFyIGUgPSBudWxsO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBlID0gbmV3IHdpbmRvdy5FdmVudCgnYWRkdHJhY2snKTtcclxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgIC8vZm9yIElFMTFcclxuICAgICAgICAgIGUgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcclxuICAgICAgICAgIGUuaW5pdEV2ZW50KCdhZGR0cmFjaycsIGZhbHNlLCBmYWxzZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGUudHJhY2sgPSB0cmFjaztcclxuICAgICAgICBtZWRpYS5kaXNwYXRjaEV2ZW50KGUpO1xyXG4gICAgICB9O1xyXG5cclxuICAgICAgdmFyIGNoYW5uZWwxID1cclxuICAgICAge1xyXG4gICAgICAgICduZXdDdWUnOiBmdW5jdGlvbihzdGFydFRpbWUsIGVuZFRpbWUsIHNjcmVlbilcclxuICAgICAgICB7XHJcbiAgICAgICAgICBpZiAoIXNlbGYudGV4dFRyYWNrMSlcclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAgLy9FbmFibGUgcmV1c2Ugb2YgZXhpc3RpbmcgdGV4dCB0cmFjay5cclxuICAgICAgICAgICAgdmFyIGV4aXN0aW5nVHJhY2sxID0gc2VsZi5nZXRFeGlzdGluZ1RyYWNrKCcxJyk7XHJcbiAgICAgICAgICAgIGlmICghZXhpc3RpbmdUcmFjazEpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICBjb25zdCB0ZXh0VHJhY2sxID0gc2VsZi5jcmVhdGVUZXh0VHJhY2soJ2NhcHRpb25zJywgc2VsZi5jb25maWcuY2FwdGlvbnNUZXh0VHJhY2sxTGFiZWwsIHNlbGYuY29uZmlnLmNhcHRpb25zVGV4dFRyYWNrMUxhbmd1YWdlQ29kZSk7XHJcbiAgICAgICAgICAgICAgaWYgKHRleHRUcmFjazEpIHtcclxuICAgICAgICAgICAgICAgIHRleHRUcmFjazEudGV4dFRyYWNrMSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBzZWxmLnRleHRUcmFjazEgPSB0ZXh0VHJhY2sxO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICBzZWxmLnRleHRUcmFjazEgPSBleGlzdGluZ1RyYWNrMTtcclxuICAgICAgICAgICAgICBjbGVhckN1cnJlbnRDdWVzKHNlbGYudGV4dFRyYWNrMSk7XHJcblxyXG4gICAgICAgICAgICAgIHNlbmRBZGRUcmFja0V2ZW50KHNlbGYudGV4dFRyYWNrMSwgc2VsZi5tZWRpYSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHNlbGYuYWRkQ3VlcygndGV4dFRyYWNrMScsIHN0YXJ0VGltZSwgZW5kVGltZSwgc2NyZWVuKTtcclxuICAgICAgICB9XHJcbiAgICAgIH07XHJcblxyXG4gICAgICB2YXIgY2hhbm5lbDIgPVxyXG4gICAgICB7XHJcbiAgICAgICAgJ25ld0N1ZSc6IGZ1bmN0aW9uKHN0YXJ0VGltZSwgZW5kVGltZSwgc2NyZWVuKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgIGlmICghc2VsZi50ZXh0VHJhY2syKVxyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICAvL0VuYWJsZSByZXVzZSBvZiBleGlzdGluZyB0ZXh0IHRyYWNrLlxyXG4gICAgICAgICAgICB2YXIgZXhpc3RpbmdUcmFjazIgPSBzZWxmLmdldEV4aXN0aW5nVHJhY2soJzInKTtcclxuICAgICAgICAgICAgaWYgKCFleGlzdGluZ1RyYWNrMilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgIGNvbnN0IHRleHRUcmFjazIgPSBzZWxmLmNyZWF0ZVRleHRUcmFjaygnY2FwdGlvbnMnLCBzZWxmLmNvbmZpZy5jYXB0aW9uc1RleHRUcmFjazJMYWJlbCwgc2VsZi5jb25maWcuY2FwdGlvbnNUZXh0VHJhY2sxTGFuZ3VhZ2VDb2RlKTtcclxuICAgICAgICAgICAgICBpZiAodGV4dFRyYWNrMikge1xyXG4gICAgICAgICAgICAgICAgdGV4dFRyYWNrMi50ZXh0VHJhY2syID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHNlbGYudGV4dFRyYWNrMiA9IHRleHRUcmFjazI7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgIHNlbGYudGV4dFRyYWNrMiA9IGV4aXN0aW5nVHJhY2syO1xyXG4gICAgICAgICAgICAgIGNsZWFyQ3VycmVudEN1ZXMoc2VsZi50ZXh0VHJhY2syKTtcclxuXHJcbiAgICAgICAgICAgICAgc2VuZEFkZFRyYWNrRXZlbnQoc2VsZi50ZXh0VHJhY2syLCBzZWxmLm1lZGlhKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgc2VsZi5hZGRDdWVzKCd0ZXh0VHJhY2syJywgc3RhcnRUaW1lLCBlbmRUaW1lLCBzY3JlZW4pO1xyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuXHJcbiAgICAgIHRoaXMuY2VhNjA4UGFyc2VyID0gbmV3IENlYTYwOFBhcnNlcigwLCBjaGFubmVsMSwgY2hhbm5lbDIpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgYWRkQ3VlcyhjaGFubmVsLCBzdGFydFRpbWUsIGVuZFRpbWUsIHNjcmVlbikge1xyXG4gICAgLy8gc2tpcCBjdWVzIHdoaWNoIG92ZXJsYXAgbW9yZSB0aGFuIDUwJSB3aXRoIHByZXZpb3VzbHkgcGFyc2VkIHRpbWUgcmFuZ2VzXHJcbiAgICBjb25zdCByYW5nZXMgPSB0aGlzLmN1ZVJhbmdlcztcclxuICAgIGxldCBtZXJnZWQgPSBmYWxzZTtcclxuICAgIGZvciAobGV0IGkgPSByYW5nZXMubGVuZ3RoOyBpLS07KSB7XHJcbiAgICAgIGxldCBjdWVSYW5nZSA9IHJhbmdlc1tpXTtcclxuICAgICAgbGV0IG92ZXJsYXAgPSBpbnRlcnNlY3Rpb24oY3VlUmFuZ2VbMF0sIGN1ZVJhbmdlWzFdLCBzdGFydFRpbWUsIGVuZFRpbWUpO1xyXG4gICAgICBpZiAob3ZlcmxhcCA+PSAwKSB7XHJcbiAgICAgICAgY3VlUmFuZ2VbMF0gPSBNYXRoLm1pbihjdWVSYW5nZVswXSwgc3RhcnRUaW1lKTtcclxuICAgICAgICBjdWVSYW5nZVsxXSA9IE1hdGgubWF4KGN1ZVJhbmdlWzFdLCBlbmRUaW1lKTtcclxuICAgICAgICBtZXJnZWQgPSB0cnVlO1xyXG4gICAgICAgIGlmICgob3ZlcmxhcCAvIChlbmRUaW1lIC0gc3RhcnRUaW1lKSkgPiAwLjUpIHtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGlmICghbWVyZ2VkKSB7XHJcbiAgICAgIHJhbmdlcy5wdXNoKFtzdGFydFRpbWUsIGVuZFRpbWVdKTtcclxuICAgIH1cclxuICAgIHRoaXMuQ3Vlcy5uZXdDdWUodGhpc1tjaGFubmVsXSwgc3RhcnRUaW1lLCBlbmRUaW1lLCBzY3JlZW4pO1xyXG4gIH1cclxuXHJcbiAgLy8gVHJpZ2dlcmVkIHdoZW4gYW4gaW5pdGlhbCBQVFMgaXMgZm91bmQ7IHVzZWQgZm9yIHN5bmNocm9uaXNhdGlvbiBvZiBXZWJWVFQuXHJcbiAgb25Jbml0UHRzRm91bmQoZGF0YSkge1xyXG4gICAgaWYgKHR5cGVvZiB0aGlzLmluaXRQVFMgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgIHRoaXMuaW5pdFBUUyA9IGRhdGEuaW5pdFBUUztcclxuICAgIH1cclxuXHJcbiAgICAvLyBEdWUgdG8gYXN5bmNocm9ueSwgaW5pdGlhbCBQVFMgbWF5IGFycml2ZSBsYXRlciB0aGFuIHRoZSBmaXJzdCBWVFQgZnJhZ21lbnRzIGFyZSBsb2FkZWQuXHJcbiAgICAvLyBQYXJzZSBhbnkgdW5wYXJzZWQgZnJhZ21lbnRzIHVwb24gcmVjZWl2aW5nIHRoZSBpbml0aWFsIFBUUy5cclxuICAgIGlmICh0aGlzLnVucGFyc2VkVnR0RnJhZ3MubGVuZ3RoKSB7XHJcbiAgICAgIHRoaXMudW5wYXJzZWRWdHRGcmFncy5mb3JFYWNoKGZyYWcgPT4ge1xyXG4gICAgICAgIHRoaXMub25GcmFnTG9hZGVkKGZyYWcpO1xyXG4gICAgICB9KTtcclxuICAgICAgdGhpcy51bnBhcnNlZFZ0dEZyYWdzID0gW107XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBnZXRFeGlzdGluZ1RyYWNrKGNoYW5uZWxOdW1iZXIpIHtcclxuICAgIGNvbnN0IG1lZGlhID0gdGhpcy5tZWRpYTtcclxuICAgIGlmIChtZWRpYSkge1xyXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1lZGlhLnRleHRUcmFja3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBsZXQgdGV4dFRyYWNrID0gbWVkaWEudGV4dFRyYWNrc1tpXTtcclxuICAgICAgICBsZXQgcHJvcE5hbWUgPSAndGV4dFRyYWNrJyArIGNoYW5uZWxOdW1iZXI7XHJcbiAgICAgICAgaWYgKHRleHRUcmFja1twcm9wTmFtZV0gPT09IHRydWUpIHtcclxuICAgICAgICAgIHJldHVybiB0ZXh0VHJhY2s7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcblxyXG4gIGNyZWF0ZVRleHRUcmFjayhraW5kLCBsYWJlbCwgbGFuZykge1xyXG4gICAgY29uc3QgbWVkaWEgPSB0aGlzLm1lZGlhO1xyXG4gICAgaWYgKG1lZGlhKVxyXG4gICAge1xyXG4gICAgICByZXR1cm4gbWVkaWEuYWRkVGV4dFRyYWNrKGtpbmQsIGxhYmVsLCBsYW5nKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGRlc3Ryb3koKSB7XHJcbiAgICBFdmVudEhhbmRsZXIucHJvdG90eXBlLmRlc3Ryb3kuY2FsbCh0aGlzKTtcclxuICB9XHJcblxyXG4gIG9uTWVkaWFBdHRhY2hpbmcoZGF0YSkge1xyXG4gICAgdGhpcy5tZWRpYSA9IGRhdGEubWVkaWE7XHJcbiAgfVxyXG5cclxuICBvbk1lZGlhRGV0YWNoaW5nKCkge1xyXG4gICAgY2xlYXJDdXJyZW50Q3Vlcyh0aGlzLnRleHRUcmFjazEpO1xyXG4gICAgY2xlYXJDdXJyZW50Q3Vlcyh0aGlzLnRleHRUcmFjazIpO1xyXG4gIH1cclxuXHJcbiAgb25NYW5pZmVzdExvYWRpbmcoKVxyXG4gIHtcclxuICAgIHRoaXMubGFzdFNuID0gLTE7IC8vIERldGVjdCBkaXNjb250aWd1aXR5IGluIGZyYWdtZW50IHBhcnNpbmdcclxuICAgIHRoaXMucHJldkNDID0gLTE7XHJcbiAgICB0aGlzLnZ0dENDcyA9IHtjY09mZnNldDogMCwgcHJlc2VudGF0aW9uT2Zmc2V0OiAwfTsgLy8gRGV0ZWN0IGRpc2NvbnRpbnVpdHkgaW4gc3VidGl0bGUgbWFuaWZlc3RzXHJcblxyXG4gICAgLy8gY2xlYXIgb3V0ZGF0ZWQgc3VidGl0bGVzXHJcbiAgICBjb25zdCBtZWRpYSA9IHRoaXMubWVkaWE7XHJcbiAgICBpZiAobWVkaWEpIHtcclxuICAgICAgY29uc3QgdGV4dFRyYWNrcyA9IG1lZGlhLnRleHRUcmFja3M7XHJcbiAgICAgIGlmICh0ZXh0VHJhY2tzKSB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZXh0VHJhY2tzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICBjbGVhckN1cnJlbnRDdWVzKHRleHRUcmFja3NbaV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgb25NYW5pZmVzdExvYWRlZChkYXRhKSB7XHJcbiAgICB0aGlzLnRleHRUcmFja3MgPSBbXTtcclxuICAgIHRoaXMudW5wYXJzZWRWdHRGcmFncyA9IHRoaXMudW5wYXJzZWRWdHRGcmFncyB8fCBbXTtcclxuICAgIHRoaXMuaW5pdFBUUyA9IHVuZGVmaW5lZDtcclxuICAgIHRoaXMuY3VlUmFuZ2VzID0gW107XHJcblxyXG4gICAgaWYgKHRoaXMuY29uZmlnLmVuYWJsZVdlYlZUVCkge1xyXG4gICAgICB0aGlzLnRyYWNrcyA9IGRhdGEuc3VidGl0bGVzIHx8IFtdO1xyXG4gICAgICBjb25zdCBpblVzZVRyYWNrcyA9IHRoaXMubWVkaWEgPyB0aGlzLm1lZGlhLnRleHRUcmFja3MgOiBbXTtcclxuXHJcbiAgICAgIHRoaXMudHJhY2tzLmZvckVhY2goKHRyYWNrLCBpbmRleCkgPT4ge1xyXG4gICAgICAgIGxldCB0ZXh0VHJhY2s7XHJcbiAgICAgICAgaWYgKGluZGV4IDwgaW5Vc2VUcmFja3MubGVuZ3RoKSB7XHJcbiAgICAgICAgICBjb25zdCBpblVzZVRyYWNrID0gaW5Vc2VUcmFja3NbaW5kZXhdO1xyXG4gICAgICAgICAgLy8gUmV1c2UgdHJhY2tzIHdpdGggdGhlIHNhbWUgbGFiZWwsIGJ1dCBkbyBub3QgcmV1c2UgNjA4LzcwOCB0cmFja3NcclxuICAgICAgICAgIGlmIChyZXVzZVZ0dFRleHRUcmFjayhpblVzZVRyYWNrLCB0cmFjaykpIHtcclxuICAgICAgICAgICAgdGV4dFRyYWNrID0gaW5Vc2VUcmFjaztcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCF0ZXh0VHJhY2spIHtcclxuICAgICAgICAgICAgdGV4dFRyYWNrID0gdGhpcy5jcmVhdGVUZXh0VHJhY2soJ3N1YnRpdGxlcycsIHRyYWNrLm5hbWUsIHRyYWNrLmxhbmcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0ZXh0VHJhY2subW9kZSA9IHRyYWNrLmRlZmF1bHQgPyAnc2hvd2luZycgOiAnaGlkZGVuJztcclxuICAgICAgICB0aGlzLnRleHRUcmFja3MucHVzaCh0ZXh0VHJhY2spO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIG9uTGV2ZWxTd2l0Y2hpbmcoKSB7XHJcbiAgICB0aGlzLmVuYWJsZWQgPSB0aGlzLmhscy5jdXJyZW50TGV2ZWwuY2xvc2VkQ2FwdGlvbnMgIT09ICdOT05FJztcclxuICB9XHJcblxyXG4gIG9uRnJhZ0xvYWRlZChkYXRhKSB7XHJcbiAgICBsZXQgZnJhZyA9IGRhdGEuZnJhZyxcclxuICAgICAgcGF5bG9hZCA9IGRhdGEucGF5bG9hZDtcclxuICAgIGlmIChmcmFnLnR5cGUgPT09ICdtYWluJykge1xyXG4gICAgICB2YXIgc24gPSBmcmFnLnNuO1xyXG4gICAgICAvLyBpZiB0aGlzIGZyYWcgaXNuJ3QgY29udGlndW91cywgY2xlYXIgdGhlIHBhcnNlciBzbyBjdWVzIHdpdGggYmFkIHN0YXJ0L2VuZCB0aW1lcyBhcmVuJ3QgYWRkZWQgdG8gdGhlIHRleHRUcmFja1xyXG4gICAgICBpZiAoc24gIT09IHRoaXMubGFzdFNuICsgMSkge1xyXG4gICAgICAgIGNvbnN0IGNlYTYwOFBhcnNlciA9IHRoaXMuY2VhNjA4UGFyc2VyO1xyXG4gICAgICAgIGlmIChjZWE2MDhQYXJzZXIpIHtcclxuICAgICAgICAgIGNlYTYwOFBhcnNlci5yZXNldCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICB0aGlzLmxhc3RTbiA9IHNuO1xyXG4gICAgfVxyXG4gICAgLy8gSWYgZnJhZ21lbnQgaXMgc3VidGl0bGUgdHlwZSwgcGFyc2UgYXMgV2ViVlRULlxyXG4gICAgZWxzZSBpZiAoZnJhZy50eXBlID09PSAnc3VidGl0bGUnKSB7XHJcbiAgICAgIGlmIChwYXlsb2FkLmJ5dGVMZW5ndGgpIHtcclxuICAgICAgICAvLyBXZSBuZWVkIGFuIGluaXRpYWwgc3luY2hyb25pc2F0aW9uIFBUUy4gU3RvcmUgZnJhZ21lbnRzIGFzIGxvbmcgYXMgbm9uZSBoYXMgYXJyaXZlZC5cclxuICAgICAgICBpZiAodHlwZW9mIHRoaXMuaW5pdFBUUyA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgIHRoaXMudW5wYXJzZWRWdHRGcmFncy5wdXNoKGRhdGEpO1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgdnR0Q0NzID0gdGhpcy52dHRDQ3M7XHJcbiAgICAgICAgaWYgKCF2dHRDQ3NbZnJhZy5jY10pIHtcclxuICAgICAgICAgIHZ0dENDc1tmcmFnLmNjXSA9IHsgc3RhcnQ6IGZyYWcuc3RhcnQsIHByZXZDQzogdGhpcy5wcmV2Q0MsIG5ldzogdHJ1ZSB9O1xyXG4gICAgICAgICAgdGhpcy5wcmV2Q0MgPSBmcmFnLmNjO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgdGV4dFRyYWNrcyA9IHRoaXMudGV4dFRyYWNrcyxcclxuICAgICAgICAgIGhscyA9IHRoaXMuaGxzO1xyXG5cclxuICAgICAgICAvLyBQYXJzZSB0aGUgV2ViVlRUIGZpbGUgY29udGVudHMuXHJcbiAgICAgICAgV2ViVlRUUGFyc2VyLnBhcnNlKHBheWxvYWQsIHRoaXMuaW5pdFBUUywgdnR0Q0NzLCBmcmFnLmNjLCBmdW5jdGlvbiAoY3Vlcykge1xyXG4gICAgICAgICAgICBjb25zdCBjdXJyZW50VHJhY2sgPSB0ZXh0VHJhY2tzW2ZyYWcudHJhY2tJZF07XHJcbiAgICAgICAgICAgIC8vIEFkZCBjdWVzIGFuZCB0cmlnZ2VyIGV2ZW50IHdpdGggc3VjY2VzcyB0cnVlLlxyXG4gICAgICAgICAgICBjdWVzLmZvckVhY2goY3VlID0+IHtcclxuICAgICAgICAgICAgICAvLyBTb21ldGltZXMgdGhlcmUgYXJlIGN1ZSBvdmVybGFwcyBvbiBzZWdtZW50ZWQgdnR0cyBzbyB0aGUgc2FtZVxyXG4gICAgICAgICAgICAgIC8vIGN1ZSBjYW4gYXBwZWFyIG1vcmUgdGhhbiBvbmNlIGluIGRpZmZlcmVudCB2dHQgZmlsZXMuXHJcbiAgICAgICAgICAgICAgLy8gVGhpcyBhdm9pZCBzaG93aW5nIGR1cGxpY2F0ZWQgY3VlcyB3aXRoIHNhbWUgdGltZWNvZGUgYW5kIHRleHQuXHJcbiAgICAgICAgICAgICAgaWYgKCFjdXJyZW50VHJhY2suY3Vlcy5nZXRDdWVCeUlkKGN1ZS5pZCkpIHtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRUcmFjay5hZGRDdWUoY3VlKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBobHMudHJpZ2dlcihFdmVudC5TVUJUSVRMRV9GUkFHX1BST0NFU1NFRCwge3N1Y2Nlc3M6IHRydWUsIGZyYWc6IGZyYWd9KTtcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAvLyBTb21ldGhpbmcgd2VudCB3cm9uZyB3aGlsZSBwYXJzaW5nLiBUcmlnZ2VyIGV2ZW50IHdpdGggc3VjY2VzcyBmYWxzZS5cclxuICAgICAgICAgICAgbG9nZ2VyLmxvZyhgRmFpbGVkIHRvIHBhcnNlIFZUVCBjdWU6ICR7ZX1gKTtcclxuICAgICAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnQuU1VCVElUTEVfRlJBR19QUk9DRVNTRUQsIHtzdWNjZXNzOiBmYWxzZSwgZnJhZzogZnJhZ30pO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSB7XHJcbiAgICAgICAgLy8gSW4gY2FzZSB0aGVyZSBpcyBubyBwYXlsb2FkLCBmaW5pc2ggdW5zdWNjZXNzZnVsbHkuXHJcbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5TVUJUSVRMRV9GUkFHX1BST0NFU1NFRCwge3N1Y2Nlc3M6IGZhbHNlLCBmcmFnOiBmcmFnfSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIG9uRnJhZ1BhcnNpbmdVc2VyZGF0YShkYXRhKSB7XHJcbiAgICAvLyBwdXNoIGFsbCBvZiB0aGUgQ0VBLTcwOCBtZXNzYWdlcyBpbnRvIHRoZSBpbnRlcnByZXRlclxyXG4gICAgLy8gaW1tZWRpYXRlbHkuIEl0IHdpbGwgY3JlYXRlIHRoZSBwcm9wZXIgdGltZXN0YW1wcyBiYXNlZCBvbiBvdXIgUFRTIHZhbHVlXHJcbiAgICBpZiAodGhpcy5lbmFibGVkICYmIHRoaXMuY29uZmlnLmVuYWJsZUNFQTcwOENhcHRpb25zKSB7XHJcbiAgICAgIGZvciAodmFyIGk9MDsgaTxkYXRhLnNhbXBsZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICB2YXIgY2NkYXRhcyA9IHRoaXMuZXh0cmFjdENlYTYwOERhdGEoZGF0YS5zYW1wbGVzW2ldLmJ5dGVzKTtcclxuICAgICAgICB0aGlzLmNlYTYwOFBhcnNlci5hZGREYXRhKGRhdGEuc2FtcGxlc1tpXS5wdHMsIGNjZGF0YXMpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBleHRyYWN0Q2VhNjA4RGF0YShieXRlQXJyYXkpIHtcclxuICAgIHZhciBjb3VudCA9IGJ5dGVBcnJheVswXSAmIDMxO1xyXG4gICAgdmFyIHBvc2l0aW9uID0gMjtcclxuICAgIHZhciB0bXBCeXRlLCBjY2J5dGUxLCBjY2J5dGUyLCBjY1ZhbGlkLCBjY1R5cGU7XHJcbiAgICB2YXIgYWN0dWFsQ0NCeXRlcyA9IFtdO1xyXG5cclxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgY291bnQ7IGorKykge1xyXG4gICAgICB0bXBCeXRlID0gYnl0ZUFycmF5W3Bvc2l0aW9uKytdO1xyXG4gICAgICBjY2J5dGUxID0gMHg3RiAmIGJ5dGVBcnJheVtwb3NpdGlvbisrXTtcclxuICAgICAgY2NieXRlMiA9IDB4N0YgJiBieXRlQXJyYXlbcG9zaXRpb24rK107XHJcbiAgICAgIGNjVmFsaWQgPSAoNCAmIHRtcEJ5dGUpICE9PSAwO1xyXG4gICAgICBjY1R5cGUgPSAzICYgdG1wQnl0ZTtcclxuXHJcbiAgICAgIGlmIChjY2J5dGUxID09PSAwICYmIGNjYnl0ZTIgPT09IDApIHtcclxuICAgICAgICBjb250aW51ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGNjVmFsaWQpIHtcclxuICAgICAgICBpZiAoY2NUeXBlID09PSAwKSAvLyB8fCBjY1R5cGUgPT09IDFcclxuICAgICAgICB7XHJcbiAgICAgICAgICBhY3R1YWxDQ0J5dGVzLnB1c2goY2NieXRlMSk7XHJcbiAgICAgICAgICBhY3R1YWxDQ0J5dGVzLnB1c2goY2NieXRlMik7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYWN0dWFsQ0NCeXRlcztcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IFRpbWVsaW5lQ29udHJvbGxlcjtcclxuIiwiZXhwb3J0IGRlZmF1bHQgY2xhc3MgQUVTQ3J5cHRvIHtcclxuICBjb25zdHJ1Y3RvcihzdWJ0bGUsaXYpIHtcclxuICAgIHRoaXMuc3VidGxlID0gc3VidGxlO1xyXG4gICAgdGhpcy5hZXNJViA9IGl2O1xyXG4gIH1cclxuXHJcbiAgZGVjcnlwdChkYXRhLCBrZXkpIHtcclxuICAgIHJldHVybiB0aGlzLnN1YnRsZS5kZWNyeXB0KHtuYW1lOiAnQUVTLUNCQycsIGl2OiB0aGlzLmFlc0lWfSwga2V5LCBkYXRhKTtcclxuICB9XHJcbn1cclxuIiwiY2xhc3MgQUVTRGVjcnlwdG9yIHtcclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIC8vIFN0YXRpYyBhZnRlciBydW5uaW5nIGluaXRUYWJsZVxyXG4gICAgdGhpcy5yY29uID0gWzB4MCwgMHgxLCAweDIsIDB4NCwgMHg4LCAweDEwLCAweDIwLCAweDQwLCAweDgwLCAweDFiLCAweDM2XTtcclxuICAgIHRoaXMuc3ViTWl4ID0gW25ldyBVaW50MzJBcnJheSgyNTYpLG5ldyBVaW50MzJBcnJheSgyNTYpLG5ldyBVaW50MzJBcnJheSgyNTYpLG5ldyBVaW50MzJBcnJheSgyNTYpXTtcclxuICAgIHRoaXMuaW52U3ViTWl4ID0gW25ldyBVaW50MzJBcnJheSgyNTYpLG5ldyBVaW50MzJBcnJheSgyNTYpLG5ldyBVaW50MzJBcnJheSgyNTYpLG5ldyBVaW50MzJBcnJheSgyNTYpXTtcclxuICAgIHRoaXMuc0JveCA9IG5ldyBVaW50MzJBcnJheSgyNTYpO1xyXG4gICAgdGhpcy5pbnZTQm94ID0gbmV3IFVpbnQzMkFycmF5KDI1Nik7XHJcblxyXG4gICAgLy8gQ2hhbmdlcyBkdXJpbmcgcnVudGltZVxyXG4gICAgdGhpcy5rZXkgPSBuZXcgVWludDMyQXJyYXkoMCk7XHJcblxyXG4gICAgdGhpcy5pbml0VGFibGUoKTtcclxuICB9XHJcblxyXG4gIC8vIFVzaW5nIHZpZXcuZ2V0VWludDMyKCkgYWxzbyBzd2FwcyB0aGUgYnl0ZSBvcmRlci5cclxuICB1aW50OEFycmF5VG9VaW50MzJBcnJheV8oYXJyYXlCdWZmZXIpIHtcclxuICAgIGxldCB2aWV3ID0gbmV3IERhdGFWaWV3KGFycmF5QnVmZmVyKTtcclxuICAgIGxldCBuZXdBcnJheSA9IG5ldyBVaW50MzJBcnJheSg0KTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKSB7XHJcbiAgICAgIG5ld0FycmF5W2ldID0gdmlldy5nZXRVaW50MzIoaSAqIDQpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5ld0FycmF5O1xyXG4gIH1cclxuXHJcbiAgaW5pdFRhYmxlKCkge1xyXG4gICAgbGV0IHNCb3ggPSB0aGlzLnNCb3g7XHJcbiAgICBsZXQgaW52U0JveCA9IHRoaXMuaW52U0JveDtcclxuICAgIGxldCBzdWJNaXggPSB0aGlzLnN1Yk1peDtcclxuICAgIGxldCBzdWJNaXgwID0gc3ViTWl4WzBdO1xyXG4gICAgbGV0IHN1Yk1peDEgPSBzdWJNaXhbMV07XHJcbiAgICBsZXQgc3ViTWl4MiA9IHN1Yk1peFsyXTtcclxuICAgIGxldCBzdWJNaXgzID0gc3ViTWl4WzNdO1xyXG4gICAgbGV0IGludlN1Yk1peCAgPSB0aGlzLmludlN1Yk1peDtcclxuICAgIGxldCBpbnZTdWJNaXgwID0gaW52U3ViTWl4WzBdO1xyXG4gICAgbGV0IGludlN1Yk1peDEgPSBpbnZTdWJNaXhbMV07XHJcbiAgICBsZXQgaW52U3ViTWl4MiA9IGludlN1Yk1peFsyXTtcclxuICAgIGxldCBpbnZTdWJNaXgzID0gaW52U3ViTWl4WzNdO1xyXG5cclxuICAgIGxldCBkID0gbmV3IFVpbnQzMkFycmF5KDI1Nik7XHJcbiAgICBsZXQgeCA9IDA7XHJcbiAgICBsZXQgeGkgPSAwO1xyXG4gICAgbGV0IGkgPSAwO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IDI1NjsgaSsrKSB7XHJcbiAgICAgIGlmIChpIDwgMTI4KSB7XHJcbiAgICAgICAgZFtpXSA9IGkgPDwgMTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBkW2ldID0gKGkgPDwgMSkgXiAweDExYjtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZvciAoaSA9IDA7IGkgPCAyNTY7IGkrKykge1xyXG4gICAgICBsZXQgc3ggPSB4aSBeICh4aSA8PCAxKSBeICh4aSA8PCAyKSBeICh4aSA8PCAzKSBeICh4aSA8PCA0KTtcclxuICAgICAgc3ggPSAoc3ggPj4+IDgpIF4gKHN4ICYgMHhmZikgXiAweDYzO1xyXG4gICAgICBzQm94W3hdID0gc3g7XHJcbiAgICAgIGludlNCb3hbc3hdID0geDtcclxuXHJcbiAgICAgIC8vIENvbXB1dGUgbXVsdGlwbGljYXRpb25cclxuICAgICAgbGV0IHgyID0gZFt4XTtcclxuICAgICAgbGV0IHg0ID0gZFt4Ml07XHJcbiAgICAgIGxldCB4OCA9IGRbeDRdO1xyXG5cclxuICAgICAgLy8gQ29tcHV0ZSBzdWIvaW52U3ViIGJ5dGVzLCBtaXggY29sdW1ucyB0YWJsZXNcclxuICAgICAgbGV0IHQgPSAoZFtzeF0gKiAweDEwMSkgXiAoc3ggKiAweDEwMTAxMDApO1xyXG4gICAgICBzdWJNaXgwW3hdID0gKHQgPDwgMjQpIHwgKHQgPj4+IDgpO1xyXG4gICAgICBzdWJNaXgxW3hdID0gKHQgPDwgMTYpIHwgKHQgPj4+IDE2KTtcclxuICAgICAgc3ViTWl4Mlt4XSA9ICh0IDw8IDgpIHwgKHQgPj4+IDI0KTtcclxuICAgICAgc3ViTWl4M1t4XSA9IHQ7XHJcblxyXG4gICAgICAvLyBDb21wdXRlIGludiBzdWIgYnl0ZXMsIGludiBtaXggY29sdW1ucyB0YWJsZXNcclxuICAgICAgdCA9ICh4OCAqIDB4MTAxMDEwMSkgXiAoeDQgKiAweDEwMDAxKSBeICh4MiAqIDB4MTAxKSBeICh4ICogMHgxMDEwMTAwKTtcclxuICAgICAgaW52U3ViTWl4MFtzeF0gPSAodCA8PCAyNCkgfCAodCA+Pj4gOCk7XHJcbiAgICAgIGludlN1Yk1peDFbc3hdID0gKHQgPDwgMTYpIHwgKHQgPj4+IDE2KTtcclxuICAgICAgaW52U3ViTWl4MltzeF0gPSAodCA8PCA4KSB8ICh0ID4+PiAyNCk7XHJcbiAgICAgIGludlN1Yk1peDNbc3hdID0gdDtcclxuXHJcbiAgICAgIC8vIENvbXB1dGUgbmV4dCBjb3VudGVyXHJcbiAgICAgIGlmICgheCkge1xyXG4gICAgICAgIHggPSB4aSA9IDE7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgeCA9IHgyIF4gZFtkW2RbeDggXiB4Ml1dXTtcclxuICAgICAgICB4aSBePSBkW2RbeGldXTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZXhwYW5kS2V5KGtleUJ1ZmZlcikge1xyXG4gICAgLy8gY29udmVydCBrZXlCdWZmZXIgdG8gVWludDMyQXJyYXlcclxuICAgIGxldCBrZXkgPSB0aGlzLnVpbnQ4QXJyYXlUb1VpbnQzMkFycmF5XyhrZXlCdWZmZXIpO1xyXG4gICAgbGV0IHNhbWVLZXkgPSB0cnVlO1xyXG4gICAgbGV0IG9mZnNldCA9IDA7XHJcblxyXG4gICAgd2hpbGUgKG9mZnNldCA8IGtleS5sZW5ndGggJiYgc2FtZUtleSkge1xyXG4gICAgICBzYW1lS2V5ID0gKGtleVtvZmZzZXRdID09PSB0aGlzLmtleVtvZmZzZXRdKTtcclxuICAgICAgb2Zmc2V0Kys7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHNhbWVLZXkpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMua2V5ID0ga2V5O1xyXG4gICAgbGV0IGtleVNpemUgPSB0aGlzLmtleVNpemUgPSBrZXkubGVuZ3RoO1xyXG5cclxuICAgIGlmIChrZXlTaXplICE9PSA0ICYmIGtleVNpemUgIT09IDYgJiYga2V5U2l6ZSAhPT0gOCkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYWVzIGtleSBzaXplPScgKyBrZXlTaXplKTtcclxuICAgIH1cclxuXHJcbiAgICBsZXQga3NSb3dzID0gdGhpcy5rc1Jvd3MgPSAoa2V5U2l6ZSArIDYgKyAxKSAqIDQ7XHJcbiAgICBsZXQga3NSb3c7XHJcbiAgICBsZXQgaW52S3NSb3c7XHJcblxyXG4gICAgbGV0IGtleVNjaGVkdWxlID0gdGhpcy5rZXlTY2hlZHVsZSA9IG5ldyBVaW50MzJBcnJheShrc1Jvd3MpO1xyXG4gICAgbGV0IGludktleVNjaGVkdWxlID0gdGhpcy5pbnZLZXlTY2hlZHVsZSA9IG5ldyBVaW50MzJBcnJheShrc1Jvd3MpO1xyXG4gICAgbGV0IHNib3ggPSB0aGlzLnNCb3g7XHJcbiAgICBsZXQgcmNvbiA9IHRoaXMucmNvbjtcclxuXHJcbiAgICBsZXQgaW52U3ViTWl4ICA9IHRoaXMuaW52U3ViTWl4O1xyXG4gICAgbGV0IGludlN1Yk1peDAgPSBpbnZTdWJNaXhbMF07XHJcbiAgICBsZXQgaW52U3ViTWl4MSA9IGludlN1Yk1peFsxXTtcclxuICAgIGxldCBpbnZTdWJNaXgyID0gaW52U3ViTWl4WzJdO1xyXG4gICAgbGV0IGludlN1Yk1peDMgPSBpbnZTdWJNaXhbM107XHJcblxyXG4gICAgbGV0IHByZXY7XHJcbiAgICBsZXQgdDtcclxuXHJcbiAgICBmb3IgKGtzUm93ID0gMDsga3NSb3cgPCBrc1Jvd3M7IGtzUm93KyspIHtcclxuICAgICAgaWYgKGtzUm93IDwga2V5U2l6ZSkge1xyXG4gICAgICAgIHByZXYgPSBrZXlTY2hlZHVsZVtrc1Jvd10gPSBrZXlba3NSb3ddO1xyXG4gICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICB9XHJcbiAgICAgIHQgPSBwcmV2O1xyXG5cclxuICAgICAgaWYgKGtzUm93ICUga2V5U2l6ZSA9PT0gMCkge1xyXG4gICAgICAgIC8vIFJvdCB3b3JkXHJcbiAgICAgICAgdCA9ICh0IDw8IDgpIHwgKHQgPj4+IDI0KTtcclxuXHJcbiAgICAgICAgLy8gU3ViIHdvcmRcclxuICAgICAgICB0ID0gKHNib3hbdCA+Pj4gMjRdIDw8IDI0KSB8IChzYm94Wyh0ID4+PiAxNikgJiAweGZmXSA8PCAxNikgfCAoc2JveFsodCA+Pj4gOCkgJiAweGZmXSA8PCA4KSB8IHNib3hbdCAmIDB4ZmZdO1xyXG5cclxuICAgICAgICAvLyBNaXggUmNvblxyXG4gICAgICAgIHQgXj0gcmNvblsoa3NSb3cgLyBrZXlTaXplKSB8IDBdIDw8IDI0O1xyXG4gICAgICB9IGVsc2UgaWYgKGtleVNpemUgPiA2ICYmIGtzUm93ICUga2V5U2l6ZSA9PT0gNCkgIHtcclxuICAgICAgICAvLyBTdWIgd29yZFxyXG4gICAgICAgIHQgPSAoc2JveFt0ID4+PiAyNF0gPDwgMjQpIHwgKHNib3hbKHQgPj4+IDE2KSAmIDB4ZmZdIDw8IDE2KSB8IChzYm94Wyh0ID4+PiA4KSAmIDB4ZmZdIDw8IDgpIHwgc2JveFt0ICYgMHhmZl07XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGtleVNjaGVkdWxlW2tzUm93XSA9IHByZXYgPSAoa2V5U2NoZWR1bGVba3NSb3cgLSBrZXlTaXplXSBeIHQpID4+PiAwO1xyXG4gICAgfVxyXG5cclxuICAgIGZvciAoaW52S3NSb3cgPSAwOyBpbnZLc1JvdyA8IGtzUm93czsgaW52S3NSb3crKykge1xyXG4gICAgICBrc1JvdyA9IGtzUm93cyAtIGludktzUm93O1xyXG4gICAgICBpZiAoaW52S3NSb3cgJiAzKSB7XHJcbiAgICAgICAgdCA9IGtleVNjaGVkdWxlW2tzUm93XTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0ID0ga2V5U2NoZWR1bGVba3NSb3cgLSA0XTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGludktzUm93IDwgNCB8fCBrc1JvdyA8PSA0KSB7XHJcbiAgICAgICAgaW52S2V5U2NoZWR1bGVbaW52S3NSb3ddID0gdDtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBpbnZLZXlTY2hlZHVsZVtpbnZLc1Jvd10gPSBpbnZTdWJNaXgwW3Nib3hbdCA+Pj4gMjRdXSBeIGludlN1Yk1peDFbc2JveFsodCA+Pj4gMTYpICYgMHhmZl1dIF4gaW52U3ViTWl4MltzYm94Wyh0ID4+PiA4KSAmIDB4ZmZdXSBeIGludlN1Yk1peDNbc2JveFt0ICYgMHhmZl1dO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpbnZLZXlTY2hlZHVsZVtpbnZLc1Jvd10gPSBpbnZLZXlTY2hlZHVsZVtpbnZLc1Jvd10gPj4+IDA7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBBZGRpbmcgdGhpcyBhcyBhIG1ldGhvZCBncmVhdGx5IGltcHJvdmVzIHBlcmZvcm1hbmNlLlxyXG4gIG5ldHdvcmtUb0hvc3RPcmRlclN3YXAod29yZCkge1xyXG4gICAgcmV0dXJuICh3b3JkIDw8IDI0KSB8ICgod29yZCAmIDB4ZmYwMCkgPDwgOCkgfCAoKHdvcmQgJiAweGZmMDAwMCkgPj4gOCkgfCAod29yZCA+Pj4gMjQpO1xyXG4gIH1cclxuXHJcbiAgZGVjcnlwdChpbnB1dEFycmF5QnVmZmVyLCBvZmZzZXQsIGFlc0lWKSB7XHJcbiAgICBsZXQgblJvdW5kcyA9IHRoaXMua2V5U2l6ZSArIDY7XHJcbiAgICBsZXQgaW52S2V5U2NoZWR1bGUgPSB0aGlzLmludktleVNjaGVkdWxlO1xyXG4gICAgbGV0IGludlNCT1ggPSB0aGlzLmludlNCb3g7XHJcblxyXG4gICAgbGV0IGludlN1Yk1peCAgPSB0aGlzLmludlN1Yk1peDtcclxuICAgIGxldCBpbnZTdWJNaXgwID0gaW52U3ViTWl4WzBdO1xyXG4gICAgbGV0IGludlN1Yk1peDEgPSBpbnZTdWJNaXhbMV07XHJcbiAgICBsZXQgaW52U3ViTWl4MiA9IGludlN1Yk1peFsyXTtcclxuICAgIGxldCBpbnZTdWJNaXgzID0gaW52U3ViTWl4WzNdO1xyXG5cclxuICAgIGxldCBpbml0VmVjdG9yID0gdGhpcy51aW50OEFycmF5VG9VaW50MzJBcnJheV8oYWVzSVYpO1xyXG4gICAgbGV0IGluaXRWZWN0b3IwID0gaW5pdFZlY3RvclswXTtcclxuICAgIGxldCBpbml0VmVjdG9yMSA9IGluaXRWZWN0b3JbMV07XHJcbiAgICBsZXQgaW5pdFZlY3RvcjIgPSBpbml0VmVjdG9yWzJdO1xyXG4gICAgbGV0IGluaXRWZWN0b3IzID0gaW5pdFZlY3RvclszXTtcclxuXHJcbiAgICBsZXQgaW5wdXRJbnQzMiA9IG5ldyBJbnQzMkFycmF5KGlucHV0QXJyYXlCdWZmZXIpO1xyXG4gICAgbGV0IG91dHB1dEludDMyID0gbmV3IEludDMyQXJyYXkoaW5wdXRJbnQzMi5sZW5ndGgpO1xyXG5cclxuICAgIGxldCB0MCwgdDEsIHQyLCB0MztcclxuICAgIGxldCBzMCwgczEsIHMyLCBzMztcclxuICAgIGxldCBpbnB1dFdvcmRzMCwgaW5wdXRXb3JkczEsIGlucHV0V29yZHMyLCBpbnB1dFdvcmRzMztcclxuXHJcbiAgICB2YXIga3NSb3csIGk7XHJcbiAgICBsZXQgc3dhcFdvcmQgPSB0aGlzLm5ldHdvcmtUb0hvc3RPcmRlclN3YXA7XHJcblxyXG4gICAgd2hpbGUgKG9mZnNldCA8IGlucHV0SW50MzIubGVuZ3RoKSB7XHJcbiAgICAgIGlucHV0V29yZHMwID0gc3dhcFdvcmQoaW5wdXRJbnQzMltvZmZzZXRdKTtcclxuICAgICAgaW5wdXRXb3JkczEgPSBzd2FwV29yZChpbnB1dEludDMyW29mZnNldCArIDFdKTtcclxuICAgICAgaW5wdXRXb3JkczIgPSBzd2FwV29yZChpbnB1dEludDMyW29mZnNldCArIDJdKTtcclxuICAgICAgaW5wdXRXb3JkczMgPSBzd2FwV29yZChpbnB1dEludDMyW29mZnNldCArIDNdKTtcclxuXHJcbiAgICAgIHMwID0gaW5wdXRXb3JkczAgXiBpbnZLZXlTY2hlZHVsZVswXTtcclxuICAgICAgczEgPSBpbnB1dFdvcmRzMyBeIGludktleVNjaGVkdWxlWzFdO1xyXG4gICAgICBzMiA9IGlucHV0V29yZHMyIF4gaW52S2V5U2NoZWR1bGVbMl07XHJcbiAgICAgIHMzID0gaW5wdXRXb3JkczEgXiBpbnZLZXlTY2hlZHVsZVszXTtcclxuXHJcbiAgICAgIGtzUm93ID0gNDtcclxuXHJcbiAgICAgIC8vIEl0ZXJhdGUgdGhyb3VnaCB0aGUgcm91bmRzIG9mIGRlY3J5cHRpb25cclxuICAgICAgZm9yIChpID0gMTsgaSA8IG5Sb3VuZHM7IGkrKykge1xyXG4gICAgICAgIHQwID0gaW52U3ViTWl4MFtzMCA+Pj4gMjRdIF4gaW52U3ViTWl4MVsoczEgPj4gMTYpICYgMHhmZl0gXiBpbnZTdWJNaXgyWyhzMiA+PiA4KSAmIDB4ZmZdIF4gaW52U3ViTWl4M1tzMyAmIDB4ZmZdIF4gaW52S2V5U2NoZWR1bGVba3NSb3ddO1xyXG4gICAgICAgIHQxID0gaW52U3ViTWl4MFtzMSA+Pj4gMjRdIF4gaW52U3ViTWl4MVsoczIgPj4gMTYpICYgMHhmZl0gXiBpbnZTdWJNaXgyWyhzMyA+PiA4KSAmIDB4ZmZdIF4gaW52U3ViTWl4M1tzMCAmIDB4ZmZdIF4gaW52S2V5U2NoZWR1bGVba3NSb3cgKyAxXTtcclxuICAgICAgICB0MiA9IGludlN1Yk1peDBbczIgPj4+IDI0XSBeIGludlN1Yk1peDFbKHMzID4+IDE2KSAmIDB4ZmZdIF4gaW52U3ViTWl4MlsoczAgPj4gOCkgJiAweGZmXSBeIGludlN1Yk1peDNbczEgJiAweGZmXSBeIGludktleVNjaGVkdWxlW2tzUm93ICsgMl07XHJcbiAgICAgICAgdDMgPSBpbnZTdWJNaXgwW3MzID4+PiAyNF0gXiBpbnZTdWJNaXgxWyhzMCA+PiAxNikgJiAweGZmXSBeIGludlN1Yk1peDJbKHMxID4+IDgpICYgMHhmZl0gXiBpbnZTdWJNaXgzW3MyICYgMHhmZl0gXiBpbnZLZXlTY2hlZHVsZVtrc1JvdyArIDNdO1xyXG4gICAgICAgIC8vIFVwZGF0ZSBzdGF0ZVxyXG4gICAgICAgIHMwID0gdDA7XHJcbiAgICAgICAgczEgPSB0MTtcclxuICAgICAgICBzMiA9IHQyO1xyXG4gICAgICAgIHMzID0gdDM7XHJcblxyXG4gICAgICAgIGtzUm93ID0ga3NSb3cgKyA0O1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBTaGlmdCByb3dzLCBzdWIgYnl0ZXMsIGFkZCByb3VuZCBrZXlcclxuICAgICAgdDAgPSAoKGludlNCT1hbczAgPj4+IDI0XSA8PCAyNCkgXiAoaW52U0JPWFsoczEgPj4gMTYpICYgMHhmZl0gPDwgMTYpIF4gKGludlNCT1hbKHMyID4+IDgpICYgMHhmZl0gPDwgOCkgXiBpbnZTQk9YW3MzICYgMHhmZl0pIF4gaW52S2V5U2NoZWR1bGVba3NSb3ddO1xyXG4gICAgICB0MSA9ICgoaW52U0JPWFtzMSA+Pj4gMjRdIDw8IDI0KSBeIChpbnZTQk9YWyhzMiA+PiAxNikgJiAweGZmXSA8PCAxNikgXiAoaW52U0JPWFsoczMgPj4gOCkgJiAweGZmXSA8PCA4KSBeIGludlNCT1hbczAgJiAweGZmXSkgXiBpbnZLZXlTY2hlZHVsZVtrc1JvdyArIDFdO1xyXG4gICAgICB0MiA9ICgoaW52U0JPWFtzMiA+Pj4gMjRdIDw8IDI0KSBeIChpbnZTQk9YWyhzMyA+PiAxNikgJiAweGZmXSA8PCAxNikgXiAoaW52U0JPWFsoczAgPj4gOCkgJiAweGZmXSA8PCA4KSBeIGludlNCT1hbczEgJiAweGZmXSkgXiBpbnZLZXlTY2hlZHVsZVtrc1JvdyArIDJdO1xyXG4gICAgICB0MyA9ICgoaW52U0JPWFtzMyA+Pj4gMjRdIDw8IDI0KSBeIChpbnZTQk9YWyhzMCA+PiAxNikgJiAweGZmXSA8PCAxNikgXiAoaW52U0JPWFsoczEgPj4gOCkgJiAweGZmXSA8PCA4KSBeIGludlNCT1hbczIgJiAweGZmXSkgXiBpbnZLZXlTY2hlZHVsZVtrc1JvdyArIDNdO1xyXG4gICAgICBrc1JvdyA9IGtzUm93ICsgMztcclxuXHJcbiAgICAgIC8vIFdyaXRlXHJcbiAgICAgIG91dHB1dEludDMyW29mZnNldF0gPSBzd2FwV29yZCh0MCBeIGluaXRWZWN0b3IwKTtcclxuICAgICAgb3V0cHV0SW50MzJbb2Zmc2V0ICsgMV0gPSBzd2FwV29yZCh0MyBeIGluaXRWZWN0b3IxKTtcclxuICAgICAgb3V0cHV0SW50MzJbb2Zmc2V0ICsgMl0gPSBzd2FwV29yZCh0MiBeIGluaXRWZWN0b3IyKTtcclxuICAgICAgb3V0cHV0SW50MzJbb2Zmc2V0ICsgM10gPSBzd2FwV29yZCh0MSBeIGluaXRWZWN0b3IzKTtcclxuXHJcbiAgICAgIC8vIHJlc2V0IGluaXRWZWN0b3IgdG8gbGFzdCA0IHVuc2lnbmVkIGludFxyXG4gICAgICBpbml0VmVjdG9yMCA9IGlucHV0V29yZHMwO1xyXG4gICAgICBpbml0VmVjdG9yMSA9IGlucHV0V29yZHMxO1xyXG4gICAgICBpbml0VmVjdG9yMiA9IGlucHV0V29yZHMyO1xyXG4gICAgICBpbml0VmVjdG9yMyA9IGlucHV0V29yZHMzO1xyXG5cclxuICAgICAgb2Zmc2V0ID0gb2Zmc2V0ICsgNDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gb3V0cHV0SW50MzIuYnVmZmVyO1xyXG4gIH1cclxuXHJcbiAgZGVzdHJveSgpIHtcclxuICAgIHRoaXMua2V5ID0gdW5kZWZpbmVkO1xyXG4gICAgdGhpcy5rZXlTaXplID0gdW5kZWZpbmVkO1xyXG4gICAgdGhpcy5rc1Jvd3MgPSB1bmRlZmluZWQ7XHJcblxyXG4gICAgdGhpcy5zQm94ID0gdW5kZWZpbmVkO1xyXG4gICAgdGhpcy5pbnZTQm94ID0gdW5kZWZpbmVkO1xyXG4gICAgdGhpcy5zdWJNaXggPSB1bmRlZmluZWQ7XHJcbiAgICB0aGlzLmludlN1Yk1peCA9IHVuZGVmaW5lZDtcclxuICAgIHRoaXMua2V5U2NoZWR1bGUgPSB1bmRlZmluZWQ7XHJcbiAgICB0aGlzLmludktleVNjaGVkdWxlID0gdW5kZWZpbmVkO1xyXG5cclxuICAgIHRoaXMucmNvbiA9IHVuZGVmaW5lZDtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IEFFU0RlY3J5cHRvcjtcclxuIiwiaW1wb3J0IEFFU0NyeXB0byBmcm9tICcuL2Flcy1jcnlwdG8nO1xyXG5pbXBvcnQgRmFzdEFFU0tleSBmcm9tICcuL2Zhc3QtYWVzLWtleSc7XHJcbmltcG9ydCBBRVNEZWNyeXB0b3IgZnJvbSAnLi9hZXMtZGVjcnlwdG9yJztcclxuXHJcbmltcG9ydCB7RXJyb3JUeXBlcywgRXJyb3JEZXRhaWxzfSBmcm9tICcuLi9lcnJvcnMnO1xyXG5pbXBvcnQge2xvZ2dlcn0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcclxuXHJcbi8qZ2xvYmFscyBzZWxmOiBmYWxzZSAqL1xyXG5cclxuY2xhc3MgRGVjcnlwdGVyIHtcclxuICBjb25zdHJ1Y3RvcihvYnNlcnZlcixjb25maWcpIHtcclxuICAgIHRoaXMub2JzZXJ2ZXIgPSBvYnNlcnZlcjtcclxuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xyXG4gICAgdGhpcy5sb2dFbmFibGVkID0gdHJ1ZTtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IGJyb3dzZXJDcnlwdG8gPSBjcnlwdG8gPyBjcnlwdG8gOiBzZWxmLmNyeXB0bztcclxuICAgICAgdGhpcy5zdWJ0bGUgPSBicm93c2VyQ3J5cHRvLnN1YnRsZSB8fCBicm93c2VyQ3J5cHRvLndlYmtpdFN1YnRsZTtcclxuICAgIH0gY2F0Y2ggKGUpIHt9XHJcbiAgICB0aGlzLmRpc2FibGVXZWJDcnlwdG8gPSAhdGhpcy5zdWJ0bGU7XHJcbiAgfVxyXG5cclxuICBpc1N5bmMoKSB7XHJcbiAgICByZXR1cm4gKHRoaXMuZGlzYWJsZVdlYkNyeXB0byAmJiB0aGlzLmNvbmZpZy5lbmFibGVTb2Z0d2FyZUFFUyk7XHJcbiAgfVxyXG5cclxuICBkZWNyeXB0KGRhdGEsIGtleSwgaXYsIGNhbGxiYWNrKSB7XHJcbiAgICBpZiAodGhpcy5kaXNhYmxlV2ViQ3J5cHRvICYmIHRoaXMuY29uZmlnLmVuYWJsZVNvZnR3YXJlQUVTKSB7XHJcbiAgICAgIGlmICh0aGlzLmxvZ0VuYWJsZWQpIHtcclxuICAgICAgICBsb2dnZXIubG9nKCdKUyBBRVMgZGVjcnlwdCcpO1xyXG4gICAgICAgIHRoaXMubG9nRW5hYmxlZCA9IGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICAgIGxldCBkZWNyeXB0b3IgPSB0aGlzLmRlY3J5cHRvcjtcclxuICAgICAgaWYgKCFkZWNyeXB0b3IpIHtcclxuICAgICAgICB0aGlzLmRlY3J5cHRvciA9IGRlY3J5cHRvciA9IG5ldyBBRVNEZWNyeXB0b3IoKTtcclxuICAgICAgfVxyXG4gICAgICBkZWNyeXB0b3IuZXhwYW5kS2V5KGtleSk7XHJcbiAgICAgIGNhbGxiYWNrKGRlY3J5cHRvci5kZWNyeXB0KGRhdGEsIDAsIGl2KSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgaWYgKHRoaXMubG9nRW5hYmxlZCkge1xyXG4gICAgICAgIGxvZ2dlci5sb2coJ1dlYkNyeXB0byBBRVMgZGVjcnlwdCcpO1xyXG4gICAgICAgIHRoaXMubG9nRW5hYmxlZCA9IGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IHN1YnRsZSA9IHRoaXMuc3VidGxlO1xyXG4gICAgICBpZiAodGhpcy5rZXkgIT09IGtleSkge1xyXG4gICAgICAgIHRoaXMua2V5ID0ga2V5O1xyXG4gICAgICAgIHRoaXMuZmFzdEFlc0tleSA9IG5ldyBGYXN0QUVTS2V5KHN1YnRsZSxrZXkpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLmZhc3RBZXNLZXkuZXhwYW5kS2V5KCkuXHJcbiAgICAgICAgdGhlbigoYWVzS2V5KSA9PiB7XHJcbiAgICAgICAgICAvLyBkZWNyeXB0IHVzaW5nIHdlYiBjcnlwdG9cclxuICAgICAgICAgIGxldCBjcnlwdG8gPSBuZXcgQUVTQ3J5cHRvKHN1YnRsZSxpdik7XHJcbiAgICAgICAgICBjcnlwdG8uZGVjcnlwdChkYXRhLCBhZXNLZXkpLlxyXG4gICAgICAgICAgY2F0Y2ggKChlcnIpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5vbldlYkNyeXB0b0Vycm9yKGVyciwgZGF0YSwga2V5LCBpdiwgY2FsbGJhY2spO1xyXG4gICAgICAgICAgfSkuXHJcbiAgICAgICAgICB0aGVuKChyZXN1bHQpID0+IHtcclxuICAgICAgICAgICAgY2FsbGJhY2socmVzdWx0KTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pLlxyXG4gICAgICAgIGNhdGNoICgoZXJyKSA9PiB7XHJcbiAgICAgICAgICB0aGlzLm9uV2ViQ3J5cHRvRXJyb3IoZXJyLCBkYXRhLCBrZXksIGl2LCBjYWxsYmFjayk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBvbldlYkNyeXB0b0Vycm9yKGVyciwgZGF0YSwga2V5LCBpdiwgY2FsbGJhY2spIHtcclxuICAgIGlmICh0aGlzLmNvbmZpZy5lbmFibGVTb2Z0d2FyZUFFUykge1xyXG4gICAgICBsb2dnZXIubG9nKCdXZWJDcnlwdG8gRXJyb3IsIGRpc2FibGUgV2ViQ3J5cHRvIEFQSScpO1xyXG4gICAgICB0aGlzLmRpc2FibGVXZWJDcnlwdG8gPSB0cnVlO1xyXG4gICAgICB0aGlzLmxvZ0VuYWJsZWQgPSB0cnVlO1xyXG4gICAgICB0aGlzLmRlY3J5cHQoZGF0YSwga2V5LCBpdiwgY2FsbGJhY2spO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgIGxvZ2dlci5lcnJvcihgZGVjcnlwdGluZyBlcnJvciA6ICR7ZXJyLm1lc3NhZ2V9YCk7XHJcbiAgICAgIHRoaXMub2JzZXJ2ZXIudHJpZ2dlcihFdmVudC5FUlJPUiwge3R5cGUgOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLCBkZXRhaWxzIDogRXJyb3JEZXRhaWxzLkZSQUdfREVDUllQVF9FUlJPUiwgZmF0YWwgOiB0cnVlLCByZWFzb24gOiBlcnIubWVzc2FnZX0pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZGVzdHJveSgpIHtcclxuICAgIGxldCBkZWNyeXB0b3IgPSB0aGlzLmRlY3J5cHRvcjtcclxuICAgIGlmIChkZWNyeXB0b3IpIHtcclxuICAgICAgZGVjcnlwdG9yLmRlc3Ryb3koKTtcclxuICAgICAgdGhpcy5kZWNyeXB0b3IgPSB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBEZWNyeXB0ZXI7XHJcbiIsImNsYXNzIEZhc3RBRVNLZXkge1xyXG4gIGNvbnN0cnVjdG9yKHN1YnRsZSxrZXkpIHtcclxuICAgIHRoaXMuc3VidGxlID0gc3VidGxlO1xyXG4gICAgdGhpcy5rZXkgPSBrZXk7XHJcbiAgfVxyXG5cclxuICBleHBhbmRLZXkoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5zdWJ0bGUuaW1wb3J0S2V5KCdyYXcnLCB0aGlzLmtleSwge25hbWU6ICdBRVMtQ0JDJ30sIGZhbHNlLCBbJ2VuY3J5cHQnLCAnZGVjcnlwdCddKTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IEZhc3RBRVNLZXk7XHJcbiIsIi8qKlxyXG4gKiBBQUMgZGVtdXhlclxyXG4gKi9cclxuaW1wb3J0IEFEVFMgZnJvbSAnLi9hZHRzJztcclxuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcclxuaW1wb3J0IElEMyBmcm9tICcuLi9kZW11eC9pZDMnO1xyXG5cclxuY2xhc3MgQUFDRGVtdXhlciB7XHJcblxyXG4gIGNvbnN0cnVjdG9yKG9ic2VydmVyLCByZW11eGVyLCBjb25maWcpIHtcclxuICAgIHRoaXMub2JzZXJ2ZXIgPSBvYnNlcnZlcjtcclxuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xyXG4gICAgdGhpcy5yZW11eGVyID0gcmVtdXhlcjtcclxuICB9XHJcblxyXG4gIHJlc2V0SW5pdFNlZ21lbnQoaW5pdFNlZ21lbnQsIGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWMsIGR1cmF0aW9uKSB7XHJcbiAgICB0aGlzLl9hdWRpb1RyYWNrID0geyBjb250YWluZXI6ICdhdWRpby9hZHRzJywgdHlwZTogJ2F1ZGlvJywgaWQ6IC0xLCBzZXF1ZW5jZU51bWJlcjogMCwgaXNBQUM6IHRydWUsIHNhbXBsZXM6IFtdLCBsZW46IDAsIG1hbmlmZXN0Q29kZWM6IGF1ZGlvQ29kZWMsIGR1cmF0aW9uOiBkdXJhdGlvbiwgaW5wdXRUaW1lU2NhbGU6IDkwMDAwIH07XHJcbiAgfVxyXG5cclxuICByZXNldFRpbWVTdGFtcCgpIHtcclxuICB9XHJcblxyXG4gIHN0YXRpYyBwcm9iZShkYXRhKSB7XHJcbiAgICAvLyBjaGVjayBpZiBkYXRhIGNvbnRhaW5zIElEMyB0aW1lc3RhbXAgYW5kIEFEVFMgc3luYyB3b3JkXHJcbiAgICB2YXIgb2Zmc2V0LCBsZW5ndGg7XHJcbiAgICBsZXQgaWQzRGF0YSA9IElEMy5nZXRJRDNEYXRhKGRhdGEsIDApO1xyXG4gICAgaWYgKGlkM0RhdGEgJiYgSUQzLmdldFRpbWVTdGFtcChpZDNEYXRhKSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIC8vIExvb2sgZm9yIEFEVFMgaGVhZGVyIHwgMTExMSAxMTExIHwgMTExMSBYMDBYIHwgd2hlcmUgWCBjYW4gYmUgZWl0aGVyIDAgb3IgMVxyXG4gICAgICAvLyBMYXllciBiaXRzIChwb3NpdGlvbiAxNCBhbmQgMTUpIGluIGhlYWRlciBzaG91bGQgYmUgYWx3YXlzIDAgZm9yIEFEVFNcclxuICAgICAgLy8gTW9yZSBpbmZvIGh0dHBzOi8vd2lraS5tdWx0aW1lZGlhLmN4L2luZGV4LnBocD90aXRsZT1BRFRTXHJcbiAgICAgIGZvciAob2Zmc2V0ID0gaWQzRGF0YS5sZW5ndGgsIGxlbmd0aCA9IE1hdGgubWluKGRhdGEubGVuZ3RoIC0gMSwgb2Zmc2V0ICsgMTAwKTsgb2Zmc2V0IDwgbGVuZ3RoOyBvZmZzZXQrKykge1xyXG4gICAgICAgIGlmIChBRFRTLnByb2JlKGRhdGEsIG9mZnNldCkpIHtcclxuICAgICAgICAgIGxvZ2dlci5sb2coJ0FEVFMgc3luYyB3b3JkIGZvdW5kICEnKTtcclxuICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgLy8gZmVlZCBpbmNvbWluZyBkYXRhIHRvIHRoZSBmcm9udCBvZiB0aGUgcGFyc2luZyBwaXBlbGluZVxyXG4gIGFwcGVuZChkYXRhLCB0aW1lT2Zmc2V0LCBjb250aWd1b3VzLCBhY2N1cmF0ZVRpbWVPZmZzZXQpIHtcclxuICAgIHZhciB0cmFjayA9IHRoaXMuX2F1ZGlvVHJhY2ssXHJcbiAgICAgIGlkM0RhdGEgPSBJRDMuZ2V0SUQzRGF0YShkYXRhLCAwKSxcclxuICAgICAgcHRzID0gOTAgKiBJRDMuZ2V0VGltZVN0YW1wKGlkM0RhdGEpLFxyXG4gICAgICBmcmFtZUluZGV4ID0gMCxcclxuICAgICAgc3RhbXAgPSBwdHMsXHJcbiAgICAgIGxlbmd0aCA9IGRhdGEubGVuZ3RoLFxyXG4gICAgICBvZmZzZXQgPSBpZDNEYXRhLmxlbmd0aDtcclxuXHJcbiAgICBsZXQgaWQzU2FtcGxlcyA9IFt7IHB0czogc3RhbXAsIGR0czogc3RhbXAsIGRhdGE6IGlkM0RhdGEgfV07XHJcblxyXG4gICAgd2hpbGUgKG9mZnNldCA8IGxlbmd0aCAtIDEpIHtcclxuICAgICAgaWYgKEFEVFMuaXNIZWFkZXIoZGF0YSwgb2Zmc2V0KSAmJiAob2Zmc2V0ICsgNSkgPCBsZW5ndGgpIHtcclxuICAgICAgICBBRFRTLmluaXRUcmFja0NvbmZpZyh0cmFjaywgdGhpcy5vYnNlcnZlciwgZGF0YSwgb2Zmc2V0LCB0cmFjay5tYW5pZmVzdENvZGVjKTtcclxuICAgICAgICB2YXIgZnJhbWUgPSBBRFRTLmFwcGVuZEZyYW1lKHRyYWNrLCBkYXRhLCBvZmZzZXQsIHB0cywgZnJhbWVJbmRleCk7XHJcbiAgICAgICAgaWYgKGZyYW1lKSB7XHJcbiAgICAgICAgICBvZmZzZXQgKz0gZnJhbWUubGVuZ3RoO1xyXG4gICAgICAgICAgc3RhbXAgPSBmcmFtZS5zYW1wbGUucHRzO1xyXG4gICAgICAgICAgZnJhbWVJbmRleCsrO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBsb2dnZXIubG9nKCdVbmFibGUgdG8gcGFyc2UgQUFDIGZyYW1lJyk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSBpZiAoSUQzLmlzSGVhZGVyKGRhdGEsIG9mZnNldCkpIHtcclxuICAgICAgICBpZDNEYXRhID0gSUQzLmdldElEM0RhdGEoZGF0YSwgb2Zmc2V0KTtcclxuICAgICAgICBpZDNTYW1wbGVzLnB1c2goeyBwdHM6IHN0YW1wLCBkdHM6IHN0YW1wLCBkYXRhOiBpZDNEYXRhIH0pO1xyXG4gICAgICAgIG9mZnNldCArPSBpZDNEYXRhLmxlbmd0aDtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvL25vdGhpbmcgZm91bmQsIGtlZXAgbG9va2luZ1xyXG4gICAgICAgIG9mZnNldCsrO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5yZW11eGVyLnJlbXV4KHRyYWNrLFxyXG4gICAgICB7IHNhbXBsZXM6IFtdIH0sXHJcbiAgICAgIHsgc2FtcGxlczogaWQzU2FtcGxlcywgaW5wdXRUaW1lU2NhbGU6IDkwMDAwIH0sXHJcbiAgICAgIHsgc2FtcGxlczogW10gfSxcclxuICAgICAgdGltZU9mZnNldCxcclxuICAgICAgY29udGlndW91cyxcclxuICAgICAgYWNjdXJhdGVUaW1lT2Zmc2V0KTtcclxuICB9XHJcblxyXG4gIGRlc3Ryb3koKSB7XHJcbiAgfVxyXG5cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgQUFDRGVtdXhlcjtcclxuIiwiLyoqXHJcbiAqICBBRFRTIHBhcnNlciBoZWxwZXJcclxuICovXHJcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XHJcbmltcG9ydCB7IEVycm9yVHlwZXMsIEVycm9yRGV0YWlscyB9IGZyb20gJy4uL2Vycm9ycyc7XHJcblxyXG5jb25zdCBBRFRTID0ge1xyXG4gIGdldEF1ZGlvQ29uZmlnOiBmdW5jdGlvbiAob2JzZXJ2ZXIsIGRhdGEsIG9mZnNldCwgYXVkaW9Db2RlYykge1xyXG4gICAgdmFyIGFkdHNPYmplY3RUeXBlLCAvLyA6aW50XHJcbiAgICAgIGFkdHNTYW1wbGVpbmdJbmRleCwgLy8gOmludFxyXG4gICAgICBhZHRzRXh0ZW5zaW9uU2FtcGxlaW5nSW5kZXgsIC8vIDppbnRcclxuICAgICAgYWR0c0NoYW5lbENvbmZpZywgLy8gOmludFxyXG4gICAgICBjb25maWcsXHJcbiAgICAgIHVzZXJBZ2VudCA9IG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKSxcclxuICAgICAgbWFuaWZlc3RDb2RlYyA9IGF1ZGlvQ29kZWMsXHJcbiAgICAgIGFkdHNTYW1wbGVpbmdSYXRlcyA9IFtcclxuICAgICAgICA5NjAwMCwgODgyMDAsXHJcbiAgICAgICAgNjQwMDAsIDQ4MDAwLFxyXG4gICAgICAgIDQ0MTAwLCAzMjAwMCxcclxuICAgICAgICAyNDAwMCwgMjIwNTAsXHJcbiAgICAgICAgMTYwMDAsIDEyMDAwLFxyXG4gICAgICAgIDExMDI1LCA4MDAwLFxyXG4gICAgICAgIDczNTBdO1xyXG4gICAgLy8gYnl0ZSAyXHJcbiAgICBhZHRzT2JqZWN0VHlwZSA9ICgoZGF0YVtvZmZzZXQgKyAyXSAmIDB4QzApID4+PiA2KSArIDE7XHJcbiAgICBhZHRzU2FtcGxlaW5nSW5kZXggPSAoKGRhdGFbb2Zmc2V0ICsgMl0gJiAweDNDKSA+Pj4gMik7XHJcbiAgICBpZiAoYWR0c1NhbXBsZWluZ0luZGV4ID4gYWR0c1NhbXBsZWluZ1JhdGVzLmxlbmd0aCAtIDEpIHtcclxuICAgICAgb2JzZXJ2ZXIudHJpZ2dlcihFdmVudC5FUlJPUiwgeyB0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLCBkZXRhaWxzOiBFcnJvckRldGFpbHMuRlJBR19QQVJTSU5HX0VSUk9SLCBmYXRhbDogdHJ1ZSwgcmVhc29uOiBgaW52YWxpZCBBRFRTIHNhbXBsaW5nIGluZGV4OiR7YWR0c1NhbXBsZWluZ0luZGV4fWAgfSk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGFkdHNDaGFuZWxDb25maWcgPSAoKGRhdGFbb2Zmc2V0ICsgMl0gJiAweDAxKSA8PCAyKTtcclxuICAgIC8vIGJ5dGUgM1xyXG4gICAgYWR0c0NoYW5lbENvbmZpZyB8PSAoKGRhdGFbb2Zmc2V0ICsgM10gJiAweEMwKSA+Pj4gNik7XHJcbiAgICBsb2dnZXIubG9nKGBtYW5pZmVzdCBjb2RlYzoke2F1ZGlvQ29kZWN9LEFEVFMgZGF0YTp0eXBlOiR7YWR0c09iamVjdFR5cGV9LHNhbXBsZWluZ0luZGV4OiR7YWR0c1NhbXBsZWluZ0luZGV4fVske2FkdHNTYW1wbGVpbmdSYXRlc1thZHRzU2FtcGxlaW5nSW5kZXhdfUh6XSxjaGFubmVsQ29uZmlnOiR7YWR0c0NoYW5lbENvbmZpZ31gKTtcclxuICAgIC8vIGZpcmVmb3g6IGZyZXEgbGVzcyB0aGFuIDI0a0h6ID0gQUFDIFNCUiAoSEUtQUFDKVxyXG4gICAgaWYgKC9maXJlZm94L2kudGVzdCh1c2VyQWdlbnQpKSB7XHJcbiAgICAgIGlmIChhZHRzU2FtcGxlaW5nSW5kZXggPj0gNikge1xyXG4gICAgICAgIGFkdHNPYmplY3RUeXBlID0gNTtcclxuICAgICAgICBjb25maWcgPSBuZXcgQXJyYXkoNCk7XHJcbiAgICAgICAgLy8gSEUtQUFDIHVzZXMgU0JSIChTcGVjdHJhbCBCYW5kIFJlcGxpY2F0aW9uKSAsIGhpZ2ggZnJlcXVlbmNpZXMgYXJlIGNvbnN0cnVjdGVkIGZyb20gbG93IGZyZXF1ZW5jaWVzXHJcbiAgICAgICAgLy8gdGhlcmUgaXMgYSBmYWN0b3IgMiBiZXR3ZWVuIGZyYW1lIHNhbXBsZSByYXRlIGFuZCBvdXRwdXQgc2FtcGxlIHJhdGVcclxuICAgICAgICAvLyBtdWx0aXBseSBmcmVxdWVuY3kgYnkgMiAoc2VlIHRhYmxlIGJlbG93LCBlcXVpdmFsZW50IHRvIHN1YnN0cmFjdCAzKVxyXG4gICAgICAgIGFkdHNFeHRlbnNpb25TYW1wbGVpbmdJbmRleCA9IGFkdHNTYW1wbGVpbmdJbmRleCAtIDM7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgYWR0c09iamVjdFR5cGUgPSAyO1xyXG4gICAgICAgIGNvbmZpZyA9IG5ldyBBcnJheSgyKTtcclxuICAgICAgICBhZHRzRXh0ZW5zaW9uU2FtcGxlaW5nSW5kZXggPSBhZHRzU2FtcGxlaW5nSW5kZXg7XHJcbiAgICAgIH1cclxuICAgICAgLy8gQW5kcm9pZCA6IGFsd2F5cyB1c2UgQUFDXHJcbiAgICB9IGVsc2UgaWYgKHVzZXJBZ2VudC5pbmRleE9mKCdhbmRyb2lkJykgIT09IC0xKSB7XHJcbiAgICAgIGFkdHNPYmplY3RUeXBlID0gMjtcclxuICAgICAgY29uZmlnID0gbmV3IEFycmF5KDIpO1xyXG4gICAgICBhZHRzRXh0ZW5zaW9uU2FtcGxlaW5nSW5kZXggPSBhZHRzU2FtcGxlaW5nSW5kZXg7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvKiAgZm9yIG90aGVyIGJyb3dzZXJzIChDaHJvbWUvVml2YWxkaS9PcGVyYSAuLi4pXHJcbiAgICAgICAgICBhbHdheXMgZm9yY2UgYXVkaW8gdHlwZSB0byBiZSBIRS1BQUMgU0JSLCBhcyBzb21lIGJyb3dzZXJzIGRvIG5vdCBzdXBwb3J0IGF1ZGlvIGNvZGVjIHN3aXRjaCBwcm9wZXJseSAobGlrZSBDaHJvbWUgLi4uKVxyXG4gICAgICAqL1xyXG4gICAgICBhZHRzT2JqZWN0VHlwZSA9IDU7XHJcbiAgICAgIGNvbmZpZyA9IG5ldyBBcnJheSg0KTtcclxuICAgICAgLy8gaWYgKG1hbmlmZXN0IGNvZGVjIGlzIEhFLUFBQyBvciBIRS1BQUN2MikgT1IgKG1hbmlmZXN0IGNvZGVjIG5vdCBzcGVjaWZpZWQgQU5EIGZyZXF1ZW5jeSBsZXNzIHRoYW4gMjRrSHopXHJcbiAgICAgIGlmICgoYXVkaW9Db2RlYyAmJiAoKGF1ZGlvQ29kZWMuaW5kZXhPZignbXA0YS40MC4yOScpICE9PSAtMSkgfHxcclxuICAgICAgICAoYXVkaW9Db2RlYy5pbmRleE9mKCdtcDRhLjQwLjUnKSAhPT0gLTEpKSkgfHxcclxuICAgICAgICAoIWF1ZGlvQ29kZWMgJiYgYWR0c1NhbXBsZWluZ0luZGV4ID49IDYpKSB7XHJcbiAgICAgICAgLy8gSEUtQUFDIHVzZXMgU0JSIChTcGVjdHJhbCBCYW5kIFJlcGxpY2F0aW9uKSAsIGhpZ2ggZnJlcXVlbmNpZXMgYXJlIGNvbnN0cnVjdGVkIGZyb20gbG93IGZyZXF1ZW5jaWVzXHJcbiAgICAgICAgLy8gdGhlcmUgaXMgYSBmYWN0b3IgMiBiZXR3ZWVuIGZyYW1lIHNhbXBsZSByYXRlIGFuZCBvdXRwdXQgc2FtcGxlIHJhdGVcclxuICAgICAgICAvLyBtdWx0aXBseSBmcmVxdWVuY3kgYnkgMiAoc2VlIHRhYmxlIGJlbG93LCBlcXVpdmFsZW50IHRvIHN1YnN0cmFjdCAzKVxyXG4gICAgICAgIGFkdHNFeHRlbnNpb25TYW1wbGVpbmdJbmRleCA9IGFkdHNTYW1wbGVpbmdJbmRleCAtIDM7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gaWYgKG1hbmlmZXN0IGNvZGVjIGlzIEFBQykgQU5EIChmcmVxdWVuY3kgbGVzcyB0aGFuIDI0a0h6IEFORCBuYiBjaGFubmVsIGlzIDEpIE9SIChtYW5pZmVzdCBjb2RlYyBub3Qgc3BlY2lmaWVkIGFuZCBtb25vIGF1ZGlvKVxyXG4gICAgICAgIC8vIENocm9tZSBmYWlscyB0byBwbGF5IGJhY2sgd2l0aCBsb3cgZnJlcXVlbmN5IEFBQyBMQyBtb25vIHdoZW4gaW5pdGlhbGl6ZWQgd2l0aCBIRS1BQUMuICBUaGlzIGlzIG5vdCBhIHByb2JsZW0gd2l0aCBzdGVyZW8uXHJcbiAgICAgICAgaWYgKGF1ZGlvQ29kZWMgJiYgYXVkaW9Db2RlYy5pbmRleE9mKCdtcDRhLjQwLjInKSAhPT0gLTEgJiYgKGFkdHNTYW1wbGVpbmdJbmRleCA+PSA2ICYmIGFkdHNDaGFuZWxDb25maWcgPT09IDEpIHx8XHJcbiAgICAgICAgICAoIWF1ZGlvQ29kZWMgJiYgYWR0c0NoYW5lbENvbmZpZyA9PT0gMSkpIHtcclxuICAgICAgICAgIGFkdHNPYmplY3RUeXBlID0gMjtcclxuICAgICAgICAgIGNvbmZpZyA9IG5ldyBBcnJheSgyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYWR0c0V4dGVuc2lvblNhbXBsZWluZ0luZGV4ID0gYWR0c1NhbXBsZWluZ0luZGV4O1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICAvKiByZWZlciB0byBodHRwOi8vd2lraS5tdWx0aW1lZGlhLmN4L2luZGV4LnBocD90aXRsZT1NUEVHLTRfQXVkaW8jQXVkaW9fU3BlY2lmaWNfQ29uZmlnXHJcbiAgICAgICAgSVNPIDE0NDk2LTMgKEFBQykucGRmIC0gVGFibGUgMS4xMyDigJQgU3ludGF4IG9mIEF1ZGlvU3BlY2lmaWNDb25maWcoKVxyXG4gICAgICBBdWRpbyBQcm9maWxlIC8gQXVkaW8gT2JqZWN0IFR5cGVcclxuICAgICAgMDogTnVsbFxyXG4gICAgICAxOiBBQUMgTWFpblxyXG4gICAgICAyOiBBQUMgTEMgKExvdyBDb21wbGV4aXR5KVxyXG4gICAgICAzOiBBQUMgU1NSIChTY2FsYWJsZSBTYW1wbGUgUmF0ZSlcclxuICAgICAgNDogQUFDIExUUCAoTG9uZyBUZXJtIFByZWRpY3Rpb24pXHJcbiAgICAgIDU6IFNCUiAoU3BlY3RyYWwgQmFuZCBSZXBsaWNhdGlvbilcclxuICAgICAgNjogQUFDIFNjYWxhYmxlXHJcbiAgICAgc2FtcGxpbmcgZnJlcVxyXG4gICAgICAwOiA5NjAwMCBIelxyXG4gICAgICAxOiA4ODIwMCBIelxyXG4gICAgICAyOiA2NDAwMCBIelxyXG4gICAgICAzOiA0ODAwMCBIelxyXG4gICAgICA0OiA0NDEwMCBIelxyXG4gICAgICA1OiAzMjAwMCBIelxyXG4gICAgICA2OiAyNDAwMCBIelxyXG4gICAgICA3OiAyMjA1MCBIelxyXG4gICAgICA4OiAxNjAwMCBIelxyXG4gICAgICA5OiAxMjAwMCBIelxyXG4gICAgICAxMDogMTEwMjUgSHpcclxuICAgICAgMTE6IDgwMDAgSHpcclxuICAgICAgMTI6IDczNTAgSHpcclxuICAgICAgMTM6IFJlc2VydmVkXHJcbiAgICAgIDE0OiBSZXNlcnZlZFxyXG4gICAgICAxNTogZnJlcXVlbmN5IGlzIHdyaXR0ZW4gZXhwbGljdGx5XHJcbiAgICAgIENoYW5uZWwgQ29uZmlndXJhdGlvbnNcclxuICAgICAgVGhlc2UgYXJlIHRoZSBjaGFubmVsIGNvbmZpZ3VyYXRpb25zOlxyXG4gICAgICAwOiBEZWZpbmVkIGluIEFPVCBTcGVjaWZjIENvbmZpZ1xyXG4gICAgICAxOiAxIGNoYW5uZWw6IGZyb250LWNlbnRlclxyXG4gICAgICAyOiAyIGNoYW5uZWxzOiBmcm9udC1sZWZ0LCBmcm9udC1yaWdodFxyXG4gICAgKi9cclxuICAgIC8vIGF1ZGlvT2JqZWN0VHlwZSA9IHByb2ZpbGUgPT4gcHJvZmlsZSwgdGhlIE1QRUctNCBBdWRpbyBPYmplY3QgVHlwZSBtaW51cyAxXHJcbiAgICBjb25maWdbMF0gPSBhZHRzT2JqZWN0VHlwZSA8PCAzO1xyXG4gICAgLy8gc2FtcGxpbmdGcmVxdWVuY3lJbmRleFxyXG4gICAgY29uZmlnWzBdIHw9IChhZHRzU2FtcGxlaW5nSW5kZXggJiAweDBFKSA+PiAxO1xyXG4gICAgY29uZmlnWzFdIHw9IChhZHRzU2FtcGxlaW5nSW5kZXggJiAweDAxKSA8PCA3O1xyXG4gICAgLy8gY2hhbm5lbENvbmZpZ3VyYXRpb25cclxuICAgIGNvbmZpZ1sxXSB8PSBhZHRzQ2hhbmVsQ29uZmlnIDw8IDM7XHJcbiAgICBpZiAoYWR0c09iamVjdFR5cGUgPT09IDUpIHtcclxuICAgICAgLy8gYWR0c0V4dGVuc2lvblNhbXBsZWluZ0luZGV4XHJcbiAgICAgIGNvbmZpZ1sxXSB8PSAoYWR0c0V4dGVuc2lvblNhbXBsZWluZ0luZGV4ICYgMHgwRSkgPj4gMTtcclxuICAgICAgY29uZmlnWzJdID0gKGFkdHNFeHRlbnNpb25TYW1wbGVpbmdJbmRleCAmIDB4MDEpIDw8IDc7XHJcbiAgICAgIC8vIGFkdHNPYmplY3RUeXBlIChmb3JjZSB0byAyLCBjaHJvbWUgaXMgY2hlY2tpbmcgdGhhdCBvYmplY3QgdHlwZSBpcyBsZXNzIHRoYW4gNSA/Pz9cclxuICAgICAgLy8gICAgaHR0cHM6Ly9jaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYy5naXQvKy9tYXN0ZXIvbWVkaWEvZm9ybWF0cy9tcDQvYWFjLmNjXHJcbiAgICAgIGNvbmZpZ1syXSB8PSAyIDw8IDI7XHJcbiAgICAgIGNvbmZpZ1szXSA9IDA7XHJcbiAgICB9XHJcbiAgICByZXR1cm4geyBjb25maWc6IGNvbmZpZywgc2FtcGxlcmF0ZTogYWR0c1NhbXBsZWluZ1JhdGVzW2FkdHNTYW1wbGVpbmdJbmRleF0sIGNoYW5uZWxDb3VudDogYWR0c0NoYW5lbENvbmZpZywgY29kZWM6ICgnbXA0YS40MC4nICsgYWR0c09iamVjdFR5cGUpLCBtYW5pZmVzdENvZGVjOiBtYW5pZmVzdENvZGVjIH07XHJcbiAgfSxcclxuXHJcbiAgaXNIZWFkZXJQYXR0ZXJuOiBmdW5jdGlvbiAoZGF0YSwgb2Zmc2V0KSB7XHJcbiAgICByZXR1cm4gZGF0YVtvZmZzZXRdID09PSAweGZmICYmIChkYXRhW29mZnNldCArIDFdICYgMHhmNikgPT09IDB4ZjA7XHJcbiAgfSxcclxuXHJcbiAgZ2V0SGVhZGVyTGVuZ3RoOiBmdW5jdGlvbiAoZGF0YSwgb2Zmc2V0KSB7XHJcbiAgICByZXR1cm4gKCEhKGRhdGFbb2Zmc2V0ICsgMV0gJiAweDAxKSA/IDcgOiA5KTtcclxuICB9LFxyXG5cclxuICBnZXRGdWxsRnJhbWVMZW5ndGg6IGZ1bmN0aW9uIChkYXRhLCBvZmZzZXQpIHtcclxuICAgIHJldHVybiAoKGRhdGFbb2Zmc2V0ICsgM10gJiAweDAzKSA8PCAxMSkgfFxyXG4gICAgICAoZGF0YVtvZmZzZXQgKyA0XSA8PCAzKSB8XHJcbiAgICAgICgoZGF0YVtvZmZzZXQgKyA1XSAmIDB4RTApID4+PiA1KTtcclxuICB9LFxyXG5cclxuICBpc0hlYWRlcjogZnVuY3Rpb24gKGRhdGEsIG9mZnNldCkge1xyXG4gICAgLy8gTG9vayBmb3IgQURUUyBoZWFkZXIgfCAxMTExIDExMTEgfCAxMTExIFgwMFggfCB3aGVyZSBYIGNhbiBiZSBlaXRoZXIgMCBvciAxXHJcbiAgICAvLyBMYXllciBiaXRzIChwb3NpdGlvbiAxNCBhbmQgMTUpIGluIGhlYWRlciBzaG91bGQgYmUgYWx3YXlzIDAgZm9yIEFEVFNcclxuICAgIC8vIE1vcmUgaW5mbyBodHRwczovL3dpa2kubXVsdGltZWRpYS5jeC9pbmRleC5waHA/dGl0bGU9QURUU1xyXG4gICAgaWYgKG9mZnNldCArIDEgPCBkYXRhLmxlbmd0aCAmJiB0aGlzLmlzSGVhZGVyUGF0dGVybihkYXRhLCBvZmZzZXQpKSB7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH0sXHJcblxyXG4gIHByb2JlOiBmdW5jdGlvbiAoZGF0YSwgb2Zmc2V0KSB7XHJcbiAgICAvLyBzYW1lIGFzIGlzSGVhZGVyIGJ1dCB3ZSBhbHNvIGNoZWNrIHRoYXQgQURUUyBmcmFtZSBmb2xsb3dzIGxhc3QgQURUUyBmcmFtZSBcclxuICAgIC8vIG9yIGVuZCBvZiBkYXRhIGlzIHJlYWNoZWRcclxuICAgIGlmIChvZmZzZXQgKyAxIDwgZGF0YS5sZW5ndGggJiYgdGhpcy5pc0hlYWRlclBhdHRlcm4oZGF0YSwgb2Zmc2V0KSkge1xyXG4gICAgICAvLyBBRFRTIGhlYWRlciBMZW5ndGhcclxuICAgICAgbGV0IGhlYWRlckxlbmd0aCA9IHRoaXMuZ2V0SGVhZGVyTGVuZ3RoKGRhdGEsIG9mZnNldCk7XHJcbiAgICAgIC8vIEFEVFMgZnJhbWUgTGVuZ3RoXHJcbiAgICAgIGxldCBmcmFtZUxlbmd0aCA9IGhlYWRlckxlbmd0aDtcclxuICAgICAgaWYgKG9mZnNldCArIDUgPCBkYXRhLmxlbmd0aCkge1xyXG4gICAgICAgIGZyYW1lTGVuZ3RoID0gdGhpcy5nZXRGdWxsRnJhbWVMZW5ndGgoZGF0YSwgb2Zmc2V0KTtcclxuICAgICAgfVxyXG4gICAgICBsZXQgbmV3T2Zmc2V0ID0gb2Zmc2V0ICsgZnJhbWVMZW5ndGg7XHJcbiAgICAgIGlmIChuZXdPZmZzZXQgPT09IGRhdGEubGVuZ3RoIHx8IChuZXdPZmZzZXQgKyAxIDwgZGF0YS5sZW5ndGggJiYgdGhpcy5pc0hlYWRlclBhdHRlcm4oZGF0YSwgbmV3T2Zmc2V0KSkpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH0sXHJcblxyXG4gIGluaXRUcmFja0NvbmZpZzogZnVuY3Rpb24gKHRyYWNrLCBvYnNlcnZlciwgZGF0YSwgb2Zmc2V0LCBhdWRpb0NvZGVjKSB7XHJcbiAgICBpZiAoIXRyYWNrLnNhbXBsZXJhdGUpIHtcclxuICAgICAgdmFyIGNvbmZpZyA9IHRoaXMuZ2V0QXVkaW9Db25maWcob2JzZXJ2ZXIsIGRhdGEsIG9mZnNldCwgYXVkaW9Db2RlYyk7XHJcbiAgICAgIHRyYWNrLmNvbmZpZyA9IGNvbmZpZy5jb25maWc7XHJcbiAgICAgIHRyYWNrLnNhbXBsZXJhdGUgPSBjb25maWcuc2FtcGxlcmF0ZTtcclxuICAgICAgdHJhY2suY2hhbm5lbENvdW50ID0gY29uZmlnLmNoYW5uZWxDb3VudDtcclxuICAgICAgdHJhY2suY29kZWMgPSBjb25maWcuY29kZWM7XHJcbiAgICAgIHRyYWNrLm1hbmlmZXN0Q29kZWMgPSBjb25maWcubWFuaWZlc3RDb2RlYztcclxuICAgICAgbG9nZ2VyLmxvZyhgcGFyc2VkIGNvZGVjOiR7dHJhY2suY29kZWN9LHJhdGU6JHtjb25maWcuc2FtcGxlcmF0ZX0sbmIgY2hhbm5lbDoke2NvbmZpZy5jaGFubmVsQ291bnR9YCk7XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgZ2V0RnJhbWVEdXJhdGlvbjogZnVuY3Rpb24gKHNhbXBsZXJhdGUpIHtcclxuICAgIHJldHVybiAxMDI0ICogOTAwMDAgLyBzYW1wbGVyYXRlO1xyXG4gIH0sXHJcblxyXG4gIGFwcGVuZEZyYW1lOiBmdW5jdGlvbiAodHJhY2ssIGRhdGEsIG9mZnNldCwgcHRzLCBmcmFtZUluZGV4KSB7XHJcbiAgICB2YXIgZnJhbWVEdXJhdGlvbiA9IHRoaXMuZ2V0RnJhbWVEdXJhdGlvbih0cmFjay5zYW1wbGVyYXRlKTtcclxuICAgIHZhciBoZWFkZXIgPSB0aGlzLnBhcnNlRnJhbWVIZWFkZXIoZGF0YSwgb2Zmc2V0LCBwdHMsIGZyYW1lSW5kZXgsIGZyYW1lRHVyYXRpb24pO1xyXG4gICAgaWYgKGhlYWRlcikge1xyXG4gICAgICB2YXIgc3RhbXAgPSBoZWFkZXIuc3RhbXA7XHJcbiAgICAgIHZhciBoZWFkZXJMZW5ndGggPSBoZWFkZXIuaGVhZGVyTGVuZ3RoO1xyXG4gICAgICB2YXIgZnJhbWVMZW5ndGggPSBoZWFkZXIuZnJhbWVMZW5ndGg7XHJcblxyXG4gICAgICAvL2xvZ2dlci5sb2coYEFBQyBmcmFtZSwgb2Zmc2V0L2xlbmd0aC90b3RhbC9wdHM6JHtvZmZzZXQraGVhZGVyTGVuZ3RofS8ke2ZyYW1lTGVuZ3RofS8ke2RhdGEuYnl0ZUxlbmd0aH0vJHsoc3RhbXAvOTApLnRvRml4ZWQoMCl9YCk7XHJcbiAgICAgIHZhciBhYWNTYW1wbGUgPSB7IHVuaXQ6IGRhdGEuc3ViYXJyYXkob2Zmc2V0ICsgaGVhZGVyTGVuZ3RoLCBvZmZzZXQgKyBoZWFkZXJMZW5ndGggKyBmcmFtZUxlbmd0aCksIHB0czogc3RhbXAsIGR0czogc3RhbXAgfTtcclxuXHJcbiAgICAgIHRyYWNrLnNhbXBsZXMucHVzaChhYWNTYW1wbGUpO1xyXG4gICAgICB0cmFjay5sZW4gKz0gZnJhbWVMZW5ndGg7XHJcblxyXG4gICAgICByZXR1cm4geyBzYW1wbGU6IGFhY1NhbXBsZSwgbGVuZ3RoOiBmcmFtZUxlbmd0aCArIGhlYWRlckxlbmd0aCB9O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgfSxcclxuXHJcbiAgcGFyc2VGcmFtZUhlYWRlcjogZnVuY3Rpb24gKGRhdGEsIG9mZnNldCwgcHRzLCBmcmFtZUluZGV4LCBmcmFtZUR1cmF0aW9uKSB7XHJcbiAgICB2YXIgaGVhZGVyTGVuZ3RoLCBmcmFtZUxlbmd0aCwgc3RhbXA7XHJcbiAgICB2YXIgbGVuZ3RoID0gZGF0YS5sZW5ndGg7XHJcblxyXG4gICAgLy8gVGhlIHByb3RlY3Rpb24gc2tpcCBiaXQgdGVsbHMgdXMgaWYgd2UgaGF2ZSAyIGJ5dGVzIG9mIENSQyBkYXRhIGF0IHRoZSBlbmQgb2YgdGhlIEFEVFMgaGVhZGVyXHJcbiAgICBoZWFkZXJMZW5ndGggPSB0aGlzLmdldEhlYWRlckxlbmd0aChkYXRhLCBvZmZzZXQpO1xyXG4gICAgLy8gcmV0cmlldmUgZnJhbWUgc2l6ZVxyXG4gICAgZnJhbWVMZW5ndGggPSB0aGlzLmdldEZ1bGxGcmFtZUxlbmd0aChkYXRhLCBvZmZzZXQpO1xyXG4gICAgZnJhbWVMZW5ndGggLT0gaGVhZGVyTGVuZ3RoO1xyXG5cclxuICAgIGlmICgoZnJhbWVMZW5ndGggPiAwKSAmJiAoKG9mZnNldCArIGhlYWRlckxlbmd0aCArIGZyYW1lTGVuZ3RoKSA8PSBsZW5ndGgpKSB7XHJcbiAgICAgIHN0YW1wID0gcHRzICsgZnJhbWVJbmRleCAqIGZyYW1lRHVyYXRpb247XHJcbiAgICAgIC8vbG9nZ2VyLmxvZyhgQUFDIGZyYW1lLCBvZmZzZXQvbGVuZ3RoL3RvdGFsL3B0czoke29mZnNldCtoZWFkZXJMZW5ndGh9LyR7ZnJhbWVMZW5ndGh9LyR7ZGF0YS5ieXRlTGVuZ3RofS8keyhzdGFtcC85MCkudG9GaXhlZCgwKX1gKTtcclxuICAgICAgcmV0dXJuIHsgaGVhZGVyTGVuZ3RoLCBmcmFtZUxlbmd0aCwgc3RhbXAgfTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gIH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQURUUzsiLCIvKiAgaW5saW5lIGRlbXV4ZXIuXHJcbiAqICAgcHJvYmUgZnJhZ21lbnRzIGFuZCBpbnN0YW50aWF0ZSBhcHByb3ByaWF0ZSBkZW11eGVyIGRlcGVuZGluZyBvbiBjb250ZW50IHR5cGUgKFRTRGVtdXhlciwgQUFDRGVtdXhlciwgLi4uKVxyXG4gKi9cclxuXHJcbmltcG9ydCBFdmVudCBmcm9tICcuLi9ldmVudHMnO1xyXG5pbXBvcnQgeyBFcnJvclR5cGVzLCBFcnJvckRldGFpbHMgfSBmcm9tICcuLi9lcnJvcnMnO1xyXG5pbXBvcnQgRGVjcnlwdGVyIGZyb20gJy4uL2NyeXB0L2RlY3J5cHRlcic7XHJcbmltcG9ydCBBQUNEZW11eGVyIGZyb20gJy4uL2RlbXV4L2FhY2RlbXV4ZXInO1xyXG5pbXBvcnQgTVA0RGVtdXhlciBmcm9tICcuLi9kZW11eC9tcDRkZW11eGVyJztcclxuaW1wb3J0IFRTRGVtdXhlciBmcm9tICcuLi9kZW11eC90c2RlbXV4ZXInO1xyXG5pbXBvcnQgTVAzRGVtdXhlciBmcm9tICcuLi9kZW11eC9tcDNkZW11eGVyJztcclxuaW1wb3J0IE1QNFJlbXV4ZXIgZnJvbSAnLi4vcmVtdXgvbXA0LXJlbXV4ZXInO1xyXG5pbXBvcnQgUGFzc1Rocm91Z2hSZW11eGVyIGZyb20gJy4uL3JlbXV4L3Bhc3N0aHJvdWdoLXJlbXV4ZXInO1xyXG5cclxuY2xhc3MgRGVtdXhlcklubGluZSB7XHJcblxyXG4gIGNvbnN0cnVjdG9yKG9ic2VydmVyLCB0eXBlU3VwcG9ydGVkLCBjb25maWcsIHZlbmRvcikge1xyXG4gICAgdGhpcy5vYnNlcnZlciA9IG9ic2VydmVyO1xyXG4gICAgdGhpcy50eXBlU3VwcG9ydGVkID0gdHlwZVN1cHBvcnRlZDtcclxuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xyXG4gICAgdGhpcy52ZW5kb3IgPSB2ZW5kb3I7XHJcbiAgfVxyXG5cclxuICBkZXN0cm95KCkge1xyXG4gICAgdmFyIGRlbXV4ZXIgPSB0aGlzLmRlbXV4ZXI7XHJcbiAgICBpZiAoZGVtdXhlcikge1xyXG4gICAgICBkZW11eGVyLmRlc3Ryb3koKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHB1c2goZGF0YSwgZGVjcnlwdGRhdGEsIGluaXRTZWdtZW50LCBhdWRpb0NvZGVjLCB2aWRlb0NvZGVjLCB0aW1lT2Zmc2V0LCBkaXNjb250aW51aXR5LCB0cmFja1N3aXRjaCwgY29udGlndW91cywgZHVyYXRpb24sIGFjY3VyYXRlVGltZU9mZnNldCwgZGVmYXVsdEluaXRQVFMpIHtcclxuICAgIGlmICgoZGF0YS5ieXRlTGVuZ3RoID4gMCkgJiYgKGRlY3J5cHRkYXRhICE9IG51bGwpICYmIChkZWNyeXB0ZGF0YS5rZXkgIT0gbnVsbCkgJiYgKGRlY3J5cHRkYXRhLm1ldGhvZCA9PT0gJ0FFUy0xMjgnKSkge1xyXG4gICAgICBsZXQgZGVjcnlwdGVyID0gdGhpcy5kZWNyeXB0ZXI7XHJcbiAgICAgIGlmIChkZWNyeXB0ZXIgPT0gbnVsbCkge1xyXG4gICAgICAgIGRlY3J5cHRlciA9IHRoaXMuZGVjcnlwdGVyID0gbmV3IERlY3J5cHRlcih0aGlzLm9ic2VydmVyLCB0aGlzLmNvbmZpZyk7XHJcbiAgICAgIH1cclxuICAgICAgdmFyIGxvY2FsdGhpcyA9IHRoaXM7XHJcbiAgICAgIC8vIHBlcmZvcm1hbmNlLm5vdygpIG5vdCBhdmFpbGFibGUgb24gV2ViV29ya2VyLCBhdCBsZWFzdCBvbiBTYWZhcmkgRGVza3RvcFxyXG4gICAgICB2YXIgc3RhcnRUaW1lO1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xyXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIHN0YXJ0VGltZSA9IERhdGUubm93KCk7XHJcbiAgICAgIH1cclxuICAgICAgZGVjcnlwdGVyLmRlY3J5cHQoZGF0YSwgZGVjcnlwdGRhdGEua2V5LmJ1ZmZlciwgZGVjcnlwdGRhdGEuaXYuYnVmZmVyLCBmdW5jdGlvbiAoZGVjcnlwdGVkRGF0YSkge1xyXG4gICAgICAgIHZhciBlbmRUaW1lO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBlbmRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgIGVuZFRpbWUgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsb2NhbHRoaXMub2JzZXJ2ZXIudHJpZ2dlcihFdmVudC5GUkFHX0RFQ1JZUFRFRCwgeyBzdGF0czogeyB0c3RhcnQ6IHN0YXJ0VGltZSwgdGRlY3J5cHQ6IGVuZFRpbWUgfSB9KTtcclxuICAgICAgICBsb2NhbHRoaXMucHVzaERlY3J5cHRlZChuZXcgVWludDhBcnJheShkZWNyeXB0ZWREYXRhKSwgZGVjcnlwdGRhdGEsIG5ldyBVaW50OEFycmF5KGluaXRTZWdtZW50KSwgYXVkaW9Db2RlYywgdmlkZW9Db2RlYywgdGltZU9mZnNldCwgZGlzY29udGludWl0eSwgdHJhY2tTd2l0Y2gsIGNvbnRpZ3VvdXMsIGR1cmF0aW9uLCBhY2N1cmF0ZVRpbWVPZmZzZXQsIGRlZmF1bHRJbml0UFRTKTtcclxuICAgICAgfSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLnB1c2hEZWNyeXB0ZWQobmV3IFVpbnQ4QXJyYXkoZGF0YSksIGRlY3J5cHRkYXRhLCBuZXcgVWludDhBcnJheShpbml0U2VnbWVudCksIGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWMsIHRpbWVPZmZzZXQsIGRpc2NvbnRpbnVpdHksIHRyYWNrU3dpdGNoLCBjb250aWd1b3VzLCBkdXJhdGlvbiwgYWNjdXJhdGVUaW1lT2Zmc2V0LCBkZWZhdWx0SW5pdFBUUyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwdXNoRGVjcnlwdGVkKGRhdGEsIGRlY3J5cHRkYXRhLCBpbml0U2VnbWVudCwgYXVkaW9Db2RlYywgdmlkZW9Db2RlYywgdGltZU9mZnNldCwgZGlzY29udGludWl0eSwgdHJhY2tTd2l0Y2gsIGNvbnRpZ3VvdXMsIGR1cmF0aW9uLCBhY2N1cmF0ZVRpbWVPZmZzZXQsIGRlZmF1bHRJbml0UFRTKSB7XHJcbiAgICB2YXIgZGVtdXhlciA9IHRoaXMuZGVtdXhlcjtcclxuICAgIGlmICghZGVtdXhlciB8fFxyXG4gICAgICAvLyBpbiBjYXNlIG9mIGNvbnRpbnVpdHkgY2hhbmdlLCB3ZSBtaWdodCBzd2l0Y2ggZnJvbSBjb250ZW50IHR5cGUgKEFBQyBjb250YWluZXIgdG8gVFMgY29udGFpbmVyIGZvciBleGFtcGxlKVxyXG4gICAgICAvLyBzbyBsZXQncyBjaGVjayB0aGF0IGN1cnJlbnQgZGVtdXhlciBpcyBzdGlsbCB2YWxpZFxyXG4gICAgICAoZGlzY29udGludWl0eSAmJiAhdGhpcy5wcm9iZShkYXRhKSkpIHtcclxuICAgICAgY29uc3Qgb2JzZXJ2ZXIgPSB0aGlzLm9ic2VydmVyO1xyXG4gICAgICBjb25zdCB0eXBlU3VwcG9ydGVkID0gdGhpcy50eXBlU3VwcG9ydGVkO1xyXG4gICAgICBjb25zdCBjb25maWcgPSB0aGlzLmNvbmZpZztcclxuICAgICAgLy8gcHJvYmluZyBvcmRlciBpcyBBQUMvTVAzL1RTL01QNFxyXG4gICAgICBjb25zdCBtdXhDb25maWcgPSBbeyBkZW11eDogQUFDRGVtdXhlciwgcmVtdXg6IE1QNFJlbXV4ZXIgfSxcclxuICAgICAgeyBkZW11eDogTVAzRGVtdXhlciwgcmVtdXg6IE1QNFJlbXV4ZXIgfSxcclxuICAgICAgeyBkZW11eDogVFNEZW11eGVyLCByZW11eDogTVA0UmVtdXhlciB9LFxyXG4gICAgICB7IGRlbXV4OiBNUDREZW11eGVyLCByZW11eDogUGFzc1Rocm91Z2hSZW11eGVyIH1dO1xyXG5cclxuICAgICAgLy8gcHJvYmUgZm9yIGNvbnRlbnQgdHlwZVxyXG4gICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gbXV4Q29uZmlnLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgbXV4ID0gbXV4Q29uZmlnW2ldO1xyXG4gICAgICAgIGNvbnN0IHByb2JlID0gbXV4LmRlbXV4LnByb2JlO1xyXG4gICAgICAgIGlmIChwcm9iZShkYXRhKSkge1xyXG4gICAgICAgICAgY29uc3QgcmVtdXhlciA9IHRoaXMucmVtdXhlciA9IG5ldyBtdXgucmVtdXgob2JzZXJ2ZXIsIGNvbmZpZywgdHlwZVN1cHBvcnRlZCwgdGhpcy52ZW5kb3IpO1xyXG4gICAgICAgICAgZGVtdXhlciA9IG5ldyBtdXguZGVtdXgob2JzZXJ2ZXIsIHJlbXV4ZXIsIGNvbmZpZywgdHlwZVN1cHBvcnRlZCk7XHJcbiAgICAgICAgICB0aGlzLnByb2JlID0gcHJvYmU7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgaWYgKCFkZW11eGVyKSB7XHJcbiAgICAgICAgb2JzZXJ2ZXIudHJpZ2dlcihFdmVudC5FUlJPUiwgeyB0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLCBkZXRhaWxzOiBFcnJvckRldGFpbHMuRlJBR19QQVJTSU5HX0VSUk9SLCBmYXRhbDogdHJ1ZSwgcmVhc29uOiAnbm8gZGVtdXggbWF0Y2hpbmcgd2l0aCBjb250ZW50IGZvdW5kJyB9KTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5kZW11eGVyID0gZGVtdXhlcjtcclxuICAgIH1cclxuICAgIGNvbnN0IHJlbXV4ZXIgPSB0aGlzLnJlbXV4ZXI7XHJcblxyXG4gICAgaWYgKGRpc2NvbnRpbnVpdHkgfHwgdHJhY2tTd2l0Y2gpIHtcclxuICAgICAgZGVtdXhlci5yZXNldEluaXRTZWdtZW50KGluaXRTZWdtZW50LCBhdWRpb0NvZGVjLCB2aWRlb0NvZGVjLCBkdXJhdGlvbik7XHJcbiAgICAgIHJlbXV4ZXIucmVzZXRJbml0U2VnbWVudCgpO1xyXG4gICAgfVxyXG4gICAgaWYgKGRpc2NvbnRpbnVpdHkpIHtcclxuICAgICAgZGVtdXhlci5yZXNldFRpbWVTdGFtcChkZWZhdWx0SW5pdFBUUyk7XHJcbiAgICAgIHJlbXV4ZXIucmVzZXRUaW1lU3RhbXAoZGVmYXVsdEluaXRQVFMpO1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiBkZW11eGVyLnNldERlY3J5cHREYXRhID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgIGRlbXV4ZXIuc2V0RGVjcnlwdERhdGEoZGVjcnlwdGRhdGEpO1xyXG4gICAgfVxyXG4gICAgZGVtdXhlci5hcHBlbmQoZGF0YSwgdGltZU9mZnNldCwgY29udGlndW91cywgYWNjdXJhdGVUaW1lT2Zmc2V0KTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IERlbXV4ZXJJbmxpbmU7XHJcbiIsIi8qIGRlbXV4ZXIgd2ViIHdvcmtlci5cclxuICogIC0gbGlzdGVuIHRvIHdvcmtlciBtZXNzYWdlLCBhbmQgdHJpZ2dlciBEZW11eGVySW5saW5lIHVwb24gcmVjZXB0aW9uIG9mIEZyYWdtZW50cy5cclxuICogIC0gcHJvdmlkZXMgTVA0IEJveGVzIGJhY2sgdG8gbWFpbiB0aHJlYWQgdXNpbmcgW3RyYW5zZmVyYWJsZSBvYmplY3RzXShodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS93ZWIvdXBkYXRlcy8yMDExLzEyL1RyYW5zZmVyYWJsZS1PYmplY3RzLUxpZ2h0bmluZy1GYXN0KSBpbiBvcmRlciB0byBtaW5pbWl6ZSBtZXNzYWdlIHBhc3Npbmcgb3ZlcmhlYWQuXHJcbiAqL1xyXG5cclxuIGltcG9ydCBEZW11eGVySW5saW5lIGZyb20gJy4uL2RlbXV4L2RlbXV4ZXItaW5saW5lJztcclxuIGltcG9ydCBFdmVudCBmcm9tICcuLi9ldmVudHMnO1xyXG4gaW1wb3J0IHtlbmFibGVMb2dzfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xyXG4gaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tICdldmVudHMnO1xyXG5cclxudmFyIERlbXV4ZXJXb3JrZXIgPSBmdW5jdGlvbiAoc2VsZikge1xyXG4gIC8vIG9ic2VydmVyIHNldHVwXHJcbiAgdmFyIG9ic2VydmVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gIG9ic2VydmVyLnRyaWdnZXIgPSBmdW5jdGlvbiB0cmlnZ2VyIChldmVudCwgLi4uZGF0YSkge1xyXG4gICAgb2JzZXJ2ZXIuZW1pdChldmVudCwgZXZlbnQsIC4uLmRhdGEpO1xyXG4gIH07XHJcblxyXG4gIG9ic2VydmVyLm9mZiA9IGZ1bmN0aW9uIG9mZiAoZXZlbnQsIC4uLmRhdGEpIHtcclxuICAgIG9ic2VydmVyLnJlbW92ZUxpc3RlbmVyKGV2ZW50LCAuLi5kYXRhKTtcclxuICB9O1xyXG5cclxuICB2YXIgZm9yd2FyZE1lc3NhZ2UgPSBmdW5jdGlvbihldixkYXRhKSB7XHJcbiAgICBzZWxmLnBvc3RNZXNzYWdlKHtldmVudDogZXYsIGRhdGE6ZGF0YSB9KTtcclxuICB9O1xyXG5cclxuICBzZWxmLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBmdW5jdGlvbiAoZXYpIHtcclxuICAgIHZhciBkYXRhID0gZXYuZGF0YTtcclxuICAgIC8vY29uc29sZS5sb2coJ2RlbXV4ZXIgY21kOicgKyBkYXRhLmNtZCk7XHJcbiAgICBzd2l0Y2ggKGRhdGEuY21kKSB7XHJcbiAgICAgIGNhc2UgJ2luaXQnOlxyXG4gICAgICAgIGxldCBjb25maWcgPSBKU09OLnBhcnNlKGRhdGEuY29uZmlnKTtcclxuICAgICAgICBzZWxmLmRlbXV4ZXIgPSBuZXcgRGVtdXhlcklubGluZShvYnNlcnZlciwgZGF0YS50eXBlU3VwcG9ydGVkLCBjb25maWcsIGRhdGEudmVuZG9yKTtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgZW5hYmxlTG9ncyhjb25maWcuZGVidWcgPT09IHRydWUpO1xyXG4gICAgICAgIH0gY2F0Y2goZXJyKSB7XHJcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ2RlbXV4ZXJXb3JrZXI6IHVuYWJsZSB0byBlbmFibGUgbG9ncycpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBzaWduYWwgZW5kIG9mIHdvcmtlciBpbml0XHJcbiAgICAgICAgZm9yd2FyZE1lc3NhZ2UoJ2luaXQnLG51bGwpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlICdkZW11eCc6XHJcbiAgICAgICAgc2VsZi5kZW11eGVyLnB1c2goZGF0YS5kYXRhLCBkYXRhLmRlY3J5cHRkYXRhLCBkYXRhLmluaXRTZWdtZW50LCBkYXRhLmF1ZGlvQ29kZWMsIGRhdGEudmlkZW9Db2RlYywgZGF0YS50aW1lT2Zmc2V0LGRhdGEuZGlzY29udGludWl0eSwgZGF0YS50cmFja1N3aXRjaCxkYXRhLmNvbnRpZ3VvdXMsZGF0YS5kdXJhdGlvbixkYXRhLmFjY3VyYXRlVGltZU9mZnNldCxkYXRhLmRlZmF1bHRJbml0UFRTKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgZGVmYXVsdDpcclxuICAgICAgICBicmVhaztcclxuICAgIH1cclxuICB9KTtcclxuXHJcbiAgLy8gZm9yd2FyZCBldmVudHMgdG8gbWFpbiB0aHJlYWRcclxuICBvYnNlcnZlci5vbihFdmVudC5GUkFHX0RFQ1JZUFRFRCwgZm9yd2FyZE1lc3NhZ2UpO1xyXG4gIG9ic2VydmVyLm9uKEV2ZW50LkZSQUdfUEFSU0lOR19JTklUX1NFR01FTlQsIGZvcndhcmRNZXNzYWdlKTtcclxuICBvYnNlcnZlci5vbihFdmVudC5GUkFHX1BBUlNFRCwgZm9yd2FyZE1lc3NhZ2UpO1xyXG4gIG9ic2VydmVyLm9uKEV2ZW50LkVSUk9SLCBmb3J3YXJkTWVzc2FnZSk7XHJcbiAgb2JzZXJ2ZXIub24oRXZlbnQuRlJBR19QQVJTSU5HX01FVEFEQVRBLCBmb3J3YXJkTWVzc2FnZSk7XHJcbiAgb2JzZXJ2ZXIub24oRXZlbnQuRlJBR19QQVJTSU5HX1VTRVJEQVRBLCBmb3J3YXJkTWVzc2FnZSk7XHJcbiAgb2JzZXJ2ZXIub24oRXZlbnQuSU5JVF9QVFNfRk9VTkQsIGZvcndhcmRNZXNzYWdlKTtcclxuXHJcbiAgLy8gc3BlY2lhbCBjYXNlIGZvciBGUkFHX1BBUlNJTkdfREFUQTogcGFzcyBkYXRhMS9kYXRhMiBhcyB0cmFuc2ZlcmFibGUgb2JqZWN0IChubyBjb3B5KVxyXG4gIG9ic2VydmVyLm9uKEV2ZW50LkZSQUdfUEFSU0lOR19EQVRBLCBmdW5jdGlvbihldiwgZGF0YSkge1xyXG4gICAgbGV0IHRyYW5zZmVyYWJsZSA9IFtdO1xyXG4gICAgbGV0IG1lc3NhZ2UgPSB7ZXZlbnQ6IGV2LCBkYXRhOmRhdGF9O1xyXG4gICAgaWYgKGRhdGEuZGF0YTEpIHtcclxuICAgICAgbWVzc2FnZS5kYXRhMSA9IGRhdGEuZGF0YTEuYnVmZmVyO1xyXG4gICAgICB0cmFuc2ZlcmFibGUucHVzaChkYXRhLmRhdGExLmJ1ZmZlcik7XHJcbiAgICAgIGRlbGV0ZSBkYXRhLmRhdGExO1xyXG4gICAgfVxyXG4gICAgaWYgKGRhdGEuZGF0YTIpIHtcclxuICAgICAgbWVzc2FnZS5kYXRhMiA9IGRhdGEuZGF0YTIuYnVmZmVyO1xyXG4gICAgICB0cmFuc2ZlcmFibGUucHVzaChkYXRhLmRhdGEyLmJ1ZmZlcik7XHJcbiAgICAgIGRlbGV0ZSBkYXRhLmRhdGEyO1xyXG4gICAgfVxyXG4gICAgc2VsZi5wb3N0TWVzc2FnZShtZXNzYWdlLHRyYW5zZmVyYWJsZSk7XHJcbiAgfSk7XHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBEZW11eGVyV29ya2VyO1xyXG5cclxuIiwiaW1wb3J0IEV2ZW50IGZyb20gJy4uL2V2ZW50cyc7XHJcbmltcG9ydCBEZW11eGVySW5saW5lIGZyb20gJy4uL2RlbXV4L2RlbXV4ZXItaW5saW5lJztcclxuaW1wb3J0IERlbXV4ZXJXb3JrZXIgZnJvbSAnLi4vZGVtdXgvZGVtdXhlci13b3JrZXInO1xyXG5pbXBvcnQge2xvZ2dlcn0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcclxuaW1wb3J0IHtFcnJvclR5cGVzLCBFcnJvckRldGFpbHN9IGZyb20gJy4uL2Vycm9ycyc7XHJcbmltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSAnZXZlbnRzJztcclxuXHJcbmNsYXNzIERlbXV4ZXIge1xyXG5cclxuICBjb25zdHJ1Y3RvcihobHMsIGlkKSB7XHJcbiAgICB0aGlzLmhscyA9IGhscztcclxuICAgIHRoaXMuaWQgPSBpZDtcclxuICAgIC8vIG9ic2VydmVyIHNldHVwXHJcbiAgICBjb25zdCBvYnNlcnZlciA9IHRoaXMub2JzZXJ2ZXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICBjb25zdCBjb25maWcgPSBobHMuY29uZmlnO1xyXG4gICAgb2JzZXJ2ZXIudHJpZ2dlciA9IGZ1bmN0aW9uIHRyaWdnZXIgKGV2ZW50LCAuLi5kYXRhKSB7XHJcbiAgICAgIG9ic2VydmVyLmVtaXQoZXZlbnQsIGV2ZW50LCAuLi5kYXRhKTtcclxuICAgIH07XHJcblxyXG4gICAgb2JzZXJ2ZXIub2ZmID0gZnVuY3Rpb24gb2ZmIChldmVudCwgLi4uZGF0YSkge1xyXG4gICAgICBvYnNlcnZlci5yZW1vdmVMaXN0ZW5lcihldmVudCwgLi4uZGF0YSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBmb3J3YXJkTWVzc2FnZSA9IGZ1bmN0aW9uKGV2LGRhdGEpIHtcclxuICAgICAgZGF0YSA9IGRhdGEgfHwge307XHJcbiAgICAgIGRhdGEuZnJhZyA9IHRoaXMuZnJhZztcclxuICAgICAgZGF0YS5pZCA9IHRoaXMuaWQ7XHJcbiAgICAgIGhscy50cmlnZ2VyKGV2LGRhdGEpO1xyXG4gICAgfS5iaW5kKHRoaXMpO1xyXG5cclxuICAgIC8vIGZvcndhcmQgZXZlbnRzIHRvIG1haW4gdGhyZWFkXHJcbiAgICBvYnNlcnZlci5vbihFdmVudC5GUkFHX0RFQ1JZUFRFRCwgZm9yd2FyZE1lc3NhZ2UpO1xyXG4gICAgb2JzZXJ2ZXIub24oRXZlbnQuRlJBR19QQVJTSU5HX0lOSVRfU0VHTUVOVCwgZm9yd2FyZE1lc3NhZ2UpO1xyXG4gICAgb2JzZXJ2ZXIub24oRXZlbnQuRlJBR19QQVJTSU5HX0RBVEEsIGZvcndhcmRNZXNzYWdlKTtcclxuICAgIG9ic2VydmVyLm9uKEV2ZW50LkZSQUdfUEFSU0VELCBmb3J3YXJkTWVzc2FnZSk7XHJcbiAgICBvYnNlcnZlci5vbihFdmVudC5FUlJPUiwgZm9yd2FyZE1lc3NhZ2UpO1xyXG4gICAgb2JzZXJ2ZXIub24oRXZlbnQuRlJBR19QQVJTSU5HX01FVEFEQVRBLCBmb3J3YXJkTWVzc2FnZSk7XHJcbiAgICBvYnNlcnZlci5vbihFdmVudC5GUkFHX1BBUlNJTkdfVVNFUkRBVEEsIGZvcndhcmRNZXNzYWdlKTtcclxuICAgIG9ic2VydmVyLm9uKEV2ZW50LklOSVRfUFRTX0ZPVU5ELCBmb3J3YXJkTWVzc2FnZSk7XHJcblxyXG4gICAgY29uc3QgdHlwZVN1cHBvcnRlZCA9IHtcclxuICAgICAgbXA0IDogTWVkaWFTb3VyY2UuaXNUeXBlU3VwcG9ydGVkKCd2aWRlby9tcDQnKSxcclxuICAgICAgbXBlZzogTWVkaWFTb3VyY2UuaXNUeXBlU3VwcG9ydGVkKCdhdWRpby9tcGVnJyksXHJcbiAgICAgIG1wMzogTWVkaWFTb3VyY2UuaXNUeXBlU3VwcG9ydGVkKCdhdWRpby9tcDQ7IGNvZGVjcz1cIm1wM1wiJylcclxuICAgIH07XHJcbiAgICAvLyBuYXZpZ2F0b3IudmVuZG9yIGlzIG5vdCBhbHdheXMgYXZhaWxhYmxlIGluIFdlYiBXb3JrZXJcclxuICAgIC8vIHJlZmVyIHRvIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Xb3JrZXJHbG9iYWxTY29wZS9uYXZpZ2F0b3JcclxuICAgIGNvbnN0IHZlbmRvciA9IG5hdmlnYXRvci52ZW5kb3I7XHJcbiAgICBpZiAoY29uZmlnLmVuYWJsZVdvcmtlciAmJiAodHlwZW9mKFdvcmtlcikgIT09ICd1bmRlZmluZWQnKSkge1xyXG4gICAgICAgIGxvZ2dlci5sb2coJ2RlbXV4aW5nIGluIHdlYndvcmtlcicpO1xyXG4gICAgICAgIGxldCB3O1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBsZXQgd29yayA9IHJlcXVpcmUoJ3dlYndvcmtpZnknKTtcclxuICAgICAgICAgIHcgPSB0aGlzLncgPSB3b3JrKERlbXV4ZXJXb3JrZXIpO1xyXG4gICAgICAgICAgdGhpcy5vbndtc2cgPSB0aGlzLm9uV29ya2VyTWVzc2FnZS5iaW5kKHRoaXMpO1xyXG4gICAgICAgICAgdy5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgdGhpcy5vbndtc2cpO1xyXG4gICAgICAgICAgdy5vbmVycm9yID0gZnVuY3Rpb24oZXZlbnQpIHsgaGxzLnRyaWdnZXIoRXZlbnQuRVJST1IsIHt0eXBlOiBFcnJvclR5cGVzLk9USEVSX0VSUk9SLCBkZXRhaWxzOiBFcnJvckRldGFpbHMuSU5URVJOQUxfRVhDRVBUSU9OLCBmYXRhbDogdHJ1ZSwgZXZlbnQgOiAnZGVtdXhlcldvcmtlcicsIGVyciA6IHsgbWVzc2FnZSA6IGV2ZW50Lm1lc3NhZ2UgKyAnICgnICsgZXZlbnQuZmlsZW5hbWUgKyAnOicgKyBldmVudC5saW5lbm8gKyAnKScgfX0pO307XHJcbiAgICAgICAgICB3LnBvc3RNZXNzYWdlKHtjbWQ6ICdpbml0JywgdHlwZVN1cHBvcnRlZCA6IHR5cGVTdXBwb3J0ZWQsIHZlbmRvciA6IHZlbmRvciwgaWQgOiBpZCwgY29uZmlnOiBKU09OLnN0cmluZ2lmeShjb25maWcpfSk7XHJcbiAgICAgICAgfSBjYXRjaChlcnIpIHtcclxuICAgICAgICAgIGxvZ2dlci5lcnJvcignZXJyb3Igd2hpbGUgaW5pdGlhbGl6aW5nIERlbXV4ZXJXb3JrZXIsIGZhbGxiYWNrIG9uIERlbXV4ZXJJbmxpbmUnKTtcclxuICAgICAgICAgIGlmICh3KSB7XHJcbiAgICAgICAgICAgIC8vIHJldm9rZSB0aGUgT2JqZWN0IFVSTCB0aGF0IHdhcyB1c2VkIHRvIGNyZWF0ZSBkZW11eGVyIHdvcmtlciwgc28gYXMgbm90IHRvIGxlYWsgaXRcclxuICAgICAgICAgICAgVVJMLnJldm9rZU9iamVjdFVSTCh3Lm9iamVjdFVSTCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICB0aGlzLmRlbXV4ZXIgPSBuZXcgRGVtdXhlcklubGluZShvYnNlcnZlcix0eXBlU3VwcG9ydGVkLGNvbmZpZyx2ZW5kb3IpO1xyXG4gICAgICAgICAgdGhpcy53ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLmRlbXV4ZXIgPSBuZXcgRGVtdXhlcklubGluZShvYnNlcnZlcix0eXBlU3VwcG9ydGVkLGNvbmZpZywgdmVuZG9yKTtcclxuICAgICAgfVxyXG4gIH1cclxuXHJcbiAgZGVzdHJveSgpIHtcclxuICAgIGxldCB3ID0gdGhpcy53O1xyXG4gICAgaWYgKHcpIHtcclxuICAgICAgdy5yZW1vdmVFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgdGhpcy5vbndtc2cpO1xyXG4gICAgICB3LnRlcm1pbmF0ZSgpO1xyXG4gICAgICB0aGlzLncgPSBudWxsO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgbGV0IGRlbXV4ZXIgPSB0aGlzLmRlbXV4ZXI7XHJcbiAgICAgIGlmIChkZW11eGVyKSB7XHJcbiAgICAgICAgZGVtdXhlci5kZXN0cm95KCk7XHJcbiAgICAgICAgdGhpcy5kZW11eGVyID0gbnVsbDtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgbGV0IG9ic2VydmVyID0gdGhpcy5vYnNlcnZlcjtcclxuICAgIGlmIChvYnNlcnZlcikge1xyXG4gICAgICBvYnNlcnZlci5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcclxuICAgICAgdGhpcy5vYnNlcnZlciA9IG51bGw7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwdXNoKGRhdGEsIGluaXRTZWdtZW50LCBhdWRpb0NvZGVjLCB2aWRlb0NvZGVjLCBmcmFnLCBkdXJhdGlvbixhY2N1cmF0ZVRpbWVPZmZzZXQsZGVmYXVsdEluaXRQVFMpIHtcclxuICAgIGNvbnN0IHcgPSB0aGlzLnc7XHJcbiAgICBjb25zdCB0aW1lT2Zmc2V0ID0gIWlzTmFOKGZyYWcuc3RhcnREVFMpID8gZnJhZy5zdGFydERUUyAgOiBmcmFnLnN0YXJ0O1xyXG4gICAgY29uc3QgZGVjcnlwdGRhdGEgPSBmcmFnLmRlY3J5cHRkYXRhO1xyXG4gICAgY29uc3QgbGFzdEZyYWcgPSB0aGlzLmZyYWc7XHJcbiAgICBjb25zdCBkaXNjb250aW51aXR5ID0gIShsYXN0RnJhZyAmJiAoZnJhZy5jYyA9PT0gbGFzdEZyYWcuY2MpKTtcclxuICAgIGNvbnN0IHRyYWNrU3dpdGNoID0gIShsYXN0RnJhZyAmJiAoZnJhZy5sZXZlbCA9PT0gbGFzdEZyYWcubGV2ZWwpKTtcclxuICAgIGNvbnN0IG5leHRTTiA9IGxhc3RGcmFnICYmIChmcmFnLnNuID09PSAobGFzdEZyYWcuc24rMSkpO1xyXG4gICAgY29uc3QgY29udGlndW91cyA9ICF0cmFja1N3aXRjaCAmJiBuZXh0U047XHJcbiAgICBpZiAoZGlzY29udGludWl0eSkge1xyXG4gICAgICBsb2dnZXIubG9nKGAke3RoaXMuaWR9OmRpc2NvbnRpbnVpdHkgZGV0ZWN0ZWRgKTtcclxuICAgIH1cclxuICAgIGlmICh0cmFja1N3aXRjaCkge1xyXG4gICAgICBsb2dnZXIubG9nKGAke3RoaXMuaWR9OnN3aXRjaCBkZXRlY3RlZGApO1xyXG4gICAgfVxyXG4gICAgdGhpcy5mcmFnID0gZnJhZztcclxuICAgIGlmICh3KSB7XHJcbiAgICAgIC8vIHBvc3QgZnJhZ21lbnQgcGF5bG9hZCBhcyB0cmFuc2ZlcmFibGUgb2JqZWN0cyAobm8gY29weSlcclxuICAgICAgdy5wb3N0TWVzc2FnZSh7Y21kOiAnZGVtdXgnLCBkYXRhLCBkZWNyeXB0ZGF0YSwgaW5pdFNlZ21lbnQsIGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWMsIHRpbWVPZmZzZXQsIGRpc2NvbnRpbnVpdHksIHRyYWNrU3dpdGNoLCBjb250aWd1b3VzLCBkdXJhdGlvbiwgYWNjdXJhdGVUaW1lT2Zmc2V0LGRlZmF1bHRJbml0UFRTfSwgW2RhdGFdKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGxldCBkZW11eGVyID0gdGhpcy5kZW11eGVyO1xyXG4gICAgICBpZiAoZGVtdXhlcikge1xyXG4gICAgICAgIGRlbXV4ZXIucHVzaChkYXRhLCBkZWNyeXB0ZGF0YSwgaW5pdFNlZ21lbnQsIGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWMsIHRpbWVPZmZzZXQsIGRpc2NvbnRpbnVpdHksIHRyYWNrU3dpdGNoLCBjb250aWd1b3VzLCBkdXJhdGlvbiwgYWNjdXJhdGVUaW1lT2Zmc2V0LGRlZmF1bHRJbml0UFRTKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgb25Xb3JrZXJNZXNzYWdlKGV2KSB7XHJcbiAgICBsZXQgZGF0YSA9IGV2LmRhdGEsXHJcbiAgICAgICAgaGxzID0gdGhpcy5obHM7XHJcbiAgICAvL2NvbnNvbGUubG9nKCdvbldvcmtlck1lc3NhZ2U6JyArIGRhdGEuZXZlbnQpO1xyXG4gICAgc3dpdGNoKGRhdGEuZXZlbnQpIHtcclxuICAgICAgY2FzZSAnaW5pdCc6XHJcbiAgICAgICAgLy8gcmV2b2tlIHRoZSBPYmplY3QgVVJMIHRoYXQgd2FzIHVzZWQgdG8gY3JlYXRlIGRlbXV4ZXIgd29ya2VyLCBzbyBhcyBub3QgdG8gbGVhayBpdFxyXG4gICAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwodGhpcy53Lm9iamVjdFVSTCk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIC8vIHNwZWNpYWwgY2FzZSBmb3IgRlJBR19QQVJTSU5HX0RBVEE6IGRhdGExIGFuZCBkYXRhMiBhcmUgdHJhbnNmZXJhYmxlIG9iamVjdHNcclxuICAgICAgY2FzZSBFdmVudC5GUkFHX1BBUlNJTkdfREFUQTpcclxuICAgICAgICBkYXRhLmRhdGEuZGF0YTEgPSBuZXcgVWludDhBcnJheShkYXRhLmRhdGExKTtcclxuICAgICAgICBpZiAoZGF0YS5kYXRhMikge1xyXG4gICAgICAgICAgZGF0YS5kYXRhLmRhdGEyID0gbmV3IFVpbnQ4QXJyYXkoZGF0YS5kYXRhMik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cclxuICAgICAgZGVmYXVsdDpcclxuICAgICAgICBkYXRhLmRhdGEgPSBkYXRhLmRhdGEgfHwge307XHJcbiAgICAgICAgZGF0YS5kYXRhLmZyYWcgPSB0aGlzLmZyYWc7XHJcbiAgICAgICAgZGF0YS5kYXRhLmlkID0gdGhpcy5pZDtcclxuICAgICAgICBobHMudHJpZ2dlcihkYXRhLmV2ZW50LCBkYXRhLmRhdGEpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgRGVtdXhlcjtcclxuXHJcbiIsIi8qKlxyXG4gKiBQYXJzZXIgZm9yIGV4cG9uZW50aWFsIEdvbG9tYiBjb2RlcywgYSB2YXJpYWJsZS1iaXR3aWR0aCBudW1iZXIgZW5jb2Rpbmcgc2NoZW1lIHVzZWQgYnkgaDI2NC5cclxuKi9cclxuXHJcbmltcG9ydCB7bG9nZ2VyfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xyXG5cclxuY2xhc3MgRXhwR29sb21iIHtcclxuXHJcbiAgY29uc3RydWN0b3IoZGF0YSkge1xyXG4gICAgdGhpcy5kYXRhID0gZGF0YTtcclxuICAgIC8vIHRoZSBudW1iZXIgb2YgYnl0ZXMgbGVmdCB0byBleGFtaW5lIGluIHRoaXMuZGF0YVxyXG4gICAgdGhpcy5ieXRlc0F2YWlsYWJsZSA9IGRhdGEuYnl0ZUxlbmd0aDtcclxuICAgIC8vIHRoZSBjdXJyZW50IHdvcmQgYmVpbmcgZXhhbWluZWRcclxuICAgIHRoaXMud29yZCA9IDA7IC8vIDp1aW50XHJcbiAgICAvLyB0aGUgbnVtYmVyIG9mIGJpdHMgbGVmdCB0byBleGFtaW5lIGluIHRoZSBjdXJyZW50IHdvcmRcclxuICAgIHRoaXMuYml0c0F2YWlsYWJsZSA9IDA7IC8vIDp1aW50XHJcbiAgfVxyXG5cclxuICAvLyAoKTp2b2lkXHJcbiAgbG9hZFdvcmQoKSB7XHJcbiAgICB2YXJcclxuICAgICAgZGF0YSA9IHRoaXMuZGF0YSxcclxuICAgICAgYnl0ZXNBdmFpbGFibGUgPSB0aGlzLmJ5dGVzQXZhaWxhYmxlLFxyXG4gICAgICBwb3NpdGlvbiA9IGRhdGEuYnl0ZUxlbmd0aCAtIGJ5dGVzQXZhaWxhYmxlLFxyXG4gICAgICB3b3JraW5nQnl0ZXMgPSBuZXcgVWludDhBcnJheSg0KSxcclxuICAgICAgYXZhaWxhYmxlQnl0ZXMgPSBNYXRoLm1pbig0LCBieXRlc0F2YWlsYWJsZSk7XHJcbiAgICBpZiAoYXZhaWxhYmxlQnl0ZXMgPT09IDApIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdubyBieXRlcyBhdmFpbGFibGUnKTtcclxuICAgIH1cclxuICAgIHdvcmtpbmdCeXRlcy5zZXQoZGF0YS5zdWJhcnJheShwb3NpdGlvbiwgcG9zaXRpb24gKyBhdmFpbGFibGVCeXRlcykpO1xyXG4gICAgdGhpcy53b3JkID0gbmV3IERhdGFWaWV3KHdvcmtpbmdCeXRlcy5idWZmZXIpLmdldFVpbnQzMigwKTtcclxuICAgIC8vIHRyYWNrIHRoZSBhbW91bnQgb2YgdGhpcy5kYXRhIHRoYXQgaGFzIGJlZW4gcHJvY2Vzc2VkXHJcbiAgICB0aGlzLmJpdHNBdmFpbGFibGUgPSBhdmFpbGFibGVCeXRlcyAqIDg7XHJcbiAgICB0aGlzLmJ5dGVzQXZhaWxhYmxlIC09IGF2YWlsYWJsZUJ5dGVzO1xyXG4gIH1cclxuXHJcbiAgLy8gKGNvdW50OmludCk6dm9pZFxyXG4gIHNraXBCaXRzKGNvdW50KSB7XHJcbiAgICB2YXIgc2tpcEJ5dGVzOyAvLyA6aW50XHJcbiAgICBpZiAodGhpcy5iaXRzQXZhaWxhYmxlID4gY291bnQpIHtcclxuICAgICAgdGhpcy53b3JkIDw8PSBjb3VudDtcclxuICAgICAgdGhpcy5iaXRzQXZhaWxhYmxlIC09IGNvdW50O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY291bnQgLT0gdGhpcy5iaXRzQXZhaWxhYmxlO1xyXG4gICAgICBza2lwQnl0ZXMgPSBjb3VudCA+PiAzO1xyXG4gICAgICBjb3VudCAtPSAoc2tpcEJ5dGVzID4+IDMpO1xyXG4gICAgICB0aGlzLmJ5dGVzQXZhaWxhYmxlIC09IHNraXBCeXRlcztcclxuICAgICAgdGhpcy5sb2FkV29yZCgpO1xyXG4gICAgICB0aGlzLndvcmQgPDw9IGNvdW50O1xyXG4gICAgICB0aGlzLmJpdHNBdmFpbGFibGUgLT0gY291bnQ7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyAoc2l6ZTppbnQpOnVpbnRcclxuICByZWFkQml0cyhzaXplKSB7XHJcbiAgICB2YXJcclxuICAgICAgYml0cyA9IE1hdGgubWluKHRoaXMuYml0c0F2YWlsYWJsZSwgc2l6ZSksIC8vIDp1aW50XHJcbiAgICAgIHZhbHUgPSB0aGlzLndvcmQgPj4+ICgzMiAtIGJpdHMpOyAvLyA6dWludFxyXG4gICAgaWYgKHNpemUgPiAzMikge1xyXG4gICAgICBsb2dnZXIuZXJyb3IoJ0Nhbm5vdCByZWFkIG1vcmUgdGhhbiAzMiBiaXRzIGF0IGEgdGltZScpO1xyXG4gICAgfVxyXG4gICAgdGhpcy5iaXRzQXZhaWxhYmxlIC09IGJpdHM7XHJcbiAgICBpZiAodGhpcy5iaXRzQXZhaWxhYmxlID4gMCkge1xyXG4gICAgICB0aGlzLndvcmQgPDw9IGJpdHM7XHJcbiAgICB9IGVsc2UgaWYgKHRoaXMuYnl0ZXNBdmFpbGFibGUgPiAwKSB7XHJcbiAgICAgIHRoaXMubG9hZFdvcmQoKTtcclxuICAgIH1cclxuICAgIGJpdHMgPSBzaXplIC0gYml0cztcclxuICAgIGlmIChiaXRzID4gMCAmJiB0aGlzLmJpdHNBdmFpbGFibGUpIHtcclxuICAgICAgcmV0dXJuIHZhbHUgPDwgYml0cyB8IHRoaXMucmVhZEJpdHMoYml0cyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gdmFsdTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vICgpOnVpbnRcclxuICBza2lwTFooKSB7XHJcbiAgICB2YXIgbGVhZGluZ1plcm9Db3VudDsgLy8gOnVpbnRcclxuICAgIGZvciAobGVhZGluZ1plcm9Db3VudCA9IDA7IGxlYWRpbmdaZXJvQ291bnQgPCB0aGlzLmJpdHNBdmFpbGFibGU7ICsrbGVhZGluZ1plcm9Db3VudCkge1xyXG4gICAgICBpZiAoMCAhPT0gKHRoaXMud29yZCAmICgweDgwMDAwMDAwID4+PiBsZWFkaW5nWmVyb0NvdW50KSkpIHtcclxuICAgICAgICAvLyB0aGUgZmlyc3QgYml0IG9mIHdvcmtpbmcgd29yZCBpcyAxXHJcbiAgICAgICAgdGhpcy53b3JkIDw8PSBsZWFkaW5nWmVyb0NvdW50O1xyXG4gICAgICAgIHRoaXMuYml0c0F2YWlsYWJsZSAtPSBsZWFkaW5nWmVyb0NvdW50O1xyXG4gICAgICAgIHJldHVybiBsZWFkaW5nWmVyb0NvdW50O1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyB3ZSBleGhhdXN0ZWQgd29yZCBhbmQgc3RpbGwgaGF2ZSBub3QgZm91bmQgYSAxXHJcbiAgICB0aGlzLmxvYWRXb3JkKCk7XHJcbiAgICByZXR1cm4gbGVhZGluZ1plcm9Db3VudCArIHRoaXMuc2tpcExaKCk7XHJcbiAgfVxyXG5cclxuICAvLyAoKTp2b2lkXHJcbiAgc2tpcFVFRygpIHtcclxuICAgIHRoaXMuc2tpcEJpdHMoMSArIHRoaXMuc2tpcExaKCkpO1xyXG4gIH1cclxuXHJcbiAgLy8gKCk6dm9pZFxyXG4gIHNraXBFRygpIHtcclxuICAgIHRoaXMuc2tpcEJpdHMoMSArIHRoaXMuc2tpcExaKCkpO1xyXG4gIH1cclxuXHJcbiAgLy8gKCk6dWludFxyXG4gIHJlYWRVRUcoKSB7XHJcbiAgICB2YXIgY2x6ID0gdGhpcy5za2lwTFooKTsgLy8gOnVpbnRcclxuICAgIHJldHVybiB0aGlzLnJlYWRCaXRzKGNseiArIDEpIC0gMTtcclxuICB9XHJcblxyXG4gIC8vICgpOmludFxyXG4gIHJlYWRFRygpIHtcclxuICAgIHZhciB2YWx1ID0gdGhpcy5yZWFkVUVHKCk7IC8vIDppbnRcclxuICAgIGlmICgweDAxICYgdmFsdSkge1xyXG4gICAgICAvLyB0aGUgbnVtYmVyIGlzIG9kZCBpZiB0aGUgbG93IG9yZGVyIGJpdCBpcyBzZXRcclxuICAgICAgcmV0dXJuICgxICsgdmFsdSkgPj4+IDE7IC8vIGFkZCAxIHRvIG1ha2UgaXQgZXZlbiwgYW5kIGRpdmlkZSBieSAyXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gLTEgKiAodmFsdSA+Pj4gMSk7IC8vIGRpdmlkZSBieSB0d28gdGhlbiBtYWtlIGl0IG5lZ2F0aXZlXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBTb21lIGNvbnZlbmllbmNlIGZ1bmN0aW9uc1xyXG4gIC8vIDpCb29sZWFuXHJcbiAgcmVhZEJvb2xlYW4oKSB7XHJcbiAgICByZXR1cm4gMSA9PT0gdGhpcy5yZWFkQml0cygxKTtcclxuICB9XHJcblxyXG4gIC8vICgpOmludFxyXG4gIHJlYWRVQnl0ZSgpIHtcclxuICAgIHJldHVybiB0aGlzLnJlYWRCaXRzKDgpO1xyXG4gIH1cclxuXHJcbiAgLy8gKCk6aW50XHJcbiAgcmVhZFVTaG9ydCgpIHtcclxuICAgIHJldHVybiB0aGlzLnJlYWRCaXRzKDE2KTtcclxuICB9XHJcbiAgICAvLyAoKTppbnRcclxuICByZWFkVUludCgpIHtcclxuICAgIHJldHVybiB0aGlzLnJlYWRCaXRzKDMyKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFkdmFuY2UgdGhlIEV4cEdvbG9tYiBkZWNvZGVyIHBhc3QgYSBzY2FsaW5nIGxpc3QuIFRoZSBzY2FsaW5nXHJcbiAgICogbGlzdCBpcyBvcHRpb25hbGx5IHRyYW5zbWl0dGVkIGFzIHBhcnQgb2YgYSBzZXF1ZW5jZSBwYXJhbWV0ZXJcclxuICAgKiBzZXQgYW5kIGlzIG5vdCByZWxldmFudCB0byB0cmFuc211eGluZy5cclxuICAgKiBAcGFyYW0gY291bnQge251bWJlcn0gdGhlIG51bWJlciBvZiBlbnRyaWVzIGluIHRoaXMgc2NhbGluZyBsaXN0XHJcbiAgICogQHNlZSBSZWNvbW1lbmRhdGlvbiBJVFUtVCBILjI2NCwgU2VjdGlvbiA3LjMuMi4xLjEuMVxyXG4gICAqL1xyXG4gIHNraXBTY2FsaW5nTGlzdChjb3VudCkge1xyXG4gICAgdmFyXHJcbiAgICAgIGxhc3RTY2FsZSA9IDgsXHJcbiAgICAgIG5leHRTY2FsZSA9IDgsXHJcbiAgICAgIGosXHJcbiAgICAgIGRlbHRhU2NhbGU7XHJcbiAgICBmb3IgKGogPSAwOyBqIDwgY291bnQ7IGorKykge1xyXG4gICAgICBpZiAobmV4dFNjYWxlICE9PSAwKSB7XHJcbiAgICAgICAgZGVsdGFTY2FsZSA9IHRoaXMucmVhZEVHKCk7XHJcbiAgICAgICAgbmV4dFNjYWxlID0gKGxhc3RTY2FsZSArIGRlbHRhU2NhbGUgKyAyNTYpICUgMjU2O1xyXG4gICAgICB9XHJcbiAgICAgIGxhc3RTY2FsZSA9IChuZXh0U2NhbGUgPT09IDApID8gbGFzdFNjYWxlIDogbmV4dFNjYWxlO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVhZCBhIHNlcXVlbmNlIHBhcmFtZXRlciBzZXQgYW5kIHJldHVybiBzb21lIGludGVyZXN0aW5nIHZpZGVvXHJcbiAgICogcHJvcGVydGllcy4gQSBzZXF1ZW5jZSBwYXJhbWV0ZXIgc2V0IGlzIHRoZSBIMjY0IG1ldGFkYXRhIHRoYXRcclxuICAgKiBkZXNjcmliZXMgdGhlIHByb3BlcnRpZXMgb2YgdXBjb21pbmcgdmlkZW8gZnJhbWVzLlxyXG4gICAqIEBwYXJhbSBkYXRhIHtVaW50OEFycmF5fSB0aGUgYnl0ZXMgb2YgYSBzZXF1ZW5jZSBwYXJhbWV0ZXIgc2V0XHJcbiAgICogQHJldHVybiB7b2JqZWN0fSBhbiBvYmplY3Qgd2l0aCBjb25maWd1cmF0aW9uIHBhcnNlZCBmcm9tIHRoZVxyXG4gICAqIHNlcXVlbmNlIHBhcmFtZXRlciBzZXQsIGluY2x1ZGluZyB0aGUgZGltZW5zaW9ucyBvZiB0aGVcclxuICAgKiBhc3NvY2lhdGVkIHZpZGVvIGZyYW1lcy5cclxuICAgKi9cclxuICByZWFkU1BTKCkge1xyXG4gICAgdmFyXHJcbiAgICAgIGZyYW1lQ3JvcExlZnRPZmZzZXQgPSAwLFxyXG4gICAgICBmcmFtZUNyb3BSaWdodE9mZnNldCA9IDAsXHJcbiAgICAgIGZyYW1lQ3JvcFRvcE9mZnNldCA9IDAsXHJcbiAgICAgIGZyYW1lQ3JvcEJvdHRvbU9mZnNldCA9IDAsXHJcbiAgICAgIHByb2ZpbGVJZGMscHJvZmlsZUNvbXBhdCxsZXZlbElkYyxcclxuICAgICAgbnVtUmVmRnJhbWVzSW5QaWNPcmRlckNudEN5Y2xlLCBwaWNXaWR0aEluTWJzTWludXMxLFxyXG4gICAgICBwaWNIZWlnaHRJbk1hcFVuaXRzTWludXMxLFxyXG4gICAgICBmcmFtZU1ic09ubHlGbGFnLFxyXG4gICAgICBzY2FsaW5nTGlzdENvdW50LFxyXG4gICAgICBpLFxyXG4gICAgICByZWFkVUJ5dGUgPSB0aGlzLnJlYWRVQnl0ZS5iaW5kKHRoaXMpLFxyXG4gICAgICByZWFkQml0cyA9IHRoaXMucmVhZEJpdHMuYmluZCh0aGlzKSxcclxuICAgICAgcmVhZFVFRyA9IHRoaXMucmVhZFVFRy5iaW5kKHRoaXMpLFxyXG4gICAgICByZWFkQm9vbGVhbiA9IHRoaXMucmVhZEJvb2xlYW4uYmluZCh0aGlzKSxcclxuICAgICAgc2tpcEJpdHMgPSB0aGlzLnNraXBCaXRzLmJpbmQodGhpcyksXHJcbiAgICAgIHNraXBFRyA9IHRoaXMuc2tpcEVHLmJpbmQodGhpcyksXHJcbiAgICAgIHNraXBVRUcgPSB0aGlzLnNraXBVRUcuYmluZCh0aGlzKSxcclxuICAgICAgc2tpcFNjYWxpbmdMaXN0ID0gdGhpcy5za2lwU2NhbGluZ0xpc3QuYmluZCh0aGlzKTtcclxuXHJcbiAgICByZWFkVUJ5dGUoKTtcclxuICAgIHByb2ZpbGVJZGMgPSByZWFkVUJ5dGUoKTsgLy8gcHJvZmlsZV9pZGNcclxuICAgIHByb2ZpbGVDb21wYXQgPSByZWFkQml0cyg1KTsgLy8gY29uc3RyYWludF9zZXRbMC00XV9mbGFnLCB1KDUpXHJcbiAgICBza2lwQml0cygzKTsgLy8gcmVzZXJ2ZWRfemVyb18zYml0cyB1KDMpLFxyXG4gICAgbGV2ZWxJZGMgPSByZWFkVUJ5dGUoKTsgLy9sZXZlbF9pZGMgdSg4KVxyXG4gICAgc2tpcFVFRygpOyAvLyBzZXFfcGFyYW1ldGVyX3NldF9pZFxyXG4gICAgLy8gc29tZSBwcm9maWxlcyBoYXZlIG1vcmUgb3B0aW9uYWwgZGF0YSB3ZSBkb24ndCBuZWVkXHJcbiAgICBpZiAocHJvZmlsZUlkYyA9PT0gMTAwIHx8XHJcbiAgICAgICAgcHJvZmlsZUlkYyA9PT0gMTEwIHx8XHJcbiAgICAgICAgcHJvZmlsZUlkYyA9PT0gMTIyIHx8XHJcbiAgICAgICAgcHJvZmlsZUlkYyA9PT0gMjQ0IHx8XHJcbiAgICAgICAgcHJvZmlsZUlkYyA9PT0gNDQgIHx8XHJcbiAgICAgICAgcHJvZmlsZUlkYyA9PT0gODMgIHx8XHJcbiAgICAgICAgcHJvZmlsZUlkYyA9PT0gODYgIHx8XHJcbiAgICAgICAgcHJvZmlsZUlkYyA9PT0gMTE4IHx8XHJcbiAgICAgICAgcHJvZmlsZUlkYyA9PT0gMTI4KSB7XHJcbiAgICAgIHZhciBjaHJvbWFGb3JtYXRJZGMgPSByZWFkVUVHKCk7XHJcbiAgICAgIGlmIChjaHJvbWFGb3JtYXRJZGMgPT09IDMpIHtcclxuICAgICAgICBza2lwQml0cygxKTsgLy8gc2VwYXJhdGVfY29sb3VyX3BsYW5lX2ZsYWdcclxuICAgICAgfVxyXG4gICAgICBza2lwVUVHKCk7IC8vIGJpdF9kZXB0aF9sdW1hX21pbnVzOFxyXG4gICAgICBza2lwVUVHKCk7IC8vIGJpdF9kZXB0aF9jaHJvbWFfbWludXM4XHJcbiAgICAgIHNraXBCaXRzKDEpOyAvLyBxcHByaW1lX3lfemVyb190cmFuc2Zvcm1fYnlwYXNzX2ZsYWdcclxuICAgICAgaWYgKHJlYWRCb29sZWFuKCkpIHsgLy8gc2VxX3NjYWxpbmdfbWF0cml4X3ByZXNlbnRfZmxhZ1xyXG4gICAgICAgIHNjYWxpbmdMaXN0Q291bnQgPSAoY2hyb21hRm9ybWF0SWRjICE9PSAzKSA/IDggOiAxMjtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2NhbGluZ0xpc3RDb3VudDsgaSsrKSB7XHJcbiAgICAgICAgICBpZiAocmVhZEJvb2xlYW4oKSkgeyAvLyBzZXFfc2NhbGluZ19saXN0X3ByZXNlbnRfZmxhZ1sgaSBdXHJcbiAgICAgICAgICAgIGlmIChpIDwgNikge1xyXG4gICAgICAgICAgICAgIHNraXBTY2FsaW5nTGlzdCgxNik7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgc2tpcFNjYWxpbmdMaXN0KDY0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgc2tpcFVFRygpOyAvLyBsb2cyX21heF9mcmFtZV9udW1fbWludXM0XHJcbiAgICB2YXIgcGljT3JkZXJDbnRUeXBlID0gcmVhZFVFRygpO1xyXG4gICAgaWYgKHBpY09yZGVyQ250VHlwZSA9PT0gMCkge1xyXG4gICAgICByZWFkVUVHKCk7IC8vbG9nMl9tYXhfcGljX29yZGVyX2NudF9sc2JfbWludXM0XHJcbiAgICB9IGVsc2UgaWYgKHBpY09yZGVyQ250VHlwZSA9PT0gMSkge1xyXG4gICAgICBza2lwQml0cygxKTsgLy8gZGVsdGFfcGljX29yZGVyX2Fsd2F5c196ZXJvX2ZsYWdcclxuICAgICAgc2tpcEVHKCk7IC8vIG9mZnNldF9mb3Jfbm9uX3JlZl9waWNcclxuICAgICAgc2tpcEVHKCk7IC8vIG9mZnNldF9mb3JfdG9wX3RvX2JvdHRvbV9maWVsZFxyXG4gICAgICBudW1SZWZGcmFtZXNJblBpY09yZGVyQ250Q3ljbGUgPSByZWFkVUVHKCk7XHJcbiAgICAgIGZvcihpID0gMDsgaSA8IG51bVJlZkZyYW1lc0luUGljT3JkZXJDbnRDeWNsZTsgaSsrKSB7XHJcbiAgICAgICAgc2tpcEVHKCk7IC8vIG9mZnNldF9mb3JfcmVmX2ZyYW1lWyBpIF1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgc2tpcFVFRygpOyAvLyBtYXhfbnVtX3JlZl9mcmFtZXNcclxuICAgIHNraXBCaXRzKDEpOyAvLyBnYXBzX2luX2ZyYW1lX251bV92YWx1ZV9hbGxvd2VkX2ZsYWdcclxuICAgIHBpY1dpZHRoSW5NYnNNaW51czEgPSByZWFkVUVHKCk7XHJcbiAgICBwaWNIZWlnaHRJbk1hcFVuaXRzTWludXMxID0gcmVhZFVFRygpO1xyXG4gICAgZnJhbWVNYnNPbmx5RmxhZyA9IHJlYWRCaXRzKDEpO1xyXG4gICAgaWYgKGZyYW1lTWJzT25seUZsYWcgPT09IDApIHtcclxuICAgICAgc2tpcEJpdHMoMSk7IC8vIG1iX2FkYXB0aXZlX2ZyYW1lX2ZpZWxkX2ZsYWdcclxuICAgIH1cclxuICAgIHNraXBCaXRzKDEpOyAvLyBkaXJlY3RfOHg4X2luZmVyZW5jZV9mbGFnXHJcbiAgICBpZiAocmVhZEJvb2xlYW4oKSkgeyAvLyBmcmFtZV9jcm9wcGluZ19mbGFnXHJcbiAgICAgIGZyYW1lQ3JvcExlZnRPZmZzZXQgPSByZWFkVUVHKCk7XHJcbiAgICAgIGZyYW1lQ3JvcFJpZ2h0T2Zmc2V0ID0gcmVhZFVFRygpO1xyXG4gICAgICBmcmFtZUNyb3BUb3BPZmZzZXQgPSByZWFkVUVHKCk7XHJcbiAgICAgIGZyYW1lQ3JvcEJvdHRvbU9mZnNldCA9IHJlYWRVRUcoKTtcclxuICAgIH1cclxuICAgIGxldCBwaXhlbFJhdGlvID0gWzEsMV07XHJcbiAgICBpZiAocmVhZEJvb2xlYW4oKSkge1xyXG4gICAgICAvLyB2dWlfcGFyYW1ldGVyc19wcmVzZW50X2ZsYWdcclxuICAgICAgaWYgKHJlYWRCb29sZWFuKCkpIHtcclxuICAgICAgICAvLyBhc3BlY3RfcmF0aW9faW5mb19wcmVzZW50X2ZsYWdcclxuICAgICAgICBjb25zdCBhc3BlY3RSYXRpb0lkYyA9IHJlYWRVQnl0ZSgpO1xyXG4gICAgICAgIHN3aXRjaCAoYXNwZWN0UmF0aW9JZGMpIHtcclxuICAgICAgICAgIGNhc2UgMTogcGl4ZWxSYXRpbyA9IFsxLDFdOyBicmVhaztcclxuICAgICAgICAgIGNhc2UgMjogcGl4ZWxSYXRpbyA9IFsxMiwxMV07IGJyZWFrO1xyXG4gICAgICAgICAgY2FzZSAzOiBwaXhlbFJhdGlvID0gWzEwLDExXTsgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlIDQ6IHBpeGVsUmF0aW8gPSBbMTYsMTFdOyBicmVhaztcclxuICAgICAgICAgIGNhc2UgNTogcGl4ZWxSYXRpbyA9IFs0MCwzM107IGJyZWFrO1xyXG4gICAgICAgICAgY2FzZSA2OiBwaXhlbFJhdGlvID0gWzI0LDExXTsgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlIDc6IHBpeGVsUmF0aW8gPSBbMjAsMTFdOyBicmVhaztcclxuICAgICAgICAgIGNhc2UgODogcGl4ZWxSYXRpbyA9IFszMiwxMV07IGJyZWFrO1xyXG4gICAgICAgICAgY2FzZSA5OiBwaXhlbFJhdGlvID0gWzgwLDMzXTsgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlIDEwOiBwaXhlbFJhdGlvID0gWzE4LDExXTsgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlIDExOiBwaXhlbFJhdGlvID0gWzE1LDExXTsgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlIDEyOiBwaXhlbFJhdGlvID0gWzY0LDMzXTsgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlIDEzOiBwaXhlbFJhdGlvID0gWzE2MCw5OV07IGJyZWFrO1xyXG4gICAgICAgICAgY2FzZSAxNDogcGl4ZWxSYXRpbyA9IFs0LDNdOyBicmVhaztcclxuICAgICAgICAgIGNhc2UgMTU6IHBpeGVsUmF0aW8gPSBbMywyXTsgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlIDE2OiBwaXhlbFJhdGlvID0gWzIsMV07IGJyZWFrO1xyXG4gICAgICAgICAgY2FzZSAyNTU6IHtcclxuICAgICAgICAgICAgcGl4ZWxSYXRpbyA9IFtyZWFkVUJ5dGUoKSA8PCA4IHwgcmVhZFVCeXRlKCksIHJlYWRVQnl0ZSgpIDw8IDggfCByZWFkVUJ5dGUoKV07XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgd2lkdGg6IE1hdGguY2VpbCgoKChwaWNXaWR0aEluTWJzTWludXMxICsgMSkgKiAxNikgLSBmcmFtZUNyb3BMZWZ0T2Zmc2V0ICogMiAtIGZyYW1lQ3JvcFJpZ2h0T2Zmc2V0ICogMikpLFxyXG4gICAgICBoZWlnaHQ6ICgoMiAtIGZyYW1lTWJzT25seUZsYWcpICogKHBpY0hlaWdodEluTWFwVW5pdHNNaW51czEgKyAxKSAqIDE2KSAtICgoZnJhbWVNYnNPbmx5RmxhZz8gMiA6IDQpICogKGZyYW1lQ3JvcFRvcE9mZnNldCArIGZyYW1lQ3JvcEJvdHRvbU9mZnNldCkpLFxyXG4gICAgICBwaXhlbFJhdGlvIDogcGl4ZWxSYXRpb1xyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIHJlYWRTbGljZVR5cGUoKSB7XHJcbiAgICAvLyBza2lwIE5BTHUgdHlwZVxyXG4gICAgdGhpcy5yZWFkVUJ5dGUoKTtcclxuICAgIC8vIGRpc2NhcmQgZmlyc3RfbWJfaW5fc2xpY2VcclxuICAgIHRoaXMucmVhZFVFRygpO1xyXG4gICAgLy8gcmV0dXJuIHNsaWNlX3R5cGVcclxuICAgIHJldHVybiB0aGlzLnJlYWRVRUcoKTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IEV4cEdvbG9tYjtcclxuIiwiLyoqXHJcbiAqIElEMyBwYXJzZXJcclxuICovXHJcbiBjbGFzcyBJRDMge1xyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBhbiBJRDMgaGVhZGVyIGNhbiBiZSBmb3VuZCBhdCBvZmZzZXQgaW4gZGF0YVxyXG4gICAqIEBwYXJhbSB7VWludDhBcnJheX0gZGF0YSAtIFRoZSBkYXRhIHRvIHNlYXJjaCBpblxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgLSBUaGUgb2Zmc2V0IGF0IHdoaWNoIHRvIHN0YXJ0IHNlYXJjaGluZ1xyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IC0gVHJ1ZSBpZiBhbiBJRDMgaGVhZGVyIGlzIGZvdW5kXHJcbiAgICovXHJcbiAgc3RhdGljIGlzSGVhZGVyKGRhdGEsIG9mZnNldCkge1xyXG4gICAgLypcclxuICAgICogaHR0cDovL2lkMy5vcmcvaWQzdjIuMy4wXHJcbiAgICAqIFswXSAgICAgPSAnSSdcclxuICAgICogWzFdICAgICA9ICdEJ1xyXG4gICAgKiBbMl0gICAgID0gJzMnXHJcbiAgICAqIFszLDRdICAgPSB7VmVyc2lvbn1cclxuICAgICogWzVdICAgICA9IHtGbGFnc31cclxuICAgICogWzYtOV0gICA9IHtJRDMgU2l6ZX1cclxuICAgICpcclxuICAgICogQW4gSUQzdjIgdGFnIGNhbiBiZSBkZXRlY3RlZCB3aXRoIHRoZSBmb2xsb3dpbmcgcGF0dGVybjpcclxuICAgICogICQ0OSA0NCAzMyB5eSB5eSB4eCB6eiB6eiB6eiB6elxyXG4gICAgKiBXaGVyZSB5eSBpcyBsZXNzIHRoYW4gJEZGLCB4eCBpcyB0aGUgJ2ZsYWdzJyBieXRlIGFuZCB6eiBpcyBsZXNzIHRoYW4gJDgwXHJcbiAgICAqL1xyXG4gICAgaWYgKG9mZnNldCArIDEwIDw9IGRhdGEubGVuZ3RoKSB7XHJcbiAgICAgIC8vbG9vayBmb3IgJ0lEMycgaWRlbnRpZmllclxyXG4gICAgICBpZiAoZGF0YVtvZmZzZXRdID09PSAweDQ5ICYmIGRhdGFbb2Zmc2V0KzFdID09PSAweDQ0ICYmIGRhdGFbb2Zmc2V0KzJdID09PSAweDMzKSB7XHJcbiAgICAgICAgLy9jaGVjayB2ZXJzaW9uIGlzIHdpdGhpbiByYW5nZVxyXG4gICAgICAgIGlmIChkYXRhW29mZnNldCszXSA8IDB4RkYgJiYgZGF0YVtvZmZzZXQrNF0gPCAweEZGKSB7XHJcbiAgICAgICAgICAvL2NoZWNrIHNpemUgaXMgd2l0aGluIHJhbmdlXHJcbiAgICAgICAgICBpZiAoZGF0YVtvZmZzZXQrNl0gPCAweDgwICYmIGRhdGFbb2Zmc2V0KzddIDwgMHg4MCAmJiBkYXRhW29mZnNldCs4XSA8IDB4ODAgJiYgZGF0YVtvZmZzZXQrOV0gPCAweDgwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBhbiBJRDMgZm9vdGVyIGNhbiBiZSBmb3VuZCBhdCBvZmZzZXQgaW4gZGF0YVxyXG4gICAqIEBwYXJhbSB7VWludDhBcnJheX0gZGF0YSAtIFRoZSBkYXRhIHRvIHNlYXJjaCBpblxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgLSBUaGUgb2Zmc2V0IGF0IHdoaWNoIHRvIHN0YXJ0IHNlYXJjaGluZ1xyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IC0gVHJ1ZSBpZiBhbiBJRDMgZm9vdGVyIGlzIGZvdW5kXHJcbiAgICovXHJcbiAgc3RhdGljIGlzRm9vdGVyKGRhdGEsIG9mZnNldCkge1xyXG4gICAgLypcclxuICAgICogVGhlIGZvb3RlciBpcyBhIGNvcHkgb2YgdGhlIGhlYWRlciwgYnV0IHdpdGggYSBkaWZmZXJlbnQgaWRlbnRpZmllclxyXG4gICAgKi9cclxuICAgIGlmIChvZmZzZXQgKyAxMCA8PSBkYXRhLmxlbmd0aCkge1xyXG4gICAgICAvL2xvb2sgZm9yICczREknIGlkZW50aWZpZXJcclxuICAgICAgaWYgKGRhdGFbb2Zmc2V0XSA9PT0gMHgzMyAmJiBkYXRhW29mZnNldCsxXSA9PT0gMHg0NCAmJiBkYXRhW29mZnNldCsyXSA9PT0gMHg0OSkge1xyXG4gICAgICAgIC8vY2hlY2sgdmVyc2lvbiBpcyB3aXRoaW4gcmFuZ2VcclxuICAgICAgICBpZiAoZGF0YVtvZmZzZXQrM10gPCAweEZGICYmIGRhdGFbb2Zmc2V0KzRdIDwgMHhGRikge1xyXG4gICAgICAgICAgLy9jaGVjayBzaXplIGlzIHdpdGhpbiByYW5nZVxyXG4gICAgICAgICAgaWYgKGRhdGFbb2Zmc2V0KzZdIDwgMHg4MCAmJiBkYXRhW29mZnNldCs3XSA8IDB4ODAgJiYgZGF0YVtvZmZzZXQrOF0gPCAweDgwICYmIGRhdGFbb2Zmc2V0KzldIDwgMHg4MCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIGFueSBhZGphY2VudCBJRDMgdGFncyBmb3VuZCBpbiBkYXRhIHN0YXJ0aW5nIGF0IG9mZnNldCwgYXMgb25lIGJsb2NrIG9mIGRhdGFcclxuICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGRhdGEgLSBUaGUgZGF0YSB0byBzZWFyY2ggaW5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IC0gVGhlIG9mZnNldCBhdCB3aGljaCB0byBzdGFydCBzZWFyY2hpbmdcclxuICAgKiBAcmV0dXJuIHtVaW50OEFycmF5fSAtIFRoZSBibG9jayBvZiBkYXRhIGNvbnRhaW5pbmcgYW55IElEMyB0YWdzIGZvdW5kXHJcbiAgICovXHJcbiAgc3RhdGljIGdldElEM0RhdGEoZGF0YSwgb2Zmc2V0KSB7XHJcbiAgICBjb25zdCBmcm9udCA9IG9mZnNldDtcclxuICAgIGxldCBsZW5ndGggPSAwO1xyXG5cclxuICAgIHdoaWxlIChJRDMuaXNIZWFkZXIoZGF0YSwgb2Zmc2V0KSkge1xyXG4gICAgICAvL0lEMyBoZWFkZXIgaXMgMTAgYnl0ZXNcclxuICAgICAgbGVuZ3RoICs9IDEwO1xyXG5cclxuICAgICAgY29uc3Qgc2l6ZSA9IElEMy5fcmVhZFNpemUoZGF0YSwgb2Zmc2V0ICsgNik7XHJcbiAgICAgIGxlbmd0aCArPSBzaXplO1xyXG5cclxuICAgICAgaWYgKElEMy5pc0Zvb3RlcihkYXRhLCBvZmZzZXQgKyAxMCkpIHtcclxuICAgICAgICAvL0lEMyBmb290ZXIgaXMgMTAgYnl0ZXNcclxuICAgICAgICBsZW5ndGggKz0gMTA7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIG9mZnNldCArPSBsZW5ndGg7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGxlbmd0aCA+IDApIHtcclxuICAgICAgcmV0dXJuIGRhdGEuc3ViYXJyYXkoZnJvbnQsIGZyb250ICsgbGVuZ3RoKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIF9yZWFkU2l6ZShkYXRhLCBvZmZzZXQpIHtcclxuICAgIGxldCBzaXplID0gMDtcclxuICAgIHNpemUgID0gKChkYXRhW29mZnNldF0gICAmIDB4N2YpIDw8IDIxKTtcclxuICAgIHNpemUgfD0gKChkYXRhW29mZnNldCsxXSAmIDB4N2YpIDw8IDE0KTtcclxuICAgIHNpemUgfD0gKChkYXRhW29mZnNldCsyXSAmIDB4N2YpIDw8IDcpO1xyXG4gICAgc2l6ZSB8PSAgKGRhdGFbb2Zmc2V0KzNdICYgMHg3Zik7XHJcbiAgICByZXR1cm4gc2l6ZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNlYXJjaGVzIGZvciB0aGUgRWxlbWVudGFyeSBTdHJlYW0gdGltZXN0YW1wIGZvdW5kIGluIHRoZSBJRDMgZGF0YSBjaHVua1xyXG4gICAqIEBwYXJhbSB7VWludDhBcnJheX0gZGF0YSAtIEJsb2NrIG9mIGRhdGEgY29udGFpbmluZyBvbmUgb3IgbW9yZSBJRDMgdGFnc1xyXG4gICAqIEByZXR1cm4ge251bWJlcn0gLSBUaGUgdGltZXN0YW1wXHJcbiAgICovXHJcbiAgc3RhdGljIGdldFRpbWVTdGFtcChkYXRhKSB7XHJcbiAgICBjb25zdCBmcmFtZXMgPSBJRDMuZ2V0SUQzRnJhbWVzKGRhdGEpO1xyXG4gICAgZm9yKGxldCBpID0gMDsgaSA8IGZyYW1lcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICBjb25zdCBmcmFtZSA9IGZyYW1lc1tpXTtcclxuICAgICAgaWYgKElEMy5pc1RpbWVTdGFtcEZyYW1lKGZyYW1lKSkge1xyXG4gICAgICAgIHJldHVybiBJRDMuX3JlYWRUaW1lU3RhbXAoZnJhbWUpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgSUQzIGZyYW1lIGlzIGFuIEVsZW1lbnRhcnkgU3RyZWFtIHRpbWVzdGFtcCBmcmFtZVxyXG4gICAqIEBwYXJhbSB7SUQzIGZyYW1lfSBmcmFtZVxyXG4gICAqL1xyXG4gIHN0YXRpYyBpc1RpbWVTdGFtcEZyYW1lKGZyYW1lKSB7XHJcbiAgICByZXR1cm4gKGZyYW1lICYmIGZyYW1lLmtleSA9PT0gJ1BSSVYnICYmIGZyYW1lLmluZm8gPT09ICdjb20uYXBwbGUuc3RyZWFtaW5nLnRyYW5zcG9ydFN0cmVhbVRpbWVzdGFtcCcpO1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIF9nZXRGcmFtZURhdGEoZGF0YSkge1xyXG4gICAgLypcclxuICAgIEZyYW1lIElEICAgICAgICR4eCB4eCB4eCB4eCAoZm91ciBjaGFyYWN0ZXJzKVxyXG4gICAgU2l6ZSAgICAgICAgICAgJHh4IHh4IHh4IHh4XHJcbiAgICBGbGFncyAgICAgICAgICAkeHggeHhcclxuICAgICovXHJcbiAgICBjb25zdCB0eXBlID0gU3RyaW5nLmZyb21DaGFyQ29kZShkYXRhWzBdLCBkYXRhWzFdLCBkYXRhWzJdLCBkYXRhWzNdKTtcclxuICAgIGNvbnN0IHNpemUgPSBJRDMuX3JlYWRTaXplKGRhdGEsIDQpO1xyXG5cclxuICAgIC8vc2tpcCBmcmFtZSBpZCwgc2l6ZSwgYW5kIGZsYWdzXHJcbiAgICBsZXQgb2Zmc2V0ID0gMTA7XHJcblxyXG4gICAgcmV0dXJuIHsgdHlwZSwgc2l6ZSwgZGF0YTogZGF0YS5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIHNpemUpIH07XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIElEMyBmcmFtZXMgZm91bmQgaW4gYWxsIHRoZSBJRDMgdGFncyBpbiB0aGUgaWQzRGF0YVxyXG4gICAqIEBwYXJhbSB7VWludDhBcnJheX0gaWQzRGF0YSAtIFRoZSBJRDMgZGF0YSBjb250YWluaW5nIG9uZSBvciBtb3JlIElEMyB0YWdzXHJcbiAgICogQHJldHVybiB7SUQzIGZyYW1lW119IC0gQXJyYXkgb2YgSUQzIGZyYW1lIG9iamVjdHNcclxuICAgKi9cclxuICBzdGF0aWMgZ2V0SUQzRnJhbWVzKGlkM0RhdGEpIHtcclxuICAgIGxldCBvZmZzZXQgPSAwO1xyXG4gICAgY29uc3QgZnJhbWVzID0gW107XHJcblxyXG4gICAgd2hpbGUgKElEMy5pc0hlYWRlcihpZDNEYXRhLCBvZmZzZXQpKSB7XHJcbiAgICAgIGNvbnN0IHNpemUgPSBJRDMuX3JlYWRTaXplKGlkM0RhdGEsIG9mZnNldCArIDYpO1xyXG4gICAgICAvL3NraXAgcGFzdCBJRDMgaGVhZGVyXHJcbiAgICAgIG9mZnNldCArPSAxMDtcclxuICAgICAgY29uc3QgZW5kID0gb2Zmc2V0ICsgc2l6ZTtcclxuICAgICAgLy9sb29wIHRocm91Z2ggZnJhbWVzIGluIHRoZSBJRDMgdGFnXHJcbiAgICAgIHdoaWxlIChvZmZzZXQgKyA4IDwgZW5kKSB7XHJcbiAgICAgICAgY29uc3QgZnJhbWVEYXRhID0gSUQzLl9nZXRGcmFtZURhdGEoaWQzRGF0YS5zdWJhcnJheShvZmZzZXQpKTtcclxuICAgICAgICBjb25zdCBmcmFtZSA9IElEMy5fZGVjb2RlRnJhbWUoZnJhbWVEYXRhKTtcclxuICAgICAgICBpZiAoZnJhbWUpIHtcclxuICAgICAgICAgIGZyYW1lcy5wdXNoKGZyYW1lKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy9za2lwIGZyYW1lIGhlYWRlciBhbmQgZnJhbWUgZGF0YVxyXG4gICAgICAgIG9mZnNldCArPSBmcmFtZURhdGEuc2l6ZSArIDEwO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoSUQzLmlzRm9vdGVyKGlkM0RhdGEsIG9mZnNldCkpIHtcclxuICAgICAgICBvZmZzZXQgKz0gMTA7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZnJhbWVzO1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIF9kZWNvZGVGcmFtZShmcmFtZSkge1xyXG4gICAgaWYgKGZyYW1lLnR5cGUgPT09ICdQUklWJykge1xyXG4gICAgICByZXR1cm4gSUQzLl9kZWNvZGVQcml2RnJhbWUoZnJhbWUpO1xyXG4gICAgfSBlbHNlIGlmIChmcmFtZS50eXBlWzBdID09PSAnVCcpIHtcclxuICAgICAgcmV0dXJuIElEMy5fZGVjb2RlVGV4dEZyYW1lKGZyYW1lKTtcclxuICAgIH0gZWxzZSBpZiAoZnJhbWUudHlwZVswXSA9PT0gJ1cnKSB7XHJcbiAgICAgIHJldHVybiBJRDMuX2RlY29kZVVSTEZyYW1lKGZyYW1lKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIF9yZWFkVGltZVN0YW1wKHRpbWVTdGFtcEZyYW1lKSB7XHJcbiAgICBpZiAodGltZVN0YW1wRnJhbWUuZGF0YS5ieXRlTGVuZ3RoID09PSA4KSB7XHJcbiAgICAgIGNvbnN0IGRhdGEgPSBuZXcgVWludDhBcnJheSh0aW1lU3RhbXBGcmFtZS5kYXRhKTtcclxuICAgICAgLy8gdGltZXN0YW1wIGlzIDMzIGJpdCBleHByZXNzZWQgYXMgYSBiaWctZW5kaWFuIGVpZ2h0LW9jdGV0IG51bWJlcixcclxuICAgICAgLy8gd2l0aCB0aGUgdXBwZXIgMzEgYml0cyBzZXQgdG8gemVyby5cclxuICAgICAgY29uc3QgcHRzMzNCaXQgPSBkYXRhWzNdICYgMHgxO1xyXG4gICAgICBsZXQgdGltZXN0YW1wID0gKGRhdGFbNF0gPDwgMjMpICtcclxuICAgICAgICAgICAgICAgICAgICAgIChkYXRhWzVdIDw8IDE1KSArXHJcbiAgICAgICAgICAgICAgICAgICAgICAoZGF0YVs2XSA8PCAgNykgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgIGRhdGFbN107XHJcbiAgICAgIHRpbWVzdGFtcCAvPSA0NTtcclxuXHJcbiAgICAgIGlmIChwdHMzM0JpdCkge1xyXG4gICAgICAgIHRpbWVzdGFtcCArPSA0NzcyMTg1OC44NDsgLy8gMl4zMiAvIDkwXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBNYXRoLnJvdW5kKHRpbWVzdGFtcCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICB9XHJcblxyXG4gIHN0YXRpYyBfZGVjb2RlUHJpdkZyYW1lKGZyYW1lKSB7XHJcbiAgICAvKlxyXG4gICAgRm9ybWF0OiA8dGV4dCBzdHJpbmc+XFwwPGJpbmFyeSBkYXRhPlxyXG4gICAgKi9cclxuICAgIGlmIChmcmFtZS5zaXplIDwgMikge1xyXG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IG93bmVyID0gSUQzLl91dGY4QXJyYXlUb1N0cihmcmFtZS5kYXRhKTtcclxuICAgIGNvbnN0IHByaXZhdGVEYXRhID0gbmV3IFVpbnQ4QXJyYXkoZnJhbWUuZGF0YS5zdWJhcnJheShvd25lci5sZW5ndGggKyAxKSk7XHJcblxyXG4gICAgcmV0dXJuIHsga2V5OiBmcmFtZS50eXBlLCBpbmZvOiBvd25lciwgZGF0YTogcHJpdmF0ZURhdGEuYnVmZmVyIH07XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgX2RlY29kZVRleHRGcmFtZShmcmFtZSkge1xyXG4gICAgaWYgKGZyYW1lLnNpemUgPCAyKSB7XHJcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGZyYW1lLnR5cGUgPT09ICdUWFhYJykge1xyXG4gICAgICAvKlxyXG4gICAgICBGb3JtYXQ6XHJcbiAgICAgIFswXSAgID0ge1RleHQgRW5jb2Rpbmd9XHJcbiAgICAgIFsxLT9dID0ge0Rlc2NyaXB0aW9ufVxcMHtWYWx1ZX1cclxuICAgICAgKi9cclxuICAgICAgbGV0IGluZGV4ID0gMTtcclxuICAgICAgY29uc3QgZGVzY3JpcHRpb24gPSBJRDMuX3V0ZjhBcnJheVRvU3RyKGZyYW1lLmRhdGEuc3ViYXJyYXkoaW5kZXgpKTtcclxuXHJcbiAgICAgIGluZGV4ICs9IGRlc2NyaXB0aW9uLmxlbmd0aCArIDE7XHJcbiAgICAgIGNvbnN0IHZhbHVlID0gSUQzLl91dGY4QXJyYXlUb1N0cihmcmFtZS5kYXRhLnN1YmFycmF5KGluZGV4KSk7XHJcblxyXG4gICAgICByZXR1cm4geyBrZXk6IGZyYW1lLnR5cGUsIGluZm86IGRlc2NyaXB0aW9uLCBkYXRhOiB2YWx1ZSB9O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLypcclxuICAgICAgRm9ybWF0OlxyXG4gICAgICBbMF0gICA9IHtUZXh0IEVuY29kaW5nfVxyXG4gICAgICBbMS0/XSA9IHtWYWx1ZX1cclxuICAgICAgKi9cclxuICAgICAgY29uc3QgdGV4dCA9IElEMy5fdXRmOEFycmF5VG9TdHIoZnJhbWUuZGF0YS5zdWJhcnJheSgxKSk7XHJcbiAgICAgIHJldHVybiB7IGtleTogZnJhbWUudHlwZSwgZGF0YTogdGV4dCB9O1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgc3RhdGljIF9kZWNvZGVVUkxGcmFtZShmcmFtZSkge1xyXG4gICAgaWYgKGZyYW1lLnR5cGUgPT09ICdXWFhYJykge1xyXG4gICAgICAvKlxyXG4gICAgICBGb3JtYXQ6XHJcbiAgICAgIFswXSAgID0ge1RleHQgRW5jb2Rpbmd9XHJcbiAgICAgIFsxLT9dID0ge0Rlc2NyaXB0aW9ufVxcMHtVUkx9XHJcbiAgICAgICovXHJcbiAgICAgIGlmIChmcmFtZS5zaXplIDwgMikge1xyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGxldCBpbmRleCA9IDE7XHJcbiAgICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gSUQzLl91dGY4QXJyYXlUb1N0cihmcmFtZS5kYXRhLnN1YmFycmF5KGluZGV4KSk7XHJcblxyXG4gICAgICBpbmRleCArPSBkZXNjcmlwdGlvbi5sZW5ndGggKyAxO1xyXG4gICAgICBjb25zdCB2YWx1ZSA9IElEMy5fdXRmOEFycmF5VG9TdHIoZnJhbWUuZGF0YS5zdWJhcnJheShpbmRleCkpO1xyXG5cclxuICAgICAgcmV0dXJuIHsga2V5OiBmcmFtZS50eXBlLCBpbmZvOiBkZXNjcmlwdGlvbiwgZGF0YTogdmFsdWUgfTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8qXHJcbiAgICAgIEZvcm1hdDpcclxuICAgICAgWzAtP10gPSB7VVJMfVxyXG4gICAgICAqL1xyXG4gICAgICBjb25zdCB1cmwgPSBJRDMuX3V0ZjhBcnJheVRvU3RyKGZyYW1lLmRhdGEpO1xyXG4gICAgICByZXR1cm4geyBrZXk6IGZyYW1lLnR5cGUsIGRhdGE6IHVybCB9O1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy84OTM2OTg0L3VpbnQ4YXJyYXktdG8tc3RyaW5nLWluLWphdmFzY3JpcHQvMjIzNzMxOTdcclxuICAvLyBodHRwOi8vd3d3Lm9uaWNvcy5jb20vc3RhZmYvaXovYW11c2UvamF2YXNjcmlwdC9leHBlcnQvdXRmLnR4dFxyXG4gIC8qIHV0Zi5qcyAtIFVURi04IDw9PiBVVEYtMTYgY29udmVydGlvblxyXG4gICAqXHJcbiAgICogQ29weXJpZ2h0IChDKSAxOTk5IE1hc2FuYW8gSXp1bW8gPGl6QG9uaWNvcy5jby5qcD5cclxuICAgKiBWZXJzaW9uOiAxLjBcclxuICAgKiBMYXN0TW9kaWZpZWQ6IERlYyAyNSAxOTk5XHJcbiAgICogVGhpcyBsaWJyYXJ5IGlzIGZyZWUuICBZb3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0LlxyXG4gICAqL1xyXG4gIHN0YXRpYyBfdXRmOEFycmF5VG9TdHIoYXJyYXkpIHtcclxuXHJcbiAgICBsZXQgY2hhcjI7XHJcbiAgICBsZXQgY2hhcjM7XHJcbiAgICBsZXQgb3V0ID0gJyc7XHJcbiAgICBsZXQgaSA9IDA7XHJcbiAgICBsZXQgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xyXG5cclxuICAgIHdoaWxlIChpIDwgbGVuZ3RoKSB7XHJcbiAgICAgIGxldCBjID0gYXJyYXlbaSsrXTtcclxuICAgICAgc3dpdGNoIChjID4+IDQpIHtcclxuICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICByZXR1cm4gb3V0O1xyXG4gICAgICAgIGNhc2UgMTogY2FzZSAyOiBjYXNlIDM6IGNhc2UgNDogY2FzZSA1OiBjYXNlIDY6IGNhc2UgNzpcclxuICAgICAgICAgIC8vIDB4eHh4eHh4XHJcbiAgICAgICAgICBvdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgMTI6IGNhc2UgMTM6XHJcbiAgICAgICAgICAvLyAxMTB4IHh4eHggICAxMHh4IHh4eHhcclxuICAgICAgICAgIGNoYXIyID0gYXJyYXlbaSsrXTtcclxuICAgICAgICAgIG91dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCgoYyAmIDB4MUYpIDw8IDYpIHwgKGNoYXIyICYgMHgzRikpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAxNDpcclxuICAgICAgICAgIC8vIDExMTAgeHh4eCAgMTB4eCB4eHh4ICAxMHh4IHh4eHhcclxuICAgICAgICAgIGNoYXIyID0gYXJyYXlbaSsrXTtcclxuICAgICAgICAgIGNoYXIzID0gYXJyYXlbaSsrXTtcclxuICAgICAgICAgIG91dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCgoYyAmIDB4MEYpIDw8IDEyKSB8XHJcbiAgICAgICAgICAgICgoY2hhcjIgJiAweDNGKSA8PCA2KSB8XHJcbiAgICAgICAgICAgICgoY2hhcjMgJiAweDNGKSA8PCAwKSk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBvdXQ7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBJRDM7XHJcbiIsIi8qKlxyXG4gKiBNUDMgZGVtdXhlclxyXG4gKi9cclxuaW1wb3J0IElEMyBmcm9tICcuLi9kZW11eC9pZDMnO1xyXG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xyXG5pbXBvcnQgTXBlZ0F1ZGlvIGZyb20gJy4vbXBlZ2F1ZGlvJztcclxuXHJcbmNsYXNzIE1QM0RlbXV4ZXIge1xyXG5cclxuICBjb25zdHJ1Y3RvcihvYnNlcnZlciwgcmVtdXhlciwgY29uZmlnKSB7XHJcbiAgICB0aGlzLm9ic2VydmVyID0gb2JzZXJ2ZXI7XHJcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcclxuICAgIHRoaXMucmVtdXhlciA9IHJlbXV4ZXI7XHJcbiAgfVxyXG5cclxuICByZXNldEluaXRTZWdtZW50KGluaXRTZWdtZW50LCBhdWRpb0NvZGVjLCB2aWRlb0NvZGVjLCBkdXJhdGlvbikge1xyXG4gICAgdGhpcy5fYXVkaW9UcmFjayA9IHsgY29udGFpbmVyOiAnYXVkaW8vbXBlZycsIHR5cGU6ICdhdWRpbycsIGlkOiAtMSwgc2VxdWVuY2VOdW1iZXI6IDAsIGlzQUFDOiBmYWxzZSwgc2FtcGxlczogW10sIGxlbjogMCwgbWFuaWZlc3RDb2RlYzogYXVkaW9Db2RlYywgZHVyYXRpb246IGR1cmF0aW9uLCBpbnB1dFRpbWVTY2FsZTogOTAwMDAgfTtcclxuICB9XHJcblxyXG4gIHJlc2V0VGltZVN0YW1wKCkge1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIHByb2JlKGRhdGEpIHtcclxuICAgIC8vIGNoZWNrIGlmIGRhdGEgY29udGFpbnMgSUQzIHRpbWVzdGFtcCBhbmQgTVBFRyBzeW5jIHdvcmRcclxuICAgIHZhciBvZmZzZXQsIGxlbmd0aDtcclxuICAgIGxldCBpZDNEYXRhID0gSUQzLmdldElEM0RhdGEoZGF0YSwgMCk7XHJcbiAgICBpZiAoaWQzRGF0YSAmJiBJRDMuZ2V0VGltZVN0YW1wKGlkM0RhdGEpICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgLy8gTG9vayBmb3IgTVBFRyBoZWFkZXIgfCAxMTExIDExMTEgfCAxMTFYIFhZWlggfCB3aGVyZSBYIGNhbiBiZSBlaXRoZXIgMCBvciAxIGFuZCBZIG9yIFogc2hvdWxkIGJlIDFcclxuICAgICAgLy8gTGF5ZXIgYml0cyAocG9zaXRpb24gMTQgYW5kIDE1KSBpbiBoZWFkZXIgc2hvdWxkIGJlIGFsd2F5cyBkaWZmZXJlbnQgZnJvbSAwIChMYXllciBJIG9yIExheWVyIElJIG9yIExheWVyIElJSSlcclxuICAgICAgLy8gTW9yZSBpbmZvIGh0dHA6Ly93d3cubXAzLXRlY2gub3JnL3Byb2dyYW1tZXIvZnJhbWVfaGVhZGVyLmh0bWxcclxuICAgICAgZm9yIChvZmZzZXQgPSBpZDNEYXRhLmxlbmd0aCwgbGVuZ3RoID0gTWF0aC5taW4oZGF0YS5sZW5ndGggLSAxLCBvZmZzZXQgKyAxMDApOyBvZmZzZXQgPCBsZW5ndGg7IG9mZnNldCsrKSB7XHJcbiAgICAgICAgaWYgKE1wZWdBdWRpby5wcm9iZShkYXRhLCBvZmZzZXQpKSB7XHJcbiAgICAgICAgICBsb2dnZXIubG9nKCdNUEVHIEF1ZGlvIHN5bmMgd29yZCBmb3VuZCAhJyk7XHJcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcblxyXG4gIC8vIGZlZWQgaW5jb21pbmcgZGF0YSB0byB0aGUgZnJvbnQgb2YgdGhlIHBhcnNpbmcgcGlwZWxpbmVcclxuICBhcHBlbmQoZGF0YSwgdGltZU9mZnNldCwgY29udGlndW91cywgYWNjdXJhdGVUaW1lT2Zmc2V0KSB7XHJcbiAgICBsZXQgaWQzRGF0YSA9IElEMy5nZXRJRDNEYXRhKGRhdGEsIDApO1xyXG4gICAgbGV0IHB0cyA9IDkwICogSUQzLmdldFRpbWVTdGFtcChpZDNEYXRhKTtcclxuICAgIHZhciBvZmZzZXQgPSBpZDNEYXRhLmxlbmd0aDtcclxuICAgIHZhciBsZW5ndGggPSBkYXRhLmxlbmd0aDtcclxuICAgIHZhciBmcmFtZUluZGV4ID0gMCwgc3RhbXAgPSAwO1xyXG4gICAgdmFyIHRyYWNrID0gdGhpcy5fYXVkaW9UcmFjaztcclxuXHJcbiAgICBsZXQgaWQzU2FtcGxlcyA9IFt7IHB0czogcHRzLCBkdHM6IHB0cywgZGF0YTogaWQzRGF0YSB9XTtcclxuXHJcbiAgICB3aGlsZSAob2Zmc2V0IDwgbGVuZ3RoKSB7XHJcbiAgICAgIGlmIChNcGVnQXVkaW8uaXNIZWFkZXIoZGF0YSwgb2Zmc2V0KSkge1xyXG4gICAgICAgIHZhciBmcmFtZSA9IE1wZWdBdWRpby5hcHBlbmRGcmFtZSh0cmFjaywgZGF0YSwgb2Zmc2V0LCBwdHMsIGZyYW1lSW5kZXgpO1xyXG4gICAgICAgIGlmIChmcmFtZSkge1xyXG4gICAgICAgICAgb2Zmc2V0ICs9IGZyYW1lLmxlbmd0aDtcclxuICAgICAgICAgIHN0YW1wID0gZnJhbWUuc2FtcGxlLnB0cztcclxuICAgICAgICAgIGZyYW1lSW5kZXgrKztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgLy9sb2dnZXIubG9nKCdVbmFibGUgdG8gcGFyc2UgTXBlZyBhdWRpbyBmcmFtZScpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2UgaWYgKElEMy5pc0hlYWRlcihkYXRhLCBvZmZzZXQpKSB7XHJcbiAgICAgICAgaWQzRGF0YSA9IElEMy5nZXRJRDNEYXRhKGRhdGEsIG9mZnNldCk7XHJcbiAgICAgICAgaWQzU2FtcGxlcy5wdXNoKHsgcHRzOiBzdGFtcCwgZHRzOiBzdGFtcCwgZGF0YTogaWQzRGF0YSB9KTtcclxuICAgICAgICBvZmZzZXQgKz0gaWQzRGF0YS5sZW5ndGg7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy9ub3RoaW5nIGZvdW5kLCBrZWVwIGxvb2tpbmdcclxuICAgICAgICBvZmZzZXQrKztcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHRoaXMucmVtdXhlci5yZW11eCh0cmFjayxcclxuICAgICAgeyBzYW1wbGVzOiBbXSB9LFxyXG4gICAgICB7IHNhbXBsZXM6IGlkM1NhbXBsZXMsIGlucHV0VGltZVNjYWxlOiA5MDAwMCB9LFxyXG4gICAgICB7IHNhbXBsZXM6IFtdIH0sXHJcbiAgICAgIHRpbWVPZmZzZXQsXHJcbiAgICAgIGNvbnRpZ3VvdXMsXHJcbiAgICAgIGFjY3VyYXRlVGltZU9mZnNldCk7XHJcbiAgfVxyXG5cclxuICBkZXN0cm95KCkge1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgTVAzRGVtdXhlcjtcclxuIiwiLyoqXHJcbiAqIE1QNCBkZW11eGVyXHJcbiAqL1xyXG4vL2ltcG9ydCB7bG9nZ2VyfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xyXG5pbXBvcnQgRXZlbnQgZnJvbSAnLi4vZXZlbnRzJztcclxuXHJcbmNvbnN0IFVJTlQzMl9NQVggPSBNYXRoLnBvdygyLCAzMikgLSAxO1xyXG5cclxuIGNsYXNzIE1QNERlbXV4ZXIge1xyXG5cclxuICBjb25zdHJ1Y3RvcihvYnNlcnZlciwgcmVtdXhlcikge1xyXG4gICAgdGhpcy5vYnNlcnZlciA9IG9ic2VydmVyO1xyXG4gICAgdGhpcy5yZW11eGVyID0gcmVtdXhlcjtcclxuICB9XHJcblxyXG4gIHJlc2V0VGltZVN0YW1wKGluaXRQVFMpIHtcclxuICAgIHRoaXMuaW5pdFBUUyA9IGluaXRQVFM7XHJcbiAgfVxyXG5cclxuICByZXNldEluaXRTZWdtZW50KGluaXRTZWdtZW50LGF1ZGlvQ29kZWMsdmlkZW9Db2RlYywgZHVyYXRpb24pIHtcclxuICAgIC8vanNoaW50IHVudXNlZDpmYWxzZVxyXG4gICAgaWYgKGluaXRTZWdtZW50ICYmIGluaXRTZWdtZW50LmJ5dGVMZW5ndGgpIHtcclxuICAgICAgY29uc3QgaW5pdERhdGEgPSB0aGlzLmluaXREYXRhID0gTVA0RGVtdXhlci5wYXJzZUluaXRTZWdtZW50KGluaXRTZWdtZW50KTtcclxuICAgICAgdmFyIHRyYWNrcyA9IHt9O1xyXG4gICAgICBpZiAoaW5pdERhdGEuYXVkaW8pIHtcclxuICAgICAgICB0cmFja3MuYXVkaW8gPSB7IGNvbnRhaW5lciA6ICdhdWRpby9tcDQnLCBjb2RlYyA6IGF1ZGlvQ29kZWMsIGluaXRTZWdtZW50IDogZHVyYXRpb24gPyBpbml0U2VnbWVudCA6IG51bGwgfTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoaW5pdERhdGEudmlkZW8pIHtcclxuICAgICAgICB0cmFja3MudmlkZW8gPSB7IGNvbnRhaW5lciA6ICd2aWRlby9tcDQnLCBjb2RlYyA6IHZpZGVvQ29kZWMsIGluaXRTZWdtZW50IDogZHVyYXRpb24gPyBpbml0U2VnbWVudCA6IG51bGwgfTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLm9ic2VydmVyLnRyaWdnZXIoRXZlbnQuRlJBR19QQVJTSU5HX0lOSVRfU0VHTUVOVCx7IHRyYWNrcyA6IHRyYWNrcyB9KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGlmIChhdWRpb0NvZGVjKSB7XHJcbiAgICAgICAgdGhpcy5hdWRpb0NvZGVjID0gYXVkaW9Db2RlYztcclxuICAgICAgfVxyXG4gICAgICBpZiAodmlkZW9Db2RlYykge1xyXG4gICAgICAgIHRoaXMudmlkZW9Db2RlYyA9IHZpZGVvQ29kZWM7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIHN0YXRpYyBwcm9iZShkYXRhKSB7XHJcbiAgICBpZiAoZGF0YS5sZW5ndGggPj0gOCkge1xyXG4gICAgICBjb25zdCBkYXRhVHlwZSA9IE1QNERlbXV4ZXIuYmluMnN0cihkYXRhLnN1YmFycmF5KDQsOCkpO1xyXG4gICAgICByZXR1cm4gKFsnbW9vZicsJ2Z0eXAnLCdzdHlwJ10uaW5kZXhPZihkYXRhVHlwZSkgPj0gMCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG5cclxuXHJcbiAgc3RhdGljIGJpbjJzdHIoYnVmZmVyKSB7XHJcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBidWZmZXIpO1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIHJlYWRVaW50MzIoYnVmZmVyLCBvZmZzZXQpIHtcclxuICAgIGlmIChidWZmZXIuZGF0YSkge1xyXG4gICAgICBvZmZzZXQgKz0gYnVmZmVyLnN0YXJ0O1xyXG4gICAgICBidWZmZXIgPSBidWZmZXIuZGF0YTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCB2YWwgPSBidWZmZXJbb2Zmc2V0XSA8PCAyNCB8XHJcbiAgICAgICAgICAgICAgICBidWZmZXJbb2Zmc2V0ICsgMV0gPDwgMTYgfFxyXG4gICAgICAgICAgICAgICAgYnVmZmVyW29mZnNldCArIDJdIDw8IDggfFxyXG4gICAgICAgICAgICAgICAgYnVmZmVyW29mZnNldCArIDNdO1xyXG4gICAgcmV0dXJuIHZhbCA8IDAgPyA0Mjk0OTY3Mjk2ICsgdmFsIDogdmFsO1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIHdyaXRlVWludDMyKGJ1ZmZlciwgb2Zmc2V0LCB2YWx1ZSkge1xyXG4gICAgaWYgKGJ1ZmZlci5kYXRhKSB7XHJcbiAgICAgIG9mZnNldCArPSBidWZmZXIuc3RhcnQ7XHJcbiAgICAgIGJ1ZmZlciA9IGJ1ZmZlci5kYXRhO1xyXG4gICAgfVxyXG4gICAgYnVmZmVyW29mZnNldF0gPSB2YWx1ZSA+PiAyNDtcclxuICAgIGJ1ZmZlcltvZmZzZXQrMV0gPSAodmFsdWUgPj4gMTYpICYgMHhmZjtcclxuICAgIGJ1ZmZlcltvZmZzZXQrMl0gPSAodmFsdWUgPj4gOCkgJiAweGZmO1xyXG4gICAgYnVmZmVyW29mZnNldCszXSA9IHZhbHVlICYgMHhmZjtcclxuICB9XHJcblxyXG5cclxuICAvLyBGaW5kIHRoZSBkYXRhIGZvciBhIGJveCBzcGVjaWZpZWQgYnkgaXRzIHBhdGhcclxuICBzdGF0aWMgZmluZEJveChkYXRhLHBhdGgpIHtcclxuICAgIHZhciByZXN1bHRzID0gW10sXHJcbiAgICAgICAgaSwgc2l6ZSwgdHlwZSwgZW5kLCBzdWJyZXN1bHRzLCBzdGFydCwgZW5kYm94O1xyXG5cclxuICAgIGlmIChkYXRhLmRhdGEpIHtcclxuICAgICAgc3RhcnQgPSBkYXRhLnN0YXJ0O1xyXG4gICAgICBlbmQgPSBkYXRhLmVuZDtcclxuICAgICAgZGF0YSA9IGRhdGEuZGF0YTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHN0YXJ0ID0gMDtcclxuICAgICAgZW5kID0gZGF0YS5ieXRlTGVuZ3RoO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghcGF0aC5sZW5ndGgpIHtcclxuICAgICAgLy8gc2hvcnQtY2lyY3VpdCB0aGUgc2VhcmNoIGZvciBlbXB0eSBwYXRoc1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDspIHtcclxuICAgICAgc2l6ZSA9IE1QNERlbXV4ZXIucmVhZFVpbnQzMihkYXRhLCBpKTtcclxuICAgICAgdHlwZSA9IE1QNERlbXV4ZXIuYmluMnN0cihkYXRhLnN1YmFycmF5KGkgKyA0LCBpICsgOCkpO1xyXG4gICAgICBlbmRib3ggPSBzaXplID4gMSA/IGkgKyBzaXplIDogZW5kO1xyXG5cclxuICAgICAgaWYgKHR5cGUgPT09IHBhdGhbMF0pIHtcclxuXHJcbiAgICAgICAgaWYgKHBhdGgubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgICAvLyB0aGlzIGlzIHRoZSBlbmQgb2YgdGhlIHBhdGggYW5kIHdlJ3ZlIGZvdW5kIHRoZSBib3ggd2Ugd2VyZVxyXG4gICAgICAgICAgLy8gbG9va2luZyBmb3JcclxuICAgICAgICAgIHJlc3VsdHMucHVzaCh7IGRhdGEgOiBkYXRhLCBzdGFydCA6IGkgKyA4LCBlbmQgOiBlbmRib3h9KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgLy8gcmVjdXJzaXZlbHkgc2VhcmNoIGZvciB0aGUgbmV4dCBib3ggYWxvbmcgdGhlIHBhdGhcclxuICAgICAgICAgIHN1YnJlc3VsdHMgPSBNUDREZW11eGVyLmZpbmRCb3goeyBkYXRhIDogZGF0YSwgc3RhcnQgOiBpICs4LCBlbmQgOiBlbmRib3ggfSwgcGF0aC5zbGljZSgxKSk7XHJcbiAgICAgICAgICBpZiAoc3VicmVzdWx0cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmVzdWx0cyA9IHJlc3VsdHMuY29uY2F0KHN1YnJlc3VsdHMpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBpID0gZW5kYm94O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHdlJ3ZlIGZpbmlzaGVkIHNlYXJjaGluZyBhbGwgb2YgZGF0YVxyXG4gICAgcmV0dXJuIHJlc3VsdHM7XHJcbiAgfVxyXG5cclxuXHJcblxyXG4vKipcclxuICogUGFyc2VzIGFuIE1QNCBpbml0aWFsaXphdGlvbiBzZWdtZW50IGFuZCBleHRyYWN0cyBzdHJlYW0gdHlwZSBhbmRcclxuICogdGltZXNjYWxlIHZhbHVlcyBmb3IgYW55IGRlY2xhcmVkIHRyYWNrcy4gVGltZXNjYWxlIHZhbHVlcyBpbmRpY2F0ZSB0aGVcclxuICogbnVtYmVyIG9mIGNsb2NrIHRpY2tzIHBlciBzZWNvbmQgdG8gYXNzdW1lIGZvciB0aW1lLWJhc2VkIHZhbHVlc1xyXG4gKiBlbHNld2hlcmUgaW4gdGhlIE1QNC5cclxuICpcclxuICogVG8gZGV0ZXJtaW5lIHRoZSBzdGFydCB0aW1lIG9mIGFuIE1QNCwgeW91IG5lZWQgdHdvIHBpZWNlcyBvZlxyXG4gKiBpbmZvcm1hdGlvbjogdGhlIHRpbWVzY2FsZSB1bml0IGFuZCB0aGUgZWFybGllc3QgYmFzZSBtZWRpYSBkZWNvZGVcclxuICogdGltZS4gTXVsdGlwbGUgdGltZXNjYWxlcyBjYW4gYmUgc3BlY2lmaWVkIHdpdGhpbiBhbiBNUDQgYnV0IHRoZVxyXG4gKiBiYXNlIG1lZGlhIGRlY29kZSB0aW1lIGlzIGFsd2F5cyBleHByZXNzZWQgaW4gdGhlIHRpbWVzY2FsZSBmcm9tXHJcbiAqIHRoZSBtZWRpYSBoZWFkZXIgYm94IGZvciB0aGUgdHJhY2s6XHJcbiAqIGBgYFxyXG4gKiBtb292ID4gdHJhayA+IG1kaWEgPiBtZGhkLnRpbWVzY2FsZVxyXG4gKiBtb292ID4gdHJhayA+IG1kaWEgPiBoZGxyXHJcbiAqIGBgYFxyXG4gKiBAcGFyYW0gaW5pdCB7VWludDhBcnJheX0gdGhlIGJ5dGVzIG9mIHRoZSBpbml0IHNlZ21lbnRcclxuICogQHJldHVybiB7b2JqZWN0fSBhIGhhc2ggb2YgdHJhY2sgdHlwZSB0byB0aW1lc2NhbGUgdmFsdWVzIG9yIG51bGwgaWZcclxuICogdGhlIGluaXQgc2VnbWVudCBpcyBtYWxmb3JtZWQuXHJcbiAqL1xyXG4gIHN0YXRpYyBwYXJzZUluaXRTZWdtZW50KGluaXRTZWdtZW50KSB7XHJcbiAgICB2YXIgcmVzdWx0ID0gW107XHJcbiAgICB2YXIgdHJha3MgPSBNUDREZW11eGVyLmZpbmRCb3goaW5pdFNlZ21lbnQsIFsnbW9vdicsICd0cmFrJ10pO1xyXG5cclxuICAgIHRyYWtzLmZvckVhY2godHJhayA9PiB7XHJcbiAgICAgIGNvbnN0IHRraGQgPSBNUDREZW11eGVyLmZpbmRCb3godHJhaywgWyd0a2hkJ10pWzBdO1xyXG4gICAgICBpZiAodGtoZCkge1xyXG4gICAgICAgIGxldCB2ZXJzaW9uID0gdGtoZC5kYXRhW3RraGQuc3RhcnRdO1xyXG4gICAgICAgIGxldCBpbmRleCA9IHZlcnNpb24gPT09IDAgPyAxMiA6IDIwO1xyXG4gICAgICAgIGxldCB0cmFja0lkID0gTVA0RGVtdXhlci5yZWFkVWludDMyKHRraGQsIGluZGV4KTtcclxuXHJcbiAgICAgICAgY29uc3QgbWRoZCA9IE1QNERlbXV4ZXIuZmluZEJveCh0cmFrLCBbJ21kaWEnLCAnbWRoZCddKVswXTtcclxuICAgICAgICBpZiAobWRoZCkge1xyXG4gICAgICAgICAgdmVyc2lvbiA9IG1kaGQuZGF0YVttZGhkLnN0YXJ0XTtcclxuICAgICAgICAgIGluZGV4ID0gdmVyc2lvbiA9PT0gMCA/IDEyIDogMjA7XHJcbiAgICAgICAgICBjb25zdCB0aW1lc2NhbGUgPSBNUDREZW11eGVyLnJlYWRVaW50MzIobWRoZCwgaW5kZXgpO1xyXG5cclxuICAgICAgICAgIGNvbnN0IGhkbHIgPSBNUDREZW11eGVyLmZpbmRCb3godHJhaywgWydtZGlhJywgJ2hkbHInXSlbMF07XHJcbiAgICAgICAgICBpZiAoaGRscikge1xyXG4gICAgICAgICAgICBjb25zdCBoZGxyVHlwZSA9IE1QNERlbXV4ZXIuYmluMnN0cihoZGxyLmRhdGEuc3ViYXJyYXkoaGRsci5zdGFydCs4LCBoZGxyLnN0YXJ0KzEyKSk7XHJcbiAgICAgICAgICAgIGxldCB0eXBlID0geyAnc291bicgOiAnYXVkaW8nLCAndmlkZScgOiAndmlkZW8nfVtoZGxyVHlwZV07XHJcbiAgICAgICAgICAgIGlmICh0eXBlKSB7XHJcbiAgICAgICAgICAgICAgcmVzdWx0W3RyYWNrSWRdID0geyB0aW1lc2NhbGUgOiB0aW1lc2NhbGUgLCB0eXBlIDogdHlwZX07XHJcbiAgICAgICAgICAgICAgcmVzdWx0W3R5cGVdID0geyB0aW1lc2NhbGUgOiB0aW1lc2NhbGUgLCBpZCA6IHRyYWNrSWR9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbiAgfVxyXG5cclxuXHJcbi8qKlxyXG4gKiBEZXRlcm1pbmUgdGhlIGJhc2UgbWVkaWEgZGVjb2RlIHN0YXJ0IHRpbWUsIGluIHNlY29uZHMsIGZvciBhbiBNUDRcclxuICogZnJhZ21lbnQuIElmIG11bHRpcGxlIGZyYWdtZW50cyBhcmUgc3BlY2lmaWVkLCB0aGUgZWFybGllc3QgdGltZSBpc1xyXG4gKiByZXR1cm5lZC5cclxuICpcclxuICogVGhlIGJhc2UgbWVkaWEgZGVjb2RlIHRpbWUgY2FuIGJlIHBhcnNlZCBmcm9tIHRyYWNrIGZyYWdtZW50XHJcbiAqIG1ldGFkYXRhOlxyXG4gKiBgYGBcclxuICogbW9vZiA+IHRyYWYgPiB0ZmR0LmJhc2VNZWRpYURlY29kZVRpbWVcclxuICogYGBgXHJcbiAqIEl0IHJlcXVpcmVzIHRoZSB0aW1lc2NhbGUgdmFsdWUgZnJvbSB0aGUgbWRoZCB0byBpbnRlcnByZXQuXHJcbiAqXHJcbiAqIEBwYXJhbSB0aW1lc2NhbGUge29iamVjdH0gYSBoYXNoIG9mIHRyYWNrIGlkcyB0byB0aW1lc2NhbGUgdmFsdWVzLlxyXG4gKiBAcmV0dXJuIHtudW1iZXJ9IHRoZSBlYXJsaWVzdCBiYXNlIG1lZGlhIGRlY29kZSBzdGFydCB0aW1lIGZvciB0aGVcclxuICogZnJhZ21lbnQsIGluIHNlY29uZHNcclxuICovXHJcbnN0YXRpYyBnZXRTdGFydERUUyhpbml0RGF0YSwgZnJhZ21lbnQpIHtcclxuICB2YXIgdHJhZnMsIGJhc2VUaW1lcywgcmVzdWx0O1xyXG5cclxuICAvLyB3ZSBuZWVkIGluZm8gZnJvbSB0d28gY2hpbGRyZW5kIG9mIGVhY2ggdHJhY2sgZnJhZ21lbnQgYm94XHJcbiAgdHJhZnMgPSBNUDREZW11eGVyLmZpbmRCb3goZnJhZ21lbnQsIFsnbW9vZicsICd0cmFmJ10pO1xyXG5cclxuICAvLyBkZXRlcm1pbmUgdGhlIHN0YXJ0IHRpbWVzIGZvciBlYWNoIHRyYWNrXHJcbiAgYmFzZVRpbWVzID0gW10uY29uY2F0LmFwcGx5KFtdLCB0cmFmcy5tYXAoZnVuY3Rpb24odHJhZikge1xyXG4gICAgcmV0dXJuIE1QNERlbXV4ZXIuZmluZEJveCh0cmFmLCBbJ3RmaGQnXSkubWFwKGZ1bmN0aW9uKHRmaGQpIHtcclxuICAgICAgdmFyIGlkLCBzY2FsZSwgYmFzZVRpbWU7XHJcblxyXG4gICAgICAvLyBnZXQgdGhlIHRyYWNrIGlkIGZyb20gdGhlIHRmaGRcclxuICAgICAgaWQgPSBNUDREZW11eGVyLnJlYWRVaW50MzIodGZoZCwgNCk7XHJcbiAgICAgIC8vIGFzc3VtZSBhIDkwa0h6IGNsb2NrIGlmIG5vIHRpbWVzY2FsZSB3YXMgc3BlY2lmaWVkXHJcbiAgICAgIHNjYWxlID0gaW5pdERhdGFbaWRdLnRpbWVzY2FsZSB8fCA5MGUzO1xyXG5cclxuICAgICAgLy8gZ2V0IHRoZSBiYXNlIG1lZGlhIGRlY29kZSB0aW1lIGZyb20gdGhlIHRmZHRcclxuICAgICAgYmFzZVRpbWUgPSBNUDREZW11eGVyLmZpbmRCb3godHJhZiwgWyd0ZmR0J10pLm1hcChmdW5jdGlvbih0ZmR0KSB7XHJcbiAgICAgICAgdmFyIHZlcnNpb24sIHJlc3VsdDtcclxuXHJcbiAgICAgICAgdmVyc2lvbiA9IHRmZHQuZGF0YVt0ZmR0LnN0YXJ0XTtcclxuICAgICAgICByZXN1bHQgPSBNUDREZW11eGVyLnJlYWRVaW50MzIodGZkdCwgNCk7XHJcbiAgICAgICAgaWYgKHZlcnNpb24gPT09ICAxKSB7XHJcbiAgICAgICAgICByZXN1bHQgKj0gTWF0aC5wb3coMiwgMzIpO1xyXG5cclxuICAgICAgICAgIHJlc3VsdCArPSBNUDREZW11eGVyLnJlYWRVaW50MzIodGZkdCwgOCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgIH0pWzBdO1xyXG4gICAgICBiYXNlVGltZSA9IGJhc2VUaW1lIHx8IEluZmluaXR5O1xyXG5cclxuICAgICAgLy8gY29udmVydCBiYXNlIHRpbWUgdG8gc2Vjb25kc1xyXG4gICAgICByZXR1cm4gYmFzZVRpbWUgLyBzY2FsZTtcclxuICAgIH0pO1xyXG4gIH0pKTtcclxuXHJcbiAgLy8gcmV0dXJuIHRoZSBtaW5pbXVtXHJcbiAgcmVzdWx0ID0gTWF0aC5taW4uYXBwbHkobnVsbCwgYmFzZVRpbWVzKTtcclxuICByZXR1cm4gaXNGaW5pdGUocmVzdWx0KSA/IHJlc3VsdCA6IDA7XHJcbn1cclxuXHJcblxyXG5cclxuXHJcbnN0YXRpYyBvZmZzZXRTdGFydERUUyhpbml0RGF0YSxmcmFnbWVudCx0aW1lT2Zmc2V0KSB7XHJcbiAgTVA0RGVtdXhlci5maW5kQm94KGZyYWdtZW50LCBbJ21vb2YnLCAndHJhZiddKS5tYXAoZnVuY3Rpb24odHJhZikge1xyXG4gICAgcmV0dXJuIE1QNERlbXV4ZXIuZmluZEJveCh0cmFmLCBbJ3RmaGQnXSkubWFwKGZ1bmN0aW9uKHRmaGQpIHtcclxuICAgICAgLy8gZ2V0IHRoZSB0cmFjayBpZCBmcm9tIHRoZSB0ZmhkXHJcbiAgICAgIHZhciBpZCA9IE1QNERlbXV4ZXIucmVhZFVpbnQzMih0ZmhkLCA0KTtcclxuICAgICAgLy8gYXNzdW1lIGEgOTBrSHogY2xvY2sgaWYgbm8gdGltZXNjYWxlIHdhcyBzcGVjaWZpZWRcclxuICAgICAgdmFyIHRpbWVzY2FsZSA9IGluaXREYXRhW2lkXS50aW1lc2NhbGUgfHwgOTBlMztcclxuXHJcbiAgICAgIC8vIGdldCB0aGUgYmFzZSBtZWRpYSBkZWNvZGUgdGltZSBmcm9tIHRoZSB0ZmR0XHJcbiAgICAgIE1QNERlbXV4ZXIuZmluZEJveCh0cmFmLCBbJ3RmZHQnXSkubWFwKGZ1bmN0aW9uKHRmZHQpIHtcclxuICAgICAgICB2YXIgdmVyc2lvbiA9IHRmZHQuZGF0YVt0ZmR0LnN0YXJ0XTtcclxuICAgICAgICB2YXIgYmFzZU1lZGlhRGVjb2RlVGltZSA9IE1QNERlbXV4ZXIucmVhZFVpbnQzMih0ZmR0LCA0KTtcclxuICAgICAgICBpZiAodmVyc2lvbiA9PT0gMCkge1xyXG4gICAgICAgICAgTVA0RGVtdXhlci53cml0ZVVpbnQzMih0ZmR0LCA0LCBiYXNlTWVkaWFEZWNvZGVUaW1lIC0gdGltZU9mZnNldCp0aW1lc2NhbGUpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBiYXNlTWVkaWFEZWNvZGVUaW1lICo9IE1hdGgucG93KDIsIDMyKTtcclxuICAgICAgICAgIGJhc2VNZWRpYURlY29kZVRpbWUgKz0gTVA0RGVtdXhlci5yZWFkVWludDMyKHRmZHQsIDgpO1xyXG4gICAgICAgICAgYmFzZU1lZGlhRGVjb2RlVGltZSAtPSB0aW1lT2Zmc2V0KnRpbWVzY2FsZTtcclxuICAgICAgICAgIGNvbnN0IHVwcGVyID0gTWF0aC5mbG9vcihiYXNlTWVkaWFEZWNvZGVUaW1lIC8gKFVJTlQzMl9NQVggKyAxKSk7XHJcbiAgICAgICAgICBjb25zdCBsb3dlciA9IE1hdGguZmxvb3IoYmFzZU1lZGlhRGVjb2RlVGltZSAlIChVSU5UMzJfTUFYICsgMSkpO1xyXG4gICAgICAgICAgTVA0RGVtdXhlci53cml0ZVVpbnQzMih0ZmR0LCA0LCB1cHBlcik7XHJcbiAgICAgICAgICBNUDREZW11eGVyLndyaXRlVWludDMyKHRmZHQsIDgsIGxvd2VyKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgfSk7XHJcbn1cclxuXHJcbiAgLy8gZmVlZCBpbmNvbWluZyBkYXRhIHRvIHRoZSBmcm9udCBvZiB0aGUgcGFyc2luZyBwaXBlbGluZVxyXG4gIGFwcGVuZChkYXRhLCB0aW1lT2Zmc2V0LGNvbnRpZ3VvdXMsYWNjdXJhdGVUaW1lT2Zmc2V0KSB7XHJcbiAgICBsZXQgaW5pdERhdGEgPSB0aGlzLmluaXREYXRhO1xyXG4gICAgaWYoIWluaXREYXRhKSB7XHJcbiAgICAgIHRoaXMucmVzZXRJbml0U2VnbWVudChkYXRhLHRoaXMuYXVkaW9Db2RlYyx0aGlzLnZpZGVvQ29kZWMpO1xyXG4gICAgICBpbml0RGF0YSA9IHRoaXMuaW5pdERhdGE7XHJcbiAgICB9XHJcbiAgICBsZXQgc3RhcnREVFMsIGluaXRQVFMgPSB0aGlzLmluaXRQVFM7XHJcbiAgICBpZiAoaW5pdFBUUyA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIGxldCBzdGFydERUUyA9IE1QNERlbXV4ZXIuZ2V0U3RhcnREVFMoaW5pdERhdGEsZGF0YSk7XHJcbiAgICAgIHRoaXMuaW5pdFBUUyA9IGluaXRQVFMgPSBzdGFydERUUyAtIHRpbWVPZmZzZXQ7XHJcbiAgICAgIHRoaXMub2JzZXJ2ZXIudHJpZ2dlcihFdmVudC5JTklUX1BUU19GT1VORCwgeyBpbml0UFRTOiBpbml0UFRTfSk7XHJcbiAgICB9XHJcbiAgICBNUDREZW11eGVyLm9mZnNldFN0YXJ0RFRTKGluaXREYXRhLGRhdGEsaW5pdFBUUyk7XHJcbiAgICBzdGFydERUUyA9IE1QNERlbXV4ZXIuZ2V0U3RhcnREVFMoaW5pdERhdGEsZGF0YSk7XHJcbiAgICB0aGlzLnJlbXV4ZXIucmVtdXgoaW5pdERhdGEuYXVkaW8sIGluaXREYXRhLnZpZGVvLCBudWxsLCBudWxsLCBzdGFydERUUywgY29udGlndW91cyxhY2N1cmF0ZVRpbWVPZmZzZXQsZGF0YSk7XHJcbiAgfVxyXG5cclxuICBkZXN0cm95KCkge1xyXG4gIH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IE1QNERlbXV4ZXI7XHJcbiIsIi8qKlxyXG4gKiAgTVBFRyBwYXJzZXIgaGVscGVyXHJcbiAqL1xyXG5cclxuY29uc3QgTXBlZ0F1ZGlvID0ge1xyXG5cclxuICAgIEJpdHJhdGVzTWFwOiBbXHJcbiAgICAgICAgMzIsIDY0LCA5NiwgMTI4LCAxNjAsIDE5MiwgMjI0LCAyNTYsIDI4OCwgMzIwLCAzNTIsIDM4NCwgNDE2LCA0NDgsXHJcbiAgICAgICAgMzIsIDQ4LCA1NiwgNjQsIDgwLCA5NiwgMTEyLCAxMjgsIDE2MCwgMTkyLCAyMjQsIDI1NiwgMzIwLCAzODQsXHJcbiAgICAgICAgMzIsIDQwLCA0OCwgNTYsIDY0LCA4MCwgOTYsIDExMiwgMTI4LCAxNjAsIDE5MiwgMjI0LCAyNTYsIDMyMCxcclxuICAgICAgICAzMiwgNDgsIDU2LCA2NCwgODAsIDk2LCAxMTIsIDEyOCwgMTQ0LCAxNjAsIDE3NiwgMTkyLCAyMjQsIDI1NixcclxuICAgICAgICA4LCAxNiwgMjQsIDMyLCA0MCwgNDgsIDU2LCA2NCwgODAsIDk2LCAxMTIsIDEyOCwgMTQ0LCAxNjBdLFxyXG5cclxuICAgIFNhbXBsaW5nUmF0ZU1hcDogWzQ0MTAwLCA0ODAwMCwgMzIwMDAsIDIyMDUwLCAyNDAwMCwgMTYwMDAsIDExMDI1LCAxMjAwMCwgODAwMF0sXHJcblxyXG4gICAgYXBwZW5kRnJhbWU6IGZ1bmN0aW9uICh0cmFjaywgZGF0YSwgb2Zmc2V0LCBwdHMsIGZyYW1lSW5kZXgpIHtcclxuICAgICAgICAvLyBVc2luZyBodHRwOi8vd3d3LmRhdGF2b3lhZ2UuY29tL21wZ3NjcmlwdC9tcGVnaGRyLmh0bSBhcyBhIHJlZmVyZW5jZVxyXG4gICAgICAgIGlmIChvZmZzZXQgKyAyNCA+IGRhdGEubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgaGVhZGVyID0gdGhpcy5wYXJzZUhlYWRlcihkYXRhLCBvZmZzZXQpO1xyXG4gICAgICAgIGlmIChoZWFkZXIgJiYgb2Zmc2V0ICsgaGVhZGVyLmZyYW1lTGVuZ3RoIDw9IGRhdGEubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHZhciBmcmFtZUR1cmF0aW9uID0gMTE1MiAqIDkwMDAwIC8gaGVhZGVyLnNhbXBsZVJhdGU7XHJcbiAgICAgICAgICAgIHZhciBzdGFtcCA9IHB0cyArIGZyYW1lSW5kZXggKiBmcmFtZUR1cmF0aW9uO1xyXG4gICAgICAgICAgICB2YXIgc2FtcGxlID0geyB1bml0OiBkYXRhLnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgaGVhZGVyLmZyYW1lTGVuZ3RoKSwgcHRzOiBzdGFtcCwgZHRzOiBzdGFtcCB9O1xyXG5cclxuICAgICAgICAgICAgdHJhY2suY29uZmlnID0gW107XHJcbiAgICAgICAgICAgIHRyYWNrLmNoYW5uZWxDb3VudCA9IGhlYWRlci5jaGFubmVsQ291bnQ7XHJcbiAgICAgICAgICAgIHRyYWNrLnNhbXBsZXJhdGUgPSBoZWFkZXIuc2FtcGxlUmF0ZTtcclxuICAgICAgICAgICAgdHJhY2suc2FtcGxlcy5wdXNoKHNhbXBsZSk7XHJcbiAgICAgICAgICAgIHRyYWNrLmxlbiArPSBoZWFkZXIuZnJhbWVMZW5ndGg7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4geyBzYW1wbGUsIGxlbmd0aDogaGVhZGVyLmZyYW1lTGVuZ3RoIH07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfSxcclxuXHJcbiAgICBwYXJzZUhlYWRlcjogZnVuY3Rpb24gKGRhdGEsIG9mZnNldCkge1xyXG4gICAgICAgIHZhciBoZWFkZXJCID0gKGRhdGFbb2Zmc2V0ICsgMV0gPj4gMykgJiAzO1xyXG4gICAgICAgIHZhciBoZWFkZXJDID0gKGRhdGFbb2Zmc2V0ICsgMV0gPj4gMSkgJiAzO1xyXG4gICAgICAgIHZhciBoZWFkZXJFID0gKGRhdGFbb2Zmc2V0ICsgMl0gPj4gNCkgJiAxNTtcclxuICAgICAgICB2YXIgaGVhZGVyRiA9IChkYXRhW29mZnNldCArIDJdID4+IDIpICYgMztcclxuICAgICAgICB2YXIgaGVhZGVyRyA9ICEhKGRhdGFbb2Zmc2V0ICsgMl0gJiAyKTtcclxuICAgICAgICBpZiAoaGVhZGVyQiAhPT0gMSAmJiBoZWFkZXJFICE9PSAwICYmIGhlYWRlckUgIT09IDE1ICYmIGhlYWRlckYgIT09IDMpIHtcclxuICAgICAgICAgICAgdmFyIGNvbHVtbkluQml0cmF0ZXMgPSBoZWFkZXJCID09PSAzID8gKDMgLSBoZWFkZXJDKSA6IChoZWFkZXJDID09PSAzID8gMyA6IDQpO1xyXG4gICAgICAgICAgICB2YXIgYml0UmF0ZSA9IE1wZWdBdWRpby5CaXRyYXRlc01hcFtjb2x1bW5JbkJpdHJhdGVzICogMTQgKyBoZWFkZXJFIC0gMV0gKiAxMDAwO1xyXG4gICAgICAgICAgICB2YXIgY29sdW1uSW5TYW1wbGVSYXRlcyA9IGhlYWRlckIgPT09IDMgPyAwIDogaGVhZGVyQiA9PT0gMiA/IDEgOiAyO1xyXG4gICAgICAgICAgICB2YXIgc2FtcGxlUmF0ZSA9IE1wZWdBdWRpby5TYW1wbGluZ1JhdGVNYXBbY29sdW1uSW5TYW1wbGVSYXRlcyAqIDMgKyBoZWFkZXJGXTtcclxuICAgICAgICAgICAgdmFyIHBhZGRpbmcgPSBoZWFkZXJHID8gMSA6IDA7XHJcbiAgICAgICAgICAgIHZhciBjaGFubmVsQ291bnQgPSBkYXRhW29mZnNldCArIDNdID4+IDYgPT09IDMgPyAxIDogMjsgLy8gSWYgYml0cyBvZiBjaGFubmVsIG1vZGUgYXJlIGAxMWAgdGhlbiBpdCBpcyBhIHNpbmdsZSBjaGFubmVsIChNb25vKVxyXG4gICAgICAgICAgICB2YXIgZnJhbWVMZW5ndGggPSBoZWFkZXJDID09PSAzID9cclxuICAgICAgICAgICAgICAgICgoaGVhZGVyQiA9PT0gMyA/IDEyIDogNikgKiBiaXRSYXRlIC8gc2FtcGxlUmF0ZSArIHBhZGRpbmcpIDw8IDIgOlxyXG4gICAgICAgICAgICAgICAgKChoZWFkZXJCID09PSAzID8gMTQ0IDogNzIpICogYml0UmF0ZSAvIHNhbXBsZVJhdGUgKyBwYWRkaW5nKSB8IDA7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4geyBzYW1wbGVSYXRlLCBjaGFubmVsQ291bnQsIGZyYW1lTGVuZ3RoIH07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfSxcclxuXHJcbiAgICBpc0hlYWRlclBhdHRlcm46IGZ1bmN0aW9uIChkYXRhLCBvZmZzZXQpIHtcclxuICAgICAgICByZXR1cm4gZGF0YVtvZmZzZXRdID09PSAweGZmICYmIChkYXRhW29mZnNldCArIDFdICYgMHhlMCkgPT09IDB4ZTAgJiYgKGRhdGFbb2Zmc2V0ICsgMV0gJiAweDA2KSAhPT0gMHgwMDtcclxuICAgIH0sXHJcblxyXG4gICAgaXNIZWFkZXI6IGZ1bmN0aW9uIChkYXRhLCBvZmZzZXQpIHtcclxuICAgICAgICAvLyBMb29rIGZvciBNUEVHIGhlYWRlciB8IDExMTEgMTExMSB8IDExMVggWFlaWCB8IHdoZXJlIFggY2FuIGJlIGVpdGhlciAwIG9yIDEgYW5kIFkgb3IgWiBzaG91bGQgYmUgMVxyXG4gICAgICAgIC8vIExheWVyIGJpdHMgKHBvc2l0aW9uIDE0IGFuZCAxNSkgaW4gaGVhZGVyIHNob3VsZCBiZSBhbHdheXMgZGlmZmVyZW50IGZyb20gMCAoTGF5ZXIgSSBvciBMYXllciBJSSBvciBMYXllciBJSUkpXHJcbiAgICAgICAgLy8gTW9yZSBpbmZvIGh0dHA6Ly93d3cubXAzLXRlY2gub3JnL3Byb2dyYW1tZXIvZnJhbWVfaGVhZGVyLmh0bWxcclxuICAgICAgICBpZiAob2Zmc2V0ICsgMSA8IGRhdGEubGVuZ3RoICYmIHRoaXMuaXNIZWFkZXJQYXR0ZXJuKGRhdGEsIG9mZnNldCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH0sXHJcblxyXG4gICAgcHJvYmU6IGZ1bmN0aW9uIChkYXRhLCBvZmZzZXQpIHtcclxuICAgICAgICAvLyBzYW1lIGFzIGlzSGVhZGVyIGJ1dCB3ZSBhbHNvIGNoZWNrIHRoYXQgTVBFRyBmcmFtZSBmb2xsb3dzIGxhc3QgTVBFRyBmcmFtZSBcclxuICAgICAgICAvLyBvciBlbmQgb2YgZGF0YSBpcyByZWFjaGVkXHJcbiAgICAgICAgaWYgKG9mZnNldCArIDEgPCBkYXRhLmxlbmd0aCAmJiB0aGlzLmlzSGVhZGVyUGF0dGVybihkYXRhLCBvZmZzZXQpKSB7XHJcbiAgICAgICAgICAgIC8vIE1QRUcgaGVhZGVyIExlbmd0aFxyXG4gICAgICAgICAgICBsZXQgaGVhZGVyTGVuZ3RoID0gNDtcclxuICAgICAgICAgICAgLy8gTVBFRyBmcmFtZSBMZW5ndGhcclxuICAgICAgICAgICAgbGV0IGhlYWRlciA9IHRoaXMucGFyc2VIZWFkZXIoZGF0YSwgb2Zmc2V0KTtcclxuICAgICAgICAgICAgbGV0IGZyYW1lTGVuZ3RoID0gaGVhZGVyTGVuZ3RoO1xyXG4gICAgICAgICAgICBpZiAoaGVhZGVyICYmIGhlYWRlci5mcmFtZUxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgZnJhbWVMZW5ndGggPSBoZWFkZXIuZnJhbWVMZW5ndGg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IG5ld09mZnNldCA9IG9mZnNldCArIGZyYW1lTGVuZ3RoO1xyXG4gICAgICAgICAgICBpZiAobmV3T2Zmc2V0ID09PSBkYXRhLmxlbmd0aCB8fCAobmV3T2Zmc2V0ICsgMSA8IGRhdGEubGVuZ3RoICYmIHRoaXMuaXNIZWFkZXJQYXR0ZXJuKGRhdGEsIG5ld09mZnNldCkpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE1wZWdBdWRpbzsiLCIvKipcclxuICogU0FNUExFLUFFUyBkZWNyeXB0ZXJcclxuKi9cclxuXHJcbiBpbXBvcnQgRGVjcnlwdGVyIGZyb20gJy4uL2NyeXB0L2RlY3J5cHRlcic7XHJcblxyXG4gY2xhc3MgU2FtcGxlQWVzRGVjcnlwdGVyIHtcclxuXHJcbiAgY29uc3RydWN0b3Iob2JzZXJ2ZXIsIGNvbmZpZywgZGVjcnlwdGRhdGEsIGRpc2NhcmRFUEIpIHtcclxuICAgIHRoaXMuZGVjcnlwdGRhdGEgPSBkZWNyeXB0ZGF0YTtcclxuICAgIHRoaXMuZGlzY2FyZEVQQiA9IGRpc2NhcmRFUEI7XHJcbiAgICB0aGlzLmRlY3J5cHRlciA9IG5ldyBEZWNyeXB0ZXIob2JzZXJ2ZXIsIGNvbmZpZyk7XHJcbiAgfVxyXG5cclxuICBkZWNyeXB0QnVmZmVyKGVuY3J5cHRlZERhdGEsIGNhbGxiYWNrKSB7XHJcbiAgICB0aGlzLmRlY3J5cHRlci5kZWNyeXB0KGVuY3J5cHRlZERhdGEsIHRoaXMuZGVjcnlwdGRhdGEua2V5LmJ1ZmZlciwgdGhpcy5kZWNyeXB0ZGF0YS5pdi5idWZmZXIsIGNhbGxiYWNrKTtcclxuICB9XHJcblxyXG4gIC8vIEFBQyAtIGVuY3J5cHQgYWxsIGZ1bGwgMTYgYnl0ZXMgYmxvY2tzIHN0YXJ0aW5nIGZyb20gb2Zmc2V0IDE2XHJcbiAgZGVjcnlwdEFhY1NhbXBsZShzYW1wbGVzLCBzYW1wbGVJbmRleCwgY2FsbGJhY2ssIHN5bmMpIHtcclxuICAgIGxldCBjdXJVbml0ID0gc2FtcGxlc1tzYW1wbGVJbmRleF0udW5pdDtcclxuICAgIGxldCBlbmNyeXB0ZWREYXRhID0gY3VyVW5pdC5zdWJhcnJheSgxNiwgY3VyVW5pdC5sZW5ndGggLSBjdXJVbml0Lmxlbmd0aCAlIDE2KTtcclxuICAgIGxldCBlbmNyeXB0ZWRCdWZmZXIgPSBlbmNyeXB0ZWREYXRhLmJ1ZmZlci5zbGljZShcclxuICAgICAgIGVuY3J5cHRlZERhdGEuYnl0ZU9mZnNldCxcclxuICAgICAgIGVuY3J5cHRlZERhdGEuYnl0ZU9mZnNldCArIGVuY3J5cHRlZERhdGEubGVuZ3RoKTtcclxuXHJcbiAgICBsZXQgbG9jYWx0aGlzID0gdGhpcztcclxuICAgIHRoaXMuZGVjcnlwdEJ1ZmZlcihlbmNyeXB0ZWRCdWZmZXIsIGZ1bmN0aW9uIChkZWNyeXB0ZWREYXRhKSB7XHJcbiAgICAgIGRlY3J5cHRlZERhdGEgPSBuZXcgVWludDhBcnJheShkZWNyeXB0ZWREYXRhKTtcclxuICAgICAgY3VyVW5pdC5zZXQoZGVjcnlwdGVkRGF0YSwgMTYpO1xyXG5cclxuICAgICAgaWYgKCFzeW5jKSB7XHJcbiAgICAgICAgbG9jYWx0aGlzLmRlY3J5cHRBYWNTYW1wbGVzKHNhbXBsZXMsIHNhbXBsZUluZGV4ICsgMSwgY2FsbGJhY2spO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIGRlY3J5cHRBYWNTYW1wbGVzKHNhbXBsZXMsIHNhbXBsZUluZGV4LCBjYWxsYmFjaykge1xyXG4gICAgZm9yICg7OyBzYW1wbGVJbmRleCsrKSB7XHJcbiAgICAgIGlmIChzYW1wbGVJbmRleCA+PSBzYW1wbGVzLmxlbmd0aCkge1xyXG4gICAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoc2FtcGxlc1tzYW1wbGVJbmRleF0udW5pdC5sZW5ndGggPCAzMikge1xyXG4gICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBsZXQgc3luYyA9IHRoaXMuZGVjcnlwdGVyLmlzU3luYygpO1xyXG5cclxuICAgICAgdGhpcy5kZWNyeXB0QWFjU2FtcGxlKHNhbXBsZXMsIHNhbXBsZUluZGV4LCBjYWxsYmFjaywgc3luYyk7XHJcblxyXG4gICAgICBpZiAoIXN5bmMpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIEFWQyAtIGVuY3J5cHQgb25lIDE2IGJ5dGVzIGJsb2NrIG91dCBvZiB0ZW4sIHN0YXJ0aW5nIGZyb20gb2Zmc2V0IDMyXHJcbiAgZ2V0QXZjRW5jcnlwdGVkRGF0YShkZWNvZGVkRGF0YSkge1xyXG4gICAgbGV0IGVuY3J5cHRlZERhdGFMZW4gPSBNYXRoLmZsb29yKChkZWNvZGVkRGF0YS5sZW5ndGggLSA0OCkgLyAxNjApICogMTYgKyAxNjtcclxuICAgIGxldCBlbmNyeXB0ZWREYXRhID0gbmV3IEludDhBcnJheShlbmNyeXB0ZWREYXRhTGVuKTtcclxuICAgIGxldCBvdXRwdXRQb3MgPSAwO1xyXG4gICAgZm9yIChsZXQgaW5wdXRQb3MgPSAzMjsgaW5wdXRQb3MgPD0gZGVjb2RlZERhdGEubGVuZ3RoIC0gMTY7IGlucHV0UG9zICs9IDE2MCwgb3V0cHV0UG9zICs9IDE2KSB7XHJcbiAgICAgIGVuY3J5cHRlZERhdGEuc2V0KGRlY29kZWREYXRhLnN1YmFycmF5KGlucHV0UG9zLCBpbnB1dFBvcyArIDE2KSwgb3V0cHV0UG9zKTtcclxuICAgIH1cclxuICAgIHJldHVybiBlbmNyeXB0ZWREYXRhO1xyXG4gIH1cclxuXHJcbiAgZ2V0QXZjRGVjcnlwdGVkVW5pdChkZWNvZGVkRGF0YSwgZGVjcnlwdGVkRGF0YSkge1xyXG4gICAgZGVjcnlwdGVkRGF0YSA9IG5ldyBVaW50OEFycmF5KGRlY3J5cHRlZERhdGEpO1xyXG4gICAgbGV0IGlucHV0UG9zID0gMDtcclxuICAgIGZvciAobGV0IG91dHB1dFBvcyA9IDMyOyBvdXRwdXRQb3MgPD0gZGVjb2RlZERhdGEubGVuZ3RoIC0gMTY7IG91dHB1dFBvcyArPSAxNjAsIGlucHV0UG9zICs9IDE2KSB7XHJcbiAgICAgIGRlY29kZWREYXRhLnNldChkZWNyeXB0ZWREYXRhLnN1YmFycmF5KGlucHV0UG9zLCBpbnB1dFBvcyArIDE2KSwgb3V0cHV0UG9zKTtcclxuICAgIH1cclxuICAgIHJldHVybiBkZWNvZGVkRGF0YTtcclxuICB9XHJcblxyXG4gIGRlY3J5cHRBdmNTYW1wbGUoc2FtcGxlcywgc2FtcGxlSW5kZXgsIHVuaXRJbmRleCwgY2FsbGJhY2ssIGN1clVuaXQsIHN5bmMpIHtcclxuICAgIGxldCBkZWNvZGVkRGF0YSA9IHRoaXMuZGlzY2FyZEVQQihjdXJVbml0LmRhdGEpO1xyXG4gICAgbGV0IGVuY3J5cHRlZERhdGEgPSB0aGlzLmdldEF2Y0VuY3J5cHRlZERhdGEoZGVjb2RlZERhdGEpO1xyXG4gICAgbGV0IGxvY2FsdGhpcyA9IHRoaXM7XHJcblxyXG4gICAgdGhpcy5kZWNyeXB0QnVmZmVyKGVuY3J5cHRlZERhdGEuYnVmZmVyLCBmdW5jdGlvbiAoZGVjcnlwdGVkRGF0YSkge1xyXG4gICAgICBjdXJVbml0LmRhdGEgPSBsb2NhbHRoaXMuZ2V0QXZjRGVjcnlwdGVkVW5pdChkZWNvZGVkRGF0YSwgZGVjcnlwdGVkRGF0YSk7XHJcblxyXG4gICAgICBpZiAoIXN5bmMpIHtcclxuICAgICAgICBsb2NhbHRoaXMuZGVjcnlwdEF2Y1NhbXBsZXMoc2FtcGxlcywgc2FtcGxlSW5kZXgsIHVuaXRJbmRleCArIDEsIGNhbGxiYWNrKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBkZWNyeXB0QXZjU2FtcGxlcyhzYW1wbGVzLCBzYW1wbGVJbmRleCwgdW5pdEluZGV4LCBjYWxsYmFjaykge1xyXG4gICAgZm9yICg7OyBzYW1wbGVJbmRleCsrLCB1bml0SW5kZXggPSAwKSB7XHJcbiAgICAgIGlmIChzYW1wbGVJbmRleCA+PSBzYW1wbGVzLmxlbmd0aCkge1xyXG4gICAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBsZXQgY3VyVW5pdHMgPSBzYW1wbGVzW3NhbXBsZUluZGV4XS51bml0cztcclxuICAgICAgZm9yICg7OyB1bml0SW5kZXgrKykge1xyXG4gICAgICAgIGlmICh1bml0SW5kZXggPj0gY3VyVW5pdHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBjdXJVbml0ID0gY3VyVW5pdHNbdW5pdEluZGV4XTtcclxuICAgICAgICBpZiAoY3VyVW5pdC5sZW5ndGggPD0gNDggfHwgKGN1clVuaXQudHlwZSAhPT0gMSAmJiBjdXJVbml0LnR5cGUgIT09IDUpKSB7XHJcbiAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBzeW5jID0gdGhpcy5kZWNyeXB0ZXIuaXNTeW5jKCk7XHJcblxyXG4gICAgICAgIHRoaXMuZGVjcnlwdEF2Y1NhbXBsZShzYW1wbGVzLCBzYW1wbGVJbmRleCwgdW5pdEluZGV4LCBjYWxsYmFjaywgY3VyVW5pdCwgc3luYyk7XHJcblxyXG4gICAgICAgIGlmICghc3luYykge1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuIH1cclxuXHJcbiBleHBvcnQgZGVmYXVsdCBTYW1wbGVBZXNEZWNyeXB0ZXI7XHJcbiIsIi8qKlxyXG4gKiBoaWdobHkgb3B0aW1pemVkIFRTIGRlbXV4ZXI6XHJcbiAqIHBhcnNlIFBBVCwgUE1UXHJcbiAqIGV4dHJhY3QgUEVTIHBhY2tldCBmcm9tIGF1ZGlvIGFuZCB2aWRlbyBQSURzXHJcbiAqIGV4dHJhY3QgQVZDL0gyNjQgTkFMIHVuaXRzIGFuZCBBQUMvQURUUyBzYW1wbGVzIGZyb20gUEVTIHBhY2tldFxyXG4gKiB0cmlnZ2VyIHRoZSByZW11eGVyIHVwb24gcGFyc2luZyBjb21wbGV0aW9uXHJcbiAqIGl0IGFsc28gdHJpZXMgdG8gd29ya2Fyb3VuZCBhcyBiZXN0IGFzIGl0IGNhbiBhdWRpbyBjb2RlYyBzd2l0Y2ggKEhFLUFBQyB0byBBQUMgYW5kIHZpY2UgdmVyc2EpLCB3aXRob3V0IGhhdmluZyB0byByZXN0YXJ0IHRoZSBNZWRpYVNvdXJjZS5cclxuICogaXQgYWxzbyBjb250cm9scyB0aGUgcmVtdXhpbmcgcHJvY2VzcyA6XHJcbiAqIHVwb24gZGlzY29udGludWl0eSBvciBsZXZlbCBzd2l0Y2ggZGV0ZWN0aW9uLCBpdCB3aWxsIGFsc28gbm90aWZpZXMgdGhlIHJlbXV4ZXIgc28gdGhhdCBpdCBjYW4gcmVzZXQgaXRzIHN0YXRlLlxyXG4qL1xyXG5cclxuIGltcG9ydCBBRFRTIGZyb20gJy4vYWR0cyc7XHJcbiBpbXBvcnQgTXBlZ0F1ZGlvIGZyb20gJy4vbXBlZ2F1ZGlvJztcclxuIGltcG9ydCBFdmVudCBmcm9tICcuLi9ldmVudHMnO1xyXG4gaW1wb3J0IEV4cEdvbG9tYiBmcm9tICcuL2V4cC1nb2xvbWInO1xyXG4gaW1wb3J0IFNhbXBsZUFlc0RlY3J5cHRlciBmcm9tICcuL3NhbXBsZS1hZXMnO1xyXG4vLyBpbXBvcnQgSGV4IGZyb20gJy4uL3V0aWxzL2hleCc7XHJcbiBpbXBvcnQge2xvZ2dlcn0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcclxuIGltcG9ydCB7RXJyb3JUeXBlcywgRXJyb3JEZXRhaWxzfSBmcm9tICcuLi9lcnJvcnMnO1xyXG5cclxuIGNsYXNzIFRTRGVtdXhlciB7XHJcblxyXG4gIGNvbnN0cnVjdG9yKG9ic2VydmVyLCByZW11eGVyLCBjb25maWcsIHR5cGVTdXBwb3J0ZWQpIHtcclxuICAgIHRoaXMub2JzZXJ2ZXIgPSBvYnNlcnZlcjtcclxuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xyXG4gICAgdGhpcy50eXBlU3VwcG9ydGVkID0gdHlwZVN1cHBvcnRlZDtcclxuICAgIHRoaXMucmVtdXhlciA9IHJlbXV4ZXI7XHJcbiAgICB0aGlzLnNhbXBsZUFlcyA9IG51bGw7XHJcbiAgfVxyXG5cclxuICBzZXREZWNyeXB0RGF0YShkZWNyeXB0ZGF0YSkge1xyXG4gICAgaWYgKChkZWNyeXB0ZGF0YSAhPSBudWxsKSAmJiAoZGVjcnlwdGRhdGEua2V5ICE9IG51bGwpICYmIChkZWNyeXB0ZGF0YS5tZXRob2QgPT09ICdTQU1QTEUtQUVTJykpIHtcclxuICAgICAgdGhpcy5zYW1wbGVBZXMgPSBuZXcgU2FtcGxlQWVzRGVjcnlwdGVyKHRoaXMub2JzZXJ2ZXIsIHRoaXMuY29uZmlnLCBkZWNyeXB0ZGF0YSwgdGhpcy5kaXNjYXJkRVBCKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuc2FtcGxlQWVzID0gbnVsbDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHN0YXRpYyBwcm9iZShkYXRhKSB7XHJcbiAgICAvLyBhIFRTIGZyYWdtZW50IHNob3VsZCBjb250YWluIGF0IGxlYXN0IDMgVFMgcGFja2V0cywgYSBQQVQsIGEgUE1ULCBhbmQgb25lIFBJRCwgZWFjaCBzdGFydGluZyB3aXRoIDB4NDdcclxuICAgIGlmIChkYXRhLmxlbmd0aCA+PSAzKjE4OCAmJiBkYXRhWzBdID09PSAweDQ3ICYmIGRhdGFbMTg4XSA9PT0gMHg0NyAmJiBkYXRhWzIqMTg4XSA9PT0gMHg0Nykge1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJlc2V0SW5pdFNlZ21lbnQoaW5pdFNlZ21lbnQsYXVkaW9Db2RlYyx2aWRlb0NvZGVjLCBkdXJhdGlvbikge1xyXG4gICAgdGhpcy5wbXRQYXJzZWQgPSBmYWxzZTtcclxuICAgIHRoaXMuX3BtdElkID0gLTE7XHJcbiAgICB0aGlzLl9hdmNUcmFjayA9IHtjb250YWluZXIgOiAndmlkZW8vbXAydCcsIHR5cGU6ICd2aWRlbycsIGlkIDotMSwgaW5wdXRUaW1lU2NhbGUgOiA5MDAwMCwgc2VxdWVuY2VOdW1iZXI6IDAsIHNhbXBsZXMgOiBbXSwgbGVuIDogMCwgZHJvcHBlZCA6IDB9O1xyXG4gICAgdGhpcy5fYXVkaW9UcmFjayA9IHtjb250YWluZXIgOiAndmlkZW8vbXAydCcsIHR5cGU6ICdhdWRpbycsIGlkIDotMSwgaW5wdXRUaW1lU2NhbGUgOiA5MDAwMCwgZHVyYXRpb246IGR1cmF0aW9uLCBzZXF1ZW5jZU51bWJlcjogMCwgc2FtcGxlcyA6IFtdLCBsZW4gOiAwLCBpc0FBQzogdHJ1ZX07XHJcbiAgICB0aGlzLl9pZDNUcmFjayA9IHt0eXBlOiAnaWQzJywgaWQgOi0xLCBpbnB1dFRpbWVTY2FsZSA6IDkwMDAwLCBzZXF1ZW5jZU51bWJlcjogMCwgc2FtcGxlcyA6IFtdLCBsZW4gOiAwfTtcclxuICAgIHRoaXMuX3R4dFRyYWNrID0ge3R5cGU6ICd0ZXh0JywgaWQ6IC0xLCBpbnB1dFRpbWVTY2FsZSA6IDkwMDAwLCBzZXF1ZW5jZU51bWJlcjogMCwgc2FtcGxlcyA6IFtdLCBsZW4gOiAwfTtcclxuICAgIC8vIGZsdXNoIGFueSBwYXJ0aWFsIGNvbnRlbnRcclxuICAgIHRoaXMuYWFjT3ZlckZsb3cgPSBudWxsO1xyXG4gICAgdGhpcy5hYWNMYXN0UFRTID0gbnVsbDtcclxuICAgIHRoaXMuYXZjU2FtcGxlID0gbnVsbDtcclxuICAgIHRoaXMuYXVkaW9Db2RlYyA9IGF1ZGlvQ29kZWM7XHJcbiAgICB0aGlzLnZpZGVvQ29kZWMgPSB2aWRlb0NvZGVjO1xyXG4gICAgdGhpcy5fZHVyYXRpb24gPSBkdXJhdGlvbjtcclxuICB9XHJcblxyXG4gIHJlc2V0VGltZVN0YW1wKCkge1xyXG4gIH1cclxuXHJcbiAgLy8gZmVlZCBpbmNvbWluZyBkYXRhIHRvIHRoZSBmcm9udCBvZiB0aGUgcGFyc2luZyBwaXBlbGluZVxyXG4gIGFwcGVuZChkYXRhLCB0aW1lT2Zmc2V0LCBjb250aWd1b3VzLGFjY3VyYXRlVGltZU9mZnNldCkge1xyXG4gICAgdmFyIHN0YXJ0LCBsZW4gPSBkYXRhLmxlbmd0aCwgc3R0LCBwaWQsIGF0Ziwgb2Zmc2V0LHBlcyxcclxuICAgICAgICB1bmtub3duUElEcyA9IGZhbHNlO1xyXG4gICAgdGhpcy5jb250aWd1b3VzID0gY29udGlndW91cztcclxuICAgIHZhciBwbXRQYXJzZWQgPSB0aGlzLnBtdFBhcnNlZCxcclxuICAgICAgICBhdmNUcmFjayA9IHRoaXMuX2F2Y1RyYWNrLFxyXG4gICAgICAgIGF1ZGlvVHJhY2sgPSB0aGlzLl9hdWRpb1RyYWNrLFxyXG4gICAgICAgIGlkM1RyYWNrID0gdGhpcy5faWQzVHJhY2ssXHJcbiAgICAgICAgYXZjSWQgPSBhdmNUcmFjay5pZCxcclxuICAgICAgICBhdWRpb0lkID0gYXVkaW9UcmFjay5pZCxcclxuICAgICAgICBpZDNJZCA9IGlkM1RyYWNrLmlkLFxyXG4gICAgICAgIHBtdElkID0gdGhpcy5fcG10SWQsXHJcbiAgICAgICAgYXZjRGF0YSA9IGF2Y1RyYWNrLnBlc0RhdGEsXHJcbiAgICAgICAgYXVkaW9EYXRhID0gYXVkaW9UcmFjay5wZXNEYXRhLFxyXG4gICAgICAgIGlkM0RhdGEgPSBpZDNUcmFjay5wZXNEYXRhLFxyXG4gICAgICAgIHBhcnNlUEFUID0gdGhpcy5fcGFyc2VQQVQsXHJcbiAgICAgICAgcGFyc2VQTVQgPSB0aGlzLl9wYXJzZVBNVCxcclxuICAgICAgICBwYXJzZVBFUyA9IHRoaXMuX3BhcnNlUEVTLFxyXG4gICAgICAgIHBhcnNlQVZDUEVTID0gdGhpcy5fcGFyc2VBVkNQRVMuYmluZCh0aGlzKSxcclxuICAgICAgICBwYXJzZUFBQ1BFUyA9IHRoaXMuX3BhcnNlQUFDUEVTLmJpbmQodGhpcyksXHJcbiAgICAgICAgcGFyc2VNUEVHUEVTID0gdGhpcy5fcGFyc2VNUEVHUEVTLmJpbmQodGhpcyksXHJcbiAgICAgICAgcGFyc2VJRDNQRVMgID0gdGhpcy5fcGFyc2VJRDNQRVMuYmluZCh0aGlzKTtcclxuXHJcbiAgICAvLyBkb24ndCBwYXJzZSBsYXN0IFRTIHBhY2tldCBpZiBpbmNvbXBsZXRlXHJcbiAgICBsZW4gLT0gbGVuICUgMTg4O1xyXG4gICAgLy8gbG9vcCB0aHJvdWdoIFRTIHBhY2tldHNcclxuICAgIGZvciAoc3RhcnQgPSAwOyBzdGFydCA8IGxlbjsgc3RhcnQgKz0gMTg4KSB7XHJcbiAgICAgIGlmIChkYXRhW3N0YXJ0XSA9PT0gMHg0Nykge1xyXG4gICAgICAgIHN0dCA9ICEhKGRhdGFbc3RhcnQgKyAxXSAmIDB4NDApO1xyXG4gICAgICAgIC8vIHBpZCBpcyBhIDEzLWJpdCBmaWVsZCBzdGFydGluZyBhdCB0aGUgbGFzdCBiaXQgb2YgVFNbMV1cclxuICAgICAgICBwaWQgPSAoKGRhdGFbc3RhcnQgKyAxXSAmIDB4MWYpIDw8IDgpICsgZGF0YVtzdGFydCArIDJdO1xyXG4gICAgICAgIGF0ZiA9IChkYXRhW3N0YXJ0ICsgM10gJiAweDMwKSA+PiA0O1xyXG4gICAgICAgIC8vIGlmIGFuIGFkYXB0aW9uIGZpZWxkIGlzIHByZXNlbnQsIGl0cyBsZW5ndGggaXMgc3BlY2lmaWVkIGJ5IHRoZSBmaWZ0aCBieXRlIG9mIHRoZSBUUyBwYWNrZXQgaGVhZGVyLlxyXG4gICAgICAgIGlmIChhdGYgPiAxKSB7XHJcbiAgICAgICAgICBvZmZzZXQgPSBzdGFydCArIDUgKyBkYXRhW3N0YXJ0ICsgNF07XHJcbiAgICAgICAgICAvLyBjb250aW51ZSBpZiB0aGVyZSBpcyBvbmx5IGFkYXB0YXRpb24gZmllbGRcclxuICAgICAgICAgIGlmIChvZmZzZXQgPT09IChzdGFydCArIDE4OCkpIHtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIG9mZnNldCA9IHN0YXJ0ICsgNDtcclxuICAgICAgICB9XHJcbiAgICAgICAgc3dpdGNoKHBpZCkge1xyXG4gICAgICAgICAgY2FzZSBhdmNJZDpcclxuICAgICAgICAgICAgaWYgKHN0dCkge1xyXG4gICAgICAgICAgICAgIGlmIChhdmNEYXRhICYmIChwZXMgPSBwYXJzZVBFUyhhdmNEYXRhKSkpIHtcclxuICAgICAgICAgICAgICAgIHBhcnNlQVZDUEVTKHBlcyxmYWxzZSk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGF2Y0RhdGEgPSB7ZGF0YTogW10sIHNpemU6IDB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChhdmNEYXRhKSB7XHJcbiAgICAgICAgICAgICAgYXZjRGF0YS5kYXRhLnB1c2goZGF0YS5zdWJhcnJheShvZmZzZXQsIHN0YXJ0ICsgMTg4KSk7XHJcbiAgICAgICAgICAgICAgYXZjRGF0YS5zaXplICs9IHN0YXJ0ICsgMTg4IC0gb2Zmc2V0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgY2FzZSBhdWRpb0lkOlxyXG4gICAgICAgICAgICBpZiAoc3R0KSB7XHJcbiAgICAgICAgICAgICAgaWYgKGF1ZGlvRGF0YSAmJiAocGVzID0gcGFyc2VQRVMoYXVkaW9EYXRhKSkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChhdWRpb1RyYWNrLmlzQUFDKSB7XHJcbiAgICAgICAgICAgICAgICAgIHBhcnNlQUFDUEVTKHBlcyk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICBwYXJzZU1QRUdQRVMocGVzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgYXVkaW9EYXRhID0ge2RhdGE6IFtdLCBzaXplOiAwfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoYXVkaW9EYXRhKSB7XHJcbiAgICAgICAgICAgICAgYXVkaW9EYXRhLmRhdGEucHVzaChkYXRhLnN1YmFycmF5KG9mZnNldCwgc3RhcnQgKyAxODgpKTtcclxuICAgICAgICAgICAgICBhdWRpb0RhdGEuc2l6ZSArPSBzdGFydCArIDE4OCAtIG9mZnNldDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGNhc2UgaWQzSWQ6XHJcbiAgICAgICAgICAgIGlmIChzdHQpIHtcclxuICAgICAgICAgICAgICBpZiAoaWQzRGF0YSAmJiAocGVzID0gcGFyc2VQRVMoaWQzRGF0YSkpKSB7XHJcbiAgICAgICAgICAgICAgICBwYXJzZUlEM1BFUyhwZXMpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBpZDNEYXRhID0ge2RhdGE6IFtdLCBzaXplOiAwfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoaWQzRGF0YSkge1xyXG4gICAgICAgICAgICAgIGlkM0RhdGEuZGF0YS5wdXNoKGRhdGEuc3ViYXJyYXkob2Zmc2V0LCBzdGFydCArIDE4OCkpO1xyXG4gICAgICAgICAgICAgIGlkM0RhdGEuc2l6ZSArPSBzdGFydCArIDE4OCAtIG9mZnNldDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgaWYgKHN0dCkge1xyXG4gICAgICAgICAgICAgIG9mZnNldCArPSBkYXRhW29mZnNldF0gKyAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHBtdElkID0gdGhpcy5fcG10SWQgPSBwYXJzZVBBVChkYXRhLCBvZmZzZXQpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGNhc2UgcG10SWQ6XHJcbiAgICAgICAgICAgIGlmIChzdHQpIHtcclxuICAgICAgICAgICAgICBvZmZzZXQgKz0gZGF0YVtvZmZzZXRdICsgMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgcGFyc2VkUElEcyA9IHBhcnNlUE1UKGRhdGEsIG9mZnNldCwgdGhpcy50eXBlU3VwcG9ydGVkLm1wZWcgPT09IHRydWUgfHwgdGhpcy50eXBlU3VwcG9ydGVkLm1wMyA9PT0gdHJ1ZSwgdGhpcy5zYW1wbGVBZXMgIT0gbnVsbCk7XHJcblxyXG4gICAgICAgICAgICAvLyBvbmx5IHVwZGF0ZSB0cmFjayBpZCBpZiB0cmFjayBQSUQgZm91bmQgd2hpbGUgcGFyc2luZyBQTVRcclxuICAgICAgICAgICAgLy8gdGhpcyBpcyB0byBhdm9pZCByZXNldHRpbmcgdGhlIFBJRCB0byAtMSBpbiBjYXNlXHJcbiAgICAgICAgICAgIC8vIHRyYWNrIFBJRCB0cmFuc2llbnRseSBkaXNhcHBlYXJzIGZyb20gdGhlIHN0cmVhbVxyXG4gICAgICAgICAgICAvLyB0aGlzIGNvdWxkIGhhcHBlbiBpbiBjYXNlIG9mIHRyYW5zaWVudCBtaXNzaW5nIGF1ZGlvIHNhbXBsZXMgZm9yIGV4YW1wbGVcclxuICAgICAgICAgICAgYXZjSWQgPSBwYXJzZWRQSURzLmF2YztcclxuICAgICAgICAgICAgaWYgKGF2Y0lkID4gMCkge1xyXG4gICAgICAgICAgICAgIGF2Y1RyYWNrLmlkID0gYXZjSWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYXVkaW9JZCA9IHBhcnNlZFBJRHMuYXVkaW87XHJcbiAgICAgICAgICAgIGlmIChhdWRpb0lkID4gMCkge1xyXG4gICAgICAgICAgICAgIGF1ZGlvVHJhY2suaWQgPSBhdWRpb0lkO1xyXG4gICAgICAgICAgICAgIGF1ZGlvVHJhY2suaXNBQUMgPSBwYXJzZWRQSURzLmlzQUFDO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlkM0lkID0gcGFyc2VkUElEcy5pZDM7XHJcbiAgICAgICAgICAgIGlmIChpZDNJZCA+IDApIHtcclxuICAgICAgICAgICAgICBpZDNUcmFjay5pZCA9IGlkM0lkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh1bmtub3duUElEcyAmJiAhcG10UGFyc2VkKSB7XHJcbiAgICAgICAgICAgICAgbG9nZ2VyLmxvZygncmVwYXJzZSBmcm9tIGJlZ2lubmluZycpO1xyXG4gICAgICAgICAgICAgIHVua25vd25QSURzID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgLy8gd2Ugc2V0IGl0IHRvIC0xODgsIHRoZSArPSAxODggaW4gdGhlIGZvciBsb29wIHdpbGwgcmVzZXQgc3RhcnQgdG8gMFxyXG4gICAgICAgICAgICAgIHN0YXJ0ID0gLTE4ODtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBwbXRQYXJzZWQgPSB0aGlzLnBtdFBhcnNlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgY2FzZSAxNzpcclxuICAgICAgICAgIGNhc2UgMHgxZmZmOlxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIHVua25vd25QSURzID0gdHJ1ZTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMub2JzZXJ2ZXIudHJpZ2dlcihFdmVudC5FUlJPUiwge3R5cGUgOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLCBkZXRhaWxzOiBFcnJvckRldGFpbHMuRlJBR19QQVJTSU5HX0VSUk9SLCBmYXRhbDogZmFsc2UsIHJlYXNvbjogJ1RTIHBhY2tldCBkaWQgbm90IHN0YXJ0IHdpdGggMHg0Nyd9KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gdHJ5IHRvIHBhcnNlIGxhc3QgUEVTIHBhY2tldHNcclxuICAgIGlmIChhdmNEYXRhICYmIChwZXMgPSBwYXJzZVBFUyhhdmNEYXRhKSkpIHtcclxuICAgICAgcGFyc2VBVkNQRVMocGVzLHRydWUpO1xyXG4gICAgICBhdmNUcmFjay5wZXNEYXRhID0gbnVsbDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIGVpdGhlciBhdmNEYXRhIG51bGwgb3IgUEVTIHRydW5jYXRlZCwga2VlcCBpdCBmb3IgbmV4dCBmcmFnIHBhcnNpbmdcclxuICAgICAgYXZjVHJhY2sucGVzRGF0YSA9IGF2Y0RhdGE7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGF1ZGlvRGF0YSAmJiAocGVzID0gcGFyc2VQRVMoYXVkaW9EYXRhKSkpIHtcclxuICAgICAgaWYgKGF1ZGlvVHJhY2suaXNBQUMpIHtcclxuICAgICAgICBwYXJzZUFBQ1BFUyhwZXMpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHBhcnNlTVBFR1BFUyhwZXMpO1xyXG4gICAgICB9XHJcbiAgICAgIGF1ZGlvVHJhY2sucGVzRGF0YSA9IG51bGw7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBpZiAoYXVkaW9EYXRhICYmIGF1ZGlvRGF0YS5zaXplKSB7XHJcbiAgICAgICAgbG9nZ2VyLmxvZygnbGFzdCBBQUMgUEVTIHBhY2tldCB0cnVuY2F0ZWQsbWlnaHQgb3ZlcmxhcCBiZXR3ZWVuIGZyYWdtZW50cycpO1xyXG4gICAgICB9XHJcbiAgICAgLy8gZWl0aGVyIGF1ZGlvRGF0YSBudWxsIG9yIFBFUyB0cnVuY2F0ZWQsIGtlZXAgaXQgZm9yIG5leHQgZnJhZyBwYXJzaW5nXHJcbiAgICAgIGF1ZGlvVHJhY2sucGVzRGF0YSA9IGF1ZGlvRGF0YTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoaWQzRGF0YSAmJiAocGVzID0gcGFyc2VQRVMoaWQzRGF0YSkpKSB7XHJcbiAgICAgIHBhcnNlSUQzUEVTKHBlcyk7XHJcbiAgICAgIGlkM1RyYWNrLnBlc0RhdGEgPSBudWxsO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gZWl0aGVyIGlkM0RhdGEgbnVsbCBvciBQRVMgdHJ1bmNhdGVkLCBrZWVwIGl0IGZvciBuZXh0IGZyYWcgcGFyc2luZ1xyXG4gICAgICBpZDNUcmFjay5wZXNEYXRhID0gaWQzRGF0YTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5zYW1wbGVBZXMgPT0gbnVsbCkge1xyXG4gICAgICB0aGlzLnJlbXV4ZXIucmVtdXgoYXVkaW9UcmFjaywgYXZjVHJhY2ssIGlkM1RyYWNrLCB0aGlzLl90eHRUcmFjaywgdGltZU9mZnNldCwgY29udGlndW91cywgYWNjdXJhdGVUaW1lT2Zmc2V0KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuZGVjcnlwdEFuZFJlbXV4KGF1ZGlvVHJhY2ssIGF2Y1RyYWNrLCBpZDNUcmFjaywgdGhpcy5fdHh0VHJhY2ssIHRpbWVPZmZzZXQsIGNvbnRpZ3VvdXMsIGFjY3VyYXRlVGltZU9mZnNldCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBkZWNyeXB0QW5kUmVtdXgoYXVkaW9UcmFjaywgdmlkZW9UcmFjaywgaWQzVHJhY2ssIHRleHRUcmFjaywgdGltZU9mZnNldCwgY29udGlndW91cywgYWNjdXJhdGVUaW1lT2Zmc2V0KSB7XHJcbiAgICBpZiAoYXVkaW9UcmFjay5zYW1wbGVzICYmIGF1ZGlvVHJhY2suaXNBQUMpIHtcclxuICAgICAgbGV0IGxvY2FsdGhpcyA9IHRoaXM7XHJcbiAgICAgIHRoaXMuc2FtcGxlQWVzLmRlY3J5cHRBYWNTYW1wbGVzKGF1ZGlvVHJhY2suc2FtcGxlcywgMCwgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgbG9jYWx0aGlzLmRlY3J5cHRBbmRSZW11eEF2YyhhdWRpb1RyYWNrLCB2aWRlb1RyYWNrLCBpZDNUcmFjaywgdGV4dFRyYWNrLCB0aW1lT2Zmc2V0LCBjb250aWd1b3VzLCBhY2N1cmF0ZVRpbWVPZmZzZXQpO1xyXG4gICAgICB9KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuZGVjcnlwdEFuZFJlbXV4QXZjKGF1ZGlvVHJhY2ssIHZpZGVvVHJhY2ssIGlkM1RyYWNrLCB0ZXh0VHJhY2ssIHRpbWVPZmZzZXQsIGNvbnRpZ3VvdXMsIGFjY3VyYXRlVGltZU9mZnNldCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBkZWNyeXB0QW5kUmVtdXhBdmMoYXVkaW9UcmFjaywgdmlkZW9UcmFjaywgaWQzVHJhY2ssIHRleHRUcmFjaywgdGltZU9mZnNldCwgY29udGlndW91cywgYWNjdXJhdGVUaW1lT2Zmc2V0KSB7XHJcbiAgICBpZiAodmlkZW9UcmFjay5zYW1wbGVzKSB7XHJcbiAgICAgIGxldCBsb2NhbHRoaXMgPSB0aGlzO1xyXG4gICAgICB0aGlzLnNhbXBsZUFlcy5kZWNyeXB0QXZjU2FtcGxlcyh2aWRlb1RyYWNrLnNhbXBsZXMsIDAsIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBsb2NhbHRoaXMucmVtdXhlci5yZW11eChhdWRpb1RyYWNrLCB2aWRlb1RyYWNrLCBpZDNUcmFjaywgdGV4dFRyYWNrLCB0aW1lT2Zmc2V0LCBjb250aWd1b3VzLCBhY2N1cmF0ZVRpbWVPZmZzZXQpO1xyXG4gICAgICB9KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMucmVtdXhlci5yZW11eChhdWRpb1RyYWNrLCB2aWRlb1RyYWNrLCBpZDNUcmFjaywgdGV4dFRyYWNrLCB0aW1lT2Zmc2V0LCBjb250aWd1b3VzLCBhY2N1cmF0ZVRpbWVPZmZzZXQpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZGVzdHJveSgpIHtcclxuICAgIHRoaXMuX2luaXRQVFMgPSB0aGlzLl9pbml0RFRTID0gdW5kZWZpbmVkO1xyXG4gICAgdGhpcy5fZHVyYXRpb24gPSAwO1xyXG4gIH1cclxuXHJcbiAgX3BhcnNlUEFUKGRhdGEsIG9mZnNldCkge1xyXG4gICAgLy8gc2tpcCB0aGUgUFNJIGhlYWRlciBhbmQgcGFyc2UgdGhlIGZpcnN0IFBNVCBlbnRyeVxyXG4gICAgcmV0dXJuIChkYXRhW29mZnNldCArIDEwXSAmIDB4MUYpIDw8IDggfCBkYXRhW29mZnNldCArIDExXTtcclxuICAgIC8vbG9nZ2VyLmxvZygnUE1UIFBJRDonICArIHRoaXMuX3BtdElkKTtcclxuICB9XHJcblxyXG4gIF9wYXJzZVBNVChkYXRhLCBvZmZzZXQsIG1wZWdTdXBwb3J0ZWQsIGlzU2FtcGxlQWVzKSB7XHJcbiAgICB2YXIgc2VjdGlvbkxlbmd0aCwgdGFibGVFbmQsIHByb2dyYW1JbmZvTGVuZ3RoLCBwaWQsIHJlc3VsdCA9IHsgYXVkaW8gOiAtMSwgYXZjIDogLTEsIGlkMyA6IC0xLCBpc0FBQyA6IHRydWV9O1xyXG4gICAgc2VjdGlvbkxlbmd0aCA9IChkYXRhW29mZnNldCArIDFdICYgMHgwZikgPDwgOCB8IGRhdGFbb2Zmc2V0ICsgMl07XHJcbiAgICB0YWJsZUVuZCA9IG9mZnNldCArIDMgKyBzZWN0aW9uTGVuZ3RoIC0gNDtcclxuICAgIC8vIHRvIGRldGVybWluZSB3aGVyZSB0aGUgdGFibGUgaXMsIHdlIGhhdmUgdG8gZmlndXJlIG91dCBob3dcclxuICAgIC8vIGxvbmcgdGhlIHByb2dyYW0gaW5mbyBkZXNjcmlwdG9ycyBhcmVcclxuICAgIHByb2dyYW1JbmZvTGVuZ3RoID0gKGRhdGFbb2Zmc2V0ICsgMTBdICYgMHgwZikgPDwgOCB8IGRhdGFbb2Zmc2V0ICsgMTFdO1xyXG4gICAgLy8gYWR2YW5jZSB0aGUgb2Zmc2V0IHRvIHRoZSBmaXJzdCBlbnRyeSBpbiB0aGUgbWFwcGluZyB0YWJsZVxyXG4gICAgb2Zmc2V0ICs9IDEyICsgcHJvZ3JhbUluZm9MZW5ndGg7XHJcbiAgICB3aGlsZSAob2Zmc2V0IDwgdGFibGVFbmQpIHtcclxuICAgICAgcGlkID0gKGRhdGFbb2Zmc2V0ICsgMV0gJiAweDFGKSA8PCA4IHwgZGF0YVtvZmZzZXQgKyAyXTtcclxuICAgICAgc3dpdGNoKGRhdGFbb2Zmc2V0XSkge1xyXG4gICAgICAgIGNhc2UgMHhjZjogICAgIC8vIFNBTVBMRS1BRVMgQUFDXHJcbiAgICAgICAgICBpZiAoIWlzU2FtcGxlQWVzKSB7XHJcbiAgICAgICAgICAgIGxvZ2dlci5sb2coJ3Vua293biBzdHJlYW0gdHlwZTonICArIGRhdGFbb2Zmc2V0XSk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xyXG5cclxuICAgICAgICAvLyBJU08vSUVDIDEzODE4LTcgQURUUyBBQUMgKE1QRUctMiBsb3dlciBiaXQtcmF0ZSBhdWRpbylcclxuICAgICAgICBjYXNlIDB4MGY6XHJcbiAgICAgICAgICAvL2xvZ2dlci5sb2coJ0FBQyBQSUQ6JyAgKyBwaWQpO1xyXG4gICAgICAgICAgaWYgKHJlc3VsdC5hdWRpbyA9PT0gLTEpIHtcclxuICAgICAgICAgICAgcmVzdWx0LmF1ZGlvID0gcGlkO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgIC8vIFBhY2tldGl6ZWQgbWV0YWRhdGEgKElEMylcclxuICAgICAgICBjYXNlIDB4MTU6XHJcbiAgICAgICAgICAvL2xvZ2dlci5sb2coJ0lEMyBQSUQ6JyAgKyBwaWQpO1xyXG4gICAgICAgICAgaWYgKHJlc3VsdC5pZDMgPT09IC0xKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5pZDMgPSBwaWQ7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgY2FzZSAweGRiOiAgICAgLy8gU0FNUExFLUFFUyBBVkNcclxuICAgICAgICAgIGlmICghaXNTYW1wbGVBZXMpIHtcclxuICAgICAgICAgICAgbG9nZ2VyLmxvZygndW5rb3duIHN0cmVhbSB0eXBlOicgICsgZGF0YVtvZmZzZXRdKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXHJcblxyXG4gICAgICAgIC8vIElUVS1UIFJlYy4gSC4yNjQgYW5kIElTTy9JRUMgMTQ0OTYtMTAgKGxvd2VyIGJpdC1yYXRlIHZpZGVvKVxyXG4gICAgICAgIGNhc2UgMHgxYjpcclxuICAgICAgICAgIC8vbG9nZ2VyLmxvZygnQVZDIFBJRDonICArIHBpZCk7XHJcbiAgICAgICAgICBpZiAocmVzdWx0LmF2YyA9PT0gLTEpIHtcclxuICAgICAgICAgICAgcmVzdWx0LmF2YyA9IHBpZDtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAvLyBJU08vSUVDIDExMTcyLTMgKE1QRUctMSBhdWRpbylcclxuICAgICAgICAvLyBvciBJU08vSUVDIDEzODE4LTMgKE1QRUctMiBoYWx2ZWQgc2FtcGxlIHJhdGUgYXVkaW8pXHJcbiAgICAgICAgY2FzZSAweDAzOlxyXG4gICAgICAgIGNhc2UgMHgwNDpcclxuICAgICAgICAgIC8vbG9nZ2VyLmxvZygnTVBFRyBQSUQ6JyAgKyBwaWQpO1xyXG4gICAgICAgICAgaWYgKCFtcGVnU3VwcG9ydGVkKSB7XHJcbiAgICAgICAgICAgIGxvZ2dlci5sb2coJ01QRUcgYXVkaW8gZm91bmQsIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBicm93c2VyIGZvciBub3cnKTtcclxuICAgICAgICAgIH0gZWxzZSBpZiAocmVzdWx0LmF1ZGlvID09PSAtMSkge1xyXG4gICAgICAgICAgICByZXN1bHQuYXVkaW8gPSBwaWQ7XHJcbiAgICAgICAgICAgIHJlc3VsdC5pc0FBQyA9IGZhbHNlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgIGNhc2UgMHgyNDpcclxuICAgICAgICAgIGxvZ2dlci53YXJuKCdIRVZDIHN0cmVhbSB0eXBlIGZvdW5kLCBub3Qgc3VwcG9ydGVkIGZvciBub3cnKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgbG9nZ2VyLmxvZygndW5rb3duIHN0cmVhbSB0eXBlOicgICsgZGF0YVtvZmZzZXRdKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICAgIC8vIG1vdmUgdG8gdGhlIG5leHQgdGFibGUgZW50cnlcclxuICAgICAgLy8gc2tpcCBwYXN0IHRoZSBlbGVtZW50YXJ5IHN0cmVhbSBkZXNjcmlwdG9ycywgaWYgcHJlc2VudFxyXG4gICAgICBvZmZzZXQgKz0gKChkYXRhW29mZnNldCArIDNdICYgMHgwRikgPDwgOCB8IGRhdGFbb2Zmc2V0ICsgNF0pICsgNTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbiAgfVxyXG5cclxuICBfcGFyc2VQRVMoc3RyZWFtKSB7XHJcbiAgICB2YXIgaSA9IDAsIGZyYWcsIHBlc0ZsYWdzLCBwZXNQcmVmaXgsIHBlc0xlbiwgcGVzSGRyTGVuLCBwZXNEYXRhLCBwZXNQdHMsIHBlc0R0cywgcGF5bG9hZFN0YXJ0T2Zmc2V0LCBkYXRhID0gc3RyZWFtLmRhdGE7XHJcbiAgICAvLyBzYWZldHkgY2hlY2tcclxuICAgIGlmICghc3RyZWFtIHx8IHN0cmVhbS5zaXplID09PSAwKSB7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHdlIG1pZ2h0IG5lZWQgdXAgdG8gMTkgYnl0ZXMgdG8gcmVhZCBQRVMgaGVhZGVyXHJcbiAgICAvLyBpZiBmaXJzdCBjaHVuayBvZiBkYXRhIGlzIGxlc3MgdGhhbiAxOSBieXRlcywgbGV0J3MgbWVyZ2UgaXQgd2l0aCBmb2xsb3dpbmcgb25lcyB1bnRpbCB3ZSBnZXQgMTkgYnl0ZXNcclxuICAgIC8vIHVzdWFsbHkgb25seSBvbmUgbWVyZ2UgaXMgbmVlZGVkIChhbmQgdGhpcyBpcyByYXJlIC4uLilcclxuICAgIHdoaWxlKGRhdGFbMF0ubGVuZ3RoIDwgMTkgJiYgZGF0YS5sZW5ndGggPiAxKSB7XHJcbiAgICAgIGxldCBuZXdEYXRhID0gbmV3IFVpbnQ4QXJyYXkoZGF0YVswXS5sZW5ndGggKyBkYXRhWzFdLmxlbmd0aCk7XHJcbiAgICAgIG5ld0RhdGEuc2V0KGRhdGFbMF0pO1xyXG4gICAgICBuZXdEYXRhLnNldChkYXRhWzFdLCBkYXRhWzBdLmxlbmd0aCk7XHJcbiAgICAgIGRhdGFbMF0gPSBuZXdEYXRhO1xyXG4gICAgICBkYXRhLnNwbGljZSgxLDEpO1xyXG4gICAgfVxyXG4gICAgLy9yZXRyaWV2ZSBQVFMvRFRTIGZyb20gZmlyc3QgZnJhZ21lbnRcclxuICAgIGZyYWcgPSBkYXRhWzBdO1xyXG4gICAgcGVzUHJlZml4ID0gKGZyYWdbMF0gPDwgMTYpICsgKGZyYWdbMV0gPDwgOCkgKyBmcmFnWzJdO1xyXG4gICAgaWYgKHBlc1ByZWZpeCA9PT0gMSkge1xyXG4gICAgICBwZXNMZW4gPSAoZnJhZ1s0XSA8PCA4KSArIGZyYWdbNV07XHJcbiAgICAgIC8vIGlmIFBFUyBwYXJzZWQgbGVuZ3RoIGlzIG5vdCB6ZXJvIGFuZCBncmVhdGVyIHRoYW4gdG90YWwgcmVjZWl2ZWQgbGVuZ3RoLCBzdG9wIHBhcnNpbmcuIFBFUyBtaWdodCBiZSB0cnVuY2F0ZWRcclxuICAgICAgLy8gbWludXMgNiA6IFBFUyBoZWFkZXIgc2l6ZVxyXG4gICAgICBpZiAocGVzTGVuICYmIHBlc0xlbiA+IHN0cmVhbS5zaXplIC0gNikge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICB9XHJcbiAgICAgIHBlc0ZsYWdzID0gZnJhZ1s3XTtcclxuICAgICAgaWYgKHBlc0ZsYWdzICYgMHhDMCkge1xyXG4gICAgICAgIC8qIFBFUyBoZWFkZXIgZGVzY3JpYmVkIGhlcmUgOiBodHRwOi8vZHZkLnNvdXJjZWZvcmdlLm5ldC9kdmRpbmZvL3Blcy1oZHIuaHRtbFxyXG4gICAgICAgICAgICBhcyBQVFMgLyBEVFMgaXMgMzMgYml0IHdlIGNhbm5vdCB1c2UgYml0d2lzZSBvcGVyYXRvciBpbiBKUyxcclxuICAgICAgICAgICAgYXMgQml0d2lzZSBvcGVyYXRvcnMgdHJlYXQgdGhlaXIgb3BlcmFuZHMgYXMgYSBzZXF1ZW5jZSBvZiAzMiBiaXRzICovXHJcbiAgICAgICAgcGVzUHRzID0gKGZyYWdbOV0gJiAweDBFKSAqIDUzNjg3MDkxMiArLy8gMSA8PCAyOVxyXG4gICAgICAgICAgKGZyYWdbMTBdICYgMHhGRikgKiA0MTk0MzA0ICsvLyAxIDw8IDIyXHJcbiAgICAgICAgICAoZnJhZ1sxMV0gJiAweEZFKSAqIDE2Mzg0ICsvLyAxIDw8IDE0XHJcbiAgICAgICAgICAoZnJhZ1sxMl0gJiAweEZGKSAqIDEyOCArLy8gMSA8PCA3XHJcbiAgICAgICAgICAoZnJhZ1sxM10gJiAweEZFKSAvIDI7XHJcbiAgICAgICAgICAvLyBjaGVjayBpZiBncmVhdGVyIHRoYW4gMl4zMiAtMVxyXG4gICAgICAgICAgaWYgKHBlc1B0cyA+IDQyOTQ5NjcyOTUpIHtcclxuICAgICAgICAgICAgLy8gZGVjcmVtZW50IDJeMzNcclxuICAgICAgICAgICAgcGVzUHRzIC09IDg1ODk5MzQ1OTI7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgaWYgKHBlc0ZsYWdzICYgMHg0MCkge1xyXG4gICAgICAgICAgcGVzRHRzID0gKGZyYWdbMTRdICYgMHgwRSApICogNTM2ODcwOTEyICsvLyAxIDw8IDI5XHJcbiAgICAgICAgICAgIChmcmFnWzE1XSAmIDB4RkYgKSAqIDQxOTQzMDQgKy8vIDEgPDwgMjJcclxuICAgICAgICAgICAgKGZyYWdbMTZdICYgMHhGRSApICogMTYzODQgKy8vIDEgPDwgMTRcclxuICAgICAgICAgICAgKGZyYWdbMTddICYgMHhGRiApICogMTI4ICsvLyAxIDw8IDdcclxuICAgICAgICAgICAgKGZyYWdbMThdICYgMHhGRSApIC8gMjtcclxuICAgICAgICAgIC8vIGNoZWNrIGlmIGdyZWF0ZXIgdGhhbiAyXjMyIC0xXHJcbiAgICAgICAgICBpZiAocGVzRHRzID4gNDI5NDk2NzI5NSkge1xyXG4gICAgICAgICAgICAvLyBkZWNyZW1lbnQgMl4zM1xyXG4gICAgICAgICAgICBwZXNEdHMgLT0gODU4OTkzNDU5MjtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmIChwZXNQdHMgLSBwZXNEdHMgPiA2MCo5MDAwMCkge1xyXG4gICAgICAgICAgICBsb2dnZXIud2FybihgJHtNYXRoLnJvdW5kKChwZXNQdHMgLSBwZXNEdHMpLzkwMDAwKX1zIGRlbHRhIGJldHdlZW4gUFRTIGFuZCBEVFMsIGFsaWduIHRoZW1gKTtcclxuICAgICAgICAgICAgcGVzUHRzID0gcGVzRHRzO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBwZXNEdHMgPSBwZXNQdHM7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHBlc0hkckxlbiA9IGZyYWdbOF07XHJcbiAgICAgIC8vIDkgYnl0ZXMgOiA2IGJ5dGVzIGZvciBQRVMgaGVhZGVyICsgMyBieXRlcyBmb3IgUEVTIGV4dGVuc2lvblxyXG4gICAgICBwYXlsb2FkU3RhcnRPZmZzZXQgPSBwZXNIZHJMZW4gKyA5O1xyXG5cclxuICAgICAgc3RyZWFtLnNpemUgLT0gcGF5bG9hZFN0YXJ0T2Zmc2V0O1xyXG4gICAgICAvL3JlYXNzZW1ibGUgUEVTIHBhY2tldFxyXG4gICAgICBwZXNEYXRhID0gbmV3IFVpbnQ4QXJyYXkoc3RyZWFtLnNpemUpO1xyXG4gICAgICBmb3IoIGxldCBqID0gMCwgZGF0YUxlbiA9IGRhdGEubGVuZ3RoOyBqIDwgZGF0YUxlbiA7IGorKykge1xyXG4gICAgICAgIGZyYWcgPSBkYXRhW2pdO1xyXG4gICAgICAgIGxldCBsZW4gPSBmcmFnLmJ5dGVMZW5ndGg7XHJcbiAgICAgICAgaWYgKHBheWxvYWRTdGFydE9mZnNldCkge1xyXG4gICAgICAgICAgaWYgKHBheWxvYWRTdGFydE9mZnNldCA+IGxlbikge1xyXG4gICAgICAgICAgICAvLyB0cmltIGZ1bGwgZnJhZyBpZiBQRVMgaGVhZGVyIGJpZ2dlciB0aGFuIGZyYWdcclxuICAgICAgICAgICAgcGF5bG9hZFN0YXJ0T2Zmc2V0LT1sZW47XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gdHJpbSBwYXJ0aWFsIGZyYWcgaWYgUEVTIGhlYWRlciBzbWFsbGVyIHRoYW4gZnJhZ1xyXG4gICAgICAgICAgICBmcmFnID0gZnJhZy5zdWJhcnJheShwYXlsb2FkU3RhcnRPZmZzZXQpO1xyXG4gICAgICAgICAgICBsZW4tPXBheWxvYWRTdGFydE9mZnNldDtcclxuICAgICAgICAgICAgcGF5bG9hZFN0YXJ0T2Zmc2V0ID0gMDtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcGVzRGF0YS5zZXQoZnJhZywgaSk7XHJcbiAgICAgICAgaSs9bGVuO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChwZXNMZW4pIHtcclxuICAgICAgICAvLyBwYXlsb2FkIHNpemUgOiByZW1vdmUgUEVTIGhlYWRlciArIFBFUyBleHRlbnNpb25cclxuICAgICAgICBwZXNMZW4gLT0gcGVzSGRyTGVuKzM7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHtkYXRhOiBwZXNEYXRhLCBwdHM6IHBlc1B0cywgZHRzOiBwZXNEdHMsIGxlbjogcGVzTGVufTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcHVzaEFjY2VzVW5pdChhdmNTYW1wbGUsYXZjVHJhY2spIHtcclxuICAgIGlmIChhdmNTYW1wbGUudW5pdHMubGVuZ3RoICYmIGF2Y1NhbXBsZS5mcmFtZSkge1xyXG4gICAgICBjb25zdCBzYW1wbGVzID0gYXZjVHJhY2suc2FtcGxlcztcclxuICAgICAgY29uc3QgbmJTYW1wbGVzID0gc2FtcGxlcy5sZW5ndGg7XHJcbiAgICAgIC8vIG9ubHkgcHVzaCBBVkMgc2FtcGxlIGlmIHN0YXJ0aW5nIHdpdGggYSBrZXlmcmFtZSBpcyBub3QgbWFuZGF0b3J5IE9SXHJcbiAgICAgIC8vICAgIGlmIGtleWZyYW1lIGFscmVhZHkgZm91bmQgaW4gdGhpcyBmcmFnbWVudCBPUlxyXG4gICAgICAvLyAgICAgICBrZXlmcmFtZSBmb3VuZCBpbiBsYXN0IGZyYWdtZW50ICh0cmFjay5zcHMpIEFORFxyXG4gICAgICAvLyAgICAgICAgICBzYW1wbGVzIGFscmVhZHkgYXBwZW5kZWQgKHdlIGFscmVhZHkgZm91bmQgYSBrZXlmcmFtZSBpbiB0aGlzIGZyYWdtZW50KSBPUiBmcmFnbWVudCBpcyBjb250aWd1b3VzXHJcbiAgICAgIGlmICghdGhpcy5jb25maWcuZm9yY2VLZXlGcmFtZU9uRGlzY29udGludWl0eSB8fFxyXG4gICAgICAgICAgYXZjU2FtcGxlLmtleSA9PT0gdHJ1ZSB8fFxyXG4gICAgICAgICAgKGF2Y1RyYWNrLnNwcyAmJiAobmJTYW1wbGVzIHx8IHRoaXMuY29udGlndW91cykpKSB7XHJcbiAgICAgICAgYXZjU2FtcGxlLmlkID0gbmJTYW1wbGVzO1xyXG4gICAgICAgIHNhbXBsZXMucHVzaChhdmNTYW1wbGUpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIGRyb3BwZWQgc2FtcGxlcywgdHJhY2sgaXRcclxuICAgICAgICBhdmNUcmFjay5kcm9wcGVkKys7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGlmKGF2Y1NhbXBsZS5kZWJ1Zy5sZW5ndGgpIHtcclxuICAgICAgbG9nZ2VyLmxvZyhhdmNTYW1wbGUucHRzICsgJy8nICsgYXZjU2FtcGxlLmR0cyArICc6JyArIGF2Y1NhbXBsZS5kZWJ1Zyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBfcGFyc2VBVkNQRVMocGVzLGxhc3QpIHtcclxuICAgIC8vbG9nZ2VyLmxvZygncGFyc2UgbmV3IFBFUycpO1xyXG4gICAgdmFyIHRyYWNrID0gdGhpcy5fYXZjVHJhY2ssXHJcbiAgICAgICAgdW5pdHMgPSB0aGlzLl9wYXJzZUFWQ05BTHUocGVzLmRhdGEpLFxyXG4gICAgICAgIGRlYnVnID0gZmFsc2UsXHJcbiAgICAgICAgZXhwR29sb21iRGVjb2RlcixcclxuICAgICAgICBhdmNTYW1wbGUgPSB0aGlzLmF2Y1NhbXBsZSxcclxuICAgICAgICBwdXNoLFxyXG4gICAgICAgIHNwc2ZvdW5kID0gZmFsc2UsXHJcbiAgICAgICAgaTtcclxuICAgIC8vZnJlZSBwZXMuZGF0YSB0byBzYXZlIHVwIHNvbWUgbWVtb3J5XHJcbiAgICBwZXMuZGF0YSA9IG51bGw7XHJcblxyXG4gICAgdW5pdHMuZm9yRWFjaCh1bml0ID0+IHtcclxuICAgICAgc3dpdGNoKHVuaXQudHlwZSkge1xyXG4gICAgICAgIC8vTkRSXHJcbiAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICBwdXNoID0gdHJ1ZTtcclxuICAgICAgICAgICBpZihkZWJ1ZyAmJiBhdmNTYW1wbGUpIHtcclxuICAgICAgICAgICAgYXZjU2FtcGxlLmRlYnVnICs9ICdORFIgJztcclxuICAgICAgICAgICB9XHJcbiAgICAgICAgICAgYXZjU2FtcGxlLmZyYW1lID0gdHJ1ZTtcclxuICAgICAgICAgICBsZXQgZGF0YSA9IHVuaXQuZGF0YTtcclxuICAgICAgICAgICAvLyBvbmx5IGNoZWNrIHNsaWNlIHR5cGUgdG8gZGV0ZWN0IEtGIGluIGNhc2UgU1BTIGZvdW5kIGluIHNhbWUgcGFja2V0IChhbnkga2V5ZnJhbWUgaXMgcHJlY2VkZWQgYnkgU1BTIC4uLilcclxuICAgICAgICAgICBpZiAoc3BzZm91bmQgJiYgZGF0YS5sZW5ndGggPiA0KSB7XHJcbiAgICAgICAgICAgICAvLyByZXRyaWV2ZSBzbGljZSB0eXBlIGJ5IHBhcnNpbmcgYmVnaW5uaW5nIG9mIE5BTCB1bml0IChmb2xsb3cgSDI2NCBzcGVjLCBzbGljZV9oZWFkZXIgZGVmaW5pdGlvbikgdG8gZGV0ZWN0IGtleWZyYW1lIGVtYmVkZGVkIGluIE5EUlxyXG4gICAgICAgICAgICAgbGV0IHNsaWNlVHlwZSA9IG5ldyBFeHBHb2xvbWIoZGF0YSkucmVhZFNsaWNlVHlwZSgpO1xyXG4gICAgICAgICAgICAgLy8gMiA6IEkgc2xpY2UsIDQgOiBTSSBzbGljZSwgNyA6IEkgc2xpY2UsIDk6IFNJIHNsaWNlXHJcbiAgICAgICAgICAgICAvLyBTSSBzbGljZSA6IEEgc2xpY2UgdGhhdCBpcyBjb2RlZCB1c2luZyBpbnRyYSBwcmVkaWN0aW9uIG9ubHkgYW5kIHVzaW5nIHF1YW50aXNhdGlvbiBvZiB0aGUgcHJlZGljdGlvbiBzYW1wbGVzLlxyXG4gICAgICAgICAgICAgLy8gQW4gU0kgc2xpY2UgY2FuIGJlIGNvZGVkIHN1Y2ggdGhhdCBpdHMgZGVjb2RlZCBzYW1wbGVzIGNhbiBiZSBjb25zdHJ1Y3RlZCBpZGVudGljYWxseSB0byBhbiBTUCBzbGljZS5cclxuICAgICAgICAgICAgIC8vIEkgc2xpY2U6IEEgc2xpY2UgdGhhdCBpcyBub3QgYW4gU0kgc2xpY2UgdGhhdCBpcyBkZWNvZGVkIHVzaW5nIGludHJhIHByZWRpY3Rpb24gb25seS5cclxuICAgICAgICAgICAgIC8vaWYgKHNsaWNlVHlwZSA9PT0gMiB8fCBzbGljZVR5cGUgPT09IDcpIHtcclxuICAgICAgICAgICAgIGlmIChzbGljZVR5cGUgPT09IDIgfHwgc2xpY2VUeXBlID09PSA0IHx8IHNsaWNlVHlwZSA9PT0gNyB8fCBzbGljZVR5cGUgPT09IDkpIHtcclxuICAgICAgICAgICAgICAgIGF2Y1NhbXBsZS5rZXkgPSB0cnVlO1xyXG4gICAgICAgICAgICAgfVxyXG4gICAgICAgICAgIH1cclxuICAgICAgICAgICBicmVhaztcclxuICAgICAgICAvL0lEUlxyXG4gICAgICAgIGNhc2UgNTpcclxuICAgICAgICAgIHB1c2ggPSB0cnVlO1xyXG4gICAgICAgICAgLy8gaGFuZGxlIFBFUyBub3Qgc3RhcnRpbmcgd2l0aCBBVURcclxuICAgICAgICAgIGlmICghYXZjU2FtcGxlKSB7XHJcbiAgICAgICAgICAgIGF2Y1NhbXBsZSA9IHRoaXMuYXZjU2FtcGxlID0gdGhpcy5fY3JlYXRlQVZDU2FtcGxlKHRydWUscGVzLnB0cyxwZXMuZHRzLCcnKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmKGRlYnVnKSB7XHJcbiAgICAgICAgICAgIGF2Y1NhbXBsZS5kZWJ1ZyArPSAnSURSICc7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBhdmNTYW1wbGUua2V5ID0gdHJ1ZTtcclxuICAgICAgICAgIGF2Y1NhbXBsZS5mcmFtZSA9IHRydWU7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICAvL1NFSVxyXG4gICAgICAgIGNhc2UgNjpcclxuICAgICAgICAgIHB1c2ggPSB0cnVlO1xyXG4gICAgICAgICAgaWYoZGVidWcgJiYgYXZjU2FtcGxlKSB7XHJcbiAgICAgICAgICAgIGF2Y1NhbXBsZS5kZWJ1ZyArPSAnU0VJICc7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBleHBHb2xvbWJEZWNvZGVyID0gbmV3IEV4cEdvbG9tYih0aGlzLmRpc2NhcmRFUEIodW5pdC5kYXRhKSk7XHJcblxyXG4gICAgICAgICAgLy8gc2tpcCBmcmFtZVR5cGVcclxuICAgICAgICAgIGV4cEdvbG9tYkRlY29kZXIucmVhZFVCeXRlKCk7XHJcblxyXG4gICAgICAgICAgdmFyIHBheWxvYWRUeXBlID0gMDtcclxuICAgICAgICAgIHZhciBwYXlsb2FkU2l6ZSA9IDA7XHJcbiAgICAgICAgICB2YXIgZW5kT2ZDYXB0aW9ucyA9IGZhbHNlO1xyXG4gICAgICAgICAgdmFyIGIgPSAwO1xyXG5cclxuICAgICAgICAgIHdoaWxlICghZW5kT2ZDYXB0aW9ucyAmJiBleHBHb2xvbWJEZWNvZGVyLmJ5dGVzQXZhaWxhYmxlID4gMSkge1xyXG4gICAgICAgICAgICBwYXlsb2FkVHlwZSA9IDA7XHJcbiAgICAgICAgICAgIGRvIHtcclxuICAgICAgICAgICAgICAgIGIgPSBleHBHb2xvbWJEZWNvZGVyLnJlYWRVQnl0ZSgpO1xyXG4gICAgICAgICAgICAgICAgcGF5bG9hZFR5cGUgKz0gYjtcclxuICAgICAgICAgICAgfSB3aGlsZSAoYiA9PT0gMHhGRik7XHJcblxyXG4gICAgICAgICAgICAvLyBQYXJzZSBwYXlsb2FkIHNpemUuXHJcbiAgICAgICAgICAgIHBheWxvYWRTaXplID0gMDtcclxuICAgICAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICAgICAgYiA9IGV4cEdvbG9tYkRlY29kZXIucmVhZFVCeXRlKCk7XHJcbiAgICAgICAgICAgICAgICBwYXlsb2FkU2l6ZSArPSBiO1xyXG4gICAgICAgICAgICB9IHdoaWxlIChiID09PSAweEZGKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFRPRE86IHRoZXJlIGNhbiBiZSBtb3JlIHRoYW4gb25lIHBheWxvYWQgaW4gYW4gU0VJIHBhY2tldC4uLlxyXG4gICAgICAgICAgICAvLyBUT0RPOiBuZWVkIHRvIHJlYWQgdHlwZSBhbmQgc2l6ZSBpbiBhIHdoaWxlIGxvb3AgdG8gZ2V0IHRoZW0gYWxsXHJcbiAgICAgICAgICAgIGlmIChwYXlsb2FkVHlwZSA9PT0gNCAmJiBleHBHb2xvbWJEZWNvZGVyLmJ5dGVzQXZhaWxhYmxlICE9PSAwKSB7XHJcblxyXG4gICAgICAgICAgICAgIGVuZE9mQ2FwdGlvbnMgPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgICB2YXIgY291bnRyeUNvZGUgPSBleHBHb2xvbWJEZWNvZGVyLnJlYWRVQnl0ZSgpO1xyXG5cclxuICAgICAgICAgICAgICBpZiAoY291bnRyeUNvZGUgPT09IDE4MSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHByb3ZpZGVyQ29kZSA9IGV4cEdvbG9tYkRlY29kZXIucmVhZFVTaG9ydCgpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChwcm92aWRlckNvZGUgPT09IDQ5KSB7XHJcbiAgICAgICAgICAgICAgICAgIHZhciB1c2VyU3RydWN0dXJlID0gZXhwR29sb21iRGVjb2Rlci5yZWFkVUludCgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgaWYgKHVzZXJTdHJ1Y3R1cmUgPT09IDB4NDc0MTM5MzQpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdXNlckRhdGFUeXBlID0gZXhwR29sb21iRGVjb2Rlci5yZWFkVUJ5dGUoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUmF3IENFQS02MDggYnl0ZXMgd3JhcHBlZCBpbiBDRUEtNzA4IHBhY2tldFxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh1c2VyRGF0YVR5cGUgPT09IDMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgIHZhciBmaXJzdEJ5dGUgPSBleHBHb2xvbWJEZWNvZGVyLnJlYWRVQnl0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgdmFyIHNlY29uZEJ5dGUgPSBleHBHb2xvbWJEZWNvZGVyLnJlYWRVQnl0ZSgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgIHZhciB0b3RhbENDcyA9IDMxICYgZmlyc3RCeXRlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgdmFyIGJ5dGVBcnJheSA9IFtmaXJzdEJ5dGUsIHNlY29uZEJ5dGVdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB0b3RhbENDczsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIDMgYnl0ZXMgcGVyIENDXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ5dGVBcnJheS5wdXNoKGV4cEdvbG9tYkRlY29kZXIucmVhZFVCeXRlKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBieXRlQXJyYXkucHVzaChleHBHb2xvbWJEZWNvZGVyLnJlYWRVQnl0ZSgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnl0ZUFycmF5LnB1c2goZXhwR29sb21iRGVjb2Rlci5yZWFkVUJ5dGUoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5zZXJ0U2FtcGxlSW5PcmRlcih0aGlzLl90eHRUcmFjay5zYW1wbGVzLCB7IHR5cGU6IDMsIHB0czogcGVzLnB0cywgYnl0ZXM6IGJ5dGVBcnJheSB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAocGF5bG9hZFNpemUgPCBleHBHb2xvbWJEZWNvZGVyLmJ5dGVzQXZhaWxhYmxlKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgZm9yIChpID0gMDsgaTxwYXlsb2FkU2l6ZTsgaSsrKVxyXG4gICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGV4cEdvbG9tYkRlY29kZXIucmVhZFVCeXRlKCk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICAvL1NQU1xyXG4gICAgICAgIGNhc2UgNzpcclxuICAgICAgICAgIHB1c2ggPSB0cnVlO1xyXG4gICAgICAgICAgc3BzZm91bmQgPSB0cnVlO1xyXG4gICAgICAgICAgaWYoZGVidWcgJiYgYXZjU2FtcGxlKSB7XHJcbiAgICAgICAgICAgIGF2Y1NhbXBsZS5kZWJ1ZyArPSAnU1BTICc7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZighdHJhY2suc3BzKSB7XHJcbiAgICAgICAgICAgIGV4cEdvbG9tYkRlY29kZXIgPSBuZXcgRXhwR29sb21iKHVuaXQuZGF0YSk7XHJcbiAgICAgICAgICAgIHZhciBjb25maWcgPSBleHBHb2xvbWJEZWNvZGVyLnJlYWRTUFMoKTtcclxuICAgICAgICAgICAgdHJhY2sud2lkdGggPSBjb25maWcud2lkdGg7XHJcbiAgICAgICAgICAgIHRyYWNrLmhlaWdodCA9IGNvbmZpZy5oZWlnaHQ7XHJcbiAgICAgICAgICAgIHRyYWNrLnBpeGVsUmF0aW8gPSBjb25maWcucGl4ZWxSYXRpbztcclxuICAgICAgICAgICAgdHJhY2suc3BzID0gW3VuaXQuZGF0YV07XHJcbiAgICAgICAgICAgIHRyYWNrLmR1cmF0aW9uID0gdGhpcy5fZHVyYXRpb247XHJcbiAgICAgICAgICAgIHZhciBjb2RlY2FycmF5ID0gdW5pdC5kYXRhLnN1YmFycmF5KDEsIDQpO1xyXG4gICAgICAgICAgICB2YXIgY29kZWNzdHJpbmcgPSAnYXZjMS4nO1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMzsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgdmFyIGggPSBjb2RlY2FycmF5W2ldLnRvU3RyaW5nKDE2KTtcclxuICAgICAgICAgICAgICBpZiAoaC5sZW5ndGggPCAyKSB7XHJcbiAgICAgICAgICAgICAgICBoID0gJzAnICsgaDtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgY29kZWNzdHJpbmcgKz0gaDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0cmFjay5jb2RlYyA9IGNvZGVjc3RyaW5nO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgLy9QUFNcclxuICAgICAgICBjYXNlIDg6XHJcbiAgICAgICAgICBwdXNoID0gdHJ1ZTtcclxuICAgICAgICAgIGlmKGRlYnVnICYmIGF2Y1NhbXBsZSkge1xyXG4gICAgICAgICAgICBhdmNTYW1wbGUuZGVidWcgKz0gJ1BQUyAnO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKCF0cmFjay5wcHMpIHtcclxuICAgICAgICAgICAgdHJhY2sucHBzID0gW3VuaXQuZGF0YV07XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICAvLyBBVURcclxuICAgICAgICBjYXNlIDk6XHJcbiAgICAgICAgICBwdXNoID0gZmFsc2U7XHJcbiAgICAgICAgICBpZiAoYXZjU2FtcGxlKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHVzaEFjY2VzVW5pdChhdmNTYW1wbGUsdHJhY2spO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgYXZjU2FtcGxlID0gdGhpcy5hdmNTYW1wbGUgPSB0aGlzLl9jcmVhdGVBVkNTYW1wbGUoZmFsc2UscGVzLnB0cyxwZXMuZHRzLGRlYnVnID8gJ0FVRCAnOiAnJyk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICAvLyBGaWxsZXIgRGF0YVxyXG4gICAgICAgIGNhc2UgMTI6XHJcbiAgICAgICAgICBwdXNoID0gZmFsc2U7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgcHVzaCA9IGZhbHNlO1xyXG4gICAgICAgICAgaWYgKGF2Y1NhbXBsZSkge1xyXG4gICAgICAgICAgICBhdmNTYW1wbGUuZGVidWcgKz0gJ3Vua25vd24gTkFMICcgKyB1bml0LnR5cGUgKyAnICc7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgICBpZihhdmNTYW1wbGUgJiYgcHVzaCkge1xyXG4gICAgICAgIGxldCB1bml0cyA9IGF2Y1NhbXBsZS51bml0cztcclxuICAgICAgICB1bml0cy5wdXNoKHVuaXQpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICAgIC8vIGlmIGxhc3QgUEVTIHBhY2tldCwgcHVzaCBzYW1wbGVzXHJcbiAgICBpZiAobGFzdCAmJiBhdmNTYW1wbGUpIHtcclxuICAgICAgdGhpcy5wdXNoQWNjZXNVbml0KGF2Y1NhbXBsZSx0cmFjayk7XHJcbiAgICAgIHRoaXMuYXZjU2FtcGxlID0gbnVsbDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIF9jcmVhdGVBVkNTYW1wbGUoa2V5LHB0cyxkdHMsZGVidWcpIHtcclxuICAgIHJldHVybiB7IGtleSA6IGtleSwgcHRzIDogcHRzLCBkdHMgOiBkdHMsIHVuaXRzIDogW10sIGRlYnVnIDogZGVidWd9O1xyXG4gIH1cclxuXHJcbiAgX2luc2VydFNhbXBsZUluT3JkZXIoYXJyLCBkYXRhKSB7XHJcbiAgICB2YXIgbGVuID0gYXJyLmxlbmd0aDtcclxuICAgIGlmIChsZW4gPiAwKSB7XHJcbiAgICAgIGlmIChkYXRhLnB0cyA+PSBhcnJbbGVuLTFdLnB0cylcclxuICAgICAge1xyXG4gICAgICAgIGFyci5wdXNoKGRhdGEpO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgIGZvciAodmFyIHBvcyA9IGxlbiAtIDE7IHBvcyA+PSAwOyBwb3MtLSkge1xyXG4gICAgICAgICAgaWYgKGRhdGEucHRzIDwgYXJyW3Bvc10ucHRzKSB7XHJcbiAgICAgICAgICAgIGFyci5zcGxpY2UocG9zLCAwLCBkYXRhKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgYXJyLnB1c2goZGF0YSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBfZ2V0TGFzdE5hbFVuaXQoKSB7XHJcbiAgICBsZXQgYXZjU2FtcGxlID0gdGhpcy5hdmNTYW1wbGUsIGxhc3RVbml0O1xyXG4gICAgLy8gdHJ5IHRvIGZhbGxiYWNrIHRvIHByZXZpb3VzIHNhbXBsZSBpZiBjdXJyZW50IG9uZSBpcyBlbXB0eVxyXG4gICAgaWYgKCFhdmNTYW1wbGUgfHwgYXZjU2FtcGxlLnVuaXRzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICBsZXQgdHJhY2sgPSB0aGlzLl9hdmNUcmFjaywgc2FtcGxlcyA9IHRyYWNrLnNhbXBsZXM7XHJcbiAgICAgIGF2Y1NhbXBsZSA9IHNhbXBsZXNbc2FtcGxlcy5sZW5ndGgtMV07XHJcbiAgICB9XHJcbiAgICBpZiAoYXZjU2FtcGxlKSB7XHJcbiAgICAgIGxldCB1bml0cyA9IGF2Y1NhbXBsZS51bml0cztcclxuICAgICAgbGFzdFVuaXQgPSB1bml0c1t1bml0cy5sZW5ndGggLSAxXTtcclxuICAgIH1cclxuICAgIHJldHVybiBsYXN0VW5pdDtcclxuICB9XHJcblxyXG4gIF9wYXJzZUFWQ05BTHUoYXJyYXkpIHtcclxuICAgIHZhciBpID0gMCwgbGVuID0gYXJyYXkuYnl0ZUxlbmd0aCwgdmFsdWUsIG92ZXJmbG93LCB0cmFjayA9IHRoaXMuX2F2Y1RyYWNrLCBzdGF0ZSA9IHRyYWNrLm5hbHVTdGF0ZSB8fCAwLCBsYXN0U3RhdGUgPSBzdGF0ZTtcclxuICAgIHZhciB1bml0cyA9IFtdLCB1bml0LCB1bml0VHlwZSwgbGFzdFVuaXRTdGFydCA9IC0xLCBsYXN0VW5pdFR5cGU7XHJcbiAgICAvL2xvZ2dlci5sb2coJ1BFUzonICsgSGV4LmhleER1bXAoYXJyYXkpKTtcclxuXHJcbiAgICBpZiAoc3RhdGUgPT09IC0xKSB7XHJcbiAgICAvLyBzcGVjaWFsIHVzZSBjYXNlIHdoZXJlIHdlIGZvdW5kIDMgb3IgNC1ieXRlIHN0YXJ0IGNvZGVzIGV4YWN0bHkgYXQgdGhlIGVuZCBvZiBwcmV2aW91cyBQRVMgcGFja2V0XHJcbiAgICAgIGxhc3RVbml0U3RhcnQgPSAwO1xyXG4gICAgICAvLyBOQUx1IHR5cGUgaXMgdmFsdWUgcmVhZCBmcm9tIG9mZnNldCAwXHJcbiAgICAgIGxhc3RVbml0VHlwZSA9IGFycmF5WzBdICYgMHgxZjtcclxuICAgICAgc3RhdGUgPSAwO1xyXG4gICAgICBpID0gMTtcclxuICAgIH1cclxuXHJcbiAgICB3aGlsZSAoaSA8IGxlbikge1xyXG4gICAgICB2YWx1ZSA9IGFycmF5W2krK107XHJcbiAgICAgIC8vIG9wdGltaXphdGlvbi4gc3RhdGUgMCBhbmQgMSBhcmUgdGhlIHByZWRvbWluYW50IGNhc2UuIGxldCdzIGhhbmRsZSB0aGVtIG91dHNpZGUgb2YgdGhlIHN3aXRjaC9jYXNlXHJcbiAgICAgIGlmICghc3RhdGUpIHtcclxuICAgICAgICBzdGF0ZSA9IHZhbHVlID8gMCA6IDE7XHJcbiAgICAgICAgY29udGludWU7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHN0YXRlID09PSAxKSB7XHJcbiAgICAgICAgc3RhdGUgPSB2YWx1ZSA/IDAgOiAyO1xyXG4gICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICB9XHJcbiAgICAgIC8vIGhlcmUgd2UgaGF2ZSBzdGF0ZSBlaXRoZXIgZXF1YWwgdG8gMiBvciAzXHJcbiAgICAgIGlmKCF2YWx1ZSkge1xyXG4gICAgICAgIHN0YXRlID0gMztcclxuICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gMSkge1xyXG4gICAgICAgIGlmIChsYXN0VW5pdFN0YXJ0ID49MCkge1xyXG4gICAgICAgICAgdW5pdCA9IHtkYXRhOiBhcnJheS5zdWJhcnJheShsYXN0VW5pdFN0YXJ0LCBpIC0gc3RhdGUgLSAxKSwgdHlwZTogbGFzdFVuaXRUeXBlfTtcclxuICAgICAgICAgIC8vbG9nZ2VyLmxvZygncHVzaGluZyBOQUxVLCB0eXBlL3NpemU6JyArIHVuaXQudHlwZSArICcvJyArIHVuaXQuZGF0YS5ieXRlTGVuZ3RoKTtcclxuICAgICAgICAgIHVuaXRzLnB1c2godW5pdCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIC8vIGxhc3RVbml0U3RhcnQgaXMgdW5kZWZpbmVkID0+IHRoaXMgaXMgdGhlIGZpcnN0IHN0YXJ0IGNvZGUgZm91bmQgaW4gdGhpcyBQRVMgcGFja2V0XHJcbiAgICAgICAgICAvLyBmaXJzdCBjaGVjayBpZiBzdGFydCBjb2RlIGRlbGltaXRlciBpcyBvdmVybGFwcGluZyBiZXR3ZWVuIDIgUEVTIHBhY2tldHMsXHJcbiAgICAgICAgICAvLyBpZSBpdCBzdGFydGVkIGluIGxhc3QgcGFja2V0IChsYXN0U3RhdGUgbm90IHplcm8pXHJcbiAgICAgICAgICAvLyBhbmQgZW5kZWQgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGlzIFBFUyBwYWNrZXQgKGkgPD0gNCAtIGxhc3RTdGF0ZSlcclxuICAgICAgICAgIGxldCBsYXN0VW5pdCA9IHRoaXMuX2dldExhc3ROYWxVbml0KCk7XHJcbiAgICAgICAgICBpZiAobGFzdFVuaXQpIHtcclxuICAgICAgICAgICAgaWYobGFzdFN0YXRlICYmICAoaSA8PSA0IC0gbGFzdFN0YXRlKSkge1xyXG4gICAgICAgICAgICAgIC8vIHN0YXJ0IGRlbGltaXRlciBvdmVybGFwcGluZyBiZXR3ZWVuIFBFUyBwYWNrZXRzXHJcbiAgICAgICAgICAgICAgLy8gc3RyaXAgc3RhcnQgZGVsaW1pdGVyIGJ5dGVzIGZyb20gdGhlIGVuZCBvZiBsYXN0IE5BTCB1bml0XHJcbiAgICAgICAgICAgICAgICAvLyBjaGVjayBpZiBsYXN0VW5pdCBoYWQgYSBzdGF0ZSBkaWZmZXJlbnQgZnJvbSB6ZXJvXHJcbiAgICAgICAgICAgICAgaWYgKGxhc3RVbml0LnN0YXRlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBzdHJpcCBsYXN0IGJ5dGVzXHJcbiAgICAgICAgICAgICAgICBsYXN0VW5pdC5kYXRhID0gbGFzdFVuaXQuZGF0YS5zdWJhcnJheSgwLGxhc3RVbml0LmRhdGEuYnl0ZUxlbmd0aCAtIGxhc3RTdGF0ZSk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIElmIE5BTCB1bml0cyBhcmUgbm90IHN0YXJ0aW5nIHJpZ2h0IGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIFBFUyBwYWNrZXQsIHB1c2ggcHJlY2VkaW5nIGRhdGEgaW50byBwcmV2aW91cyBOQUwgdW5pdC5cclxuICAgICAgICAgICAgb3ZlcmZsb3cgID0gaSAtIHN0YXRlIC0gMTtcclxuICAgICAgICAgICAgaWYgKG92ZXJmbG93ID4gMCkge1xyXG4gICAgICAgICAgICAgIC8vbG9nZ2VyLmxvZygnZmlyc3QgTkFMVSBmb3VuZCB3aXRoIG92ZXJmbG93OicgKyBvdmVyZmxvdyk7XHJcbiAgICAgICAgICAgICAgbGV0IHRtcCA9IG5ldyBVaW50OEFycmF5KGxhc3RVbml0LmRhdGEuYnl0ZUxlbmd0aCArIG92ZXJmbG93KTtcclxuICAgICAgICAgICAgICB0bXAuc2V0KGxhc3RVbml0LmRhdGEsIDApO1xyXG4gICAgICAgICAgICAgIHRtcC5zZXQoYXJyYXkuc3ViYXJyYXkoMCwgb3ZlcmZsb3cpLCBsYXN0VW5pdC5kYXRhLmJ5dGVMZW5ndGgpO1xyXG4gICAgICAgICAgICAgIGxhc3RVbml0LmRhdGEgPSB0bXA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gY2hlY2sgaWYgd2UgY2FuIHJlYWQgdW5pdCB0eXBlXHJcbiAgICAgICAgaWYgKGkgPCBsZW4pIHtcclxuICAgICAgICAgIHVuaXRUeXBlID0gYXJyYXlbaV0gJiAweDFmO1xyXG4gICAgICAgICAgLy9sb2dnZXIubG9nKCdmaW5kIE5BTFUgQCBvZmZzZXQ6JyArIGkgKyAnLHR5cGU6JyArIHVuaXRUeXBlKTtcclxuICAgICAgICAgIGxhc3RVbml0U3RhcnQgPSBpO1xyXG4gICAgICAgICAgbGFzdFVuaXRUeXBlID0gdW5pdFR5cGU7XHJcbiAgICAgICAgICBzdGF0ZSA9IDA7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIC8vIG5vdCBlbm91Z2ggYnl0ZSB0byByZWFkIHVuaXQgdHlwZS4gbGV0J3MgcmVhZCBpdCBvbiBuZXh0IFBFUyBwYXJzaW5nXHJcbiAgICAgICAgICBzdGF0ZSA9IC0xO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBzdGF0ZSA9IDA7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChsYXN0VW5pdFN0YXJ0ID49MCAmJiBzdGF0ZSA+PTApIHtcclxuICAgICAgdW5pdCA9IHtkYXRhOiBhcnJheS5zdWJhcnJheShsYXN0VW5pdFN0YXJ0LCBsZW4pLCB0eXBlOiBsYXN0VW5pdFR5cGUsIHN0YXRlIDogc3RhdGV9O1xyXG4gICAgICB1bml0cy5wdXNoKHVuaXQpO1xyXG4gICAgICAvL2xvZ2dlci5sb2coJ3B1c2hpbmcgTkFMVSwgdHlwZS9zaXplL3N0YXRlOicgKyB1bml0LnR5cGUgKyAnLycgKyB1bml0LmRhdGEuYnl0ZUxlbmd0aCArICcvJyArIHN0YXRlKTtcclxuICAgIH1cclxuICAgIC8vIG5vIE5BTHUgZm91bmRcclxuICAgIGlmICh1bml0cy5sZW5ndGggPT09IDApIHtcclxuICAgICAgLy8gYXBwZW5kIHBlcy5kYXRhIHRvIHByZXZpb3VzIE5BTCB1bml0XHJcbiAgICAgIGxldCAgbGFzdFVuaXQgPSB0aGlzLl9nZXRMYXN0TmFsVW5pdCgpO1xyXG4gICAgICBpZiAobGFzdFVuaXQpIHtcclxuICAgICAgICBsZXQgdG1wID0gbmV3IFVpbnQ4QXJyYXkobGFzdFVuaXQuZGF0YS5ieXRlTGVuZ3RoICsgYXJyYXkuYnl0ZUxlbmd0aCk7XHJcbiAgICAgICAgdG1wLnNldChsYXN0VW5pdC5kYXRhLCAwKTtcclxuICAgICAgICB0bXAuc2V0KGFycmF5LCBsYXN0VW5pdC5kYXRhLmJ5dGVMZW5ndGgpO1xyXG4gICAgICAgIGxhc3RVbml0LmRhdGEgPSB0bXA7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHRyYWNrLm5hbHVTdGF0ZSA9IHN0YXRlO1xyXG4gICAgcmV0dXJuIHVuaXRzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogcmVtb3ZlIEVtdWxhdGlvbiBQcmV2ZW50aW9uIGJ5dGVzIGZyb20gYSBSQlNQXHJcbiAgICovXHJcbiAgZGlzY2FyZEVQQihkYXRhKSB7XHJcbiAgICB2YXIgbGVuZ3RoID0gZGF0YS5ieXRlTGVuZ3RoLFxyXG4gICAgICAgIEVQQlBvc2l0aW9ucyA9IFtdLFxyXG4gICAgICAgIGkgPSAxLFxyXG4gICAgICAgIG5ld0xlbmd0aCwgbmV3RGF0YTtcclxuXHJcbiAgICAvLyBGaW5kIGFsbCBgRW11bGF0aW9uIFByZXZlbnRpb24gQnl0ZXNgXHJcbiAgICB3aGlsZSAoaSA8IGxlbmd0aCAtIDIpIHtcclxuICAgICAgaWYgKGRhdGFbaV0gPT09IDAgJiZcclxuICAgICAgICAgIGRhdGFbaSArIDFdID09PSAwICYmXHJcbiAgICAgICAgICBkYXRhW2kgKyAyXSA9PT0gMHgwMykge1xyXG4gICAgICAgIEVQQlBvc2l0aW9ucy5wdXNoKGkgKyAyKTtcclxuICAgICAgICBpICs9IDI7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaSsrO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gSWYgbm8gRW11bGF0aW9uIFByZXZlbnRpb24gQnl0ZXMgd2VyZSBmb3VuZCBqdXN0IHJldHVybiB0aGUgb3JpZ2luYWxcclxuICAgIC8vIGFycmF5XHJcbiAgICBpZiAoRVBCUG9zaXRpb25zLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICByZXR1cm4gZGF0YTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBDcmVhdGUgYSBuZXcgYXJyYXkgdG8gaG9sZCB0aGUgTkFMIHVuaXQgZGF0YVxyXG4gICAgbmV3TGVuZ3RoID0gbGVuZ3RoIC0gRVBCUG9zaXRpb25zLmxlbmd0aDtcclxuICAgIG5ld0RhdGEgPSBuZXcgVWludDhBcnJheShuZXdMZW5ndGgpO1xyXG4gICAgdmFyIHNvdXJjZUluZGV4ID0gMDtcclxuXHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgbmV3TGVuZ3RoOyBzb3VyY2VJbmRleCsrLCBpKyspIHtcclxuICAgICAgaWYgKHNvdXJjZUluZGV4ID09PSBFUEJQb3NpdGlvbnNbMF0pIHtcclxuICAgICAgICAvLyBTa2lwIHRoaXMgYnl0ZVxyXG4gICAgICAgIHNvdXJjZUluZGV4Kys7XHJcbiAgICAgICAgLy8gUmVtb3ZlIHRoaXMgcG9zaXRpb24gaW5kZXhcclxuICAgICAgICBFUEJQb3NpdGlvbnMuc2hpZnQoKTtcclxuICAgICAgfVxyXG4gICAgICBuZXdEYXRhW2ldID0gZGF0YVtzb3VyY2VJbmRleF07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV3RGF0YTtcclxuICB9XHJcblxyXG4gIF9wYXJzZUFBQ1BFUyhwZXMpIHtcclxuICAgIHZhciB0cmFjayA9IHRoaXMuX2F1ZGlvVHJhY2ssXHJcbiAgICAgICAgZGF0YSA9IHBlcy5kYXRhLFxyXG4gICAgICAgIHB0cyA9IHBlcy5wdHMsXHJcbiAgICAgICAgc3RhcnRPZmZzZXQgPSAwLFxyXG4gICAgICAgIGFhY092ZXJGbG93ID0gdGhpcy5hYWNPdmVyRmxvdyxcclxuICAgICAgICBhYWNMYXN0UFRTID0gdGhpcy5hYWNMYXN0UFRTLFxyXG4gICAgICAgIGZyYW1lRHVyYXRpb24sIGZyYW1lSW5kZXgsIG9mZnNldCwgc3RhbXAsIGxlbjtcclxuICAgIGlmIChhYWNPdmVyRmxvdykge1xyXG4gICAgICB2YXIgdG1wID0gbmV3IFVpbnQ4QXJyYXkoYWFjT3ZlckZsb3cuYnl0ZUxlbmd0aCArIGRhdGEuYnl0ZUxlbmd0aCk7XHJcbiAgICAgIHRtcC5zZXQoYWFjT3ZlckZsb3csIDApO1xyXG4gICAgICB0bXAuc2V0KGRhdGEsIGFhY092ZXJGbG93LmJ5dGVMZW5ndGgpO1xyXG4gICAgICAvL2xvZ2dlci5sb2coYEFBQzogYXBwZW5kIG92ZXJmbG93aW5nICR7YWFjT3ZlckZsb3cuYnl0ZUxlbmd0aH0gYnl0ZXMgdG8gYmVnaW5uaW5nIG9mIG5ldyBQRVNgKTtcclxuICAgICAgZGF0YSA9IHRtcDtcclxuICAgIH1cclxuICAgIC8vIGxvb2sgZm9yIEFEVFMgaGVhZGVyICgweEZGRngpXHJcbiAgICBmb3IgKG9mZnNldCA9IHN0YXJ0T2Zmc2V0LCBsZW4gPSBkYXRhLmxlbmd0aDsgb2Zmc2V0IDwgbGVuIC0gMTsgb2Zmc2V0KyspIHtcclxuICAgICAgaWYgKEFEVFMuaXNIZWFkZXIoZGF0YSwgb2Zmc2V0KSkge1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBpZiBBRFRTIGhlYWRlciBkb2VzIG5vdCBzdGFydCBzdHJhaWdodCBmcm9tIHRoZSBiZWdpbm5pbmcgb2YgdGhlIFBFUyBwYXlsb2FkLCByYWlzZSBhbiBlcnJvclxyXG4gICAgaWYgKG9mZnNldCkge1xyXG4gICAgICB2YXIgcmVhc29uLCBmYXRhbDtcclxuICAgICAgaWYgKG9mZnNldCA8IGxlbiAtIDEpIHtcclxuICAgICAgICByZWFzb24gPSBgQUFDIFBFUyBkaWQgbm90IHN0YXJ0IHdpdGggQURUUyBoZWFkZXIsb2Zmc2V0OiR7b2Zmc2V0fWA7XHJcbiAgICAgICAgZmF0YWwgPSBmYWxzZTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICByZWFzb24gPSAnbm8gQURUUyBoZWFkZXIgZm91bmQgaW4gQUFDIFBFUyc7XHJcbiAgICAgICAgZmF0YWwgPSB0cnVlO1xyXG4gICAgICB9XHJcbiAgICAgIGxvZ2dlci53YXJuKGBwYXJzaW5nIGVycm9yOiR7cmVhc29ufWApO1xyXG4gICAgICB0aGlzLm9ic2VydmVyLnRyaWdnZXIoRXZlbnQuRVJST1IsIHt0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLCBkZXRhaWxzOiBFcnJvckRldGFpbHMuRlJBR19QQVJTSU5HX0VSUk9SLCBmYXRhbDogZmF0YWwsIHJlYXNvbjogcmVhc29ufSk7XHJcbiAgICAgIGlmIChmYXRhbCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIEFEVFMuaW5pdFRyYWNrQ29uZmlnKHRyYWNrLCB0aGlzLm9ic2VydmVyLCBkYXRhLCBvZmZzZXQsIHRoaXMuYXVkaW9Db2RlYyk7XHJcbiAgICBmcmFtZUluZGV4ID0gMDtcclxuICAgIGZyYW1lRHVyYXRpb24gPSBBRFRTLmdldEZyYW1lRHVyYXRpb24odHJhY2suc2FtcGxlcmF0ZSk7XHJcblxyXG4gICAgLy8gaWYgbGFzdCBBQUMgZnJhbWUgaXMgb3ZlcmZsb3dpbmcsIHdlIHNob3VsZCBlbnN1cmUgdGltZXN0YW1wcyBhcmUgY29udGlndW91czpcclxuICAgIC8vIGZpcnN0IHNhbXBsZSBQVFMgc2hvdWxkIGJlIGVxdWFsIHRvIGxhc3Qgc2FtcGxlIFBUUyArIGZyYW1lRHVyYXRpb25cclxuICAgIGlmKGFhY092ZXJGbG93ICYmIGFhY0xhc3RQVFMpIHtcclxuICAgICAgdmFyIG5ld1BUUyA9IGFhY0xhc3RQVFMrZnJhbWVEdXJhdGlvbjtcclxuICAgICAgaWYoTWF0aC5hYnMobmV3UFRTLXB0cykgPiAxKSB7XHJcbiAgICAgICAgbG9nZ2VyLmxvZyhgQUFDOiBhbGlnbiBQVFMgZm9yIG92ZXJsYXBwaW5nIGZyYW1lcyBieSAke01hdGgucm91bmQoKG5ld1BUUy1wdHMpLzkwKX1gKTtcclxuICAgICAgICBwdHM9bmV3UFRTO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy9zY2FuIGZvciBhYWMgc2FtcGxlc1xyXG4gICAgd2hpbGUgKG9mZnNldCA8IGxlbikge1xyXG4gICAgICBpZiAoQURUUy5pc0hlYWRlcihkYXRhLCBvZmZzZXQpICYmIChvZmZzZXQgKyA1KSA8IGxlbikge1xyXG4gICAgICAgIHZhciBmcmFtZSA9IEFEVFMuYXBwZW5kRnJhbWUodHJhY2ssIGRhdGEsIG9mZnNldCwgcHRzLCBmcmFtZUluZGV4KTtcclxuICAgICAgICBpZiAoZnJhbWUpIHtcclxuICAgICAgICAgIC8vbG9nZ2VyLmxvZyhgJHtNYXRoLnJvdW5kKGZyYW1lLnNhbXBsZS5wdHMpfSA6IEFBQ2ApO1xyXG4gICAgICAgICAgb2Zmc2V0ICs9IGZyYW1lLmxlbmd0aDtcclxuICAgICAgICAgIHN0YW1wID0gZnJhbWUuc2FtcGxlLnB0cztcclxuICAgICAgICAgIGZyYW1lSW5kZXgrKztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgLy9sb2dnZXIubG9nKCdVbmFibGUgdG8gcGFyc2UgQUFDIGZyYW1lJyk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy9ub3RoaW5nIGZvdW5kLCBrZWVwIGxvb2tpbmdcclxuICAgICAgICBvZmZzZXQrKztcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmIChvZmZzZXQgPCBsZW4pIHtcclxuICAgICAgYWFjT3ZlckZsb3cgPSBkYXRhLnN1YmFycmF5KG9mZnNldCwgbGVuKTtcclxuICAgICAgLy9sb2dnZXIubG9nKGBBQUM6IG92ZXJmbG93IGRldGVjdGVkOiR7bGVuLW9mZnNldH1gKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGFhY092ZXJGbG93ID0gbnVsbDtcclxuICAgIH1cclxuICAgIHRoaXMuYWFjT3ZlckZsb3cgPSBhYWNPdmVyRmxvdztcclxuICAgIHRoaXMuYWFjTGFzdFBUUyA9IHN0YW1wO1xyXG4gIH1cclxuXHJcbiAgX3BhcnNlTVBFR1BFUyhwZXMpIHtcclxuICAgIHZhciBkYXRhID0gcGVzLmRhdGE7XHJcbiAgICB2YXIgbGVuZ3RoID0gZGF0YS5sZW5ndGg7XHJcbiAgICB2YXIgZnJhbWVJbmRleCA9IDA7XHJcbiAgICB2YXIgb2Zmc2V0ID0gMDtcclxuICAgIHZhciBwdHMgPSBwZXMucHRzO1xyXG5cclxuICAgIHdoaWxlIChvZmZzZXQgPCBsZW5ndGgpIHtcclxuICAgICAgaWYgKE1wZWdBdWRpby5pc0hlYWRlcihkYXRhLCBvZmZzZXQpKSB7XHJcbiAgICAgICAgdmFyIGZyYW1lID0gTXBlZ0F1ZGlvLmFwcGVuZEZyYW1lKHRoaXMuX2F1ZGlvVHJhY2ssIGRhdGEsIG9mZnNldCwgcHRzLCBmcmFtZUluZGV4KTtcclxuICAgICAgICBpZiAoZnJhbWUpIHtcclxuICAgICAgICAgIG9mZnNldCArPSBmcmFtZS5sZW5ndGg7XHJcbiAgICAgICAgICBmcmFtZUluZGV4Kys7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIC8vbG9nZ2VyLmxvZygnVW5hYmxlIHRvIHBhcnNlIE1wZWcgYXVkaW8gZnJhbWUnKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvL25vdGhpbmcgZm91bmQsIGtlZXAgbG9va2luZ1xyXG4gICAgICAgIG9mZnNldCsrO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBfcGFyc2VJRDNQRVMocGVzKSB7XHJcbiAgICB0aGlzLl9pZDNUcmFjay5zYW1wbGVzLnB1c2gocGVzKTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IFRTRGVtdXhlcjtcclxuIiwiZXhwb3J0IGNvbnN0IEVycm9yVHlwZXMgPSB7XHJcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBuZXR3b3JrIGVycm9yIChsb2FkaW5nIGVycm9yIC8gdGltZW91dCAuLi4pXHJcbiAgTkVUV09SS19FUlJPUjogJ25ldHdvcmtFcnJvcicsXHJcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBtZWRpYSBFcnJvciAodmlkZW8vcGFyc2luZy9tZWRpYXNvdXJjZSBlcnJvcilcclxuICBNRURJQV9FUlJPUjogJ21lZGlhRXJyb3InLFxyXG4gIC8vIElkZW50aWZpZXIgZm9yIGEgbXV4IEVycm9yIChkZW11eGluZy9yZW11eGluZylcclxuICBNVVhfRVJST1I6ICdtdXhFcnJvcicsXHJcbiAgLy8gSWRlbnRpZmllciBmb3IgYWxsIG90aGVyIGVycm9yc1xyXG4gIE9USEVSX0VSUk9SOiAnb3RoZXJFcnJvcidcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBFcnJvckRldGFpbHMgPSB7XHJcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBtYW5pZmVzdCBsb2FkIGVycm9yIC0gZGF0YTogeyB1cmwgOiBmYXVsdHkgVVJMLCByZXNwb25zZSA6IHsgY29kZTogZXJyb3IgY29kZSwgdGV4dDogZXJyb3IgdGV4dCB9fVxyXG4gIE1BTklGRVNUX0xPQURfRVJST1I6ICdtYW5pZmVzdExvYWRFcnJvcicsXHJcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBtYW5pZmVzdCBsb2FkIHRpbWVvdXQgLSBkYXRhOiB7IHVybCA6IGZhdWx0eSBVUkwsIHJlc3BvbnNlIDogeyBjb2RlOiBlcnJvciBjb2RlLCB0ZXh0OiBlcnJvciB0ZXh0IH19XHJcbiAgTUFOSUZFU1RfTE9BRF9USU1FT1VUOiAnbWFuaWZlc3RMb2FkVGltZU91dCcsXHJcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBtYW5pZmVzdCBwYXJzaW5nIGVycm9yIC0gZGF0YTogeyB1cmwgOiBmYXVsdHkgVVJMLCByZWFzb24gOiBlcnJvciByZWFzb259XHJcbiAgTUFOSUZFU1RfUEFSU0lOR19FUlJPUjogJ21hbmlmZXN0UGFyc2luZ0Vycm9yJyxcclxuICAvLyBJZGVudGlmaWVyIGZvciBhIG1hbmlmZXN0IHdpdGggb25seSBpbmNvbXBhdGlibGUgY29kZWNzIGVycm9yIC0gZGF0YTogeyB1cmwgOiBmYXVsdHkgVVJMLCByZWFzb24gOiBlcnJvciByZWFzb259XHJcbiAgTUFOSUZFU1RfSU5DT01QQVRJQkxFX0NPREVDU19FUlJPUjogJ21hbmlmZXN0SW5jb21wYXRpYmxlQ29kZWNzRXJyb3InLFxyXG4gIC8vIElkZW50aWZpZXIgZm9yIGEgbGV2ZWwgbG9hZCBlcnJvciAtIGRhdGE6IHsgdXJsIDogZmF1bHR5IFVSTCwgcmVzcG9uc2UgOiB7IGNvZGU6IGVycm9yIGNvZGUsIHRleHQ6IGVycm9yIHRleHQgfX1cclxuICBMRVZFTF9MT0FEX0VSUk9SOiAnbGV2ZWxMb2FkRXJyb3InLFxyXG4gIC8vIElkZW50aWZpZXIgZm9yIGEgbGV2ZWwgbG9hZCB0aW1lb3V0IC0gZGF0YTogeyB1cmwgOiBmYXVsdHkgVVJMLCByZXNwb25zZSA6IHsgY29kZTogZXJyb3IgY29kZSwgdGV4dDogZXJyb3IgdGV4dCB9fVxyXG4gIExFVkVMX0xPQURfVElNRU9VVDogJ2xldmVsTG9hZFRpbWVPdXQnLFxyXG4gIC8vIElkZW50aWZpZXIgZm9yIGEgbGV2ZWwgc3dpdGNoIGVycm9yIC0gZGF0YTogeyBsZXZlbCA6IGZhdWx0eSBsZXZlbCBJZCwgZXZlbnQgOiBlcnJvciBkZXNjcmlwdGlvbn1cclxuICBMRVZFTF9TV0lUQ0hfRVJST1I6ICdsZXZlbFN3aXRjaEVycm9yJyxcclxuICAvLyBJZGVudGlmaWVyIGZvciBhbiBhdWRpbyB0cmFjayBsb2FkIGVycm9yIC0gZGF0YTogeyB1cmwgOiBmYXVsdHkgVVJMLCByZXNwb25zZSA6IHsgY29kZTogZXJyb3IgY29kZSwgdGV4dDogZXJyb3IgdGV4dCB9fVxyXG4gIEFVRElPX1RSQUNLX0xPQURfRVJST1I6ICdhdWRpb1RyYWNrTG9hZEVycm9yJyxcclxuICAvLyBJZGVudGlmaWVyIGZvciBhbiBhdWRpbyB0cmFjayBsb2FkIHRpbWVvdXQgLSBkYXRhOiB7IHVybCA6IGZhdWx0eSBVUkwsIHJlc3BvbnNlIDogeyBjb2RlOiBlcnJvciBjb2RlLCB0ZXh0OiBlcnJvciB0ZXh0IH19XHJcbiAgQVVESU9fVFJBQ0tfTE9BRF9USU1FT1VUOiAnYXVkaW9UcmFja0xvYWRUaW1lT3V0JyxcclxuICAvLyBJZGVudGlmaWVyIGZvciBmcmFnbWVudCBsb2FkIGVycm9yIC0gZGF0YTogeyBmcmFnIDogZnJhZ21lbnQgb2JqZWN0LCByZXNwb25zZSA6IHsgY29kZTogZXJyb3IgY29kZSwgdGV4dDogZXJyb3IgdGV4dCB9fVxyXG4gIEZSQUdfTE9BRF9FUlJPUjogJ2ZyYWdMb2FkRXJyb3InLFxyXG4gIC8vIElkZW50aWZpZXIgZm9yIGZyYWdtZW50IGxvb3AgbG9hZGluZyBlcnJvciAtIGRhdGE6IHsgZnJhZyA6IGZyYWdtZW50IG9iamVjdH1cclxuICBGUkFHX0xPT1BfTE9BRElOR19FUlJPUjogJ2ZyYWdMb29wTG9hZGluZ0Vycm9yJyxcclxuICAvLyBJZGVudGlmaWVyIGZvciBmcmFnbWVudCBsb2FkIHRpbWVvdXQgZXJyb3IgLSBkYXRhOiB7IGZyYWcgOiBmcmFnbWVudCBvYmplY3R9XHJcbiAgRlJBR19MT0FEX1RJTUVPVVQ6ICdmcmFnTG9hZFRpbWVPdXQnLFxyXG4gIC8vIElkZW50aWZpZXIgZm9yIGEgZnJhZ21lbnQgZGVjcnlwdGlvbiBlcnJvciBldmVudCAtIGRhdGE6IHtpZCA6IGRlbXV4ZXIgSWQsZnJhZzogZnJhZ21lbnQgb2JqZWN0LCByZWFzb24gOiBwYXJzaW5nIGVycm9yIGRlc2NyaXB0aW9uIH1cclxuICBGUkFHX0RFQ1JZUFRfRVJST1I6ICdmcmFnRGVjcnlwdEVycm9yJyxcclxuICAvLyBJZGVudGlmaWVyIGZvciBhIGZyYWdtZW50IHBhcnNpbmcgZXJyb3IgZXZlbnQgLSBkYXRhOiB7IGlkIDogZGVtdXhlciBJZCwgcmVhc29uIDogcGFyc2luZyBlcnJvciBkZXNjcmlwdGlvbiB9XHJcbiAgLy8gd2lsbCBiZSByZW5hbWVkIERFTVVYX1BBUlNJTkdfRVJST1IgYW5kIHN3aXRjaGVkIHRvIE1VWF9FUlJPUiBpbiB0aGUgbmV4dCBtYWpvciByZWxlYXNlXHJcbiAgRlJBR19QQVJTSU5HX0VSUk9SOiAnZnJhZ1BhcnNpbmdFcnJvcicsXHJcbiAgLy8gSWRlbnRpZmllciBmb3IgYSByZW11eCBhbGxvYyBlcnJvciBldmVudCAtIGRhdGE6IHsgaWQgOiBkZW11eGVyIElkLCBmcmFnIDogZnJhZ21lbnQgb2JqZWN0LCBieXRlcyA6IG5iIG9mIGJ5dGVzIG9uIHdoaWNoIGFsbG9jYXRpb24gZmFpbGVkICwgcmVhc29uIDogZXJyb3IgdGV4dCB9XHJcbiAgUkVNVVhfQUxMT0NfRVJST1IgOiAncmVtdXhBbGxvY0Vycm9yJyxcclxuICAvLyBJZGVudGlmaWVyIGZvciBkZWNyeXB0IGtleSBsb2FkIGVycm9yIC0gZGF0YTogeyBmcmFnIDogZnJhZ21lbnQgb2JqZWN0LCByZXNwb25zZSA6IHsgY29kZTogZXJyb3IgY29kZSwgdGV4dDogZXJyb3IgdGV4dCB9fVxyXG4gIEtFWV9MT0FEX0VSUk9SOiAna2V5TG9hZEVycm9yJyxcclxuICAvLyBJZGVudGlmaWVyIGZvciBkZWNyeXB0IGtleSBsb2FkIHRpbWVvdXQgZXJyb3IgLSBkYXRhOiB7IGZyYWcgOiBmcmFnbWVudCBvYmplY3R9XHJcbiAgS0VZX0xPQURfVElNRU9VVDogJ2tleUxvYWRUaW1lT3V0JyxcclxuICAvLyBUcmlnZ2VyZWQgd2hlbiBhbiBleGNlcHRpb24gb2NjdXJzIHdoaWxlIGFkZGluZyBhIHNvdXJjZUJ1ZmZlciB0byBNZWRpYVNvdXJjZSAtIGRhdGEgOiB7ICBlcnIgOiBleGNlcHRpb24gLCBtaW1lVHlwZSA6IG1pbWVUeXBlIH1cclxuICBCVUZGRVJfQUREX0NPREVDX0VSUk9SOiAnYnVmZmVyQWRkQ29kZWNFcnJvcicsXHJcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBidWZmZXIgYXBwZW5kIGVycm9yIC0gZGF0YTogYXBwZW5kIGVycm9yIGRlc2NyaXB0aW9uXHJcbiAgQlVGRkVSX0FQUEVORF9FUlJPUjogJ2J1ZmZlckFwcGVuZEVycm9yJyxcclxuICAvLyBJZGVudGlmaWVyIGZvciBhIGJ1ZmZlciBhcHBlbmRpbmcgZXJyb3IgZXZlbnQgLSBkYXRhOiBhcHBlbmRpbmcgZXJyb3IgZGVzY3JpcHRpb25cclxuICBCVUZGRVJfQVBQRU5ESU5HX0VSUk9SOiAnYnVmZmVyQXBwZW5kaW5nRXJyb3InLFxyXG4gIC8vIElkZW50aWZpZXIgZm9yIGEgYnVmZmVyIHN0YWxsZWQgZXJyb3IgZXZlbnRcclxuICBCVUZGRVJfU1RBTExFRF9FUlJPUjogJ2J1ZmZlclN0YWxsZWRFcnJvcicsXHJcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBidWZmZXIgZnVsbCBldmVudFxyXG4gIEJVRkZFUl9GVUxMX0VSUk9SOiAnYnVmZmVyRnVsbEVycm9yJyxcclxuICAvLyBJZGVudGlmaWVyIGZvciBhIGJ1ZmZlciBzZWVrIG92ZXIgaG9sZSBldmVudFxyXG4gIEJVRkZFUl9TRUVLX09WRVJfSE9MRTogJ2J1ZmZlclNlZWtPdmVySG9sZScsXHJcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBidWZmZXIgbnVkZ2Ugb24gc3RhbGwgKHBsYXliYWNrIGlzIHN0dWNrIGFsdGhvdWdoIGN1cnJlbnRUaW1lIGlzIGluIGEgYnVmZmVyZWQgYXJlYSlcclxuICBCVUZGRVJfTlVER0VfT05fU1RBTEwgOiAnYnVmZmVyTnVkZ2VPblN0YWxsJyxcclxuICAvLyBJZGVudGlmaWVyIGZvciBhbiBpbnRlcm5hbCBleGNlcHRpb24gaGFwcGVuaW5nIGluc2lkZSBobHMuanMgd2hpbGUgaGFuZGxpbmcgYW4gZXZlbnRcclxuICBJTlRFUk5BTF9FWENFUFRJT046ICdpbnRlcm5hbEV4Y2VwdGlvbicsXHJcbiAgLy8gTWFsZm9ybWVkIFdlYlZUVCBjb250ZW50c1xyXG4gIFdFQlZUVF9FWENFUFRJT046ICd3ZWJWVFRFeGNlcHRpb24nXHJcbn07XHJcbiIsIi8qXHJcbipcclxuKiBBbGwgb2JqZWN0cyBpbiB0aGUgZXZlbnQgaGFuZGxpbmcgY2hhaW4gc2hvdWxkIGluaGVyaXQgZnJvbSB0aGlzIGNsYXNzXHJcbipcclxuKi9cclxuXHJcbmltcG9ydCB7bG9nZ2VyfSBmcm9tICcuL3V0aWxzL2xvZ2dlcic7XHJcbmltcG9ydCB7RXJyb3JUeXBlcywgRXJyb3JEZXRhaWxzfSBmcm9tICcuL2Vycm9ycyc7XHJcbmltcG9ydCBFdmVudCBmcm9tICcuL2V2ZW50cyc7XHJcblxyXG5jbGFzcyBFdmVudEhhbmRsZXIge1xyXG5cclxuICBjb25zdHJ1Y3RvcihobHMsIC4uLmV2ZW50cykge1xyXG4gICAgdGhpcy5obHMgPSBobHM7XHJcbiAgICB0aGlzLm9uRXZlbnQgPSB0aGlzLm9uRXZlbnQuYmluZCh0aGlzKTtcclxuICAgIHRoaXMuaGFuZGxlZEV2ZW50cyA9IGV2ZW50cztcclxuICAgIHRoaXMudXNlR2VuZXJpY0hhbmRsZXIgPSB0cnVlO1xyXG5cclxuICAgIHRoaXMucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcclxuICB9XHJcblxyXG4gIGRlc3Ryb3koKSB7XHJcbiAgICB0aGlzLnVucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcclxuICB9XHJcblxyXG4gIGlzRXZlbnRIYW5kbGVyKCkge1xyXG4gICAgcmV0dXJuIHR5cGVvZiB0aGlzLmhhbmRsZWRFdmVudHMgPT09ICdvYmplY3QnICYmIHRoaXMuaGFuZGxlZEV2ZW50cy5sZW5ndGggJiYgdHlwZW9mIHRoaXMub25FdmVudCA9PT0gJ2Z1bmN0aW9uJztcclxuICB9XHJcblxyXG4gIHJlZ2lzdGVyTGlzdGVuZXJzKCkge1xyXG4gICAgaWYgKHRoaXMuaXNFdmVudEhhbmRsZXIoKSkge1xyXG4gICAgICB0aGlzLmhhbmRsZWRFdmVudHMuZm9yRWFjaChmdW5jdGlvbihldmVudCkge1xyXG4gICAgICAgIGlmIChldmVudCA9PT0gJ2hsc0V2ZW50R2VuZXJpYycpIHtcclxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRm9yYmlkZGVuIGV2ZW50IG5hbWU6ICcgKyBldmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuaGxzLm9uKGV2ZW50LCB0aGlzLm9uRXZlbnQpO1xyXG4gICAgICB9LCB0aGlzKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHVucmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XHJcbiAgICBpZiAodGhpcy5pc0V2ZW50SGFuZGxlcigpKSB7XHJcbiAgICAgIHRoaXMuaGFuZGxlZEV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGV2ZW50KSB7XHJcbiAgICAgICAgdGhpcy5obHMub2ZmKGV2ZW50LCB0aGlzLm9uRXZlbnQpO1xyXG4gICAgICB9LCB0aGlzKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIGFyZ3VtZW50czogZXZlbnQgKHN0cmluZyksIGRhdGEgKGFueSlcclxuICAgKi9cclxuICBvbkV2ZW50KGV2ZW50LCBkYXRhKSB7XHJcbiAgICB0aGlzLm9uRXZlbnRHZW5lcmljKGV2ZW50LCBkYXRhKTtcclxuICB9XHJcblxyXG4gIG9uRXZlbnRHZW5lcmljKGV2ZW50LCBkYXRhKSB7XHJcbiAgICB2YXIgZXZlbnRUb0Z1bmN0aW9uID0gZnVuY3Rpb24oZXZlbnQsIGRhdGEpIHtcclxuICAgICAgdmFyIGZ1bmNOYW1lID0gJ29uJyArIGV2ZW50LnJlcGxhY2UoJ2hscycsICcnKTtcclxuICAgICAgaWYgKHR5cGVvZiB0aGlzW2Z1bmNOYW1lXSAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRXZlbnQgJHtldmVudH0gaGFzIG5vIGdlbmVyaWMgaGFuZGxlciBpbiB0aGlzICR7dGhpcy5jb25zdHJ1Y3Rvci5uYW1lfSBjbGFzcyAodHJpZWQgJHtmdW5jTmFtZX0pYCk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHRoaXNbZnVuY05hbWVdLmJpbmQodGhpcywgZGF0YSk7XHJcbiAgICB9O1xyXG4gICAgdHJ5IHtcclxuICAgICAgZXZlbnRUb0Z1bmN0aW9uLmNhbGwodGhpcywgZXZlbnQsIGRhdGEpLmNhbGwoKTtcclxuICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICBsb2dnZXIuZXJyb3IoYGludGVybmFsIGVycm9yIGhhcHBlbmVkIHdoaWxlIHByb2Nlc3NpbmcgJHtldmVudH06JHtlcnIubWVzc2FnZX1gKTtcclxuICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5FUlJPUiwge3R5cGU6IEVycm9yVHlwZXMuT1RIRVJfRVJST1IsIGRldGFpbHM6IEVycm9yRGV0YWlscy5JTlRFUk5BTF9FWENFUFRJT04sIGZhdGFsOiBmYWxzZSwgZXZlbnQgOiBldmVudCwgZXJyIDogZXJyfSk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBFdmVudEhhbmRsZXI7XHJcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xyXG4gIC8vIGZpcmVkIGJlZm9yZSBNZWRpYVNvdXJjZSBpcyBhdHRhY2hpbmcgdG8gbWVkaWEgZWxlbWVudCAtIGRhdGE6IHsgbWVkaWEgfVxyXG4gIE1FRElBX0FUVEFDSElORzogJ2hsc01lZGlhQXR0YWNoaW5nJyxcclxuICAvLyBmaXJlZCB3aGVuIE1lZGlhU291cmNlIGhhcyBiZWVuIHN1Y2Nlc2Z1bGx5IGF0dGFjaGVkIHRvIG1lZGlhIGVsZW1lbnQgLSBkYXRhOiB7IH1cclxuICBNRURJQV9BVFRBQ0hFRDogJ2hsc01lZGlhQXR0YWNoZWQnLFxyXG4gIC8vIGZpcmVkIGJlZm9yZSBkZXRhY2hpbmcgTWVkaWFTb3VyY2UgZnJvbSBtZWRpYSBlbGVtZW50IC0gZGF0YTogeyB9XHJcbiAgTUVESUFfREVUQUNISU5HOiAnaGxzTWVkaWFEZXRhY2hpbmcnLFxyXG4gIC8vIGZpcmVkIHdoZW4gTWVkaWFTb3VyY2UgaGFzIGJlZW4gZGV0YWNoZWQgZnJvbSBtZWRpYSBlbGVtZW50IC0gZGF0YTogeyB9XHJcbiAgTUVESUFfREVUQUNIRUQ6ICdobHNNZWRpYURldGFjaGVkJyxcclxuICAvLyBmaXJlZCB3aGVuIHdlIGJ1ZmZlciBpcyBnb2luZyB0byBiZSByZXNldCAtIGRhdGE6IHsgfVxyXG4gIEJVRkZFUl9SRVNFVDogJ2hsc0J1ZmZlclJlc2V0JyxcclxuICAvLyBmaXJlZCB3aGVuIHdlIGtub3cgYWJvdXQgdGhlIGNvZGVjcyB0aGF0IHdlIG5lZWQgYnVmZmVycyBmb3IgdG8gcHVzaCBpbnRvIC0gZGF0YToge3RyYWNrcyA6IHsgY29udGFpbmVyLCBjb2RlYywgbGV2ZWxDb2RlYywgaW5pdFNlZ21lbnQsIG1ldGFkYXRhIH19XHJcbiAgQlVGRkVSX0NPREVDUzogJ2hsc0J1ZmZlckNvZGVjcycsXHJcbiAgLy8gZmlyZWQgd2hlbiBzb3VyY2VidWZmZXJzIGhhdmUgYmVlbiBjcmVhdGVkIC0gZGF0YTogeyB0cmFja3MgOiB0cmFja3MgfVxyXG4gIEJVRkZFUl9DUkVBVEVEOiAnaGxzQnVmZmVyQ3JlYXRlZCcsXHJcbiAgLy8gZmlyZWQgd2hlbiB3ZSBhcHBlbmQgYSBzZWdtZW50IHRvIHRoZSBidWZmZXIgLSBkYXRhOiB7IHNlZ21lbnQ6IHNlZ21lbnQgb2JqZWN0IH1cclxuICBCVUZGRVJfQVBQRU5ESU5HOiAnaGxzQnVmZmVyQXBwZW5kaW5nJyxcclxuICAvLyBmaXJlZCB3aGVuIHdlIGFyZSBkb25lIHdpdGggYXBwZW5kaW5nIGEgbWVkaWEgc2VnbWVudCB0byB0aGUgYnVmZmVyIC0gZGF0YSA6IHsgcGFyZW50IDogc2VnbWVudCBwYXJlbnQgdGhhdCB0cmlnZ2VyZWQgQlVGRkVSX0FQUEVORElORywgcGVuZGluZyA6IG5iIG9mIHNlZ21lbnRzIHdhaXRpbmcgZm9yIGFwcGVuZGluZyBmb3IgdGhpcyBzZWdtZW50IHBhcmVudH1cclxuICBCVUZGRVJfQVBQRU5ERUQ6ICdobHNCdWZmZXJBcHBlbmRlZCcsXHJcbiAgLy8gZmlyZWQgd2hlbiB0aGUgc3RyZWFtIGlzIGZpbmlzaGVkIGFuZCB3ZSB3YW50IHRvIG5vdGlmeSB0aGUgbWVkaWEgYnVmZmVyIHRoYXQgdGhlcmUgd2lsbCBiZSBubyBtb3JlIGRhdGEgLSBkYXRhOiB7IH1cclxuICBCVUZGRVJfRU9TOiAnaGxzQnVmZmVyRW9zJyxcclxuICAvLyBmaXJlZCB3aGVuIHRoZSBtZWRpYSBidWZmZXIgc2hvdWxkIGJlIGZsdXNoZWQgLSBkYXRhIHsgc3RhcnRPZmZzZXQsIGVuZE9mZnNldCB9XHJcbiAgQlVGRkVSX0ZMVVNISU5HOiAnaGxzQnVmZmVyRmx1c2hpbmcnLFxyXG4gIC8vIGZpcmVkIHdoZW4gdGhlIG1lZGlhIGJ1ZmZlciBoYXMgYmVlbiBmbHVzaGVkIC0gZGF0YTogeyB9XHJcbiAgQlVGRkVSX0ZMVVNIRUQ6ICdobHNCdWZmZXJGbHVzaGVkJyxcclxuICAvLyBmaXJlZCB0byBzaWduYWwgdGhhdCBhIG1hbmlmZXN0IGxvYWRpbmcgc3RhcnRzIC0gZGF0YTogeyB1cmwgOiBtYW5pZmVzdFVSTH1cclxuICBNQU5JRkVTVF9MT0FESU5HOiAnaGxzTWFuaWZlc3RMb2FkaW5nJyxcclxuICAvLyBmaXJlZCBhZnRlciBtYW5pZmVzdCBoYXMgYmVlbiBsb2FkZWQgLSBkYXRhOiB7IGxldmVscyA6IFthdmFpbGFibGUgcXVhbGl0eSBsZXZlbHNdLCBhdWRpb1RyYWNrcyA6IFsgYXZhaWxhYmxlIGF1ZGlvIHRyYWNrc10sIHVybCA6IG1hbmlmZXN0VVJMLCBzdGF0cyA6IHsgdHJlcXVlc3QsIHRmaXJzdCwgdGxvYWQsIG10aW1lfX1cclxuICBNQU5JRkVTVF9MT0FERUQ6ICdobHNNYW5pZmVzdExvYWRlZCcsXHJcbiAgLy8gZmlyZWQgYWZ0ZXIgbWFuaWZlc3QgaGFzIGJlZW4gcGFyc2VkIC0gZGF0YTogeyBsZXZlbHMgOiBbYXZhaWxhYmxlIHF1YWxpdHkgbGV2ZWxzXSwgZmlyc3RMZXZlbCA6IGluZGV4IG9mIGZpcnN0IHF1YWxpdHkgbGV2ZWwgYXBwZWFyaW5nIGluIE1hbmlmZXN0fVxyXG4gIE1BTklGRVNUX1BBUlNFRDogJ2hsc01hbmlmZXN0UGFyc2VkJyxcclxuICAvLyBmaXJlZCB3aGVuIGEgbGV2ZWwgc3dpdGNoIGlzIHJlcXVlc3RlZCAtIGRhdGE6IHsgbGV2ZWwgOiBpZCBvZiBuZXcgbGV2ZWwgfSAvLyBkZXByZWNhdGVkIGluIGZhdm9yIExFVkVMX1NXSVRDSElOR1xyXG4gIExFVkVMX1NXSVRDSDogJ2hsc0xldmVsU3dpdGNoJyxcclxuICAvLyBmaXJlZCB3aGVuIGEgbGV2ZWwgc3dpdGNoIGlzIHJlcXVlc3RlZCAtIGRhdGE6IHsgbGV2ZWwgOiBpZCBvZiBuZXcgbGV2ZWwgfVxyXG4gIExFVkVMX1NXSVRDSElORzogJ2hsc0xldmVsU3dpdGNoaW5nJyxcclxuICAvLyBmaXJlZCB3aGVuIGEgbGV2ZWwgc3dpdGNoIGlzIGVmZmVjdGl2ZSAtIGRhdGE6IHsgbGV2ZWwgOiBpZCBvZiBuZXcgbGV2ZWwgfVxyXG4gIExFVkVMX1NXSVRDSEVEOiAnaGxzTGV2ZWxTd2l0Y2hlZCcsXHJcbiAgLy8gZmlyZWQgd2hlbiBhIGxldmVsIHBsYXlsaXN0IGxvYWRpbmcgc3RhcnRzIC0gZGF0YTogeyB1cmwgOiBsZXZlbCBVUkwsIGxldmVsIDogaWQgb2YgbGV2ZWwgYmVpbmcgbG9hZGVkfVxyXG4gIExFVkVMX0xPQURJTkc6ICdobHNMZXZlbExvYWRpbmcnLFxyXG4gIC8vIGZpcmVkIHdoZW4gYSBsZXZlbCBwbGF5bGlzdCBsb2FkaW5nIGZpbmlzaGVzIC0gZGF0YTogeyBkZXRhaWxzIDogbGV2ZWxEZXRhaWxzIG9iamVjdCwgbGV2ZWwgOiBpZCBvZiBsb2FkZWQgbGV2ZWwsIHN0YXRzIDogeyB0cmVxdWVzdCwgdGZpcnN0LCB0bG9hZCwgbXRpbWV9IH1cclxuICBMRVZFTF9MT0FERUQ6ICdobHNMZXZlbExvYWRlZCcsXHJcbiAgLy8gZmlyZWQgd2hlbiBhIGxldmVsJ3MgZGV0YWlscyBoYXZlIGJlZW4gdXBkYXRlZCBiYXNlZCBvbiBwcmV2aW91cyBkZXRhaWxzLCBhZnRlciBpdCBoYXMgYmVlbiBsb2FkZWQgLSBkYXRhOiB7IGRldGFpbHMgOiBsZXZlbERldGFpbHMgb2JqZWN0LCBsZXZlbCA6IGlkIG9mIHVwZGF0ZWQgbGV2ZWwgfVxyXG4gIExFVkVMX1VQREFURUQ6ICdobHNMZXZlbFVwZGF0ZWQnLFxyXG4gIC8vIGZpcmVkIHdoZW4gYSBsZXZlbCdzIFBUUyBpbmZvcm1hdGlvbiBoYXMgYmVlbiB1cGRhdGVkIGFmdGVyIHBhcnNpbmcgYSBmcmFnbWVudCAtIGRhdGE6IHsgZGV0YWlscyA6IGxldmVsRGV0YWlscyBvYmplY3QsIGxldmVsIDogaWQgb2YgdXBkYXRlZCBsZXZlbCwgZHJpZnQ6IFBUUyBkcmlmdCBvYnNlcnZlZCB3aGVuIHBhcnNpbmcgbGFzdCBmcmFnbWVudCB9XHJcbiAgTEVWRUxfUFRTX1VQREFURUQ6ICdobHNMZXZlbFB0c1VwZGF0ZWQnLFxyXG4gIC8vIGZpcmVkIHRvIG5vdGlmeSB0aGF0IGF1ZGlvIHRyYWNrIGxpc3RzIGhhcyBiZWVuIHVwZGF0ZWQgLSBkYXRhOiB7IGF1ZGlvVHJhY2tzIDogYXVkaW9UcmFja3MgfVxyXG4gIEFVRElPX1RSQUNLU19VUERBVEVEOiAnaGxzQXVkaW9UcmFja3NVcGRhdGVkJyxcclxuICAvLyBmaXJlZCB3aGVuIGFuIGF1ZGlvIHRyYWNrIHN3aXRjaCBvY2N1cnMgLSBkYXRhOiB7IGlkIDogYXVkaW8gdHJhY2sgaWQgfSAvLyBkZXByZWNhdGVkIGluIGZhdm9yIEFVRElPX1RSQUNLX1NXSVRDSElOR1xyXG4gIEFVRElPX1RSQUNLX1NXSVRDSDogJ2hsc0F1ZGlvVHJhY2tTd2l0Y2gnLFxyXG4gIC8vIGZpcmVkIHdoZW4gYW4gYXVkaW8gdHJhY2sgc3dpdGNoaW5nIGlzIHJlcXVlc3RlZCAtIGRhdGE6IHsgaWQgOiBhdWRpbyB0cmFjayBpZCB9XHJcbiAgQVVESU9fVFJBQ0tfU1dJVENISU5HOiAnaGxzQXVkaW9UcmFja1N3aXRjaGluZycsXHJcbiAgLy8gZmlyZWQgd2hlbiBhbiBhdWRpbyB0cmFjayBzd2l0Y2ggYWN0dWFsbHkgb2NjdXJzIC0gZGF0YTogeyBpZCA6IGF1ZGlvIHRyYWNrIGlkIH1cclxuICBBVURJT19UUkFDS19TV0lUQ0hFRDogJ2hsc0F1ZGlvVHJhY2tTd2l0Y2hlZCcsXHJcbiAgLy8gZmlyZWQgd2hlbiBhbiBhdWRpbyB0cmFjayBsb2FkaW5nIHN0YXJ0cyAtIGRhdGE6IHsgdXJsIDogYXVkaW8gdHJhY2sgVVJMLCBpZCA6IGF1ZGlvIHRyYWNrIGlkIH1cclxuICBBVURJT19UUkFDS19MT0FESU5HOiAnaGxzQXVkaW9UcmFja0xvYWRpbmcnLFxyXG4gIC8vIGZpcmVkIHdoZW4gYW4gYXVkaW8gdHJhY2sgbG9hZGluZyBmaW5pc2hlcyAtIGRhdGE6IHsgZGV0YWlscyA6IGxldmVsRGV0YWlscyBvYmplY3QsIGlkIDogYXVkaW8gdHJhY2sgaWQsIHN0YXRzIDogeyB0cmVxdWVzdCwgdGZpcnN0LCB0bG9hZCwgbXRpbWUgfSB9XHJcbiAgQVVESU9fVFJBQ0tfTE9BREVEOiAnaGxzQXVkaW9UcmFja0xvYWRlZCcsXHJcbiAgLy8gZmlyZWQgdG8gbm90aWZ5IHRoYXQgc3VidGl0bGUgdHJhY2sgbGlzdHMgaGFzIGJlZW4gdXBkYXRlZCAtIGRhdGE6IHsgc3VidGl0bGVUcmFja3MgOiBzdWJ0aXRsZVRyYWNrcyB9XHJcbiAgU1VCVElUTEVfVFJBQ0tTX1VQREFURUQ6ICdobHNTdWJ0aXRsZVRyYWNrc1VwZGF0ZWQnLFxyXG4gIC8vIGZpcmVkIHdoZW4gYW4gc3VidGl0bGUgdHJhY2sgc3dpdGNoIG9jY3VycyAtIGRhdGE6IHsgaWQgOiBzdWJ0aXRsZSB0cmFjayBpZCB9XHJcbiAgU1VCVElUTEVfVFJBQ0tfU1dJVENIOiAnaGxzU3VidGl0bGVUcmFja1N3aXRjaCcsXHJcbiAgLy8gZmlyZWQgd2hlbiBhIHN1YnRpdGxlIHRyYWNrIGxvYWRpbmcgc3RhcnRzIC0gZGF0YTogeyB1cmwgOiBzdWJ0aXRsZSB0cmFjayBVUkwsIGlkIDogc3VidGl0bGUgdHJhY2sgaWQgfVxyXG4gIFNVQlRJVExFX1RSQUNLX0xPQURJTkc6ICdobHNTdWJ0aXRsZVRyYWNrTG9hZGluZycsXHJcbiAgLy8gZmlyZWQgd2hlbiBhIHN1YnRpdGxlIHRyYWNrIGxvYWRpbmcgZmluaXNoZXMgLSBkYXRhOiB7IGRldGFpbHMgOiBsZXZlbERldGFpbHMgb2JqZWN0LCBpZCA6IHN1YnRpdGxlIHRyYWNrIGlkLCBzdGF0cyA6IHsgdHJlcXVlc3QsIHRmaXJzdCwgdGxvYWQsIG10aW1lIH0gfVxyXG4gIFNVQlRJVExFX1RSQUNLX0xPQURFRDogJ2hsc1N1YnRpdGxlVHJhY2tMb2FkZWQnLFxyXG4gIC8vIGZpcmVkIHdoZW4gYSBzdWJ0aXRsZSBmcmFnbWVudCBoYXMgYmVlbiBwcm9jZXNzZWQgLSBkYXRhOiB7IHN1Y2Nlc3MgOiBib29sZWFuLCBmcmFnIDogdGhlIHByb2Nlc3NlZCBmcmFnIH1cclxuICBTVUJUSVRMRV9GUkFHX1BST0NFU1NFRDogJ2hsc1N1YnRpdGxlRnJhZ1Byb2Nlc3NlZCcsXHJcbiAgLy8gZmlyZWQgd2hlbiB0aGUgZmlyc3QgdGltZXN0YW1wIGlzIGZvdW5kIC0gZGF0YTogeyBpZCA6IGRlbXV4ZXIgaWQsIGluaXRQVFM6IGluaXRQVFMsIGZyYWcgOiBmcmFnbWVudCBvYmplY3QgfVxyXG4gIElOSVRfUFRTX0ZPVU5EOiAnaGxzSW5pdFB0c0ZvdW5kJyxcclxuICAvLyBmaXJlZCB3aGVuIGEgZnJhZ21lbnQgbG9hZGluZyBzdGFydHMgLSBkYXRhOiB7IGZyYWcgOiBmcmFnbWVudCBvYmplY3QgfVxyXG4gIEZSQUdfTE9BRElORzogJ2hsc0ZyYWdMb2FkaW5nJyxcclxuICAvLyBmaXJlZCB3aGVuIGEgZnJhZ21lbnQgbG9hZGluZyBpcyBwcm9ncmVzc2luZyAtIGRhdGE6IHsgZnJhZyA6IGZyYWdtZW50IG9iamVjdCwgeyB0cmVxdWVzdCwgdGZpcnN0LCBsb2FkZWQgfSB9XHJcbiAgRlJBR19MT0FEX1BST0dSRVNTOiAnaGxzRnJhZ0xvYWRQcm9ncmVzcycsXHJcbiAgLy8gSWRlbnRpZmllciBmb3IgZnJhZ21lbnQgbG9hZCBhYm9ydGluZyBmb3IgZW1lcmdlbmN5IHN3aXRjaCBkb3duIC0gZGF0YTogeyBmcmFnIDogZnJhZ21lbnQgb2JqZWN0IH1cclxuICBGUkFHX0xPQURfRU1FUkdFTkNZX0FCT1JURUQ6ICdobHNGcmFnTG9hZEVtZXJnZW5jeUFib3J0ZWQnLFxyXG4gIC8vIGZpcmVkIHdoZW4gYSBmcmFnbWVudCBsb2FkaW5nIGlzIGNvbXBsZXRlZCAtIGRhdGE6IHsgZnJhZyA6IGZyYWdtZW50IG9iamVjdCwgcGF5bG9hZCA6IGZyYWdtZW50IHBheWxvYWQsIHN0YXRzIDogeyB0cmVxdWVzdCwgdGZpcnN0LCB0bG9hZCwgbGVuZ3RoIH0gfVxyXG4gIEZSQUdfTE9BREVEOiAnaGxzRnJhZ0xvYWRlZCcsXHJcbiAgLy8gZmlyZWQgd2hlbiBhIGZyYWdtZW50IGhhcyBmaW5pc2hlZCBkZWNyeXB0aW5nIC0gZGF0YTogeyBpZCA6IGRlbXV4ZXIgaWQsIGZyYWc6IGZyYWdtZW50IG9iamVjdCwgc3RhdHMgOiB7IHRzdGFydCwgdGRlY3J5cHQgfSB9XHJcbiAgRlJBR19ERUNSWVBURUQ6ICdobHNGcmFnRGVjcnlwdGVkJyxcclxuICAvLyBmaXJlZCB3aGVuIEluaXQgU2VnbWVudCBoYXMgYmVlbiBleHRyYWN0ZWQgZnJvbSBmcmFnbWVudCAtIGRhdGE6IHsgaWQgOiBkZW11eGVyIGlkLCBmcmFnOiBmcmFnbWVudCBvYmplY3QsIG1vb3YgOiBtb292IE1QNCBib3gsIGNvZGVjcyA6IGNvZGVjcyBmb3VuZCB3aGlsZSBwYXJzaW5nIGZyYWdtZW50IH1cclxuICBGUkFHX1BBUlNJTkdfSU5JVF9TRUdNRU5UOiAnaGxzRnJhZ1BhcnNpbmdJbml0U2VnbWVudCcsXHJcbiAgLy8gZmlyZWQgd2hlbiBwYXJzaW5nIHNlaSB0ZXh0IGlzIGNvbXBsZXRlZCAtIGRhdGE6IHsgaWQgOiBkZW11eGVyIGlkLCBmcmFnOiBmcmFnbWVudCBvYmplY3QsIHNhbXBsZXMgOiBbIHNlaSBzYW1wbGVzIHBlcyBdIH1cclxuICBGUkFHX1BBUlNJTkdfVVNFUkRBVEE6ICdobHNGcmFnUGFyc2luZ1VzZXJkYXRhJyxcclxuICAvLyBmaXJlZCB3aGVuIHBhcnNpbmcgaWQzIGlzIGNvbXBsZXRlZCAtIGRhdGE6IHsgaWQgOiBkZW11eGVyIGlkLCBmcmFnOiBmcmFnbWVudCBvYmplY3QsIHNhbXBsZXMgOiBbIGlkMyBzYW1wbGVzIHBlcyBdIH1cclxuICBGUkFHX1BBUlNJTkdfTUVUQURBVEE6ICdobHNGcmFnUGFyc2luZ01ldGFkYXRhJyxcclxuICAvLyBmaXJlZCB3aGVuIGRhdGEgaGF2ZSBiZWVuIGV4dHJhY3RlZCBmcm9tIGZyYWdtZW50IC0gZGF0YTogeyBpZCA6IGRlbXV4ZXIgaWQsIGZyYWc6IGZyYWdtZW50IG9iamVjdCwgZGF0YTEgOiBtb29mIE1QNCBib3ggb3IgVFMgZnJhZ21lbnRzLCBkYXRhMiA6IG1kYXQgTVA0IGJveCBvciBudWxsfVxyXG4gIEZSQUdfUEFSU0lOR19EQVRBOiAnaGxzRnJhZ1BhcnNpbmdEYXRhJyxcclxuICAvLyBmaXJlZCB3aGVuIGZyYWdtZW50IHBhcnNpbmcgaXMgY29tcGxldGVkIC0gZGF0YTogeyBpZCA6IGRlbXV4ZXIgaWQsIGZyYWc6IGZyYWdtZW50IG9iamVjdCB9XHJcbiAgRlJBR19QQVJTRUQ6ICdobHNGcmFnUGFyc2VkJyxcclxuICAvLyBmaXJlZCB3aGVuIGZyYWdtZW50IHJlbXV4ZWQgTVA0IGJveGVzIGhhdmUgYWxsIGJlZW4gYXBwZW5kZWQgaW50byBTb3VyY2VCdWZmZXIgLSBkYXRhOiB7IGlkIDogZGVtdXhlciBpZCwgZnJhZyA6IGZyYWdtZW50IG9iamVjdCwgc3RhdHMgOiB7IHRyZXF1ZXN0LCB0Zmlyc3QsIHRsb2FkLCB0cGFyc2VkLCB0YnVmZmVyZWQsIGxlbmd0aCwgYndFc3RpbWF0ZSB9IH1cclxuICBGUkFHX0JVRkZFUkVEOiAnaGxzRnJhZ0J1ZmZlcmVkJyxcclxuICAvLyBmaXJlZCB3aGVuIGZyYWdtZW50IG1hdGNoaW5nIHdpdGggY3VycmVudCBtZWRpYSBwb3NpdGlvbiBpcyBjaGFuZ2luZyAtIGRhdGEgOiB7IGlkIDogZGVtdXhlciBpZCwgZnJhZyA6IGZyYWdtZW50IG9iamVjdCB9XHJcbiAgRlJBR19DSEFOR0VEOiAnaGxzRnJhZ0NoYW5nZWQnLFxyXG4gIC8vIElkZW50aWZpZXIgZm9yIGEgRlBTIGRyb3AgZXZlbnQgLSBkYXRhOiB7IGN1cmVudERyb3BwZWQsIGN1cnJlbnREZWNvZGVkLCB0b3RhbERyb3BwZWRGcmFtZXMgfVxyXG4gIEZQU19EUk9QOiAnaGxzRnBzRHJvcCcsXHJcbiAgLy90cmlnZ2VyZWQgd2hlbiBGUFMgZHJvcCB0cmlnZ2VycyBhdXRvIGxldmVsIGNhcHBpbmcgLSBkYXRhOiB7IGxldmVsLCBkcm9wcGVkbGV2ZWwgfVxyXG4gIEZQU19EUk9QX0xFVkVMX0NBUFBJTkc6ICdobHNGcHNEcm9wTGV2ZWxDYXBwaW5nJyxcclxuICAvLyBJZGVudGlmaWVyIGZvciBhbiBlcnJvciBldmVudCAtIGRhdGE6IHsgdHlwZSA6IGVycm9yIHR5cGUsIGRldGFpbHMgOiBlcnJvciBkZXRhaWxzLCBmYXRhbCA6IGlmIHRydWUsIGhscy5qcyBjYW5ub3Qvd2lsbCBub3QgdHJ5IHRvIHJlY292ZXIsIGlmIGZhbHNlLCBobHMuanMgd2lsbCB0cnkgdG8gcmVjb3ZlcixvdGhlciBlcnJvciBzcGVjaWZpYyBkYXRhIH1cclxuICBFUlJPUjogJ2hsc0Vycm9yJyxcclxuICAvLyBmaXJlZCB3aGVuIGhscy5qcyBpbnN0YW5jZSBzdGFydHMgZGVzdHJveWluZy4gRGlmZmVyZW50IGZyb20gTUVESUFfREVUQUNIRUQgYXMgb25lIGNvdWxkIHdhbnQgdG8gZGV0YWNoIGFuZCByZWF0dGFjaCBhIG1lZGlhIHRvIHRoZSBpbnN0YW5jZSBvZiBobHMuanMgdG8gaGFuZGxlIG1pZC1yb2xscyBmb3IgZXhhbXBsZSAtIGRhdGE6IHsgfVxyXG4gIERFU1RST1lJTkc6ICdobHNEZXN0cm95aW5nJyxcclxuICAvLyBmaXJlZCB3aGVuIGEgZGVjcnlwdCBrZXkgbG9hZGluZyBzdGFydHMgLSBkYXRhOiB7IGZyYWcgOiBmcmFnbWVudCBvYmplY3QgfVxyXG4gIEtFWV9MT0FESU5HOiAnaGxzS2V5TG9hZGluZycsXHJcbiAgLy8gZmlyZWQgd2hlbiBhIGRlY3J5cHQga2V5IGxvYWRpbmcgaXMgY29tcGxldGVkIC0gZGF0YTogeyBmcmFnIDogZnJhZ21lbnQgb2JqZWN0LCBwYXlsb2FkIDoga2V5IHBheWxvYWQsIHN0YXRzIDogeyB0cmVxdWVzdCwgdGZpcnN0LCB0bG9hZCwgbGVuZ3RoIH0gfVxyXG4gIEtFWV9MT0FERUQ6ICdobHNLZXlMb2FkZWQnLFxyXG4gIC8vIGZpcmVkIHVwb24gc3RyZWFtIGNvbnRyb2xsZXIgc3RhdGUgdHJhbnNpdGlvbnMgLSBkYXRhOiB7IHByZXZpb3VzU3RhdGUsIG5leHRTdGF0ZSB9XHJcbiAgU1RSRUFNX1NUQVRFX1RSQU5TSVRJT046ICdobHNTdHJlYW1TdGF0ZVRyYW5zaXRpb24nXHJcbn07XHJcbiIsIi8qKlxyXG4gKiAgQUFDIGhlbHBlclxyXG4gKi9cclxuXHJcbmNsYXNzIEFBQyB7XHJcbiAgc3RhdGljIGdldFNpbGVudEZyYW1lKGNvZGVjLGNoYW5uZWxDb3VudCkge1xyXG4gICAgc3dpdGNoKGNvZGVjKSB7XHJcbiAgICAgIGNhc2UgJ21wNGEuNDAuMic6XHJcbiAgICAgICAgaWYgKGNoYW5uZWxDb3VudCA9PT0gMSkge1xyXG4gICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFsweDAwLCAweGM4LCAweDAwLCAweDgwLCAweDIzLCAweDgwXSk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChjaGFubmVsQ291bnQgPT09IDIpIHtcclxuICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShbMHgyMSwgMHgwMCwgMHg0OSwgMHg5MCwgMHgwMiwgMHgxOSwgMHgwMCwgMHgyMywgMHg4MF0pO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoY2hhbm5lbENvdW50ID09PSAzKSB7XHJcbiAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzB4MDAsIDB4YzgsIDB4MDAsIDB4ODAsIDB4MjAsIDB4ODQsIDB4MDEsIDB4MjYsIDB4NDAsIDB4MDgsIDB4NjQsIDB4MDAsIDB4OGVdKTtcclxuICAgICAgICB9IGVsc2UgaWYgKGNoYW5uZWxDb3VudCA9PT0gNCkge1xyXG4gICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFsweDAwLCAweGM4LCAweDAwLCAweDgwLCAweDIwLCAweDg0LCAweDAxLCAweDI2LCAweDQwLCAweDA4LCAweDY0LCAweDAwLCAweDgwLCAweDJjLCAweDgwLCAweDA4LCAweDAyLCAweDM4XSk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChjaGFubmVsQ291bnQgPT09IDUpIHtcclxuICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShbMHgwMCwgMHhjOCwgMHgwMCwgMHg4MCwgMHgyMCwgMHg4NCwgMHgwMSwgMHgyNiwgMHg0MCwgMHgwOCwgMHg2NCwgMHgwMCwgMHg4MiwgMHgzMCwgMHgwNCwgMHg5OSwgMHgwMCwgMHgyMSwgMHg5MCwgMHgwMiwgMHgzOF0pO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoY2hhbm5lbENvdW50ID09PSA2KSB7XHJcbiAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzB4MDAsIDB4YzgsIDB4MDAsIDB4ODAsIDB4MjAsIDB4ODQsIDB4MDEsIDB4MjYsIDB4NDAsIDB4MDgsIDB4NjQsIDB4MDAsIDB4ODIsIDB4MzAsIDB4MDQsIDB4OTksIDB4MDAsIDB4MjEsIDB4OTAsIDB4MDIsIDB4MDAsIDB4YjIsIDB4MDAsIDB4MjAsIDB4MDgsIDB4ZTBdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAvLyBoYW5kbGUgSEUtQUFDIGJlbG93IChtcDRhLjQwLjUgLyBtcDRhLjQwLjI5KVxyXG4gICAgICBkZWZhdWx0OlxyXG4gICAgICAgIGlmIChjaGFubmVsQ291bnQgPT09IDEpIHtcclxuICAgICAgICAgIC8vIGZmbXBlZyAteSAtZiBsYXZmaSAtaSBcImFldmFsc3JjPTA6ZD0wLjA1XCIgLWM6YSBsaWJmZGtfYWFjIC1wcm9maWxlOmEgYWFjX2hlIC1iOmEgNGsgb3V0cHV0LmFhYyAmJiBoZXhkdW1wIC12IC1lICcxNi8xIFwiMHgleCxcIiBcIlxcblwiJyAtdiBvdXRwdXQuYWFjXHJcbiAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzB4MSwweDQwLDB4MjIsMHg4MCwweGEzLDB4NGUsMHhlNiwweDgwLDB4YmEsMHg4LDB4MCwweDAsMHgwLDB4MWMsMHg2LDB4ZjEsMHhjMSwweGEsMHg1YSwweDVhLDB4NWEsMHg1YSwweDVhLDB4NWEsMHg1YSwweDVhLDB4NWEsMHg1YSwweDVhLDB4NWEsMHg1YSwweDVhLDB4NWEsMHg1YSwweDVhLDB4NWEsMHg1YSwweDVhLDB4NWEsMHg1YSwweDVhLDB4NWEsMHg1YSwweDVhLDB4NWEsMHg1YSwweDVhLDB4NWEsMHg1YSwweDVhLDB4NWEsMHg1YSwweDVhLDB4NWEsMHg1YSwweDVhLDB4NWEsMHg1YSwweDVlXSk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChjaGFubmVsQ291bnQgPT09IDIpIHtcclxuICAgICAgICAgIC8vIGZmbXBlZyAteSAtZiBsYXZmaSAtaSBcImFldmFsc3JjPTB8MDpkPTAuMDVcIiAtYzphIGxpYmZka19hYWMgLXByb2ZpbGU6YSBhYWNfaGVfdjIgLWI6YSA0ayBvdXRwdXQuYWFjICYmIGhleGR1bXAgLXYgLWUgJzE2LzEgXCIweCV4LFwiIFwiXFxuXCInIC12IG91dHB1dC5hYWNcclxuICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShbMHgxLDB4NDAsMHgyMiwweDgwLDB4YTMsMHg1ZSwweGU2LDB4ODAsMHhiYSwweDgsMHgwLDB4MCwweDAsMHgwLDB4OTUsMHgwLDB4NiwweGYxLDB4YTEsMHhhLDB4NWEsMHg1YSwweDVhLDB4NWEsMHg1YSwweDVhLDB4NWEsMHg1YSwweDVhLDB4NWEsMHg1YSwweDVhLDB4NWEsMHg1YSwweDVhLDB4NWEsMHg1YSwweDVhLDB4NWEsMHg1YSwweDVhLDB4NWEsMHg1YSwweDVhLDB4NWEsMHg1YSwweDVhLDB4NWEsMHg1YSwweDVhLDB4NWEsMHg1YSwweDVhLDB4NWEsMHg1YSwweDVhLDB4NWEsMHg1YSwweDVlXSk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChjaGFubmVsQ291bnQgPT09IDMpIHtcclxuICAgICAgICAgIC8vIGZmbXBlZyAteSAtZiBsYXZmaSAtaSBcImFldmFsc3JjPTB8MHwwOmQ9MC4wNVwiIC1jOmEgbGliZmRrX2FhYyAtcHJvZmlsZTphIGFhY19oZV92MiAtYjphIDRrIG91dHB1dC5hYWMgJiYgaGV4ZHVtcCAtdiAtZSAnMTYvMSBcIjB4JXgsXCIgXCJcXG5cIicgLXYgb3V0cHV0LmFhY1xyXG4gICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFsweDEsMHg0MCwweDIyLDB4ODAsMHhhMywweDVlLDB4ZTYsMHg4MCwweGJhLDB4OCwweDAsMHgwLDB4MCwweDAsMHg5NSwweDAsMHg2LDB4ZjEsMHhhMSwweGEsMHg1YSwweDVhLDB4NWEsMHg1YSwweDVhLDB4NWEsMHg1YSwweDVhLDB4NWEsMHg1YSwweDVhLDB4NWEsMHg1YSwweDVhLDB4NWEsMHg1YSwweDVhLDB4NWEsMHg1YSwweDVhLDB4NWEsMHg1YSwweDVhLDB4NWEsMHg1YSwweDVhLDB4NWEsMHg1YSwweDVhLDB4NWEsMHg1YSwweDVhLDB4NWEsMHg1YSwweDVhLDB4NWEsMHg1YSwweDVhLDB4NWVdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IEFBQztcclxuIiwiLyoqXHJcbiAqIEJ1ZmZlciBIZWxwZXIgdXRpbHMsIHByb3ZpZGluZyBtZXRob2RzIGRlYWxpbmcgYnVmZmVyIGxlbmd0aCByZXRyaWV2YWxcclxuKi9cclxuXHJcbmNvbnN0IEJ1ZmZlckhlbHBlciA9IHtcclxuICBpc0J1ZmZlcmVkIDogZnVuY3Rpb24obWVkaWEscG9zaXRpb24pIHtcclxuICAgIGlmIChtZWRpYSkge1xyXG4gICAgICBsZXQgYnVmZmVyZWQgPSBtZWRpYS5idWZmZXJlZDtcclxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBidWZmZXJlZC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGlmIChwb3NpdGlvbiA+PSBidWZmZXJlZC5zdGFydChpKSAmJiBwb3NpdGlvbiA8PSBidWZmZXJlZC5lbmQoaSkpIHtcclxuICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH0sXHJcblxyXG4gIGJ1ZmZlckluZm8gOiBmdW5jdGlvbihtZWRpYSwgcG9zLG1heEhvbGVEdXJhdGlvbikge1xyXG4gICAgaWYgKG1lZGlhKSB7XHJcbiAgICAgIHZhciB2YnVmZmVyZWQgPSBtZWRpYS5idWZmZXJlZCwgYnVmZmVyZWQgPSBbXSxpO1xyXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgdmJ1ZmZlcmVkLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgYnVmZmVyZWQucHVzaCh7c3RhcnQ6IHZidWZmZXJlZC5zdGFydChpKSwgZW5kOiB2YnVmZmVyZWQuZW5kKGkpfSk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyZWRJbmZvKGJ1ZmZlcmVkLHBvcyxtYXhIb2xlRHVyYXRpb24pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuIHtsZW46IDAsIHN0YXJ0OiBwb3MsIGVuZDogcG9zLCBuZXh0U3RhcnQgOiB1bmRlZmluZWR9IDtcclxuICAgIH1cclxuICB9LFxyXG5cclxuICBidWZmZXJlZEluZm8gOiBmdW5jdGlvbihidWZmZXJlZCxwb3MsbWF4SG9sZUR1cmF0aW9uKSB7XHJcbiAgICB2YXIgYnVmZmVyZWQyID0gW10sXHJcbiAgICAgICAgLy8gYnVmZmVyU3RhcnQgYW5kIGJ1ZmZlckVuZCBhcmUgYnVmZmVyIGJvdW5kYXJpZXMgYXJvdW5kIGN1cnJlbnQgdmlkZW8gcG9zaXRpb25cclxuICAgICAgICBidWZmZXJMZW4sYnVmZmVyU3RhcnQsIGJ1ZmZlckVuZCxidWZmZXJTdGFydE5leHQsaTtcclxuICAgIC8vIHNvcnQgb24gYnVmZmVyLnN0YXJ0L3NtYWxsZXIgZW5kIChJRSBkb2VzIG5vdCBhbHdheXMgcmV0dXJuIHNvcnRlZCBidWZmZXJlZCByYW5nZSlcclxuICAgIGJ1ZmZlcmVkLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgdmFyIGRpZmYgPSBhLnN0YXJ0IC0gYi5zdGFydDtcclxuICAgICAgaWYgKGRpZmYpIHtcclxuICAgICAgICByZXR1cm4gZGlmZjtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gYi5lbmQgLSBhLmVuZDtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICAvLyB0aGVyZSBtaWdodCBiZSBzb21lIHNtYWxsIGhvbGVzIGJldHdlZW4gYnVmZmVyIHRpbWUgcmFuZ2VcclxuICAgIC8vIGNvbnNpZGVyIHRoYXQgaG9sZXMgc21hbGxlciB0aGFuIG1heEhvbGVEdXJhdGlvbiBhcmUgaXJyZWxldmFudCBhbmQgYnVpbGQgYW5vdGhlclxyXG4gICAgLy8gYnVmZmVyIHRpbWUgcmFuZ2UgcmVwcmVzZW50YXRpb25zIHRoYXQgZGlzY2FyZHMgdGhvc2UgaG9sZXNcclxuICAgIGZvciAoaSA9IDA7IGkgPCBidWZmZXJlZC5sZW5ndGg7IGkrKykge1xyXG4gICAgICB2YXIgYnVmMmxlbiA9IGJ1ZmZlcmVkMi5sZW5ndGg7XHJcbiAgICAgIGlmKGJ1ZjJsZW4pIHtcclxuICAgICAgICB2YXIgYnVmMmVuZCA9IGJ1ZmZlcmVkMltidWYybGVuIC0gMV0uZW5kO1xyXG4gICAgICAgIC8vIGlmIHNtYWxsIGhvbGUgKHZhbHVlIGJldHdlZW4gMCBvciBtYXhIb2xlRHVyYXRpb24gKSBvciBvdmVybGFwcGluZyAobmVnYXRpdmUpXHJcbiAgICAgICAgaWYoKGJ1ZmZlcmVkW2ldLnN0YXJ0IC0gYnVmMmVuZCkgPCBtYXhIb2xlRHVyYXRpb24pIHtcclxuICAgICAgICAgIC8vIG1lcmdlIG92ZXJsYXBwaW5nIHRpbWUgcmFuZ2VzXHJcbiAgICAgICAgICAvLyB1cGRhdGUgbGFzdFJhbmdlLmVuZCBvbmx5IGlmIHNtYWxsZXIgdGhhbiBpdGVtLmVuZFxyXG4gICAgICAgICAgLy8gZS5nLiAgWyAxLCAxNV0gd2l0aCAgWyAyLDhdID0+IFsgMSwxNV0gKG5vIG5lZWQgdG8gbW9kaWZ5IGxhc3RSYW5nZS5lbmQpXHJcbiAgICAgICAgICAvLyB3aGVyZWFzIFsgMSwgOF0gd2l0aCAgWyAyLDE1XSA9PiBbIDEsMTVdICggbGFzdFJhbmdlIHNob3VsZCBzd2l0Y2ggZnJvbSBbMSw4XSB0byBbMSwxNV0pXHJcbiAgICAgICAgICBpZihidWZmZXJlZFtpXS5lbmQgPiBidWYyZW5kKSB7XHJcbiAgICAgICAgICAgIGJ1ZmZlcmVkMltidWYybGVuIC0gMV0uZW5kID0gYnVmZmVyZWRbaV0uZW5kO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAvLyBiaWcgaG9sZVxyXG4gICAgICAgICAgYnVmZmVyZWQyLnB1c2goYnVmZmVyZWRbaV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBmaXJzdCB2YWx1ZVxyXG4gICAgICAgIGJ1ZmZlcmVkMi5wdXNoKGJ1ZmZlcmVkW2ldKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgZm9yIChpID0gMCwgYnVmZmVyTGVuID0gMCwgYnVmZmVyU3RhcnQgPSBidWZmZXJFbmQgPSBwb3M7IGkgPCBidWZmZXJlZDIubGVuZ3RoOyBpKyspIHtcclxuICAgICAgdmFyIHN0YXJ0ID0gIGJ1ZmZlcmVkMltpXS5zdGFydCxcclxuICAgICAgICAgIGVuZCA9IGJ1ZmZlcmVkMltpXS5lbmQ7XHJcbiAgICAgIC8vbG9nZ2VyLmxvZygnYnVmIHN0YXJ0L2VuZDonICsgYnVmZmVyZWQuc3RhcnQoaSkgKyAnLycgKyBidWZmZXJlZC5lbmQoaSkpO1xyXG4gICAgICBpZiAoKHBvcyArIG1heEhvbGVEdXJhdGlvbikgPj0gc3RhcnQgJiYgcG9zIDwgZW5kKSB7XHJcbiAgICAgICAgLy8gcGxheSBwb3NpdGlvbiBpcyBpbnNpZGUgdGhpcyBidWZmZXIgVGltZVJhbmdlLCByZXRyaWV2ZSBlbmQgb2YgYnVmZmVyIHBvc2l0aW9uIGFuZCBidWZmZXIgbGVuZ3RoXHJcbiAgICAgICAgYnVmZmVyU3RhcnQgPSBzdGFydDtcclxuICAgICAgICBidWZmZXJFbmQgPSBlbmQ7XHJcbiAgICAgICAgYnVmZmVyTGVuID0gYnVmZmVyRW5kIC0gcG9zO1xyXG4gICAgICB9IGVsc2UgaWYgKChwb3MgKyBtYXhIb2xlRHVyYXRpb24pIDwgc3RhcnQpIHtcclxuICAgICAgICBidWZmZXJTdGFydE5leHQgPSBzdGFydDtcclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtsZW46IGJ1ZmZlckxlbiwgc3RhcnQ6IGJ1ZmZlclN0YXJ0LCBlbmQ6IGJ1ZmZlckVuZCwgbmV4dFN0YXJ0IDogYnVmZmVyU3RhcnROZXh0fTtcclxuICB9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEJ1ZmZlckhlbHBlcjtcclxuIiwiLyoqXHJcbiAqIExldmVsIEhlbHBlciBjbGFzcywgcHJvdmlkaW5nIG1ldGhvZHMgZGVhbGluZyB3aXRoIHBsYXlsaXN0IHNsaWRpbmcgYW5kIGRyaWZ0XHJcbiovXHJcblxyXG5pbXBvcnQge2xvZ2dlcn0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcclxuXHJcbmNvbnN0IExldmVsSGVscGVyID0ge1xyXG5cclxuICBtZXJnZURldGFpbHMgOiBmdW5jdGlvbihvbGREZXRhaWxzLG5ld0RldGFpbHMpIHtcclxuICAgIHZhciBzdGFydCA9IE1hdGgubWF4KG9sZERldGFpbHMuc3RhcnRTTixuZXdEZXRhaWxzLnN0YXJ0U04pLW5ld0RldGFpbHMuc3RhcnRTTixcclxuICAgICAgICBlbmQgPSBNYXRoLm1pbihvbGREZXRhaWxzLmVuZFNOLG5ld0RldGFpbHMuZW5kU04pLW5ld0RldGFpbHMuc3RhcnRTTixcclxuICAgICAgICBkZWx0YSA9IG5ld0RldGFpbHMuc3RhcnRTTiAtIG9sZERldGFpbHMuc3RhcnRTTixcclxuICAgICAgICBvbGRmcmFnbWVudHMgPSBvbGREZXRhaWxzLmZyYWdtZW50cyxcclxuICAgICAgICBuZXdmcmFnbWVudHMgPSBuZXdEZXRhaWxzLmZyYWdtZW50cyxcclxuICAgICAgICBjY09mZnNldCA9MCxcclxuICAgICAgICBQVFNGcmFnO1xyXG5cclxuICAgIC8vIGNoZWNrIGlmIG9sZC9uZXcgcGxheWxpc3RzIGhhdmUgZnJhZ21lbnRzIGluIGNvbW1vblxyXG4gICAgaWYgKCBlbmQgPCBzdGFydCkge1xyXG4gICAgICBuZXdEZXRhaWxzLlBUU0tub3duID0gZmFsc2U7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIC8vIGxvb3AgdGhyb3VnaCBvdmVybGFwcGluZyBTTiBhbmQgdXBkYXRlIHN0YXJ0UFRTICwgY2MsIGFuZCBkdXJhdGlvbiBpZiBhbnkgZm91bmRcclxuICAgIGZvcih2YXIgaSA9IHN0YXJ0IDsgaSA8PSBlbmQgOyBpKyspIHtcclxuICAgICAgdmFyIG9sZEZyYWcgPSBvbGRmcmFnbWVudHNbZGVsdGEraV0sXHJcbiAgICAgICAgICBuZXdGcmFnID0gbmV3ZnJhZ21lbnRzW2ldO1xyXG4gICAgICBpZiAobmV3RnJhZyAmJiBvbGRGcmFnKSB7XHJcbiAgICAgICAgY2NPZmZzZXQgPSBvbGRGcmFnLmNjIC0gbmV3RnJhZy5jYztcclxuICAgICAgICBpZiAoIWlzTmFOKG9sZEZyYWcuc3RhcnRQVFMpKSB7XHJcbiAgICAgICAgICBuZXdGcmFnLnN0YXJ0ID0gbmV3RnJhZy5zdGFydFBUUyA9IG9sZEZyYWcuc3RhcnRQVFM7XHJcbiAgICAgICAgICBuZXdGcmFnLmVuZFBUUyA9IG9sZEZyYWcuZW5kUFRTO1xyXG4gICAgICAgICAgbmV3RnJhZy5kdXJhdGlvbiA9IG9sZEZyYWcuZHVyYXRpb247XHJcbiAgICAgICAgICBuZXdGcmFnLmJhY2t0cmFja2VkID0gb2xkRnJhZy5iYWNrdHJhY2tlZDtcclxuICAgICAgICAgIG5ld0ZyYWcuZHJvcHBlZCA9IG9sZEZyYWcuZHJvcHBlZDtcclxuICAgICAgICAgIFBUU0ZyYWcgPSBuZXdGcmFnO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmKGNjT2Zmc2V0KSB7XHJcbiAgICAgIGxvZ2dlci5sb2coYGRpc2NvbnRpbnVpdHkgc2xpZGluZyBmcm9tIHBsYXlsaXN0LCB0YWtlIGRyaWZ0IGludG8gYWNjb3VudGApO1xyXG4gICAgICBmb3IoaSA9IDAgOyBpIDwgbmV3ZnJhZ21lbnRzLmxlbmd0aCA7IGkrKykge1xyXG4gICAgICAgIG5ld2ZyYWdtZW50c1tpXS5jYyArPSBjY09mZnNldDtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIGlmIGF0IGxlYXN0IG9uZSBmcmFnbWVudCBjb250YWlucyBQVFMgaW5mbywgcmVjb21wdXRlIFBUUyBpbmZvcm1hdGlvbiBmb3IgYWxsIGZyYWdtZW50c1xyXG4gICAgaWYoUFRTRnJhZykge1xyXG4gICAgICBMZXZlbEhlbHBlci51cGRhdGVGcmFnUFRTRFRTKG5ld0RldGFpbHMsUFRTRnJhZyxQVFNGcmFnLnN0YXJ0UFRTLFBUU0ZyYWcuZW5kUFRTLFBUU0ZyYWcuc3RhcnREVFMsUFRTRnJhZy5lbmREVFMpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gZW5zdXJlIHRoYXQgZGVsdGEgaXMgd2l0aGluIG9sZGZyYWdtZW50cyByYW5nZVxyXG4gICAgICAvLyBhbHNvIGFkanVzdCBzbGlkaW5nIGluIGNhc2UgZGVsdGEgaXMgMCAod2UgY291bGQgaGF2ZSBvbGQ9WzUwLTYwXSBhbmQgbmV3PW9sZD1bNTAtNjFdKVxyXG4gICAgICAvLyBpbiB0aGF0IGNhc2Ugd2UgYWxzbyBuZWVkIHRvIGFkanVzdCBzdGFydCBvZmZzZXQgb2YgYWxsIGZyYWdtZW50c1xyXG4gICAgICBpZiAoZGVsdGEgPj0gMCAmJiBkZWx0YSA8IG9sZGZyYWdtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICAvLyBhZGp1c3Qgc3RhcnQgYnkgc2xpZGluZyBvZmZzZXRcclxuICAgICAgICB2YXIgc2xpZGluZyA9IG9sZGZyYWdtZW50c1tkZWx0YV0uc3RhcnQ7XHJcbiAgICAgICAgZm9yKGkgPSAwIDsgaSA8IG5ld2ZyYWdtZW50cy5sZW5ndGggOyBpKyspIHtcclxuICAgICAgICAgIG5ld2ZyYWdtZW50c1tpXS5zdGFydCArPSBzbGlkaW5nO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gaWYgd2UgYXJlIGhlcmUsIGl0IG1lYW5zIHdlIGhhdmUgZnJhZ21lbnRzIG92ZXJsYXBwaW5nIGJldHdlZW5cclxuICAgIC8vIG9sZCBhbmQgbmV3IGxldmVsLiByZWxpYWJsZSBQVFMgaW5mbyBpcyB0aHVzIHJlbHlpbmcgb24gb2xkIGxldmVsXHJcbiAgICBuZXdEZXRhaWxzLlBUU0tub3duID0gb2xkRGV0YWlscy5QVFNLbm93bjtcclxuICAgIHJldHVybjtcclxuICB9LFxyXG5cclxuICB1cGRhdGVGcmFnUFRTRFRTIDogZnVuY3Rpb24oZGV0YWlscyxmcmFnLHN0YXJ0UFRTLGVuZFBUUyxzdGFydERUUyxlbmREVFMpIHtcclxuICAgIC8vIHVwZGF0ZSBmcmFnIFBUUy9EVFNcclxuICAgIGxldCBtYXhTdGFydFBUUyA9IHN0YXJ0UFRTO1xyXG4gICAgaWYoIWlzTmFOKGZyYWcuc3RhcnRQVFMpKSB7XHJcbiAgICAgIC8vIGRlbHRhIFBUUyBiZXR3ZWVuIGF1ZGlvIGFuZCB2aWRlb1xyXG4gICAgICBsZXQgZGVsdGFQVFMgPSBNYXRoLmFicyhmcmFnLnN0YXJ0UFRTLXN0YXJ0UFRTKTtcclxuICAgICAgaWYgKGlzTmFOKGZyYWcuZGVsdGFQVFMpKSB7XHJcbiAgICAgICAgZnJhZy5kZWx0YVBUUyA9IGRlbHRhUFRTO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGZyYWcuZGVsdGFQVFMgPSBNYXRoLm1heChkZWx0YVBUUyxmcmFnLmRlbHRhUFRTKTtcclxuICAgICAgfVxyXG4gICAgICBtYXhTdGFydFBUUyA9IE1hdGgubWF4KHN0YXJ0UFRTLGZyYWcuc3RhcnRQVFMpO1xyXG4gICAgICBzdGFydFBUUyA9IE1hdGgubWluKHN0YXJ0UFRTLGZyYWcuc3RhcnRQVFMpO1xyXG4gICAgICBlbmRQVFMgPSBNYXRoLm1heChlbmRQVFMsIGZyYWcuZW5kUFRTKTtcclxuICAgICAgc3RhcnREVFMgPSBNYXRoLm1pbihzdGFydERUUyxmcmFnLnN0YXJ0RFRTKTtcclxuICAgICAgZW5kRFRTID0gTWF0aC5tYXgoZW5kRFRTLCBmcmFnLmVuZERUUyk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgZHJpZnQgPSBzdGFydFBUUyAtIGZyYWcuc3RhcnQ7XHJcbiAgICBmcmFnLnN0YXJ0ID0gZnJhZy5zdGFydFBUUyA9IHN0YXJ0UFRTO1xyXG4gICAgZnJhZy5tYXhTdGFydFBUUyA9IG1heFN0YXJ0UFRTO1xyXG4gICAgZnJhZy5lbmRQVFMgPSBlbmRQVFM7XHJcbiAgICBmcmFnLnN0YXJ0RFRTID0gc3RhcnREVFM7XHJcbiAgICBmcmFnLmVuZERUUyA9IGVuZERUUztcclxuICAgIGZyYWcuZHVyYXRpb24gPSBlbmRQVFMgLSBzdGFydFBUUztcclxuXHJcbiAgICBjb25zdCBzbiA9IGZyYWcuc247XHJcbiAgICAvLyBleGl0IGlmIHNuIG91dCBvZiByYW5nZVxyXG4gICAgaWYgKCFkZXRhaWxzIHx8IHNuIDwgZGV0YWlscy5zdGFydFNOIHx8IHNuID4gZGV0YWlscy5lbmRTTikge1xyXG4gICAgICByZXR1cm4gMDtcclxuICAgIH1cclxuICAgIHZhciBmcmFnSWR4LCBmcmFnbWVudHMsIGk7XHJcbiAgICBmcmFnSWR4ID0gc24gLSBkZXRhaWxzLnN0YXJ0U047XHJcbiAgICBmcmFnbWVudHMgPSBkZXRhaWxzLmZyYWdtZW50cztcclxuICAgIGZyYWcgPSBmcmFnbWVudHNbZnJhZ0lkeF07XHJcbiAgICAvLyBhZGp1c3QgZnJhZ21lbnQgUFRTL2R1cmF0aW9uIGZyb20gc2VxbnVtLTEgdG8gZnJhZyAwXHJcbiAgICBmb3IoaSA9IGZyYWdJZHggOyBpID4gMCA7IGktLSkge1xyXG4gICAgICBMZXZlbEhlbHBlci51cGRhdGVQVFMoZnJhZ21lbnRzLGksaS0xKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBhZGp1c3QgZnJhZ21lbnQgUFRTL2R1cmF0aW9uIGZyb20gc2VxbnVtIHRvIGxhc3QgZnJhZ1xyXG4gICAgZm9yKGkgPSBmcmFnSWR4IDsgaSA8IGZyYWdtZW50cy5sZW5ndGggLSAxIDsgaSsrKSB7XHJcbiAgICAgIExldmVsSGVscGVyLnVwZGF0ZVBUUyhmcmFnbWVudHMsaSxpKzEpO1xyXG4gICAgfVxyXG4gICAgZGV0YWlscy5QVFNLbm93biA9IHRydWU7XHJcbiAgICAvL2xvZ2dlci5sb2coYCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhZyBzdGFydC9lbmQ6JHtzdGFydFBUUy50b0ZpeGVkKDMpfS8ke2VuZFBUUy50b0ZpeGVkKDMpfWApO1xyXG5cclxuICAgIHJldHVybiBkcmlmdDtcclxuICB9LFxyXG5cclxuICB1cGRhdGVQVFMgOiBmdW5jdGlvbihmcmFnbWVudHMsZnJvbUlkeCwgdG9JZHgpIHtcclxuICAgIHZhciBmcmFnRnJvbSA9IGZyYWdtZW50c1tmcm9tSWR4XSxmcmFnVG8gPSBmcmFnbWVudHNbdG9JZHhdLCBmcmFnVG9QVFMgPSBmcmFnVG8uc3RhcnRQVFM7XHJcbiAgICAvLyBpZiB3ZSBrbm93IHN0YXJ0UFRTW3RvSWR4XVxyXG4gICAgaWYoIWlzTmFOKGZyYWdUb1BUUykpIHtcclxuICAgICAgLy8gdXBkYXRlIGZyYWdtZW50IGR1cmF0aW9uLlxyXG4gICAgICAvLyBpdCBoZWxwcyB0byBmaXggZHJpZnRzIGJldHdlZW4gcGxheWxpc3QgcmVwb3J0ZWQgZHVyYXRpb24gYW5kIGZyYWdtZW50IHJlYWwgZHVyYXRpb25cclxuICAgICAgaWYgKHRvSWR4ID4gZnJvbUlkeCkge1xyXG4gICAgICAgIGZyYWdGcm9tLmR1cmF0aW9uID0gZnJhZ1RvUFRTLWZyYWdGcm9tLnN0YXJ0O1xyXG4gICAgICAgIGlmKGZyYWdGcm9tLmR1cmF0aW9uIDwgMCkge1xyXG4gICAgICAgICAgbG9nZ2VyLndhcm4oYG5lZ2F0aXZlIGR1cmF0aW9uIGNvbXB1dGVkIGZvciBmcmFnICR7ZnJhZ0Zyb20uc259LGxldmVsICR7ZnJhZ0Zyb20ubGV2ZWx9LCB0aGVyZSBzaG91bGQgYmUgc29tZSBkdXJhdGlvbiBkcmlmdCBiZXR3ZWVuIHBsYXlsaXN0IGFuZCBmcmFnbWVudCFgKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZnJhZ1RvLmR1cmF0aW9uID0gZnJhZ0Zyb20uc3RhcnQgLSBmcmFnVG9QVFM7XHJcbiAgICAgICAgaWYoZnJhZ1RvLmR1cmF0aW9uIDwgMCkge1xyXG4gICAgICAgICAgbG9nZ2VyLndhcm4oYG5lZ2F0aXZlIGR1cmF0aW9uIGNvbXB1dGVkIGZvciBmcmFnICR7ZnJhZ1RvLnNufSxsZXZlbCAke2ZyYWdUby5sZXZlbH0sIHRoZXJlIHNob3VsZCBiZSBzb21lIGR1cmF0aW9uIGRyaWZ0IGJldHdlZW4gcGxheWxpc3QgYW5kIGZyYWdtZW50IWApO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gd2UgZG9udCBrbm93IHN0YXJ0UFRTW3RvSWR4XVxyXG4gICAgICBpZiAodG9JZHggPiBmcm9tSWR4KSB7XHJcbiAgICAgICAgZnJhZ1RvLnN0YXJ0ID0gZnJhZ0Zyb20uc3RhcnQgKyBmcmFnRnJvbS5kdXJhdGlvbjtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBmcmFnVG8uc3RhcnQgPSBNYXRoLm1heChmcmFnRnJvbS5zdGFydCAtIGZyYWdUby5kdXJhdGlvbiwgMCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IExldmVsSGVscGVyO1xyXG4iLCIvKipcclxuICogSExTIGludGVyZmFjZVxyXG4gKi9cclxuaW1wb3J0IFVSTFRvb2xraXQgZnJvbSAndXJsLXRvb2xraXQnO1xyXG5pbXBvcnQgRXZlbnQgZnJvbSAnLi9ldmVudHMnO1xyXG5pbXBvcnQge0Vycm9yVHlwZXMsIEVycm9yRGV0YWlsc30gZnJvbSAnLi9lcnJvcnMnO1xyXG5pbXBvcnQgUGxheWxpc3RMb2FkZXIgZnJvbSAnLi9sb2FkZXIvcGxheWxpc3QtbG9hZGVyJztcclxuaW1wb3J0IEZyYWdtZW50TG9hZGVyIGZyb20gJy4vbG9hZGVyL2ZyYWdtZW50LWxvYWRlcic7XHJcbmltcG9ydCBLZXlMb2FkZXIgZnJvbSAnLi9sb2FkZXIva2V5LWxvYWRlcic7XHJcblxyXG5pbXBvcnQgU3RyZWFtQ29udHJvbGxlciBmcm9tICAnLi9jb250cm9sbGVyL3N0cmVhbS1jb250cm9sbGVyJztcclxuaW1wb3J0IExldmVsQ29udHJvbGxlciBmcm9tICAnLi9jb250cm9sbGVyL2xldmVsLWNvbnRyb2xsZXInO1xyXG5pbXBvcnQgSUQzVHJhY2tDb250cm9sbGVyIGZyb20gJy4vY29udHJvbGxlci9pZDMtdHJhY2stY29udHJvbGxlcic7XHJcblxyXG5pbXBvcnQge2xvZ2dlciwgZW5hYmxlTG9nc30gZnJvbSAnLi91dGlscy9sb2dnZXInO1xyXG5pbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gJ2V2ZW50cyc7XHJcbmltcG9ydCB7aGxzRGVmYXVsdENvbmZpZ30gZnJvbSAnLi9jb25maWcnO1xyXG5cclxuY2xhc3MgSGxzIHtcclxuXHJcbiAgc3RhdGljIGdldCB2ZXJzaW9uKCkge1xyXG4gICAgLy8gcmVwbGFjZWQgd2l0aCBicm93c2VyaWZ5LXZlcnNpb25pZnkgdHJhbnNmb3JtXHJcbiAgICByZXR1cm4gJ19fVkVSU0lPTl9fJztcclxuICB9XHJcblxyXG4gIHN0YXRpYyBpc1N1cHBvcnRlZCgpIHtcclxuICAgIGNvbnN0IG1lZGlhU291cmNlID0gd2luZG93Lk1lZGlhU291cmNlID0gd2luZG93Lk1lZGlhU291cmNlIHx8IHdpbmRvdy5XZWJLaXRNZWRpYVNvdXJjZTtcclxuICAgIGNvbnN0IHNvdXJjZUJ1ZmZlciA9IHdpbmRvdy5Tb3VyY2VCdWZmZXIgPSB3aW5kb3cuU291cmNlQnVmZmVyIHx8IHdpbmRvdy5XZWJLaXRTb3VyY2VCdWZmZXI7XHJcbiAgICBjb25zdCBpc1R5cGVTdXBwb3J0ZWQgPSBtZWRpYVNvdXJjZSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIG1lZGlhU291cmNlLmlzVHlwZVN1cHBvcnRlZCA9PT0gJ2Z1bmN0aW9uJyAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVkaWFTb3VyY2UuaXNUeXBlU3VwcG9ydGVkKCd2aWRlby9tcDQ7IGNvZGVjcz1cImF2YzEuNDJFMDFFLG1wNGEuNDAuMlwiJyk7XHJcblxyXG4gICAgLy8gaWYgU291cmNlQnVmZmVyIGlzIGV4cG9zZWQgZW5zdXJlIGl0cyBBUEkgaXMgdmFsaWRcclxuICAgIC8vIHNhZmFyaSBhbmQgb2xkIHZlcnNpb24gb2YgQ2hyb21lIGRvZSBub3QgZXhwb3NlIFNvdXJjZUJ1ZmZlciBnbG9iYWxseSBzbyBjaGVja2luZyBTb3VyY2VCdWZmZXIucHJvdG90eXBlIGlzIGltcG9zc2libGVcclxuICAgIGNvbnN0IHNvdXJjZUJ1ZmZlclZhbGlkQVBJID0gIXNvdXJjZUJ1ZmZlciB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoc291cmNlQnVmZmVyLnByb3RvdHlwZSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlb2Ygc291cmNlQnVmZmVyLnByb3RvdHlwZS5hcHBlbmRCdWZmZXIgPT09ICdmdW5jdGlvbicgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHNvdXJjZUJ1ZmZlci5wcm90b3R5cGUucmVtb3ZlID09PSAnZnVuY3Rpb24nKTtcclxuICAgIHJldHVybiBpc1R5cGVTdXBwb3J0ZWQgJiYgc291cmNlQnVmZmVyVmFsaWRBUEk7XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgZ2V0IEV2ZW50cygpIHtcclxuICAgIHJldHVybiBFdmVudDtcclxuICB9XHJcblxyXG4gIHN0YXRpYyBnZXQgRXJyb3JUeXBlcygpIHtcclxuICAgIHJldHVybiBFcnJvclR5cGVzO1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIGdldCBFcnJvckRldGFpbHMoKSB7XHJcbiAgICByZXR1cm4gRXJyb3JEZXRhaWxzO1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIGdldCBEZWZhdWx0Q29uZmlnKCkge1xyXG4gICAgaWYoIUhscy5kZWZhdWx0Q29uZmlnKSB7XHJcbiAgICAgIHJldHVybiBobHNEZWZhdWx0Q29uZmlnO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIEhscy5kZWZhdWx0Q29uZmlnO1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIHNldCBEZWZhdWx0Q29uZmlnKGRlZmF1bHRDb25maWcpIHtcclxuICAgIEhscy5kZWZhdWx0Q29uZmlnID0gZGVmYXVsdENvbmZpZztcclxuICB9XHJcblxyXG4gIGNvbnN0cnVjdG9yKGNvbmZpZyA9IHt9KSB7XHJcbiAgICB2YXIgZGVmYXVsdENvbmZpZyA9IEhscy5EZWZhdWx0Q29uZmlnO1xyXG5cclxuICAgIGlmICgoY29uZmlnLmxpdmVTeW5jRHVyYXRpb25Db3VudCB8fCBjb25maWcubGl2ZU1heExhdGVuY3lEdXJhdGlvbkNvdW50KSAmJiAoY29uZmlnLmxpdmVTeW5jRHVyYXRpb24gfHwgY29uZmlnLmxpdmVNYXhMYXRlbmN5RHVyYXRpb24pKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignSWxsZWdhbCBobHMuanMgY29uZmlnOiBkb25cXCd0IG1peCB1cCBsaXZlU3luY0R1cmF0aW9uQ291bnQvbGl2ZU1heExhdGVuY3lEdXJhdGlvbkNvdW50IGFuZCBsaXZlU3luY0R1cmF0aW9uL2xpdmVNYXhMYXRlbmN5RHVyYXRpb24nKTtcclxuICAgIH1cclxuXHJcbiAgICBmb3IgKHZhciBwcm9wIGluIGRlZmF1bHRDb25maWcpIHtcclxuICAgICAgICBpZiAocHJvcCBpbiBjb25maWcpIHsgY29udGludWU7IH1cclxuICAgICAgICBjb25maWdbcHJvcF0gPSBkZWZhdWx0Q29uZmlnW3Byb3BdO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChjb25maWcubGl2ZU1heExhdGVuY3lEdXJhdGlvbkNvdW50ICE9PSB1bmRlZmluZWQgJiYgY29uZmlnLmxpdmVNYXhMYXRlbmN5RHVyYXRpb25Db3VudCA8PSBjb25maWcubGl2ZVN5bmNEdXJhdGlvbkNvdW50KSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignSWxsZWdhbCBobHMuanMgY29uZmlnOiBcImxpdmVNYXhMYXRlbmN5RHVyYXRpb25Db3VudFwiIG11c3QgYmUgZ3QgXCJsaXZlU3luY0R1cmF0aW9uQ291bnRcIicpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChjb25maWcubGl2ZU1heExhdGVuY3lEdXJhdGlvbiAhPT0gdW5kZWZpbmVkICYmIChjb25maWcubGl2ZU1heExhdGVuY3lEdXJhdGlvbiA8PSBjb25maWcubGl2ZVN5bmNEdXJhdGlvbiB8fCBjb25maWcubGl2ZVN5bmNEdXJhdGlvbiA9PT0gdW5kZWZpbmVkKSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lsbGVnYWwgaGxzLmpzIGNvbmZpZzogXCJsaXZlTWF4TGF0ZW5jeUR1cmF0aW9uXCIgbXVzdCBiZSBndCBcImxpdmVTeW5jRHVyYXRpb25cIicpO1xyXG4gICAgfVxyXG5cclxuICAgIGVuYWJsZUxvZ3MoY29uZmlnLmRlYnVnKTtcclxuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xyXG4gICAgdGhpcy5fYXV0b0xldmVsQ2FwcGluZyA9IC0xO1xyXG4gICAgLy8gb2JzZXJ2ZXIgc2V0dXBcclxuICAgIHZhciBvYnNlcnZlciA9IHRoaXMub2JzZXJ2ZXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICBvYnNlcnZlci50cmlnZ2VyID0gZnVuY3Rpb24gdHJpZ2dlciAoZXZlbnQsIC4uLmRhdGEpIHtcclxuICAgICAgb2JzZXJ2ZXIuZW1pdChldmVudCwgZXZlbnQsIC4uLmRhdGEpO1xyXG4gICAgfTtcclxuXHJcbiAgICBvYnNlcnZlci5vZmYgPSBmdW5jdGlvbiBvZmYgKGV2ZW50LCAuLi5kYXRhKSB7XHJcbiAgICAgIG9ic2VydmVyLnJlbW92ZUxpc3RlbmVyKGV2ZW50LCAuLi5kYXRhKTtcclxuICAgIH07XHJcbiAgICB0aGlzLm9uID0gb2JzZXJ2ZXIub24uYmluZChvYnNlcnZlcik7XHJcbiAgICB0aGlzLm9mZiA9IG9ic2VydmVyLm9mZi5iaW5kKG9ic2VydmVyKTtcclxuICAgIHRoaXMudHJpZ2dlciA9IG9ic2VydmVyLnRyaWdnZXIuYmluZChvYnNlcnZlcik7XHJcblxyXG4gICAgLy8gY29yZSBjb250cm9sbGVycyBhbmQgbmV0d29yayBsb2FkZXJzXHJcbiAgICBjb25zdCBhYnJDb250cm9sbGVyID0gdGhpcy5hYnJDb250cm9sbGVyID0gbmV3IGNvbmZpZy5hYnJDb250cm9sbGVyKHRoaXMpO1xyXG4gICAgY29uc3QgYnVmZmVyQ29udHJvbGxlciAgPSBuZXcgY29uZmlnLmJ1ZmZlckNvbnRyb2xsZXIodGhpcyk7XHJcbiAgICBjb25zdCBjYXBMZXZlbENvbnRyb2xsZXIgPSBuZXcgY29uZmlnLmNhcExldmVsQ29udHJvbGxlcih0aGlzKTtcclxuICAgIGNvbnN0IGZwc0NvbnRyb2xsZXIgPSBuZXcgY29uZmlnLmZwc0NvbnRyb2xsZXIodGhpcyk7XHJcbiAgICBjb25zdCBwbGF5TGlzdExvYWRlciA9IG5ldyBQbGF5bGlzdExvYWRlcih0aGlzKTtcclxuICAgIGNvbnN0IGZyYWdtZW50TG9hZGVyID0gbmV3IEZyYWdtZW50TG9hZGVyKHRoaXMpO1xyXG4gICAgY29uc3Qga2V5TG9hZGVyID0gbmV3IEtleUxvYWRlcih0aGlzKTtcclxuICAgIGNvbnN0IGlkM1RyYWNrQ29udHJvbGxlciA9IG5ldyBJRDNUcmFja0NvbnRyb2xsZXIodGhpcyk7XHJcblxyXG4gICAgLy8gbmV0d29yayBjb250cm9sbGVyc1xyXG4gICAgY29uc3QgbGV2ZWxDb250cm9sbGVyID0gdGhpcy5sZXZlbENvbnRyb2xsZXIgPSBuZXcgTGV2ZWxDb250cm9sbGVyKHRoaXMpO1xyXG4gICAgY29uc3Qgc3RyZWFtQ29udHJvbGxlciA9IHRoaXMuc3RyZWFtQ29udHJvbGxlciA9IG5ldyBTdHJlYW1Db250cm9sbGVyKHRoaXMpO1xyXG4gICAgbGV0IG5ldHdvcmtDb250cm9sbGVycyA9IFtsZXZlbENvbnRyb2xsZXIsIHN0cmVhbUNvbnRyb2xsZXJdO1xyXG5cclxuICAgIC8vIG9wdGlvbmFsIGF1ZGlvIHN0cmVhbSBjb250cm9sbGVyXHJcbiAgICBsZXQgQ29udHJvbGxlciA9IGNvbmZpZy5hdWRpb1N0cmVhbUNvbnRyb2xsZXI7XHJcbiAgICBpZiAoQ29udHJvbGxlcikge1xyXG4gICAgICBuZXR3b3JrQ29udHJvbGxlcnMucHVzaChuZXcgQ29udHJvbGxlcih0aGlzKSk7XHJcbiAgICB9XHJcbiAgICB0aGlzLm5ldHdvcmtDb250cm9sbGVycyA9IG5ldHdvcmtDb250cm9sbGVycztcclxuXHJcbiAgICBsZXQgY29yZUNvbXBvbmVudHMgPSBbIHBsYXlMaXN0TG9hZGVyLCBmcmFnbWVudExvYWRlciwga2V5TG9hZGVyLCBhYnJDb250cm9sbGVyLCBidWZmZXJDb250cm9sbGVyLCBjYXBMZXZlbENvbnRyb2xsZXIsIGZwc0NvbnRyb2xsZXIsIGlkM1RyYWNrQ29udHJvbGxlciBdO1xyXG5cclxuICAgIC8vIG9wdGlvbmFsIGF1ZGlvIHRyYWNrIGFuZCBzdWJ0aXRsZSBjb250cm9sbGVyXHJcbiAgICBDb250cm9sbGVyID0gY29uZmlnLmF1ZGlvVHJhY2tDb250cm9sbGVyO1xyXG4gICAgaWYgKENvbnRyb2xsZXIpIHtcclxuICAgICAgbGV0IGF1ZGlvVHJhY2tDb250cm9sbGVyID0gbmV3IENvbnRyb2xsZXIodGhpcyk7XHJcbiAgICAgIHRoaXMuYXVkaW9UcmFja0NvbnRyb2xsZXIgPSBhdWRpb1RyYWNrQ29udHJvbGxlcjtcclxuICAgICAgY29yZUNvbXBvbmVudHMucHVzaChhdWRpb1RyYWNrQ29udHJvbGxlcik7XHJcbiAgICB9XHJcblxyXG4gICAgQ29udHJvbGxlciA9IGNvbmZpZy5zdWJ0aXRsZVRyYWNrQ29udHJvbGxlcjtcclxuICAgIGlmIChDb250cm9sbGVyKSB7XHJcbiAgICAgIGxldCBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlciA9IG5ldyBDb250cm9sbGVyKHRoaXMpO1xyXG4gICAgICB0aGlzLnN1YnRpdGxlVHJhY2tDb250cm9sbGVyID0gc3VidGl0bGVUcmFja0NvbnRyb2xsZXI7XHJcbiAgICAgIGNvcmVDb21wb25lbnRzLnB1c2goc3VidGl0bGVUcmFja0NvbnRyb2xsZXIpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIG9wdGlvbmFsIHN1YnRpdGxlIGNvbnRyb2xsZXJcclxuICAgIFtjb25maWcuc3VidGl0bGVTdHJlYW1Db250cm9sbGVyLCBjb25maWcudGltZWxpbmVDb250cm9sbGVyXS5mb3JFYWNoKENvbnRyb2xsZXIgPT4ge1xyXG4gICAgICBpZiAoQ29udHJvbGxlcikge1xyXG4gICAgICAgIGNvcmVDb21wb25lbnRzLnB1c2gobmV3IENvbnRyb2xsZXIodGhpcykpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICAgIHRoaXMuY29yZUNvbXBvbmVudHMgPSBjb3JlQ29tcG9uZW50cztcclxuICB9XHJcblxyXG4gIGRlc3Ryb3koKSB7XHJcbiAgICBsb2dnZXIubG9nKCdkZXN0cm95Jyk7XHJcbiAgICB0aGlzLnRyaWdnZXIoRXZlbnQuREVTVFJPWUlORyk7XHJcbiAgICB0aGlzLmRldGFjaE1lZGlhKCk7XHJcbiAgICB0aGlzLmNvcmVDb21wb25lbnRzLmNvbmNhdCh0aGlzLm5ldHdvcmtDb250cm9sbGVycykuZm9yRWFjaChjb21wb25lbnQgPT4ge2NvbXBvbmVudC5kZXN0cm95KCk7fSk7XHJcbiAgICB0aGlzLnVybCA9IG51bGw7XHJcbiAgICB0aGlzLm9ic2VydmVyLnJlbW92ZUFsbExpc3RlbmVycygpO1xyXG4gICAgdGhpcy5fYXV0b0xldmVsQ2FwcGluZyA9IC0xO1xyXG4gIH1cclxuXHJcbiAgYXR0YWNoTWVkaWEobWVkaWEpIHtcclxuICAgIGxvZ2dlci5sb2coJ2F0dGFjaE1lZGlhJyk7XHJcbiAgICB0aGlzLm1lZGlhID0gbWVkaWE7XHJcbiAgICB0aGlzLnRyaWdnZXIoRXZlbnQuTUVESUFfQVRUQUNISU5HLCB7bWVkaWE6IG1lZGlhfSk7XHJcbiAgfVxyXG5cclxuICBkZXRhY2hNZWRpYSgpIHtcclxuICAgIGxvZ2dlci5sb2coJ2RldGFjaE1lZGlhJyk7XHJcbiAgICB0aGlzLnRyaWdnZXIoRXZlbnQuTUVESUFfREVUQUNISU5HKTtcclxuICAgIHRoaXMubWVkaWEgPSBudWxsO1xyXG4gIH1cclxuXHJcbiAgbG9hZFNvdXJjZSh1cmwpIHtcclxuICAgIHVybCA9IFVSTFRvb2xraXQuYnVpbGRBYnNvbHV0ZVVSTCh3aW5kb3cubG9jYXRpb24uaHJlZiwgdXJsLCB7IGFsd2F5c05vcm1hbGl6ZTogdHJ1ZSB9KTtcclxuICAgIGxvZ2dlci5sb2coYGxvYWRTb3VyY2U6JHt1cmx9YCk7XHJcbiAgICB0aGlzLnVybCA9IHVybDtcclxuICAgIC8vIHdoZW4gYXR0YWNoaW5nIHRvIGEgc291cmNlIFVSTCwgdHJpZ2dlciBhIHBsYXlsaXN0IGxvYWRcclxuICAgIHRoaXMudHJpZ2dlcihFdmVudC5NQU5JRkVTVF9MT0FESU5HLCB7dXJsOiB1cmx9KTtcclxuICB9XHJcblxyXG4gIHN0YXJ0TG9hZChzdGFydFBvc2l0aW9uPS0xKSB7XHJcbiAgICBsb2dnZXIubG9nKGBzdGFydExvYWQoJHtzdGFydFBvc2l0aW9ufSlgKTtcclxuICAgIHRoaXMubmV0d29ya0NvbnRyb2xsZXJzLmZvckVhY2goY29udHJvbGxlciA9PiB7Y29udHJvbGxlci5zdGFydExvYWQoc3RhcnRQb3NpdGlvbik7fSk7XHJcbiAgfVxyXG5cclxuICBzdG9wTG9hZCgpIHtcclxuICAgIGxvZ2dlci5sb2coJ3N0b3BMb2FkJyk7XHJcbiAgICB0aGlzLm5ldHdvcmtDb250cm9sbGVycy5mb3JFYWNoKGNvbnRyb2xsZXIgPT4ge2NvbnRyb2xsZXIuc3RvcExvYWQoKTt9KTtcclxuICB9XHJcblxyXG4gIHN3YXBBdWRpb0NvZGVjKCkge1xyXG4gICAgbG9nZ2VyLmxvZygnc3dhcEF1ZGlvQ29kZWMnKTtcclxuICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlci5zd2FwQXVkaW9Db2RlYygpO1xyXG4gIH1cclxuXHJcbiAgcmVjb3Zlck1lZGlhRXJyb3IoKSB7XHJcbiAgICBsb2dnZXIubG9nKCdyZWNvdmVyTWVkaWFFcnJvcicpO1xyXG4gICAgdmFyIG1lZGlhID0gdGhpcy5tZWRpYTtcclxuICAgIHRoaXMuZGV0YWNoTWVkaWEoKTtcclxuICAgIHRoaXMuYXR0YWNoTWVkaWEobWVkaWEpO1xyXG4gIH1cclxuXHJcbiAgLyoqIFJldHVybiBhbGwgcXVhbGl0eSBsZXZlbHMgKiovXHJcbiAgZ2V0IGxldmVscygpIHtcclxuICAgIHJldHVybiB0aGlzLmxldmVsQ29udHJvbGxlci5sZXZlbHM7XHJcbiAgfVxyXG5cclxuICAvKiogUmV0dXJuIGN1cnJlbnQgcGxheWJhY2sgcXVhbGl0eSBsZXZlbCAqKi9cclxuICBnZXQgY3VycmVudExldmVsKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuc3RyZWFtQ29udHJvbGxlci5jdXJyZW50TGV2ZWw7XHJcbiAgfVxyXG5cclxuICAvKiBzZXQgcXVhbGl0eSBsZXZlbCBpbW1lZGlhdGVseSAoLTEgZm9yIGF1dG9tYXRpYyBsZXZlbCBzZWxlY3Rpb24pICovXHJcbiAgc2V0IGN1cnJlbnRMZXZlbChuZXdMZXZlbCkge1xyXG4gICAgbG9nZ2VyLmxvZyhgc2V0IGN1cnJlbnRMZXZlbDoke25ld0xldmVsfWApO1xyXG4gICAgdGhpcy5sb2FkTGV2ZWwgPSBuZXdMZXZlbDtcclxuICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlci5pbW1lZGlhdGVMZXZlbFN3aXRjaCgpO1xyXG4gIH1cclxuXHJcbiAgLyoqIFJldHVybiBuZXh0IHBsYXliYWNrIHF1YWxpdHkgbGV2ZWwgKHF1YWxpdHkgbGV2ZWwgb2YgbmV4dCBmcmFnbWVudCkgKiovXHJcbiAgZ2V0IG5leHRMZXZlbCgpIHtcclxuICAgIHJldHVybiB0aGlzLnN0cmVhbUNvbnRyb2xsZXIubmV4dExldmVsO1xyXG4gIH1cclxuXHJcbiAgLyogc2V0IHF1YWxpdHkgbGV2ZWwgZm9yIG5leHQgZnJhZ21lbnQgKC0xIGZvciBhdXRvbWF0aWMgbGV2ZWwgc2VsZWN0aW9uKSAqL1xyXG4gIHNldCBuZXh0TGV2ZWwobmV3TGV2ZWwpIHtcclxuICAgIGxvZ2dlci5sb2coYHNldCBuZXh0TGV2ZWw6JHtuZXdMZXZlbH1gKTtcclxuICAgIHRoaXMubGV2ZWxDb250cm9sbGVyLm1hbnVhbExldmVsID0gbmV3TGV2ZWw7XHJcbiAgICB0aGlzLnN0cmVhbUNvbnRyb2xsZXIubmV4dExldmVsU3dpdGNoKCk7XHJcbiAgfVxyXG5cclxuICAvKiogUmV0dXJuIHRoZSBxdWFsaXR5IGxldmVsIG9mIGN1cnJlbnQvbGFzdCBsb2FkZWQgZnJhZ21lbnQgKiovXHJcbiAgZ2V0IGxvYWRMZXZlbCgpIHtcclxuICAgIHJldHVybiB0aGlzLmxldmVsQ29udHJvbGxlci5sZXZlbDtcclxuICB9XHJcblxyXG4gIC8qIHNldCBxdWFsaXR5IGxldmVsIGZvciBjdXJyZW50L25leHQgbG9hZGVkIGZyYWdtZW50ICgtMSBmb3IgYXV0b21hdGljIGxldmVsIHNlbGVjdGlvbikgKi9cclxuICBzZXQgbG9hZExldmVsKG5ld0xldmVsKSB7XHJcbiAgICBsb2dnZXIubG9nKGBzZXQgbG9hZExldmVsOiR7bmV3TGV2ZWx9YCk7XHJcbiAgICB0aGlzLmxldmVsQ29udHJvbGxlci5tYW51YWxMZXZlbCA9IG5ld0xldmVsO1xyXG4gIH1cclxuXHJcbiAgLyoqIFJldHVybiB0aGUgcXVhbGl0eSBsZXZlbCBvZiBuZXh0IGxvYWRlZCBmcmFnbWVudCAqKi9cclxuICBnZXQgbmV4dExvYWRMZXZlbCgpIHtcclxuICAgIHJldHVybiB0aGlzLmxldmVsQ29udHJvbGxlci5uZXh0TG9hZExldmVsO1xyXG4gIH1cclxuXHJcbiAgLyoqIHNldCBxdWFsaXR5IGxldmVsIG9mIG5leHQgbG9hZGVkIGZyYWdtZW50ICoqL1xyXG4gIHNldCBuZXh0TG9hZExldmVsKGxldmVsKSB7XHJcbiAgICB0aGlzLmxldmVsQ29udHJvbGxlci5uZXh0TG9hZExldmVsID0gbGV2ZWw7XHJcbiAgfVxyXG5cclxuICAvKiogUmV0dXJuIGZpcnN0IGxldmVsIChpbmRleCBvZiBmaXJzdCBsZXZlbCByZWZlcmVuY2VkIGluIG1hbmlmZXN0KVxyXG4gICoqL1xyXG4gIGdldCBmaXJzdExldmVsKCkge1xyXG4gICAgcmV0dXJuIE1hdGgubWF4KHRoaXMubGV2ZWxDb250cm9sbGVyLmZpcnN0TGV2ZWwsIHRoaXMubWluQXV0b0xldmVsKTtcclxuICB9XHJcblxyXG4gIC8qKiBzZXQgZmlyc3QgbGV2ZWwgKGluZGV4IG9mIGZpcnN0IGxldmVsIHJlZmVyZW5jZWQgaW4gbWFuaWZlc3QpXHJcbiAgKiovXHJcbiAgc2V0IGZpcnN0TGV2ZWwobmV3TGV2ZWwpIHtcclxuICAgIGxvZ2dlci5sb2coYHNldCBmaXJzdExldmVsOiR7bmV3TGV2ZWx9YCk7XHJcbiAgICB0aGlzLmxldmVsQ29udHJvbGxlci5maXJzdExldmVsID0gbmV3TGV2ZWw7XHJcbiAgfVxyXG5cclxuICAvKiogUmV0dXJuIHN0YXJ0IGxldmVsIChsZXZlbCBvZiBmaXJzdCBmcmFnbWVudCB0aGF0IHdpbGwgYmUgcGxheWVkIGJhY2spXHJcbiAgICAgIGlmIG5vdCBvdmVycmlkZWQgYnkgdXNlciwgZmlyc3QgbGV2ZWwgYXBwZWFyaW5nIGluIG1hbmlmZXN0IHdpbGwgYmUgdXNlZCBhcyBzdGFydCBsZXZlbFxyXG4gICAgICBpZiAtMSA6IGF1dG9tYXRpYyBzdGFydCBsZXZlbCBzZWxlY3Rpb24sIHBsYXliYWNrIHdpbGwgc3RhcnQgZnJvbSBsZXZlbCBtYXRjaGluZyBkb3dubG9hZCBiYW5kd2lkdGggKGRldGVybWluZWQgZnJvbSBkb3dubG9hZCBvZiBmaXJzdCBzZWdtZW50KVxyXG4gICoqL1xyXG4gIGdldCBzdGFydExldmVsKCkge1xyXG4gICAgcmV0dXJuIHRoaXMubGV2ZWxDb250cm9sbGVyLnN0YXJ0TGV2ZWw7XHJcbiAgfVxyXG5cclxuICAvKiogc2V0ICBzdGFydCBsZXZlbCAobGV2ZWwgb2YgZmlyc3QgZnJhZ21lbnQgdGhhdCB3aWxsIGJlIHBsYXllZCBiYWNrKVxyXG4gICAgICBpZiBub3Qgb3ZlcnJpZGVkIGJ5IHVzZXIsIGZpcnN0IGxldmVsIGFwcGVhcmluZyBpbiBtYW5pZmVzdCB3aWxsIGJlIHVzZWQgYXMgc3RhcnQgbGV2ZWxcclxuICAgICAgaWYgLTEgOiBhdXRvbWF0aWMgc3RhcnQgbGV2ZWwgc2VsZWN0aW9uLCBwbGF5YmFjayB3aWxsIHN0YXJ0IGZyb20gbGV2ZWwgbWF0Y2hpbmcgZG93bmxvYWQgYmFuZHdpZHRoIChkZXRlcm1pbmVkIGZyb20gZG93bmxvYWQgb2YgZmlyc3Qgc2VnbWVudClcclxuICAqKi9cclxuICBzZXQgc3RhcnRMZXZlbChuZXdMZXZlbCkge1xyXG4gICAgbG9nZ2VyLmxvZyhgc2V0IHN0YXJ0TGV2ZWw6JHtuZXdMZXZlbH1gKTtcclxuICAgIGNvbnN0IGhscyA9IHRoaXM7XHJcbiAgICAvLyBpZiBub3QgaW4gYXV0b21hdGljIHN0YXJ0IGxldmVsIGRldGVjdGlvbiwgZW5zdXJlIHN0YXJ0TGV2ZWwgaXMgZ3JlYXRlciB0aGFuIG1pbkF1dG9MZXZlbFxyXG4gICAgaWYgKG5ld0xldmVsICE9PSAtMSkge1xyXG4gICAgICBuZXdMZXZlbCA9IE1hdGgubWF4KG5ld0xldmVsLGhscy5taW5BdXRvTGV2ZWwpO1xyXG4gICAgfVxyXG4gICAgaGxzLmxldmVsQ29udHJvbGxlci5zdGFydExldmVsID0gbmV3TGV2ZWw7XHJcbiAgfVxyXG5cclxuICAvKiogUmV0dXJuIHRoZSBjYXBwaW5nL21heCBsZXZlbCB2YWx1ZSB0aGF0IGNvdWxkIGJlIHVzZWQgYnkgYXV0b21hdGljIGxldmVsIHNlbGVjdGlvbiBhbGdvcml0aG0gKiovXHJcbiAgZ2V0IGF1dG9MZXZlbENhcHBpbmcoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fYXV0b0xldmVsQ2FwcGluZztcclxuICB9XHJcblxyXG4gIC8qKiBzZXQgdGhlIGNhcHBpbmcvbWF4IGxldmVsIHZhbHVlIHRoYXQgY291bGQgYmUgdXNlZCBieSBhdXRvbWF0aWMgbGV2ZWwgc2VsZWN0aW9uIGFsZ29yaXRobSAqKi9cclxuICBzZXQgYXV0b0xldmVsQ2FwcGluZyhuZXdMZXZlbCkge1xyXG4gICAgbG9nZ2VyLmxvZyhgc2V0IGF1dG9MZXZlbENhcHBpbmc6JHtuZXdMZXZlbH1gKTtcclxuICAgIHRoaXMuX2F1dG9MZXZlbENhcHBpbmcgPSBuZXdMZXZlbDtcclxuICB9XHJcblxyXG4gIC8qIGNoZWNrIGlmIHdlIGFyZSBpbiBhdXRvbWF0aWMgbGV2ZWwgc2VsZWN0aW9uIG1vZGUgKi9cclxuICBnZXQgYXV0b0xldmVsRW5hYmxlZCgpIHtcclxuICAgIHJldHVybiAodGhpcy5sZXZlbENvbnRyb2xsZXIubWFudWFsTGV2ZWwgPT09IC0xKTtcclxuICB9XHJcblxyXG4gIC8qIHJldHVybiBtYW51YWwgbGV2ZWwgKi9cclxuICBnZXQgbWFudWFsTGV2ZWwoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5sZXZlbENvbnRyb2xsZXIubWFudWFsTGV2ZWw7XHJcbiAgfVxyXG5cclxuICAvKiByZXR1cm4gbWluIGxldmVsIHNlbGVjdGFibGUgaW4gYXV0byBtb2RlIGFjY29yZGluZyB0byBjb25maWcubWluQXV0b0JpdHJhdGUgKi9cclxuICBnZXQgbWluQXV0b0xldmVsKCkge1xyXG4gICAgbGV0IGhscyA9IHRoaXMsIGxldmVscyA9IGhscy5sZXZlbHMsIG1pbkF1dG9CaXRyYXRlID0gaGxzLmNvbmZpZy5taW5BdXRvQml0cmF0ZSwgbGVuID0gbGV2ZWxzID8gbGV2ZWxzLmxlbmd0aCA6IDA7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgIGNvbnN0IGxldmVsTmV4dEJpdHJhdGUgPSBsZXZlbHNbaV0ucmVhbEJpdHJhdGUgPyBNYXRoLm1heChsZXZlbHNbaV0ucmVhbEJpdHJhdGUsbGV2ZWxzW2ldLmJpdHJhdGUpIDogbGV2ZWxzW2ldLmJpdHJhdGU7XHJcbiAgICAgIGlmIChsZXZlbE5leHRCaXRyYXRlID4gbWluQXV0b0JpdHJhdGUpIHtcclxuICAgICAgICByZXR1cm4gaTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIDA7XHJcbiAgfVxyXG5cclxuICAvKiByZXR1cm4gbWF4IGxldmVsIHNlbGVjdGFibGUgaW4gYXV0byBtb2RlIGFjY29yZGluZyB0byBhdXRvTGV2ZWxDYXBwaW5nICovXHJcbiAgZ2V0IG1heEF1dG9MZXZlbCgpIHtcclxuICAgIGNvbnN0IGhscyA9IHRoaXM7XHJcbiAgICBjb25zdCBsZXZlbHMgPSBobHMubGV2ZWxzO1xyXG4gICAgY29uc3QgYXV0b0xldmVsQ2FwcGluZyA9IGhscy5hdXRvTGV2ZWxDYXBwaW5nO1xyXG4gICAgbGV0IG1heEF1dG9MZXZlbDtcclxuICAgIGlmIChhdXRvTGV2ZWxDYXBwaW5nPT09IC0xICYmIGxldmVscyAmJiBsZXZlbHMubGVuZ3RoKSB7XHJcbiAgICAgIG1heEF1dG9MZXZlbCA9IGxldmVscy5sZW5ndGggLSAxO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgbWF4QXV0b0xldmVsID0gYXV0b0xldmVsQ2FwcGluZztcclxuICAgIH1cclxuICAgIHJldHVybiBtYXhBdXRvTGV2ZWw7XHJcbiAgfVxyXG5cclxuICAvLyByZXR1cm4gbmV4dCBhdXRvIGxldmVsXHJcbiAgZ2V0IG5leHRBdXRvTGV2ZWwoKSB7XHJcbiAgICBjb25zdCBobHMgPSB0aGlzO1xyXG4gICAgLy8gZW5zdXJlIG5leHQgYXV0byBsZXZlbCBpcyBiZXR3ZWVuICBtaW4gYW5kIG1heCBhdXRvIGxldmVsXHJcbiAgICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgoaGxzLmFickNvbnRyb2xsZXIubmV4dEF1dG9MZXZlbCxobHMubWluQXV0b0xldmVsKSxobHMubWF4QXV0b0xldmVsKTtcclxuICB9XHJcblxyXG4gIC8vIHRoaXMgc2V0dGVyIGlzIHVzZWQgdG8gZm9yY2UgbmV4dCBhdXRvIGxldmVsXHJcbiAgLy8gdGhpcyBpcyB1c2VmdWwgdG8gZm9yY2UgYSBzd2l0Y2ggZG93biBpbiBhdXRvIG1vZGUgOiBpbiBjYXNlIG9mIGxvYWQgZXJyb3Igb24gbGV2ZWwgTiwgaGxzLmpzIGNhbiBzZXQgbmV4dEF1dG9MZXZlbCB0byBOLTEgZm9yIGV4YW1wbGUpXHJcbiAgLy8gZm9yY2VkIHZhbHVlIGlzIHZhbGlkIGZvciBvbmUgZnJhZ21lbnQuIHVwb24gc3VjY2VzZnVsIGZyYWcgbG9hZGluZyBhdCBmb3JjZWQgbGV2ZWwsIHRoaXMgdmFsdWUgd2lsbCBiZSByZXNldHRlZCB0byAtMSBieSBBQlIgY29udHJvbGxlclxyXG4gIHNldCBuZXh0QXV0b0xldmVsKG5leHRMZXZlbCkge1xyXG4gICAgY29uc3QgaGxzID0gdGhpcztcclxuICAgIGhscy5hYnJDb250cm9sbGVyLm5leHRBdXRvTGV2ZWwgPSBNYXRoLm1heChobHMubWluQXV0b0xldmVsLG5leHRMZXZlbCk7XHJcbiAgfVxyXG5cclxuICAvKiogZ2V0IGFsdGVybmF0ZSBhdWRpbyB0cmFja3MgbGlzdCBmcm9tIHBsYXlsaXN0ICoqL1xyXG4gIGdldCBhdWRpb1RyYWNrcygpIHtcclxuICAgIGNvbnN0IGF1ZGlvVHJhY2tDb250cm9sbGVyID0gdGhpcy5hdWRpb1RyYWNrQ29udHJvbGxlcjtcclxuICAgIHJldHVybiBhdWRpb1RyYWNrQ29udHJvbGxlciA/IGF1ZGlvVHJhY2tDb250cm9sbGVyLmF1ZGlvVHJhY2tzIDogW107XHJcbiAgfVxyXG5cclxuICAvKiogZ2V0IGluZGV4IG9mIHRoZSBzZWxlY3RlZCBhdWRpbyB0cmFjayAoaW5kZXggaW4gYXVkaW8gdHJhY2sgbGlzdHMpICoqL1xyXG4gIGdldCBhdWRpb1RyYWNrKCkge1xyXG4gICAgY29uc3QgYXVkaW9UcmFja0NvbnRyb2xsZXIgPSB0aGlzLmF1ZGlvVHJhY2tDb250cm9sbGVyO1xyXG4gICAgcmV0dXJuIGF1ZGlvVHJhY2tDb250cm9sbGVyID8gYXVkaW9UcmFja0NvbnRyb2xsZXIuYXVkaW9UcmFjayA6IC0xO1xyXG4gIH1cclxuXHJcbiAgLyoqIHNlbGVjdCBhbiBhdWRpbyB0cmFjaywgYmFzZWQgb24gaXRzIGluZGV4IGluIGF1ZGlvIHRyYWNrIGxpc3RzKiovXHJcbiAgc2V0IGF1ZGlvVHJhY2soYXVkaW9UcmFja0lkKSB7XHJcbiAgICBjb25zdCBhdWRpb1RyYWNrQ29udHJvbGxlciA9IHRoaXMuYXVkaW9UcmFja0NvbnRyb2xsZXI7XHJcbiAgICBpZiAoYXVkaW9UcmFja0NvbnRyb2xsZXIpIHtcclxuICAgICAgYXVkaW9UcmFja0NvbnRyb2xsZXIuYXVkaW9UcmFjayA9IGF1ZGlvVHJhY2tJZDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGdldCBsaXZlU3luY1Bvc2l0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuc3RyZWFtQ29udHJvbGxlci5saXZlU3luY1Bvc2l0aW9uO1xyXG4gIH1cclxuXHJcbiAgLyoqIGdldCBhbHRlcm5hdGUgc3VidGl0bGUgdHJhY2tzIGxpc3QgZnJvbSBwbGF5bGlzdCAqKi9cclxuICBnZXQgc3VidGl0bGVUcmFja3MoKSB7XHJcbiAgICBjb25zdCBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlciA9IHRoaXMuc3VidGl0bGVUcmFja0NvbnRyb2xsZXI7XHJcbiAgICByZXR1cm4gc3VidGl0bGVUcmFja0NvbnRyb2xsZXIgPyBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlci5zdWJ0aXRsZVRyYWNrcyA6IFtdO1xyXG4gIH1cclxuXHJcbiAgLyoqIGdldCBpbmRleCBvZiB0aGUgc2VsZWN0ZWQgc3VidGl0bGUgdHJhY2sgKGluZGV4IGluIHN1YnRpdGxlIHRyYWNrIGxpc3RzKSAqKi9cclxuICBnZXQgc3VidGl0bGVUcmFjaygpIHtcclxuICAgIGNvbnN0IHN1YnRpdGxlVHJhY2tDb250cm9sbGVyID0gdGhpcy5zdWJ0aXRsZVRyYWNrQ29udHJvbGxlcjtcclxuICAgIHJldHVybiBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlciA/IHN1YnRpdGxlVHJhY2tDb250cm9sbGVyLnN1YnRpdGxlVHJhY2sgOiAtMTtcclxuICB9XHJcblxyXG4gIC8qKiBzZWxlY3QgYW4gc3VidGl0bGUgdHJhY2ssIGJhc2VkIG9uIGl0cyBpbmRleCBpbiBzdWJ0aXRsZSB0cmFjayBsaXN0cyoqL1xyXG4gIHNldCBzdWJ0aXRsZVRyYWNrKHN1YnRpdGxlVHJhY2tJZCkge1xyXG4gICAgY29uc3Qgc3VidGl0bGVUcmFja0NvbnRyb2xsZXIgPSB0aGlzLnN1YnRpdGxlVHJhY2tDb250cm9sbGVyO1xyXG4gICAgaWYgKHN1YnRpdGxlVHJhY2tDb250cm9sbGVyKSB7XHJcbiAgICAgIHN1YnRpdGxlVHJhY2tDb250cm9sbGVyLnN1YnRpdGxlVHJhY2sgPSBzdWJ0aXRsZVRyYWNrSWQ7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBIbHM7XHJcbiIsIi8vIFRoaXMgaXMgbW9zdGx5IGZvciBzdXBwb3J0IG9mIHRoZSBlczYgbW9kdWxlIGV4cG9ydFxyXG4vLyBzeW50YXggd2l0aCB0aGUgYmFiZWwgY29tcGlsZXIsIGl0IGxvb2tzIGxpa2UgaXQgZG9lc250IHN1cHBvcnRcclxuLy8gZnVuY3Rpb24gZXhwb3J0cyBsaWtlIHdlIGFyZSB1c2VkIHRvIGluIG5vZGUvY29tbW9uanNcclxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2hscy5qcycpLmRlZmF1bHQ7XHJcbiIsIi8qXHJcbiAqIEZyYWdtZW50IExvYWRlclxyXG4qL1xyXG5cclxuaW1wb3J0IEV2ZW50IGZyb20gJy4uL2V2ZW50cyc7XHJcbmltcG9ydCBFdmVudEhhbmRsZXIgZnJvbSAnLi4vZXZlbnQtaGFuZGxlcic7XHJcbmltcG9ydCB7RXJyb3JUeXBlcywgRXJyb3JEZXRhaWxzfSBmcm9tICcuLi9lcnJvcnMnO1xyXG5pbXBvcnQge2xvZ2dlcn0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcclxuXHJcbmNsYXNzIEZyYWdtZW50TG9hZGVyIGV4dGVuZHMgRXZlbnRIYW5kbGVyIHtcclxuXHJcbiAgY29uc3RydWN0b3IoaGxzKSB7XHJcbiAgICBzdXBlcihobHMsIEV2ZW50LkZSQUdfTE9BRElORyk7XHJcbiAgICB0aGlzLmxvYWRlcnMgPSB7fTtcclxuICB9XHJcblxyXG4gIGRlc3Ryb3koKSB7XHJcbiAgICBsZXQgbG9hZGVycyA9IHRoaXMubG9hZGVycztcclxuICAgIGZvciAobGV0IGxvYWRlck5hbWUgaW4gbG9hZGVycykge1xyXG4gICAgICBsZXQgbG9hZGVyID0gbG9hZGVyc1tsb2FkZXJOYW1lXTtcclxuICAgICAgaWYgKGxvYWRlcikge1xyXG4gICAgICAgIGxvYWRlci5kZXN0cm95KCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHRoaXMubG9hZGVycyA9IHt9O1xyXG4gICAgRXZlbnRIYW5kbGVyLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XHJcbiAgfVxyXG5cclxuICBvbkZyYWdMb2FkaW5nKGRhdGEpIHtcclxuICAgIGxldCBmcmFnID0gZGF0YS5mcmFnLFxyXG4gICAgICAgIHR5cGUgPSBmcmFnLnR5cGUsXHJcbiAgICAgICAgbG9hZGVyID0gdGhpcy5sb2FkZXJzW3R5cGVdLFxyXG4gICAgICAgIGNvbmZpZyA9IHRoaXMuaGxzLmNvbmZpZztcclxuXHJcbiAgICBmcmFnLmxvYWRlZCA9IDA7XHJcbiAgICBpZiAobG9hZGVyKSB7XHJcbiAgICAgIGxvZ2dlci53YXJuKGBhYm9ydCBwcmV2aW91cyBmcmFnbWVudCBsb2FkZXIgZm9yIHR5cGU6JHt0eXBlfWApO1xyXG4gICAgICBsb2FkZXIuYWJvcnQoKTtcclxuICAgIH1cclxuICAgIGxvYWRlciAgPSB0aGlzLmxvYWRlcnNbdHlwZV0gPSBmcmFnLmxvYWRlciA9IHR5cGVvZihjb25maWcuZkxvYWRlcikgIT09ICd1bmRlZmluZWQnID8gbmV3IGNvbmZpZy5mTG9hZGVyKGNvbmZpZykgOiBuZXcgY29uZmlnLmxvYWRlcihjb25maWcpO1xyXG5cclxuICAgIGxldCBsb2FkZXJDb250ZXh0LCBsb2FkZXJDb25maWcsIGxvYWRlckNhbGxiYWNrcztcclxuICAgIGxvYWRlckNvbnRleHQgPSB7IHVybCA6IGZyYWcudXJsLCBmcmFnIDogZnJhZywgcmVzcG9uc2VUeXBlIDogJ2FycmF5YnVmZmVyJywgcHJvZ3Jlc3NEYXRhIDogZmFsc2V9O1xyXG4gICAgbGV0IHN0YXJ0ID0gZnJhZy5ieXRlUmFuZ2VTdGFydE9mZnNldCwgZW5kID0gZnJhZy5ieXRlUmFuZ2VFbmRPZmZzZXQ7XHJcbiAgICBpZiAoIWlzTmFOKHN0YXJ0KSAmJiAhaXNOYU4oZW5kKSkge1xyXG4gICAgICBsb2FkZXJDb250ZXh0LnJhbmdlU3RhcnQgPSBzdGFydDtcclxuICAgICAgbG9hZGVyQ29udGV4dC5yYW5nZUVuZCA9IGVuZDtcclxuICAgIH1cclxuICAgIGxvYWRlckNvbmZpZyA9IHsgdGltZW91dCA6IGNvbmZpZy5mcmFnTG9hZGluZ1RpbWVPdXQsIG1heFJldHJ5IDogMCAsIHJldHJ5RGVsYXkgOiAwLCBtYXhSZXRyeURlbGF5IDogY29uZmlnLmZyYWdMb2FkaW5nTWF4UmV0cnlUaW1lb3V0fTtcclxuICAgIGxvYWRlckNhbGxiYWNrcyA9IHsgb25TdWNjZXNzIDogdGhpcy5sb2Fkc3VjY2Vzcy5iaW5kKHRoaXMpLCBvbkVycm9yIDp0aGlzLmxvYWRlcnJvci5iaW5kKHRoaXMpLCBvblRpbWVvdXQgOiB0aGlzLmxvYWR0aW1lb3V0LmJpbmQodGhpcyksIG9uUHJvZ3Jlc3M6IHRoaXMubG9hZHByb2dyZXNzLmJpbmQodGhpcyl9O1xyXG4gICAgbG9hZGVyLmxvYWQobG9hZGVyQ29udGV4dCxsb2FkZXJDb25maWcsbG9hZGVyQ2FsbGJhY2tzKTtcclxuICB9XHJcblxyXG4gIGxvYWRzdWNjZXNzKHJlc3BvbnNlLCBzdGF0cywgY29udGV4dCwgbmV0d29ya0RldGFpbHM9bnVsbCkge1xyXG4gICAgbGV0IHBheWxvYWQgPSByZXNwb25zZS5kYXRhLCBmcmFnID0gY29udGV4dC5mcmFnO1xyXG4gICAgLy8gZGV0YWNoIGZyYWdtZW50IGxvYWRlciBvbiBsb2FkIHN1Y2Nlc3NcclxuICAgIGZyYWcubG9hZGVyID0gdW5kZWZpbmVkO1xyXG4gICAgdGhpcy5sb2FkZXJzW2ZyYWcudHlwZV0gPSB1bmRlZmluZWQ7XHJcbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkZSQUdfTE9BREVELCB7cGF5bG9hZDogcGF5bG9hZCwgZnJhZzogZnJhZywgc3RhdHM6IHN0YXRzLCBuZXR3b3JrRGV0YWlsczogbmV0d29ya0RldGFpbHN9KTtcclxuICB9XHJcblxyXG4gIGxvYWRlcnJvcihyZXNwb25zZSwgY29udGV4dCwgbmV0d29ya0RldGFpbHM9bnVsbCkge1xyXG4gICAgbGV0IGxvYWRlciA9IGNvbnRleHQubG9hZGVyO1xyXG4gICAgaWYgKGxvYWRlcikge1xyXG4gICAgICBsb2FkZXIuYWJvcnQoKTtcclxuICAgIH1cclxuICAgIHRoaXMubG9hZGVyc1tjb250ZXh0LnR5cGVdID0gdW5kZWZpbmVkO1xyXG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5FUlJPUiwge3R5cGU6IEVycm9yVHlwZXMuTkVUV09SS19FUlJPUiwgZGV0YWlsczogRXJyb3JEZXRhaWxzLkZSQUdfTE9BRF9FUlJPUiwgZmF0YWw6IGZhbHNlLCBmcmFnOiBjb250ZXh0LmZyYWcsIHJlc3BvbnNlOiByZXNwb25zZSwgbmV0d29ya0RldGFpbHM6IG5ldHdvcmtEZXRhaWxzfSk7XHJcbiAgfVxyXG5cclxuICBsb2FkdGltZW91dChzdGF0cywgY29udGV4dCwgbmV0d29ya0RldGFpbHM9bnVsbCkge1xyXG4gICAgbGV0IGxvYWRlciA9IGNvbnRleHQubG9hZGVyO1xyXG4gICAgaWYgKGxvYWRlcikge1xyXG4gICAgICBsb2FkZXIuYWJvcnQoKTtcclxuICAgIH1cclxuICAgIHRoaXMubG9hZGVyc1tjb250ZXh0LnR5cGVdID0gdW5kZWZpbmVkO1xyXG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5FUlJPUiwge3R5cGU6IEVycm9yVHlwZXMuTkVUV09SS19FUlJPUiwgZGV0YWlsczogRXJyb3JEZXRhaWxzLkZSQUdfTE9BRF9USU1FT1VULCBmYXRhbDogZmFsc2UsIGZyYWc6IGNvbnRleHQuZnJhZywgbmV0d29ya0RldGFpbHM6IG5ldHdvcmtEZXRhaWxzfSk7XHJcbiAgfVxyXG5cclxuICAvLyBkYXRhIHdpbGwgYmUgdXNlZCBmb3IgcHJvZ3Jlc3NpdmUgcGFyc2luZ1xyXG4gIGxvYWRwcm9ncmVzcyhzdGF0cywgY29udGV4dCwgZGF0YSwgbmV0d29ya0RldGFpbHM9bnVsbCkgeyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcclxuICAgIGxldCBmcmFnID0gY29udGV4dC5mcmFnO1xyXG4gICAgZnJhZy5sb2FkZWQgPSBzdGF0cy5sb2FkZWQ7XHJcbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkZSQUdfTE9BRF9QUk9HUkVTUywge2ZyYWc6IGZyYWcsIHN0YXRzOiBzdGF0cywgbmV0d29ya0RldGFpbHM6IG5ldHdvcmtEZXRhaWxzfSk7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBGcmFnbWVudExvYWRlcjtcclxuIiwiLypcclxuICogRGVjcnlwdCBrZXkgTG9hZGVyXHJcbiovXHJcblxyXG5pbXBvcnQgRXZlbnQgZnJvbSAnLi4vZXZlbnRzJztcclxuaW1wb3J0IEV2ZW50SGFuZGxlciBmcm9tICcuLi9ldmVudC1oYW5kbGVyJztcclxuaW1wb3J0IHtFcnJvclR5cGVzLCBFcnJvckRldGFpbHN9IGZyb20gJy4uL2Vycm9ycyc7XHJcbmltcG9ydCB7bG9nZ2VyfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xyXG5cclxuY2xhc3MgS2V5TG9hZGVyIGV4dGVuZHMgRXZlbnRIYW5kbGVyIHtcclxuXHJcbiAgY29uc3RydWN0b3IoaGxzKSB7XHJcbiAgICBzdXBlcihobHMsIEV2ZW50LktFWV9MT0FESU5HKTtcclxuICAgIHRoaXMubG9hZGVycyA9IHt9O1xyXG4gICAgdGhpcy5kZWNyeXB0a2V5ID0gbnVsbDtcclxuICAgIHRoaXMuZGVjcnlwdHVybCA9IG51bGw7XHJcbiAgfVxyXG5cclxuICBkZXN0cm95KCkge1xyXG4gICAgZm9yIChsZXQgbG9hZGVyTmFtZSBpbiB0aGlzLmxvYWRlcnMpIHtcclxuICAgICAgbGV0IGxvYWRlciA9IHRoaXMubG9hZGVyc1tsb2FkZXJOYW1lXTtcclxuICAgICAgaWYgKGxvYWRlcikge1xyXG4gICAgICAgIGxvYWRlci5kZXN0cm95KCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHRoaXMubG9hZGVycyA9IHt9O1xyXG4gICAgRXZlbnRIYW5kbGVyLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XHJcbiAgfVxyXG5cclxuICBvbktleUxvYWRpbmcoZGF0YSkge1xyXG4gICAgbGV0IGZyYWcgPSBkYXRhLmZyYWcsXHJcbiAgICAgICAgdHlwZSA9IGZyYWcudHlwZSxcclxuICAgICAgICBsb2FkZXIgPSB0aGlzLmxvYWRlcnNbdHlwZV0sXHJcbiAgICAgICAgZGVjcnlwdGRhdGEgPSBmcmFnLmRlY3J5cHRkYXRhLFxyXG4gICAgICAgIHVyaSA9IGRlY3J5cHRkYXRhLnVyaTtcclxuICAgICAgICAvLyBpZiB1cmkgaXMgZGlmZmVyZW50IGZyb20gcHJldmlvdXMgb25lIG9yIGlmIGRlY3J5cHQga2V5IG5vdCByZXRyaWV2ZWQgeWV0XHJcbiAgICAgIGlmICh1cmkgIT09IHRoaXMuZGVjcnlwdHVybCB8fCB0aGlzLmRlY3J5cHRrZXkgPT09IG51bGwpIHtcclxuICAgICAgICBsZXQgY29uZmlnID0gdGhpcy5obHMuY29uZmlnO1xyXG5cclxuICAgICAgICBpZiAobG9hZGVyKSB7XHJcbiAgICAgICAgICBsb2dnZXIud2FybihgYWJvcnQgcHJldmlvdXMga2V5IGxvYWRlciBmb3IgdHlwZToke3R5cGV9YCk7XHJcbiAgICAgICAgICBsb2FkZXIuYWJvcnQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZnJhZy5sb2FkZXIgPSB0aGlzLmxvYWRlcnNbdHlwZV0gPSBuZXcgY29uZmlnLmxvYWRlcihjb25maWcpO1xyXG4gICAgICAgIHRoaXMuZGVjcnlwdHVybCA9IHVyaTtcclxuICAgICAgICB0aGlzLmRlY3J5cHRrZXkgPSBudWxsO1xyXG5cclxuICAgICAgICBsZXQgbG9hZGVyQ29udGV4dCwgbG9hZGVyQ29uZmlnLCBsb2FkZXJDYWxsYmFja3M7XHJcbiAgICAgICAgbG9hZGVyQ29udGV4dCA9IHsgdXJsIDogdXJpLCBmcmFnIDogZnJhZywgcmVzcG9uc2VUeXBlIDogJ2FycmF5YnVmZmVyJ307XHJcbiAgICAgICAgbG9hZGVyQ29uZmlnID0geyB0aW1lb3V0IDogY29uZmlnLmZyYWdMb2FkaW5nVGltZU91dCwgbWF4UmV0cnkgOiBjb25maWcuZnJhZ0xvYWRpbmdNYXhSZXRyeSAsIHJldHJ5RGVsYXkgOiBjb25maWcuZnJhZ0xvYWRpbmdSZXRyeURlbGF5LCBtYXhSZXRyeURlbGF5IDogY29uZmlnLmZyYWdMb2FkaW5nTWF4UmV0cnlUaW1lb3V0fTtcclxuICAgICAgICBsb2FkZXJDYWxsYmFja3MgPSB7IG9uU3VjY2VzcyA6IHRoaXMubG9hZHN1Y2Nlc3MuYmluZCh0aGlzKSwgb25FcnJvciA6dGhpcy5sb2FkZXJyb3IuYmluZCh0aGlzKSwgb25UaW1lb3V0IDogdGhpcy5sb2FkdGltZW91dC5iaW5kKHRoaXMpfTtcclxuICAgICAgICBmcmFnLmxvYWRlci5sb2FkKGxvYWRlckNvbnRleHQsbG9hZGVyQ29uZmlnLGxvYWRlckNhbGxiYWNrcyk7XHJcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5kZWNyeXB0a2V5KSB7XHJcbiAgICAgICAgLy8gd2UgYWxyZWFkeSBsb2FkZWQgdGhpcyBrZXksIHJldHVybiBpdFxyXG4gICAgICAgIGRlY3J5cHRkYXRhLmtleSA9IHRoaXMuZGVjcnlwdGtleTtcclxuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LktFWV9MT0FERUQsIHtmcmFnOiBmcmFnfSk7XHJcbiAgICAgIH1cclxuICB9XHJcblxyXG4gIGxvYWRzdWNjZXNzKHJlc3BvbnNlLCBzdGF0cywgY29udGV4dCkge1xyXG4gICAgbGV0IGZyYWcgPSBjb250ZXh0LmZyYWc7XHJcbiAgICB0aGlzLmRlY3J5cHRrZXkgPSBmcmFnLmRlY3J5cHRkYXRhLmtleSA9IG5ldyBVaW50OEFycmF5KHJlc3BvbnNlLmRhdGEpO1xyXG4gICAgLy8gZGV0YWNoIGZyYWdtZW50IGxvYWRlciBvbiBsb2FkIHN1Y2Nlc3NcclxuICAgIGZyYWcubG9hZGVyID0gdW5kZWZpbmVkO1xyXG4gICAgdGhpcy5sb2FkZXJzW2ZyYWcudHlwZV0gPSB1bmRlZmluZWQ7XHJcbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LktFWV9MT0FERUQsIHtmcmFnOiBmcmFnfSk7XHJcbiAgfVxyXG5cclxuICBsb2FkZXJyb3IocmVzcG9uc2UsIGNvbnRleHQpIHtcclxuICAgIGxldCBmcmFnID0gY29udGV4dC5mcmFnLFxyXG4gICAgICAgIGxvYWRlciA9IGZyYWcubG9hZGVyO1xyXG4gICAgaWYgKGxvYWRlcikge1xyXG4gICAgICBsb2FkZXIuYWJvcnQoKTtcclxuICAgIH1cclxuICAgIHRoaXMubG9hZGVyc1tjb250ZXh0LnR5cGVdID0gdW5kZWZpbmVkO1xyXG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5FUlJPUiwge3R5cGU6IEVycm9yVHlwZXMuTkVUV09SS19FUlJPUiwgZGV0YWlsczogRXJyb3JEZXRhaWxzLktFWV9MT0FEX0VSUk9SLCBmYXRhbDogZmFsc2UsIGZyYWc6IGZyYWcsIHJlc3BvbnNlOiByZXNwb25zZX0pO1xyXG4gIH1cclxuXHJcbiAgbG9hZHRpbWVvdXQoc3RhdHMsIGNvbnRleHQpIHtcclxuICAgIGxldCBmcmFnID0gY29udGV4dC5mcmFnLFxyXG4gICAgICAgIGxvYWRlciA9IGZyYWcubG9hZGVyO1xyXG4gICAgaWYgKGxvYWRlcikge1xyXG4gICAgICBsb2FkZXIuYWJvcnQoKTtcclxuICAgIH1cclxuICAgIHRoaXMubG9hZGVyc1tjb250ZXh0LnR5cGVdID0gdW5kZWZpbmVkO1xyXG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5FUlJPUiwge3R5cGU6IEVycm9yVHlwZXMuTkVUV09SS19FUlJPUiwgZGV0YWlsczogRXJyb3JEZXRhaWxzLktFWV9MT0FEX1RJTUVPVVQsIGZhdGFsOiBmYWxzZSwgZnJhZzogZnJhZ30pO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgS2V5TG9hZGVyO1xyXG4iLCIvKipcclxuICogUGxheWxpc3QgTG9hZGVyXHJcbiovXHJcblxyXG5pbXBvcnQgVVJMVG9vbGtpdCBmcm9tICd1cmwtdG9vbGtpdCc7XHJcbmltcG9ydCBFdmVudCBmcm9tICcuLi9ldmVudHMnO1xyXG5pbXBvcnQgRXZlbnRIYW5kbGVyIGZyb20gJy4uL2V2ZW50LWhhbmRsZXInO1xyXG5pbXBvcnQge0Vycm9yVHlwZXMsIEVycm9yRGV0YWlsc30gZnJvbSAnLi4vZXJyb3JzJztcclxuaW1wb3J0IEF0dHJMaXN0IGZyb20gJy4uL3V0aWxzL2F0dHItbGlzdCc7XHJcbmltcG9ydCB7bG9nZ2VyfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xyXG5cclxuLy8gaHR0cHM6Ly9yZWdleDEwMS5jb20gaXMgeW91ciBmcmllbmRcclxuY29uc3QgTUFTVEVSX1BMQVlMSVNUX1JFR0VYID0gLyNFWFQtWC1TVFJFQU0tSU5GOihbXlxcblxccl0qKVtcXHJcXG5dKyhbXlxcclxcbl0rKS9nO1xyXG5jb25zdCBNQVNURVJfUExBWUxJU1RfTUVESUFfUkVHRVggPSAvI0VYVC1YLU1FRElBOiguKikvZztcclxuXHJcbmNvbnN0IExFVkVMX1BMQVlMSVNUX1JFR0VYX0ZBU1QgPSBuZXcgUmVnRXhwKFtcclxuICAvI0VYVElORjooXFxkKig/OlxcLlxcZCspPykoPzosKC4qKVxccyspPy8uc291cmNlLCAvLyBkdXJhdGlvbiAoI0VYVElORjo8ZHVyYXRpb24+LDx0aXRsZT4pLCBncm91cCAxID0+IGR1cmF0aW9uLCBncm91cCAyID0+IHRpdGxlXHJcbiAgL3woPyEjKShcXFMrKS8uc291cmNlLCAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2VnbWVudCBVUkksIGdyb3VwIDMgPT4gdGhlIFVSSSAobm90ZSBuZXdsaW5lIGlzIG5vdCBlYXRlbilcclxuICAvfCNFWFQtWC1CWVRFUkFOR0U6KiguKykvLnNvdXJjZSwgICAgICAgICAgICAgIC8vIG5leHQgc2VnbWVudCdzIGJ5dGVyYW5nZSwgZ3JvdXAgNCA9PiByYW5nZSBzcGVjICh4QHkpXHJcbiAgL3wjRVhULVgtUFJPR1JBTS1EQVRFLVRJTUU6KC4rKS8uc291cmNlLCAgICAgICAvLyBuZXh0IHNlZ21lbnQncyBwcm9ncmFtIGRhdGUvdGltZSBncm91cCA1ID0+IHRoZSBkYXRldGltZSBzcGVjXHJcbiAgL3wjLiovLnNvdXJjZSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBbGwgb3RoZXIgbm9uLXNlZ21lbnQgb3JpZW50ZWQgdGFncyB3aWxsIG1hdGNoIHdpdGggYWxsIGdyb3VwcyBlbXB0eVxyXG5dLmpvaW4oJycpLCAnZycpO1xyXG5cclxuY29uc3QgTEVWRUxfUExBWUxJU1RfUkVHRVhfU0xPVyA9IC8oPzooPzojKEVYVE0zVSkpfCg/OiNFWFQtWC0oUExBWUxJU1QtVFlQRSk6KC4rKSl8KD86I0VYVC1YLShNRURJQS1TRVFVRU5DRSk6ICooXFxkKykpfCg/OiNFWFQtWC0oVEFSR0VURFVSQVRJT04pOiAqKFxcZCspKXwoPzojRVhULVgtKEtFWSk6KC4rKSl8KD86I0VYVC1YLShTVEFSVCk6KC4rKSl8KD86I0VYVC1YLShFTkRMSVNUKSl8KD86I0VYVC1YLShESVNDT05USU5VSVRZLVNFUSlVRU5DRTooXFxkKykpfCg/OiNFWFQtWC0oRElTKUNPTlRJTlVJVFkpKXwoPzojRVhULVgtKFZFUlNJT04pOihcXGQrKSl8KD86I0VYVC1YLShNQVApOiguKykpfCg/OigjKSguKik6KC4qKSl8KD86KCMpKC4qKSkoPzouKilcXHI/XFxuPy87XHJcblxyXG5jbGFzcyBMZXZlbEtleSB7XHJcblxyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgdGhpcy5tZXRob2QgPSBudWxsO1xyXG4gICAgdGhpcy5rZXkgPSBudWxsO1xyXG4gICAgdGhpcy5pdiA9IG51bGw7XHJcbiAgICB0aGlzLl91cmkgPSBudWxsO1xyXG4gIH1cclxuXHJcbiAgZ2V0IHVyaSgpIHtcclxuICAgIGlmICghdGhpcy5fdXJpICYmIHRoaXMucmVsdXJpKSB7XHJcbiAgICAgIHRoaXMuX3VyaSA9IFVSTFRvb2xraXQuYnVpbGRBYnNvbHV0ZVVSTCh0aGlzLmJhc2V1cmksIHRoaXMucmVsdXJpLCB7IGFsd2F5c05vcm1hbGl6ZTogdHJ1ZSB9KTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzLl91cmk7XHJcbiAgfVxyXG5cclxufVxyXG5cclxuY2xhc3MgRnJhZ21lbnQge1xyXG5cclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIHRoaXMuX3VybCA9IG51bGw7XHJcbiAgICB0aGlzLl9ieXRlUmFuZ2UgPSBudWxsO1xyXG4gICAgdGhpcy5fZGVjcnlwdGRhdGEgPSBudWxsO1xyXG4gICAgdGhpcy50YWdMaXN0ID0gW107XHJcbiAgfVxyXG5cclxuICBnZXQgdXJsKCkge1xyXG4gICAgaWYgKCF0aGlzLl91cmwgJiYgdGhpcy5yZWx1cmwpIHtcclxuICAgICAgdGhpcy5fdXJsID0gVVJMVG9vbGtpdC5idWlsZEFic29sdXRlVVJMKHRoaXMuYmFzZXVybCwgdGhpcy5yZWx1cmwsIHsgYWx3YXlzTm9ybWFsaXplOiB0cnVlIH0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXMuX3VybDtcclxuICB9XHJcblxyXG4gIHNldCB1cmwodmFsdWUpIHtcclxuICAgIHRoaXMuX3VybCA9IHZhbHVlO1xyXG4gIH1cclxuXHJcbiAgZ2V0IHByb2dyYW1EYXRlVGltZSgpIHtcclxuICAgIGlmICghdGhpcy5fcHJvZ3JhbURhdGVUaW1lICYmIHRoaXMucmF3UHJvZ3JhbURhdGVUaW1lKSB7XHJcbiAgICAgIHRoaXMuX3Byb2dyYW1EYXRlVGltZSA9IG5ldyBEYXRlKERhdGUucGFyc2UodGhpcy5yYXdQcm9ncmFtRGF0ZVRpbWUpKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzLl9wcm9ncmFtRGF0ZVRpbWU7XHJcbiAgfVxyXG5cclxuICBnZXQgYnl0ZVJhbmdlKCkge1xyXG4gICAgaWYgKCF0aGlzLl9ieXRlUmFuZ2UpIHtcclxuICAgICAgbGV0IGJ5dGVSYW5nZSA9IHRoaXMuX2J5dGVSYW5nZSA9IFtdO1xyXG4gICAgICBpZiAodGhpcy5yYXdCeXRlUmFuZ2UpIHtcclxuICAgICAgICBjb25zdCBwYXJhbXMgPSB0aGlzLnJhd0J5dGVSYW5nZS5zcGxpdCgnQCcsIDIpO1xyXG4gICAgICAgIGlmIChwYXJhbXMubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgICBjb25zdCBsYXN0Qnl0ZVJhbmdlRW5kT2Zmc2V0ID0gdGhpcy5sYXN0Qnl0ZVJhbmdlRW5kT2Zmc2V0O1xyXG4gICAgICAgICAgYnl0ZVJhbmdlWzBdID0gbGFzdEJ5dGVSYW5nZUVuZE9mZnNldCA/IGxhc3RCeXRlUmFuZ2VFbmRPZmZzZXQgOiAwO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBieXRlUmFuZ2VbMF0gPSBwYXJzZUludChwYXJhbXNbMV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBieXRlUmFuZ2VbMV0gPSBwYXJzZUludChwYXJhbXNbMF0pICsgYnl0ZVJhbmdlWzBdO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcy5fYnl0ZVJhbmdlO1xyXG4gIH1cclxuXHJcbiAgZ2V0IGJ5dGVSYW5nZVN0YXJ0T2Zmc2V0KCkge1xyXG4gICAgcmV0dXJuIHRoaXMuYnl0ZVJhbmdlWzBdO1xyXG4gIH1cclxuXHJcbiAgZ2V0IGJ5dGVSYW5nZUVuZE9mZnNldCgpIHtcclxuICAgIHJldHVybiB0aGlzLmJ5dGVSYW5nZVsxXTtcclxuICB9XHJcblxyXG4gIGdldCBkZWNyeXB0ZGF0YSgpIHtcclxuICAgIGlmICghdGhpcy5fZGVjcnlwdGRhdGEpIHtcclxuICAgICAgdGhpcy5fZGVjcnlwdGRhdGEgPSB0aGlzLmZyYWdtZW50RGVjcnlwdGRhdGFGcm9tTGV2ZWxrZXkodGhpcy5sZXZlbGtleSwgdGhpcy5zbik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcy5fZGVjcnlwdGRhdGE7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBVdGlsaXR5IG1ldGhvZCBmb3IgcGFyc2VMZXZlbFBsYXlsaXN0IHRvIGNyZWF0ZSBhbiBpbml0aWFsaXphdGlvbiB2ZWN0b3IgZm9yIGEgZ2l2ZW4gc2VnbWVudFxyXG4gICAqIEByZXR1cm5zIHtVaW50OEFycmF5fVxyXG4gICAqL1xyXG4gIGNyZWF0ZUluaXRpYWxpemF0aW9uVmVjdG9yKHNlZ21lbnROdW1iZXIpIHtcclxuICAgIHZhciB1aW50OFZpZXcgPSBuZXcgVWludDhBcnJheSgxNik7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDEyOyBpIDwgMTY7IGkrKykge1xyXG4gICAgICB1aW50OFZpZXdbaV0gPSAoc2VnbWVudE51bWJlciA+PiA4ICogKDE1IC0gaSkpICYgMHhmZjtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdWludDhWaWV3O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVXRpbGl0eSBtZXRob2QgZm9yIHBhcnNlTGV2ZWxQbGF5bGlzdCB0byBnZXQgYSBmcmFnbWVudCdzIGRlY3J5cHRpb24gZGF0YSBmcm9tIHRoZSBjdXJyZW50bHkgcGFyc2VkIGVuY3J5cHRpb24ga2V5IGRhdGFcclxuICAgKiBAcGFyYW0gbGV2ZWxrZXkgLSBhIHBsYXlsaXN0J3MgZW5jcnlwdGlvbiBpbmZvXHJcbiAgICogQHBhcmFtIHNlZ21lbnROdW1iZXIgLSB0aGUgZnJhZ21lbnQncyBzZWdtZW50IG51bWJlclxyXG4gICAqIEByZXR1cm5zIHsqfSAtIGFuIG9iamVjdCB0byBiZSBhcHBsaWVkIGFzIGEgZnJhZ21lbnQncyBkZWNyeXB0ZGF0YVxyXG4gICAqL1xyXG4gIGZyYWdtZW50RGVjcnlwdGRhdGFGcm9tTGV2ZWxrZXkobGV2ZWxrZXksIHNlZ21lbnROdW1iZXIpIHtcclxuICAgIHZhciBkZWNyeXB0ZGF0YSA9IGxldmVsa2V5O1xyXG5cclxuICAgIGlmIChsZXZlbGtleSAmJiBsZXZlbGtleS5tZXRob2QgJiYgbGV2ZWxrZXkudXJpICYmICFsZXZlbGtleS5pdikge1xyXG4gICAgICBkZWNyeXB0ZGF0YSA9IG5ldyBMZXZlbEtleSgpO1xyXG4gICAgICBkZWNyeXB0ZGF0YS5tZXRob2QgPSBsZXZlbGtleS5tZXRob2Q7XHJcbiAgICAgIGRlY3J5cHRkYXRhLmJhc2V1cmkgPSBsZXZlbGtleS5iYXNldXJpO1xyXG4gICAgICBkZWNyeXB0ZGF0YS5yZWx1cmkgPSBsZXZlbGtleS5yZWx1cmk7XHJcbiAgICAgIGRlY3J5cHRkYXRhLml2ID0gdGhpcy5jcmVhdGVJbml0aWFsaXphdGlvblZlY3RvcihzZWdtZW50TnVtYmVyKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZGVjcnlwdGRhdGE7XHJcbiAgfVxyXG5cclxuICBjbG9uZU9iaihvYmopIHtcclxuICAgIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG9iaikpO1xyXG4gIH1cclxufVxyXG5cclxuY2xhc3MgUGxheWxpc3RMb2FkZXIgZXh0ZW5kcyBFdmVudEhhbmRsZXIge1xyXG5cclxuICBjb25zdHJ1Y3RvcihobHMpIHtcclxuICAgIHN1cGVyKGhscyxcclxuICAgICAgRXZlbnQuTUFOSUZFU1RfTE9BRElORyxcclxuICAgICAgRXZlbnQuTEVWRUxfTE9BRElORyxcclxuICAgICAgRXZlbnQuQVVESU9fVFJBQ0tfTE9BRElORyxcclxuICAgICAgRXZlbnQuU1VCVElUTEVfVFJBQ0tfTE9BRElORyk7XHJcbiAgICB0aGlzLmxvYWRlcnMgPSB7fTtcclxuICB9XHJcblxyXG4gIGRlc3Ryb3koKSB7XHJcbiAgICBmb3IgKGxldCBsb2FkZXJOYW1lIGluIHRoaXMubG9hZGVycykge1xyXG4gICAgICBsZXQgbG9hZGVyID0gdGhpcy5sb2FkZXJzW2xvYWRlck5hbWVdO1xyXG4gICAgICBpZiAobG9hZGVyKSB7XHJcbiAgICAgICAgbG9hZGVyLmRlc3Ryb3koKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgdGhpcy5sb2FkZXJzID0ge307XHJcbiAgICBFdmVudEhhbmRsZXIucHJvdG90eXBlLmRlc3Ryb3kuY2FsbCh0aGlzKTtcclxuICB9XHJcblxyXG4gIG9uTWFuaWZlc3RMb2FkaW5nKGRhdGEpIHtcclxuICAgIHRoaXMubG9hZChkYXRhLnVybCwgeyB0eXBlIDogJ21hbmlmZXN0J30pO1xyXG4gIH1cclxuXHJcbiAgb25MZXZlbExvYWRpbmcoZGF0YSkge1xyXG4gICAgdGhpcy5sb2FkKGRhdGEudXJsLCB7IHR5cGUgOiAnbGV2ZWwnLCBsZXZlbCA6IGRhdGEubGV2ZWwsIGlkIDogZGF0YS5pZH0pO1xyXG4gIH1cclxuXHJcbiAgb25BdWRpb1RyYWNrTG9hZGluZyhkYXRhKSB7XHJcbiAgICB0aGlzLmxvYWQoZGF0YS51cmwsIHsgdHlwZSA6ICdhdWRpb1RyYWNrJywgaWQgOiBkYXRhLmlkfSk7XHJcbiAgfVxyXG5cclxuICBvblN1YnRpdGxlVHJhY2tMb2FkaW5nKGRhdGEpIHtcclxuICAgIHRoaXMubG9hZChkYXRhLnVybCwgeyB0eXBlIDogJ3N1YnRpdGxlVHJhY2snLCBpZCA6IGRhdGEuaWR9KTtcclxuICB9XHJcblxyXG4gIGxvYWQodXJsLCBjb250ZXh0KSB7XHJcbiAgICBsZXQgbG9hZGVyID0gdGhpcy5sb2FkZXJzW2NvbnRleHQudHlwZV07XHJcbiAgICBpZiAobG9hZGVyKSB7XHJcbiAgICAgIGxldCBsb2FkZXJDb250ZXh0ID0gbG9hZGVyLmNvbnRleHQ7XHJcbiAgICAgIGlmIChsb2FkZXJDb250ZXh0ICYmIGxvYWRlckNvbnRleHQudXJsID09PSB1cmwpIHtcclxuICAgICAgICBsb2dnZXIudHJhY2UoYHBsYXlsaXN0IHJlcXVlc3Qgb25nb2luZ2ApO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBsb2dnZXIud2FybihgYWJvcnQgcHJldmlvdXMgbG9hZGVyIGZvciB0eXBlOiR7Y29udGV4dC50eXBlfWApO1xyXG4gICAgICAgIGxvYWRlci5hYm9ydCgpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBsZXQgY29uZmlnID0gdGhpcy5obHMuY29uZmlnLFxyXG4gICAgICAgIHJldHJ5LFxyXG4gICAgICAgIHRpbWVvdXQsXHJcbiAgICAgICAgcmV0cnlEZWxheSxcclxuICAgICAgICBtYXhSZXRyeURlbGF5O1xyXG4gICAgaWYoY29udGV4dC50eXBlID09PSAnbWFuaWZlc3QnKSB7XHJcbiAgICAgIHJldHJ5ID0gY29uZmlnLm1hbmlmZXN0TG9hZGluZ01heFJldHJ5O1xyXG4gICAgICB0aW1lb3V0ID0gY29uZmlnLm1hbmlmZXN0TG9hZGluZ1RpbWVPdXQ7XHJcbiAgICAgIHJldHJ5RGVsYXkgPSBjb25maWcubWFuaWZlc3RMb2FkaW5nUmV0cnlEZWxheTtcclxuICAgICAgbWF4UmV0cnlEZWxheSA9IGNvbmZpZy5tYW5pZmVzdExvYWRpbmdNYXhSZXRyeVRpbWVvdXQ7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXRyeSA9IGNvbmZpZy5sZXZlbExvYWRpbmdNYXhSZXRyeTtcclxuICAgICAgdGltZW91dCA9IGNvbmZpZy5sZXZlbExvYWRpbmdUaW1lT3V0O1xyXG4gICAgICByZXRyeURlbGF5ID0gY29uZmlnLmxldmVsTG9hZGluZ1JldHJ5RGVsYXk7XHJcbiAgICAgIG1heFJldHJ5RGVsYXkgPSBjb25maWcubGV2ZWxMb2FkaW5nTWF4UmV0cnlUaW1lb3V0O1xyXG4gICAgICBsb2dnZXIubG9nKGBsb2FkaW5nIHBsYXlsaXN0IGZvciAke2NvbnRleHQudHlwZX0gJHtjb250ZXh0LmxldmVsIHx8IGNvbnRleHQuaWR9YCk7XHJcbiAgICB9XHJcbiAgICBsb2FkZXIgID0gdGhpcy5sb2FkZXJzW2NvbnRleHQudHlwZV0gPSBjb250ZXh0LmxvYWRlciA9IHR5cGVvZihjb25maWcucExvYWRlcikgIT09ICd1bmRlZmluZWQnID8gbmV3IGNvbmZpZy5wTG9hZGVyKGNvbmZpZykgOiBuZXcgY29uZmlnLmxvYWRlcihjb25maWcpO1xyXG4gICAgY29udGV4dC51cmwgPSB1cmw7XHJcbiAgICBjb250ZXh0LnJlc3BvbnNlVHlwZSA9ICcnO1xyXG5cclxuICAgIGxldCBsb2FkZXJDb25maWcsIGxvYWRlckNhbGxiYWNrcztcclxuICAgIGxvYWRlckNvbmZpZyA9IHsgdGltZW91dCA6IHRpbWVvdXQsIG1heFJldHJ5IDogcmV0cnkgLCByZXRyeURlbGF5IDogcmV0cnlEZWxheSwgbWF4UmV0cnlEZWxheSA6IG1heFJldHJ5RGVsYXl9O1xyXG4gICAgbG9hZGVyQ2FsbGJhY2tzID0geyBvblN1Y2Nlc3MgOiB0aGlzLmxvYWRzdWNjZXNzLmJpbmQodGhpcyksIG9uRXJyb3IgOnRoaXMubG9hZGVycm9yLmJpbmQodGhpcyksIG9uVGltZW91dCA6IHRoaXMubG9hZHRpbWVvdXQuYmluZCh0aGlzKX07XHJcbiAgICBsb2FkZXIubG9hZChjb250ZXh0LGxvYWRlckNvbmZpZyxsb2FkZXJDYWxsYmFja3MpO1xyXG4gIH1cclxuXHJcbiAgcmVzb2x2ZSh1cmwsIGJhc2VVcmwpIHtcclxuICAgIHJldHVybiBVUkxUb29sa2l0LmJ1aWxkQWJzb2x1dGVVUkwoYmFzZVVybCwgdXJsLCB7IGFsd2F5c05vcm1hbGl6ZTogdHJ1ZSB9KTtcclxuICB9XHJcblxyXG4gIHBhcnNlTWFzdGVyUGxheWxpc3Qoc3RyaW5nLCBiYXNldXJsKSB7XHJcbiAgICBsZXQgbGV2ZWxzID0gW10sIHJlc3VsdDtcclxuICAgIE1BU1RFUl9QTEFZTElTVF9SRUdFWC5sYXN0SW5kZXggPSAwO1xyXG4gICAgd2hpbGUgKChyZXN1bHQgPSBNQVNURVJfUExBWUxJU1RfUkVHRVguZXhlYyhzdHJpbmcpKSAhPSBudWxsKXtcclxuICAgICAgY29uc3QgbGV2ZWwgPSB7fTtcclxuXHJcbiAgICAgIHZhciBhdHRycyA9IGxldmVsLmF0dHJzID0gbmV3IEF0dHJMaXN0KHJlc3VsdFsxXSk7XHJcbiAgICAgIGxldmVsLnVybCA9IHRoaXMucmVzb2x2ZShyZXN1bHRbMl0sIGJhc2V1cmwpO1xyXG5cclxuICAgICAgdmFyIHJlc29sdXRpb24gPSBhdHRycy5kZWNpbWFsUmVzb2x1dGlvbignUkVTT0xVVElPTicpO1xyXG4gICAgICBpZihyZXNvbHV0aW9uKSB7XHJcbiAgICAgICAgbGV2ZWwud2lkdGggPSByZXNvbHV0aW9uLndpZHRoO1xyXG4gICAgICAgIGxldmVsLmhlaWdodCA9IHJlc29sdXRpb24uaGVpZ2h0O1xyXG4gICAgICB9XHJcbiAgICAgIGxldmVsLmJpdHJhdGUgPSBhdHRycy5kZWNpbWFsSW50ZWdlcignQVZFUkFHRS1CQU5EV0lEVEgnKSB8fCBhdHRycy5kZWNpbWFsSW50ZWdlcignQkFORFdJRFRIJyk7XHJcbiAgICAgIGxldmVsLm5hbWUgPSBhdHRycy5OQU1FO1xyXG5cclxuICAgICAgdmFyIGNvZGVjcyA9IGF0dHJzLkNPREVDUztcclxuICAgICAgaWYoY29kZWNzKSB7XHJcbiAgICAgICAgY29kZWNzID0gY29kZWNzLnNwbGl0KC9bICxdKy8pO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29kZWNzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICBjb25zdCBjb2RlYyA9IGNvZGVjc1tpXTtcclxuICAgICAgICAgIGlmIChjb2RlYy5pbmRleE9mKCdhdmMxJykgIT09IC0xKSB7XHJcbiAgICAgICAgICAgIGxldmVsLnZpZGVvQ29kZWMgPSB0aGlzLmF2YzF0b2F2Y290aShjb2RlYyk7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKGNvZGVjLmluZGV4T2YoJ2h2YzEnKSAhPT0gLTEpIHtcclxuICAgICAgICAgICAgbGV2ZWwudmlkZW9Db2RlYyA9IGNvZGVjO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgbGV2ZWwuYXVkaW9Db2RlYyA9IGNvZGVjO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgbGV2ZWxzLnB1c2gobGV2ZWwpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGxldmVscztcclxuICB9XHJcblxyXG4gIHBhcnNlTWFzdGVyUGxheWxpc3RNZWRpYShzdHJpbmcsIGJhc2V1cmwsIHR5cGUsIGF1ZGlvQ29kZWM9bnVsbCkge1xyXG4gICAgbGV0IHJlc3VsdCwgbWVkaWFzID0gW10sIGlkID0gMDtcclxuICAgIE1BU1RFUl9QTEFZTElTVF9NRURJQV9SRUdFWC5sYXN0SW5kZXggPSAwO1xyXG4gICAgd2hpbGUgKChyZXN1bHQgPSBNQVNURVJfUExBWUxJU1RfTUVESUFfUkVHRVguZXhlYyhzdHJpbmcpKSAhPSBudWxsKXtcclxuICAgICAgY29uc3QgbWVkaWEgPSB7fTtcclxuICAgICAgdmFyIGF0dHJzID0gbmV3IEF0dHJMaXN0KHJlc3VsdFsxXSk7XHJcbiAgICAgIGlmKGF0dHJzLlRZUEUgPT09IHR5cGUpIHtcclxuICAgICAgICBtZWRpYS5ncm91cElkID0gYXR0cnNbJ0dST1VQLUlEJ107XHJcbiAgICAgICAgbWVkaWEubmFtZSA9IGF0dHJzLk5BTUU7XHJcbiAgICAgICAgbWVkaWEudHlwZSA9IHR5cGU7XHJcbiAgICAgICAgbWVkaWEuZGVmYXVsdCA9IChhdHRycy5ERUZBVUxUID09PSAnWUVTJyk7XHJcbiAgICAgICAgbWVkaWEuYXV0b3NlbGVjdCA9IChhdHRycy5BVVRPU0VMRUNUID09PSAnWUVTJyk7XHJcbiAgICAgICAgbWVkaWEuZm9yY2VkID0gKGF0dHJzLkZPUkNFRCA9PT0gJ1lFUycpO1xyXG4gICAgICAgIGlmIChhdHRycy5VUkkpIHtcclxuICAgICAgICAgIG1lZGlhLnVybCA9IHRoaXMucmVzb2x2ZShhdHRycy5VUkksIGJhc2V1cmwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBtZWRpYS5sYW5nID0gYXR0cnMuTEFOR1VBR0U7XHJcbiAgICAgICAgaWYoIW1lZGlhLm5hbWUpIHtcclxuICAgICAgICAgICAgbWVkaWEubmFtZSA9IG1lZGlhLmxhbmc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChhdWRpb0NvZGVjKSB7XHJcbiAgICAgICAgICBtZWRpYS5hdWRpb0NvZGVjID0gYXVkaW9Db2RlYztcclxuICAgICAgICB9XHJcbiAgICAgICAgbWVkaWEuaWQgPSBpZCsrO1xyXG4gICAgICAgIG1lZGlhcy5wdXNoKG1lZGlhKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG1lZGlhcztcclxuICB9XHJcblxyXG4gIGF2YzF0b2F2Y290aShjb2RlYykge1xyXG4gICAgdmFyIHJlc3VsdCwgYXZjZGF0YSA9IGNvZGVjLnNwbGl0KCcuJyk7XHJcbiAgICBpZiAoYXZjZGF0YS5sZW5ndGggPiAyKSB7XHJcbiAgICAgIHJlc3VsdCA9IGF2Y2RhdGEuc2hpZnQoKSArICcuJztcclxuICAgICAgcmVzdWx0ICs9IHBhcnNlSW50KGF2Y2RhdGEuc2hpZnQoKSkudG9TdHJpbmcoMTYpO1xyXG4gICAgICByZXN1bHQgKz0gKCcwMDAnICsgcGFyc2VJbnQoYXZjZGF0YS5zaGlmdCgpKS50b1N0cmluZygxNikpLnN1YnN0cigtNCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXN1bHQgPSBjb2RlYztcclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbiAgfVxyXG5cclxuICBwYXJzZUxldmVsUGxheWxpc3Qoc3RyaW5nLCBiYXNldXJsLCBpZCwgdHlwZSkge1xyXG4gICAgdmFyIGN1cnJlbnRTTiA9IDAsXHJcbiAgICAgICAgdG90YWxkdXJhdGlvbiA9IDAsXHJcbiAgICAgICAgbGV2ZWwgPSB7dHlwZTogbnVsbCwgdmVyc2lvbjogbnVsbCwgdXJsOiBiYXNldXJsLCBmcmFnbWVudHM6IFtdLCBsaXZlOiB0cnVlLCBzdGFydFNOOiAwfSxcclxuICAgICAgICBsZXZlbGtleSA9IG5ldyBMZXZlbEtleSgpLFxyXG4gICAgICAgIGNjID0gMCxcclxuICAgICAgICBwcmV2RnJhZyA9IG51bGwsXHJcbiAgICAgICAgZnJhZyA9IG5ldyBGcmFnbWVudCgpLFxyXG4gICAgICAgIHJlc3VsdCxcclxuICAgICAgICBpO1xyXG5cclxuICAgIExFVkVMX1BMQVlMSVNUX1JFR0VYX0ZBU1QubGFzdEluZGV4ID0gMDtcclxuXHJcbiAgICB3aGlsZSAoKHJlc3VsdCA9IExFVkVMX1BMQVlMSVNUX1JFR0VYX0ZBU1QuZXhlYyhzdHJpbmcpKSAhPT0gbnVsbCkge1xyXG4gICAgICBjb25zdCBkdXJhdGlvbiA9IHJlc3VsdFsxXTtcclxuICAgICAgaWYgKGR1cmF0aW9uKSB7IC8vIElORlxyXG4gICAgICAgIGZyYWcuZHVyYXRpb24gPSBwYXJzZUZsb2F0KGR1cmF0aW9uKTtcclxuICAgICAgICAvLyBhdm9pZCBzbGljZWQgc3RyaW5ncyAgICBodHRwczovL2dpdGh1Yi5jb20vdmlkZW8tZGV2L2hscy5qcy9pc3N1ZXMvOTM5XHJcbiAgICAgICAgY29uc3QgdGl0bGUgPSAoJyAnICsgcmVzdWx0WzJdKS5zbGljZSgxKTtcclxuICAgICAgICBmcmFnLnRpdGxlID0gdGl0bGUgPyB0aXRsZSA6IG51bGw7XHJcbiAgICAgICAgZnJhZy50YWdMaXN0LnB1c2godGl0bGUgPyBbICdJTkYnLGR1cmF0aW9uLHRpdGxlIF0gOiBbICdJTkYnLGR1cmF0aW9uIF0pO1xyXG4gICAgICB9IGVsc2UgaWYgKHJlc3VsdFszXSkgeyAvLyB1cmxcclxuICAgICAgICBpZiAoIWlzTmFOKGZyYWcuZHVyYXRpb24pKSB7XHJcbiAgICAgICAgICBjb25zdCBzbiA9IGN1cnJlbnRTTisrO1xyXG4gICAgICAgICAgZnJhZy50eXBlID0gdHlwZTtcclxuICAgICAgICAgIGZyYWcuc3RhcnQgPSB0b3RhbGR1cmF0aW9uO1xyXG4gICAgICAgICAgZnJhZy5sZXZlbGtleSA9IGxldmVsa2V5O1xyXG4gICAgICAgICAgZnJhZy5zbiA9IHNuO1xyXG4gICAgICAgICAgZnJhZy5sZXZlbCA9IGlkO1xyXG4gICAgICAgICAgZnJhZy5jYyA9IGNjO1xyXG4gICAgICAgICAgZnJhZy5iYXNldXJsID0gYmFzZXVybDtcclxuICAgICAgICAgIC8vIGF2b2lkIHNsaWNlZCBzdHJpbmdzICAgIGh0dHBzOi8vZ2l0aHViLmNvbS92aWRlby1kZXYvaGxzLmpzL2lzc3Vlcy85MzlcclxuICAgICAgICAgIGZyYWcucmVsdXJsID0gKCcgJyArIHJlc3VsdFszXSkuc2xpY2UoMSk7XHJcblxyXG4gICAgICAgICAgbGV2ZWwuZnJhZ21lbnRzLnB1c2goZnJhZyk7XHJcbiAgICAgICAgICBwcmV2RnJhZyA9IGZyYWc7XHJcbiAgICAgICAgICB0b3RhbGR1cmF0aW9uICs9IGZyYWcuZHVyYXRpb247XHJcblxyXG4gICAgICAgICAgZnJhZyA9IG5ldyBGcmFnbWVudCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIGlmIChyZXN1bHRbNF0pIHsgLy8gWC1CWVRFUkFOR0VcclxuICAgICAgICBmcmFnLnJhd0J5dGVSYW5nZSA9ICgnICcgKyByZXN1bHRbNF0pLnNsaWNlKDEpO1xyXG4gICAgICAgIGlmIChwcmV2RnJhZykge1xyXG4gICAgICAgICAgY29uc3QgbGFzdEJ5dGVSYW5nZUVuZE9mZnNldCA9IHByZXZGcmFnLmJ5dGVSYW5nZUVuZE9mZnNldDtcclxuICAgICAgICAgIGlmIChsYXN0Qnl0ZVJhbmdlRW5kT2Zmc2V0KSB7XHJcbiAgICAgICAgICAgIGZyYWcubGFzdEJ5dGVSYW5nZUVuZE9mZnNldCA9IGxhc3RCeXRlUmFuZ2VFbmRPZmZzZXQ7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2UgaWYgKHJlc3VsdFs1XSkgeyAvLyBQUk9HUkFNLURBVEUtVElNRVxyXG4gICAgICAgIC8vIGF2b2lkIHNsaWNlZCBzdHJpbmdzICAgIGh0dHBzOi8vZ2l0aHViLmNvbS92aWRlby1kZXYvaGxzLmpzL2lzc3Vlcy85MzlcclxuICAgICAgICBmcmFnLnJhd1Byb2dyYW1EYXRlVGltZSA9ICgnICcgKyByZXN1bHRbNV0pLnNsaWNlKDEpO1xyXG4gICAgICAgIGZyYWcudGFnTGlzdC5wdXNoKFsnUFJPR1JBTS1EQVRFLVRJTUUnLCBmcmFnLnJhd1Byb2dyYW1EYXRlVGltZV0pO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdFswXS5tYXRjaChMRVZFTF9QTEFZTElTVF9SRUdFWF9TTE9XKTtcclxuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgcmVzdWx0Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICBpZiAocmVzdWx0W2ldICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBhdm9pZCBzbGljZWQgc3RyaW5ncyAgICBodHRwczovL2dpdGh1Yi5jb20vdmlkZW8tZGV2L2hscy5qcy9pc3N1ZXMvOTM5XHJcbiAgICAgICAgY29uc3QgdmFsdWUxID0gKCcgJyArIHJlc3VsdFtpKzFdKS5zbGljZSgxKTtcclxuICAgICAgICBjb25zdCB2YWx1ZTIgPSAoJyAnICsgcmVzdWx0W2krMl0pLnNsaWNlKDEpO1xyXG5cclxuICAgICAgICBzd2l0Y2ggKHJlc3VsdFtpXSkge1xyXG4gICAgICAgICAgY2FzZSAnIyc6XHJcbiAgICAgICAgICAgIGZyYWcudGFnTGlzdC5wdXNoKHZhbHVlMiA/IFsgdmFsdWUxLHZhbHVlMiBdIDogWyB2YWx1ZTEgXSk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgY2FzZSAnUExBWUxJU1QtVFlQRSc6XHJcbiAgICAgICAgICAgIGxldmVsLnR5cGUgPSB2YWx1ZTEudG9VcHBlckNhc2UoKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlICdNRURJQS1TRVFVRU5DRSc6XHJcbiAgICAgICAgICAgIGN1cnJlbnRTTiA9IGxldmVsLnN0YXJ0U04gPSBwYXJzZUludCh2YWx1ZTEpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGNhc2UgJ1RBUkdFVERVUkFUSU9OJzpcclxuICAgICAgICAgICAgbGV2ZWwudGFyZ2V0ZHVyYXRpb24gPSBwYXJzZUZsb2F0KHZhbHVlMSk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgY2FzZSAnVkVSU0lPTic6XHJcbiAgICAgICAgICAgIGxldmVsLnZlcnNpb24gPSBwYXJzZUludCh2YWx1ZTEpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGNhc2UgJ0VYVE0zVSc6XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgY2FzZSAnRU5ETElTVCc6XHJcbiAgICAgICAgICAgIGxldmVsLmxpdmUgPSBmYWxzZTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlICdESVMnOlxyXG4gICAgICAgICAgICBjYysrO1xyXG4gICAgICAgICAgICBmcmFnLnRhZ0xpc3QucHVzaChbJ0RJUyddKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlICdESVNDT05USU5VSVRZLVNFUSc6XHJcbiAgICAgICAgICAgIGNjID0gcGFyc2VJbnQodmFsdWUxKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlICdLRVknOlxyXG4gICAgICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvZHJhZnQtcGFudG9zLWh0dHAtbGl2ZS1zdHJlYW1pbmctMDgjc2VjdGlvbi0zLjQuNFxyXG4gICAgICAgICAgICB2YXIgZGVjcnlwdHBhcmFtcyA9IHZhbHVlMTtcclxuICAgICAgICAgICAgdmFyIGtleUF0dHJzID0gbmV3IEF0dHJMaXN0KGRlY3J5cHRwYXJhbXMpO1xyXG4gICAgICAgICAgICB2YXIgZGVjcnlwdG1ldGhvZCA9IGtleUF0dHJzLmVudW1lcmF0ZWRTdHJpbmcoJ01FVEhPRCcpLFxyXG4gICAgICAgICAgICAgICAgZGVjcnlwdHVyaSA9IGtleUF0dHJzLlVSSSxcclxuICAgICAgICAgICAgICAgIGRlY3J5cHRpdiA9IGtleUF0dHJzLmhleGFkZWNpbWFsSW50ZWdlcignSVYnKTtcclxuICAgICAgICAgICAgaWYgKGRlY3J5cHRtZXRob2QpIHtcclxuICAgICAgICAgICAgICBsZXZlbGtleSA9IG5ldyBMZXZlbEtleSgpO1xyXG4gICAgICAgICAgICAgIGlmICgoZGVjcnlwdHVyaSkgJiYgKFsnQUVTLTEyOCcsICdTQU1QTEUtQUVTJ10uaW5kZXhPZihkZWNyeXB0bWV0aG9kKSA+PSAwKSkge1xyXG4gICAgICAgICAgICAgICAgbGV2ZWxrZXkubWV0aG9kID0gZGVjcnlwdG1ldGhvZDtcclxuICAgICAgICAgICAgICAgIC8vIFVSSSB0byBnZXQgdGhlIGtleVxyXG4gICAgICAgICAgICAgICAgbGV2ZWxrZXkuYmFzZXVyaSA9IGJhc2V1cmw7XHJcbiAgICAgICAgICAgICAgICBsZXZlbGtleS5yZWx1cmkgPSBkZWNyeXB0dXJpO1xyXG4gICAgICAgICAgICAgICAgbGV2ZWxrZXkua2V5ID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIC8vIEluaXRpYWxpemF0aW9uIFZlY3RvciAoSVYpXHJcbiAgICAgICAgICAgICAgICBsZXZlbGtleS5pdiA9IGRlY3J5cHRpdjtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlICdTVEFSVCc6XHJcbiAgICAgICAgICAgIGxldCBzdGFydFBhcmFtcyA9IHZhbHVlMTtcclxuICAgICAgICAgICAgbGV0IHN0YXJ0QXR0cnMgPSBuZXcgQXR0ckxpc3Qoc3RhcnRQYXJhbXMpO1xyXG4gICAgICAgICAgICBsZXQgc3RhcnRUaW1lT2Zmc2V0ID0gc3RhcnRBdHRycy5kZWNpbWFsRmxvYXRpbmdQb2ludCgnVElNRS1PRkZTRVQnKTtcclxuICAgICAgICAgICAgLy9USU1FLU9GRlNFVCBjYW4gYmUgMFxyXG4gICAgICAgICAgICBpZiAoICFpc05hTihzdGFydFRpbWVPZmZzZXQpICkge1xyXG4gICAgICAgICAgICAgIGxldmVsLnN0YXJ0VGltZU9mZnNldCA9IHN0YXJ0VGltZU9mZnNldDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGNhc2UgJ01BUCc6XHJcbiAgICAgICAgICAgIGxldCBtYXBBdHRycyA9IG5ldyBBdHRyTGlzdCh2YWx1ZTEpO1xyXG4gICAgICAgICAgICBmcmFnLnJlbHVybCA9IG1hcEF0dHJzLlVSSTtcclxuICAgICAgICAgICAgZnJhZy5yYXdCeXRlUmFuZ2UgPSBtYXBBdHRycy5CWVRFUkFOR0U7XHJcbiAgICAgICAgICAgIGZyYWcuYmFzZXVybCA9IGJhc2V1cmw7XHJcbiAgICAgICAgICAgIGZyYWcubGV2ZWwgPSBpZDtcclxuICAgICAgICAgICAgZnJhZy50eXBlID0gdHlwZTtcclxuICAgICAgICAgICAgZnJhZy5zbiA9ICdpbml0U2VnbWVudCc7XHJcbiAgICAgICAgICAgIGxldmVsLmluaXRTZWdtZW50ID0gZnJhZztcclxuICAgICAgICAgICAgZnJhZyA9IG5ldyBGcmFnbWVudCgpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKGBsaW5lIHBhcnNlZCBidXQgbm90IGhhbmRsZWQ6ICR7cmVzdWx0fWApO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGZyYWcgPSBwcmV2RnJhZztcclxuICAgIC8vbG9nZ2VyLmxvZygnZm91bmQgJyArIGxldmVsLmZyYWdtZW50cy5sZW5ndGggKyAnIGZyYWdtZW50cycpO1xyXG4gICAgaWYoZnJhZyAmJiAhZnJhZy5yZWx1cmwpIHtcclxuICAgICAgbGV2ZWwuZnJhZ21lbnRzLnBvcCgpO1xyXG4gICAgICB0b3RhbGR1cmF0aW9uLT1mcmFnLmR1cmF0aW9uO1xyXG4gICAgfVxyXG4gICAgbGV2ZWwudG90YWxkdXJhdGlvbiA9IHRvdGFsZHVyYXRpb247XHJcbiAgICBsZXZlbC5hdmVyYWdldGFyZ2V0ZHVyYXRpb24gPSB0b3RhbGR1cmF0aW9uIC8gbGV2ZWwuZnJhZ21lbnRzLmxlbmd0aDtcclxuICAgIGxldmVsLmVuZFNOID0gY3VycmVudFNOIC0gMTtcclxuICAgIHJldHVybiBsZXZlbDtcclxuICB9XHJcblxyXG4gIGxvYWRzdWNjZXNzKHJlc3BvbnNlLCBzdGF0cywgY29udGV4dCwgbmV0d29ya0RldGFpbHM9bnVsbCkge1xyXG4gICAgdmFyIHN0cmluZyA9IHJlc3BvbnNlLmRhdGEsXHJcbiAgICAgICAgdXJsID0gcmVzcG9uc2UudXJsLFxyXG4gICAgICAgIHR5cGUgPSBjb250ZXh0LnR5cGUsXHJcbiAgICAgICAgaWQgPSBjb250ZXh0LmlkLFxyXG4gICAgICAgIGxldmVsID0gY29udGV4dC5sZXZlbCxcclxuICAgICAgICBobHMgPSB0aGlzLmhscztcclxuXHJcbiAgICB0aGlzLmxvYWRlcnNbdHlwZV0gPSB1bmRlZmluZWQ7XHJcbiAgICAvLyByZXNwb25zZVVSTCBub3Qgc3VwcG9ydGVkIG9uIHNvbWUgYnJvd3NlcnMgKGl0IGlzIHVzZWQgdG8gZGV0ZWN0IFVSTCByZWRpcmVjdGlvbilcclxuICAgIC8vIGRhdGEtdXJpIG1vZGUgYWxzbyBub3Qgc3VwcG9ydGVkIChidXQgbm8gbmVlZCB0byBkZXRlY3QgcmVkaXJlY3Rpb24pXHJcbiAgICBpZiAodXJsID09PSB1bmRlZmluZWQgfHwgdXJsLmluZGV4T2YoJ2RhdGE6JykgPT09IDApIHtcclxuICAgICAgLy8gZmFsbGJhY2sgdG8gaW5pdGlhbCBVUkxcclxuICAgICAgdXJsID0gY29udGV4dC51cmw7XHJcbiAgICB9XHJcbiAgICBzdGF0cy50bG9hZCA9IHBlcmZvcm1hbmNlLm5vdygpO1xyXG4gICAgLy9zdGF0cy5tdGltZSA9IG5ldyBEYXRlKHRhcmdldC5nZXRSZXNwb25zZUhlYWRlcignTGFzdC1Nb2RpZmllZCcpKTtcclxuICAgIGlmIChzdHJpbmcuaW5kZXhPZignI0VYVE0zVScpID09PSAwKSB7XHJcbiAgICAgIGlmIChzdHJpbmcuaW5kZXhPZignI0VYVElORjonKSA+IDApIHtcclxuICAgICAgICBsZXQgaXNMZXZlbCA9ICh0eXBlICE9PSAnYXVkaW9UcmFjaycgJiYgdHlwZSAhPT0gJ3N1YnRpdGxlVHJhY2snKSxcclxuICAgICAgICAgICAgbGV2ZWxJZCA9ICFpc05hTihsZXZlbCkgPyBsZXZlbCA6ICFpc05hTihpZCkgPyBpZCA6IDAsXHJcbiAgICAgICAgICAgIGxldmVsRGV0YWlscyA9IHRoaXMucGFyc2VMZXZlbFBsYXlsaXN0KHN0cmluZywgdXJsLCBsZXZlbElkLCAodHlwZSA9PT0gJ2F1ZGlvVHJhY2snID8gJ2F1ZGlvJyA6ICh0eXBlID09PSAnc3VidGl0bGVUcmFjaycgPyAnc3VidGl0bGUnIDogJ21haW4nKSApKTtcclxuICAgICAgICAgICAgbGV2ZWxEZXRhaWxzLnRsb2FkID0gc3RhdHMudGxvYWQ7XHJcbiAgICAgICAgaWYgKHR5cGUgPT09ICdtYW5pZmVzdCcpIHtcclxuICAgICAgICAvLyBmaXJzdCByZXF1ZXN0LCBzdHJlYW0gbWFuaWZlc3QgKG5vIG1hc3RlciBwbGF5bGlzdCksIGZpcmUgbWFuaWZlc3QgbG9hZGVkIGV2ZW50IHdpdGggbGV2ZWwgZGV0YWlsc1xyXG4gICAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnQuTUFOSUZFU1RfTE9BREVELCB7bGV2ZWxzOiBbe3VybDogdXJsLCBkZXRhaWxzIDogbGV2ZWxEZXRhaWxzfV0sIGF1ZGlvVHJhY2tzIDogW10sIHVybDogdXJsLCBzdGF0czogc3RhdHMsIG5ldHdvcmtEZXRhaWxzOiBuZXR3b3JrRGV0YWlsc30pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzdGF0cy50cGFyc2VkID0gcGVyZm9ybWFuY2Uubm93KCk7XHJcbiAgICAgICAgaWYgKGxldmVsRGV0YWlscy50YXJnZXRkdXJhdGlvbikge1xyXG4gICAgICAgICAgaWYgKGlzTGV2ZWwpIHtcclxuICAgICAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnQuTEVWRUxfTE9BREVELCB7ZGV0YWlsczogbGV2ZWxEZXRhaWxzLCBsZXZlbDogbGV2ZWwgfHwgMCwgaWQ6IGlkIHx8IDAsIHN0YXRzOiBzdGF0cywgbmV0d29ya0RldGFpbHM6IG5ldHdvcmtEZXRhaWxzfSk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gJ2F1ZGlvVHJhY2snKSB7XHJcbiAgICAgICAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnQuQVVESU9fVFJBQ0tfTE9BREVELCB7ZGV0YWlsczogbGV2ZWxEZXRhaWxzLCBpZDogaWQsIHN0YXRzOiBzdGF0cywgbmV0d29ya0RldGFpbHM6IG5ldHdvcmtEZXRhaWxzfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gJ3N1YnRpdGxlVHJhY2snKSB7XHJcbiAgICAgICAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnQuU1VCVElUTEVfVFJBQ0tfTE9BREVELCB7ZGV0YWlsczogbGV2ZWxEZXRhaWxzLCBpZDogaWQsIHN0YXRzOiBzdGF0cywgbmV0d29ya0RldGFpbHM6IG5ldHdvcmtEZXRhaWxzfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnQuRVJST1IsIHt0eXBlOiBFcnJvclR5cGVzLk5FVFdPUktfRVJST1IsIGRldGFpbHM6IEVycm9yRGV0YWlscy5NQU5JRkVTVF9QQVJTSU5HX0VSUk9SLCBmYXRhbDogdHJ1ZSwgdXJsOiB1cmwsIHJlYXNvbjogJ2ludmFsaWQgdGFyZ2V0ZHVyYXRpb24nLCBuZXR3b3JrRGV0YWlsczogbmV0d29ya0RldGFpbHN9KTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbGV0IGxldmVscyA9IHRoaXMucGFyc2VNYXN0ZXJQbGF5bGlzdChzdHJpbmcsIHVybCk7XHJcbiAgICAgICAgLy8gbXVsdGkgbGV2ZWwgcGxheWxpc3QsIHBhcnNlIGxldmVsIGluZm9cclxuICAgICAgICBpZiAobGV2ZWxzLmxlbmd0aCkge1xyXG4gICAgICAgICAgbGV0IGF1ZGlvVHJhY2tzID0gdGhpcy5wYXJzZU1hc3RlclBsYXlsaXN0TWVkaWEoc3RyaW5nLCB1cmwsICdBVURJTycsIGxldmVsc1swXS5hdWRpb0NvZGVjKTtcclxuICAgICAgICAgIGxldCBzdWJ0aXRsZXMgPSB0aGlzLnBhcnNlTWFzdGVyUGxheWxpc3RNZWRpYShzdHJpbmcsIHVybCwgJ1NVQlRJVExFUycpO1xyXG4gICAgICAgICAgaWYgKGF1ZGlvVHJhY2tzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAvLyBjaGVjayBpZiB3ZSBoYXZlIGZvdW5kIGFuIGF1ZGlvIHRyYWNrIGVtYmVkZGVkIGluIG1haW4gcGxheWxpc3QgKGF1ZGlvIHRyYWNrIHdpdGhvdXQgVVJJIGF0dHJpYnV0ZSlcclxuICAgICAgICAgICAgbGV0IGVtYmVkZGVkQXVkaW9Gb3VuZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBhdWRpb1RyYWNrcy5mb3JFYWNoKGF1ZGlvVHJhY2sgPT4ge1xyXG4gICAgICAgICAgICAgIGlmKCFhdWRpb1RyYWNrLnVybCkge1xyXG4gICAgICAgICAgICAgICAgZW1iZWRkZWRBdWRpb0ZvdW5kID0gdHJ1ZTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAvLyBpZiBubyBlbWJlZGRlZCBhdWRpbyB0cmFjayBkZWZpbmVkLCBidXQgYXVkaW8gY29kZWMgc2lnbmFsZWQgaW4gcXVhbGl0eSBsZXZlbCwgd2UgbmVlZCB0byBzaWduYWwgdGhpcyBtYWluIGF1ZGlvIHRyYWNrXHJcbiAgICAgICAgICAgIC8vIHRoaXMgY291bGQgaGFwcGVuIHdpdGggcGxheWxpc3RzIHdpdGggYWx0IGF1ZGlvIHJlbmRpdGlvbiBpbiB3aGljaCBxdWFsaXR5IGxldmVscyAobWFpbikgY29udGFpbnMgYm90aCBhdWRpbyt2aWRlby4gYnV0IHdpdGggbWl4ZWQgYXVkaW8gdHJhY2sgbm90IHNpZ25hbGVkXHJcbiAgICAgICAgICAgIGlmIChlbWJlZGRlZEF1ZGlvRm91bmQgPT09IGZhbHNlICYmIGxldmVsc1swXS5hdWRpb0NvZGVjICYmICFsZXZlbHNbMF0uYXR0cnMuQVVESU8pIHtcclxuICAgICAgICAgICAgICBsb2dnZXIubG9nKCdhdWRpbyBjb2RlYyBzaWduYWxlZCBpbiBxdWFsaXR5IGxldmVsLCBidXQgbm8gZW1iZWRkZWQgYXVkaW8gdHJhY2sgc2lnbmFsZWQsIGNyZWF0ZSBvbmUnKTtcclxuICAgICAgICAgICAgICBhdWRpb1RyYWNrcy51bnNoaWZ0KHsgdHlwZSA6ICdtYWluJywgbmFtZSA6ICdtYWluJ30pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBobHMudHJpZ2dlcihFdmVudC5NQU5JRkVTVF9MT0FERUQsIHtsZXZlbHMsIGF1ZGlvVHJhY2tzLCBzdWJ0aXRsZXMsIHVybCwgc3RhdHMsIG5ldHdvcmtEZXRhaWxzfSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGhscy50cmlnZ2VyKEV2ZW50LkVSUk9SLCB7dHlwZTogRXJyb3JUeXBlcy5ORVRXT1JLX0VSUk9SLCBkZXRhaWxzOiBFcnJvckRldGFpbHMuTUFOSUZFU1RfUEFSU0lOR19FUlJPUiwgZmF0YWw6IHRydWUsIHVybDogdXJsLCByZWFzb246ICdubyBsZXZlbCBmb3VuZCBpbiBtYW5pZmVzdCcsIG5ldHdvcmtEZXRhaWxzOiBuZXR3b3JrRGV0YWlsc30pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaGxzLnRyaWdnZXIoRXZlbnQuRVJST1IsIHt0eXBlOiBFcnJvclR5cGVzLk5FVFdPUktfRVJST1IsIGRldGFpbHM6IEVycm9yRGV0YWlscy5NQU5JRkVTVF9QQVJTSU5HX0VSUk9SLCBmYXRhbDogdHJ1ZSwgdXJsOiB1cmwsIHJlYXNvbjogJ25vIEVYVE0zVSBkZWxpbWl0ZXInLCBuZXR3b3JrRGV0YWlsczogbmV0d29ya0RldGFpbHN9KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGxvYWRlcnJvcihyZXNwb25zZSwgY29udGV4dCwgbmV0d29ya0RldGFpbHM9bnVsbCkge1xyXG4gICAgdmFyIGRldGFpbHMsIGZhdGFsLGxvYWRlciA9IGNvbnRleHQubG9hZGVyO1xyXG4gICAgc3dpdGNoKGNvbnRleHQudHlwZSkge1xyXG4gICAgICBjYXNlICdtYW5pZmVzdCc6XHJcbiAgICAgICAgZGV0YWlscyA9IEVycm9yRGV0YWlscy5NQU5JRkVTVF9MT0FEX0VSUk9SO1xyXG4gICAgICAgIGZhdGFsID0gdHJ1ZTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAnbGV2ZWwnOlxyXG4gICAgICAgIGRldGFpbHMgPSBFcnJvckRldGFpbHMuTEVWRUxfTE9BRF9FUlJPUjtcclxuICAgICAgICBmYXRhbCA9IGZhbHNlO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlICdhdWRpb1RyYWNrJzpcclxuICAgICAgICBkZXRhaWxzID0gRXJyb3JEZXRhaWxzLkFVRElPX1RSQUNLX0xPQURfRVJST1I7XHJcbiAgICAgICAgZmF0YWwgPSBmYWxzZTtcclxuICAgICAgICBicmVhaztcclxuICAgIH1cclxuICAgIGlmIChsb2FkZXIpIHtcclxuICAgICAgbG9hZGVyLmFib3J0KCk7XHJcbiAgICAgIHRoaXMubG9hZGVyc1tjb250ZXh0LnR5cGVdID0gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5FUlJPUiwge3R5cGU6IEVycm9yVHlwZXMuTkVUV09SS19FUlJPUiwgZGV0YWlsczogZGV0YWlscywgZmF0YWw6IGZhdGFsLCB1cmw6IGxvYWRlci51cmwsIGxvYWRlcjogbG9hZGVyLCByZXNwb25zZTogcmVzcG9uc2UsIGNvbnRleHQgOiBjb250ZXh0LCBuZXR3b3JrRGV0YWlsczogbmV0d29ya0RldGFpbHN9KTtcclxuICB9XHJcblxyXG4gIGxvYWR0aW1lb3V0KHN0YXRzLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscz1udWxsKSB7XHJcbiAgICB2YXIgZGV0YWlscywgZmF0YWwsIGxvYWRlciA9IGNvbnRleHQubG9hZGVyO1xyXG4gICAgc3dpdGNoKGNvbnRleHQudHlwZSkge1xyXG4gICAgICBjYXNlICdtYW5pZmVzdCc6XHJcbiAgICAgICAgZGV0YWlscyA9IEVycm9yRGV0YWlscy5NQU5JRkVTVF9MT0FEX1RJTUVPVVQ7XHJcbiAgICAgICAgZmF0YWwgPSB0cnVlO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlICdsZXZlbCc6XHJcbiAgICAgICAgZGV0YWlscyA9IEVycm9yRGV0YWlscy5MRVZFTF9MT0FEX1RJTUVPVVQ7XHJcbiAgICAgICAgZmF0YWwgPSBmYWxzZTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAnYXVkaW9UcmFjayc6XHJcbiAgICAgICAgZGV0YWlscyA9IEVycm9yRGV0YWlscy5BVURJT19UUkFDS19MT0FEX1RJTUVPVVQ7XHJcbiAgICAgICAgZmF0YWwgPSBmYWxzZTtcclxuICAgICAgICBicmVhaztcclxuICAgIH1cclxuICAgIGlmIChsb2FkZXIpIHtcclxuICAgICAgbG9hZGVyLmFib3J0KCk7XHJcbiAgICAgIHRoaXMubG9hZGVyc1tjb250ZXh0LnR5cGVdID0gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5FUlJPUiwge3R5cGU6IEVycm9yVHlwZXMuTkVUV09SS19FUlJPUiwgZGV0YWlsczogZGV0YWlscywgZmF0YWw6IGZhdGFsLCB1cmw6IGxvYWRlci51cmwsIGxvYWRlcjogbG9hZGVyLCBjb250ZXh0IDogY29udGV4dCwgbmV0d29ya0RldGFpbHM6IG5ldHdvcmtEZXRhaWxzfSk7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBQbGF5bGlzdExvYWRlcjtcclxuIiwiLyoqXHJcbiAqIEdlbmVyYXRlIE1QNCBCb3hcclxuKi9cclxuXHJcbi8vaW1wb3J0IEhleCBmcm9tICcuLi91dGlscy9oZXgnO1xyXG5cclxuY29uc3QgVUlOVDMyX01BWCA9IE1hdGgucG93KDIsIDMyKSAtIDE7XHJcblxyXG5jbGFzcyBNUDQge1xyXG4gIHN0YXRpYyBpbml0KCkge1xyXG4gICAgTVA0LnR5cGVzID0ge1xyXG4gICAgICBhdmMxOiBbXSwgLy8gY29kaW5nbmFtZVxyXG4gICAgICBhdmNDOiBbXSxcclxuICAgICAgYnRydDogW10sXHJcbiAgICAgIGRpbmY6IFtdLFxyXG4gICAgICBkcmVmOiBbXSxcclxuICAgICAgZXNkczogW10sXHJcbiAgICAgIGZ0eXA6IFtdLFxyXG4gICAgICBoZGxyOiBbXSxcclxuICAgICAgbWRhdDogW10sXHJcbiAgICAgIG1kaGQ6IFtdLFxyXG4gICAgICBtZGlhOiBbXSxcclxuICAgICAgbWZoZDogW10sXHJcbiAgICAgIG1pbmY6IFtdLFxyXG4gICAgICBtb29mOiBbXSxcclxuICAgICAgbW9vdjogW10sXHJcbiAgICAgIG1wNGE6IFtdLFxyXG4gICAgICAnLm1wMyc6IFtdLFxyXG4gICAgICBtdmV4OiBbXSxcclxuICAgICAgbXZoZDogW10sXHJcbiAgICAgIHBhc3A6IFtdLFxyXG4gICAgICBzZHRwOiBbXSxcclxuICAgICAgc3RibDogW10sXHJcbiAgICAgIHN0Y286IFtdLFxyXG4gICAgICBzdHNjOiBbXSxcclxuICAgICAgc3RzZDogW10sXHJcbiAgICAgIHN0c3o6IFtdLFxyXG4gICAgICBzdHRzOiBbXSxcclxuICAgICAgdGZkdDogW10sXHJcbiAgICAgIHRmaGQ6IFtdLFxyXG4gICAgICB0cmFmOiBbXSxcclxuICAgICAgdHJhazogW10sXHJcbiAgICAgIHRydW46IFtdLFxyXG4gICAgICB0cmV4OiBbXSxcclxuICAgICAgdGtoZDogW10sXHJcbiAgICAgIHZtaGQ6IFtdLFxyXG4gICAgICBzbWhkOiBbXVxyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgaTtcclxuICAgIGZvciAoaSBpbiBNUDQudHlwZXMpIHtcclxuICAgICAgaWYgKE1QNC50eXBlcy5oYXNPd25Qcm9wZXJ0eShpKSkge1xyXG4gICAgICAgIE1QNC50eXBlc1tpXSA9IFtcclxuICAgICAgICAgIGkuY2hhckNvZGVBdCgwKSxcclxuICAgICAgICAgIGkuY2hhckNvZGVBdCgxKSxcclxuICAgICAgICAgIGkuY2hhckNvZGVBdCgyKSxcclxuICAgICAgICAgIGkuY2hhckNvZGVBdCgzKVxyXG4gICAgICAgIF07XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB2YXIgdmlkZW9IZGxyID0gbmV3IFVpbnQ4QXJyYXkoW1xyXG4gICAgICAweDAwLCAvLyB2ZXJzaW9uIDBcclxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gZmxhZ3NcclxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcHJlX2RlZmluZWRcclxuICAgICAgMHg3NiwgMHg2OSwgMHg2NCwgMHg2NSwgLy8gaGFuZGxlcl90eXBlOiAndmlkZSdcclxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcclxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcclxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcclxuICAgICAgMHg1NiwgMHg2OSwgMHg2NCwgMHg2NSxcclxuICAgICAgMHg2ZiwgMHg0OCwgMHg2MSwgMHg2ZSxcclxuICAgICAgMHg2NCwgMHg2YywgMHg2NSwgMHg3MiwgMHgwMCAvLyBuYW1lOiAnVmlkZW9IYW5kbGVyJ1xyXG4gICAgXSk7XHJcblxyXG4gICAgdmFyIGF1ZGlvSGRsciA9IG5ldyBVaW50OEFycmF5KFtcclxuICAgICAgMHgwMCwgLy8gdmVyc2lvbiAwXHJcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGZsYWdzXHJcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHByZV9kZWZpbmVkXHJcbiAgICAgIDB4NzMsIDB4NmYsIDB4NzUsIDB4NmUsIC8vIGhhbmRsZXJfdHlwZTogJ3NvdW4nXHJcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXHJcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXHJcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXHJcbiAgICAgIDB4NTMsIDB4NmYsIDB4NzUsIDB4NmUsXHJcbiAgICAgIDB4NjQsIDB4NDgsIDB4NjEsIDB4NmUsXHJcbiAgICAgIDB4NjQsIDB4NmMsIDB4NjUsIDB4NzIsIDB4MDAgLy8gbmFtZTogJ1NvdW5kSGFuZGxlcidcclxuICAgIF0pO1xyXG5cclxuICAgIE1QNC5IRExSX1RZUEVTID0ge1xyXG4gICAgICAndmlkZW8nOiB2aWRlb0hkbHIsXHJcbiAgICAgICdhdWRpbyc6IGF1ZGlvSGRsclxyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgZHJlZiA9IG5ldyBVaW50OEFycmF5KFtcclxuICAgICAgMHgwMCwgLy8gdmVyc2lvbiAwXHJcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGZsYWdzXHJcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDEsIC8vIGVudHJ5X2NvdW50XHJcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MGMsIC8vIGVudHJ5X3NpemVcclxuICAgICAgMHg3NSwgMHg3MiwgMHg2YywgMHgyMCwgLy8gJ3VybCcgdHlwZVxyXG4gICAgICAweDAwLCAvLyB2ZXJzaW9uIDBcclxuICAgICAgMHgwMCwgMHgwMCwgMHgwMSAvLyBlbnRyeV9mbGFnc1xyXG4gICAgXSk7XHJcblxyXG4gICAgdmFyIHN0Y28gPSBuZXcgVWludDhBcnJheShbXHJcbiAgICAgIDB4MDAsIC8vIHZlcnNpb25cclxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gZmxhZ3NcclxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCAvLyBlbnRyeV9jb3VudFxyXG4gICAgXSk7XHJcblxyXG4gICAgTVA0LlNUVFMgPSBNUDQuU1RTQyA9IE1QNC5TVENPID0gc3RjbztcclxuXHJcbiAgICBNUDQuU1RTWiA9IG5ldyBVaW50OEFycmF5KFtcclxuICAgICAgMHgwMCwgLy8gdmVyc2lvblxyXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAvLyBmbGFnc1xyXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyBzYW1wbGVfc2l6ZVxyXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyBzYW1wbGVfY291bnRcclxuICAgIF0pO1xyXG4gICAgTVA0LlZNSEQgPSBuZXcgVWludDhBcnJheShbXHJcbiAgICAgIDB4MDAsIC8vIHZlcnNpb25cclxuICAgICAgMHgwMCwgMHgwMCwgMHgwMSwgLy8gZmxhZ3NcclxuICAgICAgMHgwMCwgMHgwMCwgLy8gZ3JhcGhpY3Ntb2RlXHJcbiAgICAgIDB4MDAsIDB4MDAsXHJcbiAgICAgIDB4MDAsIDB4MDAsXHJcbiAgICAgIDB4MDAsIDB4MDAgLy8gb3Bjb2xvclxyXG4gICAgXSk7XHJcbiAgICBNUDQuU01IRCA9IG5ldyBVaW50OEFycmF5KFtcclxuICAgICAgMHgwMCwgLy8gdmVyc2lvblxyXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAvLyBmbGFnc1xyXG4gICAgICAweDAwLCAweDAwLCAvLyBiYWxhbmNlXHJcbiAgICAgIDB4MDAsIDB4MDAgLy8gcmVzZXJ2ZWRcclxuICAgIF0pO1xyXG5cclxuICAgIE1QNC5TVFNEID0gbmV3IFVpbnQ4QXJyYXkoW1xyXG4gICAgICAweDAwLCAvLyB2ZXJzaW9uIDBcclxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gZmxhZ3NcclxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMV0pOy8vIGVudHJ5X2NvdW50XHJcblxyXG4gICAgdmFyIG1ham9yQnJhbmQgPSBuZXcgVWludDhBcnJheShbMTA1LDExNSwxMTEsMTA5XSk7IC8vIGlzb21cclxuICAgIHZhciBhdmMxQnJhbmQgPSBuZXcgVWludDhBcnJheShbOTcsMTE4LDk5LDQ5XSk7IC8vIGF2YzFcclxuICAgIHZhciBtaW5vclZlcnNpb24gPSBuZXcgVWludDhBcnJheShbMCwgMCwgMCwgMV0pO1xyXG5cclxuICAgIE1QNC5GVFlQID0gTVA0LmJveChNUDQudHlwZXMuZnR5cCwgbWFqb3JCcmFuZCwgbWlub3JWZXJzaW9uLCBtYWpvckJyYW5kLCBhdmMxQnJhbmQpO1xyXG4gICAgTVA0LkRJTkYgPSBNUDQuYm94KE1QNC50eXBlcy5kaW5mLCBNUDQuYm94KE1QNC50eXBlcy5kcmVmLCBkcmVmKSk7XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgYm94KHR5cGUpIHtcclxuICB2YXJcclxuICAgIHBheWxvYWQgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpLFxyXG4gICAgc2l6ZSA9IDgsXHJcbiAgICBpID0gcGF5bG9hZC5sZW5ndGgsXHJcbiAgICBsZW4gPSBpLFxyXG4gICAgcmVzdWx0O1xyXG4gICAgLy8gY2FsY3VsYXRlIHRoZSB0b3RhbCBzaXplIHdlIG5lZWQgdG8gYWxsb2NhdGVcclxuICAgIHdoaWxlIChpLS0pIHtcclxuICAgICAgc2l6ZSArPSBwYXlsb2FkW2ldLmJ5dGVMZW5ndGg7XHJcbiAgICB9XHJcbiAgICByZXN1bHQgPSBuZXcgVWludDhBcnJheShzaXplKTtcclxuICAgIHJlc3VsdFswXSA9IChzaXplID4+IDI0KSAmIDB4ZmY7XHJcbiAgICByZXN1bHRbMV0gPSAoc2l6ZSA+PiAxNikgJiAweGZmO1xyXG4gICAgcmVzdWx0WzJdID0gKHNpemUgPj4gOCkgJiAweGZmO1xyXG4gICAgcmVzdWx0WzNdID0gc2l6ZSAgJiAweGZmO1xyXG4gICAgcmVzdWx0LnNldCh0eXBlLCA0KTtcclxuICAgIC8vIGNvcHkgdGhlIHBheWxvYWQgaW50byB0aGUgcmVzdWx0XHJcbiAgICBmb3IgKGkgPSAwLCBzaXplID0gODsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgIC8vIGNvcHkgcGF5bG9hZFtpXSBhcnJheSBAIG9mZnNldCBzaXplXHJcbiAgICAgIHJlc3VsdC5zZXQocGF5bG9hZFtpXSwgc2l6ZSk7XHJcbiAgICAgIHNpemUgKz0gcGF5bG9hZFtpXS5ieXRlTGVuZ3RoO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxuICB9XHJcblxyXG4gIHN0YXRpYyBoZGxyKHR5cGUpIHtcclxuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5oZGxyLCBNUDQuSERMUl9UWVBFU1t0eXBlXSk7XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgbWRhdChkYXRhKSB7XHJcbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMubWRhdCwgZGF0YSk7XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgbWRoZCh0aW1lc2NhbGUsIGR1cmF0aW9uKSB7XHJcbiAgICBkdXJhdGlvbiAqPSB0aW1lc2NhbGU7XHJcbiAgICBjb25zdCB1cHBlcldvcmREdXJhdGlvbiA9IE1hdGguZmxvb3IoZHVyYXRpb24gLyAoVUlOVDMyX01BWCArIDEpKTtcclxuICAgIGNvbnN0IGxvd2VyV29yZER1cmF0aW9uID0gTWF0aC5mbG9vcihkdXJhdGlvbiAlIChVSU5UMzJfTUFYICsgMSkpO1xyXG4gICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLm1kaGQsIG5ldyBVaW50OEFycmF5KFtcclxuICAgICAgMHgwMSwgLy8gdmVyc2lvbiAxXHJcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGZsYWdzXHJcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDIsIC8vIGNyZWF0aW9uX3RpbWVcclxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMywgLy8gbW9kaWZpY2F0aW9uX3RpbWVcclxuICAgICAgKHRpbWVzY2FsZSA+PiAyNCkgJiAweEZGLFxyXG4gICAgICAodGltZXNjYWxlID4+IDE2KSAmIDB4RkYsXHJcbiAgICAgICh0aW1lc2NhbGUgPj4gIDgpICYgMHhGRixcclxuICAgICAgdGltZXNjYWxlICYgMHhGRiwgLy8gdGltZXNjYWxlXHJcbiAgICAgICh1cHBlcldvcmREdXJhdGlvbiA+PiAyNCksXHJcbiAgICAgICh1cHBlcldvcmREdXJhdGlvbiA+PiAxNikgJiAweEZGLFxyXG4gICAgICAodXBwZXJXb3JkRHVyYXRpb24gPj4gIDgpICYgMHhGRixcclxuICAgICAgdXBwZXJXb3JkRHVyYXRpb24gJiAweEZGLFxyXG4gICAgICAobG93ZXJXb3JkRHVyYXRpb24gPj4gMjQpLFxyXG4gICAgICAobG93ZXJXb3JkRHVyYXRpb24gPj4gMTYpICYgMHhGRixcclxuICAgICAgKGxvd2VyV29yZER1cmF0aW9uID4+ICA4KSAmIDB4RkYsXHJcbiAgICAgIGxvd2VyV29yZER1cmF0aW9uICYgMHhGRixcclxuICAgICAgMHg1NSwgMHhjNCwgLy8gJ3VuZCcgbGFuZ3VhZ2UgKHVuZGV0ZXJtaW5lZClcclxuICAgICAgMHgwMCwgMHgwMFxyXG4gICAgXSkpO1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIG1kaWEodHJhY2spIHtcclxuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5tZGlhLCBNUDQubWRoZCh0cmFjay50aW1lc2NhbGUsIHRyYWNrLmR1cmF0aW9uKSwgTVA0LmhkbHIodHJhY2sudHlwZSksIE1QNC5taW5mKHRyYWNrKSk7XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgbWZoZChzZXF1ZW5jZU51bWJlcikge1xyXG4gICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLm1maGQsIG5ldyBVaW50OEFycmF5KFtcclxuICAgICAgMHgwMCxcclxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gZmxhZ3NcclxuICAgICAgKHNlcXVlbmNlTnVtYmVyID4+IDI0KSxcclxuICAgICAgKHNlcXVlbmNlTnVtYmVyID4+IDE2KSAmIDB4RkYsXHJcbiAgICAgIChzZXF1ZW5jZU51bWJlciA+PiAgOCkgJiAweEZGLFxyXG4gICAgICBzZXF1ZW5jZU51bWJlciAmIDB4RkYsIC8vIHNlcXVlbmNlX251bWJlclxyXG4gICAgXSkpO1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIG1pbmYodHJhY2spIHtcclxuICAgIGlmICh0cmFjay50eXBlID09PSAnYXVkaW8nKSB7XHJcbiAgICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5taW5mLCBNUDQuYm94KE1QNC50eXBlcy5zbWhkLCBNUDQuU01IRCksIE1QNC5ESU5GLCBNUDQuc3RibCh0cmFjaykpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLm1pbmYsIE1QNC5ib3goTVA0LnR5cGVzLnZtaGQsIE1QNC5WTUhEKSwgTVA0LkRJTkYsIE1QNC5zdGJsKHRyYWNrKSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgbW9vZihzbiwgYmFzZU1lZGlhRGVjb2RlVGltZSwgdHJhY2spIHtcclxuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5tb29mLCBNUDQubWZoZChzbiksIE1QNC50cmFmKHRyYWNrLGJhc2VNZWRpYURlY29kZVRpbWUpKTtcclxuICB9XHJcbi8qKlxyXG4gKiBAcGFyYW0gdHJhY2tzLi4uIChvcHRpb25hbCkge2FycmF5fSB0aGUgdHJhY2tzIGFzc29jaWF0ZWQgd2l0aCB0aGlzIG1vdmllXHJcbiAqL1xyXG4gIHN0YXRpYyBtb292KHRyYWNrcykge1xyXG4gICAgdmFyXHJcbiAgICAgIGkgPSB0cmFja3MubGVuZ3RoLFxyXG4gICAgICBib3hlcyA9IFtdO1xyXG5cclxuICAgIHdoaWxlIChpLS0pIHtcclxuICAgICAgYm94ZXNbaV0gPSBNUDQudHJhayh0cmFja3NbaV0pO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBNUDQuYm94LmFwcGx5KG51bGwsIFtNUDQudHlwZXMubW9vdiwgTVA0Lm12aGQodHJhY2tzWzBdLnRpbWVzY2FsZSwgdHJhY2tzWzBdLmR1cmF0aW9uKV0uY29uY2F0KGJveGVzKS5jb25jYXQoTVA0Lm12ZXgodHJhY2tzKSkpO1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIG12ZXgodHJhY2tzKSB7XHJcbiAgICB2YXJcclxuICAgICAgaSA9IHRyYWNrcy5sZW5ndGgsXHJcbiAgICAgIGJveGVzID0gW107XHJcblxyXG4gICAgd2hpbGUgKGktLSkge1xyXG4gICAgICBib3hlc1tpXSA9IE1QNC50cmV4KHRyYWNrc1tpXSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gTVA0LmJveC5hcHBseShudWxsLCBbTVA0LnR5cGVzLm12ZXhdLmNvbmNhdChib3hlcykpO1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIG12aGQodGltZXNjYWxlLGR1cmF0aW9uKSB7XHJcbiAgICBkdXJhdGlvbio9dGltZXNjYWxlO1xyXG4gICAgY29uc3QgdXBwZXJXb3JkRHVyYXRpb24gPSBNYXRoLmZsb29yKGR1cmF0aW9uIC8gKFVJTlQzMl9NQVggKyAxKSk7XHJcbiAgICBjb25zdCBsb3dlcldvcmREdXJhdGlvbiA9IE1hdGguZmxvb3IoZHVyYXRpb24gJSAoVUlOVDMyX01BWCArIDEpKTtcclxuICAgIHZhclxyXG4gICAgICBieXRlcyA9IG5ldyBVaW50OEFycmF5KFtcclxuICAgICAgICAweDAxLCAvLyB2ZXJzaW9uIDFcclxuICAgICAgICAweDAwLCAweDAwLCAweDAwLCAvLyBmbGFnc1xyXG4gICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDIsIC8vIGNyZWF0aW9uX3RpbWVcclxuICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAzLCAvLyBtb2RpZmljYXRpb25fdGltZVxyXG4gICAgICAgICh0aW1lc2NhbGUgPj4gMjQpICYgMHhGRixcclxuICAgICAgICAodGltZXNjYWxlID4+IDE2KSAmIDB4RkYsXHJcbiAgICAgICAgKHRpbWVzY2FsZSA+PiAgOCkgJiAweEZGLFxyXG4gICAgICAgIHRpbWVzY2FsZSAmIDB4RkYsIC8vIHRpbWVzY2FsZVxyXG4gICAgICAgICh1cHBlcldvcmREdXJhdGlvbiA+PiAyNCksXHJcbiAgICAgICAgKHVwcGVyV29yZER1cmF0aW9uID4+IDE2KSAmIDB4RkYsXHJcbiAgICAgICAgKHVwcGVyV29yZER1cmF0aW9uID4+ICA4KSAmIDB4RkYsXHJcbiAgICAgICAgdXBwZXJXb3JkRHVyYXRpb24gJiAweEZGLFxyXG4gICAgICAgIChsb3dlcldvcmREdXJhdGlvbiA+PiAyNCksXHJcbiAgICAgICAgKGxvd2VyV29yZER1cmF0aW9uID4+IDE2KSAmIDB4RkYsXHJcbiAgICAgICAgKGxvd2VyV29yZER1cmF0aW9uID4+ICA4KSAmIDB4RkYsXHJcbiAgICAgICAgbG93ZXJXb3JkRHVyYXRpb24gJiAweEZGLFxyXG4gICAgICAgIDB4MDAsIDB4MDEsIDB4MDAsIDB4MDAsIC8vIDEuMCByYXRlXHJcbiAgICAgICAgMHgwMSwgMHgwMCwgLy8gMS4wIHZvbHVtZVxyXG4gICAgICAgIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXHJcbiAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcclxuICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxyXG4gICAgICAgIDB4MDAsIDB4MDEsIDB4MDAsIDB4MDAsXHJcbiAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcclxuICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxyXG4gICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXHJcbiAgICAgICAgMHgwMCwgMHgwMSwgMHgwMCwgMHgwMCxcclxuICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxyXG4gICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXHJcbiAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcclxuICAgICAgICAweDQwLCAweDAwLCAweDAwLCAweDAwLCAvLyB0cmFuc2Zvcm1hdGlvbjogdW5pdHkgbWF0cml4XHJcbiAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcclxuICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxyXG4gICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXHJcbiAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcclxuICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxyXG4gICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHByZV9kZWZpbmVkXHJcbiAgICAgICAgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiAvLyBuZXh0X3RyYWNrX0lEXHJcbiAgICAgIF0pO1xyXG4gICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLm12aGQsIGJ5dGVzKTtcclxuICB9XHJcblxyXG4gIHN0YXRpYyBzZHRwKHRyYWNrKSB7XHJcbiAgICB2YXJcclxuICAgICAgc2FtcGxlcyA9IHRyYWNrLnNhbXBsZXMgfHwgW10sXHJcbiAgICAgIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoNCArIHNhbXBsZXMubGVuZ3RoKSxcclxuICAgICAgZmxhZ3MsXHJcbiAgICAgIGk7XHJcbiAgICAvLyBsZWF2ZSB0aGUgZnVsbCBib3ggaGVhZGVyICg0IGJ5dGVzKSBhbGwgemVyb1xyXG4gICAgLy8gd3JpdGUgdGhlIHNhbXBsZSB0YWJsZVxyXG4gICAgZm9yIChpID0gMDsgaSA8IHNhbXBsZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgZmxhZ3MgPSBzYW1wbGVzW2ldLmZsYWdzO1xyXG4gICAgICBieXRlc1tpICsgNF0gPSAoZmxhZ3MuZGVwZW5kc09uIDw8IDQpIHxcclxuICAgICAgICAoZmxhZ3MuaXNEZXBlbmRlZE9uIDw8IDIpIHxcclxuICAgICAgICAoZmxhZ3MuaGFzUmVkdW5kYW5jeSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLnNkdHAsIGJ5dGVzKTtcclxuICB9XHJcblxyXG4gIHN0YXRpYyBzdGJsKHRyYWNrKSB7XHJcbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMuc3RibCwgTVA0LnN0c2QodHJhY2spLCBNUDQuYm94KE1QNC50eXBlcy5zdHRzLCBNUDQuU1RUUyksIE1QNC5ib3goTVA0LnR5cGVzLnN0c2MsIE1QNC5TVFNDKSwgTVA0LmJveChNUDQudHlwZXMuc3RzeiwgTVA0LlNUU1opLCBNUDQuYm94KE1QNC50eXBlcy5zdGNvLCBNUDQuU1RDTykpO1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIGF2YzEodHJhY2spIHtcclxuICAgIHZhciBzcHMgPSBbXSwgcHBzID0gW10sIGksIGRhdGEsIGxlbjtcclxuICAgIC8vIGFzc2VtYmxlIHRoZSBTUFNzXHJcblxyXG4gICAgZm9yIChpID0gMDsgaSA8IHRyYWNrLnNwcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICBkYXRhID0gdHJhY2suc3BzW2ldO1xyXG4gICAgICBsZW4gPSBkYXRhLmJ5dGVMZW5ndGg7XHJcbiAgICAgIHNwcy5wdXNoKChsZW4gPj4+IDgpICYgMHhGRik7XHJcbiAgICAgIHNwcy5wdXNoKChsZW4gJiAweEZGKSk7XHJcbiAgICAgIHNwcyA9IHNwcy5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZGF0YSkpOyAvLyBTUFNcclxuICAgIH1cclxuXHJcbiAgICAvLyBhc3NlbWJsZSB0aGUgUFBTc1xyXG4gICAgZm9yIChpID0gMDsgaSA8IHRyYWNrLnBwcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICBkYXRhID0gdHJhY2sucHBzW2ldO1xyXG4gICAgICBsZW4gPSBkYXRhLmJ5dGVMZW5ndGg7XHJcbiAgICAgIHBwcy5wdXNoKChsZW4gPj4+IDgpICYgMHhGRik7XHJcbiAgICAgIHBwcy5wdXNoKChsZW4gJiAweEZGKSk7XHJcbiAgICAgIHBwcyA9IHBwcy5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZGF0YSkpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBhdmNjID0gTVA0LmJveChNUDQudHlwZXMuYXZjQywgbmV3IFVpbnQ4QXJyYXkoW1xyXG4gICAgICAgICAgICAweDAxLCAgIC8vIHZlcnNpb25cclxuICAgICAgICAgICAgc3BzWzNdLCAvLyBwcm9maWxlXHJcbiAgICAgICAgICAgIHNwc1s0XSwgLy8gcHJvZmlsZSBjb21wYXRcclxuICAgICAgICAgICAgc3BzWzVdLCAvLyBsZXZlbFxyXG4gICAgICAgICAgICAweGZjIHwgMywgLy8gbGVuZ3RoU2l6ZU1pbnVzT25lLCBoYXJkLWNvZGVkIHRvIDQgYnl0ZXNcclxuICAgICAgICAgICAgMHhFMCB8IHRyYWNrLnNwcy5sZW5ndGggLy8gM2JpdCByZXNlcnZlZCAoMTExKSArIG51bU9mU2VxdWVuY2VQYXJhbWV0ZXJTZXRzXHJcbiAgICAgICAgICBdLmNvbmNhdChzcHMpLmNvbmNhdChbXHJcbiAgICAgICAgICAgIHRyYWNrLnBwcy5sZW5ndGggLy8gbnVtT2ZQaWN0dXJlUGFyYW1ldGVyU2V0c1xyXG4gICAgICAgICAgXSkuY29uY2F0KHBwcykpKSwgLy8gXCJQUFNcIlxyXG4gICAgICAgIHdpZHRoID0gdHJhY2sud2lkdGgsXHJcbiAgICAgICAgaGVpZ2h0ID0gdHJhY2suaGVpZ2h0LFxyXG4gICAgICAgIGhTcGFjaW5nID0gdHJhY2sucGl4ZWxSYXRpb1swXSxcclxuICAgICAgICB2U3BhY2luZyA9IHRyYWNrLnBpeGVsUmF0aW9bMV07XHJcbiAgICAvL2NvbnNvbGUubG9nKCdhdmNjOicgKyBIZXguaGV4RHVtcChhdmNjKSk7XHJcbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMuYXZjMSwgbmV3IFVpbnQ4QXJyYXkoW1xyXG4gICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXHJcbiAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcclxuICAgICAgICAweDAwLCAweDAxLCAvLyBkYXRhX3JlZmVyZW5jZV9pbmRleFxyXG4gICAgICAgIDB4MDAsIDB4MDAsIC8vIHByZV9kZWZpbmVkXHJcbiAgICAgICAgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcclxuICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxyXG4gICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXHJcbiAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcHJlX2RlZmluZWRcclxuICAgICAgICAod2lkdGggPj4gOCkgJiAweEZGLFxyXG4gICAgICAgIHdpZHRoICYgMHhmZiwgLy8gd2lkdGhcclxuICAgICAgICAoaGVpZ2h0ID4+IDgpICYgMHhGRixcclxuICAgICAgICBoZWlnaHQgJiAweGZmLCAvLyBoZWlnaHRcclxuICAgICAgICAweDAwLCAweDQ4LCAweDAwLCAweDAwLCAvLyBob3JpenJlc29sdXRpb25cclxuICAgICAgICAweDAwLCAweDQ4LCAweDAwLCAweDAwLCAvLyB2ZXJ0cmVzb2x1dGlvblxyXG4gICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXHJcbiAgICAgICAgMHgwMCwgMHgwMSwgLy8gZnJhbWVfY291bnRcclxuICAgICAgICAweDEyLFxyXG4gICAgICAgIDB4NjQsIDB4NjEsIDB4NjksIDB4NkMsIC8vZGFpbHltb3Rpb24vaGxzLmpzXHJcbiAgICAgICAgMHg3OSwgMHg2RCwgMHg2RiwgMHg3NCxcclxuICAgICAgICAweDY5LCAweDZGLCAweDZFLCAweDJGLFxyXG4gICAgICAgIDB4NjgsIDB4NkMsIDB4NzMsIDB4MkUsXHJcbiAgICAgICAgMHg2QSwgMHg3MywgMHgwMCwgMHgwMCxcclxuICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxyXG4gICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXHJcbiAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gY29tcHJlc3Nvcm5hbWVcclxuICAgICAgICAweDAwLCAweDE4LCAgIC8vIGRlcHRoID0gMjRcclxuICAgICAgICAweDExLCAweDExXSksIC8vIHByZV9kZWZpbmVkID0gLTFcclxuICAgICAgICAgIGF2Y2MsXHJcbiAgICAgICAgICBNUDQuYm94KE1QNC50eXBlcy5idHJ0LCBuZXcgVWludDhBcnJheShbXHJcbiAgICAgICAgICAgIDB4MDAsIDB4MWMsIDB4OWMsIDB4ODAsIC8vIGJ1ZmZlclNpemVEQlxyXG4gICAgICAgICAgICAweDAwLCAweDJkLCAweGM2LCAweGMwLCAvLyBtYXhCaXRyYXRlXHJcbiAgICAgICAgICAgIDB4MDAsIDB4MmQsIDB4YzYsIDB4YzBdKSksIC8vIGF2Z0JpdHJhdGVcclxuICAgICAgICAgIE1QNC5ib3goTVA0LnR5cGVzLnBhc3AsIG5ldyBVaW50OEFycmF5KFtcclxuICAgICAgICAgICAgKGhTcGFjaW5nID4+IDI0KSwgICAgICAgICAvLyBoU3BhY2luZ1xyXG4gICAgICAgICAgICAoaFNwYWNpbmcgPj4gMTYpICYgMHhGRixcclxuICAgICAgICAgICAgKGhTcGFjaW5nID4+ICA4KSAmIDB4RkYsXHJcbiAgICAgICAgICAgIGhTcGFjaW5nICYgMHhGRixcclxuICAgICAgICAgICAgKHZTcGFjaW5nID4+IDI0KSwgICAgICAgICAvLyB2U3BhY2luZ1xyXG4gICAgICAgICAgICAodlNwYWNpbmcgPj4gMTYpICYgMHhGRixcclxuICAgICAgICAgICAgKHZTcGFjaW5nID4+ICA4KSAmIDB4RkYsXHJcbiAgICAgICAgICAgIHZTcGFjaW5nICYgMHhGRl0pKVxyXG4gICAgICAgICAgKTtcclxuICB9XHJcblxyXG4gIHN0YXRpYyBlc2RzKHRyYWNrKSB7XHJcbiAgICB2YXIgY29uZmlnbGVuID0gdHJhY2suY29uZmlnLmxlbmd0aDtcclxuICAgIHJldHVybiBuZXcgVWludDhBcnJheShbXHJcbiAgICAgIDB4MDAsIC8vIHZlcnNpb24gMFxyXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAvLyBmbGFnc1xyXG5cclxuICAgICAgMHgwMywgLy8gZGVzY3JpcHRvcl90eXBlXHJcbiAgICAgIDB4MTcrY29uZmlnbGVuLCAvLyBsZW5ndGhcclxuICAgICAgMHgwMCwgMHgwMSwgLy9lc19pZFxyXG4gICAgICAweDAwLCAvLyBzdHJlYW1fcHJpb3JpdHlcclxuXHJcbiAgICAgIDB4MDQsIC8vIGRlc2NyaXB0b3JfdHlwZVxyXG4gICAgICAweDBmK2NvbmZpZ2xlbiwgLy8gbGVuZ3RoXHJcbiAgICAgIDB4NDAsIC8vY29kZWMgOiBtcGVnNF9hdWRpb1xyXG4gICAgICAweDE1LCAvLyBzdHJlYW1fdHlwZVxyXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAvLyBidWZmZXJfc2l6ZVxyXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyBtYXhCaXRyYXRlXHJcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGF2Z0JpdHJhdGVcclxuXHJcbiAgICAgIDB4MDUgLy8gZGVzY3JpcHRvcl90eXBlXHJcbiAgICAgIF0uY29uY2F0KFtjb25maWdsZW5dKS5jb25jYXQodHJhY2suY29uZmlnKS5jb25jYXQoWzB4MDYsIDB4MDEsIDB4MDJdKSk7IC8vIEdBU3BlY2lmaWNDb25maWcpKTsgLy8gbGVuZ3RoICsgYXVkaW8gY29uZmlnIGRlc2NyaXB0b3JcclxuICB9XHJcblxyXG4gIHN0YXRpYyBtcDRhKHRyYWNrKSB7XHJcbiAgICB2YXIgc2FtcGxlcmF0ZSA9IHRyYWNrLnNhbXBsZXJhdGU7XHJcbiAgICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5tcDRhLCBuZXcgVWludDhBcnJheShbXHJcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXHJcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXHJcbiAgICAgIDB4MDAsIDB4MDEsIC8vIGRhdGFfcmVmZXJlbmNlX2luZGV4XHJcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXHJcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXHJcbiAgICAgIDB4MDAsIHRyYWNrLmNoYW5uZWxDb3VudCwgLy8gY2hhbm5lbGNvdW50XHJcbiAgICAgIDB4MDAsIDB4MTAsIC8vIHNhbXBsZVNpemU6MTZiaXRzXHJcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkMlxyXG4gICAgICAoc2FtcGxlcmF0ZSA+PiA4KSAmIDB4RkYsXHJcbiAgICAgIHNhbXBsZXJhdGUgJiAweGZmLCAvL1xyXG4gICAgICAweDAwLCAweDAwXSksXHJcbiAgICAgIE1QNC5ib3goTVA0LnR5cGVzLmVzZHMsIE1QNC5lc2RzKHRyYWNrKSkpO1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIG1wMyh0cmFjaykge1xyXG4gICAgdmFyIHNhbXBsZXJhdGUgPSB0cmFjay5zYW1wbGVyYXRlO1xyXG4gICAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXNbJy5tcDMnXSwgbmV3IFVpbnQ4QXJyYXkoW1xyXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxyXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxyXG4gICAgICAweDAwLCAweDAxLCAvLyBkYXRhX3JlZmVyZW5jZV9pbmRleFxyXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxyXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxyXG4gICAgICAweDAwLCB0cmFjay5jaGFubmVsQ291bnQsIC8vIGNoYW5uZWxjb3VudFxyXG4gICAgICAweDAwLCAweDEwLCAvLyBzYW1wbGVTaXplOjE2Yml0c1xyXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZDJcclxuICAgICAgKHNhbXBsZXJhdGUgPj4gOCkgJiAweEZGLFxyXG4gICAgICBzYW1wbGVyYXRlICYgMHhmZiwgLy9cclxuICAgICAgMHgwMCwgMHgwMF0pKTtcclxuICB9XHJcblxyXG4gIHN0YXRpYyBzdHNkKHRyYWNrKSB7XHJcbiAgICBpZiAodHJhY2sudHlwZSA9PT0gJ2F1ZGlvJykge1xyXG4gICAgICBpZiAoIXRyYWNrLmlzQUFDICYmIHRyYWNrLmNvZGVjID09PSAnbXAzJykge1xyXG4gICAgICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5zdHNkLCBNUDQuU1RTRCwgTVA0Lm1wMyh0cmFjaykpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5zdHNkLCBNUDQuU1RTRCwgTVA0Lm1wNGEodHJhY2spKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5zdHNkLCBNUDQuU1RTRCwgTVA0LmF2YzEodHJhY2spKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHN0YXRpYyB0a2hkKHRyYWNrKSB7XHJcbiAgICB2YXIgaWQgPSB0cmFjay5pZCxcclxuICAgICAgICBkdXJhdGlvbiA9IHRyYWNrLmR1cmF0aW9uKnRyYWNrLnRpbWVzY2FsZSxcclxuICAgICAgICB3aWR0aCA9IHRyYWNrLndpZHRoLFxyXG4gICAgICAgIGhlaWdodCA9IHRyYWNrLmhlaWdodCxcclxuICAgICAgICB1cHBlcldvcmREdXJhdGlvbiA9IE1hdGguZmxvb3IoZHVyYXRpb24gLyAoVUlOVDMyX01BWCArIDEpKSxcclxuICAgICAgICBsb3dlcldvcmREdXJhdGlvbiA9IE1hdGguZmxvb3IoZHVyYXRpb24gJSAoVUlOVDMyX01BWCArIDEpKTtcclxuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy50a2hkLCBuZXcgVWludDhBcnJheShbXHJcbiAgICAgIDB4MDEsIC8vIHZlcnNpb24gMVxyXG4gICAgICAweDAwLCAweDAwLCAweDA3LCAvLyBmbGFnc1xyXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAyLCAvLyBjcmVhdGlvbl90aW1lXHJcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDMsIC8vIG1vZGlmaWNhdGlvbl90aW1lXHJcbiAgICAgIChpZCA+PiAyNCkgJiAweEZGLFxyXG4gICAgICAoaWQgPj4gMTYpICYgMHhGRixcclxuICAgICAgKGlkID4+IDgpICYgMHhGRixcclxuICAgICAgaWQgJiAweEZGLCAvLyB0cmFja19JRFxyXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxyXG4gICAgICAodXBwZXJXb3JkRHVyYXRpb24gPj4gMjQpLFxyXG4gICAgICAodXBwZXJXb3JkRHVyYXRpb24gPj4gMTYpICYgMHhGRixcclxuICAgICAgKHVwcGVyV29yZER1cmF0aW9uID4+ICA4KSAmIDB4RkYsXHJcbiAgICAgIHVwcGVyV29yZER1cmF0aW9uICYgMHhGRixcclxuICAgICAgKGxvd2VyV29yZER1cmF0aW9uID4+IDI0KSxcclxuICAgICAgKGxvd2VyV29yZER1cmF0aW9uID4+IDE2KSAmIDB4RkYsXHJcbiAgICAgIChsb3dlcldvcmREdXJhdGlvbiA+PiAgOCkgJiAweEZGLFxyXG4gICAgICBsb3dlcldvcmREdXJhdGlvbiAmIDB4RkYsXHJcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXHJcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXHJcbiAgICAgIDB4MDAsIDB4MDAsIC8vIGxheWVyXHJcbiAgICAgIDB4MDAsIDB4MDAsIC8vIGFsdGVybmF0ZV9ncm91cFxyXG4gICAgICAweDAwLCAweDAwLCAvLyBub24tYXVkaW8gdHJhY2sgdm9sdW1lXHJcbiAgICAgIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXHJcbiAgICAgIDB4MDAsIDB4MDEsIDB4MDAsIDB4MDAsXHJcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXHJcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXHJcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXHJcbiAgICAgIDB4MDAsIDB4MDEsIDB4MDAsIDB4MDAsXHJcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXHJcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXHJcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXHJcbiAgICAgIDB4NDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHRyYW5zZm9ybWF0aW9uOiB1bml0eSBtYXRyaXhcclxuICAgICAgKHdpZHRoID4+IDgpICYgMHhGRixcclxuICAgICAgd2lkdGggJiAweEZGLFxyXG4gICAgICAweDAwLCAweDAwLCAvLyB3aWR0aFxyXG4gICAgICAoaGVpZ2h0ID4+IDgpICYgMHhGRixcclxuICAgICAgaGVpZ2h0ICYgMHhGRixcclxuICAgICAgMHgwMCwgMHgwMCAvLyBoZWlnaHRcclxuICAgIF0pKTtcclxuICB9XHJcblxyXG4gIHN0YXRpYyB0cmFmKHRyYWNrLGJhc2VNZWRpYURlY29kZVRpbWUpIHtcclxuICAgIHZhciBzYW1wbGVEZXBlbmRlbmN5VGFibGUgPSBNUDQuc2R0cCh0cmFjayksXHJcbiAgICAgICAgaWQgPSB0cmFjay5pZCxcclxuICAgICAgICB1cHBlcldvcmRCYXNlTWVkaWFEZWNvZGVUaW1lID0gTWF0aC5mbG9vcihiYXNlTWVkaWFEZWNvZGVUaW1lIC8gKFVJTlQzMl9NQVggKyAxKSksXHJcbiAgICAgICAgbG93ZXJXb3JkQmFzZU1lZGlhRGVjb2RlVGltZSA9IE1hdGguZmxvb3IoYmFzZU1lZGlhRGVjb2RlVGltZSAlIChVSU5UMzJfTUFYICsgMSkpO1xyXG4gICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLnRyYWYsXHJcbiAgICAgICAgICAgICAgIE1QNC5ib3goTVA0LnR5cGVzLnRmaGQsIG5ldyBVaW50OEFycmF5KFtcclxuICAgICAgICAgICAgICAgICAweDAwLCAvLyB2ZXJzaW9uIDBcclxuICAgICAgICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLCAvLyBmbGFnc1xyXG4gICAgICAgICAgICAgICAgIChpZCA+PiAyNCksXHJcbiAgICAgICAgICAgICAgICAgKGlkID4+IDE2KSAmIDBYRkYsXHJcbiAgICAgICAgICAgICAgICAgKGlkID4+IDgpICYgMFhGRixcclxuICAgICAgICAgICAgICAgICAoaWQgJiAweEZGKSAvLyB0cmFja19JRFxyXG4gICAgICAgICAgICAgICBdKSksXHJcbiAgICAgICAgICAgICAgIE1QNC5ib3goTVA0LnR5cGVzLnRmZHQsIG5ldyBVaW50OEFycmF5KFtcclxuICAgICAgICAgICAgICAgICAweDAxLCAvLyB2ZXJzaW9uIDFcclxuICAgICAgICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLCAvLyBmbGFnc1xyXG4gICAgICAgICAgICAgICAgICh1cHBlcldvcmRCYXNlTWVkaWFEZWNvZGVUaW1lID4+MjQpLFxyXG4gICAgICAgICAgICAgICAgICh1cHBlcldvcmRCYXNlTWVkaWFEZWNvZGVUaW1lID4+IDE2KSAmIDBYRkYsXHJcbiAgICAgICAgICAgICAgICAgKHVwcGVyV29yZEJhc2VNZWRpYURlY29kZVRpbWUgPj4gOCkgJiAwWEZGLFxyXG4gICAgICAgICAgICAgICAgICh1cHBlcldvcmRCYXNlTWVkaWFEZWNvZGVUaW1lICYgMHhGRiksXHJcbiAgICAgICAgICAgICAgICAgKGxvd2VyV29yZEJhc2VNZWRpYURlY29kZVRpbWUgPj4yNCksXHJcbiAgICAgICAgICAgICAgICAgKGxvd2VyV29yZEJhc2VNZWRpYURlY29kZVRpbWUgPj4gMTYpICYgMFhGRixcclxuICAgICAgICAgICAgICAgICAobG93ZXJXb3JkQmFzZU1lZGlhRGVjb2RlVGltZSA+PiA4KSAmIDBYRkYsXHJcbiAgICAgICAgICAgICAgICAgKGxvd2VyV29yZEJhc2VNZWRpYURlY29kZVRpbWUgJiAweEZGKVxyXG4gICAgICAgICAgICAgICBdKSksXHJcbiAgICAgICAgICAgICAgIE1QNC50cnVuKHRyYWNrLFxyXG4gICAgICAgICAgICAgICAgICAgIHNhbXBsZURlcGVuZGVuY3lUYWJsZS5sZW5ndGggK1xyXG4gICAgICAgICAgICAgICAgICAgIDE2ICsgLy8gdGZoZFxyXG4gICAgICAgICAgICAgICAgICAgIDIwICsgLy8gdGZkdFxyXG4gICAgICAgICAgICAgICAgICAgIDggKyAgLy8gdHJhZiBoZWFkZXJcclxuICAgICAgICAgICAgICAgICAgICAxNiArIC8vIG1maGRcclxuICAgICAgICAgICAgICAgICAgICA4ICsgIC8vIG1vb2YgaGVhZGVyXHJcbiAgICAgICAgICAgICAgICAgICAgOCksICAvLyBtZGF0IGhlYWRlclxyXG4gICAgICAgICAgICAgICBzYW1wbGVEZXBlbmRlbmN5VGFibGUpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2VuZXJhdGUgYSB0cmFjayBib3guXHJcbiAgICogQHBhcmFtIHRyYWNrIHtvYmplY3R9IGEgdHJhY2sgZGVmaW5pdGlvblxyXG4gICAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9IHRoZSB0cmFjayBib3hcclxuICAgKi9cclxuICBzdGF0aWMgdHJhayh0cmFjaykge1xyXG4gICAgdHJhY2suZHVyYXRpb24gPSB0cmFjay5kdXJhdGlvbiB8fCAweGZmZmZmZmZmO1xyXG4gICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLnRyYWssIE1QNC50a2hkKHRyYWNrKSwgTVA0Lm1kaWEodHJhY2spKTtcclxuICB9XHJcblxyXG4gIHN0YXRpYyB0cmV4KHRyYWNrKSB7XHJcbiAgICB2YXIgaWQgPSB0cmFjay5pZDtcclxuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy50cmV4LCBuZXcgVWludDhBcnJheShbXHJcbiAgICAgIDB4MDAsIC8vIHZlcnNpb24gMFxyXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAvLyBmbGFnc1xyXG4gICAgIChpZCA+PiAyNCksXHJcbiAgICAgKGlkID4+IDE2KSAmIDBYRkYsXHJcbiAgICAgKGlkID4+IDgpICYgMFhGRixcclxuICAgICAoaWQgJiAweEZGKSwgLy8gdHJhY2tfSURcclxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMSwgLy8gZGVmYXVsdF9zYW1wbGVfZGVzY3JpcHRpb25faW5kZXhcclxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gZGVmYXVsdF9zYW1wbGVfZHVyYXRpb25cclxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gZGVmYXVsdF9zYW1wbGVfc2l6ZVxyXG4gICAgICAweDAwLCAweDAxLCAweDAwLCAweDAxIC8vIGRlZmF1bHRfc2FtcGxlX2ZsYWdzXHJcbiAgICBdKSk7XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgdHJ1bih0cmFjaywgb2Zmc2V0KSB7XHJcbiAgICB2YXIgc2FtcGxlcz0gdHJhY2suc2FtcGxlcyB8fCBbXSxcclxuICAgICAgICBsZW4gPSBzYW1wbGVzLmxlbmd0aCxcclxuICAgICAgICBhcnJheWxlbiA9IDEyICsgKDE2ICogbGVuKSxcclxuICAgICAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5bGVuKSxcclxuICAgICAgICBpLHNhbXBsZSxkdXJhdGlvbixzaXplLGZsYWdzLGN0cztcclxuICAgIG9mZnNldCArPSA4ICsgYXJyYXlsZW47XHJcbiAgICBhcnJheS5zZXQoW1xyXG4gICAgICAweDAwLCAvLyB2ZXJzaW9uIDBcclxuICAgICAgMHgwMCwgMHgwZiwgMHgwMSwgLy8gZmxhZ3NcclxuICAgICAgKGxlbiA+Pj4gMjQpICYgMHhGRixcclxuICAgICAgKGxlbiA+Pj4gMTYpICYgMHhGRixcclxuICAgICAgKGxlbiA+Pj4gOCkgJiAweEZGLFxyXG4gICAgICBsZW4gJiAweEZGLCAvLyBzYW1wbGVfY291bnRcclxuICAgICAgKG9mZnNldCA+Pj4gMjQpICYgMHhGRixcclxuICAgICAgKG9mZnNldCA+Pj4gMTYpICYgMHhGRixcclxuICAgICAgKG9mZnNldCA+Pj4gOCkgJiAweEZGLFxyXG4gICAgICBvZmZzZXQgJiAweEZGIC8vIGRhdGFfb2Zmc2V0XHJcbiAgICBdLDApO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgIHNhbXBsZSA9IHNhbXBsZXNbaV07XHJcbiAgICAgIGR1cmF0aW9uID0gc2FtcGxlLmR1cmF0aW9uO1xyXG4gICAgICBzaXplID0gc2FtcGxlLnNpemU7XHJcbiAgICAgIGZsYWdzID0gc2FtcGxlLmZsYWdzO1xyXG4gICAgICBjdHMgPSBzYW1wbGUuY3RzO1xyXG4gICAgICBhcnJheS5zZXQoW1xyXG4gICAgICAgIChkdXJhdGlvbiA+Pj4gMjQpICYgMHhGRixcclxuICAgICAgICAoZHVyYXRpb24gPj4+IDE2KSAmIDB4RkYsXHJcbiAgICAgICAgKGR1cmF0aW9uID4+PiA4KSAmIDB4RkYsXHJcbiAgICAgICAgZHVyYXRpb24gJiAweEZGLCAvLyBzYW1wbGVfZHVyYXRpb25cclxuICAgICAgICAoc2l6ZSA+Pj4gMjQpICYgMHhGRixcclxuICAgICAgICAoc2l6ZSA+Pj4gMTYpICYgMHhGRixcclxuICAgICAgICAoc2l6ZSA+Pj4gOCkgJiAweEZGLFxyXG4gICAgICAgIHNpemUgJiAweEZGLCAvLyBzYW1wbGVfc2l6ZVxyXG4gICAgICAgIChmbGFncy5pc0xlYWRpbmcgPDwgMikgfCBmbGFncy5kZXBlbmRzT24sXHJcbiAgICAgICAgKGZsYWdzLmlzRGVwZW5kZWRPbiA8PCA2KSB8XHJcbiAgICAgICAgICAoZmxhZ3MuaGFzUmVkdW5kYW5jeSA8PCA0KSB8XHJcbiAgICAgICAgICAoZmxhZ3MucGFkZGluZ1ZhbHVlIDw8IDEpIHxcclxuICAgICAgICAgIGZsYWdzLmlzTm9uU3luYyxcclxuICAgICAgICBmbGFncy5kZWdyYWRQcmlvICYgMHhGMCA8PCA4LFxyXG4gICAgICAgIGZsYWdzLmRlZ3JhZFByaW8gJiAweDBGLCAvLyBzYW1wbGVfZmxhZ3NcclxuICAgICAgICAoY3RzID4+PiAyNCkgJiAweEZGLFxyXG4gICAgICAgIChjdHMgPj4+IDE2KSAmIDB4RkYsXHJcbiAgICAgICAgKGN0cyA+Pj4gOCkgJiAweEZGLFxyXG4gICAgICAgIGN0cyAmIDB4RkYgLy8gc2FtcGxlX2NvbXBvc2l0aW9uX3RpbWVfb2Zmc2V0XHJcbiAgICAgIF0sMTIrMTYqaSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMudHJ1biwgYXJyYXkpO1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIGluaXRTZWdtZW50KHRyYWNrcykge1xyXG4gICAgaWYgKCFNUDQudHlwZXMpIHtcclxuICAgICAgTVA0LmluaXQoKTtcclxuICAgIH1cclxuICAgIHZhciBtb3ZpZSA9IE1QNC5tb292KHRyYWNrcyksIHJlc3VsdDtcclxuICAgIHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KE1QNC5GVFlQLmJ5dGVMZW5ndGggKyBtb3ZpZS5ieXRlTGVuZ3RoKTtcclxuICAgIHJlc3VsdC5zZXQoTVA0LkZUWVApO1xyXG4gICAgcmVzdWx0LnNldChtb3ZpZSwgTVA0LkZUWVAuYnl0ZUxlbmd0aCk7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgTVA0O1xyXG4iLCIgLyoqXHJcbiAqIGZNUDQgcmVtdXhlclxyXG4qL1xyXG5cclxuXHJcbmltcG9ydCBBQUMgZnJvbSAnLi4vaGVscGVyL2FhYyc7XHJcbmltcG9ydCBFdmVudCBmcm9tICcuLi9ldmVudHMnO1xyXG5pbXBvcnQge2xvZ2dlcn0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcclxuaW1wb3J0IE1QNCBmcm9tICcuLi9yZW11eC9tcDQtZ2VuZXJhdG9yJztcclxuaW1wb3J0IHtFcnJvclR5cGVzLCBFcnJvckRldGFpbHN9IGZyb20gJy4uL2Vycm9ycyc7XHJcblxyXG4vLyAxMCBzZWNvbmRzXHJcbmNvbnN0IE1BWF9TSUxFTlRfRlJBTUVfRFVSQVRJT04gPSAxMCAqIDEwMDA7XHJcblxyXG5jbGFzcyBNUDRSZW11eGVyIHtcclxuICBjb25zdHJ1Y3RvcihvYnNlcnZlciwgY29uZmlnLCB0eXBlU3VwcG9ydGVkLCB2ZW5kb3IpIHtcclxuICAgIHRoaXMub2JzZXJ2ZXIgPSBvYnNlcnZlcjtcclxuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xyXG4gICAgdGhpcy50eXBlU3VwcG9ydGVkID0gdHlwZVN1cHBvcnRlZDtcclxuICAgIGNvbnN0IHVzZXJBZ2VudCA9IG5hdmlnYXRvci51c2VyQWdlbnQ7XHJcbiAgICB0aGlzLmlzU2FmYXJpID0gdmVuZG9yICYmIHZlbmRvci5pbmRleE9mKCdBcHBsZScpID4gLTEgJiYgdXNlckFnZW50ICYmICF1c2VyQWdlbnQubWF0Y2goJ0NyaU9TJyk7XHJcbiAgICB0aGlzLklTR2VuZXJhdGVkID0gZmFsc2U7XHJcbiAgfVxyXG5cclxuICBkZXN0cm95KCkge1xyXG4gIH1cclxuXHJcbiAgcmVzZXRUaW1lU3RhbXAoZGVmYXVsdFRpbWVTdGFtcCkge1xyXG4gICAgdGhpcy5faW5pdFBUUyA9IHRoaXMuX2luaXREVFMgPSBkZWZhdWx0VGltZVN0YW1wO1xyXG4gIH1cclxuXHJcbiAgcmVzZXRJbml0U2VnbWVudCgpIHtcclxuICAgIHRoaXMuSVNHZW5lcmF0ZWQgPSBmYWxzZTtcclxuICB9XHJcblxyXG4gIHJlbXV4KGF1ZGlvVHJhY2ssdmlkZW9UcmFjayxpZDNUcmFjayx0ZXh0VHJhY2ssdGltZU9mZnNldCwgY29udGlndW91cyxhY2N1cmF0ZVRpbWVPZmZzZXQpIHtcclxuICAgIC8vIGdlbmVyYXRlIEluaXQgU2VnbWVudCBpZiBuZWVkZWRcclxuICAgIGlmICghdGhpcy5JU0dlbmVyYXRlZCkge1xyXG4gICAgICB0aGlzLmdlbmVyYXRlSVMoYXVkaW9UcmFjayx2aWRlb1RyYWNrLHRpbWVPZmZzZXQpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaWYgKGFjY3VyYXRlVGltZU9mZnNldCkge1xyXG4gICAgICAgIC8vIGNoZWNrIHRpbWVzdGFtcCBjb25zaXN0ZW5jeS4gaXQgdGhlcmUgaXMgbW9yZSB0aGFuIDEwcyBnYXAgYmV0d2VlbiBleHBlY3RlZCBQVFMvRFRTLCByZWNvbXB1dGUgaW5pdFBUUy9EVFNcclxuICAgICAgICBjb25zdCByZWZQVFMgPSB0aGlzLl9pbml0UFRTO1xyXG4gICAgICAgIGNvbnN0IHB0c05vcm1hbGl6ZSA9IHRoaXMuX1BUU05vcm1hbGl6ZTtcclxuICAgICAgICBjb25zdCB0aW1lU2NhbGUgPSBhdWRpb1RyYWNrLmlucHV0VGltZVNjYWxlIHx8IHZpZGVvVHJhY2suaW5wdXRUaW1lU2NhbGU7XHJcbiAgICAgICAgbGV0IGluaXRQVFMgPSBJbmZpbml0eSwgaW5pdERUUyA9IEluZmluaXR5O1xyXG4gICAgICAgIGxldCBzYW1wbGVzID0gYXVkaW9UcmFjay5zYW1wbGVzO1xyXG4gICAgICAgIGlmIChzYW1wbGVzLmxlbmd0aCkge1xyXG4gICAgICAgICAgIGluaXRQVFMgPSBpbml0RFRTID0gcHRzTm9ybWFsaXplKHNhbXBsZXNbMF0ucHRzIC0gdGltZVNjYWxlICogdGltZU9mZnNldCwgcmVmUFRTKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc2FtcGxlcyA9IHZpZGVvVHJhY2suc2FtcGxlcztcclxuICAgICAgICBpZiAoc2FtcGxlcy5sZW5ndGgpIHtcclxuICAgICAgICAgIGxldCBzYW1wbGUgPSBzYW1wbGVzWzBdO1xyXG4gICAgICAgICAgIGluaXRQVFMgPSBNYXRoLm1pbihpbml0UFRTLHB0c05vcm1hbGl6ZShzYW1wbGUucHRzIC0gdGltZVNjYWxlICogdGltZU9mZnNldCwgcmVmUFRTKSk7XHJcbiAgICAgICAgICAgaW5pdERUUyA9IE1hdGgubWluKGluaXREVFMscHRzTm9ybWFsaXplKHNhbXBsZS5kdHMgLSB0aW1lU2NhbGUgKiB0aW1lT2Zmc2V0LCByZWZQVFMpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGluaXRQVFMgIT09IEluZmluaXR5KSB7XHJcbiAgICAgICAgICBjb25zdCBpbml0UFRTRGVsdGEgPSByZWZQVFMgLSBpbml0UFRTO1xyXG4gICAgICAgICAgaWYgKE1hdGguYWJzKGluaXRQVFNEZWx0YSkgPiAxMCAqIHRpbWVTY2FsZSkge1xyXG4gICAgICAgICAgICBsb2dnZXIud2FybihgdGltZXN0YW1wIGluY29uc2lzdGVuY3ksICR7KGluaXRQVFNEZWx0YS90aW1lU2NhbGUpLnRvRml4ZWQoMyl9cyBkZWx0YSBhZ2FpbnN0IGV4cGVjdGVkIHZhbHVlOiBtaXNzaW5nIGRpc2NvbnRpbnVpdHkgPyByZXNldCBpbml0UFRTL2luaXREVFNgKTtcclxuICAgICAgICAgICAgdGhpcy5faW5pdFBUUyA9IGluaXRQVFM7XHJcbiAgICAgICAgICAgIHRoaXMuX2luaXREVFMgPSBpbml0RFRTO1xyXG4gICAgICAgICAgICB0aGlzLm9ic2VydmVyLnRyaWdnZXIoRXZlbnQuSU5JVF9QVFNfRk9VTkQsIHsgaW5pdFBUUzogaW5pdFBUU30pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLklTR2VuZXJhdGVkKSB7XHJcbiAgICAgIC8vIFB1cnBvc2VmdWxseSByZW11eGluZyBhdWRpbyBiZWZvcmUgdmlkZW8sIHNvIHRoYXQgcmVtdXhWaWRlbyBjYW4gdXNlIG5leHRBdWRpb1B0cywgd2hpY2ggaXNcclxuICAgICAgLy8gY2FsY3VsYXRlZCBpbiByZW11eEF1ZGlvLlxyXG4gICAgICAvL2xvZ2dlci5sb2coJ25iIEFBQyBzYW1wbGVzOicgKyBhdWRpb1RyYWNrLnNhbXBsZXMubGVuZ3RoKTtcclxuICAgICAgaWYgKGF1ZGlvVHJhY2suc2FtcGxlcy5sZW5ndGgpIHtcclxuICAgICAgICAvLyBpZiBpbml0U2VnbWVudCB3YXMgZ2VuZXJhdGVkIHdpdGhvdXQgdmlkZW8gc2FtcGxlcywgcmVnZW5lcmF0ZSBpdCBhZ2FpblxyXG4gICAgICAgIGlmICghYXVkaW9UcmFjay50aW1lc2NhbGUpIHtcclxuICAgICAgICAgIGxvZ2dlci53YXJuKCdyZWdlbmVyYXRlIEluaXRTZWdtZW50IGFzIGF1ZGlvIGRldGVjdGVkJyk7XHJcbiAgICAgICAgICB0aGlzLmdlbmVyYXRlSVMoYXVkaW9UcmFjayx2aWRlb1RyYWNrLHRpbWVPZmZzZXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgYXVkaW9EYXRhID0gdGhpcy5yZW11eEF1ZGlvKGF1ZGlvVHJhY2ssdGltZU9mZnNldCxjb250aWd1b3VzLGFjY3VyYXRlVGltZU9mZnNldCk7XHJcbiAgICAgICAgLy9sb2dnZXIubG9nKCduYiBBVkMgc2FtcGxlczonICsgdmlkZW9UcmFjay5zYW1wbGVzLmxlbmd0aCk7XHJcbiAgICAgICAgaWYgKHZpZGVvVHJhY2suc2FtcGxlcy5sZW5ndGgpIHtcclxuICAgICAgICAgIGxldCBhdWRpb1RyYWNrTGVuZ3RoO1xyXG4gICAgICAgICAgaWYgKGF1ZGlvRGF0YSkge1xyXG4gICAgICAgICAgICBhdWRpb1RyYWNrTGVuZ3RoID0gYXVkaW9EYXRhLmVuZFBUUyAtIGF1ZGlvRGF0YS5zdGFydFBUUztcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIC8vIGlmIGluaXRTZWdtZW50IHdhcyBnZW5lcmF0ZWQgd2l0aG91dCB2aWRlbyBzYW1wbGVzLCByZWdlbmVyYXRlIGl0IGFnYWluXHJcbiAgICAgICAgICBpZiAoIXZpZGVvVHJhY2sudGltZXNjYWxlKSB7XHJcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKCdyZWdlbmVyYXRlIEluaXRTZWdtZW50IGFzIHZpZGVvIGRldGVjdGVkJyk7XHJcbiAgICAgICAgICAgIHRoaXMuZ2VuZXJhdGVJUyhhdWRpb1RyYWNrLHZpZGVvVHJhY2ssdGltZU9mZnNldCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICB0aGlzLnJlbXV4VmlkZW8odmlkZW9UcmFjayx0aW1lT2Zmc2V0LGNvbnRpZ3VvdXMsYXVkaW9UcmFja0xlbmd0aCwgYWNjdXJhdGVUaW1lT2Zmc2V0KTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbGV0IHZpZGVvRGF0YTtcclxuICAgICAgICAvL2xvZ2dlci5sb2coJ25iIEFWQyBzYW1wbGVzOicgKyB2aWRlb1RyYWNrLnNhbXBsZXMubGVuZ3RoKTtcclxuICAgICAgICBpZiAodmlkZW9UcmFjay5zYW1wbGVzLmxlbmd0aCkge1xyXG4gICAgICAgICAgdmlkZW9EYXRhID0gdGhpcy5yZW11eFZpZGVvKHZpZGVvVHJhY2ssdGltZU9mZnNldCxjb250aWd1b3VzLCBhY2N1cmF0ZVRpbWVPZmZzZXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodmlkZW9EYXRhICYmIGF1ZGlvVHJhY2suY29kZWMpIHtcclxuICAgICAgICAgIHRoaXMucmVtdXhFbXB0eUF1ZGlvKGF1ZGlvVHJhY2ssIHRpbWVPZmZzZXQsIGNvbnRpZ3VvdXMsIHZpZGVvRGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICAvL2xvZ2dlci5sb2coJ25iIElEMyBzYW1wbGVzOicgKyBhdWRpb1RyYWNrLnNhbXBsZXMubGVuZ3RoKTtcclxuICAgIGlmIChpZDNUcmFjay5zYW1wbGVzLmxlbmd0aCkge1xyXG4gICAgICB0aGlzLnJlbXV4SUQzKGlkM1RyYWNrLHRpbWVPZmZzZXQpO1xyXG4gICAgfVxyXG4gICAgLy9sb2dnZXIubG9nKCduYiBJRDMgc2FtcGxlczonICsgYXVkaW9UcmFjay5zYW1wbGVzLmxlbmd0aCk7XHJcbiAgICBpZiAodGV4dFRyYWNrLnNhbXBsZXMubGVuZ3RoKSB7XHJcbiAgICAgIHRoaXMucmVtdXhUZXh0KHRleHRUcmFjayx0aW1lT2Zmc2V0KTtcclxuICAgIH1cclxuICAgIC8vbm90aWZ5IGVuZCBvZiBwYXJzaW5nXHJcbiAgICB0aGlzLm9ic2VydmVyLnRyaWdnZXIoRXZlbnQuRlJBR19QQVJTRUQpO1xyXG4gIH1cclxuXHJcbiAgZ2VuZXJhdGVJUyhhdWRpb1RyYWNrLHZpZGVvVHJhY2ssdGltZU9mZnNldCkge1xyXG4gICAgdmFyIG9ic2VydmVyID0gdGhpcy5vYnNlcnZlcixcclxuICAgICAgICBhdWRpb1NhbXBsZXMgPSBhdWRpb1RyYWNrLnNhbXBsZXMsXHJcbiAgICAgICAgdmlkZW9TYW1wbGVzID0gdmlkZW9UcmFjay5zYW1wbGVzLFxyXG4gICAgICAgIHR5cGVTdXBwb3J0ZWQgPSB0aGlzLnR5cGVTdXBwb3J0ZWQsXHJcbiAgICAgICAgY29udGFpbmVyID0gJ2F1ZGlvL21wNCcsXHJcbiAgICAgICAgdHJhY2tzID0ge30sXHJcbiAgICAgICAgZGF0YSA9IHsgdHJhY2tzIDogdHJhY2tzIH0sXHJcbiAgICAgICAgY29tcHV0ZVBUU0RUUyA9ICh0aGlzLl9pbml0UFRTID09PSB1bmRlZmluZWQpLFxyXG4gICAgICAgIGluaXRQVFMsIGluaXREVFM7XHJcblxyXG4gICAgaWYgKGNvbXB1dGVQVFNEVFMpIHtcclxuICAgICAgaW5pdFBUUyA9IGluaXREVFMgPSBJbmZpbml0eTtcclxuICAgIH1cclxuICAgIGlmIChhdWRpb1RyYWNrLmNvbmZpZyAmJiBhdWRpb1NhbXBsZXMubGVuZ3RoKSB7XHJcbiAgICAgIC8vIGxldCdzIHVzZSBhdWRpbyBzYW1wbGluZyByYXRlIGFzIE1QNCB0aW1lIHNjYWxlLlxyXG4gICAgICAvLyByYXRpb25hbGUgaXMgdGhhdCB0aGVyZSBpcyBhIGludGVnZXIgbmIgb2YgYXVkaW8gZnJhbWVzIHBlciBhdWRpbyBzYW1wbGUgKDEwMjQgZm9yIEFBQylcclxuICAgICAgLy8gdXNpbmcgYXVkaW8gc2FtcGxpbmcgcmF0ZSBoZXJlIGhlbHBzIGhhdmluZyBhbiBpbnRlZ2VyIE1QNCBmcmFtZSBkdXJhdGlvblxyXG4gICAgICAvLyB0aGlzIGF2b2lkcyBwb3RlbnRpYWwgcm91bmRpbmcgaXNzdWUgYW5kIEFWIHN5bmMgaXNzdWVcclxuICAgICAgYXVkaW9UcmFjay50aW1lc2NhbGUgPSBhdWRpb1RyYWNrLnNhbXBsZXJhdGU7XHJcbiAgICAgIGxvZ2dlci5sb2cgKGBhdWRpbyBzYW1wbGluZyByYXRlIDogJHthdWRpb1RyYWNrLnNhbXBsZXJhdGV9YCk7XHJcbiAgICAgIGlmICghYXVkaW9UcmFjay5pc0FBQykge1xyXG4gICAgICAgIGlmICh0eXBlU3VwcG9ydGVkLm1wZWcpIHsgLy8gQ2hyb21lIGFuZCBTYWZhcmlcclxuICAgICAgICAgIGNvbnRhaW5lciA9ICdhdWRpby9tcGVnJztcclxuICAgICAgICAgIGF1ZGlvVHJhY2suY29kZWMgPSAnJztcclxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVTdXBwb3J0ZWQubXAzKSB7IC8vIEZpcmVmb3hcclxuICAgICAgICAgIGF1ZGlvVHJhY2suY29kZWMgPSAnbXAzJztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgdHJhY2tzLmF1ZGlvID0ge1xyXG4gICAgICAgIGNvbnRhaW5lciA6IGNvbnRhaW5lcixcclxuICAgICAgICBjb2RlYyA6ICBhdWRpb1RyYWNrLmNvZGVjLFxyXG4gICAgICAgIGluaXRTZWdtZW50IDogIWF1ZGlvVHJhY2suaXNBQUMgJiYgdHlwZVN1cHBvcnRlZC5tcGVnID8gbmV3IFVpbnQ4QXJyYXkoKSA6IE1QNC5pbml0U2VnbWVudChbYXVkaW9UcmFja10pLFxyXG4gICAgICAgIG1ldGFkYXRhIDoge1xyXG4gICAgICAgICAgY2hhbm5lbENvdW50IDogYXVkaW9UcmFjay5jaGFubmVsQ291bnRcclxuICAgICAgICB9XHJcbiAgICAgIH07XHJcbiAgICAgIGlmIChjb21wdXRlUFRTRFRTKSB7XHJcbiAgICAgICAgLy8gcmVtZW1iZXIgZmlyc3QgUFRTIG9mIHRoaXMgZGVtdXhpbmcgY29udGV4dC4gZm9yIGF1ZGlvLCBQVFMgPSBEVFNcclxuICAgICAgICBpbml0UFRTID0gaW5pdERUUyA9IGF1ZGlvU2FtcGxlc1swXS5wdHMgLSBhdWRpb1RyYWNrLmlucHV0VGltZVNjYWxlICogdGltZU9mZnNldDtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmICh2aWRlb1RyYWNrLnNwcyAmJiB2aWRlb1RyYWNrLnBwcyAmJiB2aWRlb1NhbXBsZXMubGVuZ3RoKSB7XHJcbiAgICAgIC8vIGxldCdzIHVzZSBpbnB1dCB0aW1lIHNjYWxlIGFzIE1QNCB2aWRlbyB0aW1lc2NhbGVcclxuICAgICAgLy8gd2UgdXNlIGlucHV0IHRpbWUgc2NhbGUgc3RyYWlnaHQgYXdheSB0byBhdm9pZCByb3VuZGluZyBpc3N1ZXMgb24gZnJhbWUgZHVyYXRpb24gLyBjdHMgY29tcHV0YXRpb25cclxuICAgICAgY29uc3QgaW5wdXRUaW1lU2NhbGUgPSB2aWRlb1RyYWNrLmlucHV0VGltZVNjYWxlO1xyXG4gICAgICB2aWRlb1RyYWNrLnRpbWVzY2FsZSA9IGlucHV0VGltZVNjYWxlO1xyXG4gICAgICB0cmFja3MudmlkZW8gPSB7XHJcbiAgICAgICAgY29udGFpbmVyIDogJ3ZpZGVvL21wNCcsXHJcbiAgICAgICAgY29kZWMgOiAgdmlkZW9UcmFjay5jb2RlYyxcclxuICAgICAgICBpbml0U2VnbWVudCA6IE1QNC5pbml0U2VnbWVudChbdmlkZW9UcmFja10pLFxyXG4gICAgICAgIG1ldGFkYXRhIDoge1xyXG4gICAgICAgICAgd2lkdGggOiB2aWRlb1RyYWNrLndpZHRoLFxyXG4gICAgICAgICAgaGVpZ2h0IDogdmlkZW9UcmFjay5oZWlnaHRcclxuICAgICAgICB9XHJcbiAgICAgIH07XHJcbiAgICAgIGlmIChjb21wdXRlUFRTRFRTKSB7XHJcbiAgICAgICAgaW5pdFBUUyA9IE1hdGgubWluKGluaXRQVFMsdmlkZW9TYW1wbGVzWzBdLnB0cyAtIGlucHV0VGltZVNjYWxlICogdGltZU9mZnNldCk7XHJcbiAgICAgICAgaW5pdERUUyA9IE1hdGgubWluKGluaXREVFMsdmlkZW9TYW1wbGVzWzBdLmR0cyAtIGlucHV0VGltZVNjYWxlICogdGltZU9mZnNldCk7XHJcbiAgICAgICAgdGhpcy5vYnNlcnZlci50cmlnZ2VyKEV2ZW50LklOSVRfUFRTX0ZPVU5ELCB7IGluaXRQVFM6IGluaXRQVFN9KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmKE9iamVjdC5rZXlzKHRyYWNrcykubGVuZ3RoKSB7XHJcbiAgICAgIG9ic2VydmVyLnRyaWdnZXIoRXZlbnQuRlJBR19QQVJTSU5HX0lOSVRfU0VHTUVOVCxkYXRhKTtcclxuICAgICAgdGhpcy5JU0dlbmVyYXRlZCA9IHRydWU7XHJcbiAgICAgIGlmIChjb21wdXRlUFRTRFRTKSB7XHJcbiAgICAgICAgdGhpcy5faW5pdFBUUyA9IGluaXRQVFM7XHJcbiAgICAgICAgdGhpcy5faW5pdERUUyA9IGluaXREVFM7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIG9ic2VydmVyLnRyaWdnZXIoRXZlbnQuRVJST1IsIHt0eXBlIDogRXJyb3JUeXBlcy5NRURJQV9FUlJPUiwgZGV0YWlsczogRXJyb3JEZXRhaWxzLkZSQUdfUEFSU0lOR19FUlJPUiwgZmF0YWw6IGZhbHNlLCByZWFzb246ICdubyBhdWRpby92aWRlbyBzYW1wbGVzIGZvdW5kJ30pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmVtdXhWaWRlbyh0cmFjaywgdGltZU9mZnNldCwgY29udGlndW91cywgYXVkaW9UcmFja0xlbmd0aCwgYWNjdXJhdGVUaW1lT2Zmc2V0KSB7XHJcbiAgICB2YXIgb2Zmc2V0ID0gOCxcclxuICAgICAgICB0aW1lU2NhbGUgPSB0cmFjay50aW1lc2NhbGUsXHJcbiAgICAgICAgbXA0U2FtcGxlRHVyYXRpb24sXHJcbiAgICAgICAgbWRhdCwgbW9vZixcclxuICAgICAgICBmaXJzdFBUUywgZmlyc3REVFMsXHJcbiAgICAgICAgbmV4dERUUyxcclxuICAgICAgICBsYXN0UFRTLCBsYXN0RFRTLFxyXG4gICAgICAgIGlucHV0U2FtcGxlcyA9IHRyYWNrLnNhbXBsZXMsXHJcbiAgICAgICAgb3V0cHV0U2FtcGxlcyA9IFtdLFxyXG4gICAgICAgIG5iU2FtcGxlcyA9IGlucHV0U2FtcGxlcy5sZW5ndGgsXHJcbiAgICAgICAgcHRzTm9ybWFsaXplID0gdGhpcy5fUFRTTm9ybWFsaXplLFxyXG4gICAgICAgIGluaXREVFMgPSB0aGlzLl9pbml0RFRTO1xyXG5cclxuICAvLyBmb3IgKGxldCBpID0gMDsgaSA8IHRyYWNrLnNhbXBsZXMubGVuZ3RoOyBpKyspIHtcclxuICAvLyAgIGxldCBhdmNTYW1wbGUgPSB0cmFjay5zYW1wbGVzW2ldO1xyXG4gIC8vICAgbGV0IHVuaXRzID0gYXZjU2FtcGxlLnVuaXRzO1xyXG4gIC8vICAgbGV0IHVuaXRzU3RyaW5nID0gJyc7XHJcbiAgLy8gICBmb3IgKGxldCBqID0gMDsgaiA8IHVuaXRzLmxlbmd0aCA7IGorKykge1xyXG4gIC8vICAgICB1bml0c1N0cmluZyArPSB1bml0c1tqXS50eXBlICsgJywnO1xyXG4gIC8vICAgICBpZiAodW5pdHNbal0uZGF0YS5sZW5ndGggPCA1MDApIHtcclxuICAvLyAgICAgICB1bml0c1N0cmluZyArPSBIZXguaGV4RHVtcCh1bml0c1tqXS5kYXRhKTtcclxuICAvLyAgICAgfVxyXG4gIC8vICAgfVxyXG4gIC8vICAgbG9nZ2VyLmxvZyhhdmNTYW1wbGUucHRzICsgJy8nICsgYXZjU2FtcGxlLmR0cyArICcsJyArIHVuaXRzU3RyaW5nICsgYXZjU2FtcGxlLnVuaXRzLmxlbmd0aCk7XHJcbiAgLy8gfVxyXG5cclxuICAgIC8vIGlmIHBhcnNlZCBmcmFnbWVudCBpcyBjb250aWd1b3VzIHdpdGggbGFzdCBvbmUsIGxldCdzIHVzZSBsYXN0IERUUyB2YWx1ZSBhcyByZWZlcmVuY2VcclxuICAgIGxldCBuZXh0QXZjRHRzID0gdGhpcy5uZXh0QXZjRHRzO1xyXG5cclxuICAgIGNvbnN0IGlzU2FmYXJpID0gdGhpcy5pc1NhZmFyaTtcclxuXHJcbiAgICAvLyBTYWZhcmkgZG9lcyBub3QgbGlrZSBvdmVybGFwcGluZyBEVFMgb24gY29uc2VjdXRpdmUgZnJhZ21lbnRzLiBsZXQncyB1c2UgbmV4dEF2Y0R0cyB0byBvdmVyY29tZSB0aGlzIGlmIGZyYWdtZW50cyBhcmUgY29uc2VjdXRpdmVcclxuICAgIGlmIChpc1NhZmFyaSkge1xyXG4gICAgICAvLyBhbHNvIGNvbnNpZGVyIGNvbnNlY3V0aXZlIGZyYWdtZW50cyBhcyBiZWluZyBjb250aWd1b3VzIChldmVuIGlmIGEgbGV2ZWwgc3dpdGNoIG9jY3VycyksXHJcbiAgICAgIC8vIGZvciBzYWtlIG9mIGNsYXJpdHk6XHJcbiAgICAgIC8vIGNvbnNlY3V0aXZlIGZyYWdtZW50cyBhcmUgZnJhZ3Mgd2l0aFxyXG4gICAgICAvLyAgLSBsZXNzIHRoYW4gMTAwbXMgZ2FwcyBiZXR3ZWVuIG5ldyB0aW1lIG9mZnNldCAoaWYgYWNjdXJhdGUpIGFuZCBuZXh0IGV4cGVjdGVkIFBUUyBPUlxyXG4gICAgICAvLyAgLSBsZXNzIHRoYW4gMjAwIG1zIFBUUyBnYXBzICh0aW1lU2NhbGUvNSlcclxuICAgICAgY29udGlndW91cyB8PSAoaW5wdXRTYW1wbGVzLmxlbmd0aCAmJiBuZXh0QXZjRHRzICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICgoYWNjdXJhdGVUaW1lT2Zmc2V0ICYmIE1hdGguYWJzKHRpbWVPZmZzZXQtbmV4dEF2Y0R0cy90aW1lU2NhbGUpIDwgMC4xKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgTWF0aC5hYnMoKGlucHV0U2FtcGxlc1swXS5wdHMtbmV4dEF2Y0R0cy1pbml0RFRTKSkgPCB0aW1lU2NhbGUvNSlcclxuICAgICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFjb250aWd1b3VzKSB7XHJcbiAgICAgIC8vIGlmIG5vdCBjb250aWd1b3VzLCBsZXQncyB1c2UgdGFyZ2V0IHRpbWVPZmZzZXRcclxuICAgICAgbmV4dEF2Y0R0cyA9IHRpbWVPZmZzZXQqdGltZVNjYWxlO1xyXG4gICAgfVxyXG5cclxuICAvLyBQVFMgaXMgY29kZWQgb24gMzNiaXRzLCBhbmQgY2FuIGxvb3AgZnJvbSAtMl4zMiB0byAyXjMyXHJcbiAgLy8gcHRzTm9ybWFsaXplIHdpbGwgbWFrZSBQVFMvRFRTIHZhbHVlIG1vbm90b25pYywgd2UgdXNlIGxhc3Qga25vd24gRFRTIHZhbHVlIGFzIHJlZmVyZW5jZSB2YWx1ZVxyXG4gICAgaW5wdXRTYW1wbGVzLmZvckVhY2goZnVuY3Rpb24oc2FtcGxlKSB7XHJcbiAgICAgIHNhbXBsZS5wdHMgPSBwdHNOb3JtYWxpemUoc2FtcGxlLnB0cy1pbml0RFRTLCBuZXh0QXZjRHRzKTtcclxuICAgICAgc2FtcGxlLmR0cyA9IHB0c05vcm1hbGl6ZShzYW1wbGUuZHRzLWluaXREVFMsIG5leHRBdmNEdHMpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gc29ydCB2aWRlbyBzYW1wbGVzIGJ5IERUUyB0aGVuIFBUUyB0aGVuIGRlbXV4IGlkIG9yZGVyXHJcbiAgICBpbnB1dFNhbXBsZXMuc29ydChmdW5jdGlvbihhLCBiKSB7XHJcbiAgICAgIGNvbnN0IGRlbHRhZHRzID0gYS5kdHMgLSBiLmR0cztcclxuICAgICAgY29uc3QgZGVsdGFwdHMgPSBhLnB0cyAtIGIucHRzO1xyXG4gICAgICByZXR1cm4gZGVsdGFkdHMgPyBkZWx0YWR0cyA6IGRlbHRhcHRzID8gZGVsdGFwdHMgOiAoYS5pZCAtIGIuaWQpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gaGFuZGxlIGJyb2tlbiBzdHJlYW1zIHdpdGggUFRTIDwgRFRTLCB0b2xlcmFuY2UgdXAgMjAwbXMgKDE4MDAwIGluIDkwa0h6IHRpbWVzY2FsZSlcclxuICAgIGxldCBQVFNEVFNzaGlmdCA9IGlucHV0U2FtcGxlcy5yZWR1Y2UoIChwcmV2LCBjdXJyKSA9PiBNYXRoLm1heChNYXRoLm1pbihwcmV2LGN1cnIucHRzLWN1cnIuZHRzKSwtMTgwMDApLDApO1xyXG4gICAgaWYgKFBUU0RUU3NoaWZ0IDwgMCkge1xyXG4gICAgICBsb2dnZXIud2FybihgUFRTIDwgRFRTIGRldGVjdGVkIGluIHZpZGVvIHNhbXBsZXMsIHNoaWZ0aW5nIERUUyBieSAke01hdGgucm91bmQoUFRTRFRTc2hpZnQvOTApfSBtcyB0byBvdmVyY29tZSB0aGlzIGlzc3VlYCk7XHJcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXRTYW1wbGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgaW5wdXRTYW1wbGVzW2ldLmR0cyArPSBQVFNEVFNzaGlmdDtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIGNvbXB1dGUgZmlyc3QgRFRTIGFuZCBsYXN0IERUUywgbm9ybWFsaXplIHRoZW0gYWdhaW5zdCByZWZlcmVuY2UgdmFsdWVcclxuICAgIGxldCBzYW1wbGUgPSBpbnB1dFNhbXBsZXNbMF07XHJcbiAgICBmaXJzdERUUyA9ICBNYXRoLm1heChzYW1wbGUuZHRzLDApO1xyXG4gICAgZmlyc3RQVFMgPSAgTWF0aC5tYXgoc2FtcGxlLnB0cywwKTtcclxuXHJcbiAgICAvLyBjaGVjayB0aW1lc3RhbXAgY29udGludWl0eSBhY2Nyb3NzIGNvbnNlY3V0aXZlIGZyYWdtZW50cyAodGhpcyBpcyB0byByZW1vdmUgaW50ZXItZnJhZ21lbnQgZ2FwL2hvbGUpXHJcbiAgICBsZXQgZGVsdGEgPSBNYXRoLnJvdW5kKChmaXJzdERUUyAtIG5leHRBdmNEdHMpIC8gOTApO1xyXG4gICAgLy8gaWYgZnJhZ21lbnQgYXJlIGNvbnRpZ3VvdXMsIGRldGVjdCBob2xlL292ZXJsYXBwaW5nIGJldHdlZW4gZnJhZ21lbnRzXHJcbiAgICBpZiAoY29udGlndW91cykge1xyXG4gICAgICBpZiAoZGVsdGEpIHtcclxuICAgICAgICBpZiAoZGVsdGEgPiAxKSB7XHJcbiAgICAgICAgICBsb2dnZXIubG9nKGBBVkM6JHtkZWx0YX0gbXMgaG9sZSBiZXR3ZWVuIGZyYWdtZW50cyBkZXRlY3RlZCxmaWxsaW5nIGl0YCk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChkZWx0YSA8IC0xKSB7XHJcbiAgICAgICAgICBsb2dnZXIubG9nKGBBVkM6JHsoLWRlbHRhKX0gbXMgb3ZlcmxhcHBpbmcgYmV0d2VlbiBmcmFnbWVudHMgZGV0ZWN0ZWRgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gcmVtb3ZlIGhvbGUvZ2FwIDogc2V0IERUUyB0byBuZXh0IGV4cGVjdGVkIERUU1xyXG4gICAgICAgIGZpcnN0RFRTID0gbmV4dEF2Y0R0cztcclxuICAgICAgICBpbnB1dFNhbXBsZXNbMF0uZHRzID0gZmlyc3REVFM7XHJcbiAgICAgICAgLy8gb2Zmc2V0IFBUUyBhcyB3ZWxsLCBlbnN1cmUgdGhhdCBQVFMgaXMgc21hbGxlciBvciBlcXVhbCB0aGFuIG5ldyBEVFNcclxuICAgICAgICBmaXJzdFBUUyA9IE1hdGgubWF4KGZpcnN0UFRTIC0gZGVsdGEsIG5leHRBdmNEdHMpO1xyXG4gICAgICAgIGlucHV0U2FtcGxlc1swXS5wdHMgPSBmaXJzdFBUUztcclxuICAgICAgICBsb2dnZXIubG9nKGBWaWRlby9QVFMvRFRTIGFkanVzdGVkOiAke01hdGgucm91bmQoZmlyc3RQVFMvOTApfS8ke01hdGgucm91bmQoZmlyc3REVFMvOTApfSxkZWx0YToke2RlbHRhfSBtc2ApO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBuZXh0RFRTID0gZmlyc3REVFM7XHJcblxyXG4gICAgLy8gY29tcHV0ZSBsYXN0UFRTL2xhc3REVFNcclxuICAgIHNhbXBsZSA9IGlucHV0U2FtcGxlc1tpbnB1dFNhbXBsZXMubGVuZ3RoLTFdO1xyXG4gICAgbGFzdERUUyA9ICBNYXRoLm1heChzYW1wbGUuZHRzLDApO1xyXG4gICAgbGFzdFBUUyA9ICBNYXRoLm1heChzYW1wbGUucHRzLDAsbGFzdERUUyk7XHJcblxyXG4gICAgICAvLyBvbiBTYWZhcmkgbGV0J3Mgc2lnbmFsIHRoZSBzYW1lIHNhbXBsZSBkdXJhdGlvbiBmb3IgYWxsIHNhbXBsZXNcclxuICAgICAgLy8gc2FtcGxlIGR1cmF0aW9uIChhcyBleHBlY3RlZCBieSB0cnVuIE1QNCBib3hlcyksIHNob3VsZCBiZSB0aGUgZGVsdGEgYmV0d2VlbiBzYW1wbGUgRFRTXHJcbiAgICAgIC8vIHNldCB0aGlzIGNvbnN0YW50IGR1cmF0aW9uIGFzIGJlaW5nIHRoZSBhdmcgZGVsdGEgYmV0d2VlbiBjb25zZWN1dGl2ZSBEVFMuXHJcbiAgICBpZiAoaXNTYWZhcmkpIHtcclxuICAgICAgbXA0U2FtcGxlRHVyYXRpb24gPSBNYXRoLnJvdW5kKChsYXN0RFRTLWZpcnN0RFRTKS8oaW5wdXRTYW1wbGVzLmxlbmd0aC0xKSk7XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IG5iTmFsdSA9IDAsIG5hbHVMZW4gPSAwO1xyXG4gICAgZm9yIChsZXQgaSA9IDAgOyBpIDwgbmJTYW1wbGVzOyBpKyspIHtcclxuICAgICAgLy8gY29tcHV0ZSB0b3RhbC9hdmMgc2FtcGxlIGxlbmd0aCBhbmQgbmIgb2YgTkFMIHVuaXRzXHJcbiAgICAgIGxldCBzYW1wbGUgPSBpbnB1dFNhbXBsZXNbaV0sIHVuaXRzID0gc2FtcGxlLnVuaXRzLCBuYlVuaXRzID0gdW5pdHMubGVuZ3RoLCBzYW1wbGVMZW4gPSAwO1xyXG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG5iVW5pdHM7IGorKykge1xyXG4gICAgICAgIHNhbXBsZUxlbiArPSB1bml0c1tqXS5kYXRhLmxlbmd0aDtcclxuICAgICAgfVxyXG4gICAgICBuYWx1TGVuICs9IHNhbXBsZUxlbjtcclxuICAgICAgbmJOYWx1ICs9IG5iVW5pdHM7XHJcbiAgICAgIHNhbXBsZS5sZW5ndGggPSBzYW1wbGVMZW47XHJcblxyXG4gICAgICAvLyBub3JtYWxpemUgUFRTL0RUU1xyXG4gICAgICBpZiAoaXNTYWZhcmkpIHtcclxuICAgICAgICAvLyBzYW1wbGUgRFRTIGlzIGNvbXB1dGVkIHVzaW5nIGEgY29uc3RhbnQgZGVjb2Rpbmcgb2Zmc2V0IChtcDRTYW1wbGVEdXJhdGlvbikgYmV0d2VlbiBzYW1wbGVzXHJcbiAgICAgICAgc2FtcGxlLmR0cyA9IGZpcnN0RFRTICsgaSptcDRTYW1wbGVEdXJhdGlvbjtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBlbnN1cmUgc2FtcGxlIG1vbm90b25pYyBEVFNcclxuICAgICAgICBzYW1wbGUuZHRzID0gTWF0aC5tYXgoc2FtcGxlLmR0cyxmaXJzdERUUyk7XHJcbiAgICAgIH1cclxuICAgICAgLy8gZW5zdXJlIHRoYXQgY29tcHV0ZWQgdmFsdWUgaXMgZ3JlYXRlciBvciBlcXVhbCB0aGFuIHNhbXBsZSBEVFNcclxuICAgICAgc2FtcGxlLnB0cyA9IE1hdGgubWF4KHNhbXBsZS5wdHMgLCBzYW1wbGUuZHRzKTtcclxuICAgIH1cclxuXHJcbiAgICAvKiBjb25jYXRlbmF0ZSB0aGUgdmlkZW8gZGF0YSBhbmQgY29uc3RydWN0IHRoZSBtZGF0IGluIHBsYWNlXHJcbiAgICAgIChuZWVkIDggbW9yZSBieXRlcyB0byBmaWxsIGxlbmd0aCBhbmQgbXBkYXQgdHlwZSkgKi9cclxuICAgIGxldCBtZGF0U2l6ZSA9IG5hbHVMZW4gKyAoNCAqIG5iTmFsdSkgKyA4O1xyXG4gICAgdHJ5IHtcclxuICAgICAgbWRhdCA9IG5ldyBVaW50OEFycmF5KG1kYXRTaXplKTtcclxuICAgIH0gY2F0Y2goZXJyKSB7XHJcbiAgICAgIHRoaXMub2JzZXJ2ZXIudHJpZ2dlcihFdmVudC5FUlJPUiwge3R5cGUgOiBFcnJvclR5cGVzLk1VWF9FUlJPUiwgZGV0YWlsczogRXJyb3JEZXRhaWxzLlJFTVVYX0FMTE9DX0VSUk9SLCBmYXRhbDogZmFsc2UsIGJ5dGVzIDogbWRhdFNpemUsIHJlYXNvbjogYGZhaWwgYWxsb2NhdGluZyB2aWRlbyBtZGF0ICR7bWRhdFNpemV9YH0pO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBsZXQgdmlldyA9IG5ldyBEYXRhVmlldyhtZGF0LmJ1ZmZlcik7XHJcbiAgICB2aWV3LnNldFVpbnQzMigwLCBtZGF0U2l6ZSk7XHJcbiAgICBtZGF0LnNldChNUDQudHlwZXMubWRhdCwgNCk7XHJcblxyXG4gICAgZm9yIChsZXQgaSA9IDAgOyBpIDwgbmJTYW1wbGVzOyBpKyspIHtcclxuICAgICAgbGV0IGF2Y1NhbXBsZSA9IGlucHV0U2FtcGxlc1tpXSxcclxuICAgICAgICAgIGF2Y1NhbXBsZVVuaXRzID0gYXZjU2FtcGxlLnVuaXRzLFxyXG4gICAgICAgICAgbXA0U2FtcGxlTGVuZ3RoID0gMCxcclxuICAgICAgICAgIGNvbXBvc2l0aW9uVGltZU9mZnNldDtcclxuICAgICAgLy8gY29udmVydCBOQUxVIGJpdHN0cmVhbSB0byBNUDQgZm9ybWF0IChwcmVwZW5kIE5BTFUgd2l0aCBzaXplIGZpZWxkKVxyXG4gICAgICBmb3IobGV0IGogPSAwLCBuYlVuaXRzID0gYXZjU2FtcGxlVW5pdHMubGVuZ3RoOyBqIDwgbmJVbml0cyA7IGorKykge1xyXG4gICAgICAgIGxldCB1bml0ID0gYXZjU2FtcGxlVW5pdHNbal0sXHJcbiAgICAgICAgICAgIHVuaXREYXRhID0gdW5pdC5kYXRhLFxyXG4gICAgICAgICAgICB1bml0RGF0YUxlbiA9IHVuaXQuZGF0YS5ieXRlTGVuZ3RoO1xyXG4gICAgICAgIHZpZXcuc2V0VWludDMyKG9mZnNldCwgdW5pdERhdGFMZW4pO1xyXG4gICAgICAgIG9mZnNldCArPSA0O1xyXG4gICAgICAgIG1kYXQuc2V0KHVuaXREYXRhLCBvZmZzZXQpO1xyXG4gICAgICAgIG9mZnNldCArPSB1bml0RGF0YUxlbjtcclxuICAgICAgICBtcDRTYW1wbGVMZW5ndGggKz0gNCArIHVuaXREYXRhTGVuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZighaXNTYWZhcmkpIHtcclxuICAgICAgICAvLyBleHBlY3RlZCBzYW1wbGUgZHVyYXRpb24gaXMgdGhlIERlY29kaW5nIFRpbWVzdGFtcCBkaWZmIG9mIGNvbnNlY3V0aXZlIHNhbXBsZXNcclxuICAgICAgICBpZiAoaSA8IG5iU2FtcGxlcyAtIDEpIHtcclxuICAgICAgICAgIG1wNFNhbXBsZUR1cmF0aW9uID0gaW5wdXRTYW1wbGVzW2krMV0uZHRzIC0gYXZjU2FtcGxlLmR0cztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgbGV0IGNvbmZpZyA9IHRoaXMuY29uZmlnLFxyXG4gICAgICAgICAgICAgIGxhc3RGcmFtZUR1cmF0aW9uID0gYXZjU2FtcGxlLmR0cyAtIGlucHV0U2FtcGxlc1tpID4gMCA/IGktMSA6IGldLmR0cztcclxuICAgICAgICAgIGlmIChjb25maWcuc3RyZXRjaFNob3J0VmlkZW9UcmFjaykge1xyXG4gICAgICAgICAgICAvLyBJbiBzb21lIGNhc2VzLCBhIHNlZ21lbnQncyBhdWRpbyB0cmFjayBkdXJhdGlvbiBtYXkgZXhjZWVkIHRoZSB2aWRlbyB0cmFjayBkdXJhdGlvbi5cclxuICAgICAgICAgICAgLy8gU2luY2Ugd2UndmUgYWxyZWFkeSByZW11eGVkIGF1ZGlvLCBhbmQgd2Uga25vdyBob3cgbG9uZyB0aGUgYXVkaW8gdHJhY2sgaXMsIHdlIGxvb2sgdG9cclxuICAgICAgICAgICAgLy8gc2VlIGlmIHRoZSBkZWx0YSB0byB0aGUgbmV4dCBzZWdtZW50IGlzIGxvbmdlciB0aGFuIHRoZSBtaW5pbXVtIG9mIG1heEJ1ZmZlckhvbGUgYW5kXHJcbiAgICAgICAgICAgIC8vIG1heFNlZWtIb2xlLiBJZiBzbywgcGxheWJhY2sgd291bGQgcG90ZW50aWFsbHkgZ2V0IHN0dWNrLCBzbyB3ZSBhcnRpZmljaWFsbHkgaW5mbGF0ZVxyXG4gICAgICAgICAgICAvLyB0aGUgZHVyYXRpb24gb2YgdGhlIGxhc3QgZnJhbWUgdG8gbWluaW1pemUgYW55IHBvdGVudGlhbCBnYXAgYmV0d2VlbiBzZWdtZW50cy5cclxuICAgICAgICAgICAgbGV0IG1heEJ1ZmZlckhvbGUgPSBjb25maWcubWF4QnVmZmVySG9sZSxcclxuICAgICAgICAgICAgICAgIG1heFNlZWtIb2xlID0gY29uZmlnLm1heFNlZWtIb2xlLFxyXG4gICAgICAgICAgICAgICAgZ2FwVG9sZXJhbmNlID0gTWF0aC5mbG9vcihNYXRoLm1pbihtYXhCdWZmZXJIb2xlLCBtYXhTZWVrSG9sZSkgKiB0aW1lU2NhbGUpLFxyXG4gICAgICAgICAgICAgICAgZGVsdGFUb0ZyYW1lRW5kID0gKGF1ZGlvVHJhY2tMZW5ndGggPyBmaXJzdFBUUyArIGF1ZGlvVHJhY2tMZW5ndGggKiB0aW1lU2NhbGUgOiB0aGlzLm5leHRBdWRpb1B0cykgLSBhdmNTYW1wbGUucHRzO1xyXG4gICAgICAgICAgICBpZiAoZGVsdGFUb0ZyYW1lRW5kID4gZ2FwVG9sZXJhbmNlKSB7XHJcbiAgICAgICAgICAgICAgLy8gV2Ugc3VidHJhY3QgbGFzdEZyYW1lRHVyYXRpb24gZnJvbSBkZWx0YVRvRnJhbWVFbmQgdG8gdHJ5IHRvIHByZXZlbnQgYW55IHZpZGVvXHJcbiAgICAgICAgICAgICAgLy8gZnJhbWUgb3ZlcmxhcC4gbWF4QnVmZmVySG9sZS9tYXhTZWVrSG9sZSBzaG91bGQgYmUgPj4gbGFzdEZyYW1lRHVyYXRpb24gYW55d2F5LlxyXG4gICAgICAgICAgICAgIG1wNFNhbXBsZUR1cmF0aW9uID0gZGVsdGFUb0ZyYW1lRW5kIC0gbGFzdEZyYW1lRHVyYXRpb247XHJcbiAgICAgICAgICAgICAgaWYgKG1wNFNhbXBsZUR1cmF0aW9uIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgbXA0U2FtcGxlRHVyYXRpb24gPSBsYXN0RnJhbWVEdXJhdGlvbjtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgbG9nZ2VyLmxvZyhgSXQgaXMgYXBwcm94aW1hdGVseSAke2RlbHRhVG9GcmFtZUVuZC85MH0gbXMgdG8gdGhlIG5leHQgc2VnbWVudDsgdXNpbmcgZHVyYXRpb24gJHttcDRTYW1wbGVEdXJhdGlvbi85MH0gbXMgZm9yIHRoZSBsYXN0IHZpZGVvIGZyYW1lLmApO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIG1wNFNhbXBsZUR1cmF0aW9uID0gbGFzdEZyYW1lRHVyYXRpb247XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIG1wNFNhbXBsZUR1cmF0aW9uID0gbGFzdEZyYW1lRHVyYXRpb247XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbXBvc2l0aW9uVGltZU9mZnNldCA9IE1hdGgucm91bmQoYXZjU2FtcGxlLnB0cyAtIGF2Y1NhbXBsZS5kdHMpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNvbXBvc2l0aW9uVGltZU9mZnNldCA9IE1hdGgubWF4KDAsbXA0U2FtcGxlRHVyYXRpb24qTWF0aC5yb3VuZCgoYXZjU2FtcGxlLnB0cyAtIGF2Y1NhbXBsZS5kdHMpL21wNFNhbXBsZUR1cmF0aW9uKSk7XHJcbiAgICAgIH1cclxuXHJcblxyXG4gICAgICAvL2NvbnNvbGUubG9nKCdQVFMvRFRTL2luaXREVFMvbm9ybVBUUy9ub3JtRFRTL3JlbGF0aXZlIFBUUyA6ICR7YXZjU2FtcGxlLnB0c30vJHthdmNTYW1wbGUuZHRzfS8ke2luaXREVFN9LyR7cHRzbm9ybX0vJHtkdHNub3JtfS8keyhhdmNTYW1wbGUucHRzLzQyOTQ5NjcyOTYpLnRvRml4ZWQoMyl9Jyk7XHJcbiAgICAgIG91dHB1dFNhbXBsZXMucHVzaCh7XHJcbiAgICAgICAgc2l6ZTogbXA0U2FtcGxlTGVuZ3RoLFxyXG4gICAgICAgICAvLyBjb25zdGFudCBkdXJhdGlvblxyXG4gICAgICAgIGR1cmF0aW9uOiBtcDRTYW1wbGVEdXJhdGlvbixcclxuICAgICAgICBjdHM6IGNvbXBvc2l0aW9uVGltZU9mZnNldCxcclxuICAgICAgICBmbGFnczoge1xyXG4gICAgICAgICAgaXNMZWFkaW5nOiAwLFxyXG4gICAgICAgICAgaXNEZXBlbmRlZE9uOiAwLFxyXG4gICAgICAgICAgaGFzUmVkdW5kYW5jeTogMCxcclxuICAgICAgICAgIGRlZ3JhZFByaW86IDAsXHJcbiAgICAgICAgICBkZXBlbmRzT24gOiBhdmNTYW1wbGUua2V5ID8gMiA6IDEsXHJcbiAgICAgICAgICBpc05vblN5bmMgOiBhdmNTYW1wbGUua2V5ID8gMCA6IDFcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLy8gbmV4dCBBVkMgc2FtcGxlIERUUyBzaG91bGQgYmUgZXF1YWwgdG8gbGFzdCBzYW1wbGUgRFRTICsgbGFzdCBzYW1wbGUgZHVyYXRpb24gKGluIFBFUyB0aW1lc2NhbGUpXHJcbiAgICB0aGlzLm5leHRBdmNEdHMgPSBsYXN0RFRTICsgbXA0U2FtcGxlRHVyYXRpb247XHJcbiAgICBsZXQgZHJvcHBlZCA9IHRyYWNrLmRyb3BwZWQ7XHJcbiAgICB0cmFjay5sZW4gPSAwO1xyXG4gICAgdHJhY2submJOYWx1ID0gMDtcclxuICAgIHRyYWNrLmRyb3BwZWQgPSAwO1xyXG4gICAgaWYob3V0cHV0U2FtcGxlcy5sZW5ndGggJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ2Nocm9tZScpID4gLTEpIHtcclxuICAgICAgbGV0IGZsYWdzID0gb3V0cHV0U2FtcGxlc1swXS5mbGFncztcclxuICAgIC8vIGNocm9tZSB3b3JrYXJvdW5kLCBtYXJrIGZpcnN0IHNhbXBsZSBhcyBiZWluZyBhIFJhbmRvbSBBY2Nlc3MgUG9pbnQgdG8gYXZvaWQgc291cmNlYnVmZmVyIGFwcGVuZCBpc3N1ZVxyXG4gICAgLy8gaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTIyOTQxMlxyXG4gICAgICBmbGFncy5kZXBlbmRzT24gPSAyO1xyXG4gICAgICBmbGFncy5pc05vblN5bmMgPSAwO1xyXG4gICAgfVxyXG4gICAgdHJhY2suc2FtcGxlcyA9IG91dHB1dFNhbXBsZXM7XHJcbiAgICBtb29mID0gTVA0Lm1vb2YodHJhY2suc2VxdWVuY2VOdW1iZXIrKywgZmlyc3REVFMgLCB0cmFjayk7XHJcbiAgICB0cmFjay5zYW1wbGVzID0gW107XHJcblxyXG4gICAgbGV0IGRhdGEgPSB7XHJcbiAgICAgIGRhdGExOiBtb29mLFxyXG4gICAgICBkYXRhMjogbWRhdCxcclxuICAgICAgc3RhcnRQVFM6IGZpcnN0UFRTIC8gdGltZVNjYWxlLFxyXG4gICAgICBlbmRQVFM6IChsYXN0UFRTICsgIG1wNFNhbXBsZUR1cmF0aW9uKSAvIHRpbWVTY2FsZSxcclxuICAgICAgc3RhcnREVFM6IGZpcnN0RFRTIC8gdGltZVNjYWxlLFxyXG4gICAgICBlbmREVFM6IHRoaXMubmV4dEF2Y0R0cyAvIHRpbWVTY2FsZSxcclxuICAgICAgdHlwZTogJ3ZpZGVvJyxcclxuICAgICAgbmI6IG91dHB1dFNhbXBsZXMubGVuZ3RoLFxyXG4gICAgICBkcm9wcGVkIDogZHJvcHBlZFxyXG4gICAgfTtcclxuICAgIHRoaXMub2JzZXJ2ZXIudHJpZ2dlcihFdmVudC5GUkFHX1BBUlNJTkdfREFUQSwgZGF0YSk7XHJcbiAgICByZXR1cm4gZGF0YTtcclxuICB9XHJcblxyXG4gIHJlbXV4QXVkaW8odHJhY2ssIHRpbWVPZmZzZXQsIGNvbnRpZ3VvdXMsYWNjdXJhdGVUaW1lT2Zmc2V0KSB7XHJcbiAgICBjb25zdCBpbnB1dFRpbWVTY2FsZSA9IHRyYWNrLmlucHV0VGltZVNjYWxlLFxyXG4gICAgICAgICAgbXA0dGltZVNjYWxlID0gdHJhY2sudGltZXNjYWxlLFxyXG4gICAgICAgICAgc2NhbGVGYWN0b3IgPSBpbnB1dFRpbWVTY2FsZS9tcDR0aW1lU2NhbGUsXHJcbiAgICAgICAgICBtcDRTYW1wbGVEdXJhdGlvbiA9IHRyYWNrLmlzQUFDID8gMTAyNCA6IDExNTIsXHJcbiAgICAgICAgICBpbnB1dFNhbXBsZUR1cmF0aW9uID0gbXA0U2FtcGxlRHVyYXRpb24gKiBzY2FsZUZhY3RvcixcclxuICAgICAgICAgIHB0c05vcm1hbGl6ZSA9IHRoaXMuX1BUU05vcm1hbGl6ZSxcclxuICAgICAgICAgIGluaXREVFMgPSB0aGlzLl9pbml0RFRTLFxyXG4gICAgICAgICAgcmF3TVBFRyA9ICF0cmFjay5pc0FBQyAmJiB0aGlzLnR5cGVTdXBwb3J0ZWQubXBlZztcclxuXHJcbiAgICB2YXIgb2Zmc2V0LFxyXG4gICAgICAgIG1wNFNhbXBsZSxcclxuICAgICAgICBmaWxsRnJhbWUsXHJcbiAgICAgICAgbWRhdCwgbW9vZixcclxuICAgICAgICBmaXJzdFBUUywgbGFzdFBUUyxcclxuICAgICAgICBpbnB1dFNhbXBsZXMgPSB0cmFjay5zYW1wbGVzLFxyXG4gICAgICAgIG91dHB1dFNhbXBsZXMgPSBbXSxcclxuICAgICAgICBuZXh0QXVkaW9QdHMgPSB0aGlzLm5leHRBdWRpb1B0cztcclxuXHJcbiAgICAvLyBmb3IgYXVkaW8gc2FtcGxlcywgYWxzbyBjb25zaWRlciBjb25zZWN1dGl2ZSBmcmFnbWVudHMgYXMgYmVpbmcgY29udGlndW91cyAoZXZlbiBpZiBhIGxldmVsIHN3aXRjaCBvY2N1cnMpLFxyXG4gICAgLy8gZm9yIHNha2Ugb2YgY2xhcml0eTpcclxuICAgIC8vIGNvbnNlY3V0aXZlIGZyYWdtZW50cyBhcmUgZnJhZ3Mgd2l0aFxyXG4gICAgLy8gIC0gbGVzcyB0aGFuIDEwMG1zIGdhcHMgYmV0d2VlbiBuZXcgdGltZSBvZmZzZXQgKGlmIGFjY3VyYXRlKSBhbmQgbmV4dCBleHBlY3RlZCBQVFMgT1JcclxuICAgIC8vICAtIGxlc3MgdGhhbiAyMCBhdWRpbyBmcmFtZXMgZGlzdGFuY2VcclxuICAgIC8vIGNvbnRpZ3VvdXMgZnJhZ21lbnRzIGFyZSBjb25zZWN1dGl2ZSBmcmFnbWVudHMgZnJvbSBzYW1lIHF1YWxpdHkgbGV2ZWwgKHNhbWUgbGV2ZWwsIG5ldyBTTiA9IG9sZCBTTiArIDEpXHJcbiAgICAvLyB0aGlzIGhlbHBzIGVuc3VyaW5nIGF1ZGlvIGNvbnRpbnVpdHlcclxuICAgIC8vIGFuZCB0aGlzIGFsc28gYXZvaWRzIGF1ZGlvIGdsaXRjaGVzL2N1dCB3aGVuIHN3aXRjaGluZyBxdWFsaXR5LCBvciByZXBvcnRpbmcgd3JvbmcgZHVyYXRpb24gb24gZmlyc3QgYXVkaW8gZnJhbWVcclxuICAgIGNvbnRpZ3VvdXMgfD0gKGlucHV0U2FtcGxlcy5sZW5ndGggJiYgbmV4dEF1ZGlvUHRzICYmXHJcbiAgICAgICAgICAgICAgICAgICAoKGFjY3VyYXRlVGltZU9mZnNldCAmJiBNYXRoLmFicyh0aW1lT2Zmc2V0LW5leHRBdWRpb1B0cy9pbnB1dFRpbWVTY2FsZSkgPCAwLjEpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgTWF0aC5hYnMoKGlucHV0U2FtcGxlc1swXS5wdHMtbmV4dEF1ZGlvUHRzLWluaXREVFMpKSA8IDIwKmlucHV0U2FtcGxlRHVyYXRpb24pXHJcbiAgICAgICAgICAgICAgICAgICAgKTtcclxuXHJcbiAgICBpZiAoIWNvbnRpZ3VvdXMpIHtcclxuICAgICAgLy8gaWYgZnJhZ21lbnRzIGFyZSBub3QgY29udGlndW91cywgbGV0J3MgdXNlIHRpbWVPZmZzZXQgdG8gY29tcHV0ZSBuZXh0IEF1ZGlvIFBUU1xyXG4gICAgICBuZXh0QXVkaW9QdHMgPSB0aW1lT2Zmc2V0KmlucHV0VGltZVNjYWxlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGNvbXB1dGUgbm9ybWFsaXplZCBQVFNcclxuICAgIGlucHV0U2FtcGxlcy5mb3JFYWNoKGZ1bmN0aW9uKHNhbXBsZSkge1xyXG4gICAgICBzYW1wbGUucHRzID0gc2FtcGxlLmR0cyA9IHB0c05vcm1hbGl6ZShzYW1wbGUucHRzIC0gaW5pdERUUywgbmV4dEF1ZGlvUHRzKTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIHNvcnQgYmFzZWQgb24gbm9ybWFsaXplZCBQVFMgKHRoaXMgaXMgdG8gYXZvaWQgc29ydGluZyBpc3N1ZXMgaW4gY2FzZSB0aW1lc3RhbXBcclxuICAgIC8vIHJlbG9vcCBpbiB0aGUgbWlkZGxlIG9mIG91ciBzYW1wbGVzIGFycmF5KVxyXG4gICAgaW5wdXRTYW1wbGVzLnNvcnQoZnVuY3Rpb24oYSwgYikge1xyXG4gICAgICByZXR1cm4gYS5wdHMgLSBiLnB0cztcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIElmIHRoZSBhdWRpbyB0cmFjayBpcyBtaXNzaW5nIHNhbXBsZXMsIHRoZSBmcmFtZXMgc2VlbSB0byBnZXQgXCJsZWZ0LXNoaWZ0ZWRcIiB3aXRoaW4gdGhlXHJcbiAgICAvLyByZXN1bHRpbmcgbXA0IHNlZ21lbnQsIGNhdXNpbmcgc3luYyBpc3N1ZXMgYW5kIGxlYXZpbmcgZ2FwcyBhdCB0aGUgZW5kIG9mIHRoZSBhdWRpbyBzZWdtZW50LlxyXG4gICAgLy8gSW4gYW4gZWZmb3J0IHRvIHByZXZlbnQgdGhpcyBmcm9tIGhhcHBlbmluZywgd2UgaW5qZWN0IGZyYW1lcyBoZXJlIHdoZXJlIHRoZXJlIGFyZSBnYXBzLlxyXG4gICAgLy8gV2hlbiBwb3NzaWJsZSwgd2UgaW5qZWN0IGEgc2lsZW50IGZyYW1lOyB3aGVuIHRoYXQncyBub3QgcG9zc2libGUsIHdlIGR1cGxpY2F0ZSB0aGUgbGFzdFxyXG4gICAgLy8gZnJhbWUuXHJcblxyXG4gICAgLy8gb25seSBpbmplY3QvZHJvcCBhdWRpbyBmcmFtZXMgaW4gY2FzZSB0aW1lIG9mZnNldCBpcyBhY2N1cmF0ZVxyXG4gICAgaWYgKGFjY3VyYXRlVGltZU9mZnNldCAmJiB0cmFjay5pc0FBQykge1xyXG4gICAgICBmb3IgKGxldCBpID0gMCwgbmV4dFB0cyA9IG5leHRBdWRpb1B0czsgaSA8IGlucHV0U2FtcGxlcy5sZW5ndGg7ICkge1xyXG4gICAgICAgIC8vIEZpcnN0LCBsZXQncyBzZWUgaG93IGZhciBvZmYgdGhpcyBmcmFtZSBpcyBmcm9tIHdoZXJlIHdlIGV4cGVjdCBpdCB0byBiZVxyXG4gICAgICAgIHZhciBzYW1wbGUgPSBpbnB1dFNhbXBsZXNbaV0sIGRlbHRhO1xyXG4gICAgICAgIGxldCBwdHMgPSBzYW1wbGUucHRzO1xyXG4gICAgICAgIGRlbHRhID0gcHRzIC0gbmV4dFB0cztcclxuXHJcbiAgICAgICAgY29uc3QgZHVyYXRpb24gPSBNYXRoLmFicygxMDAwKmRlbHRhL2lucHV0VGltZVNjYWxlKTtcclxuXHJcbiAgICAgICAgLy8gSWYgd2UncmUgb3ZlcmxhcHBpbmcgYnkgbW9yZSB0aGFuIGEgZHVyYXRpb24sIGRyb3AgdGhpcyBzYW1wbGVcclxuICAgICAgICBpZiAoZGVsdGEgPD0gLWlucHV0U2FtcGxlRHVyYXRpb24pIHtcclxuICAgICAgICAgIGxvZ2dlci53YXJuKGBEcm9wcGluZyAxIGF1ZGlvIGZyYW1lIEAgJHsobmV4dFB0cy9pbnB1dFRpbWVTY2FsZSkudG9GaXhlZCgzKX1zIGR1ZSB0byAke2R1cmF0aW9ufSBtcyBvdmVybGFwLmApO1xyXG4gICAgICAgICAgaW5wdXRTYW1wbGVzLnNwbGljZShpLCAxKTtcclxuICAgICAgICAgIHRyYWNrLmxlbiAtPSBzYW1wbGUudW5pdC5sZW5ndGg7XHJcbiAgICAgICAgICAvLyBEb24ndCB0b3VjaCBuZXh0UHRzTm9ybSBvciBpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBJbnNlcnQgbWlzc2luZyBmcmFtZXMgaWY6XHJcbiAgICAgICAgLy8gMTogV2UncmUgbW9yZSB0aGFuIG9uZSBmcmFtZSBhd2F5XHJcbiAgICAgICAgLy8gMjogTm90IG1vcmUgdGhhbiBNQVhfU0lMRU5UX0ZSQU1FX0RVUkFUSU9OIGF3YXlcclxuICAgICAgICAvLyAzOiBjdXJyZW50VGltZSAoYWthIG5leHRQdHNOb3JtKSBpcyBub3QgMFxyXG4gICAgICAgIGVsc2UgaWYgKGRlbHRhID49IGlucHV0U2FtcGxlRHVyYXRpb24gJiYgZHVyYXRpb24gPCBNQVhfU0lMRU5UX0ZSQU1FX0RVUkFUSU9OICYmIG5leHRQdHMpIHtcclxuICAgICAgICAgIHZhciBtaXNzaW5nID0gTWF0aC5yb3VuZChkZWx0YSAvIGlucHV0U2FtcGxlRHVyYXRpb24pO1xyXG4gICAgICAgICAgbG9nZ2VyLndhcm4oYEluamVjdGluZyAke21pc3Npbmd9IGF1ZGlvIGZyYW1lIEAgJHsobmV4dFB0cy9pbnB1dFRpbWVTY2FsZSkudG9GaXhlZCgzKX1zIGR1ZSB0byAke01hdGgucm91bmQoMTAwMCpkZWx0YS9pbnB1dFRpbWVTY2FsZSl9IG1zIGdhcC5gKTtcclxuICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWlzc2luZzsgaisrKSB7XHJcbiAgICAgICAgICAgIGxldCBuZXdTdGFtcCA9IE1hdGgubWF4KG5leHRQdHMsMCk7XHJcbiAgICAgICAgICAgIGZpbGxGcmFtZSA9IEFBQy5nZXRTaWxlbnRGcmFtZSh0cmFjay5tYW5pZmVzdENvZGVjIHx8IHRyYWNrLmNvZGVjLHRyYWNrLmNoYW5uZWxDb3VudCk7XHJcbiAgICAgICAgICAgIGlmICghZmlsbEZyYW1lKSB7XHJcbiAgICAgICAgICAgICAgbG9nZ2VyLmxvZygnVW5hYmxlIHRvIGdldCBzaWxlbnQgZnJhbWUgZm9yIGdpdmVuIGF1ZGlvIGNvZGVjOyBkdXBsaWNhdGluZyBsYXN0IGZyYW1lIGluc3RlYWQuJyk7XHJcbiAgICAgICAgICAgICAgZmlsbEZyYW1lID0gc2FtcGxlLnVuaXQuc3ViYXJyYXkoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpbnB1dFNhbXBsZXMuc3BsaWNlKGksIDAsIHt1bml0OiBmaWxsRnJhbWUsIHB0czogbmV3U3RhbXAsIGR0czogbmV3U3RhbXB9KTtcclxuICAgICAgICAgICAgdHJhY2subGVuICs9IGZpbGxGcmFtZS5sZW5ndGg7XHJcbiAgICAgICAgICAgIG5leHRQdHMgKz0gaW5wdXRTYW1wbGVEdXJhdGlvbjtcclxuICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIEFkanVzdCBzYW1wbGUgdG8gbmV4dCBleHBlY3RlZCBwdHNcclxuICAgICAgICAgIHNhbXBsZS5wdHMgPSBzYW1wbGUuZHRzID0gbmV4dFB0cztcclxuICAgICAgICAgIG5leHRQdHMgKz0gaW5wdXRTYW1wbGVEdXJhdGlvbjtcclxuICAgICAgICAgIGkrKztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIE90aGVyd2lzZSwganVzdCBhZGp1c3QgcHRzXHJcbiAgICAgICAgICBpZiAoTWF0aC5hYnMoZGVsdGEpID4gKDAuMSAqIGlucHV0U2FtcGxlRHVyYXRpb24pKSB7XHJcbiAgICAgICAgICAgIC8vbG9nZ2VyLmxvZyhgSW52YWxpZCBmcmFtZSBkZWx0YSAke01hdGgucm91bmQoZGVsdGEgKyBpbnB1dFNhbXBsZUR1cmF0aW9uKX0gYXQgUFRTICR7TWF0aC5yb3VuZChwdHMgLyA5MCl9IChzaG91bGQgYmUgJHtNYXRoLnJvdW5kKGlucHV0U2FtcGxlRHVyYXRpb24pfSkuYCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBzYW1wbGUucHRzID0gc2FtcGxlLmR0cyA9IG5leHRQdHM7XHJcbiAgICAgICAgICBuZXh0UHRzICs9IGlucHV0U2FtcGxlRHVyYXRpb247XHJcbiAgICAgICAgICBpKys7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGZvciAobGV0IGogPTAgLCBuYlNhbXBsZXMgPSBpbnB1dFNhbXBsZXMubGVuZ3RoOyBqIDwgbmJTYW1wbGVzIDsgaisrKSB7XHJcbiAgICAgIGxldCBhdWRpb1NhbXBsZSA9IGlucHV0U2FtcGxlc1tqXTtcclxuICAgICAgbGV0IHVuaXQgPSBhdWRpb1NhbXBsZS51bml0O1xyXG4gICAgICBsZXQgcHRzID0gYXVkaW9TYW1wbGUucHRzO1xyXG4gICAgICAvL2xvZ2dlci5sb2coYEF1ZGlvL1BUUzoke01hdGgucm91bmQocHRzLzkwKX1gKTtcclxuICAgICAgLy8gaWYgbm90IGZpcnN0IHNhbXBsZVxyXG4gICAgICBpZiAobGFzdFBUUyAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgbXA0U2FtcGxlLmR1cmF0aW9uID0gTWF0aC5yb3VuZCgocHRzIC0gbGFzdFBUUykgLyBzY2FsZUZhY3Rvcik7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbGV0IGRlbHRhID0gTWF0aC5yb3VuZCgxMDAwICogKHB0cyAtIG5leHRBdWRpb1B0cykgLyBpbnB1dFRpbWVTY2FsZSksXHJcbiAgICAgICAgICAgIG51bU1pc3NpbmdGcmFtZXMgPSAwO1xyXG4gICAgICAgIC8vIGlmIGZyYWdtZW50IGFyZSBjb250aWd1b3VzLCBkZXRlY3QgaG9sZS9vdmVybGFwcGluZyBiZXR3ZWVuIGZyYWdtZW50c1xyXG4gICAgICAgIC8vIGNvbnRpZ3VvdXMgZnJhZ21lbnRzIGFyZSBjb25zZWN1dGl2ZSBmcmFnbWVudHMgZnJvbSBzYW1lIHF1YWxpdHkgbGV2ZWwgKHNhbWUgbGV2ZWwsIG5ldyBTTiA9IG9sZCBTTiArIDEpXHJcbiAgICAgICAgaWYgKGNvbnRpZ3VvdXMgJiYgdHJhY2suaXNBQUMpIHtcclxuICAgICAgICAgIC8vIGxvZyBkZWx0YVxyXG4gICAgICAgICAgaWYgKGRlbHRhKSB7XHJcbiAgICAgICAgICAgIGlmIChkZWx0YSA+IDAgJiYgZGVsdGEgPCBNQVhfU0lMRU5UX0ZSQU1FX0RVUkFUSU9OKSB7XHJcbiAgICAgICAgICAgICAgbnVtTWlzc2luZ0ZyYW1lcyA9IE1hdGgucm91bmQoKHB0cyAtIG5leHRBdWRpb1B0cykgLyBpbnB1dFNhbXBsZUR1cmF0aW9uKTtcclxuICAgICAgICAgICAgICBsb2dnZXIubG9nKGAke2RlbHRhfSBtcyBob2xlIGJldHdlZW4gQUFDIHNhbXBsZXMgZGV0ZWN0ZWQsZmlsbGluZyBpdGApO1xyXG4gICAgICAgICAgICAgIGlmIChudW1NaXNzaW5nRnJhbWVzID4gMCkge1xyXG4gICAgICAgICAgICAgICAgZmlsbEZyYW1lID0gQUFDLmdldFNpbGVudEZyYW1lKHRyYWNrLm1hbmlmZXN0Q29kZWMgfHwgdHJhY2suY29kZWMsdHJhY2suY2hhbm5lbENvdW50KTtcclxuICAgICAgICAgICAgICAgIGlmICghZmlsbEZyYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgIGZpbGxGcmFtZSA9IHVuaXQuc3ViYXJyYXkoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRyYWNrLmxlbiArPSBudW1NaXNzaW5nRnJhbWVzICogZmlsbEZyYW1lLmxlbmd0aDtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgLy8gaWYgd2UgaGF2ZSBmcmFtZSBvdmVybGFwLCBvdmVybGFwcGluZyBmb3IgbW9yZSB0aGFuIGhhbGYgYSBmcmFtZSBkdXJhaW9uXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZGVsdGEgPCAtMTIpIHtcclxuICAgICAgICAgICAgICAvLyBkcm9wIG92ZXJsYXBwaW5nIGF1ZGlvIGZyYW1lcy4uLiBicm93c2VyIHdpbGwgZGVhbCB3aXRoIGl0XHJcbiAgICAgICAgICAgICAgbG9nZ2VyLmxvZyhgZHJvcCBvdmVybGFwcGluZyBBQUMgc2FtcGxlLCBleHBlY3RlZC9wYXJzZWQvZGVsdGE6JHsobmV4dEF1ZGlvUHRzL2lucHV0VGltZVNjYWxlKS50b0ZpeGVkKDMpfXMvJHsocHRzL2lucHV0VGltZVNjYWxlKS50b0ZpeGVkKDMpfXMvJHsoLWRlbHRhKX1tc2ApO1xyXG4gICAgICAgICAgICAgIHRyYWNrLmxlbiAtPSB1bml0LmJ5dGVMZW5ndGg7XHJcbiAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gc2V0IFBUUy9EVFMgdG8gZXhwZWN0ZWQgUFRTL0RUU1xyXG4gICAgICAgICAgICBwdHMgPSBuZXh0QXVkaW9QdHM7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHJlbWVtYmVyIGZpcnN0IFBUUyBvZiBvdXIgYXVkaW9TYW1wbGVzLCBlbnN1cmUgdmFsdWUgaXMgcG9zaXRpdmVcclxuICAgICAgICBmaXJzdFBUUyA9IE1hdGgubWF4KDAsIHB0cyk7XHJcbiAgICAgICAgaWYodHJhY2subGVuID4gMCkge1xyXG4gICAgICAgICAgLyogY29uY2F0ZW5hdGUgdGhlIGF1ZGlvIGRhdGEgYW5kIGNvbnN0cnVjdCB0aGUgbWRhdCBpbiBwbGFjZVxyXG4gICAgICAgICAgICAobmVlZCA4IG1vcmUgYnl0ZXMgdG8gZmlsbCBsZW5ndGggYW5kIG1kYXQgdHlwZSkgKi9cclxuICAgICAgICAgIGxldCBtZGF0U2l6ZSA9IHJhd01QRUcgPyB0cmFjay5sZW4gOiB0cmFjay5sZW4gKyA4O1xyXG4gICAgICAgICAgb2Zmc2V0ID0gcmF3TVBFRyA/IDAgOiA4O1xyXG4gICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgbWRhdCA9IG5ldyBVaW50OEFycmF5KG1kYXRTaXplKTtcclxuICAgICAgICAgIH0gY2F0Y2goZXJyKSB7XHJcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZXIudHJpZ2dlcihFdmVudC5FUlJPUiwge3R5cGUgOiBFcnJvclR5cGVzLk1VWF9FUlJPUiwgZGV0YWlsczogRXJyb3JEZXRhaWxzLlJFTVVYX0FMTE9DX0VSUk9SLCBmYXRhbDogZmFsc2UsIGJ5dGVzIDogbWRhdFNpemUsIHJlYXNvbjogYGZhaWwgYWxsb2NhdGluZyBhdWRpbyBtZGF0ICR7bWRhdFNpemV9YH0pO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAoIXJhd01QRUcpIHtcclxuICAgICAgICAgICAgY29uc3QgdmlldyA9IG5ldyBEYXRhVmlldyhtZGF0LmJ1ZmZlcik7XHJcbiAgICAgICAgICAgIHZpZXcuc2V0VWludDMyKDAsIG1kYXRTaXplKTtcclxuICAgICAgICAgICAgbWRhdC5zZXQoTVA0LnR5cGVzLm1kYXQsIDQpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAvLyBubyBhdWRpbyBzYW1wbGVzXHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtTWlzc2luZ0ZyYW1lczsgaSsrKSB7XHJcbiAgICAgICAgICBmaWxsRnJhbWUgPSBBQUMuZ2V0U2lsZW50RnJhbWUodHJhY2subWFuaWZlc3RDb2RlYyB8fCB0cmFjay5jb2RlYyx0cmFjay5jaGFubmVsQ291bnQpO1xyXG4gICAgICAgICAgaWYgKCFmaWxsRnJhbWUpIHtcclxuICAgICAgICAgICAgbG9nZ2VyLmxvZygnVW5hYmxlIHRvIGdldCBzaWxlbnQgZnJhbWUgZm9yIGdpdmVuIGF1ZGlvIGNvZGVjOyBkdXBsaWNhdGluZyB0aGlzIGZyYW1lIGluc3RlYWQuJyk7XHJcbiAgICAgICAgICAgIGZpbGxGcmFtZSA9IHVuaXQuc3ViYXJyYXkoKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIG1kYXQuc2V0KGZpbGxGcmFtZSwgb2Zmc2V0KTtcclxuICAgICAgICAgIG9mZnNldCArPSBmaWxsRnJhbWUuYnl0ZUxlbmd0aDtcclxuICAgICAgICAgIG1wNFNhbXBsZSA9IHtcclxuICAgICAgICAgICAgc2l6ZTogZmlsbEZyYW1lLmJ5dGVMZW5ndGgsXHJcbiAgICAgICAgICAgIGN0czogMCxcclxuICAgICAgICAgICAgZHVyYXRpb246IDEwMjQsXHJcbiAgICAgICAgICAgIGZsYWdzOiB7XHJcbiAgICAgICAgICAgICAgaXNMZWFkaW5nOiAwLFxyXG4gICAgICAgICAgICAgIGlzRGVwZW5kZWRPbjogMCxcclxuICAgICAgICAgICAgICBoYXNSZWR1bmRhbmN5OiAwLFxyXG4gICAgICAgICAgICAgIGRlZ3JhZFByaW86IDAsXHJcbiAgICAgICAgICAgICAgZGVwZW5kc09uOiAxLFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgICAgb3V0cHV0U2FtcGxlcy5wdXNoKG1wNFNhbXBsZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIG1kYXQuc2V0KHVuaXQsIG9mZnNldCk7XHJcbiAgICAgIGxldCB1bml0TGVuID0gdW5pdC5ieXRlTGVuZ3RoO1xyXG4gICAgICBvZmZzZXQgKz0gdW5pdExlbjtcclxuICAgICAgLy9jb25zb2xlLmxvZygnUFRTL0RUUy9pbml0RFRTL25vcm1QVFMvbm9ybURUUy9yZWxhdGl2ZSBQVFMgOiAke2F1ZGlvU2FtcGxlLnB0c30vJHthdWRpb1NhbXBsZS5kdHN9LyR7aW5pdERUU30vJHtwdHNub3JtfS8ke2R0c25vcm19LyR7KGF1ZGlvU2FtcGxlLnB0cy80Mjk0OTY3Mjk2KS50b0ZpeGVkKDMpfScpO1xyXG4gICAgICBtcDRTYW1wbGUgPSB7XHJcbiAgICAgICAgc2l6ZTogdW5pdExlbixcclxuICAgICAgICBjdHM6IDAsXHJcbiAgICAgICAgZHVyYXRpb246IDAsXHJcbiAgICAgICAgZmxhZ3M6IHtcclxuICAgICAgICAgIGlzTGVhZGluZzogMCxcclxuICAgICAgICAgIGlzRGVwZW5kZWRPbjogMCxcclxuICAgICAgICAgIGhhc1JlZHVuZGFuY3k6IDAsXHJcbiAgICAgICAgICBkZWdyYWRQcmlvOiAwLFxyXG4gICAgICAgICAgZGVwZW5kc09uOiAxLFxyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuICAgICAgb3V0cHV0U2FtcGxlcy5wdXNoKG1wNFNhbXBsZSk7XHJcbiAgICAgIGxhc3RQVFMgPSBwdHM7XHJcbiAgICB9XHJcbiAgICB2YXIgbGFzdFNhbXBsZUR1cmF0aW9uID0gMDtcclxuICAgIHZhciBuYlNhbXBsZXMgPSBvdXRwdXRTYW1wbGVzLmxlbmd0aDtcclxuICAgIC8vc2V0IGxhc3Qgc2FtcGxlIGR1cmF0aW9uIGFzIGJlaW5nIGlkZW50aWNhbCB0byBwcmV2aW91cyBzYW1wbGVcclxuICAgIGlmIChuYlNhbXBsZXMgPj0gMikge1xyXG4gICAgICBsYXN0U2FtcGxlRHVyYXRpb24gPSBvdXRwdXRTYW1wbGVzW25iU2FtcGxlcyAtIDJdLmR1cmF0aW9uO1xyXG4gICAgICBtcDRTYW1wbGUuZHVyYXRpb24gPSBsYXN0U2FtcGxlRHVyYXRpb247XHJcbiAgICB9XHJcbiAgICBpZiAobmJTYW1wbGVzKSB7XHJcbiAgICAgIC8vIG5leHQgYXVkaW8gc2FtcGxlIFBUUyBzaG91bGQgYmUgZXF1YWwgdG8gbGFzdCBzYW1wbGUgUFRTICsgZHVyYXRpb25cclxuICAgICAgdGhpcy5uZXh0QXVkaW9QdHMgPSBuZXh0QXVkaW9QdHMgPSBsYXN0UFRTICsgc2NhbGVGYWN0b3IgKiBsYXN0U2FtcGxlRHVyYXRpb247XHJcbiAgICAgIC8vbG9nZ2VyLmxvZygnQXVkaW8vUFRTL1BUU2VuZDonICsgYXVkaW9TYW1wbGUucHRzLnRvRml4ZWQoMCkgKyAnLycgKyB0aGlzLm5leHRBYWNEdHMudG9GaXhlZCgwKSk7XHJcbiAgICAgIHRyYWNrLmxlbiA9IDA7XHJcbiAgICAgIHRyYWNrLnNhbXBsZXMgPSBvdXRwdXRTYW1wbGVzO1xyXG4gICAgICBpZiAocmF3TVBFRykge1xyXG4gICAgICAgIG1vb2YgPSBuZXcgVWludDhBcnJheSgpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIG1vb2YgPSBNUDQubW9vZih0cmFjay5zZXF1ZW5jZU51bWJlcisrLCBmaXJzdFBUUyAvIHNjYWxlRmFjdG9yLCB0cmFjayk7XHJcbiAgICAgIH1cclxuICAgICAgdHJhY2suc2FtcGxlcyA9IFtdO1xyXG4gICAgICBjb25zdCBzdGFydCA9IGZpcnN0UFRTIC8gaW5wdXRUaW1lU2NhbGU7XHJcbiAgICAgIGNvbnN0IGVuZCA9IG5leHRBdWRpb1B0cyAvIGlucHV0VGltZVNjYWxlO1xyXG4gICAgICBjb25zdCBhdWRpb0RhdGEgPSB7XHJcbiAgICAgICAgZGF0YTE6IG1vb2YsXHJcbiAgICAgICAgZGF0YTI6IG1kYXQsXHJcbiAgICAgICAgc3RhcnRQVFM6IHN0YXJ0LFxyXG4gICAgICAgIGVuZFBUUzogZW5kLFxyXG4gICAgICAgIHN0YXJ0RFRTOiBzdGFydCxcclxuICAgICAgICBlbmREVFM6IGVuZCxcclxuICAgICAgICB0eXBlOiAnYXVkaW8nLFxyXG4gICAgICAgIG5iOiBuYlNhbXBsZXNcclxuICAgICAgfTtcclxuICAgICAgdGhpcy5vYnNlcnZlci50cmlnZ2VyKEV2ZW50LkZSQUdfUEFSU0lOR19EQVRBLCBhdWRpb0RhdGEpO1xyXG4gICAgICByZXR1cm4gYXVkaW9EYXRhO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG5cclxuICByZW11eEVtcHR5QXVkaW8odHJhY2ssIHRpbWVPZmZzZXQsIGNvbnRpZ3VvdXMsIHZpZGVvRGF0YSkge1xyXG4gICAgbGV0IGlucHV0VGltZVNjYWxlID0gdHJhY2suaW5wdXRUaW1lU2NhbGUsXHJcbiAgICAgICAgbXA0dGltZVNjYWxlID0gdHJhY2suc2FtcGxlcmF0ZSA/IHRyYWNrLnNhbXBsZXJhdGUgOiBpbnB1dFRpbWVTY2FsZSxcclxuICAgICAgICBzY2FsZUZhY3RvciA9IGlucHV0VGltZVNjYWxlL21wNHRpbWVTY2FsZSxcclxuICAgICAgICBuZXh0QXVkaW9QdHMgPSB0aGlzLm5leHRBdWRpb1B0cyxcclxuXHJcbiAgICAgICAgLy8gc3luYyB3aXRoIHZpZGVvJ3MgdGltZXN0YW1wXHJcbiAgICAgICAgc3RhcnREVFMgPSAobmV4dEF1ZGlvUHRzICE9PSB1bmRlZmluZWQgPyBuZXh0QXVkaW9QdHMgOiB2aWRlb0RhdGEuc3RhcnREVFMgKiBpbnB1dFRpbWVTY2FsZSkgKyB0aGlzLl9pbml0RFRTLFxyXG4gICAgICAgIGVuZERUUyA9IHZpZGVvRGF0YS5lbmREVFMgKiBpbnB1dFRpbWVTY2FsZSArIHRoaXMuX2luaXREVFMsXHJcbiAgICAgICAgLy8gb25lIHNhbXBsZSdzIGR1cmF0aW9uIHZhbHVlXHJcbiAgICAgICAgc2FtcGxlRHVyYXRpb24gPSAxMDI0LFxyXG4gICAgICAgIGZyYW1lRHVyYXRpb24gPSBzY2FsZUZhY3RvciAqIHNhbXBsZUR1cmF0aW9uLFxyXG5cclxuICAgICAgICAvLyBzYW1wbGVzIGNvdW50IG9mIHRoaXMgc2VnbWVudCdzIGR1cmF0aW9uXHJcbiAgICAgICAgbmJTYW1wbGVzID0gTWF0aC5jZWlsKChlbmREVFMgLSBzdGFydERUUykgLyBmcmFtZUR1cmF0aW9uKSxcclxuXHJcbiAgICAgICAgLy8gc2lsZW50IGZyYW1lXHJcbiAgICAgICAgc2lsZW50RnJhbWUgPSBBQUMuZ2V0U2lsZW50RnJhbWUodHJhY2subWFuaWZlc3RDb2RlYyB8fCB0cmFjay5jb2RlYyx0cmFjay5jaGFubmVsQ291bnQpO1xyXG5cclxuICAgICAgICBsb2dnZXIud2FybigncmVtdXggZW1wdHkgQXVkaW8nKTtcclxuICAgIC8vIENhbid0IHJlbXV4IGlmIHdlIGNhbid0IGdlbmVyYXRlIGEgc2lsZW50IGZyYW1lLi4uXHJcbiAgICBpZiAoIXNpbGVudEZyYW1lKSB7XHJcbiAgICAgIGxvZ2dlci50cmFjZSgnVW5hYmxlIHRvIHJlbXV4RW1wdHlBdWRpbyBzaW5jZSB3ZSB3ZXJlIHVuYWJsZSB0byBnZXQgYSBzaWxlbnQgZnJhbWUgZm9yIGdpdmVuIGF1ZGlvIGNvZGVjIScpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IHNhbXBsZXMgPSBbXTtcclxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBuYlNhbXBsZXM7IGkrKykge1xyXG4gICAgICB2YXIgc3RhbXAgPSBzdGFydERUUyArIGkgKiBmcmFtZUR1cmF0aW9uO1xyXG4gICAgICBzYW1wbGVzLnB1c2goe3VuaXQ6IHNpbGVudEZyYW1lLCBwdHM6IHN0YW1wLCBkdHM6IHN0YW1wfSk7XHJcbiAgICAgIHRyYWNrLmxlbiArPSBzaWxlbnRGcmFtZS5sZW5ndGg7XHJcbiAgICB9XHJcbiAgICB0cmFjay5zYW1wbGVzID0gc2FtcGxlcztcclxuXHJcbiAgICB0aGlzLnJlbXV4QXVkaW8odHJhY2ssIHRpbWVPZmZzZXQsIGNvbnRpZ3VvdXMpO1xyXG4gIH1cclxuXHJcbiAgcmVtdXhJRDModHJhY2ssdGltZU9mZnNldCkge1xyXG4gICAgdmFyIGxlbmd0aCA9IHRyYWNrLnNhbXBsZXMubGVuZ3RoLCBzYW1wbGU7XHJcbiAgICBjb25zdCBpbnB1dFRpbWVTY2FsZSA9IHRyYWNrLmlucHV0VGltZVNjYWxlO1xyXG4gICAgY29uc3QgaW5pdFBUUyA9IHRoaXMuX2luaXRQVFM7XHJcbiAgICBjb25zdCBpbml0RFRTID0gdGhpcy5faW5pdERUUztcclxuICAgIC8vIGNvbnN1bWUgc2FtcGxlc1xyXG4gICAgaWYobGVuZ3RoKSB7XHJcbiAgICAgIGZvcih2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xyXG4gICAgICAgIHNhbXBsZSA9IHRyYWNrLnNhbXBsZXNbaW5kZXhdO1xyXG4gICAgICAgIC8vIHNldHRpbmcgaWQzIHB0cywgZHRzIHRvIHJlbGF0aXZlIHRpbWVcclxuICAgICAgICAvLyB1c2luZyB0aGlzLl9pbml0UFRTIGFuZCB0aGlzLl9pbml0RFRTIHRvIGNhbGN1bGF0ZSByZWxhdGl2ZSB0aW1lXHJcbiAgICAgICAgc2FtcGxlLnB0cyA9ICgoc2FtcGxlLnB0cyAtIGluaXRQVFMpIC8gaW5wdXRUaW1lU2NhbGUpO1xyXG4gICAgICAgIHNhbXBsZS5kdHMgPSAoKHNhbXBsZS5kdHMgLSBpbml0RFRTKSAvIGlucHV0VGltZVNjYWxlKTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLm9ic2VydmVyLnRyaWdnZXIoRXZlbnQuRlJBR19QQVJTSU5HX01FVEFEQVRBLCB7XHJcbiAgICAgICAgc2FtcGxlczp0cmFjay5zYW1wbGVzXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHRyYWNrLnNhbXBsZXMgPSBbXTtcclxuICAgIHRpbWVPZmZzZXQgPSB0aW1lT2Zmc2V0O1xyXG4gIH1cclxuXHJcbiAgcmVtdXhUZXh0KHRyYWNrLHRpbWVPZmZzZXQpIHtcclxuICAgIHRyYWNrLnNhbXBsZXMuc29ydChmdW5jdGlvbihhLCBiKSB7XHJcbiAgICAgIHJldHVybiAoYS5wdHMtYi5wdHMpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgdmFyIGxlbmd0aCA9IHRyYWNrLnNhbXBsZXMubGVuZ3RoLCBzYW1wbGU7XHJcbiAgICBjb25zdCBpbnB1dFRpbWVTY2FsZSA9IHRyYWNrLmlucHV0VGltZVNjYWxlO1xyXG4gICAgY29uc3QgaW5pdFBUUyA9IHRoaXMuX2luaXRQVFM7XHJcbiAgICAvLyBjb25zdW1lIHNhbXBsZXNcclxuICAgIGlmKGxlbmd0aCkge1xyXG4gICAgICBmb3IodmFyIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcclxuICAgICAgICBzYW1wbGUgPSB0cmFjay5zYW1wbGVzW2luZGV4XTtcclxuICAgICAgICAvLyBzZXR0aW5nIHRleHQgcHRzLCBkdHMgdG8gcmVsYXRpdmUgdGltZVxyXG4gICAgICAgIC8vIHVzaW5nIHRoaXMuX2luaXRQVFMgYW5kIHRoaXMuX2luaXREVFMgdG8gY2FsY3VsYXRlIHJlbGF0aXZlIHRpbWVcclxuICAgICAgICBzYW1wbGUucHRzID0gKChzYW1wbGUucHRzIC0gaW5pdFBUUykgLyBpbnB1dFRpbWVTY2FsZSk7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5vYnNlcnZlci50cmlnZ2VyKEV2ZW50LkZSQUdfUEFSU0lOR19VU0VSREFUQSwge1xyXG4gICAgICAgIHNhbXBsZXM6dHJhY2suc2FtcGxlc1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICB0cmFjay5zYW1wbGVzID0gW107XHJcbiAgICB0aW1lT2Zmc2V0ID0gdGltZU9mZnNldDtcclxuICB9XHJcblxyXG4gIF9QVFNOb3JtYWxpemUodmFsdWUsIHJlZmVyZW5jZSkge1xyXG4gICAgdmFyIG9mZnNldDtcclxuICAgIGlmIChyZWZlcmVuY2UgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9XHJcbiAgICBpZiAocmVmZXJlbmNlIDwgdmFsdWUpIHtcclxuICAgICAgLy8gLSAyXjMzXHJcbiAgICAgIG9mZnNldCA9IC04NTg5OTM0NTkyO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gKyAyXjMzXHJcbiAgICAgIG9mZnNldCA9IDg1ODk5MzQ1OTI7XHJcbiAgICB9XHJcbiAgICAvKiBQVFMgaXMgMzNiaXQgKGZyb20gMCB0byAyXjMzIC0xKVxyXG4gICAgICBpZiBkaWZmIGJldHdlZW4gdmFsdWUgYW5kIHJlZmVyZW5jZSBpcyBiaWdnZXIgdGhhbiBoYWxmIG9mIHRoZSBhbXBsaXR1ZGUgKDJeMzIpIHRoZW4gaXQgbWVhbnMgdGhhdFxyXG4gICAgICBQVFMgbG9vcGluZyBvY2N1cmVkLiBmaWxsIHRoZSBnYXAgKi9cclxuICAgIHdoaWxlIChNYXRoLmFicyh2YWx1ZSAtIHJlZmVyZW5jZSkgPiA0Mjk0OTY3Mjk2KSB7XHJcbiAgICAgICAgdmFsdWUgKz0gb2Zmc2V0O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZhbHVlO1xyXG4gIH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IE1QNFJlbXV4ZXI7XHJcbiIsIi8qKlxyXG4gKiBwYXNzdGhyb3VnaCByZW11eGVyXHJcbiovXHJcbmltcG9ydCBFdmVudCBmcm9tICcuLi9ldmVudHMnO1xyXG5cclxuY2xhc3MgUGFzc1Rocm91Z2hSZW11eGVyIHtcclxuICBjb25zdHJ1Y3RvcihvYnNlcnZlcikge1xyXG4gICAgdGhpcy5vYnNlcnZlciA9IG9ic2VydmVyO1xyXG4gIH1cclxuXHJcbiAgZGVzdHJveSgpIHtcclxuICB9XHJcblxyXG4gIHJlc2V0VGltZVN0YW1wKCkge1xyXG4gIH1cclxuXHJcbiAgcmVzZXRJbml0U2VnbWVudCgpIHtcclxuICB9XHJcblxyXG4gIHJlbXV4KGF1ZGlvVHJhY2ssdmlkZW9UcmFjayxpZDNUcmFjayx0ZXh0VHJhY2ssdGltZU9mZnNldCwgY29udGlndW91cyxhY2N1cmF0ZVRpbWVPZmZzZXQscmF3RGF0YSkge1xyXG4gICAgdmFyIG9ic2VydmVyID0gdGhpcy5vYnNlcnZlcjtcclxuICAgIHZhciBzdHJlYW1UeXBlID0gJyc7XHJcbiAgICBpZiAoYXVkaW9UcmFjaykge1xyXG4gICAgICBzdHJlYW1UeXBlICs9ICdhdWRpbyc7XHJcbiAgICB9XHJcbiAgICBpZiAodmlkZW9UcmFjaykge1xyXG4gICAgICBzdHJlYW1UeXBlICs9ICd2aWRlbyc7XHJcbiAgICB9XHJcbiAgICBvYnNlcnZlci50cmlnZ2VyKEV2ZW50LkZSQUdfUEFSU0lOR19EQVRBLCB7XHJcbiAgICAgIGRhdGExOiByYXdEYXRhLFxyXG4gICAgICBzdGFydFBUUzogdGltZU9mZnNldCxcclxuICAgICAgc3RhcnREVFM6IHRpbWVPZmZzZXQsXHJcbiAgICAgIHR5cGU6IHN0cmVhbVR5cGUsXHJcbiAgICAgIG5iOiAxLFxyXG4gICAgICBkcm9wcGVkIDogMFxyXG4gICAgfSk7XHJcbiAgICAvL25vdGlmeSBlbmQgb2YgcGFyc2luZ1xyXG4gICAgb2JzZXJ2ZXIudHJpZ2dlcihFdmVudC5GUkFHX1BBUlNFRCk7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBQYXNzVGhyb3VnaFJlbXV4ZXI7XHJcbiIsImNvbnN0IERFQ0lNQUxfUkVTT0xVVElPTl9SRUdFWCA9IC9eKFxcZCspeChcXGQrKSQvO1xyXG5jb25zdCBBVFRSX0xJU1RfUkVHRVggPSAvXFxzKiguKz8pXFxzKj0oKD86XFxcIi4qP1xcXCIpfC4qPykoPzosfCQpL2c7XHJcblxyXG4vLyBhZGFwdGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2thbm9uZ2lsL25vZGUtbTN1OHBhcnNlL2Jsb2IvbWFzdGVyL2F0dHJsaXN0LmpzXHJcbmNsYXNzIEF0dHJMaXN0IHtcclxuXHJcbiAgY29uc3RydWN0b3IoYXR0cnMpIHtcclxuICAgIGlmICh0eXBlb2YgYXR0cnMgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgIGF0dHJzID0gQXR0ckxpc3QucGFyc2VBdHRyTGlzdChhdHRycyk7XHJcbiAgICB9XHJcbiAgICBmb3IodmFyIGF0dHIgaW4gYXR0cnMpe1xyXG4gICAgICBpZihhdHRycy5oYXNPd25Qcm9wZXJ0eShhdHRyKSkge1xyXG4gICAgICAgIHRoaXNbYXR0cl0gPSBhdHRyc1thdHRyXTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZGVjaW1hbEludGVnZXIoYXR0ck5hbWUpIHtcclxuICAgIGNvbnN0IGludFZhbHVlID0gcGFyc2VJbnQodGhpc1thdHRyTmFtZV0sIDEwKTtcclxuICAgIGlmIChpbnRWYWx1ZSA+IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKSB7XHJcbiAgICAgIHJldHVybiBJbmZpbml0eTtcclxuICAgIH1cclxuICAgIHJldHVybiBpbnRWYWx1ZTtcclxuICB9XHJcblxyXG4gIGhleGFkZWNpbWFsSW50ZWdlcihhdHRyTmFtZSkge1xyXG4gICAgaWYodGhpc1thdHRyTmFtZV0pIHtcclxuICAgICAgbGV0IHN0cmluZ1ZhbHVlID0gKHRoaXNbYXR0ck5hbWVdIHx8ICcweCcpLnNsaWNlKDIpO1xyXG4gICAgICBzdHJpbmdWYWx1ZSA9ICgoc3RyaW5nVmFsdWUubGVuZ3RoICYgMSkgPyAnMCcgOiAnJykgKyBzdHJpbmdWYWx1ZTtcclxuXHJcbiAgICAgIGNvbnN0IHZhbHVlID0gbmV3IFVpbnQ4QXJyYXkoc3RyaW5nVmFsdWUubGVuZ3RoIC8gMik7XHJcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyaW5nVmFsdWUubGVuZ3RoIC8gMjsgaSsrKSB7XHJcbiAgICAgICAgdmFsdWVbaV0gPSBwYXJzZUludChzdHJpbmdWYWx1ZS5zbGljZShpICogMiwgaSAqIDIgKyAyKSwgMTYpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgaGV4YWRlY2ltYWxJbnRlZ2VyQXNOdW1iZXIoYXR0ck5hbWUpIHtcclxuICAgIGNvbnN0IGludFZhbHVlID0gcGFyc2VJbnQodGhpc1thdHRyTmFtZV0sIDE2KTtcclxuICAgIGlmIChpbnRWYWx1ZSA+IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKSB7XHJcbiAgICAgIHJldHVybiBJbmZpbml0eTtcclxuICAgIH1cclxuICAgIHJldHVybiBpbnRWYWx1ZTtcclxuICB9XHJcblxyXG4gIGRlY2ltYWxGbG9hdGluZ1BvaW50KGF0dHJOYW1lKSB7XHJcbiAgICByZXR1cm4gcGFyc2VGbG9hdCh0aGlzW2F0dHJOYW1lXSk7XHJcbiAgfVxyXG5cclxuICBlbnVtZXJhdGVkU3RyaW5nKGF0dHJOYW1lKSB7XHJcbiAgICByZXR1cm4gdGhpc1thdHRyTmFtZV07XHJcbiAgfVxyXG5cclxuICBkZWNpbWFsUmVzb2x1dGlvbihhdHRyTmFtZSkge1xyXG4gICAgY29uc3QgcmVzID0gREVDSU1BTF9SRVNPTFVUSU9OX1JFR0VYLmV4ZWModGhpc1thdHRyTmFtZV0pO1xyXG4gICAgaWYgKHJlcyA9PT0gbnVsbCkge1xyXG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgd2lkdGg6IHBhcnNlSW50KHJlc1sxXSwgMTApLFxyXG4gICAgICBoZWlnaHQ6IHBhcnNlSW50KHJlc1syXSwgMTApXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIHBhcnNlQXR0ckxpc3QoaW5wdXQpIHtcclxuICAgIHZhciBtYXRjaCwgYXR0cnMgPSB7fTtcclxuICAgIEFUVFJfTElTVF9SRUdFWC5sYXN0SW5kZXggPSAwO1xyXG4gICAgd2hpbGUgKChtYXRjaCA9IEFUVFJfTElTVF9SRUdFWC5leGVjKGlucHV0KSkgIT09IG51bGwpIHtcclxuICAgICAgdmFyIHZhbHVlID0gbWF0Y2hbMl0sIHF1b3RlID0gJ1wiJztcclxuXHJcbiAgICAgIGlmICh2YWx1ZS5pbmRleE9mKHF1b3RlKSA9PT0gMCAmJlxyXG4gICAgICAgICAgdmFsdWUubGFzdEluZGV4T2YocXVvdGUpID09PSAodmFsdWUubGVuZ3RoLTEpKSB7XHJcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5zbGljZSgxLCAtMSk7XHJcbiAgICAgIH1cclxuICAgICAgYXR0cnNbbWF0Y2hbMV1dID0gdmFsdWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYXR0cnM7XHJcbiAgfVxyXG5cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgQXR0ckxpc3Q7XHJcbiIsInZhciBCaW5hcnlTZWFyY2ggPSB7XHJcbiAgICAvKipcclxuICAgICAqIFNlYXJjaGVzIGZvciBhbiBpdGVtIGluIGFuIGFycmF5IHdoaWNoIG1hdGNoZXMgYSBjZXJ0YWluIGNvbmRpdGlvbi5cclxuICAgICAqIFRoaXMgcmVxdWlyZXMgdGhlIGNvbmRpdGlvbiB0byBvbmx5IG1hdGNoIG9uZSBpdGVtIGluIHRoZSBhcnJheSxcclxuICAgICAqIGFuZCBmb3IgdGhlIGFycmF5IHRvIGJlIG9yZGVyZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgYXJyYXkgdG8gc2VhcmNoLlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY29tcGFyaXNvbkZ1bmN0aW9uXHJcbiAgICAgKiAgICAgIENhbGxlZCBhbmQgcHJvdmlkZWQgYSBjYW5kaWRhdGUgaXRlbSBhcyB0aGUgZmlyc3QgYXJndW1lbnQuXHJcbiAgICAgKiAgICAgIFNob3VsZCByZXR1cm46XHJcbiAgICAgKiAgICAgICAgICA+IC0xIGlmIHRoZSBpdGVtIHNob3VsZCBiZSBsb2NhdGVkIGF0IGEgbG93ZXIgaW5kZXggdGhhbiB0aGUgcHJvdmlkZWQgaXRlbS5cclxuICAgICAqICAgICAgICAgID4gMSBpZiB0aGUgaXRlbSBzaG91bGQgYmUgbG9jYXRlZCBhdCBhIGhpZ2hlciBpbmRleCB0aGFuIHRoZSBwcm92aWRlZCBpdGVtLlxyXG4gICAgICogICAgICAgICAgPiAwIGlmIHRoZSBpdGVtIGlzIHRoZSBpdGVtIHlvdSdyZSBsb29raW5nIGZvci5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIHsqfSBUaGUgb2JqZWN0IGlmIGl0IGlzIGZvdW5kIG9yIG51bGwgb3RoZXJ3aXNlLlxyXG4gICAgICovXHJcbiAgICBzZWFyY2g6IGZ1bmN0aW9uKGxpc3QsIGNvbXBhcmlzb25GdW5jdGlvbikge1xyXG4gICAgICAgIHZhciBtaW5JbmRleCA9IDA7XHJcbiAgICAgICAgdmFyIG1heEluZGV4ID0gbGlzdC5sZW5ndGggLSAxO1xyXG4gICAgICAgIHZhciBjdXJyZW50SW5kZXggPSBudWxsO1xyXG4gICAgICAgIHZhciBjdXJyZW50RWxlbWVudCA9IG51bGw7XHJcbiAgICAgXHJcbiAgICAgICAgd2hpbGUgKG1pbkluZGV4IDw9IG1heEluZGV4KSB7XHJcbiAgICAgICAgICAgIGN1cnJlbnRJbmRleCA9IChtaW5JbmRleCArIG1heEluZGV4KSAvIDIgfCAwO1xyXG4gICAgICAgICAgICBjdXJyZW50RWxlbWVudCA9IGxpc3RbY3VycmVudEluZGV4XTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHZhciBjb21wYXJpc29uUmVzdWx0ID0gY29tcGFyaXNvbkZ1bmN0aW9uKGN1cnJlbnRFbGVtZW50KTtcclxuICAgICAgICAgICAgaWYgKGNvbXBhcmlzb25SZXN1bHQgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBtaW5JbmRleCA9IGN1cnJlbnRJbmRleCArIDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY29tcGFyaXNvblJlc3VsdCA8IDApIHtcclxuICAgICAgICAgICAgICAgIG1heEluZGV4ID0gY3VycmVudEluZGV4IC0gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjdXJyZW50RWxlbWVudDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICBcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQmluYXJ5U2VhcmNoO1xyXG4iLCIvKipcclxuICpcclxuICogVGhpcyBjb2RlIHdhcyBwb3J0ZWQgZnJvbSB0aGUgZGFzaC5qcyBwcm9qZWN0IGF0OlxyXG4gKiAgIGh0dHBzOi8vZ2l0aHViLmNvbS9EYXNoLUluZHVzdHJ5LUZvcnVtL2Rhc2guanMvYmxvYi9kZXZlbG9wbWVudC9leHRlcm5hbHMvY2VhNjA4LXBhcnNlci5qc1xyXG4gKiAgIGh0dHBzOi8vZ2l0aHViLmNvbS9EYXNoLUluZHVzdHJ5LUZvcnVtL2Rhc2guanMvY29tbWl0LzgyNjliMjZhNzYxZTA4NTNiYjIxZDc4NzgwZWQ5NDUxNDRlY2RkNGQjZGlmZi03MWJjMjk1YTJkNmI2YjcwOTNhMWQzMjkwZDUzYTRiMlxyXG4gKlxyXG4gKiBUaGUgb3JpZ2luYWwgY29weXJpZ2h0IGFwcGVhcnMgYmVsb3c6XHJcbiAqXHJcbiAqIFRoZSBjb3B5cmlnaHQgaW4gdGhpcyBzb2Z0d2FyZSBpcyBiZWluZyBtYWRlIGF2YWlsYWJsZSB1bmRlciB0aGUgQlNEIExpY2Vuc2UsXHJcbiAqIGluY2x1ZGVkIGJlbG93LiBUaGlzIHNvZnR3YXJlIG1heSBiZSBzdWJqZWN0IHRvIG90aGVyIHRoaXJkIHBhcnR5IGFuZCBjb250cmlidXRvclxyXG4gKiByaWdodHMsIGluY2x1ZGluZyBwYXRlbnQgcmlnaHRzLCBhbmQgbm8gc3VjaCByaWdodHMgYXJlIGdyYW50ZWQgdW5kZXIgdGhpcyBsaWNlbnNlLlxyXG4gKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUtMjAxNiwgREFTSCBJbmR1c3RyeSBGb3J1bS5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0IG1vZGlmaWNhdGlvbixcclxuICogYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxyXG4gKiAgMS4gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzXHJcbiAqICBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cclxuICogICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxyXG4gKiAgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3JcclxuICogIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXHJcbiAqICAyLiBOZWl0aGVyIHRoZSBuYW1lIG9mIERhc2ggSW5kdXN0cnkgRm9ydW0gbm9yIHRoZSBuYW1lcyBvZiBpdHNcclxuICogIGNvbnRyaWJ1dG9ycyBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmVcclxuICogIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxyXG4gKlxyXG4gKiAgVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBBUyBJUyBBTkQgQU5ZXHJcbiAqICBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEXHJcbiAqICBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuXHJcbiAqICBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIEhPTERFUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULFxyXG4gKiAgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVFxyXG4gKiAgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUlxyXG4gKiAgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksXHJcbiAqICBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpXHJcbiAqICBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRVxyXG4gKiAgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXHJcbiAqL1xyXG4gICAgLyoqXHJcbiAgICAgKiAgRXhjZXB0aW9ucyBmcm9tIHJlZ3VsYXIgQVNDSUkuIENvZGVQb2ludHMgYXJlIG1hcHBlZCB0byBVVEYtMTYgY29kZXNcclxuICAgICAqL1xyXG5cclxudmFyIHNwZWNpYWxDZWE2MDhDaGFyc0NvZGVzID0ge1xyXG4gICAgMHgyYSA6IDB4ZTEsIC8vIGxvd2VyY2FzZSBhLCBhY3V0ZSBhY2NlbnRcclxuICAgIDB4NWMgOiAweGU5LCAvLyBsb3dlcmNhc2UgZSwgYWN1dGUgYWNjZW50XHJcbiAgICAweDVlIDogMHhlZCwgLy8gbG93ZXJjYXNlIGksIGFjdXRlIGFjY2VudFxyXG4gICAgMHg1ZiA6IDB4ZjMsIC8vIGxvd2VyY2FzZSBvLCBhY3V0ZSBhY2NlbnRcclxuICAgIDB4NjAgOiAweGZhLCAvLyBsb3dlcmNhc2UgdSwgYWN1dGUgYWNjZW50XHJcbiAgICAweDdiIDogMHhlNywgLy8gbG93ZXJjYXNlIGMgd2l0aCBjZWRpbGxhXHJcbiAgICAweDdjIDogMHhmNywgLy8gZGl2aXNpb24gc3ltYm9sXHJcbiAgICAweDdkIDogMHhkMSwgLy8gdXBwZXJjYXNlIE4gdGlsZGVcclxuICAgIDB4N2UgOiAweGYxLCAvLyBsb3dlcmNhc2UgbiB0aWxkZVxyXG4gICAgMHg3ZiA6IDB4MjU4OCwgLy8gRnVsbCBibG9ja1xyXG4gICAgLy8gVEhJUyBCTE9DSyBJTkNMVURFUyBUSEUgMTYgRVhURU5ERUQgKFRXTy1CWVRFKSBMSU5FIDIxIENIQVJBQ1RFUlNcclxuICAgIC8vIFRIQVQgQ09NRSBGUk9NIEhJIEJZVEU9MHgxMSBBTkQgTE9XIEJFVFdFRU4gMHgzMCBBTkQgMHgzRlxyXG4gICAgLy8gVEhJUyBNRUFOUyBUSEFUIFxceDUwIE1VU1QgQkUgQURERUQgVE8gVEhFIFZBTFVFU1xyXG4gICAgMHg4MCA6IDB4YWUsIC8vIFJlZ2lzdGVyZWQgc3ltYm9sIChSKVxyXG4gICAgMHg4MSA6IDB4YjAsIC8vIGRlZ3JlZSBzaWduXHJcbiAgICAweDgyIDogMHhiZCwgLy8gMS8yIHN5bWJvbFxyXG4gICAgMHg4MyA6IDB4YmYsIC8vIEludmVydGVkIChvcGVuKSBxdWVzdGlvbiBtYXJrXHJcbiAgICAweDg0IDogMHgyMTIyLCAvLyBUcmFkZW1hcmsgc3ltYm9sIChUTSlcclxuICAgIDB4ODUgOiAweGEyLCAvLyBDZW50cyBzeW1ib2xcclxuICAgIDB4ODYgOiAweGEzLCAvLyBQb3VuZHMgc3RlcmxpbmdcclxuICAgIDB4ODcgOiAweDI2NmEsIC8vIE11c2ljIDgndGggbm90ZVxyXG4gICAgMHg4OCA6IDB4ZTAsIC8vIGxvd2VyY2FzZSBhLCBncmF2ZSBhY2NlbnRcclxuICAgIDB4ODkgOiAweDIwLCAvLyB0cmFuc3BhcmVudCBzcGFjZSAocmVndWxhcilcclxuICAgIDB4OGEgOiAweGU4LCAvLyBsb3dlcmNhc2UgZSwgZ3JhdmUgYWNjZW50XHJcbiAgICAweDhiIDogMHhlMiwgLy8gbG93ZXJjYXNlIGEsIGNpcmN1bWZsZXggYWNjZW50XHJcbiAgICAweDhjIDogMHhlYSwgLy8gbG93ZXJjYXNlIGUsIGNpcmN1bWZsZXggYWNjZW50XHJcbiAgICAweDhkIDogMHhlZSwgLy8gbG93ZXJjYXNlIGksIGNpcmN1bWZsZXggYWNjZW50XHJcbiAgICAweDhlIDogMHhmNCwgLy8gbG93ZXJjYXNlIG8sIGNpcmN1bWZsZXggYWNjZW50XHJcbiAgICAweDhmIDogMHhmYiwgLy8gbG93ZXJjYXNlIHUsIGNpcmN1bWZsZXggYWNjZW50XHJcbiAgICAvLyBUSElTIEJMT0NLIElOQ0xVREVTIFRIRSAzMiBFWFRFTkRFRCAoVFdPLUJZVEUpIExJTkUgMjEgQ0hBUkFDVEVSU1xyXG4gICAgLy8gVEhBVCBDT01FIEZST00gSEkgQllURT0weDEyIEFORCBMT1cgQkVUV0VFTiAweDIwIEFORCAweDNGXHJcbiAgICAweDkwIDogMHhjMSwgLy8gY2FwaXRhbCBsZXR0ZXIgQSB3aXRoIGFjdXRlXHJcbiAgICAweDkxIDogMHhjOSwgLy8gY2FwaXRhbCBsZXR0ZXIgRSB3aXRoIGFjdXRlXHJcbiAgICAweDkyIDogMHhkMywgLy8gY2FwaXRhbCBsZXR0ZXIgTyB3aXRoIGFjdXRlXHJcbiAgICAweDkzIDogMHhkYSwgLy8gY2FwaXRhbCBsZXR0ZXIgVSB3aXRoIGFjdXRlXHJcbiAgICAweDk0IDogMHhkYywgLy8gY2FwaXRhbCBsZXR0ZXIgVSB3aXRoIGRpYXJlc2lzXHJcbiAgICAweDk1IDogMHhmYywgLy8gbG93ZXJjYXNlIGxldHRlciBVIHdpdGggZGlhZXJlc2lzXHJcbiAgICAweDk2IDogMHgyMDE4LCAvLyBvcGVuaW5nIHNpbmdsZSBxdW90ZVxyXG4gICAgMHg5NyA6IDB4YTEsIC8vIGludmVydGVkIGV4Y2xhbWF0aW9uIG1hcmtcclxuICAgIDB4OTggOiAweDJhLCAvLyBhc3Rlcmlza1xyXG4gICAgMHg5OSA6IDB4MjAxOSwgLy8gY2xvc2luZyBzaW5nbGUgcXVvdGVcclxuICAgIDB4OWEgOiAweDI1MDEsIC8vIGJveCBkcmF3aW5ncyBoZWF2eSBob3Jpem9udGFsXHJcbiAgICAweDliIDogMHhhOSwgLy8gY29weXJpZ2h0IHNpZ25cclxuICAgIDB4OWMgOiAweDIxMjAsIC8vIFNlcnZpY2UgbWFya1xyXG4gICAgMHg5ZCA6IDB4MjAyMiwgLy8gKHJvdW5kKSBidWxsZXRcclxuICAgIDB4OWUgOiAweDIwMWMsIC8vIExlZnQgZG91YmxlIHF1b3RhdGlvbiBtYXJrXHJcbiAgICAweDlmIDogMHgyMDFkLCAvLyBSaWdodCBkb3VibGUgcXVvdGF0aW9uIG1hcmtcclxuICAgIDB4YTAgOiAweGMwLCAvLyB1cHBlcmNhc2UgQSwgZ3JhdmUgYWNjZW50XHJcbiAgICAweGExIDogMHhjMiwgLy8gdXBwZXJjYXNlIEEsIGNpcmN1bWZsZXhcclxuICAgIDB4YTIgOiAweGM3LCAvLyB1cHBlcmNhc2UgQyB3aXRoIGNlZGlsbGFcclxuICAgIDB4YTMgOiAweGM4LCAvLyB1cHBlcmNhc2UgRSwgZ3JhdmUgYWNjZW50XHJcbiAgICAweGE0IDogMHhjYSwgLy8gdXBwZXJjYXNlIEUsIGNpcmN1bWZsZXhcclxuICAgIDB4YTUgOiAweGNiLCAvLyBjYXBpdGFsIGxldHRlciBFIHdpdGggZGlhcmVzaXNcclxuICAgIDB4YTYgOiAweGViLCAvLyBsb3dlcmNhc2UgbGV0dGVyIGUgd2l0aCBkaWFyZXNpc1xyXG4gICAgMHhhNyA6IDB4Y2UsIC8vIHVwcGVyY2FzZSBJLCBjaXJjdW1mbGV4XHJcbiAgICAweGE4IDogMHhjZiwgLy8gdXBwZXJjYXNlIEksIHdpdGggZGlhcmVzaXNcclxuICAgIDB4YTkgOiAweGVmLCAvLyBsb3dlcmNhc2UgaSwgd2l0aCBkaWFyZXNpc1xyXG4gICAgMHhhYSA6IDB4ZDQsIC8vIHVwcGVyY2FzZSBPLCBjaXJjdW1mbGV4XHJcbiAgICAweGFiIDogMHhkOSwgLy8gdXBwZXJjYXNlIFUsIGdyYXZlIGFjY2VudFxyXG4gICAgMHhhYyA6IDB4ZjksIC8vIGxvd2VyY2FzZSB1LCBncmF2ZSBhY2NlbnRcclxuICAgIDB4YWQgOiAweGRiLCAvLyB1cHBlcmNhc2UgVSwgY2lyY3VtZmxleFxyXG4gICAgMHhhZSA6IDB4YWIsIC8vIGxlZnQtcG9pbnRpbmcgZG91YmxlIGFuZ2xlIHF1b3RhdGlvbiBtYXJrXHJcbiAgICAweGFmIDogMHhiYiwgLy8gcmlnaHQtcG9pbnRpbmcgZG91YmxlIGFuZ2xlIHF1b3RhdGlvbiBtYXJrXHJcbiAgICAvLyBUSElTIEJMT0NLIElOQ0xVREVTIFRIRSAzMiBFWFRFTkRFRCAoVFdPLUJZVEUpIExJTkUgMjEgQ0hBUkFDVEVSU1xyXG4gICAgLy8gVEhBVCBDT01FIEZST00gSEkgQllURT0weDEzIEFORCBMT1cgQkVUV0VFTiAweDIwIEFORCAweDNGXHJcbiAgICAweGIwIDogMHhjMywgLy8gVXBwZXJjYXNlIEEsIHRpbGRlXHJcbiAgICAweGIxIDogMHhlMywgLy8gTG93ZXJjYXNlIGEsIHRpbGRlXHJcbiAgICAweGIyIDogMHhjZCwgLy8gVXBwZXJjYXNlIEksIGFjdXRlIGFjY2VudFxyXG4gICAgMHhiMyA6IDB4Y2MsIC8vIFVwcGVyY2FzZSBJLCBncmF2ZSBhY2NlbnRcclxuICAgIDB4YjQgOiAweGVjLCAvLyBMb3dlcmNhc2UgaSwgZ3JhdmUgYWNjZW50XHJcbiAgICAweGI1IDogMHhkMiwgLy8gVXBwZXJjYXNlIE8sIGdyYXZlIGFjY2VudFxyXG4gICAgMHhiNiA6IDB4ZjIsIC8vIExvd2VyY2FzZSBvLCBncmF2ZSBhY2NlbnRcclxuICAgIDB4YjcgOiAweGQ1LCAvLyBVcHBlcmNhc2UgTywgdGlsZGVcclxuICAgIDB4YjggOiAweGY1LCAvLyBMb3dlcmNhc2UgbywgdGlsZGVcclxuICAgIDB4YjkgOiAweDdiLCAvLyBPcGVuIGN1cmx5IGJyYWNlXHJcbiAgICAweGJhIDogMHg3ZCwgLy8gQ2xvc2luZyBjdXJseSBicmFjZVxyXG4gICAgMHhiYiA6IDB4NWMsIC8vIEJhY2tzbGFzaFxyXG4gICAgMHhiYyA6IDB4NWUsIC8vIENhcmV0XHJcbiAgICAweGJkIDogMHg1ZiwgLy8gVW5kZXJzY29yZVxyXG4gICAgMHhiZSA6IDB4N2MsIC8vIFBpcGUgKHZlcnRpY2FsIGxpbmUpXHJcbiAgICAweGJmIDogMHgyMjNjLCAvLyBUaWxkZSBvcGVyYXRvclxyXG4gICAgMHhjMCA6IDB4YzQsIC8vIFVwcGVyY2FzZSBBLCB1bWxhdXRcclxuICAgIDB4YzEgOiAweGU0LCAvLyBMb3dlcmNhc2UgQSwgdW1sYXV0XHJcbiAgICAweGMyIDogMHhkNiwgLy8gVXBwZXJjYXNlIE8sIHVtbGF1dFxyXG4gICAgMHhjMyA6IDB4ZjYsIC8vIExvd2VyY2FzZSBvLCB1bWxhdXRcclxuICAgIDB4YzQgOiAweGRmLCAvLyBFc3N6ZXR0IChzaGFycCBTKVxyXG4gICAgMHhjNSA6IDB4YTUsIC8vIFllbiBzeW1ib2xcclxuICAgIDB4YzYgOiAweGE0LCAvLyBHZW5lcmljIGN1cnJlbmN5IHNpZ25cclxuICAgIDB4YzcgOiAweDI1MDMsIC8vIEJveCBkcmF3aW5ncyBoZWF2eSB2ZXJ0aWNhbFxyXG4gICAgMHhjOCA6IDB4YzUsIC8vIFVwcGVyY2FzZSBBLCByaW5nXHJcbiAgICAweGM5IDogMHhlNSwgLy8gTG93ZXJjYXNlIEEsIHJpbmdcclxuICAgIDB4Y2EgOiAweGQ4LCAvLyBVcHBlcmNhc2UgTywgc3Ryb2tlXHJcbiAgICAweGNiIDogMHhmOCwgLy8gTG93ZXJjYXNlIG8sIHN0cm9rXHJcbiAgICAweGNjIDogMHgyNTBmLCAvLyBCb3ggZHJhd2luZ3MgaGVhdnkgZG93biBhbmQgcmlnaHRcclxuICAgIDB4Y2QgOiAweDI1MTMsIC8vIEJveCBkcmF3aW5ncyBoZWF2eSBkb3duIGFuZCBsZWZ0XHJcbiAgICAweGNlIDogMHgyNTE3LCAvLyBCb3ggZHJhd2luZ3MgaGVhdnkgdXAgYW5kIHJpZ2h0XHJcbiAgICAweGNmIDogMHgyNTFiIC8vIEJveCBkcmF3aW5ncyBoZWF2eSB1cCBhbmQgbGVmdFxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFV0aWxzXHJcbiAqL1xyXG52YXIgZ2V0Q2hhckZvckJ5dGUgPSBmdW5jdGlvbihieXRlKSB7XHJcbiAgICB2YXIgY2hhckNvZGUgPSBieXRlO1xyXG4gICAgaWYgKHNwZWNpYWxDZWE2MDhDaGFyc0NvZGVzLmhhc093blByb3BlcnR5KGJ5dGUpKSB7XHJcbiAgICAgICAgY2hhckNvZGUgPSBzcGVjaWFsQ2VhNjA4Q2hhcnNDb2Rlc1tieXRlXTtcclxuICAgIH1cclxuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoYXJDb2RlKTtcclxufTtcclxuXHJcbnZhciBOUl9ST1dTID0gMTUsXHJcbiAgICBOUl9DT0xTID0gMTAwO1xyXG4vLyBUYWJsZXMgdG8gbG9vayB1cCByb3cgZnJvbSBQQUMgZGF0YVxyXG52YXIgcm93c0xvd0NoMSA9IHsweDExIDogMSwgMHgxMiA6IDMsIDB4MTUgOiA1LCAweDE2IDogNywgMHgxNyA6IDksIDB4MTAgOiAxMSwgMHgxMyA6IDEyLCAweDE0IDogMTR9O1xyXG52YXIgcm93c0hpZ2hDaDEgPSB7MHgxMSA6IDIsIDB4MTIgOiA0LCAweDE1IDogNiwgMHgxNiA6IDgsIDB4MTcgOiAxMCwgMHgxMyA6IDEzLCAweDE0IDogMTV9O1xyXG52YXIgcm93c0xvd0NoMiA9IHsweDE5IDogMSwgMHgxQSA6IDMsIDB4MUQgOiA1LCAweDFFIDogNywgMHgxRiA6IDksIDB4MTggOiAxMSwgMHgxQiA6IDEyLCAweDFDIDogMTR9O1xyXG52YXIgcm93c0hpZ2hDaDIgPSB7MHgxOSA6IDIsIDB4MUEgOiA0LCAweDFEIDogNiwgMHgxRSA6IDgsIDB4MUYgOiAxMCwgMHgxQiA6IDEzLCAweDFDIDogMTV9O1xyXG5cclxudmFyIGJhY2tncm91bmRDb2xvcnMgPSBbJ3doaXRlJywgJ2dyZWVuJywgJ2JsdWUnLCAnY3lhbicsICdyZWQnLCAneWVsbG93JywgJ21hZ2VudGEnLCAnYmxhY2snLCAndHJhbnNwYXJlbnQnXTtcclxuXHJcbi8qKlxyXG4gKiBTaW1wbGUgbG9nZ2VyIGNsYXNzIHRvIGJlIGFibGUgdG8gd3JpdGUgd2l0aCB0aW1lLXN0YW1wcyBhbmQgZmlsdGVyIG9uIGxldmVsLlxyXG4gKi9cclxudmFyIGxvZ2dlciA9IHtcclxuICAgIHZlcmJvc2VGaWx0ZXIgOiB7J0RBVEEnIDogMywgJ0RFQlVHJyA6IDMsICdJTkZPJyA6IDIsICdXQVJOSU5HJyA6IDIsICdURVhUJyA6IDEsICdFUlJPUicgOiAwfSxcclxuICAgIHRpbWUgOiBudWxsLFxyXG4gICAgdmVyYm9zZUxldmVsIDogMCwgLy8gT25seSB3cml0ZSBlcnJvcnNcclxuICAgIHNldFRpbWUgOiBmdW5jdGlvbihuZXdUaW1lKSB7XHJcbiAgICAgICAgdGhpcy50aW1lID0gbmV3VGltZTtcclxuICAgIH0sXHJcbiAgICBsb2cgOiBmdW5jdGlvbihzZXZlcml0eSwgbXNnKSB7XHJcbiAgICAgICAgdmFyIG1pbkxldmVsID0gdGhpcy52ZXJib3NlRmlsdGVyW3NldmVyaXR5XTtcclxuICAgICAgICBpZiAodGhpcy52ZXJib3NlTGV2ZWwgPj0gbWluTGV2ZWwpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2codGhpcy50aW1lICsgJyBbJyArIHNldmVyaXR5ICsgJ10gJyArIG1zZyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5cclxudmFyIG51bUFycmF5VG9IZXhBcnJheSA9IGZ1bmN0aW9uKG51bUFycmF5KSB7XHJcbiAgICB2YXIgaGV4QXJyYXkgPSBbXTtcclxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgbnVtQXJyYXkubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICBoZXhBcnJheS5wdXNoKG51bUFycmF5W2pdLnRvU3RyaW5nKDE2KSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaGV4QXJyYXk7XHJcbn07XHJcblxyXG5jbGFzcyBQZW5TdGF0ZSB7XHJcblxyXG4gICAgY29uc3RydWN0b3IoZm9yZWdyb3VuZCwgdW5kZXJsaW5lLCBpdGFsaWNzLCBiYWNrZ3JvdW5kLCBmbGFzaCkge1xyXG4gICAgICAgIHRoaXMuZm9yZWdyb3VuZCA9IGZvcmVncm91bmQgfHwgJ3doaXRlJztcclxuICAgICAgICB0aGlzLnVuZGVybGluZSA9IHVuZGVybGluZSB8fCBmYWxzZTtcclxuICAgICAgICB0aGlzLml0YWxpY3MgPSBpdGFsaWNzIHx8IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuYmFja2dyb3VuZCA9IGJhY2tncm91bmQgfHwgJ2JsYWNrJztcclxuICAgICAgICB0aGlzLmZsYXNoID0gZmxhc2ggfHwgZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgcmVzZXQoKSB7XHJcbiAgICAgICAgdGhpcy5mb3JlZ3JvdW5kID0gJ3doaXRlJztcclxuICAgICAgICB0aGlzLnVuZGVybGluZSA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuaXRhbGljcyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuYmFja2dyb3VuZCA9ICdibGFjayc7XHJcbiAgICAgICAgdGhpcy5mbGFzaCA9IGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIHNldFN0eWxlcyhzdHlsZXMpIHtcclxuICAgICAgICB2YXIgYXR0cmlicyA9IFsnZm9yZWdyb3VuZCcsICd1bmRlcmxpbmUnLCAnaXRhbGljcycsICdiYWNrZ3JvdW5kJywgJ2ZsYXNoJ107XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAgOyBpIDwgYXR0cmlicy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgc3R5bGUgPSBhdHRyaWJzW2ldO1xyXG4gICAgICAgICAgICBpZiAoc3R5bGVzLmhhc093blByb3BlcnR5KHN0eWxlKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpc1tzdHlsZV0gPSBzdHlsZXNbc3R5bGVdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlzRGVmYXVsdCgpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMuZm9yZWdyb3VuZCA9PT0gJ3doaXRlJyAmJiAhdGhpcy51bmRlcmxpbmUgJiYgIXRoaXMuaXRhbGljcyAmJlxyXG4gICAgICAgICAgICAgICAgdGhpcy5iYWNrZ3JvdW5kID09PSAnYmxhY2snICYmICF0aGlzLmZsYXNoKTtcclxuICAgIH1cclxuXHJcbiAgICBlcXVhbHMob3RoZXIpIHtcclxuICAgICAgICByZXR1cm4gKCAodGhpcy5mb3JlZ3JvdW5kID09PSBvdGhlci5mb3JlZ3JvdW5kKSAmJlxyXG4gICAgICAgICAgICAgICAgICh0aGlzLnVuZGVybGluZSA9PT0gb3RoZXIudW5kZXJsaW5lKSAmJlxyXG4gICAgICAgICAgICAgICAgICh0aGlzLml0YWxpY3MgPT09IG90aGVyLml0YWxpY3MpICYmXHJcbiAgICAgICAgICAgICAgICAgKHRoaXMuYmFja2dyb3VuZCA9PT0gb3RoZXIuYmFja2dyb3VuZCkgJiZcclxuICAgICAgICAgICAgICAgICAodGhpcy5mbGFzaCA9PT0gb3RoZXIuZmxhc2gpICk7XHJcbiAgICB9XHJcblxyXG4gICAgY29weShuZXdQZW5TdGF0ZSkge1xyXG4gICAgICAgIHRoaXMuZm9yZWdyb3VuZCA9IG5ld1BlblN0YXRlLmZvcmVncm91bmQ7XHJcbiAgICAgICAgdGhpcy51bmRlcmxpbmUgPSBuZXdQZW5TdGF0ZS51bmRlcmxpbmU7XHJcbiAgICAgICAgdGhpcy5pdGFsaWNzID0gbmV3UGVuU3RhdGUuaXRhbGljcztcclxuICAgICAgICB0aGlzLmJhY2tncm91bmQgPSBuZXdQZW5TdGF0ZS5iYWNrZ3JvdW5kO1xyXG4gICAgICAgIHRoaXMuZmxhc2ggPSBuZXdQZW5TdGF0ZS5mbGFzaDtcclxuICAgIH1cclxuXHJcbiAgICB0b1N0cmluZygpIHtcclxuICAgICAgICByZXR1cm4gKCdjb2xvcj0nICsgdGhpcy5mb3JlZ3JvdW5kICsgJywgdW5kZXJsaW5lPScgKyB0aGlzLnVuZGVybGluZSArICcsIGl0YWxpY3M9JyArIHRoaXMuaXRhbGljcyArXHJcbiAgICAgICAgICAgICcsIGJhY2tncm91bmQ9JyArIHRoaXMuYmFja2dyb3VuZCArICcsIGZsYXNoPScgKyB0aGlzLmZsYXNoKTtcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFVuaWNvZGUgY2hhcmFjdGVyIHdpdGggc3R5bGluZyBhbmQgYmFja2dyb3VuZC5cclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG5jbGFzcyBTdHlsZWRVbmljb2RlQ2hhclxyXG57XHJcblxyXG4gICAgY29uc3RydWN0b3IodWNoYXIsIGZvcmVncm91bmQsIHVuZGVybGluZSwgaXRhbGljcywgYmFja2dyb3VuZCwgZmxhc2gpIHtcclxuICAgICAgICB0aGlzLnVjaGFyID0gdWNoYXIgfHwgJyAnOyAvLyB1bmljb2RlIGNoYXJhY3RlclxyXG4gICAgICAgIHRoaXMucGVuU3RhdGUgPSBuZXcgUGVuU3RhdGUoZm9yZWdyb3VuZCwgdW5kZXJsaW5lLGl0YWxpY3MsIGJhY2tncm91bmQsIGZsYXNoKTtcclxuICAgIH1cclxuXHJcbiAgICByZXNldCgpIHtcclxuICAgICAgICB0aGlzLnVjaGFyID0gJyAnO1xyXG4gICAgICAgIHRoaXMucGVuU3RhdGUucmVzZXQoKTtcclxuICAgIH1cclxuXHJcbiAgICBzZXRDaGFyKHVjaGFyLCBuZXdQZW5TdGF0ZSkge1xyXG4gICAgICAgIHRoaXMudWNoYXIgPSB1Y2hhcjtcclxuICAgICAgICB0aGlzLnBlblN0YXRlLmNvcHkobmV3UGVuU3RhdGUpO1xyXG4gICAgfVxyXG5cclxuICAgIHNldFBlblN0YXRlKG5ld1BlblN0YXRlKSB7XHJcbiAgICAgICAgdGhpcy5wZW5TdGF0ZS5jb3B5KG5ld1BlblN0YXRlKTtcclxuICAgIH1cclxuXHJcbiAgICBlcXVhbHMob3RoZXIpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy51Y2hhciA9PT0gb3RoZXIudWNoYXIgJiYgdGhpcy5wZW5TdGF0ZS5lcXVhbHMob3RoZXIucGVuU3RhdGUpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvcHkobmV3Q2hhcikge1xyXG4gICAgICAgIHRoaXMudWNoYXIgPSBuZXdDaGFyLnVjaGFyO1xyXG4gICAgICAgIHRoaXMucGVuU3RhdGUuY29weShuZXdDaGFyLnBlblN0YXRlKTtcclxuICAgIH1cclxuXHJcbiAgICBpc0VtcHR5KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnVjaGFyID09PSAnICcgJiYgdGhpcy5wZW5TdGF0ZS5pc0RlZmF1bHQoKTtcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIENFQS02MDggcm93IGNvbnNpc3Rpbmcgb2YgTlJfQ09MUyBpbnN0YW5jZXMgb2YgU3R5bGVkVW5pY29kZUNoYXIuXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKi9cclxuY2xhc3MgUm93IHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMuY2hhcnMgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMCA7IGkgPCBOUl9DT0xTIDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2hhcnMucHVzaChuZXcgU3R5bGVkVW5pY29kZUNoYXIoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucG9zID0gMDtcclxuICAgICAgICB0aGlzLmN1cnJQZW5TdGF0ZSA9IG5ldyBQZW5TdGF0ZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIGVxdWFscyhvdGhlcikge1xyXG4gICAgICAgIHZhciBlcXVhbCA9IHRydWU7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAgOyBpIDwgTlJfQ09MUzsgaSArKykge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuY2hhcnNbaV0uZXF1YWxzKG90aGVyLmNoYXJzW2ldKSkge1xyXG4gICAgICAgICAgICAgICAgZXF1YWwgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBlcXVhbDtcclxuICAgIH1cclxuXHJcbiAgICBjb3B5KG90aGVyKSB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAgOyBpIDwgTlJfQ09MUzsgaSArKykge1xyXG4gICAgICAgICAgICB0aGlzLmNoYXJzW2ldLmNvcHkob3RoZXIuY2hhcnNbaV0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpc0VtcHR5KCkge1xyXG4gICAgICAgIHZhciBlbXB0eSA9IHRydWU7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAgOyBpIDwgTlJfQ09MUzsgaSArKykge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuY2hhcnNbaV0uaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgICAgICBlbXB0eSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGVtcHR5O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogIFNldCB0aGUgY3Vyc29yIHRvIGEgdmFsaWQgY29sdW1uLlxyXG4gICAgICovXHJcbiAgICBzZXRDdXJzb3IoYWJzUG9zKSB7XHJcbiAgICAgICAgaWYgKHRoaXMucG9zICE9PSBhYnNQb3MpIHtcclxuICAgICAgICAgICAgdGhpcy5wb3MgPSBhYnNQb3M7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnBvcyA8IDApIHtcclxuICAgICAgICAgICAgbG9nZ2VyLmxvZygnRVJST1InLCAnTmVnYXRpdmUgY3Vyc29yIHBvc2l0aW9uICcgKyB0aGlzLnBvcyk7XHJcbiAgICAgICAgICAgIHRoaXMucG9zID0gMDtcclxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMucG9zID4gTlJfQ09MUykge1xyXG4gICAgICAgICAgICBsb2dnZXIubG9nKCdFUlJPUicsICdUb28gbGFyZ2UgY3Vyc29yIHBvc2l0aW9uICcgKyB0aGlzLnBvcyk7XHJcbiAgICAgICAgICAgIHRoaXMucG9zID0gTlJfQ09MUztcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNb3ZlIHRoZSBjdXJzb3IgcmVsYXRpdmUgdG8gY3VycmVudCBwb3NpdGlvbi5cclxuICAgICAqL1xyXG4gICAgbW92ZUN1cnNvcihyZWxQb3MpIHtcclxuICAgICAgICB2YXIgbmV3UG9zID0gdGhpcy5wb3MgKyByZWxQb3M7XHJcbiAgICAgICAgaWYgKHJlbFBvcyA+IDEpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMucG9zKzE7IGkgPCBuZXdQb3MrMSA7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jaGFyc1tpXS5zZXRQZW5TdGF0ZSh0aGlzLmN1cnJQZW5TdGF0ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zZXRDdXJzb3IobmV3UG9zKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEJhY2tzcGFjZSwgbW92ZSBvbmUgc3RlcCBiYWNrIGFuZCBjbGVhciBjaGFyYWN0ZXIuXHJcbiAgICAgKi9cclxuICAgIGJhY2tTcGFjZSgpIHtcclxuICAgICAgICB0aGlzLm1vdmVDdXJzb3IoLTEpO1xyXG4gICAgICAgIHRoaXMuY2hhcnNbdGhpcy5wb3NdLnNldENoYXIoJyAnLCB0aGlzLmN1cnJQZW5TdGF0ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgaW5zZXJ0Q2hhcihieXRlKSB7XHJcbiAgICAgICAgaWYgKGJ5dGUgPj0gMHg5MCkgeyAvL0V4dGVuZGVkIGNoYXJcclxuICAgICAgICAgICAgdGhpcy5iYWNrU3BhY2UoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGNoYXIgPSBnZXRDaGFyRm9yQnl0ZShieXRlKTtcclxuICAgICAgICBpZiAodGhpcy5wb3MgPj0gTlJfQ09MUykge1xyXG4gICAgICAgICAgICBsb2dnZXIubG9nKCdFUlJPUicsICdDYW5ub3QgaW5zZXJ0ICcgKyBieXRlLnRvU3RyaW5nKDE2KSArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICcgKCcgKyBjaGFyICsgJykgYXQgcG9zaXRpb24gJyArIHRoaXMucG9zICsgJy4gU2tpcHBpbmcgaXQhJyk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jaGFyc1t0aGlzLnBvc10uc2V0Q2hhcihjaGFyLCB0aGlzLmN1cnJQZW5TdGF0ZSk7XHJcbiAgICAgICAgdGhpcy5tb3ZlQ3Vyc29yKDEpO1xyXG4gICAgfVxyXG5cclxuICAgIGNsZWFyRnJvbVBvcyhzdGFydFBvcykge1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIGZvciAoaSA9IHN0YXJ0UG9zIDsgaSA8IE5SX0NPTFMgOyBpKyspIHtcclxuICAgICAgICAgICAgdGhpcy5jaGFyc1tpXS5yZXNldCgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBjbGVhcigpIHtcclxuICAgICAgICB0aGlzLmNsZWFyRnJvbVBvcygwKTtcclxuICAgICAgICB0aGlzLnBvcyA9IDA7XHJcbiAgICAgICAgdGhpcy5jdXJyUGVuU3RhdGUucmVzZXQoKTtcclxuICAgIH1cclxuXHJcbiAgICBjbGVhclRvRW5kT2ZSb3coKSB7XHJcbiAgICAgICAgdGhpcy5jbGVhckZyb21Qb3ModGhpcy5wb3MpO1xyXG4gICAgfVxyXG5cclxuICAgIGdldFRleHRTdHJpbmcoKSB7XHJcbiAgICAgICAgdmFyIGNoYXJzID0gW107XHJcbiAgICAgICAgdmFyIGVtcHR5ID0gdHJ1ZTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMCA7IGkgPCBOUl9DT0xTIDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBjaGFyID0gdGhpcy5jaGFyc1tpXS51Y2hhcjtcclxuICAgICAgICAgICAgaWYgKGNoYXIgIT09ICcgJykge1xyXG4gICAgICAgICAgICAgICAgZW1wdHkgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjaGFycy5wdXNoKGNoYXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZW1wdHkpIHtcclxuICAgICAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjaGFycy5qb2luKCcnKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgc2V0UGVuU3R5bGVzKHN0eWxlcykge1xyXG4gICAgICAgIHRoaXMuY3VyclBlblN0YXRlLnNldFN0eWxlcyhzdHlsZXMpO1xyXG4gICAgICAgIHZhciBjdXJyQ2hhciA9IHRoaXMuY2hhcnNbdGhpcy5wb3NdO1xyXG4gICAgICAgIGN1cnJDaGFyLnNldFBlblN0YXRlKHRoaXMuY3VyclBlblN0YXRlKTtcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEtlZXAgYSBDRUEtNjA4IHNjcmVlbiBvZiAzMngxNSBzdHlsZWQgY2hhcmFjdGVyc1xyXG4gKiBAY29uc3RydWN0b3JcclxuKi9cclxuY2xhc3MgQ2FwdGlvblNjcmVlbiB7XHJcblxyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5yb3dzID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAgOyBpIDwgIE5SX1JPV1M7IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzLnJvd3MucHVzaChuZXcgUm93KCkpOyAvLyBOb3RlIHRoYXQgd2UgdXNlIHplcm8tYmFzZWQgbnVtYmVyaW5nICgwLTE0KVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmN1cnJSb3cgPSBOUl9ST1dTIC0gMTtcclxuICAgICAgICB0aGlzLm5yUm9sbFVwUm93cyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5yZXNldCgpO1xyXG4gICAgfVxyXG5cclxuICAgIHJlc2V0KCkge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwIDsgaSA8IE5SX1JPV1MgOyBpKyspIHtcclxuICAgICAgICAgICAgdGhpcy5yb3dzW2ldLmNsZWFyKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY3VyclJvdyA9IE5SX1JPV1MgLSAxO1xyXG4gICAgfVxyXG5cclxuICAgIGVxdWFscyhvdGhlcikge1xyXG4gICAgICAgIHZhciBlcXVhbCA9IHRydWU7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAgOyBpIDwgTlJfUk9XUyA7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMucm93c1tpXS5lcXVhbHMob3RoZXIucm93c1tpXSkpIHtcclxuICAgICAgICAgICAgICAgIGVxdWFsID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZXF1YWw7XHJcbiAgICB9XHJcblxyXG4gICAgY29weShvdGhlcikge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwIDsgaSA8IE5SX1JPV1MgOyBpKyspIHtcclxuICAgICAgICAgICAgdGhpcy5yb3dzW2ldLmNvcHkob3RoZXIucm93c1tpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlzRW1wdHkoKSB7XHJcbiAgICAgICAgdmFyIGVtcHR5ID0gdHJ1ZTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMCA7IGkgPCBOUl9ST1dTIDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5yb3dzW2ldLmlzRW1wdHkoKSkge1xyXG4gICAgICAgICAgICAgICAgZW1wdHkgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBlbXB0eTtcclxuICAgIH1cclxuXHJcbiAgICBiYWNrU3BhY2UoKSB7XHJcbiAgICAgICAgdmFyIHJvdyA9IHRoaXMucm93c1t0aGlzLmN1cnJSb3ddO1xyXG4gICAgICAgIHJvdy5iYWNrU3BhY2UoKTtcclxuICAgIH1cclxuXHJcbiAgICBjbGVhclRvRW5kT2ZSb3coKSB7XHJcbiAgICAgICAgdmFyIHJvdyA9IHRoaXMucm93c1t0aGlzLmN1cnJSb3ddO1xyXG4gICAgICAgIHJvdy5jbGVhclRvRW5kT2ZSb3coKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEluc2VydCBhIGNoYXJhY3RlciAod2l0aG91dCBzdHlsaW5nKSBpbiB0aGUgY3VycmVudCByb3cuXHJcbiAgICAgKi9cclxuICAgIGluc2VydENoYXIoY2hhcikge1xyXG4gICAgICAgIHZhciByb3cgPSB0aGlzLnJvd3NbdGhpcy5jdXJyUm93XTtcclxuICAgICAgICByb3cuaW5zZXJ0Q2hhcihjaGFyKTtcclxuICAgIH1cclxuXHJcbiAgICBzZXRQZW4oc3R5bGVzKSB7XHJcbiAgICAgICAgdmFyIHJvdyA9IHRoaXMucm93c1t0aGlzLmN1cnJSb3ddO1xyXG4gICAgICAgIHJvdy5zZXRQZW5TdHlsZXMoc3R5bGVzKTtcclxuICAgIH1cclxuXHJcbiAgICBtb3ZlQ3Vyc29yKHJlbFBvcykge1xyXG4gICAgICAgIHZhciByb3cgPSB0aGlzLnJvd3NbdGhpcy5jdXJyUm93XTtcclxuICAgICAgICByb3cubW92ZUN1cnNvcihyZWxQb3MpO1xyXG4gICAgfVxyXG5cclxuICAgIHNldEN1cnNvcihhYnNQb3MpIHtcclxuICAgICAgICBsb2dnZXIubG9nKCdJTkZPJywgJ3NldEN1cnNvcjogJyArIGFic1Bvcyk7XHJcbiAgICAgICAgdmFyIHJvdyA9IHRoaXMucm93c1t0aGlzLmN1cnJSb3ddO1xyXG4gICAgICAgIHJvdy5zZXRDdXJzb3IoYWJzUG9zKTtcclxuICAgIH1cclxuXHJcbiAgICBzZXRQQUMocGFjRGF0YSkge1xyXG4gICAgICAgIGxvZ2dlci5sb2coJ0lORk8nLCAncGFjRGF0YSA9ICcgKyBKU09OLnN0cmluZ2lmeShwYWNEYXRhKSk7XHJcbiAgICAgICAgdmFyIG5ld1JvdyA9IHBhY0RhdGEucm93IC0gMTtcclxuICAgICAgICBpZiAodGhpcy5uclJvbGxVcFJvd3MgICYmIG5ld1JvdyA8IHRoaXMubnJSb2xsVXBSb3dzIC0gMSkge1xyXG4gICAgICAgICAgICAgICAgbmV3Um93ID0gdGhpcy5uclJvbGxVcFJvd3MtMTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vTWFrZSBzdXJlIHRoaXMgb25seSBhZmZlY3RzIFJvbGwtdXAgQ2FwdGlvbnMgYnkgY2hlY2tpbmcgdGhpcy5uclJvbGxVcFJvd3NcclxuICAgICAgICBpZiAodGhpcy5uclJvbGxVcFJvd3MgJiYgdGhpcy5jdXJyUm93ICE9PSBuZXdSb3cpIHtcclxuICAgICAgICAgIC8vY2xlYXIgYWxsIHJvd3MgZmlyc3RcclxuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTlJfUk9XUzsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRoaXMucm93c1tpXS5jbGVhcigpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vQ29weSB0aGlzLm5yUm9sbFVwUm93cyByb3dzIGZyb20gbGFzdE91dHB1dFNjcmVlbiBhbmQgcGxhY2UgaXQgaW4gdGhlIG5ld1JvdyBsb2NhdGlvblxyXG4gICAgICAgICAgLy90b3BSb3dJbmRleCAtIHRoZSBzdGFydCBvZiByb3dzIHRvIGNvcHkgKGluY2x1c2l2ZSBpbmRleClcclxuICAgICAgICAgIHZhciB0b3BSb3dJbmRleCA9IHRoaXMuY3VyclJvdyArIDEgLSAodGhpcy5uclJvbGxVcFJvd3MpO1xyXG4gICAgICAgICAgLy9XZSBvbmx5IGNvcHkgaWYgdGhlIGxhc3QgcG9zaXRpb24gd2FzIGFscmVhZHkgc2hvd24uXHJcbiAgICAgICAgICAvL1dlIHVzZSB0aGUgY3VlU3RhcnRUaW1lIHZhbHVlIHRvIGNoZWNrIHRoaXMuXHJcbiAgICAgICAgICBjb25zdCBsYXN0T3V0cHV0U2NyZWVuID0gdGhpcy5sYXN0T3V0cHV0U2NyZWVuO1xyXG4gICAgICAgICAgaWYgKGxhc3RPdXRwdXRTY3JlZW4pIHtcclxuICAgICAgICAgICAgdmFyIHByZXZMaW5lVGltZSA9IGxhc3RPdXRwdXRTY3JlZW4ucm93c1t0b3BSb3dJbmRleF0uY3VlU3RhcnRUaW1lO1xyXG4gICAgICAgICAgICBpZihwcmV2TGluZVRpbWUgJiYgcHJldkxpbmVUaW1lIDwgbG9nZ2VyLnRpbWUpIHtcclxuICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubnJSb2xsVXBSb3dzOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucm93c1tuZXdSb3ctdGhpcy5uclJvbGxVcFJvd3MraSsxXS5jb3B5KGxhc3RPdXRwdXRTY3JlZW4ucm93c1t0b3BSb3dJbmRleCtpXSk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmN1cnJSb3cgPSBuZXdSb3c7XHJcbiAgICAgICAgdmFyIHJvdyA9IHRoaXMucm93c1t0aGlzLmN1cnJSb3ddO1xyXG4gICAgICAgIGlmIChwYWNEYXRhLmluZGVudCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB2YXIgaW5kZW50ID0gcGFjRGF0YS5pbmRlbnQ7XHJcbiAgICAgICAgICAgIHZhciBwcmV2UG9zID0gTWF0aC5tYXgoaW5kZW50LTEsIDApO1xyXG4gICAgICAgICAgICByb3cuc2V0Q3Vyc29yKHBhY0RhdGEuaW5kZW50KTtcclxuICAgICAgICAgICAgcGFjRGF0YS5jb2xvciA9IHJvdy5jaGFyc1twcmV2UG9zXS5wZW5TdGF0ZS5mb3JlZ3JvdW5kO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgc3R5bGVzID0ge2ZvcmVncm91bmQgOiBwYWNEYXRhLmNvbG9yLCB1bmRlcmxpbmUgOiBwYWNEYXRhLnVuZGVybGluZSwgaXRhbGljcyA6IHBhY0RhdGEuaXRhbGljcywgYmFja2dyb3VuZCA6ICdibGFjaycsIGZsYXNoIDogZmFsc2V9O1xyXG4gICAgICAgIHRoaXMuc2V0UGVuKHN0eWxlcyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgYmFja2dyb3VuZC9leHRyYSBmb3JlZ3JvdW5kLCBidXQgZmlyc3QgZG8gYmFja19zcGFjZSwgYW5kIHRoZW4gaW5zZXJ0IHNwYWNlIChiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSkuXHJcbiAgICAgKi9cclxuICAgIHNldEJrZ0RhdGEoYmtnRGF0YSkge1xyXG5cclxuICAgICAgICBsb2dnZXIubG9nKCdJTkZPJywgJ2JrZ0RhdGEgPSAnICsgSlNPTi5zdHJpbmdpZnkoYmtnRGF0YSkpO1xyXG4gICAgICAgIHRoaXMuYmFja1NwYWNlKCk7XHJcbiAgICAgICAgdGhpcy5zZXRQZW4oYmtnRGF0YSk7XHJcbiAgICAgICAgdGhpcy5pbnNlcnRDaGFyKDB4MjApOyAvL1NwYWNlXHJcbiAgICB9XHJcblxyXG4gICAgc2V0Um9sbFVwUm93cyhuclJvd3MpIHtcclxuICAgICAgICB0aGlzLm5yUm9sbFVwUm93cyA9IG5yUm93cztcclxuICAgIH1cclxuXHJcbiAgICByb2xsVXAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMubnJSb2xsVXBSb3dzID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGxvZ2dlci5sb2coJ0RFQlVHJywgJ3JvbGxfdXAgYnV0IG5yUm9sbFVwUm93cyBub3Qgc2V0IHlldCcpO1xyXG4gICAgICAgICAgICByZXR1cm47IC8vTm90IHByb3Blcmx5IHNldHVwXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxvZ2dlci5sb2coJ1RFWFQnLCB0aGlzLmdldERpc3BsYXlUZXh0KCkpO1xyXG4gICAgICAgIHZhciB0b3BSb3dJbmRleCA9IHRoaXMuY3VyclJvdyArIDEgLSB0aGlzLm5yUm9sbFVwUm93cztcclxuICAgICAgICB2YXIgdG9wUm93ID0gdGhpcy5yb3dzLnNwbGljZSh0b3BSb3dJbmRleCwgMSlbMF07XHJcbiAgICAgICAgdG9wUm93LmNsZWFyKCk7XHJcbiAgICAgICAgdGhpcy5yb3dzLnNwbGljZSh0aGlzLmN1cnJSb3csIDAsIHRvcFJvdyk7XHJcbiAgICAgICAgbG9nZ2VyLmxvZygnSU5GTycsICdSb2xsaW5nIHVwJyk7XHJcbiAgICAgICAgLy9sb2dnZXIubG9nKCdURVhUJywgdGhpcy5nZXRfZGlzcGxheV90ZXh0KCkpXHJcbiAgICB9XHJcblxyXG4gICAvKipcclxuICAgICogR2V0IGFsbCBub24tZW1wdHkgcm93cyB3aXRoIGFzIHVuaWNvZGUgdGV4dC5cclxuICAgICovXHJcbiAgICBnZXREaXNwbGF5VGV4dChhc09uZVJvdykge1xyXG4gICAgICAgIGFzT25lUm93ID0gYXNPbmVSb3cgfHwgZmFsc2U7XHJcbiAgICAgICAgdmFyIGRpc3BsYXlUZXh0ID0gW107XHJcbiAgICAgICAgdmFyIHRleHQgPSAnJztcclxuICAgICAgICB2YXIgcm93TnIgPSAtMTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMCA7IGkgPCBOUl9ST1dTIDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciByb3dUZXh0ID0gdGhpcy5yb3dzW2ldLmdldFRleHRTdHJpbmcoKTtcclxuICAgICAgICAgICAgaWYgKHJvd1RleHQpIHtcclxuICAgICAgICAgICAgICAgIHJvd05yID0gaSsxO1xyXG4gICAgICAgICAgICAgICAgaWYgKGFzT25lUm93KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheVRleHQucHVzaCgnUm93ICcgKyByb3dOciArICc6IFxcJycgKyByb3dUZXh0ICsgJ1xcJycpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5VGV4dC5wdXNoKHJvd1RleHQudHJpbSgpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZGlzcGxheVRleHQubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICBpZiAoYXNPbmVSb3cpIHtcclxuICAgICAgICAgICAgICAgIHRleHQgPSAnWycgKyBkaXNwbGF5VGV4dC5qb2luKCcgfCAnKSArICddJztcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRleHQgPSBkaXNwbGF5VGV4dC5qb2luKCdcXG4nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGV4dDtcclxuICAgIH1cclxuXHJcbiAgICBnZXRUZXh0QW5kRm9ybWF0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJvd3M7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8vdmFyIG1vZGVzID0gWydNT0RFX1JPTEwtVVAnLCAnTU9ERV9QT1AtT04nLCAnTU9ERV9QQUlOVC1PTicsICdNT0RFX1RFWFQnXTtcclxuXHJcbmNsYXNzIENlYTYwOENoYW5uZWxcclxue1xyXG4gICAgY29uc3RydWN0b3IoY2hhbm5lbE51bWJlciwgb3V0cHV0RmlsdGVyKSB7XHJcblxyXG4gICAgICAgIHRoaXMuY2hOciA9IGNoYW5uZWxOdW1iZXI7XHJcbiAgICAgICAgdGhpcy5vdXRwdXRGaWx0ZXIgPSBvdXRwdXRGaWx0ZXI7XHJcbiAgICAgICAgdGhpcy5tb2RlID0gbnVsbDtcclxuICAgICAgICB0aGlzLnZlcmJvc2UgPSAwO1xyXG4gICAgICAgIHRoaXMuZGlzcGxheWVkTWVtb3J5ID0gbmV3IENhcHRpb25TY3JlZW4oKTtcclxuICAgICAgICB0aGlzLm5vbkRpc3BsYXllZE1lbW9yeSA9IG5ldyBDYXB0aW9uU2NyZWVuKCk7XHJcbiAgICAgICAgdGhpcy5sYXN0T3V0cHV0U2NyZWVuID0gbmV3IENhcHRpb25TY3JlZW4oKTtcclxuICAgICAgICB0aGlzLmN1cnJSb2xsVXBSb3cgPSB0aGlzLmRpc3BsYXllZE1lbW9yeS5yb3dzW05SX1JPV1MtMV07XHJcbiAgICAgICAgdGhpcy53cml0ZVNjcmVlbiA9IHRoaXMuZGlzcGxheWVkTWVtb3J5O1xyXG4gICAgICAgIHRoaXMubW9kZSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5jdWVTdGFydFRpbWUgPSBudWxsOyAvLyBLZWVwcyB0cmFjayBvZiB3aGVyZSBhIGN1ZSBzdGFydGVkLlxyXG4gICAgfVxyXG5cclxuICAgIHJlc2V0KCkge1xyXG4gICAgICAgIHRoaXMubW9kZSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5kaXNwbGF5ZWRNZW1vcnkucmVzZXQoKTtcclxuICAgICAgICB0aGlzLm5vbkRpc3BsYXllZE1lbW9yeS5yZXNldCgpO1xyXG4gICAgICAgIHRoaXMubGFzdE91dHB1dFNjcmVlbi5yZXNldCgpO1xyXG4gICAgICAgIHRoaXMuY3VyclJvbGxVcFJvdyA9IHRoaXMuZGlzcGxheWVkTWVtb3J5LnJvd3NbTlJfUk9XUy0xXTtcclxuICAgICAgICB0aGlzLndyaXRlU2NyZWVuID0gdGhpcy5kaXNwbGF5ZWRNZW1vcnk7XHJcbiAgICAgICAgdGhpcy5tb2RlID0gbnVsbDtcclxuICAgICAgICB0aGlzLmN1ZVN0YXJ0VGltZSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5sYXN0Q3VlRW5kVGltZSA9IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0SGFuZGxlcigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5vdXRwdXRGaWx0ZXI7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0SGFuZGxlcihuZXdIYW5kbGVyKSB7XHJcbiAgICAgICAgdGhpcy5vdXRwdXRGaWx0ZXIgPSBuZXdIYW5kbGVyO1xyXG4gICAgfVxyXG5cclxuICAgIHNldFBBQyhwYWNEYXRhKSB7XHJcbiAgICAgICAgdGhpcy53cml0ZVNjcmVlbi5zZXRQQUMocGFjRGF0YSk7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0QmtnRGF0YShia2dEYXRhKSB7XHJcbiAgICAgICAgdGhpcy53cml0ZVNjcmVlbi5zZXRCa2dEYXRhKGJrZ0RhdGEpO1xyXG4gICAgfVxyXG5cclxuICAgIHNldE1vZGUobmV3TW9kZSkge1xyXG4gICAgICAgIGlmIChuZXdNb2RlID09PSB0aGlzLm1vZGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLm1vZGUgPSBuZXdNb2RlO1xyXG4gICAgICAgIGxvZ2dlci5sb2coJ0lORk8nLCAnTU9ERT0nICsgbmV3TW9kZSk7XHJcbiAgICAgICAgaWYgKHRoaXMubW9kZSA9PT0gJ01PREVfUE9QLU9OJykge1xyXG4gICAgICAgICAgICB0aGlzLndyaXRlU2NyZWVuID0gdGhpcy5ub25EaXNwbGF5ZWRNZW1vcnk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy53cml0ZVNjcmVlbiA9IHRoaXMuZGlzcGxheWVkTWVtb3J5O1xyXG4gICAgICAgICAgICB0aGlzLndyaXRlU2NyZWVuLnJlc2V0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLm1vZGUgIT09ICdNT0RFX1JPTEwtVVAnKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGlzcGxheWVkTWVtb3J5Lm5yUm9sbFVwUm93cyA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMubm9uRGlzcGxheWVkTWVtb3J5Lm5yUm9sbFVwUm93cyA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubW9kZSA9IG5ld01vZGU7XHJcbiAgICB9XHJcblxyXG4gICAgaW5zZXJ0Q2hhcnMoY2hhcnMpIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMCA7IGkgPCBjaGFycy5sZW5ndGggOyBpKyspIHtcclxuICAgICAgICAgICAgdGhpcy53cml0ZVNjcmVlbi5pbnNlcnRDaGFyKGNoYXJzW2ldKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHNjcmVlbiA9IHRoaXMud3JpdGVTY3JlZW4gPT09IHRoaXMuZGlzcGxheWVkTWVtb3J5ID8gJ0RJU1AnIDogJ05PTl9ESVNQJztcclxuICAgICAgICBsb2dnZXIubG9nKCdJTkZPJywgc2NyZWVuICsgJzogJyArIHRoaXMud3JpdGVTY3JlZW4uZ2V0RGlzcGxheVRleHQodHJ1ZSkpO1xyXG4gICAgICAgIGlmICh0aGlzLm1vZGUgPT09ICdNT0RFX1BBSU5ULU9OJyB8fCB0aGlzLm1vZGUgPT09ICdNT0RFX1JPTEwtVVAnKSB7XHJcbiAgICAgICAgICAgIGxvZ2dlci5sb2coJ1RFWFQnLCAnRElTUExBWUVEOiAnICsgdGhpcy5kaXNwbGF5ZWRNZW1vcnkuZ2V0RGlzcGxheVRleHQodHJ1ZSkpO1xyXG4gICAgICAgICAgICB0aGlzLm91dHB1dERhdGFVcGRhdGUoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY2NSQ0woKSB7IC8vIFJlc3VtZSBDYXB0aW9uIExvYWRpbmcgKHN3aXRjaCBtb2RlIHRvIFBvcCBPbilcclxuICAgICAgICBsb2dnZXIubG9nKCdJTkZPJywgJ1JDTCAtIFJlc3VtZSBDYXB0aW9uIExvYWRpbmcnKTtcclxuICAgICAgICB0aGlzLnNldE1vZGUoJ01PREVfUE9QLU9OJyk7XHJcbiAgICB9XHJcblxyXG4gICAgY2NCUygpIHsgLy8gQmFja1NwYWNlXHJcbiAgICAgICAgbG9nZ2VyLmxvZygnSU5GTycsICdCUyAtIEJhY2tTcGFjZScpO1xyXG4gICAgICAgIGlmICh0aGlzLm1vZGUgPT09ICdNT0RFX1RFWFQnKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy53cml0ZVNjcmVlbi5iYWNrU3BhY2UoKTtcclxuICAgICAgICBpZiAodGhpcy53cml0ZVNjcmVlbiA9PT0gdGhpcy5kaXNwbGF5ZWRNZW1vcnkpIHtcclxuICAgICAgICAgICAgdGhpcy5vdXRwdXREYXRhVXBkYXRlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNjQU9GKCkgeyAvLyBSZXNlcnZlZCAoZm9ybWVybHkgQWxhcm0gT2ZmKVxyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjY0FPTigpIHsgLy8gUmVzZXJ2ZWQgKGZvcm1lcmx5IEFsYXJtIE9uKVxyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjY0RFUigpIHsgLy8gRGVsZXRlIHRvIEVuZCBvZiBSb3dcclxuICAgICAgICBsb2dnZXIubG9nKCdJTkZPJywgJ0RFUi0gRGVsZXRlIHRvIEVuZCBvZiBSb3cnKTtcclxuICAgICAgICB0aGlzLndyaXRlU2NyZWVuLmNsZWFyVG9FbmRPZlJvdygpO1xyXG4gICAgICAgIHRoaXMub3V0cHV0RGF0YVVwZGF0ZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIGNjUlUobnJSb3dzKSB7IC8vUm9sbC1VcCBDYXB0aW9ucy0yLDMsb3IgNCBSb3dzXHJcbiAgICAgICAgbG9nZ2VyLmxvZygnSU5GTycsICdSVSgnICsgbnJSb3dzICsnKSAtIFJvbGwgVXAnKTtcclxuICAgICAgICB0aGlzLndyaXRlU2NyZWVuID0gdGhpcy5kaXNwbGF5ZWRNZW1vcnk7XHJcbiAgICAgICAgdGhpcy5zZXRNb2RlKCdNT0RFX1JPTEwtVVAnKTtcclxuICAgICAgICB0aGlzLndyaXRlU2NyZWVuLnNldFJvbGxVcFJvd3MobnJSb3dzKTtcclxuICAgIH1cclxuXHJcbiAgICBjY0ZPTigpIHsgLy9GbGFzaCBPblxyXG4gICAgICAgIGxvZ2dlci5sb2coJ0lORk8nLCAnRk9OIC0gRmxhc2ggT24nKTtcclxuICAgICAgICB0aGlzLndyaXRlU2NyZWVuLnNldFBlbih7Zmxhc2ggOiB0cnVlfSk7XHJcbiAgICB9XHJcblxyXG4gICAgY2NSREMoKSB7IC8vIFJlc3VtZSBEaXJlY3QgQ2FwdGlvbmluZyAoc3dpdGNoIG1vZGUgdG8gUGFpbnRPbilcclxuICAgICAgICBsb2dnZXIubG9nKCdJTkZPJywgJ1JEQyAtIFJlc3VtZSBEaXJlY3QgQ2FwdGlvbmluZycpO1xyXG4gICAgICAgIHRoaXMuc2V0TW9kZSgnTU9ERV9QQUlOVC1PTicpO1xyXG4gICAgfVxyXG5cclxuICAgIGNjVFIoKSB7IC8vIFRleHQgUmVzdGFydCBpbiB0ZXh0IG1vZGUgKG5vdCBzdXBwb3J0ZWQsIGhvd2V2ZXIpXHJcbiAgICAgICAgbG9nZ2VyLmxvZygnSU5GTycsICdUUicpO1xyXG4gICAgICAgIHRoaXMuc2V0TW9kZSgnTU9ERV9URVhUJyk7XHJcbiAgICB9XHJcblxyXG4gICAgY2NSVEQoKSB7IC8vIFJlc3VtZSBUZXh0IERpc3BsYXkgaW4gVGV4dCBtb2RlIChub3Qgc3VwcG9ydGVkLCBob3dldmVyKVxyXG4gICAgICAgIGxvZ2dlci5sb2coJ0lORk8nLCAnUlREJyk7XHJcbiAgICAgICAgdGhpcy5zZXRNb2RlKCdNT0RFX1RFWFQnKTtcclxuICAgIH1cclxuXHJcbiAgICBjY0VETSgpIHsgLy8gRXJhc2UgRGlzcGxheWVkIE1lbW9yeVxyXG4gICAgICAgIGxvZ2dlci5sb2coJ0lORk8nLCAnRURNIC0gRXJhc2UgRGlzcGxheWVkIE1lbW9yeScpO1xyXG4gICAgICAgIHRoaXMuZGlzcGxheWVkTWVtb3J5LnJlc2V0KCk7XHJcbiAgICAgICAgdGhpcy5vdXRwdXREYXRhVXBkYXRlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgY2NDUigpIHsgLy8gQ2FycmlhZ2UgUmV0dXJuXHJcbiAgICAgICAgbG9nZ2VyLmxvZygnQ1IgLSBDYXJyaWFnZSBSZXR1cm4nKTtcclxuICAgICAgICB0aGlzLndyaXRlU2NyZWVuLnJvbGxVcCgpO1xyXG4gICAgICAgIHRoaXMub3V0cHV0RGF0YVVwZGF0ZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIGNjRU5NKCkgeyAvL0VyYXNlIE5vbi1EaXNwbGF5ZWQgTWVtb3J5XHJcbiAgICAgICAgbG9nZ2VyLmxvZygnSU5GTycsICdFTk0gLSBFcmFzZSBOb24tZGlzcGxheWVkIE1lbW9yeScpO1xyXG4gICAgICAgIHRoaXMubm9uRGlzcGxheWVkTWVtb3J5LnJlc2V0KCk7XHJcbiAgICB9XHJcblxyXG4gICAgY2NFT0MoKSB7IC8vRW5kIG9mIENhcHRpb24gKEZsaXAgTWVtb3JpZXMpXHJcbiAgICAgICAgbG9nZ2VyLmxvZygnSU5GTycsICdFT0MgLSBFbmQgT2YgQ2FwdGlvbicpO1xyXG4gICAgICAgIGlmICh0aGlzLm1vZGUgPT09ICdNT0RFX1BPUC1PTicpIHtcclxuICAgICAgICAgICAgdmFyIHRtcCA9IHRoaXMuZGlzcGxheWVkTWVtb3J5O1xyXG4gICAgICAgICAgICB0aGlzLmRpc3BsYXllZE1lbW9yeSA9IHRoaXMubm9uRGlzcGxheWVkTWVtb3J5O1xyXG4gICAgICAgICAgICB0aGlzLm5vbkRpc3BsYXllZE1lbW9yeSA9IHRtcDtcclxuICAgICAgICAgICAgdGhpcy53cml0ZVNjcmVlbiA9IHRoaXMubm9uRGlzcGxheWVkTWVtb3J5O1xyXG4gICAgICAgICAgICBsb2dnZXIubG9nKCdURVhUJywgJ0RJU1A6ICcgKyB0aGlzLmRpc3BsYXllZE1lbW9yeS5nZXREaXNwbGF5VGV4dCgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5vdXRwdXREYXRhVXBkYXRlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgY2NUTyhuckNvbHMpIHsgLy8gVGFiIE9mZnNldCAxLDIsIG9yIDMgY29sdW1uc1xyXG4gICAgICAgIGxvZ2dlci5sb2coJ0lORk8nLCAnVE8oJyArIG5yQ29scyArICcpIC0gVGFiIE9mZnNldCcpO1xyXG4gICAgICAgIHRoaXMud3JpdGVTY3JlZW4ubW92ZUN1cnNvcihuckNvbHMpO1xyXG4gICAgfVxyXG5cclxuICAgIGNjTUlEUk9XKHNlY29uZEJ5dGUpIHsgLy8gUGFyc2UgTUlEUk9XIGNvbW1hbmRcclxuICAgICAgICB2YXIgc3R5bGVzID0ge2ZsYXNoIDogZmFsc2V9O1xyXG4gICAgICAgIHN0eWxlcy51bmRlcmxpbmUgPSBzZWNvbmRCeXRlICUgMiA9PT0gMTtcclxuICAgICAgICBzdHlsZXMuaXRhbGljcyA9IHNlY29uZEJ5dGUgPj0gMHgyZTtcclxuICAgICAgICBpZiAoIXN0eWxlcy5pdGFsaWNzKSB7XHJcbiAgICAgICAgICAgIHZhciBjb2xvckluZGV4ID0gTWF0aC5mbG9vcihzZWNvbmRCeXRlLzIpIC0gMHgxMDtcclxuICAgICAgICAgICAgdmFyIGNvbG9ycyA9IFsnd2hpdGUnLCAnZ3JlZW4nLCAnYmx1ZScsICdjeWFuJywgJ3JlZCcsICd5ZWxsb3cnLCAnbWFnZW50YSddO1xyXG4gICAgICAgICAgICBzdHlsZXMuZm9yZWdyb3VuZCA9IGNvbG9yc1tjb2xvckluZGV4XTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBzdHlsZXMuZm9yZWdyb3VuZCA9ICd3aGl0ZSc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxvZ2dlci5sb2coJ0lORk8nLCAnTUlEUk9XOiAnICsgSlNPTi5zdHJpbmdpZnkoc3R5bGVzKSk7XHJcbiAgICAgICAgdGhpcy53cml0ZVNjcmVlbi5zZXRQZW4oc3R5bGVzKTtcclxuICAgIH1cclxuXHJcbiAgICBvdXRwdXREYXRhVXBkYXRlKCkge1xyXG4gICAgICAgIHZhciB0ID0gbG9nZ2VyLnRpbWU7XHJcbiAgICAgICAgaWYgKHQgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5vdXRwdXRGaWx0ZXIpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMub3V0cHV0RmlsdGVyLnVwZGF0ZURhdGEpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMub3V0cHV0RmlsdGVyLnVwZGF0ZURhdGEodCwgdGhpcy5kaXNwbGF5ZWRNZW1vcnkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmN1ZVN0YXJ0VGltZSA9PT0gbnVsbCAmJiAhdGhpcy5kaXNwbGF5ZWRNZW1vcnkuaXNFbXB0eSgpKSB7IC8vIFN0YXJ0IG9mIGEgbmV3IGN1ZVxyXG4gICAgICAgICAgICAgICAgdGhpcy5jdWVTdGFydFRpbWUgPSB0O1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmRpc3BsYXllZE1lbW9yeS5lcXVhbHModGhpcy5sYXN0T3V0cHV0U2NyZWVuKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm91dHB1dEZpbHRlci5uZXdDdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vdXRwdXRGaWx0ZXIubmV3Q3VlKHRoaXMuY3VlU3RhcnRUaW1lLCB0LCB0aGlzLmxhc3RPdXRwdXRTY3JlZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1ZVN0YXJ0VGltZSA9IHRoaXMuZGlzcGxheWVkTWVtb3J5LmlzRW1wdHkoKSA/IG51bGwgOiB0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMubGFzdE91dHB1dFNjcmVlbi5jb3B5KHRoaXMuZGlzcGxheWVkTWVtb3J5KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY3VlU3BsaXRBdFRpbWUodCkge1xyXG4gICAgICAgIGlmICh0aGlzLm91dHB1dEZpbHRlcikge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuZGlzcGxheWVkTWVtb3J5LmlzRW1wdHkoKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3V0cHV0RmlsdGVyLm5ld0N1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3V0cHV0RmlsdGVyLm5ld0N1ZSh0aGlzLmN1ZVN0YXJ0VGltZSwgdCwgdGhpcy5kaXNwbGF5ZWRNZW1vcnkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5jdWVTdGFydFRpbWUgPSB0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5jbGFzcyBDZWE2MDhQYXJzZXIge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKGZpZWxkLCBvdXQxLCBvdXQyKSB7XHJcbiAgICAgICAgdGhpcy5maWVsZCA9IGZpZWxkIHx8IDE7XHJcbiAgICAgICAgdGhpcy5vdXRwdXRzID0gW291dDEsIG91dDJdO1xyXG4gICAgICAgIHRoaXMuY2hhbm5lbHMgPSBbbmV3IENlYTYwOENoYW5uZWwoMSwgb3V0MSksIG5ldyBDZWE2MDhDaGFubmVsKDIsIG91dDIpXTtcclxuICAgICAgICB0aGlzLmN1cnJDaE5yID0gLTE7IC8vIFdpbGwgYmUgMSBvciAyXHJcbiAgICAgICAgdGhpcy5sYXN0Q21kQSA9IG51bGw7IC8vIEZpcnN0IGJ5dGUgb2YgbGFzdCBjb21tYW5kXHJcbiAgICAgICAgdGhpcy5sYXN0Q21kQiA9IG51bGw7IC8vIFNlY29uZCBieXRlIG9mIGxhc3QgY29tbWFuZFxyXG4gICAgICAgIHRoaXMuYnVmZmVyZWREYXRhID0gW107XHJcbiAgICAgICAgdGhpcy5zdGFydFRpbWUgPSBudWxsO1xyXG4gICAgICAgIHRoaXMubGFzdFRpbWUgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuZGF0YUNvdW50ZXJzID0geydwYWRkaW5nJyA6IDAsICdjaGFyJyA6IDAsICdjbWQnIDogMCwgJ290aGVyJyA6IDB9O1xyXG4gICAgfVxyXG5cclxuICAgIGdldEhhbmRsZXIoaW5kZXgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jaGFubmVsc1tpbmRleF0uZ2V0SGFuZGxlcigpO1xyXG4gICAgfVxyXG5cclxuICAgIHNldEhhbmRsZXIoaW5kZXgsIG5ld0hhbmRsZXIpIHtcclxuICAgICAgICB0aGlzLmNoYW5uZWxzW2luZGV4XS5zZXRIYW5kbGVyKG5ld0hhbmRsZXIpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkIGRhdGEgZm9yIHRpbWUgdCBpbiBmb3JtcyBvZiBsaXN0IG9mIGJ5dGVzICh1bnNpZ25lZCBpbnRzKS4gVGhlIGJ5dGVzIGFyZSB0cmVhdGVkIGFzIHBhaXJzLlxyXG4gICAgICovXHJcbiAgICBhZGREYXRhKHQsIGJ5dGVMaXN0KSB7XHJcbiAgICAgICAgdmFyIGNtZEZvdW5kLCBhLCBiLFxyXG4gICAgICAgIGNoYXJzRm91bmQgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgdGhpcy5sYXN0VGltZSA9IHQ7XHJcbiAgICAgICAgbG9nZ2VyLnNldFRpbWUodCk7XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwIDsgaSA8IGJ5dGVMaXN0Lmxlbmd0aCA7IGkrPTIpIHtcclxuICAgICAgICAgICAgYSA9IGJ5dGVMaXN0W2ldICYgMHg3ZjtcclxuICAgICAgICAgICAgYiA9IGJ5dGVMaXN0W2krMV0gJiAweDdmO1xyXG4gICAgICAgICAgICBpZiAoYSA9PT0gMCAmJiBiID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGFDb3VudGVycy5wYWRkaW5nICs9IDI7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGxvZ2dlci5sb2coJ0RBVEEnLCAnWycgKyBudW1BcnJheVRvSGV4QXJyYXkoW2J5dGVMaXN0W2ldLCBieXRlTGlzdFtpKzFdXSkgKyddIC0+ICgnICsgbnVtQXJyYXlUb0hleEFycmF5KFthLCBiXSkgKyAnKScpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNtZEZvdW5kID0gdGhpcy5wYXJzZUNtZChhLCBiKTtcclxuICAgICAgICAgICAgaWYgKCFjbWRGb3VuZCkge1xyXG4gICAgICAgICAgICAgICAgY21kRm91bmQgPSB0aGlzLnBhcnNlTWlkcm93KGEsIGIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghY21kRm91bmQpIHtcclxuICAgICAgICAgICAgICAgIGNtZEZvdW5kID0gdGhpcy5wYXJzZVBBQyhhLCBiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIWNtZEZvdW5kKSB7XHJcbiAgICAgICAgICAgICAgICBjbWRGb3VuZCA9IHRoaXMucGFyc2VCYWNrZ3JvdW5kQXR0cmlidXRlcyhhLCBiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIWNtZEZvdW5kKSB7XHJcbiAgICAgICAgICAgICAgICBjaGFyc0ZvdW5kID0gdGhpcy5wYXJzZUNoYXJzKGEsIGIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNoYXJzRm91bmQpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jdXJyQ2hOciAmJiB0aGlzLmN1cnJDaE5yID49MCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2hhbm5lbCA9IHRoaXMuY2hhbm5lbHNbdGhpcy5jdXJyQ2hOci0xXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbm5lbC5pbnNlcnRDaGFycyhjaGFyc0ZvdW5kKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIubG9nKCdXQVJOSU5HJywgJ05vIGNoYW5uZWwgZm91bmQgeWV0LiBURVhULU1PREU/Jyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChjbWRGb3VuZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhQ291bnRlcnMuY21kICs9IDI7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2hhcnNGb3VuZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhQ291bnRlcnMuY2hhciArPSAyO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhQ291bnRlcnMub3RoZXIgKz0gMjtcclxuICAgICAgICAgICAgICAgIGxvZ2dlci5sb2coJ1dBUk5JTkcnLCAnQ291bGRuXFwndCBwYXJzZSBjbGVhbmVkIGRhdGEgJyArIG51bUFycmF5VG9IZXhBcnJheShbYSwgYl0pICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICcgb3JpZzogJyArIG51bUFycmF5VG9IZXhBcnJheShbYnl0ZUxpc3RbaV0sIGJ5dGVMaXN0W2krMV1dKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQYXJzZSBDb21tYW5kLlxyXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59IFRlbGxzIGlmIGEgY29tbWFuZCB3YXMgZm91bmRcclxuICAgICAqL1xyXG4gICAgcGFyc2VDbWQoYSwgYikge1xyXG4gICAgICAgIHZhciBjaE5yID0gbnVsbDtcclxuXHJcbiAgICAgICAgdmFyIGNvbmQxID0gKGEgPT09IDB4MTQgfHwgYSA9PT0gMHgxQykgJiYgKDB4MjAgPD0gYiAmJiBiIDw9IDB4MkYpO1xyXG4gICAgICAgIHZhciBjb25kMiA9IChhID09PSAweDE3IHx8IGEgPT09IDB4MUYpICYmICgweDIxIDw9IGIgJiYgYiA8PSAweDIzKTtcclxuICAgICAgICBpZiAoIShjb25kMSB8fCBjb25kMikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGEgPT09IHRoaXMubGFzdENtZEEgJiYgYiA9PT0gdGhpcy5sYXN0Q21kQikge1xyXG4gICAgICAgICAgICB0aGlzLmxhc3RDbWRBID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5sYXN0Q21kQiA9IG51bGw7IC8vIFJlcGVhdGVkIGNvbW1hbmRzIGFyZSBkcm9wcGVkIChvbmNlKVxyXG4gICAgICAgICAgICBsb2dnZXIubG9nKCdERUJVRycsICdSZXBlYXRlZCBjb21tYW5kICgnICsgbnVtQXJyYXlUb0hleEFycmF5KFthLCBiXSkgKyAnKSBpcyBkcm9wcGVkJyk7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGEgPT09IDB4MTQgfHwgYSA9PT0gMHgxNykge1xyXG4gICAgICAgICAgICBjaE5yID0gMTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjaE5yID0gMjsgLy8gKGEgPT09IDB4MUMgfHwgYT09PSAweDFmKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGNoYW5uZWwgPSB0aGlzLmNoYW5uZWxzW2NoTnIgLSAxXTtcclxuXHJcbiAgICAgICAgaWYgKGEgPT09IDB4MTQgfHwgYSA9PT0gMHgxQykge1xyXG4gICAgICAgICAgICBpZiAoYiA9PT0gMHgyMCkge1xyXG4gICAgICAgICAgICAgICAgY2hhbm5lbC5jY1JDTCgpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGIgPT09IDB4MjEpIHtcclxuICAgICAgICAgICAgICAgIGNoYW5uZWwuY2NCUygpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGIgPT09IDB4MjIpIHtcclxuICAgICAgICAgICAgICAgIGNoYW5uZWwuY2NBT0YoKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChiID09PSAweDIzKSB7XHJcbiAgICAgICAgICAgICAgICBjaGFubmVsLmNjQU9OKCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyNCkge1xyXG4gICAgICAgICAgICAgICAgY2hhbm5lbC5jY0RFUigpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGIgPT09IDB4MjUpIHtcclxuICAgICAgICAgICAgICAgIGNoYW5uZWwuY2NSVSgyKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChiID09PSAweDI2KSB7XHJcbiAgICAgICAgICAgICAgICBjaGFubmVsLmNjUlUoMyk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyNykge1xyXG4gICAgICAgICAgICAgICAgY2hhbm5lbC5jY1JVKDQpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGIgPT09IDB4MjgpIHtcclxuICAgICAgICAgICAgICAgIGNoYW5uZWwuY2NGT04oKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChiID09PSAweDI5KSB7XHJcbiAgICAgICAgICAgICAgICBjaGFubmVsLmNjUkRDKCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyQSkge1xyXG4gICAgICAgICAgICAgICAgY2hhbm5lbC5jY1RSKCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyQikge1xyXG4gICAgICAgICAgICAgICAgY2hhbm5lbC5jY1JURCgpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGIgPT09IDB4MkMpIHtcclxuICAgICAgICAgICAgICAgIGNoYW5uZWwuY2NFRE0oKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChiID09PSAweDJEKSB7XHJcbiAgICAgICAgICAgICAgICBjaGFubmVsLmNjQ1IoKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChiID09PSAweDJFKSB7XHJcbiAgICAgICAgICAgICAgICBjaGFubmVsLmNjRU5NKCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyRikge1xyXG4gICAgICAgICAgICAgICAgY2hhbm5lbC5jY0VPQygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHsgLy9hID09IDB4MTcgfHwgYSA9PSAweDFGXHJcbiAgICAgICAgICAgIGNoYW5uZWwuY2NUTyhiIC0gMHgyMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubGFzdENtZEEgPSBhO1xyXG4gICAgICAgIHRoaXMubGFzdENtZEIgPSBiO1xyXG4gICAgICAgIHRoaXMuY3VyckNoTnIgPSBjaE5yO1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUGFyc2UgbWlkcm93IHN0eWxpbmcgY29tbWFuZFxyXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIHBhcnNlTWlkcm93KGEsIGIpIHtcclxuICAgICAgICB2YXIgY2hOciA9IG51bGw7XHJcblxyXG4gICAgICAgIGlmICggKChhID09PSAweDExKSB8fCAoYSA9PT0gMHgxOSkpICYmIDB4MjAgPD0gYiAmJiBiIDw9IDB4MmYpIHtcclxuICAgICAgICAgICAgaWYgKGEgPT09IDB4MTEpIHtcclxuICAgICAgICAgICAgICAgIGNoTnIgPSAxO1xyXG4gICAgICAgICAgICB9IGVsc2UgIHtcclxuICAgICAgICAgICAgICAgIGNoTnIgPSAyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChjaE5yICE9PSB0aGlzLmN1cnJDaE5yKSB7XHJcbiAgICAgICAgICAgICAgICBsb2dnZXIubG9nKCdFUlJPUicsICdNaXNtYXRjaCBjaGFubmVsIGluIG1pZHJvdyBwYXJzaW5nJyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGNoYW5uZWwgPSB0aGlzLmNoYW5uZWxzW2NoTnItMV07XHJcbiAgICAgICAgICAgIGNoYW5uZWwuY2NNSURST1coYik7XHJcbiAgICAgICAgICAgIGxvZ2dlci5sb2coJ0RFQlVHJywgJ01JRFJPVyAoJyArIG51bUFycmF5VG9IZXhBcnJheShbYSwgYl0pICsgJyknKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUGFyc2UgUHJlYWJsZSBBY2Nlc3MgQ29kZXMgKFRhYmxlIDUzKS5cclxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSBUZWxscyBpZiBQQUMgZm91bmRcclxuICAgICAqL1xyXG4gICAgcGFyc2VQQUMoYSwgYikge1xyXG5cclxuICAgICAgIHZhciBjaE5yID0gbnVsbDtcclxuICAgICAgIHZhciByb3cgPSBudWxsO1xyXG5cclxuICAgICAgICB2YXIgY2FzZTEgPSAoKDB4MTEgPD0gYSAgJiYgYSA8PSAweDE3KSB8fCAoMHgxOSA8PSBhICYmIGEgPD0gMHgxRikpICYmICgweDQwIDw9IGIgJiYgYiA8PSAweDdGKTtcclxuICAgICAgICB2YXIgY2FzZTIgPSAoYSA9PT0gMHgxMCB8fCBhID09PSAweDE4KSAmJiAoMHg0MCA8PSBiICYmIGIgPD0gMHg1Rik7XHJcbiAgICAgICAgaWYgKCEgKGNhc2UxIHx8IGNhc2UyKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoYSA9PT0gdGhpcy5sYXN0Q21kQSAmJiBiID09PSB0aGlzLmxhc3RDbWRCKSB7XHJcbiAgICAgICAgICAgIHRoaXMubGFzdENtZEEgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLmxhc3RDbWRCID0gbnVsbDtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7IC8vIFJlcGVhdGVkIGNvbW1hbmRzIGFyZSBkcm9wcGVkIChvbmNlKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY2hOciA9IChhIDw9IDB4MTcpID8gMSA6IDI7XHJcblxyXG4gICAgICAgIGlmICgweDQwIDw9IGIgJiYgYiA8PSAweDVGKSB7XHJcbiAgICAgICAgICAgIHJvdyA9IChjaE5yID09PSAxKSA/IHJvd3NMb3dDaDFbYV0gOiByb3dzTG93Q2gyW2FdO1xyXG4gICAgICAgIH0gZWxzZSB7IC8vIDB4NjAgPD0gYiA8PSAweDdGXHJcbiAgICAgICAgICAgIHJvdyA9IChjaE5yID09PSAxKSA/IHJvd3NIaWdoQ2gxW2FdIDogcm93c0hpZ2hDaDJbYV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBwYWNEYXRhID0gdGhpcy5pbnRlcnByZXRQQUMocm93LCBiKTtcclxuICAgICAgICB2YXIgY2hhbm5lbCA9IHRoaXMuY2hhbm5lbHNbY2hOci0xXTtcclxuICAgICAgICBjaGFubmVsLnNldFBBQyhwYWNEYXRhKTtcclxuICAgICAgICB0aGlzLmxhc3RDbWRBID0gYTtcclxuICAgICAgICB0aGlzLmxhc3RDbWRCID0gYjtcclxuICAgICAgICB0aGlzLmN1cnJDaE5yID0gY2hOcjtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEludGVycHJldCB0aGUgc2Vjb25kIGJ5dGUgb2YgdGhlIHBhYywgYW5kIHJldHVybiB0aGUgaW5mb3JtYXRpb24uXHJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBwYWNEYXRhIHdpdGggc3R5bGUgcGFyYW1ldGVycy5cclxuICAgICAqL1xyXG4gICAgaW50ZXJwcmV0UEFDKHJvdywgYnl0ZSkge1xyXG4gICAgICAgIHZhciBwYWNJbmRleCA9IGJ5dGU7XHJcbiAgICAgICAgdmFyIHBhY0RhdGEgPSB7Y29sb3IgOiBudWxsLCBpdGFsaWNzIDogZmFsc2UsIGluZGVudCA6IG51bGwsIHVuZGVybGluZSA6IGZhbHNlLCByb3cgOiByb3d9O1xyXG5cclxuICAgICAgICBpZiAoYnl0ZSA+IDB4NUYpIHtcclxuICAgICAgICAgICAgcGFjSW5kZXggPSBieXRlIC0gMHg2MDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBwYWNJbmRleCA9IGJ5dGUgLSAweDQwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwYWNEYXRhLnVuZGVybGluZSA9IChwYWNJbmRleCAmIDEpID09PSAxO1xyXG4gICAgICAgIGlmIChwYWNJbmRleCA8PSAweGQpIHtcclxuICAgICAgICAgICAgcGFjRGF0YS5jb2xvciA9IFsnd2hpdGUnLCAnZ3JlZW4nLCAnYmx1ZScsICdjeWFuJywgJ3JlZCcsICd5ZWxsb3cnLCAnbWFnZW50YScsICd3aGl0ZSddW01hdGguZmxvb3IocGFjSW5kZXgvMildO1xyXG4gICAgICAgIH0gZWxzZSBpZiAocGFjSW5kZXggPD0gMHhmKSB7XHJcbiAgICAgICAgICAgIHBhY0RhdGEuaXRhbGljcyA9IHRydWU7XHJcbiAgICAgICAgICAgIHBhY0RhdGEuY29sb3IgPSAnd2hpdGUnO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHBhY0RhdGEuaW5kZW50ID0gKE1hdGguZmxvb3IoKHBhY0luZGV4LTB4MTApLzIpKSo0O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcGFjRGF0YTsgLy8gTm90ZSB0aGF0IHJvdyBoYXMgemVybyBvZmZzZXQuIFRoZSBzcGVjIHVzZXMgMS5cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFBhcnNlIGNoYXJhY3RlcnMuXHJcbiAgICAgKiBAcmV0dXJucyBBbiBhcnJheSB3aXRoIDEgdG8gMiBjb2RlcyBjb3JyZXNwb25kaW5nIHRvIGNoYXJzLCBpZiBmb3VuZC4gbnVsbCBvdGhlcndpc2UuXHJcbiAgICAgKi9cclxuICAgIHBhcnNlQ2hhcnMoYSwgYikge1xyXG5cclxuICAgICAgIHZhciAgY2hhbm5lbE5yID0gbnVsbCxcclxuICAgICAgICAgICAgY2hhckNvZGVzID0gbnVsbCxcclxuICAgICAgICAgICAgY2hhckNvZGUxID0gbnVsbDtcclxuXHJcbiAgICAgICAgaWYgKGEgPj0gMHgxOSkge1xyXG4gICAgICAgICAgICBjaGFubmVsTnIgPSAyO1xyXG4gICAgICAgICAgICBjaGFyQ29kZTEgPSBhIC0gODtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjaGFubmVsTnIgPSAxO1xyXG4gICAgICAgICAgICBjaGFyQ29kZTEgPSBhO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoMHgxMSA8PSBjaGFyQ29kZTEgJiYgY2hhckNvZGUxIDw9IDB4MTMpIHtcclxuICAgICAgICAgICAgLy8gU3BlY2lhbCBjaGFyYWN0ZXJcclxuICAgICAgICAgICAgdmFyIG9uZUNvZGUgPSBiO1xyXG4gICAgICAgICAgICBpZiAoY2hhckNvZGUxID09PSAweDExKSB7XHJcbiAgICAgICAgICAgICAgICBvbmVDb2RlID0gYiArIDB4NTA7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2hhckNvZGUxID09PSAweDEyKSB7XHJcbiAgICAgICAgICAgICAgICBvbmVDb2RlID0gYiArIDB4NzA7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBvbmVDb2RlID0gYiArIDB4OTA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbG9nZ2VyLmxvZygnSU5GTycsICdTcGVjaWFsIGNoYXIgXFwnJyArIGdldENoYXJGb3JCeXRlKG9uZUNvZGUpICsgJ1xcJyBpbiBjaGFubmVsICcgKyBjaGFubmVsTnIpO1xyXG4gICAgICAgICAgICBjaGFyQ29kZXMgPSBbb25lQ29kZV07XHJcbiAgICAgICAgfSBlbHNlIGlmICgweDIwIDw9IGEgJiYgYSA8PSAweDdmKSB7XHJcbiAgICAgICAgICAgIGNoYXJDb2RlcyA9IChiID09PSAwKSA/IFthXSA6IFthLCBiXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNoYXJDb2Rlcykge1xyXG4gICAgICAgICAgICB2YXIgaGV4Q29kZXMgPSBudW1BcnJheVRvSGV4QXJyYXkoY2hhckNvZGVzKTtcclxuICAgICAgICAgICAgbG9nZ2VyLmxvZygnREVCVUcnLCAnQ2hhciBjb2RlcyA9ICAnICsgaGV4Q29kZXMuam9pbignLCcpKTtcclxuICAgICAgICAgICAgdGhpcy5sYXN0Q21kQSA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMubGFzdENtZEIgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY2hhckNvZGVzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBQYXJzZSBleHRlbmRlZCBiYWNrZ3JvdW5kIGF0dHJpYnV0ZXMgYXMgd2VsbCBhcyBuZXcgZm9yZWdyb3VuZCBjb2xvciBibGFjay5cclxuICAgICogQHJldHVybnN7Qm9vbGVhbn0gVGVsbHMgaWYgYmFja2dyb3VuZCBhdHRyaWJ1dGVzIGFyZSBmb3VuZFxyXG4gICAgKi9cclxuICAgIHBhcnNlQmFja2dyb3VuZEF0dHJpYnV0ZXMoYSwgYikge1xyXG4gICAgICAgdmFyICBia2dEYXRhLFxyXG4gICAgICAgICAgICBpbmRleCxcclxuICAgICAgICAgICAgY2hOcixcclxuICAgICAgICAgICAgY2hhbm5lbDtcclxuXHJcbiAgICAgICAgdmFyIGNhc2UxID0gKGEgPT09IDB4MTAgfHwgYSA9PT0gMHgxOCkgJiYgKDB4MjAgPD0gYiAmJiBiIDw9IDB4MmYpO1xyXG4gICAgICAgIHZhciBjYXNlMiA9IChhID09PSAweDE3IHx8IGEgPT09IDB4MWYpICYmICgweDJkIDw9YiAmJiBiIDw9IDB4MmYpO1xyXG4gICAgICAgIGlmICghKGNhc2UxIHx8IGNhc2UyKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJrZ0RhdGEgPSB7fTtcclxuICAgICAgICBpZiAoYSAgPT09IDB4MTAgfHwgYSA9PT0gMHgxOCkge1xyXG4gICAgICAgICAgICBpbmRleCA9IE1hdGguZmxvb3IoKGItMHgyMCkvMik7XHJcbiAgICAgICAgICAgIGJrZ0RhdGEuYmFja2dyb3VuZCA9IGJhY2tncm91bmRDb2xvcnNbaW5kZXhdO1xyXG4gICAgICAgICAgICBpZiAoYiAlIDIgPT09IDEpIHtcclxuICAgICAgICAgICAgICAgIGJrZ0RhdGEuYmFja2dyb3VuZCA9IGJrZ0RhdGEuYmFja2dyb3VuZCArICdfc2VtaSc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2UgaWYgKGIgPT09IDB4MmQpIHtcclxuICAgICAgICAgICAgYmtnRGF0YS5iYWNrZ3JvdW5kID0gJ3RyYW5zcGFyZW50JztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBia2dEYXRhLmZvcmVncm91bmQgPSAnYmxhY2snO1xyXG4gICAgICAgICAgICBpZiAoYiA9PT0gMHgyZikge1xyXG4gICAgICAgICAgICAgICAgYmtnRGF0YS51bmRlcmxpbmUgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNoTnIgPSAoYSA8IDB4MTgpID8gMSA6IDI7XHJcbiAgICAgICAgY2hhbm5lbCA9IHRoaXMuY2hhbm5lbHNbY2hOci0xXTtcclxuICAgICAgICBjaGFubmVsLnNldEJrZ0RhdGEoYmtnRGF0YSk7XHJcbiAgICAgICAgdGhpcy5sYXN0Q21kQSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5sYXN0Q21kQiA9IG51bGw7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXNldCBzdGF0ZSBvZiBwYXJzZXIgYW5kIGl0cyBjaGFubmVscy5cclxuICAgICAqL1xyXG4gICAgcmVzZXQoKSB7XHJcbiAgICAgICAgZm9yICh2YXIgaT0wIDsgaSA8IHRoaXMuY2hhbm5lbHMubGVuZ3RoIDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNoYW5uZWxzW2ldKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5uZWxzW2ldLnJlc2V0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5sYXN0Q21kQSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5sYXN0Q21kQiA9IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUcmlnZ2VyIHRoZSBnZW5lcmF0aW9uIG9mIGEgY3VlLCBhbmQgdGhlIHN0YXJ0IG9mIGEgbmV3IG9uZSBpZiBkaXNwbGF5U2NyZWVucyBhcmUgbm90IGVtcHR5LlxyXG4gICAgICovXHJcbiAgICBjdWVTcGxpdEF0VGltZSh0KSB7XHJcbiAgICAgICAgZm9yICh2YXIgaT0wIDsgaSA8IHRoaXMuY2hhbm5lbHMubGVuZ3RoIDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNoYW5uZWxzW2ldKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5uZWxzW2ldLmN1ZVNwbGl0QXRUaW1lKHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBDZWE2MDhQYXJzZXI7XHJcbiIsImltcG9ydCB7IGZpeExpbmVCcmVha3MgfSBmcm9tICcuL3Z0dHBhcnNlcic7XHJcblxyXG5jb25zdCBDdWVzID0ge1xyXG5cclxuICBuZXdDdWU6IGZ1bmN0aW9uKHRyYWNrLCBzdGFydFRpbWUsIGVuZFRpbWUsIGNhcHRpb25TY3JlZW4pIHtcclxuICAgIHZhciByb3c7XHJcbiAgICB2YXIgY3VlO1xyXG4gICAgdmFyIGluZGVudGluZztcclxuICAgIHZhciBpbmRlbnQ7XHJcbiAgICB2YXIgdGV4dDtcclxuICAgIHZhciBWVFRDdWUgPSB3aW5kb3cuVlRUQ3VlIHx8IHdpbmRvdy5UZXh0VHJhY2tDdWU7XHJcblxyXG4gICAgZm9yICh2YXIgcj0wOyByPGNhcHRpb25TY3JlZW4ucm93cy5sZW5ndGg7IHIrKylcclxuICAgIHtcclxuICAgICAgcm93ID0gY2FwdGlvblNjcmVlbi5yb3dzW3JdO1xyXG4gICAgICBpbmRlbnRpbmcgPSB0cnVlO1xyXG4gICAgICBpbmRlbnQgPSAwO1xyXG4gICAgICB0ZXh0ID0gJyc7XHJcblxyXG4gICAgICBpZiAoIXJvdy5pc0VtcHR5KCkpXHJcbiAgICAgIHtcclxuICAgICAgICBmb3IgKHZhciBjPTA7IGM8cm93LmNoYXJzLmxlbmd0aDsgYysrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgIGlmIChyb3cuY2hhcnNbY10udWNoYXIubWF0Y2goL1xccy8pICYmIGluZGVudGluZylcclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAgaW5kZW50Kys7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIHRleHQgKz0gcm93LmNoYXJzW2NdLnVjaGFyO1xyXG4gICAgICAgICAgICBpbmRlbnRpbmcgPSBmYWxzZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy9UbyBiZSB1c2VkIGZvciBjbGVhbmluZy11cCBvcnBoYW5lZCByb2xsLXVwIGNhcHRpb25zXHJcbiAgICAgICAgcm93LmN1ZVN0YXJ0VGltZSA9IHN0YXJ0VGltZTtcclxuXHJcbiAgICAgICAgLy8gR2l2ZSBhIHNsaWdodCBidW1wIHRvIHRoZSBlbmRUaW1lIGlmIGl0J3MgZXF1YWwgdG8gc3RhcnRUaW1lIHRvIGF2b2lkIGEgU3ludGF4RXJyb3IgaW4gSUVcclxuICAgICAgICBpZiAoc3RhcnRUaW1lID09PSBlbmRUaW1lKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgIGVuZFRpbWUgKz0gMC4wMDAxO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY3VlID0gbmV3IFZUVEN1ZShzdGFydFRpbWUsIGVuZFRpbWUsIGZpeExpbmVCcmVha3ModGV4dC50cmltKCkpKTtcclxuXHJcbiAgICAgICAgaWYgKGluZGVudCA+PSAxNilcclxuICAgICAgICB7XHJcbiAgICAgICAgICBpbmRlbnQtLTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgIGluZGVudCsrO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gVlRUQ3VlLmxpbmUgZ2V0J3MgZmxha2V5IHdoZW4gdXNpbmcgY29udHJvbHMsIHNvIGxldCdzIG5vdyBpbmNsdWRlIGxpbmUgMTMmMTRcclxuICAgICAgICAvLyBhbHNvLCBkcm9wIGxpbmUgMSBzaW5jZSBpdCdzIHRvIGNsb3NlIHRvIHRoZSB0b3BcclxuICAgICAgICBpZiAobmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvRmlyZWZveFxcLy8pKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgIGN1ZS5saW5lID0gciArIDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICBjdWUubGluZSA9IChyID4gNyA/IHIgLSAyIDogciArIDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjdWUuYWxpZ24gPSAnbGVmdCc7XHJcbiAgICAgICAgLy8gQ2xhbXAgdGhlIHBvc2l0aW9uIGJldHdlZW4gMCBhbmQgMTAwIC0gaWYgb3V0IG9mIHRoZXNlIGJvdW5kcywgRmlyZWZveCB0aHJvd3MgYW4gZXhjZXB0aW9uIGFuZCBjYXB0aW9ucyBicmVha1xyXG4gICAgICAgIGN1ZS5wb3NpdGlvbiA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEwMCwgMTAwICogKGluZGVudCAvIDMyKSArIChuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9GaXJlZm94XFwvLykgPyA1MCA6IDApKSk7XHJcbiAgICAgICAgdHJhY2suYWRkQ3VlKGN1ZSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDdWVzO1xyXG4iLCJpbXBvcnQgQmluYXJ5U2VhcmNoIGZyb20gJy4vYmluYXJ5LXNlYXJjaCc7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZmluZEZyYWdXaXRoQ0MoZnJhZ21lbnRzLCBDQykge1xyXG4gIHJldHVybiBCaW5hcnlTZWFyY2guc2VhcmNoKGZyYWdtZW50cywgKGNhbmRpZGF0ZSkgPT4ge1xyXG4gICAgIGlmIChjYW5kaWRhdGUuY2MgPCBDQykge1xyXG4gICAgICAgIHJldHVybiAxO1xyXG4gICAgICB9IGVsc2UgaWYgKGNhbmRpZGF0ZS5jYyA+IENDKSB7XHJcbiAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgfVxyXG4gIH0pO1xyXG59XHJcbiIsIi8qXHJcbiAqIEVXTUEgQmFuZHdpZHRoIEVzdGltYXRvclxyXG4gKiAgLSBoZWF2aWx5IGluc3BpcmVkIGZyb20gc2hha2EtcGxheWVyXHJcbiAqIFRyYWNrcyBiYW5kd2lkdGggc2FtcGxlcyBhbmQgZXN0aW1hdGVzIGF2YWlsYWJsZSBiYW5kd2lkdGguXHJcbiAqIEJhc2VkIG9uIHRoZSBtaW5pbXVtIG9mIHR3byBleHBvbmVudGlhbGx5LXdlaWdodGVkIG1vdmluZyBhdmVyYWdlcyB3aXRoXHJcbiAqIGRpZmZlcmVudCBoYWxmLWxpdmVzLlxyXG4gKi9cclxuXHJcbmltcG9ydCBFV01BIGZyb20gJy4uL3V0aWxzL2V3bWEnO1xyXG5cclxuXHJcbmNsYXNzIEV3bWFCYW5kV2lkdGhFc3RpbWF0b3Ige1xyXG5cclxuICBjb25zdHJ1Y3RvcihobHMsc2xvdyxmYXN0LGRlZmF1bHRFc3RpbWF0ZSkge1xyXG4gICAgdGhpcy5obHMgPSBobHM7XHJcbiAgICB0aGlzLmRlZmF1bHRFc3RpbWF0ZV8gPSBkZWZhdWx0RXN0aW1hdGU7XHJcbiAgICB0aGlzLm1pbldlaWdodF8gPSAwLjAwMTtcclxuICAgIHRoaXMubWluRGVsYXlNc18gPSA1MDtcclxuICAgIHRoaXMuc2xvd18gPSBuZXcgRVdNQShzbG93KTtcclxuICAgIHRoaXMuZmFzdF8gPSBuZXcgRVdNQShmYXN0KTtcclxuICB9XHJcblxyXG4gIHNhbXBsZShkdXJhdGlvbk1zLG51bUJ5dGVzKSB7XHJcbiAgICBkdXJhdGlvbk1zID0gTWF0aC5tYXgoZHVyYXRpb25NcywgdGhpcy5taW5EZWxheU1zXyk7XHJcbiAgICB2YXIgYmFuZHdpZHRoID0gODAwMCogbnVtQnl0ZXMgLyBkdXJhdGlvbk1zLFxyXG4gICAgLy9jb25zb2xlLmxvZygnaW5zdGFudCBidzonKyBNYXRoLnJvdW5kKGJhbmR3aWR0aCkpO1xyXG4gICAgLy8gd2Ugd2VpZ2h0IHNhbXBsZSB1c2luZyBsb2FkaW5nIGR1cmF0aW9uLi4uLlxyXG4gICAgICAgIHdlaWdodCA9IGR1cmF0aW9uTXMgLyAxMDAwO1xyXG4gICAgdGhpcy5mYXN0Xy5zYW1wbGUod2VpZ2h0LGJhbmR3aWR0aCk7XHJcbiAgICB0aGlzLnNsb3dfLnNhbXBsZSh3ZWlnaHQsYmFuZHdpZHRoKTtcclxuICB9XHJcblxyXG4gIGNhbkVzdGltYXRlKCkge1xyXG4gICAgbGV0IGZhc3QgPSB0aGlzLmZhc3RfO1xyXG4gICAgcmV0dXJuIChmYXN0ICYmIGZhc3QuZ2V0VG90YWxXZWlnaHQoKSA+PSB0aGlzLm1pbldlaWdodF8pO1xyXG4gIH1cclxuXHJcblxyXG4gIGdldEVzdGltYXRlKCkge1xyXG4gICAgaWYgKHRoaXMuY2FuRXN0aW1hdGUoKSkge1xyXG4gICAgICAvL2NvbnNvbGUubG9nKCdzbG93IGVzdGltYXRlOicrIE1hdGgucm91bmQodGhpcy5zbG93Xy5nZXRFc3RpbWF0ZSgpKSk7XHJcbiAgICAgIC8vY29uc29sZS5sb2coJ2Zhc3QgZXN0aW1hdGU6JysgTWF0aC5yb3VuZCh0aGlzLmZhc3RfLmdldEVzdGltYXRlKCkpKTtcclxuICAgICAgLy8gVGFrZSB0aGUgbWluaW11bSBvZiB0aGVzZSB0d28gZXN0aW1hdGVzLiAgVGhpcyBzaG91bGQgaGF2ZSB0aGUgZWZmZWN0IG9mXHJcbiAgICAgIC8vIGFkYXB0aW5nIGRvd24gcXVpY2tseSwgYnV0IHVwIG1vcmUgc2xvd2x5LlxyXG4gICAgICByZXR1cm4gTWF0aC5taW4odGhpcy5mYXN0Xy5nZXRFc3RpbWF0ZSgpLHRoaXMuc2xvd18uZ2V0RXN0aW1hdGUoKSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gdGhpcy5kZWZhdWx0RXN0aW1hdGVfO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZGVzdHJveSgpIHtcclxuICB9XHJcbn1cclxuZXhwb3J0IGRlZmF1bHQgRXdtYUJhbmRXaWR0aEVzdGltYXRvcjtcclxuXHJcbiIsIi8qXHJcbiAqIGNvbXB1dGUgYW4gRXhwb25lbnRpYWwgV2VpZ2h0ZWQgbW92aW5nIGF2ZXJhZ2VcclxuICogLSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Nb3ZpbmdfYXZlcmFnZSNFeHBvbmVudGlhbF9tb3ZpbmdfYXZlcmFnZVxyXG4gKiAgLSBoZWF2aWx5IGluc3BpcmVkIGZyb20gc2hha2EtcGxheWVyXHJcbiAqL1xyXG5cclxuY2xhc3MgRVdNQSB7XHJcblxyXG4gLy8gIEFib3V0IGhhbGYgb2YgdGhlIGVzdGltYXRlZCB2YWx1ZSB3aWxsIGJlIGZyb20gdGhlIGxhc3QgfGhhbGZMaWZlfCBzYW1wbGVzIGJ5IHdlaWdodC5cclxuICBjb25zdHJ1Y3RvcihoYWxmTGlmZSkge1xyXG4gICAgLy8gTGFyZ2VyIHZhbHVlcyBvZiBhbHBoYSBleHBpcmUgaGlzdG9yaWNhbCBkYXRhIG1vcmUgc2xvd2x5LlxyXG4gICAgdGhpcy5hbHBoYV8gPSBoYWxmTGlmZSA/IE1hdGguZXhwKE1hdGgubG9nKDAuNSkgLyBoYWxmTGlmZSkgOiAwO1xyXG4gICAgdGhpcy5lc3RpbWF0ZV8gPSAwO1xyXG4gICAgdGhpcy50b3RhbFdlaWdodF8gPSAwO1xyXG4gIH1cclxuXHJcbiAgc2FtcGxlKHdlaWdodCx2YWx1ZSkge1xyXG4gICAgdmFyIGFkakFscGhhID0gTWF0aC5wb3codGhpcy5hbHBoYV8sIHdlaWdodCk7XHJcbiAgICB0aGlzLmVzdGltYXRlXyA9IHZhbHVlICogKDEgLSBhZGpBbHBoYSkgKyBhZGpBbHBoYSAqIHRoaXMuZXN0aW1hdGVfO1xyXG4gICAgdGhpcy50b3RhbFdlaWdodF8gKz0gd2VpZ2h0O1xyXG4gIH1cclxuXHJcbiAgZ2V0VG90YWxXZWlnaHQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy50b3RhbFdlaWdodF87XHJcbiAgfVxyXG5cclxuICBnZXRFc3RpbWF0ZSgpIHtcclxuICAgIGlmICh0aGlzLmFscGhhXykge1xyXG4gICAgICB2YXIgemVyb0ZhY3RvciA9IDEgLSBNYXRoLnBvdyh0aGlzLmFscGhhXywgdGhpcy50b3RhbFdlaWdodF8pO1xyXG4gICAgICByZXR1cm4gdGhpcy5lc3RpbWF0ZV8gLyB6ZXJvRmFjdG9yO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuIHRoaXMuZXN0aW1hdGVfO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgRVdNQTtcclxuIiwiZnVuY3Rpb24gbm9vcCgpIHt9XHJcblxyXG5jb25zdCBmYWtlTG9nZ2VyID0ge1xyXG4gIHRyYWNlOiBub29wLFxyXG4gIGRlYnVnOiBub29wLFxyXG4gIGxvZzogbm9vcCxcclxuICB3YXJuOiBub29wLFxyXG4gIGluZm86IG5vb3AsXHJcbiAgZXJyb3I6IG5vb3BcclxufTtcclxuXHJcbmxldCBleHBvcnRlZExvZ2dlciA9IGZha2VMb2dnZXI7XHJcblxyXG4vKmdsb2JhbHMgc2VsZjogZmFsc2UgKi9cclxuXHJcbi8vbGV0IGxhc3RDYWxsVGltZTtcclxuLy8gZnVuY3Rpb24gZm9ybWF0TXNnV2l0aFRpbWVJbmZvKHR5cGUsIG1zZykge1xyXG4vLyAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XHJcbi8vICAgY29uc3QgZGlmZiA9IGxhc3RDYWxsVGltZSA/ICcrJyArIChub3cgLSBsYXN0Q2FsbFRpbWUpIDogJzAnO1xyXG4vLyAgIGxhc3RDYWxsVGltZSA9IG5vdztcclxuLy8gICBtc2cgPSAobmV3IERhdGUobm93KSkudG9JU09TdHJpbmcoKSArICcgfCBbJyArICB0eXBlICsgJ10gPiAnICsgbXNnICsgJyAoICcgKyBkaWZmICsgJyBtcyApJztcclxuLy8gICByZXR1cm4gbXNnO1xyXG4vLyB9XHJcblxyXG5mdW5jdGlvbiBmb3JtYXRNc2codHlwZSwgbXNnKSB7XHJcbiAgbXNnID0gJ1snICsgIHR5cGUgKyAnXSA+ICcgKyBtc2c7XHJcbiAgcmV0dXJuIG1zZztcclxufVxyXG5cclxuZnVuY3Rpb24gY29uc29sZVByaW50Rm4odHlwZSkge1xyXG4gIGNvbnN0IGZ1bmMgPSBzZWxmLmNvbnNvbGVbdHlwZV07XHJcbiAgaWYgKGZ1bmMpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiguLi5hcmdzKSB7XHJcbiAgICAgIGlmKGFyZ3NbMF0pIHtcclxuICAgICAgICBhcmdzWzBdID0gZm9ybWF0TXNnKHR5cGUsIGFyZ3NbMF0pO1xyXG4gICAgICB9XHJcbiAgICAgIGZ1bmMuYXBwbHkoc2VsZi5jb25zb2xlLCBhcmdzKTtcclxuICAgIH07XHJcbiAgfVxyXG4gIHJldHVybiBub29wO1xyXG59XHJcblxyXG5mdW5jdGlvbiBleHBvcnRMb2dnZXJGdW5jdGlvbnMoZGVidWdDb25maWcsIC4uLmZ1bmN0aW9ucykge1xyXG4gIGZ1bmN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uKHR5cGUpIHtcclxuICAgIGV4cG9ydGVkTG9nZ2VyW3R5cGVdID0gZGVidWdDb25maWdbdHlwZV0gPyBkZWJ1Z0NvbmZpZ1t0eXBlXS5iaW5kKGRlYnVnQ29uZmlnKSA6IGNvbnNvbGVQcmludEZuKHR5cGUpO1xyXG4gIH0pO1xyXG59XHJcblxyXG5leHBvcnQgdmFyIGVuYWJsZUxvZ3MgPSBmdW5jdGlvbihkZWJ1Z0NvbmZpZykge1xyXG4gIGlmIChkZWJ1Z0NvbmZpZyA9PT0gdHJ1ZSB8fCB0eXBlb2YgZGVidWdDb25maWcgPT09ICdvYmplY3QnKSB7XHJcbiAgICBleHBvcnRMb2dnZXJGdW5jdGlvbnMoZGVidWdDb25maWcsXHJcbiAgICAgIC8vIFJlbW92ZSBvdXQgZnJvbSBsaXN0IGhlcmUgdG8gaGFyZC1kaXNhYmxlIGEgbG9nLWxldmVsXHJcbiAgICAgIC8vJ3RyYWNlJyxcclxuICAgICAgJ2RlYnVnJyxcclxuICAgICAgJ2xvZycsXHJcbiAgICAgICdpbmZvJyxcclxuICAgICAgJ3dhcm4nLFxyXG4gICAgICAnZXJyb3InXHJcbiAgICApO1xyXG4gICAgLy8gU29tZSBicm93c2VycyBkb24ndCBhbGxvdyB0byB1c2UgYmluZCBvbiBjb25zb2xlIG9iamVjdCBhbnl3YXlcclxuICAgIC8vIGZhbGxiYWNrIHRvIGRlZmF1bHQgaWYgbmVlZGVkXHJcbiAgICB0cnkge1xyXG4gICAgIGV4cG9ydGVkTG9nZ2VyLmxvZygpO1xyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICBleHBvcnRlZExvZ2dlciA9IGZha2VMb2dnZXI7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGVsc2Uge1xyXG4gICAgZXhwb3J0ZWRMb2dnZXIgPSBmYWtlTG9nZ2VyO1xyXG4gIH1cclxufTtcclxuXHJcbmV4cG9ydCB2YXIgbG9nZ2VyID0gZXhwb3J0ZWRMb2dnZXI7XHJcbiIsIi8qKlxyXG4gKiAgVGltZVJhbmdlcyB0byBzdHJpbmcgaGVscGVyXHJcbiAqL1xyXG5cclxuY29uc3QgVGltZVJhbmdlcyA9IHtcclxuICB0b1N0cmluZyA6IGZ1bmN0aW9uKHIpIHtcclxuICAgIHZhciBsb2cgPSAnJywgbGVuID0gci5sZW5ndGg7XHJcbiAgICBmb3IgKHZhciBpPTA7IGk8bGVuOyBpKyspIHtcclxuICAgICAgbG9nICs9ICdbJyArIHIuc3RhcnQoaSkudG9GaXhlZCgzKSArICcsJyArIHIuZW5kKGkpLnRvRml4ZWQoMykgKyAnXSc7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbG9nO1xyXG4gIH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVGltZVJhbmdlcztcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAyMDEzIHZ0dC5qcyBDb250cmlidXRvcnNcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuXHJcbmV4cG9ydCBkZWZhdWx0IChmdW5jdGlvbigpIHtcclxuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LlZUVEN1ZSkge1xyXG4gICAgcmV0dXJuIHdpbmRvdy5WVFRDdWU7XHJcbiAgfVxyXG5cclxuICB2YXIgYXV0b0tleXdvcmQgPSAnYXV0byc7XHJcbiAgdmFyIGRpcmVjdGlvblNldHRpbmcgPSB7XHJcbiAgICAnJzogdHJ1ZSxcclxuICAgIGxyOiB0cnVlLFxyXG4gICAgcmw6IHRydWVcclxuICB9O1xyXG4gIHZhciBhbGlnblNldHRpbmcgPSB7XHJcbiAgICBzdGFydDogdHJ1ZSxcclxuICAgIG1pZGRsZTogdHJ1ZSxcclxuICAgIGVuZDogdHJ1ZSxcclxuICAgIGxlZnQ6IHRydWUsXHJcbiAgICByaWdodDogdHJ1ZVxyXG4gIH07XHJcblxyXG4gIGZ1bmN0aW9uIGZpbmREaXJlY3Rpb25TZXR0aW5nKHZhbHVlKSB7XHJcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICB2YXIgZGlyID0gZGlyZWN0aW9uU2V0dGluZ1t2YWx1ZS50b0xvd2VyQ2FzZSgpXTtcclxuICAgIHJldHVybiBkaXIgPyB2YWx1ZS50b0xvd2VyQ2FzZSgpIDogZmFsc2U7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBmaW5kQWxpZ25TZXR0aW5nKHZhbHVlKSB7XHJcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICB2YXIgYWxpZ24gPSBhbGlnblNldHRpbmdbdmFsdWUudG9Mb3dlckNhc2UoKV07XHJcbiAgICByZXR1cm4gYWxpZ24gPyB2YWx1ZS50b0xvd2VyQ2FzZSgpIDogZmFsc2U7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBleHRlbmQob2JqKSB7XHJcbiAgICB2YXIgaSA9IDE7XHJcbiAgICBmb3IgKDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICB2YXIgY29iaiA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgZm9yICh2YXIgcCBpbiBjb2JqKSB7XHJcbiAgICAgICAgb2JqW3BdID0gY29ialtwXTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBvYmo7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBWVFRDdWUoc3RhcnRUaW1lLCBlbmRUaW1lLCB0ZXh0KSB7XHJcbiAgICB2YXIgY3VlID0gdGhpcztcclxuICAgIHZhciBpc0lFOCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgIGlmICh0eXBlb2YgbmF2aWdhdG9yID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gKC9NU0lFXFxzOFxcLjAvKS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xyXG4gICAgfSkoKTtcclxuICAgIHZhciBiYXNlT2JqID0ge307XHJcblxyXG4gICAgaWYgKGlzSUU4KSB7XHJcbiAgICAgIGN1ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2N1c3RvbScpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgYmFzZU9iai5lbnVtZXJhYmxlID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNoaW0gaW1wbGVtZW50YXRpb24gc3BlY2lmaWMgcHJvcGVydGllcy4gVGhlc2UgcHJvcGVydGllcyBhcmUgbm90IGluXHJcbiAgICAgKiB0aGUgc3BlYy5cclxuICAgICAqL1xyXG5cclxuICAgIC8vIExldHMgdXMga25vdyB3aGVuIHRoZSBWVFRDdWUncyBkYXRhIGhhcyBjaGFuZ2VkIGluIHN1Y2ggYSB3YXkgdGhhdCB3ZSBuZWVkXHJcbiAgICAvLyB0byByZWNvbXB1dGUgaXRzIGRpc3BsYXkgc3RhdGUuIFRoaXMgbGV0cyB1cyBjb21wdXRlIGl0cyBkaXNwbGF5IHN0YXRlXHJcbiAgICAvLyBsYXppbHkuXHJcbiAgICBjdWUuaGFzQmVlblJlc2V0ID0gZmFsc2U7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBWVFRDdWUgYW5kIFRleHRUcmFja0N1ZSBwcm9wZXJ0aWVzXHJcbiAgICAgKiBodHRwOi8vZGV2LnczLm9yZy9odG1sNS93ZWJ2dHQvI3Z0dGN1ZS1pbnRlcmZhY2VcclxuICAgICAqL1xyXG5cclxuICAgIHZhciBfaWQgPSAnJztcclxuICAgIHZhciBfcGF1c2VPbkV4aXQgPSBmYWxzZTtcclxuICAgIHZhciBfc3RhcnRUaW1lID0gc3RhcnRUaW1lO1xyXG4gICAgdmFyIF9lbmRUaW1lID0gZW5kVGltZTtcclxuICAgIHZhciBfdGV4dCA9IHRleHQ7XHJcbiAgICB2YXIgX3JlZ2lvbiA9IG51bGw7XHJcbiAgICB2YXIgX3ZlcnRpY2FsID0gJyc7XHJcbiAgICB2YXIgX3NuYXBUb0xpbmVzID0gdHJ1ZTtcclxuICAgIHZhciBfbGluZSA9ICdhdXRvJztcclxuICAgIHZhciBfbGluZUFsaWduID0gJ3N0YXJ0JztcclxuICAgIHZhciBfcG9zaXRpb24gPSA1MDtcclxuICAgIHZhciBfcG9zaXRpb25BbGlnbiA9ICdtaWRkbGUnO1xyXG4gICAgdmFyIF9zaXplID0gNTA7XHJcbiAgICB2YXIgX2FsaWduID0gJ21pZGRsZSc7XHJcblxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSwgJ2lkJywgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XHJcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBfaWQ7XHJcbiAgICAgIH0sXHJcbiAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgX2lkID0gJycgKyB2YWx1ZTtcclxuICAgICAgfVxyXG4gICAgfSkpO1xyXG5cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsICdwYXVzZU9uRXhpdCcsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xyXG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX3BhdXNlT25FeGl0O1xyXG4gICAgICB9LFxyXG4gICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgIF9wYXVzZU9uRXhpdCA9ICEhdmFsdWU7XHJcbiAgICAgIH1cclxuICAgIH0pKTtcclxuXHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLCAnc3RhcnRUaW1lJywgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XHJcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBfc3RhcnRUaW1lO1xyXG4gICAgICB9LFxyXG4gICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdTdGFydCB0aW1lIG11c3QgYmUgc2V0IHRvIGEgbnVtYmVyLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBfc3RhcnRUaW1lID0gdmFsdWU7XHJcbiAgICAgICAgdGhpcy5oYXNCZWVuUmVzZXQgPSB0cnVlO1xyXG4gICAgICB9XHJcbiAgICB9KSk7XHJcblxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSwgJ2VuZFRpbWUnLCBleHRlbmQoe30sIGJhc2VPYmosIHtcclxuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9lbmRUaW1lO1xyXG4gICAgICB9LFxyXG4gICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFbmQgdGltZSBtdXN0IGJlIHNldCB0byBhIG51bWJlci4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgX2VuZFRpbWUgPSB2YWx1ZTtcclxuICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XHJcbiAgICAgIH1cclxuICAgIH0pKTtcclxuXHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLCAndGV4dCcsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xyXG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX3RleHQ7XHJcbiAgICAgIH0sXHJcbiAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgX3RleHQgPSAnJyArIHZhbHVlO1xyXG4gICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgfSkpO1xyXG5cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsICdyZWdpb24nLCBleHRlbmQoe30sIGJhc2VPYmosIHtcclxuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9yZWdpb247XHJcbiAgICAgIH0sXHJcbiAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgX3JlZ2lvbiA9IHZhbHVlO1xyXG4gICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgfSkpO1xyXG5cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsICd2ZXJ0aWNhbCcsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xyXG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX3ZlcnRpY2FsO1xyXG4gICAgICB9LFxyXG4gICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgIHZhciBzZXR0aW5nID0gZmluZERpcmVjdGlvblNldHRpbmcodmFsdWUpO1xyXG4gICAgICAgIC8vIEhhdmUgdG8gY2hlY2sgZm9yIGZhbHNlIGJlY2F1c2UgdGhlIHNldHRpbmcgYW4gYmUgYW4gZW1wdHkgc3RyaW5nLlxyXG4gICAgICAgIGlmIChzZXR0aW5nID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdBbiBpbnZhbGlkIG9yIGlsbGVnYWwgc3RyaW5nIHdhcyBzcGVjaWZpZWQuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF92ZXJ0aWNhbCA9IHNldHRpbmc7XHJcbiAgICAgICAgdGhpcy5oYXNCZWVuUmVzZXQgPSB0cnVlO1xyXG4gICAgICB9XHJcbiAgICB9KSk7XHJcblxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSwgJ3NuYXBUb0xpbmVzJywgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XHJcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBfc25hcFRvTGluZXM7XHJcbiAgICAgIH0sXHJcbiAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgX3NuYXBUb0xpbmVzID0gISF2YWx1ZTtcclxuICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XHJcbiAgICAgIH1cclxuICAgIH0pKTtcclxuXHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLCAnbGluZScsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xyXG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX2xpbmU7XHJcbiAgICAgIH0sXHJcbiAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicgJiYgdmFsdWUgIT09IGF1dG9LZXl3b3JkKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0FuIGludmFsaWQgbnVtYmVyIG9yIGlsbGVnYWwgc3RyaW5nIHdhcyBzcGVjaWZpZWQuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9saW5lID0gdmFsdWU7XHJcbiAgICAgICAgdGhpcy5oYXNCZWVuUmVzZXQgPSB0cnVlO1xyXG4gICAgICB9XHJcbiAgICB9KSk7XHJcblxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSwgJ2xpbmVBbGlnbicsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xyXG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX2xpbmVBbGlnbjtcclxuICAgICAgfSxcclxuICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICB2YXIgc2V0dGluZyA9IGZpbmRBbGlnblNldHRpbmcodmFsdWUpO1xyXG4gICAgICAgIGlmICghc2V0dGluZykge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdBbiBpbnZhbGlkIG9yIGlsbGVnYWwgc3RyaW5nIHdhcyBzcGVjaWZpZWQuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9saW5lQWxpZ24gPSBzZXR0aW5nO1xyXG4gICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgfSkpO1xyXG5cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsICdwb3NpdGlvbicsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xyXG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX3Bvc2l0aW9uO1xyXG4gICAgICB9LFxyXG4gICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgIGlmICh2YWx1ZSA8IDAgfHwgdmFsdWUgPiAxMDApIHtcclxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUG9zaXRpb24gbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDEwMC4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgX3Bvc2l0aW9uID0gdmFsdWU7XHJcbiAgICAgICAgdGhpcy5oYXNCZWVuUmVzZXQgPSB0cnVlO1xyXG4gICAgICB9XHJcbiAgICB9KSk7XHJcblxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSwgJ3Bvc2l0aW9uQWxpZ24nLCBleHRlbmQoe30sIGJhc2VPYmosIHtcclxuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9wb3NpdGlvbkFsaWduO1xyXG4gICAgICB9LFxyXG4gICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgIHZhciBzZXR0aW5nID0gZmluZEFsaWduU2V0dGluZyh2YWx1ZSk7XHJcbiAgICAgICAgaWYgKCFzZXR0aW5nKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0FuIGludmFsaWQgb3IgaWxsZWdhbCBzdHJpbmcgd2FzIHNwZWNpZmllZC4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgX3Bvc2l0aW9uQWxpZ24gPSBzZXR0aW5nO1xyXG4gICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgfSkpO1xyXG5cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsICdzaXplJywgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XHJcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBfc2l6ZTtcclxuICAgICAgfSxcclxuICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICBpZiAodmFsdWUgPCAwIHx8IHZhbHVlID4gMTAwKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NpemUgbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDEwMC4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgX3NpemUgPSB2YWx1ZTtcclxuICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XHJcbiAgICAgIH1cclxuICAgIH0pKTtcclxuXHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLCAnYWxpZ24nLCBleHRlbmQoe30sIGJhc2VPYmosIHtcclxuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9hbGlnbjtcclxuICAgICAgfSxcclxuICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICB2YXIgc2V0dGluZyA9IGZpbmRBbGlnblNldHRpbmcodmFsdWUpO1xyXG4gICAgICAgIGlmICghc2V0dGluZykge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdBbiBpbnZhbGlkIG9yIGlsbGVnYWwgc3RyaW5nIHdhcyBzcGVjaWZpZWQuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9hbGlnbiA9IHNldHRpbmc7XHJcbiAgICAgICAgdGhpcy5oYXNCZWVuUmVzZXQgPSB0cnVlO1xyXG4gICAgICB9XHJcbiAgICB9KSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBPdGhlciA8dHJhY2s+IHNwZWMgZGVmaW5lZCBwcm9wZXJ0aWVzXHJcbiAgICAgKi9cclxuXHJcbiAgICAvLyBodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS90aGUtdmlkZW8tZWxlbWVudC5odG1sI3RleHQtdHJhY2stY3VlLWRpc3BsYXktc3RhdGVcclxuICAgIGN1ZS5kaXNwbGF5U3RhdGUgPSB1bmRlZmluZWQ7XHJcblxyXG4gICAgaWYgKGlzSUU4KSB7XHJcbiAgICAgIHJldHVybiBjdWU7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBWVFRDdWUgbWV0aG9kc1xyXG4gICAqL1xyXG5cclxuICBWVFRDdWUucHJvdG90eXBlLmdldEN1ZUFzSFRNTCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIC8vIEFzc3VtZSBXZWJWVFQuY29udmVydEN1ZVRvRE9NVHJlZSBpcyBvbiB0aGUgZ2xvYmFsLlxyXG4gICAgdmFyIFdlYlZUVCA9IHdpbmRvdy5XZWJWVFQ7XHJcbiAgICByZXR1cm4gV2ViVlRULmNvbnZlcnRDdWVUb0RPTVRyZWUod2luZG93LCB0aGlzLnRleHQpO1xyXG4gIH07XHJcblxyXG4gIHJldHVybiBWVFRDdWU7XHJcbn0pKCk7XHJcbiIsIi8qXHJcbiAqIFNvdXJjZTogaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvdnR0LmpzL2Jsb2IvbWFzdGVyL2Rpc3QvdnR0LmpzI0wxNzE2XHJcbiAqL1xyXG5cclxuaW1wb3J0IFZUVEN1ZSBmcm9tICcuL3Z0dGN1ZSc7XHJcblxyXG5jb25zdCBTdHJpbmdEZWNvZGVyID0gZnVuY3Rpb24gU3RyaW5nRGVjb2RlcigpIHtcclxuICByZXR1cm4ge1xyXG4gICAgZGVjb2RlOiBmdW5jdGlvbihkYXRhKSB7XHJcbiAgICAgIGlmICghZGF0YSkge1xyXG4gICAgICAgIHJldHVybiAnJztcclxuICAgICAgfVxyXG4gICAgICBpZiAodHlwZW9mIGRhdGEgIT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFcnJvciAtIGV4cGVjdGVkIHN0cmluZyBkYXRhLicpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoZW5jb2RlVVJJQ29tcG9uZW50KGRhdGEpKTtcclxuICAgICAgICB9LFxyXG4gICAgfTtcclxuICB9O1xyXG5cclxuZnVuY3Rpb24gVlRUUGFyc2VyKCkge1xyXG4gICAgdGhpcy53aW5kb3cgPSB3aW5kb3c7XHJcbiAgICB0aGlzLnN0YXRlID0gJ0lOSVRJQUwnO1xyXG4gICAgdGhpcy5idWZmZXIgPSAnJztcclxuICAgIHRoaXMuZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKCk7XHJcbiAgICB0aGlzLnJlZ2lvbkxpc3QgPSBbXTtcclxufVxyXG5cclxuXHJcbi8vIFRyeSB0byBwYXJzZSBpbnB1dCBhcyBhIHRpbWUgc3RhbXAuXHJcbmZ1bmN0aW9uIHBhcnNlVGltZVN0YW1wKGlucHV0KSB7XHJcblxyXG4gIGZ1bmN0aW9uIGNvbXB1dGVTZWNvbmRzKGgsIG0sIHMsIGYpIHtcclxuICAgIHJldHVybiAoaCB8IDApICogMzYwMCArIChtIHwgMCkgKiA2MCArIChzIHwgMCkgKyAoZiB8IDApIC8gMTAwMDtcclxuICB9XHJcblxyXG4gIHZhciBtID0gaW5wdXQubWF0Y2goL14oXFxkKyk6KFxcZHsyfSkoOlxcZHsyfSk/XFwuKFxcZHszfSkvKTtcclxuICBpZiAoIW0pIHtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuXHJcbiAgaWYgKG1bM10pIHtcclxuICAgIC8vIFRpbWVzdGFtcCB0YWtlcyB0aGUgZm9ybSBvZiBbaG91cnNdOlttaW51dGVzXTpbc2Vjb25kc10uW21pbGxpc2Vjb25kc11cclxuICAgIHJldHVybiBjb21wdXRlU2Vjb25kcyhtWzFdLCBtWzJdLCBtWzNdLnJlcGxhY2UoJzonLCAnJyksIG1bNF0pO1xyXG4gIH0gZWxzZSBpZiAobVsxXSA+IDU5KSB7XHJcbiAgICAvLyBUaW1lc3RhbXAgdGFrZXMgdGhlIGZvcm0gb2YgW2hvdXJzXTpbbWludXRlc10uW21pbGxpc2Vjb25kc11cclxuICAgIC8vIEZpcnN0IHBvc2l0aW9uIGlzIGhvdXJzIGFzIGl0J3Mgb3ZlciA1OS5cclxuICAgIHJldHVybiBjb21wdXRlU2Vjb25kcyhtWzFdLCBtWzJdLCAwLCBtWzRdKTtcclxuICB9IGVsc2Uge1xyXG4gICAgLy8gVGltZXN0YW1wIHRha2VzIHRoZSBmb3JtIG9mIFttaW51dGVzXTpbc2Vjb25kc10uW21pbGxpc2Vjb25kc11cclxuICAgIHJldHVybiBjb21wdXRlU2Vjb25kcygwLCBtWzFdLCBtWzJdLCBtWzRdKTtcclxuICB9XHJcbn1cclxuXHJcbi8vIEEgc2V0dGluZ3Mgb2JqZWN0IGhvbGRzIGtleS92YWx1ZSBwYWlycyBhbmQgd2lsbCBpZ25vcmUgYW55dGhpbmcgYnV0IHRoZSBmaXJzdFxyXG4vLyBhc3NpZ25tZW50IHRvIGEgc3BlY2lmaWMga2V5LlxyXG5mdW5jdGlvbiBTZXR0aW5ncygpIHtcclxuICB0aGlzLnZhbHVlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbn1cclxuXHJcblNldHRpbmdzLnByb3RvdHlwZSA9IHtcclxuICAvLyBPbmx5IGFjY2VwdCB0aGUgZmlyc3QgYXNzaWdubWVudCB0byBhbnkga2V5LlxyXG4gIHNldDogZnVuY3Rpb24oaywgdikge1xyXG4gICAgaWYgKCF0aGlzLmdldChrKSAmJiB2ICE9PSAnJykge1xyXG4gICAgICB0aGlzLnZhbHVlc1trXSA9IHY7XHJcbiAgICB9XHJcbiAgfSxcclxuICAvLyBSZXR1cm4gdGhlIHZhbHVlIGZvciBhIGtleSwgb3IgYSBkZWZhdWx0IHZhbHVlLlxyXG4gIC8vIElmICdkZWZhdWx0S2V5JyBpcyBwYXNzZWQgdGhlbiAnZGZsdCcgaXMgYXNzdW1lZCB0byBiZSBhbiBvYmplY3Qgd2l0aFxyXG4gIC8vIGEgbnVtYmVyIG9mIHBvc3NpYmxlIGRlZmF1bHQgdmFsdWVzIGFzIHByb3BlcnRpZXMgd2hlcmUgJ2RlZmF1bHRLZXknIGlzXHJcbiAgLy8gdGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdGhhdCB3aWxsIGJlIGNob3Nlbjsgb3RoZXJ3aXNlIGl0J3MgYXNzdW1lZCB0byBiZVxyXG4gIC8vIGEgc2luZ2xlIHZhbHVlLlxyXG4gIGdldDogZnVuY3Rpb24oaywgZGZsdCwgZGVmYXVsdEtleSkge1xyXG4gICAgaWYgKGRlZmF1bHRLZXkpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuaGFzKGspID8gdGhpcy52YWx1ZXNba10gOiBkZmx0W2RlZmF1bHRLZXldO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXMuaGFzKGspID8gdGhpcy52YWx1ZXNba10gOiBkZmx0O1xyXG4gIH0sXHJcbiAgLy8gQ2hlY2sgd2hldGhlciB3ZSBoYXZlIGEgdmFsdWUgZm9yIGEga2V5LlxyXG4gIGhhczogZnVuY3Rpb24oaykge1xyXG4gICAgcmV0dXJuIGsgaW4gdGhpcy52YWx1ZXM7XHJcbiAgfSxcclxuICAvLyBBY2NlcHQgYSBzZXR0aW5nIGlmIGl0cyBvbmUgb2YgdGhlIGdpdmVuIGFsdGVybmF0aXZlcy5cclxuICBhbHQ6IGZ1bmN0aW9uKGssIHYsIGEpIHtcclxuICAgIGZvciAodmFyIG4gPSAwOyBuIDwgYS5sZW5ndGg7ICsrbikge1xyXG4gICAgICBpZiAodiA9PT0gYVtuXSkge1xyXG4gICAgICAgIHRoaXMuc2V0KGssIHYpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSxcclxuICAvLyBBY2NlcHQgYSBzZXR0aW5nIGlmIGl0cyBhIHZhbGlkIChzaWduZWQpIGludGVnZXIuXHJcbiAgaW50ZWdlcjogZnVuY3Rpb24oaywgdikge1xyXG4gICAgaWYgKC9eLT9cXGQrJC8udGVzdCh2KSkgeyAvLyBpbnRlZ2VyXHJcbiAgICAgIHRoaXMuc2V0KGssIHBhcnNlSW50KHYsIDEwKSk7XHJcbiAgICB9XHJcbiAgfSxcclxuICAvLyBBY2NlcHQgYSBzZXR0aW5nIGlmIGl0cyBhIHZhbGlkIHBlcmNlbnRhZ2UuXHJcbiAgcGVyY2VudDogZnVuY3Rpb24oaywgdikge1xyXG4gICAgdmFyIG07XHJcbiAgICBpZiAoKG0gPSB2Lm1hdGNoKC9eKFtcXGRdezEsM30pKFxcLltcXGRdKik/JSQvKSkpIHtcclxuICAgICAgdiA9IHBhcnNlRmxvYXQodik7XHJcbiAgICAgIGlmICh2ID49IDAgJiYgdiA8PSAxMDApIHtcclxuICAgICAgICB0aGlzLnNldChrLCB2KTtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxufTtcclxuXHJcbi8vIEhlbHBlciBmdW5jdGlvbiB0byBwYXJzZSBpbnB1dCBpbnRvIGdyb3VwcyBzZXBhcmF0ZWQgYnkgJ2dyb3VwRGVsaW0nLCBhbmRcclxuLy8gaW50ZXJwcmV0ZSBlYWNoIGdyb3VwIGFzIGEga2V5L3ZhbHVlIHBhaXIgc2VwYXJhdGVkIGJ5ICdrZXlWYWx1ZURlbGltJy5cclxuZnVuY3Rpb24gcGFyc2VPcHRpb25zKGlucHV0LCBjYWxsYmFjaywga2V5VmFsdWVEZWxpbSwgZ3JvdXBEZWxpbSkge1xyXG4gIHZhciBncm91cHMgPSBncm91cERlbGltID8gaW5wdXQuc3BsaXQoZ3JvdXBEZWxpbSkgOiBbaW5wdXRdO1xyXG4gIGZvciAodmFyIGkgaW4gZ3JvdXBzKSB7XHJcbiAgICBpZiAodHlwZW9mIGdyb3Vwc1tpXSAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgY29udGludWU7XHJcbiAgICB9XHJcbiAgICB2YXIga3YgPSBncm91cHNbaV0uc3BsaXQoa2V5VmFsdWVEZWxpbSk7XHJcbiAgICBpZiAoa3YubGVuZ3RoICE9PSAyKSB7XHJcbiAgICAgIGNvbnRpbnVlO1xyXG4gICAgfVxyXG4gICAgdmFyIGsgPSBrdlswXTtcclxuICAgIHZhciB2ID0ga3ZbMV07XHJcbiAgICBjYWxsYmFjayhrLCB2KTtcclxuICB9XHJcbn1cclxuXHJcbnZhciBkZWZhdWx0cyA9IG5ldyBWVFRDdWUoMCwgMCwgMCk7XHJcbi8vICdtaWRkbGUnIHdhcyBjaGFuZ2VkIHRvICdjZW50ZXInIGluIHRoZSBzcGVjOiBodHRwczovL2dpdGh1Yi5jb20vdzNjL3dlYnZ0dC9wdWxsLzI0NFxyXG4vLyBDaHJvbWUgYW5kIFNhZmFyaSBkb24ndCB5ZXQgc3VwcG9ydCB0aGlzIGNoYW5nZSwgYnV0IEZGIGRvZXNcclxudmFyIGNlbnRlciA9IGRlZmF1bHRzLmFsaWduID09PSAnbWlkZGxlJyA/ICdtaWRkbGUnIDogJ2NlbnRlcic7XHJcblxyXG5mdW5jdGlvbiBwYXJzZUN1ZShpbnB1dCwgY3VlLCByZWdpb25MaXN0KSB7XHJcbiAgLy8gUmVtZW1iZXIgdGhlIG9yaWdpbmFsIGlucHV0IGlmIHdlIG5lZWQgdG8gdGhyb3cgYW4gZXJyb3IuXHJcbiAgdmFyIG9JbnB1dCA9IGlucHV0O1xyXG4gIC8vIDQuMSBXZWJWVFQgdGltZXN0YW1wXHJcbiAgZnVuY3Rpb24gY29uc3VtZVRpbWVTdGFtcCgpIHtcclxuICAgIHZhciB0cyA9IHBhcnNlVGltZVN0YW1wKGlucHV0KTtcclxuICAgIGlmICh0cyA9PT0gbnVsbCkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ01hbGZvcm1lZCB0aW1lc3RhbXA6ICcgKyBvSW5wdXQpO1xyXG4gICAgfVxyXG4gICAgLy8gUmVtb3ZlIHRpbWUgc3RhbXAgZnJvbSBpbnB1dC5cclxuICAgIGlucHV0ID0gaW5wdXQucmVwbGFjZSgvXlteXFxzYS16QS1aLV0rLywgJycpO1xyXG4gICAgcmV0dXJuIHRzO1xyXG4gIH1cclxuXHJcbiAgLy8gNC40LjIgV2ViVlRUIGN1ZSBzZXR0aW5nc1xyXG4gIGZ1bmN0aW9uIGNvbnN1bWVDdWVTZXR0aW5ncyhpbnB1dCwgY3VlKSB7XHJcbiAgICB2YXIgc2V0dGluZ3MgPSBuZXcgU2V0dGluZ3MoKTtcclxuXHJcbiAgICBwYXJzZU9wdGlvbnMoaW5wdXQsIGZ1bmN0aW9uKGssIHYpIHtcclxuICAgICAgc3dpdGNoIChrKSB7XHJcbiAgICAgICAgY2FzZSAncmVnaW9uJzpcclxuICAgICAgICAgIC8vIEZpbmQgdGhlIGxhc3QgcmVnaW9uIHdlIHBhcnNlZCB3aXRoIHRoZSBzYW1lIHJlZ2lvbiBpZC5cclxuICAgICAgICAgIGZvciAodmFyIGkgPSByZWdpb25MaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgICAgIGlmIChyZWdpb25MaXN0W2ldLmlkID09PSB2KSB7XHJcbiAgICAgICAgICAgICAgc2V0dGluZ3Muc2V0KGssIHJlZ2lvbkxpc3RbaV0ucmVnaW9uKTtcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAndmVydGljYWwnOlxyXG4gICAgICAgICAgc2V0dGluZ3MuYWx0KGssIHYsIFsncmwnLCAnbHInXSk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlICdsaW5lJzpcclxuICAgICAgICAgIHZhciB2YWxzID0gdi5zcGxpdCgnLCcpLFxyXG4gICAgICAgICAgICB2YWxzMCA9IHZhbHNbMF07XHJcbiAgICAgICAgICBzZXR0aW5ncy5pbnRlZ2VyKGssIHZhbHMwKTtcclxuICAgICAgICAgIGlmIChzZXR0aW5ncy5wZXJjZW50KGssIHZhbHMwKSkge1xyXG4gICAgICAgICAgICBzZXR0aW5ncy5zZXQoJ3NuYXBUb0xpbmVzJywgZmFsc2UpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgc2V0dGluZ3MuYWx0KGssIHZhbHMwLCBbJ2F1dG8nXSk7XHJcbiAgICAgICAgICBpZiAodmFscy5sZW5ndGggPT09IDIpIHtcclxuICAgICAgICAgICAgc2V0dGluZ3MuYWx0KCdsaW5lQWxpZ24nLCB2YWxzWzFdLCBbJ3N0YXJ0JywgY2VudGVyLCAnZW5kJ10pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAncG9zaXRpb24nOlxyXG4gICAgICAgICAgdmFscyA9IHYuc3BsaXQoJywnKTtcclxuICAgICAgICAgIHNldHRpbmdzLnBlcmNlbnQoaywgdmFsc1swXSk7XHJcbiAgICAgICAgICBpZiAodmFscy5sZW5ndGggPT09IDIpIHtcclxuICAgICAgICAgICAgc2V0dGluZ3MuYWx0KCdwb3NpdGlvbkFsaWduJywgdmFsc1sxXSwgWydzdGFydCcsIGNlbnRlciwgJ2VuZCcsICdsaW5lLWxlZnQnLCAnbGluZS1yaWdodCcsICdhdXRvJ10pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAnc2l6ZSc6XHJcbiAgICAgICAgICBzZXR0aW5ncy5wZXJjZW50KGssIHYpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAnYWxpZ24nOlxyXG4gICAgICAgICAgc2V0dGluZ3MuYWx0KGssIHYsIFsnc3RhcnQnLCBjZW50ZXIsICdlbmQnLCAnbGVmdCcsICdyaWdodCddKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICB9LCAvOi8sIC9cXHMvKTtcclxuXHJcbiAgICAvLyBBcHBseSBkZWZhdWx0IHZhbHVlcyBmb3IgYW55IG1pc3NpbmcgZmllbGRzLlxyXG4gICAgY3VlLnJlZ2lvbiA9IHNldHRpbmdzLmdldCgncmVnaW9uJywgbnVsbCk7XHJcbiAgICBjdWUudmVydGljYWwgPSBzZXR0aW5ncy5nZXQoJ3ZlcnRpY2FsJywgJycpO1xyXG4gICAgdmFyIGxpbmUgPSBzZXR0aW5ncy5nZXQoJ2xpbmUnLCAnYXV0bycpO1xyXG4gICAgaWYgKGxpbmUgPT09ICdhdXRvJyAmJiBkZWZhdWx0cy5saW5lID09PSAtMSkge1xyXG4gICAgICAvLyBzZXQgbnVtZXJpYyBsaW5lIG51bWJlciBmb3IgU2FmYXJpXHJcbiAgICAgIGxpbmUgPSAtMTtcclxuICAgIH1cclxuICAgIGN1ZS5saW5lID0gbGluZTtcclxuICAgIGN1ZS5saW5lQWxpZ24gPSBzZXR0aW5ncy5nZXQoJ2xpbmVBbGlnbicsICdzdGFydCcpO1xyXG4gICAgY3VlLnNuYXBUb0xpbmVzID0gc2V0dGluZ3MuZ2V0KCdzbmFwVG9MaW5lcycsIHRydWUpO1xyXG4gICAgY3VlLnNpemUgPSBzZXR0aW5ncy5nZXQoJ3NpemUnLCAxMDApO1xyXG4gICAgY3VlLmFsaWduID0gc2V0dGluZ3MuZ2V0KCdhbGlnbicsIGNlbnRlcik7XHJcbiAgICB2YXIgcG9zaXRpb24gPSBzZXR0aW5ncy5nZXQoJ3Bvc2l0aW9uJywgJ2F1dG8nKTtcclxuICAgIGlmIChwb3NpdGlvbiA9PT0gJ2F1dG8nICYmIGRlZmF1bHRzLnBvc2l0aW9uID09PSA1MCkge1xyXG4gICAgICAvLyBzZXQgbnVtZXJpYyBwb3NpdGlvbiBmb3IgU2FmYXJpXHJcbiAgICAgIHBvc2l0aW9uID0gY3VlLmFsaWduID09PSAnc3RhcnQnIHx8IGN1ZS5hbGlnbiA9PT0gJ2xlZnQnID8gMCA6IGN1ZS5hbGlnbiA9PT0gJ2VuZCcgfHwgY3VlLmFsaWduID09PSAncmlnaHQnID8gMTAwIDogNTA7XHJcbiAgICB9XHJcbiAgICBjdWUucG9zaXRpb24gPSBwb3NpdGlvbjtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHNraXBXaGl0ZXNwYWNlKCkge1xyXG4gICAgaW5wdXQgPSBpbnB1dC5yZXBsYWNlKC9eXFxzKy8sICcnKTtcclxuICB9XHJcblxyXG4gIC8vIDQuMSBXZWJWVFQgY3VlIHRpbWluZ3MuXHJcbiAgc2tpcFdoaXRlc3BhY2UoKTtcclxuICBjdWUuc3RhcnRUaW1lID0gY29uc3VtZVRpbWVTdGFtcCgpOyAgIC8vICgxKSBjb2xsZWN0IGN1ZSBzdGFydCB0aW1lXHJcbiAgc2tpcFdoaXRlc3BhY2UoKTtcclxuICBpZiAoaW5wdXQuc3Vic3RyKDAsIDMpICE9PSAnLS0+JykgeyAgICAgLy8gKDMpIG5leHQgY2hhcmFjdGVycyBtdXN0IG1hdGNoICctLT4nXHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ01hbGZvcm1lZCB0aW1lIHN0YW1wICh0aW1lIHN0YW1wcyBtdXN0IGJlIHNlcGFyYXRlZCBieSBcXCctLT5cXCcpOiAnICtcclxuICAgICAgb0lucHV0KTtcclxuICB9XHJcbiAgaW5wdXQgPSBpbnB1dC5zdWJzdHIoMyk7XHJcbiAgc2tpcFdoaXRlc3BhY2UoKTtcclxuICBjdWUuZW5kVGltZSA9IGNvbnN1bWVUaW1lU3RhbXAoKTsgICAgIC8vICg1KSBjb2xsZWN0IGN1ZSBlbmQgdGltZVxyXG5cclxuICAvLyA0LjEgV2ViVlRUIGN1ZSBzZXR0aW5ncyBsaXN0LlxyXG4gIHNraXBXaGl0ZXNwYWNlKCk7XHJcbiAgY29uc3VtZUN1ZVNldHRpbmdzKGlucHV0LCBjdWUpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBmaXhMaW5lQnJlYWtzKGlucHV0KSB7XHJcbiAgcmV0dXJuIGlucHV0LnJlcGxhY2UoLzxicig/OiBcXC8pPz4vZ2ksICdcXG4nKTtcclxufVxyXG5cclxuVlRUUGFyc2VyLnByb3RvdHlwZSA9IHtcclxuICBwYXJzZTogZnVuY3Rpb24oZGF0YSkge1xyXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgIC8vIElmIHRoZXJlIGlzIG5vIGRhdGEgdGhlbiB3ZSB3b24ndCBkZWNvZGUgaXQsIGJ1dCB3aWxsIGp1c3QgdHJ5IHRvIHBhcnNlXHJcbiAgICAvLyB3aGF0ZXZlciBpcyBpbiBidWZmZXIgYWxyZWFkeS4gVGhpcyBtYXkgb2NjdXIgaW4gY2lyY3Vtc3RhbmNlcywgZm9yXHJcbiAgICAvLyBleGFtcGxlIHdoZW4gZmx1c2goKSBpcyBjYWxsZWQuXHJcbiAgICBpZiAoZGF0YSkge1xyXG4gICAgICAvLyBUcnkgdG8gZGVjb2RlIHRoZSBkYXRhIHRoYXQgd2UgcmVjZWl2ZWQuXHJcbiAgICAgIHNlbGYuYnVmZmVyICs9IHNlbGYuZGVjb2Rlci5kZWNvZGUoZGF0YSwge3N0cmVhbTogdHJ1ZX0pO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNvbGxlY3ROZXh0TGluZSgpIHtcclxuICAgICAgdmFyIGJ1ZmZlciA9IHNlbGYuYnVmZmVyO1xyXG4gICAgICB2YXIgcG9zID0gMDtcclxuXHJcbiAgICAgIGJ1ZmZlciA9IGZpeExpbmVCcmVha3MoYnVmZmVyKTtcclxuXHJcbiAgICAgIHdoaWxlIChwb3MgPCBidWZmZXIubGVuZ3RoICYmIGJ1ZmZlcltwb3NdICE9PSAnXFxyJyAmJiBidWZmZXJbcG9zXSAhPT0gJ1xcbicpIHtcclxuICAgICAgICArK3BvcztcclxuICAgICAgfVxyXG4gICAgICB2YXIgbGluZSA9IGJ1ZmZlci5zdWJzdHIoMCwgcG9zKTtcclxuICAgICAgLy8gQWR2YW5jZSB0aGUgYnVmZmVyIGVhcmx5IGluIGNhc2Ugd2UgZmFpbCBiZWxvdy5cclxuICAgICAgaWYgKGJ1ZmZlcltwb3NdID09PSAnXFxyJykge1xyXG4gICAgICAgICsrcG9zO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChidWZmZXJbcG9zXSA9PT0gJ1xcbicpIHtcclxuICAgICAgICArK3BvcztcclxuICAgICAgfVxyXG4gICAgICBzZWxmLmJ1ZmZlciA9IGJ1ZmZlci5zdWJzdHIocG9zKTtcclxuICAgICAgcmV0dXJuIGxpbmU7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gMy4yIFdlYlZUVCBtZXRhZGF0YSBoZWFkZXIgc3ludGF4XHJcbiAgICBmdW5jdGlvbiBwYXJzZUhlYWRlcihpbnB1dCkge1xyXG4gICAgICBwYXJzZU9wdGlvbnMoaW5wdXQsIGZ1bmN0aW9uKGssIHYpIHtcclxuICAgICAgICBzd2l0Y2ggKGspIHtcclxuICAgICAgICAgIGNhc2UgJ1JlZ2lvbic6XHJcbiAgICAgICAgICAgIC8vIDMuMyBXZWJWVFQgcmVnaW9uIG1ldGFkYXRhIGhlYWRlciBzeW50YXhcclxuICAgICAgICAgICAgY29uc29sZS5sb2coJ3BhcnNlIHJlZ2lvbicsIHYpO1xyXG4gICAgICAgICAgICAvL3BhcnNlUmVnaW9uKHYpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgIH0sIC86Lyk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gNS4xIFdlYlZUVCBmaWxlIHBhcnNpbmcuXHJcbiAgICB0cnkge1xyXG4gICAgICB2YXIgbGluZTtcclxuICAgICAgaWYgKHNlbGYuc3RhdGUgPT09ICdJTklUSUFMJykge1xyXG4gICAgICAgIC8vIFdlIGNhbid0IHN0YXJ0IHBhcnNpbmcgdW50aWwgd2UgaGF2ZSB0aGUgZmlyc3QgbGluZS5cclxuICAgICAgICBpZiAoIS9cXHJcXG58XFxuLy50ZXN0KHNlbGYuYnVmZmVyKSkge1xyXG4gICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsaW5lID0gY29sbGVjdE5leHRMaW5lKCk7XHJcblxyXG4gICAgICAgIHZhciBtID0gbGluZS5tYXRjaCgvXldFQlZUVChbIFxcdF0uKik/JC8pO1xyXG4gICAgICAgIGlmICghbSB8fCAhbVswXSkge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNYWxmb3JtZWQgV2ViVlRUIHNpZ25hdHVyZS4nKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHNlbGYuc3RhdGUgPSAnSEVBREVSJztcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIGFscmVhZHlDb2xsZWN0ZWRMaW5lID0gZmFsc2U7XHJcbiAgICAgIHdoaWxlIChzZWxmLmJ1ZmZlcikge1xyXG4gICAgICAgIC8vIFdlIGNhbid0IHBhcnNlIGEgbGluZSB1bnRpbCB3ZSBoYXZlIHRoZSBmdWxsIGxpbmUuXHJcbiAgICAgICAgaWYgKCEvXFxyXFxufFxcbi8udGVzdChzZWxmLmJ1ZmZlcikpIHtcclxuICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFhbHJlYWR5Q29sbGVjdGVkTGluZSkge1xyXG4gICAgICAgICAgbGluZSA9IGNvbGxlY3ROZXh0TGluZSgpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBhbHJlYWR5Q29sbGVjdGVkTGluZSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc3dpdGNoIChzZWxmLnN0YXRlKSB7XHJcbiAgICAgICAgICBjYXNlICdIRUFERVInOlxyXG4gICAgICAgICAgICAvLyAxMy0xOCAtIEFsbG93IGEgaGVhZGVyIChtZXRhZGF0YSkgdW5kZXIgdGhlIFdFQlZUVCBsaW5lLlxyXG4gICAgICAgICAgICBpZiAoLzovLnRlc3QobGluZSkpIHtcclxuICAgICAgICAgICAgICBwYXJzZUhlYWRlcihsaW5lKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmICghbGluZSkge1xyXG4gICAgICAgICAgICAgIC8vIEFuIGVtcHR5IGxpbmUgdGVybWluYXRlcyB0aGUgaGVhZGVyIGFuZCBzdGFydHMgdGhlIGJvZHkgKGN1ZXMpLlxyXG4gICAgICAgICAgICAgIHNlbGYuc3RhdGUgPSAnSUQnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgY2FzZSAnTk9URSc6XHJcbiAgICAgICAgICAgIC8vIElnbm9yZSBOT1RFIGJsb2Nrcy5cclxuICAgICAgICAgICAgaWYgKCFsaW5lKSB7XHJcbiAgICAgICAgICAgICAgc2VsZi5zdGF0ZSA9ICdJRCc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICBjYXNlICdJRCc6XHJcbiAgICAgICAgICAgIC8vIENoZWNrIGZvciB0aGUgc3RhcnQgb2YgTk9URSBibG9ja3MuXHJcbiAgICAgICAgICAgIGlmICgvXk5PVEUoJHxbIFxcdF0pLy50ZXN0KGxpbmUpKSB7XHJcbiAgICAgICAgICAgICAgc2VsZi5zdGF0ZSA9ICdOT1RFJztcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyAxOS0yOSAtIEFsbG93IGFueSBudW1iZXIgb2YgbGluZSB0ZXJtaW5hdG9ycywgdGhlbiBpbml0aWFsaXplIG5ldyBjdWUgdmFsdWVzLlxyXG4gICAgICAgICAgICBpZiAoIWxpbmUpIHtcclxuICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzZWxmLmN1ZSA9IG5ldyBWVFRDdWUoMCwgMCwgJycpO1xyXG4gICAgICAgICAgICBzZWxmLnN0YXRlID0gJ0NVRSc7XHJcbiAgICAgICAgICAgIC8vIDMwLTM5IC0gQ2hlY2sgaWYgc2VsZiBsaW5lIGNvbnRhaW5zIGFuIG9wdGlvbmFsIGlkZW50aWZpZXIgb3IgdGltaW5nIGRhdGEuXHJcbiAgICAgICAgICAgIGlmIChsaW5lLmluZGV4T2YoJy0tPicpID09PSAtMSkge1xyXG4gICAgICAgICAgICAgIHNlbGYuY3VlLmlkID0gbGluZTtcclxuICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgLy8gUHJvY2VzcyBsaW5lIGFzIHN0YXJ0IG9mIGEgY3VlLlxyXG4gICAgICAgICAgLypmYWxscyB0aHJvdWdoKi9cclxuICAgICAgICAgIGNhc2UgJ0NVRSc6XHJcbiAgICAgICAgICAgIC8vIDQwIC0gQ29sbGVjdCBjdWUgdGltaW5ncyBhbmQgc2V0dGluZ3MuXHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgcGFyc2VDdWUobGluZSwgc2VsZi5jdWUsIHNlbGYucmVnaW9uTGlzdCk7XHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAvLyBJbiBjYXNlIG9mIGFuIGVycm9yIGlnbm9yZSByZXN0IG9mIHRoZSBjdWUuXHJcbiAgICAgICAgICAgICAgc2VsZi5jdWUgPSBudWxsO1xyXG4gICAgICAgICAgICAgIHNlbGYuc3RhdGUgPSAnQkFEQ1VFJztcclxuICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzZWxmLnN0YXRlID0gJ0NVRVRFWFQnO1xyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgIGNhc2UgJ0NVRVRFWFQnOlxyXG4gICAgICAgICAgICB2YXIgaGFzU3Vic3RyaW5nID0gbGluZS5pbmRleE9mKCctLT4nKSAhPT0gLTE7XHJcbiAgICAgICAgICAgIC8vIDM0IC0gSWYgd2UgaGF2ZSBhbiBlbXB0eSBsaW5lIHRoZW4gcmVwb3J0IHRoZSBjdWUuXHJcbiAgICAgICAgICAgIC8vIDM1IC0gSWYgd2UgaGF2ZSB0aGUgc3BlY2lhbCBzdWJzdHJpbmcgJy0tPicgdGhlbiByZXBvcnQgdGhlIGN1ZSxcclxuICAgICAgICAgICAgLy8gYnV0IGRvIG5vdCBjb2xsZWN0IHRoZSBsaW5lIGFzIHdlIG5lZWQgdG8gcHJvY2VzcyB0aGUgY3VycmVudFxyXG4gICAgICAgICAgICAvLyBvbmUgYXMgYSBuZXcgY3VlLlxyXG4gICAgICAgICAgICBpZiAoIWxpbmUgfHwgaGFzU3Vic3RyaW5nICYmIChhbHJlYWR5Q29sbGVjdGVkTGluZSA9IHRydWUpKSB7XHJcbiAgICAgICAgICAgICAgLy8gV2UgYXJlIGRvbmUgcGFyc2luZyBzZWxmIGN1ZS5cclxuICAgICAgICAgICAgICBpZiAoc2VsZi5vbmN1ZSkge1xyXG4gICAgICAgICAgICAgICAgc2VsZi5vbmN1ZShzZWxmLmN1ZSk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIHNlbGYuY3VlID0gbnVsbDtcclxuICAgICAgICAgICAgICBzZWxmLnN0YXRlID0gJ0lEJztcclxuICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoc2VsZi5jdWUudGV4dCkge1xyXG4gICAgICAgICAgICAgIHNlbGYuY3VlLnRleHQgKz0gJ1xcbic7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc2VsZi5jdWUudGV4dCArPSBsaW5lO1xyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgIGNhc2UgJ0JBRENVRSc6IC8vIEJBRENVRVxyXG4gICAgICAgICAgICAvLyA1NC02MiAtIENvbGxlY3QgYW5kIGRpc2NhcmQgdGhlIHJlbWFpbmluZyBjdWUuXHJcbiAgICAgICAgICAgIGlmICghbGluZSkge1xyXG4gICAgICAgICAgICAgIHNlbGYuc3RhdGUgPSAnSUQnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSBjYXRjaCAoZSkge1xyXG5cclxuICAgICAgLy8gSWYgd2UgYXJlIGN1cnJlbnRseSBwYXJzaW5nIGEgY3VlLCByZXBvcnQgd2hhdCB3ZSBoYXZlLlxyXG4gICAgICBpZiAoc2VsZi5zdGF0ZSA9PT0gJ0NVRVRFWFQnICYmIHNlbGYuY3VlICYmIHNlbGYub25jdWUpIHtcclxuICAgICAgICBzZWxmLm9uY3VlKHNlbGYuY3VlKTtcclxuICAgICAgfVxyXG4gICAgICBzZWxmLmN1ZSA9IG51bGw7XHJcbiAgICAgIC8vIEVudGVyIEJBRFdFQlZUVCBzdGF0ZSBpZiBoZWFkZXIgd2FzIG5vdCBwYXJzZWQgY29ycmVjdGx5IG90aGVyd2lzZVxyXG4gICAgICAvLyBhbm90aGVyIGV4Y2VwdGlvbiBvY2N1cnJlZCBzbyBlbnRlciBCQURDVUUgc3RhdGUuXHJcbiAgICAgIHNlbGYuc3RhdGUgPSBzZWxmLnN0YXRlID09PSAnSU5JVElBTCcgPyAnQkFEV0VCVlRUJyA6ICdCQURDVUUnO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfSxcclxuICBmbHVzaDogZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICB0cnkge1xyXG4gICAgICAvLyBGaW5pc2ggZGVjb2RpbmcgdGhlIHN0cmVhbS5cclxuICAgICAgc2VsZi5idWZmZXIgKz0gc2VsZi5kZWNvZGVyLmRlY29kZSgpO1xyXG4gICAgICAvLyBTeW50aGVzaXplIHRoZSBlbmQgb2YgdGhlIGN1cnJlbnQgY3VlIG9yIHJlZ2lvbi5cclxuICAgICAgaWYgKHNlbGYuY3VlIHx8IHNlbGYuc3RhdGUgPT09ICdIRUFERVInKSB7XHJcbiAgICAgICAgc2VsZi5idWZmZXIgKz0gJ1xcblxcbic7XHJcbiAgICAgICAgc2VsZi5wYXJzZSgpO1xyXG4gICAgICB9XHJcbiAgICAgIC8vIElmIHdlJ3ZlIGZsdXNoZWQsIHBhcnNlZCwgYW5kIHdlJ3JlIHN0aWxsIG9uIHRoZSBJTklUSUFMIHN0YXRlIHRoZW5cclxuICAgICAgLy8gdGhhdCBtZWFucyB3ZSBkb24ndCBoYXZlIGVub3VnaCBvZiB0aGUgc3RyZWFtIHRvIHBhcnNlIHRoZSBmaXJzdFxyXG4gICAgICAvLyBsaW5lLlxyXG4gICAgICBpZiAoc2VsZi5zdGF0ZSA9PT0gJ0lOSVRJQUwnKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNYWxmb3JtZWQgV2ViVlRUIHNpZ25hdHVyZS4nKTtcclxuICAgICAgfVxyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICB0aHJvdyBlO1xyXG4gICAgfVxyXG4gICAgaWYgKHNlbGYub25mbHVzaCkge1xyXG4gICAgICBzZWxmLm9uZmx1c2goKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxufTtcclxuXHJcbmV4cG9ydCB7IGZpeExpbmVCcmVha3MgfTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IFZUVFBhcnNlcjtcclxuIiwiaW1wb3J0IFZUVFBhcnNlciBmcm9tICcuL3Z0dHBhcnNlcic7XHJcblxyXG4vLyBTdHJpbmcucHJvdG90eXBlLnN0YXJ0c1dpdGggaXMgbm90IHN1cHBvcnRlZCBpbiBJRTExXHJcbmNvbnN0IHN0YXJ0c1dpdGggPSBmdW5jdGlvbihpbnB1dFN0cmluZywgc2VhcmNoU3RyaW5nLCBwb3NpdGlvbikge1xyXG4gIHJldHVybiBpbnB1dFN0cmluZy5zdWJzdHIocG9zaXRpb24gfHwgMCwgc2VhcmNoU3RyaW5nLmxlbmd0aCkgPT09IHNlYXJjaFN0cmluZztcclxufTtcclxuXHJcbmNvbnN0IGN1ZVN0cmluZzJtaWxsaXMgPSBmdW5jdGlvbih0aW1lU3RyaW5nKSB7XHJcbiAgICBsZXQgdHMgPSBwYXJzZUludCh0aW1lU3RyaW5nLnN1YnN0cigtMykpO1xyXG4gICAgbGV0IHNlY3MgPSBwYXJzZUludCh0aW1lU3RyaW5nLnN1YnN0cigtNiwyKSk7XHJcbiAgICBsZXQgbWlucyA9IHBhcnNlSW50KHRpbWVTdHJpbmcuc3Vic3RyKC05LDIpKTtcclxuICAgIGxldCBob3VycyA9IHRpbWVTdHJpbmcubGVuZ3RoID4gOSA/IHBhcnNlSW50KHRpbWVTdHJpbmcuc3Vic3RyKDAsIHRpbWVTdHJpbmcuaW5kZXhPZignOicpKSkgOiAwO1xyXG5cclxuICAgIGlmIChpc05hTih0cykgfHwgaXNOYU4oc2VjcykgfHwgaXNOYU4obWlucykgfHwgaXNOYU4oaG91cnMpKSB7XHJcbiAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgfVxyXG5cclxuICAgIHRzICs9IDEwMDAgKiBzZWNzO1xyXG4gICAgdHMgKz0gNjAqMTAwMCAqIG1pbnM7XHJcbiAgICB0cyArPSA2MCo2MCoxMDAwICogaG91cnM7XHJcblxyXG4gICAgcmV0dXJuIHRzO1xyXG59O1xyXG5cclxuLy8gRnJvbSBodHRwczovL2dpdGh1Yi5jb20vZGFya3NreWFwcC9zdHJpbmctaGFzaFxyXG5jb25zdCBoYXNoID0gZnVuY3Rpb24odGV4dCkge1xyXG4gICAgbGV0IGhhc2ggPSA1MzgxO1xyXG4gICAgbGV0IGkgPSB0ZXh0Lmxlbmd0aDtcclxuICAgIHdoaWxlIChpKSB7XHJcbiAgICAgICAgaGFzaCA9IChoYXNoICogMzMpIF4gdGV4dC5jaGFyQ29kZUF0KC0taSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gKGhhc2ggPj4+IDApLnRvU3RyaW5nKCk7XHJcbn07XHJcblxyXG5jb25zdCBjYWxjdWxhdGVPZmZzZXQgPSBmdW5jdGlvbih2dHRDQ3MsIGNjLCBwcmVzZW50YXRpb25UaW1lKSB7XHJcbiAgICBsZXQgY3VyckNDID0gdnR0Q0NzW2NjXTtcclxuICAgIGxldCBwcmV2Q0MgPSB2dHRDQ3NbY3VyckNDLnByZXZDQ107XHJcblxyXG4gICAgLy8gVGhpcyBpcyB0aGUgZmlyc3QgZGlzY29udGludWl0eSBvciBjdWVzIGhhdmUgYmVlbiBwcm9jZXNzZWQgc2luY2UgdGhlIGxhc3QgZGlzY29udGludWl0eVxyXG4gICAgLy8gT2Zmc2V0ID0gY3VycmVudCBkaXNjb250aW51aXR5IHRpbWVcclxuICAgIGlmICghcHJldkNDIHx8ICghcHJldkNDLm5ldyAmJiBjdXJyQ0MubmV3KSkge1xyXG4gICAgICAgIHZ0dENDcy5jY09mZnNldCA9IHZ0dENDcy5wcmVzZW50YXRpb25PZmZzZXQgPSBjdXJyQ0Muc3RhcnQ7XHJcbiAgICAgICAgY3VyckNDLm5ldyA9IGZhbHNlO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBUaGVyZSBoYXZlIGJlZW4gZGlzY29udGludWl0aWVzIHNpbmNlIGN1ZXMgd2VyZSBsYXN0IHBhcnNlZC5cclxuICAgIC8vIE9mZnNldCA9IHRpbWUgZWxhcHNlZFxyXG4gICAgd2hpbGUgKHByZXZDQyAmJiBwcmV2Q0MubmV3KSB7XHJcbiAgICAgICAgdnR0Q0NzLmNjT2Zmc2V0ICs9IGN1cnJDQy5zdGFydCAtIHByZXZDQy5zdGFydDtcclxuICAgICAgICBjdXJyQ0MubmV3ID0gZmFsc2U7XHJcbiAgICAgICAgY3VyckNDID0gcHJldkNDO1xyXG4gICAgICAgIHByZXZDQyA9IHZ0dENDc1tjdXJyQ0MucHJldkNDXTtcclxuICAgIH1cclxuXHJcbiAgICB2dHRDQ3MucHJlc2VudGF0aW9uT2Zmc2V0ID0gcHJlc2VudGF0aW9uVGltZTtcclxufTtcclxuXHJcbmNvbnN0IFdlYlZUVFBhcnNlciA9IHtcclxuICAgIHBhcnNlOiBmdW5jdGlvbih2dHRCeXRlQXJyYXksIHN5bmNQVFMsIHZ0dENDcywgY2MsIGNhbGxCYWNrLCBlcnJvckNhbGxCYWNrKSB7XHJcbiAgICAgICAgLy8gQ29udmVydCBieXRlQXJyYXkgaW50byBzdHJpbmcsIHJlcGxhY2luZyBhbnkgc29tZXdoYXQgZXhvdGljIGxpbmVmZWVkcyB3aXRoIFwiXFxuXCIsIHRoZW4gc3BsaXQgb24gdGhhdCBjaGFyYWN0ZXIuXHJcbiAgICAgICAgbGV0IHJlID0gL1xcclxcbnxcXG5cXHJ8XFxufFxcci9nO1xyXG4gICAgICAgIGxldCB2dHRMaW5lcyA9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgbmV3IFVpbnQ4QXJyYXkodnR0Qnl0ZUFycmF5KSkudHJpbSgpLnJlcGxhY2UocmUsICdcXG4nKS5zcGxpdCgnXFxuJyk7XHJcbiAgICAgICAgbGV0IGN1ZVRpbWUgPSAnMDA6MDAuMDAwJztcclxuICAgICAgICBsZXQgbXBlZ1RzID0gMDtcclxuICAgICAgICBsZXQgbG9jYWxUaW1lID0gMDtcclxuICAgICAgICBsZXQgcHJlc2VudGF0aW9uVGltZSA9IDA7XHJcbiAgICAgICAgbGV0IGN1ZXMgPSBbXTtcclxuICAgICAgICBsZXQgcGFyc2luZ0Vycm9yO1xyXG4gICAgICAgIGxldCBpbkhlYWRlciA9IHRydWU7XHJcbiAgICAgICAgLy8gbGV0IFZUVEN1ZSA9IFZUVEN1ZSB8fCB3aW5kb3cuVGV4dFRyYWNrQ3VlO1xyXG5cclxuICAgICAgICAvLyBDcmVhdGUgcGFyc2VyIG9iamVjdCB1c2luZyBWVFRDdWUgd2l0aCBUZXh0VHJhY2tDdWUgZmFsbGJhY2sgb24gY2VydGFpbiBicm93c2Vycy5cclxuICAgICAgICBsZXQgcGFyc2VyID0gbmV3IFZUVFBhcnNlcigpO1xyXG5cclxuICAgICAgICBwYXJzZXIub25jdWUgPSBmdW5jdGlvbihjdWUpIHtcclxuICAgICAgICAgICAgLy8gQWRqdXN0IGN1ZSB0aW1pbmc7IGNsYW1wIGN1ZXMgdG8gc3RhcnQgbm8gZWFybGllciB0aGFuIC0gYW5kIGRyb3AgY3VlcyB0aGF0IGRvbid0IGVuZCBhZnRlciAtIDAgb24gdGltZWxpbmUuXHJcbiAgICAgICAgICAgIGxldCBjdXJyQ0MgPSB2dHRDQ3NbY2NdO1xyXG4gICAgICAgICAgICBsZXQgY3VlT2Zmc2V0ID0gdnR0Q0NzLmNjT2Zmc2V0O1xyXG5cclxuICAgICAgICAgICAgLy8gVXBkYXRlIG9mZnNldHMgZm9yIG5ldyBkaXNjb250aW51aXRpZXNcclxuICAgICAgICAgICAgaWYgKGN1cnJDQyAmJiBjdXJyQ0MubmV3KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobG9jYWxUaW1lICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBXaGVuIGxvY2FsIHRpbWUgaXMgcHJvdmlkZWQsIG9mZnNldCA9IGRpc2NvbnRpbnVpdHkgc3RhcnQgdGltZSAtIGxvY2FsIHRpbWVcclxuICAgICAgICAgICAgICAgICAgICBjdWVPZmZzZXQgPSB2dHRDQ3MuY2NPZmZzZXQgPSBjdXJyQ0Muc3RhcnQ7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbGN1bGF0ZU9mZnNldCh2dHRDQ3MsIGNjLCBwcmVzZW50YXRpb25UaW1lKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHByZXNlbnRhdGlvblRpbWUpIHtcclxuICAgICAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgTVBFR1RTLCBvZmZzZXQgPSBwcmVzZW50YXRpb24gdGltZSArIGRpc2NvbnRpbnVpdHkgb2Zmc2V0XHJcbiAgICAgICAgICAgICAgICBjdWVPZmZzZXQgPSBwcmVzZW50YXRpb25UaW1lICsgdnR0Q0NzLmNjT2Zmc2V0IC0gdnR0Q0NzLnByZXNlbnRhdGlvbk9mZnNldDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgY3VlLnN0YXJ0VGltZSArPSBjdWVPZmZzZXQgLSBsb2NhbFRpbWU7XHJcbiAgICAgICAgICAgIGN1ZS5lbmRUaW1lICs9IGN1ZU9mZnNldCAtIGxvY2FsVGltZTtcclxuXHJcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIHVuaXF1ZSBoYXNoIGlkIGZvciBhIGN1ZSBiYXNlZCBvbiBzdGFydC9lbmQgdGltZXMgYW5kIHRleHQuXHJcbiAgICAgICAgICAgIC8vIFRoaXMgaGVscHMgdGltZWxpbmUtY29udHJvbGxlciB0byBhdm9pZCBzaG93aW5nIHJlcGVhdGVkIGNhcHRpb25zLlxyXG4gICAgICAgICAgICBjdWUuaWQgPSBoYXNoKGN1ZS5zdGFydFRpbWUpICsgaGFzaChjdWUuZW5kVGltZSkgKyBoYXNoKGN1ZS50ZXh0KTtcclxuXHJcbiAgICAgICAgICAgIC8vIEZpeCBlbmNvZGluZyBvZiBzcGVjaWFsIGNoYXJhY3RlcnMuIFRPRE86IFRlc3Qgd2l0aCBhbGwgc29ydHMgb2Ygd2VpcmQgY2hhcmFjdGVycy5cclxuICAgICAgICAgICAgY3VlLnRleHQgPSBkZWNvZGVVUklDb21wb25lbnQoZXNjYXBlKGN1ZS50ZXh0KSk7XHJcbiAgICAgICAgICAgIGlmIChjdWUuZW5kVGltZSA+IDApIHtcclxuICAgICAgICAgICAgICBjdWVzLnB1c2goY3VlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHBhcnNlci5vbnBhcnNpbmdlcnJvciA9IGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgcGFyc2luZ0Vycm9yID0gZTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBwYXJzZXIub25mbHVzaCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBpZiAocGFyc2luZ0Vycm9yICYmIGVycm9yQ2FsbEJhY2spIHtcclxuICAgICAgICAgICAgICAgIGVycm9yQ2FsbEJhY2socGFyc2luZ0Vycm9yKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYWxsQmFjayhjdWVzKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvLyBHbyB0aHJvdWdoIGNvbnRlbnRzIGxpbmUgYnkgbGluZS5cclxuICAgICAgICB2dHRMaW5lcy5mb3JFYWNoKGxpbmUgPT4ge1xyXG4gICAgICAgICAgICBpZiAoaW5IZWFkZXIpIHtcclxuICAgICAgICAgICAgICAgIC8vIExvb2sgZm9yIFgtVElNRVNUQU1QLU1BUCBpbiBoZWFkZXIuXHJcbiAgICAgICAgICAgICAgICBpZiAoc3RhcnRzV2l0aChsaW5lLCAnWC1USU1FU1RBTVAtTUFQPScpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gT25jZSBmb3VuZCwgbm8gbW9yZSBhcmUgYWxsb3dlZCBhbnl3YXksIHNvIHN0b3Agc2VhcmNoaW5nLlxyXG4gICAgICAgICAgICAgICAgICAgIGluSGVhZGVyID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRXh0cmFjdCBMT0NBTCBhbmQgTVBFR1RTLlxyXG4gICAgICAgICAgICAgICAgICAgIGxpbmUuc3Vic3RyKDE2KS5zcGxpdCgnLCcpLmZvckVhY2godGltZXN0YW1wID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXJ0c1dpdGgodGltZXN0YW1wLCAnTE9DQUw6JykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBjdWVUaW1lID0gdGltZXN0YW1wLnN1YnN0cig2KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdGFydHNXaXRoKHRpbWVzdGFtcCwgJ01QRUdUUzonKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIG1wZWdUcyA9IHBhcnNlSW50KHRpbWVzdGFtcC5zdWJzdHIoNykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHN1YnRpdGxlIG9mZnNldCBpbiBtaWxsaXNlY29uZHMuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHN5bmMgUFRTIGlzIGxlc3MgdGhhbiB6ZXJvLCB3ZSBoYXZlIGEgMzMtYml0IHdyYXBhcm91bmQsIHdoaWNoIGlzIGZpeGVkIGJ5IGFkZGluZyAyXjMzID0gODU4OTkzNDU5Mi5cclxuICAgICAgICAgICAgICAgICAgICAgICAgc3luY1BUUyA9IHN5bmNQVFMgPCAwID8gc3luY1BUUyArIDg1ODk5MzQ1OTIgOiBzeW5jUFRTO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBZGp1c3QgTVBFR1RTIGJ5IHN5bmMgUFRTLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtcGVnVHMgLT0gc3luY1BUUztcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29udmVydCBjdWUgdGltZSB0byBzZWNvbmRzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsVGltZSA9IGN1ZVN0cmluZzJtaWxsaXMoY3VlVGltZSkgLyAxMDAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDb252ZXJ0IE1QRUdUUyB0byBzZWNvbmRzIGZyb20gOTBrSHouXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXNlbnRhdGlvblRpbWUgPSBtcGVnVHMgLyA5MDAwMDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsb2NhbFRpbWUgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzaW5nRXJyb3IgPSBuZXcgRXJyb3IoYE1hbGZvcm1lZCBYLVRJTUVTVEFNUC1NQVA6ICR7bGluZX1gKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjYXRjaChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNpbmdFcnJvciA9IG5ldyBFcnJvcihgTWFsZm9ybWVkIFgtVElNRVNUQU1QLU1BUDogJHtsaW5lfWApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvLyBSZXR1cm4gd2l0aG91dCBwYXJzaW5nIFgtVElNRVNUQU1QLU1BUCBsaW5lLlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobGluZSA9PT0gJycpIHtcclxuICAgICAgICAgICAgICAgICAgaW5IZWFkZXIgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBQYXJzZSBsaW5lIGJ5IGRlZmF1bHQuXHJcbiAgICAgICAgICAgIHBhcnNlci5wYXJzZShsaW5lKydcXG4nKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcGFyc2VyLmZsdXNoKCk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBXZWJWVFRQYXJzZXI7XHJcbiIsIi8qKlxyXG4gKiBYSFIgYmFzZWQgbG9nZ2VyXHJcbiovXHJcblxyXG5pbXBvcnQge2xvZ2dlcn0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcclxuXHJcbmNsYXNzIFhockxvYWRlciB7XHJcblxyXG4gIGNvbnN0cnVjdG9yKGNvbmZpZykge1xyXG4gICAgaWYgKGNvbmZpZyAmJiBjb25maWcueGhyU2V0dXApIHtcclxuICAgICAgdGhpcy54aHJTZXR1cCA9IGNvbmZpZy54aHJTZXR1cDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGRlc3Ryb3koKSB7XHJcbiAgICB0aGlzLmFib3J0KCk7XHJcbiAgICB0aGlzLmxvYWRlciA9IG51bGw7XHJcbiAgfVxyXG5cclxuICBhYm9ydCgpIHtcclxuICAgIHZhciBsb2FkZXIgPSB0aGlzLmxvYWRlcjtcclxuICAgIGlmIChsb2FkZXIgJiYgbG9hZGVyLnJlYWR5U3RhdGUgIT09IDQpIHtcclxuICAgICAgdGhpcy5zdGF0cy5hYm9ydGVkID0gdHJ1ZTtcclxuICAgICAgbG9hZGVyLmFib3J0KCk7XHJcbiAgICB9XHJcblxyXG4gICAgd2luZG93LmNsZWFyVGltZW91dCh0aGlzLnJlcXVlc3RUaW1lb3V0KTtcclxuICAgIHRoaXMucmVxdWVzdFRpbWVvdXQgPSBudWxsO1xyXG4gICAgd2luZG93LmNsZWFyVGltZW91dCh0aGlzLnJldHJ5VGltZW91dCk7XHJcbiAgICB0aGlzLnJldHJ5VGltZW91dCA9IG51bGw7XHJcbiAgfVxyXG5cclxuICBsb2FkKGNvbnRleHQsIGNvbmZpZywgY2FsbGJhY2tzKSB7XHJcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xyXG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XHJcbiAgICB0aGlzLmNhbGxiYWNrcyA9IGNhbGxiYWNrcztcclxuICAgIHRoaXMuc3RhdHMgPSB7dHJlcXVlc3Q6IHBlcmZvcm1hbmNlLm5vdygpLCByZXRyeTogMH07XHJcbiAgICB0aGlzLnJldHJ5RGVsYXkgPSBjb25maWcucmV0cnlEZWxheTtcclxuICAgIHRoaXMubG9hZEludGVybmFsKCk7XHJcbiAgfVxyXG5cclxuICBsb2FkSW50ZXJuYWwoKSB7XHJcbiAgICB2YXIgeGhyLCBjb250ZXh0ID0gdGhpcy5jb250ZXh0O1xyXG5cclxuICAgIGlmICh0eXBlb2YgWERvbWFpblJlcXVlc3QgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICB4aHIgPSB0aGlzLmxvYWRlciA9IG5ldyBYRG9tYWluUmVxdWVzdCgpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgIHhociA9IHRoaXMubG9hZGVyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XHJcbiAgICB9XHJcbiAgICBsZXQgc3RhdHMgPSB0aGlzLnN0YXRzO1xyXG4gICAgc3RhdHMudGZpcnN0ID0gMDtcclxuICAgIHN0YXRzLmxvYWRlZCA9IDA7XHJcbiAgICBjb25zdCB4aHJTZXR1cCA9IHRoaXMueGhyU2V0dXA7XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgaWYgKHhoclNldHVwKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIHhoclNldHVwKHhociwgY29udGV4dC51cmwpO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgIC8vIGZpeCB4aHJTZXR1cDogKHhociwgdXJsKSA9PiB7eGhyLnNldFJlcXVlc3RIZWFkZXIoXCJDb250ZW50LUxhbmd1YWdlXCIsIFwidGVzdFwiKTt9XHJcbiAgICAgICAgICAvLyBub3Qgd29ya2luZywgYXMgeGhyLnNldFJlcXVlc3RIZWFkZXIgZXhwZWN0cyB4aHIucmVhZHlTdGF0ZSA9PT0gT1BFTlxyXG4gICAgICAgICAgeGhyLm9wZW4oJ0dFVCcsIGNvbnRleHQudXJsLCB0cnVlKTtcclxuICAgICAgICAgIHhoclNldHVwKHhociwgY29udGV4dC51cmwpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBpZiAoIXhoci5yZWFkeVN0YXRlKSB7XHJcbiAgICAgICAgeGhyLm9wZW4oJ0dFVCcsIGNvbnRleHQudXJsLCB0cnVlKTtcclxuICAgICAgfVxyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAvLyBJRTExIHRocm93cyBhbiBleGNlcHRpb24gb24geGhyLm9wZW4gaWYgYXR0ZW1wdGluZyB0byBhY2Nlc3MgYW4gSFRUUCByZXNvdXJjZSBvdmVyIEhUVFBTXHJcbiAgICAgIHRoaXMuY2FsbGJhY2tzLm9uRXJyb3IoeyBjb2RlIDogeGhyLnN0YXR1cywgdGV4dDogZS5tZXNzYWdlIH0sIGNvbnRleHQsIHhocik7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoY29udGV4dC5yYW5nZUVuZCkge1xyXG4gICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcignUmFuZ2UnLCdieXRlcz0nICsgY29udGV4dC5yYW5nZVN0YXJ0ICsgJy0nICsgKGNvbnRleHQucmFuZ2VFbmQtMSkpO1xyXG4gICAgfVxyXG4gICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IHRoaXMucmVhZHlzdGF0ZWNoYW5nZS5iaW5kKHRoaXMpO1xyXG4gICAgeGhyLm9ucHJvZ3Jlc3MgPSB0aGlzLmxvYWRwcm9ncmVzcy5iaW5kKHRoaXMpO1xyXG4gICAgeGhyLnJlc3BvbnNlVHlwZSA9IGNvbnRleHQucmVzcG9uc2VUeXBlO1xyXG5cclxuICAgIC8vIHNldHVwIHRpbWVvdXQgYmVmb3JlIHdlIHBlcmZvcm0gcmVxdWVzdFxyXG4gICAgdGhpcy5yZXF1ZXN0VGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KHRoaXMubG9hZHRpbWVvdXQuYmluZCh0aGlzKSwgdGhpcy5jb25maWcudGltZW91dCk7XHJcbiAgICB4aHIuc2VuZCgpO1xyXG4gIH1cclxuXHJcbiAgcmVhZHlzdGF0ZWNoYW5nZShldmVudCkge1xyXG4gICAgdmFyIHhociA9IGV2ZW50LmN1cnJlbnRUYXJnZXQsXHJcbiAgICAgICAgcmVhZHlTdGF0ZSA9IHhoci5yZWFkeVN0YXRlLFxyXG4gICAgICAgIHN0YXRzID0gdGhpcy5zdGF0cyxcclxuICAgICAgICBjb250ZXh0ID0gdGhpcy5jb250ZXh0LFxyXG4gICAgICAgIGNvbmZpZyA9IHRoaXMuY29uZmlnO1xyXG5cclxuICAgIC8vIGRvbid0IHByb2NlZWQgaWYgeGhyIGhhcyBiZWVuIGFib3J0ZWRcclxuICAgIGlmIChzdGF0cy5hYm9ydGVkKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICAvLyA+PSBIRUFERVJTX1JFQ0VJVkVEXHJcbiAgICBpZiAocmVhZHlTdGF0ZSA+PTIpIHtcclxuICAgICAgLy8gY2xlYXIgeGhyIHRpbWVvdXQgYW5kIHJlYXJtIGl0IGlmIHJlYWR5U3RhdGUgbGVzcyB0aGFuIDRcclxuICAgICAgd2luZG93LmNsZWFyVGltZW91dCh0aGlzLnJlcXVlc3RUaW1lb3V0KTtcclxuICAgICAgaWYgKHN0YXRzLnRmaXJzdCA9PT0gMCkge1xyXG4gICAgICAgIHN0YXRzLnRmaXJzdCA9IE1hdGgubWF4KHBlcmZvcm1hbmNlLm5vdygpLCBzdGF0cy50cmVxdWVzdCk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHJlYWR5U3RhdGUgPT09IDQpIHtcclxuICAgICAgICBsZXQgc3RhdHVzID0geGhyLnN0YXR1cztcclxuICAgICAgICAvLyBodHRwIHN0YXR1cyBiZXR3ZWVuIDIwMCB0byAyOTkgYXJlIGFsbCBzdWNjZXNzZnVsXHJcbiAgICAgICAgaWYgKHN0YXR1cyA+PSAyMDAgJiYgc3RhdHVzIDwgMzAwKSAge1xyXG4gICAgICAgICAgc3RhdHMudGxvYWQgPSBNYXRoLm1heChzdGF0cy50Zmlyc3QscGVyZm9ybWFuY2Uubm93KCkpO1xyXG4gICAgICAgICAgbGV0IGRhdGEsbGVuO1xyXG4gICAgICAgICAgaWYgKGNvbnRleHQucmVzcG9uc2VUeXBlID09PSAnYXJyYXlidWZmZXInKSB7XHJcbiAgICAgICAgICAgIGRhdGEgPSB4aHIucmVzcG9uc2U7XHJcbiAgICAgICAgICAgIGxlbiA9IGRhdGEuYnl0ZUxlbmd0aDtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGRhdGEgPSB4aHIucmVzcG9uc2VUZXh0O1xyXG4gICAgICAgICAgICBsZW4gPSBkYXRhLmxlbmd0aDtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHN0YXRzLmxvYWRlZCA9IHN0YXRzLnRvdGFsID0gbGVuO1xyXG4gICAgICAgICAgbGV0IHJlc3BvbnNlID0geyB1cmwgOiB4aHIucmVzcG9uc2VVUkwsIGRhdGEgOiBkYXRhIH07XHJcbiAgICAgICAgICB0aGlzLmNhbGxiYWNrcy5vblN1Y2Nlc3MocmVzcG9uc2UsIHN0YXRzLCBjb250ZXh0LCB4aHIpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIGlmIG1heCBuYiBvZiByZXRyaWVzIHJlYWNoZWQgb3IgaWYgaHR0cCBzdGF0dXMgYmV0d2VlbiA0MDAgYW5kIDQ5OSAoc3VjaCBlcnJvciBjYW5ub3QgYmUgcmVjb3ZlcmVkLCByZXRyeWluZyBpcyB1c2VsZXNzKSwgcmV0dXJuIGVycm9yXHJcbiAgICAgICAgICBpZiAoc3RhdHMucmV0cnkgPj0gY29uZmlnLm1heFJldHJ5IHx8IChzdGF0dXMgPj0gNDAwICYmIHN0YXR1cyA8IDQ5OSkpIHtcclxuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGAke3N0YXR1c30gd2hpbGUgbG9hZGluZyAke2NvbnRleHQudXJsfWAgKTtcclxuICAgICAgICAgICAgdGhpcy5jYWxsYmFja3Mub25FcnJvcih7IGNvZGUgOiBzdGF0dXMsIHRleHQgOiB4aHIuc3RhdHVzVGV4dH0sIGNvbnRleHQsIHhocik7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyByZXRyeVxyXG4gICAgICAgICAgICBsb2dnZXIud2FybihgJHtzdGF0dXN9IHdoaWxlIGxvYWRpbmcgJHtjb250ZXh0LnVybH0sIHJldHJ5aW5nIGluICR7dGhpcy5yZXRyeURlbGF5fS4uLmApO1xyXG4gICAgICAgICAgICAvLyBhYm9ydHMgYW5kIHJlc2V0cyBpbnRlcm5hbCBzdGF0ZVxyXG4gICAgICAgICAgICB0aGlzLmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgLy8gc2NoZWR1bGUgcmV0cnlcclxuICAgICAgICAgICAgdGhpcy5yZXRyeVRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dCh0aGlzLmxvYWRJbnRlcm5hbC5iaW5kKHRoaXMpLCB0aGlzLnJldHJ5RGVsYXkpO1xyXG4gICAgICAgICAgICAvLyBzZXQgZXhwb25lbnRpYWwgYmFja29mZlxyXG4gICAgICAgICAgICB0aGlzLnJldHJ5RGVsYXkgPSBNYXRoLm1pbigyICogdGhpcy5yZXRyeURlbGF5LCBjb25maWcubWF4UmV0cnlEZWxheSk7XHJcbiAgICAgICAgICAgIHN0YXRzLnJldHJ5Kys7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIHJlYWR5U3RhdGUgPj0gMiBBTkQgcmVhZHlTdGF0ZSAhPT00IChyZWFkeVN0YXRlID0gSEVBREVSU19SRUNFSVZFRCB8fCBMT0FESU5HKSByZWFybSB0aW1lb3V0IGFzIHhociBub3QgZmluaXNoZWQgeWV0XHJcbiAgICAgICAgdGhpcy5yZXF1ZXN0VGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KHRoaXMubG9hZHRpbWVvdXQuYmluZCh0aGlzKSwgY29uZmlnLnRpbWVvdXQpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBsb2FkdGltZW91dCgpIHtcclxuICAgIGxvZ2dlci53YXJuKGB0aW1lb3V0IHdoaWxlIGxvYWRpbmcgJHt0aGlzLmNvbnRleHQudXJsfWAgKTtcclxuICAgIHRoaXMuY2FsbGJhY2tzLm9uVGltZW91dCh0aGlzLnN0YXRzLCB0aGlzLmNvbnRleHQsIG51bGwpO1xyXG4gIH1cclxuXHJcbiAgbG9hZHByb2dyZXNzKGV2ZW50KSB7XHJcbiAgICB2YXIgeGhyID0gZXZlbnQuY3VycmVudFRhcmdldCxcclxuICAgICAgICBzdGF0cyA9IHRoaXMuc3RhdHM7XHJcblxyXG4gICAgc3RhdHMubG9hZGVkID0gZXZlbnQubG9hZGVkO1xyXG4gICAgaWYgKGV2ZW50Lmxlbmd0aENvbXB1dGFibGUpIHtcclxuICAgICAgc3RhdHMudG90YWwgPSBldmVudC50b3RhbDtcclxuICAgIH1cclxuICAgIGxldCBvblByb2dyZXNzID0gdGhpcy5jYWxsYmFja3Mub25Qcm9ncmVzcztcclxuICAgIGlmIChvblByb2dyZXNzKSB7XHJcbiAgICAgIC8vIHRoaXJkIGFyZyBpcyB0byBwcm92aWRlIG9uIHByb2dyZXNzIGRhdGFcclxuICAgICAgb25Qcm9ncmVzcyhzdGF0cywgdGhpcy5jb250ZXh0LCBudWxsLCB4aHIpO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgWGhyTG9hZGVyO1xyXG4iXX0=
